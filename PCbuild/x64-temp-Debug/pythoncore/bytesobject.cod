; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@DKPNDJBA@bytes_iterator?$AA@		; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
PUBLIC	??_C@_05FBJAGGIG@bytes?$AA@			; `string'
PUBLIC	??_C@_09PAJHGGFL@__bytes__?$AA@			; `string'
PUBLIC	??_C@_06OEKOLKIL@source?$AA@			; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_05DMFNFMHA@zfill?$AA@			; `string'
PUBLIC	??_C@_05NECKJAMC@upper?$AA@			; `string'
PUBLIC	??_C@_09ODNGOEIO@translate?$AA@			; `string'
PUBLIC	??_C@_05PHLGJONK@title?$AA@			; `string'
PUBLIC	??_C@_08EDJLBCEI@swapcase?$AA@			; `string'
PUBLIC	??_C@_05GGNGIGHC@strip?$AA@			; `string'
PUBLIC	??_C@_0L@MPOGHCCL@startswith?$AA@		; `string'
PUBLIC	??_C@_0L@BCMGLLLC@splitlines?$AA@		; `string'
PUBLIC	??_C@_05EHPMMFBK@split?$AA@			; `string'
PUBLIC	??_C@_06DBIPDJKN@rstrip?$AA@			; `string'
PUBLIC	??_C@_06BAKFHKMF@rsplit?$AA@			; `string'
PUBLIC	??_C@_0L@KEEHLNKL@rpartition?$AA@		; `string'
PUBLIC	??_C@_05JKFAKHCP@rjust?$AA@			; `string'
PUBLIC	??_C@_06NCDOMFM@rindex?$AA@			; `string'
PUBLIC	??_C@_05BLFDIAHL@rfind?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_09IKAEIPAD@partition?$AA@			; `string'
PUBLIC	??_C@_09PBBLPCAA@maketrans?$AA@			; `string'
PUBLIC	??_C@_06GGONODO@lstrip?$AA@			; `string'
PUBLIC	??_C@_05IPJEPLHL@lower?$AA@			; `string'
PUBLIC	??_C@_05KDIMMEME@ljust?$AA@			; `string'
PUBLIC	??_C@_04DFGCDGNN@join?$AA@			; `string'
PUBLIC	??_C@_07BCOOJPCO@isupper?$AA@			; `string'
PUBLIC	??_C@_07DBHCJBDG@istitle?$AA@			; `string'
PUBLIC	??_C@_07CNBMLEON@isspace?$AA@			; `string'
PUBLIC	??_C@_07EJFAPEJH@islower?$AA@			; `string'
PUBLIC	??_C@_07CFBKIKCH@isdigit?$AA@			; `string'
PUBLIC	??_C@_07EGIOHHOB@isalpha?$AA@			; `string'
PUBLIC	??_C@_07EOADCIGC@isalnum?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_07DIMGGDAC@fromhex?$AA@			; `string'
PUBLIC	??_C@_04CKFJHKAP@find?$AA@			; `string'
PUBLIC	??_C@_0L@DEOCELBD@expandtabs?$AA@		; `string'
PUBLIC	??_C@_08MLCMCPNP@endswith?$AA@			; `string'
PUBLIC	??_C@_06KPNAMAEI@decode?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_06BBLOAEEI@center?$AA@			; `string'
PUBLIC	??_C@_0L@NMODNBEH@capitalize?$AA@		; `string'
PUBLIC	??_C@_0P@BCBHENLA@__getnewargs__?$AA@		; `string'
PUBLIC	??_C@_08EMIAAFLA@keepends?$AA@			; `string'
PUBLIC	??_C@_06EOMHCNPI@errors?$AA@			; `string'
PUBLIC	??_C@_08MLPGAEIK@encoding?$AA@			; `string'
PUBLIC	??_C@_08HONNCIIN@maxsplit?$AA@			; `string'
PUBLIC	??_C@_03MGBCFPKM@sep?$AA@			; `string'
PUBLIC	??_C@_08NLCECJOD@?$HMO?3strip?$AA@		; `string'
PUBLIC	??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@		; `string'
PUBLIC	??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@		; `string'
PUBLIC	PyBytes_Type
PUBLIC	PyBytesIter_Type
EXTRN	PyObject_SelfIter:PROC
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PyBaseObject_Type:BYTE
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
EXTRN	_Py_upper__doc__:BYTE
EXTRN	_Py_title__doc__:BYTE
EXTRN	_Py_swapcase__doc__:BYTE
EXTRN	_Py_maketrans__doc__:BYTE
EXTRN	_Py_lower__doc__:BYTE
EXTRN	_Py_isupper__doc__:BYTE
EXTRN	_Py_istitle__doc__:BYTE
EXTRN	_Py_isspace__doc__:BYTE
EXTRN	_Py_islower__doc__:BYTE
EXTRN	_Py_isdigit__doc__:BYTE
EXTRN	_Py_isalpha__doc__:BYTE
EXTRN	_Py_isalnum__doc__:BYTE
EXTRN	_Py_capitalize__doc__:BYTE
;	COMDAT ??_C@_0P@DKPNDJBA@bytes_iterator?$AA@
CONST	SEGMENT
??_C@_0P@DKPNDJBA@bytes_iterator?$AA@ DB 'bytes_iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FBJAGGIG@bytes?$AA@
CONST	SEGMENT
??_C@_05FBJAGGIG@bytes?$AA@ DB 'bytes', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___bytes__@?1??bytes_new@@9@9 DQ 0000000000000000H	; `bytes_new'::`2'::PyId___bytes__
	DQ	FLAT:??_C@_09PAJHGGFL@__bytes__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_09PAJHGGFL@__bytes__?$AA@
CONST	SEGMENT
??_C@_09PAJHGGFL@__bytes__?$AA@ DB '__bytes__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OEKOLKIL@source?$AA@
CONST	SEGMENT
??_C@_06OEKOLKIL@source?$AA@ DB 'source', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DMFNFMHA@zfill?$AA@
CONST	SEGMENT
??_C@_05DMFNFMHA@zfill?$AA@ DB 'zfill', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NECKJAMC@upper?$AA@
CONST	SEGMENT
??_C@_05NECKJAMC@upper?$AA@ DB 'upper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODNGOEIO@translate?$AA@
CONST	SEGMENT
??_C@_09ODNGOEIO@translate?$AA@ DB 'translate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHLGJONK@title?$AA@
CONST	SEGMENT
??_C@_05PHLGJONK@title?$AA@ DB 'title', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDJLBCEI@swapcase?$AA@
CONST	SEGMENT
??_C@_08EDJLBCEI@swapcase?$AA@ DB 'swapcase', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GGNGIGHC@strip?$AA@
CONST	SEGMENT
??_C@_05GGNGIGHC@strip?$AA@ DB 'strip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPOGHCCL@startswith?$AA@
CONST	SEGMENT
??_C@_0L@MPOGHCCL@startswith?$AA@ DB 'startswith', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCMGLLLC@splitlines?$AA@
CONST	SEGMENT
??_C@_0L@BCMGLLLC@splitlines?$AA@ DB 'splitlines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EHPMMFBK@split?$AA@
CONST	SEGMENT
??_C@_05EHPMMFBK@split?$AA@ DB 'split', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DBIPDJKN@rstrip?$AA@
CONST	SEGMENT
??_C@_06DBIPDJKN@rstrip?$AA@ DB 'rstrip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BAKFHKMF@rsplit?$AA@
CONST	SEGMENT
??_C@_06BAKFHKMF@rsplit?$AA@ DB 'rsplit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEEHLNKL@rpartition?$AA@
CONST	SEGMENT
??_C@_0L@KEEHLNKL@rpartition?$AA@ DB 'rpartition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKFAKHCP@rjust?$AA@
CONST	SEGMENT
??_C@_05JKFAKHCP@rjust?$AA@ DB 'rjust', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NCDOMFM@rindex?$AA@
CONST	SEGMENT
??_C@_06NCDOMFM@rindex?$AA@ DB 'rindex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLFDIAHL@rfind?$AA@
CONST	SEGMENT
??_C@_05BLFDIAHL@rfind?$AA@ DB 'rfind', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IKAEIPAD@partition?$AA@
CONST	SEGMENT
??_C@_09IKAEIPAD@partition?$AA@ DB 'partition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PBBLPCAA@maketrans?$AA@
CONST	SEGMENT
??_C@_09PBBLPCAA@maketrans?$AA@ DB 'maketrans', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGONODO@lstrip?$AA@
CONST	SEGMENT
??_C@_06GGONODO@lstrip?$AA@ DB 'lstrip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPJEPLHL@lower?$AA@
CONST	SEGMENT
??_C@_05IPJEPLHL@lower?$AA@ DB 'lower', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDIMMEME@ljust?$AA@
CONST	SEGMENT
??_C@_05KDIMMEME@ljust?$AA@ DB 'ljust', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DFGCDGNN@join?$AA@
CONST	SEGMENT
??_C@_04DFGCDGNN@join?$AA@ DB 'join', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCOOJPCO@isupper?$AA@
CONST	SEGMENT
??_C@_07BCOOJPCO@isupper?$AA@ DB 'isupper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBHCJBDG@istitle?$AA@
CONST	SEGMENT
??_C@_07DBHCJBDG@istitle?$AA@ DB 'istitle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNBMLEON@isspace?$AA@
CONST	SEGMENT
??_C@_07CNBMLEON@isspace?$AA@ DB 'isspace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EJFAPEJH@islower?$AA@
CONST	SEGMENT
??_C@_07EJFAPEJH@islower?$AA@ DB 'islower', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CFBKIKCH@isdigit?$AA@
CONST	SEGMENT
??_C@_07CFBKIKCH@isdigit?$AA@ DB 'isdigit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EGIOHHOB@isalpha?$AA@
CONST	SEGMENT
??_C@_07EGIOHHOB@isalpha?$AA@ DB 'isalpha', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOADCIGC@isalnum?$AA@
CONST	SEGMENT
??_C@_07EOADCIGC@isalnum?$AA@ DB 'isalnum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIMGGDAC@fromhex?$AA@
CONST	SEGMENT
??_C@_07DIMGGDAC@fromhex?$AA@ DB 'fromhex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CKFJHKAP@find?$AA@
CONST	SEGMENT
??_C@_04CKFJHKAP@find?$AA@ DB 'find', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DEOCELBD@expandtabs?$AA@
CONST	SEGMENT
??_C@_0L@DEOCELBD@expandtabs?$AA@ DB 'expandtabs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLCMCPNP@endswith?$AA@
CONST	SEGMENT
??_C@_08MLCMCPNP@endswith?$AA@ DB 'endswith', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KPNAMAEI@decode?$AA@
CONST	SEGMENT
??_C@_06KPNAMAEI@decode?$AA@ DB 'decode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BBLOAEEI@center?$AA@
CONST	SEGMENT
??_C@_06BBLOAEEI@center?$AA@ DB 'center', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMODNBEH@capitalize?$AA@
CONST	SEGMENT
??_C@_0L@NMODNBEH@capitalize?$AA@ DB 'capitalize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BCBHENLA@__getnewargs__?$AA@
CONST	SEGMENT
??_C@_0P@BCBHENLA@__getnewargs__?$AA@ DB '__getnewargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMIAAFLA@keepends?$AA@
CONST	SEGMENT
??_C@_08EMIAAFLA@keepends?$AA@ DB 'keepends', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOMHCNPI@errors?$AA@
CONST	SEGMENT
??_C@_06EOMHCNPI@errors?$AA@ DB 'errors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPGAEIK@encoding?$AA@
CONST	SEGMENT
??_C@_08MLPGAEIK@encoding?$AA@ DB 'encoding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HONNCIIN@maxsplit?$AA@
CONST	SEGMENT
??_C@_08HONNCIIN@maxsplit?$AA@ DB 'maxsplit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGBCFPKM@sep?$AA@
CONST	SEGMENT
??_C@_03MGBCFPKM@sep?$AA@ DB 'sep', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLCECJOD@?$HMO?3strip?$AA@
CONST	SEGMENT
??_C@_08NLCECJOD@?$HMO?3strip?$AA@ DB '|O:strip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@
CONST	SEGMENT
??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@ DB '|O:rstrip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@
CONST	SEGMENT
??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@ DB '|O:lstrip', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
expandtabs__doc__ DB 'B.expandtabs([tabsize]) -> copy of B', 0aH, 0aH, 'R'
	DB	'eturn a copy of B where all tab characters are expanded using'
	DB	' spaces.', 0aH, 'If tabsize is not given, a tab size of 8 cha'
	DB	'racters is assumed.', 00H
	ORG $+3
ljust__doc__ DB	'B.ljust(width[, fillchar]) -> copy of B', 0aH, 0aH, 'Ret'
	DB	'urn B left justified in a string of length width. Padding is', 0aH
	DB	'done using the specified fill character (default is a space).'
	DB	00H
	ORG $+9
rjust__doc__ DB	'B.rjust(width[, fillchar]) -> copy of B', 0aH, 0aH, 'Ret'
	DB	'urn B right justified in a string of length width. Padding is'
	DB	0aH, 'done using the specified fill character (default is a sp'
	DB	'ace)', 00H
	ORG $+9
center__doc__ DB 'B.center(width[, fillchar]) -> copy of B', 0aH, 0aH, 'R'
	DB	'eturn B centered in a string of length width.  Padding is', 0aH
	DB	'done using the specified fill character (default is a space).'
	DB	00H
	ORG $+13
zfill__doc__ DB	'B.zfill(width) -> copy of B', 0aH, 0aH, 'Pad a numeric s'
	DB	'tring B with zeros on the left, to fill a field', 0aH, 'of th'
	DB	'e specified width.  B is never truncated.', 00H
	ORG $+5
bytes_as_sequence DQ FLAT:bytes_length
	DQ	FLAT:bytes_concat
	DQ	FLAT:bytes_repeat
	DQ	FLAT:bytes_item
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytes_contains
	ORG $+16
bytes_as_mapping DQ FLAT:bytes_length
	DQ	FLAT:bytes_subscript
	DQ	0000000000000000H
bytes_as_buffer DQ FLAT:bytes_buffer_getbuffer
	DQ	0000000000000000H
stripformat DQ	FLAT:??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@
	DQ	FLAT:??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@
	DQ	FLAT:??_C@_08NLCECJOD@?$HMO?3strip?$AA@
split__doc__ DB	'B.split(sep=None, maxsplit=-1) -> list of bytes', 0aH, 0aH
	DB	'Return a list of the sections in B, using sep as the delimite'
	DB	'r.', 0aH, 'If sep is not specified or is None, B is split on '
	DB	'ASCII whitespace', 0aH, 'characters (space, tab, return, newl'
	DB	'ine, formfeed, vertical tab).', 0aH, 'If maxsplit is given, a'
	DB	't most maxsplit splits are done.', 00H
	ORG $+2
?kwlist@?1??bytes_split@@9@9 DQ FLAT:??_C@_03MGBCFPKM@sep?$AA@ ; `bytes_split'::`2'::kwlist
	DQ	FLAT:??_C@_08HONNCIIN@maxsplit?$AA@
	DQ	0000000000000000H
	ORG $+8
partition__doc__ DB 'B.partition(sep) -> (head, sep, tail)', 0aH, 0aH, 'S'
	DB	'earch for the separator sep in B, and return the part before '
	DB	'it,', 0aH, 'the separator itself, and the part after it.  If '
	DB	'the separator is not', 0aH, 'found, returns B and two empty b'
	DB	'ytes objects.', 00H
	ORG $+3
rpartition__doc__ DB 'B.rpartition(sep) -> (head, sep, tail)', 0aH, 0aH, 'S'
	DB	'earch for the separator sep in B, starting at the end of B,', 0aH
	DB	'and return the part before it, the separator itself, and the', 0aH
	DB	'part after it.  If the separator is not found, returns two em'
	DB	'pty', 0aH, 'bytes objects and B.', 00H
	ORG $+8
rsplit__doc__ DB 'B.rsplit(sep=None, maxsplit=-1) -> list of bytes', 0aH, 0aH
	DB	'Return a list of the sections in B, using sep as the delimite'
	DB	'r,', 0aH, 'starting at the end of B and working to the front.'
	DB	0aH, 'If sep is not given, B is split on ASCII whitespace char'
	DB	'acters', 0aH, '(space, tab, return, newline, formfeed, vertic'
	DB	'al tab).', 0aH, 'If maxsplit is given, at most maxsplit split'
	DB	's are done.', 00H
	ORG $+5
?kwlist@?1??bytes_rsplit@@9@9 DQ FLAT:??_C@_03MGBCFPKM@sep?$AA@ ; `bytes_rsplit'::`2'::kwlist
	DQ	FLAT:??_C@_08HONNCIIN@maxsplit?$AA@
	DQ	0000000000000000H
join__doc__ DB	'B.join(iterable_of_bytes) -> bytes', 0aH, 0aH, 'Concaten'
	DB	'ate any number of bytes objects, with B in between each pair.'
	DB	0aH, 'Example: b''.''.join([b''ab'', b''pq'', b''rs'']) -> b'''
	DB	'ab.pq.rs''.', 00H
	ORG $+12
find__doc__ DB	'B.find(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return t'
	DB	'he lowest index in B where substring sub is found,', 0aH, 'su'
	DB	'ch that sub is contained within B[start:end].  Optional', 0aH
	DB	'arguments start and end are interpreted as in slice notation.'
	DB	0aH, 0aH, 'Return -1 on failure.', 00H
	ORG $+2
index__doc__ DB	'B.index(sub[, start[, end]]) -> int', 0aH, 0aH, 'Like B.'
	DB	'find() but raise ValueError when the substring is not found.', 00H
	ORG $+7
rfind__doc__ DB	'B.rfind(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return '
	DB	'the highest index in B where substring sub is found,', 0aH, 's'
	DB	'uch that sub is contained within B[start:end].  Optional', 0aH
	DB	'arguments start and end are interpreted as in slice notation.'
	DB	0aH, 0aH, 'Return -1 on failure.', 00H
rindex__doc__ DB 'B.rindex(sub[, start[, end]]) -> int', 0aH, 0aH, 'Like '
	DB	'B.rfind() but raise ValueError when the substring is not foun'
	DB	'd.', 00H
	ORG $+5
strip__doc__ DB	'B.strip([bytes]) -> bytes', 0aH, 0aH, 'Strip leading and'
	DB	' trailing bytes contained in the argument.', 0aH, 'If the arg'
	DB	'ument is omitted, strip leading and trailing ASCII whitespace'
	DB	'.', 00H
lstrip__doc__ DB 'B.lstrip([bytes]) -> bytes', 0aH, 0aH, 'Strip leading b'
	DB	'ytes contained in the argument.', 0aH, 'If the argument is om'
	DB	'itted, strip leading ASCII whitespace.', 00H
	ORG $+9
rstrip__doc__ DB 'B.rstrip([bytes]) -> bytes', 0aH, 0aH, 'Strip trailing '
	DB	'bytes contained in the argument.', 0aH, 'If the argument is o'
	DB	'mitted, strip trailing ASCII whitespace.', 00H
	ORG $+7
count__doc__ DB	'B.count(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return '
	DB	'the number of non-overlapping occurrences of substring sub in'
	DB	0aH, 'string B[start:end].  Optional arguments start and end a'
	DB	're interpreted', 0aH, 'as in slice notation.', 00H
	ORG $+9
translate__doc__ DB 'B.translate(table[, deletechars]) -> bytes', 0aH, 0aH
	DB	'Return a copy of B, where all characters occurring in the', 0aH
	DB	'optional argument deletechars are removed, and the remaining', 0aH
	DB	'characters have been mapped through the given translation', 0aH
	DB	'table, which must be a bytes object of length 256.', 00H
replace__doc__ DB 'B.replace(old, new[, count]) -> bytes', 0aH, 0aH, 'Ret'
	DB	'urn a copy of B with all occurrences of subsection', 0aH, 'ol'
	DB	'd replaced by new.  If the optional argument count is', 0aH, 'g'
	DB	'iven, only first count occurances are replaced.', 00H
	ORG $+10
startswith__doc__ DB 'B.startswith(prefix[, start[, end]]) -> bool', 0aH, 0aH
	DB	'Return True if B starts with the specified prefix, False othe'
	DB	'rwise.', 0aH, 'With optional start, test B beginning at that '
	DB	'position.', 0aH, 'With optional end, stop comparing B at that'
	DB	' position.', 0aH, 'prefix can also be a tuple of bytes to try'
	DB	'.', 00H
	ORG $+4
endswith__doc__ DB 'B.endswith(suffix[, start[, end]]) -> bool', 0aH, 0aH
	DB	'Return True if B ends with the specified suffix, False otherw'
	DB	'ise.', 0aH, 'With optional start, test B beginning at that po'
	DB	'sition.', 0aH, 'With optional end, stop comparing B at that p'
	DB	'osition.', 0aH, 'suffix can also be a tuple of bytes to try.', 00H
	ORG $+8
decode__doc__ DB 'B.decode(encoding=''utf-8'', errors=''strict'') -> str', 0aH
	DB	0aH, 'Decode B using the codec registered for encoding. Defaul'
	DB	't encoding', 0aH, 'is ''utf-8''. errors may be given to set a'
	DB	' different error', 0aH, 'handling scheme.  Default is ''stric'
	DB	't'' meaning that encoding errors raise', 0aH, 'a UnicodeDecod'
	DB	'eError.  Other possible values are ''ignore'' and ''replace'''
	DB	0aH, 'as well as any other name registerd with codecs.register'
	DB	'_error that is', 0aH, 'able to handle UnicodeDecodeErrors.', 00H
	ORG $+4
?kwlist@?1??bytes_decode@@9@9 DQ FLAT:??_C@_08MLPGAEIK@encoding?$AA@ ; `bytes_decode'::`2'::kwlist
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
	ORG $+8
splitlines__doc__ DB 'B.splitlines([keepends]) -> list of lines', 0aH, 0aH
	DB	'Return a list of the lines in B, breaking at line boundaries.'
	DB	0aH, 'Line breaks are not included in the resulting list unles'
	DB	's keepends', 0aH, 'is given and true.', 00H
	ORG $+1
?kwlist@?1??bytes_splitlines@@9@9 DQ FLAT:??_C@_08EMIAAFLA@keepends?$AA@ ; `bytes_splitlines'::`2'::kwlist
	DQ	0000000000000000H
fromhex_doc DB	'bytes.fromhex(string) -> bytes', 0aH, 0aH, 'Create a byt'
	DB	'es object from a string of hexadecimal numbers.', 0aH, 'Space'
	DB	's between two numbers are accepted.', 0aH, 'Example: bytes.fr'
	DB	'omhex(''B9 01EF'') -> b''\xb9\x01\xef''.', 00H
	ORG $+5
sizeof__doc__ DB 'B.__sizeof__() -> size of B in memory, in bytes', 00H
bytes_methods DQ FLAT:??_C@_0P@BCBHENLA@__getnewargs__?$AA@
	DQ	FLAT:bytes_getnewargs
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@NMODNBEH@capitalize?$AA@
	DQ	FLAT:stringlib_capitalize
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_capitalize__doc__
	DQ	FLAT:??_C@_06BBLOAEEI@center?$AA@
	DQ	FLAT:stringlib_center
	DD	01H
	ORG $+4
	DQ	FLAT:center__doc__
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	FLAT:bytes_count
	DD	01H
	ORG $+4
	DQ	FLAT:count__doc__
	DQ	FLAT:??_C@_06KPNAMAEI@decode?$AA@
	DQ	FLAT:bytes_decode
	DD	03H
	ORG $+4
	DQ	FLAT:decode__doc__
	DQ	FLAT:??_C@_08MLCMCPNP@endswith?$AA@
	DQ	FLAT:bytes_endswith
	DD	01H
	ORG $+4
	DQ	FLAT:endswith__doc__
	DQ	FLAT:??_C@_0L@DEOCELBD@expandtabs?$AA@
	DQ	FLAT:stringlib_expandtabs
	DD	01H
	ORG $+4
	DQ	FLAT:expandtabs__doc__
	DQ	FLAT:??_C@_04CKFJHKAP@find?$AA@
	DQ	FLAT:bytes_find
	DD	01H
	ORG $+4
	DQ	FLAT:find__doc__
	DQ	FLAT:??_C@_07DIMGGDAC@fromhex?$AA@
	DQ	FLAT:bytes_fromhex
	DD	011H
	ORG $+4
	DQ	FLAT:fromhex_doc
	DQ	FLAT:??_C@_05FKHKFDID@index?$AA@
	DQ	FLAT:bytes_index
	DD	01H
	ORG $+4
	DQ	FLAT:index__doc__
	DQ	FLAT:??_C@_07EOADCIGC@isalnum?$AA@
	DQ	FLAT:stringlib_isalnum
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isalnum__doc__
	DQ	FLAT:??_C@_07EGIOHHOB@isalpha?$AA@
	DQ	FLAT:stringlib_isalpha
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isalpha__doc__
	DQ	FLAT:??_C@_07CFBKIKCH@isdigit?$AA@
	DQ	FLAT:stringlib_isdigit
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isdigit__doc__
	DQ	FLAT:??_C@_07EJFAPEJH@islower?$AA@
	DQ	FLAT:stringlib_islower
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_islower__doc__
	DQ	FLAT:??_C@_07CNBMLEON@isspace?$AA@
	DQ	FLAT:stringlib_isspace
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isspace__doc__
	DQ	FLAT:??_C@_07DBHCJBDG@istitle?$AA@
	DQ	FLAT:stringlib_istitle
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_istitle__doc__
	DQ	FLAT:??_C@_07BCOOJPCO@isupper?$AA@
	DQ	FLAT:stringlib_isupper
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isupper__doc__
	DQ	FLAT:??_C@_04DFGCDGNN@join?$AA@
	DQ	FLAT:bytes_join
	DD	08H
	ORG $+4
	DQ	FLAT:join__doc__
	DQ	FLAT:??_C@_05KDIMMEME@ljust?$AA@
	DQ	FLAT:stringlib_ljust
	DD	01H
	ORG $+4
	DQ	FLAT:ljust__doc__
	DQ	FLAT:??_C@_05IPJEPLHL@lower?$AA@
	DQ	FLAT:stringlib_lower
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_lower__doc__
	DQ	FLAT:??_C@_06GGONODO@lstrip?$AA@
	DQ	FLAT:bytes_lstrip
	DD	01H
	ORG $+4
	DQ	FLAT:lstrip__doc__
	DQ	FLAT:??_C@_09PBBLPCAA@maketrans?$AA@
	DQ	FLAT:bytes_maketrans
	DD	021H
	ORG $+4
	DQ	FLAT:_Py_maketrans__doc__
	DQ	FLAT:??_C@_09IKAEIPAD@partition?$AA@
	DQ	FLAT:bytes_partition
	DD	08H
	ORG $+4
	DQ	FLAT:partition__doc__
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:bytes_replace
	DD	01H
	ORG $+4
	DQ	FLAT:replace__doc__
	DQ	FLAT:??_C@_05BLFDIAHL@rfind?$AA@
	DQ	FLAT:bytes_rfind
	DD	01H
	ORG $+4
	DQ	FLAT:rfind__doc__
	DQ	FLAT:??_C@_06NCDOMFM@rindex?$AA@
	DQ	FLAT:bytes_rindex
	DD	01H
	ORG $+4
	DQ	FLAT:rindex__doc__
	DQ	FLAT:??_C@_05JKFAKHCP@rjust?$AA@
	DQ	FLAT:stringlib_rjust
	DD	01H
	ORG $+4
	DQ	FLAT:rjust__doc__
	DQ	FLAT:??_C@_0L@KEEHLNKL@rpartition?$AA@
	DQ	FLAT:bytes_rpartition
	DD	08H
	ORG $+4
	DQ	FLAT:rpartition__doc__
	DQ	FLAT:??_C@_06BAKFHKMF@rsplit?$AA@
	DQ	FLAT:bytes_rsplit
	DD	03H
	ORG $+4
	DQ	FLAT:rsplit__doc__
	DQ	FLAT:??_C@_06DBIPDJKN@rstrip?$AA@
	DQ	FLAT:bytes_rstrip
	DD	01H
	ORG $+4
	DQ	FLAT:rstrip__doc__
	DQ	FLAT:??_C@_05EHPMMFBK@split?$AA@
	DQ	FLAT:bytes_split
	DD	03H
	ORG $+4
	DQ	FLAT:split__doc__
	DQ	FLAT:??_C@_0L@BCMGLLLC@splitlines?$AA@
	DQ	FLAT:bytes_splitlines
	DD	03H
	ORG $+4
	DQ	FLAT:splitlines__doc__
	DQ	FLAT:??_C@_0L@MPOGHCCL@startswith?$AA@
	DQ	FLAT:bytes_startswith
	DD	01H
	ORG $+4
	DQ	FLAT:startswith__doc__
	DQ	FLAT:??_C@_05GGNGIGHC@strip?$AA@
	DQ	FLAT:bytes_strip
	DD	01H
	ORG $+4
	DQ	FLAT:strip__doc__
	DQ	FLAT:??_C@_08EDJLBCEI@swapcase?$AA@
	DQ	FLAT:stringlib_swapcase
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_swapcase__doc__
	DQ	FLAT:??_C@_05PHLGJONK@title?$AA@
	DQ	FLAT:stringlib_title
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_title__doc__
	DQ	FLAT:??_C@_09ODNGOEIO@translate?$AA@
	DQ	FLAT:bytes_translate
	DD	01H
	ORG $+4
	DQ	FLAT:translate__doc__
	DQ	FLAT:??_C@_05NECKJAMC@upper?$AA@
	DQ	FLAT:stringlib_upper
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_upper__doc__
	DQ	FLAT:??_C@_05DMFNFMHA@zfill?$AA@
	DQ	FLAT:stringlib_zfill
	DD	01H
	ORG $+4
	DQ	FLAT:zfill__doc__
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:bytes_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
?kwlist@?1??bytes_new@@9@9 DQ FLAT:??_C@_06OEKOLKIL@source?$AA@ ; `bytes_new'::`2'::kwlist
	DQ	FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
bytes_doc DB	'bytes(iterable_of_ints) -> bytes', 0aH, 'bytes(string, e'
	DB	'ncoding[, errors]) -> bytes', 0aH, 'bytes(bytes_or_buffer) ->'
	DB	' immutable copy of bytes_or_buffer', 0aH, 'bytes(int) -> byte'
	DB	's object of size given by the parameter initialized with null'
	DB	' bytes', 0aH, 'bytes() -> empty bytes object', 0aH, 0aH, 'Con'
	DB	'struct an immutable array of bytes from:', 0aH, '  - an itera'
	DB	'ble yielding integers in range(256)', 0aH, '  - a text string'
	DB	' encoded using the specified encoding', 0aH, '  - any object '
	DB	'implementing the buffer API.', 0aH, '  - an integer', 00H
	ORG $+5
PyBytes_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_05FBJAGGIG@bytes?$AA@
	DQ	0000000000000079H
	DQ	0000000000000001H
	DQ	FLAT:bytes_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytes_repr
	DQ	0000000000000000H
	DQ	FLAT:bytes_as_sequence
	DQ	FLAT:bytes_as_mapping
	DQ	FLAT:bytes_hash
	DQ	0000000000000000H
	DQ	FLAT:bytes_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	FLAT:bytes_as_buffer
	DD	08040400H
	ORG $+4
	DQ	FLAT:bytes_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytes_richcompare
	DQ	0000000000000000H
	DQ	FLAT:bytes_iter
	DQ	0000000000000000H
	DQ	FLAT:bytes_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyBaseObject_Type
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytes_new
	DQ	FLAT:_PyObject_DebugFree
	ORG $+64
length_hint_doc DB 'Private method returning an estimate of len(list(it))'
	DB	'.', 00H
	ORG $+1
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+1
setstate_doc DB	'Set state information for unpickling.', 00H
	ORG $+10
striter_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:striter_len
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:striter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:striter_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyBytesIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0P@DKPNDJBA@bytes_iterator?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:striter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:striter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:striter_next
	DQ	FLAT:striter_methods
	DQ	0000000000000000H
	ORG $+144
_DATA	ENDS
PUBLIC	??_C@_0BJ@GKFHPJMO@byte?5string?5is?5too?5large?$AA@ ; `string'
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0DC@LEOKNIFE@Negative?5size?5passed?5to?5PyBytes_@ ; `string'
PUBLIC	PyBytes_FromStringAndSize
EXTRN	_Py_PXCTX:PROC
EXTRN	memcpy:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyObject_DebugMalloc:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_SystemError:QWORD
_BSS	SEGMENT
characters DQ	0100H DUP (?)
nullstring DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$PyBytes_FromStringAndSize DD imagerel $LN21
	DD	imagerel $LN21+580
	DD	imagerel $unwind$PyBytes_FromStringAndSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_FromStringAndSize DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BJ@GKFHPJMO@byte?5string?5is?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BJ@GKFHPJMO@byte?5string?5is?5too?5large?$AA@ DB 'byte string is t'
	DB	'oo large', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LEOKNIFE@Negative?5size?5passed?5to?5PyBytes_@
CONST	SEGMENT
??_C@_0DC@LEOKNIFE@Negative?5size?5passed?5to?5PyBytes_@ DB 'Negative siz'
	DB	'e passed to PyBytes_FromStringAndSize', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBytes_FromStringAndSize
_TEXT	SEGMENT
op$ = 32
t_$20438 = 40
s_$20440 = 48
i_$20436 = 56
n_$20437 = 64
str$ = 96
size$ = 104
PyBytes_FromStringAndSize PROC				; COMDAT

; 67   : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 68   :     register PyBytesObject *op;
; 69   :     if (size < 0) {

  0000e	48 83 7c 24 68
	00		 cmp	 QWORD PTR size$[rsp], 0
  00014	7d 1a		 jge	 SHORT $LN18@PyBytes_Fr

; 70   :         PyErr_SetString(PyExc_SystemError,
; 71   :             "Negative size passed to PyBytes_FromStringAndSize");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LEOKNIFE@Negative?5size?5passed?5to?5PyBytes_@
  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00024	e8 00 00 00 00	 call	 PyErr_SetString

; 72   :         return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	e9 0f 02 00 00	 jmp	 $LN19@PyBytes_Fr
$LN18@PyBytes_Fr:

; 73   :     }
; 74   :     if (size == 0 && (op = nullstring) != NULL) {

  00030	48 83 7c 24 68
	00		 cmp	 QWORD PTR size$[rsp], 0
  00036	75 28		 jne	 SHORT $LN17@PyBytes_Fr
  00038	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR nullstring
  0003f	48 89 44 24 20	 mov	 QWORD PTR op$[rsp], rax
  00044	48 83 7c 24 20
	00		 cmp	 QWORD PTR op$[rsp], 0
  0004a	74 14		 je	 SHORT $LN17@PyBytes_Fr

; 75   : #ifdef COUNT_ALLOCS
; 76   :         null_strings++;
; 77   : #endif
; 78   :         Py_INCREF(op);

  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  00051	e8 00 00 00 00	 call	 _Py_IncRef

; 79   :         return (PyObject *)op;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  0005b	e9 df 01 00 00	 jmp	 $LN19@PyBytes_Fr
$LN17@PyBytes_Fr:

; 80   :     }
; 81   :     if (size == 1 && str != NULL &&
; 82   :         (op = characters[*str & UCHAR_MAX]) != NULL)

  00060	48 83 7c 24 68
	01		 cmp	 QWORD PTR size$[rsp], 1
  00066	75 43		 jne	 SHORT $LN16@PyBytes_Fr
  00068	48 83 7c 24 60
	00		 cmp	 QWORD PTR str$[rsp], 0
  0006e	74 3b		 je	 SHORT $LN16@PyBytes_Fr
  00070	48 8b 44 24 60	 mov	 rax, QWORD PTR str$[rsp]
  00075	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00078	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007d	48 98		 cdqe
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:characters
  00086	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0008a	48 89 44 24 20	 mov	 QWORD PTR op$[rsp], rax
  0008f	48 83 7c 24 20
	00		 cmp	 QWORD PTR op$[rsp], 0
  00095	74 14		 je	 SHORT $LN16@PyBytes_Fr

; 83   :     {
; 84   : #ifdef COUNT_ALLOCS
; 85   :         one_strings++;
; 86   : #endif
; 87   :         Py_INCREF(op);

  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  0009c	e8 00 00 00 00	 call	 _Py_IncRef

; 88   :         return (PyObject *)op;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  000a6	e9 94 01 00 00	 jmp	 $LN19@PyBytes_Fr
$LN16@PyBytes_Fr:

; 89   :     }
; 90   : 
; 91   :     if (size > PY_SSIZE_T_MAX - PyBytesObject_SIZE) {

  000ab	48 b8 86 ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775686 ; 7fffffffffffff86H
  000b5	48 39 44 24 68	 cmp	 QWORD PTR size$[rsp], rax
  000ba	76 1a		 jbe	 SHORT $LN15@PyBytes_Fr

; 92   :         PyErr_SetString(PyExc_OverflowError,
; 93   :                         "byte string is too large");

  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GKFHPJMO@byte?5string?5is?5too?5large?$AA@
  000c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000ca	e8 00 00 00 00	 call	 PyErr_SetString

; 94   :         return NULL;

  000cf	33 c0		 xor	 eax, eax
  000d1	e9 69 01 00 00	 jmp	 $LN19@PyBytes_Fr
$LN15@PyBytes_Fr:

; 95   :     }
; 96   : 
; 97   :     /* Inline PyObject_NewVar */
; 98   :     op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + size);

  000d6	48 8b 44 24 68	 mov	 rax, QWORD PTR size$[rsp]
  000db	48 83 c0 79	 add	 rax, 121		; 00000079H
  000df	48 8b c8	 mov	 rcx, rax
  000e2	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  000e7	48 89 44 24 20	 mov	 QWORD PTR op$[rsp], rax

; 99   :     if (op == NULL)

  000ec	48 83 7c 24 20
	00		 cmp	 QWORD PTR op$[rsp], 0
  000f2	75 0a		 jne	 SHORT $LN14@PyBytes_Fr

; 100  :         return PyErr_NoMemory();

  000f4	e8 00 00 00 00	 call	 PyErr_NoMemory
  000f9	e9 41 01 00 00	 jmp	 $LN19@PyBytes_Fr
$LN14@PyBytes_Fr:

; 101  :     PyObject_INIT_VAR((PyVarObject *)op, &PyBytes_Type, size);

  000fe	4c 8b 44 24 68	 mov	 r8, QWORD PTR size$[rsp]
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyBytes_Type
  0010a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  0010f	e8 00 00 00 00	 call	 PyObject_INIT_VAR

; 102  :     op->ob_shash = -1;

  00114	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  00119	48 c7 40 70 ff
	ff ff ff	 mov	 QWORD PTR [rax+112], -1

; 103  :     if (str != NULL)

  00121	48 83 7c 24 60
	00		 cmp	 QWORD PTR str$[rsp], 0
  00127	0f 84 95 00 00
	00		 je	 $LN13@PyBytes_Fr
$LN12@PyBytes_Fr:

; 104  :         Py_MEMCPY(op->ob_sval, str, size);

  0012d	48 8b 44 24 68	 mov	 rax, QWORD PTR size$[rsp]
  00132	48 89 44 24 40	 mov	 QWORD PTR n_$20437[rsp], rax
  00137	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  0013c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00140	48 89 44 24 28	 mov	 QWORD PTR t_$20438[rsp], rax
  00145	48 8b 44 24 60	 mov	 rax, QWORD PTR str$[rsp]
  0014a	48 89 44 24 30	 mov	 QWORD PTR s_$20440[rsp], rax
  0014f	48 83 7c 24 40
	10		 cmp	 QWORD PTR n_$20437[rsp], 16
  00155	72 16		 jb	 SHORT $LN9@PyBytes_Fr
  00157	4c 8b 44 24 40	 mov	 r8, QWORD PTR n_$20437[rsp]
  0015c	48 8b 54 24 30	 mov	 rdx, QWORD PTR s_$20440[rsp]
  00161	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t_$20438[rsp]
  00166	e8 00 00 00 00	 call	 memcpy
  0016b	eb 4b		 jmp	 SHORT $LN8@PyBytes_Fr
$LN9@PyBytes_Fr:
  0016d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i_$20436[rsp], 0
  00176	eb 0d		 jmp	 SHORT $LN7@PyBytes_Fr
$LN6@PyBytes_Fr:
  00178	48 8b 44 24 38	 mov	 rax, QWORD PTR i_$20436[rsp]
  0017d	48 ff c0	 inc	 rax
  00180	48 89 44 24 38	 mov	 QWORD PTR i_$20436[rsp], rax
$LN7@PyBytes_Fr:
  00185	48 8b 44 24 40	 mov	 rax, QWORD PTR n_$20437[rsp]
  0018a	48 39 44 24 38	 cmp	 QWORD PTR i_$20436[rsp], rax
  0018f	73 27		 jae	 SHORT $LN5@PyBytes_Fr
  00191	48 8b 44 24 38	 mov	 rax, QWORD PTR i_$20436[rsp]
  00196	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t_$20438[rsp]
  0019b	48 03 c8	 add	 rcx, rax
  0019e	48 8b c1	 mov	 rax, rcx
  001a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i_$20436[rsp]
  001a6	48 8b 54 24 30	 mov	 rdx, QWORD PTR s_$20440[rsp]
  001ab	48 03 d1	 add	 rdx, rcx
  001ae	48 8b ca	 mov	 rcx, rdx
  001b1	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001b4	88 08		 mov	 BYTE PTR [rax], cl
  001b6	eb c0		 jmp	 SHORT $LN6@PyBytes_Fr
$LN5@PyBytes_Fr:
$LN8@PyBytes_Fr:
  001b8	33 c0		 xor	 eax, eax
  001ba	85 c0		 test	 eax, eax
  001bc	0f 85 6b ff ff
	ff		 jne	 $LN12@PyBytes_Fr
$LN13@PyBytes_Fr:

; 105  :     op->ob_sval[size] = '\0';

  001c2	48 8b 44 24 68	 mov	 rax, QWORD PTR size$[rsp]
  001c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  001cc	48 03 c8	 add	 rcx, rax
  001cf	48 8b c1	 mov	 rax, rcx
  001d2	c6 40 78 00	 mov	 BYTE PTR [rax+120], 0

; 106  : 
; 107  :     if (Py_PXCTX)

  001d6	e8 00 00 00 00	 call	 _Py_PXCTX
  001db	85 c0		 test	 eax, eax
  001dd	74 02		 je	 SHORT $LN4@PyBytes_Fr

; 108  :         goto end;

  001df	eb 59		 jmp	 SHORT $end$20448
$LN4@PyBytes_Fr:

; 109  : 
; 110  :     /* share short strings */
; 111  :     if (size == 0) {

  001e1	48 83 7c 24 68
	00		 cmp	 QWORD PTR size$[rsp], 0
  001e7	75 18		 jne	 SHORT $LN3@PyBytes_Fr

; 112  :         nullstring = op;

  001e9	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  001ee	48 89 05 00 00
	00 00		 mov	 QWORD PTR nullstring, rax

; 113  :         Py_INCREF(op);

  001f5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  001fa	e8 00 00 00 00	 call	 _Py_IncRef
  001ff	eb 39		 jmp	 SHORT $LN2@PyBytes_Fr
$LN3@PyBytes_Fr:

; 114  :     } else if (size == 1 && str != NULL) {

  00201	48 83 7c 24 68
	01		 cmp	 QWORD PTR size$[rsp], 1
  00207	75 31		 jne	 SHORT $LN1@PyBytes_Fr
  00209	48 83 7c 24 60
	00		 cmp	 QWORD PTR str$[rsp], 0
  0020f	74 29		 je	 SHORT $LN1@PyBytes_Fr

; 115  :         characters[*str & UCHAR_MAX] = op;

  00211	48 8b 44 24 60	 mov	 rax, QWORD PTR str$[rsp]
  00216	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00219	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0021e	48 98		 cdqe
  00220	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:characters
  00227	48 8b 54 24 20	 mov	 rdx, QWORD PTR op$[rsp]
  0022c	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 116  :         Py_INCREF(op);

  00230	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  00235	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@PyBytes_Fr:
$LN2@PyBytes_Fr:
$end$20448:

; 117  :     }
; 118  : end:
; 119  :     return (PyObject *) op;

  0023a	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
$LN19@PyBytes_Fr:

; 120  : }

  0023f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00243	c3		 ret	 0
PyBytes_FromStringAndSize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
EXTRN	_Py_NewReference:PROC
EXTRN	_PxObject_InitVar:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$PyObject_INIT_VAR DD imagerel PyObject_INIT_VAR
	DD	imagerel PyObject_INIT_VAR+108
	DD	imagerel $unwind$PyObject_INIT_VAR
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT_VAR DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_INIT_VAR
_TEXT	SEGMENT
op$ = 48
tp$ = 56
n$ = 64
PyObject_INIT_VAR PROC					; COMDAT

; 247  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 248  :     Px_RETURN(_PxObject_InitVar(op, tp, n))

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 16		 je	 SHORT $LN1@PyObject_I
  0001c	4c 8b 44 24 40	 mov	 r8, QWORD PTR n$[rsp]
  00021	48 8b 54 24 38	 mov	 rdx, QWORD PTR tp$[rsp]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0002b	e8 00 00 00 00	 call	 _PxObject_InitVar
  00030	eb 35		 jmp	 SHORT $LN2@PyObject_I
$LN1@PyObject_I:

; 249  :     Py_SIZE(op) = n;

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  0003c	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 250  :     Py_TYPE(op) = tp;

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00045	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tp$[rsp]
  0004a	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 251  :     _PyObject_InitHead((PyObject *)op);

  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00053	e8 00 00 00 00	 call	 _PyObject_InitHead

; 252  :     _Py_NewReference((PyObject *)op);

  00058	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0005d	e8 00 00 00 00	 call	 _Py_NewReference

; 253  :     return op;

  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
$LN2@PyObject_I:

; 254  : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
PyObject_INIT_VAR ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_InitHead DD imagerel _PyObject_InitHead
	DD	imagerel _PyObject_InitHead+182
	DD	imagerel $unwind$_PyObject_InitHead
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_InitHead DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H
	DB	'(', 00H, 'o', 00H, 'p', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@
CONST	SEGMENT
??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 48
_PyObject_InitHead PROC					; COMDAT

; 215  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 216  :     assert(Py_TYPE(op));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0000e	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  00013	75 1c		 jne	 SHORT $LN3@PyObject_I@2
  00015	41 b8 d8 00 00
	00		 mov	 r8d, 216		; 000000d8H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	33 c0		 xor	 eax, eax
$LN3@PyObject_I@2:

; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00036	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx

; 218  :     op->px    = _Py_NOT_PARALLEL;

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00048	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00052	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 219  :     op->slist_entry.Next = NULL;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0005b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00068	48 c7 40 20 01
	00 00 00	 mov	 QWORD PTR [rax+32], 1

; 221  :     op->srw_lock  = NULL;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00075	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 222  :     op->event     = NULL;

  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 223  :     op->orig_type = NULL;

  0008a	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0008f	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;

  00097	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0009c	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 226  :     op->_ob_prev = NULL;

  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  000a9	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;
; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;
; 230  : #endif
; 231  : }

  000b1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b5	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@CPOCIEOB@byte?5string?5is?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_1BI@MFCLPIBM@?$AAs?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	PyBytes_FromString
EXTRN	strlen:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$PyBytes_FromString DD imagerel $LN20
	DD	imagerel $LN20+547
	DD	imagerel $unwind$PyBytes_FromString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_FromString DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0BI@CPOCIEOB@byte?5string?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BI@CPOCIEOB@byte?5string?5is?5too?5long?$AA@ DB 'byte string is to'
	DB	'o long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@MFCLPIBM@?$AAs?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@MFCLPIBM@?$AAs?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'b', 00H, 'y', 00H, 't'
	DB	00H, 'e', 00H, 's', 00H, 'o', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBytes_FromString
_TEXT	SEGMENT
size$ = 32
op$ = 40
t_$20493 = 48
s_$20495 = 56
i_$20491 = 64
n_$20492 = 72
str$ = 96
PyBytes_FromString PROC					; COMDAT

; 124  : {

$LN20:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 125  :     register size_t size;
; 126  :     register PyBytesObject *op;
; 127  : 
; 128  :     assert(str != NULL);

  00009	48 83 7c 24 60
	00		 cmp	 QWORD PTR str$[rsp], 0
  0000f	75 1c		 jne	 SHORT $LN19@PyBytes_Fr@2
  00011	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@MFCLPIBM@?$AAs?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002b	33 c0		 xor	 eax, eax
$LN19@PyBytes_Fr@2:

; 129  :     size = strlen(str);

  0002d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str$[rsp]
  00032	e8 00 00 00 00	 call	 strlen
  00037	48 89 44 24 20	 mov	 QWORD PTR size$[rsp], rax

; 130  :     if (size > PY_SSIZE_T_MAX - PyBytesObject_SIZE) {

  0003c	48 b8 86 ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775686 ; 7fffffffffffff86H
  00046	48 39 44 24 20	 cmp	 QWORD PTR size$[rsp], rax
  0004b	76 1a		 jbe	 SHORT $LN16@PyBytes_Fr@2

; 131  :         PyErr_SetString(PyExc_OverflowError,
; 132  :             "byte string is too long");

  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@CPOCIEOB@byte?5string?5is?5too?5long?$AA@
  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0005b	e8 00 00 00 00	 call	 PyErr_SetString

; 133  :         return NULL;

  00060	33 c0		 xor	 eax, eax
  00062	e9 b7 01 00 00	 jmp	 $LN17@PyBytes_Fr@2
$LN16@PyBytes_Fr@2:

; 134  :     }
; 135  :     if (size == 0 && (op = nullstring) != NULL) {

  00067	48 83 7c 24 20
	00		 cmp	 QWORD PTR size$[rsp], 0
  0006d	75 28		 jne	 SHORT $LN15@PyBytes_Fr@2
  0006f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR nullstring
  00076	48 89 44 24 28	 mov	 QWORD PTR op$[rsp], rax
  0007b	48 83 7c 24 28
	00		 cmp	 QWORD PTR op$[rsp], 0
  00081	74 14		 je	 SHORT $LN15@PyBytes_Fr@2

; 136  : #ifdef COUNT_ALLOCS
; 137  :         null_strings++;
; 138  : #endif
; 139  :         Py_INCREF(op);

  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op$[rsp]
  00088	e8 00 00 00 00	 call	 _Py_IncRef

; 140  :         return (PyObject *)op;

  0008d	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  00092	e9 87 01 00 00	 jmp	 $LN17@PyBytes_Fr@2
$LN15@PyBytes_Fr@2:

; 141  :     }
; 142  :     if (size == 1 && (op = characters[*str & UCHAR_MAX]) != NULL) {

  00097	48 83 7c 24 20
	01		 cmp	 QWORD PTR size$[rsp], 1
  0009d	75 3b		 jne	 SHORT $LN14@PyBytes_Fr@2
  0009f	48 8b 44 24 60	 mov	 rax, QWORD PTR str$[rsp]
  000a4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000ac	48 98		 cdqe
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:characters
  000b5	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000b9	48 89 44 24 28	 mov	 QWORD PTR op$[rsp], rax
  000be	48 83 7c 24 28
	00		 cmp	 QWORD PTR op$[rsp], 0
  000c4	74 14		 je	 SHORT $LN14@PyBytes_Fr@2

; 143  : #ifdef COUNT_ALLOCS
; 144  :         one_strings++;
; 145  : #endif
; 146  :         Py_INCREF(op);

  000c6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op$[rsp]
  000cb	e8 00 00 00 00	 call	 _Py_IncRef

; 147  :         return (PyObject *)op;

  000d0	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  000d5	e9 44 01 00 00	 jmp	 $LN17@PyBytes_Fr@2
$LN14@PyBytes_Fr@2:

; 148  :     }
; 149  : 
; 150  :     /* Inline PyObject_NewVar */
; 151  :     op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + size);

  000da	48 8b 44 24 20	 mov	 rax, QWORD PTR size$[rsp]
  000df	48 83 c0 79	 add	 rax, 121		; 00000079H
  000e3	48 8b c8	 mov	 rcx, rax
  000e6	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  000eb	48 89 44 24 28	 mov	 QWORD PTR op$[rsp], rax

; 152  :     if (op == NULL)

  000f0	48 83 7c 24 28
	00		 cmp	 QWORD PTR op$[rsp], 0
  000f6	75 0a		 jne	 SHORT $LN13@PyBytes_Fr@2

; 153  :         return PyErr_NoMemory();

  000f8	e8 00 00 00 00	 call	 PyErr_NoMemory
  000fd	e9 1c 01 00 00	 jmp	 $LN17@PyBytes_Fr@2
$LN13@PyBytes_Fr@2:

; 154  :     PyObject_INIT_VAR((PyVarObject *)op, &PyBytes_Type, size);

  00102	4c 8b 44 24 20	 mov	 r8, QWORD PTR size$[rsp]
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyBytes_Type
  0010e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op$[rsp]
  00113	e8 00 00 00 00	 call	 PyObject_INIT_VAR

; 155  :     op->ob_shash = -1;

  00118	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  0011d	48 c7 40 70 ff
	ff ff ff	 mov	 QWORD PTR [rax+112], -1
$LN12@PyBytes_Fr@2:

; 156  :     Py_MEMCPY(op->ob_sval, str, size+1);

  00125	48 8b 44 24 20	 mov	 rax, QWORD PTR size$[rsp]
  0012a	48 ff c0	 inc	 rax
  0012d	48 89 44 24 48	 mov	 QWORD PTR n_$20492[rsp], rax
  00132	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  00137	48 83 c0 78	 add	 rax, 120		; 00000078H
  0013b	48 89 44 24 30	 mov	 QWORD PTR t_$20493[rsp], rax
  00140	48 8b 44 24 60	 mov	 rax, QWORD PTR str$[rsp]
  00145	48 89 44 24 38	 mov	 QWORD PTR s_$20495[rsp], rax
  0014a	48 83 7c 24 48
	10		 cmp	 QWORD PTR n_$20492[rsp], 16
  00150	72 16		 jb	 SHORT $LN9@PyBytes_Fr@2
  00152	4c 8b 44 24 48	 mov	 r8, QWORD PTR n_$20492[rsp]
  00157	48 8b 54 24 38	 mov	 rdx, QWORD PTR s_$20495[rsp]
  0015c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t_$20493[rsp]
  00161	e8 00 00 00 00	 call	 memcpy
  00166	eb 4b		 jmp	 SHORT $LN8@PyBytes_Fr@2
$LN9@PyBytes_Fr@2:
  00168	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i_$20491[rsp], 0
  00171	eb 0d		 jmp	 SHORT $LN7@PyBytes_Fr@2
$LN6@PyBytes_Fr@2:
  00173	48 8b 44 24 40	 mov	 rax, QWORD PTR i_$20491[rsp]
  00178	48 ff c0	 inc	 rax
  0017b	48 89 44 24 40	 mov	 QWORD PTR i_$20491[rsp], rax
$LN7@PyBytes_Fr@2:
  00180	48 8b 44 24 48	 mov	 rax, QWORD PTR n_$20492[rsp]
  00185	48 39 44 24 40	 cmp	 QWORD PTR i_$20491[rsp], rax
  0018a	73 27		 jae	 SHORT $LN5@PyBytes_Fr@2
  0018c	48 8b 44 24 40	 mov	 rax, QWORD PTR i_$20491[rsp]
  00191	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t_$20493[rsp]
  00196	48 03 c8	 add	 rcx, rax
  00199	48 8b c1	 mov	 rax, rcx
  0019c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i_$20491[rsp]
  001a1	48 8b 54 24 38	 mov	 rdx, QWORD PTR s_$20495[rsp]
  001a6	48 03 d1	 add	 rdx, rcx
  001a9	48 8b ca	 mov	 rcx, rdx
  001ac	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001af	88 08		 mov	 BYTE PTR [rax], cl
  001b1	eb c0		 jmp	 SHORT $LN6@PyBytes_Fr@2
$LN5@PyBytes_Fr@2:
$LN8@PyBytes_Fr@2:
  001b3	33 c0		 xor	 eax, eax
  001b5	85 c0		 test	 eax, eax
  001b7	0f 85 68 ff ff
	ff		 jne	 $LN12@PyBytes_Fr@2

; 157  : 
; 158  :     if (Py_PXCTX)

  001bd	e8 00 00 00 00	 call	 _Py_PXCTX
  001c2	85 c0		 test	 eax, eax
  001c4	74 02		 je	 SHORT $LN4@PyBytes_Fr@2

; 159  :         goto end;

  001c6	eb 51		 jmp	 SHORT $end$20503
$LN4@PyBytes_Fr@2:

; 160  : 
; 161  :     /* share short strings */
; 162  :     if (size == 0) {

  001c8	48 83 7c 24 20
	00		 cmp	 QWORD PTR size$[rsp], 0
  001ce	75 18		 jne	 SHORT $LN3@PyBytes_Fr@2

; 163  :         nullstring = op;

  001d0	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  001d5	48 89 05 00 00
	00 00		 mov	 QWORD PTR nullstring, rax

; 164  :         Py_INCREF(op);

  001dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op$[rsp]
  001e1	e8 00 00 00 00	 call	 _Py_IncRef
  001e6	eb 31		 jmp	 SHORT $LN2@PyBytes_Fr@2
$LN3@PyBytes_Fr@2:

; 165  :     } else if (size == 1) {

  001e8	48 83 7c 24 20
	01		 cmp	 QWORD PTR size$[rsp], 1
  001ee	75 29		 jne	 SHORT $LN1@PyBytes_Fr@2

; 166  :         characters[*str & UCHAR_MAX] = op;

  001f0	48 8b 44 24 60	 mov	 rax, QWORD PTR str$[rsp]
  001f5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001f8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001fd	48 98		 cdqe
  001ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:characters
  00206	48 8b 54 24 28	 mov	 rdx, QWORD PTR op$[rsp]
  0020b	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 167  :         Py_INCREF(op);

  0020f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op$[rsp]
  00214	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@PyBytes_Fr@2:
$LN2@PyBytes_Fr@2:
$end$20503:

; 168  :     }
; 169  : end:
; 170  :     return (PyObject *) op;

  00219	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
$LN17@PyBytes_Fr@2:

; 171  : }

  0021e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00222	c3		 ret	 0
PyBytes_FromString ENDP
_TEXT	ENDS
PUBLIC	_PyBytes_Resize
PUBLIC	??_C@_1CM@OKCLHEPD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_02IKAHHCAI@?$CFi?$AA@			; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu?$AA@			; `string'
PUBLIC	??_C@_03GEFEEEBD@?$CFIu?$AA@			; `string'
PUBLIC	??_C@_03FKNCMABI@?$CFlu?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_03DHINGHAD@?$CFId?$AA@			; `string'
PUBLIC	??_C@_03JALODAI@?$CFld?$AA@			; `string'
PUBLIC	PyBytes_AsString
PUBLIC	??_C@_0EG@OEHELKIM@PyBytes_FromFormatV?$CI?$CJ?3?5?$CFc?5format@ ; `string'
PUBLIC	PyBytes_FromFormatV
EXTRN	strcpy:PROC
EXTRN	__imp_memmove:PROC
EXTRN	__imp_sprintf:PROC
EXTRN	__ImageBase:BYTE
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBytes_FromFormatV DD imagerel $LN76
	DD	imagerel $LN76+2736
	DD	imagerel $unwind$PyBytes_FromFormatV
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_FromFormatV DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_1CM@OKCLHEPD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@OKCLHEPD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02IKAHHCAI@?$CFi?$AA@
CONST	SEGMENT
??_C@_02IKAHHCAI@?$CFi?$AA@ DB '%i', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu?$AA@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu?$AA@ DB '%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GEFEEEBD@?$CFIu?$AA@
CONST	SEGMENT
??_C@_03GEFEEEBD@?$CFIu?$AA@ DB '%Iu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKNCMABI@?$CFlu?$AA@
CONST	SEGMENT
??_C@_03FKNCMABI@?$CFlu?$AA@ DB '%lu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DHINGHAD@?$CFId?$AA@
CONST	SEGMENT
??_C@_03DHINGHAD@?$CFId?$AA@ DB '%Id', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JALODAI@?$CFld?$AA@
CONST	SEGMENT
??_C@_03JALODAI@?$CFld?$AA@ DB '%ld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@OEHELKIM@PyBytes_FromFormatV?$CI?$CJ?3?5?$CFc?5format@
CONST	SEGMENT
??_C@_0EG@OEHELKIM@PyBytes_FromFormatV?$CI?$CJ?3?5?$CFc?5format@ DB 'PyBy'
	DB	'tes_FromFormatV(): %c format expects an integer in range [0; '
	DB	'255]', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBytes_FromFormatV
_TEXT	SEGMENT
count$ = 32
n$ = 40
s$ = 48
f$ = 56
string$ = 64
p$20524 = 72
c$20537 = 80
p$20598 = 88
longflag$20600 = 96
i$20599 = 104
size_tflag$20601 = 112
c$20624 = 116
t_$20753 = 120
s_$20755 = 128
i_$20751 = 136
n_$20752 = 144
tv94 = 152
tv223 = 156
format$ = 176
vargs$ = 184
PyBytes_FromFormatV PROC				; COMDAT

; 175  : {

$LN76:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 176  :     va_list count;
; 177  :     Py_ssize_t n = 0;

  00011	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0

; 178  :     const char* f;
; 179  :     char *s;
; 180  :     PyObject* string;
; 181  : 
; 182  :     Py_VA_COPY(count, vargs);

  0001a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00022	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 183  :     /* step 1: figure out how large a buffer we need */
; 184  :     for (f = format; *f; f++) {

  00027	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR format$[rsp]
  0002f	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
  00034	eb 0d		 jmp	 SHORT $LN68@PyBytes_Fr@3
$LN67@PyBytes_Fr@3:
  00036	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  0003b	48 ff c0	 inc	 rax
  0003e	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
$LN68@PyBytes_Fr@3:
  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00048	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 05 02 00
	00		 je	 $LN66@PyBytes_Fr@3

; 185  :         if (*f == '%') {

  00053	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00058	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005b	83 f8 25	 cmp	 eax, 37			; 00000025H
  0005e	0f 85 e2 01 00
	00		 jne	 $LN65@PyBytes_Fr@3

; 186  :             const char* p = f;

  00064	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00069	48 89 44 24 48	 mov	 QWORD PTR p$20524[rsp], rax
$LN64@PyBytes_Fr@3:

; 187  :             while (*++f && *f != '%' && !Py_ISALPHA(*f))

  0006e	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00073	48 ff c0	 inc	 rax
  00076	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00080	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00083	85 c0		 test	 eax, eax
  00085	74 30		 je	 SHORT $LN63@PyBytes_Fr@3
  00087	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  0008c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0008f	83 f8 25	 cmp	 eax, 37			; 00000025H
  00092	74 23		 je	 SHORT $LN63@PyBytes_Fr@3
  00094	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00099	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a1	0f b6 c0	 movzx	 eax, al
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000ab	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000ae	83 e0 03	 and	 eax, 3
  000b1	85 c0		 test	 eax, eax
  000b3	75 02		 jne	 SHORT $LN63@PyBytes_Fr@3

; 188  :                 ;

  000b5	eb b7		 jmp	 SHORT $LN64@PyBytes_Fr@3
$LN63@PyBytes_Fr@3:

; 189  : 
; 190  :             /* skip the 'l' or 'z' in {%ld, %zd, %lu, %zu} since
; 191  :              * they don't affect the amount of space we reserve.
; 192  :              */
; 193  :             if ((*f == 'l' || *f == 'z') &&
; 194  :                             (f[1] == 'd' || f[1] == 'u'))

  000b7	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  000bc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000bf	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  000c2	74 0d		 je	 SHORT $LN61@PyBytes_Fr@3
  000c4	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  000c9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000cc	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  000cf	75 29		 jne	 SHORT $LN62@PyBytes_Fr@3
$LN61@PyBytes_Fr@3:
  000d1	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  000d6	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000da	83 f8 64	 cmp	 eax, 100		; 00000064H
  000dd	74 0e		 je	 SHORT $LN60@PyBytes_Fr@3
  000df	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  000e4	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000e8	83 f8 75	 cmp	 eax, 117		; 00000075H
  000eb	75 0d		 jne	 SHORT $LN62@PyBytes_Fr@3
$LN60@PyBytes_Fr@3:

; 195  :                 ++f;

  000ed	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  000f2	48 ff c0	 inc	 rax
  000f5	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
$LN62@PyBytes_Fr@3:

; 196  : 
; 197  :             switch (*f) {

  000fa	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  000ff	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00102	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv94[rsp], eax
  00109	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv94[rsp]
  00110	83 e8 25	 sub	 eax, 37			; 00000025H
  00113	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv94[rsp], eax
  0011a	83 bc 24 98 00
	00 00 53	 cmp	 DWORD PTR tv94[rsp], 83	; 00000053H
  00122	0f 87 00 01 00
	00		 ja	 $LN50@PyBytes_Fr@3
  00128	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR tv94[rsp]
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00137	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN74@PyBytes_Fr@3[rcx+rax]
  0013f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN75@PyBytes_Fr@3[rcx+rax*4]
  00146	48 03 c1	 add	 rax, rcx
  00149	ff e0		 jmp	 rax
$LN57@PyBytes_Fr@3:

; 198  :             case 'c':
; 199  :             {
; 200  :                 int c = va_arg(count, int);

  0014b	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00150	48 83 c0 08	 add	 rax, 8
  00154	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
  00159	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  0015e	8b 40 f8	 mov	 eax, DWORD PTR [rax-8]
  00161	89 44 24 50	 mov	 DWORD PTR c$20537[rsp], eax

; 201  :                 if (c < 0 || c > 255) {

  00165	83 7c 24 50 00	 cmp	 DWORD PTR c$20537[rsp], 0
  0016a	7c 0a		 jl	 SHORT $LN55@PyBytes_Fr@3
  0016c	81 7c 24 50 ff
	00 00 00	 cmp	 DWORD PTR c$20537[rsp], 255 ; 000000ffH
  00174	7e 1a		 jle	 SHORT $LN56@PyBytes_Fr@3
$LN55@PyBytes_Fr@3:

; 202  :                     PyErr_SetString(PyExc_OverflowError,
; 203  :                                     "PyBytes_FromFormatV(): %c format "
; 204  :                                     "expects an integer in range [0; 255]");

  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@OEHELKIM@PyBytes_FromFormatV?$CI?$CJ?3?5?$CFc?5format@
  0017d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00184	e8 00 00 00 00	 call	 PyErr_SetString

; 205  :                     return NULL;

  00189	33 c0		 xor	 eax, eax
  0018b	e9 33 08 00 00	 jmp	 $LN69@PyBytes_Fr@3
$LN56@PyBytes_Fr@3:

; 206  :                 }
; 207  :                 n++;

  00190	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00195	48 ff c0	 inc	 rax
  00198	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 208  :                 break;

  0019d	e9 a2 00 00 00	 jmp	 $LN58@PyBytes_Fr@3
$LN54@PyBytes_Fr@3:

; 209  :             }
; 210  :             case '%':
; 211  :                 n++;

  001a2	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  001a7	48 ff c0	 inc	 rax
  001aa	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 212  :                 break;

  001af	e9 90 00 00 00	 jmp	 $LN58@PyBytes_Fr@3
$LN53@PyBytes_Fr@3:

; 213  :             case 'd': case 'u': case 'i': case 'x':
; 214  :                 (void) va_arg(count, int);

  001b4	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  001b9	48 83 c0 08	 add	 rax, 8
  001bd	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 215  :                 /* 20 bytes is enough to hold a 64-bit
; 216  :                    integer.  Decimal takes the most space.
; 217  :                    This isn't enough for octal. */
; 218  :                 n += 20;

  001c2	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  001c7	48 83 c0 14	 add	 rax, 20
  001cb	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 219  :                 break;

  001d0	eb 72		 jmp	 SHORT $LN58@PyBytes_Fr@3
$LN52@PyBytes_Fr@3:

; 220  :             case 's':
; 221  :                 s = va_arg(count, char*);

  001d2	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  001d7	48 83 c0 08	 add	 rax, 8
  001db	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
  001e0	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  001e5	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  001e9	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 222  :                 n += strlen(s);

  001ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  001f3	e8 00 00 00 00	 call	 strlen
  001f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$[rsp]
  001fd	48 03 c8	 add	 rcx, rax
  00200	48 8b c1	 mov	 rax, rcx
  00203	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 223  :                 break;

  00208	eb 3a		 jmp	 SHORT $LN58@PyBytes_Fr@3
$LN51@PyBytes_Fr@3:

; 224  :             case 'p':
; 225  :                 (void) va_arg(count, int);

  0020a	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  0020f	48 83 c0 08	 add	 rax, 8
  00213	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 226  :                 /* maximum 64-bit pointer representation:
; 227  :                  * 0xffffffffffffffff
; 228  :                  * so 19 characters is enough.
; 229  :                  * XXX I count 18 -- what's the extra for?
; 230  :                  */
; 231  :                 n += 19;

  00218	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0021d	48 83 c0 13	 add	 rax, 19
  00221	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 232  :                 break;

  00226	eb 1c		 jmp	 SHORT $LN58@PyBytes_Fr@3
$LN50@PyBytes_Fr@3:

; 233  :             default:
; 234  :                 /* if we stumble upon an unknown
; 235  :                    formatting code, copy the rest of
; 236  :                    the format string to the output
; 237  :                    string. (we cannot just skip the
; 238  :                    code, since there's no way to know
; 239  :                    what's in the argument list) */
; 240  :                 n += strlen(p);

  00228	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$20524[rsp]
  0022d	e8 00 00 00 00	 call	 strlen
  00232	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$[rsp]
  00237	48 03 c8	 add	 rcx, rax
  0023a	48 8b c1	 mov	 rax, rcx
  0023d	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 241  :                 goto expand;

  00242	eb 14		 jmp	 SHORT $expand$20589
$LN58@PyBytes_Fr@3:

; 242  :             }
; 243  :         } else

  00244	eb 0d		 jmp	 SHORT $LN49@PyBytes_Fr@3
$LN65@PyBytes_Fr@3:

; 244  :             n++;

  00246	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0024b	48 ff c0	 inc	 rax
  0024e	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
$LN49@PyBytes_Fr@3:

; 245  :     }

  00253	e9 de fd ff ff	 jmp	 $LN67@PyBytes_Fr@3
$LN66@PyBytes_Fr@3:
$expand$20589:

; 246  :  expand:
; 247  :     /* step 2: fill the buffer */
; 248  :     /* Since we've analyzed how much space we need for the worst case,
; 249  :        use sprintf directly instead of the slower PyOS_snprintf. */
; 250  :     string = PyBytes_FromStringAndSize(NULL, n);

  00258	48 8b 54 24 28	 mov	 rdx, QWORD PTR n$[rsp]
  0025d	33 c9		 xor	 ecx, ecx
  0025f	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00264	48 89 44 24 40	 mov	 QWORD PTR string$[rsp], rax

; 251  :     if (!string)

  00269	48 83 7c 24 40
	00		 cmp	 QWORD PTR string$[rsp], 0
  0026f	75 07		 jne	 SHORT $LN48@PyBytes_Fr@3

; 252  :         return NULL;

  00271	33 c0		 xor	 eax, eax
  00273	e9 4b 07 00 00	 jmp	 $LN69@PyBytes_Fr@3
$LN48@PyBytes_Fr@3:

; 253  : 
; 254  :     s = PyBytes_AsString(string);

  00278	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0027d	e8 00 00 00 00	 call	 PyBytes_AsString
  00282	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 255  : 
; 256  :     for (f = format; *f; f++) {

  00287	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR format$[rsp]
  0028f	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
  00294	eb 0d		 jmp	 SHORT $LN47@PyBytes_Fr@3
$LN46@PyBytes_Fr@3:
  00296	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  0029b	48 ff c0	 inc	 rax
  0029e	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
$LN47@PyBytes_Fr@3:
  002a3	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  002a8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ab	85 c0		 test	 eax, eax
  002ad	0f 84 b6 06 00
	00		 je	 $LN45@PyBytes_Fr@3

; 257  :         if (*f == '%') {

  002b3	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  002b8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002bb	83 f8 25	 cmp	 eax, 37			; 00000025H
  002be	0f 85 84 06 00
	00		 jne	 $LN44@PyBytes_Fr@3

; 258  :             const char* p = f++;

  002c4	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  002c9	48 89 44 24 58	 mov	 QWORD PTR p$20598[rsp], rax
  002ce	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  002d3	48 ff c0	 inc	 rax
  002d6	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax

; 259  :             Py_ssize_t i;
; 260  :             int longflag = 0;

  002db	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR longflag$20600[rsp], 0

; 261  :             int size_tflag = 0;

  002e3	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR size_tflag$20601[rsp], 0

; 262  :             /* parse the width.precision part (we're only
; 263  :                interested in the precision value, if any) */
; 264  :             n = 0;

  002eb	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0
$LN43@PyBytes_Fr@3:

; 265  :             while (Py_ISDIGIT(*f))

  002f4	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  002f9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002fc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00301	0f b6 c0	 movzx	 eax, al
  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0030b	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0030e	83 e0 04	 and	 eax, 4
  00311	85 c0		 test	 eax, eax
  00313	74 2b		 je	 SHORT $LN42@PyBytes_Fr@3

; 266  :                 n = (n*10) + *f++ - '0';

  00315	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0031a	48 6b c0 0a	 imul	 rax, 10
  0031e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  00323	48 0f be 09	 movsx	 rcx, BYTE PTR [rcx]
  00327	48 8d 44 08 d0	 lea	 rax, QWORD PTR [rax+rcx-48]
  0032c	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
  00331	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00336	48 ff c0	 inc	 rax
  00339	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
  0033e	eb b4		 jmp	 SHORT $LN43@PyBytes_Fr@3
$LN42@PyBytes_Fr@3:

; 267  :             if (*f == '.') {

  00340	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00345	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00348	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0034b	75 62		 jne	 SHORT $LN41@PyBytes_Fr@3

; 268  :                 f++;

  0034d	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00352	48 ff c0	 inc	 rax
  00355	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax

; 269  :                 n = 0;

  0035a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0
$LN40@PyBytes_Fr@3:

; 270  :                 while (Py_ISDIGIT(*f))

  00363	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00368	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0036b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00370	0f b6 c0	 movzx	 eax, al
  00373	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0037a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0037d	83 e0 04	 and	 eax, 4
  00380	85 c0		 test	 eax, eax
  00382	74 2b		 je	 SHORT $LN39@PyBytes_Fr@3

; 271  :                     n = (n*10) + *f++ - '0';

  00384	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00389	48 6b c0 0a	 imul	 rax, 10
  0038d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  00392	48 0f be 09	 movsx	 rcx, BYTE PTR [rcx]
  00396	48 8d 44 08 d0	 lea	 rax, QWORD PTR [rax+rcx-48]
  0039b	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
  003a0	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  003a5	48 ff c0	 inc	 rax
  003a8	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
  003ad	eb b4		 jmp	 SHORT $LN40@PyBytes_Fr@3
$LN39@PyBytes_Fr@3:
$LN41@PyBytes_Fr@3:
$LN38@PyBytes_Fr@3:

; 272  :             }
; 273  :             while (*f && *f != '%' && !Py_ISALPHA(*f))

  003af	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  003b4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003b7	85 c0		 test	 eax, eax
  003b9	74 3d		 je	 SHORT $LN37@PyBytes_Fr@3
  003bb	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  003c0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003c3	83 f8 25	 cmp	 eax, 37			; 00000025H
  003c6	74 30		 je	 SHORT $LN37@PyBytes_Fr@3
  003c8	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  003cd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003d0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003d5	0f b6 c0	 movzx	 eax, al
  003d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  003df	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  003e2	83 e0 03	 and	 eax, 3
  003e5	85 c0		 test	 eax, eax
  003e7	75 0f		 jne	 SHORT $LN37@PyBytes_Fr@3

; 274  :                 f++;

  003e9	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  003ee	48 ff c0	 inc	 rax
  003f1	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
  003f6	eb b7		 jmp	 SHORT $LN38@PyBytes_Fr@3
$LN37@PyBytes_Fr@3:

; 275  :             /* handle the long flag, but only for %ld and %lu.
; 276  :                others can be added when necessary. */
; 277  :             if (*f == 'l' && (f[1] == 'd' || f[1] == 'u')) {

  003f8	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  003fd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00400	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  00403	75 31		 jne	 SHORT $LN36@PyBytes_Fr@3
  00405	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  0040a	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0040e	83 f8 64	 cmp	 eax, 100		; 00000064H
  00411	74 0e		 je	 SHORT $LN35@PyBytes_Fr@3
  00413	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00418	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0041c	83 f8 75	 cmp	 eax, 117		; 00000075H
  0041f	75 15		 jne	 SHORT $LN36@PyBytes_Fr@3
$LN35@PyBytes_Fr@3:

; 278  :                 longflag = 1;

  00421	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR longflag$20600[rsp], 1

; 279  :                 ++f;

  00429	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  0042e	48 ff c0	 inc	 rax
  00431	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
$LN36@PyBytes_Fr@3:

; 280  :             }
; 281  :             /* handle the size_t flag. */
; 282  :             if (*f == 'z' && (f[1] == 'd' || f[1] == 'u')) {

  00436	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  0043b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0043e	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00441	75 31		 jne	 SHORT $LN34@PyBytes_Fr@3
  00443	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00448	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0044c	83 f8 64	 cmp	 eax, 100		; 00000064H
  0044f	74 0e		 je	 SHORT $LN33@PyBytes_Fr@3
  00451	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00456	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0045a	83 f8 75	 cmp	 eax, 117		; 00000075H
  0045d	75 15		 jne	 SHORT $LN34@PyBytes_Fr@3
$LN33@PyBytes_Fr@3:

; 283  :                 size_tflag = 1;

  0045f	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR size_tflag$20601[rsp], 1

; 284  :                 ++f;

  00467	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  0046c	48 ff c0	 inc	 rax
  0046f	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
$LN34@PyBytes_Fr@3:

; 285  :             }
; 286  : 
; 287  :             switch (*f) {

  00474	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00479	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0047c	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv223[rsp], eax
  00483	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv223[rsp]
  0048a	83 e8 25	 sub	 eax, 37			; 00000025H
  0048d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv223[rsp], eax
  00494	83 bc 24 9c 00
	00 00 53	 cmp	 DWORD PTR tv223[rsp], 83 ; 00000053H
  0049c	0f 87 79 04 00
	00		 ja	 $LN2@PyBytes_Fr@3
  004a2	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv223[rsp]
  004aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  004b1	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN72@PyBytes_Fr@3[rcx+rax]
  004b9	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN73@PyBytes_Fr@3[rcx+rax*4]
  004c0	48 03 c1	 add	 rax, rcx
  004c3	ff e0		 jmp	 rax
$LN30@PyBytes_Fr@3:

; 288  :             case 'c':
; 289  :             {
; 290  :                 int c = va_arg(vargs, int);

  004c5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  004cd	48 83 c0 08	 add	 rax, 8
  004d1	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  004d9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  004e1	8b 40 f8	 mov	 eax, DWORD PTR [rax-8]
  004e4	89 44 24 74	 mov	 DWORD PTR c$20624[rsp], eax

; 291  :                 /* c has been checked for overflow in the first step */
; 292  :                 *s++ = (unsigned char)c;

  004e8	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  004ed	0f b6 4c 24 74	 movzx	 ecx, BYTE PTR c$20624[rsp]
  004f2	88 08		 mov	 BYTE PTR [rax], cl
  004f4	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  004f9	48 ff c0	 inc	 rax
  004fc	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 293  :                 break;

  00501	e9 40 04 00 00	 jmp	 $LN31@PyBytes_Fr@3
$LN29@PyBytes_Fr@3:

; 294  :             }
; 295  :             case 'd':
; 296  :                 if (longflag)

  00506	83 7c 24 60 00	 cmp	 DWORD PTR longflag$20600[rsp], 0
  0050b	74 34		 je	 SHORT $LN28@PyBytes_Fr@3

; 297  :                     sprintf(s, "%ld", va_arg(vargs, long));

  0050d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00515	48 83 c0 08	 add	 rax, 8
  00519	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  00521	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00529	44 8b 40 f8	 mov	 r8d, DWORD PTR [rax-8]
  0052d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JALODAI@?$CFld?$AA@
  00534	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00539	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
  0053f	eb 6d		 jmp	 SHORT $LN27@PyBytes_Fr@3
$LN28@PyBytes_Fr@3:

; 298  :                 else if (size_tflag)

  00541	83 7c 24 70 00	 cmp	 DWORD PTR size_tflag$20601[rsp], 0
  00546	74 34		 je	 SHORT $LN26@PyBytes_Fr@3

; 299  :                     sprintf(s, "%" PY_FORMAT_SIZE_T "d",
; 300  :                         va_arg(vargs, Py_ssize_t));

  00548	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00550	48 83 c0 08	 add	 rax, 8
  00554	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  0055c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00564	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  00568	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03DHINGHAD@?$CFId?$AA@
  0056f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00574	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 301  :                 else

  0057a	eb 32		 jmp	 SHORT $LN25@PyBytes_Fr@3
$LN26@PyBytes_Fr@3:

; 302  :                     sprintf(s, "%d", va_arg(vargs, int));

  0057c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00584	48 83 c0 08	 add	 rax, 8
  00588	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  00590	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00598	44 8b 40 f8	 mov	 r8d, DWORD PTR [rax-8]
  0059c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  005a3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  005a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
$LN25@PyBytes_Fr@3:
$LN27@PyBytes_Fr@3:

; 303  :                 s += strlen(s);

  005ae	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  005b3	e8 00 00 00 00	 call	 strlen
  005b8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  005bd	48 03 c8	 add	 rcx, rax
  005c0	48 8b c1	 mov	 rax, rcx
  005c3	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 304  :                 break;

  005c8	e9 79 03 00 00	 jmp	 $LN31@PyBytes_Fr@3
$LN24@PyBytes_Fr@3:

; 305  :             case 'u':
; 306  :                 if (longflag)

  005cd	83 7c 24 60 00	 cmp	 DWORD PTR longflag$20600[rsp], 0
  005d2	74 34		 je	 SHORT $LN23@PyBytes_Fr@3

; 307  :                     sprintf(s, "%lu",
; 308  :                         va_arg(vargs, unsigned long));

  005d4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  005dc	48 83 c0 08	 add	 rax, 8
  005e0	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  005e8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  005f0	44 8b 40 f8	 mov	 r8d, DWORD PTR [rax-8]
  005f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03FKNCMABI@?$CFlu?$AA@
  005fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00600	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
  00606	eb 6d		 jmp	 SHORT $LN22@PyBytes_Fr@3
$LN23@PyBytes_Fr@3:

; 309  :                 else if (size_tflag)

  00608	83 7c 24 70 00	 cmp	 DWORD PTR size_tflag$20601[rsp], 0
  0060d	74 34		 je	 SHORT $LN21@PyBytes_Fr@3

; 310  :                     sprintf(s, "%" PY_FORMAT_SIZE_T "u",
; 311  :                         va_arg(vargs, size_t));

  0060f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00617	48 83 c0 08	 add	 rax, 8
  0061b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  00623	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  0062b	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  0062f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03GEFEEEBD@?$CFIu?$AA@
  00636	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0063b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 312  :                 else

  00641	eb 32		 jmp	 SHORT $LN20@PyBytes_Fr@3
$LN21@PyBytes_Fr@3:

; 313  :                     sprintf(s, "%u",
; 314  :                         va_arg(vargs, unsigned int));

  00643	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  0064b	48 83 c0 08	 add	 rax, 8
  0064f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  00657	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  0065f	44 8b 40 f8	 mov	 r8d, DWORD PTR [rax-8]
  00663	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02GMHACPFF@?$CFu?$AA@
  0066a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0066f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
$LN20@PyBytes_Fr@3:
$LN22@PyBytes_Fr@3:

; 315  :                 s += strlen(s);

  00675	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0067a	e8 00 00 00 00	 call	 strlen
  0067f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00684	48 03 c8	 add	 rcx, rax
  00687	48 8b c1	 mov	 rax, rcx
  0068a	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 316  :                 break;

  0068f	e9 b2 02 00 00	 jmp	 $LN31@PyBytes_Fr@3
$LN19@PyBytes_Fr@3:

; 317  :             case 'i':
; 318  :                 sprintf(s, "%i", va_arg(vargs, int));

  00694	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  0069c	48 83 c0 08	 add	 rax, 8
  006a0	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  006a8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  006b0	44 8b 40 f8	 mov	 r8d, DWORD PTR [rax-8]
  006b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02IKAHHCAI@?$CFi?$AA@
  006bb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  006c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 319  :                 s += strlen(s);

  006c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  006cb	e8 00 00 00 00	 call	 strlen
  006d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  006d5	48 03 c8	 add	 rcx, rax
  006d8	48 8b c1	 mov	 rax, rcx
  006db	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 320  :                 break;

  006e0	e9 61 02 00 00	 jmp	 $LN31@PyBytes_Fr@3
$LN18@PyBytes_Fr@3:

; 321  :             case 'x':
; 322  :                 sprintf(s, "%x", va_arg(vargs, int));

  006e5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  006ed	48 83 c0 08	 add	 rax, 8
  006f1	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  006f9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00701	44 8b 40 f8	 mov	 r8d, DWORD PTR [rax-8]
  00705	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02NJNOFBBI@?$CFx?$AA@
  0070c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00711	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 323  :                 s += strlen(s);

  00717	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0071c	e8 00 00 00 00	 call	 strlen
  00721	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00726	48 03 c8	 add	 rcx, rax
  00729	48 8b c1	 mov	 rax, rcx
  0072c	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 324  :                 break;

  00731	e9 10 02 00 00	 jmp	 $LN31@PyBytes_Fr@3
$LN17@PyBytes_Fr@3:

; 325  :             case 's':
; 326  :                 p = va_arg(vargs, char*);

  00736	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  0073e	48 83 c0 08	 add	 rax, 8
  00742	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  0074a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00752	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00756	48 89 44 24 58	 mov	 QWORD PTR p$20598[rsp], rax

; 327  :                 i = strlen(p);

  0075b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$20598[rsp]
  00760	e8 00 00 00 00	 call	 strlen
  00765	48 89 44 24 68	 mov	 QWORD PTR i$20599[rsp], rax

; 328  :                 if (n > 0 && i > n)

  0076a	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$[rsp], 0
  00770	7e 16		 jle	 SHORT $LN16@PyBytes_Fr@3
  00772	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00777	48 39 44 24 68	 cmp	 QWORD PTR i$20599[rsp], rax
  0077c	7e 0a		 jle	 SHORT $LN16@PyBytes_Fr@3

; 329  :                     i = n;

  0077e	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00783	48 89 44 24 68	 mov	 QWORD PTR i$20599[rsp], rax
$LN16@PyBytes_Fr@3:
$LN15@PyBytes_Fr@3:

; 330  :                 Py_MEMCPY(s, p, i);

  00788	48 8b 44 24 68	 mov	 rax, QWORD PTR i$20599[rsp]
  0078d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR n_$20752[rsp], rax
  00795	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0079a	48 89 44 24 78	 mov	 QWORD PTR t_$20753[rsp], rax
  0079f	48 8b 44 24 58	 mov	 rax, QWORD PTR p$20598[rsp]
  007a4	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s_$20755[rsp], rax
  007ac	48 83 bc 24 90
	00 00 00 10	 cmp	 QWORD PTR n_$20752[rsp], 16
  007b5	72 1c		 jb	 SHORT $LN12@PyBytes_Fr@3
  007b7	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR n_$20752[rsp]
  007bf	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s_$20755[rsp]
  007c7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR t_$20753[rsp]
  007cc	e8 00 00 00 00	 call	 memcpy
  007d1	eb 63		 jmp	 SHORT $LN11@PyBytes_Fr@3
$LN12@PyBytes_Fr@3:
  007d3	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$20751[rsp], 0
  007df	eb 13		 jmp	 SHORT $LN10@PyBytes_Fr@3
$LN9@PyBytes_Fr@3:
  007e1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR i_$20751[rsp]
  007e9	48 ff c0	 inc	 rax
  007ec	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR i_$20751[rsp], rax
$LN10@PyBytes_Fr@3:
  007f4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR n_$20752[rsp]
  007fc	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR i_$20751[rsp], rax
  00804	73 30		 jae	 SHORT $LN8@PyBytes_Fr@3
  00806	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR i_$20751[rsp]
  0080e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR t_$20753[rsp]
  00813	48 03 c8	 add	 rcx, rax
  00816	48 8b c1	 mov	 rax, rcx
  00819	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR i_$20751[rsp]
  00821	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s_$20755[rsp]
  00829	48 03 d1	 add	 rdx, rcx
  0082c	48 8b ca	 mov	 rcx, rdx
  0082f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00832	88 08		 mov	 BYTE PTR [rax], cl
  00834	eb ab		 jmp	 SHORT $LN9@PyBytes_Fr@3
$LN8@PyBytes_Fr@3:
$LN11@PyBytes_Fr@3:
  00836	33 c0		 xor	 eax, eax
  00838	85 c0		 test	 eax, eax
  0083a	0f 85 48 ff ff
	ff		 jne	 $LN15@PyBytes_Fr@3

; 331  :                 s += i;

  00840	48 8b 44 24 68	 mov	 rax, QWORD PTR i$20599[rsp]
  00845	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0084a	48 03 c8	 add	 rcx, rax
  0084d	48 8b c1	 mov	 rax, rcx
  00850	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 332  :                 break;

  00855	e9 ec 00 00 00	 jmp	 $LN31@PyBytes_Fr@3
$LN7@PyBytes_Fr@3:

; 333  :             case 'p':
; 334  :                 sprintf(s, "%p", va_arg(vargs, void*));

  0085a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00862	48 83 c0 08	 add	 rax, 8
  00866	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vargs$[rsp], rax
  0086e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR vargs$[rsp]
  00876	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  0087a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02BBAHNLBA@?$CFp?$AA@
  00881	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00886	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 335  :                 /* %p is ill-defined:  ensure leading 0x. */
; 336  :                 if (s[1] == 'X')

  0088c	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00891	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00895	83 f8 58	 cmp	 eax, 88			; 00000058H
  00898	75 0b		 jne	 SHORT $LN6@PyBytes_Fr@3

; 337  :                     s[1] = 'x';

  0089a	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0089f	c6 40 01 78	 mov	 BYTE PTR [rax+1], 120	; 00000078H
  008a3	eb 43		 jmp	 SHORT $LN5@PyBytes_Fr@3
$LN6@PyBytes_Fr@3:

; 338  :                 else if (s[1] != 'x') {

  008a5	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  008aa	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  008ae	83 f8 78	 cmp	 eax, 120		; 00000078H
  008b1	74 35		 je	 SHORT $LN4@PyBytes_Fr@3

; 339  :                     memmove(s+2, s, strlen(s)+1);

  008b3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  008b8	e8 00 00 00 00	 call	 strlen
  008bd	48 ff c0	 inc	 rax
  008c0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  008c5	48 83 c1 02	 add	 rcx, 2
  008c9	4c 8b c0	 mov	 r8, rax
  008cc	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  008d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 340  :                     s[0] = '0';

  008d7	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  008dc	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H

; 341  :                     s[1] = 'x';

  008df	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  008e4	c6 40 01 78	 mov	 BYTE PTR [rax+1], 120	; 00000078H
$LN4@PyBytes_Fr@3:
$LN5@PyBytes_Fr@3:

; 342  :                 }
; 343  :                 s += strlen(s);

  008e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  008ed	e8 00 00 00 00	 call	 strlen
  008f2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  008f7	48 03 c8	 add	 rcx, rax
  008fa	48 8b c1	 mov	 rax, rcx
  008fd	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 344  :                 break;

  00902	eb 42		 jmp	 SHORT $LN31@PyBytes_Fr@3
$LN3@PyBytes_Fr@3:

; 345  :             case '%':
; 346  :                 *s++ = '%';

  00904	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00909	c6 00 25	 mov	 BYTE PTR [rax], 37	; 00000025H
  0090c	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00911	48 ff c0	 inc	 rax
  00914	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 347  :                 break;

  00919	eb 2b		 jmp	 SHORT $LN31@PyBytes_Fr@3
$LN2@PyBytes_Fr@3:

; 348  :             default:
; 349  :                 strcpy(s, p);

  0091b	48 8b 54 24 58	 mov	 rdx, QWORD PTR p$20598[rsp]
  00920	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00925	e8 00 00 00 00	 call	 strcpy

; 350  :                 s += strlen(s);

  0092a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0092f	e8 00 00 00 00	 call	 strlen
  00934	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00939	48 03 c8	 add	 rcx, rax
  0093c	48 8b c1	 mov	 rax, rcx
  0093f	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 351  :                 goto end;

  00944	eb 23		 jmp	 SHORT $end$20779
$LN31@PyBytes_Fr@3:

; 352  :             }
; 353  :         } else

  00946	eb 1c		 jmp	 SHORT $LN1@PyBytes_Fr@3
$LN44@PyBytes_Fr@3:

; 354  :             *s++ = *f;

  00948	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0094d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  00952	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00955	88 08		 mov	 BYTE PTR [rax], cl
  00957	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0095c	48 ff c0	 inc	 rax
  0095f	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax
$LN1@PyBytes_Fr@3:

; 355  :     }

  00964	e9 2d f9 ff ff	 jmp	 $LN46@PyBytes_Fr@3
$LN45@PyBytes_Fr@3:
$end$20779:

; 356  : 
; 357  :  end:
; 358  :     _PyBytes_Resize(&string, s - PyBytes_AS_STRING(string));

  00969	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0096e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00972	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00978	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0097d	85 c0		 test	 eax, eax
  0097f	75 1c		 jne	 SHORT $LN71@PyBytes_Fr@3
  00981	41 b8 66 01 00
	00		 mov	 r8d, 358		; 00000166H
  00987	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0098e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@OKCLHEPD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
  00995	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0099b	33 c0		 xor	 eax, eax
$LN71@PyBytes_Fr@3:
  0099d	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  009a2	48 83 c0 78	 add	 rax, 120		; 00000078H
  009a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  009ab	48 2b c8	 sub	 rcx, rax
  009ae	48 8b c1	 mov	 rax, rcx
  009b1	48 8b d0	 mov	 rdx, rax
  009b4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR string$[rsp]
  009b9	e8 00 00 00 00	 call	 _PyBytes_Resize

; 359  :     return string;

  009be	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
$LN69@PyBytes_Fr@3:

; 360  : }

  009c3	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  009ca	c3		 ret	 0
  009cb	90		 npad	 1
$LN75@PyBytes_Fr@3:
  009cc	00 00 00 00	 DD	 $LN54@PyBytes_Fr@3
  009d0	00 00 00 00	 DD	 $LN57@PyBytes_Fr@3
  009d4	00 00 00 00	 DD	 $LN53@PyBytes_Fr@3
  009d8	00 00 00 00	 DD	 $LN51@PyBytes_Fr@3
  009dc	00 00 00 00	 DD	 $LN52@PyBytes_Fr@3
  009e0	00 00 00 00	 DD	 $LN50@PyBytes_Fr@3
$LN74@PyBytes_Fr@3:
  009e4	00		 DB	 0
  009e5	05		 DB	 5
  009e6	05		 DB	 5
  009e7	05		 DB	 5
  009e8	05		 DB	 5
  009e9	05		 DB	 5
  009ea	05		 DB	 5
  009eb	05		 DB	 5
  009ec	05		 DB	 5
  009ed	05		 DB	 5
  009ee	05		 DB	 5
  009ef	05		 DB	 5
  009f0	05		 DB	 5
  009f1	05		 DB	 5
  009f2	05		 DB	 5
  009f3	05		 DB	 5
  009f4	05		 DB	 5
  009f5	05		 DB	 5
  009f6	05		 DB	 5
  009f7	05		 DB	 5
  009f8	05		 DB	 5
  009f9	05		 DB	 5
  009fa	05		 DB	 5
  009fb	05		 DB	 5
  009fc	05		 DB	 5
  009fd	05		 DB	 5
  009fe	05		 DB	 5
  009ff	05		 DB	 5
  00a00	05		 DB	 5
  00a01	05		 DB	 5
  00a02	05		 DB	 5
  00a03	05		 DB	 5
  00a04	05		 DB	 5
  00a05	05		 DB	 5
  00a06	05		 DB	 5
  00a07	05		 DB	 5
  00a08	05		 DB	 5
  00a09	05		 DB	 5
  00a0a	05		 DB	 5
  00a0b	05		 DB	 5
  00a0c	05		 DB	 5
  00a0d	05		 DB	 5
  00a0e	05		 DB	 5
  00a0f	05		 DB	 5
  00a10	05		 DB	 5
  00a11	05		 DB	 5
  00a12	05		 DB	 5
  00a13	05		 DB	 5
  00a14	05		 DB	 5
  00a15	05		 DB	 5
  00a16	05		 DB	 5
  00a17	05		 DB	 5
  00a18	05		 DB	 5
  00a19	05		 DB	 5
  00a1a	05		 DB	 5
  00a1b	05		 DB	 5
  00a1c	05		 DB	 5
  00a1d	05		 DB	 5
  00a1e	05		 DB	 5
  00a1f	05		 DB	 5
  00a20	05		 DB	 5
  00a21	05		 DB	 5
  00a22	01		 DB	 1
  00a23	02		 DB	 2
  00a24	05		 DB	 5
  00a25	05		 DB	 5
  00a26	05		 DB	 5
  00a27	05		 DB	 5
  00a28	02		 DB	 2
  00a29	05		 DB	 5
  00a2a	05		 DB	 5
  00a2b	05		 DB	 5
  00a2c	05		 DB	 5
  00a2d	05		 DB	 5
  00a2e	05		 DB	 5
  00a2f	03		 DB	 3
  00a30	05		 DB	 5
  00a31	05		 DB	 5
  00a32	04		 DB	 4
  00a33	05		 DB	 5
  00a34	02		 DB	 2
  00a35	05		 DB	 5
  00a36	05		 DB	 5
  00a37	02		 DB	 2
$LN73@PyBytes_Fr@3:
  00a38	00 00 00 00	 DD	 $LN3@PyBytes_Fr@3
  00a3c	00 00 00 00	 DD	 $LN30@PyBytes_Fr@3
  00a40	00 00 00 00	 DD	 $LN29@PyBytes_Fr@3
  00a44	00 00 00 00	 DD	 $LN19@PyBytes_Fr@3
  00a48	00 00 00 00	 DD	 $LN7@PyBytes_Fr@3
  00a4c	00 00 00 00	 DD	 $LN17@PyBytes_Fr@3
  00a50	00 00 00 00	 DD	 $LN24@PyBytes_Fr@3
  00a54	00 00 00 00	 DD	 $LN18@PyBytes_Fr@3
  00a58	00 00 00 00	 DD	 $LN2@PyBytes_Fr@3
$LN72@PyBytes_Fr@3:
  00a5c	00		 DB	 0
  00a5d	08		 DB	 8
  00a5e	08		 DB	 8
  00a5f	08		 DB	 8
  00a60	08		 DB	 8
  00a61	08		 DB	 8
  00a62	08		 DB	 8
  00a63	08		 DB	 8
  00a64	08		 DB	 8
  00a65	08		 DB	 8
  00a66	08		 DB	 8
  00a67	08		 DB	 8
  00a68	08		 DB	 8
  00a69	08		 DB	 8
  00a6a	08		 DB	 8
  00a6b	08		 DB	 8
  00a6c	08		 DB	 8
  00a6d	08		 DB	 8
  00a6e	08		 DB	 8
  00a6f	08		 DB	 8
  00a70	08		 DB	 8
  00a71	08		 DB	 8
  00a72	08		 DB	 8
  00a73	08		 DB	 8
  00a74	08		 DB	 8
  00a75	08		 DB	 8
  00a76	08		 DB	 8
  00a77	08		 DB	 8
  00a78	08		 DB	 8
  00a79	08		 DB	 8
  00a7a	08		 DB	 8
  00a7b	08		 DB	 8
  00a7c	08		 DB	 8
  00a7d	08		 DB	 8
  00a7e	08		 DB	 8
  00a7f	08		 DB	 8
  00a80	08		 DB	 8
  00a81	08		 DB	 8
  00a82	08		 DB	 8
  00a83	08		 DB	 8
  00a84	08		 DB	 8
  00a85	08		 DB	 8
  00a86	08		 DB	 8
  00a87	08		 DB	 8
  00a88	08		 DB	 8
  00a89	08		 DB	 8
  00a8a	08		 DB	 8
  00a8b	08		 DB	 8
  00a8c	08		 DB	 8
  00a8d	08		 DB	 8
  00a8e	08		 DB	 8
  00a8f	08		 DB	 8
  00a90	08		 DB	 8
  00a91	08		 DB	 8
  00a92	08		 DB	 8
  00a93	08		 DB	 8
  00a94	08		 DB	 8
  00a95	08		 DB	 8
  00a96	08		 DB	 8
  00a97	08		 DB	 8
  00a98	08		 DB	 8
  00a99	08		 DB	 8
  00a9a	01		 DB	 1
  00a9b	02		 DB	 2
  00a9c	08		 DB	 8
  00a9d	08		 DB	 8
  00a9e	08		 DB	 8
  00a9f	08		 DB	 8
  00aa0	03		 DB	 3
  00aa1	08		 DB	 8
  00aa2	08		 DB	 8
  00aa3	08		 DB	 8
  00aa4	08		 DB	 8
  00aa5	08		 DB	 8
  00aa6	08		 DB	 8
  00aa7	04		 DB	 4
  00aa8	08		 DB	 8
  00aa9	08		 DB	 8
  00aaa	05		 DB	 5
  00aab	08		 DB	 8
  00aac	06		 DB	 6
  00aad	08		 DB	 8
  00aae	08		 DB	 8
  00aaf	07		 DB	 7
PyBytes_FromFormatV ENDP
_TEXT	ENDS
PUBLIC	PyBytes_FromFormat
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBytes_FromFormat DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$PyBytes_FromFormat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_FromFormat DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyBytes_FromFormat
_TEXT	SEGMENT
vargs$ = 32
ret$ = 40
format$ = 64
PyBytes_FromFormat PROC					; COMDAT

; 364  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 365  :     PyObject* ret;
; 366  :     va_list vargs;
; 367  : 
; 368  : #ifdef HAVE_STDARG_PROTOTYPES
; 369  :     va_start(vargs, format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR format$[rsp+8]
  0001d	48 89 44 24 20	 mov	 QWORD PTR vargs$[rsp], rax

; 370  : #else
; 371  :     va_start(vargs);
; 372  : #endif
; 373  :     ret = PyBytes_FromFormatV(format, vargs);

  00022	48 8b 54 24 20	 mov	 rdx, QWORD PTR vargs$[rsp]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR format$[rsp]
  0002c	e8 00 00 00 00	 call	 PyBytes_FromFormatV
  00031	48 89 44 24 28	 mov	 QWORD PTR ret$[rsp], rax

; 374  :     va_end(vargs);

  00036	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR vargs$[rsp], 0

; 375  :     return ret;

  0003f	48 8b 44 24 28	 mov	 rax, QWORD PTR ret$[rsp]

; 376  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
PyBytes_FromFormat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_dealloc DD imagerel bytes_dealloc
	DD	imagerel bytes_dealloc+34
	DD	imagerel $unwind$bytes_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_dealloc
_TEXT	SEGMENT
op$ = 48
bytes_dealloc PROC					; COMDAT

; 380  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 381  :     Py_TYPE(op)->tp_free(op);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00017	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 382  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
bytes_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@GCJJKEKA@decoding?5error?$DL?5unknown?5error?5ha@ ; `string'
PUBLIC	??_C@_06GDPEBLPA@ignore?$AA@			; `string'
PUBLIC	??_C@_0CB@MDFFHBMF@invalid?5?2x?5escape?5at?5position?5?$CFd@ ; `string'
PUBLIC	??_C@_06OLFOGHEN@strict?$AA@			; `string'
PUBLIC	??_C@_0BF@FNHLBDLO@Trailing?5?2?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_1CC@GEFILGEM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	_Py_DecRef
PUBLIC	PyBytes_DecodeEscape
EXTRN	PyErr_Format:PROC
EXTRN	strcmp:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyUnicode_AsEncodedString:PROC
EXTRN	PyUnicode_DecodeUTF8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBytes_DecodeEscape DD imagerel $LN65
	DD	imagerel $LN65+2623
	DD	imagerel $unwind$PyBytes_DecodeEscape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_DecodeEscape DD 021b01H
	DD	017011bH
xdata	ENDS
;	COMDAT ??_C@_0DE@GCJJKEKA@decoding?5error?$DL?5unknown?5error?5ha@
CONST	SEGMENT
??_C@_0DE@GCJJKEKA@decoding?5error?$DL?5unknown?5error?5ha@ DB 'decoding '
	DB	'error; unknown error handling code: %.400s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GDPEBLPA@ignore?$AA@
CONST	SEGMENT
??_C@_06GDPEBLPA@ignore?$AA@ DB 'ignore', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MDFFHBMF@invalid?5?2x?5escape?5at?5position?5?$CFd@
CONST	SEGMENT
??_C@_0CB@MDFFHBMF@invalid?5?2x?5escape?5at?5position?5?$CFd@ DB 'invalid'
	DB	' \x escape at position %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict?$AA@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict?$AA@ DB 'strict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FNHLBDLO@Trailing?5?2?5in?5string?$AA@
CONST	SEGMENT
??_C@_0BF@FNHLBDLO@Trailing?5?2?5in?5string?$AA@ DB 'Trailing \ in string'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@GEFILGEM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@GEFILGEM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'w', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBytes_DecodeEscape
_TEXT	SEGMENT
p$ = 32
v$ = 40
newlen$ = 48
end$ = 56
buf$ = 64
c$ = 72
w$20826 = 80
u$20825 = 88
rn$20829 = 96
r$20827 = 104
t$20828 = 112
t_$20851 = 120
s_$20853 = 128
i_$20849 = 136
n_$20850 = 144
x$20886 = 152
tv66 = 160
tv175 = 168
tv176 = 172
s$ = 192
len$ = 200
errors$ = 208
unicode$ = 216
recode_encoding$ = 224
PyBytes_DecodeEscape PROC				; COMDAT

; 394  : {

$LN65:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 395  :     int c;
; 396  :     char *p, *buf;
; 397  :     const char *end;
; 398  :     PyObject *v;
; 399  :     Py_ssize_t newlen = recode_encoding ? 4*len:len;

  0001b	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR recode_encoding$[rsp], 0
  00024	74 16		 je	 SHORT $LN57@PyBytes_De
  00026	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0002e	48 c1 e0 02	 shl	 rax, 2
  00032	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv66[rsp], rax
  0003a	eb 10		 jmp	 SHORT $LN58@PyBytes_De
$LN57@PyBytes_De:
  0003c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00044	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv66[rsp], rax
$LN58@PyBytes_De:
  0004c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv66[rsp]
  00054	48 89 44 24 30	 mov	 QWORD PTR newlen$[rsp], rax

; 400  :     v = PyBytes_FromStringAndSize((char *)NULL, newlen);

  00059	48 8b 54 24 30	 mov	 rdx, QWORD PTR newlen$[rsp]
  0005e	33 c9		 xor	 ecx, ecx
  00060	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00065	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 401  :     if (v == NULL)

  0006a	48 83 7c 24 28
	00		 cmp	 QWORD PTR v$[rsp], 0
  00070	75 07		 jne	 SHORT $LN54@PyBytes_De

; 402  :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	e9 14 09 00 00	 jmp	 $LN55@PyBytes_De
$LN54@PyBytes_De:

; 403  :     p = buf = PyBytes_AsString(v);

  00079	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  0007e	e8 00 00 00 00	 call	 PyBytes_AsString
  00083	48 89 44 24 40	 mov	 QWORD PTR buf$[rsp], rax
  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  0008d	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 404  :     end = s + len;

  00092	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0009a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000a2	48 03 c8	 add	 rcx, rax
  000a5	48 8b c1	 mov	 rax, rcx
  000a8	48 89 44 24 38	 mov	 QWORD PTR end$[rsp], rax
$LN62@PyBytes_De:
$LN53@PyBytes_De:

; 405  :     while (s < end) {

  000ad	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  000b2	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR s$[rsp], rax
  000ba	0f 83 86 08 00
	00		 jae	 $LN52@PyBytes_De

; 406  :         if (*s != '\\') {

  000c0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000c8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000cb	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  000ce	0f 84 a8 02 00
	00		 je	 $LN51@PyBytes_De
$non_esc$20823:

; 407  :           non_esc:
; 408  :             if (recode_encoding && (*s & 0x80)) {

  000d4	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR recode_encoding$[rsp], 0
  000dd	0f 84 62 02 00
	00		 je	 $LN50@PyBytes_De
  000e3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000eb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ee	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000f3	85 c0		 test	 eax, eax
  000f5	0f 84 4a 02 00
	00		 je	 $LN50@PyBytes_De

; 409  :                 PyObject *u, *w;
; 410  :                 char *r;
; 411  :                 const char* t;
; 412  :                 Py_ssize_t rn;
; 413  :                 t = s;

  000fb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00103	48 89 44 24 70	 mov	 QWORD PTR t$20828[rsp], rax
$LN49@PyBytes_De:

; 414  :                 /* Decode non-ASCII bytes as UTF-8. */
; 415  :                 while (t < end && (*t & 0x80)) t++;

  00108	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  0010d	48 39 44 24 70	 cmp	 QWORD PTR t$20828[rsp], rax
  00112	73 20		 jae	 SHORT $LN48@PyBytes_De
  00114	48 8b 44 24 70	 mov	 rax, QWORD PTR t$20828[rsp]
  00119	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0011c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00121	85 c0		 test	 eax, eax
  00123	74 0f		 je	 SHORT $LN48@PyBytes_De
  00125	48 8b 44 24 70	 mov	 rax, QWORD PTR t$20828[rsp]
  0012a	48 ff c0	 inc	 rax
  0012d	48 89 44 24 70	 mov	 QWORD PTR t$20828[rsp], rax
  00132	eb d4		 jmp	 SHORT $LN49@PyBytes_De
$LN48@PyBytes_De:

; 416  :                 u = PyUnicode_DecodeUTF8(s, t - s, errors);

  00134	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0013c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR t$20828[rsp]
  00141	48 2b c8	 sub	 rcx, rax
  00144	48 8b c1	 mov	 rax, rcx
  00147	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR errors$[rsp]
  0014f	48 8b d0	 mov	 rdx, rax
  00152	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0015a	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  0015f	48 89 44 24 58	 mov	 QWORD PTR u$20825[rsp], rax

; 417  :                 if(!u) goto failed;

  00164	48 83 7c 24 58
	00		 cmp	 QWORD PTR u$20825[rsp], 0
  0016a	75 05		 jne	 SHORT $LN47@PyBytes_De
  0016c	e9 10 08 00 00	 jmp	 $failed$20834
$LN47@PyBytes_De:

; 418  : 
; 419  :                 /* Recode them in target encoding. */
; 420  :                 w = PyUnicode_AsEncodedString(
; 421  :                     u, recode_encoding, errors);

  00171	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR errors$[rsp]
  00179	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR recode_encoding$[rsp]
  00181	48 8b 4c 24 58	 mov	 rcx, QWORD PTR u$20825[rsp]
  00186	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString
  0018b	48 89 44 24 50	 mov	 QWORD PTR w$20826[rsp], rax

; 422  :                 Py_DECREF(u);

  00190	48 8b 4c 24 58	 mov	 rcx, QWORD PTR u$20825[rsp]
  00195	e8 00 00 00 00	 call	 _Py_DecRef

; 423  :                 if (!w)                 goto failed;

  0019a	48 83 7c 24 50
	00		 cmp	 QWORD PTR w$20826[rsp], 0
  001a0	75 05		 jne	 SHORT $LN46@PyBytes_De
  001a2	e9 da 07 00 00	 jmp	 $failed$20834
$LN46@PyBytes_De:

; 424  : 
; 425  :                 /* Append bytes to output buffer. */
; 426  :                 assert(PyBytes_Check(w));

  001a7	48 8b 44 24 50	 mov	 rax, QWORD PTR w$20826[rsp]
  001ac	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001b0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001b6	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001bb	85 c0		 test	 eax, eax
  001bd	75 1c		 jne	 SHORT $LN59@PyBytes_De
  001bf	41 b8 aa 01 00
	00		 mov	 r8d, 426		; 000001aaH
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@GEFILGEM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d9	33 c0		 xor	 eax, eax
$LN59@PyBytes_De:

; 427  :                 r = PyBytes_AS_STRING(w);

  001db	48 8b 44 24 50	 mov	 rax, QWORD PTR w$20826[rsp]
  001e0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001e4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001ea	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001ef	85 c0		 test	 eax, eax
  001f1	75 1c		 jne	 SHORT $LN60@PyBytes_De
  001f3	41 b8 ab 01 00
	00		 mov	 r8d, 427		; 000001abH
  001f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00200	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@GEFILGEM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
  00207	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0020d	33 c0		 xor	 eax, eax
$LN60@PyBytes_De:
  0020f	48 8b 44 24 50	 mov	 rax, QWORD PTR w$20826[rsp]
  00214	48 83 c0 78	 add	 rax, 120		; 00000078H
  00218	48 89 44 24 68	 mov	 QWORD PTR r$20827[rsp], rax

; 428  :                 rn = PyBytes_GET_SIZE(w);

  0021d	48 8b 44 24 50	 mov	 rax, QWORD PTR w$20826[rsp]
  00222	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00226	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0022c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00231	85 c0		 test	 eax, eax
  00233	75 1c		 jne	 SHORT $LN61@PyBytes_De
  00235	41 b8 ac 01 00
	00		 mov	 r8d, 428		; 000001acH
  0023b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@GEFILGEM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
  00249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0024f	33 c0		 xor	 eax, eax
$LN61@PyBytes_De:
  00251	48 8b 44 24 50	 mov	 rax, QWORD PTR w$20826[rsp]
  00256	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0025a	48 89 44 24 60	 mov	 QWORD PTR rn$20829[rsp], rax
$LN45@PyBytes_De:

; 429  :                 Py_MEMCPY(p, r, rn);

  0025f	48 8b 44 24 60	 mov	 rax, QWORD PTR rn$20829[rsp]
  00264	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR n_$20850[rsp], rax
  0026c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00271	48 89 44 24 78	 mov	 QWORD PTR t_$20851[rsp], rax
  00276	48 8b 44 24 68	 mov	 rax, QWORD PTR r$20827[rsp]
  0027b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s_$20853[rsp], rax
  00283	48 83 bc 24 90
	00 00 00 10	 cmp	 QWORD PTR n_$20850[rsp], 16
  0028c	72 1c		 jb	 SHORT $LN42@PyBytes_De
  0028e	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR n_$20850[rsp]
  00296	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s_$20853[rsp]
  0029e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR t_$20851[rsp]
  002a3	e8 00 00 00 00	 call	 memcpy
  002a8	eb 63		 jmp	 SHORT $LN41@PyBytes_De
$LN42@PyBytes_De:
  002aa	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$20849[rsp], 0
  002b6	eb 13		 jmp	 SHORT $LN40@PyBytes_De
$LN39@PyBytes_De:
  002b8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR i_$20849[rsp]
  002c0	48 ff c0	 inc	 rax
  002c3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR i_$20849[rsp], rax
$LN40@PyBytes_De:
  002cb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR n_$20850[rsp]
  002d3	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR i_$20849[rsp], rax
  002db	73 30		 jae	 SHORT $LN38@PyBytes_De
  002dd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR i_$20849[rsp]
  002e5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR t_$20851[rsp]
  002ea	48 03 c8	 add	 rcx, rax
  002ed	48 8b c1	 mov	 rax, rcx
  002f0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR i_$20849[rsp]
  002f8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s_$20853[rsp]
  00300	48 03 d1	 add	 rdx, rcx
  00303	48 8b ca	 mov	 rcx, rdx
  00306	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00309	88 08		 mov	 BYTE PTR [rax], cl
  0030b	eb ab		 jmp	 SHORT $LN39@PyBytes_De
$LN38@PyBytes_De:
$LN41@PyBytes_De:
  0030d	33 c0		 xor	 eax, eax
  0030f	85 c0		 test	 eax, eax
  00311	0f 85 48 ff ff
	ff		 jne	 $LN45@PyBytes_De

; 430  :                 p += rn;

  00317	48 8b 44 24 60	 mov	 rax, QWORD PTR rn$20829[rsp]
  0031c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00321	48 03 c8	 add	 rcx, rax
  00324	48 8b c1	 mov	 rax, rcx
  00327	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 431  :                 Py_DECREF(w);

  0032c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR w$20826[rsp]
  00331	e8 00 00 00 00	 call	 _Py_DecRef

; 432  :                 s = t;

  00336	48 8b 44 24 70	 mov	 rax, QWORD PTR t$20828[rsp]
  0033b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 433  :             } else {

  00343	eb 32		 jmp	 SHORT $LN37@PyBytes_De
$LN50@PyBytes_De:

; 434  :                 *p++ = *s++;

  00345	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0034a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00352	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00355	88 08		 mov	 BYTE PTR [rax], cl
  00357	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0035c	48 ff c0	 inc	 rax
  0035f	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00364	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0036c	48 ff c0	 inc	 rax
  0036f	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN37@PyBytes_De:

; 435  :             }
; 436  :             continue;

  00377	e9 31 fd ff ff	 jmp	 $LN53@PyBytes_De
$LN51@PyBytes_De:

; 437  :         }
; 438  :         s++;

  0037c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00384	48 ff c0	 inc	 rax
  00387	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 439  :         if (s==end) {

  0038f	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  00394	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR s$[rsp], rax
  0039c	75 18		 jne	 SHORT $LN36@PyBytes_De

; 440  :             PyErr_SetString(PyExc_ValueError,
; 441  :                             "Trailing \\ in string");

  0039e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@FNHLBDLO@Trailing?5?2?5in?5string?$AA@
  003a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  003ac	e8 00 00 00 00	 call	 PyErr_SetString

; 442  :             goto failed;

  003b1	e9 cb 05 00 00	 jmp	 $failed$20834
$LN36@PyBytes_De:

; 443  :         }
; 444  :         switch (*s++) {

  003b6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003be	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003c1	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv175[rsp], eax
  003c8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003d0	48 ff c0	 inc	 rax
  003d3	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
  003db	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv175[rsp]
  003e2	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  003e9	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv176[rsp]
  003f0	83 e8 0a	 sub	 eax, 10
  003f3	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  003fa	83 bc 24 ac 00
	00 00 6e	 cmp	 DWORD PTR tv176[rsp], 110 ; 0000006eH
  00402	0f 87 0c 05 00
	00		 ja	 $LN2@PyBytes_De
  00408	48 63 84 24 ac
	00 00 00	 movsxd	 rax, DWORD PTR tv176[rsp]
  00410	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00417	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN63@PyBytes_De[rcx+rax]
  0041f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN64@PyBytes_De[rcx+rax*4]
  00426	48 03 c1	 add	 rax, rcx
  00429	ff e0		 jmp	 rax
$LN33@PyBytes_De:

; 445  :         /* XXX This assumes ASCII! */
; 446  :         case '\n': break;

  0042b	e9 11 05 00 00	 jmp	 $LN34@PyBytes_De
$LN32@PyBytes_De:

; 447  :         case '\\': *p++ = '\\'; break;

  00430	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00435	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  00438	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0043d	48 ff c0	 inc	 rax
  00440	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00445	e9 f7 04 00 00	 jmp	 $LN34@PyBytes_De
$LN31@PyBytes_De:

; 448  :         case '\'': *p++ = '\''; break;

  0044a	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0044f	c6 00 27	 mov	 BYTE PTR [rax], 39	; 00000027H
  00452	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00457	48 ff c0	 inc	 rax
  0045a	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0045f	e9 dd 04 00 00	 jmp	 $LN34@PyBytes_De
$LN30@PyBytes_De:

; 449  :         case '\"': *p++ = '\"'; break;

  00464	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00469	c6 00 22	 mov	 BYTE PTR [rax], 34	; 00000022H
  0046c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00471	48 ff c0	 inc	 rax
  00474	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00479	e9 c3 04 00 00	 jmp	 $LN34@PyBytes_De
$LN29@PyBytes_De:

; 450  :         case 'b': *p++ = '\b'; break;

  0047e	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00483	c6 00 08	 mov	 BYTE PTR [rax], 8
  00486	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0048b	48 ff c0	 inc	 rax
  0048e	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00493	e9 a9 04 00 00	 jmp	 $LN34@PyBytes_De
$LN28@PyBytes_De:

; 451  :         case 'f': *p++ = '\014'; break; /* FF */

  00498	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0049d	c6 00 0c	 mov	 BYTE PTR [rax], 12
  004a0	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004a5	48 ff c0	 inc	 rax
  004a8	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  004ad	e9 8f 04 00 00	 jmp	 $LN34@PyBytes_De
$LN27@PyBytes_De:

; 452  :         case 't': *p++ = '\t'; break;

  004b2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004b7	c6 00 09	 mov	 BYTE PTR [rax], 9
  004ba	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004bf	48 ff c0	 inc	 rax
  004c2	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  004c7	e9 75 04 00 00	 jmp	 $LN34@PyBytes_De
$LN26@PyBytes_De:

; 453  :         case 'n': *p++ = '\n'; break;

  004cc	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004d1	c6 00 0a	 mov	 BYTE PTR [rax], 10
  004d4	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004d9	48 ff c0	 inc	 rax
  004dc	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  004e1	e9 5b 04 00 00	 jmp	 $LN34@PyBytes_De
$LN25@PyBytes_De:

; 454  :         case 'r': *p++ = '\r'; break;

  004e6	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004eb	c6 00 0d	 mov	 BYTE PTR [rax], 13
  004ee	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004f3	48 ff c0	 inc	 rax
  004f6	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  004fb	e9 41 04 00 00	 jmp	 $LN34@PyBytes_De
$LN24@PyBytes_De:

; 455  :         case 'v': *p++ = '\013'; break; /* VT */

  00500	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00505	c6 00 0b	 mov	 BYTE PTR [rax], 11
  00508	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0050d	48 ff c0	 inc	 rax
  00510	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00515	e9 27 04 00 00	 jmp	 $LN34@PyBytes_De
$LN23@PyBytes_De:

; 456  :         case 'a': *p++ = '\007'; break; /* BEL, not classic C */

  0051a	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0051f	c6 00 07	 mov	 BYTE PTR [rax], 7
  00522	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00527	48 ff c0	 inc	 rax
  0052a	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0052f	e9 0d 04 00 00	 jmp	 $LN34@PyBytes_De
$LN22@PyBytes_De:

; 457  :         case '0': case '1': case '2': case '3':
; 458  :         case '4': case '5': case '6': case '7':
; 459  :             c = s[-1] - '0';

  00534	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0053c	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  00540	83 e8 30	 sub	 eax, 48			; 00000030H
  00543	89 44 24 48	 mov	 DWORD PTR c$[rsp], eax

; 460  :             if (s < end && '0' <= *s && *s <= '7') {

  00547	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  0054c	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR s$[rsp], rax
  00554	0f 83 ab 00 00
	00		 jae	 $LN21@PyBytes_De
  0055a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00562	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00565	83 f8 30	 cmp	 eax, 48			; 00000030H
  00568	0f 8c 97 00 00
	00		 jl	 $LN21@PyBytes_De
  0056e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00576	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00579	83 f8 37	 cmp	 eax, 55			; 00000037H
  0057c	0f 8f 83 00 00
	00		 jg	 $LN21@PyBytes_De

; 461  :                 c = (c<<3) + *s++ - '0';

  00582	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0058a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0058d	8b 4c 24 48	 mov	 ecx, DWORD PTR c$[rsp]
  00591	8d 44 c8 d0	 lea	 eax, DWORD PTR [rax+rcx*8-48]
  00595	89 44 24 48	 mov	 DWORD PTR c$[rsp], eax
  00599	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005a1	48 ff c0	 inc	 rax
  005a4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 462  :                 if (s < end && '0' <= *s && *s <= '7')

  005ac	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  005b1	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR s$[rsp], rax
  005b9	73 4a		 jae	 SHORT $LN20@PyBytes_De
  005bb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005c3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005c6	83 f8 30	 cmp	 eax, 48			; 00000030H
  005c9	7c 3a		 jl	 SHORT $LN20@PyBytes_De
  005cb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005d3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005d6	83 f8 37	 cmp	 eax, 55			; 00000037H
  005d9	7f 2a		 jg	 SHORT $LN20@PyBytes_De

; 463  :                     c = (c<<3) + *s++ - '0';

  005db	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005e3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005e6	8b 4c 24 48	 mov	 ecx, DWORD PTR c$[rsp]
  005ea	8d 44 c8 d0	 lea	 eax, DWORD PTR [rax+rcx*8-48]
  005ee	89 44 24 48	 mov	 DWORD PTR c$[rsp], eax
  005f2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005fa	48 ff c0	 inc	 rax
  005fd	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN20@PyBytes_De:
$LN21@PyBytes_De:

; 464  :             }
; 465  :             *p++ = c;

  00605	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0060a	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR c$[rsp]
  0060f	88 08		 mov	 BYTE PTR [rax], cl
  00611	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00616	48 ff c0	 inc	 rax
  00619	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 466  :             break;

  0061e	e9 1e 03 00 00	 jmp	 $LN34@PyBytes_De
$LN19@PyBytes_De:

; 467  :         case 'x':
; 468  :             if (s+1 < end && Py_ISXDIGIT(s[0]) && Py_ISXDIGIT(s[1])) {

  00623	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0062b	48 ff c0	 inc	 rax
  0062e	48 3b 44 24 38	 cmp	 rax, QWORD PTR end$[rsp]
  00633	0f 83 ca 01 00
	00		 jae	 $LN18@PyBytes_De
  00639	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00641	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00644	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00649	0f b6 c0	 movzx	 eax, al
  0064c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00653	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00656	83 e0 10	 and	 eax, 16
  00659	85 c0		 test	 eax, eax
  0065b	0f 84 a2 01 00
	00		 je	 $LN18@PyBytes_De
  00661	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00669	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0066d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00672	0f b6 c0	 movzx	 eax, al
  00675	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0067c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0067f	83 e0 10	 and	 eax, 16
  00682	85 c0		 test	 eax, eax
  00684	0f 84 79 01 00
	00		 je	 $LN18@PyBytes_De

; 469  :                 unsigned int x = 0;

  0068a	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR x$20886[rsp], 0

; 470  :                 c = Py_CHARMASK(*s);

  00695	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0069d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  006a0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006a5	0f b6 c0	 movzx	 eax, al
  006a8	89 44 24 48	 mov	 DWORD PTR c$[rsp], eax

; 471  :                 s++;

  006ac	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006b4	48 ff c0	 inc	 rax
  006b7	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 472  :                 if (Py_ISDIGIT(c))

  006bf	8b 44 24 48	 mov	 eax, DWORD PTR c$[rsp]
  006c3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006c8	0f b6 c0	 movzx	 eax, al
  006cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  006d2	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  006d5	83 e0 04	 and	 eax, 4
  006d8	85 c0		 test	 eax, eax
  006da	74 10		 je	 SHORT $LN17@PyBytes_De

; 473  :                     x = c - '0';

  006dc	8b 44 24 48	 mov	 eax, DWORD PTR c$[rsp]
  006e0	83 e8 30	 sub	 eax, 48			; 00000030H
  006e3	89 84 24 98 00
	00 00		 mov	 DWORD PTR x$20886[rsp], eax
  006ea	eb 3b		 jmp	 SHORT $LN16@PyBytes_De
$LN17@PyBytes_De:

; 474  :                 else if (Py_ISLOWER(c))

  006ec	8b 44 24 48	 mov	 eax, DWORD PTR c$[rsp]
  006f0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006f5	0f b6 c0	 movzx	 eax, al
  006f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  006ff	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00702	83 e0 01	 and	 eax, 1
  00705	85 c0		 test	 eax, eax
  00707	74 10		 je	 SHORT $LN15@PyBytes_De

; 475  :                     x = 10 + c - 'a';

  00709	8b 44 24 48	 mov	 eax, DWORD PTR c$[rsp]
  0070d	83 e8 57	 sub	 eax, 87			; 00000057H
  00710	89 84 24 98 00
	00 00		 mov	 DWORD PTR x$20886[rsp], eax

; 476  :                 else

  00717	eb 0e		 jmp	 SHORT $LN14@PyBytes_De
$LN15@PyBytes_De:

; 477  :                     x = 10 + c - 'A';

  00719	8b 44 24 48	 mov	 eax, DWORD PTR c$[rsp]
  0071d	83 e8 37	 sub	 eax, 55			; 00000037H
  00720	89 84 24 98 00
	00 00		 mov	 DWORD PTR x$20886[rsp], eax
$LN14@PyBytes_De:
$LN16@PyBytes_De:

; 478  :                 x = x << 4;

  00727	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$20886[rsp]
  0072e	c1 e0 04	 shl	 eax, 4
  00731	89 84 24 98 00
	00 00		 mov	 DWORD PTR x$20886[rsp], eax

; 479  :                 c = Py_CHARMASK(*s);

  00738	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00740	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00743	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00748	0f b6 c0	 movzx	 eax, al
  0074b	89 44 24 48	 mov	 DWORD PTR c$[rsp], eax

; 480  :                 s++;

  0074f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00757	48 ff c0	 inc	 rax
  0075a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 481  :                 if (Py_ISDIGIT(c))

  00762	8b 44 24 48	 mov	 eax, DWORD PTR c$[rsp]
  00766	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0076b	0f b6 c0	 movzx	 eax, al
  0076e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00775	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00778	83 e0 04	 and	 eax, 4
  0077b	85 c0		 test	 eax, eax
  0077d	74 18		 je	 SHORT $LN13@PyBytes_De

; 482  :                     x += c - '0';

  0077f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$20886[rsp]
  00786	8b 4c 24 48	 mov	 ecx, DWORD PTR c$[rsp]
  0078a	8d 44 08 d0	 lea	 eax, DWORD PTR [rax+rcx-48]
  0078e	89 84 24 98 00
	00 00		 mov	 DWORD PTR x$20886[rsp], eax
  00795	eb 4b		 jmp	 SHORT $LN12@PyBytes_De
$LN13@PyBytes_De:

; 483  :                 else if (Py_ISLOWER(c))

  00797	8b 44 24 48	 mov	 eax, DWORD PTR c$[rsp]
  0079b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007a0	0f b6 c0	 movzx	 eax, al
  007a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  007aa	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  007ad	83 e0 01	 and	 eax, 1
  007b0	85 c0		 test	 eax, eax
  007b2	74 18		 je	 SHORT $LN11@PyBytes_De

; 484  :                     x += 10 + c - 'a';

  007b4	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$20886[rsp]
  007bb	8b 4c 24 48	 mov	 ecx, DWORD PTR c$[rsp]
  007bf	8d 44 08 a9	 lea	 eax, DWORD PTR [rax+rcx-87]
  007c3	89 84 24 98 00
	00 00		 mov	 DWORD PTR x$20886[rsp], eax

; 485  :                 else

  007ca	eb 16		 jmp	 SHORT $LN10@PyBytes_De
$LN11@PyBytes_De:

; 486  :                     x += 10 + c - 'A';

  007cc	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$20886[rsp]
  007d3	8b 4c 24 48	 mov	 ecx, DWORD PTR c$[rsp]
  007d7	8d 44 08 c9	 lea	 eax, DWORD PTR [rax+rcx-55]
  007db	89 84 24 98 00
	00 00		 mov	 DWORD PTR x$20886[rsp], eax
$LN10@PyBytes_De:
$LN12@PyBytes_De:

; 487  :                 *p++ = x;

  007e2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  007e7	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR x$20886[rsp]
  007ef	88 08		 mov	 BYTE PTR [rax], cl
  007f1	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  007f6	48 ff c0	 inc	 rax
  007f9	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 488  :                 break;

  007fe	e9 3e 01 00 00	 jmp	 $LN34@PyBytes_De
$LN18@PyBytes_De:

; 489  :             }
; 490  :             if (!errors || strcmp(errors, "strict") == 0) {

  00803	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR errors$[rsp], 0
  0080c	74 18		 je	 SHORT $LN8@PyBytes_De
  0080e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00815	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR errors$[rsp]
  0081d	e8 00 00 00 00	 call	 strcmp
  00822	85 c0		 test	 eax, eax
  00824	75 3d		 jne	 SHORT $LN9@PyBytes_De
$LN8@PyBytes_De:

; 491  :                 PyErr_Format(PyExc_ValueError,
; 492  :                              "invalid \\x escape at position %d",
; 493  :                              s - 2 - (end - len));

  00826	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0082e	48 83 e8 02	 sub	 rax, 2
  00832	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  0083a	48 8b 54 24 38	 mov	 rdx, QWORD PTR end$[rsp]
  0083f	48 2b d1	 sub	 rdx, rcx
  00842	48 8b ca	 mov	 rcx, rdx
  00845	48 2b c1	 sub	 rax, rcx
  00848	4c 8b c0	 mov	 r8, rax
  0084b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@MDFFHBMF@invalid?5?2x?5escape?5at?5position?5?$CFd@
  00852	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00859	e8 00 00 00 00	 call	 PyErr_Format

; 494  :                 goto failed;

  0085e	e9 1e 01 00 00	 jmp	 $failed$20834
$LN9@PyBytes_De:

; 495  :             }
; 496  :             if (strcmp(errors, "replace") == 0) {

  00863	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07CLEHDIEJ@replace?$AA@
  0086a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR errors$[rsp]
  00872	e8 00 00 00 00	 call	 strcmp
  00877	85 c0		 test	 eax, eax
  00879	75 17		 jne	 SHORT $LN7@PyBytes_De

; 497  :                 *p++ = '?';

  0087b	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00880	c6 00 3f	 mov	 BYTE PTR [rax], 63	; 0000003fH
  00883	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00888	48 ff c0	 inc	 rax
  0088b	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00890	eb 3a		 jmp	 SHORT $LN6@PyBytes_De
$LN7@PyBytes_De:

; 498  :             } else if (strcmp(errors, "ignore") == 0)

  00892	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06GDPEBLPA@ignore?$AA@
  00899	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR errors$[rsp]
  008a1	e8 00 00 00 00	 call	 strcmp
  008a6	85 c0		 test	 eax, eax
  008a8	75 02		 jne	 SHORT $LN5@PyBytes_De

; 499  :                 /* do nothing */;
; 500  :             else {

  008aa	eb 20		 jmp	 SHORT $LN4@PyBytes_De
$LN5@PyBytes_De:

; 501  :                 PyErr_Format(PyExc_ValueError,
; 502  :                              "decoding error; unknown "
; 503  :                              "error handling code: %.400s",
; 504  :                              errors);

  008ac	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR errors$[rsp]
  008b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@GCJJKEKA@decoding?5error?$DL?5unknown?5error?5ha@
  008bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  008c2	e8 00 00 00 00	 call	 PyErr_Format

; 505  :                 goto failed;

  008c7	e9 b5 00 00 00	 jmp	 $failed$20834
$LN4@PyBytes_De:
$LN6@PyBytes_De:

; 506  :             }
; 507  :             /* skip \x */
; 508  :             if (s < end && Py_ISXDIGIT(s[0]))

  008cc	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  008d1	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR s$[rsp], rax
  008d9	73 37		 jae	 SHORT $LN3@PyBytes_De
  008db	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008e3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  008e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008eb	0f b6 c0	 movzx	 eax, al
  008ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  008f5	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  008f8	83 e0 10	 and	 eax, 16
  008fb	85 c0		 test	 eax, eax
  008fd	74 13		 je	 SHORT $LN3@PyBytes_De

; 509  :                 s++; /* and a hexdigit */

  008ff	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00907	48 ff c0	 inc	 rax
  0090a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN3@PyBytes_De:

; 510  :             break;

  00912	eb 2d		 jmp	 SHORT $LN34@PyBytes_De
$LN2@PyBytes_De:

; 511  :         default:
; 512  :             *p++ = '\\';

  00914	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00919	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  0091c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00921	48 ff c0	 inc	 rax
  00924	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 513  :             s--;

  00929	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00931	48 ff c8	 dec	 rax
  00934	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 514  :             goto non_esc; /* an arbitrary number of unescaped

  0093c	e9 93 f7 ff ff	 jmp	 $non_esc$20823
$LN34@PyBytes_De:

; 515  :                              UTF-8 bytes may follow. */
; 516  :         }
; 517  :     }

  00941	e9 67 f7 ff ff	 jmp	 $LN62@PyBytes_De
$LN52@PyBytes_De:

; 518  :     if (p-buf < newlen)

  00946	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  0094b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00950	48 2b c8	 sub	 rcx, rax
  00953	48 8b c1	 mov	 rax, rcx
  00956	48 3b 44 24 30	 cmp	 rax, QWORD PTR newlen$[rsp]
  0095b	7d 1d		 jge	 SHORT $LN1@PyBytes_De

; 519  :         _PyBytes_Resize(&v, p - buf);

  0095d	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  00962	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00967	48 2b c8	 sub	 rcx, rax
  0096a	48 8b c1	 mov	 rax, rcx
  0096d	48 8b d0	 mov	 rdx, rax
  00970	48 8d 4c 24 28	 lea	 rcx, QWORD PTR v$[rsp]
  00975	e8 00 00 00 00	 call	 _PyBytes_Resize
$LN1@PyBytes_De:

; 520  :     return v;

  0097a	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  0097f	eb 0c		 jmp	 SHORT $LN55@PyBytes_De
$failed$20834:

; 521  :   failed:
; 522  :     Py_DECREF(v);

  00981	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  00986	e8 00 00 00 00	 call	 _Py_DecRef

; 523  :     return NULL;

  0098b	33 c0		 xor	 eax, eax
$LN55@PyBytes_De:

; 524  : }

  0098d	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00994	c3		 ret	 0
  00995	0f 1f 00	 npad	 3
$LN64@PyBytes_De:
  00998	00 00 00 00	 DD	 $LN33@PyBytes_De
  0099c	00 00 00 00	 DD	 $LN30@PyBytes_De
  009a0	00 00 00 00	 DD	 $LN31@PyBytes_De
  009a4	00 00 00 00	 DD	 $LN22@PyBytes_De
  009a8	00 00 00 00	 DD	 $LN32@PyBytes_De
  009ac	00 00 00 00	 DD	 $LN23@PyBytes_De
  009b0	00 00 00 00	 DD	 $LN29@PyBytes_De
  009b4	00 00 00 00	 DD	 $LN28@PyBytes_De
  009b8	00 00 00 00	 DD	 $LN26@PyBytes_De
  009bc	00 00 00 00	 DD	 $LN25@PyBytes_De
  009c0	00 00 00 00	 DD	 $LN27@PyBytes_De
  009c4	00 00 00 00	 DD	 $LN24@PyBytes_De
  009c8	00 00 00 00	 DD	 $LN19@PyBytes_De
  009cc	00 00 00 00	 DD	 $LN2@PyBytes_De
$LN63@PyBytes_De:
  009d0	00		 DB	 0
  009d1	0d		 DB	 13
  009d2	0d		 DB	 13
  009d3	0d		 DB	 13
  009d4	0d		 DB	 13
  009d5	0d		 DB	 13
  009d6	0d		 DB	 13
  009d7	0d		 DB	 13
  009d8	0d		 DB	 13
  009d9	0d		 DB	 13
  009da	0d		 DB	 13
  009db	0d		 DB	 13
  009dc	0d		 DB	 13
  009dd	0d		 DB	 13
  009de	0d		 DB	 13
  009df	0d		 DB	 13
  009e0	0d		 DB	 13
  009e1	0d		 DB	 13
  009e2	0d		 DB	 13
  009e3	0d		 DB	 13
  009e4	0d		 DB	 13
  009e5	0d		 DB	 13
  009e6	0d		 DB	 13
  009e7	0d		 DB	 13
  009e8	01		 DB	 1
  009e9	0d		 DB	 13
  009ea	0d		 DB	 13
  009eb	0d		 DB	 13
  009ec	0d		 DB	 13
  009ed	02		 DB	 2
  009ee	0d		 DB	 13
  009ef	0d		 DB	 13
  009f0	0d		 DB	 13
  009f1	0d		 DB	 13
  009f2	0d		 DB	 13
  009f3	0d		 DB	 13
  009f4	0d		 DB	 13
  009f5	0d		 DB	 13
  009f6	03		 DB	 3
  009f7	03		 DB	 3
  009f8	03		 DB	 3
  009f9	03		 DB	 3
  009fa	03		 DB	 3
  009fb	03		 DB	 3
  009fc	03		 DB	 3
  009fd	03		 DB	 3
  009fe	0d		 DB	 13
  009ff	0d		 DB	 13
  00a00	0d		 DB	 13
  00a01	0d		 DB	 13
  00a02	0d		 DB	 13
  00a03	0d		 DB	 13
  00a04	0d		 DB	 13
  00a05	0d		 DB	 13
  00a06	0d		 DB	 13
  00a07	0d		 DB	 13
  00a08	0d		 DB	 13
  00a09	0d		 DB	 13
  00a0a	0d		 DB	 13
  00a0b	0d		 DB	 13
  00a0c	0d		 DB	 13
  00a0d	0d		 DB	 13
  00a0e	0d		 DB	 13
  00a0f	0d		 DB	 13
  00a10	0d		 DB	 13
  00a11	0d		 DB	 13
  00a12	0d		 DB	 13
  00a13	0d		 DB	 13
  00a14	0d		 DB	 13
  00a15	0d		 DB	 13
  00a16	0d		 DB	 13
  00a17	0d		 DB	 13
  00a18	0d		 DB	 13
  00a19	0d		 DB	 13
  00a1a	0d		 DB	 13
  00a1b	0d		 DB	 13
  00a1c	0d		 DB	 13
  00a1d	0d		 DB	 13
  00a1e	0d		 DB	 13
  00a1f	0d		 DB	 13
  00a20	0d		 DB	 13
  00a21	0d		 DB	 13
  00a22	04		 DB	 4
  00a23	0d		 DB	 13
  00a24	0d		 DB	 13
  00a25	0d		 DB	 13
  00a26	0d		 DB	 13
  00a27	05		 DB	 5
  00a28	06		 DB	 6
  00a29	0d		 DB	 13
  00a2a	0d		 DB	 13
  00a2b	0d		 DB	 13
  00a2c	07		 DB	 7
  00a2d	0d		 DB	 13
  00a2e	0d		 DB	 13
  00a2f	0d		 DB	 13
  00a30	0d		 DB	 13
  00a31	0d		 DB	 13
  00a32	0d		 DB	 13
  00a33	0d		 DB	 13
  00a34	08		 DB	 8
  00a35	0d		 DB	 13
  00a36	0d		 DB	 13
  00a37	0d		 DB	 13
  00a38	09		 DB	 9
  00a39	0d		 DB	 13
  00a3a	0a		 DB	 10
  00a3b	0d		 DB	 13
  00a3c	0b		 DB	 11
  00a3d	0d		 DB	 13
  00a3e	0c		 DB	 12
PyBytes_DecodeEscape ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@KABNEBGK@expected?5bytes?0?5?$CF?4200s?5found?$AA@ ; `string'
PUBLIC	PyBytes_Size
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$PyBytes_Size DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$PyBytes_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_Size DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BN@KABNEBGK@expected?5bytes?0?5?$CF?4200s?5found?$AA@
CONST	SEGMENT
??_C@_0BN@KABNEBGK@expected?5bytes?0?5?$CF?4200s?5found?$AA@ DB 'expected'
	DB	' bytes, %.200s found', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBytes_Size
_TEXT	SEGMENT
op$ = 48
PyBytes_Size PROC					; COMDAT

; 531  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 532  :     if (!PyBytes_Check(op)) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 29		 jne	 SHORT $LN1@PyBytes_Si

; 533  :         PyErr_Format(PyExc_TypeError,
; 534  :              "expected bytes, %.200s found", Py_TYPE(op)->tp_name);

  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00026	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002a	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KABNEBGK@expected?5bytes?0?5?$CF?4200s?5found?$AA@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003c	e8 00 00 00 00	 call	 PyErr_Format

; 535  :         return -1;

  00041	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00048	eb 09		 jmp	 SHORT $LN2@PyBytes_Si
$LN1@PyBytes_Si:

; 536  :     }
; 537  :     return Py_SIZE(op);

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0004f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
$LN2@PyBytes_Si:

; 538  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
PyBytes_Size ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBytes_AsString DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$PyBytes_AsString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_AsString DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyBytes_AsString
_TEXT	SEGMENT
op$ = 48
PyBytes_AsString PROC					; COMDAT

; 542  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 543  :     if (!PyBytes_Check(op)) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 24		 jne	 SHORT $LN1@PyBytes_As

; 544  :         PyErr_Format(PyExc_TypeError,
; 545  :              "expected bytes, %.200s found", Py_TYPE(op)->tp_name);

  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00026	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002a	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KABNEBGK@expected?5bytes?0?5?$CF?4200s?5found?$AA@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003c	e8 00 00 00 00	 call	 PyErr_Format

; 546  :         return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	eb 09		 jmp	 SHORT $LN2@PyBytes_As
$LN1@PyBytes_As:

; 547  :     }
; 548  :     return ((PyBytesObject *)op)->ob_sval;

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0004a	48 83 c0 78	 add	 rax, 120		; 00000078H
$LN2@PyBytes_As:

; 549  : }

  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
PyBytes_AsString ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@GADJCNIN@expected?5bytes?5with?5no?5null?$AA@ ; `string'
PUBLIC	??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@ ; `string'
PUBLIC	PyBytes_AsStringAndSize
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBytes_AsStringAndSize DD imagerel $LN11
	DD	imagerel $LN11+377
	DD	imagerel $unwind$PyBytes_AsStringAndSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_AsStringAndSize DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_0BM@GADJCNIN@expected?5bytes?5with?5no?5null?$AA@
CONST	SEGMENT
??_C@_0BM@GADJCNIN@expected?5bytes?5with?5no?5null?$AA@ DB 'expected byte'
	DB	's with no null', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
CONST	SEGMENT
??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@ DB '..\Objects\byte'
	DB	'sobject.c', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBytes_AsStringAndSize
_TEXT	SEGMENT
obj$ = 48
s$ = 56
len$ = 64
PyBytes_AsStringAndSize PROC				; COMDAT

; 555  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 556  :     if (s == NULL) {

  00013	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  00019	75 1b		 jne	 SHORT $LN5@PyBytes_As@2

; 557  :         PyErr_BadInternalCall();

  0001b	ba 2d 02 00 00	 mov	 edx, 557		; 0000022dH
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  00027	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 558  :         return -1;

  0002c	b8 ff ff ff ff	 mov	 eax, -1
  00031	e9 3e 01 00 00	 jmp	 $LN6@PyBytes_As@2
$LN5@PyBytes_As@2:

; 559  :     }
; 560  : 
; 561  :     if (!PyBytes_Check(obj)) {

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR obj$[rsp]
  0003b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00045	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0004a	85 c0		 test	 eax, eax
  0004c	75 2a		 jne	 SHORT $LN4@PyBytes_As@2

; 562  :         PyErr_Format(PyExc_TypeError,
; 563  :              "expected bytes, %.200s found", Py_TYPE(obj)->tp_name);

  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR obj$[rsp]
  00053	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00057	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KABNEBGK@expected?5bytes?0?5?$CF?4200s?5found?$AA@
  00062	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00069	e8 00 00 00 00	 call	 PyErr_Format

; 564  :         return -1;

  0006e	b8 ff ff ff ff	 mov	 eax, -1
  00073	e9 fc 00 00 00	 jmp	 $LN6@PyBytes_As@2
$LN4@PyBytes_As@2:

; 565  :     }
; 566  : 
; 567  :     *s = PyBytes_AS_STRING(obj);

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR obj$[rsp]
  0007d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00081	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00087	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0008c	85 c0		 test	 eax, eax
  0008e	75 1c		 jne	 SHORT $LN8@PyBytes_As@2
  00090	41 b8 37 02 00
	00		 mov	 r8d, 567		; 00000237H
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000aa	33 c0		 xor	 eax, eax
$LN8@PyBytes_As@2:
  000ac	48 8b 44 24 30	 mov	 rax, QWORD PTR obj$[rsp]
  000b1	48 83 c0 78	 add	 rax, 120		; 00000078H
  000b5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  000ba	48 89 01	 mov	 QWORD PTR [rcx], rax

; 568  :     if (len != NULL)

  000bd	48 83 7c 24 40
	00		 cmp	 QWORD PTR len$[rsp], 0
  000c3	74 47		 je	 SHORT $LN3@PyBytes_As@2

; 569  :         *len = PyBytes_GET_SIZE(obj);

  000c5	48 8b 44 24 30	 mov	 rax, QWORD PTR obj$[rsp]
  000ca	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ce	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000d9	85 c0		 test	 eax, eax
  000db	75 1c		 jne	 SHORT $LN9@PyBytes_As@2
  000dd	41 b8 39 02 00
	00		 mov	 r8d, 569		; 00000239H
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f7	33 c0		 xor	 eax, eax
$LN9@PyBytes_As@2:
  000f9	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  000fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR obj$[rsp]
  00103	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00107	48 89 08	 mov	 QWORD PTR [rax], rcx
  0010a	eb 66		 jmp	 SHORT $LN2@PyBytes_As@2
$LN3@PyBytes_As@2:

; 570  :     else if (strlen(*s) != (size_t)PyBytes_GET_SIZE(obj)) {

  0010c	48 8b 44 24 30	 mov	 rax, QWORD PTR obj$[rsp]
  00111	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00115	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0011b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00120	85 c0		 test	 eax, eax
  00122	75 1c		 jne	 SHORT $LN10@PyBytes_As@2
  00124	41 b8 3a 02 00
	00		 mov	 r8d, 570		; 0000023aH
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0013e	33 c0		 xor	 eax, eax
$LN10@PyBytes_As@2:
  00140	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00145	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00148	e8 00 00 00 00	 call	 strlen
  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR obj$[rsp]
  00152	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  00156	74 1a		 je	 SHORT $LN1@PyBytes_As@2

; 571  :         PyErr_SetString(PyExc_TypeError,
; 572  :                         "expected bytes with no null");

  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@GADJCNIN@expected?5bytes?5with?5no?5null?$AA@
  0015f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00166	e8 00 00 00 00	 call	 PyErr_SetString

; 573  :         return -1;

  0016b	b8 ff ff ff ff	 mov	 eax, -1
  00170	eb 02		 jmp	 SHORT $LN6@PyBytes_As@2
$LN1@PyBytes_As@2:
$LN2@PyBytes_As@2:

; 574  :     }
; 575  :     return 0;

  00172	33 c0		 xor	 eax, eax
$LN6@PyBytes_As@2:

; 576  : }

  00174	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00178	c3		 ret	 0
PyBytes_AsStringAndSize ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ ; `string'
EXTRN	_Py_bytes_isspace:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\ctype.h
pdata	SEGMENT
$pdata$stringlib_isspace DD imagerel stringlib_isspace
	DD	imagerel stringlib_isspace+144
	DD	imagerel $unwind$stringlib_isspace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_isspace DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, 'e', 00H, 'l', 00H, 'f', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'l', 00H
	DB	'i', 00H, 'b', 00H, '/', 00H, 'c', 00H, 't', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_isspace
_TEXT	SEGMENT
self$ = 48
stringlib_isspace PROC					; COMDAT

; 8    : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 9    :     return _Py_bytes_isspace(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN3@stringlib_
  00021	41 b8 09 00 00
	00		 mov	 r8d, 9
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN3@stringlib_:
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00046	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00051	85 c0		 test	 eax, eax
  00053	75 1c		 jne	 SHORT $LN4@stringlib_
  00055	41 b8 09 00 00
	00		 mov	 r8d, 9
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN4@stringlib_:
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00076	48 83 c0 78	 add	 rax, 120		; 00000078H
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007f	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 _Py_bytes_isspace

; 10   : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
stringlib_isspace ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isalpha:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_isalpha DD imagerel stringlib_isalpha
	DD	imagerel stringlib_isalpha+144
	DD	imagerel $unwind$stringlib_isalpha
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_isalpha DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_isalpha
_TEXT	SEGMENT
self$ = 48
stringlib_isalpha PROC					; COMDAT

; 14   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 15   :     return _Py_bytes_isalpha(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN3@stringlib_@2
  00021	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN3@stringlib_@2:
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00046	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00051	85 c0		 test	 eax, eax
  00053	75 1c		 jne	 SHORT $LN4@stringlib_@2
  00055	41 b8 0f 00 00
	00		 mov	 r8d, 15
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN4@stringlib_@2:
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00076	48 83 c0 78	 add	 rax, 120		; 00000078H
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007f	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 _Py_bytes_isalpha

; 16   : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
stringlib_isalpha ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isalnum:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_isalnum DD imagerel stringlib_isalnum
	DD	imagerel stringlib_isalnum+144
	DD	imagerel $unwind$stringlib_isalnum
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_isalnum DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_isalnum
_TEXT	SEGMENT
self$ = 48
stringlib_isalnum PROC					; COMDAT

; 20   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 21   :     return _Py_bytes_isalnum(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN3@stringlib_@3
  00021	41 b8 15 00 00
	00		 mov	 r8d, 21
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN3@stringlib_@3:
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00046	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00051	85 c0		 test	 eax, eax
  00053	75 1c		 jne	 SHORT $LN4@stringlib_@3
  00055	41 b8 15 00 00
	00		 mov	 r8d, 21
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN4@stringlib_@3:
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00076	48 83 c0 78	 add	 rax, 120		; 00000078H
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007f	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 _Py_bytes_isalnum

; 22   : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
stringlib_isalnum ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isdigit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_isdigit DD imagerel stringlib_isdigit
	DD	imagerel stringlib_isdigit+144
	DD	imagerel $unwind$stringlib_isdigit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_isdigit DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_isdigit
_TEXT	SEGMENT
self$ = 48
stringlib_isdigit PROC					; COMDAT

; 26   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 27   :     return _Py_bytes_isdigit(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN3@stringlib_@4
  00021	41 b8 1b 00 00
	00		 mov	 r8d, 27
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN3@stringlib_@4:
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00046	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00051	85 c0		 test	 eax, eax
  00053	75 1c		 jne	 SHORT $LN4@stringlib_@4
  00055	41 b8 1b 00 00
	00		 mov	 r8d, 27
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN4@stringlib_@4:
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00076	48 83 c0 78	 add	 rax, 120		; 00000078H
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007f	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 _Py_bytes_isdigit

; 28   : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
stringlib_isdigit ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_islower:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_islower DD imagerel stringlib_islower
	DD	imagerel stringlib_islower+144
	DD	imagerel $unwind$stringlib_islower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_islower DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_islower
_TEXT	SEGMENT
self$ = 48
stringlib_islower PROC					; COMDAT

; 32   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 33   :     return _Py_bytes_islower(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN3@stringlib_@5
  00021	41 b8 21 00 00
	00		 mov	 r8d, 33			; 00000021H
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN3@stringlib_@5:
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00046	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00051	85 c0		 test	 eax, eax
  00053	75 1c		 jne	 SHORT $LN4@stringlib_@5
  00055	41 b8 21 00 00
	00		 mov	 r8d, 33			; 00000021H
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN4@stringlib_@5:
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00076	48 83 c0 78	 add	 rax, 120		; 00000078H
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007f	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 _Py_bytes_islower

; 34   : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
stringlib_islower ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isupper:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_isupper DD imagerel stringlib_isupper
	DD	imagerel stringlib_isupper+144
	DD	imagerel $unwind$stringlib_isupper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_isupper DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_isupper
_TEXT	SEGMENT
self$ = 48
stringlib_isupper PROC					; COMDAT

; 38   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 39   :     return _Py_bytes_isupper(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN3@stringlib_@6
  00021	41 b8 27 00 00
	00		 mov	 r8d, 39			; 00000027H
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN3@stringlib_@6:
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00046	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00051	85 c0		 test	 eax, eax
  00053	75 1c		 jne	 SHORT $LN4@stringlib_@6
  00055	41 b8 27 00 00
	00		 mov	 r8d, 39			; 00000027H
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN4@stringlib_@6:
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00076	48 83 c0 78	 add	 rax, 120		; 00000078H
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007f	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 _Py_bytes_isupper

; 40   : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
stringlib_isupper ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_istitle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_istitle DD imagerel stringlib_istitle
	DD	imagerel stringlib_istitle+144
	DD	imagerel $unwind$stringlib_istitle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_istitle DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_istitle
_TEXT	SEGMENT
self$ = 48
stringlib_istitle PROC					; COMDAT

; 44   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 45   :     return _Py_bytes_istitle(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN3@stringlib_@7
  00021	41 b8 2d 00 00
	00		 mov	 r8d, 45			; 0000002dH
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN3@stringlib_@7:
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00046	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00051	85 c0		 test	 eax, eax
  00053	75 1c		 jne	 SHORT $LN4@stringlib_@7
  00055	41 b8 2d 00 00
	00		 mov	 r8d, 45			; 0000002dH
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN4@stringlib_@7:
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00076	48 83 c0 78	 add	 rax, 120		; 00000078H
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007f	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 _Py_bytes_istitle

; 46   : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
stringlib_istitle ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@IAHHNEOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_bytes_lower:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_lower DD imagerel stringlib_lower
	DD	imagerel stringlib_lower+298
	DD	imagerel $unwind$stringlib_lower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_lower DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1CM@IAHHNEOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@IAHHNEOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'n', 00H, 'e', 00H, 'w', 00H, 'o', 00H, 'b', 00H, 'j', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_lower
_TEXT	SEGMENT
newobj$ = 32
self$ = 64
stringlib_lower PROC					; COMDAT

; 53   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 54   :     PyObject* newobj;
; 55   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN4@stringlib_@8
  00021	41 b8 37 00 00
	00		 mov	 r8d, 55			; 00000037H
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN4@stringlib_@8:
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0004d	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax

; 56   :     if (!newobj)

  00052	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  00058	75 07		 jne	 SHORT $LN1@stringlib_@8

; 57   :             return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 c4 00 00 00	 jmp	 $LN2@stringlib_@8
$LN1@stringlib_@8:

; 58   :     _Py_bytes_lower(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 59   :                  STRINGLIB_LEN(self));

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00066	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00075	85 c0		 test	 eax, eax
  00077	75 1c		 jne	 SHORT $LN5@stringlib_@8
  00079	41 b8 3b 00 00
	00		 mov	 r8d, 59			; 0000003bH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00093	33 c0		 xor	 eax, eax
$LN5@stringlib_@8:
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000a4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000a9	85 c0		 test	 eax, eax
  000ab	75 1c		 jne	 SHORT $LN6@stringlib_@8
  000ad	41 b8 3a 00 00
	00		 mov	 r8d, 58			; 0000003aH
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c7	33 c0		 xor	 eax, eax
$LN6@stringlib_@8:
  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  000ce	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000dd	85 c0		 test	 eax, eax
  000df	75 1c		 jne	 SHORT $LN7@stringlib_@8
  000e1	41 b8 3a 00 00
	00		 mov	 r8d, 58			; 0000003aH
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@IAHHNEOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fb	33 c0		 xor	 eax, eax
$LN7@stringlib_@8:
  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00102	48 83 c0 78	 add	 rax, 120		; 00000078H
  00106	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newobj$[rsp]
  0010b	48 83 c1 78	 add	 rcx, 120		; 00000078H
  0010f	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  00114	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00118	48 8b d0	 mov	 rdx, rax
  0011b	e8 00 00 00 00	 call	 _Py_bytes_lower

; 60   :     return newobj;

  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@stringlib_@8:

; 61   : }

  00125	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00129	c3		 ret	 0
stringlib_lower ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_upper:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_upper DD imagerel stringlib_upper
	DD	imagerel stringlib_upper+298
	DD	imagerel $unwind$stringlib_upper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_upper DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_upper
_TEXT	SEGMENT
newobj$ = 32
self$ = 64
stringlib_upper PROC					; COMDAT

; 65   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 66   :     PyObject* newobj;
; 67   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN4@stringlib_@9
  00021	41 b8 43 00 00
	00		 mov	 r8d, 67			; 00000043H
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN4@stringlib_@9:
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0004d	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax

; 68   :     if (!newobj)

  00052	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  00058	75 07		 jne	 SHORT $LN1@stringlib_@9

; 69   :             return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 c4 00 00 00	 jmp	 $LN2@stringlib_@9
$LN1@stringlib_@9:

; 70   :     _Py_bytes_upper(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 71   :                  STRINGLIB_LEN(self));

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00066	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00075	85 c0		 test	 eax, eax
  00077	75 1c		 jne	 SHORT $LN5@stringlib_@9
  00079	41 b8 47 00 00
	00		 mov	 r8d, 71			; 00000047H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00093	33 c0		 xor	 eax, eax
$LN5@stringlib_@9:
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000a4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000a9	85 c0		 test	 eax, eax
  000ab	75 1c		 jne	 SHORT $LN6@stringlib_@9
  000ad	41 b8 46 00 00
	00		 mov	 r8d, 70			; 00000046H
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c7	33 c0		 xor	 eax, eax
$LN6@stringlib_@9:
  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  000ce	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000dd	85 c0		 test	 eax, eax
  000df	75 1c		 jne	 SHORT $LN7@stringlib_@9
  000e1	41 b8 46 00 00
	00		 mov	 r8d, 70			; 00000046H
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@IAHHNEOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fb	33 c0		 xor	 eax, eax
$LN7@stringlib_@9:
  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00102	48 83 c0 78	 add	 rax, 120		; 00000078H
  00106	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newobj$[rsp]
  0010b	48 83 c1 78	 add	 rcx, 120		; 00000078H
  0010f	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  00114	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00118	48 8b d0	 mov	 rdx, rax
  0011b	e8 00 00 00 00	 call	 _Py_bytes_upper

; 72   :     return newobj;

  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@stringlib_@9:

; 73   : }

  00125	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00129	c3		 ret	 0
stringlib_upper ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_title:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_title DD imagerel stringlib_title
	DD	imagerel stringlib_title+298
	DD	imagerel $unwind$stringlib_title
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_title DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_title
_TEXT	SEGMENT
newobj$ = 32
self$ = 64
stringlib_title PROC					; COMDAT

; 77   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 78   :     PyObject* newobj;
; 79   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN4@stringlib_@10
  00021	41 b8 4f 00 00
	00		 mov	 r8d, 79			; 0000004fH
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN4@stringlib_@10:
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0004d	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax

; 80   :     if (!newobj)

  00052	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  00058	75 07		 jne	 SHORT $LN1@stringlib_@10

; 81   :             return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 c4 00 00 00	 jmp	 $LN2@stringlib_@10
$LN1@stringlib_@10:

; 82   :     _Py_bytes_title(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 83   :                  STRINGLIB_LEN(self));

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00066	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00075	85 c0		 test	 eax, eax
  00077	75 1c		 jne	 SHORT $LN5@stringlib_@10
  00079	41 b8 53 00 00
	00		 mov	 r8d, 83			; 00000053H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00093	33 c0		 xor	 eax, eax
$LN5@stringlib_@10:
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000a4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000a9	85 c0		 test	 eax, eax
  000ab	75 1c		 jne	 SHORT $LN6@stringlib_@10
  000ad	41 b8 52 00 00
	00		 mov	 r8d, 82			; 00000052H
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c7	33 c0		 xor	 eax, eax
$LN6@stringlib_@10:
  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  000ce	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000dd	85 c0		 test	 eax, eax
  000df	75 1c		 jne	 SHORT $LN7@stringlib_@10
  000e1	41 b8 52 00 00
	00		 mov	 r8d, 82			; 00000052H
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@IAHHNEOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fb	33 c0		 xor	 eax, eax
$LN7@stringlib_@10:
  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00102	48 83 c0 78	 add	 rax, 120		; 00000078H
  00106	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newobj$[rsp]
  0010b	48 83 c1 78	 add	 rcx, 120		; 00000078H
  0010f	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  00114	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00118	48 8b d0	 mov	 rdx, rax
  0011b	e8 00 00 00 00	 call	 _Py_bytes_title

; 84   :     return newobj;

  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@stringlib_@10:

; 85   : }

  00125	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00129	c3		 ret	 0
stringlib_title ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_capitalize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_capitalize DD imagerel stringlib_capitalize
	DD	imagerel stringlib_capitalize+298
	DD	imagerel $unwind$stringlib_capitalize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_capitalize DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_capitalize
_TEXT	SEGMENT
newobj$ = 32
self$ = 64
stringlib_capitalize PROC				; COMDAT

; 89   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 90   :     PyObject* newobj;
; 91   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN4@stringlib_@11
  00021	41 b8 5b 00 00
	00		 mov	 r8d, 91			; 0000005bH
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN4@stringlib_@11:
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0004d	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax

; 92   :     if (!newobj)

  00052	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  00058	75 07		 jne	 SHORT $LN1@stringlib_@11

; 93   :             return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 c4 00 00 00	 jmp	 $LN2@stringlib_@11
$LN1@stringlib_@11:

; 94   :     _Py_bytes_capitalize(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 95   :                       STRINGLIB_LEN(self));

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00066	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00075	85 c0		 test	 eax, eax
  00077	75 1c		 jne	 SHORT $LN5@stringlib_@11
  00079	41 b8 5f 00 00
	00		 mov	 r8d, 95			; 0000005fH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00093	33 c0		 xor	 eax, eax
$LN5@stringlib_@11:
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000a4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000a9	85 c0		 test	 eax, eax
  000ab	75 1c		 jne	 SHORT $LN6@stringlib_@11
  000ad	41 b8 5e 00 00
	00		 mov	 r8d, 94			; 0000005eH
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c7	33 c0		 xor	 eax, eax
$LN6@stringlib_@11:
  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  000ce	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000dd	85 c0		 test	 eax, eax
  000df	75 1c		 jne	 SHORT $LN7@stringlib_@11
  000e1	41 b8 5e 00 00
	00		 mov	 r8d, 94			; 0000005eH
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@IAHHNEOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fb	33 c0		 xor	 eax, eax
$LN7@stringlib_@11:
  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00102	48 83 c0 78	 add	 rax, 120		; 00000078H
  00106	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newobj$[rsp]
  0010b	48 83 c1 78	 add	 rcx, 120		; 00000078H
  0010f	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  00114	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00118	48 8b d0	 mov	 rdx, rax
  0011b	e8 00 00 00 00	 call	 _Py_bytes_capitalize

; 96   :     return newobj;

  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@stringlib_@11:

; 97   : }

  00125	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00129	c3		 ret	 0
stringlib_capitalize ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_swapcase:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_swapcase DD imagerel stringlib_swapcase
	DD	imagerel stringlib_swapcase+298
	DD	imagerel $unwind$stringlib_swapcase
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_swapcase DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_swapcase
_TEXT	SEGMENT
newobj$ = 32
self$ = 64
stringlib_swapcase PROC					; COMDAT

; 101  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 102  :     PyObject* newobj;
; 103  :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN4@stringlib_@12
  00021	41 b8 67 00 00
	00		 mov	 r8d, 103		; 00000067H
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN4@stringlib_@12:
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0004d	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax

; 104  :     if (!newobj)

  00052	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  00058	75 07		 jne	 SHORT $LN1@stringlib_@12

; 105  :             return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 c4 00 00 00	 jmp	 $LN2@stringlib_@12
$LN1@stringlib_@12:

; 106  :     _Py_bytes_swapcase(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 107  :                     STRINGLIB_LEN(self));

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00066	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00075	85 c0		 test	 eax, eax
  00077	75 1c		 jne	 SHORT $LN5@stringlib_@12
  00079	41 b8 6b 00 00
	00		 mov	 r8d, 107		; 0000006bH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00093	33 c0		 xor	 eax, eax
$LN5@stringlib_@12:
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000a4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000a9	85 c0		 test	 eax, eax
  000ab	75 1c		 jne	 SHORT $LN6@stringlib_@12
  000ad	41 b8 6a 00 00
	00		 mov	 r8d, 106		; 0000006aH
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c7	33 c0		 xor	 eax, eax
$LN6@stringlib_@12:
  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  000ce	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000dd	85 c0		 test	 eax, eax
  000df	75 1c		 jne	 SHORT $LN7@stringlib_@12
  000e1	41 b8 6a 00 00
	00		 mov	 r8d, 106		; 0000006aH
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@IAHHNEOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fb	33 c0		 xor	 eax, eax
$LN7@stringlib_@12:
  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00102	48 83 c0 78	 add	 rax, 120		; 00000078H
  00106	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newobj$[rsp]
  0010b	48 83 c1 78	 add	 rcx, 120		; 00000078H
  0010f	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  00114	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00118	48 8b d0	 mov	 rdx, rax
  0011b	e8 00 00 00 00	 call	 _Py_bytes_swapcase

; 108  :     return newobj;

  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@stringlib_@12:

; 109  : }

  00125	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00129	c3		 ret	 0
stringlib_swapcase ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@	; `string'
PUBLIC	??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ ; `string'
PUBLIC	??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@	; `string'
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\transmogrify.h
pdata	SEGMENT
$pdata$stringlib_expandtabs DD imagerel stringlib_expandtabs
	DD	imagerel stringlib_expandtabs+1062
	DD	imagerel $unwind$stringlib_expandtabs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_expandtabs DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'u', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@ DB 'result is too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'l', 00H
	DB	'i', 00H, 'b', 00H, '/', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 's', 00H, 'm', 00H, 'o', 00H, 'g', 00H, 'r', 00H, 'i', 00H
	DB	'f', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@
CONST	SEGMENT
??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@ DB '|i:expandtabs', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_expandtabs
_TEXT	SEGMENT
p$ = 32
i$ = 40
u$ = 48
tabsize$ = 56
q$ = 64
e$ = 72
j$ = 80
tv134 = 88
tv183 = 96
self$ = 128
args$ = 136
stringlib_expandtabs PROC				; COMDAT

; 15   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 16   :     const char *e, *p;
; 17   :     char *q;
; 18   :     size_t i, j;
; 19   :     PyObject *u;
; 20   :     int tabsize = 8;

  0000e	c7 44 24 38 08
	00 00 00	 mov	 DWORD PTR tabsize$[rsp], 8

; 21   : 
; 22   :     if (!PyArg_ParseTuple(args, "|i:expandtabs", &tabsize))

  00016	4c 8d 44 24 38	 lea	 r8, QWORD PTR tabsize$[rsp]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@
  00022	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0002a	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002f	85 c0		 test	 eax, eax
  00031	75 07		 jne	 SHORT $LN23@stringlib_@13

; 23   :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 e7 03 00 00	 jmp	 $LN24@stringlib_@13
$LN23@stringlib_@13:

; 24   : 
; 25   :     /* First pass: determine size of output string */
; 26   :     i = j = 0;

  0003a	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00048	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 27   :     e = STRINGLIB_STR(self) + STRINGLIB_LEN(self);

  0004d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00055	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00059	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00064	85 c0		 test	 eax, eax
  00066	75 1c		 jne	 SHORT $LN26@stringlib_@13
  00068	41 b8 1b 00 00
	00		 mov	 r8d, 27
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00082	33 c0		 xor	 eax, eax
$LN26@stringlib_@13:
  00084	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0008c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00090	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00096	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0009b	85 c0		 test	 eax, eax
  0009d	75 1c		 jne	 SHORT $LN27@stringlib_@13
  0009f	41 b8 1b 00 00
	00		 mov	 r8d, 27
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b9	33 c0		 xor	 eax, eax
$LN27@stringlib_@13:
  000bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000c3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000cf	48 8d 44 01 78	 lea	 rax, QWORD PTR [rcx+rax+120]
  000d4	48 89 44 24 48	 mov	 QWORD PTR e$[rsp], rax

; 28   :     for (p = STRINGLIB_STR(self); p < e; p++)

  000d9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000e1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000e5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000eb	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000f0	85 c0		 test	 eax, eax
  000f2	75 1c		 jne	 SHORT $LN28@stringlib_@13
  000f4	41 b8 1c 00 00
	00		 mov	 r8d, 28
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00101	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0010e	33 c0		 xor	 eax, eax
$LN28@stringlib_@13:
  00110	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00118	48 83 c0 78	 add	 rax, 120		; 00000078H
  0011c	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00121	eb 0d		 jmp	 SHORT $LN22@stringlib_@13
$LN21@stringlib_@13:
  00123	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00128	48 ff c0	 inc	 rax
  0012b	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN22@stringlib_@13:
  00130	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  00135	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  0013a	0f 83 ed 00 00
	00		 jae	 $LN20@stringlib_@13

; 29   :         if (*p == '\t') {

  00140	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00145	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00148	83 f8 09	 cmp	 eax, 9
  0014b	75 6b		 jne	 SHORT $LN19@stringlib_@13

; 30   :             if (tabsize > 0) {

  0014d	83 7c 24 38 00	 cmp	 DWORD PTR tabsize$[rsp], 0
  00152	7e 62		 jle	 SHORT $LN18@stringlib_@13

; 31   :                 j += tabsize - (j % tabsize);

  00154	48 63 44 24 38	 movsxd	 rax, DWORD PTR tabsize$[rsp]
  00159	48 89 44 24 58	 mov	 QWORD PTR tv134[rsp], rax
  0015e	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR tabsize$[rsp]
  00163	33 d2		 xor	 edx, edx
  00165	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0016a	48 f7 f1	 div	 rcx
  0016d	48 8b c2	 mov	 rax, rdx
  00170	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv134[rsp]
  00175	48 2b c8	 sub	 rcx, rax
  00178	48 8b c1	 mov	 rax, rcx
  0017b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  00180	48 03 c8	 add	 rcx, rax
  00183	48 8b c1	 mov	 rax, rcx
  00186	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax

; 32   :                 if (j > PY_SSIZE_T_MAX) {

  0018b	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00195	48 39 44 24 50	 cmp	 QWORD PTR j$[rsp], rax
  0019a	76 1a		 jbe	 SHORT $LN17@stringlib_@13

; 33   :                     PyErr_SetString(PyExc_OverflowError,
; 34   :                                     "result is too long");

  0019c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@
  001a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001aa	e8 00 00 00 00	 call	 PyErr_SetString

; 35   :                     return NULL;

  001af	33 c0		 xor	 eax, eax
  001b1	e9 6b 02 00 00	 jmp	 $LN24@stringlib_@13
$LN17@stringlib_@13:
$LN18@stringlib_@13:

; 36   :                 }
; 37   :             }
; 38   :         }
; 39   :         else {

  001b6	eb 70		 jmp	 SHORT $LN16@stringlib_@13
$LN19@stringlib_@13:

; 40   :             j++;

  001b8	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  001bd	48 ff c0	 inc	 rax
  001c0	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax

; 41   :             if (*p == '\n' || *p == '\r') {

  001c5	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001ca	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001cd	83 f8 0a	 cmp	 eax, 10
  001d0	74 0d		 je	 SHORT $LN14@stringlib_@13
  001d2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001d7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001da	83 f8 0d	 cmp	 eax, 13
  001dd	75 49		 jne	 SHORT $LN15@stringlib_@13
$LN14@stringlib_@13:

; 42   :                 i += j;

  001df	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  001e4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  001e9	48 03 c8	 add	 rcx, rax
  001ec	48 8b c1	 mov	 rax, rcx
  001ef	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 43   :                 j = 0;

  001f4	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0

; 44   :                 if (i > PY_SSIZE_T_MAX) {

  001fd	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00207	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0020c	76 1a		 jbe	 SHORT $LN13@stringlib_@13

; 45   :                     PyErr_SetString(PyExc_OverflowError,
; 46   :                                     "result is too long");

  0020e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@
  00215	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0021c	e8 00 00 00 00	 call	 PyErr_SetString

; 47   :                     return NULL;

  00221	33 c0		 xor	 eax, eax
  00223	e9 f9 01 00 00	 jmp	 $LN24@stringlib_@13
$LN13@stringlib_@13:
$LN15@stringlib_@13:
$LN16@stringlib_@13:

; 48   :                 }
; 49   :             }
; 50   :         }

  00228	e9 f6 fe ff ff	 jmp	 $LN21@stringlib_@13
$LN20@stringlib_@13:

; 51   : 
; 52   :     if ((i + j) > PY_SSIZE_T_MAX) {

  0022d	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00232	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00237	48 03 c8	 add	 rcx, rax
  0023a	48 8b c1	 mov	 rax, rcx
  0023d	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00247	48 3b c1	 cmp	 rax, rcx
  0024a	76 1a		 jbe	 SHORT $LN12@stringlib_@13

; 53   :         PyErr_SetString(PyExc_OverflowError, "result is too long");

  0024c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@
  00253	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0025a	e8 00 00 00 00	 call	 PyErr_SetString

; 54   :         return NULL;

  0025f	33 c0		 xor	 eax, eax
  00261	e9 bb 01 00 00	 jmp	 $LN24@stringlib_@13
$LN12@stringlib_@13:

; 55   :     }
; 56   : 
; 57   :     /* Second pass: create output string and fill it */
; 58   :     u = STRINGLIB_NEW(NULL, i + j);

  00266	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0026b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00270	48 03 c8	 add	 rcx, rax
  00273	48 8b c1	 mov	 rax, rcx
  00276	48 8b d0	 mov	 rdx, rax
  00279	33 c9		 xor	 ecx, ecx
  0027b	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00280	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax

; 59   :     if (!u)

  00285	48 83 7c 24 30
	00		 cmp	 QWORD PTR u$[rsp], 0
  0028b	75 07		 jne	 SHORT $LN11@stringlib_@13

; 60   :         return NULL;

  0028d	33 c0		 xor	 eax, eax
  0028f	e9 8d 01 00 00	 jmp	 $LN24@stringlib_@13
$LN11@stringlib_@13:

; 61   : 
; 62   :     j = 0;

  00294	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0

; 63   :     q = STRINGLIB_STR(u);

  0029d	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  002a2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002a6	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002ac	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002b1	85 c0		 test	 eax, eax
  002b3	75 1c		 jne	 SHORT $LN29@stringlib_@13
  002b5	41 b8 3f 00 00
	00		 mov	 r8d, 63			; 0000003fH
  002bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  002c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  002c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002cf	33 c0		 xor	 eax, eax
$LN29@stringlib_@13:
  002d1	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  002d6	48 83 c0 78	 add	 rax, 120		; 00000078H
  002da	48 89 44 24 40	 mov	 QWORD PTR q$[rsp], rax

; 64   : 
; 65   :     for (p = STRINGLIB_STR(self); p < e; p++)

  002df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002e7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002eb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002f1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002f6	85 c0		 test	 eax, eax
  002f8	75 1c		 jne	 SHORT $LN30@stringlib_@13
  002fa	41 b8 41 00 00
	00		 mov	 r8d, 65			; 00000041H
  00300	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0030e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00314	33 c0		 xor	 eax, eax
$LN30@stringlib_@13:
  00316	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0031e	48 83 c0 78	 add	 rax, 120		; 00000078H
  00322	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00327	eb 0d		 jmp	 SHORT $LN10@stringlib_@13
$LN9@stringlib_@13:
  00329	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0032e	48 ff c0	 inc	 rax
  00331	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN10@stringlib_@13:
  00336	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  0033b	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  00340	0f 83 d6 00 00
	00		 jae	 $LN8@stringlib_@13

; 66   :         if (*p == '\t') {

  00346	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0034b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0034e	83 f8 09	 cmp	 eax, 9
  00351	75 78		 jne	 SHORT $LN7@stringlib_@13

; 67   :             if (tabsize > 0) {

  00353	83 7c 24 38 00	 cmp	 DWORD PTR tabsize$[rsp], 0
  00358	7e 6f		 jle	 SHORT $LN6@stringlib_@13

; 68   :                 i = tabsize - (j % tabsize);

  0035a	48 63 44 24 38	 movsxd	 rax, DWORD PTR tabsize$[rsp]
  0035f	48 89 44 24 60	 mov	 QWORD PTR tv183[rsp], rax
  00364	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR tabsize$[rsp]
  00369	33 d2		 xor	 edx, edx
  0036b	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00370	48 f7 f1	 div	 rcx
  00373	48 8b c2	 mov	 rax, rdx
  00376	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv183[rsp]
  0037b	48 2b c8	 sub	 rcx, rax
  0037e	48 8b c1	 mov	 rax, rcx
  00381	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 69   :                 j += i;

  00386	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0038b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  00390	48 03 c8	 add	 rcx, rax
  00393	48 8b c1	 mov	 rax, rcx
  00396	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax
$LN5@stringlib_@13:

; 70   :                 while (i--)

  0039b	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  003a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  003a5	48 ff c9	 dec	 rcx
  003a8	48 89 4c 24 28	 mov	 QWORD PTR i$[rsp], rcx
  003ad	48 85 c0	 test	 rax, rax
  003b0	74 17		 je	 SHORT $LN4@stringlib_@13

; 71   :                     *q++ = ' ';

  003b2	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  003b7	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H
  003ba	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  003bf	48 ff c0	 inc	 rax
  003c2	48 89 44 24 40	 mov	 QWORD PTR q$[rsp], rax
  003c7	eb d2		 jmp	 SHORT $LN5@stringlib_@13
$LN4@stringlib_@13:
$LN6@stringlib_@13:

; 72   :             }
; 73   :         }
; 74   :         else {

  003c9	eb 4c		 jmp	 SHORT $LN3@stringlib_@13
$LN7@stringlib_@13:

; 75   :             j++;

  003cb	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  003d0	48 ff c0	 inc	 rax
  003d3	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax

; 76   :             *q++ = *p;

  003d8	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  003dd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  003e2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  003e5	88 08		 mov	 BYTE PTR [rax], cl
  003e7	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  003ec	48 ff c0	 inc	 rax
  003ef	48 89 44 24 40	 mov	 QWORD PTR q$[rsp], rax

; 77   :             if (*p == '\n' || *p == '\r')

  003f4	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003f9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003fc	83 f8 0a	 cmp	 eax, 10
  003ff	74 0d		 je	 SHORT $LN1@stringlib_@13
  00401	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00406	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00409	83 f8 0d	 cmp	 eax, 13
  0040c	75 09		 jne	 SHORT $LN2@stringlib_@13
$LN1@stringlib_@13:

; 78   :                 j = 0;

  0040e	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
$LN2@stringlib_@13:
$LN3@stringlib_@13:

; 79   :         }

  00417	e9 0d ff ff ff	 jmp	 $LN9@stringlib_@13
$LN8@stringlib_@13:

; 80   : 
; 81   :     return u;

  0041c	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
$LN24@stringlib_@13:

; 82   : }

  00421	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00425	c3		 ret	 0
stringlib_expandtabs ENDP
_TEXT	ENDS
PUBLIC	??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_ljust DD imagerel stringlib_ljust
	DD	imagerel stringlib_ljust+258
	DD	imagerel $unwind$stringlib_ljust
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_ljust DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@
CONST	SEGMENT
??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@ DB 'n|c:ljust', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_ljust
_TEXT	SEGMENT
width$ = 32
fillchar$ = 40
self$ = 64
args$ = 72
stringlib_ljust PROC					; COMDAT

; 129  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 130  :     Py_ssize_t width;
; 131  :     char fillchar = ' ';

  0000e	c6 44 24 28 20	 mov	 BYTE PTR fillchar$[rsp], 32 ; 00000020H

; 132  : 
; 133  :     if (!PyArg_ParseTuple(args, "n|c:ljust", &width, &fillchar))

  00013	4c 8d 4c 24 28	 lea	 r9, QWORD PTR fillchar$[rsp]
  00018	4c 8d 44 24 20	 lea	 r8, QWORD PTR width$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@
  00024	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 07		 jne	 SHORT $LN2@stringlib_@14

; 134  :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 c4 00 00 00	 jmp	 $LN3@stringlib_@14
$LN2@stringlib_@14:

; 135  : 
; 136  :     if (STRINGLIB_LEN(self) >= width && STRINGLIB_CHECK_EXACT(self)) {

  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00042	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00048	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0004d	85 c0		 test	 eax, eax
  0004f	75 1c		 jne	 SHORT $LN5@stringlib_@14
  00051	41 b8 88 00 00
	00		 mov	 r8d, 136		; 00000088H
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006b	33 c0		 xor	 eax, eax
$LN5@stringlib_@14:
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR width$[rsp]
  00077	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0007b	7c 23		 jl	 SHORT $LN1@stringlib_@14
  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00089	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0008d	75 11		 jne	 SHORT $LN1@stringlib_@14

; 137  : #if STRINGLIB_MUTABLE
; 138  :         /* We're defined as returning a copy;  If the object is mutable
; 139  :          * that means we must make an identical copy. */
; 140  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));
; 141  : #else
; 142  :         Py_INCREF(self);

  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00094	e8 00 00 00 00	 call	 _Py_IncRef

; 143  :         return (PyObject*) self;

  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009e	eb 5d		 jmp	 SHORT $LN3@stringlib_@14
$LN1@stringlib_@14:

; 144  : #endif
; 145  :     }
; 146  : 
; 147  :     return pad(self, 0, width - STRINGLIB_LEN(self), fillchar);

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000af	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b4	85 c0		 test	 eax, eax
  000b6	75 1c		 jne	 SHORT $LN6@stringlib_@14
  000b8	41 b8 93 00 00
	00		 mov	 r8d, 147		; 00000093H
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d2	33 c0		 xor	 eax, eax
$LN6@stringlib_@14:
  000d4	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000d9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000dd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR width$[rsp]
  000e2	48 2b c8	 sub	 rcx, rax
  000e5	48 8b c1	 mov	 rax, rcx
  000e8	44 0f b6 4c 24
	28		 movzx	 r9d, BYTE PTR fillchar$[rsp]
  000ee	4c 8b c0	 mov	 r8, rax
  000f1	33 d2		 xor	 edx, edx
  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000f8	e8 00 00 00 00	 call	 pad
$LN3@stringlib_@14:

; 148  : }

  000fd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00101	c3		 ret	 0
stringlib_ljust ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pad DD	imagerel pad
	DD	imagerel pad+788
	DD	imagerel $unwind$pad
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pad DD	011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pad
_TEXT	SEGMENT
u$ = 32
t_$22016 = 40
s_$22021 = 48
i_$22011 = 56
n_$22012 = 64
self$ = 96
left$ = 104
right$ = 112
fill$ = 120
pad	PROC						; COMDAT

; 86   : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 87   :     PyObject *u;
; 88   : 
; 89   :     if (left < 0)

  00018	48 83 7c 24 68
	00		 cmp	 QWORD PTR left$[rsp], 0
  0001e	7d 09		 jge	 SHORT $LN14@pad

; 90   :         left = 0;

  00020	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR left$[rsp], 0
$LN14@pad:

; 91   :     if (right < 0)

  00029	48 83 7c 24 70
	00		 cmp	 QWORD PTR right$[rsp], 0
  0002f	7d 09		 jge	 SHORT $LN13@pad

; 92   :         right = 0;

  00031	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR right$[rsp], 0
$LN13@pad:

; 93   : 
; 94   :     if (left == 0 && right == 0 && STRINGLIB_CHECK_EXACT(self)) {

  0003a	48 83 7c 24 68
	00		 cmp	 QWORD PTR left$[rsp], 0
  00040	75 2e		 jne	 SHORT $LN12@pad
  00042	48 83 7c 24 70
	00		 cmp	 QWORD PTR right$[rsp], 0
  00048	75 26		 jne	 SHORT $LN12@pad
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00051	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00056	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0005a	75 14		 jne	 SHORT $LN12@pad

; 95   : #if STRINGLIB_MUTABLE
; 96   :         /* We're defined as returning a copy;  If the object is mutable
; 97   :          * that means we must make an identical copy. */
; 98   :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));
; 99   : #else
; 100  :         Py_INCREF(self);

  0005c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00061	e8 00 00 00 00	 call	 _Py_IncRef

; 101  :         return (PyObject *)self;

  00066	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0006b	e9 9f 02 00 00	 jmp	 $LN15@pad
$LN12@pad:

; 102  : #endif /* STRINGLIB_MUTABLE */
; 103  :     }
; 104  : 
; 105  :     u = STRINGLIB_NEW(NULL,
; 106  : 				   left + STRINGLIB_LEN(self) + right);

  00070	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00075	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00079	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0007f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00084	85 c0		 test	 eax, eax
  00086	75 1c		 jne	 SHORT $LN17@pad
  00088	41 b8 6a 00 00
	00		 mov	 r8d, 106		; 0000006aH
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a2	33 c0		 xor	 eax, eax
$LN17@pad:
  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000a9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR left$[rsp]
  000b2	48 03 c8	 add	 rcx, rax
  000b5	48 8b c1	 mov	 rax, rcx
  000b8	48 03 44 24 70	 add	 rax, QWORD PTR right$[rsp]
  000bd	48 8b d0	 mov	 rdx, rax
  000c0	33 c9		 xor	 ecx, ecx
  000c2	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000c7	48 89 44 24 20	 mov	 QWORD PTR u$[rsp], rax

; 107  :     if (u) {

  000cc	48 83 7c 24 20
	00		 cmp	 QWORD PTR u$[rsp], 0
  000d2	0f 84 32 02 00
	00		 je	 $LN11@pad

; 108  :         if (left)

  000d8	48 83 7c 24 68
	00		 cmp	 QWORD PTR left$[rsp], 0
  000de	74 4e		 je	 SHORT $LN10@pad

; 109  :             memset(STRINGLIB_STR(u), fill, left);

  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  000e5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000e9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000ef	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000f4	85 c0		 test	 eax, eax
  000f6	75 1c		 jne	 SHORT $LN18@pad
  000f8	41 b8 6d 00 00
	00		 mov	 r8d, 109		; 0000006dH
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00112	33 c0		 xor	 eax, eax
$LN18@pad:
  00114	0f be 44 24 78	 movsx	 eax, BYTE PTR fill$[rsp]
  00119	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  0011e	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00122	4c 8b 44 24 68	 mov	 r8, QWORD PTR left$[rsp]
  00127	8b d0		 mov	 edx, eax
  00129	e8 00 00 00 00	 call	 memset
$LN10@pad:
$LN9@pad:

; 110  :         Py_MEMCPY(STRINGLIB_STR(u) + left,
; 111  : 	       STRINGLIB_STR(self),
; 112  : 	       STRINGLIB_LEN(self));

  0012e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00133	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00137	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0013d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00142	85 c0		 test	 eax, eax
  00144	75 1c		 jne	 SHORT $LN19@pad
  00146	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00160	33 c0		 xor	 eax, eax
$LN19@pad:
  00162	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00167	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0016b	48 89 44 24 40	 mov	 QWORD PTR n_$22012[rsp], rax
  00170	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00175	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00179	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0017f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00184	85 c0		 test	 eax, eax
  00186	75 1c		 jne	 SHORT $LN20@pad
  00188	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001a2	33 c0		 xor	 eax, eax
$LN20@pad:
  001a4	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  001a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR left$[rsp]
  001ae	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  001b3	48 89 44 24 28	 mov	 QWORD PTR t_$22016[rsp], rax
  001b8	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001bd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001c1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001c7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001cc	85 c0		 test	 eax, eax
  001ce	75 1c		 jne	 SHORT $LN21@pad
  001d0	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  001d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  001dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001ea	33 c0		 xor	 eax, eax
$LN21@pad:
  001ec	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001f1	48 83 c0 78	 add	 rax, 120		; 00000078H
  001f5	48 89 44 24 30	 mov	 QWORD PTR s_$22021[rsp], rax
  001fa	48 83 7c 24 40
	10		 cmp	 QWORD PTR n_$22012[rsp], 16
  00200	72 16		 jb	 SHORT $LN6@pad
  00202	4c 8b 44 24 40	 mov	 r8, QWORD PTR n_$22012[rsp]
  00207	48 8b 54 24 30	 mov	 rdx, QWORD PTR s_$22021[rsp]
  0020c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t_$22016[rsp]
  00211	e8 00 00 00 00	 call	 memcpy
  00216	eb 4b		 jmp	 SHORT $LN5@pad
$LN6@pad:
  00218	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i_$22011[rsp], 0
  00221	eb 0d		 jmp	 SHORT $LN4@pad
$LN3@pad:
  00223	48 8b 44 24 38	 mov	 rax, QWORD PTR i_$22011[rsp]
  00228	48 ff c0	 inc	 rax
  0022b	48 89 44 24 38	 mov	 QWORD PTR i_$22011[rsp], rax
$LN4@pad:
  00230	48 8b 44 24 40	 mov	 rax, QWORD PTR n_$22012[rsp]
  00235	48 39 44 24 38	 cmp	 QWORD PTR i_$22011[rsp], rax
  0023a	73 27		 jae	 SHORT $LN2@pad
  0023c	48 8b 44 24 38	 mov	 rax, QWORD PTR i_$22011[rsp]
  00241	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t_$22016[rsp]
  00246	48 03 c8	 add	 rcx, rax
  00249	48 8b c1	 mov	 rax, rcx
  0024c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i_$22011[rsp]
  00251	48 8b 54 24 30	 mov	 rdx, QWORD PTR s_$22021[rsp]
  00256	48 03 d1	 add	 rdx, rcx
  00259	48 8b ca	 mov	 rcx, rdx
  0025c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0025f	88 08		 mov	 BYTE PTR [rax], cl
  00261	eb c0		 jmp	 SHORT $LN3@pad
$LN2@pad:
$LN5@pad:
  00263	33 c0		 xor	 eax, eax
  00265	85 c0		 test	 eax, eax
  00267	0f 85 c1 fe ff
	ff		 jne	 $LN9@pad

; 113  :         if (right)

  0026d	48 83 7c 24 70
	00		 cmp	 QWORD PTR right$[rsp], 0
  00273	0f 84 91 00 00
	00		 je	 $LN1@pad

; 114  :             memset(STRINGLIB_STR(u) + left + STRINGLIB_LEN(self),
; 115  : 		   fill, right);

  00279	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0027e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00282	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00288	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0028d	85 c0		 test	 eax, eax
  0028f	75 1c		 jne	 SHORT $LN22@pad
  00291	41 b8 72 00 00
	00		 mov	 r8d, 114		; 00000072H
  00297	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0029e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  002a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ab	33 c0		 xor	 eax, eax
$LN22@pad:
  002ad	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  002b2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002b6	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002bc	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002c1	85 c0		 test	 eax, eax
  002c3	75 1c		 jne	 SHORT $LN23@pad
  002c5	41 b8 72 00 00
	00		 mov	 r8d, 114		; 00000072H
  002cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  002d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  002d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002df	33 c0		 xor	 eax, eax
$LN23@pad:
  002e1	0f be 44 24 78	 movsx	 eax, BYTE PTR fill$[rsp]
  002e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  002eb	48 8b 54 24 68	 mov	 rdx, QWORD PTR left$[rsp]
  002f0	48 8d 4c 11 78	 lea	 rcx, QWORD PTR [rcx+rdx+120]
  002f5	48 8b 54 24 60	 mov	 rdx, QWORD PTR self$[rsp]
  002fa	48 03 4a 60	 add	 rcx, QWORD PTR [rdx+96]
  002fe	4c 8b 44 24 70	 mov	 r8, QWORD PTR right$[rsp]
  00303	8b d0		 mov	 edx, eax
  00305	e8 00 00 00 00	 call	 memset
$LN1@pad:
$LN11@pad:

; 116  :     }
; 117  : 
; 118  :     return u;

  0030a	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
$LN15@pad:

; 119  : }

  0030f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00313	c3		 ret	 0
pad	ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rjust DD imagerel stringlib_rjust
	DD	imagerel stringlib_rjust+259
	DD	imagerel $unwind$stringlib_rjust
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rjust DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@
CONST	SEGMENT
??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@ DB 'n|c:rjust', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_rjust
_TEXT	SEGMENT
width$ = 32
fillchar$ = 40
self$ = 64
args$ = 72
stringlib_rjust PROC					; COMDAT

; 159  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 160  :     Py_ssize_t width;
; 161  :     char fillchar = ' ';

  0000e	c6 44 24 28 20	 mov	 BYTE PTR fillchar$[rsp], 32 ; 00000020H

; 162  : 
; 163  :     if (!PyArg_ParseTuple(args, "n|c:rjust", &width, &fillchar))

  00013	4c 8d 4c 24 28	 lea	 r9, QWORD PTR fillchar$[rsp]
  00018	4c 8d 44 24 20	 lea	 r8, QWORD PTR width$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@
  00024	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 07		 jne	 SHORT $LN2@stringlib_@15

; 164  :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 c5 00 00 00	 jmp	 $LN3@stringlib_@15
$LN2@stringlib_@15:

; 165  : 
; 166  :     if (STRINGLIB_LEN(self) >= width && STRINGLIB_CHECK_EXACT(self)) {

  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00042	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00048	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0004d	85 c0		 test	 eax, eax
  0004f	75 1c		 jne	 SHORT $LN5@stringlib_@15
  00051	41 b8 a6 00 00
	00		 mov	 r8d, 166		; 000000a6H
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006b	33 c0		 xor	 eax, eax
$LN5@stringlib_@15:
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR width$[rsp]
  00077	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0007b	7c 23		 jl	 SHORT $LN1@stringlib_@15
  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00089	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0008d	75 11		 jne	 SHORT $LN1@stringlib_@15

; 167  : #if STRINGLIB_MUTABLE
; 168  :         /* We're defined as returning a copy;  If the object is mutable
; 169  :          * that means we must make an identical copy. */
; 170  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));
; 171  : #else
; 172  :         Py_INCREF(self);

  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00094	e8 00 00 00 00	 call	 _Py_IncRef

; 173  :         return (PyObject*) self;

  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009e	eb 5e		 jmp	 SHORT $LN3@stringlib_@15
$LN1@stringlib_@15:

; 174  : #endif
; 175  :     }
; 176  : 
; 177  :     return pad(self, width - STRINGLIB_LEN(self), 0, fillchar);

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000af	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b4	85 c0		 test	 eax, eax
  000b6	75 1c		 jne	 SHORT $LN6@stringlib_@15
  000b8	41 b8 b1 00 00
	00		 mov	 r8d, 177		; 000000b1H
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d2	33 c0		 xor	 eax, eax
$LN6@stringlib_@15:
  000d4	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000d9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000dd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR width$[rsp]
  000e2	48 2b c8	 sub	 rcx, rax
  000e5	48 8b c1	 mov	 rax, rcx
  000e8	44 0f b6 4c 24
	28		 movzx	 r9d, BYTE PTR fillchar$[rsp]
  000ee	45 33 c0	 xor	 r8d, r8d
  000f1	48 8b d0	 mov	 rdx, rax
  000f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000f9	e8 00 00 00 00	 call	 pad
$LN3@stringlib_@15:

; 178  : }

  000fe	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00102	c3		 ret	 0
stringlib_rjust ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_center DD imagerel stringlib_center
	DD	imagerel stringlib_center+326
	DD	imagerel $unwind$stringlib_center
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_center DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@
CONST	SEGMENT
??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@ DB 'n|c:center', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_center
_TEXT	SEGMENT
left$ = 32
width$ = 40
fillchar$ = 48
marg$ = 56
self$ = 80
args$ = 88
stringlib_center PROC					; COMDAT

; 189  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 190  :     Py_ssize_t marg, left;
; 191  :     Py_ssize_t width;
; 192  :     char fillchar = ' ';

  0000e	c6 44 24 30 20	 mov	 BYTE PTR fillchar$[rsp], 32 ; 00000020H

; 193  : 
; 194  :     if (!PyArg_ParseTuple(args, "n|c:center", &width, &fillchar))

  00013	4c 8d 4c 24 30	 lea	 r9, QWORD PTR fillchar$[rsp]
  00018	4c 8d 44 24 28	 lea	 r8, QWORD PTR width$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@
  00024	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 07		 jne	 SHORT $LN2@stringlib_@16

; 195  :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 08 01 00 00	 jmp	 $LN3@stringlib_@16
$LN2@stringlib_@16:

; 196  : 
; 197  :     if (STRINGLIB_LEN(self) >= width && STRINGLIB_CHECK_EXACT(self)) {

  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0003e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00042	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00048	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0004d	85 c0		 test	 eax, eax
  0004f	75 1c		 jne	 SHORT $LN5@stringlib_@16
  00051	41 b8 c5 00 00
	00		 mov	 r8d, 197		; 000000c5H
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006b	33 c0		 xor	 eax, eax
$LN5@stringlib_@16:
  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00072	48 8b 4c 24 28	 mov	 rcx, QWORD PTR width$[rsp]
  00077	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0007b	7c 26		 jl	 SHORT $LN1@stringlib_@16
  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00084	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00089	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0008d	75 14		 jne	 SHORT $LN1@stringlib_@16

; 198  : #if STRINGLIB_MUTABLE
; 199  :         /* We're defined as returning a copy;  If the object is mutable
; 200  :          * that means we must make an identical copy. */
; 201  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));
; 202  : #else
; 203  :         Py_INCREF(self);

  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00094	e8 00 00 00 00	 call	 _Py_IncRef

; 204  :         return (PyObject*) self;

  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0009e	e9 9e 00 00 00	 jmp	 $LN3@stringlib_@16
$LN1@stringlib_@16:

; 205  : #endif
; 206  :     }
; 207  : 
; 208  :     marg = width - STRINGLIB_LEN(self);

  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ac	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000b2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b7	85 c0		 test	 eax, eax
  000b9	75 1c		 jne	 SHORT $LN6@stringlib_@16
  000bb	41 b8 d0 00 00
	00		 mov	 r8d, 208		; 000000d0H
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d5	33 c0		 xor	 eax, eax
$LN6@stringlib_@16:
  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000dc	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR width$[rsp]
  000e5	48 2b c8	 sub	 rcx, rax
  000e8	48 8b c1	 mov	 rax, rcx
  000eb	48 89 44 24 38	 mov	 QWORD PTR marg$[rsp], rax

; 209  :     left = marg / 2 + (marg & width & 1);

  000f0	48 8b 44 24 38	 mov	 rax, QWORD PTR marg$[rsp]
  000f5	48 99		 cdq
  000f7	48 2b c2	 sub	 rax, rdx
  000fa	48 d1 f8	 sar	 rax, 1
  000fd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR width$[rsp]
  00102	48 8b 54 24 38	 mov	 rdx, QWORD PTR marg$[rsp]
  00107	48 23 d1	 and	 rdx, rcx
  0010a	48 8b ca	 mov	 rcx, rdx
  0010d	48 83 e1 01	 and	 rcx, 1
  00111	48 03 c1	 add	 rax, rcx
  00114	48 89 44 24 20	 mov	 QWORD PTR left$[rsp], rax

; 210  : 
; 211  :     return pad(self, left, marg - left, fillchar);

  00119	48 8b 44 24 20	 mov	 rax, QWORD PTR left$[rsp]
  0011e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR marg$[rsp]
  00123	48 2b c8	 sub	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	44 0f b6 4c 24
	30		 movzx	 r9d, BYTE PTR fillchar$[rsp]
  0012f	4c 8b c0	 mov	 r8, rax
  00132	48 8b 54 24 20	 mov	 rdx, QWORD PTR left$[rsp]
  00137	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0013c	e8 00 00 00 00	 call	 pad
$LN3@stringlib_@16:

; 212  : }

  00141	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00145	c3		 ret	 0
stringlib_center ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@PPMJPEFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_07CBMPGKCP@n?3zfill?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_zfill DD imagerel stringlib_zfill
	DD	imagerel stringlib_zfill+584
	DD	imagerel $unwind$stringlib_zfill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_zfill DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1CC@PPMJPEFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@PPMJPEFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CBMPGKCP@n?3zfill?$AA@
CONST	SEGMENT
??_C@_07CBMPGKCP@n?3zfill?$AA@ DB 'n:zfill', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_zfill
_TEXT	SEGMENT
p$ = 32
s$ = 40
width$ = 48
fill$ = 56
self$ = 80
args$ = 88
stringlib_zfill PROC					; COMDAT

; 222  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 223  :     Py_ssize_t fill;
; 224  :     PyObject *s;
; 225  :     char *p;
; 226  :     Py_ssize_t width;
; 227  : 
; 228  :     if (!PyArg_ParseTuple(args, "n:zfill", &width))

  0000e	4c 8d 44 24 30	 lea	 r8, QWORD PTR width$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07CBMPGKCP@n?3zfill?$AA@
  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 07		 jne	 SHORT $LN7@stringlib_@17

; 229  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 14 02 00 00	 jmp	 $LN8@stringlib_@17
$LN7@stringlib_@17:

; 230  : 
; 231  :     if (STRINGLIB_LEN(self) >= width) {

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00043	85 c0		 test	 eax, eax
  00045	75 1c		 jne	 SHORT $LN10@stringlib_@17
  00047	41 b8 e7 00 00
	00		 mov	 r8d, 231		; 000000e7H
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN10@stringlib_@17:
  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR width$[rsp]
  0006d	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00071	0f 8c b2 00 00
	00		 jl	 $LN6@stringlib_@17

; 232  :         if (STRINGLIB_CHECK_EXACT(self)) {

  00077	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00083	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00087	75 19		 jne	 SHORT $LN5@stringlib_@17

; 233  : #if STRINGLIB_MUTABLE
; 234  :             /* We're defined as returning a copy;  If the object is mutable
; 235  :              * that means we must make an identical copy. */
; 236  :             return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));
; 237  : #else
; 238  :             Py_INCREF(self);

  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0008e	e8 00 00 00 00	 call	 _Py_IncRef

; 239  :             return (PyObject*) self;

  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00098	e9 a6 01 00 00	 jmp	 $LN8@stringlib_@17

; 240  : #endif
; 241  :         }
; 242  :         else

  0009d	e9 87 00 00 00	 jmp	 $LN4@stringlib_@17
$LN5@stringlib_@17:

; 243  :             return STRINGLIB_NEW(
; 244  :                 STRINGLIB_STR(self),
; 245  :                 STRINGLIB_LEN(self)
; 246  :             );

  000a2	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000a7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ab	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000b1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b6	85 c0		 test	 eax, eax
  000b8	75 1c		 jne	 SHORT $LN11@stringlib_@17
  000ba	41 b8 f5 00 00
	00		 mov	 r8d, 245		; 000000f5H
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d4	33 c0		 xor	 eax, eax
$LN11@stringlib_@17:
  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000db	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000df	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000e5	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000ea	85 c0		 test	 eax, eax
  000ec	75 1c		 jne	 SHORT $LN12@stringlib_@17
  000ee	41 b8 f4 00 00
	00		 mov	 r8d, 244		; 000000f4H
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00108	33 c0		 xor	 eax, eax
$LN12@stringlib_@17:
  0010a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0010f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00113	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00118	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0011c	48 8b c8	 mov	 rcx, rax
  0011f	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00124	e9 1a 01 00 00	 jmp	 $LN8@stringlib_@17
$LN4@stringlib_@17:
$LN6@stringlib_@17:

; 247  :     }
; 248  : 
; 249  :     fill = width - STRINGLIB_LEN(self);

  00129	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0012e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00132	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00138	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0013d	85 c0		 test	 eax, eax
  0013f	75 1c		 jne	 SHORT $LN13@stringlib_@17
  00141	41 b8 f9 00 00
	00		 mov	 r8d, 249		; 000000f9H
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0015b	33 c0		 xor	 eax, eax
$LN13@stringlib_@17:
  0015d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00162	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00166	48 8b 4c 24 30	 mov	 rcx, QWORD PTR width$[rsp]
  0016b	48 2b c8	 sub	 rcx, rax
  0016e	48 8b c1	 mov	 rax, rcx
  00171	48 89 44 24 38	 mov	 QWORD PTR fill$[rsp], rax

; 250  : 
; 251  :     s = pad(self, fill, 0, '0');

  00176	41 b1 30	 mov	 r9b, 48			; 00000030H
  00179	45 33 c0	 xor	 r8d, r8d
  0017c	48 8b 54 24 38	 mov	 rdx, QWORD PTR fill$[rsp]
  00181	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00186	e8 00 00 00 00	 call	 pad
  0018b	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 252  : 
; 253  :     if (s == NULL)

  00190	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  00196	75 07		 jne	 SHORT $LN3@stringlib_@17

; 254  :         return NULL;

  00198	33 c0		 xor	 eax, eax
  0019a	e9 a4 00 00 00	 jmp	 $LN8@stringlib_@17
$LN3@stringlib_@17:

; 255  : 
; 256  :     p = STRINGLIB_STR(s);

  0019f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001a4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001a8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001ae	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001b3	85 c0		 test	 eax, eax
  001b5	75 1c		 jne	 SHORT $LN14@stringlib_@17
  001b7	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@PPMJPEFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d1	33 c0		 xor	 eax, eax
$LN14@stringlib_@17:
  001d3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001d8	48 83 c0 78	 add	 rax, 120		; 00000078H
  001dc	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 257  :     if (p[fill] == '+' || p[fill] == '-') {

  001e1	48 8b 44 24 38	 mov	 rax, QWORD PTR fill$[rsp]
  001e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001eb	48 03 c8	 add	 rcx, rax
  001ee	48 8b c1	 mov	 rax, rcx
  001f1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001f4	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  001f7	74 18		 je	 SHORT $LN1@stringlib_@17
  001f9	48 8b 44 24 38	 mov	 rax, QWORD PTR fill$[rsp]
  001fe	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00203	48 03 c8	 add	 rcx, rax
  00206	48 8b c1	 mov	 rax, rcx
  00209	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0020c	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0020f	75 2d		 jne	 SHORT $LN2@stringlib_@17
$LN1@stringlib_@17:

; 258  :         /* move sign to beginning of string */
; 259  :         p[0] = p[fill];

  00211	48 8b 44 24 38	 mov	 rax, QWORD PTR fill$[rsp]
  00216	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0021b	48 03 c8	 add	 rcx, rax
  0021e	48 8b c1	 mov	 rax, rcx
  00221	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00226	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00229	88 01		 mov	 BYTE PTR [rcx], al

; 260  :         p[fill] = '0';

  0022b	48 8b 44 24 38	 mov	 rax, QWORD PTR fill$[rsp]
  00230	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00235	48 03 c8	 add	 rcx, rax
  00238	48 8b c1	 mov	 rax, rcx
  0023b	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
$LN2@stringlib_@17:

; 261  :     }
; 262  : 
; 263  :     return (PyObject*) s;

  0023e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
$LN8@stringlib_@17:

; 264  : }

  00243	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00247	c3		 ret	 0
stringlib_zfill ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EE@OGFJKBIM@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAv?$AA?0?$AA?5?$AA1@ ; `string'
PUBLIC	??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@ ; `string'
PUBLIC	??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CH@HHFIJLJJ@bytes?5object?5is?5too?5large?5to?5mak@ ; `string'
PUBLIC	PyBytes_Repr
EXTRN	_PyUnicode_CheckConsistency:PROC
EXTRN	Py_hexdigits:QWORD
EXTRN	PyUnicode_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$PyBytes_Repr DD imagerel $LN45
	DD	imagerel $LN45+1548
	DD	imagerel $unwind$PyBytes_Repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_Repr DD 021001H
	DD	0130110H
xdata	ENDS
;	COMDAT ??_C@_1EE@OGFJKBIM@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAv?$AA?0?$AA?5?$AA1@
CONST	SEGMENT
??_C@_1EE@OGFJKBIM@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAv?$AA?0?$AA?5?$AA1@ DB '_'
	DB	00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e'
	DB	00H, 'c', 00H, 'k', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 's', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'y'
	DB	00H, '(', 00H, 'v', 00H, ',', 00H, ' ', 00H, '1', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
CONST	SEGMENT
??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'v', 00H, ')', 00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'v', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'v', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HHFIJLJJ@bytes?5object?5is?5too?5large?5to?5mak@
CONST	SEGMENT
??_C@_0CH@HHFIJLJJ@bytes?5object?5is?5too?5large?5to?5mak@ DB 'bytes obje'
	DB	'ct is too large to make repr', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBytes_Repr
_TEXT	SEGMENT
p$ = 32
v$ = 40
length$ = 48
i$ = 56
s$ = 64
quote$ = 72
newsize$ = 80
squotes$ = 88
dquotes$ = 96
op$ = 104
c$22213 = 112
tv70 = 116
tv165 = 120
tv174 = 128
obj$ = 160
smartquotes$ = 168
PyBytes_Repr PROC					; COMDAT

; 594  : {

$LN45:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 595  :     register PyBytesObject* op = (PyBytesObject*) obj;

  00010	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00018	48 89 44 24 68	 mov	 QWORD PTR op$[rsp], rax

; 596  :     Py_ssize_t i, length = Py_SIZE(op);

  0001d	48 8b 44 24 68	 mov	 rax, QWORD PTR op$[rsp]
  00022	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00026	48 89 44 24 30	 mov	 QWORD PTR length$[rsp], rax

; 597  :     size_t newsize, squotes, dquotes;
; 598  :     PyObject *v;
; 599  :     unsigned char quote, *s, *p;
; 600  : 
; 601  :     /* Compute size of output string */
; 602  :     squotes = dquotes = 0;

  0002b	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR dquotes$[rsp], 0
  00034	48 8b 44 24 60	 mov	 rax, QWORD PTR dquotes$[rsp]
  00039	48 89 44 24 58	 mov	 QWORD PTR squotes$[rsp], rax

; 603  :     newsize = 3; /* b'' */

  0003e	48 c7 44 24 50
	03 00 00 00	 mov	 QWORD PTR newsize$[rsp], 3

; 604  :     s = (unsigned char*)op->ob_sval;

  00047	48 8b 44 24 68	 mov	 rax, QWORD PTR op$[rsp]
  0004c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00050	48 89 44 24 40	 mov	 QWORD PTR s$[rsp], rax

; 605  :     for (i = 0; i < length; i++) {

  00055	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0005e	eb 0d		 jmp	 SHORT $LN31@PyBytes_Re
$LN30@PyBytes_Re:
  00060	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00065	48 ff c0	 inc	 rax
  00068	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN31@PyBytes_Re:
  0006d	48 8b 44 24 30	 mov	 rax, QWORD PTR length$[rsp]
  00072	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00077	0f 8d e3 00 00
	00		 jge	 $LN29@PyBytes_Re

; 606  :         switch(s[i]) {

  0007d	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00090	89 44 24 74	 mov	 DWORD PTR tv70[rsp], eax
  00094	8b 44 24 74	 mov	 eax, DWORD PTR tv70[rsp]
  00098	83 e8 09	 sub	 eax, 9
  0009b	89 44 24 74	 mov	 DWORD PTR tv70[rsp], eax
  0009f	83 7c 24 74 53	 cmp	 DWORD PTR tv70[rsp], 83	; 00000053H
  000a4	77 68		 ja	 SHORT $LN23@PyBytes_Re
  000a6	48 63 44 24 74	 movsxd	 rax, DWORD PTR tv70[rsp]
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000b2	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN43@PyBytes_Re[rcx+rax]
  000ba	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN44@PyBytes_Re[rcx+rax*4]
  000c1	48 03 c1	 add	 rax, rcx
  000c4	ff e0		 jmp	 rax
$LN26@PyBytes_Re:

; 607  :         case '\'': squotes++; newsize++; break;

  000c6	48 8b 44 24 58	 mov	 rax, QWORD PTR squotes$[rsp]
  000cb	48 ff c0	 inc	 rax
  000ce	48 89 44 24 58	 mov	 QWORD PTR squotes$[rsp], rax
  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR newsize$[rsp]
  000d8	48 ff c0	 inc	 rax
  000db	48 89 44 24 50	 mov	 QWORD PTR newsize$[rsp], rax
  000e0	eb 79		 jmp	 SHORT $LN27@PyBytes_Re
$LN25@PyBytes_Re:

; 608  :         case '"':  dquotes++; newsize++; break;

  000e2	48 8b 44 24 60	 mov	 rax, QWORD PTR dquotes$[rsp]
  000e7	48 ff c0	 inc	 rax
  000ea	48 89 44 24 60	 mov	 QWORD PTR dquotes$[rsp], rax
  000ef	48 8b 44 24 50	 mov	 rax, QWORD PTR newsize$[rsp]
  000f4	48 ff c0	 inc	 rax
  000f7	48 89 44 24 50	 mov	 QWORD PTR newsize$[rsp], rax
  000fc	eb 5d		 jmp	 SHORT $LN27@PyBytes_Re
$LN24@PyBytes_Re:

; 609  :         case '\\': case '\t': case '\n': case '\r':
; 610  :             newsize += 2; break; /* \C */

  000fe	48 8b 44 24 50	 mov	 rax, QWORD PTR newsize$[rsp]
  00103	48 83 c0 02	 add	 rax, 2
  00107	48 89 44 24 50	 mov	 QWORD PTR newsize$[rsp], rax
  0010c	eb 4d		 jmp	 SHORT $LN27@PyBytes_Re
$LN23@PyBytes_Re:

; 611  :         default:
; 612  :             if (s[i] < ' ' || s[i] >= 0x7f)

  0010e	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00118	48 03 c8	 add	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00121	83 f8 20	 cmp	 eax, 32			; 00000020H
  00124	7c 18		 jl	 SHORT $LN21@PyBytes_Re
  00126	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0012b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00130	48 03 c8	 add	 rcx, rax
  00133	48 8b c1	 mov	 rax, rcx
  00136	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00139	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0013c	7c 10		 jl	 SHORT $LN22@PyBytes_Re
$LN21@PyBytes_Re:

; 613  :                 newsize += 4; /* \xHH */

  0013e	48 8b 44 24 50	 mov	 rax, QWORD PTR newsize$[rsp]
  00143	48 83 c0 04	 add	 rax, 4
  00147	48 89 44 24 50	 mov	 QWORD PTR newsize$[rsp], rax

; 614  :             else

  0014c	eb 0d		 jmp	 SHORT $LN20@PyBytes_Re
$LN22@PyBytes_Re:

; 615  :                 newsize++;

  0014e	48 8b 44 24 50	 mov	 rax, QWORD PTR newsize$[rsp]
  00153	48 ff c0	 inc	 rax
  00156	48 89 44 24 50	 mov	 QWORD PTR newsize$[rsp], rax
$LN20@PyBytes_Re:
$LN27@PyBytes_Re:

; 616  :         }
; 617  :     }

  0015b	e9 00 ff ff ff	 jmp	 $LN30@PyBytes_Re
$LN29@PyBytes_Re:

; 618  :     quote = '\'';

  00160	c6 44 24 48 27	 mov	 BYTE PTR quote$[rsp], 39 ; 00000027H

; 619  :     if (smartquotes && squotes && !dquotes)

  00165	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR smartquotes$[rsp], 0
  0016d	74 15		 je	 SHORT $LN19@PyBytes_Re
  0016f	48 83 7c 24 58
	00		 cmp	 QWORD PTR squotes$[rsp], 0
  00175	74 0d		 je	 SHORT $LN19@PyBytes_Re
  00177	48 83 7c 24 60
	00		 cmp	 QWORD PTR dquotes$[rsp], 0
  0017d	75 05		 jne	 SHORT $LN19@PyBytes_Re

; 620  :         quote = '"';

  0017f	c6 44 24 48 22	 mov	 BYTE PTR quote$[rsp], 34 ; 00000022H
$LN19@PyBytes_Re:

; 621  :     if (squotes && quote == '\'')

  00184	48 83 7c 24 58
	00		 cmp	 QWORD PTR squotes$[rsp], 0
  0018a	74 1f		 je	 SHORT $LN18@PyBytes_Re
  0018c	0f b6 44 24 48	 movzx	 eax, BYTE PTR quote$[rsp]
  00191	83 f8 27	 cmp	 eax, 39			; 00000027H
  00194	75 15		 jne	 SHORT $LN18@PyBytes_Re

; 622  :         newsize += squotes;

  00196	48 8b 44 24 58	 mov	 rax, QWORD PTR squotes$[rsp]
  0019b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newsize$[rsp]
  001a0	48 03 c8	 add	 rcx, rax
  001a3	48 8b c1	 mov	 rax, rcx
  001a6	48 89 44 24 50	 mov	 QWORD PTR newsize$[rsp], rax
$LN18@PyBytes_Re:

; 623  : 
; 624  :     if (newsize > (PY_SSIZE_T_MAX - sizeof(PyUnicodeObject) - 1)) {

  001ab	48 b8 4e ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775630 ; 7fffffffffffff4eH
  001b5	48 39 44 24 50	 cmp	 QWORD PTR newsize$[rsp], rax
  001ba	76 1a		 jbe	 SHORT $LN17@PyBytes_Re

; 625  :         PyErr_SetString(PyExc_OverflowError,
; 626  :             "bytes object is too large to make repr");

  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@HHFIJLJJ@bytes?5object?5is?5too?5large?5to?5mak@
  001c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001ca	e8 00 00 00 00	 call	 PyErr_SetString

; 627  :         return NULL;

  001cf	33 c0		 xor	 eax, eax
  001d1	e9 c8 03 00 00	 jmp	 $LN32@PyBytes_Re
$LN17@PyBytes_Re:

; 628  :     }
; 629  : 
; 630  :     v = PyUnicode_New(newsize, 127);

  001d6	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  001db	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newsize$[rsp]
  001e0	e8 00 00 00 00	 call	 PyUnicode_New
  001e5	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 631  :     if (v == NULL) {

  001ea	48 83 7c 24 28
	00		 cmp	 QWORD PTR v$[rsp], 0
  001f0	75 07		 jne	 SHORT $LN16@PyBytes_Re

; 632  :         return NULL;

  001f2	33 c0		 xor	 eax, eax
  001f4	e9 a5 03 00 00	 jmp	 $LN32@PyBytes_Re
$LN16@PyBytes_Re:

; 633  :     }
; 634  :     p = PyUnicode_1BYTE_DATA(v);

  001f9	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  001fe	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00202	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00208	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0020d	85 c0		 test	 eax, eax
  0020f	75 1c		 jne	 SHORT $LN34@PyBytes_Re
  00211	41 b8 7a 02 00
	00		 mov	 r8d, 634		; 0000027aH
  00217	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0022b	33 c0		 xor	 eax, eax
$LN34@PyBytes_Re:
  0022d	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00232	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00235	c1 e8 05	 shr	 eax, 5
  00238	83 e0 01	 and	 eax, 1
  0023b	85 c0		 test	 eax, eax
  0023d	0f 84 a5 00 00
	00		 je	 $LN40@PyBytes_Re
  00243	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00248	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0024c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00252	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00257	85 c0		 test	 eax, eax
  00259	75 1c		 jne	 SHORT $LN35@PyBytes_Re
  0025b	41 b8 7a 02 00
	00		 mov	 r8d, 634		; 0000027aH
  00261	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0026f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00275	33 c0		 xor	 eax, eax
$LN35@PyBytes_Re:
  00277	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  0027c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0027f	c1 e8 07	 shr	 eax, 7
  00282	83 e0 01	 and	 eax, 1
  00285	85 c0		 test	 eax, eax
  00287	75 1c		 jne	 SHORT $LN36@PyBytes_Re
  00289	41 b8 7a 02 00
	00		 mov	 r8d, 634		; 0000027aH
  0028f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002a3	33 c0		 xor	 eax, eax
$LN36@PyBytes_Re:
  002a5	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  002aa	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002ad	c1 e8 06	 shr	 eax, 6
  002b0	83 e0 01	 and	 eax, 1
  002b3	85 c0		 test	 eax, eax
  002b5	74 12		 je	 SHORT $LN37@PyBytes_Re
  002b7	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  002bc	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  002c2	48 89 44 24 78	 mov	 QWORD PTR tv165[rsp], rax
  002c7	eb 10		 jmp	 SHORT $LN38@PyBytes_Re
$LN37@PyBytes_Re:
  002c9	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  002ce	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  002d4	48 89 44 24 78	 mov	 QWORD PTR tv165[rsp], rax
$LN38@PyBytes_Re:
  002d9	48 8b 44 24 78	 mov	 rax, QWORD PTR tv165[rsp]
  002de	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
  002e6	eb 3f		 jmp	 SHORT $LN41@PyBytes_Re
$LN40@PyBytes_Re:
  002e8	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  002ed	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  002f5	75 1c		 jne	 SHORT $LN39@PyBytes_Re
  002f7	41 b8 7a 02 00
	00		 mov	 r8d, 634		; 0000027aH
  002fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
  0030b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00311	33 c0		 xor	 eax, eax
$LN39@PyBytes_Re:
  00313	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00318	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0031f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
$LN41@PyBytes_Re:
  00327	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv174[rsp]
  0032f	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 635  : 
; 636  :     *p++ = 'b', *p++ = quote;

  00334	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00339	c6 00 62	 mov	 BYTE PTR [rax], 98	; 00000062H
  0033c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00341	48 ff c0	 inc	 rax
  00344	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00349	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0034e	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR quote$[rsp]
  00353	88 08		 mov	 BYTE PTR [rax], cl
  00355	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0035a	48 ff c0	 inc	 rax
  0035d	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 637  :     for (i = 0; i < length; i++) {

  00362	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0036b	eb 0d		 jmp	 SHORT $LN15@PyBytes_Re
$LN14@PyBytes_Re:
  0036d	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00372	48 ff c0	 inc	 rax
  00375	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN15@PyBytes_Re:
  0037a	48 8b 44 24 30	 mov	 rax, QWORD PTR length$[rsp]
  0037f	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00384	0f 8d c7 01 00
	00		 jge	 $LN13@PyBytes_Re

; 638  :         unsigned char c = op->ob_sval[i];

  0038a	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0038f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op$[rsp]
  00394	48 03 c8	 add	 rcx, rax
  00397	48 8b c1	 mov	 rax, rcx
  0039a	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0039e	88 44 24 70	 mov	 BYTE PTR c$22213[rsp], al

; 639  :         if (c == quote || c == '\\')

  003a2	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$22213[rsp]
  003a7	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR quote$[rsp]
  003ac	3b c1		 cmp	 eax, ecx
  003ae	74 0a		 je	 SHORT $LN11@PyBytes_Re
  003b0	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$22213[rsp]
  003b5	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  003b8	75 33		 jne	 SHORT $LN12@PyBytes_Re
$LN11@PyBytes_Re:

; 640  :             *p++ = '\\', *p++ = c;

  003ba	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003bf	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  003c2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003c7	48 ff c0	 inc	 rax
  003ca	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  003cf	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003d4	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR c$22213[rsp]
  003d9	88 08		 mov	 BYTE PTR [rax], cl
  003db	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003e0	48 ff c0	 inc	 rax
  003e3	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  003e8	e9 5f 01 00 00	 jmp	 $LN10@PyBytes_Re
$LN12@PyBytes_Re:

; 641  :         else if (c == '\t')

  003ed	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$22213[rsp]
  003f2	83 f8 09	 cmp	 eax, 9
  003f5	75 2f		 jne	 SHORT $LN9@PyBytes_Re

; 642  :             *p++ = '\\', *p++ = 't';

  003f7	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003fc	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  003ff	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00404	48 ff c0	 inc	 rax
  00407	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0040c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00411	c6 00 74	 mov	 BYTE PTR [rax], 116	; 00000074H
  00414	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00419	48 ff c0	 inc	 rax
  0041c	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00421	e9 26 01 00 00	 jmp	 $LN8@PyBytes_Re
$LN9@PyBytes_Re:

; 643  :         else if (c == '\n')

  00426	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$22213[rsp]
  0042b	83 f8 0a	 cmp	 eax, 10
  0042e	75 2f		 jne	 SHORT $LN7@PyBytes_Re

; 644  :             *p++ = '\\', *p++ = 'n';

  00430	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00435	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  00438	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0043d	48 ff c0	 inc	 rax
  00440	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00445	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0044a	c6 00 6e	 mov	 BYTE PTR [rax], 110	; 0000006eH
  0044d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00452	48 ff c0	 inc	 rax
  00455	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0045a	e9 ed 00 00 00	 jmp	 $LN6@PyBytes_Re
$LN7@PyBytes_Re:

; 645  :         else if (c == '\r')

  0045f	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$22213[rsp]
  00464	83 f8 0d	 cmp	 eax, 13
  00467	75 2f		 jne	 SHORT $LN5@PyBytes_Re

; 646  :             *p++ = '\\', *p++ = 'r';

  00469	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0046e	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  00471	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00476	48 ff c0	 inc	 rax
  00479	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0047e	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00483	c6 00 72	 mov	 BYTE PTR [rax], 114	; 00000072H
  00486	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0048b	48 ff c0	 inc	 rax
  0048e	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00493	e9 b4 00 00 00	 jmp	 $LN4@PyBytes_Re
$LN5@PyBytes_Re:

; 647  :         else if (c < ' ' || c >= 0x7f) {

  00498	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$22213[rsp]
  0049d	83 f8 20	 cmp	 eax, 32			; 00000020H
  004a0	7c 0e		 jl	 SHORT $LN2@PyBytes_Re
  004a2	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$22213[rsp]
  004a7	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  004aa	0f 8c 83 00 00
	00		 jl	 $LN3@PyBytes_Re
$LN2@PyBytes_Re:

; 648  :             *p++ = '\\';

  004b0	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004b5	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  004b8	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004bd	48 ff c0	 inc	 rax
  004c0	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 649  :             *p++ = 'x';

  004c5	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004ca	c6 00 78	 mov	 BYTE PTR [rax], 120	; 00000078H
  004cd	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004d2	48 ff c0	 inc	 rax
  004d5	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 650  :             *p++ = Py_hexdigits[(c & 0xf0) >> 4];

  004da	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$22213[rsp]
  004df	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  004e4	c1 f8 04	 sar	 eax, 4
  004e7	48 98		 cdqe
  004e9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  004ee	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  004f5	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  004f9	88 01		 mov	 BYTE PTR [rcx], al
  004fb	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00500	48 ff c0	 inc	 rax
  00503	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 651  :             *p++ = Py_hexdigits[c & 0xf];

  00508	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$22213[rsp]
  0050d	83 e0 0f	 and	 eax, 15
  00510	48 98		 cdqe
  00512	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00517	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  0051e	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00522	88 01		 mov	 BYTE PTR [rcx], al
  00524	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00529	48 ff c0	 inc	 rax
  0052c	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 652  :         }
; 653  :         else

  00531	eb 19		 jmp	 SHORT $LN1@PyBytes_Re
$LN3@PyBytes_Re:

; 654  :             *p++ = c;

  00533	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00538	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR c$22213[rsp]
  0053d	88 08		 mov	 BYTE PTR [rax], cl
  0053f	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00544	48 ff c0	 inc	 rax
  00547	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN1@PyBytes_Re:
$LN4@PyBytes_Re:
$LN6@PyBytes_Re:
$LN8@PyBytes_Re:
$LN10@PyBytes_Re:

; 655  :     }

  0054c	e9 1c fe ff ff	 jmp	 $LN14@PyBytes_Re
$LN13@PyBytes_Re:

; 656  :     *p++ = quote;

  00551	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00556	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR quote$[rsp]
  0055b	88 08		 mov	 BYTE PTR [rax], cl
  0055d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00562	48 ff c0	 inc	 rax
  00565	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 657  :     assert(_PyUnicode_CheckConsistency(v, 1));

  0056a	ba 01 00 00 00	 mov	 edx, 1
  0056f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  00574	e8 00 00 00 00	 call	 _PyUnicode_CheckConsistency
  00579	85 c0		 test	 eax, eax
  0057b	75 1c		 jne	 SHORT $LN42@PyBytes_Re
  0057d	41 b8 91 02 00
	00		 mov	 r8d, 657		; 00000291H
  00583	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0058a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@OGFJKBIM@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAv?$AA?0?$AA?5?$AA1@
  00591	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00597	33 c0		 xor	 eax, eax
$LN42@PyBytes_Re:

; 658  :     return v;

  00599	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
$LN32@PyBytes_Re:

; 659  : }

  0059e	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  005a5	c3		 ret	 0
  005a6	66 90		 npad	 2
$LN44@PyBytes_Re:
  005a8	00 00 00 00	 DD	 $LN24@PyBytes_Re
  005ac	00 00 00 00	 DD	 $LN25@PyBytes_Re
  005b0	00 00 00 00	 DD	 $LN26@PyBytes_Re
  005b4	00 00 00 00	 DD	 $LN23@PyBytes_Re
$LN43@PyBytes_Re:
  005b8	00		 DB	 0
  005b9	00		 DB	 0
  005ba	03		 DB	 3
  005bb	03		 DB	 3
  005bc	00		 DB	 0
  005bd	03		 DB	 3
  005be	03		 DB	 3
  005bf	03		 DB	 3
  005c0	03		 DB	 3
  005c1	03		 DB	 3
  005c2	03		 DB	 3
  005c3	03		 DB	 3
  005c4	03		 DB	 3
  005c5	03		 DB	 3
  005c6	03		 DB	 3
  005c7	03		 DB	 3
  005c8	03		 DB	 3
  005c9	03		 DB	 3
  005ca	03		 DB	 3
  005cb	03		 DB	 3
  005cc	03		 DB	 3
  005cd	03		 DB	 3
  005ce	03		 DB	 3
  005cf	03		 DB	 3
  005d0	03		 DB	 3
  005d1	01		 DB	 1
  005d2	03		 DB	 3
  005d3	03		 DB	 3
  005d4	03		 DB	 3
  005d5	03		 DB	 3
  005d6	02		 DB	 2
  005d7	03		 DB	 3
  005d8	03		 DB	 3
  005d9	03		 DB	 3
  005da	03		 DB	 3
  005db	03		 DB	 3
  005dc	03		 DB	 3
  005dd	03		 DB	 3
  005de	03		 DB	 3
  005df	03		 DB	 3
  005e0	03		 DB	 3
  005e1	03		 DB	 3
  005e2	03		 DB	 3
  005e3	03		 DB	 3
  005e4	03		 DB	 3
  005e5	03		 DB	 3
  005e6	03		 DB	 3
  005e7	03		 DB	 3
  005e8	03		 DB	 3
  005e9	03		 DB	 3
  005ea	03		 DB	 3
  005eb	03		 DB	 3
  005ec	03		 DB	 3
  005ed	03		 DB	 3
  005ee	03		 DB	 3
  005ef	03		 DB	 3
  005f0	03		 DB	 3
  005f1	03		 DB	 3
  005f2	03		 DB	 3
  005f3	03		 DB	 3
  005f4	03		 DB	 3
  005f5	03		 DB	 3
  005f6	03		 DB	 3
  005f7	03		 DB	 3
  005f8	03		 DB	 3
  005f9	03		 DB	 3
  005fa	03		 DB	 3
  005fb	03		 DB	 3
  005fc	03		 DB	 3
  005fd	03		 DB	 3
  005fe	03		 DB	 3
  005ff	03		 DB	 3
  00600	03		 DB	 3
  00601	03		 DB	 3
  00602	03		 DB	 3
  00603	03		 DB	 3
  00604	03		 DB	 3
  00605	03		 DB	 3
  00606	03		 DB	 3
  00607	03		 DB	 3
  00608	03		 DB	 3
  00609	03		 DB	 3
  0060a	03		 DB	 3
  0060b	00		 DB	 0
PyBytes_Repr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_repr DD imagerel bytes_repr
	DD	imagerel bytes_repr+29
	DD	imagerel $unwind$bytes_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_repr DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_repr
_TEXT	SEGMENT
op$ = 48
bytes_repr PROC						; COMDAT

; 663  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 664  :     return PyBytes_Repr(op, 1);

  00009	ba 01 00 00 00	 mov	 edx, 1
  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00013	e8 00 00 00 00	 call	 PyBytes_Repr

; 665  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
bytes_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@CNFIHAHP@str?$CI?$CJ?5on?5a?5bytes?5instance?$AA@ ; `string'
EXTRN	PyErr_WarnEx:PROC
EXTRN	PyExc_BytesWarning:QWORD
EXTRN	Py_BytesWarningFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_str DD imagerel bytes_str
	DD	imagerel bytes_str+66
	DD	imagerel $unwind$bytes_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_str DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BK@CNFIHAHP@str?$CI?$CJ?5on?5a?5bytes?5instance?$AA@
CONST	SEGMENT
??_C@_0BK@CNFIHAHP@str?$CI?$CJ?5on?5a?5bytes?5instance?$AA@ DB 'str() on '
	DB	'a bytes instance', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_str
_TEXT	SEGMENT
op$ = 48
bytes_str PROC						; COMDAT

; 669  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 670  :     if (Py_BytesWarningFlag) {

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_BytesWarningFlag, 0
  00010	74 21		 je	 SHORT $LN2@bytes_str

; 671  :         if (PyErr_WarnEx(PyExc_BytesWarning,
; 672  :                          "str() on a bytes instance", 1))

  00012	41 b8 01 00 00
	00		 mov	 r8d, 1
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@CNFIHAHP@str?$CI?$CJ?5on?5a?5bytes?5instance?$AA@
  0001f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BytesWarning
  00026	e8 00 00 00 00	 call	 PyErr_WarnEx
  0002b	85 c0		 test	 eax, eax
  0002d	74 04		 je	 SHORT $LN1@bytes_str

; 673  :             return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 0a		 jmp	 SHORT $LN3@bytes_str
$LN1@bytes_str:
$LN2@bytes_str:

; 674  :     }
; 675  :     return bytes_repr(op);

  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00038	e8 00 00 00 00	 call	 bytes_repr
$LN3@bytes_str:

; 676  : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
bytes_str ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT bytes_length
_TEXT	SEGMENT
a$ = 8
bytes_length PROC					; COMDAT

; 680  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 681  :     return Py_SIZE(a);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR a$[rsp]
  0000a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]

; 682  : }

  0000e	c3		 ret	 0
bytes_length ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@ ; `string'
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_concat DD imagerel bytes_concat
	DD	imagerel bytes_concat+565
	DD	imagerel $unwind$bytes_concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_concat DD 021101H
	DD	01b0111H
xdata	ENDS
;	COMDAT ??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@
CONST	SEGMENT
??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@ DB 'ca'
	DB	'n''t concat %.100s to %.100s', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_concat
_TEXT	SEGMENT
va$ = 32
size$ = 112
result$ = 120
vb$ = 128
a$ = 224
b$ = 232
bytes_concat PROC					; COMDAT

; 687  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 688  :     Py_ssize_t size;
; 689  :     Py_buffer va, vb;
; 690  :     PyObject *result = NULL;

  00011	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 691  : 
; 692  :     va.len = -1;

  0001a	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR va$[rsp+16], -1

; 693  :     vb.len = -1;

  00023	48 c7 84 24 90
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR vb$[rsp+16], -1

; 694  :     if (_getbuffer(a, &va) < 0  ||
; 695  :         _getbuffer(b, &vb) < 0) {

  0002f	48 8d 54 24 20	 lea	 rdx, QWORD PTR va$[rsp]
  00034	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0003c	e8 00 00 00 00	 call	 _getbuffer
  00041	48 85 c0	 test	 rax, rax
  00044	7c 1a		 jl	 SHORT $LN7@bytes_conc
  00046	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR vb$[rsp]
  0004e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00056	e8 00 00 00 00	 call	 _getbuffer
  0005b	48 85 c0	 test	 rax, rax
  0005e	7d 38		 jge	 SHORT $LN8@bytes_conc
$LN7@bytes_conc:

; 696  :         PyErr_Format(PyExc_TypeError, "can't concat %.100s to %.100s",
; 697  :                      Py_TYPE(a)->tp_name, Py_TYPE(b)->tp_name);

  00060	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00068	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00074	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00078	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  0007c	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0008e	e8 00 00 00 00	 call	 PyErr_Format

; 698  :         goto done;

  00093	e9 66 01 00 00	 jmp	 $done$22261
$LN8@bytes_conc:

; 699  :     }
; 700  : 
; 701  :     /* Optimize end cases */
; 702  :     if (va.len == 0 && PyBytes_CheckExact(b)) {

  00098	48 83 7c 24 30
	00		 cmp	 QWORD PTR va$[rsp+16], 0
  0009e	75 31		 jne	 SHORT $LN6@bytes_conc
  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  000a7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  000af	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000b3	75 1c		 jne	 SHORT $LN6@bytes_conc

; 703  :         result = b;

  000b5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000bd	48 89 44 24 78	 mov	 QWORD PTR result$[rsp], rax

; 704  :         Py_INCREF(result);

  000c2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR result$[rsp]
  000c7	e8 00 00 00 00	 call	 _Py_IncRef

; 705  :         goto done;

  000cc	e9 2d 01 00 00	 jmp	 $done$22261
$LN6@bytes_conc:

; 706  :     }
; 707  :     if (vb.len == 0 && PyBytes_CheckExact(a)) {

  000d1	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR vb$[rsp+16], 0
  000da	75 31		 jne	 SHORT $LN5@bytes_conc
  000dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  000e3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000eb	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000ef	75 1c		 jne	 SHORT $LN5@bytes_conc

; 708  :         result = a;

  000f1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000f9	48 89 44 24 78	 mov	 QWORD PTR result$[rsp], rax

; 709  :         Py_INCREF(result);

  000fe	48 8b 4c 24 78	 mov	 rcx, QWORD PTR result$[rsp]
  00103	e8 00 00 00 00	 call	 _Py_IncRef

; 710  :         goto done;

  00108	e9 f1 00 00 00	 jmp	 $done$22261
$LN5@bytes_conc:

; 711  :     }
; 712  : 
; 713  :     size = va.len + vb.len;

  0010d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR vb$[rsp+16]
  00115	48 8b 4c 24 30	 mov	 rcx, QWORD PTR va$[rsp+16]
  0011a	48 03 c8	 add	 rcx, rax
  0011d	48 8b c1	 mov	 rax, rcx
  00120	48 89 44 24 70	 mov	 QWORD PTR size$[rsp], rax

; 714  :     if (size < 0) {

  00125	48 83 7c 24 70
	00		 cmp	 QWORD PTR size$[rsp], 0
  0012b	7d 0a		 jge	 SHORT $LN4@bytes_conc

; 715  :         PyErr_NoMemory();

  0012d	e8 00 00 00 00	 call	 PyErr_NoMemory

; 716  :         goto done;

  00132	e9 c7 00 00 00	 jmp	 $done$22261
$LN4@bytes_conc:

; 717  :     }
; 718  : 
; 719  :     result = PyBytes_FromStringAndSize(NULL, size);

  00137	48 8b 54 24 70	 mov	 rdx, QWORD PTR size$[rsp]
  0013c	33 c9		 xor	 ecx, ecx
  0013e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00143	48 89 44 24 78	 mov	 QWORD PTR result$[rsp], rax

; 720  :     if (result != NULL) {

  00148	48 83 7c 24 78
	00		 cmp	 QWORD PTR result$[rsp], 0
  0014e	0f 84 aa 00 00
	00		 je	 $LN3@bytes_conc

; 721  :         memcpy(PyBytes_AS_STRING(result), va.buf, va.len);

  00154	48 8b 44 24 78	 mov	 rax, QWORD PTR result$[rsp]
  00159	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0015d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00163	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00168	85 c0		 test	 eax, eax
  0016a	75 1c		 jne	 SHORT $LN11@bytes_conc
  0016c	41 b8 d1 02 00
	00		 mov	 r8d, 721		; 000002d1H
  00172	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00186	33 c0		 xor	 eax, eax
$LN11@bytes_conc:
  00188	48 8b 44 24 78	 mov	 rax, QWORD PTR result$[rsp]
  0018d	48 83 c0 78	 add	 rax, 120		; 00000078H
  00191	4c 8b 44 24 30	 mov	 r8, QWORD PTR va$[rsp+16]
  00196	48 8b 54 24 20	 mov	 rdx, QWORD PTR va$[rsp]
  0019b	48 8b c8	 mov	 rcx, rax
  0019e	e8 00 00 00 00	 call	 memcpy

; 722  :         memcpy(PyBytes_AS_STRING(result) + va.len, vb.buf, vb.len);

  001a3	48 8b 44 24 78	 mov	 rax, QWORD PTR result$[rsp]
  001a8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001ac	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001b2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001b7	85 c0		 test	 eax, eax
  001b9	75 1c		 jne	 SHORT $LN12@bytes_conc
  001bb	41 b8 d2 02 00
	00		 mov	 r8d, 722		; 000002d2H
  001c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d5	33 c0		 xor	 eax, eax
$LN12@bytes_conc:
  001d7	48 8b 44 24 78	 mov	 rax, QWORD PTR result$[rsp]
  001dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR va$[rsp+16]
  001e1	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  001e6	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR vb$[rsp+16]
  001ee	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR vb$[rsp]
  001f6	48 8b c8	 mov	 rcx, rax
  001f9	e8 00 00 00 00	 call	 memcpy
$LN3@bytes_conc:
$done$22261:

; 723  :     }
; 724  : 
; 725  :   done:
; 726  :     if (va.len != -1)

  001fe	48 83 7c 24 30
	ff		 cmp	 QWORD PTR va$[rsp+16], -1
  00204	74 0a		 je	 SHORT $LN2@bytes_conc

; 727  :         PyBuffer_Release(&va);

  00206	48 8d 4c 24 20	 lea	 rcx, QWORD PTR va$[rsp]
  0020b	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@bytes_conc:

; 728  :     if (vb.len != -1)

  00210	48 83 bc 24 90
	00 00 00 ff	 cmp	 QWORD PTR vb$[rsp+16], -1
  00219	74 0d		 je	 SHORT $LN1@bytes_conc

; 729  :         PyBuffer_Release(&vb);

  0021b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR vb$[rsp]
  00223	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytes_conc:

; 730  :     return result;

  00228	48 8b 44 24 78	 mov	 rax, QWORD PTR result$[rsp]

; 731  : }

  0022d	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00234	c3		 ret	 0
bytes_concat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_getbuffer DD imagerel _getbuffer
	DD	imagerel _getbuffer+142
	DD	imagerel $unwind$_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_getbuffer DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@
CONST	SEGMENT
??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@ DB 'Type %'
	DB	'.100s doesn''t support the buffer API', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _getbuffer
_TEXT	SEGMENT
buffer$ = 32
obj$ = 64
view$ = 72
_getbuffer PROC						; COMDAT

; 12   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 13   :     PyBufferProcs *buffer = Py_TYPE(obj)->tp_as_buffer;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  0001e	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax

; 14   : 
; 15   :     if (buffer == NULL || buffer->bf_getbuffer == NULL)

  00023	48 83 7c 24 20
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00029	74 0b		 je	 SHORT $LN2@getbuffer
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00030	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00034	75 29		 jne	 SHORT $LN3@getbuffer
$LN2@getbuffer:

; 16   :     {
; 17   :         PyErr_Format(PyExc_TypeError,
; 18   :                      "Type %.100s doesn't support the buffer API",
; 19   :                      Py_TYPE(obj)->tp_name);

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  0003b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00051	e8 00 00 00 00	 call	 PyErr_Format

; 20   :         return -1;

  00056	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0005d	eb 2a		 jmp	 SHORT $LN4@getbuffer
$LN3@getbuffer:

; 21   :     }
; 22   : 
; 23   :     if (buffer->bf_getbuffer(obj, view, PyBUF_SIMPLE) < 0)

  0005f	45 33 c0	 xor	 r8d, r8d
  00062	48 8b 54 24 48	 mov	 rdx, QWORD PTR view$[rsp]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00071	ff 10		 call	 QWORD PTR [rax]
  00073	85 c0		 test	 eax, eax
  00075	7d 09		 jge	 SHORT $LN1@getbuffer

; 24   :         return -1;

  00077	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0007e	eb 09		 jmp	 SHORT $LN4@getbuffer
$LN1@getbuffer:

; 25   :     return view->len;

  00080	48 8b 44 24 48	 mov	 rax, QWORD PTR view$[rsp]
  00085	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN4@getbuffer:

; 26   : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
_getbuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@PIBCFLKK@repeated?5bytes?5are?5too?5long?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_repeat DD imagerel bytes_repeat
	DD	imagerel bytes_repeat+928
	DD	imagerel $unwind$bytes_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_repeat DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0BM@PIBCFLKK@repeated?5bytes?5are?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BM@PIBCFLKK@repeated?5bytes?5are?5too?5long?$AA@ DB 'repeated byte'
	DB	's are too long', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_repeat
_TEXT	SEGMENT
i$ = 32
size$ = 40
nbytes$ = 48
op$ = 56
j$ = 64
t_$22328 = 72
s_$22330 = 80
i_$22325 = 88
n_$22326 = 96
t_$22346 = 104
s_$22348 = 112
i_$22344 = 120
n_$22345 = 128
tv153 = 136
a$ = 160
n$ = 168
bytes_repeat PROC					; COMDAT

; 735  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 736  :     register Py_ssize_t i;
; 737  :     register Py_ssize_t j;
; 738  :     register Py_ssize_t size;
; 739  :     register PyBytesObject *op;
; 740  :     size_t nbytes;
; 741  :     if (n < 0)

  00011	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  0001a	7d 0c		 jge	 SHORT $LN25@bytes_repe

; 742  :         n = 0;

  0001c	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR n$[rsp], 0
$LN25@bytes_repe:

; 743  :     /* watch out for overflows:  the size can overflow int,
; 744  :      * and the # of bytes needed can overflow size_t
; 745  :      */
; 746  :     if (n > 0 && Py_SIZE(a) > PY_SSIZE_T_MAX / n) {

  00028	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  00031	7e 3c		 jle	 SHORT $LN24@bytes_repe
  00033	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0003d	48 99		 cdq
  0003f	48 f7 bc 24 a8
	00 00 00	 idiv	 QWORD PTR n$[rsp]
  00047	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0004f	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00053	7e 1a		 jle	 SHORT $LN24@bytes_repe

; 747  :         PyErr_SetString(PyExc_OverflowError,
; 748  :             "repeated bytes are too long");

  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PIBCFLKK@repeated?5bytes?5are?5too?5long?$AA@
  0005c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00063	e8 00 00 00 00	 call	 PyErr_SetString

; 749  :         return NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 29 03 00 00	 jmp	 $LN26@bytes_repe
$LN24@bytes_repe:

; 750  :     }
; 751  :     size = Py_SIZE(a) * n;

  0006f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00077	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0007b	48 0f af 84 24
	a8 00 00 00	 imul	 rax, QWORD PTR n$[rsp]
  00084	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 752  :     if (size == Py_SIZE(a) && PyBytes_CheckExact(a)) {

  00089	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00091	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00095	48 39 44 24 28	 cmp	 QWORD PTR size$[rsp], rax
  0009a	75 2f		 jne	 SHORT $LN23@bytes_repe
  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  000a3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000ab	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000af	75 1a		 jne	 SHORT $LN23@bytes_repe

; 753  :         Py_INCREF(a);

  000b1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000b9	e8 00 00 00 00	 call	 _Py_IncRef

; 754  :         return (PyObject *)a;

  000be	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000c6	e9 cd 02 00 00	 jmp	 $LN26@bytes_repe
$LN23@bytes_repe:

; 755  :     }
; 756  :     nbytes = (size_t)size;

  000cb	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000d0	48 89 44 24 30	 mov	 QWORD PTR nbytes$[rsp], rax

; 757  :     if (nbytes + PyBytesObject_SIZE <= nbytes) {

  000d5	48 8b 44 24 30	 mov	 rax, QWORD PTR nbytes$[rsp]
  000da	48 83 c0 79	 add	 rax, 121		; 00000079H
  000de	48 3b 44 24 30	 cmp	 rax, QWORD PTR nbytes$[rsp]
  000e3	77 1a		 ja	 SHORT $LN22@bytes_repe

; 758  :         PyErr_SetString(PyExc_OverflowError,
; 759  :             "repeated bytes are too long");

  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PIBCFLKK@repeated?5bytes?5are?5too?5long?$AA@
  000ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000f3	e8 00 00 00 00	 call	 PyErr_SetString

; 760  :         return NULL;

  000f8	33 c0		 xor	 eax, eax
  000fa	e9 99 02 00 00	 jmp	 $LN26@bytes_repe
$LN22@bytes_repe:

; 761  :     }
; 762  :     op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + nbytes);

  000ff	48 8b 44 24 30	 mov	 rax, QWORD PTR nbytes$[rsp]
  00104	48 83 c0 79	 add	 rax, 121		; 00000079H
  00108	48 8b c8	 mov	 rcx, rax
  0010b	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00110	48 89 44 24 38	 mov	 QWORD PTR op$[rsp], rax

; 763  :     if (op == NULL)

  00115	48 83 7c 24 38
	00		 cmp	 QWORD PTR op$[rsp], 0
  0011b	75 0a		 jne	 SHORT $LN21@bytes_repe

; 764  :         return PyErr_NoMemory();

  0011d	e8 00 00 00 00	 call	 PyErr_NoMemory
  00122	e9 71 02 00 00	 jmp	 $LN26@bytes_repe
$LN21@bytes_repe:

; 765  :     PyObject_INIT_VAR((PyVarObject *)op, &PyBytes_Type, size);

  00127	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  0012c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyBytes_Type
  00133	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$[rsp]
  00138	e8 00 00 00 00	 call	 PyObject_INIT_VAR

; 766  :     op->ob_shash = -1;

  0013d	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  00142	48 c7 40 70 ff
	ff ff ff	 mov	 QWORD PTR [rax+112], -1

; 767  :     op->ob_sval[size] = '\0';

  0014a	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  0014f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$[rsp]
  00154	48 03 c8	 add	 rcx, rax
  00157	48 8b c1	 mov	 rax, rcx
  0015a	c6 40 78 00	 mov	 BYTE PTR [rax+120], 0

; 768  :     if (Py_SIZE(a) == 1 && n > 0) {

  0015e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00166	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  0016b	75 39		 jne	 SHORT $LN20@bytes_repe
  0016d	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  00176	7e 2e		 jle	 SHORT $LN20@bytes_repe

; 769  :         memset(op->ob_sval, a->ob_sval[0] , n);

  00178	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00180	0f be 40 78	 movsx	 eax, BYTE PTR [rax+120]
  00184	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$[rsp]
  00189	48 83 c1 78	 add	 rcx, 120		; 00000078H
  0018d	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR n$[rsp]
  00195	8b d0		 mov	 edx, eax
  00197	e8 00 00 00 00	 call	 memset

; 770  :         return (PyObject *) op;

  0019c	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  001a1	e9 f2 01 00 00	 jmp	 $LN26@bytes_repe
$LN20@bytes_repe:

; 771  :     }
; 772  :     i = 0;

  001a6	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0

; 773  :     if (i < size) {

  001af	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  001b4	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  001b9	0f 8d b4 00 00
	00		 jge	 $LN19@bytes_repe
$LN18@bytes_repe:

; 774  :         Py_MEMCPY(op->ob_sval, a->ob_sval, Py_SIZE(a));

  001bf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001c7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001cb	48 89 44 24 60	 mov	 QWORD PTR n_$22326[rsp], rax
  001d0	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  001d5	48 83 c0 78	 add	 rax, 120		; 00000078H
  001d9	48 89 44 24 48	 mov	 QWORD PTR t_$22328[rsp], rax
  001de	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001e6	48 83 c0 78	 add	 rax, 120		; 00000078H
  001ea	48 89 44 24 50	 mov	 QWORD PTR s_$22330[rsp], rax
  001ef	48 83 7c 24 60
	10		 cmp	 QWORD PTR n_$22326[rsp], 16
  001f5	72 16		 jb	 SHORT $LN15@bytes_repe
  001f7	4c 8b 44 24 60	 mov	 r8, QWORD PTR n_$22326[rsp]
  001fc	48 8b 54 24 50	 mov	 rdx, QWORD PTR s_$22330[rsp]
  00201	48 8b 4c 24 48	 mov	 rcx, QWORD PTR t_$22328[rsp]
  00206	e8 00 00 00 00	 call	 memcpy
  0020b	eb 4b		 jmp	 SHORT $LN14@bytes_repe
$LN15@bytes_repe:
  0020d	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR i_$22325[rsp], 0
  00216	eb 0d		 jmp	 SHORT $LN13@bytes_repe
$LN12@bytes_repe:
  00218	48 8b 44 24 58	 mov	 rax, QWORD PTR i_$22325[rsp]
  0021d	48 ff c0	 inc	 rax
  00220	48 89 44 24 58	 mov	 QWORD PTR i_$22325[rsp], rax
$LN13@bytes_repe:
  00225	48 8b 44 24 60	 mov	 rax, QWORD PTR n_$22326[rsp]
  0022a	48 39 44 24 58	 cmp	 QWORD PTR i_$22325[rsp], rax
  0022f	73 27		 jae	 SHORT $LN11@bytes_repe
  00231	48 8b 44 24 58	 mov	 rax, QWORD PTR i_$22325[rsp]
  00236	48 8b 4c 24 48	 mov	 rcx, QWORD PTR t_$22328[rsp]
  0023b	48 03 c8	 add	 rcx, rax
  0023e	48 8b c1	 mov	 rax, rcx
  00241	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i_$22325[rsp]
  00246	48 8b 54 24 50	 mov	 rdx, QWORD PTR s_$22330[rsp]
  0024b	48 03 d1	 add	 rdx, rcx
  0024e	48 8b ca	 mov	 rcx, rdx
  00251	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00254	88 08		 mov	 BYTE PTR [rax], cl
  00256	eb c0		 jmp	 SHORT $LN12@bytes_repe
$LN11@bytes_repe:
$LN14@bytes_repe:
  00258	33 c0		 xor	 eax, eax
  0025a	85 c0		 test	 eax, eax
  0025c	0f 85 5d ff ff
	ff		 jne	 $LN18@bytes_repe

; 775  :         i = Py_SIZE(a);

  00262	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0026a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0026e	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN19@bytes_repe:
$LN10@bytes_repe:

; 776  :     }
; 777  :     while (i < size) {

  00273	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00278	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0027d	0f 8d 10 01 00
	00		 jge	 $LN9@bytes_repe

; 778  :         j = (i <= size-i)  ?  i  :  size-i;

  00283	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00288	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  0028d	48 2b c8	 sub	 rcx, rax
  00290	48 8b c1	 mov	 rax, rcx
  00293	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00298	7f 0f		 jg	 SHORT $LN28@bytes_repe
  0029a	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0029f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv153[rsp], rax
  002a7	eb 18		 jmp	 SHORT $LN29@bytes_repe
$LN28@bytes_repe:
  002a9	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  002ae	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  002b3	48 2b c8	 sub	 rcx, rax
  002b6	48 8b c1	 mov	 rax, rcx
  002b9	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv153[rsp], rax
$LN29@bytes_repe:
  002c1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv153[rsp]
  002c9	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
$LN8@bytes_repe:

; 779  :         Py_MEMCPY(op->ob_sval+i, op->ob_sval, j);

  002ce	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  002d3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n_$22345[rsp], rax
  002db	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  002e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  002e5	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  002ea	48 89 44 24 68	 mov	 QWORD PTR t_$22346[rsp], rax
  002ef	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  002f4	48 83 c0 78	 add	 rax, 120		; 00000078H
  002f8	48 89 44 24 70	 mov	 QWORD PTR s_$22348[rsp], rax
  002fd	48 83 bc 24 80
	00 00 00 10	 cmp	 QWORD PTR n_$22345[rsp], 16
  00306	72 19		 jb	 SHORT $LN5@bytes_repe
  00308	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR n_$22345[rsp]
  00310	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$22348[rsp]
  00315	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$22346[rsp]
  0031a	e8 00 00 00 00	 call	 memcpy
  0031f	eb 4e		 jmp	 SHORT $LN4@bytes_repe
$LN5@bytes_repe:
  00321	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i_$22344[rsp], 0
  0032a	eb 0d		 jmp	 SHORT $LN3@bytes_repe
$LN2@bytes_repe:
  0032c	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$22344[rsp]
  00331	48 ff c0	 inc	 rax
  00334	48 89 44 24 78	 mov	 QWORD PTR i_$22344[rsp], rax
$LN3@bytes_repe:
  00339	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n_$22345[rsp]
  00341	48 39 44 24 78	 cmp	 QWORD PTR i_$22344[rsp], rax
  00346	73 27		 jae	 SHORT $LN1@bytes_repe
  00348	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$22344[rsp]
  0034d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$22346[rsp]
  00352	48 03 c8	 add	 rcx, rax
  00355	48 8b c1	 mov	 rax, rcx
  00358	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i_$22344[rsp]
  0035d	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$22348[rsp]
  00362	48 03 d1	 add	 rdx, rcx
  00365	48 8b ca	 mov	 rcx, rdx
  00368	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0036b	88 08		 mov	 BYTE PTR [rax], cl
  0036d	eb bd		 jmp	 SHORT $LN2@bytes_repe
$LN1@bytes_repe:
$LN4@bytes_repe:
  0036f	33 c0		 xor	 eax, eax
  00371	85 c0		 test	 eax, eax
  00373	0f 85 55 ff ff
	ff		 jne	 $LN8@bytes_repe

; 780  :         i += j;

  00379	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0037e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00383	48 03 c8	 add	 rcx, rax
  00386	48 8b c1	 mov	 rax, rcx
  00389	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 781  :     }

  0038e	e9 e0 fe ff ff	 jmp	 $LN10@bytes_repe
$LN9@bytes_repe:

; 782  :     return (PyObject *) op;

  00393	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
$LN26@bytes_repe:

; 783  : }

  00398	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0039f	c3		 ret	 0
bytes_repeat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@ ; `string'
EXTRN	__imp_memchr:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_contains DD imagerel bytes_contains
	DD	imagerel bytes_contains+455
	DD	imagerel $unwind$bytes_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_contains DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@ DB 'byt'
	DB	'e must be in range(0, 256)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_contains
_TEXT	SEGMENT
ival$ = 48
pos$22365 = 56
varg$22364 = 64
tv92 = 144
tv144 = 148
self$ = 176
arg$ = 184
bytes_contains PROC					; COMDAT

; 787  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 788  :     Py_ssize_t ival = PyNumber_AsSsize_t(arg, PyExc_ValueError);

  00011	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_ValueError
  00018	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00020	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00025	48 89 44 24 30	 mov	 QWORD PTR ival$[rsp], rax

; 789  :     if (ival == -1 && PyErr_Occurred()) {

  0002a	48 83 7c 24 30
	ff		 cmp	 QWORD PTR ival$[rsp], -1
  00030	0f 85 d9 00 00
	00		 jne	 $LN4@bytes_cont
  00036	e8 00 00 00 00	 call	 PyErr_Occurred
  0003b	48 85 c0	 test	 rax, rax
  0003e	0f 84 cb 00 00
	00		 je	 $LN4@bytes_cont

; 790  :         Py_buffer varg;
; 791  :         Py_ssize_t pos;
; 792  :         PyErr_Clear();

  00044	e8 00 00 00 00	 call	 PyErr_Clear

; 793  :         if (_getbuffer(arg, &varg) < 0)

  00049	48 8d 54 24 40	 lea	 rdx, QWORD PTR varg$22364[rsp]
  0004e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00056	e8 00 00 00 00	 call	 _getbuffer
  0005b	48 85 c0	 test	 rax, rax
  0005e	7d 0a		 jge	 SHORT $LN3@bytes_cont

; 794  :             return -1;

  00060	b8 ff ff ff ff	 mov	 eax, -1
  00065	e9 55 01 00 00	 jmp	 $LN5@bytes_cont
$LN3@bytes_cont:

; 795  :         pos = stringlib_find(PyBytes_AS_STRING(self), Py_SIZE(self),
; 796  :                              varg.buf, varg.len, 0);

  0006a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00072	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00076	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0007c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00081	85 c0		 test	 eax, eax
  00083	75 1c		 jne	 SHORT $LN7@bytes_cont
  00085	41 b8 1b 03 00
	00		 mov	 r8d, 795		; 0000031bH
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009f	33 c0		 xor	 eax, eax
$LN7@bytes_cont:
  000a1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a9	48 83 c0 78	 add	 rax, 120		; 00000078H
  000ad	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000b6	4c 8b 4c 24 50	 mov	 r9, QWORD PTR varg$22364[rsp+16]
  000bb	4c 8b 44 24 40	 mov	 r8, QWORD PTR varg$22364[rsp]
  000c0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000c8	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  000cc	48 8b c8	 mov	 rcx, rax
  000cf	e8 00 00 00 00	 call	 stringlib_find
  000d4	48 89 44 24 38	 mov	 QWORD PTR pos$22365[rsp], rax

; 797  :         PyBuffer_Release(&varg);

  000d9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR varg$22364[rsp]
  000de	e8 00 00 00 00	 call	 PyBuffer_Release

; 798  :         return pos >= 0;

  000e3	48 83 7c 24 38
	00		 cmp	 QWORD PTR pos$22365[rsp], 0
  000e9	7c 0d		 jl	 SHORT $LN8@bytes_cont
  000eb	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv92[rsp], 1
  000f6	eb 0b		 jmp	 SHORT $LN9@bytes_cont
$LN8@bytes_cont:
  000f8	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv92[rsp], 0
$LN9@bytes_cont:
  00103	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv92[rsp]
  0010a	e9 b0 00 00 00	 jmp	 $LN5@bytes_cont
$LN4@bytes_cont:

; 799  :     }
; 800  :     if (ival < 0 || ival >= 256) {

  0010f	48 83 7c 24 30
	00		 cmp	 QWORD PTR ival$[rsp], 0
  00115	7c 0b		 jl	 SHORT $LN1@bytes_cont
  00117	48 81 7c 24 30
	00 01 00 00	 cmp	 QWORD PTR ival$[rsp], 256 ; 00000100H
  00120	7c 1d		 jl	 SHORT $LN2@bytes_cont
$LN1@bytes_cont:

; 801  :         PyErr_SetString(PyExc_ValueError, "byte must be in range(0, 256)");

  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  00129	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00130	e8 00 00 00 00	 call	 PyErr_SetString

; 802  :         return -1;

  00135	b8 ff ff ff ff	 mov	 eax, -1
  0013a	e9 80 00 00 00	 jmp	 $LN5@bytes_cont
$LN2@bytes_cont:

; 803  :     }
; 804  : 
; 805  :     return memchr(PyBytes_AS_STRING(self), (int) ival, Py_SIZE(self)) != NULL;

  0013f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00147	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0014b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00151	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00156	85 c0		 test	 eax, eax
  00158	75 1c		 jne	 SHORT $LN10@bytes_cont
  0015a	41 b8 25 03 00
	00		 mov	 r8d, 805		; 00000325H
  00160	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00174	33 c0		 xor	 eax, eax
$LN10@bytes_cont:
  00176	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0017e	48 83 c0 78	 add	 rax, 120		; 00000078H
  00182	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0018a	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  0018e	8b 54 24 30	 mov	 edx, DWORD PTR ival$[rsp]
  00192	48 8b c8	 mov	 rcx, rax
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0019b	48 85 c0	 test	 rax, rax
  0019e	74 0d		 je	 SHORT $LN11@bytes_cont
  001a0	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv144[rsp], 1
  001ab	eb 0b		 jmp	 SHORT $LN12@bytes_cont
$LN11@bytes_cont:
  001ad	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv144[rsp], 0
$LN12@bytes_cont:
  001b8	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv144[rsp]
$LN5@bytes_cont:

; 806  : }

  001bf	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001c6	c3		 ret	 0
bytes_contains ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$stringlib_find DD imagerel stringlib_find
	DD	imagerel stringlib_find+142
	DD	imagerel $unwind$stringlib_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_find DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_find
_TEXT	SEGMENT
pos$ = 48
str$ = 80
str_len$ = 88
sub$ = 96
sub_len$ = 104
offset$ = 112
stringlib_find PROC					; COMDAT

; 11   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 12   :     Py_ssize_t pos;
; 13   : 
; 14   :     if (str_len < 0)

  00018	48 83 7c 24 58
	00		 cmp	 QWORD PTR str_len$[rsp], 0
  0001e	7d 09		 jge	 SHORT $LN3@stringlib_@18

; 15   :         return -1;

  00020	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00027	eb 60		 jmp	 SHORT $LN4@stringlib_@18
$LN3@stringlib_@18:

; 16   :     if (sub_len == 0)

  00029	48 83 7c 24 68
	00		 cmp	 QWORD PTR sub_len$[rsp], 0
  0002f	75 07		 jne	 SHORT $LN2@stringlib_@18

; 17   :         return offset;

  00031	48 8b 44 24 70	 mov	 rax, QWORD PTR offset$[rsp]
  00036	eb 51		 jmp	 SHORT $LN4@stringlib_@18
$LN2@stringlib_@18:

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

  00038	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  00040	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  00049	4c 8b 4c 24 68	 mov	 r9, QWORD PTR sub_len$[rsp]
  0004e	4c 8b 44 24 60	 mov	 r8, QWORD PTR sub$[rsp]
  00053	48 8b 54 24 58	 mov	 rdx, QWORD PTR str_len$[rsp]
  00058	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  0005d	e8 00 00 00 00	 call	 fastsearch
  00062	48 89 44 24 30	 mov	 QWORD PTR pos$[rsp], rax

; 20   : 
; 21   :     if (pos >= 0)

  00067	48 83 7c 24 30
	00		 cmp	 QWORD PTR pos$[rsp], 0
  0006d	7c 15		 jl	 SHORT $LN1@stringlib_@18

; 22   :         pos += offset;

  0006f	48 8b 44 24 70	 mov	 rax, QWORD PTR offset$[rsp]
  00074	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pos$[rsp]
  00079	48 03 c8	 add	 rcx, rax
  0007c	48 8b c1	 mov	 rax, rcx
  0007f	48 89 44 24 30	 mov	 QWORD PTR pos$[rsp], rax
$LN1@stringlib_@18:

; 23   : 
; 24   :     return pos;

  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR pos$[rsp]
$LN4@stringlib_@18:

; 25   : }

  00089	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008d	c3		 ret	 0
stringlib_find ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$fastsearch DD imagerel fastsearch
	DD	imagerel fastsearch+2017
	DD	imagerel $unwind$fastsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fastsearch DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fastsearch
_TEXT	SEGMENT
w$ = 48
count$ = 56
i$ = 64
mask$ = 72
skip$ = 80
mlast$ = 88
j$ = 96
needle$21056 = 104
tv298 = 108
tv312 = 112
tv339 = 116
tv351 = 120
tv359 = 124
tv368 = 128
tv391 = 132
tv402 = 136
s$ = 160
n$ = 168
p$ = 176
m$ = 184
maxcount$ = 192
mode$ = 200
fastsearch PROC						; COMDAT

; 87   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 88   :     unsigned long mask;
; 89   :     Py_ssize_t skip, count = 0;

  0001b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 90   :     Py_ssize_t i, j, mlast, w;
; 91   : 
; 92   :     w = n - m;

  00024	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  0002c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00034	48 2b c8	 sub	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 89 44 24 30	 mov	 QWORD PTR w$[rsp], rax

; 93   : 
; 94   :     if (w < 0 || (mode == FAST_COUNT && maxcount == 0))

  0003f	48 83 7c 24 30
	00		 cmp	 QWORD PTR w$[rsp], 0
  00045	7c 15		 jl	 SHORT $LN60@fastsearch
  00047	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  0004f	75 17		 jne	 SHORT $LN61@fastsearch
  00051	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR maxcount$[rsp], 0
  0005a	75 0c		 jne	 SHORT $LN61@fastsearch
$LN60@fastsearch:

; 95   :         return -1;

  0005c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00063	e9 71 07 00 00	 jmp	 $LN62@fastsearch
$LN61@fastsearch:

; 96   : 
; 97   :     /* look for special cases */
; 98   :     if (m <= 1) {

  00068	48 83 bc 24 b8
	00 00 00 01	 cmp	 QWORD PTR m$[rsp], 1
  00071	0f 8f e0 01 00
	00		 jg	 $LN59@fastsearch

; 99   :         if (m <= 0)

  00077	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR m$[rsp], 0
  00080	7f 0c		 jg	 SHORT $LN58@fastsearch

; 100  :             return -1;

  00082	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00089	e9 4b 07 00 00	 jmp	 $LN62@fastsearch
$LN58@fastsearch:

; 101  :         /* use special case for 1-character strings */
; 102  :         if (n > 10 && (mode == FAST_SEARCH
; 103  : #ifdef HAVE_MEMRCHR
; 104  :                     || mode == FAST_RSEARCH
; 105  : #endif
; 106  :                     )) {

  0008e	48 83 bc 24 a8
	00 00 00 0a	 cmp	 QWORD PTR n$[rsp], 10
  00097	7e 62		 jle	 SHORT $LN57@fastsearch
  00099	83 bc 24 c8 00
	00 00 01	 cmp	 DWORD PTR mode$[rsp], 1
  000a1	75 58		 jne	 SHORT $LN57@fastsearch

; 107  :             /* use memchr if we can choose a needle without two many likely
; 108  :                false positives */
; 109  :             unsigned char needle;
; 110  :             needle = p[0] & 0xff;

  000a3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  000ab	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b3	88 44 24 68	 mov	 BYTE PTR needle$21056[rsp], al

; 111  : #if STRINGLIB_SIZEOF_CHAR > 1
; 112  :             /* If looking for a multiple of 256, we'd have too
; 113  :                many false positives looking for the '\0' byte in UCS2
; 114  :                and UCS4 representations. */
; 115  :             if (needle != 0)
; 116  : #endif
; 117  :                 return STRINGLIB(fastsearch_memchr_1char)
; 118  :                        (s, n, p[0], needle, maxcount, mode);

  000b7	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR mode$[rsp]
  000be	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000c2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cf	44 0f b6 4c 24
	68		 movzx	 r9d, BYTE PTR needle$21056[rsp]
  000d5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  000dd	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  000e1	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  000e9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f1	e8 00 00 00 00	 call	 stringlib_fastsearch_memchr_1char
  000f6	e9 de 06 00 00	 jmp	 $LN62@fastsearch
$LN57@fastsearch:

; 119  :         }
; 120  :         if (mode == FAST_COUNT) {

  000fb	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  00103	0f 85 86 00 00
	00		 jne	 $LN56@fastsearch

; 121  :             for (i = 0; i < n; i++)

  00109	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00112	eb 0d		 jmp	 SHORT $LN55@fastsearch
$LN54@fastsearch:
  00114	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00119	48 ff c0	 inc	 rax
  0011c	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN55@fastsearch:
  00121	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00129	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  0012e	7d 50		 jge	 SHORT $LN53@fastsearch

; 122  :                 if (s[i] == p[0]) {

  00130	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00135	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0013d	48 03 c8	 add	 rcx, rax
  00140	48 8b c1	 mov	 rax, rcx
  00143	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00146	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  0014e	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00151	3b c1		 cmp	 eax, ecx
  00153	75 29		 jne	 SHORT $LN52@fastsearch

; 123  :                     count++;

  00155	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  0015a	48 ff c0	 inc	 rax
  0015d	48 89 44 24 38	 mov	 QWORD PTR count$[rsp], rax

; 124  :                     if (count == maxcount)

  00162	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0016a	48 39 44 24 38	 cmp	 QWORD PTR count$[rsp], rax
  0016f	75 0d		 jne	 SHORT $LN51@fastsearch

; 125  :                         return maxcount;

  00171	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00179	e9 5b 06 00 00	 jmp	 $LN62@fastsearch
$LN51@fastsearch:
$LN52@fastsearch:

; 126  :                 }

  0017e	eb 94		 jmp	 SHORT $LN54@fastsearch
$LN53@fastsearch:

; 127  :             return count;

  00180	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  00185	e9 4f 06 00 00	 jmp	 $LN62@fastsearch
  0018a	e9 bc 00 00 00	 jmp	 $LN50@fastsearch
$LN56@fastsearch:

; 128  :         } else if (mode == FAST_SEARCH) {

  0018f	83 bc 24 c8 00
	00 00 01	 cmp	 DWORD PTR mode$[rsp], 1
  00197	75 5a		 jne	 SHORT $LN49@fastsearch

; 129  :             for (i = 0; i < n; i++)

  00199	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001a2	eb 0d		 jmp	 SHORT $LN48@fastsearch
$LN47@fastsearch:
  001a4	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001a9	48 ff c0	 inc	 rax
  001ac	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN48@fastsearch:
  001b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001b9	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  001be	7d 31		 jge	 SHORT $LN46@fastsearch

; 130  :                 if (s[i] == p[0])

  001c0	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001c5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001cd	48 03 c8	 add	 rcx, rax
  001d0	48 8b c1	 mov	 rax, rcx
  001d3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001d6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  001de	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  001e1	3b c1		 cmp	 eax, ecx
  001e3	75 0a		 jne	 SHORT $LN45@fastsearch

; 131  :                     return i;

  001e5	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001ea	e9 ea 05 00 00	 jmp	 $LN62@fastsearch
$LN45@fastsearch:

; 132  :         } else {    /* FAST_RSEARCH */

  001ef	eb b3		 jmp	 SHORT $LN47@fastsearch
$LN46@fastsearch:
  001f1	eb 58		 jmp	 SHORT $LN44@fastsearch
$LN49@fastsearch:

; 133  :             for (i = n - 1; i > -1; i--)

  001f3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001fb	48 ff c8	 dec	 rax
  001fe	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00203	eb 0d		 jmp	 SHORT $LN43@fastsearch
$LN42@fastsearch:
  00205	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0020a	48 ff c8	 dec	 rax
  0020d	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN43@fastsearch:
  00212	48 83 7c 24 40
	ff		 cmp	 QWORD PTR i$[rsp], -1
  00218	7e 31		 jle	 SHORT $LN41@fastsearch

; 134  :                 if (s[i] == p[0])

  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0021f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00227	48 03 c8	 add	 rcx, rax
  0022a	48 8b c1	 mov	 rax, rcx
  0022d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00230	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00238	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  0023b	3b c1		 cmp	 eax, ecx
  0023d	75 0a		 jne	 SHORT $LN40@fastsearch

; 135  :                     return i;

  0023f	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00244	e9 90 05 00 00	 jmp	 $LN62@fastsearch
$LN40@fastsearch:

; 136  :         }

  00249	eb ba		 jmp	 SHORT $LN42@fastsearch
$LN41@fastsearch:
$LN44@fastsearch:
$LN50@fastsearch:

; 137  :         return -1;

  0024b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00252	e9 82 05 00 00	 jmp	 $LN62@fastsearch
$LN59@fastsearch:

; 138  :     }
; 139  : 
; 140  :     mlast = m - 1;

  00257	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  0025f	48 ff c8	 dec	 rax
  00262	48 89 44 24 58	 mov	 QWORD PTR mlast$[rsp], rax

; 141  :     skip = mlast - 1;

  00267	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  0026c	48 ff c8	 dec	 rax
  0026f	48 89 44 24 50	 mov	 QWORD PTR skip$[rsp], rax

; 142  :     mask = 0;

  00274	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR mask$[rsp], 0

; 143  : 
; 144  :     if (mode != FAST_RSEARCH) {

  0027c	83 bc 24 c8 00
	00 00 02	 cmp	 DWORD PTR mode$[rsp], 2
  00284	0f 84 e1 02 00
	00		 je	 $LN39@fastsearch

; 145  : 
; 146  :         /* create compressed boyer-moore delta 1 table */
; 147  : 
; 148  :         /* process pattern[:-1] */
; 149  :         for (i = 0; i < mlast; i++) {

  0028a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00293	eb 0d		 jmp	 SHORT $LN38@fastsearch
$LN37@fastsearch:
  00295	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0029a	48 ff c0	 inc	 rax
  0029d	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN38@fastsearch:
  002a2	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  002a7	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  002ac	0f 8d 84 00 00
	00		 jge	 $LN36@fastsearch

; 150  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  002b2	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  002b7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  002bf	48 03 c8	 add	 rcx, rax
  002c2	48 8b c1	 mov	 rax, rcx
  002c5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002c8	83 e0 1f	 and	 eax, 31
  002cb	b9 01 00 00 00	 mov	 ecx, 1
  002d0	89 4c 24 6c	 mov	 DWORD PTR tv298[rsp], ecx
  002d4	0f b6 c8	 movzx	 ecx, al
  002d7	8b 44 24 6c	 mov	 eax, DWORD PTR tv298[rsp]
  002db	d3 e0		 shl	 eax, cl
  002dd	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  002e1	0b c8		 or	 ecx, eax
  002e3	8b c1		 mov	 eax, ecx
  002e5	89 44 24 48	 mov	 DWORD PTR mask$[rsp], eax

; 151  :             if (p[i] == p[mlast])

  002e9	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  002ee	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  002f6	48 03 c8	 add	 rcx, rax
  002f9	48 8b c1	 mov	 rax, rcx
  002fc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR mlast$[rsp]
  00304	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  0030c	48 03 d1	 add	 rdx, rcx
  0030f	48 8b ca	 mov	 rcx, rdx
  00312	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00315	3b c1		 cmp	 eax, ecx
  00317	75 18		 jne	 SHORT $LN35@fastsearch

; 152  :                 skip = mlast - i - 1;

  00319	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0031e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR mlast$[rsp]
  00323	48 2b c8	 sub	 rcx, rax
  00326	48 8b c1	 mov	 rax, rcx
  00329	48 ff c8	 dec	 rax
  0032c	48 89 44 24 50	 mov	 QWORD PTR skip$[rsp], rax
$LN35@fastsearch:

; 153  :         }

  00331	e9 5f ff ff ff	 jmp	 $LN37@fastsearch
$LN36@fastsearch:

; 154  :         /* process pattern[-1] outside the loop */
; 155  :         STRINGLIB_BLOOM_ADD(mask, p[mlast]);

  00336	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  0033b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00343	48 03 c8	 add	 rcx, rax
  00346	48 8b c1	 mov	 rax, rcx
  00349	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0034c	83 e0 1f	 and	 eax, 31
  0034f	b9 01 00 00 00	 mov	 ecx, 1
  00354	89 4c 24 70	 mov	 DWORD PTR tv312[rsp], ecx
  00358	0f b6 c8	 movzx	 ecx, al
  0035b	8b 44 24 70	 mov	 eax, DWORD PTR tv312[rsp]
  0035f	d3 e0		 shl	 eax, cl
  00361	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  00365	0b c8		 or	 ecx, eax
  00367	8b c1		 mov	 eax, ecx
  00369	89 44 24 48	 mov	 DWORD PTR mask$[rsp], eax

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  0036d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00376	eb 0d		 jmp	 SHORT $LN34@fastsearch
$LN33@fastsearch:
  00378	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0037d	48 ff c0	 inc	 rax
  00380	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN34@fastsearch:
  00385	48 8b 44 24 30	 mov	 rax, QWORD PTR w$[rsp]
  0038a	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  0038f	0f 8f d1 01 00
	00		 jg	 $LN32@fastsearch

; 158  :             /* note: using mlast in the skip path slows things down on x86 */
; 159  :             if (s[i+m-1] == p[m-1]) {

  00395	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  0039d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  003a2	48 03 c8	 add	 rcx, rax
  003a5	48 8b c1	 mov	 rax, rcx
  003a8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003b0	0f be 44 01 ff	 movsx	 eax, BYTE PTR [rcx+rax-1]
  003b5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR m$[rsp]
  003bd	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  003c5	48 03 d1	 add	 rdx, rcx
  003c8	48 8b ca	 mov	 rcx, rdx
  003cb	0f be 49 ff	 movsx	 ecx, BYTE PTR [rcx-1]
  003cf	3b c1		 cmp	 eax, ecx
  003d1	0f 85 32 01 00
	00		 jne	 $LN31@fastsearch

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  003d7	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  003e0	eb 0d		 jmp	 SHORT $LN30@fastsearch
$LN29@fastsearch:
  003e2	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  003e7	48 ff c0	 inc	 rax
  003ea	48 89 44 24 60	 mov	 QWORD PTR j$[rsp], rax
$LN30@fastsearch:
  003ef	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  003f4	48 39 44 24 60	 cmp	 QWORD PTR j$[rsp], rax
  003f9	7d 3a		 jge	 SHORT $LN28@fastsearch

; 162  :                     if (s[i+j] != p[j])

  003fb	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00400	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00405	48 03 c8	 add	 rcx, rax
  00408	48 8b c1	 mov	 rax, rcx
  0040b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00413	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00417	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0041c	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00424	48 03 d1	 add	 rdx, rcx
  00427	48 8b ca	 mov	 rcx, rdx
  0042a	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  0042d	3b c1		 cmp	 eax, ecx
  0042f	74 02		 je	 SHORT $LN27@fastsearch

; 163  :                         break;

  00431	eb 02		 jmp	 SHORT $LN28@fastsearch
$LN27@fastsearch:

; 164  :                 if (j == mlast) {

  00433	eb ad		 jmp	 SHORT $LN29@fastsearch
$LN28@fastsearch:
  00435	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  0043a	48 39 44 24 60	 cmp	 QWORD PTR j$[rsp], rax
  0043f	75 57		 jne	 SHORT $LN26@fastsearch

; 165  :                     /* got a match! */
; 166  :                     if (mode != FAST_COUNT)

  00441	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  00449	74 0a		 je	 SHORT $LN25@fastsearch

; 167  :                         return i;

  0044b	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00450	e9 84 03 00 00	 jmp	 $LN62@fastsearch
$LN25@fastsearch:

; 168  :                     count++;

  00455	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  0045a	48 ff c0	 inc	 rax
  0045d	48 89 44 24 38	 mov	 QWORD PTR count$[rsp], rax

; 169  :                     if (count == maxcount)

  00462	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0046a	48 39 44 24 38	 cmp	 QWORD PTR count$[rsp], rax
  0046f	75 0d		 jne	 SHORT $LN24@fastsearch

; 170  :                         return maxcount;

  00471	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00479	e9 5b 03 00 00	 jmp	 $LN62@fastsearch
$LN24@fastsearch:

; 171  :                     i = i + mlast;

  0047e	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  00483	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00488	48 03 c8	 add	 rcx, rax
  0048b	48 8b c1	 mov	 rax, rcx
  0048e	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax

; 172  :                     continue;

  00493	e9 e0 fe ff ff	 jmp	 $LN33@fastsearch
$LN26@fastsearch:

; 173  :                 }
; 174  :                 /* miss: check if next character is part of pattern */
; 175  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  00498	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  004a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  004a5	48 03 c8	 add	 rcx, rax
  004a8	48 8b c1	 mov	 rax, rcx
  004ab	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004b3	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  004b7	83 e0 1f	 and	 eax, 31
  004ba	b9 01 00 00 00	 mov	 ecx, 1
  004bf	89 4c 24 74	 mov	 DWORD PTR tv339[rsp], ecx
  004c3	0f b6 c8	 movzx	 ecx, al
  004c6	8b 44 24 74	 mov	 eax, DWORD PTR tv339[rsp]
  004ca	d3 e0		 shl	 eax, cl
  004cc	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  004d0	23 c8		 and	 ecx, eax
  004d2	8b c1		 mov	 eax, ecx
  004d4	85 c0		 test	 eax, eax
  004d6	75 1a		 jne	 SHORT $LN23@fastsearch

; 176  :                     i = i + m;

  004d8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  004e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  004e5	48 03 c8	 add	 rcx, rax
  004e8	48 8b c1	 mov	 rax, rcx
  004eb	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax

; 177  :                 else

  004f0	eb 15		 jmp	 SHORT $LN22@fastsearch
$LN23@fastsearch:

; 178  :                     i = i + skip;

  004f2	48 8b 44 24 50	 mov	 rax, QWORD PTR skip$[rsp]
  004f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  004fc	48 03 c8	 add	 rcx, rax
  004ff	48 8b c1	 mov	 rax, rcx
  00502	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN22@fastsearch:

; 179  :             } else {

  00507	eb 58		 jmp	 SHORT $LN21@fastsearch
$LN31@fastsearch:

; 180  :                 /* skip: check if next character is part of pattern */
; 181  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  00509	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00511	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00516	48 03 c8	 add	 rcx, rax
  00519	48 8b c1	 mov	 rax, rcx
  0051c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00524	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00528	83 e0 1f	 and	 eax, 31
  0052b	b9 01 00 00 00	 mov	 ecx, 1
  00530	89 4c 24 78	 mov	 DWORD PTR tv351[rsp], ecx
  00534	0f b6 c8	 movzx	 ecx, al
  00537	8b 44 24 78	 mov	 eax, DWORD PTR tv351[rsp]
  0053b	d3 e0		 shl	 eax, cl
  0053d	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  00541	23 c8		 and	 ecx, eax
  00543	8b c1		 mov	 eax, ecx
  00545	85 c0		 test	 eax, eax
  00547	75 18		 jne	 SHORT $LN20@fastsearch

; 182  :                     i = i + m;

  00549	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00551	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00556	48 03 c8	 add	 rcx, rax
  00559	48 8b c1	 mov	 rax, rcx
  0055c	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN20@fastsearch:
$LN21@fastsearch:

; 183  :             }
; 184  :         }

  00561	e9 12 fe ff ff	 jmp	 $LN33@fastsearch
$LN32@fastsearch:

; 185  :     } else {    /* FAST_RSEARCH */

  00566	e9 56 02 00 00	 jmp	 $LN19@fastsearch
$LN39@fastsearch:

; 186  : 
; 187  :         /* create compressed boyer-moore delta 1 table */
; 188  : 
; 189  :         /* process pattern[0] outside the loop */
; 190  :         STRINGLIB_BLOOM_ADD(mask, p[0]);

  0056b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00573	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00576	83 e0 1f	 and	 eax, 31
  00579	b9 01 00 00 00	 mov	 ecx, 1
  0057e	89 4c 24 7c	 mov	 DWORD PTR tv359[rsp], ecx
  00582	0f b6 c8	 movzx	 ecx, al
  00585	8b 44 24 7c	 mov	 eax, DWORD PTR tv359[rsp]
  00589	d3 e0		 shl	 eax, cl
  0058b	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  0058f	0b c8		 or	 ecx, eax
  00591	8b c1		 mov	 eax, ecx
  00593	89 44 24 48	 mov	 DWORD PTR mask$[rsp], eax

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  00597	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  0059c	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  005a1	eb 0d		 jmp	 SHORT $LN18@fastsearch
$LN17@fastsearch:
  005a3	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  005a8	48 ff c8	 dec	 rax
  005ab	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN18@fastsearch:
  005b0	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  005b6	7e 74		 jle	 SHORT $LN16@fastsearch

; 193  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  005b8	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  005bd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  005c5	48 03 c8	 add	 rcx, rax
  005c8	48 8b c1	 mov	 rax, rcx
  005cb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005ce	83 e0 1f	 and	 eax, 31
  005d1	b9 01 00 00 00	 mov	 ecx, 1
  005d6	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv368[rsp], ecx
  005dd	0f b6 c8	 movzx	 ecx, al
  005e0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv368[rsp]
  005e7	d3 e0		 shl	 eax, cl
  005e9	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  005ed	0b c8		 or	 ecx, eax
  005ef	8b c1		 mov	 eax, ecx
  005f1	89 44 24 48	 mov	 DWORD PTR mask$[rsp], eax

; 194  :             if (p[i] == p[0])

  005f5	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  005fa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00602	48 03 c8	 add	 rcx, rax
  00605	48 8b c1	 mov	 rax, rcx
  00608	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0060b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00613	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00616	3b c1		 cmp	 eax, ecx
  00618	75 0d		 jne	 SHORT $LN15@fastsearch

; 195  :                 skip = i - 1;

  0061a	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0061f	48 ff c8	 dec	 rax
  00622	48 89 44 24 50	 mov	 QWORD PTR skip$[rsp], rax
$LN15@fastsearch:

; 196  :         }

  00627	e9 77 ff ff ff	 jmp	 $LN17@fastsearch
$LN16@fastsearch:

; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  0062c	48 8b 44 24 30	 mov	 rax, QWORD PTR w$[rsp]
  00631	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00636	eb 0d		 jmp	 SHORT $LN14@fastsearch
$LN13@fastsearch:
  00638	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0063d	48 ff c8	 dec	 rax
  00640	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN14@fastsearch:
  00645	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  0064b	0f 8c 70 01 00
	00		 jl	 $LN12@fastsearch

; 199  :             if (s[i] == p[0]) {

  00651	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00656	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0065e	48 03 c8	 add	 rcx, rax
  00661	48 8b c1	 mov	 rax, rcx
  00664	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00667	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  0066f	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00672	3b c1		 cmp	 eax, ecx
  00674	0f 85 e4 00 00
	00		 jne	 $LN11@fastsearch

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  0067a	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  0067f	48 89 44 24 60	 mov	 QWORD PTR j$[rsp], rax
  00684	eb 0d		 jmp	 SHORT $LN10@fastsearch
$LN9@fastsearch:
  00686	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0068b	48 ff c8	 dec	 rax
  0068e	48 89 44 24 60	 mov	 QWORD PTR j$[rsp], rax
$LN10@fastsearch:
  00693	48 83 7c 24 60
	00		 cmp	 QWORD PTR j$[rsp], 0
  00699	7e 3a		 jle	 SHORT $LN8@fastsearch

; 202  :                     if (s[i+j] != p[j])

  0069b	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  006a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  006a5	48 03 c8	 add	 rcx, rax
  006a8	48 8b c1	 mov	 rax, rcx
  006ab	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006b3	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  006b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  006bc	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  006c4	48 03 d1	 add	 rdx, rcx
  006c7	48 8b ca	 mov	 rcx, rdx
  006ca	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  006cd	3b c1		 cmp	 eax, ecx
  006cf	74 02		 je	 SHORT $LN7@fastsearch

; 203  :                         break;

  006d1	eb 02		 jmp	 SHORT $LN8@fastsearch
$LN7@fastsearch:

; 204  :                 if (j == 0)

  006d3	eb b1		 jmp	 SHORT $LN9@fastsearch
$LN8@fastsearch:
  006d5	48 83 7c 24 60
	00		 cmp	 QWORD PTR j$[rsp], 0
  006db	75 0a		 jne	 SHORT $LN6@fastsearch

; 205  :                     /* got a match! */
; 206  :                     return i;

  006dd	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  006e2	e9 f2 00 00 00	 jmp	 $LN62@fastsearch
$LN6@fastsearch:

; 207  :                 /* miss: check if previous character is part of pattern */
; 208  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  006e7	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  006ed	7e 58		 jle	 SHORT $LN5@fastsearch
  006ef	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  006f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006fc	48 03 c8	 add	 rcx, rax
  006ff	48 8b c1	 mov	 rax, rcx
  00702	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  00706	83 e0 1f	 and	 eax, 31
  00709	b9 01 00 00 00	 mov	 ecx, 1
  0070e	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv391[rsp], ecx
  00715	0f b6 c8	 movzx	 ecx, al
  00718	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv391[rsp]
  0071f	d3 e0		 shl	 eax, cl
  00721	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  00725	23 c8		 and	 ecx, eax
  00727	8b c1		 mov	 eax, ecx
  00729	85 c0		 test	 eax, eax
  0072b	75 1a		 jne	 SHORT $LN5@fastsearch

; 209  :                     i = i - m;

  0072d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00735	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  0073a	48 2b c8	 sub	 rcx, rax
  0073d	48 8b c1	 mov	 rax, rcx
  00740	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax

; 210  :                 else

  00745	eb 15		 jmp	 SHORT $LN4@fastsearch
$LN5@fastsearch:

; 211  :                     i = i - skip;

  00747	48 8b 44 24 50	 mov	 rax, QWORD PTR skip$[rsp]
  0074c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00751	48 2b c8	 sub	 rcx, rax
  00754	48 8b c1	 mov	 rax, rcx
  00757	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN4@fastsearch:

; 212  :             } else {

  0075c	eb 5e		 jmp	 SHORT $LN3@fastsearch
$LN11@fastsearch:

; 213  :                 /* skip: check if previous character is part of pattern */
; 214  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  0075e	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  00764	7e 56		 jle	 SHORT $LN2@fastsearch
  00766	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0076b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00773	48 03 c8	 add	 rcx, rax
  00776	48 8b c1	 mov	 rax, rcx
  00779	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  0077d	83 e0 1f	 and	 eax, 31
  00780	b9 01 00 00 00	 mov	 ecx, 1
  00785	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv402[rsp], ecx
  0078c	0f b6 c8	 movzx	 ecx, al
  0078f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv402[rsp]
  00796	d3 e0		 shl	 eax, cl
  00798	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  0079c	23 c8		 and	 ecx, eax
  0079e	8b c1		 mov	 eax, ecx
  007a0	85 c0		 test	 eax, eax
  007a2	75 18		 jne	 SHORT $LN2@fastsearch

; 215  :                     i = i - m;

  007a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  007ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  007b1	48 2b c8	 sub	 rcx, rax
  007b4	48 8b c1	 mov	 rax, rcx
  007b7	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN2@fastsearch:
$LN3@fastsearch:

; 216  :             }
; 217  :         }

  007bc	e9 77 fe ff ff	 jmp	 $LN13@fastsearch
$LN12@fastsearch:
$LN19@fastsearch:

; 218  :     }
; 219  : 
; 220  :     if (mode != FAST_COUNT)

  007c1	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  007c9	74 09		 je	 SHORT $LN1@fastsearch

; 221  :         return -1;

  007cb	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  007d2	eb 05		 jmp	 SHORT $LN62@fastsearch
$LN1@fastsearch:

; 222  :     return count;

  007d4	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
$LN62@fastsearch:

; 223  : }

  007d9	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  007e0	c3		 ret	 0
fastsearch ENDP
_TEXT	ENDS
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_1GC@ONFLMJIG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_fastsearch_memchr_1char DD imagerel stringlib_fastsearch_memchr_1char
	DD	imagerel stringlib_fastsearch_memchr_1char+239
	DD	imagerel $unwind$stringlib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_fastsearch_memchr_1char DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@ONFLMJIG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1GC@ONFLMJIG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'l', 00H
	DB	'i', 00H, 'b', 00H, '/', 00H, 'f', 00H, 'a', 00H, 's', 00H, 't'
	DB	00H, 's', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_fastsearch_memchr_1char
_TEXT	SEGMENT
ptr$21009 = 32
e$21010 = 40
candidate$21014 = 48
s$ = 80
n$ = 88
ch$ = 96
needle$ = 104
maxcount$ = 112
mode$ = 120
stringlib_fastsearch_memchr_1char PROC			; COMDAT

; 40   : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 41   :     if (mode == FAST_SEARCH) {

  00018	83 7c 24 78 01	 cmp	 DWORD PTR mode$[rsp], 1
  0001d	0f 85 a3 00 00
	00		 jne	 $LN6@stringlib_@19

; 42   :         const STRINGLIB_CHAR *ptr = s;

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00028	48 89 44 24 20	 mov	 QWORD PTR ptr$21009[rsp], rax

; 43   :         const STRINGLIB_CHAR *e = s + n;

  0002d	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 89 44 24 28	 mov	 QWORD PTR e$21010[rsp], rax
$LN5@stringlib_@19:

; 44   :         while (ptr < e) {

  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR e$21010[rsp]
  00047	48 39 44 24 20	 cmp	 QWORD PTR ptr$21009[rsp], rax
  0004c	73 6d		 jae	 SHORT $LN4@stringlib_@19

; 45   :             void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(STRINGLIB_CHAR));

  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$21009[rsp]
  00053	48 8b 4c 24 28	 mov	 rcx, QWORD PTR e$21010[rsp]
  00058	48 2b c8	 sub	 rcx, rax
  0005b	48 8b c1	 mov	 rax, rcx
  0005e	0f b6 4c 24 68	 movzx	 ecx, BYTE PTR needle$[rsp]
  00063	4c 8b c0	 mov	 r8, rax
  00066	8b d1		 mov	 edx, ecx
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$21009[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00073	48 89 44 24 30	 mov	 QWORD PTR candidate$21014[rsp], rax

; 46   :             if (candidate == NULL)

  00078	48 83 7c 24 30
	00		 cmp	 QWORD PTR candidate$21014[rsp], 0
  0007e	75 09		 jne	 SHORT $LN3@stringlib_@19

; 47   :                 return -1;

  00080	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00087	eb 61		 jmp	 SHORT $LN7@stringlib_@19
$LN3@stringlib_@19:

; 48   :             ptr = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));

  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR candidate$21014[rsp]
  0008e	48 89 44 24 20	 mov	 QWORD PTR ptr$21009[rsp], rax

; 49   :             if (sizeof(STRINGLIB_CHAR) == 1 || *ptr == ch)

  00093	33 c0		 xor	 eax, eax
  00095	83 f8 01	 cmp	 eax, 1
  00098	74 12		 je	 SHORT $LN2@stringlib_@19

; 50   :                 return (ptr - s);

  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0009f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$21009[rsp]
  000a4	48 2b c8	 sub	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	eb 3e		 jmp	 SHORT $LN7@stringlib_@19
$LN2@stringlib_@19:

; 51   :             /* False positive */
; 52   :             ptr++;

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$21009[rsp]
  000b1	48 ff c0	 inc	 rax
  000b4	48 89 44 24 20	 mov	 QWORD PTR ptr$21009[rsp], rax

; 53   :         }

  000b9	eb 87		 jmp	 SHORT $LN5@stringlib_@19
$LN4@stringlib_@19:

; 54   :         return -1;

  000bb	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000c2	eb 26		 jmp	 SHORT $LN7@stringlib_@19

; 55   :     }
; 56   : #ifdef HAVE_MEMRCHR
; 57   :     /* memrchr() is a GNU extension, available since glibc 2.1.91.
; 58   :        it doesn't seem as optimized as memchr(), but is still quite
; 59   :        faster than our hand-written loop in FASTSEARCH below */
; 60   :     else if (mode == FAST_RSEARCH) {
; 61   :         while (n > 0) {
; 62   :             const STRINGLIB_CHAR *found;
; 63   :             void *candidate = memrchr((const void *) s, needle, n * sizeof(STRINGLIB_CHAR));
; 64   :             if (candidate == NULL)
; 65   :                 return -1;
; 66   :             found = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));
; 67   :             n = found - s;
; 68   :             if (sizeof(STRINGLIB_CHAR) == 1 || *found == ch)
; 69   :                 return n;
; 70   :             /* False positive */
; 71   :         }
; 72   :         return -1;
; 73   :     }
; 74   : #endif
; 75   :     else {

  000c4	eb 24		 jmp	 SHORT $LN1@stringlib_@19
$LN6@stringlib_@19:

; 76   :         assert(0); /* Should never get here */

  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 1c		 jne	 SHORT $LN9@stringlib_@19
  000cc	41 b8 4c 00 00
	00		 mov	 r8d, 76			; 0000004cH
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GC@ONFLMJIG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e6	33 c0		 xor	 eax, eax
$LN9@stringlib_@19:

; 77   :         return 0;

  000e8	33 c0		 xor	 eax, eax
$LN1@stringlib_@19:
$LN7@stringlib_@19:

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  000ea	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ee	c3		 ret	 0
stringlib_fastsearch_memchr_1char ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@	; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$bytes_item DD imagerel bytes_item
	DD	imagerel bytes_item+93
	DD	imagerel $unwind$bytes_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_item DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@ DB 'index out of range', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_item
_TEXT	SEGMENT
a$ = 48
i$ = 56
bytes_item PROC						; COMDAT

; 810  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 811  :     if (i < 0 || i >= Py_SIZE(a)) {

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  00014	7c 10		 jl	 SHORT $LN1@bytes_item
  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0001b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001f	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00024	7c 17		 jl	 SHORT $LN2@bytes_item
$LN1@bytes_item:

; 812  :         PyErr_SetString(PyExc_IndexError, "index out of range");

  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00034	e8 00 00 00 00	 call	 PyErr_SetString

; 813  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 1b		 jmp	 SHORT $LN3@bytes_item
$LN2@bytes_item:

; 814  :     }
; 815  :     return PyLong_FromLong((unsigned char)a->ob_sval[i]);

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00042	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00047	48 03 c8	 add	 rcx, rax
  0004a	48 8b c1	 mov	 rax, rcx
  0004d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00051	8b c8		 mov	 ecx, eax
  00053	e8 00 00 00 00	 call	 PyLong_FromLong
$LN3@bytes_item:

; 816  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
bytes_item ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@BBGHAPNJ@Comparison?5between?5bytes?5and?5str@ ; `string'
EXTRN	memcmp:PROC
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	PyObject_IsInstance:PROC
EXTRN	PyUnicode_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_richcompare DD imagerel bytes_richcompare
	DD	imagerel bytes_richcompare+1108
	DD	imagerel $unwind$bytes_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_richcompare DD 021601H
	DD	0110116H
xdata	ENDS
;	COMDAT ??_C@_0CE@BBGHAPNJ@Comparison?5between?5bytes?5and?5str@
CONST	SEGMENT
??_C@_0CE@BBGHAPNJ@Comparison?5between?5bytes?5and?5str@ DB 'Comparison b'
	DB	'etween bytes and string', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_richcompare
_TEXT	SEGMENT
len_b$ = 32
len_a$ = 40
result$ = 48
min_len$ = 56
c$ = 64
tv89 = 68
tv145 = 72
tv171 = 80
tv170 = 84
tv172 = 88
tv174 = 92
tv176 = 96
tv183 = 100
tv185 = 104
tv187 = 108
tv190 = 112
a$ = 144
b$ = 152
op$ = 160
bytes_richcompare PROC					; COMDAT

; 820  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 821  :     int c;
; 822  :     Py_ssize_t len_a, len_b;
; 823  :     Py_ssize_t min_len;
; 824  :     PyObject *result;
; 825  : 
; 826  :     /* Make sure both arguments are strings. */
; 827  :     if (!(PyBytes_Check(a) && PyBytes_Check(b))) {

  00016	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0001e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00022	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00028	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0002d	85 c0		 test	 eax, eax
  0002f	74 1f		 je	 SHORT $LN26@bytes_rich
  00031	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00039	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00043	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00048	85 c0		 test	 eax, eax
  0004a	0f 85 82 00 00
	00		 jne	 $LN27@bytes_rich
$LN26@bytes_rich:

; 828  :         if (Py_BytesWarningFlag && (op == Py_EQ || op == Py_NE) &&
; 829  :             (PyObject_IsInstance((PyObject*)a,
; 830  :                                  (PyObject*)&PyUnicode_Type) ||
; 831  :             PyObject_IsInstance((PyObject*)b,
; 832  :                                  (PyObject*)&PyUnicode_Type))) {

  00050	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_BytesWarningFlag, 0
  00057	74 68		 je	 SHORT $LN25@bytes_rich
  00059	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  00061	74 0a		 je	 SHORT $LN24@bytes_rich
  00063	83 bc 24 a0 00
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  0006b	75 54		 jne	 SHORT $LN25@bytes_rich
$LN24@bytes_rich:
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyUnicode_Type
  00074	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0007c	e8 00 00 00 00	 call	 PyObject_IsInstance
  00081	85 c0		 test	 eax, eax
  00083	75 18		 jne	 SHORT $LN23@bytes_rich
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyUnicode_Type
  0008c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00094	e8 00 00 00 00	 call	 PyObject_IsInstance
  00099	85 c0		 test	 eax, eax
  0009b	74 24		 je	 SHORT $LN25@bytes_rich
$LN23@bytes_rich:

; 833  :             if (PyErr_WarnEx(PyExc_BytesWarning,
; 834  :                         "Comparison between bytes and string", 1))

  0009d	41 b8 01 00 00
	00		 mov	 r8d, 1
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@BBGHAPNJ@Comparison?5between?5bytes?5and?5str@
  000aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BytesWarning
  000b1	e8 00 00 00 00	 call	 PyErr_WarnEx
  000b6	85 c0		 test	 eax, eax
  000b8	74 07		 je	 SHORT $LN22@bytes_rich

; 835  :                 return NULL;

  000ba	33 c0		 xor	 eax, eax
  000bc	e9 5b 03 00 00	 jmp	 $LN28@bytes_rich
$LN22@bytes_rich:
$LN25@bytes_rich:

; 836  :         }
; 837  :         result = Py_NotImplemented;

  000c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000c8	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 838  :         goto out;

  000cd	e9 3b 03 00 00	 jmp	 $out$22418
$LN27@bytes_rich:

; 839  :     }
; 840  :     if (a == b) {

  000d2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000da	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR a$[rsp], rax
  000e2	75 4c		 jne	 SHORT $LN21@bytes_rich

; 841  :         switch (op) {

  000e4	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  000eb	89 44 24 44	 mov	 DWORD PTR tv89[rsp], eax
  000ef	83 7c 24 44 05	 cmp	 DWORD PTR tv89[rsp], 5
  000f4	77 3a		 ja	 SHORT $LN19@bytes_rich
  000f6	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv89[rsp]
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00102	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN50@bytes_rich[rcx+rax*4]
  00109	48 03 c1	 add	 rax, rcx
  0010c	ff e0		 jmp	 rax
$LN18@bytes_rich:

; 842  :         case Py_EQ:case Py_LE:case Py_GE:
; 843  :             result = Py_True;

  0010e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00115	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 844  :             goto out;

  0011a	e9 ee 02 00 00	 jmp	 $out$22418
$LN17@bytes_rich:

; 845  :         case Py_NE:case Py_LT:case Py_GT:
; 846  :             result = Py_False;

  0011f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00126	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 847  :             goto out;

  0012b	e9 dd 02 00 00	 jmp	 $out$22418
$LN19@bytes_rich:
$LN21@bytes_rich:

; 848  :         }
; 849  :     }
; 850  :     if (op == Py_EQ) {

  00130	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  00138	0f 85 85 00 00
	00		 jne	 $LN16@bytes_rich

; 851  :         /* Supporting Py_NE here as well does not save
; 852  :            much time, since Py_NE is rarely used.  */
; 853  :         if (Py_SIZE(a) == Py_SIZE(b)
; 854  :             && (a->ob_sval[0] == b->ob_sval[0]
; 855  :             && memcmp(a->ob_sval, b->ob_sval, Py_SIZE(a)) == 0)) {

  0013e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00146	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0014e	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00152	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00156	75 5a		 jne	 SHORT $LN15@bytes_rich
  00158	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00160	0f be 40 78	 movsx	 eax, BYTE PTR [rax+120]
  00164	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0016c	0f be 49 78	 movsx	 ecx, BYTE PTR [rcx+120]
  00170	3b c1		 cmp	 eax, ecx
  00172	75 3e		 jne	 SHORT $LN15@bytes_rich
  00174	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0017c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00180	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00188	48 83 c1 78	 add	 rcx, 120		; 00000078H
  0018c	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR a$[rsp]
  00194	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00198	48 8b d0	 mov	 rdx, rax
  0019b	e8 00 00 00 00	 call	 memcmp
  001a0	85 c0		 test	 eax, eax
  001a2	75 0e		 jne	 SHORT $LN15@bytes_rich

; 856  :             result = Py_True;

  001a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  001ab	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 857  :         } else {

  001b0	eb 0c		 jmp	 SHORT $LN14@bytes_rich
$LN15@bytes_rich:

; 858  :             result = Py_False;

  001b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  001b9	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$LN14@bytes_rich:

; 859  :         }
; 860  :         goto out;

  001be	e9 4a 02 00 00	 jmp	 $out$22418
$LN16@bytes_rich:

; 861  :     }
; 862  :     len_a = Py_SIZE(a); len_b = Py_SIZE(b);

  001c3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001cb	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001cf	48 89 44 24 28	 mov	 QWORD PTR len_a$[rsp], rax
  001d4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  001dc	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001e0	48 89 44 24 20	 mov	 QWORD PTR len_b$[rsp], rax

; 863  :     min_len = (len_a < len_b) ? len_a : len_b;

  001e5	48 8b 44 24 20	 mov	 rax, QWORD PTR len_b$[rsp]
  001ea	48 39 44 24 28	 cmp	 QWORD PTR len_a$[rsp], rax
  001ef	7d 0c		 jge	 SHORT $LN30@bytes_rich
  001f1	48 8b 44 24 28	 mov	 rax, QWORD PTR len_a$[rsp]
  001f6	48 89 44 24 48	 mov	 QWORD PTR tv145[rsp], rax
  001fb	eb 0a		 jmp	 SHORT $LN31@bytes_rich
$LN30@bytes_rich:
  001fd	48 8b 44 24 20	 mov	 rax, QWORD PTR len_b$[rsp]
  00202	48 89 44 24 48	 mov	 QWORD PTR tv145[rsp], rax
$LN31@bytes_rich:
  00207	48 8b 44 24 48	 mov	 rax, QWORD PTR tv145[rsp]
  0020c	48 89 44 24 38	 mov	 QWORD PTR min_len$[rsp], rax

; 864  :     if (min_len > 0) {

  00211	48 83 7c 24 38
	00		 cmp	 QWORD PTR min_len$[rsp], 0
  00217	7e 61		 jle	 SHORT $LN13@bytes_rich

; 865  :         c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);

  00219	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00221	0f be 40 78	 movsx	 eax, BYTE PTR [rax+120]
  00225	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0022a	0f b6 c0	 movzx	 eax, al
  0022d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00235	0f be 49 78	 movsx	 ecx, BYTE PTR [rcx+120]
  00239	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0023f	0f b6 c9	 movzx	 ecx, cl
  00242	2b c1		 sub	 eax, ecx
  00244	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax

; 866  :         if (c==0)

  00248	83 7c 24 40 00	 cmp	 DWORD PTR c$[rsp], 0
  0024d	75 29		 jne	 SHORT $LN12@bytes_rich

; 867  :             c = memcmp(a->ob_sval, b->ob_sval, min_len);

  0024f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00257	48 83 c0 78	 add	 rax, 120		; 00000078H
  0025b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00263	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00267	4c 8b 44 24 38	 mov	 r8, QWORD PTR min_len$[rsp]
  0026c	48 8b d0	 mov	 rdx, rax
  0026f	e8 00 00 00 00	 call	 memcmp
  00274	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax
$LN12@bytes_rich:

; 868  :     } else

  00278	eb 08		 jmp	 SHORT $LN11@bytes_rich
$LN13@bytes_rich:

; 869  :         c = 0;

  0027a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR c$[rsp], 0
$LN11@bytes_rich:

; 870  :     if (c == 0)

  00282	83 7c 24 40 00	 cmp	 DWORD PTR c$[rsp], 0
  00287	75 44		 jne	 SHORT $LN10@bytes_rich

; 871  :         c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;

  00289	48 8b 44 24 20	 mov	 rax, QWORD PTR len_b$[rsp]
  0028e	48 39 44 24 28	 cmp	 QWORD PTR len_a$[rsp], rax
  00293	7d 0a		 jge	 SHORT $LN34@bytes_rich
  00295	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR tv171[rsp], -1
  0029d	eb 26		 jmp	 SHORT $LN35@bytes_rich
$LN34@bytes_rich:
  0029f	48 8b 44 24 20	 mov	 rax, QWORD PTR len_b$[rsp]
  002a4	48 39 44 24 28	 cmp	 QWORD PTR len_a$[rsp], rax
  002a9	7e 0a		 jle	 SHORT $LN32@bytes_rich
  002ab	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv170[rsp], 1
  002b3	eb 08		 jmp	 SHORT $LN33@bytes_rich
$LN32@bytes_rich:
  002b5	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv170[rsp], 0
$LN33@bytes_rich:
  002bd	8b 44 24 54	 mov	 eax, DWORD PTR tv170[rsp]
  002c1	89 44 24 50	 mov	 DWORD PTR tv171[rsp], eax
$LN35@bytes_rich:
  002c5	8b 44 24 50	 mov	 eax, DWORD PTR tv171[rsp]
  002c9	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax
$LN10@bytes_rich:

; 872  :     switch (op) {

  002cd	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  002d4	89 44 24 58	 mov	 DWORD PTR tv172[rsp], eax
  002d8	83 7c 24 58 05	 cmp	 DWORD PTR tv172[rsp], 5
  002dd	0f 87 f1 00 00
	00		 ja	 $LN1@bytes_rich
  002e3	48 63 44 24 58	 movsxd	 rax, DWORD PTR tv172[rsp]
  002e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  002ef	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN49@bytes_rich[rcx+rax*4]
  002f6	48 03 c1	 add	 rax, rcx
  002f9	ff e0		 jmp	 rax
$LN7@bytes_rich:

; 873  :     case Py_LT: c = c <  0; break;

  002fb	83 7c 24 40 00	 cmp	 DWORD PTR c$[rsp], 0
  00300	7d 0a		 jge	 SHORT $LN36@bytes_rich
  00302	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0030a	eb 08		 jmp	 SHORT $LN37@bytes_rich
$LN36@bytes_rich:
  0030c	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN37@bytes_rich:
  00314	8b 44 24 5c	 mov	 eax, DWORD PTR tv174[rsp]
  00318	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax
  0031c	e9 c1 00 00 00	 jmp	 $LN8@bytes_rich
$LN6@bytes_rich:

; 874  :     case Py_LE: c = c <= 0; break;

  00321	83 7c 24 40 00	 cmp	 DWORD PTR c$[rsp], 0
  00326	7f 0a		 jg	 SHORT $LN38@bytes_rich
  00328	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv176[rsp], 1
  00330	eb 08		 jmp	 SHORT $LN39@bytes_rich
$LN38@bytes_rich:
  00332	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
$LN39@bytes_rich:
  0033a	8b 44 24 60	 mov	 eax, DWORD PTR tv176[rsp]
  0033e	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax
  00342	e9 9b 00 00 00	 jmp	 $LN8@bytes_rich
$LN5@bytes_rich:

; 875  :     case Py_EQ: assert(0);  break; /* unreachable */

  00347	33 c0		 xor	 eax, eax
  00349	85 c0		 test	 eax, eax
  0034b	75 1c		 jne	 SHORT $LN40@bytes_rich
  0034d	41 b8 6b 03 00
	00		 mov	 r8d, 875		; 0000036bH
  00353	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00367	33 c0		 xor	 eax, eax
$LN40@bytes_rich:
  00369	eb 77		 jmp	 SHORT $LN8@bytes_rich
$LN4@bytes_rich:

; 876  :     case Py_NE: c = c != 0; break;

  0036b	83 7c 24 40 00	 cmp	 DWORD PTR c$[rsp], 0
  00370	74 0a		 je	 SHORT $LN41@bytes_rich
  00372	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv183[rsp], 1
  0037a	eb 08		 jmp	 SHORT $LN42@bytes_rich
$LN41@bytes_rich:
  0037c	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv183[rsp], 0
$LN42@bytes_rich:
  00384	8b 44 24 64	 mov	 eax, DWORD PTR tv183[rsp]
  00388	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax
  0038c	eb 54		 jmp	 SHORT $LN8@bytes_rich
$LN3@bytes_rich:

; 877  :     case Py_GT: c = c >  0; break;

  0038e	83 7c 24 40 00	 cmp	 DWORD PTR c$[rsp], 0
  00393	7e 0a		 jle	 SHORT $LN43@bytes_rich
  00395	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv185[rsp], 1
  0039d	eb 08		 jmp	 SHORT $LN44@bytes_rich
$LN43@bytes_rich:
  0039f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN44@bytes_rich:
  003a7	8b 44 24 68	 mov	 eax, DWORD PTR tv185[rsp]
  003ab	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax
  003af	eb 31		 jmp	 SHORT $LN8@bytes_rich
$LN2@bytes_rich:

; 878  :     case Py_GE: c = c >= 0; break;

  003b1	83 7c 24 40 00	 cmp	 DWORD PTR c$[rsp], 0
  003b6	7c 0a		 jl	 SHORT $LN45@bytes_rich
  003b8	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv187[rsp], 1
  003c0	eb 08		 jmp	 SHORT $LN46@bytes_rich
$LN45@bytes_rich:
  003c2	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN46@bytes_rich:
  003ca	8b 44 24 6c	 mov	 eax, DWORD PTR tv187[rsp]
  003ce	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax
  003d2	eb 0e		 jmp	 SHORT $LN8@bytes_rich
$LN1@bytes_rich:

; 879  :     default:
; 880  :         result = Py_NotImplemented;

  003d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  003db	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 881  :         goto out;

  003e0	eb 2b		 jmp	 SHORT $out$22418
$LN8@bytes_rich:

; 882  :     }
; 883  :     result = c ? Py_True : Py_False;

  003e2	83 7c 24 40 00	 cmp	 DWORD PTR c$[rsp], 0
  003e7	74 0e		 je	 SHORT $LN47@bytes_rich
  003e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  003f0	48 89 44 24 70	 mov	 QWORD PTR tv190[rsp], rax
  003f5	eb 0c		 jmp	 SHORT $LN48@bytes_rich
$LN47@bytes_rich:
  003f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  003fe	48 89 44 24 70	 mov	 QWORD PTR tv190[rsp], rax
$LN48@bytes_rich:
  00403	48 8b 44 24 70	 mov	 rax, QWORD PTR tv190[rsp]
  00408	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$out$22418:

; 884  :   out:
; 885  :     Py_INCREF(result);

  0040d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00412	e8 00 00 00 00	 call	 _Py_IncRef

; 886  :     return result;

  00417	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN28@bytes_rich:

; 887  : }

  0041c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00423	c3		 ret	 0
$LN50@bytes_rich:
  00424	00 00 00 00	 DD	 $LN17@bytes_rich
  00428	00 00 00 00	 DD	 $LN18@bytes_rich
  0042c	00 00 00 00	 DD	 $LN18@bytes_rich
  00430	00 00 00 00	 DD	 $LN17@bytes_rich
  00434	00 00 00 00	 DD	 $LN17@bytes_rich
  00438	00 00 00 00	 DD	 $LN18@bytes_rich
$LN49@bytes_rich:
  0043c	00 00 00 00	 DD	 $LN7@bytes_rich
  00440	00 00 00 00	 DD	 $LN6@bytes_rich
  00444	00 00 00 00	 DD	 $LN5@bytes_rich
  00448	00 00 00 00	 DD	 $LN4@bytes_rich
  0044c	00 00 00 00	 DD	 $LN3@bytes_rich
  00450	00 00 00 00	 DD	 $LN2@bytes_rich
bytes_richcompare ENDP
_TEXT	ENDS
EXTRN	_Py_HashBytes:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_hash DD imagerel bytes_hash
	DD	imagerel bytes_hash+70
	DD	imagerel $unwind$bytes_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_hash DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_hash
_TEXT	SEGMENT
a$ = 48
bytes_hash PROC						; COMDAT

; 891  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 892  :     if (a->ob_shash == -1) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0000e	48 83 78 70 ff	 cmp	 QWORD PTR [rax+112], -1
  00013	75 23		 jne	 SHORT $LN1@bytes_hash

; 893  :         /* Can't fail */
; 894  :         a->ob_shash = _Py_HashBytes((unsigned char *) a->ob_sval, Py_SIZE(a));

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0001a	48 83 c0 78	 add	 rax, 120		; 00000078H
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00023	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 _Py_HashBytes
  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00034	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax
$LN1@bytes_hash:

; 895  :     }
; 896  :     return a->ob_shash;

  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0003d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]

; 897  : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
bytes_hash ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@HKNFHIEC@byte?5indices?5must?5be?5integers?0?5n@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PySlice_GetIndicesEx:PROC
EXTRN	PySlice_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_subscript DD imagerel bytes_subscript
	DD	imagerel bytes_subscript+1123
	DD	imagerel $unwind$bytes_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_subscript DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0CK@HKNFHIEC@byte?5indices?5must?5be?5integers?0?5n@
CONST	SEGMENT
??_C@_0CK@HKNFHIEC@byte?5indices?5must?5be?5integers?0?5n@ DB 'byte indic'
	DB	'es must be integers, not %.200s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_subscript
_TEXT	SEGMENT
i$22475 = 48
source_buf$22498 = 56
i$22497 = 64
cur$22496 = 72
slicelength$22495 = 80
step$22494 = 88
stop$22493 = 96
start$22492 = 104
result$22500 = 112
result_buf$22499 = 120
self$ = 144
item$ = 152
bytes_subscript PROC					; COMDAT

; 901  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 902  :     if (PyIndex_Check(item)) {

  00011	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00019	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001d	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00025	0f 84 42 01 00
	00		 je	 $LN19@bytes_subs
  0002b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00033	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00037	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0003e	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00046	0f 84 21 01 00
	00		 je	 $LN19@bytes_subs

; 903  :         Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  0004c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00053	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  0005b	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00060	48 89 44 24 30	 mov	 QWORD PTR i$22475[rsp], rax

; 904  :         if (i == -1 && PyErr_Occurred())

  00065	48 83 7c 24 30
	ff		 cmp	 QWORD PTR i$22475[rsp], -1
  0006b	75 11		 jne	 SHORT $LN18@bytes_subs
  0006d	e8 00 00 00 00	 call	 PyErr_Occurred
  00072	48 85 c0	 test	 rax, rax
  00075	74 07		 je	 SHORT $LN18@bytes_subs

; 905  :             return NULL;

  00077	33 c0		 xor	 eax, eax
  00079	e9 dd 03 00 00	 jmp	 $LN20@bytes_subs
$LN18@bytes_subs:

; 906  :         if (i < 0)

  0007e	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$22475[rsp], 0
  00084	7d 53		 jge	 SHORT $LN17@bytes_subs

; 907  :             i += PyBytes_GET_SIZE(self);

  00086	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0008e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00092	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00098	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0009d	85 c0		 test	 eax, eax
  0009f	75 1c		 jne	 SHORT $LN22@bytes_subs
  000a1	41 b8 8b 03 00
	00		 mov	 r8d, 907		; 0000038bH
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000bb	33 c0		 xor	 eax, eax
$LN22@bytes_subs:
  000bd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000c5	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$22475[rsp]
  000ce	48 03 c8	 add	 rcx, rax
  000d1	48 8b c1	 mov	 rax, rcx
  000d4	48 89 44 24 30	 mov	 QWORD PTR i$22475[rsp], rax
$LN17@bytes_subs:

; 908  :         if (i < 0 || i >= PyBytes_GET_SIZE(self)) {

  000d9	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$22475[rsp], 0
  000df	7c 4a		 jl	 SHORT $LN15@bytes_subs
  000e1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000e9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ed	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f3	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000f8	85 c0		 test	 eax, eax
  000fa	75 1c		 jne	 SHORT $LN23@bytes_subs
  000fc	41 b8 8c 03 00
	00		 mov	 r8d, 908		; 0000038cH
  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00116	33 c0		 xor	 eax, eax
$LN23@bytes_subs:
  00118	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00120	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00124	48 39 44 24 30	 cmp	 QWORD PTR i$22475[rsp], rax
  00129	7c 1a		 jl	 SHORT $LN16@bytes_subs
$LN15@bytes_subs:

; 909  :             PyErr_SetString(PyExc_IndexError,
; 910  :                             "index out of range");

  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  00132	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00139	e8 00 00 00 00	 call	 PyErr_SetString

; 911  :             return NULL;

  0013e	33 c0		 xor	 eax, eax
  00140	e9 16 03 00 00	 jmp	 $LN20@bytes_subs
$LN16@bytes_subs:

; 912  :         }
; 913  :         return PyLong_FromLong((unsigned char)self->ob_sval[i]);

  00145	48 8b 44 24 30	 mov	 rax, QWORD PTR i$22475[rsp]
  0014a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00152	48 03 c8	 add	 rcx, rax
  00155	48 8b c1	 mov	 rax, rcx
  00158	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0015c	8b c8		 mov	 ecx, eax
  0015e	e8 00 00 00 00	 call	 PyLong_FromLong
  00163	e9 f3 02 00 00	 jmp	 $LN20@bytes_subs
  00168	e9 ee 02 00 00	 jmp	 $LN14@bytes_subs
$LN19@bytes_subs:

; 914  :     }
; 915  :     else if (PySlice_Check(item)) {

  0016d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  00174	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  0017c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00180	0f 85 b0 02 00
	00		 jne	 $LN13@bytes_subs

; 916  :         Py_ssize_t start, stop, step, slicelength, cur, i;
; 917  :         char* source_buf;
; 918  :         char* result_buf;
; 919  :         PyObject* result;
; 920  : 
; 921  :         if (PySlice_GetIndicesEx(item,
; 922  :                          PyBytes_GET_SIZE(self),
; 923  :                          &start, &stop, &step, &slicelength) < 0) {

  00186	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0018e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00192	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00198	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0019d	85 c0		 test	 eax, eax
  0019f	75 1c		 jne	 SHORT $LN24@bytes_subs
  001a1	41 b8 9a 03 00
	00		 mov	 r8d, 922		; 0000039aH
  001a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001bb	33 c0		 xor	 eax, eax
$LN24@bytes_subs:
  001bd	48 8d 44 24 50	 lea	 rax, QWORD PTR slicelength$22495[rsp]
  001c2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c7	48 8d 44 24 58	 lea	 rax, QWORD PTR step$22494[rsp]
  001cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d1	4c 8d 4c 24 60	 lea	 r9, QWORD PTR stop$22493[rsp]
  001d6	4c 8d 44 24 68	 lea	 r8, QWORD PTR start$22492[rsp]
  001db	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001e3	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  001e7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  001ef	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  001f4	85 c0		 test	 eax, eax
  001f6	7d 07		 jge	 SHORT $LN12@bytes_subs

; 924  :             return NULL;

  001f8	33 c0		 xor	 eax, eax
  001fa	e9 5c 02 00 00	 jmp	 $LN20@bytes_subs
$LN12@bytes_subs:

; 925  :         }
; 926  : 
; 927  :         if (slicelength <= 0) {

  001ff	48 83 7c 24 50
	00		 cmp	 QWORD PTR slicelength$22495[rsp], 0
  00205	7f 18		 jg	 SHORT $LN11@bytes_subs

; 928  :             return PyBytes_FromStringAndSize("", 0);

  00207	33 d2		 xor	 edx, edx
  00209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00210	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00215	e9 41 02 00 00	 jmp	 $LN20@bytes_subs

; 929  :         }
; 930  :         else if (start == 0 && step == 1 &&

  0021a	e9 15 02 00 00	 jmp	 $LN10@bytes_subs
$LN11@bytes_subs:

; 931  :                  slicelength == PyBytes_GET_SIZE(self) &&
; 932  :                  PyBytes_CheckExact(self)) {

  0021f	48 83 7c 24 68
	00		 cmp	 QWORD PTR start$22492[rsp], 0
  00225	0f 85 86 00 00
	00		 jne	 $LN9@bytes_subs
  0022b	48 83 7c 24 58
	01		 cmp	 QWORD PTR step$22494[rsp], 1
  00231	75 7e		 jne	 SHORT $LN9@bytes_subs
  00233	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0023b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0023f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00245	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0024a	85 c0		 test	 eax, eax
  0024c	75 1c		 jne	 SHORT $LN25@bytes_subs
  0024e	41 b8 a3 03 00
	00		 mov	 r8d, 931		; 000003a3H
  00254	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0025b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00268	33 c0		 xor	 eax, eax
$LN25@bytes_subs:
  0026a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00272	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00276	48 39 44 24 50	 cmp	 QWORD PTR slicelength$22495[rsp], rax
  0027b	75 34		 jne	 SHORT $LN9@bytes_subs
  0027d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00284	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0028c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00290	75 1f		 jne	 SHORT $LN9@bytes_subs

; 933  :             Py_INCREF(self);

  00292	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0029a	e8 00 00 00 00	 call	 _Py_IncRef

; 934  :             return (PyObject *)self;

  0029f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002a7	e9 af 01 00 00	 jmp	 $LN20@bytes_subs
  002ac	e9 83 01 00 00	 jmp	 $LN8@bytes_subs
$LN9@bytes_subs:

; 935  :         }
; 936  :         else if (step == 1) {

  002b1	48 83 7c 24 58
	01		 cmp	 QWORD PTR step$22494[rsp], 1
  002b7	75 60		 jne	 SHORT $LN7@bytes_subs

; 937  :             return PyBytes_FromStringAndSize(
; 938  :                 PyBytes_AS_STRING(self) + start,
; 939  :                 slicelength);

  002b9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002c1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002c5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002cb	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002d0	85 c0		 test	 eax, eax
  002d2	75 1c		 jne	 SHORT $LN26@bytes_subs
  002d4	41 b8 aa 03 00
	00		 mov	 r8d, 938		; 000003aaH
  002da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  002e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ee	33 c0		 xor	 eax, eax
$LN26@bytes_subs:
  002f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002f8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR start$22492[rsp]
  002fd	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  00302	48 8b 54 24 50	 mov	 rdx, QWORD PTR slicelength$22495[rsp]
  00307	48 8b c8	 mov	 rcx, rax
  0030a	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0030f	e9 47 01 00 00	 jmp	 $LN20@bytes_subs

; 940  :         }
; 941  :         else {

  00314	e9 1b 01 00 00	 jmp	 $LN6@bytes_subs
$LN7@bytes_subs:

; 942  :             source_buf = PyBytes_AS_STRING(self);

  00319	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00321	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00325	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0032b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00330	85 c0		 test	 eax, eax
  00332	75 1c		 jne	 SHORT $LN27@bytes_subs
  00334	41 b8 ae 03 00
	00		 mov	 r8d, 942		; 000003aeH
  0033a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00341	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00348	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0034e	33 c0		 xor	 eax, eax
$LN27@bytes_subs:
  00350	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00358	48 83 c0 78	 add	 rax, 120		; 00000078H
  0035c	48 89 44 24 38	 mov	 QWORD PTR source_buf$22498[rsp], rax

; 943  :             result = PyBytes_FromStringAndSize(NULL, slicelength);

  00361	48 8b 54 24 50	 mov	 rdx, QWORD PTR slicelength$22495[rsp]
  00366	33 c9		 xor	 ecx, ecx
  00368	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0036d	48 89 44 24 70	 mov	 QWORD PTR result$22500[rsp], rax

; 944  :             if (result == NULL)

  00372	48 83 7c 24 70
	00		 cmp	 QWORD PTR result$22500[rsp], 0
  00378	75 07		 jne	 SHORT $LN5@bytes_subs

; 945  :                 return NULL;

  0037a	33 c0		 xor	 eax, eax
  0037c	e9 da 00 00 00	 jmp	 $LN20@bytes_subs
$LN5@bytes_subs:

; 946  : 
; 947  :             result_buf = PyBytes_AS_STRING(result);

  00381	48 8b 44 24 70	 mov	 rax, QWORD PTR result$22500[rsp]
  00386	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0038a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00390	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00395	85 c0		 test	 eax, eax
  00397	75 1c		 jne	 SHORT $LN28@bytes_subs
  00399	41 b8 b3 03 00
	00		 mov	 r8d, 947		; 000003b3H
  0039f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003b3	33 c0		 xor	 eax, eax
$LN28@bytes_subs:
  003b5	48 8b 44 24 70	 mov	 rax, QWORD PTR result$22500[rsp]
  003ba	48 83 c0 78	 add	 rax, 120		; 00000078H
  003be	48 89 44 24 78	 mov	 QWORD PTR result_buf$22499[rsp], rax

; 948  :             for (cur = start, i = 0; i < slicelength;
; 949  :                  cur += step, i++) {

  003c3	48 8b 44 24 68	 mov	 rax, QWORD PTR start$22492[rsp]
  003c8	48 89 44 24 48	 mov	 QWORD PTR cur$22496[rsp], rax
  003cd	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$22497[rsp], 0
  003d6	eb 22		 jmp	 SHORT $LN4@bytes_subs
$LN3@bytes_subs:
  003d8	48 8b 44 24 58	 mov	 rax, QWORD PTR step$22494[rsp]
  003dd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cur$22496[rsp]
  003e2	48 03 c8	 add	 rcx, rax
  003e5	48 8b c1	 mov	 rax, rcx
  003e8	48 89 44 24 48	 mov	 QWORD PTR cur$22496[rsp], rax
  003ed	48 8b 44 24 40	 mov	 rax, QWORD PTR i$22497[rsp]
  003f2	48 ff c0	 inc	 rax
  003f5	48 89 44 24 40	 mov	 QWORD PTR i$22497[rsp], rax
$LN4@bytes_subs:
  003fa	48 8b 44 24 50	 mov	 rax, QWORD PTR slicelength$22495[rsp]
  003ff	48 39 44 24 40	 cmp	 QWORD PTR i$22497[rsp], rax
  00404	7d 27		 jge	 SHORT $LN2@bytes_subs

; 950  :                 result_buf[i] = source_buf[cur];

  00406	48 8b 44 24 40	 mov	 rax, QWORD PTR i$22497[rsp]
  0040b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR result_buf$22499[rsp]
  00410	48 03 c8	 add	 rcx, rax
  00413	48 8b c1	 mov	 rax, rcx
  00416	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cur$22496[rsp]
  0041b	48 8b 54 24 38	 mov	 rdx, QWORD PTR source_buf$22498[rsp]
  00420	48 03 d1	 add	 rdx, rcx
  00423	48 8b ca	 mov	 rcx, rdx
  00426	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00429	88 08		 mov	 BYTE PTR [rax], cl

; 951  :             }

  0042b	eb ab		 jmp	 SHORT $LN3@bytes_subs
$LN2@bytes_subs:

; 952  : 
; 953  :             return result;

  0042d	48 8b 44 24 70	 mov	 rax, QWORD PTR result$22500[rsp]
  00432	eb 27		 jmp	 SHORT $LN20@bytes_subs
$LN6@bytes_subs:
$LN8@bytes_subs:
$LN10@bytes_subs:

; 954  :         }
; 955  :     }
; 956  :     else {

  00434	eb 25		 jmp	 SHORT $LN1@bytes_subs
$LN13@bytes_subs:

; 957  :         PyErr_Format(PyExc_TypeError,
; 958  :                      "byte indices must be integers, not %.200s",
; 959  :                      Py_TYPE(item)->tp_name);

  00436	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  0043e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00442	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00446	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@HKNFHIEC@byte?5indices?5must?5be?5integers?0?5n@
  0044d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00454	e8 00 00 00 00	 call	 PyErr_Format

; 960  :         return NULL;

  00459	33 c0		 xor	 eax, eax
$LN1@bytes_subs:
$LN14@bytes_subs:
$LN20@bytes_subs:

; 961  :     }
; 962  : }

  0045b	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00462	c3		 ret	 0
bytes_subscript ENDP
_TEXT	ENDS
EXTRN	PyBuffer_FillInfo:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_buffer_getbuffer DD imagerel bytes_buffer_getbuffer
	DD	imagerel bytes_buffer_getbuffer+76
	DD	imagerel $unwind$bytes_buffer_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_buffer_getbuffer DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_buffer_getbuffer
_TEXT	SEGMENT
self$ = 64
view$ = 72
flags$ = 80
bytes_buffer_getbuffer PROC				; COMDAT

; 966  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 967  :     return PyBuffer_FillInfo(view, (PyObject*)self, (void *)self->ob_sval, Py_SIZE(self),
; 968  :                              1, flags);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 83 c0 78	 add	 rax, 120		; 00000078H
  0001c	8b 4c 24 50	 mov	 ecx, DWORD PTR flags$[rsp]
  00020	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00024	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00031	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  00035	4c 8b c0	 mov	 r8, rax
  00038	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  0003d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR view$[rsp]
  00042	e8 00 00 00 00	 call	 PyBuffer_FillInfo

; 969  : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
bytes_buffer_getbuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_09DBJIONJK@?$HMOn?3split?$AA@		; `string'
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_split DD imagerel bytes_split
	DD	imagerel bytes_split+509
	DD	imagerel $unwind$bytes_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_split DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_09DBJIONJK@?$HMOn?3split?$AA@
CONST	SEGMENT
??_C@_09DBJIONJK@?$HMOn?3split?$AA@ DB '|On:split', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_split
_TEXT	SEGMENT
vsub$ = 48
n$ = 128
s$ = 136
list$ = 144
len$ = 152
sub$ = 160
subobj$ = 168
maxsplit$ = 176
self$ = 208
args$ = 216
kwds$ = 224
bytes_split PROC					; COMDAT

; 1013 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1014 :     static char *kwlist[] = {"sep", "maxsplit", 0};
; 1015 :     Py_ssize_t len = PyBytes_GET_SIZE(self), n;

  00016	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00022	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00028	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0002d	85 c0		 test	 eax, eax
  0002f	75 1c		 jne	 SHORT $LN7@bytes_spli
  00031	41 b8 f7 03 00
	00		 mov	 r8d, 1015		; 000003f7H
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004b	33 c0		 xor	 eax, eax
$LN7@bytes_spli:
  0004d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00055	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00059	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 1016 :     Py_ssize_t maxsplit = -1;

  00061	48 c7 84 24 b0
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR maxsplit$[rsp], -1

; 1017 :     const char *s = PyBytes_AS_STRING(self), *sub;

  0006d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00075	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00079	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0007f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00084	85 c0		 test	 eax, eax
  00086	75 1c		 jne	 SHORT $LN8@bytes_spli
  00088	41 b8 f9 03 00
	00		 mov	 r8d, 1017		; 000003f9H
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a2	33 c0		 xor	 eax, eax
$LN8@bytes_spli:
  000a4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000ac	48 83 c0 78	 add	 rax, 120		; 00000078H
  000b0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1018 :     Py_buffer vsub;
; 1019 :     PyObject *list, *subobj = Py_None;

  000b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000bf	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR subobj$[rsp], rax

; 1020 : 
; 1021 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|On:split",
; 1022 :                                      kwlist, &subobj, &maxsplit))

  000c7	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR maxsplit$[rsp]
  000cf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d4	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR subobj$[rsp]
  000dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytes_split@@9@9
  000e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09DBJIONJK@?$HMOn?3split?$AA@
  000ef	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  000f7	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000ff	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00104	85 c0		 test	 eax, eax
  00106	75 07		 jne	 SHORT $LN4@bytes_spli

; 1023 :         return NULL;

  00108	33 c0		 xor	 eax, eax
  0010a	e9 e6 00 00 00	 jmp	 $LN5@bytes_spli
$LN4@bytes_spli:

; 1024 :     if (maxsplit < 0)

  0010f	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR maxsplit$[rsp], 0
  00118	7d 12		 jge	 SHORT $LN3@bytes_spli

; 1025 :         maxsplit = PY_SSIZE_T_MAX;

  0011a	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00124	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR maxsplit$[rsp], rax
$LN3@bytes_spli:

; 1026 :     if (subobj == Py_None)

  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00133	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR subobj$[rsp], rax
  0013b	75 2a		 jne	 SHORT $LN2@bytes_spli

; 1027 :         return stringlib_split_whitespace((PyObject*) self, s, len, maxsplit);

  0013d	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR maxsplit$[rsp]
  00145	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR len$[rsp]
  0014d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00155	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0015d	e8 00 00 00 00	 call	 stringlib_split_whitespace
  00162	e9 8e 00 00 00	 jmp	 $LN5@bytes_spli
$LN2@bytes_spli:

; 1028 :     if (_getbuffer(subobj, &vsub) < 0)

  00167	48 8d 54 24 30	 lea	 rdx, QWORD PTR vsub$[rsp]
  0016c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR subobj$[rsp]
  00174	e8 00 00 00 00	 call	 _getbuffer
  00179	48 85 c0	 test	 rax, rax
  0017c	7d 04		 jge	 SHORT $LN1@bytes_spli

; 1029 :         return NULL;

  0017e	33 c0		 xor	 eax, eax
  00180	eb 73		 jmp	 SHORT $LN5@bytes_spli
$LN1@bytes_spli:

; 1030 :     sub = vsub.buf;

  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR vsub$[rsp]
  00187	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR sub$[rsp], rax

; 1031 :     n = vsub.len;

  0018f	48 8b 44 24 40	 mov	 rax, QWORD PTR vsub$[rsp+16]
  00194	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 1032 : 
; 1033 :     list = stringlib_split((PyObject*) self, s, len, sub, n, maxsplit);

  0019c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR maxsplit$[rsp]
  001a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b6	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR sub$[rsp]
  001be	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR len$[rsp]
  001c6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  001ce	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001d6	e8 00 00 00 00	 call	 stringlib_split
  001db	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR list$[rsp], rax

; 1034 :     PyBuffer_Release(&vsub);

  001e3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vsub$[rsp]
  001e8	e8 00 00 00 00	 call	 PyBuffer_Release

; 1035 :     return list;

  001ed	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR list$[rsp]
$LN5@bytes_spli:

; 1036 : }

  001f5	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001fc	c3		 ret	 0
bytes_split ENDP
_TEXT	ENDS
EXTRN	PyList_Append:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\split.h
pdata	SEGMENT
$pdata$stringlib_split_whitespace DD imagerel stringlib_split_whitespace
	DD	imagerel stringlib_split_whitespace+846
	DD	imagerel $unwind$stringlib_split_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_split_whitespace DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_split_whitespace
_TEXT	SEGMENT
count$ = 32
i$ = 40
list$ = 48
sub$ = 56
j$ = 64
tv67 = 72
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
stringlib_split_whitespace PROC				; COMDAT

; 57   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 58   :     Py_ssize_t i, j, count=0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 59   :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	48 83 7c 24 78
	0c		 cmp	 QWORD PTR maxcount$[rsp], 12
  00027	7c 0b		 jl	 SHORT $LN26@stringlib_@20
  00029	48 c7 44 24 48
	0c 00 00 00	 mov	 QWORD PTR tv67[rsp], 12
  00032	eb 0d		 jmp	 SHORT $LN27@stringlib_@20
$LN26@stringlib_@20:
  00034	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  00039	48 ff c0	 inc	 rax
  0003c	48 89 44 24 48	 mov	 QWORD PTR tv67[rsp], rax
$LN27@stringlib_@20:
  00041	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv67[rsp]
  00046	e8 00 00 00 00	 call	 PyList_New
  0004b	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 60   :     PyObject *sub;
; 61   : 
; 62   :     if (list == NULL)

  00050	48 83 7c 24 30
	00		 cmp	 QWORD PTR list$[rsp], 0
  00056	75 07		 jne	 SHORT $LN23@stringlib_@20

; 63   :         return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 ea 02 00 00	 jmp	 $LN24@stringlib_@20
$LN23@stringlib_@20:

; 64   : 
; 65   :     i = j = 0;

  0005f	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0006d	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN22@stringlib_@20:

; 66   :     while (maxcount-- > 0) {

  00072	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  00077	48 8b 4c 24 78	 mov	 rcx, QWORD PTR maxcount$[rsp]
  0007c	48 ff c9	 dec	 rcx
  0007f	48 89 4c 24 78	 mov	 QWORD PTR maxcount$[rsp], rcx
  00084	48 85 c0	 test	 rax, rax
  00087	0f 8e a4 01 00
	00		 jle	 $LN21@stringlib_@20
$LN20@stringlib_@20:

; 67   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  0008d	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00092	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00097	7d 3b		 jge	 SHORT $LN19@stringlib_@20
  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0009e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b1	0f b6 c0	 movzx	 eax, al
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000bb	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000be	83 e0 08	 and	 eax, 8
  000c1	85 c0		 test	 eax, eax
  000c3	74 0f		 je	 SHORT $LN19@stringlib_@20

; 68   :             i++;

  000c5	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000ca	48 ff c0	 inc	 rax
  000cd	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  000d2	eb b9		 jmp	 SHORT $LN20@stringlib_@20
$LN19@stringlib_@20:

; 69   :         if (i == str_len) break;

  000d4	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  000d9	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000de	75 05		 jne	 SHORT $LN18@stringlib_@20
  000e0	e9 4c 01 00 00	 jmp	 $LN21@stringlib_@20
$LN18@stringlib_@20:

; 70   :         j = i; i++;

  000e5	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000ea	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
  000ef	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000f4	48 ff c0	 inc	 rax
  000f7	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN17@stringlib_@20:

; 71   :         while (i < str_len && !STRINGLIB_ISSPACE(str[i]))

  000fc	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00101	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00106	7d 3b		 jge	 SHORT $LN16@stringlib_@20
  00108	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0010d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  00112	48 03 c8	 add	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0011b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00120	0f b6 c0	 movzx	 eax, al
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0012a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0012d	83 e0 08	 and	 eax, 8
  00130	85 c0		 test	 eax, eax
  00132	75 0f		 jne	 SHORT $LN16@stringlib_@20

; 72   :             i++;

  00134	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00139	48 ff c0	 inc	 rax
  0013c	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00141	eb b9		 jmp	 SHORT $LN17@stringlib_@20
$LN16@stringlib_@20:

; 73   : #ifndef STRINGLIB_MUTABLE
; 74   :         if (j == 0 && i == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {

  00143	48 83 7c 24 40
	00		 cmp	 QWORD PTR j$[rsp], 0
  00149	75 4b		 jne	 SHORT $LN15@stringlib_@20
  0014b	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00150	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00155	75 3f		 jne	 SHORT $LN15@stringlib_@20
  00157	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  0015e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  00163	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00167	75 2d		 jne	 SHORT $LN15@stringlib_@20

; 75   :             /* No whitespace in str_obj, so just use it as list[0] */
; 76   :             Py_INCREF(str_obj);

  00169	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  0016e	e8 00 00 00 00	 call	 _Py_IncRef

; 77   :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  00173	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00178	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0017c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  00181	48 89 08	 mov	 QWORD PTR [rax], rcx

; 78   :             count++;

  00184	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00189	48 ff c0	 inc	 rax
  0018c	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 79   :             break;

  00191	e9 9b 00 00 00	 jmp	 $LN21@stringlib_@20
$LN15@stringlib_@20:

; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  00196	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0019b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  001a0	48 2b c8	 sub	 rcx, rax
  001a3	48 8b c1	 mov	 rax, rcx
  001a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001ab	48 8b 54 24 68	 mov	 rdx, QWORD PTR str$[rsp]
  001b0	48 03 d1	 add	 rdx, rcx
  001b3	48 8b ca	 mov	 rcx, rdx
  001b6	48 8b d0	 mov	 rdx, rax
  001b9	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  001be	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  001c3	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  001c9	75 05		 jne	 SHORT $LN14@stringlib_@20
  001cb	e9 6d 01 00 00	 jmp	 $onError$21377
$LN14@stringlib_@20:
  001d0	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  001d6	7d 19		 jge	 SHORT $LN13@stringlib_@20
  001d8	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  001dd	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001e1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  001e6	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  001eb	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  001ef	eb 2e		 jmp	 SHORT $LN12@stringlib_@20
$LN13@stringlib_@20:
  001f1	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  001f6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  001fb	e8 00 00 00 00	 call	 PyList_Append
  00200	85 c0		 test	 eax, eax
  00202	74 11		 je	 SHORT $LN11@stringlib_@20
  00204	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  00209	e8 00 00 00 00	 call	 _Py_DecRef
  0020e	e9 2a 01 00 00	 jmp	 $onError$21377
  00213	eb 0a		 jmp	 SHORT $LN10@stringlib_@20
$LN11@stringlib_@20:
  00215	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0021a	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@stringlib_@20:
$LN12@stringlib_@20:
  0021f	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00224	48 ff c0	 inc	 rax
  00227	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 83   :     }

  0022c	e9 41 fe ff ff	 jmp	 $LN22@stringlib_@20
$LN21@stringlib_@20:

; 84   : 
; 85   :     if (i < str_len) {

  00231	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00236	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0023b	0f 8d e7 00 00
	00		 jge	 $LN9@stringlib_@20
$LN8@stringlib_@20:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  00241	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00246	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0024b	7d 3b		 jge	 SHORT $LN7@stringlib_@20
  0024d	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00252	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  00257	48 03 c8	 add	 rcx, rax
  0025a	48 8b c1	 mov	 rax, rcx
  0025d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00260	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00265	0f b6 c0	 movzx	 eax, al
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0026f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00272	83 e0 08	 and	 eax, 8
  00275	85 c0		 test	 eax, eax
  00277	74 0f		 je	 SHORT $LN7@stringlib_@20

; 89   :             i++;

  00279	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0027e	48 ff c0	 inc	 rax
  00281	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00286	eb b9		 jmp	 SHORT $LN8@stringlib_@20
$LN7@stringlib_@20:

; 90   :         if (i != str_len)

  00288	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  0028d	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00292	0f 84 90 00 00
	00		 je	 $LN6@stringlib_@20

; 91   :             SPLIT_ADD(str, i, str_len);

  00298	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0029d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR str_len$[rsp]
  002a2	48 2b c8	 sub	 rcx, rax
  002a5	48 8b c1	 mov	 rax, rcx
  002a8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  002ad	48 8b 54 24 68	 mov	 rdx, QWORD PTR str$[rsp]
  002b2	48 03 d1	 add	 rdx, rcx
  002b5	48 8b ca	 mov	 rcx, rdx
  002b8	48 8b d0	 mov	 rdx, rax
  002bb	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  002c0	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  002c5	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  002cb	75 02		 jne	 SHORT $LN5@stringlib_@20
  002cd	eb 6e		 jmp	 SHORT $onError$21377
$LN5@stringlib_@20:
  002cf	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  002d5	7d 19		 jge	 SHORT $LN4@stringlib_@20
  002d7	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  002dc	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  002e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  002e5	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  002ea	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  002ee	eb 2b		 jmp	 SHORT $LN3@stringlib_@20
$LN4@stringlib_@20:
  002f0	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  002f5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  002fa	e8 00 00 00 00	 call	 PyList_Append
  002ff	85 c0		 test	 eax, eax
  00301	74 0e		 je	 SHORT $LN2@stringlib_@20
  00303	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  00308	e8 00 00 00 00	 call	 _Py_DecRef
  0030d	eb 2e		 jmp	 SHORT $onError$21377
  0030f	eb 0a		 jmp	 SHORT $LN1@stringlib_@20
$LN2@stringlib_@20:
  00311	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  00316	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@stringlib_@20:
$LN3@stringlib_@20:
  0031b	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00320	48 ff c0	 inc	 rax
  00323	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
$LN6@stringlib_@20:
$LN9@stringlib_@20:

; 92   :     }
; 93   :     FIX_PREALLOC_SIZE(list);

  00328	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  0032d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00332	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 94   :     return list;

  00336	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  0033b	eb 0c		 jmp	 SHORT $LN24@stringlib_@20
$onError$21377:

; 95   : 
; 96   :   onError:
; 97   :     Py_DECREF(list);

  0033d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00342	e8 00 00 00 00	 call	 _Py_DecRef

; 98   :     return NULL;

  00347	33 c0		 xor	 eax, eax
$LN24@stringlib_@20:

; 99   : }

  00349	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0034d	c3		 ret	 0
stringlib_split_whitespace ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@JDENDMBF@empty?5separator?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_split DD imagerel stringlib_split
	DD	imagerel stringlib_split+833
	DD	imagerel $unwind$stringlib_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_split DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT ??_C@_0BA@JDENDMBF@empty?5separator?$AA@
CONST	SEGMENT
??_C@_0BA@JDENDMBF@empty?5separator?$AA@ DB 'empty separator', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_split
_TEXT	SEGMENT
count$ = 48
i$ = 56
list$ = 64
sub$ = 72
pos$ = 80
j$ = 88
tv77 = 96
str_obj$ = 128
str$ = 136
str_len$ = 144
sep$ = 152
sep_len$ = 160
maxcount$ = 168
stringlib_split PROC					; COMDAT

; 149  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 150  :     Py_ssize_t i, j, pos, count=0;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 151  :     PyObject *list, *sub;
; 152  : 
; 153  :     if (sep_len == 0) {

  00021	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR sep_len$[rsp], 0
  0002a	75 1c		 jne	 SHORT $LN19@stringlib_@21

; 154  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003a	e8 00 00 00 00	 call	 PyErr_SetString

; 155  :         return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 f6 02 00 00	 jmp	 $LN20@stringlib_@21
  00046	eb 46		 jmp	 SHORT $LN18@stringlib_@21
$LN19@stringlib_@21:

; 156  :     }
; 157  :     else if (sep_len == 1)

  00048	48 83 bc 24 a0
	00 00 00 01	 cmp	 QWORD PTR sep_len$[rsp], 1
  00051	75 3b		 jne	 SHORT $LN17@stringlib_@21

; 158  :         return STRINGLIB(split_char)(str_obj, str, str_len, sep[0], maxcount);

  00053	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0005b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00060	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  00068	44 0f b6 08	 movzx	 r9d, BYTE PTR [rax]
  0006c	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR str_len$[rsp]
  00074	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  0007c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str_obj$[rsp]
  00084	e8 00 00 00 00	 call	 stringlib_split_char
  00089	e9 ae 02 00 00	 jmp	 $LN20@stringlib_@21
$LN17@stringlib_@21:
$LN18@stringlib_@21:

; 159  : 
; 160  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  0008e	48 83 bc 24 a8
	00 00 00 0c	 cmp	 QWORD PTR maxcount$[rsp], 12
  00097	7c 0b		 jl	 SHORT $LN22@stringlib_@21
  00099	48 c7 44 24 60
	0c 00 00 00	 mov	 QWORD PTR tv77[rsp], 12
  000a2	eb 10		 jmp	 SHORT $LN23@stringlib_@21
$LN22@stringlib_@21:
  000a4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000ac	48 ff c0	 inc	 rax
  000af	48 89 44 24 60	 mov	 QWORD PTR tv77[rsp], rax
$LN23@stringlib_@21:
  000b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv77[rsp]
  000b9	e8 00 00 00 00	 call	 PyList_New
  000be	48 89 44 24 40	 mov	 QWORD PTR list$[rsp], rax

; 161  :     if (list == NULL)

  000c3	48 83 7c 24 40
	00		 cmp	 QWORD PTR list$[rsp], 0
  000c9	75 07		 jne	 SHORT $LN16@stringlib_@21

; 162  :         return NULL;

  000cb	33 c0		 xor	 eax, eax
  000cd	e9 6a 02 00 00	 jmp	 $LN20@stringlib_@21
$LN16@stringlib_@21:

; 163  : 
; 164  :     i = j = 0;

  000d2	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  000db	48 8b 44 24 58	 mov	 rax, QWORD PTR j$[rsp]
  000e0	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN15@stringlib_@21:

; 165  :     while (maxcount-- > 0) {

  000e5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000ed	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR maxcount$[rsp]
  000f5	48 ff c9	 dec	 rcx
  000f8	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR maxcount$[rsp], rcx
  00100	48 85 c0	 test	 rax, rax
  00103	0f 8e 2c 01 00
	00		 jle	 $LN14@stringlib_@21

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

  00109	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0010e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR str_len$[rsp]
  00116	48 2b c8	 sub	 rcx, rax
  00119	48 8b c1	 mov	 rax, rcx
  0011c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00121	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  00129	48 03 d1	 add	 rdx, rcx
  0012c	48 8b ca	 mov	 rcx, rdx
  0012f	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  00137	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  00140	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR sep_len$[rsp]
  00148	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR sep$[rsp]
  00150	48 8b d0	 mov	 rdx, rax
  00153	e8 00 00 00 00	 call	 fastsearch
  00158	48 89 44 24 50	 mov	 QWORD PTR pos$[rsp], rax

; 167  :         if (pos < 0)

  0015d	48 83 7c 24 50
	00		 cmp	 QWORD PTR pos$[rsp], 0
  00163	7d 05		 jge	 SHORT $LN13@stringlib_@21

; 168  :             break;

  00165	e9 cb 00 00 00	 jmp	 $LN14@stringlib_@21
$LN13@stringlib_@21:

; 169  :         j = i + pos;

  0016a	48 8b 44 24 50	 mov	 rax, QWORD PTR pos$[rsp]
  0016f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00174	48 03 c8	 add	 rcx, rax
  00177	48 8b c1	 mov	 rax, rcx
  0017a	48 89 44 24 58	 mov	 QWORD PTR j$[rsp], rax

; 170  :         SPLIT_ADD(str, i, j);

  0017f	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00184	48 8b 4c 24 58	 mov	 rcx, QWORD PTR j$[rsp]
  00189	48 2b c8	 sub	 rcx, rax
  0018c	48 8b c1	 mov	 rax, rcx
  0018f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00194	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  0019c	48 03 d1	 add	 rdx, rcx
  0019f	48 8b ca	 mov	 rcx, rdx
  001a2	48 8b d0	 mov	 rdx, rax
  001a5	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  001aa	48 89 44 24 48	 mov	 QWORD PTR sub$[rsp], rax
  001af	48 83 7c 24 48
	00		 cmp	 QWORD PTR sub$[rsp], 0
  001b5	75 05		 jne	 SHORT $LN12@stringlib_@21
  001b7	e9 74 01 00 00	 jmp	 $onError$21492
$LN12@stringlib_@21:
  001bc	48 83 7c 24 30
	0c		 cmp	 QWORD PTR count$[rsp], 12
  001c2	7d 19		 jge	 SHORT $LN11@stringlib_@21
  001c4	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  001c9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  001d2	48 8b 54 24 48	 mov	 rdx, QWORD PTR sub$[rsp]
  001d7	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  001db	eb 2e		 jmp	 SHORT $LN10@stringlib_@21
$LN11@stringlib_@21:
  001dd	48 8b 54 24 48	 mov	 rdx, QWORD PTR sub$[rsp]
  001e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  001e7	e8 00 00 00 00	 call	 PyList_Append
  001ec	85 c0		 test	 eax, eax
  001ee	74 11		 je	 SHORT $LN9@stringlib_@21
  001f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sub$[rsp]
  001f5	e8 00 00 00 00	 call	 _Py_DecRef
  001fa	e9 31 01 00 00	 jmp	 $onError$21492
  001ff	eb 0a		 jmp	 SHORT $LN8@stringlib_@21
$LN9@stringlib_@21:
  00201	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sub$[rsp]
  00206	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@stringlib_@21:
$LN10@stringlib_@21:
  0020b	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  00210	48 ff c0	 inc	 rax
  00213	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax

; 171  :         i = j + sep_len;

  00218	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep_len$[rsp]
  00220	48 8b 4c 24 58	 mov	 rcx, QWORD PTR j$[rsp]
  00225	48 03 c8	 add	 rcx, rax
  00228	48 8b c1	 mov	 rax, rcx
  0022b	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax

; 172  :     }

  00230	e9 b0 fe ff ff	 jmp	 $LN15@stringlib_@21
$LN14@stringlib_@21:

; 173  : #ifndef STRINGLIB_MUTABLE
; 174  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  00235	48 83 7c 24 30
	00		 cmp	 QWORD PTR count$[rsp], 0
  0023b	75 48		 jne	 SHORT $LN7@stringlib_@21
  0023d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00244	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str_obj$[rsp]
  0024c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00250	75 33		 jne	 SHORT $LN7@stringlib_@21

; 175  :         /* No match in str_obj, so just use it as list[0] */
; 176  :         Py_INCREF(str_obj);

  00252	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str_obj$[rsp]
  0025a	e8 00 00 00 00	 call	 _Py_IncRef

; 177  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  0025f	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  00264	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00268	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str_obj$[rsp]
  00270	48 89 08	 mov	 QWORD PTR [rax], rcx

; 178  :         count++;

  00273	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  00278	48 ff c0	 inc	 rax
  0027b	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax

; 179  :     } else

  00280	e9 96 00 00 00	 jmp	 $LN6@stringlib_@21
$LN7@stringlib_@21:

; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00285	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0028a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR str_len$[rsp]
  00292	48 2b c8	 sub	 rcx, rax
  00295	48 8b c1	 mov	 rax, rcx
  00298	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0029d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  002a5	48 03 d1	 add	 rdx, rcx
  002a8	48 8b ca	 mov	 rcx, rdx
  002ab	48 8b d0	 mov	 rdx, rax
  002ae	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  002b3	48 89 44 24 48	 mov	 QWORD PTR sub$[rsp], rax
  002b8	48 83 7c 24 48
	00		 cmp	 QWORD PTR sub$[rsp], 0
  002be	75 02		 jne	 SHORT $LN5@stringlib_@21
  002c0	eb 6e		 jmp	 SHORT $onError$21492
$LN5@stringlib_@21:
  002c2	48 83 7c 24 30
	0c		 cmp	 QWORD PTR count$[rsp], 12
  002c8	7d 19		 jge	 SHORT $LN4@stringlib_@21
  002ca	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  002cf	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  002d3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  002d8	48 8b 54 24 48	 mov	 rdx, QWORD PTR sub$[rsp]
  002dd	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  002e1	eb 2b		 jmp	 SHORT $LN3@stringlib_@21
$LN4@stringlib_@21:
  002e3	48 8b 54 24 48	 mov	 rdx, QWORD PTR sub$[rsp]
  002e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  002ed	e8 00 00 00 00	 call	 PyList_Append
  002f2	85 c0		 test	 eax, eax
  002f4	74 0e		 je	 SHORT $LN2@stringlib_@21
  002f6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sub$[rsp]
  002fb	e8 00 00 00 00	 call	 _Py_DecRef
  00300	eb 2e		 jmp	 SHORT $onError$21492
  00302	eb 0a		 jmp	 SHORT $LN1@stringlib_@21
$LN2@stringlib_@21:
  00304	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sub$[rsp]
  00309	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@stringlib_@21:
$LN3@stringlib_@21:
  0030e	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  00313	48 ff c0	 inc	 rax
  00316	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax
$LN6@stringlib_@21:

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  0031b	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  00320	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  00325	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 185  :     return list;

  00329	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  0032e	eb 0c		 jmp	 SHORT $LN20@stringlib_@21
$onError$21492:

; 186  : 
; 187  :   onError:
; 188  :     Py_DECREF(list);

  00330	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  00335	e8 00 00 00 00	 call	 _Py_DecRef

; 189  :     return NULL;

  0033a	33 c0		 xor	 eax, eax
$LN20@stringlib_@21:

; 190  : }

  0033c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00340	c3		 ret	 0
stringlib_split ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_split_char DD imagerel stringlib_split_char
	DD	imagerel stringlib_split_char+689
	DD	imagerel $unwind$stringlib_split_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_split_char DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_split_char
_TEXT	SEGMENT
count$ = 32
i$ = 40
list$ = 48
sub$ = 56
j$ = 64
tv67 = 72
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
stringlib_split_char PROC				; COMDAT

; 106  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 107  :     Py_ssize_t i, j, count=0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 108  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	48 83 bc 24 80
	00 00 00 0c	 cmp	 QWORD PTR maxcount$[rsp], 12
  0002a	7c 0b		 jl	 SHORT $LN23@stringlib_@22
  0002c	48 c7 44 24 48
	0c 00 00 00	 mov	 QWORD PTR tv67[rsp], 12
  00035	eb 10		 jmp	 SHORT $LN24@stringlib_@22
$LN23@stringlib_@22:
  00037	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0003f	48 ff c0	 inc	 rax
  00042	48 89 44 24 48	 mov	 QWORD PTR tv67[rsp], rax
$LN24@stringlib_@22:
  00047	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv67[rsp]
  0004c	e8 00 00 00 00	 call	 PyList_New
  00051	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 109  :     PyObject *sub;
; 110  : 
; 111  :     if (list == NULL)

  00056	48 83 7c 24 30
	00		 cmp	 QWORD PTR list$[rsp], 0
  0005c	75 07		 jne	 SHORT $LN20@stringlib_@22

; 112  :         return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 47 02 00 00	 jmp	 $LN21@stringlib_@22
$LN20@stringlib_@22:

; 113  : 
; 114  :     i = j = 0;

  00065	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00073	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN19@stringlib_@22:

; 115  :     while ((j < str_len) && (maxcount-- > 0)) {

  00078	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  0007d	48 39 44 24 40	 cmp	 QWORD PTR j$[rsp], rax
  00082	0f 8d 1c 01 00
	00		 jge	 $LN18@stringlib_@22
  00088	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00090	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR maxcount$[rsp]
  00098	48 ff c9	 dec	 rcx
  0009b	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR maxcount$[rsp], rcx
  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 8e f8 00 00
	00		 jle	 $LN18@stringlib_@22

; 116  :         for(; j < str_len; j++) {

  000ac	eb 0d		 jmp	 SHORT $LN17@stringlib_@22
$LN16@stringlib_@22:
  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000b3	48 ff c0	 inc	 rax
  000b6	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
$LN17@stringlib_@22:
  000bb	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  000c0	48 39 44 24 40	 cmp	 QWORD PTR j$[rsp], rax
  000c5	0f 8d d4 00 00
	00		 jge	 $LN15@stringlib_@22

; 117  :             /* I found that using memchr makes no difference */
; 118  :             if (str[j] == ch) {

  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000d5	48 03 c8	 add	 rcx, rax
  000d8	48 8b c1	 mov	 rax, rcx
  000db	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000de	0f be 4c 24 78	 movsx	 ecx, BYTE PTR ch$[rsp]
  000e3	3b c1		 cmp	 eax, ecx
  000e5	0f 85 af 00 00
	00		 jne	 $LN14@stringlib_@22

; 119  :                 SPLIT_ADD(str, i, j);

  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000f5	48 2b c8	 sub	 rcx, rax
  000f8	48 8b c1	 mov	 rax, rcx
  000fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00100	48 8b 54 24 68	 mov	 rdx, QWORD PTR str$[rsp]
  00105	48 03 d1	 add	 rdx, rcx
  00108	48 8b ca	 mov	 rcx, rdx
  0010b	48 8b d0	 mov	 rdx, rax
  0010e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00113	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  00118	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0011e	75 05		 jne	 SHORT $LN13@stringlib_@22
  00120	e9 7b 01 00 00	 jmp	 $onError$21432
$LN13@stringlib_@22:
  00125	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  0012b	7d 19		 jge	 SHORT $LN12@stringlib_@22
  0012d	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00132	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00136	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  0013b	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00140	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00144	eb 2e		 jmp	 SHORT $LN11@stringlib_@22
$LN12@stringlib_@22:
  00146	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  0014b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00150	e8 00 00 00 00	 call	 PyList_Append
  00155	85 c0		 test	 eax, eax
  00157	74 11		 je	 SHORT $LN10@stringlib_@22
  00159	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0015e	e8 00 00 00 00	 call	 _Py_DecRef
  00163	e9 38 01 00 00	 jmp	 $onError$21432
  00168	eb 0a		 jmp	 SHORT $LN9@stringlib_@22
$LN10@stringlib_@22:
  0016a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0016f	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@stringlib_@22:
$LN11@stringlib_@22:
  00174	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00179	48 ff c0	 inc	 rax
  0017c	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 120  :                 i = j = j + 1;

  00181	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00186	48 ff c0	 inc	 rax
  00189	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
  0018e	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00193	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 121  :                 break;

  00198	eb 05		 jmp	 SHORT $LN15@stringlib_@22
$LN14@stringlib_@22:

; 122  :             }
; 123  :         }

  0019a	e9 0f ff ff ff	 jmp	 $LN16@stringlib_@22
$LN15@stringlib_@22:

; 124  :     }

  0019f	e9 d4 fe ff ff	 jmp	 $LN19@stringlib_@22
$LN18@stringlib_@22:

; 125  : #ifndef STRINGLIB_MUTABLE
; 126  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  001a4	48 83 7c 24 20
	00		 cmp	 QWORD PTR count$[rsp], 0
  001aa	75 3f		 jne	 SHORT $LN8@stringlib_@22
  001ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  001b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  001b8	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001bc	75 2d		 jne	 SHORT $LN8@stringlib_@22

; 127  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 128  :         Py_INCREF(str_obj);

  001be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  001c3	e8 00 00 00 00	 call	 _Py_IncRef

; 129  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  001c8	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  001cd	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001d1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  001d6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 130  :         count++;

  001d9	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  001de	48 ff c0	 inc	 rax
  001e1	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 131  :     } else

  001e6	e9 a0 00 00 00	 jmp	 $LN7@stringlib_@22
$LN8@stringlib_@22:

; 132  : #endif
; 133  :     if (i <= str_len) {

  001eb	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  001f0	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  001f5	0f 8f 90 00 00
	00		 jg	 $LN6@stringlib_@22

; 134  :         SPLIT_ADD(str, i, str_len);

  001fb	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00200	48 8b 4c 24 70	 mov	 rcx, QWORD PTR str_len$[rsp]
  00205	48 2b c8	 sub	 rcx, rax
  00208	48 8b c1	 mov	 rax, rcx
  0020b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00210	48 8b 54 24 68	 mov	 rdx, QWORD PTR str$[rsp]
  00215	48 03 d1	 add	 rdx, rcx
  00218	48 8b ca	 mov	 rcx, rdx
  0021b	48 8b d0	 mov	 rdx, rax
  0021e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00223	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  00228	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0022e	75 02		 jne	 SHORT $LN5@stringlib_@22
  00230	eb 6e		 jmp	 SHORT $onError$21432
$LN5@stringlib_@22:
  00232	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  00238	7d 19		 jge	 SHORT $LN4@stringlib_@22
  0023a	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  0023f	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00243	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00248	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  0024d	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00251	eb 2b		 jmp	 SHORT $LN3@stringlib_@22
$LN4@stringlib_@22:
  00253	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00258	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0025d	e8 00 00 00 00	 call	 PyList_Append
  00262	85 c0		 test	 eax, eax
  00264	74 0e		 je	 SHORT $LN2@stringlib_@22
  00266	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0026b	e8 00 00 00 00	 call	 _Py_DecRef
  00270	eb 2e		 jmp	 SHORT $onError$21432
  00272	eb 0a		 jmp	 SHORT $LN1@stringlib_@22
$LN2@stringlib_@22:
  00274	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  00279	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@stringlib_@22:
$LN3@stringlib_@22:
  0027e	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00283	48 ff c0	 inc	 rax
  00286	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
$LN6@stringlib_@22:
$LN7@stringlib_@22:

; 135  :     }
; 136  :     FIX_PREALLOC_SIZE(list);

  0028b	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00290	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00295	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 137  :     return list;

  00299	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  0029e	eb 0c		 jmp	 SHORT $LN21@stringlib_@22
$onError$21432:

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

  002a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  002a5	e8 00 00 00 00	 call	 _Py_DecRef

; 141  :     return NULL;

  002aa	33 c0		 xor	 eax, eax
$LN21@stringlib_@22:

; 142  : }

  002ac	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002b0	c3		 ret	 0
stringlib_split_char ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CO@MJBIOIBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyObject_AsCharBuffer:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$bytes_partition DD imagerel bytes_partition
	DD	imagerel bytes_partition+372
	DD	imagerel $unwind$bytes_partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_partition DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1CO@MJBIOIBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@MJBIOIBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, 'e', 00H, 'p', 00H, '_', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_partition
_TEXT	SEGMENT
sep_len$ = 48
sep$ = 56
self$ = 80
sep_obj$ = 88
bytes_partition PROC					; COMDAT

; 1047 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1048 :     const char *sep;
; 1049 :     Py_ssize_t sep_len;
; 1050 : 
; 1051 :     if (PyBytes_Check(sep_obj)) {

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR sep_obj$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00022	85 c0		 test	 eax, eax
  00024	0f 84 86 00 00
	00		 je	 $LN3@bytes_part

; 1052 :         sep = PyBytes_AS_STRING(sep_obj);

  0002a	48 8b 44 24 58	 mov	 rax, QWORD PTR sep_obj$[rsp]
  0002f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00033	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00039	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0003e	85 c0		 test	 eax, eax
  00040	75 1c		 jne	 SHORT $LN6@bytes_part
  00042	41 b8 1c 04 00
	00		 mov	 r8d, 1052		; 0000041cH
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@MJBIOIBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005c	33 c0		 xor	 eax, eax
$LN6@bytes_part:
  0005e	48 8b 44 24 58	 mov	 rax, QWORD PTR sep_obj$[rsp]
  00063	48 83 c0 78	 add	 rax, 120		; 00000078H
  00067	48 89 44 24 38	 mov	 QWORD PTR sep$[rsp], rax

; 1053 :         sep_len = PyBytes_GET_SIZE(sep_obj);

  0006c	48 8b 44 24 58	 mov	 rax, QWORD PTR sep_obj$[rsp]
  00071	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00075	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0007b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00080	85 c0		 test	 eax, eax
  00082	75 1c		 jne	 SHORT $LN7@bytes_part
  00084	41 b8 1d 04 00
	00		 mov	 r8d, 1053		; 0000041dH
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@MJBIOIBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009e	33 c0		 xor	 eax, eax
$LN7@bytes_part:
  000a0	48 8b 44 24 58	 mov	 rax, QWORD PTR sep_obj$[rsp]
  000a5	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a9	48 89 44 24 30	 mov	 QWORD PTR sep_len$[rsp], rax
  000ae	eb 1f		 jmp	 SHORT $LN2@bytes_part
$LN3@bytes_part:

; 1054 :     }
; 1055 :     else if (PyObject_AsCharBuffer(sep_obj, &sep, &sep_len))

  000b0	4c 8d 44 24 30	 lea	 r8, QWORD PTR sep_len$[rsp]
  000b5	48 8d 54 24 38	 lea	 rdx, QWORD PTR sep$[rsp]
  000ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  000bf	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  000c4	85 c0		 test	 eax, eax
  000c6	74 07		 je	 SHORT $LN1@bytes_part

; 1056 :         return NULL;

  000c8	33 c0		 xor	 eax, eax
  000ca	e9 a0 00 00 00	 jmp	 $LN4@bytes_part
$LN1@bytes_part:
$LN2@bytes_part:

; 1057 : 
; 1058 :     return stringlib_partition(
; 1059 :         (PyObject*) self,
; 1060 :         PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),
; 1061 :         sep_obj, sep, sep_len
; 1062 :         );

  000cf	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000de	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000e3	85 c0		 test	 eax, eax
  000e5	75 1c		 jne	 SHORT $LN8@bytes_part
  000e7	41 b8 24 04 00
	00		 mov	 r8d, 1060		; 00000424H
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00101	33 c0		 xor	 eax, eax
$LN8@bytes_part:
  00103	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00108	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0010c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00112	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00117	85 c0		 test	 eax, eax
  00119	75 1c		 jne	 SHORT $LN9@bytes_part
  0011b	41 b8 24 04 00
	00		 mov	 r8d, 1060		; 00000424H
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00135	33 c0		 xor	 eax, eax
$LN9@bytes_part:
  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0013c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00140	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sep_len$[rsp]
  00145	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sep$[rsp]
  0014f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00154	4c 8b 4c 24 58	 mov	 r9, QWORD PTR sep_obj$[rsp]
  00159	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0015e	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00162	48 8b d0	 mov	 rdx, rax
  00165	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0016a	e8 00 00 00 00	 call	 stringlib_partition
$LN4@bytes_part:

; 1063 : }

  0016f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00173	c3		 ret	 0
bytes_partition ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\partition.h
pdata	SEGMENT
$pdata$stringlib_partition DD imagerel stringlib_partition
	DD	imagerel stringlib_partition+391
	DD	imagerel $unwind$stringlib_partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_partition DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_partition
_TEXT	SEGMENT
out$ = 48
pos$ = 56
str_obj$ = 80
str$ = 88
str_len$ = 96
sep_obj$ = 104
sep$ = 112
sep_len$ = 120
stringlib_partition PROC				; COMDAT

; 12   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 13   :     PyObject* out;
; 14   :     Py_ssize_t pos;
; 15   : 
; 16   :     if (sep_len == 0) {

  00018	48 83 7c 24 78
	00		 cmp	 QWORD PTR sep_len$[rsp], 0
  0001e	75 1a		 jne	 SHORT $LN4@stringlib_@23

; 17   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002e	e8 00 00 00 00	 call	 PyErr_SetString

; 18   :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 48 01 00 00	 jmp	 $LN5@stringlib_@23
$LN4@stringlib_@23:

; 19   :     }
; 20   : 
; 21   :     out = PyTuple_New(3);

  0003a	b9 03 00 00 00	 mov	 ecx, 3
  0003f	e8 00 00 00 00	 call	 PyTuple_New
  00044	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax

; 22   :     if (!out)

  00049	48 83 7c 24 30
	00		 cmp	 QWORD PTR out$[rsp], 0
  0004f	75 07		 jne	 SHORT $LN3@stringlib_@23

; 23   :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	e9 2a 01 00 00	 jmp	 $LN5@stringlib_@23
$LN3@stringlib_@23:

; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

  00058	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  00060	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  00069	4c 8b 4c 24 78	 mov	 r9, QWORD PTR sep_len$[rsp]
  0006e	4c 8b 44 24 70	 mov	 r8, QWORD PTR sep$[rsp]
  00073	48 8b 54 24 60	 mov	 rdx, QWORD PTR str_len$[rsp]
  00078	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  0007d	e8 00 00 00 00	 call	 fastsearch
  00082	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 26   : 
; 27   :     if (pos < 0) {

  00087	48 83 7c 24 38
	00		 cmp	 QWORD PTR pos$[rsp], 0
  0008d	7d 5d		 jge	 SHORT $LN2@stringlib_@23

; 28   : #if STRINGLIB_MUTABLE
; 29   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, str_len));
; 30   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));
; 31   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(NULL, 0));
; 32   : #else
; 33   :         Py_INCREF(str_obj);

  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str_obj$[rsp]
  00094	e8 00 00 00 00	 call	 _Py_IncRef

; 34   :         PyTuple_SET_ITEM(out, 0, (PyObject*) str_obj);

  00099	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str_obj$[rsp]
  000a3	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 35   :         Py_INCREF(STRINGLIB_EMPTY);

  000a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR nullstring
  000ae	e8 00 00 00 00	 call	 _Py_IncRef

; 36   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);

  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR nullstring
  000bf	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 37   :         Py_INCREF(STRINGLIB_EMPTY);

  000c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR nullstring
  000ca	e8 00 00 00 00	 call	 _Py_IncRef

; 38   :         PyTuple_SET_ITEM(out, 2, (PyObject*) STRINGLIB_EMPTY);

  000cf	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR nullstring
  000db	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 39   : #endif
; 40   :         return out;

  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000e7	e9 96 00 00 00	 jmp	 $LN5@stringlib_@23
$LN2@stringlib_@23:

; 41   :     }
; 42   : 
; 43   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  000ec	48 8b 54 24 38	 mov	 rdx, QWORD PTR pos$[rsp]
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  000f6	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00100	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 44   :     Py_INCREF(sep_obj);

  00104	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  00109	e8 00 00 00 00	 call	 _Py_IncRef

; 45   :     PyTuple_SET_ITEM(out, 1, sep_obj);

  0010e	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  00113	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  00118	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 46   :     pos += sep_len;

  0011c	48 8b 44 24 78	 mov	 rax, QWORD PTR sep_len$[rsp]
  00121	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pos$[rsp]
  00126	48 03 c8	 add	 rcx, rax
  00129	48 8b c1	 mov	 rax, rcx
  0012c	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 47   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  00131	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  00136	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_len$[rsp]
  0013b	48 2b c8	 sub	 rcx, rax
  0013e	48 8b c1	 mov	 rax, rcx
  00141	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pos$[rsp]
  00146	48 8b 54 24 58	 mov	 rdx, QWORD PTR str$[rsp]
  0014b	48 03 d1	 add	 rdx, rcx
  0014e	48 8b ca	 mov	 rcx, rdx
  00151	48 8b d0	 mov	 rdx, rax
  00154	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00159	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0015e	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 48   : 
; 49   :     if (PyErr_Occurred()) {

  00165	e8 00 00 00 00	 call	 PyErr_Occurred
  0016a	48 85 c0	 test	 rax, rax
  0016d	74 0e		 je	 SHORT $LN1@stringlib_@23

; 50   :         Py_DECREF(out);

  0016f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00174	e8 00 00 00 00	 call	 _Py_DecRef

; 51   :         return NULL;

  00179	33 c0		 xor	 eax, eax
  0017b	eb 05		 jmp	 SHORT $LN5@stringlib_@23
$LN1@stringlib_@23:

; 52   :     }
; 53   : 
; 54   :     return out;

  0017d	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
$LN5@stringlib_@23:

; 55   : }

  00182	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00186	c3		 ret	 0
stringlib_partition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$bytes_rpartition DD imagerel bytes_rpartition
	DD	imagerel bytes_rpartition+372
	DD	imagerel $unwind$bytes_rpartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_rpartition DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_rpartition
_TEXT	SEGMENT
sep_len$ = 48
sep$ = 56
self$ = 80
sep_obj$ = 88
bytes_rpartition PROC					; COMDAT

; 1075 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1076 :     const char *sep;
; 1077 :     Py_ssize_t sep_len;
; 1078 : 
; 1079 :     if (PyBytes_Check(sep_obj)) {

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR sep_obj$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00022	85 c0		 test	 eax, eax
  00024	0f 84 86 00 00
	00		 je	 $LN3@bytes_rpar

; 1080 :         sep = PyBytes_AS_STRING(sep_obj);

  0002a	48 8b 44 24 58	 mov	 rax, QWORD PTR sep_obj$[rsp]
  0002f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00033	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00039	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0003e	85 c0		 test	 eax, eax
  00040	75 1c		 jne	 SHORT $LN6@bytes_rpar
  00042	41 b8 38 04 00
	00		 mov	 r8d, 1080		; 00000438H
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@MJBIOIBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005c	33 c0		 xor	 eax, eax
$LN6@bytes_rpar:
  0005e	48 8b 44 24 58	 mov	 rax, QWORD PTR sep_obj$[rsp]
  00063	48 83 c0 78	 add	 rax, 120		; 00000078H
  00067	48 89 44 24 38	 mov	 QWORD PTR sep$[rsp], rax

; 1081 :         sep_len = PyBytes_GET_SIZE(sep_obj);

  0006c	48 8b 44 24 58	 mov	 rax, QWORD PTR sep_obj$[rsp]
  00071	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00075	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0007b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00080	85 c0		 test	 eax, eax
  00082	75 1c		 jne	 SHORT $LN7@bytes_rpar
  00084	41 b8 39 04 00
	00		 mov	 r8d, 1081		; 00000439H
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@MJBIOIBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009e	33 c0		 xor	 eax, eax
$LN7@bytes_rpar:
  000a0	48 8b 44 24 58	 mov	 rax, QWORD PTR sep_obj$[rsp]
  000a5	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a9	48 89 44 24 30	 mov	 QWORD PTR sep_len$[rsp], rax
  000ae	eb 1f		 jmp	 SHORT $LN2@bytes_rpar
$LN3@bytes_rpar:

; 1082 :     }
; 1083 :     else if (PyObject_AsCharBuffer(sep_obj, &sep, &sep_len))

  000b0	4c 8d 44 24 30	 lea	 r8, QWORD PTR sep_len$[rsp]
  000b5	48 8d 54 24 38	 lea	 rdx, QWORD PTR sep$[rsp]
  000ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  000bf	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  000c4	85 c0		 test	 eax, eax
  000c6	74 07		 je	 SHORT $LN1@bytes_rpar

; 1084 :         return NULL;

  000c8	33 c0		 xor	 eax, eax
  000ca	e9 a0 00 00 00	 jmp	 $LN4@bytes_rpar
$LN1@bytes_rpar:
$LN2@bytes_rpar:

; 1085 : 
; 1086 :     return stringlib_rpartition(
; 1087 :         (PyObject*) self,
; 1088 :         PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),
; 1089 :         sep_obj, sep, sep_len
; 1090 :         );

  000cf	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000de	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000e3	85 c0		 test	 eax, eax
  000e5	75 1c		 jne	 SHORT $LN8@bytes_rpar
  000e7	41 b8 40 04 00
	00		 mov	 r8d, 1088		; 00000440H
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00101	33 c0		 xor	 eax, eax
$LN8@bytes_rpar:
  00103	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00108	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0010c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00112	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00117	85 c0		 test	 eax, eax
  00119	75 1c		 jne	 SHORT $LN9@bytes_rpar
  0011b	41 b8 40 04 00
	00		 mov	 r8d, 1088		; 00000440H
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00135	33 c0		 xor	 eax, eax
$LN9@bytes_rpar:
  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0013c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00140	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sep_len$[rsp]
  00145	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sep$[rsp]
  0014f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00154	4c 8b 4c 24 58	 mov	 r9, QWORD PTR sep_obj$[rsp]
  00159	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0015e	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00162	48 8b d0	 mov	 rdx, rax
  00165	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0016a	e8 00 00 00 00	 call	 stringlib_rpartition
$LN4@bytes_rpar:

; 1091 : }

  0016f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00173	c3		 ret	 0
bytes_rpartition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\partition.h
pdata	SEGMENT
$pdata$stringlib_rpartition DD imagerel stringlib_rpartition
	DD	imagerel stringlib_rpartition+391
	DD	imagerel $unwind$stringlib_rpartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rpartition DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rpartition
_TEXT	SEGMENT
out$ = 48
pos$ = 56
str_obj$ = 80
str$ = 88
str_len$ = 96
sep_obj$ = 104
sep$ = 112
sep_len$ = 120
stringlib_rpartition PROC				; COMDAT

; 62   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 63   :     PyObject* out;
; 64   :     Py_ssize_t pos;
; 65   : 
; 66   :     if (sep_len == 0) {

  00018	48 83 7c 24 78
	00		 cmp	 QWORD PTR sep_len$[rsp], 0
  0001e	75 1a		 jne	 SHORT $LN4@stringlib_@24

; 67   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002e	e8 00 00 00 00	 call	 PyErr_SetString

; 68   :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 48 01 00 00	 jmp	 $LN5@stringlib_@24
$LN4@stringlib_@24:

; 69   :     }
; 70   : 
; 71   :     out = PyTuple_New(3);

  0003a	b9 03 00 00 00	 mov	 ecx, 3
  0003f	e8 00 00 00 00	 call	 PyTuple_New
  00044	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax

; 72   :     if (!out)

  00049	48 83 7c 24 30
	00		 cmp	 QWORD PTR out$[rsp], 0
  0004f	75 07		 jne	 SHORT $LN3@stringlib_@24

; 73   :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	e9 2a 01 00 00	 jmp	 $LN5@stringlib_@24
$LN3@stringlib_@24:

; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

  00058	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  00060	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  00069	4c 8b 4c 24 78	 mov	 r9, QWORD PTR sep_len$[rsp]
  0006e	4c 8b 44 24 70	 mov	 r8, QWORD PTR sep$[rsp]
  00073	48 8b 54 24 60	 mov	 rdx, QWORD PTR str_len$[rsp]
  00078	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  0007d	e8 00 00 00 00	 call	 fastsearch
  00082	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 76   : 
; 77   :     if (pos < 0) {

  00087	48 83 7c 24 38
	00		 cmp	 QWORD PTR pos$[rsp], 0
  0008d	7d 5d		 jge	 SHORT $LN2@stringlib_@24

; 78   : #if STRINGLIB_MUTABLE
; 79   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(NULL, 0));
; 80   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));
; 81   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str, str_len));
; 82   : #else
; 83   :         Py_INCREF(STRINGLIB_EMPTY);

  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR nullstring
  00096	e8 00 00 00 00	 call	 _Py_IncRef

; 84   :         PyTuple_SET_ITEM(out, 0, (PyObject*) STRINGLIB_EMPTY);

  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR nullstring
  000a7	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 85   :         Py_INCREF(STRINGLIB_EMPTY);

  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR nullstring
  000b2	e8 00 00 00 00	 call	 _Py_IncRef

; 86   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);

  000b7	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR nullstring
  000c3	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 87   :         Py_INCREF(str_obj);

  000c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str_obj$[rsp]
  000cc	e8 00 00 00 00	 call	 _Py_IncRef

; 88   :         PyTuple_SET_ITEM(out, 2, (PyObject*) str_obj);

  000d1	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str_obj$[rsp]
  000db	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 89   : #endif
; 90   :         return out;

  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000e7	e9 96 00 00 00	 jmp	 $LN5@stringlib_@24
$LN2@stringlib_@24:

; 91   :     }
; 92   : 
; 93   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  000ec	48 8b 54 24 38	 mov	 rdx, QWORD PTR pos$[rsp]
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  000f6	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00100	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 94   :     Py_INCREF(sep_obj);

  00104	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  00109	e8 00 00 00 00	 call	 _Py_IncRef

; 95   :     PyTuple_SET_ITEM(out, 1, sep_obj);

  0010e	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  00113	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  00118	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 96   :     pos += sep_len;

  0011c	48 8b 44 24 78	 mov	 rax, QWORD PTR sep_len$[rsp]
  00121	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pos$[rsp]
  00126	48 03 c8	 add	 rcx, rax
  00129	48 8b c1	 mov	 rax, rcx
  0012c	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 97   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  00131	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  00136	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_len$[rsp]
  0013b	48 2b c8	 sub	 rcx, rax
  0013e	48 8b c1	 mov	 rax, rcx
  00141	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pos$[rsp]
  00146	48 8b 54 24 58	 mov	 rdx, QWORD PTR str$[rsp]
  0014b	48 03 d1	 add	 rdx, rcx
  0014e	48 8b ca	 mov	 rcx, rdx
  00151	48 8b d0	 mov	 rdx, rax
  00154	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00159	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0015e	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 98   : 
; 99   :     if (PyErr_Occurred()) {

  00165	e8 00 00 00 00	 call	 PyErr_Occurred
  0016a	48 85 c0	 test	 rax, rax
  0016d	74 0e		 je	 SHORT $LN1@stringlib_@24

; 100  :         Py_DECREF(out);

  0016f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00174	e8 00 00 00 00	 call	 _Py_DecRef

; 101  :         return NULL;

  00179	33 c0		 xor	 eax, eax
  0017b	eb 05		 jmp	 SHORT $LN5@stringlib_@24
$LN1@stringlib_@24:

; 102  :     }
; 103  : 
; 104  :     return out;

  0017d	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
$LN5@stringlib_@24:

; 105  : }

  00182	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00186	c3		 ret	 0
stringlib_rpartition ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$bytes_rsplit DD imagerel bytes_rsplit
	DD	imagerel bytes_rsplit+509
	DD	imagerel $unwind$bytes_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_rsplit DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@
CONST	SEGMENT
??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@ DB '|On:rsplit', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_rsplit
_TEXT	SEGMENT
vsub$ = 48
n$ = 128
s$ = 136
list$ = 144
len$ = 152
sub$ = 160
subobj$ = 168
maxsplit$ = 176
self$ = 208
args$ = 216
kwds$ = 224
bytes_rsplit PROC					; COMDAT

; 1105 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1106 :     static char *kwlist[] = {"sep", "maxsplit", 0};
; 1107 :     Py_ssize_t len = PyBytes_GET_SIZE(self), n;

  00016	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00022	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00028	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0002d	85 c0		 test	 eax, eax
  0002f	75 1c		 jne	 SHORT $LN7@bytes_rspl
  00031	41 b8 53 04 00
	00		 mov	 r8d, 1107		; 00000453H
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004b	33 c0		 xor	 eax, eax
$LN7@bytes_rspl:
  0004d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00055	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00059	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 1108 :     Py_ssize_t maxsplit = -1;

  00061	48 c7 84 24 b0
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR maxsplit$[rsp], -1

; 1109 :     const char *s = PyBytes_AS_STRING(self), *sub;

  0006d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00075	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00079	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0007f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00084	85 c0		 test	 eax, eax
  00086	75 1c		 jne	 SHORT $LN8@bytes_rspl
  00088	41 b8 55 04 00
	00		 mov	 r8d, 1109		; 00000455H
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a2	33 c0		 xor	 eax, eax
$LN8@bytes_rspl:
  000a4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000ac	48 83 c0 78	 add	 rax, 120		; 00000078H
  000b0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1110 :     Py_buffer vsub;
; 1111 :     PyObject *list, *subobj = Py_None;

  000b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000bf	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR subobj$[rsp], rax

; 1112 : 
; 1113 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|On:rsplit",
; 1114 :                                      kwlist, &subobj, &maxsplit))

  000c7	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR maxsplit$[rsp]
  000cf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d4	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR subobj$[rsp]
  000dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytes_rsplit@@9@9
  000e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@
  000ef	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  000f7	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000ff	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00104	85 c0		 test	 eax, eax
  00106	75 07		 jne	 SHORT $LN4@bytes_rspl

; 1115 :         return NULL;

  00108	33 c0		 xor	 eax, eax
  0010a	e9 e6 00 00 00	 jmp	 $LN5@bytes_rspl
$LN4@bytes_rspl:

; 1116 :     if (maxsplit < 0)

  0010f	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR maxsplit$[rsp], 0
  00118	7d 12		 jge	 SHORT $LN3@bytes_rspl

; 1117 :         maxsplit = PY_SSIZE_T_MAX;

  0011a	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00124	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR maxsplit$[rsp], rax
$LN3@bytes_rspl:

; 1118 :     if (subobj == Py_None)

  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00133	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR subobj$[rsp], rax
  0013b	75 2a		 jne	 SHORT $LN2@bytes_rspl

; 1119 :         return stringlib_rsplit_whitespace((PyObject*) self, s, len, maxsplit);

  0013d	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR maxsplit$[rsp]
  00145	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR len$[rsp]
  0014d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00155	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0015d	e8 00 00 00 00	 call	 stringlib_rsplit_whitespace
  00162	e9 8e 00 00 00	 jmp	 $LN5@bytes_rspl
$LN2@bytes_rspl:

; 1120 :     if (_getbuffer(subobj, &vsub) < 0)

  00167	48 8d 54 24 30	 lea	 rdx, QWORD PTR vsub$[rsp]
  0016c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR subobj$[rsp]
  00174	e8 00 00 00 00	 call	 _getbuffer
  00179	48 85 c0	 test	 rax, rax
  0017c	7d 04		 jge	 SHORT $LN1@bytes_rspl

; 1121 :         return NULL;

  0017e	33 c0		 xor	 eax, eax
  00180	eb 73		 jmp	 SHORT $LN5@bytes_rspl
$LN1@bytes_rspl:

; 1122 :     sub = vsub.buf;

  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR vsub$[rsp]
  00187	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR sub$[rsp], rax

; 1123 :     n = vsub.len;

  0018f	48 8b 44 24 40	 mov	 rax, QWORD PTR vsub$[rsp+16]
  00194	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 1124 : 
; 1125 :     list = stringlib_rsplit((PyObject*) self, s, len, sub, n, maxsplit);

  0019c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR maxsplit$[rsp]
  001a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b6	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR sub$[rsp]
  001be	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR len$[rsp]
  001c6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  001ce	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001d6	e8 00 00 00 00	 call	 stringlib_rsplit
  001db	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR list$[rsp], rax

; 1126 :     PyBuffer_Release(&vsub);

  001e3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vsub$[rsp]
  001e8	e8 00 00 00 00	 call	 PyBuffer_Release

; 1127 :     return list;

  001ed	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR list$[rsp]
$LN5@bytes_rspl:

; 1128 : }

  001f5	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001fc	c3		 ret	 0
bytes_rsplit ENDP
_TEXT	ENDS
EXTRN	PyList_Reverse:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\split.h
pdata	SEGMENT
$pdata$stringlib_rsplit_whitespace DD imagerel stringlib_rsplit_whitespace
	DD	imagerel stringlib_rsplit_whitespace+824
	DD	imagerel $unwind$stringlib_rsplit_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rsplit_whitespace DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rsplit_whitespace
_TEXT	SEGMENT
count$ = 32
i$ = 40
list$ = 48
sub$ = 56
j$ = 64
tv67 = 72
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
stringlib_rsplit_whitespace PROC			; COMDAT

; 196  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 197  :     Py_ssize_t i, j, count=0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 198  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	48 83 7c 24 78
	0c		 cmp	 QWORD PTR maxcount$[rsp], 12
  00027	7c 0b		 jl	 SHORT $LN27@stringlib_@25
  00029	48 c7 44 24 48
	0c 00 00 00	 mov	 QWORD PTR tv67[rsp], 12
  00032	eb 0d		 jmp	 SHORT $LN28@stringlib_@25
$LN27@stringlib_@25:
  00034	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  00039	48 ff c0	 inc	 rax
  0003c	48 89 44 24 48	 mov	 QWORD PTR tv67[rsp], rax
$LN28@stringlib_@25:
  00041	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv67[rsp]
  00046	e8 00 00 00 00	 call	 PyList_New
  0004b	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 199  :     PyObject *sub;
; 200  : 
; 201  :     if (list == NULL)

  00050	48 83 7c 24 30
	00		 cmp	 QWORD PTR list$[rsp], 0
  00056	75 07		 jne	 SHORT $LN24@stringlib_@25

; 202  :         return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 d4 02 00 00	 jmp	 $LN25@stringlib_@25
$LN24@stringlib_@25:

; 203  : 
; 204  :     i = j = str_len - 1;

  0005f	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00064	48 ff c8	 dec	 rax
  00067	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00071	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN23@stringlib_@25:

; 205  :     while (maxcount-- > 0) {

  00076	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  0007b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR maxcount$[rsp]
  00080	48 ff c9	 dec	 rcx
  00083	48 89 4c 24 78	 mov	 QWORD PTR maxcount$[rsp], rcx
  00088	48 85 c0	 test	 rax, rax
  0008b	0f 8e 9d 01 00
	00		 jle	 $LN22@stringlib_@25
$LN21@stringlib_@25:

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  00091	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00097	7c 3b		 jl	 SHORT $LN20@stringlib_@25
  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0009e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b1	0f b6 c0	 movzx	 eax, al
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000bb	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000be	83 e0 08	 and	 eax, 8
  000c1	85 c0		 test	 eax, eax
  000c3	74 0f		 je	 SHORT $LN20@stringlib_@25

; 207  :             i--;

  000c5	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000ca	48 ff c8	 dec	 rax
  000cd	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  000d2	eb bd		 jmp	 SHORT $LN21@stringlib_@25
$LN20@stringlib_@25:

; 208  :         if (i < 0) break;

  000d4	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000da	7d 05		 jge	 SHORT $LN19@stringlib_@25
  000dc	e9 4d 01 00 00	 jmp	 $LN22@stringlib_@25
$LN19@stringlib_@25:

; 209  :         j = i; i--;

  000e1	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000e6	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000f0	48 ff c8	 dec	 rax
  000f3	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN18@stringlib_@25:

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000f8	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000fe	7c 3b		 jl	 SHORT $LN17@stringlib_@25
  00100	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00105	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  0010a	48 03 c8	 add	 rcx, rax
  0010d	48 8b c1	 mov	 rax, rcx
  00110	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00113	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00118	0f b6 c0	 movzx	 eax, al
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00122	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00125	83 e0 08	 and	 eax, 8
  00128	85 c0		 test	 eax, eax
  0012a	75 0f		 jne	 SHORT $LN17@stringlib_@25

; 211  :             i--;

  0012c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00131	48 ff c8	 dec	 rax
  00134	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00139	eb bd		 jmp	 SHORT $LN18@stringlib_@25
$LN17@stringlib_@25:

; 212  : #ifndef STRINGLIB_MUTABLE
; 213  :         if (j == str_len - 1 && i < 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  0013b	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00140	48 ff c8	 dec	 rax
  00143	48 39 44 24 40	 cmp	 QWORD PTR j$[rsp], rax
  00148	75 47		 jne	 SHORT $LN16@stringlib_@25
  0014a	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00150	7d 3f		 jge	 SHORT $LN16@stringlib_@25
  00152	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00159	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  0015e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00162	75 2d		 jne	 SHORT $LN16@stringlib_@25

; 214  :             /* No whitespace in str_obj, so just use it as list[0] */
; 215  :             Py_INCREF(str_obj);

  00164	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  00169	e8 00 00 00 00	 call	 _Py_IncRef

; 216  :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  0016e	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00173	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00177	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  0017c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 217  :             count++;

  0017f	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00184	48 ff c0	 inc	 rax
  00187	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 218  :             break;

  0018c	e9 9d 00 00 00	 jmp	 $LN22@stringlib_@25
$LN16@stringlib_@25:

; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  00191	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00196	48 ff c0	 inc	 rax
  00199	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0019e	48 ff c1	 inc	 rcx
  001a1	48 2b c1	 sub	 rax, rcx
  001a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  001a9	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  001ae	48 8d 4c 11 01	 lea	 rcx, QWORD PTR [rcx+rdx+1]
  001b3	48 8b d0	 mov	 rdx, rax
  001b6	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  001bb	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  001c0	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  001c6	75 05		 jne	 SHORT $LN15@stringlib_@25
  001c8	e9 5a 01 00 00	 jmp	 $onError$21555
$LN15@stringlib_@25:
  001cd	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  001d3	7d 19		 jge	 SHORT $LN14@stringlib_@25
  001d5	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  001da	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001de	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  001e3	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  001e8	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  001ec	eb 2e		 jmp	 SHORT $LN13@stringlib_@25
$LN14@stringlib_@25:
  001ee	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  001f3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  001f8	e8 00 00 00 00	 call	 PyList_Append
  001fd	85 c0		 test	 eax, eax
  001ff	74 11		 je	 SHORT $LN12@stringlib_@25
  00201	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  00206	e8 00 00 00 00	 call	 _Py_DecRef
  0020b	e9 17 01 00 00	 jmp	 $onError$21555
  00210	eb 0a		 jmp	 SHORT $LN11@stringlib_@25
$LN12@stringlib_@25:
  00212	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  00217	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@stringlib_@25:
$LN13@stringlib_@25:
  0021c	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00221	48 ff c0	 inc	 rax
  00224	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 222  :     }

  00229	e9 48 fe ff ff	 jmp	 $LN23@stringlib_@25
$LN22@stringlib_@25:

; 223  : 
; 224  :     if (i >= 0) {

  0022e	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00234	0f 8c c8 00 00
	00		 jl	 $LN10@stringlib_@25
$LN9@stringlib_@25:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0023a	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00240	7c 3b		 jl	 SHORT $LN8@stringlib_@25
  00242	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00247	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  0024c	48 03 c8	 add	 rcx, rax
  0024f	48 8b c1	 mov	 rax, rcx
  00252	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00255	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0025a	0f b6 c0	 movzx	 eax, al
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00264	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00267	83 e0 08	 and	 eax, 8
  0026a	85 c0		 test	 eax, eax
  0026c	74 0f		 je	 SHORT $LN8@stringlib_@25

; 228  :             i--;

  0026e	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00273	48 ff c8	 dec	 rax
  00276	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0027b	eb bd		 jmp	 SHORT $LN9@stringlib_@25
$LN8@stringlib_@25:

; 229  :         if (i >= 0)

  0027d	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00283	7c 7d		 jl	 SHORT $LN7@stringlib_@25

; 230  :             SPLIT_ADD(str, 0, i + 1);

  00285	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0028a	48 ff c0	 inc	 rax
  0028d	48 8b d0	 mov	 rdx, rax
  00290	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  00295	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0029a	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  0029f	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  002a5	75 02		 jne	 SHORT $LN6@stringlib_@25
  002a7	eb 7e		 jmp	 SHORT $onError$21555
$LN6@stringlib_@25:
  002a9	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  002af	7d 19		 jge	 SHORT $LN5@stringlib_@25
  002b1	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  002b6	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  002ba	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  002bf	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  002c4	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  002c8	eb 2b		 jmp	 SHORT $LN4@stringlib_@25
$LN5@stringlib_@25:
  002ca	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  002cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  002d4	e8 00 00 00 00	 call	 PyList_Append
  002d9	85 c0		 test	 eax, eax
  002db	74 0e		 je	 SHORT $LN3@stringlib_@25
  002dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  002e2	e8 00 00 00 00	 call	 _Py_DecRef
  002e7	eb 3e		 jmp	 SHORT $onError$21555
  002e9	eb 0a		 jmp	 SHORT $LN2@stringlib_@25
$LN3@stringlib_@25:
  002eb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  002f0	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@stringlib_@25:
$LN4@stringlib_@25:
  002f5	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  002fa	48 ff c0	 inc	 rax
  002fd	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
$LN7@stringlib_@25:
$LN10@stringlib_@25:

; 231  :     }
; 232  :     FIX_PREALLOC_SIZE(list);

  00302	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00307	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  0030c	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 233  :     if (PyList_Reverse(list) < 0)

  00310	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00315	e8 00 00 00 00	 call	 PyList_Reverse
  0031a	85 c0		 test	 eax, eax
  0031c	7d 02		 jge	 SHORT $LN1@stringlib_@25

; 234  :         goto onError;

  0031e	eb 07		 jmp	 SHORT $onError$21555
$LN1@stringlib_@25:

; 235  :     return list;

  00320	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00325	eb 0c		 jmp	 SHORT $LN25@stringlib_@25
$onError$21555:

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  00327	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0032c	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  00331	33 c0		 xor	 eax, eax
$LN25@stringlib_@25:

; 240  : }

  00333	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00337	c3		 ret	 0
stringlib_rsplit_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rsplit DD imagerel stringlib_rsplit
	DD	imagerel stringlib_rsplit+753
	DD	imagerel $unwind$stringlib_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rsplit DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rsplit
_TEXT	SEGMENT
count$ = 48
list$ = 56
sub$ = 64
pos$ = 72
j$ = 80
tv77 = 88
str_obj$ = 112
str$ = 120
str_len$ = 128
sep$ = 136
sep_len$ = 144
maxcount$ = 152
stringlib_rsplit PROC					; COMDAT

; 291  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 292  :     Py_ssize_t j, pos, count=0;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 293  :     PyObject *list, *sub;
; 294  : 
; 295  :     if (sep_len == 0) {

  00021	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR sep_len$[rsp], 0
  0002a	75 1c		 jne	 SHORT $LN20@stringlib_@26

; 296  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003a	e8 00 00 00 00	 call	 PyErr_SetString

; 297  :         return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 a6 02 00 00	 jmp	 $LN21@stringlib_@26
  00046	eb 40		 jmp	 SHORT $LN19@stringlib_@26
$LN20@stringlib_@26:

; 298  :     }
; 299  :     else if (sep_len == 1)

  00048	48 83 bc 24 90
	00 00 00 01	 cmp	 QWORD PTR sep_len$[rsp], 1
  00051	75 35		 jne	 SHORT $LN18@stringlib_@26

; 300  :         return STRINGLIB(rsplit_char)(str_obj, str, str_len, sep[0], maxcount);

  00053	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0005b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00060	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  00068	44 0f b6 08	 movzx	 r9d, BYTE PTR [rax]
  0006c	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR str_len$[rsp]
  00074	48 8b 54 24 78	 mov	 rdx, QWORD PTR str$[rsp]
  00079	48 8b 4c 24 70	 mov	 rcx, QWORD PTR str_obj$[rsp]
  0007e	e8 00 00 00 00	 call	 stringlib_rsplit_char
  00083	e9 64 02 00 00	 jmp	 $LN21@stringlib_@26
$LN18@stringlib_@26:
$LN19@stringlib_@26:

; 301  : 
; 302  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  00088	48 83 bc 24 98
	00 00 00 0c	 cmp	 QWORD PTR maxcount$[rsp], 12
  00091	7c 0b		 jl	 SHORT $LN23@stringlib_@26
  00093	48 c7 44 24 58
	0c 00 00 00	 mov	 QWORD PTR tv77[rsp], 12
  0009c	eb 10		 jmp	 SHORT $LN24@stringlib_@26
$LN23@stringlib_@26:
  0009e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000a6	48 ff c0	 inc	 rax
  000a9	48 89 44 24 58	 mov	 QWORD PTR tv77[rsp], rax
$LN24@stringlib_@26:
  000ae	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv77[rsp]
  000b3	e8 00 00 00 00	 call	 PyList_New
  000b8	48 89 44 24 38	 mov	 QWORD PTR list$[rsp], rax

; 303  :     if (list == NULL)

  000bd	48 83 7c 24 38
	00		 cmp	 QWORD PTR list$[rsp], 0
  000c3	75 07		 jne	 SHORT $LN17@stringlib_@26

; 304  :         return NULL;

  000c5	33 c0		 xor	 eax, eax
  000c7	e9 20 02 00 00	 jmp	 $LN21@stringlib_@26
$LN17@stringlib_@26:

; 305  : 
; 306  :     j = str_len;

  000cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str_len$[rsp]
  000d4	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax
$LN16@stringlib_@26:

; 307  :     while (maxcount-- > 0) {

  000d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000e1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR maxcount$[rsp]
  000e9	48 ff c9	 dec	 rcx
  000ec	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR maxcount$[rsp], rcx
  000f4	48 85 c0	 test	 rax, rax
  000f7	0f 8e 03 01 00
	00		 jle	 $LN15@stringlib_@26

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

  000fd	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  00105	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  0010e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR sep_len$[rsp]
  00116	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR sep$[rsp]
  0011e	48 8b 54 24 50	 mov	 rdx, QWORD PTR j$[rsp]
  00123	48 8b 4c 24 78	 mov	 rcx, QWORD PTR str$[rsp]
  00128	e8 00 00 00 00	 call	 fastsearch
  0012d	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 309  :         if (pos < 0)

  00132	48 83 7c 24 48
	00		 cmp	 QWORD PTR pos$[rsp], 0
  00138	7d 05		 jge	 SHORT $LN14@stringlib_@26

; 310  :             break;

  0013a	e9 c1 00 00 00	 jmp	 $LN15@stringlib_@26
$LN14@stringlib_@26:

; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  0013f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sep_len$[rsp]
  00147	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pos$[rsp]
  0014c	48 03 c8	 add	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  00157	48 2b c8	 sub	 rcx, rax
  0015a	48 8b c1	 mov	 rax, rcx
  0015d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sep_len$[rsp]
  00165	48 8b 54 24 48	 mov	 rdx, QWORD PTR pos$[rsp]
  0016a	48 03 d1	 add	 rdx, rcx
  0016d	48 8b ca	 mov	 rcx, rdx
  00170	48 8b 54 24 78	 mov	 rdx, QWORD PTR str$[rsp]
  00175	48 03 d1	 add	 rdx, rcx
  00178	48 8b ca	 mov	 rcx, rdx
  0017b	48 8b d0	 mov	 rdx, rax
  0017e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00183	48 89 44 24 40	 mov	 QWORD PTR sub$[rsp], rax
  00188	48 83 7c 24 40
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0018e	75 05		 jne	 SHORT $LN13@stringlib_@26
  00190	e9 4b 01 00 00	 jmp	 $onError$21671
$LN13@stringlib_@26:
  00195	48 83 7c 24 30
	0c		 cmp	 QWORD PTR count$[rsp], 12
  0019b	7d 19		 jge	 SHORT $LN12@stringlib_@26
  0019d	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  001a2	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  001ab	48 8b 54 24 40	 mov	 rdx, QWORD PTR sub$[rsp]
  001b0	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  001b4	eb 2e		 jmp	 SHORT $LN11@stringlib_@26
$LN12@stringlib_@26:
  001b6	48 8b 54 24 40	 mov	 rdx, QWORD PTR sub$[rsp]
  001bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$[rsp]
  001c0	e8 00 00 00 00	 call	 PyList_Append
  001c5	85 c0		 test	 eax, eax
  001c7	74 11		 je	 SHORT $LN10@stringlib_@26
  001c9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sub$[rsp]
  001ce	e8 00 00 00 00	 call	 _Py_DecRef
  001d3	e9 08 01 00 00	 jmp	 $onError$21671
  001d8	eb 0a		 jmp	 SHORT $LN9@stringlib_@26
$LN10@stringlib_@26:
  001da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sub$[rsp]
  001df	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@stringlib_@26:
$LN11@stringlib_@26:
  001e4	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  001e9	48 ff c0	 inc	 rax
  001ec	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax

; 312  :         j = pos;

  001f1	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  001f6	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax

; 313  :     }

  001fb	e9 d9 fe ff ff	 jmp	 $LN16@stringlib_@26
$LN15@stringlib_@26:

; 314  : #ifndef STRINGLIB_MUTABLE
; 315  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  00200	48 83 7c 24 30
	00		 cmp	 QWORD PTR count$[rsp], 0
  00206	75 3c		 jne	 SHORT $LN8@stringlib_@26
  00208	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  0020f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR str_obj$[rsp]
  00214	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00218	75 2a		 jne	 SHORT $LN8@stringlib_@26

; 316  :         /* No match in str_obj, so just use it as list[0] */
; 317  :         Py_INCREF(str_obj);

  0021a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR str_obj$[rsp]
  0021f	e8 00 00 00 00	 call	 _Py_IncRef

; 318  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  00224	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  00229	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0022d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR str_obj$[rsp]
  00232	48 89 08	 mov	 QWORD PTR [rax], rcx

; 319  :         count++;

  00235	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  0023a	48 ff c0	 inc	 rax
  0023d	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax

; 320  :     } else

  00242	eb 77		 jmp	 SHORT $LN7@stringlib_@26
$LN8@stringlib_@26:

; 321  : #endif
; 322  :     {
; 323  :         SPLIT_ADD(str, 0, j);

  00244	48 8b 54 24 50	 mov	 rdx, QWORD PTR j$[rsp]
  00249	48 8b 4c 24 78	 mov	 rcx, QWORD PTR str$[rsp]
  0024e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00253	48 89 44 24 40	 mov	 QWORD PTR sub$[rsp], rax
  00258	48 83 7c 24 40
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0025e	75 02		 jne	 SHORT $LN6@stringlib_@26
  00260	eb 7e		 jmp	 SHORT $onError$21671
$LN6@stringlib_@26:
  00262	48 83 7c 24 30
	0c		 cmp	 QWORD PTR count$[rsp], 12
  00268	7d 19		 jge	 SHORT $LN5@stringlib_@26
  0026a	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  0026f	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00273	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  00278	48 8b 54 24 40	 mov	 rdx, QWORD PTR sub$[rsp]
  0027d	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00281	eb 2b		 jmp	 SHORT $LN4@stringlib_@26
$LN5@stringlib_@26:
  00283	48 8b 54 24 40	 mov	 rdx, QWORD PTR sub$[rsp]
  00288	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$[rsp]
  0028d	e8 00 00 00 00	 call	 PyList_Append
  00292	85 c0		 test	 eax, eax
  00294	74 0e		 je	 SHORT $LN3@stringlib_@26
  00296	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sub$[rsp]
  0029b	e8 00 00 00 00	 call	 _Py_DecRef
  002a0	eb 3e		 jmp	 SHORT $onError$21671
  002a2	eb 0a		 jmp	 SHORT $LN2@stringlib_@26
$LN3@stringlib_@26:
  002a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sub$[rsp]
  002a9	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@stringlib_@26:
$LN4@stringlib_@26:
  002ae	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  002b3	48 ff c0	 inc	 rax
  002b6	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax
$LN7@stringlib_@26:

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);

  002bb	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  002c0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  002c5	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 326  :     if (PyList_Reverse(list) < 0)

  002c9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$[rsp]
  002ce	e8 00 00 00 00	 call	 PyList_Reverse
  002d3	85 c0		 test	 eax, eax
  002d5	7d 02		 jge	 SHORT $LN1@stringlib_@26

; 327  :         goto onError;

  002d7	eb 07		 jmp	 SHORT $onError$21671
$LN1@stringlib_@26:

; 328  :     return list;

  002d9	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  002de	eb 0c		 jmp	 SHORT $LN21@stringlib_@26
$onError$21671:

; 329  : 
; 330  :   onError:
; 331  :     Py_DECREF(list);

  002e0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$[rsp]
  002e5	e8 00 00 00 00	 call	 _Py_DecRef

; 332  :     return NULL;

  002ea	33 c0		 xor	 eax, eax
$LN21@stringlib_@26:

; 333  : }

  002ec	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002f0	c3		 ret	 0
stringlib_rsplit ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rsplit_char DD imagerel stringlib_rsplit_char
	DD	imagerel stringlib_rsplit_char+676
	DD	imagerel $unwind$stringlib_rsplit_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rsplit_char DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rsplit_char
_TEXT	SEGMENT
count$ = 32
i$ = 40
list$ = 48
sub$ = 56
j$ = 64
tv67 = 72
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
stringlib_rsplit_char PROC				; COMDAT

; 247  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 248  :     Py_ssize_t i, j, count=0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 249  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	48 83 bc 24 80
	00 00 00 0c	 cmp	 QWORD PTR maxcount$[rsp], 12
  0002a	7c 0b		 jl	 SHORT $LN24@stringlib_@27
  0002c	48 c7 44 24 48
	0c 00 00 00	 mov	 QWORD PTR tv67[rsp], 12
  00035	eb 10		 jmp	 SHORT $LN25@stringlib_@27
$LN24@stringlib_@27:
  00037	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0003f	48 ff c0	 inc	 rax
  00042	48 89 44 24 48	 mov	 QWORD PTR tv67[rsp], rax
$LN25@stringlib_@27:
  00047	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv67[rsp]
  0004c	e8 00 00 00 00	 call	 PyList_New
  00051	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 250  :     PyObject *sub;
; 251  : 
; 252  :     if (list == NULL)

  00056	48 83 7c 24 30
	00		 cmp	 QWORD PTR list$[rsp], 0
  0005c	75 07		 jne	 SHORT $LN21@stringlib_@27

; 253  :         return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 3a 02 00 00	 jmp	 $LN22@stringlib_@27
$LN21@stringlib_@27:

; 254  : 
; 255  :     i = j = str_len - 1;

  00065	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  0006a	48 ff c8	 dec	 rax
  0006d	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00077	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN20@stringlib_@27:

; 256  :     while ((i >= 0) && (maxcount-- > 0)) {

  0007c	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00082	0f 8c 1a 01 00
	00		 jl	 $LN19@stringlib_@27
  00088	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00090	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR maxcount$[rsp]
  00098	48 ff c9	 dec	 rcx
  0009b	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR maxcount$[rsp], rcx
  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 8e f6 00 00
	00		 jle	 $LN19@stringlib_@27

; 257  :         for(; i >= 0; i--) {

  000ac	eb 0d		 jmp	 SHORT $LN18@stringlib_@27
$LN17@stringlib_@27:
  000ae	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000b3	48 ff c8	 dec	 rax
  000b6	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN18@stringlib_@27:
  000bb	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000c1	0f 8c d6 00 00
	00		 jl	 $LN16@stringlib_@27

; 258  :             if (str[i] == ch) {

  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000da	0f be 4c 24 78	 movsx	 ecx, BYTE PTR ch$[rsp]
  000df	3b c1		 cmp	 eax, ecx
  000e1	0f 85 b1 00 00
	00		 jne	 $LN15@stringlib_@27

; 259  :                 SPLIT_ADD(str, i + 1, j + 1);

  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000ec	48 ff c0	 inc	 rax
  000ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000f4	48 ff c1	 inc	 rcx
  000f7	48 2b c1	 sub	 rax, rcx
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000ff	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00104	48 8d 4c 11 01	 lea	 rcx, QWORD PTR [rcx+rdx+1]
  00109	48 8b d0	 mov	 rdx, rax
  0010c	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00111	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  00116	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0011c	75 05		 jne	 SHORT $LN14@stringlib_@27
  0011e	e9 70 01 00 00	 jmp	 $onError$21611
$LN14@stringlib_@27:
  00123	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  00129	7d 19		 jge	 SHORT $LN13@stringlib_@27
  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00130	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00139	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  0013e	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00142	eb 2e		 jmp	 SHORT $LN12@stringlib_@27
$LN13@stringlib_@27:
  00144	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00149	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0014e	e8 00 00 00 00	 call	 PyList_Append
  00153	85 c0		 test	 eax, eax
  00155	74 11		 je	 SHORT $LN11@stringlib_@27
  00157	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0015c	e8 00 00 00 00	 call	 _Py_DecRef
  00161	e9 2d 01 00 00	 jmp	 $onError$21611
  00166	eb 0a		 jmp	 SHORT $LN10@stringlib_@27
$LN11@stringlib_@27:
  00168	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0016d	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@stringlib_@27:
$LN12@stringlib_@27:
  00172	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00177	48 ff c0	 inc	 rax
  0017a	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 260  :                 j = i = i - 1;

  0017f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00184	48 ff c8	 dec	 rax
  00187	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0018c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00191	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax

; 261  :                 break;

  00196	eb 05		 jmp	 SHORT $LN16@stringlib_@27
$LN15@stringlib_@27:

; 262  :             }
; 263  :         }

  00198	e9 11 ff ff ff	 jmp	 $LN17@stringlib_@27
$LN16@stringlib_@27:

; 264  :     }

  0019d	e9 da fe ff ff	 jmp	 $LN20@stringlib_@27
$LN19@stringlib_@27:

; 265  : #ifndef STRINGLIB_MUTABLE
; 266  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  001a2	48 83 7c 24 20
	00		 cmp	 QWORD PTR count$[rsp], 0
  001a8	75 3f		 jne	 SHORT $LN9@stringlib_@27
  001aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  001b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  001b6	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001ba	75 2d		 jne	 SHORT $LN9@stringlib_@27

; 267  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 268  :         Py_INCREF(str_obj);

  001bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  001c1	e8 00 00 00 00	 call	 _Py_IncRef

; 269  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  001c6	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  001cb	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  001d4	48 89 08	 mov	 QWORD PTR [rax], rcx

; 270  :         count++;

  001d7	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  001dc	48 ff c0	 inc	 rax
  001df	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 271  :     } else

  001e4	e9 85 00 00 00	 jmp	 $LN8@stringlib_@27
$LN9@stringlib_@27:

; 272  : #endif
; 273  :     if (j >= -1) {

  001e9	48 83 7c 24 40
	ff		 cmp	 QWORD PTR j$[rsp], -1
  001ef	7c 7d		 jl	 SHORT $LN7@stringlib_@27

; 274  :         SPLIT_ADD(str, 0, j + 1);

  001f1	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  001f6	48 ff c0	 inc	 rax
  001f9	48 8b d0	 mov	 rdx, rax
  001fc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  00201	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00206	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  0020b	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  00211	75 02		 jne	 SHORT $LN6@stringlib_@27
  00213	eb 7e		 jmp	 SHORT $onError$21611
$LN6@stringlib_@27:
  00215	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  0021b	7d 19		 jge	 SHORT $LN5@stringlib_@27
  0021d	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00222	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00226	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  0022b	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00230	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00234	eb 2b		 jmp	 SHORT $LN4@stringlib_@27
$LN5@stringlib_@27:
  00236	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  0023b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00240	e8 00 00 00 00	 call	 PyList_Append
  00245	85 c0		 test	 eax, eax
  00247	74 0e		 je	 SHORT $LN3@stringlib_@27
  00249	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0024e	e8 00 00 00 00	 call	 _Py_DecRef
  00253	eb 3e		 jmp	 SHORT $onError$21611
  00255	eb 0a		 jmp	 SHORT $LN2@stringlib_@27
$LN3@stringlib_@27:
  00257	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0025c	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@stringlib_@27:
$LN4@stringlib_@27:
  00261	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00266	48 ff c0	 inc	 rax
  00269	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
$LN7@stringlib_@27:
$LN8@stringlib_@27:

; 275  :     }
; 276  :     FIX_PREALLOC_SIZE(list);

  0026e	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00273	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00278	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 277  :     if (PyList_Reverse(list) < 0)

  0027c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00281	e8 00 00 00 00	 call	 PyList_Reverse
  00286	85 c0		 test	 eax, eax
  00288	7d 02		 jge	 SHORT $LN1@stringlib_@27

; 278  :         goto onError;

  0028a	eb 07		 jmp	 SHORT $onError$21611
$LN1@stringlib_@27:

; 279  :     return list;

  0028c	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00291	eb 0c		 jmp	 SHORT $LN22@stringlib_@27
$onError$21611:

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

  00293	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00298	e8 00 00 00 00	 call	 _Py_DecRef

; 283  :     return NULL;

  0029d	33 c0		 xor	 eax, eax
$LN22@stringlib_@27:

; 284  : }

  0029f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002a3	c3		 ret	 0
stringlib_rsplit_char ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DA@GHGMKAJM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@POOCBCOH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@OADLJEAH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CE@MJLEPPKI@join?$CI?$CJ?5result?5is?5too?5long?5for?5by@ ; `string'
PUBLIC	??_C@_0CP@BJLDFOBC@sequence?5item?5?$CFzd?3?5expected?5byte@ ; `string'
EXTRN	_PyByteArray_empty_string:BYTE
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyByteArray_Type:BYTE
EXTRN	PySequence_Size:PROC
EXTRN	PySequence_Fast:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$bytes_join DD imagerel bytes_join
	DD	imagerel bytes_join+1739
	DD	imagerel $unwind$bytes_join
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_join DD 021101H
	DD	01d0111H
xdata	ENDS
;	COMDAT ??_C@_1DA@GHGMKAJM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@GHGMKAJM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'm', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@POOCBCOH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@POOCBCOH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'm', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@OADLJEAH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@OADLJEAH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MJLEPPKI@join?$CI?$CJ?5result?5is?5too?5long?5for?5by@
CONST	SEGMENT
??_C@_0CE@MJLEPPKI@join?$CI?$CJ?5result?5is?5too?5long?5for?5by@ DB 'join'
	DB	'() result is too long for bytes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BJLDFOBC@sequence?5item?5?$CFzd?3?5expected?5byte@
CONST	SEGMENT
??_C@_0CP@BJLDFOBC@sequence?5item?5?$CFzd?3?5expected?5byte@ DB 'sequence'
	DB	' item %zd: expected bytes, %.80s found', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_join
_TEXT	SEGMENT
p$ = 32
res$ = 40
i$ = 48
seplen$ = 56
seqlen$ = 64
seq$ = 72
sep$ = 80
item$ = 88
sz$ = 96
old_sz$22738 = 104
n$22772 = 112
q$22773 = 120
t_$22780 = 128
s_$22782 = 136
i_$22778 = 144
n_$22779 = 152
t_$22811 = 160
s_$22813 = 168
i_$22809 = 176
n_$22810 = 184
tv133 = 192
tv150 = 200
tv215 = 208
tv244 = 216
self$ = 240
orig$ = 248
bytes_join PROC						; COMDAT

; 1139 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 1140 :     char *sep = PyBytes_AS_STRING(self);

  00011	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00019	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00023	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00028	85 c0		 test	 eax, eax
  0002a	75 1c		 jne	 SHORT $LN37@bytes_join
  0002c	41 b8 74 04 00
	00		 mov	 r8d, 1140		; 00000474H
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00046	33 c0		 xor	 eax, eax
$LN37@bytes_join:
  00048	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00050	48 83 c0 78	 add	 rax, 120		; 00000078H
  00054	48 89 44 24 50	 mov	 QWORD PTR sep$[rsp], rax

; 1141 :     const Py_ssize_t seplen = PyBytes_GET_SIZE(self);

  00059	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00061	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00065	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0006b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00070	85 c0		 test	 eax, eax
  00072	75 1c		 jne	 SHORT $LN38@bytes_join
  00074	41 b8 75 04 00
	00		 mov	 r8d, 1141		; 00000475H
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008e	33 c0		 xor	 eax, eax
$LN38@bytes_join:
  00090	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00098	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0009c	48 89 44 24 38	 mov	 QWORD PTR seplen$[rsp], rax

; 1142 :     PyObject *res = NULL;

  000a1	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR res$[rsp], 0

; 1143 :     char *p;
; 1144 :     Py_ssize_t seqlen = 0;

  000aa	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR seqlen$[rsp], 0

; 1145 :     size_t sz = 0;

  000b3	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR sz$[rsp], 0

; 1146 :     Py_ssize_t i;
; 1147 :     PyObject *seq, *item;
; 1148 : 
; 1149 :     seq = PySequence_Fast(orig, "");

  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000c3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR orig$[rsp]
  000cb	e8 00 00 00 00	 call	 PySequence_Fast
  000d0	48 89 44 24 48	 mov	 QWORD PTR seq$[rsp], rax

; 1150 :     if (seq == NULL) {

  000d5	48 83 7c 24 48
	00		 cmp	 QWORD PTR seq$[rsp], 0
  000db	75 07		 jne	 SHORT $LN34@bytes_join

; 1151 :         return NULL;

  000dd	33 c0		 xor	 eax, eax
  000df	e9 df 05 00 00	 jmp	 $LN35@bytes_join
$LN34@bytes_join:

; 1152 :     }
; 1153 : 
; 1154 :     seqlen = PySequence_Size(seq);

  000e4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seq$[rsp]
  000e9	e8 00 00 00 00	 call	 PySequence_Size
  000ee	48 89 44 24 40	 mov	 QWORD PTR seqlen$[rsp], rax

; 1155 :     if (seqlen == 0) {

  000f3	48 83 7c 24 40
	00		 cmp	 QWORD PTR seqlen$[rsp], 0
  000f9	75 1b		 jne	 SHORT $LN33@bytes_join

; 1156 :         Py_DECREF(seq);

  000fb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seq$[rsp]
  00100	e8 00 00 00 00	 call	 _Py_DecRef

; 1157 :         return PyBytes_FromString("");

  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0010c	e8 00 00 00 00	 call	 PyBytes_FromString
  00111	e9 ad 05 00 00	 jmp	 $LN35@bytes_join
$LN33@bytes_join:

; 1158 :     }
; 1159 :     if (seqlen == 1) {

  00116	48 83 7c 24 40
	01		 cmp	 QWORD PTR seqlen$[rsp], 1
  0011c	75 7c		 jne	 SHORT $LN32@bytes_join

; 1160 :         item = PySequence_Fast_GET_ITEM(seq, 0);

  0011e	48 8b 44 24 48	 mov	 rax, QWORD PTR seq$[rsp]
  00123	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00127	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0012d	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00132	85 c0		 test	 eax, eax
  00134	74 16		 je	 SHORT $LN39@bytes_join
  00136	48 8b 44 24 48	 mov	 rax, QWORD PTR seq$[rsp]
  0013b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0013f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00142	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  0014a	eb 11		 jmp	 SHORT $LN40@bytes_join
$LN39@bytes_join:
  0014c	48 8b 44 24 48	 mov	 rax, QWORD PTR seq$[rsp]
  00151	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00155	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
$LN40@bytes_join:
  0015d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv133[rsp]
  00165	48 89 44 24 58	 mov	 QWORD PTR item$[rsp], rax

; 1161 :         if (PyBytes_CheckExact(item)) {

  0016a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00171	48 8b 4c 24 58	 mov	 rcx, QWORD PTR item$[rsp]
  00176	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0017a	75 1e		 jne	 SHORT $LN31@bytes_join

; 1162 :             Py_INCREF(item);

  0017c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR item$[rsp]
  00181	e8 00 00 00 00	 call	 _Py_IncRef

; 1163 :             Py_DECREF(seq);

  00186	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seq$[rsp]
  0018b	e8 00 00 00 00	 call	 _Py_DecRef

; 1164 :             return item;

  00190	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  00195	e9 29 05 00 00	 jmp	 $LN35@bytes_join
$LN31@bytes_join:
$LN32@bytes_join:

; 1165 :         }
; 1166 :     }
; 1167 : 
; 1168 :     /* There are at least two things to join, or else we have a subclass
; 1169 :      * of the builtin types in the sequence.
; 1170 :      * Do a pre-pass to figure out the total amount of space we'll
; 1171 :      * need (sz), and see whether all argument are bytes.
; 1172 :      */
; 1173 :     /* XXX Shouldn't we use _getbuffer() on these items instead? */
; 1174 :     for (i = 0; i < seqlen; i++) {

  0019a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001a3	eb 0d		 jmp	 SHORT $LN30@bytes_join
$LN29@bytes_join:
  001a5	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  001aa	48 ff c0	 inc	 rax
  001ad	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN30@bytes_join:
  001b2	48 8b 44 24 40	 mov	 rax, QWORD PTR seqlen$[rsp]
  001b7	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  001bc	0f 8d 57 01 00
	00		 jge	 $LN28@bytes_join

; 1175 :         const size_t old_sz = sz;

  001c2	48 8b 44 24 60	 mov	 rax, QWORD PTR sz$[rsp]
  001c7	48 89 44 24 68	 mov	 QWORD PTR old_sz$22738[rsp], rax

; 1176 :         item = PySequence_Fast_GET_ITEM(seq, i);

  001cc	48 8b 44 24 48	 mov	 rax, QWORD PTR seq$[rsp]
  001d1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001d5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001db	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  001e0	85 c0		 test	 eax, eax
  001e2	74 1c		 je	 SHORT $LN41@bytes_join
  001e4	48 8b 44 24 48	 mov	 rax, QWORD PTR seq$[rsp]
  001e9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  001f2	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  001f6	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  001fe	eb 17		 jmp	 SHORT $LN42@bytes_join
$LN41@bytes_join:
  00200	48 8b 44 24 48	 mov	 rax, QWORD PTR seq$[rsp]
  00205	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0020a	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  0020f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
$LN42@bytes_join:
  00217	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv150[rsp]
  0021f	48 89 44 24 58	 mov	 QWORD PTR item$[rsp], rax

; 1177 :         if (!PyBytes_Check(item) && !PyByteArray_Check(item)) {

  00224	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  00229	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0022d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00233	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00238	85 c0		 test	 eax, eax
  0023a	75 61		 jne	 SHORT $LN27@bytes_join
  0023c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00243	48 8b 4c 24 58	 mov	 rcx, QWORD PTR item$[rsp]
  00248	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0024c	74 4f		 je	 SHORT $LN27@bytes_join
  0024e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00255	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  0025a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0025e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00263	85 c0		 test	 eax, eax
  00265	75 36		 jne	 SHORT $LN27@bytes_join

; 1178 :             PyErr_Format(PyExc_TypeError,
; 1179 :                          "sequence item %zd: expected bytes,"
; 1180 :                          " %.80s found",
; 1181 :                          i, Py_TYPE(item)->tp_name);

  00267	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  0026c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00270	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00274	4c 8b 44 24 30	 mov	 r8, QWORD PTR i$[rsp]
  00279	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@BJLDFOBC@sequence?5item?5?$CFzd?3?5expected?5byte@
  00280	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00287	e8 00 00 00 00	 call	 PyErr_Format

; 1182 :             Py_DECREF(seq);

  0028c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seq$[rsp]
  00291	e8 00 00 00 00	 call	 _Py_DecRef

; 1183 :             return NULL;

  00296	33 c0		 xor	 eax, eax
  00298	e9 26 04 00 00	 jmp	 $LN35@bytes_join
$LN27@bytes_join:

; 1184 :         }
; 1185 :         sz += Py_SIZE(item);

  0029d	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  002a2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sz$[rsp]
  002ab	48 03 c8	 add	 rcx, rax
  002ae	48 8b c1	 mov	 rax, rcx
  002b1	48 89 44 24 60	 mov	 QWORD PTR sz$[rsp], rax

; 1186 :         if (i != 0)

  002b6	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  002bc	74 15		 je	 SHORT $LN26@bytes_join

; 1187 :             sz += seplen;

  002be	48 8b 44 24 38	 mov	 rax, QWORD PTR seplen$[rsp]
  002c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sz$[rsp]
  002c8	48 03 c8	 add	 rcx, rax
  002cb	48 8b c1	 mov	 rax, rcx
  002ce	48 89 44 24 60	 mov	 QWORD PTR sz$[rsp], rax
$LN26@bytes_join:

; 1188 :         if (sz < old_sz || sz > PY_SSIZE_T_MAX) {

  002d3	48 8b 44 24 68	 mov	 rax, QWORD PTR old_sz$22738[rsp]
  002d8	48 39 44 24 60	 cmp	 QWORD PTR sz$[rsp], rax
  002dd	72 11		 jb	 SHORT $LN24@bytes_join
  002df	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  002e9	48 39 44 24 60	 cmp	 QWORD PTR sz$[rsp], rax
  002ee	76 24		 jbe	 SHORT $LN25@bytes_join
$LN24@bytes_join:

; 1189 :             PyErr_SetString(PyExc_OverflowError,
; 1190 :                 "join() result is too long for bytes");

  002f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MJLEPPKI@join?$CI?$CJ?5result?5is?5too?5long?5for?5by@
  002f7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  002fe	e8 00 00 00 00	 call	 PyErr_SetString

; 1191 :             Py_DECREF(seq);

  00303	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seq$[rsp]
  00308	e8 00 00 00 00	 call	 _Py_DecRef

; 1192 :             return NULL;

  0030d	33 c0		 xor	 eax, eax
  0030f	e9 af 03 00 00	 jmp	 $LN35@bytes_join
$LN25@bytes_join:

; 1193 :         }
; 1194 :     }

  00314	e9 8c fe ff ff	 jmp	 $LN29@bytes_join
$LN28@bytes_join:

; 1195 : 
; 1196 :     /* Allocate result space. */
; 1197 :     res = PyBytes_FromStringAndSize((char*)NULL, sz);

  00319	48 8b 54 24 60	 mov	 rdx, QWORD PTR sz$[rsp]
  0031e	33 c9		 xor	 ecx, ecx
  00320	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00325	48 89 44 24 28	 mov	 QWORD PTR res$[rsp], rax

; 1198 :     if (res == NULL) {

  0032a	48 83 7c 24 28
	00		 cmp	 QWORD PTR res$[rsp], 0
  00330	75 11		 jne	 SHORT $LN23@bytes_join

; 1199 :         Py_DECREF(seq);

  00332	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seq$[rsp]
  00337	e8 00 00 00 00	 call	 _Py_DecRef

; 1200 :         return NULL;

  0033c	33 c0		 xor	 eax, eax
  0033e	e9 80 03 00 00	 jmp	 $LN35@bytes_join
$LN23@bytes_join:

; 1201 :     }
; 1202 : 
; 1203 :     /* Catenate everything. */
; 1204 :     /* I'm not worried about a PyByteArray item growing because there's
; 1205 :        nowhere in this function where we release the GIL. */
; 1206 :     p = PyBytes_AS_STRING(res);

  00343	48 8b 44 24 28	 mov	 rax, QWORD PTR res$[rsp]
  00348	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0034c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00352	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00357	85 c0		 test	 eax, eax
  00359	75 1c		 jne	 SHORT $LN43@bytes_join
  0035b	41 b8 b6 04 00
	00		 mov	 r8d, 1206		; 000004b6H
  00361	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00368	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@OADLJEAH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  0036f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00375	33 c0		 xor	 eax, eax
$LN43@bytes_join:
  00377	48 8b 44 24 28	 mov	 rax, QWORD PTR res$[rsp]
  0037c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00380	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1207 :     for (i = 0; i < seqlen; ++i) {

  00385	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0038e	eb 0d		 jmp	 SHORT $LN22@bytes_join
$LN21@bytes_join:
  00390	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00395	48 ff c0	 inc	 rax
  00398	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN22@bytes_join:
  0039d	48 8b 44 24 40	 mov	 rax, QWORD PTR seqlen$[rsp]
  003a2	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  003a7	0f 8d 07 03 00
	00		 jge	 $LN20@bytes_join

; 1208 :         size_t n;
; 1209 :         char *q;
; 1210 :         if (i) {

  003ad	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  003b3	0f 84 d6 00 00
	00		 je	 $LN19@bytes_join
$LN18@bytes_join:

; 1211 :             Py_MEMCPY(p, sep, seplen);

  003b9	48 8b 44 24 38	 mov	 rax, QWORD PTR seplen$[rsp]
  003be	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR n_$22779[rsp], rax
  003c6	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003cb	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR t_$22780[rsp], rax
  003d3	48 8b 44 24 50	 mov	 rax, QWORD PTR sep$[rsp]
  003d8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s_$22782[rsp], rax
  003e0	48 83 bc 24 98
	00 00 00 10	 cmp	 QWORD PTR n_$22779[rsp], 16
  003e9	72 1f		 jb	 SHORT $LN15@bytes_join
  003eb	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR n_$22779[rsp]
  003f3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s_$22782[rsp]
  003fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t_$22780[rsp]
  00403	e8 00 00 00 00	 call	 memcpy
  00408	eb 66		 jmp	 SHORT $LN14@bytes_join
$LN15@bytes_join:
  0040a	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$22778[rsp], 0
  00416	eb 13		 jmp	 SHORT $LN13@bytes_join
$LN12@bytes_join:
  00418	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i_$22778[rsp]
  00420	48 ff c0	 inc	 rax
  00423	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR i_$22778[rsp], rax
$LN13@bytes_join:
  0042b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n_$22779[rsp]
  00433	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR i_$22778[rsp], rax
  0043b	73 33		 jae	 SHORT $LN11@bytes_join
  0043d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i_$22778[rsp]
  00445	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t_$22780[rsp]
  0044d	48 03 c8	 add	 rcx, rax
  00450	48 8b c1	 mov	 rax, rcx
  00453	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR i_$22778[rsp]
  0045b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s_$22782[rsp]
  00463	48 03 d1	 add	 rdx, rcx
  00466	48 8b ca	 mov	 rcx, rdx
  00469	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0046c	88 08		 mov	 BYTE PTR [rax], cl
  0046e	eb a8		 jmp	 SHORT $LN12@bytes_join
$LN11@bytes_join:
$LN14@bytes_join:
  00470	33 c0		 xor	 eax, eax
  00472	85 c0		 test	 eax, eax
  00474	0f 85 3f ff ff
	ff		 jne	 $LN18@bytes_join

; 1212 :             p += seplen;

  0047a	48 8b 44 24 38	 mov	 rax, QWORD PTR seplen$[rsp]
  0047f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00484	48 03 c8	 add	 rcx, rax
  00487	48 8b c1	 mov	 rax, rcx
  0048a	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN19@bytes_join:

; 1213 :         }
; 1214 :         item = PySequence_Fast_GET_ITEM(seq, i);

  0048f	48 8b 44 24 48	 mov	 rax, QWORD PTR seq$[rsp]
  00494	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00498	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0049e	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  004a3	85 c0		 test	 eax, eax
  004a5	74 1c		 je	 SHORT $LN44@bytes_join
  004a7	48 8b 44 24 48	 mov	 rax, QWORD PTR seq$[rsp]
  004ac	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  004b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  004b5	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  004b9	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
  004c1	eb 17		 jmp	 SHORT $LN45@bytes_join
$LN44@bytes_join:
  004c3	48 8b 44 24 48	 mov	 rax, QWORD PTR seq$[rsp]
  004c8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  004cd	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  004d2	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
$LN45@bytes_join:
  004da	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv215[rsp]
  004e2	48 89 44 24 58	 mov	 QWORD PTR item$[rsp], rax

; 1215 :         n = Py_SIZE(item);

  004e7	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  004ec	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  004f0	48 89 44 24 70	 mov	 QWORD PTR n$22772[rsp], rax

; 1216 :         if (PyBytes_Check(item))

  004f5	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  004fa	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  004fe	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00504	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00509	85 c0		 test	 eax, eax
  0050b	74 47		 je	 SHORT $LN10@bytes_join

; 1217 :             q = PyBytes_AS_STRING(item);

  0050d	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  00512	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00516	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0051c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00521	85 c0		 test	 eax, eax
  00523	75 1c		 jne	 SHORT $LN46@bytes_join
  00525	41 b8 c1 04 00
	00		 mov	 r8d, 1217		; 000004c1H
  0052b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00532	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@POOCBCOH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@
  00539	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0053f	33 c0		 xor	 eax, eax
$LN46@bytes_join:
  00541	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  00546	48 83 c0 78	 add	 rax, 120		; 00000078H
  0054a	48 89 44 24 78	 mov	 QWORD PTR q$22773[rsp], rax

; 1218 :         else

  0054f	e9 85 00 00 00	 jmp	 $LN9@bytes_join
$LN10@bytes_join:

; 1219 :             q = PyByteArray_AS_STRING(item);

  00554	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0055b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR item$[rsp]
  00560	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00564	74 35		 je	 SHORT $LN47@bytes_join
  00566	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0056d	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  00572	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00576	e8 00 00 00 00	 call	 PyType_IsSubtype
  0057b	85 c0		 test	 eax, eax
  0057d	75 1c		 jne	 SHORT $LN47@bytes_join
  0057f	41 b8 c3 04 00
	00		 mov	 r8d, 1219		; 000004c3H
  00585	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0058c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@GHGMKAJM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@
  00593	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00599	33 c0		 xor	 eax, eax
$LN47@bytes_join:
  0059b	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  005a0	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  005a5	74 16		 je	 SHORT $LN48@bytes_join
  005a7	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  005ac	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  005b3	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv244[rsp], rax
  005bb	eb 0f		 jmp	 SHORT $LN49@bytes_join
$LN48@bytes_join:
  005bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  005c4	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv244[rsp], rax
$LN49@bytes_join:
  005cc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv244[rsp]
  005d4	48 89 44 24 78	 mov	 QWORD PTR q$22773[rsp], rax
$LN9@bytes_join:
$LN8@bytes_join:

; 1220 :         Py_MEMCPY(p, q, n);

  005d9	48 8b 44 24 70	 mov	 rax, QWORD PTR n$22772[rsp]
  005de	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR n_$22810[rsp], rax
  005e6	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  005eb	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR t_$22811[rsp], rax
  005f3	48 8b 44 24 78	 mov	 rax, QWORD PTR q$22773[rsp]
  005f8	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s_$22813[rsp], rax
  00600	48 83 bc 24 b8
	00 00 00 10	 cmp	 QWORD PTR n_$22810[rsp], 16
  00609	72 1f		 jb	 SHORT $LN5@bytes_join
  0060b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR n_$22810[rsp]
  00613	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR s_$22813[rsp]
  0061b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR t_$22811[rsp]
  00623	e8 00 00 00 00	 call	 memcpy
  00628	eb 66		 jmp	 SHORT $LN4@bytes_join
$LN5@bytes_join:
  0062a	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$22809[rsp], 0
  00636	eb 13		 jmp	 SHORT $LN3@bytes_join
$LN2@bytes_join:
  00638	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i_$22809[rsp]
  00640	48 ff c0	 inc	 rax
  00643	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR i_$22809[rsp], rax
$LN3@bytes_join:
  0064b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n_$22810[rsp]
  00653	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR i_$22809[rsp], rax
  0065b	73 33		 jae	 SHORT $LN1@bytes_join
  0065d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i_$22809[rsp]
  00665	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR t_$22811[rsp]
  0066d	48 03 c8	 add	 rcx, rax
  00670	48 8b c1	 mov	 rax, rcx
  00673	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR i_$22809[rsp]
  0067b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR s_$22813[rsp]
  00683	48 03 d1	 add	 rdx, rcx
  00686	48 8b ca	 mov	 rcx, rdx
  00689	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0068c	88 08		 mov	 BYTE PTR [rax], cl
  0068e	eb a8		 jmp	 SHORT $LN2@bytes_join
$LN1@bytes_join:
$LN4@bytes_join:
  00690	33 c0		 xor	 eax, eax
  00692	85 c0		 test	 eax, eax
  00694	0f 85 3f ff ff
	ff		 jne	 $LN8@bytes_join

; 1221 :         p += n;

  0069a	48 8b 44 24 70	 mov	 rax, QWORD PTR n$22772[rsp]
  0069f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  006a4	48 03 c8	 add	 rcx, rax
  006a7	48 8b c1	 mov	 rax, rcx
  006aa	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1222 :     }

  006af	e9 dc fc ff ff	 jmp	 $LN21@bytes_join
$LN20@bytes_join:

; 1223 : 
; 1224 :     Py_DECREF(seq);

  006b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seq$[rsp]
  006b9	e8 00 00 00 00	 call	 _Py_DecRef

; 1225 :     return res;

  006be	48 8b 44 24 28	 mov	 rax, QWORD PTR res$[rsp]
$LN35@bytes_join:

; 1226 : }

  006c3	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  006ca	c3		 ret	 0
bytes_join ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@HGNCLDBA@?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EE@OIJPPCHH@?$AAs?$AAe?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp@ ; `string'
PUBLIC	_PyBytes_Join
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyBytes_Join DD imagerel $LN6
	DD	imagerel $LN6+130
	DD	imagerel $unwind$_PyBytes_Join
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyBytes_Join DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_1BE@HGNCLDBA@?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@HGNCLDBA@?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'x'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@OIJPPCHH@?$AAs?$AAe?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp@
CONST	SEGMENT
??_C@_1EE@OIJPPCHH@?$AAs?$AAe?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp@ DB 's'
	DB	00H, 'e', 00H, 'p', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'P', 00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H
	DB	'e', 00H, 's', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 's', 00H, 'e', 00H, 'p', 00H, ')', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyBytes_Join
_TEXT	SEGMENT
sep$ = 48
x$ = 56
_PyBytes_Join PROC					; COMDAT

; 1230 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1231 :     assert(sep != NULL && PyBytes_Check(sep));

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR sep$[rsp], 0
  00014	74 18		 je	 SHORT $LN3@PyBytes_Jo
  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR sep$[rsp]
  0001b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00025	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0002a	85 c0		 test	 eax, eax
  0002c	75 1c		 jne	 SHORT $LN4@PyBytes_Jo
$LN3@PyBytes_Jo:
  0002e	41 b8 cf 04 00
	00		 mov	 r8d, 1231		; 000004cfH
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@OIJPPCHH@?$AAs?$AAe?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAp@
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00048	33 c0		 xor	 eax, eax
$LN4@PyBytes_Jo:

; 1232 :     assert(x != NULL);

  0004a	48 83 7c 24 38
	00		 cmp	 QWORD PTR x$[rsp], 0
  00050	75 1c		 jne	 SHORT $LN5@PyBytes_Jo
  00052	41 b8 d0 04 00
	00		 mov	 r8d, 1232		; 000004d0H
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@HGNCLDBA@?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006c	33 c0		 xor	 eax, eax
$LN5@PyBytes_Jo:

; 1233 :     return bytes_join(sep, x);

  0006e	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00073	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sep$[rsp]
  00078	e8 00 00 00 00	 call	 bytes_join

; 1234 : }

  0007d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00081	c3		 ret	 0
_PyBytes_Join ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_find DD imagerel bytes_find
	DD	imagerel bytes_find+67
	DD	imagerel $unwind$bytes_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_find DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_find
_TEXT	SEGMENT
result$ = 32
self$ = 64
args$ = 72
bytes_find PROC						; COMDAT

; 1305 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1306 :     Py_ssize_t result = bytes_find_internal(self, args, +1);

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	e8 00 00 00 00	 call	 bytes_find_internal
  00023	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1307 :     if (result == -2)

  00028	48 83 7c 24 20
	fe		 cmp	 QWORD PTR result$[rsp], -2
  0002e	75 04		 jne	 SHORT $LN1@bytes_find

; 1308 :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 0a		 jmp	 SHORT $LN2@bytes_find
$LN1@bytes_find:

; 1309 :     return PyLong_FromSsize_t(result);

  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00039	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN2@bytes_find:

; 1310 : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
bytes_find ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_find_internal DD imagerel bytes_find_internal
	DD	imagerel bytes_find_internal+615
	DD	imagerel $unwind$bytes_find_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_find_internal DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@
CONST	SEGMENT
??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@ DB 'find/rfind/index/r'
	DB	'index', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_find_internal
_TEXT	SEGMENT
res$ = 48
end$ = 56
start$ = 64
sub_len$ = 72
sub$ = 80
subbuf$ = 96
byte$ = 176
subobj$ = 184
self$ = 208
args$ = 216
dir$ = 224
bytes_find_internal PROC				; COMDAT

; 1253 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1254 :     PyObject *subobj;
; 1255 :     char byte;
; 1256 :     Py_buffer subbuf;
; 1257 :     const char *sub;
; 1258 :     Py_ssize_t sub_len;
; 1259 :     Py_ssize_t start=0, end=PY_SSIZE_T_MAX;

  00016	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  0001f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00029	48 89 44 24 38	 mov	 QWORD PTR end$[rsp], rax

; 1260 :     Py_ssize_t res;
; 1261 : 
; 1262 :     if (!stringlib_parse_args_finds_byte("find/rfind/index/rindex",
; 1263 :                                          args, &subobj, &byte, &start, &end))

  0002e	48 8d 44 24 38	 lea	 rax, QWORD PTR end$[rsp]
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 44 24 40	 lea	 rax, QWORD PTR start$[rsp]
  0003d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00042	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR byte$[rsp]
  0004a	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR subobj$[rsp]
  00052	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR args$[rsp]
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@
  00061	e8 00 00 00 00	 call	 stringlib_parse_args_finds_byte
  00066	85 c0		 test	 eax, eax
  00068	75 0c		 jne	 SHORT $LN7@bytes_find@2

; 1264 :         return -2;

  0006a	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00071	e9 e9 01 00 00	 jmp	 $LN8@bytes_find@2
$LN7@bytes_find@2:

; 1265 : 
; 1266 :     if (subobj) {

  00076	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR subobj$[rsp], 0
  0007f	74 39		 je	 SHORT $LN6@bytes_find@2

; 1267 :         if (_getbuffer(subobj, &subbuf) < 0)

  00081	48 8d 54 24 60	 lea	 rdx, QWORD PTR subbuf$[rsp]
  00086	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR subobj$[rsp]
  0008e	e8 00 00 00 00	 call	 _getbuffer
  00093	48 85 c0	 test	 rax, rax
  00096	7d 0c		 jge	 SHORT $LN5@bytes_find@2

; 1268 :             return -2;

  00098	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  0009f	e9 bb 01 00 00	 jmp	 $LN8@bytes_find@2
$LN5@bytes_find@2:

; 1269 : 
; 1270 :         sub = subbuf.buf;

  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR subbuf$[rsp]
  000a9	48 89 44 24 50	 mov	 QWORD PTR sub$[rsp], rax

; 1271 :         sub_len = subbuf.len;

  000ae	48 8b 44 24 70	 mov	 rax, QWORD PTR subbuf$[rsp+16]
  000b3	48 89 44 24 48	 mov	 QWORD PTR sub_len$[rsp], rax

; 1272 :     }
; 1273 :     else {

  000b8	eb 16		 jmp	 SHORT $LN4@bytes_find@2
$LN6@bytes_find@2:

; 1274 :         sub = &byte;

  000ba	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR byte$[rsp]
  000c2	48 89 44 24 50	 mov	 QWORD PTR sub$[rsp], rax

; 1275 :         sub_len = 1;

  000c7	48 c7 44 24 48
	01 00 00 00	 mov	 QWORD PTR sub_len$[rsp], 1
$LN4@bytes_find@2:

; 1276 :     }
; 1277 : 
; 1278 :     if (dir > 0)

  000d0	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR dir$[rsp], 0
  000d8	0f 8e b6 00 00
	00		 jle	 $LN3@bytes_find@2

; 1279 :         res = stringlib_find_slice(
; 1280 :             PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),
; 1281 :             sub, sub_len, start, end);

  000de	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000e6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ea	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000f5	85 c0		 test	 eax, eax
  000f7	75 1c		 jne	 SHORT $LN10@bytes_find@2
  000f9	41 b8 00 05 00
	00		 mov	 r8d, 1280		; 00000500H
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00113	33 c0		 xor	 eax, eax
$LN10@bytes_find@2:
  00115	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0011d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00121	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00127	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0012c	85 c0		 test	 eax, eax
  0012e	75 1c		 jne	 SHORT $LN11@bytes_find@2
  00130	41 b8 00 05 00
	00		 mov	 r8d, 1280		; 00000500H
  00136	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0014a	33 c0		 xor	 eax, eax
$LN11@bytes_find@2:
  0014c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00154	48 83 c0 78	 add	 rax, 120		; 00000078H
  00158	48 8b 4c 24 38	 mov	 rcx, QWORD PTR end$[rsp]
  0015d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00162	48 8b 4c 24 40	 mov	 rcx, QWORD PTR start$[rsp]
  00167	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0016c	4c 8b 4c 24 48	 mov	 r9, QWORD PTR sub_len$[rsp]
  00171	4c 8b 44 24 50	 mov	 r8, QWORD PTR sub$[rsp]
  00176	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0017e	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00182	48 8b c8	 mov	 rcx, rax
  00185	e8 00 00 00 00	 call	 stringlib_find_slice
  0018a	48 89 44 24 30	 mov	 QWORD PTR res$[rsp], rax

; 1282 :     else

  0018f	e9 b1 00 00 00	 jmp	 $LN2@bytes_find@2
$LN3@bytes_find@2:

; 1283 :         res = stringlib_rfind_slice(
; 1284 :             PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),
; 1285 :             sub, sub_len, start, end);

  00194	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0019c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001a0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001a6	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001ab	85 c0		 test	 eax, eax
  001ad	75 1c		 jne	 SHORT $LN12@bytes_find@2
  001af	41 b8 04 05 00
	00		 mov	 r8d, 1284		; 00000504H
  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001c9	33 c0		 xor	 eax, eax
$LN12@bytes_find@2:
  001cb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001d3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001d7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001dd	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001e2	85 c0		 test	 eax, eax
  001e4	75 1c		 jne	 SHORT $LN13@bytes_find@2
  001e6	41 b8 04 05 00
	00		 mov	 r8d, 1284		; 00000504H
  001ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00200	33 c0		 xor	 eax, eax
$LN13@bytes_find@2:
  00202	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0020a	48 83 c0 78	 add	 rax, 120		; 00000078H
  0020e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR end$[rsp]
  00213	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00218	48 8b 4c 24 40	 mov	 rcx, QWORD PTR start$[rsp]
  0021d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00222	4c 8b 4c 24 48	 mov	 r9, QWORD PTR sub_len$[rsp]
  00227	4c 8b 44 24 50	 mov	 r8, QWORD PTR sub$[rsp]
  0022c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00234	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00238	48 8b c8	 mov	 rcx, rax
  0023b	e8 00 00 00 00	 call	 stringlib_rfind_slice
  00240	48 89 44 24 30	 mov	 QWORD PTR res$[rsp], rax
$LN2@bytes_find@2:

; 1286 : 
; 1287 :     if (subobj)

  00245	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR subobj$[rsp], 0
  0024e	74 0a		 je	 SHORT $LN1@bytes_find@2

; 1288 :         PyBuffer_Release(&subbuf);

  00250	48 8d 4c 24 60	 lea	 rcx, QWORD PTR subbuf$[rsp]
  00255	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytes_find@2:

; 1289 : 
; 1290 :     return res;

  0025a	48 8b 44 24 30	 mov	 rax, QWORD PTR res$[rsp]
$LN8@bytes_find@2:

; 1291 : }

  0025f	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00266	c3		 ret	 0
bytes_find_internal ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$stringlib_find_slice DD imagerel stringlib_find_slice
	DD	imagerel stringlib_find_slice+205
	DD	imagerel $unwind$stringlib_find_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_find_slice DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_find_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
stringlib_find_slice PROC				; COMDAT

; 66   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 67   :     ADJUST_INDICES(start, end, str_len);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0001d	48 39 44 24 68	 cmp	 QWORD PTR end$[rsp], rax
  00022	7e 0c		 jle	 SHORT $LN6@stringlib_@28
  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  00029	48 89 44 24 68	 mov	 QWORD PTR end$[rsp], rax
  0002e	eb 2e		 jmp	 SHORT $LN5@stringlib_@28
$LN6@stringlib_@28:
  00030	48 83 7c 24 68
	00		 cmp	 QWORD PTR end$[rsp], 0
  00036	7d 26		 jge	 SHORT $LN4@stringlib_@28
  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0003d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR end$[rsp]
  00042	48 03 c8	 add	 rcx, rax
  00045	48 8b c1	 mov	 rax, rcx
  00048	48 89 44 24 68	 mov	 QWORD PTR end$[rsp], rax
  0004d	48 83 7c 24 68
	00		 cmp	 QWORD PTR end$[rsp], 0
  00053	7d 09		 jge	 SHORT $LN3@stringlib_@28
  00055	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR end$[rsp], 0
$LN3@stringlib_@28:
$LN4@stringlib_@28:
$LN5@stringlib_@28:
  0005e	48 83 7c 24 60
	00		 cmp	 QWORD PTR start$[rsp], 0
  00064	7d 26		 jge	 SHORT $LN2@stringlib_@28
  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0006b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax
  0007b	48 83 7c 24 60
	00		 cmp	 QWORD PTR start$[rsp], 0
  00081	7d 09		 jge	 SHORT $LN1@stringlib_@28
  00083	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
$LN1@stringlib_@28:
$LN2@stringlib_@28:

; 68   :     return STRINGLIB(find)(str + start, end - start, sub, sub_len, start);

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00091	48 8b 4c 24 68	 mov	 rcx, QWORD PTR end$[rsp]
  00096	48 2b c8	 sub	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  000a1	48 8b 54 24 40	 mov	 rdx, QWORD PTR str$[rsp]
  000a6	48 03 d1	 add	 rdx, rcx
  000a9	48 8b ca	 mov	 rcx, rdx
  000ac	48 8b 54 24 60	 mov	 rdx, QWORD PTR start$[rsp]
  000b1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000b6	4c 8b 4c 24 58	 mov	 r9, QWORD PTR sub_len$[rsp]
  000bb	4c 8b 44 24 50	 mov	 r8, QWORD PTR sub$[rsp]
  000c0	48 8b d0	 mov	 rdx, rax
  000c3	e8 00 00 00 00	 call	 stringlib_find

; 69   : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
stringlib_find_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rfind_slice DD imagerel stringlib_rfind_slice
	DD	imagerel stringlib_rfind_slice+205
	DD	imagerel $unwind$stringlib_rfind_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rfind_slice DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rfind_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
stringlib_rfind_slice PROC				; COMDAT

; 75   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 76   :     ADJUST_INDICES(start, end, str_len);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0001d	48 39 44 24 68	 cmp	 QWORD PTR end$[rsp], rax
  00022	7e 0c		 jle	 SHORT $LN6@stringlib_@29
  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  00029	48 89 44 24 68	 mov	 QWORD PTR end$[rsp], rax
  0002e	eb 2e		 jmp	 SHORT $LN5@stringlib_@29
$LN6@stringlib_@29:
  00030	48 83 7c 24 68
	00		 cmp	 QWORD PTR end$[rsp], 0
  00036	7d 26		 jge	 SHORT $LN4@stringlib_@29
  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0003d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR end$[rsp]
  00042	48 03 c8	 add	 rcx, rax
  00045	48 8b c1	 mov	 rax, rcx
  00048	48 89 44 24 68	 mov	 QWORD PTR end$[rsp], rax
  0004d	48 83 7c 24 68
	00		 cmp	 QWORD PTR end$[rsp], 0
  00053	7d 09		 jge	 SHORT $LN3@stringlib_@29
  00055	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR end$[rsp], 0
$LN3@stringlib_@29:
$LN4@stringlib_@29:
$LN5@stringlib_@29:
  0005e	48 83 7c 24 60
	00		 cmp	 QWORD PTR start$[rsp], 0
  00064	7d 26		 jge	 SHORT $LN2@stringlib_@29
  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0006b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax
  0007b	48 83 7c 24 60
	00		 cmp	 QWORD PTR start$[rsp], 0
  00081	7d 09		 jge	 SHORT $LN1@stringlib_@29
  00083	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
$LN1@stringlib_@29:
$LN2@stringlib_@29:

; 77   :     return STRINGLIB(rfind)(str + start, end - start, sub, sub_len, start);

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00091	48 8b 4c 24 68	 mov	 rcx, QWORD PTR end$[rsp]
  00096	48 2b c8	 sub	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  000a1	48 8b 54 24 40	 mov	 rdx, QWORD PTR str$[rsp]
  000a6	48 03 d1	 add	 rdx, rcx
  000a9	48 8b ca	 mov	 rcx, rdx
  000ac	48 8b 54 24 60	 mov	 rdx, QWORD PTR start$[rsp]
  000b1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000b6	4c 8b 4c 24 58	 mov	 r9, QWORD PTR sub_len$[rsp]
  000bb	4c 8b 44 24 50	 mov	 r8, QWORD PTR sub$[rsp]
  000c0	48 8b d0	 mov	 rdx, rax
  000c3	e8 00 00 00 00	 call	 stringlib_rfind

; 78   : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
stringlib_rfind_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rfind DD imagerel stringlib_rfind
	DD	imagerel stringlib_rfind+153
	DD	imagerel $unwind$stringlib_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rfind DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rfind
_TEXT	SEGMENT
pos$ = 48
str$ = 80
str_len$ = 88
sub$ = 96
sub_len$ = 104
offset$ = 112
stringlib_rfind PROC					; COMDAT

; 31   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 32   :     Py_ssize_t pos;
; 33   : 
; 34   :     if (str_len < 0)

  00018	48 83 7c 24 58
	00		 cmp	 QWORD PTR str_len$[rsp], 0
  0001e	7d 09		 jge	 SHORT $LN3@stringlib_@30

; 35   :         return -1;

  00020	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00027	eb 6b		 jmp	 SHORT $LN4@stringlib_@30
$LN3@stringlib_@30:

; 36   :     if (sub_len == 0)

  00029	48 83 7c 24 68
	00		 cmp	 QWORD PTR sub_len$[rsp], 0
  0002f	75 12		 jne	 SHORT $LN2@stringlib_@30

; 37   :         return str_len + offset;

  00031	48 8b 44 24 70	 mov	 rax, QWORD PTR offset$[rsp]
  00036	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str_len$[rsp]
  0003b	48 03 c8	 add	 rcx, rax
  0003e	48 8b c1	 mov	 rax, rcx
  00041	eb 51		 jmp	 SHORT $LN4@stringlib_@30
$LN2@stringlib_@30:

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

  00043	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  0004b	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  00054	4c 8b 4c 24 68	 mov	 r9, QWORD PTR sub_len$[rsp]
  00059	4c 8b 44 24 60	 mov	 r8, QWORD PTR sub$[rsp]
  0005e	48 8b 54 24 58	 mov	 rdx, QWORD PTR str_len$[rsp]
  00063	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  00068	e8 00 00 00 00	 call	 fastsearch
  0006d	48 89 44 24 30	 mov	 QWORD PTR pos$[rsp], rax

; 40   : 
; 41   :     if (pos >= 0)

  00072	48 83 7c 24 30
	00		 cmp	 QWORD PTR pos$[rsp], 0
  00078	7c 15		 jl	 SHORT $LN1@stringlib_@30

; 42   :         pos += offset;

  0007a	48 8b 44 24 70	 mov	 rax, QWORD PTR offset$[rsp]
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pos$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	48 89 44 24 30	 mov	 QWORD PTR pos$[rsp], rax
$LN1@stringlib_@30:

; 43   : 
; 44   :     return pos;

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR pos$[rsp]
$LN4@stringlib_@30:

; 45   : }

  00094	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00098	c3		 ret	 0
stringlib_rfind ENDP
_TEXT	ENDS
EXTRN	PyErr_GivenExceptionMatches:PROC
EXTRN	PyNumber_Check:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_parse_args_finds_byte DD imagerel stringlib_parse_args_finds_byte
	DD	imagerel stringlib_parse_args_finds_byte+283
	DD	imagerel $unwind$stringlib_parse_args_finds_byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_parse_args_finds_byte DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_parse_args_finds_byte
_TEXT	SEGMENT
tmp_subobj$ = 48
err$ = 56
ival$ = 64
function_name$ = 96
args$ = 104
subobj$ = 112
byte$ = 120
start$ = 128
end$ = 136
stringlib_parse_args_finds_byte PROC			; COMDAT

; 186  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 187  :     PyObject *tmp_subobj;
; 188  :     Py_ssize_t ival;
; 189  :     PyObject *err;
; 190  : 
; 191  :     if(!STRINGLIB(parse_args_finds)(function_name, args, &tmp_subobj,
; 192  :                                     start, end))

  00018	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR end$[rsp]
  00020	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00025	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR start$[rsp]
  0002d	4c 8d 44 24 30	 lea	 r8, QWORD PTR tmp_subobj$[rsp]
  00032	48 8b 54 24 68	 mov	 rdx, QWORD PTR args$[rsp]
  00037	48 8b 4c 24 60	 mov	 rcx, QWORD PTR function_name$[rsp]
  0003c	e8 00 00 00 00	 call	 stringlib_parse_args_finds
  00041	85 c0		 test	 eax, eax
  00043	75 07		 jne	 SHORT $LN6@stringlib_@31

; 193  :         return 0;

  00045	33 c0		 xor	 eax, eax
  00047	e9 ca 00 00 00	 jmp	 $LN7@stringlib_@31
$LN6@stringlib_@31:

; 194  : 
; 195  :     if (!PyNumber_Check(tmp_subobj)) {

  0004c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp_subobj$[rsp]
  00051	e8 00 00 00 00	 call	 PyNumber_Check
  00056	85 c0		 test	 eax, eax
  00058	75 17		 jne	 SHORT $LN5@stringlib_@31

; 196  :         *subobj = tmp_subobj;

  0005a	48 8b 44 24 70	 mov	 rax, QWORD PTR subobj$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp_subobj$[rsp]
  00064	48 89 08	 mov	 QWORD PTR [rax], rcx

; 197  :         return 1;

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	e9 a5 00 00 00	 jmp	 $LN7@stringlib_@31
$LN5@stringlib_@31:

; 198  :     }
; 199  : 
; 200  :     ival = PyNumber_AsSsize_t(tmp_subobj, PyExc_OverflowError);

  00071	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp_subobj$[rsp]
  0007d	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00082	48 89 44 24 40	 mov	 QWORD PTR ival$[rsp], rax

; 201  :     if (ival == -1) {

  00087	48 83 7c 24 40
	ff		 cmp	 QWORD PTR ival$[rsp], -1
  0008d	75 40		 jne	 SHORT $LN4@stringlib_@31

; 202  :         err = PyErr_Occurred();

  0008f	e8 00 00 00 00	 call	 PyErr_Occurred
  00094	48 89 44 24 38	 mov	 QWORD PTR err$[rsp], rax

; 203  :         if (err && !PyErr_GivenExceptionMatches(err, PyExc_OverflowError)) {

  00099	48 83 7c 24 38
	00		 cmp	 QWORD PTR err$[rsp], 0
  0009f	74 2e		 je	 SHORT $LN3@stringlib_@31
  000a1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR err$[rsp]
  000ad	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches
  000b2	85 c0		 test	 eax, eax
  000b4	75 19		 jne	 SHORT $LN3@stringlib_@31

; 204  :             PyErr_Clear();

  000b6	e8 00 00 00 00	 call	 PyErr_Clear

; 205  :             *subobj = tmp_subobj;

  000bb	48 8b 44 24 70	 mov	 rax, QWORD PTR subobj$[rsp]
  000c0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp_subobj$[rsp]
  000c5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 206  :             return 1;

  000c8	b8 01 00 00 00	 mov	 eax, 1
  000cd	eb 47		 jmp	 SHORT $LN7@stringlib_@31
$LN3@stringlib_@31:
$LN4@stringlib_@31:

; 207  :         }
; 208  :     }
; 209  : 
; 210  :     if (ival < 0 || ival > 255) {

  000cf	48 83 7c 24 40
	00		 cmp	 QWORD PTR ival$[rsp], 0
  000d5	7c 0b		 jl	 SHORT $LN1@stringlib_@31
  000d7	48 81 7c 24 40
	ff 00 00 00	 cmp	 QWORD PTR ival$[rsp], 255 ; 000000ffH
  000e0	7e 17		 jle	 SHORT $LN2@stringlib_@31
$LN1@stringlib_@31:

; 211  :         PyErr_SetString(PyExc_ValueError, "byte must be in range(0, 256)");

  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  000e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000f0	e8 00 00 00 00	 call	 PyErr_SetString

; 212  :         return 0;

  000f5	33 c0		 xor	 eax, eax
  000f7	eb 1d		 jmp	 SHORT $LN7@stringlib_@31
$LN2@stringlib_@31:

; 213  :     }
; 214  : 
; 215  :     *subobj = NULL;

  000f9	48 8b 44 24 70	 mov	 rax, QWORD PTR subobj$[rsp]
  000fe	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 216  :     *byte = (char)ival;

  00105	48 8b 44 24 78	 mov	 rax, QWORD PTR byte$[rsp]
  0010a	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ival$[rsp]
  0010f	88 08		 mov	 BYTE PTR [rax], cl

; 217  :     return 1;

  00111	b8 01 00 00 00	 mov	 eax, 1
$LN7@stringlib_@31:

; 218  : }

  00116	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011a	c3		 ret	 0
stringlib_parse_args_finds_byte ENDP
_TEXT	ENDS
PUBLIC	??_C@_05BBAJLHME@O?$HMOO?3?$AA@			; `string'
EXTRN	_PyEval_SliceIndex:PROC
EXTRN	__imp_strncpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_parse_args_finds DD imagerel stringlib_parse_args_finds
	DD	imagerel stringlib_parse_args_finds+389
	DD	imagerel $unwind$stringlib_parse_args_finds
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_parse_args_finds DD 041d01H
	DD	015011dH
	DD	060157016H
xdata	ENDS
;	COMDAT ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
CONST	SEGMENT
??_C@_05BBAJLHME@O?$HMOO?3?$AA@ DB 'O|OO:', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_parse_args_finds
_TEXT	SEGMENT
len$ = 48
obj_end$ = 56
tmp_end$ = 64
tmp_subobj$ = 72
format$ = 80
obj_start$ = 136
tmp_start$ = 144
function_name$ = 192
args$ = 200
subobj$ = 208
start$ = 216
end$ = 224
stringlib_parse_args_finds PROC				; COMDAT

; 108  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 109  :     PyObject *tmp_subobj;
; 110  :     Py_ssize_t tmp_start = 0;

  0001d	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tmp_start$[rsp], 0

; 111  :     Py_ssize_t tmp_end = PY_SSIZE_T_MAX;

  00029	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00033	48 89 44 24 40	 mov	 QWORD PTR tmp_end$[rsp], rax

; 112  :     PyObject *obj_start=Py_None, *obj_end=Py_None;

  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0003f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR obj_start$[rsp], rax
  00047	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0004e	48 89 44 24 38	 mov	 QWORD PTR obj_end$[rsp], rax

; 113  :     char format[FORMAT_BUFFER_SIZE] = "O|OO:";

  00053	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp]
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  0005f	48 8b f8	 mov	 rdi, rax
  00062	48 8b f1	 mov	 rsi, rcx
  00065	b9 06 00 00 00	 mov	 ecx, 6
  0006a	f3 a4		 rep movsb
  0006c	48 8d 44 24 56	 lea	 rax, QWORD PTR format$[rsp+6]
  00071	48 8b f8	 mov	 rdi, rax
  00074	33 c0		 xor	 eax, eax
  00076	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0007b	f3 aa		 rep stosb

; 114  :     size_t len = strlen(format);

  0007d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR format$[rsp]
  00082	e8 00 00 00 00	 call	 strlen
  00087	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 115  : 
; 116  :     strncpy(format + len, function_name, FORMAT_BUFFER_SIZE - len - 1);

  0008c	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  00091	48 2b 44 24 30	 sub	 rax, QWORD PTR len$[rsp]
  00096	48 ff c8	 dec	 rax
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR len$[rsp]
  0009e	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR format$[rsp+rcx]
  000a3	4c 8b c0	 mov	 r8, rax
  000a6	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR function_name$[rsp]
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 117  :     format[FORMAT_BUFFER_SIZE - 1] = '\0';

  000b4	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR format$[rsp+49], 0

; 118  : 
; 119  :     if (!PyArg_ParseTuple(args, format, &tmp_subobj, &obj_start, &obj_end))

  000bc	48 8d 44 24 38	 lea	 rax, QWORD PTR obj_end$[rsp]
  000c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c6	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR obj_start$[rsp]
  000ce	4c 8d 44 24 48	 lea	 r8, QWORD PTR tmp_subobj$[rsp]
  000d3	48 8d 54 24 50	 lea	 rdx, QWORD PTR format$[rsp]
  000d8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000e0	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000e5	85 c0		 test	 eax, eax
  000e7	75 07		 jne	 SHORT $LN5@stringlib_@32

; 120  :         return 0;

  000e9	33 c0		 xor	 eax, eax
  000eb	e9 8b 00 00 00	 jmp	 $LN6@stringlib_@32
$LN5@stringlib_@32:

; 121  : 
; 122  :     /* To support None in "start" and "end" arguments, meaning
; 123  :        the same as if they were not passed.
; 124  :     */
; 125  :     if (obj_start != Py_None)

  000f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000f7	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR obj_start$[rsp], rax
  000ff	74 1d		 je	 SHORT $LN4@stringlib_@32

; 126  :         if (!_PyEval_SliceIndex(obj_start, &tmp_start))

  00101	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR tmp_start$[rsp]
  00109	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR obj_start$[rsp]
  00111	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  00116	85 c0		 test	 eax, eax
  00118	75 04		 jne	 SHORT $LN3@stringlib_@32

; 127  :             return 0;

  0011a	33 c0		 xor	 eax, eax
  0011c	eb 5d		 jmp	 SHORT $LN6@stringlib_@32
$LN3@stringlib_@32:
$LN4@stringlib_@32:

; 128  :     if (obj_end != Py_None)

  0011e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00125	48 39 44 24 38	 cmp	 QWORD PTR obj_end$[rsp], rax
  0012a	74 17		 je	 SHORT $LN2@stringlib_@32

; 129  :         if (!_PyEval_SliceIndex(obj_end, &tmp_end))

  0012c	48 8d 54 24 40	 lea	 rdx, QWORD PTR tmp_end$[rsp]
  00131	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obj_end$[rsp]
  00136	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  0013b	85 c0		 test	 eax, eax
  0013d	75 04		 jne	 SHORT $LN1@stringlib_@32

; 130  :             return 0;

  0013f	33 c0		 xor	 eax, eax
  00141	eb 38		 jmp	 SHORT $LN6@stringlib_@32
$LN1@stringlib_@32:
$LN2@stringlib_@32:

; 131  : 
; 132  :     *start = tmp_start;

  00143	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR start$[rsp]
  0014b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tmp_start$[rsp]
  00153	48 89 08	 mov	 QWORD PTR [rax], rcx

; 133  :     *end = tmp_end;

  00156	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR end$[rsp]
  0015e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tmp_end$[rsp]
  00163	48 89 08	 mov	 QWORD PTR [rax], rcx

; 134  :     *subobj = tmp_subobj;

  00166	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR subobj$[rsp]
  0016e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tmp_subobj$[rsp]
  00173	48 89 08	 mov	 QWORD PTR [rax], rcx

; 135  :     return 1;

  00176	b8 01 00 00 00	 mov	 eax, 1
$LN6@stringlib_@32:

; 136  : }

  0017b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00182	5f		 pop	 rdi
  00183	5e		 pop	 rsi
  00184	c3		 ret	 0
stringlib_parse_args_finds ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@NLNEJIOA@substring?5not?5found?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$bytes_index DD imagerel bytes_index
	DD	imagerel bytes_index+98
	DD	imagerel $unwind$bytes_index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_index DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BE@NLNEJIOA@substring?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BE@NLNEJIOA@substring?5not?5found?$AA@ DB 'substring not found', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_index
_TEXT	SEGMENT
result$ = 32
self$ = 64
args$ = 72
bytes_index PROC					; COMDAT

; 1320 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1321 :     Py_ssize_t result = bytes_find_internal(self, args, +1);

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	e8 00 00 00 00	 call	 bytes_find_internal
  00023	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1322 :     if (result == -2)

  00028	48 83 7c 24 20
	fe		 cmp	 QWORD PTR result$[rsp], -2
  0002e	75 04		 jne	 SHORT $LN2@bytes_inde

; 1323 :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 29		 jmp	 SHORT $LN3@bytes_inde
$LN2@bytes_inde:

; 1324 :     if (result == -1) {

  00034	48 83 7c 24 20
	ff		 cmp	 QWORD PTR result$[rsp], -1
  0003a	75 17		 jne	 SHORT $LN1@bytes_inde

; 1325 :         PyErr_SetString(PyExc_ValueError,
; 1326 :                         "substring not found");

  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@NLNEJIOA@substring?5not?5found?$AA@
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0004a	e8 00 00 00 00	 call	 PyErr_SetString

; 1327 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	eb 0a		 jmp	 SHORT $LN3@bytes_inde
$LN1@bytes_inde:

; 1328 :     }
; 1329 :     return PyLong_FromSsize_t(result);

  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00058	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN3@bytes_inde:

; 1330 : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
bytes_index ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_rfind DD imagerel bytes_rfind
	DD	imagerel bytes_rfind+67
	DD	imagerel $unwind$bytes_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_rfind DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_rfind
_TEXT	SEGMENT
result$ = 32
self$ = 64
args$ = 72
bytes_rfind PROC					; COMDAT

; 1344 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1345 :     Py_ssize_t result = bytes_find_internal(self, args, -1);

  0000e	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	e8 00 00 00 00	 call	 bytes_find_internal
  00023	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1346 :     if (result == -2)

  00028	48 83 7c 24 20
	fe		 cmp	 QWORD PTR result$[rsp], -2
  0002e	75 04		 jne	 SHORT $LN1@bytes_rfin

; 1347 :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 0a		 jmp	 SHORT $LN2@bytes_rfin
$LN1@bytes_rfin:

; 1348 :     return PyLong_FromSsize_t(result);

  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00039	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN2@bytes_rfin:

; 1349 : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
bytes_rfind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_rindex DD imagerel bytes_rindex
	DD	imagerel bytes_rindex+98
	DD	imagerel $unwind$bytes_rindex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_rindex DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_rindex
_TEXT	SEGMENT
result$ = 32
self$ = 64
args$ = 72
bytes_rindex PROC					; COMDAT

; 1359 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1360 :     Py_ssize_t result = bytes_find_internal(self, args, -1);

  0000e	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	e8 00 00 00 00	 call	 bytes_find_internal
  00023	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1361 :     if (result == -2)

  00028	48 83 7c 24 20
	fe		 cmp	 QWORD PTR result$[rsp], -2
  0002e	75 04		 jne	 SHORT $LN2@bytes_rind

; 1362 :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 29		 jmp	 SHORT $LN3@bytes_rind
$LN2@bytes_rind:

; 1363 :     if (result == -1) {

  00034	48 83 7c 24 20
	ff		 cmp	 QWORD PTR result$[rsp], -1
  0003a	75 17		 jne	 SHORT $LN1@bytes_rind

; 1364 :         PyErr_SetString(PyExc_ValueError,
; 1365 :                         "substring not found");

  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@NLNEJIOA@substring?5not?5found?$AA@
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0004a	e8 00 00 00 00	 call	 PyErr_SetString

; 1366 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	eb 0a		 jmp	 SHORT $LN3@bytes_rind
$LN1@bytes_rind:

; 1367 :     }
; 1368 :     return PyLong_FromSsize_t(result);

  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00058	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN3@bytes_rind:

; 1369 : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
bytes_rindex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_strip DD imagerel bytes_strip
	DD	imagerel bytes_strip+70
	DD	imagerel $unwind$bytes_strip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_strip DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_strip
_TEXT	SEGMENT
self$ = 48
args$ = 56
bytes_strip PROC					; COMDAT

; 1465 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1466 :     if (PyTuple_GET_SIZE(args) == 0)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR args$[rsp]
  00013	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00018	75 13		 jne	 SHORT $LN2@bytes_stri

; 1467 :         return do_strip(self, BOTHSTRIP); /* Common case */

  0001a	ba 02 00 00 00	 mov	 edx, 2
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00024	e8 00 00 00 00	 call	 do_strip
  00029	eb 16		 jmp	 SHORT $LN3@bytes_stri

; 1468 :     else

  0002b	eb 14		 jmp	 SHORT $LN1@bytes_stri
$LN2@bytes_stri:

; 1469 :         return do_argstrip(self, BOTHSTRIP, args);

  0002d	4c 8b 44 24 38	 mov	 r8, QWORD PTR args$[rsp]
  00032	ba 02 00 00 00	 mov	 edx, 2
  00037	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0003c	e8 00 00 00 00	 call	 do_argstrip
$LN1@bytes_stri:
$LN3@bytes_stri:

; 1470 : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
bytes_strip ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_strip DD imagerel do_strip
	DD	imagerel do_strip+433
	DD	imagerel $unwind$do_strip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_strip DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT do_strip
_TEXT	SEGMENT
i$ = 32
s$ = 40
len$ = 48
j$ = 56
self$ = 80
striptype$ = 88
do_strip PROC						; COMDAT

; 1415 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1416 :     char *s = PyBytes_AS_STRING(self);

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00012	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00016	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00021	85 c0		 test	 eax, eax
  00023	75 1c		 jne	 SHORT $LN13@do_strip
  00025	41 b8 88 05 00
	00		 mov	 r8d, 1416		; 00000588H
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003f	33 c0		 xor	 eax, eax
$LN13@do_strip:
  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00046	48 83 c0 78	 add	 rax, 120		; 00000078H
  0004a	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 1417 :     Py_ssize_t len = PyBytes_GET_SIZE(self), i, j;

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00054	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00058	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00063	85 c0		 test	 eax, eax
  00065	75 1c		 jne	 SHORT $LN14@do_strip
  00067	41 b8 89 05 00
	00		 mov	 r8d, 1417		; 00000589H
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00081	33 c0		 xor	 eax, eax
$LN14@do_strip:
  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00088	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008c	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 1418 : 
; 1419 :     i = 0;

  00091	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0

; 1420 :     if (striptype != RIGHTSTRIP) {

  0009a	83 7c 24 58 01	 cmp	 DWORD PTR striptype$[rsp], 1
  0009f	74 47		 je	 SHORT $LN10@do_strip
$LN9@do_strip:

; 1421 :         while (i < len && Py_ISSPACE(s[i])) {

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  000a6	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000ab	7d 3b		 jge	 SHORT $LN8@do_strip
  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000b2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000b7	48 03 c8	 add	 rcx, rax
  000ba	48 8b c1	 mov	 rax, rcx
  000bd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c5	0f b6 c0	 movzx	 eax, al
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000cf	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000d2	83 e0 08	 and	 eax, 8
  000d5	85 c0		 test	 eax, eax
  000d7	74 0f		 je	 SHORT $LN8@do_strip

; 1422 :             i++;

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000de	48 ff c0	 inc	 rax
  000e1	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 1423 :         }

  000e6	eb b9		 jmp	 SHORT $LN9@do_strip
$LN8@do_strip:
$LN10@do_strip:

; 1424 :     }
; 1425 : 
; 1426 :     j = len;

  000e8	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  000ed	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax

; 1427 :     if (striptype != LEFTSTRIP) {

  000f2	83 7c 24 58 00	 cmp	 DWORD PTR striptype$[rsp], 0
  000f7	74 52		 je	 SHORT $LN7@do_strip
$LN6@do_strip:

; 1428 :         do {
; 1429 :             j--;

  000f9	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  000fe	48 ff c8	 dec	 rax
  00101	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax

; 1430 :         } while (j >= i && Py_ISSPACE(s[j]));

  00106	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0010b	48 39 44 24 38	 cmp	 QWORD PTR j$[rsp], rax
  00110	7c 2c		 jl	 SHORT $LN3@do_strip
  00112	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  00117	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0011c	48 03 c8	 add	 rcx, rax
  0011f	48 8b c1	 mov	 rax, rcx
  00122	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00125	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0012a	0f b6 c0	 movzx	 eax, al
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00134	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00137	83 e0 08	 and	 eax, 8
  0013a	85 c0		 test	 eax, eax
  0013c	75 bb		 jne	 SHORT $LN6@do_strip
$LN3@do_strip:

; 1431 :         j++;

  0013e	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  00143	48 ff c0	 inc	 rax
  00146	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax
$LN7@do_strip:

; 1432 :     }
; 1433 : 
; 1434 :     if (i == 0 && j == len && PyBytes_CheckExact(self)) {

  0014b	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  00151	75 31		 jne	 SHORT $LN2@do_strip
  00153	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00158	48 39 44 24 38	 cmp	 QWORD PTR j$[rsp], rax
  0015d	75 25		 jne	 SHORT $LN2@do_strip
  0015f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00166	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0016b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0016f	75 13		 jne	 SHORT $LN2@do_strip

; 1435 :         Py_INCREF(self);

  00171	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00176	e8 00 00 00 00	 call	 _Py_IncRef

; 1436 :         return (PyObject*)self;

  0017b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00180	eb 2a		 jmp	 SHORT $LN11@do_strip

; 1437 :     }
; 1438 :     else

  00182	eb 28		 jmp	 SHORT $LN1@do_strip
$LN2@do_strip:

; 1439 :         return PyBytes_FromStringAndSize(s+i, j-i);

  00184	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00189	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  0018e	48 2b c8	 sub	 rcx, rax
  00191	48 8b c1	 mov	 rax, rcx
  00194	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00199	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  0019e	48 03 d1	 add	 rdx, rcx
  001a1	48 8b ca	 mov	 rcx, rdx
  001a4	48 8b d0	 mov	 rdx, rax
  001a7	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
$LN1@do_strip:
$LN11@do_strip:

; 1440 : }

  001ac	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b0	c3		 ret	 0
do_strip ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_argstrip DD imagerel do_argstrip
	DD	imagerel do_argstrip+128
	DD	imagerel $unwind$do_argstrip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_argstrip DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT do_argstrip
_TEXT	SEGMENT
sep$ = 32
self$ = 64
striptype$ = 72
args$ = 80
do_argstrip PROC					; COMDAT

; 1445 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1446 :     PyObject *sep = NULL;

  00012	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR sep$[rsp], 0

; 1447 : 
; 1448 :     if (!PyArg_ParseTuple(args, (char *)stripformat[striptype], &sep))

  0001b	48 63 44 24 48	 movsxd	 rax, DWORD PTR striptype$[rsp]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stripformat
  00027	4c 8d 44 24 20	 lea	 r8, QWORD PTR sep$[rsp]
  0002c	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00030	48 8b 4c 24 50	 mov	 rcx, QWORD PTR args$[rsp]
  00035	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003a	85 c0		 test	 eax, eax
  0003c	75 04		 jne	 SHORT $LN2@do_argstri

; 1449 :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 39		 jmp	 SHORT $LN3@do_argstri
$LN2@do_argstri:

; 1450 : 
; 1451 :     if (sep != NULL && sep != Py_None) {

  00042	48 83 7c 24 20
	00		 cmp	 QWORD PTR sep$[rsp], 0
  00048	74 23		 je	 SHORT $LN1@do_argstri
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00051	48 39 44 24 20	 cmp	 QWORD PTR sep$[rsp], rax
  00056	74 15		 je	 SHORT $LN1@do_argstri

; 1452 :         return do_xstrip(self, striptype, sep);

  00058	4c 8b 44 24 20	 mov	 r8, QWORD PTR sep$[rsp]
  0005d	8b 54 24 48	 mov	 edx, DWORD PTR striptype$[rsp]
  00061	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00066	e8 00 00 00 00	 call	 do_xstrip
  0006b	eb 0e		 jmp	 SHORT $LN3@do_argstri
$LN1@do_argstri:

; 1453 :     }
; 1454 :     return do_strip(self, striptype);

  0006d	8b 54 24 48	 mov	 edx, DWORD PTR striptype$[rsp]
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00076	e8 00 00 00 00	 call	 do_strip
$LN3@do_argstri:

; 1455 : }

  0007b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007f	c3		 ret	 0
do_argstrip ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_xstrip DD imagerel do_xstrip
	DD	imagerel do_xstrip+591
	DD	imagerel $unwind$do_xstrip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_xstrip DD 021501H
	DD	0170115H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT do_xstrip
_TEXT	SEGMENT
i$ = 32
seplen$ = 40
s$ = 48
vsep$ = 64
len$ = 144
sep$ = 152
j$ = 160
self$ = 192
striptype$ = 200
sepobj$ = 208
do_xstrip PROC						; COMDAT

; 1374 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1375 :     Py_buffer vsep;
; 1376 :     char *s = PyBytes_AS_STRING(self);

  00015	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00027	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0002c	85 c0		 test	 eax, eax
  0002e	75 1c		 jne	 SHORT $LN14@do_xstrip
  00030	41 b8 60 05 00
	00		 mov	 r8d, 1376		; 00000560H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004a	33 c0		 xor	 eax, eax
$LN14@do_xstrip:
  0004c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00054	48 83 c0 78	 add	 rax, 120		; 00000078H
  00058	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 1377 :     Py_ssize_t len = PyBytes_GET_SIZE(self);

  0005d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00065	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00069	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0006f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00074	85 c0		 test	 eax, eax
  00076	75 1c		 jne	 SHORT $LN15@do_xstrip
  00078	41 b8 61 05 00
	00		 mov	 r8d, 1377		; 00000561H
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00092	33 c0		 xor	 eax, eax
$LN15@do_xstrip:
  00094	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 1378 :     char *sep;
; 1379 :     Py_ssize_t seplen;
; 1380 :     Py_ssize_t i, j;
; 1381 : 
; 1382 :     if (_getbuffer(sepobj, &vsep) < 0)

  000a8	48 8d 54 24 40	 lea	 rdx, QWORD PTR vsep$[rsp]
  000ad	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR sepobj$[rsp]
  000b5	e8 00 00 00 00	 call	 _getbuffer
  000ba	48 85 c0	 test	 rax, rax
  000bd	7d 07		 jge	 SHORT $LN11@do_xstrip

; 1383 :         return NULL;

  000bf	33 c0		 xor	 eax, eax
  000c1	e9 81 01 00 00	 jmp	 $LN12@do_xstrip
$LN11@do_xstrip:

; 1384 :     sep = vsep.buf;

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR vsep$[rsp]
  000cb	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR sep$[rsp], rax

; 1385 :     seplen = vsep.len;

  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR vsep$[rsp+16]
  000d8	48 89 44 24 28	 mov	 QWORD PTR seplen$[rsp], rax

; 1386 : 
; 1387 :     i = 0;

  000dd	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0

; 1388 :     if (striptype != RIGHTSTRIP) {

  000e6	83 bc 24 c8 00
	00 00 01	 cmp	 DWORD PTR striptype$[rsp], 1
  000ee	74 53		 je	 SHORT $LN10@do_xstrip
$LN9@do_xstrip:

; 1389 :         while (i < len && memchr(sep, Py_CHARMASK(s[i]), seplen)) {

  000f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  000f8	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000fd	7d 44		 jge	 SHORT $LN8@do_xstrip
  000ff	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00104	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00109	48 03 c8	 add	 rcx, rax
  0010c	48 8b c1	 mov	 rax, rcx
  0010f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00112	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00117	0f b6 c0	 movzx	 eax, al
  0011a	4c 8b 44 24 28	 mov	 r8, QWORD PTR seplen$[rsp]
  0011f	8b d0		 mov	 edx, eax
  00121	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR sep$[rsp]
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0012f	48 85 c0	 test	 rax, rax
  00132	74 0f		 je	 SHORT $LN8@do_xstrip

; 1390 :             i++;

  00134	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00139	48 ff c0	 inc	 rax
  0013c	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 1391 :         }

  00141	eb ad		 jmp	 SHORT $LN9@do_xstrip
$LN8@do_xstrip:
$LN10@do_xstrip:

; 1392 :     }
; 1393 : 
; 1394 :     j = len;

  00143	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0014b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR j$[rsp], rax

; 1395 :     if (striptype != LEFTSTRIP) {

  00153	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR striptype$[rsp], 0
  0015b	74 6d		 je	 SHORT $LN7@do_xstrip
$LN6@do_xstrip:

; 1396 :         do {
; 1397 :             j--;

  0015d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00165	48 ff c8	 dec	 rax
  00168	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR j$[rsp], rax

; 1398 :         } while (j >= i && memchr(sep, Py_CHARMASK(s[j]), seplen));

  00170	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00175	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR j$[rsp], rax
  0017d	7c 38		 jl	 SHORT $LN3@do_xstrip
  0017f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00187	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0018c	48 03 c8	 add	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00195	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0019a	0f b6 c0	 movzx	 eax, al
  0019d	4c 8b 44 24 28	 mov	 r8, QWORD PTR seplen$[rsp]
  001a2	8b d0		 mov	 edx, eax
  001a4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR sep$[rsp]
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  001b2	48 85 c0	 test	 rax, rax
  001b5	75 a6		 jne	 SHORT $LN6@do_xstrip
$LN3@do_xstrip:

; 1399 :         j++;

  001b7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  001bf	48 ff c0	 inc	 rax
  001c2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR j$[rsp], rax
$LN7@do_xstrip:

; 1400 :     }
; 1401 : 
; 1402 :     PyBuffer_Release(&vsep);

  001ca	48 8d 4c 24 40	 lea	 rcx, QWORD PTR vsep$[rsp]
  001cf	e8 00 00 00 00	 call	 PyBuffer_Release

; 1403 : 
; 1404 :     if (i == 0 && j == len && PyBytes_CheckExact(self)) {

  001d4	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  001da	75 40		 jne	 SHORT $LN2@do_xstrip
  001dc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  001e4	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR j$[rsp], rax
  001ec	75 2e		 jne	 SHORT $LN2@do_xstrip
  001ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  001f5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001fd	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00201	75 19		 jne	 SHORT $LN2@do_xstrip

; 1405 :         Py_INCREF(self);

  00203	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0020b	e8 00 00 00 00	 call	 _Py_IncRef

; 1406 :         return (PyObject*)self;

  00210	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00218	eb 2d		 jmp	 SHORT $LN12@do_xstrip

; 1407 :     }
; 1408 :     else

  0021a	eb 2b		 jmp	 SHORT $LN1@do_xstrip
$LN2@do_xstrip:

; 1409 :         return PyBytes_FromStringAndSize(s+i, j-i);

  0021c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00221	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00229	48 2b c8	 sub	 rcx, rax
  0022c	48 8b c1	 mov	 rax, rcx
  0022f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00234	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  00239	48 03 d1	 add	 rdx, rcx
  0023c	48 8b ca	 mov	 rcx, rdx
  0023f	48 8b d0	 mov	 rdx, rax
  00242	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
$LN1@do_xstrip:
$LN12@do_xstrip:

; 1410 : }

  00247	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0024e	c3		 ret	 0
do_xstrip ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_lstrip DD imagerel bytes_lstrip
	DD	imagerel bytes_lstrip+64
	DD	imagerel $unwind$bytes_lstrip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_lstrip DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_lstrip
_TEXT	SEGMENT
self$ = 48
args$ = 56
bytes_lstrip PROC					; COMDAT

; 1480 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1481 :     if (PyTuple_GET_SIZE(args) == 0)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR args$[rsp]
  00013	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00018	75 10		 jne	 SHORT $LN2@bytes_lstr

; 1482 :         return do_strip(self, LEFTSTRIP); /* Common case */

  0001a	33 d2		 xor	 edx, edx
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00021	e8 00 00 00 00	 call	 do_strip
  00026	eb 13		 jmp	 SHORT $LN3@bytes_lstr

; 1483 :     else

  00028	eb 11		 jmp	 SHORT $LN1@bytes_lstr
$LN2@bytes_lstr:

; 1484 :         return do_argstrip(self, LEFTSTRIP, args);

  0002a	4c 8b 44 24 38	 mov	 r8, QWORD PTR args$[rsp]
  0002f	33 d2		 xor	 edx, edx
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00036	e8 00 00 00 00	 call	 do_argstrip
$LN1@bytes_lstr:
$LN3@bytes_lstr:

; 1485 : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
bytes_lstrip ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_rstrip DD imagerel bytes_rstrip
	DD	imagerel bytes_rstrip+70
	DD	imagerel $unwind$bytes_rstrip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_rstrip DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_rstrip
_TEXT	SEGMENT
self$ = 48
args$ = 56
bytes_rstrip PROC					; COMDAT

; 1495 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1496 :     if (PyTuple_GET_SIZE(args) == 0)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR args$[rsp]
  00013	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00018	75 13		 jne	 SHORT $LN2@bytes_rstr

; 1497 :         return do_strip(self, RIGHTSTRIP); /* Common case */

  0001a	ba 01 00 00 00	 mov	 edx, 1
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00024	e8 00 00 00 00	 call	 do_strip
  00029	eb 16		 jmp	 SHORT $LN3@bytes_rstr

; 1498 :     else

  0002b	eb 14		 jmp	 SHORT $LN1@bytes_rstr
$LN2@bytes_rstr:

; 1499 :         return do_argstrip(self, RIGHTSTRIP, args);

  0002d	4c 8b 44 24 38	 mov	 r8, QWORD PTR args$[rsp]
  00032	ba 01 00 00 00	 mov	 edx, 1
  00037	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0003c	e8 00 00 00 00	 call	 do_argstrip
$LN1@bytes_rstr:
$LN3@bytes_rstr:

; 1500 : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
bytes_rstrip ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_count DD imagerel bytes_count
	DD	imagerel bytes_count+816
	DD	imagerel $unwind$bytes_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_count DD 021101H
	DD	01b0111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_count
_TEXT	SEGMENT
sub_obj$ = 48
vsub$ = 64
count_obj$ = 144
end$ = 152
start$ = 160
sub_len$ = 168
sub$ = 176
byte$ = 184
str$ = 192
self$ = 224
args$ = 232
bytes_count PROC					; COMDAT

; 1512 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1513 :     PyObject *sub_obj;
; 1514 :     const char *str = PyBytes_AS_STRING(self), *sub;

  00011	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00019	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00023	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00028	85 c0		 test	 eax, eax
  0002a	75 1c		 jne	 SHORT $LN14@bytes_coun
  0002c	41 b8 ea 05 00
	00		 mov	 r8d, 1514		; 000005eaH
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00046	33 c0		 xor	 eax, eax
$LN14@bytes_coun:
  00048	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00050	48 83 c0 78	 add	 rax, 120		; 00000078H
  00054	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR str$[rsp], rax

; 1515 :     Py_ssize_t sub_len;
; 1516 :     char byte;
; 1517 :     Py_ssize_t start = 0, end = PY_SSIZE_T_MAX;

  0005c	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR start$[rsp], 0
  00068	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00072	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR end$[rsp], rax

; 1518 : 
; 1519 :     Py_buffer vsub;
; 1520 :     PyObject *count_obj;
; 1521 : 
; 1522 :     if (!stringlib_parse_args_finds_byte("count", args, &sub_obj, &byte,
; 1523 :                                          &start, &end))

  0007a	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR end$[rsp]
  00082	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00087	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR start$[rsp]
  0008f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00094	4c 8d 8c 24 b8
	00 00 00	 lea	 r9, QWORD PTR byte$[rsp]
  0009c	4c 8d 44 24 30	 lea	 r8, QWORD PTR sub_obj$[rsp]
  000a1	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR args$[rsp]
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
  000b0	e8 00 00 00 00	 call	 stringlib_parse_args_finds_byte
  000b5	85 c0		 test	 eax, eax
  000b7	75 07		 jne	 SHORT $LN11@bytes_coun

; 1524 :         return NULL;

  000b9	33 c0		 xor	 eax, eax
  000bb	e9 68 02 00 00	 jmp	 $LN12@bytes_coun
$LN11@bytes_coun:

; 1525 : 
; 1526 :     if (sub_obj) {

  000c0	48 83 7c 24 30
	00		 cmp	 QWORD PTR sub_obj$[rsp], 0
  000c6	74 37		 je	 SHORT $LN10@bytes_coun

; 1527 :         if (_getbuffer(sub_obj, &vsub) < 0)

  000c8	48 8d 54 24 40	 lea	 rdx, QWORD PTR vsub$[rsp]
  000cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sub_obj$[rsp]
  000d2	e8 00 00 00 00	 call	 _getbuffer
  000d7	48 85 c0	 test	 rax, rax
  000da	7d 07		 jge	 SHORT $LN9@bytes_coun

; 1528 :             return NULL;

  000dc	33 c0		 xor	 eax, eax
  000de	e9 45 02 00 00	 jmp	 $LN12@bytes_coun
$LN9@bytes_coun:

; 1529 : 
; 1530 :         sub = vsub.buf;

  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR vsub$[rsp]
  000e8	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR sub$[rsp], rax

; 1531 :         sub_len = vsub.len;

  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR vsub$[rsp+16]
  000f5	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR sub_len$[rsp], rax

; 1532 :     }
; 1533 :     else {

  000fd	eb 1c		 jmp	 SHORT $LN8@bytes_coun
$LN10@bytes_coun:

; 1534 :         sub = &byte;

  000ff	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR byte$[rsp]
  00107	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR sub$[rsp], rax

; 1535 :         sub_len = 1;

  0010f	48 c7 84 24 a8
	00 00 00 01 00
	00 00		 mov	 QWORD PTR sub_len$[rsp], 1
$LN8@bytes_coun:

; 1536 :     }
; 1537 : 
; 1538 :     ADJUST_INDICES(start, end, PyBytes_GET_SIZE(self));

  0011b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00123	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00127	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0012d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00132	85 c0		 test	 eax, eax
  00134	75 1c		 jne	 SHORT $LN15@bytes_coun
  00136	41 b8 02 06 00
	00		 mov	 r8d, 1538		; 00000602H
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00150	33 c0		 xor	 eax, eax
$LN15@bytes_coun:
  00152	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0015a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0015e	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR end$[rsp], rax
  00166	7e 4d		 jle	 SHORT $LN7@bytes_coun
  00168	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00170	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00174	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0017a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0017f	85 c0		 test	 eax, eax
  00181	75 1c		 jne	 SHORT $LN16@bytes_coun
  00183	41 b8 02 06 00
	00		 mov	 r8d, 1538		; 00000602H
  00189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0019d	33 c0		 xor	 eax, eax
$LN16@bytes_coun:
  0019f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001a7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001ab	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR end$[rsp], rax
  001b3	eb 7b		 jmp	 SHORT $LN6@bytes_coun
$LN7@bytes_coun:
  001b5	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR end$[rsp], 0
  001be	7d 70		 jge	 SHORT $LN5@bytes_coun
  001c0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001c8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001cc	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001d2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001d7	85 c0		 test	 eax, eax
  001d9	75 1c		 jne	 SHORT $LN17@bytes_coun
  001db	41 b8 02 06 00
	00		 mov	 r8d, 1538		; 00000602H
  001e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f5	33 c0		 xor	 eax, eax
$LN17@bytes_coun:
  001f7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001ff	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00203	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  0020b	48 03 c8	 add	 rcx, rax
  0020e	48 8b c1	 mov	 rax, rcx
  00211	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR end$[rsp], rax
  00219	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR end$[rsp], 0
  00222	7d 0c		 jge	 SHORT $LN4@bytes_coun
  00224	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR end$[rsp], 0
$LN4@bytes_coun:
$LN5@bytes_coun:
$LN6@bytes_coun:
  00230	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR start$[rsp], 0
  00239	7d 70		 jge	 SHORT $LN3@bytes_coun
  0023b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00243	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00247	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0024d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00252	85 c0		 test	 eax, eax
  00254	75 1c		 jne	 SHORT $LN18@bytes_coun
  00256	41 b8 02 06 00
	00		 mov	 r8d, 1538		; 00000602H
  0025c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00263	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0026a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00270	33 c0		 xor	 eax, eax
$LN18@bytes_coun:
  00272	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0027a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0027e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR start$[rsp]
  00286	48 03 c8	 add	 rcx, rax
  00289	48 8b c1	 mov	 rax, rcx
  0028c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR start$[rsp], rax
  00294	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR start$[rsp], 0
  0029d	7d 0c		 jge	 SHORT $LN2@bytes_coun
  0029f	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR start$[rsp], 0
$LN2@bytes_coun:
$LN3@bytes_coun:

; 1539 : 
; 1540 :     count_obj = PyLong_FromSsize_t(
; 1541 :         stringlib_count(str + start, end - start, sub, sub_len, PY_SSIZE_T_MAX)
; 1542 :         );

  002ab	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR start$[rsp]
  002b3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  002bb	48 2b c8	 sub	 rcx, rax
  002be	48 8b c1	 mov	 rax, rcx
  002c1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR start$[rsp]
  002c9	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  002d1	48 03 d1	 add	 rdx, rcx
  002d4	48 8b ca	 mov	 rcx, rdx
  002d7	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  002e1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002e6	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR sub_len$[rsp]
  002ee	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR sub$[rsp]
  002f6	48 8b d0	 mov	 rdx, rax
  002f9	e8 00 00 00 00	 call	 stringlib_count
  002fe	48 8b c8	 mov	 rcx, rax
  00301	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00306	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR count_obj$[rsp], rax

; 1543 : 
; 1544 :     if (sub_obj)

  0030e	48 83 7c 24 30
	00		 cmp	 QWORD PTR sub_obj$[rsp], 0
  00314	74 0a		 je	 SHORT $LN1@bytes_coun

; 1545 :         PyBuffer_Release(&vsub);

  00316	48 8d 4c 24 40	 lea	 rcx, QWORD PTR vsub$[rsp]
  0031b	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytes_coun:

; 1546 : 
; 1547 :     return count_obj;

  00320	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR count_obj$[rsp]
$LN12@bytes_coun:

; 1548 : }

  00328	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0032f	c3		 ret	 0
bytes_count ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\count.h
pdata	SEGMENT
$pdata$stringlib_count DD imagerel stringlib_count
	DD	imagerel stringlib_count+158
	DD	imagerel $unwind$stringlib_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_count DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_count
_TEXT	SEGMENT
count$ = 48
tv68 = 56
str$ = 80
str_len$ = 88
sub$ = 96
sub_len$ = 104
maxcount$ = 112
stringlib_count PROC					; COMDAT

; 11   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 12   :     Py_ssize_t count;
; 13   : 
; 14   :     if (str_len < 0)

  00018	48 83 7c 24 58
	00		 cmp	 QWORD PTR str_len$[rsp], 0
  0001e	7d 04		 jge	 SHORT $LN3@stringlib_@33

; 15   :         return 0; /* start > len(str) */

  00020	33 c0		 xor	 eax, eax
  00022	eb 75		 jmp	 SHORT $LN4@stringlib_@33
$LN3@stringlib_@33:

; 16   :     if (sub_len == 0)

  00024	48 83 7c 24 68
	00		 cmp	 QWORD PTR sub_len$[rsp], 0
  0002a	75 2c		 jne	 SHORT $LN2@stringlib_@33

; 17   :         return (str_len < maxcount) ? str_len + 1 : maxcount;

  0002c	48 8b 44 24 70	 mov	 rax, QWORD PTR maxcount$[rsp]
  00031	48 39 44 24 58	 cmp	 QWORD PTR str_len$[rsp], rax
  00036	7d 0f		 jge	 SHORT $LN6@stringlib_@33
  00038	48 8b 44 24 58	 mov	 rax, QWORD PTR str_len$[rsp]
  0003d	48 ff c0	 inc	 rax
  00040	48 89 44 24 38	 mov	 QWORD PTR tv68[rsp], rax
  00045	eb 0a		 jmp	 SHORT $LN7@stringlib_@33
$LN6@stringlib_@33:
  00047	48 8b 44 24 70	 mov	 rax, QWORD PTR maxcount$[rsp]
  0004c	48 89 44 24 38	 mov	 QWORD PTR tv68[rsp], rax
$LN7@stringlib_@33:
  00051	48 8b 44 24 38	 mov	 rax, QWORD PTR tv68[rsp]
  00056	eb 41		 jmp	 SHORT $LN4@stringlib_@33
$LN2@stringlib_@33:

; 18   : 
; 19   :     count = FASTSEARCH(str, str_len, sub, sub_len, maxcount, FAST_COUNT);

  00058	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00060	48 8b 44 24 70	 mov	 rax, QWORD PTR maxcount$[rsp]
  00065	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006a	4c 8b 4c 24 68	 mov	 r9, QWORD PTR sub_len$[rsp]
  0006f	4c 8b 44 24 60	 mov	 r8, QWORD PTR sub$[rsp]
  00074	48 8b 54 24 58	 mov	 rdx, QWORD PTR str_len$[rsp]
  00079	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  0007e	e8 00 00 00 00	 call	 fastsearch
  00083	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax

; 20   : 
; 21   :     if (count < 0)

  00088	48 83 7c 24 30
	00		 cmp	 QWORD PTR count$[rsp], 0
  0008e	7d 04		 jge	 SHORT $LN1@stringlib_@33

; 22   :         return 0; /* no match */

  00090	33 c0		 xor	 eax, eax
  00092	eb 05		 jmp	 SHORT $LN4@stringlib_@33
$LN1@stringlib_@33:

; 23   : 
; 24   :     return count;

  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
$LN4@stringlib_@33:

; 25   : }

  00099	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009d	c3		 ret	 0
stringlib_count ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DC@FCGLMCFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@JEOCHDG@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAd?$AAe?$AAl?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@ ; `string'
PUBLIC	??_C@_1DA@NKPKLCJM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$bytes_translate DD imagerel bytes_translate
	DD	imagerel bytes_translate+1880
	DD	imagerel $unwind$bytes_translate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_translate DD 021101H
	DD	0970111H
xdata	ENDS
;	COMDAT ??_C@_1DC@FCGLMCFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@FCGLMCFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, '_', 00H
	DB	'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@JEOCHDG@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAd?$AAe?$AAl?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@JEOCHDG@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAd?$AAe?$AAl?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'd', 00H, 'e', 00H, 'l', 00H, 'o', 00H, 'b', 00H, 'j', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@
CONST	SEGMENT
??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@ DB 'translation'
	DB	' table must be 256 characters long', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@NKPKLCJM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@NKPKLCJM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'o', 00H
	DB	'b', 00H, 'j', 00H, ')', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_translate
_TEXT	SEGMENT
trans_table$ = 48
del_table$ = 1072
tablen$ = 1080
inlen$ = 1088
changed$ = 1096
i$ = 1104
tableobj$ = 1112
output$ = 1120
input$ = 1128
output_start$ = 1136
table$ = 1144
delobj$ = 1152
result$ = 1160
input_obj$ = 1168
c$ = 1176
dellen$ = 1184
self$ = 1216
args$ = 1224
bytes_translate PROC					; COMDAT

; 1561 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 04
	00 00		 sub	 rsp, 1208		; 000004b8H

; 1562 :     register char *input, *output;
; 1563 :     const char *table;
; 1564 :     register Py_ssize_t i, c, changed = 0;

  00011	48 c7 84 24 48
	04 00 00 00 00
	00 00		 mov	 QWORD PTR changed$[rsp], 0

; 1565 :     PyObject *input_obj = (PyObject*)self;

  0001d	48 8b 84 24 c0
	04 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00025	48 89 84 24 90
	04 00 00	 mov	 QWORD PTR input_obj$[rsp], rax

; 1566 :     const char *output_start, *del_table=NULL;

  0002d	48 c7 84 24 30
	04 00 00 00 00
	00 00		 mov	 QWORD PTR del_table$[rsp], 0

; 1567 :     Py_ssize_t inlen, tablen, dellen = 0;

  00039	48 c7 84 24 a0
	04 00 00 00 00
	00 00		 mov	 QWORD PTR dellen$[rsp], 0

; 1568 :     PyObject *result;
; 1569 :     int trans_table[256];
; 1570 :     PyObject *tableobj, *delobj = NULL;

  00045	48 c7 84 24 80
	04 00 00 00 00
	00 00		 mov	 QWORD PTR delobj$[rsp], 0

; 1571 : 
; 1572 :     if (!PyArg_UnpackTuple(args, "translate", 1, 2,
; 1573 :                           &tableobj, &delobj))

  00051	48 8d 84 24 80
	04 00 00	 lea	 rax, QWORD PTR delobj$[rsp]
  00059	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005e	48 8d 84 24 58
	04 00 00	 lea	 rax, QWORD PTR tableobj$[rsp]
  00066	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00071	41 b8 01 00 00
	00		 mov	 r8d, 1
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09ODNGOEIO@translate?$AA@
  0007e	48 8b 8c 24 c8
	04 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00086	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0008b	85 c0		 test	 eax, eax
  0008d	75 07		 jne	 SHORT $LN36@bytes_tran

; 1574 :         return NULL;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 ba 06 00 00	 jmp	 $LN37@bytes_tran
$LN36@bytes_tran:

; 1575 : 
; 1576 :     if (PyBytes_Check(tableobj)) {

  00096	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tableobj$[rsp]
  0009e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000a8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000ad	85 c0		 test	 eax, eax
  000af	0f 84 98 00 00
	00		 je	 $LN35@bytes_tran

; 1577 :         table = PyBytes_AS_STRING(tableobj);

  000b5	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tableobj$[rsp]
  000bd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000c1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000c7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000cc	85 c0		 test	 eax, eax
  000ce	75 1c		 jne	 SHORT $LN39@bytes_tran
  000d0	41 b8 29 06 00
	00		 mov	 r8d, 1577		; 00000629H
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@NKPKLCJM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ea	33 c0		 xor	 eax, eax
$LN39@bytes_tran:
  000ec	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tableobj$[rsp]
  000f4	48 83 c0 78	 add	 rax, 120		; 00000078H
  000f8	48 89 84 24 78
	04 00 00	 mov	 QWORD PTR table$[rsp], rax

; 1578 :         tablen = PyBytes_GET_SIZE(tableobj);

  00100	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tableobj$[rsp]
  00108	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0010c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00112	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00117	85 c0		 test	 eax, eax
  00119	75 1c		 jne	 SHORT $LN40@bytes_tran
  0011b	41 b8 2a 06 00
	00		 mov	 r8d, 1578		; 0000062aH
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@NKPKLCJM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00135	33 c0		 xor	 eax, eax
$LN40@bytes_tran:
  00137	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tableobj$[rsp]
  0013f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00143	48 89 84 24 38
	04 00 00	 mov	 QWORD PTR tablen$[rsp], rax
  0014b	eb 53		 jmp	 SHORT $LN34@bytes_tran
$LN35@bytes_tran:

; 1579 :     }
; 1580 :     else if (tableobj == Py_None) {

  0014d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00154	48 39 84 24 58
	04 00 00	 cmp	 QWORD PTR tableobj$[rsp], rax
  0015c	75 1a		 jne	 SHORT $LN33@bytes_tran

; 1581 :         table = NULL;

  0015e	48 c7 84 24 78
	04 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp], 0

; 1582 :         tablen = 256;

  0016a	48 c7 84 24 38
	04 00 00 00 01
	00 00		 mov	 QWORD PTR tablen$[rsp], 256 ; 00000100H
  00176	eb 28		 jmp	 SHORT $LN32@bytes_tran
$LN33@bytes_tran:

; 1583 :     }
; 1584 :     else if (PyObject_AsCharBuffer(tableobj, &table, &tablen))

  00178	4c 8d 84 24 38
	04 00 00	 lea	 r8, QWORD PTR tablen$[rsp]
  00180	48 8d 94 24 78
	04 00 00	 lea	 rdx, QWORD PTR table$[rsp]
  00188	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tableobj$[rsp]
  00190	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  00195	85 c0		 test	 eax, eax
  00197	74 07		 je	 SHORT $LN31@bytes_tran

; 1585 :         return NULL;

  00199	33 c0		 xor	 eax, eax
  0019b	e9 b0 05 00 00	 jmp	 $LN37@bytes_tran
$LN31@bytes_tran:
$LN32@bytes_tran:
$LN34@bytes_tran:

; 1586 : 
; 1587 :     if (tablen != 256) {

  001a0	48 81 bc 24 38
	04 00 00 00 01
	00 00		 cmp	 QWORD PTR tablen$[rsp], 256 ; 00000100H
  001ac	74 1a		 je	 SHORT $LN30@bytes_tran

; 1588 :         PyErr_SetString(PyExc_ValueError,
; 1589 :           "translation table must be 256 characters long");

  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@
  001b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001bc	e8 00 00 00 00	 call	 PyErr_SetString

; 1590 :         return NULL;

  001c1	33 c0		 xor	 eax, eax
  001c3	e9 88 05 00 00	 jmp	 $LN37@bytes_tran
$LN30@bytes_tran:

; 1591 :     }
; 1592 : 
; 1593 :     if (delobj != NULL) {

  001c8	48 83 bc 24 80
	04 00 00 00	 cmp	 QWORD PTR delobj$[rsp], 0
  001d1	0f 84 e1 00 00
	00		 je	 $LN29@bytes_tran

; 1594 :         if (PyBytes_Check(delobj)) {

  001d7	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR delobj$[rsp]
  001df	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001e3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001e9	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001ee	85 c0		 test	 eax, eax
  001f0	0f 84 98 00 00
	00		 je	 $LN28@bytes_tran

; 1595 :             del_table = PyBytes_AS_STRING(delobj);

  001f6	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR delobj$[rsp]
  001fe	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00202	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00208	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0020d	85 c0		 test	 eax, eax
  0020f	75 1c		 jne	 SHORT $LN41@bytes_tran
  00211	41 b8 3b 06 00
	00		 mov	 r8d, 1595		; 0000063bH
  00217	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@JEOCHDG@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAd?$AAe?$AAl?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0022b	33 c0		 xor	 eax, eax
$LN41@bytes_tran:
  0022d	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR delobj$[rsp]
  00235	48 83 c0 78	 add	 rax, 120		; 00000078H
  00239	48 89 84 24 30
	04 00 00	 mov	 QWORD PTR del_table$[rsp], rax

; 1596 :             dellen = PyBytes_GET_SIZE(delobj);

  00241	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR delobj$[rsp]
  00249	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0024d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00253	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00258	85 c0		 test	 eax, eax
  0025a	75 1c		 jne	 SHORT $LN42@bytes_tran
  0025c	41 b8 3c 06 00
	00		 mov	 r8d, 1596		; 0000063cH
  00262	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00269	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@JEOCHDG@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAd?$AAe?$AAl?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00270	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00276	33 c0		 xor	 eax, eax
$LN42@bytes_tran:
  00278	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR delobj$[rsp]
  00280	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00284	48 89 84 24 a0
	04 00 00	 mov	 QWORD PTR dellen$[rsp], rax
  0028c	eb 28		 jmp	 SHORT $LN27@bytes_tran
$LN28@bytes_tran:

; 1597 :         }
; 1598 :         else if (PyObject_AsCharBuffer(delobj, &del_table, &dellen))

  0028e	4c 8d 84 24 a0
	04 00 00	 lea	 r8, QWORD PTR dellen$[rsp]
  00296	48 8d 94 24 30
	04 00 00	 lea	 rdx, QWORD PTR del_table$[rsp]
  0029e	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR delobj$[rsp]
  002a6	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  002ab	85 c0		 test	 eax, eax
  002ad	74 07		 je	 SHORT $LN26@bytes_tran

; 1599 :             return NULL;

  002af	33 c0		 xor	 eax, eax
  002b1	e9 9a 04 00 00	 jmp	 $LN37@bytes_tran
$LN26@bytes_tran:
$LN27@bytes_tran:

; 1600 :     }
; 1601 :     else {

  002b6	eb 18		 jmp	 SHORT $LN25@bytes_tran
$LN29@bytes_tran:

; 1602 :         del_table = NULL;

  002b8	48 c7 84 24 30
	04 00 00 00 00
	00 00		 mov	 QWORD PTR del_table$[rsp], 0

; 1603 :         dellen = 0;

  002c4	48 c7 84 24 a0
	04 00 00 00 00
	00 00		 mov	 QWORD PTR dellen$[rsp], 0
$LN25@bytes_tran:

; 1604 :     }
; 1605 : 
; 1606 :     inlen = PyBytes_GET_SIZE(input_obj);

  002d0	48 8b 84 24 90
	04 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  002d8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002dc	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002e2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002e7	85 c0		 test	 eax, eax
  002e9	75 1c		 jne	 SHORT $LN43@bytes_tran
  002eb	41 b8 46 06 00
	00		 mov	 r8d, 1606		; 00000646H
  002f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@FCGLMCFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  002ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00305	33 c0		 xor	 eax, eax
$LN43@bytes_tran:
  00307	48 8b 84 24 90
	04 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  0030f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00313	48 89 84 24 40
	04 00 00	 mov	 QWORD PTR inlen$[rsp], rax

; 1607 :     result = PyBytes_FromStringAndSize((char *)NULL, inlen);

  0031b	48 8b 94 24 40
	04 00 00	 mov	 rdx, QWORD PTR inlen$[rsp]
  00323	33 c9		 xor	 ecx, ecx
  00325	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0032a	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR result$[rsp], rax

; 1608 :     if (result == NULL)

  00332	48 83 bc 24 88
	04 00 00 00	 cmp	 QWORD PTR result$[rsp], 0
  0033b	75 07		 jne	 SHORT $LN24@bytes_tran

; 1609 :         return NULL;

  0033d	33 c0		 xor	 eax, eax
  0033f	e9 0c 04 00 00	 jmp	 $LN37@bytes_tran
$LN24@bytes_tran:

; 1610 :     output_start = output = PyBytes_AsString(result);

  00344	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  0034c	e8 00 00 00 00	 call	 PyBytes_AsString
  00351	48 89 84 24 60
	04 00 00	 mov	 QWORD PTR output$[rsp], rax
  00359	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR output$[rsp]
  00361	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR output_start$[rsp], rax

; 1611 :     input = PyBytes_AS_STRING(input_obj);

  00369	48 8b 84 24 90
	04 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  00371	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00375	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0037b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00380	85 c0		 test	 eax, eax
  00382	75 1c		 jne	 SHORT $LN44@bytes_tran
  00384	41 b8 4b 06 00
	00		 mov	 r8d, 1611		; 0000064bH
  0038a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00391	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@FCGLMCFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0039e	33 c0		 xor	 eax, eax
$LN44@bytes_tran:
  003a0	48 8b 84 24 90
	04 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  003a8	48 83 c0 78	 add	 rax, 120		; 00000078H
  003ac	48 89 84 24 68
	04 00 00	 mov	 QWORD PTR input$[rsp], rax

; 1612 : 
; 1613 :     if (dellen == 0 && table != NULL) {

  003b4	48 83 bc 24 a0
	04 00 00 00	 cmp	 QWORD PTR dellen$[rsp], 0
  003bd	0f 85 2a 01 00
	00		 jne	 $LN23@bytes_tran
  003c3	48 83 bc 24 78
	04 00 00 00	 cmp	 QWORD PTR table$[rsp], 0
  003cc	0f 84 1b 01 00
	00		 je	 $LN23@bytes_tran

; 1614 :         /* If no deletions are required, use faster code */
; 1615 :         for (i = inlen; --i >= 0; ) {

  003d2	48 8b 84 24 40
	04 00 00	 mov	 rax, QWORD PTR inlen$[rsp]
  003da	48 89 84 24 50
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN22@bytes_tran:
  003e2	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  003ea	48 ff c8	 dec	 rax
  003ed	48 89 84 24 50
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
  003f5	48 83 bc 24 50
	04 00 00 00	 cmp	 QWORD PTR i$[rsp], 0
  003fe	0f 8c 95 00 00
	00		 jl	 $LN21@bytes_tran

; 1616 :             c = Py_CHARMASK(*input++);

  00404	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR input$[rsp]
  0040c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0040f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00414	0f b6 c0	 movzx	 eax, al
  00417	48 89 84 24 98
	04 00 00	 mov	 QWORD PTR c$[rsp], rax
  0041f	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR input$[rsp]
  00427	48 ff c0	 inc	 rax
  0042a	48 89 84 24 68
	04 00 00	 mov	 QWORD PTR input$[rsp], rax

; 1617 :             if (Py_CHARMASK((*output++ = table[c])) != c)

  00432	48 8b 84 24 98
	04 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0043a	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00442	48 03 c8	 add	 rcx, rax
  00445	48 8b c1	 mov	 rax, rcx
  00448	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR output$[rsp]
  00450	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00453	88 01		 mov	 BYTE PTR [rcx], al
  00455	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR output$[rsp]
  0045d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00460	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00465	0f b6 c0	 movzx	 eax, al
  00468	48 8b 8c 24 98
	04 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00470	48 8b 94 24 60
	04 00 00	 mov	 rdx, QWORD PTR output$[rsp]
  00478	48 ff c2	 inc	 rdx
  0047b	48 89 94 24 60
	04 00 00	 mov	 QWORD PTR output$[rsp], rdx
  00483	48 3b c1	 cmp	 rax, rcx
  00486	74 0c		 je	 SHORT $LN20@bytes_tran

; 1618 :                 changed = 1;

  00488	48 c7 84 24 48
	04 00 00 01 00
	00 00		 mov	 QWORD PTR changed$[rsp], 1
$LN20@bytes_tran:

; 1619 :         }

  00494	e9 49 ff ff ff	 jmp	 $LN22@bytes_tran
$LN21@bytes_tran:

; 1620 :         if (changed || !PyBytes_CheckExact(input_obj))

  00499	48 83 bc 24 48
	04 00 00 00	 cmp	 QWORD PTR changed$[rsp], 0
  004a2	75 15		 jne	 SHORT $LN18@bytes_tran
  004a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  004ab	48 8b 8c 24 90
	04 00 00	 mov	 rcx, QWORD PTR input_obj$[rsp]
  004b3	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  004b7	74 0d		 je	 SHORT $LN19@bytes_tran
$LN18@bytes_tran:

; 1621 :             return result;

  004b9	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR result$[rsp]
  004c1	e9 8a 02 00 00	 jmp	 $LN37@bytes_tran
$LN19@bytes_tran:

; 1622 :         Py_DECREF(result);

  004c6	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  004ce	e8 00 00 00 00	 call	 _Py_DecRef

; 1623 :         Py_INCREF(input_obj);

  004d3	48 8b 8c 24 90
	04 00 00	 mov	 rcx, QWORD PTR input_obj$[rsp]
  004db	e8 00 00 00 00	 call	 _Py_IncRef

; 1624 :         return input_obj;

  004e0	48 8b 84 24 90
	04 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  004e8	e9 63 02 00 00	 jmp	 $LN37@bytes_tran
$LN23@bytes_tran:

; 1625 :     }
; 1626 : 
; 1627 :     if (table == NULL) {

  004ed	48 83 bc 24 78
	04 00 00 00	 cmp	 QWORD PTR table$[rsp], 0
  004f6	75 50		 jne	 SHORT $LN17@bytes_tran

; 1628 :         for (i = 0; i < 256; i++)

  004f8	48 c7 84 24 50
	04 00 00 00 00
	00 00		 mov	 QWORD PTR i$[rsp], 0
  00504	eb 13		 jmp	 SHORT $LN16@bytes_tran
$LN15@bytes_tran:
  00506	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0050e	48 ff c0	 inc	 rax
  00511	48 89 84 24 50
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN16@bytes_tran:
  00519	48 81 bc 24 50
	04 00 00 00 01
	00 00		 cmp	 QWORD PTR i$[rsp], 256	; 00000100H
  00525	7d 1f		 jge	 SHORT $LN14@bytes_tran

; 1629 :             trans_table[i] = Py_CHARMASK(i);

  00527	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0052f	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00535	0f b6 c0	 movzx	 eax, al
  00538	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  00540	89 44 8c 30	 mov	 DWORD PTR trans_table$[rsp+rcx*4], eax
  00544	eb c0		 jmp	 SHORT $LN15@bytes_tran
$LN14@bytes_tran:

; 1630 :     } else {

  00546	eb 5e		 jmp	 SHORT $LN13@bytes_tran
$LN17@bytes_tran:

; 1631 :         for (i = 0; i < 256; i++)

  00548	48 c7 84 24 50
	04 00 00 00 00
	00 00		 mov	 QWORD PTR i$[rsp], 0
  00554	eb 13		 jmp	 SHORT $LN12@bytes_tran
$LN11@bytes_tran:
  00556	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0055e	48 ff c0	 inc	 rax
  00561	48 89 84 24 50
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN12@bytes_tran:
  00569	48 81 bc 24 50
	04 00 00 00 01
	00 00		 cmp	 QWORD PTR i$[rsp], 256	; 00000100H
  00575	7d 2f		 jge	 SHORT $LN10@bytes_tran

; 1632 :             trans_table[i] = Py_CHARMASK(table[i]);

  00577	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0057f	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00587	48 03 c8	 add	 rcx, rax
  0058a	48 8b c1	 mov	 rax, rcx
  0058d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00590	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00595	0f b6 c0	 movzx	 eax, al
  00598	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  005a0	89 44 8c 30	 mov	 DWORD PTR trans_table$[rsp+rcx*4], eax
  005a4	eb b0		 jmp	 SHORT $LN11@bytes_tran
$LN10@bytes_tran:
$LN13@bytes_tran:

; 1633 :     }
; 1634 : 
; 1635 :     for (i = 0; i < dellen; i++)

  005a6	48 c7 84 24 50
	04 00 00 00 00
	00 00		 mov	 QWORD PTR i$[rsp], 0
  005b2	eb 13		 jmp	 SHORT $LN9@bytes_tran
$LN8@bytes_tran:
  005b4	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  005bc	48 ff c0	 inc	 rax
  005bf	48 89 84 24 50
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN9@bytes_tran:
  005c7	48 8b 84 24 a0
	04 00 00	 mov	 rax, QWORD PTR dellen$[rsp]
  005cf	48 39 84 24 50
	04 00 00	 cmp	 QWORD PTR i$[rsp], rax
  005d7	7d 2b		 jge	 SHORT $LN7@bytes_tran

; 1636 :         trans_table[(int) Py_CHARMASK(del_table[i])] = -1;

  005d9	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  005e1	48 8b 8c 24 30
	04 00 00	 mov	 rcx, QWORD PTR del_table$[rsp]
  005e9	48 03 c8	 add	 rcx, rax
  005ec	48 8b c1	 mov	 rax, rcx
  005ef	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005f2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005f7	0f b6 c0	 movzx	 eax, al
  005fa	c7 44 84 30 ff
	ff ff ff	 mov	 DWORD PTR trans_table$[rsp+rax*4], -1
  00602	eb b0		 jmp	 SHORT $LN8@bytes_tran
$LN7@bytes_tran:

; 1637 : 
; 1638 :     for (i = inlen; --i >= 0; ) {

  00604	48 8b 84 24 40
	04 00 00	 mov	 rax, QWORD PTR inlen$[rsp]
  0060c	48 89 84 24 50
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN45@bytes_tran:
$LN6@bytes_tran:
  00614	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0061c	48 ff c8	 dec	 rax
  0061f	48 89 84 24 50
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
  00627	48 83 bc 24 50
	04 00 00 00	 cmp	 QWORD PTR i$[rsp], 0
  00630	0f 8c 9d 00 00
	00		 jl	 $LN5@bytes_tran

; 1639 :         c = Py_CHARMASK(*input++);

  00636	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR input$[rsp]
  0063e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00641	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00646	0f b6 c0	 movzx	 eax, al
  00649	48 89 84 24 98
	04 00 00	 mov	 QWORD PTR c$[rsp], rax
  00651	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR input$[rsp]
  00659	48 ff c0	 inc	 rax
  0065c	48 89 84 24 68
	04 00 00	 mov	 QWORD PTR input$[rsp], rax

; 1640 :         if (trans_table[c] != -1)

  00664	48 8b 84 24 98
	04 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0066c	83 7c 84 30 ff	 cmp	 DWORD PTR trans_table$[rsp+rax*4], -1
  00671	74 4f		 je	 SHORT $LN4@bytes_tran

; 1641 :             if (Py_CHARMASK(*output++ = (char)trans_table[c]) == c)

  00673	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR output$[rsp]
  0067b	48 8b 8c 24 98
	04 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00683	0f b6 4c 8c 30	 movzx	 ecx, BYTE PTR trans_table$[rsp+rcx*4]
  00688	88 08		 mov	 BYTE PTR [rax], cl
  0068a	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR output$[rsp]
  00692	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00695	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0069a	0f b6 c0	 movzx	 eax, al
  0069d	48 8b 8c 24 98
	04 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006a5	48 8b 94 24 60
	04 00 00	 mov	 rdx, QWORD PTR output$[rsp]
  006ad	48 ff c2	 inc	 rdx
  006b0	48 89 94 24 60
	04 00 00	 mov	 QWORD PTR output$[rsp], rdx
  006b8	48 3b c1	 cmp	 rax, rcx
  006bb	75 05		 jne	 SHORT $LN3@bytes_tran

; 1642 :                 continue;

  006bd	e9 52 ff ff ff	 jmp	 $LN6@bytes_tran
$LN3@bytes_tran:
$LN4@bytes_tran:

; 1643 :         changed = 1;

  006c2	48 c7 84 24 48
	04 00 00 01 00
	00 00		 mov	 QWORD PTR changed$[rsp], 1

; 1644 :     }

  006ce	e9 41 ff ff ff	 jmp	 $LN45@bytes_tran
$LN5@bytes_tran:

; 1645 :     if (!changed && PyBytes_CheckExact(input_obj)) {

  006d3	48 83 bc 24 48
	04 00 00 00	 cmp	 QWORD PTR changed$[rsp], 0
  006dc	75 39		 jne	 SHORT $LN2@bytes_tran
  006de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  006e5	48 8b 8c 24 90
	04 00 00	 mov	 rcx, QWORD PTR input_obj$[rsp]
  006ed	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  006f1	75 24		 jne	 SHORT $LN2@bytes_tran

; 1646 :         Py_DECREF(result);

  006f3	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  006fb	e8 00 00 00 00	 call	 _Py_DecRef

; 1647 :         Py_INCREF(input_obj);

  00700	48 8b 8c 24 90
	04 00 00	 mov	 rcx, QWORD PTR input_obj$[rsp]
  00708	e8 00 00 00 00	 call	 _Py_IncRef

; 1648 :         return input_obj;

  0070d	48 8b 84 24 90
	04 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  00715	eb 39		 jmp	 SHORT $LN37@bytes_tran
$LN2@bytes_tran:

; 1649 :     }
; 1650 :     /* Fix the size of the resulting string */
; 1651 :     if (inlen > 0)

  00717	48 83 bc 24 40
	04 00 00 00	 cmp	 QWORD PTR inlen$[rsp], 0
  00720	7e 26		 jle	 SHORT $LN1@bytes_tran

; 1652 :         _PyBytes_Resize(&result, output - output_start);

  00722	48 8b 84 24 70
	04 00 00	 mov	 rax, QWORD PTR output_start$[rsp]
  0072a	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR output$[rsp]
  00732	48 2b c8	 sub	 rcx, rax
  00735	48 8b c1	 mov	 rax, rcx
  00738	48 8b d0	 mov	 rdx, rax
  0073b	48 8d 8c 24 88
	04 00 00	 lea	 rcx, QWORD PTR result$[rsp]
  00743	e8 00 00 00 00	 call	 _PyBytes_Resize
$LN1@bytes_tran:

; 1653 :     return result;

  00748	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN37@bytes_tran:

; 1654 : }

  00750	48 81 c4 b8 04
	00 00		 add	 rsp, 1208		; 000004b8H
  00757	c3		 ret	 0
bytes_translate ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_maketrans:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_maketrans DD imagerel bytes_maketrans
	DD	imagerel bytes_maketrans+29
	DD	imagerel $unwind$bytes_maketrans
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_maketrans DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_maketrans
_TEXT	SEGMENT
null$ = 48
args$ = 56
bytes_maketrans PROC					; COMDAT

; 1659 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1660 :     return _Py_bytes_maketrans(args);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  00013	e8 00 00 00 00	 call	 _Py_bytes_maketrans

; 1661 : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
bytes_maketrans ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@PEHKHMMO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAo?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@BAKIOBBJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAo?$AAm?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_replace DD imagerel bytes_replace
	DD	imagerel bytes_replace+510
	DD	imagerel $unwind$bytes_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_replace DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_1CE@PEHKHMMO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAo?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@PEHKHMMO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAo?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 't', 00H, 'o', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@BAKIOBBJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAo?$AAm?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@BAKIOBBJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAo?$AAm?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@
CONST	SEGMENT
??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@ DB 'OO|n:replace', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_replace
_TEXT	SEGMENT
count$ = 48
to$ = 56
to_len$ = 64
from_len$ = 72
from_s$ = 80
from$ = 88
to_s$ = 96
self$ = 128
args$ = 136
bytes_replace PROC					; COMDAT

; 2164 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2165 :     Py_ssize_t count = -1;

  0000e	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR count$[rsp], -1

; 2166 :     PyObject *from, *to;
; 2167 :     const char *from_s, *to_s;
; 2168 :     Py_ssize_t from_len, to_len;
; 2169 : 
; 2170 :     if (!PyArg_ParseTuple(args, "OO|n:replace", &from, &to, &count))

  00017	48 8d 44 24 30	 lea	 rax, QWORD PTR count$[rsp]
  0001c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00021	4c 8d 4c 24 38	 lea	 r9, QWORD PTR to$[rsp]
  00026	4c 8d 44 24 58	 lea	 r8, QWORD PTR from$[rsp]
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@
  00032	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0003a	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003f	85 c0		 test	 eax, eax
  00041	75 07		 jne	 SHORT $LN7@bytes_repl

; 2171 :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 af 01 00 00	 jmp	 $LN8@bytes_repl
$LN7@bytes_repl:

; 2172 : 
; 2173 :     if (PyBytes_Check(from)) {

  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR from$[rsp]
  0004f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00053	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00059	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0005e	85 c0		 test	 eax, eax
  00060	0f 84 86 00 00
	00		 je	 $LN6@bytes_repl

; 2174 :         from_s = PyBytes_AS_STRING(from);

  00066	48 8b 44 24 58	 mov	 rax, QWORD PTR from$[rsp]
  0006b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00075	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0007a	85 c0		 test	 eax, eax
  0007c	75 1c		 jne	 SHORT $LN10@bytes_repl
  0007e	41 b8 7e 08 00
	00		 mov	 r8d, 2174		; 0000087eH
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@BAKIOBBJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAo?$AAm?$AA?$CJ?$AA?$AA@
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00098	33 c0		 xor	 eax, eax
$LN10@bytes_repl:
  0009a	48 8b 44 24 58	 mov	 rax, QWORD PTR from$[rsp]
  0009f	48 83 c0 78	 add	 rax, 120		; 00000078H
  000a3	48 89 44 24 50	 mov	 QWORD PTR from_s$[rsp], rax

; 2175 :         from_len = PyBytes_GET_SIZE(from);

  000a8	48 8b 44 24 58	 mov	 rax, QWORD PTR from$[rsp]
  000ad	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000b1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000b7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000bc	85 c0		 test	 eax, eax
  000be	75 1c		 jne	 SHORT $LN11@bytes_repl
  000c0	41 b8 7f 08 00
	00		 mov	 r8d, 2175		; 0000087fH
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@BAKIOBBJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAo?$AAm?$AA?$CJ?$AA?$AA@
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000da	33 c0		 xor	 eax, eax
$LN11@bytes_repl:
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR from$[rsp]
  000e1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000e5	48 89 44 24 48	 mov	 QWORD PTR from_len$[rsp], rax
  000ea	eb 1f		 jmp	 SHORT $LN5@bytes_repl
$LN6@bytes_repl:

; 2176 :     }
; 2177 :     else if (PyObject_AsCharBuffer(from, &from_s, &from_len))

  000ec	4c 8d 44 24 48	 lea	 r8, QWORD PTR from_len$[rsp]
  000f1	48 8d 54 24 50	 lea	 rdx, QWORD PTR from_s$[rsp]
  000f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR from$[rsp]
  000fb	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  00100	85 c0		 test	 eax, eax
  00102	74 07		 je	 SHORT $LN4@bytes_repl

; 2178 :         return NULL;

  00104	33 c0		 xor	 eax, eax
  00106	e9 ee 00 00 00	 jmp	 $LN8@bytes_repl
$LN4@bytes_repl:
$LN5@bytes_repl:

; 2179 : 
; 2180 :     if (PyBytes_Check(to)) {

  0010b	48 8b 44 24 38	 mov	 rax, QWORD PTR to$[rsp]
  00110	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00114	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0011a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0011f	85 c0		 test	 eax, eax
  00121	0f 84 86 00 00
	00		 je	 $LN3@bytes_repl

; 2181 :         to_s = PyBytes_AS_STRING(to);

  00127	48 8b 44 24 38	 mov	 rax, QWORD PTR to$[rsp]
  0012c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00130	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00136	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 1c		 jne	 SHORT $LN12@bytes_repl
  0013f	41 b8 85 08 00
	00		 mov	 r8d, 2181		; 00000885H
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@PEHKHMMO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAo?$AA?$CJ?$AA?$AA@
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00159	33 c0		 xor	 eax, eax
$LN12@bytes_repl:
  0015b	48 8b 44 24 38	 mov	 rax, QWORD PTR to$[rsp]
  00160	48 83 c0 78	 add	 rax, 120		; 00000078H
  00164	48 89 44 24 60	 mov	 QWORD PTR to_s$[rsp], rax

; 2182 :         to_len = PyBytes_GET_SIZE(to);

  00169	48 8b 44 24 38	 mov	 rax, QWORD PTR to$[rsp]
  0016e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00172	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00178	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0017d	85 c0		 test	 eax, eax
  0017f	75 1c		 jne	 SHORT $LN13@bytes_repl
  00181	41 b8 86 08 00
	00		 mov	 r8d, 2182		; 00000886H
  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@PEHKHMMO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAo?$AA?$CJ?$AA?$AA@
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0019b	33 c0		 xor	 eax, eax
$LN13@bytes_repl:
  0019d	48 8b 44 24 38	 mov	 rax, QWORD PTR to$[rsp]
  001a2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001a6	48 89 44 24 40	 mov	 QWORD PTR to_len$[rsp], rax
  001ab	eb 1c		 jmp	 SHORT $LN2@bytes_repl
$LN3@bytes_repl:

; 2183 :     }
; 2184 :     else if (PyObject_AsCharBuffer(to, &to_s, &to_len))

  001ad	4c 8d 44 24 40	 lea	 r8, QWORD PTR to_len$[rsp]
  001b2	48 8d 54 24 60	 lea	 rdx, QWORD PTR to_s$[rsp]
  001b7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR to$[rsp]
  001bc	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  001c1	85 c0		 test	 eax, eax
  001c3	74 04		 je	 SHORT $LN1@bytes_repl

; 2185 :         return NULL;

  001c5	33 c0		 xor	 eax, eax
  001c7	eb 30		 jmp	 SHORT $LN8@bytes_repl
$LN1@bytes_repl:
$LN2@bytes_repl:

; 2186 : 
; 2187 :     return (PyObject *)replace((PyBytesObject *) self,
; 2188 :                                from_s, from_len,
; 2189 :                                to_s, to_len, count);

  001c9	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  001ce	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d3	48 8b 44 24 40	 mov	 rax, QWORD PTR to_len$[rsp]
  001d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001dd	4c 8b 4c 24 60	 mov	 r9, QWORD PTR to_s$[rsp]
  001e2	4c 8b 44 24 48	 mov	 r8, QWORD PTR from_len$[rsp]
  001e7	48 8b 54 24 50	 mov	 rdx, QWORD PTR from_s$[rsp]
  001ec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001f4	e8 00 00 00 00	 call	 replace
$LN8@bytes_repl:

; 2190 : }

  001f9	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001fd	c3		 ret	 0
bytes_replace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace DD imagerel replace
	DD	imagerel replace+574
	DD	imagerel $unwind$replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace
_TEXT	SEGMENT
self$ = 64
from_s$ = 72
from_len$ = 80
to_s$ = 88
to_len$ = 96
maxcount$ = 104
replace	PROC						; COMDAT

; 2087 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2088 :     if (maxcount < 0) {

  00018	48 83 7c 24 68
	00		 cmp	 QWORD PTR maxcount$[rsp], 0
  0001e	7d 11		 jge	 SHORT $LN16@replace

; 2089 :         maxcount = PY_SSIZE_T_MAX;

  00020	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002a	48 89 44 24 68	 mov	 QWORD PTR maxcount$[rsp], rax
  0002f	eb 57		 jmp	 SHORT $LN15@replace
$LN16@replace:

; 2090 :     } else if (maxcount == 0 || PyBytes_GET_SIZE(self) == 0) {

  00031	48 83 7c 24 68
	00		 cmp	 QWORD PTR maxcount$[rsp], 0
  00037	74 40		 je	 SHORT $LN13@replace
  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00042	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00048	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0004d	85 c0		 test	 eax, eax
  0004f	75 1c		 jne	 SHORT $LN19@replace
  00051	41 b8 2a 08 00
	00		 mov	 r8d, 2090		; 0000082aH
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006b	33 c0		 xor	 eax, eax
$LN19@replace:
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00072	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00077	75 0f		 jne	 SHORT $LN14@replace
$LN13@replace:

; 2091 :         /* nothing to do; return the original string */
; 2092 :         return return_self(self);

  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0007e	e8 00 00 00 00	 call	 return_self
  00083	e9 b1 01 00 00	 jmp	 $LN17@replace
$LN14@replace:
$LN15@replace:

; 2093 :     }
; 2094 : 
; 2095 :     if (maxcount == 0 ||
; 2096 :         (from_len == 0 && to_len == 0)) {

  00088	48 83 7c 24 68
	00		 cmp	 QWORD PTR maxcount$[rsp], 0
  0008e	74 10		 je	 SHORT $LN11@replace
  00090	48 83 7c 24 50
	00		 cmp	 QWORD PTR from_len$[rsp], 0
  00096	75 17		 jne	 SHORT $LN12@replace
  00098	48 83 7c 24 60
	00		 cmp	 QWORD PTR to_len$[rsp], 0
  0009e	75 0f		 jne	 SHORT $LN12@replace
$LN11@replace:

; 2097 :         /* nothing to do; return the original string */
; 2098 :         return return_self(self);

  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000a5	e8 00 00 00 00	 call	 return_self
  000aa	e9 8a 01 00 00	 jmp	 $LN17@replace
$LN12@replace:

; 2099 :     }
; 2100 : 
; 2101 :     /* Handle zero-length special cases */
; 2102 : 
; 2103 :     if (from_len == 0) {

  000af	48 83 7c 24 50
	00		 cmp	 QWORD PTR from_len$[rsp], 0
  000b5	75 1e		 jne	 SHORT $LN10@replace

; 2104 :         /* insert the 'to' string everywhere.   */
; 2105 :         /*    >>> "Python".replace("", ".")     */
; 2106 :         /*    '.P.y.t.h.o.n.'                   */
; 2107 :         return replace_interleave(self, to_s, to_len, maxcount);

  000b7	4c 8b 4c 24 68	 mov	 r9, QWORD PTR maxcount$[rsp]
  000bc	4c 8b 44 24 60	 mov	 r8, QWORD PTR to_len$[rsp]
  000c1	48 8b 54 24 58	 mov	 rdx, QWORD PTR to_s$[rsp]
  000c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000cb	e8 00 00 00 00	 call	 replace_interleave
  000d0	e9 64 01 00 00	 jmp	 $LN17@replace
$LN10@replace:

; 2108 :     }
; 2109 : 
; 2110 :     /* Except for "".replace("", "A") == "A" there is no way beyond this */
; 2111 :     /* point for an empty self string to generate a non-empty string */
; 2112 :     /* Special case so the remaining code always gets a non-empty string */
; 2113 :     if (PyBytes_GET_SIZE(self) == 0) {

  000d5	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000da	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000de	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000e4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 1c		 jne	 SHORT $LN20@replace
  000ed	41 b8 41 08 00
	00		 mov	 r8d, 2113		; 00000841H
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00107	33 c0		 xor	 eax, eax
$LN20@replace:
  00109	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0010e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00113	75 0f		 jne	 SHORT $LN9@replace

; 2114 :         return return_self(self);

  00115	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0011a	e8 00 00 00 00	 call	 return_self
  0011f	e9 15 01 00 00	 jmp	 $LN17@replace
$LN9@replace:

; 2115 :     }
; 2116 : 
; 2117 :     if (to_len == 0) {

  00124	48 83 7c 24 60
	00		 cmp	 QWORD PTR to_len$[rsp], 0
  0012a	75 44		 jne	 SHORT $LN8@replace

; 2118 :         /* delete all occurrences of 'from' string */
; 2119 :         if (from_len == 1) {

  0012c	48 83 7c 24 50
	01		 cmp	 QWORD PTR from_len$[rsp], 1
  00132	75 1e		 jne	 SHORT $LN7@replace

; 2120 :             return replace_delete_single_character(
; 2121 :                 self, from_s[0], maxcount);

  00134	4c 8b 44 24 68	 mov	 r8, QWORD PTR maxcount$[rsp]
  00139	48 8b 44 24 48	 mov	 rax, QWORD PTR from_s$[rsp]
  0013e	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00146	e8 00 00 00 00	 call	 replace_delete_single_character
  0014b	e9 e9 00 00 00	 jmp	 $LN17@replace

; 2122 :         } else {

  00150	eb 1e		 jmp	 SHORT $LN6@replace
$LN7@replace:

; 2123 :             return replace_delete_substring(self, from_s,
; 2124 :                                             from_len, maxcount);

  00152	4c 8b 4c 24 68	 mov	 r9, QWORD PTR maxcount$[rsp]
  00157	4c 8b 44 24 50	 mov	 r8, QWORD PTR from_len$[rsp]
  0015c	48 8b 54 24 48	 mov	 rdx, QWORD PTR from_s$[rsp]
  00161	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00166	e8 00 00 00 00	 call	 replace_delete_substring
  0016b	e9 c9 00 00 00	 jmp	 $LN17@replace
$LN6@replace:
$LN8@replace:

; 2125 :         }
; 2126 :     }
; 2127 : 
; 2128 :     /* Handle special case where both strings have the same length */
; 2129 : 
; 2130 :     if (from_len == to_len) {

  00170	48 8b 44 24 60	 mov	 rax, QWORD PTR to_len$[rsp]
  00175	48 39 44 24 50	 cmp	 QWORD PTR from_len$[rsp], rax
  0017a	75 5e		 jne	 SHORT $LN5@replace

; 2131 :         if (from_len == 1) {

  0017c	48 83 7c 24 50
	01		 cmp	 QWORD PTR from_len$[rsp], 1
  00182	75 27		 jne	 SHORT $LN4@replace

; 2132 :             return replace_single_character_in_place(
; 2133 :                 self,
; 2134 :                 from_s[0],
; 2135 :                 to_s[0],
; 2136 :                 maxcount);

  00184	4c 8b 4c 24 68	 mov	 r9, QWORD PTR maxcount$[rsp]
  00189	48 8b 44 24 58	 mov	 rax, QWORD PTR to_s$[rsp]
  0018e	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  00192	48 8b 44 24 48	 mov	 rax, QWORD PTR from_s$[rsp]
  00197	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0019a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0019f	e8 00 00 00 00	 call	 replace_single_character_in_place
  001a4	e9 90 00 00 00	 jmp	 $LN17@replace

; 2137 :         } else {

  001a9	eb 2f		 jmp	 SHORT $LN3@replace
$LN4@replace:

; 2138 :             return replace_substring_in_place(
; 2139 :                 self, from_s, from_len, to_s, to_len,
; 2140 :                 maxcount);

  001ab	48 8b 44 24 68	 mov	 rax, QWORD PTR maxcount$[rsp]
  001b0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b5	48 8b 44 24 60	 mov	 rax, QWORD PTR to_len$[rsp]
  001ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bf	4c 8b 4c 24 58	 mov	 r9, QWORD PTR to_s$[rsp]
  001c4	4c 8b 44 24 50	 mov	 r8, QWORD PTR from_len$[rsp]
  001c9	48 8b 54 24 48	 mov	 rdx, QWORD PTR from_s$[rsp]
  001ce	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  001d3	e8 00 00 00 00	 call	 replace_substring_in_place
  001d8	eb 5f		 jmp	 SHORT $LN17@replace
$LN3@replace:
$LN5@replace:

; 2141 :         }
; 2142 :     }
; 2143 : 
; 2144 :     /* Otherwise use the more generic algorithms */
; 2145 :     if (from_len == 1) {

  001da	48 83 7c 24 50
	01		 cmp	 QWORD PTR from_len$[rsp], 1
  001e0	75 2a		 jne	 SHORT $LN2@replace

; 2146 :         return replace_single_character(self, from_s[0],
; 2147 :                                         to_s, to_len, maxcount);

  001e2	48 8b 44 24 68	 mov	 rax, QWORD PTR maxcount$[rsp]
  001e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ec	4c 8b 4c 24 60	 mov	 r9, QWORD PTR to_len$[rsp]
  001f1	4c 8b 44 24 58	 mov	 r8, QWORD PTR to_s$[rsp]
  001f6	48 8b 44 24 48	 mov	 rax, QWORD PTR from_s$[rsp]
  001fb	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  001fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00203	e8 00 00 00 00	 call	 replace_single_character
  00208	eb 2f		 jmp	 SHORT $LN17@replace

; 2148 :     } else {

  0020a	eb 2d		 jmp	 SHORT $LN1@replace
$LN2@replace:

; 2149 :         /* len('from')>=2, len('to')>=1 */
; 2150 :         return replace_substring(self, from_s, from_len, to_s, to_len,
; 2151 :                                  maxcount);

  0020c	48 8b 44 24 68	 mov	 rax, QWORD PTR maxcount$[rsp]
  00211	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00216	48 8b 44 24 60	 mov	 rax, QWORD PTR to_len$[rsp]
  0021b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00220	4c 8b 4c 24 58	 mov	 r9, QWORD PTR to_s$[rsp]
  00225	4c 8b 44 24 50	 mov	 r8, QWORD PTR from_len$[rsp]
  0022a	48 8b 54 24 48	 mov	 rdx, QWORD PTR from_s$[rsp]
  0022f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00234	e8 00 00 00 00	 call	 replace_substring
$LN1@replace:
$LN17@replace:

; 2152 :     }
; 2153 : }

  00239	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0023d	c3		 ret	 0
replace	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$return_self DD imagerel return_self
	DD	imagerel return_self+182
	DD	imagerel $unwind$return_self
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$return_self DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT return_self
_TEXT	SEGMENT
self$ = 48
return_self PROC					; COMDAT

; 1672 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1673 :     if (PyBytes_CheckExact(self)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	75 14		 jne	 SHORT $LN1@return_sel

; 1674 :         Py_INCREF(self);

  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00020	e8 00 00 00 00	 call	 _Py_IncRef

; 1675 :         return self;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0002a	e9 82 00 00 00	 jmp	 $LN2@return_sel
$LN1@return_sel:

; 1676 :     }
; 1677 :     return (PyBytesObject *)PyBytes_FromStringAndSize(
; 1678 :         PyBytes_AS_STRING(self),
; 1679 :         PyBytes_GET_SIZE(self));

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00043	85 c0		 test	 eax, eax
  00045	75 1c		 jne	 SHORT $LN4@return_sel
  00047	41 b8 8f 06 00
	00		 mov	 r8d, 1679		; 0000068fH
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN4@return_sel:
  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00068	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00072	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN5@return_sel
  0007b	41 b8 8e 06 00
	00		 mov	 r8d, 1678		; 0000068eH
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00095	33 c0		 xor	 eax, eax
$LN5@return_sel:
  00097	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 c0 78	 add	 rax, 120		; 00000078H
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  000a5	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
$LN2@return_sel:

; 1680 : }

  000b1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b5	c3		 ret	 0
return_self ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@DIPAALHI@replacement?5bytes?5are?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_interleave DD imagerel replace_interleave
	DD	imagerel replace_interleave+1135
	DD	imagerel $unwind$replace_interleave
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_interleave DD 021b01H
	DD	019011bH
xdata	ENDS
;	COMDAT ??_C@_0BP@DIPAALHI@replacement?5bytes?5are?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BP@DIPAALHI@replacement?5bytes?5are?5too?5long?$AA@ DB 'replacemen'
	DB	't bytes are too long', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT replace_interleave
_TEXT	SEGMENT
result_len$ = 32
count$ = 40
i$ = 48
self_len$ = 56
result_s$ = 64
result$ = 72
self_s$ = 80
t_$23283 = 88
s_$23285 = 96
i_$23281 = 104
n_$23282 = 112
t_$23300 = 120
s_$23302 = 128
i_$23298 = 136
n_$23299 = 144
t_$23314 = 152
s_$23316 = 160
i_$23312 = 168
n_$23313 = 176
self$ = 208
to_s$ = 216
to_len$ = 224
maxcount$ = 232
replace_interleave PROC					; COMDAT

; 1706 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1707 :     char *self_s, *result_s;
; 1708 :     Py_ssize_t self_len, result_len;
; 1709 :     Py_ssize_t count, i;
; 1710 :     PyBytesObject *result;
; 1711 : 
; 1712 :     self_len = PyBytes_GET_SIZE(self);

  0001b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00023	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00027	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00032	85 c0		 test	 eax, eax
  00034	75 1c		 jne	 SHORT $LN34@replace_in
  00036	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN34@replace_in:
  00052	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0005e	48 89 44 24 38	 mov	 QWORD PTR self_len$[rsp], rax

; 1713 : 
; 1714 :     /* 1 at the end plus 1 after every character;
; 1715 :        count = min(maxcount, self_len + 1) */
; 1716 :     if (maxcount <= self_len)

  00063	48 8b 44 24 38	 mov	 rax, QWORD PTR self_len$[rsp]
  00068	48 39 84 24 e8
	00 00 00	 cmp	 QWORD PTR maxcount$[rsp], rax
  00070	7f 0f		 jg	 SHORT $LN31@replace_in

; 1717 :         count = maxcount;

  00072	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0007a	48 89 44 24 28	 mov	 QWORD PTR count$[rsp], rax

; 1718 :     else

  0007f	eb 0d		 jmp	 SHORT $LN30@replace_in
$LN31@replace_in:

; 1719 :         /* Can't overflow: self_len + 1 <= maxcount <= PY_SSIZE_T_MAX. */
; 1720 :         count = self_len + 1;

  00081	48 8b 44 24 38	 mov	 rax, QWORD PTR self_len$[rsp]
  00086	48 ff c0	 inc	 rax
  00089	48 89 44 24 28	 mov	 QWORD PTR count$[rsp], rax
$LN30@replace_in:

; 1721 : 
; 1722 :     /* Check for overflow */
; 1723 :     /*   result_len = count * to_len + self_len; */
; 1724 :     assert(count > 0);

  0008e	48 83 7c 24 28
	00		 cmp	 QWORD PTR count$[rsp], 0
  00094	7f 1c		 jg	 SHORT $LN35@replace_in
  00096	41 b8 bc 06 00
	00		 mov	 r8d, 1724		; 000006bcH
  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b0	33 c0		 xor	 eax, eax
$LN35@replace_in:

; 1725 :     if (to_len > (PY_SSIZE_T_MAX - self_len) / count) {

  000b2	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000bc	48 2b 44 24 38	 sub	 rax, QWORD PTR self_len$[rsp]
  000c1	48 99		 cdq
  000c3	48 f7 7c 24 28	 idiv	 QWORD PTR count$[rsp]
  000c8	48 39 84 24 e0
	00 00 00	 cmp	 QWORD PTR to_len$[rsp], rax
  000d0	7e 1a		 jle	 SHORT $LN29@replace_in

; 1726 :         PyErr_SetString(PyExc_OverflowError,
; 1727 :                         "replacement bytes are too long");

  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@DIPAALHI@replacement?5bytes?5are?5too?5long?$AA@
  000d9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000e0	e8 00 00 00 00	 call	 PyErr_SetString

; 1728 :         return NULL;

  000e5	33 c0		 xor	 eax, eax
  000e7	e9 7b 03 00 00	 jmp	 $LN32@replace_in
$LN29@replace_in:

; 1729 :     }
; 1730 :     result_len = count * to_len + self_len;

  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  000f1	48 0f af 84 24
	e0 00 00 00	 imul	 rax, QWORD PTR to_len$[rsp]
  000fa	48 03 44 24 38	 add	 rax, QWORD PTR self_len$[rsp]
  000ff	48 89 44 24 20	 mov	 QWORD PTR result_len$[rsp], rax

; 1731 : 
; 1732 :     if (! (result = (PyBytesObject *)
; 1733 :                      PyBytes_FromStringAndSize(NULL, result_len)) )

  00104	48 8b 54 24 20	 mov	 rdx, QWORD PTR result_len$[rsp]
  00109	33 c9		 xor	 ecx, ecx
  0010b	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00110	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax
  00115	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  0011b	75 07		 jne	 SHORT $LN28@replace_in

; 1734 :         return NULL;

  0011d	33 c0		 xor	 eax, eax
  0011f	e9 43 03 00 00	 jmp	 $LN32@replace_in
$LN28@replace_in:

; 1735 : 
; 1736 :     self_s = PyBytes_AS_STRING(self);

  00124	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0012c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00130	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00136	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 1c		 jne	 SHORT $LN36@replace_in
  0013f	41 b8 c8 06 00
	00		 mov	 r8d, 1736		; 000006c8H
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00159	33 c0		 xor	 eax, eax
$LN36@replace_in:
  0015b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00163	48 83 c0 78	 add	 rax, 120		; 00000078H
  00167	48 89 44 24 50	 mov	 QWORD PTR self_s$[rsp], rax

; 1737 :     result_s = PyBytes_AS_STRING(result);

  0016c	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00171	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00175	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0017b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00180	85 c0		 test	 eax, eax
  00182	75 1c		 jne	 SHORT $LN37@replace_in
  00184	41 b8 c9 06 00
	00		 mov	 r8d, 1737		; 000006c9H
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0019e	33 c0		 xor	 eax, eax
$LN37@replace_in:
  001a0	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  001a5	48 83 c0 78	 add	 rax, 120		; 00000078H
  001a9	48 89 44 24 40	 mov	 QWORD PTR result_s$[rsp], rax
$LN27@replace_in:

; 1738 : 
; 1739 :     /* TODO: special case single character, which doesn't need memcpy */
; 1740 : 
; 1741 :     /* Lay the first one down (guaranteed this will occur) */
; 1742 :     Py_MEMCPY(result_s, to_s, to_len);

  001ae	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  001b6	48 89 44 24 70	 mov	 QWORD PTR n_$23282[rsp], rax
  001bb	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  001c0	48 89 44 24 58	 mov	 QWORD PTR t_$23283[rsp], rax
  001c5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  001cd	48 89 44 24 60	 mov	 QWORD PTR s_$23285[rsp], rax
  001d2	48 83 7c 24 70
	10		 cmp	 QWORD PTR n_$23282[rsp], 16
  001d8	72 16		 jb	 SHORT $LN24@replace_in
  001da	4c 8b 44 24 70	 mov	 r8, QWORD PTR n_$23282[rsp]
  001df	48 8b 54 24 60	 mov	 rdx, QWORD PTR s_$23285[rsp]
  001e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t_$23283[rsp]
  001e9	e8 00 00 00 00	 call	 memcpy
  001ee	eb 4b		 jmp	 SHORT $LN23@replace_in
$LN24@replace_in:
  001f0	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR i_$23281[rsp], 0
  001f9	eb 0d		 jmp	 SHORT $LN22@replace_in
$LN21@replace_in:
  001fb	48 8b 44 24 68	 mov	 rax, QWORD PTR i_$23281[rsp]
  00200	48 ff c0	 inc	 rax
  00203	48 89 44 24 68	 mov	 QWORD PTR i_$23281[rsp], rax
$LN22@replace_in:
  00208	48 8b 44 24 70	 mov	 rax, QWORD PTR n_$23282[rsp]
  0020d	48 39 44 24 68	 cmp	 QWORD PTR i_$23281[rsp], rax
  00212	73 27		 jae	 SHORT $LN20@replace_in
  00214	48 8b 44 24 68	 mov	 rax, QWORD PTR i_$23281[rsp]
  00219	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t_$23283[rsp]
  0021e	48 03 c8	 add	 rcx, rax
  00221	48 8b c1	 mov	 rax, rcx
  00224	48 8b 4c 24 68	 mov	 rcx, QWORD PTR i_$23281[rsp]
  00229	48 8b 54 24 60	 mov	 rdx, QWORD PTR s_$23285[rsp]
  0022e	48 03 d1	 add	 rdx, rcx
  00231	48 8b ca	 mov	 rcx, rdx
  00234	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00237	88 08		 mov	 BYTE PTR [rax], cl
  00239	eb c0		 jmp	 SHORT $LN21@replace_in
$LN20@replace_in:
$LN23@replace_in:
  0023b	33 c0		 xor	 eax, eax
  0023d	85 c0		 test	 eax, eax
  0023f	0f 85 69 ff ff
	ff		 jne	 $LN27@replace_in

; 1743 :     result_s += to_len;

  00245	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  0024d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result_s$[rsp]
  00252	48 03 c8	 add	 rcx, rax
  00255	48 8b c1	 mov	 rax, rcx
  00258	48 89 44 24 40	 mov	 QWORD PTR result_s$[rsp], rax

; 1744 :     count -= 1;

  0025d	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  00262	48 ff c8	 dec	 rax
  00265	48 89 44 24 28	 mov	 QWORD PTR count$[rsp], rax

; 1745 : 
; 1746 :     for (i=0; i<count; i++) {

  0026a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00273	eb 0d		 jmp	 SHORT $LN19@replace_in
$LN18@replace_in:
  00275	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0027a	48 ff c0	 inc	 rax
  0027d	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN19@replace_in:
  00282	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  00287	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0028c	0f 8d 04 01 00
	00		 jge	 $LN17@replace_in

; 1747 :         *result_s++ = *self_s++;

  00292	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  00297	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self_s$[rsp]
  0029c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0029f	88 08		 mov	 BYTE PTR [rax], cl
  002a1	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  002a6	48 ff c0	 inc	 rax
  002a9	48 89 44 24 40	 mov	 QWORD PTR result_s$[rsp], rax
  002ae	48 8b 44 24 50	 mov	 rax, QWORD PTR self_s$[rsp]
  002b3	48 ff c0	 inc	 rax
  002b6	48 89 44 24 50	 mov	 QWORD PTR self_s$[rsp], rax
$LN16@replace_in:

; 1748 :         Py_MEMCPY(result_s, to_s, to_len);

  002bb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  002c3	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR n_$23299[rsp], rax
  002cb	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  002d0	48 89 44 24 78	 mov	 QWORD PTR t_$23300[rsp], rax
  002d5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  002dd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s_$23302[rsp], rax
  002e5	48 83 bc 24 90
	00 00 00 10	 cmp	 QWORD PTR n_$23299[rsp], 16
  002ee	72 1c		 jb	 SHORT $LN13@replace_in
  002f0	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR n_$23299[rsp]
  002f8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s_$23302[rsp]
  00300	48 8b 4c 24 78	 mov	 rcx, QWORD PTR t_$23300[rsp]
  00305	e8 00 00 00 00	 call	 memcpy
  0030a	eb 63		 jmp	 SHORT $LN12@replace_in
$LN13@replace_in:
  0030c	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23298[rsp], 0
  00318	eb 13		 jmp	 SHORT $LN11@replace_in
$LN10@replace_in:
  0031a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR i_$23298[rsp]
  00322	48 ff c0	 inc	 rax
  00325	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR i_$23298[rsp], rax
$LN11@replace_in:
  0032d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR n_$23299[rsp]
  00335	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR i_$23298[rsp], rax
  0033d	73 30		 jae	 SHORT $LN9@replace_in
  0033f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR i_$23298[rsp]
  00347	48 8b 4c 24 78	 mov	 rcx, QWORD PTR t_$23300[rsp]
  0034c	48 03 c8	 add	 rcx, rax
  0034f	48 8b c1	 mov	 rax, rcx
  00352	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR i_$23298[rsp]
  0035a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s_$23302[rsp]
  00362	48 03 d1	 add	 rdx, rcx
  00365	48 8b ca	 mov	 rcx, rdx
  00368	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0036b	88 08		 mov	 BYTE PTR [rax], cl
  0036d	eb ab		 jmp	 SHORT $LN10@replace_in
$LN9@replace_in:
$LN12@replace_in:
  0036f	33 c0		 xor	 eax, eax
  00371	85 c0		 test	 eax, eax
  00373	0f 85 42 ff ff
	ff		 jne	 $LN16@replace_in

; 1749 :         result_s += to_len;

  00379	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00381	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result_s$[rsp]
  00386	48 03 c8	 add	 rcx, rax
  00389	48 8b c1	 mov	 rax, rcx
  0038c	48 89 44 24 40	 mov	 QWORD PTR result_s$[rsp], rax

; 1750 :     }

  00391	e9 df fe ff ff	 jmp	 $LN18@replace_in
$LN17@replace_in:
$LN8@replace_in:

; 1751 : 
; 1752 :     /* Copy the rest of the original string */
; 1753 :     Py_MEMCPY(result_s, self_s, self_len-i);

  00396	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0039b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR self_len$[rsp]
  003a0	48 2b c8	 sub	 rcx, rax
  003a3	48 8b c1	 mov	 rax, rcx
  003a6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR n_$23313[rsp], rax
  003ae	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  003b3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR t_$23314[rsp], rax
  003bb	48 8b 44 24 50	 mov	 rax, QWORD PTR self_s$[rsp]
  003c0	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR s_$23316[rsp], rax
  003c8	48 83 bc 24 b0
	00 00 00 10	 cmp	 QWORD PTR n_$23313[rsp], 16
  003d1	72 1f		 jb	 SHORT $LN5@replace_in
  003d3	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR n_$23313[rsp]
  003db	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s_$23316[rsp]
  003e3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR t_$23314[rsp]
  003eb	e8 00 00 00 00	 call	 memcpy
  003f0	eb 66		 jmp	 SHORT $LN4@replace_in
$LN5@replace_in:
  003f2	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23312[rsp], 0
  003fe	eb 13		 jmp	 SHORT $LN3@replace_in
$LN2@replace_in:
  00400	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR i_$23312[rsp]
  00408	48 ff c0	 inc	 rax
  0040b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR i_$23312[rsp], rax
$LN3@replace_in:
  00413	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR n_$23313[rsp]
  0041b	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR i_$23312[rsp], rax
  00423	73 33		 jae	 SHORT $LN1@replace_in
  00425	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR i_$23312[rsp]
  0042d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR t_$23314[rsp]
  00435	48 03 c8	 add	 rcx, rax
  00438	48 8b c1	 mov	 rax, rcx
  0043b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR i_$23312[rsp]
  00443	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s_$23316[rsp]
  0044b	48 03 d1	 add	 rdx, rcx
  0044e	48 8b ca	 mov	 rcx, rdx
  00451	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00454	88 08		 mov	 BYTE PTR [rax], cl
  00456	eb a8		 jmp	 SHORT $LN2@replace_in
$LN1@replace_in:
$LN4@replace_in:
  00458	33 c0		 xor	 eax, eax
  0045a	85 c0		 test	 eax, eax
  0045c	0f 85 34 ff ff
	ff		 jne	 $LN8@replace_in

; 1754 : 
; 1755 :     return result;

  00462	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
$LN32@replace_in:

; 1756 : }

  00467	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0046e	c3		 ret	 0
replace_interleave ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BM@JMBDMDDM@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_delete_single_character DD imagerel replace_delete_single_character
	DD	imagerel replace_delete_single_character+934
	DD	imagerel $unwind$replace_delete_single_character
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_delete_single_character DD 021501H
	DD	0170115H
xdata	ENDS
;	COMDAT ??_C@_1BM@JMBDMDDM@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@JMBDMDDM@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, '_', 00H
	DB	'l', 00H, 'e', 00H, 'n', 00H, '>', 00H, '=', 00H, '0', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT replace_delete_single_character
_TEXT	SEGMENT
result_len$ = 32
count$ = 40
self_len$ = 48
next$ = 56
end$ = 64
start$ = 72
result_s$ = 80
result$ = 88
self_s$ = 96
t_$23369 = 104
s_$23371 = 112
i_$23367 = 120
n_$23368 = 128
t_$23383 = 136
s_$23385 = 144
i_$23381 = 152
n_$23382 = 160
self$ = 192
from_c$ = 200
maxcount$ = 208
replace_delete_single_character PROC			; COMDAT

; 1763 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1764 :     char *self_s, *result_s;
; 1765 :     char *start, *next, *end;
; 1766 :     Py_ssize_t self_len, result_len;
; 1767 :     Py_ssize_t count;
; 1768 :     PyBytesObject *result;
; 1769 : 
; 1770 :     self_len = PyBytes_GET_SIZE(self);

  00015	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00027	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0002c	85 c0		 test	 eax, eax
  0002e	75 1c		 jne	 SHORT $LN24@replace_de
  00030	41 b8 ea 06 00
	00		 mov	 r8d, 1770		; 000006eaH
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004a	33 c0		 xor	 eax, eax
$LN24@replace_de:
  0004c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00054	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00058	48 89 44 24 30	 mov	 QWORD PTR self_len$[rsp], rax

; 1771 :     self_s = PyBytes_AS_STRING(self);

  0005d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00065	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00069	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0006f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00074	85 c0		 test	 eax, eax
  00076	75 1c		 jne	 SHORT $LN25@replace_de
  00078	41 b8 eb 06 00
	00		 mov	 r8d, 1771		; 000006ebH
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00092	33 c0		 xor	 eax, eax
$LN25@replace_de:
  00094	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 c0 78	 add	 rax, 120		; 00000078H
  000a0	48 89 44 24 60	 mov	 QWORD PTR self_s$[rsp], rax

; 1772 : 
; 1773 :     count = countchar(self_s, self_len, from_c, maxcount);

  000a5	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR maxcount$[rsp]
  000ad	44 0f b6 84 24
	c8 00 00 00	 movzx	 r8d, BYTE PTR from_c$[rsp]
  000b6	48 8b 54 24 30	 mov	 rdx, QWORD PTR self_len$[rsp]
  000bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self_s$[rsp]
  000c0	e8 00 00 00 00	 call	 countchar
  000c5	48 89 44 24 28	 mov	 QWORD PTR count$[rsp], rax

; 1774 :     if (count == 0) {

  000ca	48 83 7c 24 28
	00		 cmp	 QWORD PTR count$[rsp], 0
  000d0	75 12		 jne	 SHORT $LN21@replace_de

; 1775 :         return return_self(self);

  000d2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000da	e8 00 00 00 00	 call	 return_self
  000df	e9 ba 02 00 00	 jmp	 $LN22@replace_de
$LN21@replace_de:

; 1776 :     }
; 1777 : 
; 1778 :     result_len = self_len - count;  /* from_len == 1 */

  000e4	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self_len$[rsp]
  000ee	48 2b c8	 sub	 rcx, rax
  000f1	48 8b c1	 mov	 rax, rcx
  000f4	48 89 44 24 20	 mov	 QWORD PTR result_len$[rsp], rax

; 1779 :     assert(result_len>=0);

  000f9	48 83 7c 24 20
	00		 cmp	 QWORD PTR result_len$[rsp], 0
  000ff	7d 1c		 jge	 SHORT $LN26@replace_de
  00101	41 b8 f3 06 00
	00		 mov	 r8d, 1779		; 000006f3H
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@JMBDMDDM@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0011b	33 c0		 xor	 eax, eax
$LN26@replace_de:

; 1780 : 
; 1781 :     if ( (result = (PyBytesObject *)
; 1782 :                     PyBytes_FromStringAndSize(NULL, result_len)) == NULL)

  0011d	48 8b 54 24 20	 mov	 rdx, QWORD PTR result_len$[rsp]
  00122	33 c9		 xor	 ecx, ecx
  00124	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00129	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax
  0012e	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  00134	75 07		 jne	 SHORT $LN20@replace_de

; 1783 :         return NULL;

  00136	33 c0		 xor	 eax, eax
  00138	e9 61 02 00 00	 jmp	 $LN22@replace_de
$LN20@replace_de:

; 1784 :     result_s = PyBytes_AS_STRING(result);

  0013d	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00142	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00146	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0014c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00151	85 c0		 test	 eax, eax
  00153	75 1c		 jne	 SHORT $LN27@replace_de
  00155	41 b8 f8 06 00
	00		 mov	 r8d, 1784		; 000006f8H
  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0016f	33 c0		 xor	 eax, eax
$LN27@replace_de:
  00171	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00176	48 83 c0 78	 add	 rax, 120		; 00000078H
  0017a	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax

; 1785 : 
; 1786 :     start = self_s;

  0017f	48 8b 44 24 60	 mov	 rax, QWORD PTR self_s$[rsp]
  00184	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1787 :     end = self_s + self_len;

  00189	48 8b 44 24 30	 mov	 rax, QWORD PTR self_len$[rsp]
  0018e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self_s$[rsp]
  00193	48 03 c8	 add	 rcx, rax
  00196	48 8b c1	 mov	 rax, rcx
  00199	48 89 44 24 40	 mov	 QWORD PTR end$[rsp], rax
$LN19@replace_de:

; 1788 :     while (count-- > 0) {

  0019e	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  001a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR count$[rsp]
  001a8	48 ff c9	 dec	 rcx
  001ab	48 89 4c 24 28	 mov	 QWORD PTR count$[rsp], rcx
  001b0	48 85 c0	 test	 rax, rax
  001b3	0f 8e 14 01 00
	00		 jle	 $LN18@replace_de

; 1789 :         next = findchar(start, end-start, from_c);

  001b9	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  001be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  001c3	48 2b c8	 sub	 rcx, rax
  001c6	48 8b c1	 mov	 rax, rcx
  001c9	0f be 8c 24 c8
	00 00 00	 movsx	 ecx, BYTE PTR from_c$[rsp]
  001d1	4c 8b c0	 mov	 r8, rax
  001d4	8b d1		 mov	 edx, ecx
  001d6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  001e1	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 1790 :         if (next == NULL)

  001e6	48 83 7c 24 38
	00		 cmp	 QWORD PTR next$[rsp], 0
  001ec	75 05		 jne	 SHORT $LN17@replace_de

; 1791 :             break;

  001ee	e9 da 00 00 00	 jmp	 $LN18@replace_de
$LN17@replace_de:
$LN16@replace_de:

; 1792 :         Py_MEMCPY(result_s, start, next-start);

  001f3	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  001f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  001fd	48 2b c8	 sub	 rcx, rax
  00200	48 8b c1	 mov	 rax, rcx
  00203	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n_$23368[rsp], rax
  0020b	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  00210	48 89 44 24 68	 mov	 QWORD PTR t_$23369[rsp], rax
  00215	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  0021a	48 89 44 24 70	 mov	 QWORD PTR s_$23371[rsp], rax
  0021f	48 83 bc 24 80
	00 00 00 10	 cmp	 QWORD PTR n_$23368[rsp], 16
  00228	72 19		 jb	 SHORT $LN13@replace_de
  0022a	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR n_$23368[rsp]
  00232	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23371[rsp]
  00237	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23369[rsp]
  0023c	e8 00 00 00 00	 call	 memcpy
  00241	eb 4e		 jmp	 SHORT $LN12@replace_de
$LN13@replace_de:
  00243	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i_$23367[rsp], 0
  0024c	eb 0d		 jmp	 SHORT $LN11@replace_de
$LN10@replace_de:
  0024e	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23367[rsp]
  00253	48 ff c0	 inc	 rax
  00256	48 89 44 24 78	 mov	 QWORD PTR i_$23367[rsp], rax
$LN11@replace_de:
  0025b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n_$23368[rsp]
  00263	48 39 44 24 78	 cmp	 QWORD PTR i_$23367[rsp], rax
  00268	73 27		 jae	 SHORT $LN9@replace_de
  0026a	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23367[rsp]
  0026f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23369[rsp]
  00274	48 03 c8	 add	 rcx, rax
  00277	48 8b c1	 mov	 rax, rcx
  0027a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i_$23367[rsp]
  0027f	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23371[rsp]
  00284	48 03 d1	 add	 rdx, rcx
  00287	48 8b ca	 mov	 rcx, rdx
  0028a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0028d	88 08		 mov	 BYTE PTR [rax], cl
  0028f	eb bd		 jmp	 SHORT $LN10@replace_de
$LN9@replace_de:
$LN12@replace_de:
  00291	33 c0		 xor	 eax, eax
  00293	85 c0		 test	 eax, eax
  00295	0f 85 58 ff ff
	ff		 jne	 $LN16@replace_de

; 1793 :         result_s += (next-start);

  0029b	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  002a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  002a5	48 2b c8	 sub	 rcx, rax
  002a8	48 8b c1	 mov	 rax, rcx
  002ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  002b0	48 03 c8	 add	 rcx, rax
  002b3	48 8b c1	 mov	 rax, rcx
  002b6	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax

; 1794 :         start = next+1;

  002bb	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  002c0	48 ff c0	 inc	 rax
  002c3	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1795 :     }

  002c8	e9 d1 fe ff ff	 jmp	 $LN19@replace_de
$LN18@replace_de:
$LN8@replace_de:

; 1796 :     Py_MEMCPY(result_s, start, end-start);

  002cd	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  002d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  002d7	48 2b c8	 sub	 rcx, rax
  002da	48 8b c1	 mov	 rax, rcx
  002dd	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR n_$23382[rsp], rax
  002e5	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  002ea	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR t_$23383[rsp], rax
  002f2	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  002f7	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR s_$23385[rsp], rax
  002ff	48 83 bc 24 a0
	00 00 00 10	 cmp	 QWORD PTR n_$23382[rsp], 16
  00308	72 1f		 jb	 SHORT $LN5@replace_de
  0030a	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR n_$23382[rsp]
  00312	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23385[rsp]
  0031a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23383[rsp]
  00322	e8 00 00 00 00	 call	 memcpy
  00327	eb 66		 jmp	 SHORT $LN4@replace_de
$LN5@replace_de:
  00329	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23381[rsp], 0
  00335	eb 13		 jmp	 SHORT $LN3@replace_de
$LN2@replace_de:
  00337	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23381[rsp]
  0033f	48 ff c0	 inc	 rax
  00342	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR i_$23381[rsp], rax
$LN3@replace_de:
  0034a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR n_$23382[rsp]
  00352	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR i_$23381[rsp], rax
  0035a	73 33		 jae	 SHORT $LN1@replace_de
  0035c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23381[rsp]
  00364	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23383[rsp]
  0036c	48 03 c8	 add	 rcx, rax
  0036f	48 8b c1	 mov	 rax, rcx
  00372	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR i_$23381[rsp]
  0037a	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23385[rsp]
  00382	48 03 d1	 add	 rdx, rcx
  00385	48 8b ca	 mov	 rcx, rdx
  00388	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0038b	88 08		 mov	 BYTE PTR [rax], cl
  0038d	eb a8		 jmp	 SHORT $LN2@replace_de
$LN1@replace_de:
$LN4@replace_de:
  0038f	33 c0		 xor	 eax, eax
  00391	85 c0		 test	 eax, eax
  00393	0f 85 34 ff ff
	ff		 jne	 $LN8@replace_de

; 1797 : 
; 1798 :     return result;

  00399	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
$LN22@replace_de:

; 1799 : }

  0039e	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003a5	c3		 ret	 0
replace_delete_single_character ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$countchar DD imagerel countchar
	DD	imagerel countchar+166
	DD	imagerel $unwind$countchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$countchar DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT countchar
_TEXT	SEGMENT
count$ = 32
end$ = 40
start$ = 48
target$ = 80
target_len$ = 88
c$ = 96
maxcount$ = 104
countchar PROC						; COMDAT

; 1684 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1685 :     Py_ssize_t count=0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 1686 :     const char *start=target;

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR target$[rsp]
  00026	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax

; 1687 :     const char *end=target+target_len;

  0002b	48 8b 44 24 58	 mov	 rax, QWORD PTR target_len$[rsp]
  00030	48 8b 4c 24 50	 mov	 rcx, QWORD PTR target$[rsp]
  00035	48 03 c8	 add	 rcx, rax
  00038	48 8b c1	 mov	 rax, rcx
  0003b	48 89 44 24 28	 mov	 QWORD PTR end$[rsp], rax
$LN3@countchar:

; 1688 : 
; 1689 :     while ( (start=findchar(start, end-start, c)) != NULL ) {

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR start$[rsp]
  00045	48 8b 4c 24 28	 mov	 rcx, QWORD PTR end$[rsp]
  0004a	48 2b c8	 sub	 rcx, rax
  0004d	48 8b c1	 mov	 rax, rcx
  00050	0f be 4c 24 60	 movsx	 ecx, BYTE PTR c$[rsp]
  00055	4c 8b c0	 mov	 r8, rax
  00058	8b d1		 mov	 edx, ecx
  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR start$[rsp]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00065	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax
  0006a	48 83 7c 24 30
	00		 cmp	 QWORD PTR start$[rsp], 0
  00070	74 2a		 je	 SHORT $LN2@countchar

; 1690 :         count++;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00077	48 ff c0	 inc	 rax
  0007a	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 1691 :         if (count >= maxcount)

  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR maxcount$[rsp]
  00084	48 39 44 24 20	 cmp	 QWORD PTR count$[rsp], rax
  00089	7c 02		 jl	 SHORT $LN1@countchar

; 1692 :             break;

  0008b	eb 0f		 jmp	 SHORT $LN2@countchar
$LN1@countchar:

; 1693 :         start += 1;

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR start$[rsp]
  00092	48 ff c0	 inc	 rax
  00095	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax

; 1694 :     }

  0009a	eb a4		 jmp	 SHORT $LN3@countchar
$LN2@countchar:

; 1695 :     return count;

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]

; 1696 : }

  000a1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a5	c3		 ret	 0
countchar ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_delete_substring DD imagerel replace_delete_substring
	DD	imagerel replace_delete_substring+1043
	DD	imagerel $unwind$replace_delete_substring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_delete_substring DD 021b01H
	DD	019011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace_delete_substring
_TEXT	SEGMENT
result_len$ = 48
count$ = 56
self_len$ = 64
offset$ = 72
next$ = 80
end$ = 88
start$ = 96
result_s$ = 104
result$ = 112
self_s$ = 120
t_$23437 = 128
s_$23439 = 136
i_$23435 = 144
n_$23436 = 152
t_$23451 = 160
s_$23453 = 168
i_$23449 = 176
n_$23450 = 184
self$ = 208
from_s$ = 216
from_len$ = 224
maxcount$ = 232
replace_delete_substring PROC				; COMDAT

; 1806 :                          Py_ssize_t maxcount) {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1807 :     char *self_s, *result_s;
; 1808 :     char *start, *next, *end;
; 1809 :     Py_ssize_t self_len, result_len;
; 1810 :     Py_ssize_t count, offset;
; 1811 :     PyBytesObject *result;
; 1812 : 
; 1813 :     self_len = PyBytes_GET_SIZE(self);

  0001b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00023	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00027	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00032	85 c0		 test	 eax, eax
  00034	75 1c		 jne	 SHORT $LN24@replace_de@2
  00036	41 b8 15 07 00
	00		 mov	 r8d, 1813		; 00000715H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN24@replace_de@2:
  00052	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0005e	48 89 44 24 40	 mov	 QWORD PTR self_len$[rsp], rax

; 1814 :     self_s = PyBytes_AS_STRING(self);

  00063	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00075	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0007a	85 c0		 test	 eax, eax
  0007c	75 1c		 jne	 SHORT $LN25@replace_de@2
  0007e	41 b8 16 07 00
	00		 mov	 r8d, 1814		; 00000716H
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00098	33 c0		 xor	 eax, eax
$LN25@replace_de@2:
  0009a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a2	48 83 c0 78	 add	 rax, 120		; 00000078H
  000a6	48 89 44 24 78	 mov	 QWORD PTR self_s$[rsp], rax

; 1815 : 
; 1816 :     count = stringlib_count(self_s, self_len,
; 1817 :                             from_s, from_len,
; 1818 :                             maxcount);

  000ab	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b8	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  000c0	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  000c8	48 8b 54 24 40	 mov	 rdx, QWORD PTR self_len$[rsp]
  000cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self_s$[rsp]
  000d2	e8 00 00 00 00	 call	 stringlib_count
  000d7	48 89 44 24 38	 mov	 QWORD PTR count$[rsp], rax

; 1819 : 
; 1820 :     if (count == 0) {

  000dc	48 83 7c 24 38
	00		 cmp	 QWORD PTR count$[rsp], 0
  000e2	75 12		 jne	 SHORT $LN21@replace_de@2

; 1821 :         /* no matches */
; 1822 :         return return_self(self);

  000e4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000ec	e8 00 00 00 00	 call	 return_self
  000f1	e9 15 03 00 00	 jmp	 $LN22@replace_de@2
$LN21@replace_de@2:

; 1823 :     }
; 1824 : 
; 1825 :     result_len = self_len - (count * from_len);

  000f6	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  000fb	48 0f af 84 24
	e0 00 00 00	 imul	 rax, QWORD PTR from_len$[rsp]
  00104	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self_len$[rsp]
  00109	48 2b c8	 sub	 rcx, rax
  0010c	48 8b c1	 mov	 rax, rcx
  0010f	48 89 44 24 30	 mov	 QWORD PTR result_len$[rsp], rax

; 1826 :     assert (result_len>=0);

  00114	48 83 7c 24 30
	00		 cmp	 QWORD PTR result_len$[rsp], 0
  0011a	7d 1c		 jge	 SHORT $LN26@replace_de@2
  0011c	41 b8 22 07 00
	00		 mov	 r8d, 1826		; 00000722H
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@JMBDMDDM@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00136	33 c0		 xor	 eax, eax
$LN26@replace_de@2:

; 1827 : 
; 1828 :     if ( (result = (PyBytesObject *)
; 1829 :           PyBytes_FromStringAndSize(NULL, result_len)) == NULL )

  00138	48 8b 54 24 30	 mov	 rdx, QWORD PTR result_len$[rsp]
  0013d	33 c9		 xor	 ecx, ecx
  0013f	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00144	48 89 44 24 70	 mov	 QWORD PTR result$[rsp], rax
  00149	48 83 7c 24 70
	00		 cmp	 QWORD PTR result$[rsp], 0
  0014f	75 07		 jne	 SHORT $LN20@replace_de@2

; 1830 :         return NULL;

  00151	33 c0		 xor	 eax, eax
  00153	e9 b3 02 00 00	 jmp	 $LN22@replace_de@2
$LN20@replace_de@2:

; 1831 : 
; 1832 :     result_s = PyBytes_AS_STRING(result);

  00158	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  0015d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00161	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00167	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0016c	85 c0		 test	 eax, eax
  0016e	75 1c		 jne	 SHORT $LN27@replace_de@2
  00170	41 b8 28 07 00
	00		 mov	 r8d, 1832		; 00000728H
  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0018a	33 c0		 xor	 eax, eax
$LN27@replace_de@2:
  0018c	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  00191	48 83 c0 78	 add	 rax, 120		; 00000078H
  00195	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax

; 1833 : 
; 1834 :     start = self_s;

  0019a	48 8b 44 24 78	 mov	 rax, QWORD PTR self_s$[rsp]
  0019f	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax

; 1835 :     end = self_s + self_len;

  001a4	48 8b 44 24 40	 mov	 rax, QWORD PTR self_len$[rsp]
  001a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self_s$[rsp]
  001ae	48 03 c8	 add	 rcx, rax
  001b1	48 8b c1	 mov	 rax, rcx
  001b4	48 89 44 24 58	 mov	 QWORD PTR end$[rsp], rax
$LN19@replace_de@2:

; 1836 :     while (count-- > 0) {

  001b9	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  001be	48 8b 4c 24 38	 mov	 rcx, QWORD PTR count$[rsp]
  001c3	48 ff c9	 dec	 rcx
  001c6	48 89 4c 24 38	 mov	 QWORD PTR count$[rsp], rcx
  001cb	48 85 c0	 test	 rax, rax
  001ce	0f 8e 66 01 00
	00		 jle	 $LN18@replace_de@2

; 1837 :         offset = stringlib_find(start, end-start,
; 1838 :                                 from_s, from_len,
; 1839 :                                 0);

  001d4	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  001d9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR end$[rsp]
  001de	48 2b c8	 sub	 rcx, rax
  001e1	48 8b c1	 mov	 rax, rcx
  001e4	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001ed	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  001f5	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  001fd	48 8b d0	 mov	 rdx, rax
  00200	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00205	e8 00 00 00 00	 call	 stringlib_find
  0020a	48 89 44 24 48	 mov	 QWORD PTR offset$[rsp], rax

; 1840 :         if (offset == -1)

  0020f	48 83 7c 24 48
	ff		 cmp	 QWORD PTR offset$[rsp], -1
  00215	75 05		 jne	 SHORT $LN17@replace_de@2

; 1841 :             break;

  00217	e9 1e 01 00 00	 jmp	 $LN18@replace_de@2
$LN17@replace_de@2:

; 1842 :         next = start + offset;

  0021c	48 8b 44 24 48	 mov	 rax, QWORD PTR offset$[rsp]
  00221	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00226	48 03 c8	 add	 rcx, rax
  00229	48 8b c1	 mov	 rax, rcx
  0022c	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
$LN16@replace_de@2:

; 1843 : 
; 1844 :         Py_MEMCPY(result_s, start, next-start);

  00231	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00236	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  0023b	48 2b c8	 sub	 rcx, rax
  0023e	48 8b c1	 mov	 rax, rcx
  00241	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR n_$23436[rsp], rax
  00249	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  0024e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR t_$23437[rsp], rax
  00256	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0025b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s_$23439[rsp], rax
  00263	48 83 bc 24 98
	00 00 00 10	 cmp	 QWORD PTR n_$23436[rsp], 16
  0026c	72 1f		 jb	 SHORT $LN13@replace_de@2
  0026e	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR n_$23436[rsp]
  00276	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s_$23439[rsp]
  0027e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t_$23437[rsp]
  00286	e8 00 00 00 00	 call	 memcpy
  0028b	eb 66		 jmp	 SHORT $LN12@replace_de@2
$LN13@replace_de@2:
  0028d	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23435[rsp], 0
  00299	eb 13		 jmp	 SHORT $LN11@replace_de@2
$LN10@replace_de@2:
  0029b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i_$23435[rsp]
  002a3	48 ff c0	 inc	 rax
  002a6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR i_$23435[rsp], rax
$LN11@replace_de@2:
  002ae	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n_$23436[rsp]
  002b6	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR i_$23435[rsp], rax
  002be	73 33		 jae	 SHORT $LN9@replace_de@2
  002c0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i_$23435[rsp]
  002c8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t_$23437[rsp]
  002d0	48 03 c8	 add	 rcx, rax
  002d3	48 8b c1	 mov	 rax, rcx
  002d6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR i_$23435[rsp]
  002de	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s_$23439[rsp]
  002e6	48 03 d1	 add	 rdx, rcx
  002e9	48 8b ca	 mov	 rcx, rdx
  002ec	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002ef	88 08		 mov	 BYTE PTR [rax], cl
  002f1	eb a8		 jmp	 SHORT $LN10@replace_de@2
$LN9@replace_de@2:
$LN12@replace_de@2:
  002f3	33 c0		 xor	 eax, eax
  002f5	85 c0		 test	 eax, eax
  002f7	0f 85 34 ff ff
	ff		 jne	 $LN16@replace_de@2

; 1845 : 
; 1846 :         result_s += (next-start);

  002fd	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00302	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00307	48 2b c8	 sub	 rcx, rax
  0030a	48 8b c1	 mov	 rax, rcx
  0030d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result_s$[rsp]
  00312	48 03 c8	 add	 rcx, rax
  00315	48 8b c1	 mov	 rax, rcx
  00318	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax

; 1847 :         start = next+from_len;

  0031d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  00325	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  0032a	48 03 c8	 add	 rcx, rax
  0032d	48 8b c1	 mov	 rax, rcx
  00330	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax

; 1848 :     }

  00335	e9 7f fe ff ff	 jmp	 $LN19@replace_de@2
$LN18@replace_de@2:
$LN8@replace_de@2:

; 1849 :     Py_MEMCPY(result_s, start, end-start);

  0033a	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0033f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR end$[rsp]
  00344	48 2b c8	 sub	 rcx, rax
  00347	48 8b c1	 mov	 rax, rcx
  0034a	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR n_$23450[rsp], rax
  00352	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  00357	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR t_$23451[rsp], rax
  0035f	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00364	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s_$23453[rsp], rax
  0036c	48 83 bc 24 b8
	00 00 00 10	 cmp	 QWORD PTR n_$23450[rsp], 16
  00375	72 1f		 jb	 SHORT $LN5@replace_de@2
  00377	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR n_$23450[rsp]
  0037f	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR s_$23453[rsp]
  00387	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR t_$23451[rsp]
  0038f	e8 00 00 00 00	 call	 memcpy
  00394	eb 66		 jmp	 SHORT $LN4@replace_de@2
$LN5@replace_de@2:
  00396	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23449[rsp], 0
  003a2	eb 13		 jmp	 SHORT $LN3@replace_de@2
$LN2@replace_de@2:
  003a4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i_$23449[rsp]
  003ac	48 ff c0	 inc	 rax
  003af	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR i_$23449[rsp], rax
$LN3@replace_de@2:
  003b7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n_$23450[rsp]
  003bf	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR i_$23449[rsp], rax
  003c7	73 33		 jae	 SHORT $LN1@replace_de@2
  003c9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i_$23449[rsp]
  003d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR t_$23451[rsp]
  003d9	48 03 c8	 add	 rcx, rax
  003dc	48 8b c1	 mov	 rax, rcx
  003df	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR i_$23449[rsp]
  003e7	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR s_$23453[rsp]
  003ef	48 03 d1	 add	 rdx, rcx
  003f2	48 8b ca	 mov	 rcx, rdx
  003f5	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  003f8	88 08		 mov	 BYTE PTR [rax], cl
  003fa	eb a8		 jmp	 SHORT $LN2@replace_de@2
$LN1@replace_de@2:
$LN4@replace_de@2:
  003fc	33 c0		 xor	 eax, eax
  003fe	85 c0		 test	 eax, eax
  00400	0f 85 34 ff ff
	ff		 jne	 $LN8@replace_de@2

; 1850 :     return result;

  00406	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
$LN22@replace_de@2:

; 1851 : }

  0040b	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00412	c3		 ret	 0
replace_delete_substring ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_single_character_in_place DD imagerel replace_single_character_in_place
	DD	imagerel replace_single_character_in_place+679
	DD	imagerel $unwind$replace_single_character_in_place
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_single_character_in_place DD 021a01H
	DD	011011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace_single_character_in_place
_TEXT	SEGMENT
self_len$ = 32
next$ = 40
end$ = 48
start$ = 56
result_s$ = 64
result$ = 72
self_s$ = 80
t_$23500 = 88
s_$23502 = 96
i_$23498 = 104
n_$23499 = 112
self$ = 144
from_c$ = 152
to_c$ = 160
maxcount$ = 168
replace_single_character_in_place PROC			; COMDAT

; 1858 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1859 :     char *self_s, *result_s, *start, *end, *next;
; 1860 :     Py_ssize_t self_len;
; 1861 :     PyBytesObject *result;
; 1862 : 
; 1863 :     /* The result string will be the same size */
; 1864 :     self_s = PyBytes_AS_STRING(self);

  0001a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00022	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00026	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00031	85 c0		 test	 eax, eax
  00033	75 1c		 jne	 SHORT $LN16@replace_si
  00035	41 b8 48 07 00
	00		 mov	 r8d, 1864		; 00000748H
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004f	33 c0		 xor	 eax, eax
$LN16@replace_si:
  00051	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00059	48 83 c0 78	 add	 rax, 120		; 00000078H
  0005d	48 89 44 24 50	 mov	 QWORD PTR self_s$[rsp], rax

; 1865 :     self_len = PyBytes_GET_SIZE(self);

  00062	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00074	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00079	85 c0		 test	 eax, eax
  0007b	75 1c		 jne	 SHORT $LN17@replace_si
  0007d	41 b8 49 07 00
	00		 mov	 r8d, 1865		; 00000749H
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00097	33 c0		 xor	 eax, eax
$LN17@replace_si:
  00099	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a5	48 89 44 24 20	 mov	 QWORD PTR self_len$[rsp], rax

; 1866 : 
; 1867 :     next = findchar(self_s, self_len, from_c);

  000aa	0f be 84 24 98
	00 00 00	 movsx	 eax, BYTE PTR from_c$[rsp]
  000b2	4c 8b 44 24 20	 mov	 r8, QWORD PTR self_len$[rsp]
  000b7	8b d0		 mov	 edx, eax
  000b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self_s$[rsp]
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000c4	48 89 44 24 28	 mov	 QWORD PTR next$[rsp], rax

; 1868 : 
; 1869 :     if (next == NULL) {

  000c9	48 83 7c 24 28
	00		 cmp	 QWORD PTR next$[rsp], 0
  000cf	75 12		 jne	 SHORT $LN13@replace_si

; 1870 :         /* No matches; return the original string */
; 1871 :         return return_self(self);

  000d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000d9	e8 00 00 00 00	 call	 return_self
  000de	e9 bc 01 00 00	 jmp	 $LN14@replace_si
$LN13@replace_si:

; 1872 :     }
; 1873 : 
; 1874 :     /* Need to make a new string */
; 1875 :     result = (PyBytesObject *) PyBytes_FromStringAndSize(NULL, self_len);

  000e3	48 8b 54 24 20	 mov	 rdx, QWORD PTR self_len$[rsp]
  000e8	33 c9		 xor	 ecx, ecx
  000ea	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000ef	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 1876 :     if (result == NULL)

  000f4	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  000fa	75 07		 jne	 SHORT $LN12@replace_si

; 1877 :         return NULL;

  000fc	33 c0		 xor	 eax, eax
  000fe	e9 9c 01 00 00	 jmp	 $LN14@replace_si
$LN12@replace_si:

; 1878 :     result_s = PyBytes_AS_STRING(result);

  00103	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00108	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0010c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00112	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00117	85 c0		 test	 eax, eax
  00119	75 1c		 jne	 SHORT $LN18@replace_si
  0011b	41 b8 56 07 00
	00		 mov	 r8d, 1878		; 00000756H
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00135	33 c0		 xor	 eax, eax
$LN18@replace_si:
  00137	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  0013c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00140	48 89 44 24 40	 mov	 QWORD PTR result_s$[rsp], rax
$LN11@replace_si:

; 1879 :     Py_MEMCPY(result_s, self_s, self_len);

  00145	48 8b 44 24 20	 mov	 rax, QWORD PTR self_len$[rsp]
  0014a	48 89 44 24 70	 mov	 QWORD PTR n_$23499[rsp], rax
  0014f	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  00154	48 89 44 24 58	 mov	 QWORD PTR t_$23500[rsp], rax
  00159	48 8b 44 24 50	 mov	 rax, QWORD PTR self_s$[rsp]
  0015e	48 89 44 24 60	 mov	 QWORD PTR s_$23502[rsp], rax
  00163	48 83 7c 24 70
	10		 cmp	 QWORD PTR n_$23499[rsp], 16
  00169	72 16		 jb	 SHORT $LN8@replace_si
  0016b	4c 8b 44 24 70	 mov	 r8, QWORD PTR n_$23499[rsp]
  00170	48 8b 54 24 60	 mov	 rdx, QWORD PTR s_$23502[rsp]
  00175	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t_$23500[rsp]
  0017a	e8 00 00 00 00	 call	 memcpy
  0017f	eb 4b		 jmp	 SHORT $LN7@replace_si
$LN8@replace_si:
  00181	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR i_$23498[rsp], 0
  0018a	eb 0d		 jmp	 SHORT $LN6@replace_si
$LN5@replace_si:
  0018c	48 8b 44 24 68	 mov	 rax, QWORD PTR i_$23498[rsp]
  00191	48 ff c0	 inc	 rax
  00194	48 89 44 24 68	 mov	 QWORD PTR i_$23498[rsp], rax
$LN6@replace_si:
  00199	48 8b 44 24 70	 mov	 rax, QWORD PTR n_$23499[rsp]
  0019e	48 39 44 24 68	 cmp	 QWORD PTR i_$23498[rsp], rax
  001a3	73 27		 jae	 SHORT $LN4@replace_si
  001a5	48 8b 44 24 68	 mov	 rax, QWORD PTR i_$23498[rsp]
  001aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t_$23500[rsp]
  001af	48 03 c8	 add	 rcx, rax
  001b2	48 8b c1	 mov	 rax, rcx
  001b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR i_$23498[rsp]
  001ba	48 8b 54 24 60	 mov	 rdx, QWORD PTR s_$23502[rsp]
  001bf	48 03 d1	 add	 rdx, rcx
  001c2	48 8b ca	 mov	 rcx, rdx
  001c5	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001c8	88 08		 mov	 BYTE PTR [rax], cl
  001ca	eb c0		 jmp	 SHORT $LN5@replace_si
$LN4@replace_si:
$LN7@replace_si:
  001cc	33 c0		 xor	 eax, eax
  001ce	85 c0		 test	 eax, eax
  001d0	0f 85 6f ff ff
	ff		 jne	 $LN11@replace_si

; 1880 : 
; 1881 :     /* change everything in-place, starting with this one */
; 1882 :     start =  result_s + (next-self_s);

  001d6	48 8b 44 24 50	 mov	 rax, QWORD PTR self_s$[rsp]
  001db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR next$[rsp]
  001e0	48 2b c8	 sub	 rcx, rax
  001e3	48 8b c1	 mov	 rax, rcx
  001e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result_s$[rsp]
  001eb	48 03 c8	 add	 rcx, rax
  001ee	48 8b c1	 mov	 rax, rcx
  001f1	48 89 44 24 38	 mov	 QWORD PTR start$[rsp], rax

; 1883 :     *start = to_c;

  001f6	48 8b 44 24 38	 mov	 rax, QWORD PTR start$[rsp]
  001fb	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR to_c$[rsp]
  00203	88 08		 mov	 BYTE PTR [rax], cl

; 1884 :     start++;

  00205	48 8b 44 24 38	 mov	 rax, QWORD PTR start$[rsp]
  0020a	48 ff c0	 inc	 rax
  0020d	48 89 44 24 38	 mov	 QWORD PTR start$[rsp], rax

; 1885 :     end = result_s + self_len;

  00212	48 8b 44 24 20	 mov	 rax, QWORD PTR self_len$[rsp]
  00217	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result_s$[rsp]
  0021c	48 03 c8	 add	 rcx, rax
  0021f	48 8b c1	 mov	 rax, rcx
  00222	48 89 44 24 30	 mov	 QWORD PTR end$[rsp], rax
$LN3@replace_si:

; 1886 : 
; 1887 :     while (--maxcount > 0) {

  00227	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0022f	48 ff c8	 dec	 rax
  00232	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR maxcount$[rsp], rax
  0023a	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR maxcount$[rsp], 0
  00243	7e 55		 jle	 SHORT $LN2@replace_si

; 1888 :         next = findchar(start, end-start, from_c);

  00245	48 8b 44 24 38	 mov	 rax, QWORD PTR start$[rsp]
  0024a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR end$[rsp]
  0024f	48 2b c8	 sub	 rcx, rax
  00252	48 8b c1	 mov	 rax, rcx
  00255	0f be 8c 24 98
	00 00 00	 movsx	 ecx, BYTE PTR from_c$[rsp]
  0025d	4c 8b c0	 mov	 r8, rax
  00260	8b d1		 mov	 edx, ecx
  00262	48 8b 4c 24 38	 mov	 rcx, QWORD PTR start$[rsp]
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0026d	48 89 44 24 28	 mov	 QWORD PTR next$[rsp], rax

; 1889 :         if (next == NULL)

  00272	48 83 7c 24 28
	00		 cmp	 QWORD PTR next$[rsp], 0
  00278	75 02		 jne	 SHORT $LN1@replace_si

; 1890 :             break;

  0027a	eb 1e		 jmp	 SHORT $LN2@replace_si
$LN1@replace_si:

; 1891 :         *next = to_c;

  0027c	48 8b 44 24 28	 mov	 rax, QWORD PTR next$[rsp]
  00281	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR to_c$[rsp]
  00289	88 08		 mov	 BYTE PTR [rax], cl

; 1892 :         start = next+1;

  0028b	48 8b 44 24 28	 mov	 rax, QWORD PTR next$[rsp]
  00290	48 ff c0	 inc	 rax
  00293	48 89 44 24 38	 mov	 QWORD PTR start$[rsp], rax

; 1893 :     }

  00298	eb 8d		 jmp	 SHORT $LN3@replace_si
$LN2@replace_si:

; 1894 : 
; 1895 :     return result;

  0029a	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
$LN14@replace_si:

; 1896 : }

  0029f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002a6	c3		 ret	 0
replace_single_character_in_place ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_substring_in_place DD imagerel replace_substring_in_place
	DD	imagerel replace_substring_in_place+1131
	DD	imagerel $unwind$replace_substring_in_place
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_substring_in_place DD 021b01H
	DD	01b011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace_substring_in_place
_TEXT	SEGMENT
self_len$ = 48
offset$ = 56
end$ = 64
start$ = 72
result_s$ = 80
result$ = 88
self_s$ = 96
t_$23557 = 104
s_$23559 = 112
i_$23555 = 120
n_$23556 = 128
t_$23571 = 136
s_$23573 = 144
i_$23569 = 152
n_$23570 = 160
t_$23589 = 168
s_$23591 = 176
i_$23587 = 184
n_$23588 = 192
self$ = 224
from_s$ = 232
from_len$ = 240
to_s$ = 248
to_len$ = 256
maxcount$ = 264
replace_substring_in_place PROC				; COMDAT

; 1904 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1905 :     char *result_s, *start, *end;
; 1906 :     char *self_s;
; 1907 :     Py_ssize_t self_len, offset;
; 1908 :     PyBytesObject *result;
; 1909 : 
; 1910 :     /* The result string will be the same size */
; 1911 : 
; 1912 :     self_s = PyBytes_AS_STRING(self);

  0001b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00023	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00027	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00032	85 c0		 test	 eax, eax
  00034	75 1c		 jne	 SHORT $LN32@replace_su
  00036	41 b8 78 07 00
	00		 mov	 r8d, 1912		; 00000778H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN32@replace_su:
  00052	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005a	48 83 c0 78	 add	 rax, 120		; 00000078H
  0005e	48 89 44 24 60	 mov	 QWORD PTR self_s$[rsp], rax

; 1913 :     self_len = PyBytes_GET_SIZE(self);

  00063	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00075	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0007a	85 c0		 test	 eax, eax
  0007c	75 1c		 jne	 SHORT $LN33@replace_su
  0007e	41 b8 79 07 00
	00		 mov	 r8d, 1913		; 00000779H
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00098	33 c0		 xor	 eax, eax
$LN33@replace_su:
  0009a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a6	48 89 44 24 30	 mov	 QWORD PTR self_len$[rsp], rax

; 1914 : 
; 1915 :     offset = stringlib_find(self_s, self_len,
; 1916 :                             from_s, from_len,
; 1917 :                             0);

  000ab	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000b4	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  000bc	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  000c4	48 8b 54 24 30	 mov	 rdx, QWORD PTR self_len$[rsp]
  000c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self_s$[rsp]
  000ce	e8 00 00 00 00	 call	 stringlib_find
  000d3	48 89 44 24 38	 mov	 QWORD PTR offset$[rsp], rax

; 1918 :     if (offset == -1) {

  000d8	48 83 7c 24 38
	ff		 cmp	 QWORD PTR offset$[rsp], -1
  000de	75 12		 jne	 SHORT $LN29@replace_su

; 1919 :         /* No matches; return the original string */
; 1920 :         return return_self(self);

  000e0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000e8	e8 00 00 00 00	 call	 return_self
  000ed	e9 71 03 00 00	 jmp	 $LN30@replace_su
$LN29@replace_su:

; 1921 :     }
; 1922 : 
; 1923 :     /* Need to make a new string */
; 1924 :     result = (PyBytesObject *) PyBytes_FromStringAndSize(NULL, self_len);

  000f2	48 8b 54 24 30	 mov	 rdx, QWORD PTR self_len$[rsp]
  000f7	33 c9		 xor	 ecx, ecx
  000f9	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000fe	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 1925 :     if (result == NULL)

  00103	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  00109	75 07		 jne	 SHORT $LN28@replace_su

; 1926 :         return NULL;

  0010b	33 c0		 xor	 eax, eax
  0010d	e9 51 03 00 00	 jmp	 $LN30@replace_su
$LN28@replace_su:

; 1927 :     result_s = PyBytes_AS_STRING(result);

  00112	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00117	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0011b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00121	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00126	85 c0		 test	 eax, eax
  00128	75 1c		 jne	 SHORT $LN34@replace_su
  0012a	41 b8 87 07 00
	00		 mov	 r8d, 1927		; 00000787H
  00130	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00144	33 c0		 xor	 eax, eax
$LN34@replace_su:
  00146	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  0014b	48 83 c0 78	 add	 rax, 120		; 00000078H
  0014f	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax
$LN27@replace_su:

; 1928 :     Py_MEMCPY(result_s, self_s, self_len);

  00154	48 8b 44 24 30	 mov	 rax, QWORD PTR self_len$[rsp]
  00159	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n_$23556[rsp], rax
  00161	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  00166	48 89 44 24 68	 mov	 QWORD PTR t_$23557[rsp], rax
  0016b	48 8b 44 24 60	 mov	 rax, QWORD PTR self_s$[rsp]
  00170	48 89 44 24 70	 mov	 QWORD PTR s_$23559[rsp], rax
  00175	48 83 bc 24 80
	00 00 00 10	 cmp	 QWORD PTR n_$23556[rsp], 16
  0017e	72 19		 jb	 SHORT $LN24@replace_su
  00180	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR n_$23556[rsp]
  00188	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23559[rsp]
  0018d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23557[rsp]
  00192	e8 00 00 00 00	 call	 memcpy
  00197	eb 4e		 jmp	 SHORT $LN23@replace_su
$LN24@replace_su:
  00199	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i_$23555[rsp], 0
  001a2	eb 0d		 jmp	 SHORT $LN22@replace_su
$LN21@replace_su:
  001a4	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23555[rsp]
  001a9	48 ff c0	 inc	 rax
  001ac	48 89 44 24 78	 mov	 QWORD PTR i_$23555[rsp], rax
$LN22@replace_su:
  001b1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n_$23556[rsp]
  001b9	48 39 44 24 78	 cmp	 QWORD PTR i_$23555[rsp], rax
  001be	73 27		 jae	 SHORT $LN20@replace_su
  001c0	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23555[rsp]
  001c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23557[rsp]
  001ca	48 03 c8	 add	 rcx, rax
  001cd	48 8b c1	 mov	 rax, rcx
  001d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i_$23555[rsp]
  001d5	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23559[rsp]
  001da	48 03 d1	 add	 rdx, rcx
  001dd	48 8b ca	 mov	 rcx, rdx
  001e0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001e3	88 08		 mov	 BYTE PTR [rax], cl
  001e5	eb bd		 jmp	 SHORT $LN21@replace_su
$LN20@replace_su:
$LN23@replace_su:
  001e7	33 c0		 xor	 eax, eax
  001e9	85 c0		 test	 eax, eax
  001eb	0f 85 63 ff ff
	ff		 jne	 $LN27@replace_su

; 1929 : 
; 1930 :     /* change everything in-place, starting with this one */
; 1931 :     start =  result_s + offset;

  001f1	48 8b 44 24 38	 mov	 rax, QWORD PTR offset$[rsp]
  001f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  001fb	48 03 c8	 add	 rcx, rax
  001fe	48 8b c1	 mov	 rax, rcx
  00201	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax
$LN19@replace_su:

; 1932 :     Py_MEMCPY(start, to_s, from_len);

  00206	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  0020e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR n_$23570[rsp], rax
  00216	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  0021b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR t_$23571[rsp], rax
  00223	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  0022b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR s_$23573[rsp], rax
  00233	48 83 bc 24 a0
	00 00 00 10	 cmp	 QWORD PTR n_$23570[rsp], 16
  0023c	72 1f		 jb	 SHORT $LN16@replace_su
  0023e	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR n_$23570[rsp]
  00246	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23573[rsp]
  0024e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23571[rsp]
  00256	e8 00 00 00 00	 call	 memcpy
  0025b	eb 66		 jmp	 SHORT $LN15@replace_su
$LN16@replace_su:
  0025d	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23569[rsp], 0
  00269	eb 13		 jmp	 SHORT $LN14@replace_su
$LN13@replace_su:
  0026b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23569[rsp]
  00273	48 ff c0	 inc	 rax
  00276	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR i_$23569[rsp], rax
$LN14@replace_su:
  0027e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR n_$23570[rsp]
  00286	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR i_$23569[rsp], rax
  0028e	73 33		 jae	 SHORT $LN12@replace_su
  00290	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23569[rsp]
  00298	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23571[rsp]
  002a0	48 03 c8	 add	 rcx, rax
  002a3	48 8b c1	 mov	 rax, rcx
  002a6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR i_$23569[rsp]
  002ae	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23573[rsp]
  002b6	48 03 d1	 add	 rdx, rcx
  002b9	48 8b ca	 mov	 rcx, rdx
  002bc	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002bf	88 08		 mov	 BYTE PTR [rax], cl
  002c1	eb a8		 jmp	 SHORT $LN13@replace_su
$LN12@replace_su:
$LN15@replace_su:
  002c3	33 c0		 xor	 eax, eax
  002c5	85 c0		 test	 eax, eax
  002c7	0f 85 39 ff ff
	ff		 jne	 $LN19@replace_su

; 1933 :     start += from_len;

  002cd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  002d5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  002da	48 03 c8	 add	 rcx, rax
  002dd	48 8b c1	 mov	 rax, rcx
  002e0	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1934 :     end = result_s + self_len;

  002e5	48 8b 44 24 30	 mov	 rax, QWORD PTR self_len$[rsp]
  002ea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  002ef	48 03 c8	 add	 rcx, rax
  002f2	48 8b c1	 mov	 rax, rcx
  002f5	48 89 44 24 40	 mov	 QWORD PTR end$[rsp], rax
$LN11@replace_su:

; 1935 : 
; 1936 :     while ( --maxcount > 0) {

  002fa	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00302	48 ff c8	 dec	 rax
  00305	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR maxcount$[rsp], rax
  0030d	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR maxcount$[rsp], 0
  00316	0f 8e 42 01 00
	00		 jle	 $LN10@replace_su

; 1937 :         offset = stringlib_find(start, end-start,
; 1938 :                                 from_s, from_len,
; 1939 :                                 0);

  0031c	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00321	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  00326	48 2b c8	 sub	 rcx, rax
  00329	48 8b c1	 mov	 rax, rcx
  0032c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00335	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  0033d	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  00345	48 8b d0	 mov	 rdx, rax
  00348	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  0034d	e8 00 00 00 00	 call	 stringlib_find
  00352	48 89 44 24 38	 mov	 QWORD PTR offset$[rsp], rax

; 1940 :         if (offset==-1)

  00357	48 83 7c 24 38
	ff		 cmp	 QWORD PTR offset$[rsp], -1
  0035d	75 05		 jne	 SHORT $LN9@replace_su

; 1941 :             break;

  0035f	e9 fa 00 00 00	 jmp	 $LN10@replace_su
$LN9@replace_su:
$LN8@replace_su:

; 1942 :         Py_MEMCPY(start+offset, to_s, from_len);

  00364	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  0036c	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR n_$23588[rsp], rax
  00374	48 8b 44 24 38	 mov	 rax, QWORD PTR offset$[rsp]
  00379	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  0037e	48 03 c8	 add	 rcx, rax
  00381	48 8b c1	 mov	 rax, rcx
  00384	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR t_$23589[rsp], rax
  0038c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  00394	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR s_$23591[rsp], rax
  0039c	48 83 bc 24 c0
	00 00 00 10	 cmp	 QWORD PTR n_$23588[rsp], 16
  003a5	72 1f		 jb	 SHORT $LN5@replace_su
  003a7	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR n_$23588[rsp]
  003af	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR s_$23591[rsp]
  003b7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR t_$23589[rsp]
  003bf	e8 00 00 00 00	 call	 memcpy
  003c4	eb 66		 jmp	 SHORT $LN4@replace_su
$LN5@replace_su:
  003c6	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23587[rsp], 0
  003d2	eb 13		 jmp	 SHORT $LN3@replace_su
$LN2@replace_su:
  003d4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR i_$23587[rsp]
  003dc	48 ff c0	 inc	 rax
  003df	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR i_$23587[rsp], rax
$LN3@replace_su:
  003e7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n_$23588[rsp]
  003ef	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR i_$23587[rsp], rax
  003f7	73 33		 jae	 SHORT $LN1@replace_su
  003f9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR i_$23587[rsp]
  00401	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR t_$23589[rsp]
  00409	48 03 c8	 add	 rcx, rax
  0040c	48 8b c1	 mov	 rax, rcx
  0040f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR i_$23587[rsp]
  00417	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR s_$23591[rsp]
  0041f	48 03 d1	 add	 rdx, rcx
  00422	48 8b ca	 mov	 rcx, rdx
  00425	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00428	88 08		 mov	 BYTE PTR [rax], cl
  0042a	eb a8		 jmp	 SHORT $LN2@replace_su
$LN1@replace_su:
$LN4@replace_su:
  0042c	33 c0		 xor	 eax, eax
  0042e	85 c0		 test	 eax, eax
  00430	0f 85 2e ff ff
	ff		 jne	 $LN8@replace_su

; 1943 :         start += offset+from_len;

  00436	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  0043e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR offset$[rsp]
  00443	48 03 c8	 add	 rcx, rax
  00446	48 8b c1	 mov	 rax, rcx
  00449	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  0044e	48 03 c8	 add	 rcx, rax
  00451	48 8b c1	 mov	 rax, rcx
  00454	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1944 :     }

  00459	e9 9c fe ff ff	 jmp	 $LN11@replace_su
$LN10@replace_su:

; 1945 : 
; 1946 :     return result;

  0045e	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
$LN30@replace_su:

; 1947 : }

  00463	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0046a	c3		 ret	 0
replace_substring_in_place ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_single_character DD imagerel replace_single_character
	DD	imagerel replace_single_character+1520
	DD	imagerel $unwind$replace_single_character
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_single_character DD 021a01H
	DD	01f011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace_single_character
_TEXT	SEGMENT
result_len$ = 32
count$ = 40
self_len$ = 48
next$ = 56
end$ = 64
start$ = 72
result_s$ = 80
result$ = 88
self_s$ = 96
t_$23652 = 104
s_$23654 = 112
i_$23650 = 120
n_$23651 = 128
t_$23667 = 136
s_$23669 = 144
i_$23665 = 152
n_$23666 = 160
t_$23681 = 168
s_$23683 = 176
i_$23679 = 184
n_$23680 = 192
t_$23695 = 200
s_$23697 = 208
i_$23693 = 216
n_$23694 = 224
tv95 = 232
self$ = 256
from_c$ = 264
to_s$ = 272
to_len$ = 280
maxcount$ = 288
replace_single_character PROC				; COMDAT

; 1955 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 1956 :     char *self_s, *result_s;
; 1957 :     char *start, *next, *end;
; 1958 :     Py_ssize_t self_len, result_len;
; 1959 :     Py_ssize_t count;
; 1960 :     PyBytesObject *result;
; 1961 : 
; 1962 :     self_s = PyBytes_AS_STRING(self);

  0001a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00022	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00026	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00031	85 c0		 test	 eax, eax
  00033	75 1c		 jne	 SHORT $LN43@replace_si@2
  00035	41 b8 aa 07 00
	00		 mov	 r8d, 1962		; 000007aaH
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004f	33 c0		 xor	 eax, eax
$LN43@replace_si@2:
  00051	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00059	48 83 c0 78	 add	 rax, 120		; 00000078H
  0005d	48 89 44 24 60	 mov	 QWORD PTR self_s$[rsp], rax

; 1963 :     self_len = PyBytes_GET_SIZE(self);

  00062	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00074	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00079	85 c0		 test	 eax, eax
  0007b	75 1c		 jne	 SHORT $LN44@replace_si@2
  0007d	41 b8 ab 07 00
	00		 mov	 r8d, 1963		; 000007abH
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00097	33 c0		 xor	 eax, eax
$LN44@replace_si@2:
  00099	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a5	48 89 44 24 30	 mov	 QWORD PTR self_len$[rsp], rax

; 1964 : 
; 1965 :     count = countchar(self_s, self_len, from_c, maxcount);

  000aa	4c 8b 8c 24 20
	01 00 00	 mov	 r9, QWORD PTR maxcount$[rsp]
  000b2	44 0f b6 84 24
	08 01 00 00	 movzx	 r8d, BYTE PTR from_c$[rsp]
  000bb	48 8b 54 24 30	 mov	 rdx, QWORD PTR self_len$[rsp]
  000c0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self_s$[rsp]
  000c5	e8 00 00 00 00	 call	 countchar
  000ca	48 89 44 24 28	 mov	 QWORD PTR count$[rsp], rax

; 1966 :     if (count == 0) {

  000cf	48 83 7c 24 28
	00		 cmp	 QWORD PTR count$[rsp], 0
  000d5	75 12		 jne	 SHORT $LN40@replace_si@2

; 1967 :         /* no matches, return unchanged */
; 1968 :         return return_self(self);

  000d7	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000df	e8 00 00 00 00	 call	 return_self
  000e4	e9 ff 04 00 00	 jmp	 $LN41@replace_si@2
$LN40@replace_si@2:

; 1969 :     }
; 1970 : 
; 1971 :     /* use the difference between current and new, hence the "-1" */
; 1972 :     /*   result_len = self_len + count * (to_len-1)  */
; 1973 :     assert(count > 0);

  000e9	48 83 7c 24 28
	00		 cmp	 QWORD PTR count$[rsp], 0
  000ef	7f 1c		 jg	 SHORT $LN45@replace_si@2
  000f1	41 b8 b5 07 00
	00		 mov	 r8d, 1973		; 000007b5H
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0010b	33 c0		 xor	 eax, eax
$LN45@replace_si@2:

; 1974 :     if (to_len - 1 > (PY_SSIZE_T_MAX - self_len) / count) {

  0010d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00115	48 ff c8	 dec	 rax
  00118	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
  00120	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0012a	48 2b 4c 24 30	 sub	 rcx, QWORD PTR self_len$[rsp]
  0012f	48 8b c1	 mov	 rax, rcx
  00132	48 99		 cdq
  00134	48 f7 7c 24 28	 idiv	 QWORD PTR count$[rsp]
  00139	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv95[rsp]
  00141	48 3b c8	 cmp	 rcx, rax
  00144	7e 1a		 jle	 SHORT $LN39@replace_si@2

; 1975 :         PyErr_SetString(PyExc_OverflowError,
; 1976 :                         "replacement bytes are too long");

  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@DIPAALHI@replacement?5bytes?5are?5too?5long?$AA@
  0014d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00154	e8 00 00 00 00	 call	 PyErr_SetString

; 1977 :         return NULL;

  00159	33 c0		 xor	 eax, eax
  0015b	e9 88 04 00 00	 jmp	 $LN41@replace_si@2
$LN39@replace_si@2:

; 1978 :     }
; 1979 :     result_len = self_len + count * (to_len - 1);

  00160	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00168	48 ff c8	 dec	 rax
  0016b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR count$[rsp]
  00170	48 0f af c8	 imul	 rcx, rax
  00174	48 8b c1	 mov	 rax, rcx
  00177	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self_len$[rsp]
  0017c	48 03 c8	 add	 rcx, rax
  0017f	48 8b c1	 mov	 rax, rcx
  00182	48 89 44 24 20	 mov	 QWORD PTR result_len$[rsp], rax

; 1980 : 
; 1981 :     if ( (result = (PyBytesObject *)
; 1982 :           PyBytes_FromStringAndSize(NULL, result_len)) == NULL)

  00187	48 8b 54 24 20	 mov	 rdx, QWORD PTR result_len$[rsp]
  0018c	33 c9		 xor	 ecx, ecx
  0018e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00193	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax
  00198	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  0019e	75 07		 jne	 SHORT $LN38@replace_si@2

; 1983 :         return NULL;

  001a0	33 c0		 xor	 eax, eax
  001a2	e9 41 04 00 00	 jmp	 $LN41@replace_si@2
$LN38@replace_si@2:

; 1984 :     result_s = PyBytes_AS_STRING(result);

  001a7	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001ac	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001b0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001b6	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001bb	85 c0		 test	 eax, eax
  001bd	75 1c		 jne	 SHORT $LN46@replace_si@2
  001bf	41 b8 c0 07 00
	00		 mov	 r8d, 1984		; 000007c0H
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d9	33 c0		 xor	 eax, eax
$LN46@replace_si@2:
  001db	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001e0	48 83 c0 78	 add	 rax, 120		; 00000078H
  001e4	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax

; 1985 : 
; 1986 :     start = self_s;

  001e9	48 8b 44 24 60	 mov	 rax, QWORD PTR self_s$[rsp]
  001ee	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1987 :     end = self_s + self_len;

  001f3	48 8b 44 24 30	 mov	 rax, QWORD PTR self_len$[rsp]
  001f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self_s$[rsp]
  001fd	48 03 c8	 add	 rcx, rax
  00200	48 8b c1	 mov	 rax, rcx
  00203	48 89 44 24 40	 mov	 QWORD PTR end$[rsp], rax
$LN37@replace_si@2:

; 1988 :     while (count-- > 0) {

  00208	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  0020d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR count$[rsp]
  00212	48 ff c9	 dec	 rcx
  00215	48 89 4c 24 28	 mov	 QWORD PTR count$[rsp], rcx
  0021a	48 85 c0	 test	 rax, rax
  0021d	0f 8e f4 02 00
	00		 jle	 $LN36@replace_si@2

; 1989 :         next = findchar(start, end-start, from_c);

  00223	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00228	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  0022d	48 2b c8	 sub	 rcx, rax
  00230	48 8b c1	 mov	 rax, rcx
  00233	0f be 8c 24 08
	01 00 00	 movsx	 ecx, BYTE PTR from_c$[rsp]
  0023b	4c 8b c0	 mov	 r8, rax
  0023e	8b d1		 mov	 edx, ecx
  00240	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0024b	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 1990 :         if (next == NULL)

  00250	48 83 7c 24 38
	00		 cmp	 QWORD PTR next$[rsp], 0
  00256	75 05		 jne	 SHORT $LN35@replace_si@2

; 1991 :             break;

  00258	e9 ba 02 00 00	 jmp	 $LN36@replace_si@2
$LN35@replace_si@2:

; 1992 : 
; 1993 :         if (next == start) {

  0025d	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00262	48 39 44 24 38	 cmp	 QWORD PTR next$[rsp], rax
  00267	0f 85 cd 00 00
	00		 jne	 $LN34@replace_si@2
$LN33@replace_si@2:

; 1994 :             /* replace with the 'to' */
; 1995 :             Py_MEMCPY(result_s, to_s, to_len);

  0026d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00275	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n_$23651[rsp], rax
  0027d	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  00282	48 89 44 24 68	 mov	 QWORD PTR t_$23652[rsp], rax
  00287	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  0028f	48 89 44 24 70	 mov	 QWORD PTR s_$23654[rsp], rax
  00294	48 83 bc 24 80
	00 00 00 10	 cmp	 QWORD PTR n_$23651[rsp], 16
  0029d	72 19		 jb	 SHORT $LN30@replace_si@2
  0029f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR n_$23651[rsp]
  002a7	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23654[rsp]
  002ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23652[rsp]
  002b1	e8 00 00 00 00	 call	 memcpy
  002b6	eb 4e		 jmp	 SHORT $LN29@replace_si@2
$LN30@replace_si@2:
  002b8	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i_$23650[rsp], 0
  002c1	eb 0d		 jmp	 SHORT $LN28@replace_si@2
$LN27@replace_si@2:
  002c3	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23650[rsp]
  002c8	48 ff c0	 inc	 rax
  002cb	48 89 44 24 78	 mov	 QWORD PTR i_$23650[rsp], rax
$LN28@replace_si@2:
  002d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n_$23651[rsp]
  002d8	48 39 44 24 78	 cmp	 QWORD PTR i_$23650[rsp], rax
  002dd	73 27		 jae	 SHORT $LN26@replace_si@2
  002df	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23650[rsp]
  002e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23652[rsp]
  002e9	48 03 c8	 add	 rcx, rax
  002ec	48 8b c1	 mov	 rax, rcx
  002ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i_$23650[rsp]
  002f4	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23654[rsp]
  002f9	48 03 d1	 add	 rdx, rcx
  002fc	48 8b ca	 mov	 rcx, rdx
  002ff	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00302	88 08		 mov	 BYTE PTR [rax], cl
  00304	eb bd		 jmp	 SHORT $LN27@replace_si@2
$LN26@replace_si@2:
$LN29@replace_si@2:
  00306	33 c0		 xor	 eax, eax
  00308	85 c0		 test	 eax, eax
  0030a	0f 85 5d ff ff
	ff		 jne	 $LN33@replace_si@2

; 1996 :             result_s += to_len;

  00310	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00318	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  0031d	48 03 c8	 add	 rcx, rax
  00320	48 8b c1	 mov	 rax, rcx
  00323	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax

; 1997 :             start += 1;

  00328	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  0032d	48 ff c0	 inc	 rax
  00330	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1998 :         } else {

  00335	e9 d8 01 00 00	 jmp	 $LN25@replace_si@2
$LN34@replace_si@2:
$LN24@replace_si@2:

; 1999 :             /* copy the unchanged old then the 'to' */
; 2000 :             Py_MEMCPY(result_s, start, next-start);

  0033a	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  0033f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  00344	48 2b c8	 sub	 rcx, rax
  00347	48 8b c1	 mov	 rax, rcx
  0034a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR n_$23666[rsp], rax
  00352	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  00357	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR t_$23667[rsp], rax
  0035f	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00364	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR s_$23669[rsp], rax
  0036c	48 83 bc 24 a0
	00 00 00 10	 cmp	 QWORD PTR n_$23666[rsp], 16
  00375	72 1f		 jb	 SHORT $LN21@replace_si@2
  00377	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR n_$23666[rsp]
  0037f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23669[rsp]
  00387	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23667[rsp]
  0038f	e8 00 00 00 00	 call	 memcpy
  00394	eb 66		 jmp	 SHORT $LN20@replace_si@2
$LN21@replace_si@2:
  00396	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23665[rsp], 0
  003a2	eb 13		 jmp	 SHORT $LN19@replace_si@2
$LN18@replace_si@2:
  003a4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23665[rsp]
  003ac	48 ff c0	 inc	 rax
  003af	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR i_$23665[rsp], rax
$LN19@replace_si@2:
  003b7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR n_$23666[rsp]
  003bf	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR i_$23665[rsp], rax
  003c7	73 33		 jae	 SHORT $LN17@replace_si@2
  003c9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23665[rsp]
  003d1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23667[rsp]
  003d9	48 03 c8	 add	 rcx, rax
  003dc	48 8b c1	 mov	 rax, rcx
  003df	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR i_$23665[rsp]
  003e7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23669[rsp]
  003ef	48 03 d1	 add	 rdx, rcx
  003f2	48 8b ca	 mov	 rcx, rdx
  003f5	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  003f8	88 08		 mov	 BYTE PTR [rax], cl
  003fa	eb a8		 jmp	 SHORT $LN18@replace_si@2
$LN17@replace_si@2:
$LN20@replace_si@2:
  003fc	33 c0		 xor	 eax, eax
  003fe	85 c0		 test	 eax, eax
  00400	0f 85 34 ff ff
	ff		 jne	 $LN24@replace_si@2

; 2001 :             result_s += (next-start);

  00406	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  0040b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  00410	48 2b c8	 sub	 rcx, rax
  00413	48 8b c1	 mov	 rax, rcx
  00416	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  0041b	48 03 c8	 add	 rcx, rax
  0041e	48 8b c1	 mov	 rax, rcx
  00421	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax
$LN16@replace_si@2:

; 2002 :             Py_MEMCPY(result_s, to_s, to_len);

  00426	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  0042e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR n_$23680[rsp], rax
  00436	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  0043b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR t_$23681[rsp], rax
  00443	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  0044b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR s_$23683[rsp], rax
  00453	48 83 bc 24 c0
	00 00 00 10	 cmp	 QWORD PTR n_$23680[rsp], 16
  0045c	72 1f		 jb	 SHORT $LN13@replace_si@2
  0045e	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR n_$23680[rsp]
  00466	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR s_$23683[rsp]
  0046e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR t_$23681[rsp]
  00476	e8 00 00 00 00	 call	 memcpy
  0047b	eb 66		 jmp	 SHORT $LN12@replace_si@2
$LN13@replace_si@2:
  0047d	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23679[rsp], 0
  00489	eb 13		 jmp	 SHORT $LN11@replace_si@2
$LN10@replace_si@2:
  0048b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR i_$23679[rsp]
  00493	48 ff c0	 inc	 rax
  00496	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR i_$23679[rsp], rax
$LN11@replace_si@2:
  0049e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n_$23680[rsp]
  004a6	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR i_$23679[rsp], rax
  004ae	73 33		 jae	 SHORT $LN9@replace_si@2
  004b0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR i_$23679[rsp]
  004b8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR t_$23681[rsp]
  004c0	48 03 c8	 add	 rcx, rax
  004c3	48 8b c1	 mov	 rax, rcx
  004c6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR i_$23679[rsp]
  004ce	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR s_$23683[rsp]
  004d6	48 03 d1	 add	 rdx, rcx
  004d9	48 8b ca	 mov	 rcx, rdx
  004dc	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  004df	88 08		 mov	 BYTE PTR [rax], cl
  004e1	eb a8		 jmp	 SHORT $LN10@replace_si@2
$LN9@replace_si@2:
$LN12@replace_si@2:
  004e3	33 c0		 xor	 eax, eax
  004e5	85 c0		 test	 eax, eax
  004e7	0f 85 39 ff ff
	ff		 jne	 $LN16@replace_si@2

; 2003 :             result_s += to_len;

  004ed	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  004f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  004fa	48 03 c8	 add	 rcx, rax
  004fd	48 8b c1	 mov	 rax, rcx
  00500	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax

; 2004 :             start = next+1;

  00505	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  0050a	48 ff c0	 inc	 rax
  0050d	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax
$LN25@replace_si@2:

; 2005 :         }
; 2006 :     }

  00512	e9 f1 fc ff ff	 jmp	 $LN37@replace_si@2
$LN36@replace_si@2:
$LN8@replace_si@2:

; 2007 :     /* Copy the remainder of the remaining string */
; 2008 :     Py_MEMCPY(result_s, start, end-start);

  00517	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  0051c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  00521	48 2b c8	 sub	 rcx, rax
  00524	48 8b c1	 mov	 rax, rcx
  00527	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR n_$23694[rsp], rax
  0052f	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  00534	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR t_$23695[rsp], rax
  0053c	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00541	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR s_$23697[rsp], rax
  00549	48 83 bc 24 e0
	00 00 00 10	 cmp	 QWORD PTR n_$23694[rsp], 16
  00552	72 1f		 jb	 SHORT $LN5@replace_si@2
  00554	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR n_$23694[rsp]
  0055c	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR s_$23697[rsp]
  00564	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR t_$23695[rsp]
  0056c	e8 00 00 00 00	 call	 memcpy
  00571	eb 66		 jmp	 SHORT $LN4@replace_si@2
$LN5@replace_si@2:
  00573	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23693[rsp], 0
  0057f	eb 13		 jmp	 SHORT $LN3@replace_si@2
$LN2@replace_si@2:
  00581	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR i_$23693[rsp]
  00589	48 ff c0	 inc	 rax
  0058c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR i_$23693[rsp], rax
$LN3@replace_si@2:
  00594	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR n_$23694[rsp]
  0059c	48 39 84 24 d8
	00 00 00	 cmp	 QWORD PTR i_$23693[rsp], rax
  005a4	73 33		 jae	 SHORT $LN1@replace_si@2
  005a6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR i_$23693[rsp]
  005ae	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR t_$23695[rsp]
  005b6	48 03 c8	 add	 rcx, rax
  005b9	48 8b c1	 mov	 rax, rcx
  005bc	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR i_$23693[rsp]
  005c4	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR s_$23697[rsp]
  005cc	48 03 d1	 add	 rdx, rcx
  005cf	48 8b ca	 mov	 rcx, rdx
  005d2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  005d5	88 08		 mov	 BYTE PTR [rax], cl
  005d7	eb a8		 jmp	 SHORT $LN2@replace_si@2
$LN1@replace_si@2:
$LN4@replace_si@2:
  005d9	33 c0		 xor	 eax, eax
  005db	85 c0		 test	 eax, eax
  005dd	0f 85 34 ff ff
	ff		 jne	 $LN8@replace_si@2

; 2009 : 
; 2010 :     return result;

  005e3	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
$LN41@replace_si@2:

; 2011 : }

  005e8	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  005ef	c3		 ret	 0
replace_single_character ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_substring DD imagerel replace_substring
	DD	imagerel replace_substring+1648
	DD	imagerel $unwind$replace_substring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_substring DD 021b01H
	DD	023011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace_substring
_TEXT	SEGMENT
result_len$ = 48
count$ = 56
self_len$ = 64
offset$ = 72
next$ = 80
end$ = 88
start$ = 96
result_s$ = 104
result$ = 112
self_s$ = 120
t_$23758 = 128
s_$23760 = 136
i_$23756 = 144
n_$23757 = 152
t_$23773 = 160
s_$23775 = 168
i_$23771 = 176
n_$23772 = 184
t_$23787 = 192
s_$23789 = 200
i_$23785 = 208
n_$23786 = 216
t_$23801 = 224
s_$23803 = 232
i_$23799 = 240
n_$23800 = 248
tv128 = 256
self$ = 288
from_s$ = 296
from_len$ = 304
to_s$ = 312
to_len$ = 320
maxcount$ = 328
replace_substring PROC					; COMDAT

; 2018 :                   Py_ssize_t maxcount) {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 2019 :     char *self_s, *result_s;
; 2020 :     char *start, *next, *end;
; 2021 :     Py_ssize_t self_len, result_len;
; 2022 :     Py_ssize_t count, offset;
; 2023 :     PyBytesObject *result;
; 2024 : 
; 2025 :     self_s = PyBytes_AS_STRING(self);

  0001b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00023	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00027	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00032	85 c0		 test	 eax, eax
  00034	75 1c		 jne	 SHORT $LN43@replace_su@2
  00036	41 b8 e9 07 00
	00		 mov	 r8d, 2025		; 000007e9H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN43@replace_su@2:
  00052	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005a	48 83 c0 78	 add	 rax, 120		; 00000078H
  0005e	48 89 44 24 78	 mov	 QWORD PTR self_s$[rsp], rax

; 2026 :     self_len = PyBytes_GET_SIZE(self);

  00063	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00075	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0007a	85 c0		 test	 eax, eax
  0007c	75 1c		 jne	 SHORT $LN44@replace_su@2
  0007e	41 b8 ea 07 00
	00		 mov	 r8d, 2026		; 000007eaH
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00098	33 c0		 xor	 eax, eax
$LN44@replace_su@2:
  0009a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a6	48 89 44 24 40	 mov	 QWORD PTR self_len$[rsp], rax

; 2027 : 
; 2028 :     count = stringlib_count(self_s, self_len,
; 2029 :                             from_s, from_len,
; 2030 :                             maxcount);

  000ab	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b8	4c 8b 8c 24 30
	01 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  000c0	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  000c8	48 8b 54 24 40	 mov	 rdx, QWORD PTR self_len$[rsp]
  000cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self_s$[rsp]
  000d2	e8 00 00 00 00	 call	 stringlib_count
  000d7	48 89 44 24 38	 mov	 QWORD PTR count$[rsp], rax

; 2031 : 
; 2032 :     if (count == 0) {

  000dc	48 83 7c 24 38
	00		 cmp	 QWORD PTR count$[rsp], 0
  000e2	75 12		 jne	 SHORT $LN40@replace_su@2

; 2033 :         /* no matches, return unchanged */
; 2034 :         return return_self(self);

  000e4	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000ec	e8 00 00 00 00	 call	 return_self
  000f1	e9 72 05 00 00	 jmp	 $LN41@replace_su@2
$LN40@replace_su@2:

; 2035 :     }
; 2036 : 
; 2037 :     /* Check for overflow */
; 2038 :     /*    result_len = self_len + count * (to_len-from_len) */
; 2039 :     assert(count > 0);

  000f6	48 83 7c 24 38
	00		 cmp	 QWORD PTR count$[rsp], 0
  000fc	7f 1c		 jg	 SHORT $LN45@replace_su@2
  000fe	41 b8 f7 07 00
	00		 mov	 r8d, 2039		; 000007f7H
  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00118	33 c0		 xor	 eax, eax
$LN45@replace_su@2:

; 2040 :     if (to_len - from_len > (PY_SSIZE_T_MAX - self_len) / count) {

  0011a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  00122	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR to_len$[rsp]
  0012a	48 2b c8	 sub	 rcx, rax
  0012d	48 8b c1	 mov	 rax, rcx
  00130	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv128[rsp], rax
  00138	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00142	48 2b 4c 24 40	 sub	 rcx, QWORD PTR self_len$[rsp]
  00147	48 8b c1	 mov	 rax, rcx
  0014a	48 99		 cdq
  0014c	48 f7 7c 24 38	 idiv	 QWORD PTR count$[rsp]
  00151	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv128[rsp]
  00159	48 3b c8	 cmp	 rcx, rax
  0015c	7e 1a		 jle	 SHORT $LN39@replace_su@2

; 2041 :         PyErr_SetString(PyExc_OverflowError,
; 2042 :                         "replacement bytes are too long");

  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@DIPAALHI@replacement?5bytes?5are?5too?5long?$AA@
  00165	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0016c	e8 00 00 00 00	 call	 PyErr_SetString

; 2043 :         return NULL;

  00171	33 c0		 xor	 eax, eax
  00173	e9 f0 04 00 00	 jmp	 $LN41@replace_su@2
$LN39@replace_su@2:

; 2044 :     }
; 2045 :     result_len = self_len + count * (to_len-from_len);

  00178	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  00180	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR to_len$[rsp]
  00188	48 2b c8	 sub	 rcx, rax
  0018b	48 8b c1	 mov	 rax, rcx
  0018e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR count$[rsp]
  00193	48 0f af c8	 imul	 rcx, rax
  00197	48 8b c1	 mov	 rax, rcx
  0019a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self_len$[rsp]
  0019f	48 03 c8	 add	 rcx, rax
  001a2	48 8b c1	 mov	 rax, rcx
  001a5	48 89 44 24 30	 mov	 QWORD PTR result_len$[rsp], rax

; 2046 : 
; 2047 :     if ( (result = (PyBytesObject *)
; 2048 :           PyBytes_FromStringAndSize(NULL, result_len)) == NULL)

  001aa	48 8b 54 24 30	 mov	 rdx, QWORD PTR result_len$[rsp]
  001af	33 c9		 xor	 ecx, ecx
  001b1	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  001b6	48 89 44 24 70	 mov	 QWORD PTR result$[rsp], rax
  001bb	48 83 7c 24 70
	00		 cmp	 QWORD PTR result$[rsp], 0
  001c1	75 07		 jne	 SHORT $LN38@replace_su@2

; 2049 :         return NULL;

  001c3	33 c0		 xor	 eax, eax
  001c5	e9 9e 04 00 00	 jmp	 $LN41@replace_su@2
$LN38@replace_su@2:

; 2050 :     result_s = PyBytes_AS_STRING(result);

  001ca	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  001cf	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001d3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001d9	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001de	85 c0		 test	 eax, eax
  001e0	75 1c		 jne	 SHORT $LN46@replace_su@2
  001e2	41 b8 02 08 00
	00		 mov	 r8d, 2050		; 00000802H
  001e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001fc	33 c0		 xor	 eax, eax
$LN46@replace_su@2:
  001fe	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  00203	48 83 c0 78	 add	 rax, 120		; 00000078H
  00207	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax

; 2051 : 
; 2052 :     start = self_s;

  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR self_s$[rsp]
  00211	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax

; 2053 :     end = self_s + self_len;

  00216	48 8b 44 24 40	 mov	 rax, QWORD PTR self_len$[rsp]
  0021b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self_s$[rsp]
  00220	48 03 c8	 add	 rcx, rax
  00223	48 8b c1	 mov	 rax, rcx
  00226	48 89 44 24 58	 mov	 QWORD PTR end$[rsp], rax
$LN37@replace_su@2:

; 2054 :     while (count-- > 0) {

  0022b	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  00230	48 8b 4c 24 38	 mov	 rcx, QWORD PTR count$[rsp]
  00235	48 ff c9	 dec	 rcx
  00238	48 89 4c 24 38	 mov	 QWORD PTR count$[rsp], rcx
  0023d	48 85 c0	 test	 rax, rax
  00240	0f 8e 51 03 00
	00		 jle	 $LN36@replace_su@2

; 2055 :         offset = stringlib_find(start, end-start,
; 2056 :                                 from_s, from_len,
; 2057 :                                 0);

  00246	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0024b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR end$[rsp]
  00250	48 2b c8	 sub	 rcx, rax
  00253	48 8b c1	 mov	 rax, rcx
  00256	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0025f	4c 8b 8c 24 30
	01 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  00267	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  0026f	48 8b d0	 mov	 rdx, rax
  00272	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00277	e8 00 00 00 00	 call	 stringlib_find
  0027c	48 89 44 24 48	 mov	 QWORD PTR offset$[rsp], rax

; 2058 :         if (offset == -1)

  00281	48 83 7c 24 48
	ff		 cmp	 QWORD PTR offset$[rsp], -1
  00287	75 05		 jne	 SHORT $LN35@replace_su@2

; 2059 :             break;

  00289	e9 09 03 00 00	 jmp	 $LN36@replace_su@2
$LN35@replace_su@2:

; 2060 :         next = start+offset;

  0028e	48 8b 44 24 48	 mov	 rax, QWORD PTR offset$[rsp]
  00293	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00298	48 03 c8	 add	 rcx, rax
  0029b	48 8b c1	 mov	 rax, rcx
  0029e	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 2061 :         if (next == start) {

  002a3	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  002a8	48 39 44 24 50	 cmp	 QWORD PTR next$[rsp], rax
  002ad	0f 85 fc 00 00
	00		 jne	 $LN34@replace_su@2
$LN33@replace_su@2:

; 2062 :             /* replace with the 'to' */
; 2063 :             Py_MEMCPY(result_s, to_s, to_len);

  002b3	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  002bb	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR n_$23757[rsp], rax
  002c3	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  002c8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR t_$23758[rsp], rax
  002d0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  002d8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s_$23760[rsp], rax
  002e0	48 83 bc 24 98
	00 00 00 10	 cmp	 QWORD PTR n_$23757[rsp], 16
  002e9	72 1f		 jb	 SHORT $LN30@replace_su@2
  002eb	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR n_$23757[rsp]
  002f3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s_$23760[rsp]
  002fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t_$23758[rsp]
  00303	e8 00 00 00 00	 call	 memcpy
  00308	eb 66		 jmp	 SHORT $LN29@replace_su@2
$LN30@replace_su@2:
  0030a	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23756[rsp], 0
  00316	eb 13		 jmp	 SHORT $LN28@replace_su@2
$LN27@replace_su@2:
  00318	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i_$23756[rsp]
  00320	48 ff c0	 inc	 rax
  00323	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR i_$23756[rsp], rax
$LN28@replace_su@2:
  0032b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n_$23757[rsp]
  00333	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR i_$23756[rsp], rax
  0033b	73 33		 jae	 SHORT $LN26@replace_su@2
  0033d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i_$23756[rsp]
  00345	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t_$23758[rsp]
  0034d	48 03 c8	 add	 rcx, rax
  00350	48 8b c1	 mov	 rax, rcx
  00353	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR i_$23756[rsp]
  0035b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s_$23760[rsp]
  00363	48 03 d1	 add	 rdx, rcx
  00366	48 8b ca	 mov	 rcx, rdx
  00369	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0036c	88 08		 mov	 BYTE PTR [rax], cl
  0036e	eb a8		 jmp	 SHORT $LN27@replace_su@2
$LN26@replace_su@2:
$LN29@replace_su@2:
  00370	33 c0		 xor	 eax, eax
  00372	85 c0		 test	 eax, eax
  00374	0f 85 39 ff ff
	ff		 jne	 $LN33@replace_su@2

; 2064 :             result_s += to_len;

  0037a	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00382	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result_s$[rsp]
  00387	48 03 c8	 add	 rcx, rax
  0038a	48 8b c1	 mov	 rax, rcx
  0038d	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax

; 2065 :             start += from_len;

  00392	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  0039a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  0039f	48 03 c8	 add	 rcx, rax
  003a2	48 8b c1	 mov	 rax, rcx
  003a5	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax

; 2066 :         } else {

  003aa	e9 e3 01 00 00	 jmp	 $LN25@replace_su@2
$LN34@replace_su@2:
$LN24@replace_su@2:

; 2067 :             /* copy the unchanged old then the 'to' */
; 2068 :             Py_MEMCPY(result_s, start, next-start);

  003af	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  003b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  003b9	48 2b c8	 sub	 rcx, rax
  003bc	48 8b c1	 mov	 rax, rcx
  003bf	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR n_$23772[rsp], rax
  003c7	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  003cc	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR t_$23773[rsp], rax
  003d4	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  003d9	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s_$23775[rsp], rax
  003e1	48 83 bc 24 b8
	00 00 00 10	 cmp	 QWORD PTR n_$23772[rsp], 16
  003ea	72 1f		 jb	 SHORT $LN21@replace_su@2
  003ec	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR n_$23772[rsp]
  003f4	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR s_$23775[rsp]
  003fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR t_$23773[rsp]
  00404	e8 00 00 00 00	 call	 memcpy
  00409	eb 66		 jmp	 SHORT $LN20@replace_su@2
$LN21@replace_su@2:
  0040b	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23771[rsp], 0
  00417	eb 13		 jmp	 SHORT $LN19@replace_su@2
$LN18@replace_su@2:
  00419	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i_$23771[rsp]
  00421	48 ff c0	 inc	 rax
  00424	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR i_$23771[rsp], rax
$LN19@replace_su@2:
  0042c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n_$23772[rsp]
  00434	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR i_$23771[rsp], rax
  0043c	73 33		 jae	 SHORT $LN17@replace_su@2
  0043e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i_$23771[rsp]
  00446	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR t_$23773[rsp]
  0044e	48 03 c8	 add	 rcx, rax
  00451	48 8b c1	 mov	 rax, rcx
  00454	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR i_$23771[rsp]
  0045c	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR s_$23775[rsp]
  00464	48 03 d1	 add	 rdx, rcx
  00467	48 8b ca	 mov	 rcx, rdx
  0046a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0046d	88 08		 mov	 BYTE PTR [rax], cl
  0046f	eb a8		 jmp	 SHORT $LN18@replace_su@2
$LN17@replace_su@2:
$LN20@replace_su@2:
  00471	33 c0		 xor	 eax, eax
  00473	85 c0		 test	 eax, eax
  00475	0f 85 34 ff ff
	ff		 jne	 $LN24@replace_su@2

; 2069 :             result_s += (next-start);

  0047b	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00480	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00485	48 2b c8	 sub	 rcx, rax
  00488	48 8b c1	 mov	 rax, rcx
  0048b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result_s$[rsp]
  00490	48 03 c8	 add	 rcx, rax
  00493	48 8b c1	 mov	 rax, rcx
  00496	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax
$LN16@replace_su@2:

; 2070 :             Py_MEMCPY(result_s, to_s, to_len);

  0049b	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  004a3	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR n_$23786[rsp], rax
  004ab	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  004b0	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR t_$23787[rsp], rax
  004b8	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  004c0	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR s_$23789[rsp], rax
  004c8	48 83 bc 24 d8
	00 00 00 10	 cmp	 QWORD PTR n_$23786[rsp], 16
  004d1	72 1f		 jb	 SHORT $LN13@replace_su@2
  004d3	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR n_$23786[rsp]
  004db	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR s_$23789[rsp]
  004e3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR t_$23787[rsp]
  004eb	e8 00 00 00 00	 call	 memcpy
  004f0	eb 66		 jmp	 SHORT $LN12@replace_su@2
$LN13@replace_su@2:
  004f2	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23785[rsp], 0
  004fe	eb 13		 jmp	 SHORT $LN11@replace_su@2
$LN10@replace_su@2:
  00500	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR i_$23785[rsp]
  00508	48 ff c0	 inc	 rax
  0050b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR i_$23785[rsp], rax
$LN11@replace_su@2:
  00513	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR n_$23786[rsp]
  0051b	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR i_$23785[rsp], rax
  00523	73 33		 jae	 SHORT $LN9@replace_su@2
  00525	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR i_$23785[rsp]
  0052d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR t_$23787[rsp]
  00535	48 03 c8	 add	 rcx, rax
  00538	48 8b c1	 mov	 rax, rcx
  0053b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR i_$23785[rsp]
  00543	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR s_$23789[rsp]
  0054b	48 03 d1	 add	 rdx, rcx
  0054e	48 8b ca	 mov	 rcx, rdx
  00551	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00554	88 08		 mov	 BYTE PTR [rax], cl
  00556	eb a8		 jmp	 SHORT $LN10@replace_su@2
$LN9@replace_su@2:
$LN12@replace_su@2:
  00558	33 c0		 xor	 eax, eax
  0055a	85 c0		 test	 eax, eax
  0055c	0f 85 39 ff ff
	ff		 jne	 $LN16@replace_su@2

; 2071 :             result_s += to_len;

  00562	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  0056a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result_s$[rsp]
  0056f	48 03 c8	 add	 rcx, rax
  00572	48 8b c1	 mov	 rax, rcx
  00575	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax

; 2072 :             start = next+from_len;

  0057a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  00582	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00587	48 03 c8	 add	 rcx, rax
  0058a	48 8b c1	 mov	 rax, rcx
  0058d	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax
$LN25@replace_su@2:

; 2073 :         }
; 2074 :     }

  00592	e9 94 fc ff ff	 jmp	 $LN37@replace_su@2
$LN36@replace_su@2:
$LN8@replace_su@2:

; 2075 :     /* Copy the remainder of the remaining string */
; 2076 :     Py_MEMCPY(result_s, start, end-start);

  00597	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0059c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR end$[rsp]
  005a1	48 2b c8	 sub	 rcx, rax
  005a4	48 8b c1	 mov	 rax, rcx
  005a7	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR n_$23800[rsp], rax
  005af	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  005b4	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR t_$23801[rsp], rax
  005bc	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  005c1	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR s_$23803[rsp], rax
  005c9	48 83 bc 24 f8
	00 00 00 10	 cmp	 QWORD PTR n_$23800[rsp], 16
  005d2	72 1f		 jb	 SHORT $LN5@replace_su@2
  005d4	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR n_$23800[rsp]
  005dc	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR s_$23803[rsp]
  005e4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR t_$23801[rsp]
  005ec	e8 00 00 00 00	 call	 memcpy
  005f1	eb 66		 jmp	 SHORT $LN4@replace_su@2
$LN5@replace_su@2:
  005f3	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23799[rsp], 0
  005ff	eb 13		 jmp	 SHORT $LN3@replace_su@2
$LN2@replace_su@2:
  00601	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR i_$23799[rsp]
  00609	48 ff c0	 inc	 rax
  0060c	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR i_$23799[rsp], rax
$LN3@replace_su@2:
  00614	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR n_$23800[rsp]
  0061c	48 39 84 24 f0
	00 00 00	 cmp	 QWORD PTR i_$23799[rsp], rax
  00624	73 33		 jae	 SHORT $LN1@replace_su@2
  00626	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR i_$23799[rsp]
  0062e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR t_$23801[rsp]
  00636	48 03 c8	 add	 rcx, rax
  00639	48 8b c1	 mov	 rax, rcx
  0063c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR i_$23799[rsp]
  00644	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR s_$23803[rsp]
  0064c	48 03 d1	 add	 rdx, rcx
  0064f	48 8b ca	 mov	 rcx, rdx
  00652	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00655	88 08		 mov	 BYTE PTR [rax], cl
  00657	eb a8		 jmp	 SHORT $LN2@replace_su@2
$LN1@replace_su@2:
$LN4@replace_su@2:
  00659	33 c0		 xor	 eax, eax
  0065b	85 c0		 test	 eax, eax
  0065d	0f 85 34 ff ff
	ff		 jne	 $LN8@replace_su@2

; 2077 : 
; 2078 :     return result;

  00663	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
$LN41@replace_su@2:

; 2079 : }

  00668	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0066f	c3		 ret	 0
replace_substring ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@ ; `string'
EXTRN	PyBool_FromLong:PROC
EXTRN	PyErr_ExceptionMatches:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_startswith DD imagerel bytes_startswith
	DD	imagerel bytes_startswith+383
	DD	imagerel $unwind$bytes_startswith
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_startswith DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@
CONST	SEGMENT
??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@ DB 'startswith '
	DB	'first arg must be bytes or a tuple of bytes, not %s', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_startswith
_TEXT	SEGMENT
end$ = 48
start$ = 56
result$ = 64
subobj$ = 72
i$23955 = 80
self$ = 112
args$ = 120
bytes_startswith PROC					; COMDAT

; 2245 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2246 :     Py_ssize_t start = 0;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0

; 2247 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  00017	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00021	48 89 44 24 30	 mov	 QWORD PTR end$[rsp], rax

; 2248 :     PyObject *subobj;
; 2249 :     int result;
; 2250 : 
; 2251 :     if (!stringlib_parse_args_finds("startswith", args, &subobj, &start, &end))

  00026	48 8d 44 24 30	 lea	 rax, QWORD PTR end$[rsp]
  0002b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00030	4c 8d 4c 24 38	 lea	 r9, QWORD PTR start$[rsp]
  00035	4c 8d 44 24 48	 lea	 r8, QWORD PTR subobj$[rsp]
  0003a	48 8b 54 24 78	 mov	 rdx, QWORD PTR args$[rsp]
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@MPOGHCCL@startswith?$AA@
  00046	e8 00 00 00 00	 call	 stringlib_parse_args_finds
  0004b	85 c0		 test	 eax, eax
  0004d	75 07		 jne	 SHORT $LN11@bytes_star

; 2252 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 24 01 00 00	 jmp	 $LN12@bytes_star
$LN11@bytes_star:

; 2253 :     if (PyTuple_Check(subobj)) {

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  0005b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00065	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 9d 00 00
	00		 je	 $LN10@bytes_star

; 2254 :         Py_ssize_t i;
; 2255 :         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  00072	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$23955[rsp], 0
  0007b	eb 0d		 jmp	 SHORT $LN9@bytes_star
$LN8@bytes_star:
  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR i$23955[rsp]
  00082	48 ff c0	 inc	 rax
  00085	48 89 44 24 50	 mov	 QWORD PTR i$23955[rsp], rax
$LN9@bytes_star:
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  0008f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00093	48 39 44 24 50	 cmp	 QWORD PTR i$23955[rsp], rax
  00098	7d 60		 jge	 SHORT $LN7@bytes_star

; 2256 :             result = _bytes_tailmatch(self,
; 2257 :                             PyTuple_GET_ITEM(subobj, i),
; 2258 :                             start, end, -1);

  0009a	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  000a2	4c 8b 4c 24 30	 mov	 r9, QWORD PTR end$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR start$[rsp]
  000ac	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$23955[rsp]
  000b6	48 8b 54 c8 70	 mov	 rdx, QWORD PTR [rax+rcx*8+112]
  000bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000c0	e8 00 00 00 00	 call	 _bytes_tailmatch
  000c5	89 44 24 40	 mov	 DWORD PTR result$[rsp], eax

; 2259 :             if (result == -1)

  000c9	83 7c 24 40 ff	 cmp	 DWORD PTR result$[rsp], -1
  000ce	75 09		 jne	 SHORT $LN6@bytes_star

; 2260 :                 return NULL;

  000d0	33 c0		 xor	 eax, eax
  000d2	e9 a3 00 00 00	 jmp	 $LN12@bytes_star
  000d7	eb 1f		 jmp	 SHORT $LN5@bytes_star
$LN6@bytes_star:

; 2261 :             else if (result) {

  000d9	83 7c 24 40 00	 cmp	 DWORD PTR result$[rsp], 0
  000de	74 18		 je	 SHORT $LN4@bytes_star

; 2262 :                 Py_RETURN_TRUE;

  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000e7	e8 00 00 00 00	 call	 _Py_IncRef
  000ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000f3	e9 82 00 00 00	 jmp	 $LN12@bytes_star
$LN4@bytes_star:
$LN5@bytes_star:

; 2263 :             }
; 2264 :         }

  000f8	eb 83		 jmp	 SHORT $LN8@bytes_star
$LN7@bytes_star:

; 2265 :         Py_RETURN_FALSE;

  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00101	e8 00 00 00 00	 call	 _Py_IncRef
  00106	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0010d	eb 6b		 jmp	 SHORT $LN12@bytes_star
$LN10@bytes_star:

; 2266 :     }
; 2267 :     result = _bytes_tailmatch(self, subobj, start, end, -1);

  0010f	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  00117	4c 8b 4c 24 30	 mov	 r9, QWORD PTR end$[rsp]
  0011c	4c 8b 44 24 38	 mov	 r8, QWORD PTR start$[rsp]
  00121	48 8b 54 24 48	 mov	 rdx, QWORD PTR subobj$[rsp]
  00126	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0012b	e8 00 00 00 00	 call	 _bytes_tailmatch
  00130	89 44 24 40	 mov	 DWORD PTR result$[rsp], eax

; 2268 :     if (result == -1) {

  00134	83 7c 24 40 ff	 cmp	 DWORD PTR result$[rsp], -1
  00139	75 36		 jne	 SHORT $LN3@bytes_star

; 2269 :         if (PyErr_ExceptionMatches(PyExc_TypeError))

  0013b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00142	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00147	85 c0		 test	 eax, eax
  00149	74 20		 je	 SHORT $LN2@bytes_star

; 2270 :             PyErr_Format(PyExc_TypeError, "startswith first arg must be bytes "
; 2271 :                          "or a tuple of bytes, not %s", Py_TYPE(subobj)->tp_name);

  0014b	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  00150	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00154	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@
  0015f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00166	e8 00 00 00 00	 call	 PyErr_Format
$LN2@bytes_star:

; 2272 :         return NULL;

  0016b	33 c0		 xor	 eax, eax
  0016d	eb 0b		 jmp	 SHORT $LN12@bytes_star

; 2273 :     }
; 2274 :     else

  0016f	eb 09		 jmp	 SHORT $LN1@bytes_star
$LN3@bytes_star:

; 2275 :         return PyBool_FromLong(result);

  00171	8b 4c 24 40	 mov	 ecx, DWORD PTR result$[rsp]
  00175	e8 00 00 00 00	 call	 PyBool_FromLong
$LN1@bytes_star:
$LN12@bytes_star:

; 2276 : }

  0017a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017e	c3		 ret	 0
bytes_startswith ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@PFNANHJD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAu?$AAb?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_bytes_tailmatch DD imagerel _bytes_tailmatch
	DD	imagerel _bytes_tailmatch+688
	DD	imagerel $unwind$_bytes_tailmatch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_bytes_tailmatch DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT ??_C@_1CM@PFNANHJD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAu?$AAb?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@PFNANHJD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAu?$AAb?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 't', 00H, 'r', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _bytes_tailmatch
_TEXT	SEGMENT
slen$ = 32
len$ = 40
sub$ = 48
str$ = 56
tv165 = 64
self$ = 96
substr$ = 104
start$ = 112
end$ = 120
direction$ = 128
_bytes_tailmatch PROC					; COMDAT

; 2201 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2202 :     Py_ssize_t len = PyBytes_GET_SIZE(self);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00027	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0002c	85 c0		 test	 eax, eax
  0002e	75 1c		 jne	 SHORT $LN19@bytes_tail
  00030	41 b8 9a 08 00
	00		 mov	 r8d, 2202		; 0000089aH
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004a	33 c0		 xor	 eax, eax
$LN19@bytes_tail:
  0004c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00051	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00055	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 2203 :     Py_ssize_t slen;
; 2204 :     const char* sub;
; 2205 :     const char* str;
; 2206 : 
; 2207 :     if (PyBytes_Check(substr)) {

  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR substr$[rsp]
  0005f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00063	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00069	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0006e	85 c0		 test	 eax, eax
  00070	0f 84 86 00 00
	00		 je	 $LN16@bytes_tail

; 2208 :         sub = PyBytes_AS_STRING(substr);

  00076	48 8b 44 24 68	 mov	 rax, QWORD PTR substr$[rsp]
  0007b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0007f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00085	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0008a	85 c0		 test	 eax, eax
  0008c	75 1c		 jne	 SHORT $LN20@bytes_tail
  0008e	41 b8 a0 08 00
	00		 mov	 r8d, 2208		; 000008a0H
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@PFNANHJD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAu?$AAb?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a8	33 c0		 xor	 eax, eax
$LN20@bytes_tail:
  000aa	48 8b 44 24 68	 mov	 rax, QWORD PTR substr$[rsp]
  000af	48 83 c0 78	 add	 rax, 120		; 00000078H
  000b3	48 89 44 24 30	 mov	 QWORD PTR sub$[rsp], rax

; 2209 :         slen = PyBytes_GET_SIZE(substr);

  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR substr$[rsp]
  000bd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000c1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000c7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000cc	85 c0		 test	 eax, eax
  000ce	75 1c		 jne	 SHORT $LN21@bytes_tail
  000d0	41 b8 a1 08 00
	00		 mov	 r8d, 2209		; 000008a1H
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@PFNANHJD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAu?$AAb?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ea	33 c0		 xor	 eax, eax
$LN21@bytes_tail:
  000ec	48 8b 44 24 68	 mov	 rax, QWORD PTR substr$[rsp]
  000f1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000f5	48 89 44 24 20	 mov	 QWORD PTR slen$[rsp], rax
  000fa	eb 22		 jmp	 SHORT $LN15@bytes_tail
$LN16@bytes_tail:

; 2210 :     }
; 2211 :     else if (PyObject_AsCharBuffer(substr, &sub, &slen))

  000fc	4c 8d 44 24 20	 lea	 r8, QWORD PTR slen$[rsp]
  00101	48 8d 54 24 30	 lea	 rdx, QWORD PTR sub$[rsp]
  00106	48 8b 4c 24 68	 mov	 rcx, QWORD PTR substr$[rsp]
  0010b	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  00110	85 c0		 test	 eax, eax
  00112	74 0a		 je	 SHORT $LN14@bytes_tail

; 2212 :         return -1;

  00114	b8 ff ff ff ff	 mov	 eax, -1
  00119	e9 8d 01 00 00	 jmp	 $LN17@bytes_tail
$LN14@bytes_tail:
$LN15@bytes_tail:

; 2213 :     str = PyBytes_AS_STRING(self);

  0011e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00123	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00127	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0012d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00132	85 c0		 test	 eax, eax
  00134	75 1c		 jne	 SHORT $LN22@bytes_tail
  00136	41 b8 a5 08 00
	00		 mov	 r8d, 2213		; 000008a5H
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00150	33 c0		 xor	 eax, eax
$LN22@bytes_tail:
  00152	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00157	48 83 c0 78	 add	 rax, 120		; 00000078H
  0015b	48 89 44 24 38	 mov	 QWORD PTR str$[rsp], rax

; 2214 : 
; 2215 :     ADJUST_INDICES(start, end, len);

  00160	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00165	48 39 44 24 78	 cmp	 QWORD PTR end$[rsp], rax
  0016a	7e 0c		 jle	 SHORT $LN13@bytes_tail
  0016c	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00171	48 89 44 24 78	 mov	 QWORD PTR end$[rsp], rax
  00176	eb 2e		 jmp	 SHORT $LN12@bytes_tail
$LN13@bytes_tail:
  00178	48 83 7c 24 78
	00		 cmp	 QWORD PTR end$[rsp], 0
  0017e	7d 26		 jge	 SHORT $LN11@bytes_tail
  00180	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR end$[rsp]
  0018a	48 03 c8	 add	 rcx, rax
  0018d	48 8b c1	 mov	 rax, rcx
  00190	48 89 44 24 78	 mov	 QWORD PTR end$[rsp], rax
  00195	48 83 7c 24 78
	00		 cmp	 QWORD PTR end$[rsp], 0
  0019b	7d 09		 jge	 SHORT $LN10@bytes_tail
  0019d	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR end$[rsp], 0
$LN10@bytes_tail:
$LN11@bytes_tail:
$LN12@bytes_tail:
  001a6	48 83 7c 24 70
	00		 cmp	 QWORD PTR start$[rsp], 0
  001ac	7d 26		 jge	 SHORT $LN9@bytes_tail
  001ae	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  001b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR start$[rsp]
  001b8	48 03 c8	 add	 rcx, rax
  001bb	48 8b c1	 mov	 rax, rcx
  001be	48 89 44 24 70	 mov	 QWORD PTR start$[rsp], rax
  001c3	48 83 7c 24 70
	00		 cmp	 QWORD PTR start$[rsp], 0
  001c9	7d 09		 jge	 SHORT $LN8@bytes_tail
  001cb	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
$LN8@bytes_tail:
$LN9@bytes_tail:

; 2216 : 
; 2217 :     if (direction < 0) {

  001d4	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR direction$[rsp], 0
  001dc	7d 20		 jge	 SHORT $LN7@bytes_tail

; 2218 :         /* startswith */
; 2219 :         if (start+slen > len)

  001de	48 8b 44 24 20	 mov	 rax, QWORD PTR slen$[rsp]
  001e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR start$[rsp]
  001e8	48 03 c8	 add	 rcx, rax
  001eb	48 8b c1	 mov	 rax, rcx
  001ee	48 3b 44 24 28	 cmp	 rax, QWORD PTR len$[rsp]
  001f3	7e 07		 jle	 SHORT $LN6@bytes_tail

; 2220 :             return 0;

  001f5	33 c0		 xor	 eax, eax
  001f7	e9 af 00 00 00	 jmp	 $LN17@bytes_tail
$LN6@bytes_tail:

; 2221 :     } else {

  001fc	eb 56		 jmp	 SHORT $LN5@bytes_tail
$LN7@bytes_tail:

; 2222 :         /* endswith */
; 2223 :         if (end-start < slen || start > len)

  001fe	48 8b 44 24 70	 mov	 rax, QWORD PTR start$[rsp]
  00203	48 8b 4c 24 78	 mov	 rcx, QWORD PTR end$[rsp]
  00208	48 2b c8	 sub	 rcx, rax
  0020b	48 8b c1	 mov	 rax, rcx
  0020e	48 3b 44 24 20	 cmp	 rax, QWORD PTR slen$[rsp]
  00213	7c 0c		 jl	 SHORT $LN3@bytes_tail
  00215	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0021a	48 39 44 24 70	 cmp	 QWORD PTR start$[rsp], rax
  0021f	7e 07		 jle	 SHORT $LN4@bytes_tail
$LN3@bytes_tail:

; 2224 :             return 0;

  00221	33 c0		 xor	 eax, eax
  00223	e9 83 00 00 00	 jmp	 $LN17@bytes_tail
$LN4@bytes_tail:

; 2225 : 
; 2226 :         if (end-slen > start)

  00228	48 8b 44 24 20	 mov	 rax, QWORD PTR slen$[rsp]
  0022d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR end$[rsp]
  00232	48 2b c8	 sub	 rcx, rax
  00235	48 8b c1	 mov	 rax, rcx
  00238	48 3b 44 24 70	 cmp	 rax, QWORD PTR start$[rsp]
  0023d	7e 15		 jle	 SHORT $LN2@bytes_tail

; 2227 :             start = end - slen;

  0023f	48 8b 44 24 20	 mov	 rax, QWORD PTR slen$[rsp]
  00244	48 8b 4c 24 78	 mov	 rcx, QWORD PTR end$[rsp]
  00249	48 2b c8	 sub	 rcx, rax
  0024c	48 8b c1	 mov	 rax, rcx
  0024f	48 89 44 24 70	 mov	 QWORD PTR start$[rsp], rax
$LN2@bytes_tail:
$LN5@bytes_tail:

; 2228 :     }
; 2229 :     if (end-start >= slen)

  00254	48 8b 44 24 70	 mov	 rax, QWORD PTR start$[rsp]
  00259	48 8b 4c 24 78	 mov	 rcx, QWORD PTR end$[rsp]
  0025e	48 2b c8	 sub	 rcx, rax
  00261	48 8b c1	 mov	 rax, rcx
  00264	48 3b 44 24 20	 cmp	 rax, QWORD PTR slen$[rsp]
  00269	7c 3e		 jl	 SHORT $LN1@bytes_tail

; 2230 :         return ! memcmp(str+start, sub, slen);

  0026b	48 8b 44 24 70	 mov	 rax, QWORD PTR start$[rsp]
  00270	48 8b 4c 24 38	 mov	 rcx, QWORD PTR str$[rsp]
  00275	48 03 c8	 add	 rcx, rax
  00278	48 8b c1	 mov	 rax, rcx
  0027b	4c 8b 44 24 20	 mov	 r8, QWORD PTR slen$[rsp]
  00280	48 8b 54 24 30	 mov	 rdx, QWORD PTR sub$[rsp]
  00285	48 8b c8	 mov	 rcx, rax
  00288	e8 00 00 00 00	 call	 memcmp
  0028d	85 c0		 test	 eax, eax
  0028f	75 0a		 jne	 SHORT $LN23@bytes_tail
  00291	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv165[rsp], 1
  00299	eb 08		 jmp	 SHORT $LN24@bytes_tail
$LN23@bytes_tail:
  0029b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN24@bytes_tail:
  002a3	8b 44 24 40	 mov	 eax, DWORD PTR tv165[rsp]
  002a7	eb 02		 jmp	 SHORT $LN17@bytes_tail
$LN1@bytes_tail:

; 2231 :     return 0;

  002a9	33 c0		 xor	 eax, eax
$LN17@bytes_tail:

; 2232 : }

  002ab	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002af	c3		 ret	 0
_bytes_tailmatch ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_endswith DD imagerel bytes_endswith
	DD	imagerel bytes_endswith+383
	DD	imagerel $unwind$bytes_endswith
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_endswith DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@
CONST	SEGMENT
??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@ DB 'endswith fi'
	DB	'rst arg must be bytes or a tuple of bytes, not %s', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_endswith
_TEXT	SEGMENT
end$ = 48
start$ = 56
result$ = 64
subobj$ = 72
i$23995 = 80
self$ = 112
args$ = 120
bytes_endswith PROC					; COMDAT

; 2289 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2290 :     Py_ssize_t start = 0;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0

; 2291 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  00017	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00021	48 89 44 24 30	 mov	 QWORD PTR end$[rsp], rax

; 2292 :     PyObject *subobj;
; 2293 :     int result;
; 2294 : 
; 2295 :     if (!stringlib_parse_args_finds("endswith", args, &subobj, &start, &end))

  00026	48 8d 44 24 30	 lea	 rax, QWORD PTR end$[rsp]
  0002b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00030	4c 8d 4c 24 38	 lea	 r9, QWORD PTR start$[rsp]
  00035	4c 8d 44 24 48	 lea	 r8, QWORD PTR subobj$[rsp]
  0003a	48 8b 54 24 78	 mov	 rdx, QWORD PTR args$[rsp]
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08MLCMCPNP@endswith?$AA@
  00046	e8 00 00 00 00	 call	 stringlib_parse_args_finds
  0004b	85 c0		 test	 eax, eax
  0004d	75 07		 jne	 SHORT $LN11@bytes_ends

; 2296 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 24 01 00 00	 jmp	 $LN12@bytes_ends
$LN11@bytes_ends:

; 2297 :     if (PyTuple_Check(subobj)) {

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  0005b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00065	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 9d 00 00
	00		 je	 $LN10@bytes_ends

; 2298 :         Py_ssize_t i;
; 2299 :         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  00072	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$23995[rsp], 0
  0007b	eb 0d		 jmp	 SHORT $LN9@bytes_ends
$LN8@bytes_ends:
  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR i$23995[rsp]
  00082	48 ff c0	 inc	 rax
  00085	48 89 44 24 50	 mov	 QWORD PTR i$23995[rsp], rax
$LN9@bytes_ends:
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  0008f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00093	48 39 44 24 50	 cmp	 QWORD PTR i$23995[rsp], rax
  00098	7d 60		 jge	 SHORT $LN7@bytes_ends

; 2300 :             result = _bytes_tailmatch(self,
; 2301 :                             PyTuple_GET_ITEM(subobj, i),
; 2302 :                             start, end, +1);

  0009a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000a2	4c 8b 4c 24 30	 mov	 r9, QWORD PTR end$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR start$[rsp]
  000ac	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$23995[rsp]
  000b6	48 8b 54 c8 70	 mov	 rdx, QWORD PTR [rax+rcx*8+112]
  000bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000c0	e8 00 00 00 00	 call	 _bytes_tailmatch
  000c5	89 44 24 40	 mov	 DWORD PTR result$[rsp], eax

; 2303 :             if (result == -1)

  000c9	83 7c 24 40 ff	 cmp	 DWORD PTR result$[rsp], -1
  000ce	75 09		 jne	 SHORT $LN6@bytes_ends

; 2304 :                 return NULL;

  000d0	33 c0		 xor	 eax, eax
  000d2	e9 a3 00 00 00	 jmp	 $LN12@bytes_ends
  000d7	eb 1f		 jmp	 SHORT $LN5@bytes_ends
$LN6@bytes_ends:

; 2305 :             else if (result) {

  000d9	83 7c 24 40 00	 cmp	 DWORD PTR result$[rsp], 0
  000de	74 18		 je	 SHORT $LN4@bytes_ends

; 2306 :                 Py_RETURN_TRUE;

  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000e7	e8 00 00 00 00	 call	 _Py_IncRef
  000ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000f3	e9 82 00 00 00	 jmp	 $LN12@bytes_ends
$LN4@bytes_ends:
$LN5@bytes_ends:

; 2307 :             }
; 2308 :         }

  000f8	eb 83		 jmp	 SHORT $LN8@bytes_ends
$LN7@bytes_ends:

; 2309 :         Py_RETURN_FALSE;

  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00101	e8 00 00 00 00	 call	 _Py_IncRef
  00106	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0010d	eb 6b		 jmp	 SHORT $LN12@bytes_ends
$LN10@bytes_ends:

; 2310 :     }
; 2311 :     result = _bytes_tailmatch(self, subobj, start, end, +1);

  0010f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00117	4c 8b 4c 24 30	 mov	 r9, QWORD PTR end$[rsp]
  0011c	4c 8b 44 24 38	 mov	 r8, QWORD PTR start$[rsp]
  00121	48 8b 54 24 48	 mov	 rdx, QWORD PTR subobj$[rsp]
  00126	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0012b	e8 00 00 00 00	 call	 _bytes_tailmatch
  00130	89 44 24 40	 mov	 DWORD PTR result$[rsp], eax

; 2312 :     if (result == -1) {

  00134	83 7c 24 40 ff	 cmp	 DWORD PTR result$[rsp], -1
  00139	75 36		 jne	 SHORT $LN3@bytes_ends

; 2313 :         if (PyErr_ExceptionMatches(PyExc_TypeError))

  0013b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00142	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00147	85 c0		 test	 eax, eax
  00149	74 20		 je	 SHORT $LN2@bytes_ends

; 2314 :             PyErr_Format(PyExc_TypeError, "endswith first arg must be bytes or "
; 2315 :                          "a tuple of bytes, not %s", Py_TYPE(subobj)->tp_name);

  0014b	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  00150	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00154	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@
  0015f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00166	e8 00 00 00 00	 call	 PyErr_Format
$LN2@bytes_ends:

; 2316 :         return NULL;

  0016b	33 c0		 xor	 eax, eax
  0016d	eb 0b		 jmp	 SHORT $LN12@bytes_ends

; 2317 :     }
; 2318 :     else

  0016f	eb 09		 jmp	 SHORT $LN1@bytes_ends
$LN3@bytes_ends:

; 2319 :         return PyBool_FromLong(result);

  00171	8b 4c 24 40	 mov	 ecx, DWORD PTR result$[rsp]
  00175	e8 00 00 00 00	 call	 PyBool_FromLong
$LN1@bytes_ends:
$LN12@bytes_ends:

; 2320 : }

  0017a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017e	c3		 ret	 0
bytes_endswith ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@		; `string'
EXTRN	PyUnicode_FromEncodedObject:PROC
EXTRN	PyUnicode_GetDefaultEncoding:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_decode DD imagerel bytes_decode
	DD	imagerel bytes_decode+137
	DD	imagerel $unwind$bytes_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_decode DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@
CONST	SEGMENT
??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@ DB '|ss:decode', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_decode
_TEXT	SEGMENT
errors$ = 48
encoding$ = 56
self$ = 80
args$ = 88
kwargs$ = 96
bytes_decode PROC					; COMDAT

; 2335 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2336 :     const char *encoding = NULL;

  00013	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR encoding$[rsp], 0

; 2337 :     const char *errors = NULL;

  0001c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR errors$[rsp], 0

; 2338 :     static char *kwlist[] = {"encoding", "errors", 0};
; 2339 : 
; 2340 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ss:decode", kwlist, &encoding, &errors))

  00025	48 8d 44 24 30	 lea	 rax, QWORD PTR errors$[rsp]
  0002a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002f	48 8d 44 24 38	 lea	 rax, QWORD PTR encoding$[rsp]
  00034	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00039	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytes_decode@@9@9
  00040	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@
  00047	48 8b 54 24 60	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0004c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00051	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00056	85 c0		 test	 eax, eax
  00058	75 04		 jne	 SHORT $LN2@bytes_deco

; 2341 :         return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb 26		 jmp	 SHORT $LN3@bytes_deco
$LN2@bytes_deco:

; 2342 :     if (encoding == NULL)

  0005e	48 83 7c 24 38
	00		 cmp	 QWORD PTR encoding$[rsp], 0
  00064	75 0a		 jne	 SHORT $LN1@bytes_deco

; 2343 :         encoding = PyUnicode_GetDefaultEncoding();

  00066	e8 00 00 00 00	 call	 PyUnicode_GetDefaultEncoding
  0006b	48 89 44 24 38	 mov	 QWORD PTR encoding$[rsp], rax
$LN1@bytes_deco:

; 2344 :     return PyUnicode_FromEncodedObject(self, encoding, errors);

  00070	4c 8b 44 24 30	 mov	 r8, QWORD PTR errors$[rsp]
  00075	48 8b 54 24 38	 mov	 rdx, QWORD PTR encoding$[rsp]
  0007a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0007f	e8 00 00 00 00	 call	 PyUnicode_FromEncodedObject
$LN3@bytes_deco:

; 2345 : }

  00084	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00088	c3		 ret	 0
bytes_decode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_splitlines DD imagerel bytes_splitlines
	DD	imagerel bytes_splitlines+222
	DD	imagerel $unwind$bytes_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_splitlines DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@
CONST	SEGMENT
??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@ DB '|i:splitlines', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_splitlines
_TEXT	SEGMENT
keepends$ = 48
self$ = 80
args$ = 88
kwds$ = 96
bytes_splitlines PROC					; COMDAT

; 2357 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2358 :     static char *kwlist[] = {"keepends", 0};
; 2359 :     int keepends = 0;

  00013	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR keepends$[rsp], 0

; 2360 : 
; 2361 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|i:splitlines",
; 2362 :                                      kwlist, &keepends))

  0001b	48 8d 44 24 30	 lea	 rax, QWORD PTR keepends$[rsp]
  00020	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00025	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytes_splitlines@@9@9
  0002c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@
  00033	48 8b 54 24 60	 mov	 rdx, QWORD PTR kwds$[rsp]
  00038	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0003d	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00042	85 c0		 test	 eax, eax
  00044	75 07		 jne	 SHORT $LN1@bytes_spli@2

; 2363 :         return NULL;

  00046	33 c0		 xor	 eax, eax
  00048	e9 8c 00 00 00	 jmp	 $LN2@bytes_spli@2
$LN1@bytes_spli@2:

; 2364 : 
; 2365 :     return stringlib_splitlines(
; 2366 :         (PyObject*) self, PyBytes_AS_STRING(self),
; 2367 :         PyBytes_GET_SIZE(self), keepends
; 2368 :         );

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00052	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00056	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00061	85 c0		 test	 eax, eax
  00063	75 1c		 jne	 SHORT $LN4@bytes_spli@2
  00065	41 b8 3f 09 00
	00		 mov	 r8d, 2367		; 0000093fH
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007f	33 c0		 xor	 eax, eax
$LN4@bytes_spli@2:
  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00086	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00090	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00095	85 c0		 test	 eax, eax
  00097	75 1c		 jne	 SHORT $LN5@bytes_spli@2
  00099	41 b8 3e 09 00
	00		 mov	 r8d, 2366		; 0000093eH
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KFCJBGEE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b3	33 c0		 xor	 eax, eax
$LN5@bytes_spli@2:
  000b5	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ba	48 83 c0 78	 add	 rax, 120		; 00000078H
  000be	44 8b 4c 24 30	 mov	 r9d, DWORD PTR keepends$[rsp]
  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000c8	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000d4	e8 00 00 00 00	 call	 stringlib_splitlines
$LN2@bytes_spli@2:

; 2369 : }

  000d9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000dd	c3		 ret	 0
bytes_splitlines ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\split.h
pdata	SEGMENT
$pdata$stringlib_splitlines DD imagerel stringlib_splitlines
	DD	imagerel stringlib_splitlines+491
	DD	imagerel $unwind$stringlib_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_splitlines DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_splitlines
_TEXT	SEGMENT
i$ = 32
list$ = 40
sub$ = 48
j$ = 56
eol$21718 = 64
str_obj$ = 96
str$ = 104
str_len$ = 112
keepends$ = 120
stringlib_splitlines PROC				; COMDAT

; 339  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 340  :     /* This does not use the preallocated list because splitlines is
; 341  :        usually run with hundreds of newlines.  The overhead of
; 342  :        switching between PyList_SET_ITEM and append causes about a
; 343  :        2-3% slowdown for that common case.  A smarter implementation
; 344  :        could move the if check out, so the SET_ITEMs are done first
; 345  :        and the appends only done when the prealloc buffer is full.
; 346  :        That's too much work for little gain.*/
; 347  : 
; 348  :     register Py_ssize_t i;
; 349  :     register Py_ssize_t j;
; 350  :     PyObject *list = PyList_New(0);

  00018	33 c9		 xor	 ecx, ecx
  0001a	e8 00 00 00 00	 call	 PyList_New
  0001f	48 89 44 24 28	 mov	 QWORD PTR list$[rsp], rax

; 351  :     PyObject *sub;
; 352  : 
; 353  :     if (list == NULL)

  00024	48 83 7c 24 28
	00		 cmp	 QWORD PTR list$[rsp], 0
  0002a	75 07		 jne	 SHORT $LN14@stringlib_@34

; 354  :         return NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 b3 01 00 00	 jmp	 $LN15@stringlib_@34
$LN14@stringlib_@34:

; 355  : 
; 356  :     for (i = j = 0; i < str_len; ) {

  00033	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  00041	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN13@stringlib_@34:
  00046	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  0004b	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00050	0f 8d 7d 01 00
	00		 jge	 $LN12@stringlib_@34
$LN11@stringlib_@34:

; 357  :         Py_ssize_t eol;
; 358  : 
; 359  :         /* Find a line and append it */
; 360  :         while (i < str_len && !STRINGLIB_ISLINEBREAK(str[i]))

  00056	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  0005b	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00060	7d 3f		 jge	 SHORT $LN10@stringlib_@34
  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00067	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  0006c	48 03 c8	 add	 rcx, rax
  0006f	48 8b c1	 mov	 rax, rcx
  00072	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00075	83 f8 0a	 cmp	 eax, 10
  00078	74 27		 je	 SHORT $LN10@stringlib_@34
  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0007f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0008d	83 f8 0d	 cmp	 eax, 13
  00090	74 0f		 je	 SHORT $LN10@stringlib_@34

; 361  :             i++;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00097	48 ff c0	 inc	 rax
  0009a	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  0009f	eb b5		 jmp	 SHORT $LN11@stringlib_@34
$LN10@stringlib_@34:

; 362  : 
; 363  :         /* Skip the line break reading CRLF as one line break */
; 364  :         eol = i;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000a6	48 89 44 24 40	 mov	 QWORD PTR eol$21718[rsp], rax

; 365  :         if (i < str_len) {

  000ab	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  000b0	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000b5	7d 6e		 jge	 SHORT $LN9@stringlib_@34

; 366  :             if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')

  000b7	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000c1	48 03 c8	 add	 rcx, rax
  000c4	48 8b c1	 mov	 rax, rcx
  000c7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ca	83 f8 0d	 cmp	 eax, 13
  000cd	75 38		 jne	 SHORT $LN8@stringlib_@34
  000cf	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000d4	48 ff c0	 inc	 rax
  000d7	48 3b 44 24 70	 cmp	 rax, QWORD PTR str_len$[rsp]
  000dc	7d 29		 jge	 SHORT $LN8@stringlib_@34
  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000e8	48 03 c8	 add	 rcx, rax
  000eb	48 8b c1	 mov	 rax, rcx
  000ee	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000f2	83 f8 0a	 cmp	 eax, 10
  000f5	75 10		 jne	 SHORT $LN8@stringlib_@34

; 367  :                 i += 2;

  000f7	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000fc	48 83 c0 02	 add	 rax, 2
  00100	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 368  :             else

  00105	eb 0d		 jmp	 SHORT $LN7@stringlib_@34
$LN8@stringlib_@34:

; 369  :                 i++;

  00107	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0010c	48 ff c0	 inc	 rax
  0010f	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN7@stringlib_@34:

; 370  :             if (keepends)

  00114	83 7c 24 78 00	 cmp	 DWORD PTR keepends$[rsp], 0
  00119	74 0a		 je	 SHORT $LN6@stringlib_@34

; 371  :                 eol = i;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00120	48 89 44 24 40	 mov	 QWORD PTR eol$21718[rsp], rax
$LN6@stringlib_@34:
$LN9@stringlib_@34:

; 372  :         }
; 373  : #ifndef STRINGLIB_MUTABLE
; 374  :         if (j == 0 && eol == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {

  00125	48 83 7c 24 38
	00		 cmp	 QWORD PTR j$[rsp], 0
  0012b	75 35		 jne	 SHORT $LN5@stringlib_@34
  0012d	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00132	48 39 44 24 40	 cmp	 QWORD PTR eol$21718[rsp], rax
  00137	75 29		 jne	 SHORT $LN5@stringlib_@34
  00139	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00140	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_obj$[rsp]
  00145	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00149	75 17		 jne	 SHORT $LN5@stringlib_@34

; 375  :             /* No linebreak in str_obj, so just use it as list[0] */
; 376  :             if (PyList_Append(list, str_obj))

  0014b	48 8b 54 24 60	 mov	 rdx, QWORD PTR str_obj$[rsp]
  00150	48 8b 4c 24 28	 mov	 rcx, QWORD PTR list$[rsp]
  00155	e8 00 00 00 00	 call	 PyList_Append
  0015a	85 c0		 test	 eax, eax
  0015c	74 02		 je	 SHORT $LN4@stringlib_@34

; 377  :                 goto onError;

  0015e	eb 7a		 jmp	 SHORT $onError$21729
$LN4@stringlib_@34:

; 378  :             break;

  00160	eb 71		 jmp	 SHORT $LN12@stringlib_@34
$LN5@stringlib_@34:

; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  00162	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  00167	48 8b 4c 24 40	 mov	 rcx, QWORD PTR eol$21718[rsp]
  0016c	48 2b c8	 sub	 rcx, rax
  0016f	48 8b c1	 mov	 rax, rcx
  00172	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  00177	48 8b 54 24 68	 mov	 rdx, QWORD PTR str$[rsp]
  0017c	48 03 d1	 add	 rdx, rcx
  0017f	48 8b ca	 mov	 rcx, rdx
  00182	48 8b d0	 mov	 rdx, rax
  00185	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0018a	48 89 44 24 30	 mov	 QWORD PTR sub$[rsp], rax
  0018f	48 83 7c 24 30
	00		 cmp	 QWORD PTR sub$[rsp], 0
  00195	75 02		 jne	 SHORT $LN3@stringlib_@34
  00197	eb 41		 jmp	 SHORT $onError$21729
$LN3@stringlib_@34:
  00199	48 8b 54 24 30	 mov	 rdx, QWORD PTR sub$[rsp]
  0019e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR list$[rsp]
  001a3	e8 00 00 00 00	 call	 PyList_Append
  001a8	85 c0		 test	 eax, eax
  001aa	74 0e		 je	 SHORT $LN2@stringlib_@34
  001ac	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sub$[rsp]
  001b1	e8 00 00 00 00	 call	 _Py_DecRef
  001b6	eb 22		 jmp	 SHORT $onError$21729
  001b8	eb 0a		 jmp	 SHORT $LN1@stringlib_@34
$LN2@stringlib_@34:
  001ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sub$[rsp]
  001bf	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@stringlib_@34:

; 382  :         j = i;

  001c4	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  001c9	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax

; 383  :     }

  001ce	e9 73 fe ff ff	 jmp	 $LN13@stringlib_@34
$LN12@stringlib_@34:

; 384  :     return list;

  001d3	48 8b 44 24 28	 mov	 rax, QWORD PTR list$[rsp]
  001d8	eb 0c		 jmp	 SHORT $LN15@stringlib_@34
$onError$21729:

; 385  : 
; 386  :   onError:
; 387  :     Py_DECREF(list);

  001da	48 8b 4c 24 28	 mov	 rcx, QWORD PTR list$[rsp]
  001df	e8 00 00 00 00	 call	 _Py_DecRef

; 388  :     return NULL;

  001e4	33 c0		 xor	 eax, eax
$LN15@stringlib_@34:

; 389  : }

  001e6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ea	c3		 ret	 0
stringlib_splitlines ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@ ; `string'
PUBLIC	??_C@_1DC@NHMOKICC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EO@FBOEPPKM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ ; `string'
PUBLIC	??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_09FKEMNDFN@U?3fromhex?$AA@		; `string'
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytesobject.c
pdata	SEGMENT
$pdata$bytes_fromhex DD imagerel bytes_fromhex
	DD	imagerel bytes_fromhex+1467
	DD	imagerel $unwind$bytes_fromhex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_fromhex DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@
CONST	SEGMENT
??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@ DB 'non-hexadec'
	DB	'imal number found in fromhex() arg at position %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@NHMOKICC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@NHMOKICC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'n', 00H, 'e', 00H, 'w', 00H, 's', 00H, 't', 00H, 'r', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@FBOEPPKM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
CONST	SEGMENT
??_C@_1EO@FBOEPPKM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'h', 00H, 'e', 00H, 'x', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'h', 00H
	DB	'e', 00H, 'x', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'h', 00H, 'e', 00H, 'x', 00H, 'o', 00H
	DB	'b', 00H, 'j', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FKEMNDFN@U?3fromhex?$AA@
CONST	SEGMENT
??_C@_09FKEMNDFN@U?3fromhex?$AA@ DB 'U:fromhex', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_fromhex
_TEXT	SEGMENT
kind$ = 32
i$ = 40
hexobj$ = 48
hexlen$ = 56
newstring$ = 64
bot$ = 72
byteslen$ = 80
buf$ = 88
top$ = 96
data$ = 104
j$ = 112
tv91 = 120
tv177 = 128
tv186 = 136
tv230 = 144
tv229 = 148
tv245 = 152
tv244 = 156
tv261 = 160
tv260 = 164
cls$ = 192
args$ = 200
bytes_fromhex PROC					; COMDAT

; 2397 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2398 :     PyObject *newstring, *hexobj;
; 2399 :     char *buf;
; 2400 :     Py_ssize_t hexlen, byteslen, i, j;
; 2401 :     int top, bot;
; 2402 :     void *data;
; 2403 :     unsigned int kind;
; 2404 : 
; 2405 :     if (!PyArg_ParseTuple(args, "U:fromhex", &hexobj))

  00011	4c 8d 44 24 30	 lea	 r8, QWORD PTR hexobj$[rsp]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09FKEMNDFN@U?3fromhex?$AA@
  0001d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN16@bytes_from

; 2406 :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 7e 05 00 00	 jmp	 $LN17@bytes_from
$LN16@bytes_from:

; 2407 :     assert(PyUnicode_Check(hexobj));

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  0003a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00044	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00049	85 c0		 test	 eax, eax
  0004b	75 1c		 jne	 SHORT $LN19@bytes_from
  0004d	41 b8 67 09 00
	00		 mov	 r8d, 2407		; 00000967H
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00067	33 c0		 xor	 eax, eax
$LN19@bytes_from:

; 2408 :     if (PyUnicode_READY(hexobj))

  00069	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  0006e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00072	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00078	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0007d	85 c0		 test	 eax, eax
  0007f	75 1c		 jne	 SHORT $LN20@bytes_from
  00081	41 b8 68 09 00
	00		 mov	 r8d, 2408		; 00000968H
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009b	33 c0		 xor	 eax, eax
$LN20@bytes_from:
  0009d	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  000a2	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000a5	c1 e8 07	 shr	 eax, 7
  000a8	83 e0 01	 and	 eax, 1
  000ab	85 c0		 test	 eax, eax
  000ad	74 0a		 je	 SHORT $LN21@bytes_from
  000af	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
  000b7	eb 0e		 jmp	 SHORT $LN22@bytes_from
$LN21@bytes_from:
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hexobj$[rsp]
  000be	e8 00 00 00 00	 call	 _PyUnicode_Ready
  000c3	89 44 24 78	 mov	 DWORD PTR tv91[rsp], eax
$LN22@bytes_from:
  000c7	83 7c 24 78 00	 cmp	 DWORD PTR tv91[rsp], 0
  000cc	74 07		 je	 SHORT $LN15@bytes_from

; 2409 :         return NULL;

  000ce	33 c0		 xor	 eax, eax
  000d0	e9 de 04 00 00	 jmp	 $LN17@bytes_from
$LN15@bytes_from:

; 2410 :     kind = PyUnicode_KIND(hexobj);

  000d5	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  000da	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000de	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000e4	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 1c		 jne	 SHORT $LN23@bytes_from
  000ed	41 b8 6a 09 00
	00		 mov	 r8d, 2410		; 0000096aH
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00107	33 c0		 xor	 eax, eax
$LN23@bytes_from:
  00109	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  0010e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00111	c1 e8 07	 shr	 eax, 7
  00114	83 e0 01	 and	 eax, 1
  00117	85 c0		 test	 eax, eax
  00119	75 1c		 jne	 SHORT $LN24@bytes_from
  0011b	41 b8 6a 09 00
	00		 mov	 r8d, 2410		; 0000096aH
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00135	33 c0		 xor	 eax, eax
$LN24@bytes_from:
  00137	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  0013c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0013f	c1 e8 02	 shr	 eax, 2
  00142	83 e0 07	 and	 eax, 7
  00145	89 44 24 20	 mov	 DWORD PTR kind$[rsp], eax

; 2411 :     data = PyUnicode_DATA(hexobj);

  00149	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  0014e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00152	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00158	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0015d	85 c0		 test	 eax, eax
  0015f	75 1c		 jne	 SHORT $LN25@bytes_from
  00161	41 b8 6b 09 00
	00		 mov	 r8d, 2411		; 0000096bH
  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0016e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0017b	33 c0		 xor	 eax, eax
$LN25@bytes_from:
  0017d	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  00182	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00185	c1 e8 05	 shr	 eax, 5
  00188	83 e0 01	 and	 eax, 1
  0018b	85 c0		 test	 eax, eax
  0018d	0f 84 ae 00 00
	00		 je	 $LN31@bytes_from
  00193	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  00198	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0019c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001a2	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  001a7	85 c0		 test	 eax, eax
  001a9	75 1c		 jne	 SHORT $LN26@bytes_from
  001ab	41 b8 6b 09 00
	00		 mov	 r8d, 2411		; 0000096bH
  001b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001c5	33 c0		 xor	 eax, eax
$LN26@bytes_from:
  001c7	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  001cc	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001cf	c1 e8 07	 shr	 eax, 7
  001d2	83 e0 01	 and	 eax, 1
  001d5	85 c0		 test	 eax, eax
  001d7	75 1c		 jne	 SHORT $LN27@bytes_from
  001d9	41 b8 6b 09 00
	00		 mov	 r8d, 2411		; 0000096bH
  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f3	33 c0		 xor	 eax, eax
$LN27@bytes_from:
  001f5	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  001fa	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001fd	c1 e8 06	 shr	 eax, 6
  00200	83 e0 01	 and	 eax, 1
  00203	85 c0		 test	 eax, eax
  00205	74 15		 je	 SHORT $LN28@bytes_from
  00207	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  0020c	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00212	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
  0021a	eb 13		 jmp	 SHORT $LN29@bytes_from
$LN28@bytes_from:
  0021c	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  00221	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00227	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
$LN29@bytes_from:
  0022f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv177[rsp]
  00237	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
  0023f	eb 3f		 jmp	 SHORT $LN32@bytes_from
$LN31@bytes_from:
  00241	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  00246	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  0024e	75 1c		 jne	 SHORT $LN30@bytes_from
  00250	41 b8 6b 09 00
	00		 mov	 r8d, 2411		; 0000096bH
  00256	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@FBOEPPKM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  00264	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0026a	33 c0		 xor	 eax, eax
$LN30@bytes_from:
  0026c	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  00271	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00278	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
$LN32@bytes_from:
  00280	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv186[rsp]
  00288	48 89 44 24 68	 mov	 QWORD PTR data$[rsp], rax

; 2412 :     hexlen = PyUnicode_GET_LENGTH(hexobj);

  0028d	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  00292	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00296	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0029c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  002a1	85 c0		 test	 eax, eax
  002a3	75 1c		 jne	 SHORT $LN33@bytes_from
  002a5	41 b8 6c 09 00
	00		 mov	 r8d, 2412		; 0000096cH
  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  002b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002bf	33 c0		 xor	 eax, eax
$LN33@bytes_from:
  002c1	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  002c6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002c9	c1 e8 07	 shr	 eax, 7
  002cc	83 e0 01	 and	 eax, 1
  002cf	85 c0		 test	 eax, eax
  002d1	75 1c		 jne	 SHORT $LN34@bytes_from
  002d3	41 b8 6c 09 00
	00		 mov	 r8d, 2412		; 0000096cH
  002d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  002e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ed	33 c0		 xor	 eax, eax
$LN34@bytes_from:
  002ef	48 8b 44 24 30	 mov	 rax, QWORD PTR hexobj$[rsp]
  002f4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002f8	48 89 44 24 38	 mov	 QWORD PTR hexlen$[rsp], rax

; 2413 : 
; 2414 :     byteslen = hexlen/2; /* This overestimates if there are spaces */

  002fd	48 8b 44 24 38	 mov	 rax, QWORD PTR hexlen$[rsp]
  00302	48 99		 cdq
  00304	48 2b c2	 sub	 rax, rdx
  00307	48 d1 f8	 sar	 rax, 1
  0030a	48 89 44 24 50	 mov	 QWORD PTR byteslen$[rsp], rax

; 2415 :     newstring = PyBytes_FromStringAndSize(NULL, byteslen);

  0030f	48 8b 54 24 50	 mov	 rdx, QWORD PTR byteslen$[rsp]
  00314	33 c9		 xor	 ecx, ecx
  00316	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0031b	48 89 44 24 40	 mov	 QWORD PTR newstring$[rsp], rax

; 2416 :     if (!newstring)

  00320	48 83 7c 24 40
	00		 cmp	 QWORD PTR newstring$[rsp], 0
  00326	75 07		 jne	 SHORT $LN14@bytes_from

; 2417 :         return NULL;

  00328	33 c0		 xor	 eax, eax
  0032a	e9 84 02 00 00	 jmp	 $LN17@bytes_from
$LN14@bytes_from:

; 2418 :     buf = PyBytes_AS_STRING(newstring);

  0032f	48 8b 44 24 40	 mov	 rax, QWORD PTR newstring$[rsp]
  00334	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00338	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0033e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00343	85 c0		 test	 eax, eax
  00345	75 1c		 jne	 SHORT $LN35@bytes_from
  00347	41 b8 72 09 00
	00		 mov	 r8d, 2418		; 00000972H
  0034d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@NHMOKICC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
  0035b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00361	33 c0		 xor	 eax, eax
$LN35@bytes_from:
  00363	48 8b 44 24 40	 mov	 rax, QWORD PTR newstring$[rsp]
  00368	48 83 c0 78	 add	 rax, 120		; 00000078H
  0036c	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp], rax

; 2419 :     for (i = j = 0; i < hexlen; i += 2) {

  00371	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  0037a	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  0037f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00384	eb 0e		 jmp	 SHORT $LN13@bytes_from
$LN12@bytes_from:
  00386	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0038b	48 83 c0 02	 add	 rax, 2
  0038f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN13@bytes_from:
  00394	48 8b 44 24 38	 mov	 rax, QWORD PTR hexlen$[rsp]
  00399	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0039e	0f 8d cd 01 00
	00		 jge	 $LN11@bytes_from
$LN10@bytes_from:

; 2420 :         /* skip over spaces in the input */
; 2421 :         while (PyUnicode_READ(kind, data, i) == ' ')

  003a4	83 7c 24 20 01	 cmp	 DWORD PTR kind$[rsp], 1
  003a9	75 1c		 jne	 SHORT $LN38@bytes_from
  003ab	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  003b0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR data$[rsp]
  003b5	48 03 c8	 add	 rcx, rax
  003b8	48 8b c1	 mov	 rax, rcx
  003bb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003be	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv230[rsp], eax
  003c5	eb 40		 jmp	 SHORT $LN39@bytes_from
$LN38@bytes_from:
  003c7	83 7c 24 20 02	 cmp	 DWORD PTR kind$[rsp], 2
  003cc	75 17		 jne	 SHORT $LN36@bytes_from
  003ce	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  003d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  003d8	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  003dc	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv229[rsp], eax
  003e3	eb 14		 jmp	 SHORT $LN37@bytes_from
$LN36@bytes_from:
  003e5	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  003ea	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  003ef	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  003f2	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv229[rsp], eax
$LN37@bytes_from:
  003f9	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv229[rsp]
  00400	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv230[rsp], eax
$LN39@bytes_from:
  00407	83 bc 24 90 00
	00 00 20	 cmp	 DWORD PTR tv230[rsp], 32 ; 00000020H
  0040f	75 0f		 jne	 SHORT $LN9@bytes_from

; 2422 :             i++;

  00411	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00416	48 ff c0	 inc	 rax
  00419	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0041e	eb 84		 jmp	 SHORT $LN10@bytes_from
$LN9@bytes_from:

; 2423 :         if (i >= hexlen)

  00420	48 8b 44 24 38	 mov	 rax, QWORD PTR hexlen$[rsp]
  00425	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0042a	7c 05		 jl	 SHORT $LN8@bytes_from

; 2424 :             break;

  0042c	e9 40 01 00 00	 jmp	 $LN11@bytes_from
$LN8@bytes_from:

; 2425 :         top = hex_digit_to_int(PyUnicode_READ(kind, data, i));

  00431	83 7c 24 20 01	 cmp	 DWORD PTR kind$[rsp], 1
  00436	75 1c		 jne	 SHORT $LN42@bytes_from
  00438	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0043d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR data$[rsp]
  00442	48 03 c8	 add	 rcx, rax
  00445	48 8b c1	 mov	 rax, rcx
  00448	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0044b	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv245[rsp], eax
  00452	eb 40		 jmp	 SHORT $LN43@bytes_from
$LN42@bytes_from:
  00454	83 7c 24 20 02	 cmp	 DWORD PTR kind$[rsp], 2
  00459	75 17		 jne	 SHORT $LN40@bytes_from
  0045b	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  00460	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00465	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00469	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv244[rsp], eax
  00470	eb 14		 jmp	 SHORT $LN41@bytes_from
$LN40@bytes_from:
  00472	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  00477	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0047c	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0047f	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv244[rsp], eax
$LN41@bytes_from:
  00486	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv244[rsp]
  0048d	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv245[rsp], eax
$LN43@bytes_from:
  00494	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv245[rsp]
  0049b	e8 00 00 00 00	 call	 hex_digit_to_int
  004a0	89 44 24 60	 mov	 DWORD PTR top$[rsp], eax

; 2426 :         bot = hex_digit_to_int(PyUnicode_READ(kind, data, i+1));

  004a4	83 7c 24 20 01	 cmp	 DWORD PTR kind$[rsp], 1
  004a9	75 1d		 jne	 SHORT $LN46@bytes_from
  004ab	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  004b0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR data$[rsp]
  004b5	48 03 c8	 add	 rcx, rax
  004b8	48 8b c1	 mov	 rax, rcx
  004bb	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  004bf	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv261[rsp], eax
  004c6	eb 42		 jmp	 SHORT $LN47@bytes_from
$LN46@bytes_from:
  004c8	83 7c 24 20 02	 cmp	 DWORD PTR kind$[rsp], 2
  004cd	75 18		 jne	 SHORT $LN44@bytes_from
  004cf	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  004d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  004d9	0f b7 44 48 02	 movzx	 eax, WORD PTR [rax+rcx*2+2]
  004de	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv260[rsp], eax
  004e5	eb 15		 jmp	 SHORT $LN45@bytes_from
$LN44@bytes_from:
  004e7	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  004ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  004f1	8b 44 88 04	 mov	 eax, DWORD PTR [rax+rcx*4+4]
  004f5	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv260[rsp], eax
$LN45@bytes_from:
  004fc	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv260[rsp]
  00503	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv261[rsp], eax
$LN47@bytes_from:
  0050a	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv261[rsp]
  00511	e8 00 00 00 00	 call	 hex_digit_to_int
  00516	89 44 24 48	 mov	 DWORD PTR bot$[rsp], eax

; 2427 :         if (top == -1 || bot == -1) {

  0051a	83 7c 24 60 ff	 cmp	 DWORD PTR top$[rsp], -1
  0051f	74 07		 je	 SHORT $LN6@bytes_from
  00521	83 7c 24 48 ff	 cmp	 DWORD PTR bot$[rsp], -1
  00526	75 1a		 jne	 SHORT $LN7@bytes_from
$LN6@bytes_from:

; 2428 :             PyErr_Format(PyExc_ValueError,
; 2429 :                          "non-hexadecimal number found in "
; 2430 :                          "fromhex() arg at position %zd", i);

  00528	4c 8b 44 24 28	 mov	 r8, QWORD PTR i$[rsp]
  0052d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@
  00534	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0053b	e8 00 00 00 00	 call	 PyErr_Format

; 2431 :             goto error;

  00540	eb 57		 jmp	 SHORT $error$24160
$LN7@bytes_from:

; 2432 :         }
; 2433 :         buf[j++] = (top << 4) + bot;

  00542	8b 44 24 60	 mov	 eax, DWORD PTR top$[rsp]
  00546	c1 e0 04	 shl	 eax, 4
  00549	03 44 24 48	 add	 eax, DWORD PTR bot$[rsp]
  0054d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR j$[rsp]
  00552	48 8b 54 24 58	 mov	 rdx, QWORD PTR buf$[rsp]
  00557	48 03 d1	 add	 rdx, rcx
  0055a	48 8b ca	 mov	 rcx, rdx
  0055d	88 01		 mov	 BYTE PTR [rcx], al
  0055f	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  00564	48 ff c0	 inc	 rax
  00567	48 89 44 24 70	 mov	 QWORD PTR j$[rsp], rax

; 2434 :     }

  0056c	e9 15 fe ff ff	 jmp	 $LN12@bytes_from
$LN11@bytes_from:

; 2435 :     if (j != byteslen && _PyBytes_Resize(&newstring, j) < 0)

  00571	48 8b 44 24 50	 mov	 rax, QWORD PTR byteslen$[rsp]
  00576	48 39 44 24 70	 cmp	 QWORD PTR j$[rsp], rax
  0057b	74 15		 je	 SHORT $LN5@bytes_from
  0057d	48 8b 54 24 70	 mov	 rdx, QWORD PTR j$[rsp]
  00582	48 8d 4c 24 40	 lea	 rcx, QWORD PTR newstring$[rsp]
  00587	e8 00 00 00 00	 call	 _PyBytes_Resize
  0058c	85 c0		 test	 eax, eax
  0058e	7d 02		 jge	 SHORT $LN5@bytes_from

; 2436 :         goto error;

  00590	eb 07		 jmp	 SHORT $error$24160
$LN5@bytes_from:

; 2437 :     return newstring;

  00592	48 8b 44 24 40	 mov	 rax, QWORD PTR newstring$[rsp]
  00597	eb 1a		 jmp	 SHORT $LN17@bytes_from
$error$24160:
$LN4@bytes_from:

; 2438 : 
; 2439 :   error:
; 2440 :     Py_XDECREF(newstring);

  00599	48 83 7c 24 40
	00		 cmp	 QWORD PTR newstring$[rsp], 0
  0059f	74 0a		 je	 SHORT $LN1@bytes_from
  005a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newstring$[rsp]
  005a6	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@bytes_from:
  005ab	33 c0		 xor	 eax, eax
  005ad	85 c0		 test	 eax, eax
  005af	75 e8		 jne	 SHORT $LN4@bytes_from

; 2441 :     return NULL;

  005b1	33 c0		 xor	 eax, eax
$LN17@bytes_from:

; 2442 : }

  005b3	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  005ba	c3		 ret	 0
bytes_fromhex ENDP
_TEXT	ENDS
EXTRN	_Py_ctype_tolower:BYTE
; Function compile flags: /Odtp
;	COMDAT hex_digit_to_int
_TEXT	SEGMENT
c$ = 8
hex_digit_to_int PROC					; COMDAT

; 2381 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 2382 :     if (c >= 128)

  00004	81 7c 24 08 80
	00 00 00	 cmp	 DWORD PTR c$[rsp], 128	; 00000080H
  0000c	72 07		 jb	 SHORT $LN5@hex_digit_

; 2383 :         return -1;

  0000e	b8 ff ff ff ff	 mov	 eax, -1
  00013	eb 7c		 jmp	 SHORT $LN6@hex_digit_
$LN5@hex_digit_:

; 2384 :     if (Py_ISDIGIT(c))

  00015	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00019	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0001e	0f b6 c0	 movzx	 eax, al
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00028	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0002b	83 e0 04	 and	 eax, 4
  0002e	85 c0		 test	 eax, eax
  00030	74 0b		 je	 SHORT $LN4@hex_digit_

; 2385 :         return c - '0';

  00032	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00036	83 e8 30	 sub	 eax, 48			; 00000030H
  00039	eb 56		 jmp	 SHORT $LN6@hex_digit_

; 2386 :     else {

  0003b	eb 4f		 jmp	 SHORT $LN3@hex_digit_
$LN4@hex_digit_:

; 2387 :         if (Py_ISUPPER(c))

  0003d	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00041	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00046	0f b6 c0	 movzx	 eax, al
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00050	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00053	83 e0 02	 and	 eax, 2
  00056	85 c0		 test	 eax, eax
  00058	74 1b		 je	 SHORT $LN2@hex_digit_

; 2388 :             c = Py_TOLOWER(c);

  0005a	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  0005e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00063	0f b6 c0	 movzx	 eax, al
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_tolower
  0006d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00071	89 44 24 08	 mov	 DWORD PTR c$[rsp], eax
$LN2@hex_digit_:

; 2389 :         if (c >= 'a' && c <= 'f')

  00075	83 7c 24 08 61	 cmp	 DWORD PTR c$[rsp], 97	; 00000061H
  0007a	72 10		 jb	 SHORT $LN1@hex_digit_
  0007c	83 7c 24 08 66	 cmp	 DWORD PTR c$[rsp], 102	; 00000066H
  00081	77 09		 ja	 SHORT $LN1@hex_digit_

; 2390 :             return c - 'a' + 10;

  00083	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00087	83 e8 57	 sub	 eax, 87			; 00000057H
  0008a	eb 05		 jmp	 SHORT $LN6@hex_digit_
$LN1@hex_digit_:
$LN3@hex_digit_:

; 2391 :     }
; 2392 :     return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
$LN6@hex_digit_:

; 2393 : }

  00091	f3 c3		 fatret	 0
hex_digit_to_int ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_sizeof DD imagerel bytes_sizeof
	DD	imagerel bytes_sizeof+62
	DD	imagerel $unwind$bytes_sizeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_sizeof DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytes_sizeof
_TEXT	SEGMENT
res$ = 32
v$ = 64
bytes_sizeof PROC					; COMDAT

; 2449 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2450 :     Py_ssize_t res;
; 2451 :     res = PyBytesObject_SIZE + Py_SIZE(v) * Py_TYPE(v)->tp_itemsize;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00017	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0001b	48 0f af 88 80
	00 00 00	 imul	 rcx, QWORD PTR [rax+128]
  00023	48 8b c1	 mov	 rax, rcx
  00026	48 83 c0 79	 add	 rax, 121		; 00000079H
  0002a	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 2452 :     return PyLong_FromSsize_t(res);

  0002f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  00034	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 2453 : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
bytes_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_04KABGOEGD@?$CIy?$CD?$CJ?$AA@		; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_getnewargs DD imagerel bytes_getnewargs
	DD	imagerel bytes_getnewargs+47
	DD	imagerel $unwind$bytes_getnewargs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_getnewargs DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_04KABGOEGD@?$CIy?$CD?$CJ?$AA@
CONST	SEGMENT
??_C@_04KABGOEGD@?$CIy?$CD?$CJ?$AA@ DB '(y#)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_getnewargs
_TEXT	SEGMENT
v$ = 48
bytes_getnewargs PROC					; COMDAT

; 2458 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2459 :     return Py_BuildValue("(y#)", v->ob_sval, Py_SIZE(v));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 83 c0 78	 add	 rax, 120		; 00000078H
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00017	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  0001b	48 8b d0	 mov	 rdx, rax
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04KABGOEGD@?$CIy?$CD?$CJ?$AA@
  00025	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 2460 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
bytes_getnewargs ENDP
_TEXT	ENDS
PUBLIC	PyBytes_FromObject
PUBLIC	??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@ ; `string'
PUBLIC	??_C@_0P@DIJHAIGC@negative?5count?$AA@		; `string'
PUBLIC	??_C@_0CL@GNADLFAE@__bytes__?5returned?5non?9bytes?5?$CIty@ ; `string'
PUBLIC	??_C@_1CG@EGDILHHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@ ; `string'
PUBLIC	??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@ ; `string'
PUBLIC	??_C@_0L@PHLOHJKP@?$HMOss?3bytes?$AA@		; `string'
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	_PyObject_LookupSpecial:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_new DD imagerel bytes_new
	DD	imagerel bytes_new+834
	DD	imagerel $unwind$bytes_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_new DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@
CONST	SEGMENT
??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@ DB 'encoding or'
	DB	' errors without a string argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DIJHAIGC@negative?5count?$AA@
CONST	SEGMENT
??_C@_0P@DIJHAIGC@negative?5count?$AA@ DB 'negative count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GNADLFAE@__bytes__?5returned?5non?9bytes?5?$CIty@
CONST	SEGMENT
??_C@_0CL@GNADLFAE@__bytes__?5returned?5non?9bytes?5?$CIty@ DB '__bytes__'
	DB	' returned non-bytes (type %.200s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@EGDILHHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@EGDILHHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'n', 00H, 'e', 00H, 'w', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@
CONST	SEGMENT
??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@ DB 'string argum'
	DB	'ent without an encoding', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@
CONST	SEGMENT
??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@ DB 'encoding or '
	DB	'errors without sequence argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHLOHJKP@?$HMOss?3bytes?$AA@
CONST	SEGMENT
??_C@_0L@PHLOHJKP@?$HMOss?3bytes?$AA@ DB '|Oss:bytes', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_new
_TEXT	SEGMENT
x$ = 64
errors$ = 72
size$ = 80
encoding$ = 88
func$ = 96
new$ = 104
type$ = 128
args$ = 136
kwds$ = 144
bytes_new PROC						; COMDAT

; 2531 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2532 :     PyObject *x = NULL;

  00013	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 2533 :     const char *encoding = NULL;

  0001c	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR encoding$[rsp], 0

; 2534 :     const char *errors = NULL;

  00025	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR errors$[rsp], 0

; 2535 :     PyObject *new = NULL;

  0002e	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR new$[rsp], 0

; 2536 :     PyObject *func;
; 2537 :     Py_ssize_t size;
; 2538 :     static char *kwlist[] = {"source", "encoding", "errors", 0};
; 2539 :     _Py_IDENTIFIER(__bytes__);
; 2540 : 
; 2541 :     if (type != &PyBytes_Type)

  00037	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  0003e	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR type$[rsp], rax
  00046	74 22		 je	 SHORT $LN22@bytes_new

; 2542 :         return str_subtype_new(type, args, kwds);

  00048	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR kwds$[rsp]
  00050	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR args$[rsp]
  00058	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  00060	e8 00 00 00 00	 call	 str_subtype_new
  00065	e9 d3 02 00 00	 jmp	 $LN23@bytes_new
$LN22@bytes_new:

; 2543 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|Oss:bytes", kwlist, &x,
; 2544 :                                      &encoding, &errors))

  0006a	48 8d 44 24 48	 lea	 rax, QWORD PTR errors$[rsp]
  0006f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00074	48 8d 44 24 58	 lea	 rax, QWORD PTR encoding$[rsp]
  00079	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007e	48 8d 44 24 40	 lea	 rax, QWORD PTR x$[rsp]
  00083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00088	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytes_new@@9@9
  0008f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@PHLOHJKP@?$HMOss?3bytes?$AA@
  00096	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  0009e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000a6	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000ab	85 c0		 test	 eax, eax
  000ad	75 07		 jne	 SHORT $LN21@bytes_new

; 2545 :         return NULL;

  000af	33 c0		 xor	 eax, eax
  000b1	e9 87 02 00 00	 jmp	 $LN23@bytes_new
$LN21@bytes_new:

; 2546 :     if (x == NULL) {

  000b6	48 83 7c 24 40
	00		 cmp	 QWORD PTR x$[rsp], 0
  000bc	75 3b		 jne	 SHORT $LN20@bytes_new

; 2547 :         if (encoding != NULL || errors != NULL) {

  000be	48 83 7c 24 58
	00		 cmp	 QWORD PTR encoding$[rsp], 0
  000c4	75 08		 jne	 SHORT $LN18@bytes_new
  000c6	48 83 7c 24 48
	00		 cmp	 QWORD PTR errors$[rsp], 0
  000cc	74 1a		 je	 SHORT $LN19@bytes_new
$LN18@bytes_new:

; 2548 :             PyErr_SetString(PyExc_TypeError,
; 2549 :                             "encoding or errors without sequence "
; 2550 :                             "argument");

  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@
  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000dc	e8 00 00 00 00	 call	 PyErr_SetString

; 2551 :             return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	e9 55 02 00 00	 jmp	 $LN23@bytes_new
$LN19@bytes_new:

; 2552 :         }
; 2553 :         return PyBytes_FromString("");

  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000ef	e8 00 00 00 00	 call	 PyBytes_FromString
  000f4	e9 44 02 00 00	 jmp	 $LN23@bytes_new
$LN20@bytes_new:

; 2554 :     }
; 2555 : 
; 2556 :     if (PyUnicode_Check(x)) {

  000f9	48 8b 44 24 40	 mov	 rax, QWORD PTR x$[rsp]
  000fe	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00102	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00108	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0010d	85 c0		 test	 eax, eax
  0010f	0f 84 88 00 00
	00		 je	 $LN17@bytes_new

; 2557 :         /* Encode via the codec registry */
; 2558 :         if (encoding == NULL) {

  00115	48 83 7c 24 58
	00		 cmp	 QWORD PTR encoding$[rsp], 0
  0011b	75 1a		 jne	 SHORT $LN16@bytes_new

; 2559 :             PyErr_SetString(PyExc_TypeError,
; 2560 :                             "string argument without an encoding");

  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@
  00124	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0012b	e8 00 00 00 00	 call	 PyErr_SetString

; 2561 :             return NULL;

  00130	33 c0		 xor	 eax, eax
  00132	e9 06 02 00 00	 jmp	 $LN23@bytes_new
$LN16@bytes_new:

; 2562 :         }
; 2563 :         new = PyUnicode_AsEncodedString(x, encoding, errors);

  00137	4c 8b 44 24 48	 mov	 r8, QWORD PTR errors$[rsp]
  0013c	48 8b 54 24 58	 mov	 rdx, QWORD PTR encoding$[rsp]
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x$[rsp]
  00146	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString
  0014b	48 89 44 24 68	 mov	 QWORD PTR new$[rsp], rax

; 2564 :         if (new == NULL)

  00150	48 83 7c 24 68
	00		 cmp	 QWORD PTR new$[rsp], 0
  00156	75 07		 jne	 SHORT $LN15@bytes_new

; 2565 :             return NULL;

  00158	33 c0		 xor	 eax, eax
  0015a	e9 de 01 00 00	 jmp	 $LN23@bytes_new
$LN15@bytes_new:

; 2566 :         assert(PyBytes_Check(new));

  0015f	48 8b 44 24 68	 mov	 rax, QWORD PTR new$[rsp]
  00164	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00168	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0016e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00173	85 c0		 test	 eax, eax
  00175	75 1c		 jne	 SHORT $LN25@bytes_new
  00177	41 b8 06 0a 00
	00		 mov	 r8d, 2566		; 00000a06H
  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@EGDILHHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AA?$CJ?$AA?$AA@
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00191	33 c0		 xor	 eax, eax
$LN25@bytes_new:

; 2567 :         return new;

  00193	48 8b 44 24 68	 mov	 rax, QWORD PTR new$[rsp]
  00198	e9 a0 01 00 00	 jmp	 $LN23@bytes_new
$LN17@bytes_new:

; 2568 :     }
; 2569 : 
; 2570 :     /* We'd like to call PyObject_Bytes here, but we need to check for an
; 2571 :        integer argument before deferring to PyBytes_FromObject, something
; 2572 :        PyObject_Bytes doesn't do. */
; 2573 :     func = _PyObject_LookupSpecial(x, &PyId___bytes__);

  0019d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___bytes__@?1??bytes_new@@9@9
  001a2	8b c0		 mov	 eax, eax
  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001aa	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b3	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  001b7	48 8b d0	 mov	 rdx, rax
  001ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x$[rsp]
  001bf	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  001c4	48 89 44 24 60	 mov	 QWORD PTR func$[rsp], rax

; 2574 :     if (func != NULL) {

  001c9	48 83 7c 24 60
	00		 cmp	 QWORD PTR func$[rsp], 0
  001cf	74 7f		 je	 SHORT $LN14@bytes_new

; 2575 :         new = PyObject_CallFunctionObjArgs(func, NULL);

  001d1	33 d2		 xor	 edx, edx
  001d3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR func$[rsp]
  001d8	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  001dd	48 89 44 24 68	 mov	 QWORD PTR new$[rsp], rax

; 2576 :         Py_DECREF(func);

  001e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR func$[rsp]
  001e7	e8 00 00 00 00	 call	 _Py_DecRef

; 2577 :         if (new == NULL)

  001ec	48 83 7c 24 68
	00		 cmp	 QWORD PTR new$[rsp], 0
  001f2	75 07		 jne	 SHORT $LN13@bytes_new

; 2578 :             return NULL;

  001f4	33 c0		 xor	 eax, eax
  001f6	e9 42 01 00 00	 jmp	 $LN23@bytes_new
$LN13@bytes_new:

; 2579 :         if (!PyBytes_Check(new)) {

  001fb	48 8b 44 24 68	 mov	 rax, QWORD PTR new$[rsp]
  00200	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00204	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0020a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0020f	85 c0		 test	 eax, eax
  00211	75 31		 jne	 SHORT $LN12@bytes_new

; 2580 :             PyErr_Format(PyExc_TypeError,
; 2581 :                          "__bytes__ returned non-bytes (type %.200s)",
; 2582 :                          Py_TYPE(new)->tp_name);

  00213	48 8b 44 24 68	 mov	 rax, QWORD PTR new$[rsp]
  00218	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0021c	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@GNADLFAE@__bytes__?5returned?5non?9bytes?5?$CIty@
  00227	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0022e	e8 00 00 00 00	 call	 PyErr_Format

; 2583 :             Py_DECREF(new);

  00233	48 8b 4c 24 68	 mov	 rcx, QWORD PTR new$[rsp]
  00238	e8 00 00 00 00	 call	 _Py_DecRef

; 2584 :             return NULL;

  0023d	33 c0		 xor	 eax, eax
  0023f	e9 f9 00 00 00	 jmp	 $LN23@bytes_new
$LN12@bytes_new:

; 2585 :         }
; 2586 :         return new;

  00244	48 8b 44 24 68	 mov	 rax, QWORD PTR new$[rsp]
  00249	e9 ef 00 00 00	 jmp	 $LN23@bytes_new
  0024e	eb 11		 jmp	 SHORT $LN11@bytes_new
$LN14@bytes_new:

; 2587 :     }
; 2588 :     else if (PyErr_Occurred())

  00250	e8 00 00 00 00	 call	 PyErr_Occurred
  00255	48 85 c0	 test	 rax, rax
  00258	74 07		 je	 SHORT $LN10@bytes_new

; 2589 :         return NULL;

  0025a	33 c0		 xor	 eax, eax
  0025c	e9 dc 00 00 00	 jmp	 $LN23@bytes_new
$LN10@bytes_new:
$LN11@bytes_new:

; 2590 : 
; 2591 :     /* Is it an integer? */
; 2592 :     size = PyNumber_AsSsize_t(x, PyExc_OverflowError);

  00261	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00268	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x$[rsp]
  0026d	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00272	48 89 44 24 50	 mov	 QWORD PTR size$[rsp], rax

; 2593 :     if (size == -1 && PyErr_Occurred()) {

  00277	48 83 7c 24 50
	ff		 cmp	 QWORD PTR size$[rsp], -1
  0027d	75 28		 jne	 SHORT $LN9@bytes_new
  0027f	e8 00 00 00 00	 call	 PyErr_Occurred
  00284	48 85 c0	 test	 rax, rax
  00287	74 1e		 je	 SHORT $LN9@bytes_new

; 2594 :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  00289	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00290	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00295	85 c0		 test	 eax, eax
  00297	74 07		 je	 SHORT $LN8@bytes_new

; 2595 :             return NULL;

  00299	33 c0		 xor	 eax, eax
  0029b	e9 9d 00 00 00	 jmp	 $LN23@bytes_new
$LN8@bytes_new:

; 2596 :         PyErr_Clear();

  002a0	e8 00 00 00 00	 call	 PyErr_Clear
  002a5	eb 65		 jmp	 SHORT $LN7@bytes_new
$LN9@bytes_new:

; 2597 :     }
; 2598 :     else if (size < 0) {

  002a7	48 83 7c 24 50
	00		 cmp	 QWORD PTR size$[rsp], 0
  002ad	7d 19		 jge	 SHORT $LN6@bytes_new

; 2599 :         PyErr_SetString(PyExc_ValueError, "negative count");

  002af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DIJHAIGC@negative?5count?$AA@
  002b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  002bd	e8 00 00 00 00	 call	 PyErr_SetString

; 2600 :         return NULL;

  002c2	33 c0		 xor	 eax, eax
  002c4	eb 77		 jmp	 SHORT $LN23@bytes_new

; 2601 :     }
; 2602 :     else {

  002c6	eb 44		 jmp	 SHORT $LN5@bytes_new
$LN6@bytes_new:

; 2603 :         new = PyBytes_FromStringAndSize(NULL, size);

  002c8	48 8b 54 24 50	 mov	 rdx, QWORD PTR size$[rsp]
  002cd	33 c9		 xor	 ecx, ecx
  002cf	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  002d4	48 89 44 24 68	 mov	 QWORD PTR new$[rsp], rax

; 2604 :         if (new == NULL)

  002d9	48 83 7c 24 68
	00		 cmp	 QWORD PTR new$[rsp], 0
  002df	75 04		 jne	 SHORT $LN4@bytes_new

; 2605 :             return NULL;

  002e1	33 c0		 xor	 eax, eax
  002e3	eb 58		 jmp	 SHORT $LN23@bytes_new
$LN4@bytes_new:

; 2606 :         if (size > 0)

  002e5	48 83 7c 24 50
	00		 cmp	 QWORD PTR size$[rsp], 0
  002eb	7e 18		 jle	 SHORT $LN3@bytes_new

; 2607 :             memset(((PyBytesObject*)new)->ob_sval, 0, size);

  002ed	48 8b 44 24 68	 mov	 rax, QWORD PTR new$[rsp]
  002f2	48 83 c0 78	 add	 rax, 120		; 00000078H
  002f6	4c 8b 44 24 50	 mov	 r8, QWORD PTR size$[rsp]
  002fb	33 d2		 xor	 edx, edx
  002fd	48 8b c8	 mov	 rcx, rax
  00300	e8 00 00 00 00	 call	 memset
$LN3@bytes_new:

; 2608 :         return new;

  00305	48 8b 44 24 68	 mov	 rax, QWORD PTR new$[rsp]
  0030a	eb 31		 jmp	 SHORT $LN23@bytes_new
$LN5@bytes_new:
$LN7@bytes_new:

; 2609 :     }
; 2610 : 
; 2611 :     /* If it's not unicode, there can't be encoding or errors */
; 2612 :     if (encoding != NULL || errors != NULL) {

  0030c	48 83 7c 24 58
	00		 cmp	 QWORD PTR encoding$[rsp], 0
  00312	75 08		 jne	 SHORT $LN1@bytes_new
  00314	48 83 7c 24 48
	00		 cmp	 QWORD PTR errors$[rsp], 0
  0031a	74 17		 je	 SHORT $LN2@bytes_new
$LN1@bytes_new:

; 2613 :         PyErr_SetString(PyExc_TypeError,
; 2614 :             "encoding or errors without a string argument");

  0031c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@
  00323	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0032a	e8 00 00 00 00	 call	 PyErr_SetString

; 2615 :         return NULL;

  0032f	33 c0		 xor	 eax, eax
  00331	eb 0a		 jmp	 SHORT $LN23@bytes_new
$LN2@bytes_new:

; 2616 :     }
; 2617 : 
; 2618 :     return PyBytes_FromObject(x);

  00333	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x$[rsp]
  00338	e8 00 00 00 00	 call	 PyBytes_FromObject
$LN23@bytes_new:

; 2619 : }

  0033d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00341	c3		 ret	 0
bytes_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@MLPHABLA@bytes?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CH@FMEGCOLJ@cannot?5convert?5unicode?5object?5to@ ; `string'
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
EXTRN	_PyObject_LengthHint:PROC
EXTRN	PyTuple_Type:BYTE
EXTRN	PyList_Type:BYTE
EXTRN	PyBuffer_ToContiguous:PROC
EXTRN	PyObject_GetBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBytes_FromObject DD imagerel $LN47
	DD	imagerel $LN47+1410
	DD	imagerel $unwind$PyBytes_FromObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_FromObject DD 020c01H
	DD	017010cH
xdata	ENDS
;	COMDAT ??_C@_0BP@MLPHABLA@bytes?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@MLPHABLA@bytes?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@ DB 'by'
	DB	'tes must be in range(0, 256)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FMEGCOLJ@cannot?5convert?5unicode?5object?5to@
CONST	SEGMENT
??_C@_0CH@FMEGCOLJ@cannot?5convert?5unicode?5object?5to@ DB 'cannot conve'
	DB	'rt unicode object to bytes', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBytes_FromObject
_TEXT	SEGMENT
it$ = 32
i$ = 40
size$ = 48
new$ = 56
view$24370 = 64
value$24399 = 144
value$24422 = 152
value$24446 = 160
item$24445 = 168
x$ = 192
PyBytes_FromObject PROC					; COMDAT

; 2623 : {

$LN47:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2624 :     PyObject *new, *it;
; 2625 :     Py_ssize_t i, size;
; 2626 : 
; 2627 :     if (x == NULL) {

  0000c	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR x$[rsp], 0
  00015	75 18		 jne	 SHORT $LN44@PyBytes_Fr@4

; 2628 :         PyErr_BadInternalCall();

  00017	ba 44 0a 00 00	 mov	 edx, 2628		; 00000a44H
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  00023	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2629 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 4b 05 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN44@PyBytes_Fr@4:

; 2630 :     }
; 2631 : 
; 2632 :     if (PyBytes_CheckExact(x)) {

  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00036	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  0003e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00042	75 1a		 jne	 SHORT $LN43@PyBytes_Fr@4

; 2633 :         Py_INCREF(x);

  00044	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  0004c	e8 00 00 00 00	 call	 _Py_IncRef

; 2634 :         return x;

  00051	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00059	e9 1c 05 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN43@PyBytes_Fr@4:

; 2635 :     }
; 2636 : 
; 2637 :     /* Use the modern buffer interface */
; 2638 :     if (PyObject_CheckBuffer(x)) {

  0005e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00066	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006a	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  00072	0f 84 bc 00 00
	00		 je	 $LN42@PyBytes_Fr@4
  00078	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00080	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00084	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  0008b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008f	0f 84 9f 00 00
	00		 je	 $LN42@PyBytes_Fr@4

; 2639 :         Py_buffer view;
; 2640 :         if (PyObject_GetBuffer(x, &view, PyBUF_FULL_RO) < 0)

  00095	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  0009b	48 8d 54 24 40	 lea	 rdx, QWORD PTR view$24370[rsp]
  000a0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  000a8	e8 00 00 00 00	 call	 PyObject_GetBuffer
  000ad	85 c0		 test	 eax, eax
  000af	7d 07		 jge	 SHORT $LN41@PyBytes_Fr@4

; 2641 :             return NULL;

  000b1	33 c0		 xor	 eax, eax
  000b3	e9 c2 04 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN41@PyBytes_Fr@4:

; 2642 :         new = PyBytes_FromStringAndSize(NULL, view.len);

  000b8	48 8b 54 24 50	 mov	 rdx, QWORD PTR view$24370[rsp+16]
  000bd	33 c9		 xor	 ecx, ecx
  000bf	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000c4	48 89 44 24 38	 mov	 QWORD PTR new$[rsp], rax

; 2643 :         if (!new)

  000c9	48 83 7c 24 38
	00		 cmp	 QWORD PTR new$[rsp], 0
  000cf	75 02		 jne	 SHORT $LN40@PyBytes_Fr@4

; 2644 :             goto fail;

  000d1	eb 38		 jmp	 SHORT $fail$24375
$LN40@PyBytes_Fr@4:

; 2645 :         if (PyBuffer_ToContiguous(((PyBytesObject *)new)->ob_sval,
; 2646 :                                   &view, view.len, 'C') < 0)

  000d3	48 8b 44 24 38	 mov	 rax, QWORD PTR new$[rsp]
  000d8	48 83 c0 78	 add	 rax, 120		; 00000078H
  000dc	41 b1 43	 mov	 r9b, 67			; 00000043H
  000df	4c 8b 44 24 50	 mov	 r8, QWORD PTR view$24370[rsp+16]
  000e4	48 8d 54 24 40	 lea	 rdx, QWORD PTR view$24370[rsp]
  000e9	48 8b c8	 mov	 rcx, rax
  000ec	e8 00 00 00 00	 call	 PyBuffer_ToContiguous
  000f1	85 c0		 test	 eax, eax
  000f3	7d 02		 jge	 SHORT $LN39@PyBytes_Fr@4

; 2647 :             goto fail;

  000f5	eb 14		 jmp	 SHORT $fail$24375
$LN39@PyBytes_Fr@4:

; 2648 :         PyBuffer_Release(&view);

  000f7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR view$24370[rsp]
  000fc	e8 00 00 00 00	 call	 PyBuffer_Release

; 2649 :         return new;

  00101	48 8b 44 24 38	 mov	 rax, QWORD PTR new$[rsp]
  00106	e9 6f 04 00 00	 jmp	 $LN45@PyBytes_Fr@4
$fail$24375:
$LN38@PyBytes_Fr@4:

; 2650 :       fail:
; 2651 :         Py_XDECREF(new);

  0010b	48 83 7c 24 38
	00		 cmp	 QWORD PTR new$[rsp], 0
  00111	74 0a		 je	 SHORT $LN35@PyBytes_Fr@4
  00113	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new$[rsp]
  00118	e8 00 00 00 00	 call	 _Py_DecRef
$LN35@PyBytes_Fr@4:
  0011d	33 c0		 xor	 eax, eax
  0011f	85 c0		 test	 eax, eax
  00121	75 e8		 jne	 SHORT $LN38@PyBytes_Fr@4

; 2652 :         PyBuffer_Release(&view);

  00123	48 8d 4c 24 40	 lea	 rcx, QWORD PTR view$24370[rsp]
  00128	e8 00 00 00 00	 call	 PyBuffer_Release

; 2653 :         return NULL;

  0012d	33 c0		 xor	 eax, eax
  0012f	e9 46 04 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN42@PyBytes_Fr@4:

; 2654 :     }
; 2655 :     if (PyUnicode_Check(x)) {

  00134	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0013c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00140	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00146	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0014b	85 c0		 test	 eax, eax
  0014d	74 1a		 je	 SHORT $LN34@PyBytes_Fr@4

; 2656 :         PyErr_SetString(PyExc_TypeError,
; 2657 :                         "cannot convert unicode object to bytes");

  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@FMEGCOLJ@cannot?5convert?5unicode?5object?5to@
  00156	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0015d	e8 00 00 00 00	 call	 PyErr_SetString

; 2658 :         return NULL;

  00162	33 c0		 xor	 eax, eax
  00164	e9 11 04 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN34@PyBytes_Fr@4:

; 2659 :     }
; 2660 : 
; 2661 :     if (PyList_CheckExact(x)) {

  00169	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  00170	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  00178	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0017c	0f 85 0c 01 00
	00		 jne	 $LN33@PyBytes_Fr@4

; 2662 :         new = PyBytes_FromStringAndSize(NULL, Py_SIZE(x));

  00182	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0018a	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0018e	33 c9		 xor	 ecx, ecx
  00190	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00195	48 89 44 24 38	 mov	 QWORD PTR new$[rsp], rax

; 2663 :         if (new == NULL)

  0019a	48 83 7c 24 38
	00		 cmp	 QWORD PTR new$[rsp], 0
  001a0	75 07		 jne	 SHORT $LN32@PyBytes_Fr@4

; 2664 :             return NULL;

  001a2	33 c0		 xor	 eax, eax
  001a4	e9 d1 03 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN32@PyBytes_Fr@4:

; 2665 :         for (i = 0; i < Py_SIZE(x); i++) {

  001a9	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001b2	eb 0d		 jmp	 SHORT $LN31@PyBytes_Fr@4
$LN30@PyBytes_Fr@4:
  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  001b9	48 ff c0	 inc	 rax
  001bc	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN31@PyBytes_Fr@4:
  001c1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  001c9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001cd	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  001d2	0f 8d ac 00 00
	00		 jge	 $LN29@PyBytes_Fr@4

; 2666 :             Py_ssize_t value = PyNumber_AsSsize_t(
; 2667 :                 PyList_GET_ITEM(x, i), PyExc_ValueError);

  001d8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  001e0	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001e4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_ValueError
  001eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  001f0	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  001f4	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  001f9	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR value$24399[rsp], rax

; 2668 :             if (value == -1 && PyErr_Occurred()) {

  00201	48 83 bc 24 90
	00 00 00 ff	 cmp	 QWORD PTR value$24399[rsp], -1
  0020a	75 1b		 jne	 SHORT $LN28@PyBytes_Fr@4
  0020c	e8 00 00 00 00	 call	 PyErr_Occurred
  00211	48 85 c0	 test	 rax, rax
  00214	74 11		 je	 SHORT $LN28@PyBytes_Fr@4

; 2669 :                 Py_DECREF(new);

  00216	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new$[rsp]
  0021b	e8 00 00 00 00	 call	 _Py_DecRef

; 2670 :                 return NULL;

  00220	33 c0		 xor	 eax, eax
  00222	e9 53 03 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN28@PyBytes_Fr@4:

; 2671 :             }
; 2672 :             if (value < 0 || value >= 256) {

  00227	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR value$24399[rsp], 0
  00230	7c 0e		 jl	 SHORT $LN26@PyBytes_Fr@4
  00232	48 81 bc 24 90
	00 00 00 00 01
	00 00		 cmp	 QWORD PTR value$24399[rsp], 256 ; 00000100H
  0023e	7c 24		 jl	 SHORT $LN27@PyBytes_Fr@4
$LN26@PyBytes_Fr@4:

; 2673 :                 PyErr_SetString(PyExc_ValueError,
; 2674 :                                 "bytes must be in range(0, 256)");

  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@MLPHABLA@bytes?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  00247	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0024e	e8 00 00 00 00	 call	 PyErr_SetString

; 2675 :                 Py_DECREF(new);

  00253	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new$[rsp]
  00258	e8 00 00 00 00	 call	 _Py_DecRef

; 2676 :                 return NULL;

  0025d	33 c0		 xor	 eax, eax
  0025f	e9 16 03 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN27@PyBytes_Fr@4:

; 2677 :             }
; 2678 :             ((PyBytesObject *)new)->ob_sval[i] = (char) value;

  00264	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00269	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new$[rsp]
  0026e	48 03 c8	 add	 rcx, rax
  00271	48 8b c1	 mov	 rax, rcx
  00274	0f b6 8c 24 90
	00 00 00	 movzx	 ecx, BYTE PTR value$24399[rsp]
  0027c	88 48 78	 mov	 BYTE PTR [rax+120], cl

; 2679 :         }

  0027f	e9 30 ff ff ff	 jmp	 $LN30@PyBytes_Fr@4
$LN29@PyBytes_Fr@4:

; 2680 :         return new;

  00284	48 8b 44 24 38	 mov	 rax, QWORD PTR new$[rsp]
  00289	e9 ec 02 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN33@PyBytes_Fr@4:

; 2681 :     }
; 2682 :     if (PyTuple_CheckExact(x)) {

  0028e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  00295	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  0029d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  002a1	0f 85 09 01 00
	00		 jne	 $LN25@PyBytes_Fr@4

; 2683 :         new = PyBytes_FromStringAndSize(NULL, Py_SIZE(x));

  002a7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  002af	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  002b3	33 c9		 xor	 ecx, ecx
  002b5	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  002ba	48 89 44 24 38	 mov	 QWORD PTR new$[rsp], rax

; 2684 :         if (new == NULL)

  002bf	48 83 7c 24 38
	00		 cmp	 QWORD PTR new$[rsp], 0
  002c5	75 07		 jne	 SHORT $LN24@PyBytes_Fr@4

; 2685 :             return NULL;

  002c7	33 c0		 xor	 eax, eax
  002c9	e9 ac 02 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN24@PyBytes_Fr@4:

; 2686 :         for (i = 0; i < Py_SIZE(x); i++) {

  002ce	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  002d7	eb 0d		 jmp	 SHORT $LN23@PyBytes_Fr@4
$LN22@PyBytes_Fr@4:
  002d9	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  002de	48 ff c0	 inc	 rax
  002e1	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN23@PyBytes_Fr@4:
  002e6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  002ee	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002f2	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  002f7	0f 8d a9 00 00
	00		 jge	 $LN21@PyBytes_Fr@4

; 2687 :             Py_ssize_t value = PyNumber_AsSsize_t(
; 2688 :                 PyTuple_GET_ITEM(x, i), PyExc_ValueError);

  002fd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_ValueError
  00304	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0030c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00311	48 8b 4c c8 70	 mov	 rcx, QWORD PTR [rax+rcx*8+112]
  00316	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0031b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR value$24422[rsp], rax

; 2689 :             if (value == -1 && PyErr_Occurred()) {

  00323	48 83 bc 24 98
	00 00 00 ff	 cmp	 QWORD PTR value$24422[rsp], -1
  0032c	75 1b		 jne	 SHORT $LN20@PyBytes_Fr@4
  0032e	e8 00 00 00 00	 call	 PyErr_Occurred
  00333	48 85 c0	 test	 rax, rax
  00336	74 11		 je	 SHORT $LN20@PyBytes_Fr@4

; 2690 :                 Py_DECREF(new);

  00338	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new$[rsp]
  0033d	e8 00 00 00 00	 call	 _Py_DecRef

; 2691 :                 return NULL;

  00342	33 c0		 xor	 eax, eax
  00344	e9 31 02 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN20@PyBytes_Fr@4:

; 2692 :             }
; 2693 :             if (value < 0 || value >= 256) {

  00349	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR value$24422[rsp], 0
  00352	7c 0e		 jl	 SHORT $LN18@PyBytes_Fr@4
  00354	48 81 bc 24 98
	00 00 00 00 01
	00 00		 cmp	 QWORD PTR value$24422[rsp], 256 ; 00000100H
  00360	7c 24		 jl	 SHORT $LN19@PyBytes_Fr@4
$LN18@PyBytes_Fr@4:

; 2694 :                 PyErr_SetString(PyExc_ValueError,
; 2695 :                                 "bytes must be in range(0, 256)");

  00362	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@MLPHABLA@bytes?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  00369	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00370	e8 00 00 00 00	 call	 PyErr_SetString

; 2696 :                 Py_DECREF(new);

  00375	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new$[rsp]
  0037a	e8 00 00 00 00	 call	 _Py_DecRef

; 2697 :                 return NULL;

  0037f	33 c0		 xor	 eax, eax
  00381	e9 f4 01 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN19@PyBytes_Fr@4:

; 2698 :             }
; 2699 :             ((PyBytesObject *)new)->ob_sval[i] = (char) value;

  00386	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0038b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new$[rsp]
  00390	48 03 c8	 add	 rcx, rax
  00393	48 8b c1	 mov	 rax, rcx
  00396	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR value$24422[rsp]
  0039e	88 48 78	 mov	 BYTE PTR [rax+120], cl

; 2700 :         }

  003a1	e9 33 ff ff ff	 jmp	 $LN22@PyBytes_Fr@4
$LN21@PyBytes_Fr@4:

; 2701 :         return new;

  003a6	48 8b 44 24 38	 mov	 rax, QWORD PTR new$[rsp]
  003ab	e9 ca 01 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN25@PyBytes_Fr@4:

; 2702 :     }
; 2703 : 
; 2704 :     /* For iterator version, create a string object and resize as needed */
; 2705 :     size = _PyObject_LengthHint(x, 64);

  003b0	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  003b5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  003bd	e8 00 00 00 00	 call	 _PyObject_LengthHint
  003c2	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 2706 :     if (size == -1 && PyErr_Occurred())

  003c7	48 83 7c 24 30
	ff		 cmp	 QWORD PTR size$[rsp], -1
  003cd	75 11		 jne	 SHORT $LN17@PyBytes_Fr@4
  003cf	e8 00 00 00 00	 call	 PyErr_Occurred
  003d4	48 85 c0	 test	 rax, rax
  003d7	74 07		 je	 SHORT $LN17@PyBytes_Fr@4

; 2707 :         return NULL;

  003d9	33 c0		 xor	 eax, eax
  003db	e9 9a 01 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN17@PyBytes_Fr@4:

; 2708 :     /* Allocate an extra byte to prevent PyBytes_FromStringAndSize() from
; 2709 :        returning a shared empty bytes string. This required because we
; 2710 :        want to call _PyBytes_Resize() the returned object, which we can
; 2711 :        only do on bytes objects with refcount == 1. */
; 2712 :     size += 1;

  003e0	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  003e5	48 ff c0	 inc	 rax
  003e8	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 2713 :     new = PyBytes_FromStringAndSize(NULL, size);

  003ed	48 8b 54 24 30	 mov	 rdx, QWORD PTR size$[rsp]
  003f2	33 c9		 xor	 ecx, ecx
  003f4	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  003f9	48 89 44 24 38	 mov	 QWORD PTR new$[rsp], rax

; 2714 :     if (new == NULL)

  003fe	48 83 7c 24 38
	00		 cmp	 QWORD PTR new$[rsp], 0
  00404	75 07		 jne	 SHORT $LN16@PyBytes_Fr@4

; 2715 :         return NULL;

  00406	33 c0		 xor	 eax, eax
  00408	e9 6d 01 00 00	 jmp	 $LN45@PyBytes_Fr@4
$LN16@PyBytes_Fr@4:

; 2716 : 
; 2717 :     /* Get the iterator */
; 2718 :     it = PyObject_GetIter(x);

  0040d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  00415	e8 00 00 00 00	 call	 PyObject_GetIter
  0041a	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 2719 :     if (it == NULL)

  0041f	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00425	75 05		 jne	 SHORT $LN15@PyBytes_Fr@4

; 2720 :         goto error;

  00427	e9 2a 01 00 00	 jmp	 $error$24441
$LN15@PyBytes_Fr@4:

; 2721 : 
; 2722 :     /* Run the iterator to exhaustion */
; 2723 :     for (i = 0; ; i++) {

  0042c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00435	eb 0d		 jmp	 SHORT $LN14@PyBytes_Fr@4
$LN13@PyBytes_Fr@4:
  00437	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0043c	48 ff c0	 inc	 rax
  0043f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN14@PyBytes_Fr@4:

; 2724 :         PyObject *item;
; 2725 :         Py_ssize_t value;
; 2726 : 
; 2727 :         /* Get the next item */
; 2728 :         item = PyIter_Next(it);

  00444	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00449	e8 00 00 00 00	 call	 PyIter_Next
  0044e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR item$24445[rsp], rax

; 2729 :         if (item == NULL) {

  00456	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR item$24445[rsp], 0
  0045f	75 14		 jne	 SHORT $LN11@PyBytes_Fr@4

; 2730 :             if (PyErr_Occurred())

  00461	e8 00 00 00 00	 call	 PyErr_Occurred
  00466	48 85 c0	 test	 rax, rax
  00469	74 05		 je	 SHORT $LN10@PyBytes_Fr@4

; 2731 :                 goto error;

  0046b	e9 e6 00 00 00	 jmp	 $error$24441
$LN10@PyBytes_Fr@4:

; 2732 :             break;

  00470	e9 c1 00 00 00	 jmp	 $LN12@PyBytes_Fr@4
$LN11@PyBytes_Fr@4:

; 2733 :         }
; 2734 : 
; 2735 :         /* Interpret it as an int (__index__) */
; 2736 :         value = PyNumber_AsSsize_t(item, PyExc_ValueError);

  00475	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_ValueError
  0047c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR item$24445[rsp]
  00484	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00489	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR value$24446[rsp], rax

; 2737 :         Py_DECREF(item);

  00491	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR item$24445[rsp]
  00499	e8 00 00 00 00	 call	 _Py_DecRef

; 2738 :         if (value == -1 && PyErr_Occurred())

  0049e	48 83 bc 24 a0
	00 00 00 ff	 cmp	 QWORD PTR value$24446[rsp], -1
  004a7	75 0f		 jne	 SHORT $LN9@PyBytes_Fr@4
  004a9	e8 00 00 00 00	 call	 PyErr_Occurred
  004ae	48 85 c0	 test	 rax, rax
  004b1	74 05		 je	 SHORT $LN9@PyBytes_Fr@4

; 2739 :             goto error;

  004b3	e9 9e 00 00 00	 jmp	 $error$24441
$LN9@PyBytes_Fr@4:

; 2740 : 
; 2741 :         /* Range check */
; 2742 :         if (value < 0 || value >= 256) {

  004b8	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR value$24446[rsp], 0
  004c1	7c 0e		 jl	 SHORT $LN7@PyBytes_Fr@4
  004c3	48 81 bc 24 a0
	00 00 00 00 01
	00 00		 cmp	 QWORD PTR value$24446[rsp], 256 ; 00000100H
  004cf	7c 15		 jl	 SHORT $LN8@PyBytes_Fr@4
$LN7@PyBytes_Fr@4:

; 2743 :             PyErr_SetString(PyExc_ValueError,
; 2744 :                             "bytes must be in range(0, 256)");

  004d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@MLPHABLA@bytes?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  004d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  004df	e8 00 00 00 00	 call	 PyErr_SetString

; 2745 :             goto error;

  004e4	eb 70		 jmp	 SHORT $error$24441
$LN8@PyBytes_Fr@4:

; 2746 :         }
; 2747 : 
; 2748 :         /* Append the byte */
; 2749 :         if (i >= size) {

  004e6	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  004eb	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  004f0	7c 24		 jl	 SHORT $LN6@PyBytes_Fr@4

; 2750 :             size = 2 * size + 1;

  004f2	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  004f7	48 8d 44 00 01	 lea	 rax, QWORD PTR [rax+rax+1]
  004fc	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 2751 :             if (_PyBytes_Resize(&new, size) < 0)

  00501	48 8b 54 24 30	 mov	 rdx, QWORD PTR size$[rsp]
  00506	48 8d 4c 24 38	 lea	 rcx, QWORD PTR new$[rsp]
  0050b	e8 00 00 00 00	 call	 _PyBytes_Resize
  00510	85 c0		 test	 eax, eax
  00512	7d 02		 jge	 SHORT $LN5@PyBytes_Fr@4

; 2752 :                 goto error;

  00514	eb 40		 jmp	 SHORT $error$24441
$LN5@PyBytes_Fr@4:
$LN6@PyBytes_Fr@4:

; 2753 :         }
; 2754 :         ((PyBytesObject *)new)->ob_sval[i] = (char) value;

  00516	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0051b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new$[rsp]
  00520	48 03 c8	 add	 rcx, rax
  00523	48 8b c1	 mov	 rax, rcx
  00526	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR value$24446[rsp]
  0052e	88 48 78	 mov	 BYTE PTR [rax+120], cl

; 2755 :     }

  00531	e9 01 ff ff ff	 jmp	 $LN13@PyBytes_Fr@4
$LN12@PyBytes_Fr@4:

; 2756 :     _PyBytes_Resize(&new, i);

  00536	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0053b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR new$[rsp]
  00540	e8 00 00 00 00	 call	 _PyBytes_Resize

; 2757 : 
; 2758 :     /* Clean up and return success */
; 2759 :     Py_DECREF(it);

  00545	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0054a	e8 00 00 00 00	 call	 _Py_DecRef

; 2760 :     return new;

  0054f	48 8b 44 24 38	 mov	 rax, QWORD PTR new$[rsp]
  00554	eb 24		 jmp	 SHORT $LN45@PyBytes_Fr@4
$error$24441:
$LN4@PyBytes_Fr@4:

; 2761 : 
; 2762 :   error:
; 2763 :     /* Error handling when new != NULL */
; 2764 :     Py_XDECREF(it);

  00556	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  0055c	74 0a		 je	 SHORT $LN1@PyBytes_Fr@4
  0055e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00563	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyBytes_Fr@4:
  00568	33 c0		 xor	 eax, eax
  0056a	85 c0		 test	 eax, eax
  0056c	75 e8		 jne	 SHORT $LN4@PyBytes_Fr@4

; 2765 :     Py_DECREF(new);

  0056e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new$[rsp]
  00573	e8 00 00 00 00	 call	 _Py_DecRef

; 2766 :     return NULL;

  00578	33 c0		 xor	 eax, eax
$LN45@PyBytes_Fr@4:

; 2767 : }

  0057a	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00581	c3		 ret	 0
PyBytes_FromObject ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CI@PNJCPFFG@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAn?$AAe?$AAw?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@LIFEINFL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@EILLKDCI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EM@FFEHMLDK@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$str_subtype_new DD imagerel str_subtype_new
	DD	imagerel str_subtype_new+561
	DD	imagerel $unwind$str_subtype_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$str_subtype_new DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_1CI@PNJCPFFG@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAn?$AAe?$AAw?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@PNJCPFFG@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAn?$AAe?$AAw?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'p', 00H, 'n', 00H, 'e', 00H, 'w', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LIFEINFL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@LIFEINFL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 't', 00H, 'm', 00H, 'p', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@EILLKDCI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@EILLKDCI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'E'
	DB	00H, 'x', 00H, 'a', 00H, 'c', 00H, 't', 00H, '(', 00H, 't', 00H
	DB	'm', 00H, 'p', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@FFEHMLDK@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_@
CONST	SEGMENT
??_C@_1EM@FFEHMLDK@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_@ DB 'P'
	DB	00H, 'y', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H
	DB	'I', 00H, 's', 00H, 'S', 00H, 'u', 00H, 'b', 00H, 't', 00H, 'y'
	DB	00H, 'p', 00H, 'e', 00H, '(', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, ',', 00H, ' ', 00H, '&', 00H, 'P', 00H, 'y', 00H, 'B'
	DB	00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, '_', 00H, 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT str_subtype_new
_TEXT	SEGMENT
n$ = 32
tmp$ = 40
pnew$ = 48
t_$24495 = 56
s_$24501 = 64
i_$24493 = 72
n_$24494 = 80
type$ = 112
args$ = 120
kwds$ = 128
str_subtype_new PROC					; COMDAT

; 2771 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2772 :     PyObject *tmp, *pnew;
; 2773 :     Py_ssize_t n;
; 2774 : 
; 2775 :     assert(PyType_IsSubtype(type, &PyBytes_Type));

  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyBytes_Type
  0001a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR type$[rsp]
  0001f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00024	85 c0		 test	 eax, eax
  00026	75 1c		 jne	 SHORT $LN13@str_subtyp
  00028	41 b8 d7 0a 00
	00		 mov	 r8d, 2775		; 00000ad7H
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@FFEHMLDK@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00042	33 c0		 xor	 eax, eax
$LN13@str_subtyp:

; 2776 :     tmp = bytes_new(&PyBytes_Type, args, kwds);

  00044	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR kwds$[rsp]
  0004c	48 8b 54 24 78	 mov	 rdx, QWORD PTR args$[rsp]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBytes_Type
  00058	e8 00 00 00 00	 call	 bytes_new
  0005d	48 89 44 24 28	 mov	 QWORD PTR tmp$[rsp], rax

; 2777 :     if (tmp == NULL)

  00062	48 83 7c 24 28
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00068	75 07		 jne	 SHORT $LN10@str_subtyp

; 2778 :         return NULL;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 bb 01 00 00	 jmp	 $LN11@str_subtyp
$LN10@str_subtyp:

; 2779 :     assert(PyBytes_CheckExact(tmp));

  00071	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00078	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmp$[rsp]
  0007d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00081	74 1c		 je	 SHORT $LN14@str_subtyp
  00083	41 b8 db 0a 00
	00		 mov	 r8d, 2779		; 00000adbH
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@EILLKDCI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009d	33 c0		 xor	 eax, eax
$LN14@str_subtyp:

; 2780 :     n = PyBytes_GET_SIZE(tmp);

  0009f	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  000a4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000ae	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b3	85 c0		 test	 eax, eax
  000b5	75 1c		 jne	 SHORT $LN15@str_subtyp
  000b7	41 b8 dc 0a 00
	00		 mov	 r8d, 2780		; 00000adcH
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@LIFEINFL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d1	33 c0		 xor	 eax, eax
$LN15@str_subtyp:
  000d3	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  000d8	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000dc	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 2781 :     pnew = type->tp_alloc(type, n);

  000e1	48 8b 54 24 20	 mov	 rdx, QWORD PTR n$[rsp]
  000e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR type$[rsp]
  000eb	48 8b 44 24 70	 mov	 rax, QWORD PTR type$[rsp]
  000f0	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000f6	48 89 44 24 30	 mov	 QWORD PTR pnew$[rsp], rax

; 2782 :     if (pnew != NULL) {

  000fb	48 83 7c 24 30
	00		 cmp	 QWORD PTR pnew$[rsp], 0
  00101	0f 84 16 01 00
	00		 je	 $LN9@str_subtyp
$LN8@str_subtyp:

; 2783 :         Py_MEMCPY(PyBytes_AS_STRING(pnew),
; 2784 :                   PyBytes_AS_STRING(tmp), n+1);

  00107	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  0010c	48 ff c0	 inc	 rax
  0010f	48 89 44 24 50	 mov	 QWORD PTR n_$24494[rsp], rax
  00114	48 8b 44 24 30	 mov	 rax, QWORD PTR pnew$[rsp]
  00119	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0011d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00123	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00128	85 c0		 test	 eax, eax
  0012a	75 1c		 jne	 SHORT $LN16@str_subtyp
  0012c	41 b8 e0 0a 00
	00		 mov	 r8d, 2784		; 00000ae0H
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@PNJCPFFG@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAn?$AAe?$AAw?$AA?$CJ?$AA?$AA@
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00146	33 c0		 xor	 eax, eax
$LN16@str_subtyp:
  00148	48 8b 44 24 30	 mov	 rax, QWORD PTR pnew$[rsp]
  0014d	48 83 c0 78	 add	 rax, 120		; 00000078H
  00151	48 89 44 24 38	 mov	 QWORD PTR t_$24495[rsp], rax
  00156	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  0015b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0015f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00165	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0016a	85 c0		 test	 eax, eax
  0016c	75 1c		 jne	 SHORT $LN17@str_subtyp
  0016e	41 b8 e0 0a 00
	00		 mov	 r8d, 2784		; 00000ae0H
  00174	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0017b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@LIFEINFL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00188	33 c0		 xor	 eax, eax
$LN17@str_subtyp:
  0018a	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  0018f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00193	48 89 44 24 40	 mov	 QWORD PTR s_$24501[rsp], rax
  00198	48 83 7c 24 50
	10		 cmp	 QWORD PTR n_$24494[rsp], 16
  0019e	72 16		 jb	 SHORT $LN5@str_subtyp
  001a0	4c 8b 44 24 50	 mov	 r8, QWORD PTR n_$24494[rsp]
  001a5	48 8b 54 24 40	 mov	 rdx, QWORD PTR s_$24501[rsp]
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t_$24495[rsp]
  001af	e8 00 00 00 00	 call	 memcpy
  001b4	eb 4b		 jmp	 SHORT $LN4@str_subtyp
$LN5@str_subtyp:
  001b6	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR i_$24493[rsp], 0
  001bf	eb 0d		 jmp	 SHORT $LN3@str_subtyp
$LN2@str_subtyp:
  001c1	48 8b 44 24 48	 mov	 rax, QWORD PTR i_$24493[rsp]
  001c6	48 ff c0	 inc	 rax
  001c9	48 89 44 24 48	 mov	 QWORD PTR i_$24493[rsp], rax
$LN3@str_subtyp:
  001ce	48 8b 44 24 50	 mov	 rax, QWORD PTR n_$24494[rsp]
  001d3	48 39 44 24 48	 cmp	 QWORD PTR i_$24493[rsp], rax
  001d8	73 27		 jae	 SHORT $LN1@str_subtyp
  001da	48 8b 44 24 48	 mov	 rax, QWORD PTR i_$24493[rsp]
  001df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t_$24495[rsp]
  001e4	48 03 c8	 add	 rcx, rax
  001e7	48 8b c1	 mov	 rax, rcx
  001ea	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i_$24493[rsp]
  001ef	48 8b 54 24 40	 mov	 rdx, QWORD PTR s_$24501[rsp]
  001f4	48 03 d1	 add	 rdx, rcx
  001f7	48 8b ca	 mov	 rcx, rdx
  001fa	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001fd	88 08		 mov	 BYTE PTR [rax], cl
  001ff	eb c0		 jmp	 SHORT $LN2@str_subtyp
$LN1@str_subtyp:
$LN4@str_subtyp:
  00201	33 c0		 xor	 eax, eax
  00203	85 c0		 test	 eax, eax
  00205	0f 85 fc fe ff
	ff		 jne	 $LN8@str_subtyp

; 2785 :         ((PyBytesObject *)pnew)->ob_shash =
; 2786 :             ((PyBytesObject *)tmp)->ob_shash;

  0020b	48 8b 44 24 30	 mov	 rax, QWORD PTR pnew$[rsp]
  00210	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmp$[rsp]
  00215	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00219	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
$LN9@str_subtyp:

; 2787 :     }
; 2788 :     Py_DECREF(tmp);

  0021d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmp$[rsp]
  00222	e8 00 00 00 00	 call	 _Py_DecRef

; 2789 :     return pnew;

  00227	48 8b 44 24 30	 mov	 rax, QWORD PTR pnew$[rsp]
$LN11@str_subtyp:

; 2790 : }

  0022c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00230	c3		 ret	 0
str_subtype_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@DLDFGFNK@PyBytes_Concat?$AA@		; `string'
PUBLIC	??_C@_1BG@CDPACJFP@?$AAp?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	PyBytes_Concat
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBytes_Concat DD imagerel $LN10
	DD	imagerel $LN10+227
	DD	imagerel $unwind$PyBytes_Concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_Concat DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0P@DLDFGFNK@PyBytes_Concat?$AA@
CONST	SEGMENT
??_C@_0P@DLDFGFNK@PyBytes_Concat?$AA@ DB 'PyBytes_Concat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@CDPACJFP@?$AAp?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@CDPACJFP@?$AAp?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'p'
	DB	00H, 'v', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBytes_Concat
_TEXT	SEGMENT
v$ = 48
_py_tmp$24556 = 56
pv$ = 80
w$ = 88
PyBytes_Concat PROC					; COMDAT

; 2852 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2853 :     register PyObject *v;
; 2854 :     assert(pv != NULL);

  0000e	48 83 7c 24 50
	00		 cmp	 QWORD PTR pv$[rsp], 0
  00014	75 1c		 jne	 SHORT $LN9@PyBytes_Co
  00016	41 b8 26 0b 00
	00		 mov	 r8d, 2854		; 00000b26H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@CDPACJFP@?$AAp?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN9@PyBytes_Co:

; 2855 :     if (*pv == NULL)

  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  00037	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003b	75 05		 jne	 SHORT $LN6@PyBytes_Co

; 2856 :         return;

  0003d	e9 9c 00 00 00	 jmp	 $LN7@PyBytes_Co
$LN6@PyBytes_Co:

; 2857 :     if (w == NULL) {

  00042	48 83 7c 24 58
	00		 cmp	 QWORD PTR w$[rsp], 0
  00048	75 63		 jne	 SHORT $LN5@PyBytes_Co
$LN4@PyBytes_Co:

; 2858 :         Py_CLEAR(*pv);

  0004a	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  0004f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00053	74 50		 je	 SHORT $LN1@PyBytes_Co
  00055	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  00062	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  00065	41 b8 2a 0b 00
	00		 mov	 r8d, 2858		; 00000b2aH
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@DLDFGFNK@PyBytes_Concat?$AA@
  00079	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007e	85 c0		 test	 eax, eax
  00080	75 23		 jne	 SHORT $LN1@PyBytes_Co
  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  00087	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008a	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$24556[rsp], rax
  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  00094	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  0009b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$24556[rsp]
  000a0	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyBytes_Co:
  000a5	33 c0		 xor	 eax, eax
  000a7	85 c0		 test	 eax, eax
  000a9	75 9f		 jne	 SHORT $LN4@PyBytes_Co

; 2859 :         return;

  000ab	eb 31		 jmp	 SHORT $LN7@PyBytes_Co
$LN5@PyBytes_Co:

; 2860 :     }
; 2861 :     v = bytes_concat(*pv, w);

  000ad	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  000b2	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  000b7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000ba	e8 00 00 00 00	 call	 bytes_concat
  000bf	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax

; 2862 :     Py_DECREF(*pv);

  000c4	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  000c9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000cc	e8 00 00 00 00	 call	 _Py_DecRef

; 2863 :     *pv = v;

  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  000d6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  000db	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN7@PyBytes_Co:

; 2864 : }

  000de	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e2	c3		 ret	 0
PyBytes_Concat ENDP
_TEXT	ENDS
PUBLIC	PyBytes_ConcatAndDel
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBytes_ConcatAndDel DD imagerel $LN7
	DD	imagerel $LN7+58
	DD	imagerel $unwind$PyBytes_ConcatAndDel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_ConcatAndDel DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyBytes_ConcatAndDel
_TEXT	SEGMENT
pv$ = 48
w$ = 56
PyBytes_ConcatAndDel PROC				; COMDAT

; 2868 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2869 :     PyBytes_Concat(pv, w);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pv$[rsp]
  00018	e8 00 00 00 00	 call	 PyBytes_Concat
$LN4@PyBytes_Co@2:

; 2870 :     Py_XDECREF(w);

  0001d	48 83 7c 24 38
	00		 cmp	 QWORD PTR w$[rsp], 0
  00023	74 0a		 je	 SHORT $LN1@PyBytes_Co@2
  00025	48 8b 4c 24 38	 mov	 rcx, QWORD PTR w$[rsp]
  0002a	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyBytes_Co@2:
  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 e8		 jne	 SHORT $LN4@PyBytes_Co@2

; 2871 : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
PyBytes_ConcatAndDel ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@JCLLOKPM@_PyBytes_Resize?$AA@		; `string'
EXTRN	_PyObject_DebugRealloc:PROC
EXTRN	_Py_ForgetReference:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyBytes_Resize DD imagerel $LN13
	DD	imagerel $LN13+394
	DD	imagerel $unwind$_PyBytes_Resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyBytes_Resize DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BA@JCLLOKPM@_PyBytes_Resize?$AA@
CONST	SEGMENT
??_C@_0BA@JCLLOKPM@_PyBytes_Resize?$AA@ DB '_PyBytes_Resize', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyBytes_Resize
_TEXT	SEGMENT
v$ = 48
sv$ = 56
pv$ = 80
newsize$ = 88
_PyBytes_Resize PROC					; COMDAT

; 2890 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2891 :     register PyObject *v;
; 2892 :     register PyBytesObject *sv;
; 2893 :     v = *pv;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax

; 2894 :     if (!PyBytes_Check(v) || Py_REFCNT(v) != 1 || newsize < 0) {

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  00020	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00024	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0002f	85 c0		 test	 eax, eax
  00031	74 14		 je	 SHORT $LN7@PyBytes_Re@2
  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  00038	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  0003d	75 08		 jne	 SHORT $LN7@PyBytes_Re@2
  0003f	48 83 7c 24 58
	00		 cmp	 QWORD PTR newsize$[rsp], 0
  00045	7d 31		 jge	 SHORT $LN8@PyBytes_Re@2
$LN7@PyBytes_Re@2:

; 2895 :         *pv = 0;

  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  0004c	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2896 :         Py_DECREF(v);

  00053	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00058	e8 00 00 00 00	 call	 _Py_DecRef

; 2897 :         PyErr_BadInternalCall();

  0005d	ba 51 0b 00 00	 mov	 edx, 2897		; 00000b51H
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  00069	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2898 :         return -1;

  0006e	b8 ff ff ff ff	 mov	 eax, -1
  00073	e9 0d 01 00 00	 jmp	 $LN9@PyBytes_Re@2
$LN8@PyBytes_Re@2:
$LN6@PyBytes_Re@2:

; 2899 :     }
; 2900 :     PyPx_GUARD_OBJ(v);

  00078	e8 00 00 00 00	 call	 _Py_PXCTX
  0007d	85 c0		 test	 eax, eax
  0007f	74 28		 je	 SHORT $LN3@PyBytes_Re@2
  00081	c7 44 24 20 40
	00 00 00	 mov	 DWORD PTR [rsp+32], 64	; 00000040H
  00089	4c 8b 4c 24 30	 mov	 r9, QWORD PTR v$[rsp]
  0008e	41 b8 54 0b 00
	00		 mov	 r8d, 2900		; 00000b54H
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JCLLOKPM@_PyBytes_Resize?$AA@
  000a2	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a7	eb 26		 jmp	 SHORT $LN2@PyBytes_Re@2
$LN3@PyBytes_Re@2:
  000a9	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  000b1	4c 8b 4c 24 30	 mov	 r9, QWORD PTR v$[rsp]
  000b6	41 b8 54 0b 00
	00		 mov	 r8d, 2900		; 00000b54H
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JCLLOKPM@_PyBytes_Resize?$AA@
  000ca	e8 00 00 00 00	 call	 _PyParallel_Guard
$LN2@PyBytes_Re@2:
  000cf	33 c0		 xor	 eax, eax
  000d1	85 c0		 test	 eax, eax
  000d3	75 a3		 jne	 SHORT $LN6@PyBytes_Re@2

; 2901 : 
; 2902 :     /* XXX UNREF/NEWREF interface should be more symmetrical */
; 2903 :     _Py_DEC_REFTOTAL;

  000d5	e8 00 00 00 00	 call	 _Py_PXCTX
  000da	85 c0		 test	 eax, eax
  000dc	74 02		 je	 SHORT $LN11@PyBytes_Re@2
  000de	eb 11		 jmp	 SHORT $LN12@PyBytes_Re@2
$LN11@PyBytes_Re@2:
  000e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  000e7	48 ff c8	 dec	 rax
  000ea	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@PyBytes_Re@2:

; 2904 :     _Py_ForgetReference(v);

  000f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  000f6	e8 00 00 00 00	 call	 _Py_ForgetReference

; 2905 :     *pv = (PyObject *)
; 2906 :         PyObject_REALLOC((char *)v, PyBytesObject_SIZE + newsize);

  000fb	48 8b 44 24 58	 mov	 rax, QWORD PTR newsize$[rsp]
  00100	48 83 c0 79	 add	 rax, 121		; 00000079H
  00104	48 8b d0	 mov	 rdx, rax
  00107	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0010c	e8 00 00 00 00	 call	 _PyObject_DebugRealloc
  00111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pv$[rsp]
  00116	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2907 :     if (*pv == NULL) {

  00119	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  0011e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00122	75 16		 jne	 SHORT $LN1@PyBytes_Re@2

; 2908 :         PyObject_Del(v);

  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00129	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 2909 :         PyErr_NoMemory();

  0012e	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2910 :         return -1;

  00133	b8 ff ff ff ff	 mov	 eax, -1
  00138	eb 4b		 jmp	 SHORT $LN9@PyBytes_Re@2
$LN1@PyBytes_Re@2:

; 2911 :     }
; 2912 :     _Py_NewReference(*pv);

  0013a	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  0013f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00142	e8 00 00 00 00	 call	 _Py_NewReference

; 2913 :     sv = (PyBytesObject *) *pv;

  00147	48 8b 44 24 50	 mov	 rax, QWORD PTR pv$[rsp]
  0014c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0014f	48 89 44 24 38	 mov	 QWORD PTR sv$[rsp], rax

; 2914 :     Py_SIZE(sv) = newsize;

  00154	48 8b 44 24 38	 mov	 rax, QWORD PTR sv$[rsp]
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR newsize$[rsp]
  0015e	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 2915 :     sv->ob_sval[newsize] = '\0';

  00162	48 8b 44 24 58	 mov	 rax, QWORD PTR newsize$[rsp]
  00167	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sv$[rsp]
  0016c	48 03 c8	 add	 rcx, rax
  0016f	48 8b c1	 mov	 rax, rcx
  00172	c6 40 78 00	 mov	 BYTE PTR [rax+120], 0

; 2916 :     sv->ob_shash = -1;          /* invalidate cached hash value */

  00176	48 8b 44 24 38	 mov	 rax, QWORD PTR sv$[rsp]
  0017b	48 c7 40 70 ff
	ff ff ff	 mov	 QWORD PTR [rax+112], -1

; 2917 :     return 0;

  00183	33 c0		 xor	 eax, eax
$LN9@PyBytes_Re@2:

; 2918 : }

  00185	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00189	c3		 ret	 0
_PyBytes_Resize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@LGGNFECD@PyBytes_Fini?$AA@		; `string'
PUBLIC	PyBytes_Fini
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBytes_Fini DD imagerel $LN15
	DD	imagerel $LN15+288
	DD	imagerel $unwind$PyBytes_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBytes_Fini DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0N@LGGNFECD@PyBytes_Fini?$AA@
CONST	SEGMENT
??_C@_0N@LGGNFECD@PyBytes_Fini?$AA@ DB 'PyBytes_Fini', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBytes_Fini
_TEXT	SEGMENT
i$ = 48
_py_tmp$24611 = 56
_py_tmp$24619 = 64
PyBytes_Fini PROC					; COMDAT

; 2922 : {

$LN15:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2923 :     int i;
; 2924 :     if (Py_PXCTX)

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 05		 je	 SHORT $LN12@PyBytes_Fi

; 2925 :         return;

  0000d	e9 09 01 00 00	 jmp	 $LN13@PyBytes_Fi
$LN12@PyBytes_Fi:

; 2926 :     for (i = 0; i < UCHAR_MAX + 1; i++)

  00012	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 0a		 jmp	 SHORT $LN11@PyBytes_Fi
$LN10@PyBytes_Fi:
  0001c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@PyBytes_Fi:
  00026	81 7c 24 30 00
	01 00 00	 cmp	 DWORD PTR i$[rsp], 256	; 00000100H
  0002e	0f 8d 8a 00 00
	00		 jge	 $LN9@PyBytes_Fi
$LN8@PyBytes_Fi:

; 2927 :         Py_CLEAR(characters[i]);

  00034	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:characters
  00040	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00045	74 68		 je	 SHORT $LN5@PyBytes_Fi
  00047	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:characters
  00053	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005b	4c 8b 0c c1	 mov	 r9, QWORD PTR [rcx+rax*8]
  0005f	41 b8 6f 0b 00
	00		 mov	 r8d, 2927		; 00000b6fH
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@LGGNFECD@PyBytes_Fini?$AA@
  00073	e8 00 00 00 00	 call	 _PyParallel_Guard
  00078	85 c0		 test	 eax, eax
  0007a	75 33		 jne	 SHORT $LN5@PyBytes_Fi
  0007c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:characters
  00088	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0008c	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$24611[rsp], rax
  00091	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:characters
  0009d	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$24611[rsp]
  000aa	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@PyBytes_Fi:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	0f 85 7b ff ff
	ff		 jne	 $LN8@PyBytes_Fi
  000b9	e9 5e ff ff ff	 jmp	 $LN10@PyBytes_Fi
$LN9@PyBytes_Fi:
$LN4@PyBytes_Fi:

; 2928 :     Py_CLEAR(nullstring);

  000be	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR nullstring, 0
  000c6	74 4d		 je	 SHORT $LN1@PyBytes_Fi
  000c8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d0	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR nullstring
  000d7	41 b8 70 0b 00
	00		 mov	 r8d, 2928		; 00000b70H
  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@LGGNFECD@PyBytes_Fini?$AA@
  000eb	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f0	85 c0		 test	 eax, eax
  000f2	75 21		 jne	 SHORT $LN1@PyBytes_Fi
  000f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR nullstring
  000fb	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$24619[rsp], rax
  00100	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR nullstring, 0
  0010b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$24619[rsp]
  00110	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyBytes_Fi:
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	75 a3		 jne	 SHORT $LN4@PyBytes_Fi
$LN13@PyBytes_Fi:

; 2929 : }

  0011b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011f	c3		 ret	 0
PyBytes_Fini ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ ; `string'
PUBLIC	??_C@_0BA@NMNLIHFB@striter_dealloc?$AA@		; `string'
EXTRN	PyObject_GC_Del:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$striter_dealloc DD imagerel striter_dealloc
	DD	imagerel striter_dealloc+295
	DD	imagerel $unwind$striter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$striter_dealloc DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
CONST	SEGMENT
??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ DB 'g'
	DB	00H, '-', 00H, '>', 00H, 'g', 00H, 'c', 00H, '.', 00H, 'g', 00H
	DB	'c', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 's', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H, 'y', 00H
	DB	'G', 00H, 'C', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'S'
	DB	00H, '_', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H
	DB	'C', 00H, 'K', 00H, 'E', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NMNLIHFB@striter_dealloc?$AA@
CONST	SEGMENT
??_C@_0BA@NMNLIHFB@striter_dealloc?$AA@ DB 'striter_dealloc', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT striter_dealloc
_TEXT	SEGMENT
g$24637 = 48
tv79 = 56
it$ = 80
striter_dealloc PROC					; COMDAT

; 2941 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2942 :     _PyObject_GC_UNTRACK(it);

  00009	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00011	4c 8b 4c 24 50	 mov	 r9, QWORD PTR it$[rsp]
  00016	41 b8 7e 0b 00
	00		 mov	 r8d, 2942		; 00000b7eH
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@NMNLIHFB@striter_dealloc?$AA@
  0002a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0002f	85 c0		 test	 eax, eax
  00031	0f 85 c1 00 00
	00		 jne	 $LN8@striter_de
$LN7@striter_de:
  00037	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0003f	4c 8b 4c 24 50	 mov	 r9, QWORD PTR it$[rsp]
  00044	41 b8 7e 0b 00
	00		 mov	 r8d, 2942		; 00000b7eH
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@NMNLIHFB@striter_dealloc?$AA@
  00058	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005d	85 c0		 test	 eax, eax
  0005f	74 0b		 je	 SHORT $LN11@striter_de
  00061	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  0006a	eb 0e		 jmp	 SHORT $LN12@striter_de
$LN11@striter_de:
  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  00071	48 83 e8 18	 sub	 rax, 24
  00075	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
$LN12@striter_de:
  0007a	48 8b 44 24 38	 mov	 rax, QWORD PTR tv79[rsp]
  0007f	48 89 44 24 30	 mov	 QWORD PTR g$24637[rsp], rax
  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR g$24637[rsp]
  00089	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  0008e	75 1c		 jne	 SHORT $LN13@striter_de
  00090	41 b8 7e 0b 00
	00		 mov	 r8d, 2942		; 00000b7eH
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000aa	33 c0		 xor	 eax, eax
$LN13@striter_de:
  000ac	48 8b 44 24 30	 mov	 rax, QWORD PTR g$24637[rsp]
  000b1	48 c7 40 10 fe
	ff ff ff	 mov	 QWORD PTR [rax+16], -2
  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR g$24637[rsp]
  000be	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$24637[rsp]
  000c7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ca	48 89 08	 mov	 QWORD PTR [rax], rcx
  000cd	48 8b 44 24 30	 mov	 rax, QWORD PTR g$24637[rsp]
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$24637[rsp]
  000da	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000de	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR g$24637[rsp]
  000e7	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 85 3f ff ff
	ff		 jne	 $LN7@striter_de
$LN8@striter_de:
$LN4@striter_de:

; 2943 :     Py_XDECREF(it->it_seq);

  000f8	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  000fd	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00102	74 0e		 je	 SHORT $LN1@striter_de
  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  00109	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  0010d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@striter_de:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 e0		 jne	 SHORT $LN4@striter_de

; 2944 :     PyObject_GC_Del(it);

  00118	48 8b 4c 24 50	 mov	 rcx, QWORD PTR it$[rsp]
  0011d	e8 00 00 00 00	 call	 PyObject_GC_Del

; 2945 : }

  00122	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00126	c3		 ret	 0
striter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@MPIMDAPK@striter_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$striter_traverse DD imagerel striter_traverse
	DD	imagerel striter_traverse+116
	DD	imagerel $unwind$striter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$striter_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BB@MPIMDAPK@striter_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@MPIMDAPK@striter_traverse?$AA@ DB 'striter_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT striter_traverse
_TEXT	SEGMENT
vret$24662 = 32
it$ = 64
visit$ = 72
arg$ = 80
striter_traverse PROC					; COMDAT

; 2949 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@striter_tr:

; 2950 :     Py_VISIT(it->it_seq);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@striter_tr
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 86 0b 00
	00		 mov	 r8d, 2950		; 00000b86H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MPIMDAPK@striter_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@striter_tr:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 23		 je	 SHORT $LN2@striter_tr
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$24662[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$24662[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@striter_tr
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$24662[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@striter_tr
$LN1@striter_tr:
$LN2@striter_tr:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@striter_tr

; 2951 :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@striter_tr:

; 2952 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
striter_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CG@ECDBFODC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$striter_next DD imagerel striter_next
	DD	imagerel striter_next+295
	DD	imagerel $unwind$striter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$striter_next DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1CG@ECDBFODC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@ECDBFODC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, 'e', 00H, 'q', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'i'
	DB	00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT striter_next
_TEXT	SEGMENT
seq$ = 32
item$ = 40
it$ = 64
striter_next PROC					; COMDAT

; 2956 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2957 :     PyBytesObject *seq;
; 2958 :     PyObject *item;
; 2959 : 
; 2960 :     assert(it != NULL);

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR it$[rsp], 0
  0000f	75 1c		 jne	 SHORT $LN6@striter_ne
  00011	41 b8 90 0b 00
	00		 mov	 r8d, 2960		; 00000b90H
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002b	33 c0		 xor	 eax, eax
$LN6@striter_ne:

; 2961 :     seq = it->it_seq;

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00032	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00036	48 89 44 24 20	 mov	 QWORD PTR seq$[rsp], rax

; 2962 :     if (seq == NULL)

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00041	75 07		 jne	 SHORT $LN3@striter_ne

; 2963 :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 d8 00 00 00	 jmp	 $LN4@striter_ne
$LN3@striter_ne:

; 2964 :     assert(PyBytes_Check(seq));

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR seq$[rsp]
  0004f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00053	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00059	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0005e	85 c0		 test	 eax, eax
  00060	75 1c		 jne	 SHORT $LN7@striter_ne
  00062	41 b8 94 0b 00
	00		 mov	 r8d, 2964		; 00000b94H
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@ECDBFODC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007c	33 c0		 xor	 eax, eax
$LN7@striter_ne:

; 2965 : 
; 2966 :     if (it->it_index < PyBytes_GET_SIZE(seq)) {

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR seq$[rsp]
  00083	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00087	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0008d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00092	85 c0		 test	 eax, eax
  00094	75 1c		 jne	 SHORT $LN8@striter_ne
  00096	41 b8 96 0b 00
	00		 mov	 r8d, 2966		; 00000b96H
  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@ECDBFODC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b0	33 c0		 xor	 eax, eax
$LN8@striter_ne:
  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  000b7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR seq$[rsp]
  000bc	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000c0	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  000c4	7d 43		 jge	 SHORT $LN2@striter_ne

; 2967 :         item = PyLong_FromLong(
; 2968 :             (unsigned char)seq->ob_sval[it->it_index]);

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  000cb	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR seq$[rsp]
  000d4	0f b6 44 01 78	 movzx	 eax, BYTE PTR [rcx+rax+120]
  000d9	8b c8		 mov	 ecx, eax
  000db	e8 00 00 00 00	 call	 PyLong_FromLong
  000e0	48 89 44 24 28	 mov	 QWORD PTR item$[rsp], rax

; 2969 :         if (item != NULL)

  000e5	48 83 7c 24 28
	00		 cmp	 QWORD PTR item$[rsp], 0
  000eb	74 15		 je	 SHORT $LN1@striter_ne

; 2970 :             ++it->it_index;

  000ed	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  000f2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000f6	48 ff c0	 inc	 rax
  000f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  000fe	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN1@striter_ne:

; 2971 :         return item;

  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR item$[rsp]
  00107	eb 19		 jmp	 SHORT $LN4@striter_ne
$LN2@striter_ne:

; 2972 :     }
; 2973 : 
; 2974 :     Py_DECREF(seq);

  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR seq$[rsp]
  0010e	e8 00 00 00 00	 call	 _Py_DecRef

; 2975 :     it->it_seq = NULL;

  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00118	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 2976 :     return NULL;

  00120	33 c0		 xor	 eax, eax
$LN4@striter_ne:

; 2977 : }

  00122	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00126	c3		 ret	 0
striter_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@HKFMHENK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?9?$AA?$DO?$AAi?$AAt?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$striter_len DD imagerel striter_len
	DD	imagerel striter_len+131
	DD	imagerel $unwind$striter_len
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$striter_len DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1DE@HKFMHENK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?9?$AA?$DO?$AAi?$AAt?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@HKFMHENK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?9?$AA?$DO?$AAi?$AAt?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'i', 00H, 't', 00H, '-', 00H, '>', 00H, 'i', 00H, 't', 00H
	DB	'_', 00H, 's', 00H, 'e', 00H, 'q', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT striter_len
_TEXT	SEGMENT
len$ = 32
it$ = 64
striter_len PROC					; COMDAT

; 2981 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2982 :     Py_ssize_t len = 0;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0

; 2983 :     if (it->it_seq)

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00017	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0001c	74 56		 je	 SHORT $LN1@striter_le

; 2984 :         len = PyBytes_GET_SIZE(it->it_seq) - it->it_index;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00023	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00027	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00031	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00036	85 c0		 test	 eax, eax
  00038	75 1c		 jne	 SHORT $LN4@striter_le
  0003a	41 b8 a8 0b 00
	00		 mov	 r8d, 2984		; 00000ba8H
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@PIHJIEFM@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@HKFMHENK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?9?$AA?$DO?$AAi?$AAt?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00054	33 c0		 xor	 eax, eax
$LN4@striter_le:
  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0005b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  00064	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00068	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006c	48 2b c1	 sub	 rax, rcx
  0006f	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax
$LN1@striter_le:

; 2985 :     return PyLong_FromSsize_t(len);

  00074	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  00079	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 2986 : }

  0007e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00082	c3		 ret	 0
striter_len ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@		; `string'
PUBLIC	??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@		; `string'
PUBLIC	??_C@_04BKLHDIKK@iter?$AA@			; `string'
EXTRN	PyUnicode_FromUnicode:PROC
EXTRN	_PyObject_GetBuiltin:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$striter_reduce DD imagerel striter_reduce
	DD	imagerel striter_reduce+133
	DD	imagerel $unwind$striter_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$striter_reduce DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@ DB 'N(N)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
CONST	SEGMENT
??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@ DB 'N(O)n', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLHDIKK@iter?$AA@
CONST	SEGMENT
??_C@_04BKLHDIKK@iter?$AA@ DB 'iter', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT striter_reduce
_TEXT	SEGMENT
u$24710 = 32
it$ = 64
striter_reduce PROC					; COMDAT

; 2993 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2994 :     if (it->it_seq != NULL) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	74 31		 je	 SHORT $LN3@striter_re

; 2995 :         return Py_BuildValue("N(O)n", _PyObject_GetBuiltin("iter"),
; 2996 :                              it->it_seq, it->it_index);

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  0001c	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  00026	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  0002f	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  00033	48 8b d0	 mov	 rdx, rax
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
  0003d	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00042	eb 3c		 jmp	 SHORT $LN4@striter_re

; 2997 :     } else {

  00044	eb 3a		 jmp	 SHORT $LN2@striter_re
$LN3@striter_re:

; 2998 :         PyObject *u = PyUnicode_FromUnicode(NULL, 0);

  00046	33 d2		 xor	 edx, edx
  00048	33 c9		 xor	 ecx, ecx
  0004a	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0004f	48 89 44 24 20	 mov	 QWORD PTR u$24710[rsp], rax

; 2999 :         if (u == NULL)

  00054	48 83 7c 24 20
	00		 cmp	 QWORD PTR u$24710[rsp], 0
  0005a	75 04		 jne	 SHORT $LN1@striter_re

; 3000 :             return NULL;

  0005c	33 c0		 xor	 eax, eax
  0005e	eb 20		 jmp	 SHORT $LN4@striter_re
$LN1@striter_re:

; 3001 :         return Py_BuildValue("N(N)", _PyObject_GetBuiltin("iter"), u);

  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  00067	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  0006c	4c 8b 44 24 20	 mov	 r8, QWORD PTR u$24710[rsp]
  00071	48 8b d0	 mov	 rdx, rax
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
  0007b	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN2@striter_re:
$LN4@striter_re:

; 3002 :     }
; 3003 : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	c3		 ret	 0
striter_reduce ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$striter_setstate DD imagerel striter_setstate
	DD	imagerel striter_setstate+106
	DD	imagerel $unwind$striter_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$striter_setstate DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT striter_setstate
_TEXT	SEGMENT
index$ = 32
it$ = 64
state$ = 72
striter_setstate PROC					; COMDAT

; 3009 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3010 :     Py_ssize_t index = PyLong_AsSsize_t(state);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00013	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00018	48 89 44 24 20	 mov	 QWORD PTR index$[rsp], rax

; 3011 :     if (index == -1 && PyErr_Occurred())

  0001d	48 83 7c 24 20
	ff		 cmp	 QWORD PTR index$[rsp], -1
  00023	75 0e		 jne	 SHORT $LN2@striter_se
  00025	e8 00 00 00 00	 call	 PyErr_Occurred
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 04		 je	 SHORT $LN2@striter_se

; 3012 :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 32		 jmp	 SHORT $LN3@striter_se
$LN2@striter_se:

; 3013 :     if (index < 0)

  00033	48 83 7c 24 20
	00		 cmp	 QWORD PTR index$[rsp], 0
  00039	7d 09		 jge	 SHORT $LN1@striter_se

; 3014 :         index = 0;

  0003b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR index$[rsp], 0
$LN1@striter_se:

; 3015 :     it->it_index = index;

  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00049	48 8b 4c 24 20	 mov	 rcx, QWORD PTR index$[rsp]
  0004e	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3016 :     Py_RETURN_NONE;

  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00059	e8 00 00 00 00	 call	 _Py_IncRef
  0005e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@striter_se:

; 3017 : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
striter_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_0L@KAOKLDGC@bytes_iter?$AA@		; `string'
EXTRN	_PyGC_generation0:QWORD
EXTRN	Py_FatalError:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytes_iter DD imagerel bytes_iter
	DD	imagerel bytes_iter+412
	DD	imagerel $unwind$bytes_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytes_iter DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KAOKLDGC@bytes_iter?$AA@
CONST	SEGMENT
??_C@_0L@KAOKLDGC@bytes_iter?$AA@ DB 'bytes_iter', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytes_iter
_TEXT	SEGMENT
it$ = 48
g$24774 = 56
tv76 = 64
tv128 = 72
seq$ = 96
bytes_iter PROC						; COMDAT

; 3066 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3067 :     striterobject *it;
; 3068 : 
; 3069 :     if (!PyBytes_Check(seq)) {

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR seq$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 18		 jne	 SHORT $LN7@bytes_iter

; 3070 :         PyErr_BadInternalCall();

  00021	ba fe 0b 00 00	 mov	 edx, 3070		; 00000bfeH
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  0002d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3071 :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 5e 01 00 00	 jmp	 $LN8@bytes_iter
$LN7@bytes_iter:

; 3072 :     }
; 3073 :     it = PyObject_GC_New(striterobject, &PyBytesIter_Type);

  00039	e8 00 00 00 00	 call	 _Py_PXCTX
  0003e	85 c0		 test	 eax, eax
  00040	74 13		 je	 SHORT $LN10@bytes_iter
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBytesIter_Type
  00049	e8 00 00 00 00	 call	 _PxObject_New
  0004e	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
  00053	eb 11		 jmp	 SHORT $LN11@bytes_iter
$LN10@bytes_iter:
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBytesIter_Type
  0005c	e8 00 00 00 00	 call	 _PyObject_GC_New
  00061	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
$LN11@bytes_iter:
  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR tv76[rsp]
  0006b	48 89 44 24 30	 mov	 QWORD PTR it$[rsp], rax

; 3074 :     if (it == NULL)

  00070	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$[rsp], 0
  00076	75 07		 jne	 SHORT $LN6@bytes_iter

; 3075 :         return NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	e9 18 01 00 00	 jmp	 $LN8@bytes_iter
$LN6@bytes_iter:

; 3076 :     it->it_index = 0;

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  00084	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 3077 :     Py_INCREF(seq);

  0008c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR seq$[rsp]
  00091	e8 00 00 00 00	 call	 _Py_IncRef

; 3078 :     it->it_seq = (PyBytesObject *)seq;

  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  0009b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR seq$[rsp]
  000a0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 3079 :     _PyObject_GC_TRACK(it);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 30	 mov	 r9, QWORD PTR it$[rsp]
  000b1	41 b8 07 0c 00
	00		 mov	 r8d, 3079		; 00000c07H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@KAOKLDGC@bytes_iter?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	0f 85 c0 00 00
	00		 jne	 $LN5@bytes_iter
$LN4@bytes_iter:
  000d2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000da	4c 8b 4c 24 30	 mov	 r9, QWORD PTR it$[rsp]
  000df	41 b8 07 0c 00
	00		 mov	 r8d, 3079		; 00000c07H
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@IJCMIAIO@?4?4?2Objects?2bytesobject?4c?$AA@
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@KAOKLDGC@bytes_iter?$AA@
  000f3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f8	85 c0		 test	 eax, eax
  000fa	74 0b		 je	 SHORT $LN12@bytes_iter
  000fc	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv128[rsp], 0
  00105	eb 0e		 jmp	 SHORT $LN13@bytes_iter
$LN12@bytes_iter:
  00107	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  0010c	48 83 e8 18	 sub	 rax, 24
  00110	48 89 44 24 48	 mov	 QWORD PTR tv128[rsp], rax
$LN13@bytes_iter:
  00115	48 8b 44 24 48	 mov	 rax, QWORD PTR tv128[rsp]
  0011a	48 89 44 24 38	 mov	 QWORD PTR g$24774[rsp], rax
  0011f	48 8b 44 24 38	 mov	 rax, QWORD PTR g$24774[rsp]
  00124	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  00129	74 0c		 je	 SHORT $LN1@bytes_iter
  0012b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  00132	e8 00 00 00 00	 call	 Py_FatalError
$LN1@bytes_iter:
  00137	48 8b 44 24 38	 mov	 rax, QWORD PTR g$24774[rsp]
  0013c	48 c7 40 10 fd
	ff ff ff	 mov	 QWORD PTR [rax+16], -3
  00144	48 8b 44 24 38	 mov	 rax, QWORD PTR g$24774[rsp]
  00149	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  00150	48 89 08	 mov	 QWORD PTR [rax], rcx
  00153	48 8b 44 24 38	 mov	 rax, QWORD PTR g$24774[rsp]
  00158	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  0015f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00163	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00167	48 8b 44 24 38	 mov	 rax, QWORD PTR g$24774[rsp]
  0016c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00170	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$24774[rsp]
  00175	48 89 08	 mov	 QWORD PTR [rax], rcx
  00178	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0017f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$24774[rsp]
  00184	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00188	33 c0		 xor	 eax, eax
  0018a	85 c0		 test	 eax, eax
  0018c	0f 85 40 ff ff
	ff		 jne	 $LN4@bytes_iter
$LN5@bytes_iter:

; 3080 :     return (PyObject *)it;

  00192	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
$LN8@bytes_iter:

; 3081 : }

  00197	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0019b	c3		 ret	 0
bytes_iter ENDP
_TEXT	ENDS
END
