; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	PyFuture_FromAST
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyObject_DebugMalloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\future.c
pdata	SEGMENT
$pdata$PyFuture_FromAST DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$PyFuture_FromAST
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFuture_FromAST DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyFuture_FromAST
_TEXT	SEGMENT
ff$ = 32
mod$ = 64
filename$ = 72
PyFuture_FromAST PROC					; COMDAT

; 121  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 122  :     PyFutureFeatures *ff;
; 123  : 
; 124  :     ff = (PyFutureFeatures *)PyObject_Malloc(sizeof(PyFutureFeatures));

  0000e	b9 08 00 00 00	 mov	 ecx, 8
  00013	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00018	48 89 44 24 20	 mov	 QWORD PTR ff$[rsp], rax

; 125  :     if (ff == NULL) {

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR ff$[rsp], 0
  00023	75 09		 jne	 SHORT $LN2@PyFuture_F

; 126  :         PyErr_NoMemory();

  00025	e8 00 00 00 00	 call	 PyErr_NoMemory

; 127  :         return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 42		 jmp	 SHORT $LN3@PyFuture_F
$LN2@PyFuture_F:

; 128  :     }
; 129  :     ff->ff_features = 0;

  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR ff$[rsp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 130  :     ff->ff_lineno = -1;

  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR ff$[rsp]
  0003e	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [rax+4], -1

; 131  : 
; 132  :     if (!future_parse(ff, mod, filename)) {

  00045	4c 8b 44 24 48	 mov	 r8, QWORD PTR filename$[rsp]
  0004a	48 8b 54 24 40	 mov	 rdx, QWORD PTR mod$[rsp]
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ff$[rsp]
  00054	e8 00 00 00 00	 call	 future_parse
  00059	85 c0		 test	 eax, eax
  0005b	75 0e		 jne	 SHORT $LN1@PyFuture_F

; 133  :         PyObject_Free(ff);

  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ff$[rsp]
  00062	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 134  :         return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	eb 05		 jmp	 SHORT $LN3@PyFuture_F
$LN1@PyFuture_F:

; 135  :     }
; 136  :     return ff;

  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR ff$[rsp]
$LN3@PyFuture_F:

; 137  : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
PyFuture_FromAST ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@ ; `string'
PUBLIC	??_C@_0L@GKAJCJCM@__future__?$AA@		; `string'
EXTRN	PyErr_SyntaxLocationEx:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_SyntaxError:QWORD
EXTRN	PyUnicode_CompareWithASCIIString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$future_parse DD imagerel future_parse
	DD	imagerel future_parse+473
	DD	imagerel $unwind$future_parse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$future_parse DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@
CONST	SEGMENT
??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@ DB 'from __futur'
	DB	'e__ imports must occur at the beginning of the file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GKAJCJCM@__future__?$AA@
CONST	SEGMENT
??_C@_0L@GKAJCJCM@__future__?$AA@ DB '__future__', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT future_parse
_TEXT	SEGMENT
i$ = 32
prev_line$ = 36
found_docstring$ = 40
done$ = 44
s$21724 = 48
modname$21728 = 56
e$21737 = 64
tv72 = 72
ff$ = 96
mod$ = 104
filename$ = 112
future_parse PROC					; COMDAT

; 60   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 61   :     int i, found_docstring = 0, done = 0, prev_line = 0;

  00013	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR found_docstring$[rsp], 0
  0001b	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR done$[rsp], 0
  00023	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR prev_line$[rsp], 0

; 62   : 
; 63   :     if (!(mod->kind == Module_kind || mod->kind == Interactive_kind))

  0002b	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  00030	83 38 01	 cmp	 DWORD PTR [rax], 1
  00033	74 14		 je	 SHORT $LN15@future_par
  00035	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  0003a	83 38 02	 cmp	 DWORD PTR [rax], 2
  0003d	74 0a		 je	 SHORT $LN15@future_par

; 64   :         return 1;

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	e9 8b 01 00 00	 jmp	 $LN16@future_par
$LN15@future_par:

; 65   : 
; 66   :     /* A subsequent pass will detect future imports that don't
; 67   :        appear at the beginning of the file.  There's one case,
; 68   :        however, that is easier to handle here: A series of imports
; 69   :        joined by semi-colons, where the first import is a future
; 70   :        statement but some subsequent import has the future form
; 71   :        but is preceded by a regular import.
; 72   :     */
; 73   : 
; 74   : 
; 75   :     for (i = 0; i < asdl_seq_LEN(mod->v.Module.body); i++) {

  00049	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00051	eb 0a		 jmp	 SHORT $LN14@future_par
$LN13@future_par:
  00053	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00057	ff c0		 inc	 eax
  00059	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN14@future_par:
  0005d	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  00062	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00067	75 0b		 jne	 SHORT $LN18@future_par
  00069	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv72[rsp], 0
  00072	eb 11		 jmp	 SHORT $LN19@future_par
$LN18@future_par:
  00074	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  00079	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00080	48 89 44 24 48	 mov	 QWORD PTR tv72[rsp], rax
$LN19@future_par:
  00085	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0008a	48 3b 44 24 48	 cmp	 rax, QWORD PTR tv72[rsp]
  0008f	0f 8d 3a 01 00
	00		 jge	 $LN12@future_par

; 76   :         stmt_ty s = (stmt_ty)asdl_seq_GET(mod->v.Module.body, i);

  00095	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  0009a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0009e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a3	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  000a8	48 89 44 24 30	 mov	 QWORD PTR s$21724[rsp], rax

; 77   : 
; 78   :         if (done && s->lineno > prev_line)

  000ad	83 7c 24 2c 00	 cmp	 DWORD PTR done$[rsp], 0
  000b2	74 18		 je	 SHORT $LN11@future_par
  000b4	48 8b 44 24 30	 mov	 rax, QWORD PTR s$21724[rsp]
  000b9	8b 4c 24 24	 mov	 ecx, DWORD PTR prev_line$[rsp]
  000bd	39 48 40	 cmp	 DWORD PTR [rax+64], ecx
  000c0	7e 0a		 jle	 SHORT $LN11@future_par

; 79   :             return 1;

  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	e9 08 01 00 00	 jmp	 $LN16@future_par
$LN11@future_par:

; 80   :         prev_line = s->lineno;

  000cc	48 8b 44 24 30	 mov	 rax, QWORD PTR s$21724[rsp]
  000d1	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000d4	89 44 24 24	 mov	 DWORD PTR prev_line$[rsp], eax

; 81   : 
; 82   :         /* The tests below will return from this function unless it is
; 83   :            still possible to find a future statement.  The only things
; 84   :            that can precede a future statement are another future
; 85   :            statement and a doc string.
; 86   :         */
; 87   : 
; 88   :         if (s->kind == ImportFrom_kind) {

  000d8	48 8b 44 24 30	 mov	 rax, QWORD PTR s$21724[rsp]
  000dd	83 38 0f	 cmp	 DWORD PTR [rax], 15
  000e0	0f 85 9f 00 00
	00		 jne	 $LN10@future_par

; 89   :             identifier modname = s->v.ImportFrom.module;

  000e6	48 8b 44 24 30	 mov	 rax, QWORD PTR s$21724[rsp]
  000eb	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ef	48 89 44 24 38	 mov	 QWORD PTR modname$21728[rsp], rax

; 90   :             if (modname &&
; 91   :                 !PyUnicode_CompareWithASCIIString(modname, "__future__")) {

  000f4	48 83 7c 24 38
	00		 cmp	 QWORD PTR modname$21728[rsp], 0
  000fa	74 7f		 je	 SHORT $LN9@future_par
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@GKAJCJCM@__future__?$AA@
  00103	48 8b 4c 24 38	 mov	 rcx, QWORD PTR modname$21728[rsp]
  00108	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  0010d	85 c0		 test	 eax, eax
  0010f	75 6a		 jne	 SHORT $LN9@future_par

; 92   :                 if (done) {

  00111	83 7c 24 2c 00	 cmp	 DWORD PTR done$[rsp], 0
  00116	74 35		 je	 SHORT $LN8@future_par

; 93   :                     PyErr_SetString(PyExc_SyntaxError,
; 94   :                                     ERR_LATE_FUTURE);

  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@
  0011f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  00126	e8 00 00 00 00	 call	 PyErr_SetString

; 95   :                     PyErr_SyntaxLocationEx(filename, s->lineno, s->col_offset);

  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR s$21724[rsp]
  00130	44 8b 40 44	 mov	 r8d, DWORD PTR [rax+68]
  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR s$21724[rsp]
  00139	8b 50 40	 mov	 edx, DWORD PTR [rax+64]
  0013c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR filename$[rsp]
  00141	e8 00 00 00 00	 call	 PyErr_SyntaxLocationEx

; 96   :                     return 0;

  00146	33 c0		 xor	 eax, eax
  00148	e9 87 00 00 00	 jmp	 $LN16@future_par
$LN8@future_par:

; 97   :                 }
; 98   :                 if (!future_check_features(ff, s, filename))

  0014d	4c 8b 44 24 70	 mov	 r8, QWORD PTR filename$[rsp]
  00152	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$21724[rsp]
  00157	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ff$[rsp]
  0015c	e8 00 00 00 00	 call	 future_check_features
  00161	85 c0		 test	 eax, eax
  00163	75 04		 jne	 SHORT $LN7@future_par

; 99   :                     return 0;

  00165	33 c0		 xor	 eax, eax
  00167	eb 6b		 jmp	 SHORT $LN16@future_par
$LN7@future_par:

; 100  :                 ff->ff_lineno = s->lineno;

  00169	48 8b 44 24 60	 mov	 rax, QWORD PTR ff$[rsp]
  0016e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$21724[rsp]
  00173	8b 49 40	 mov	 ecx, DWORD PTR [rcx+64]
  00176	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 101  :             }
; 102  :             else

  00179	eb 08		 jmp	 SHORT $LN6@future_par
$LN9@future_par:

; 103  :                 done = 1;

  0017b	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR done$[rsp], 1
$LN6@future_par:

; 104  :         }
; 105  :         else if (s->kind == Expr_kind && !found_docstring) {

  00183	eb 45		 jmp	 SHORT $LN5@future_par
$LN10@future_par:
  00185	48 8b 44 24 30	 mov	 rax, QWORD PTR s$21724[rsp]
  0018a	83 38 12	 cmp	 DWORD PTR [rax], 18
  0018d	75 33		 jne	 SHORT $LN4@future_par
  0018f	83 7c 24 28 00	 cmp	 DWORD PTR found_docstring$[rsp], 0
  00194	75 2c		 jne	 SHORT $LN4@future_par

; 106  :             expr_ty e = s->v.Expr.value;

  00196	48 8b 44 24 30	 mov	 rax, QWORD PTR s$21724[rsp]
  0019b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0019f	48 89 44 24 40	 mov	 QWORD PTR e$21737[rsp], rax

; 107  :             if (e->kind != Str_kind)

  001a4	48 8b 44 24 40	 mov	 rax, QWORD PTR e$21737[rsp]
  001a9	83 38 11	 cmp	 DWORD PTR [rax], 17
  001ac	74 0a		 je	 SHORT $LN3@future_par

; 108  :                 done = 1;

  001ae	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR done$[rsp], 1

; 109  :             else

  001b6	eb 08		 jmp	 SHORT $LN2@future_par
$LN3@future_par:

; 110  :                 found_docstring = 1;

  001b8	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR found_docstring$[rsp], 1
$LN2@future_par:

; 111  :         }
; 112  :         else

  001c0	eb 08		 jmp	 SHORT $LN1@future_par
$LN4@future_par:

; 113  :             done = 1;

  001c2	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR done$[rsp], 1
$LN1@future_par:
$LN5@future_par:

; 114  :     }

  001ca	e9 84 fe ff ff	 jmp	 $LN13@future_par
$LN12@future_par:

; 115  :     return 1;

  001cf	b8 01 00 00 00	 mov	 eax, 1
$LN16@future_par:

; 116  : }

  001d4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d8	c3		 ret	 0
future_parse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@KIGBMAPF@future?5feature?5?$CF?4100s?5is?5not?5def@ ; `string'
PUBLIC	??_C@_0N@JONJKGOD@not?5a?5chance?$AA@		; `string'
PUBLIC	??_C@_06PPJPPEGJ@braces?$AA@			; `string'
PUBLIC	??_C@_0P@CALPMJDK@barry_as_FLUFL?$AA@		; `string'
PUBLIC	??_C@_0BB@GAMIIIAF@unicode_literals?$AA@	; `string'
PUBLIC	??_C@_0P@HDJNLGM@print_function?$AA@		; `string'
PUBLIC	??_C@_0P@KAIBPEGC@with_statement?$AA@		; `string'
PUBLIC	??_C@_0BA@DKNAAIIE@absolute_import?$AA@		; `string'
PUBLIC	??_C@_08DHDHNDEI@division?$AA@			; `string'
PUBLIC	??_C@_0L@FCNMNMNJ@generators?$AA@		; `string'
PUBLIC	??_C@_0O@LEAFGNOD@nested_scopes?$AA@		; `string'
PUBLIC	??_C@_1DG@MIDKOMOL@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAm?$AAp?$AAo?$AAr?$AAt?$AAF?$AAr?$AAo?$AAm?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@PBNBAMCI@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAf?$AAu?$AAt?$AAu?$AAr?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	strcmp:PROC
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$future_check_features DD imagerel future_check_features
	DD	imagerel future_check_features+596
	DD	imagerel $unwind$future_check_features
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$future_check_features DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0CF@KIGBMAPF@future?5feature?5?$CF?4100s?5is?5not?5def@
CONST	SEGMENT
??_C@_0CF@KIGBMAPF@future?5feature?5?$CF?4100s?5is?5not?5def@ DB 'future '
	DB	'feature %.100s is not defined', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JONJKGOD@not?5a?5chance?$AA@
CONST	SEGMENT
??_C@_0N@JONJKGOD@not?5a?5chance?$AA@ DB 'not a chance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PPJPPEGJ@braces?$AA@
CONST	SEGMENT
??_C@_06PPJPPEGJ@braces?$AA@ DB 'braces', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CALPMJDK@barry_as_FLUFL?$AA@
CONST	SEGMENT
??_C@_0P@CALPMJDK@barry_as_FLUFL?$AA@ DB 'barry_as_FLUFL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GAMIIIAF@unicode_literals?$AA@
CONST	SEGMENT
??_C@_0BB@GAMIIIAF@unicode_literals?$AA@ DB 'unicode_literals', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HDJNLGM@print_function?$AA@
CONST	SEGMENT
??_C@_0P@HDJNLGM@print_function?$AA@ DB 'print_function', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KAIBPEGC@with_statement?$AA@
CONST	SEGMENT
??_C@_0P@KAIBPEGC@with_statement?$AA@ DB 'with_statement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKNAAIIE@absolute_import?$AA@
CONST	SEGMENT
??_C@_0BA@DKNAAIIE@absolute_import?$AA@ DB 'absolute_import', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DHDHNDEI@division?$AA@
CONST	SEGMENT
??_C@_08DHDHNDEI@division?$AA@ DB 'division', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FCNMNMNJ@generators?$AA@
CONST	SEGMENT
??_C@_0L@FCNMNMNJ@generators?$AA@ DB 'generators', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LEAFGNOD@nested_scopes?$AA@
CONST	SEGMENT
??_C@_0O@LEAFGNOD@nested_scopes?$AA@ DB 'nested_scopes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@MIDKOMOL@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAm?$AAp?$AAo?$AAr?$AAt?$AAF?$AAr?$AAo?$AAm?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@MIDKOMOL@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAm?$AAp?$AAo?$AAr?$AAt?$AAF?$AAr?$AAo?$AAm?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 's'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'p'
	DB	00H, 'o', 00H, 'r', 00H, 't', 00H, 'F', 00H, 'r', 00H, 'o', 00H
	DB	'm', 00H, '_', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@PBNBAMCI@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAf?$AAu?$AAt?$AAu?$AAr?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@PBNBAMCI@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAf?$AAu?$AAt?$AAu?$AAr?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'y', 00H, 't', 00H, 'h', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'f', 00H, 'u', 00H, 't', 00H, 'u'
	DB	00H, 'r', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT future_check_features
_TEXT	SEGMENT
i$ = 32
names$ = 40
feature$21676 = 48
name$21674 = 56
tv73 = 64
ff$ = 96
s$ = 104
filename$ = 112
future_check_features PROC				; COMDAT

; 15   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 16   :     int i;
; 17   :     asdl_seq *names;
; 18   : 
; 19   :     assert(s->kind == ImportFrom_kind);

  00013	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00018	83 38 0f	 cmp	 DWORD PTR [rax], 15
  0001b	74 1c		 je	 SHORT $LN25@future_che
  0001d	41 b8 13 00 00
	00		 mov	 r8d, 19
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CG@PBNBAMCI@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAf?$AAu?$AAt?$AAu?$AAr?$AAe?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MIDKOMOL@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAm?$AAp?$AAo?$AAr?$AAt?$AAF?$AAr?$AAo?$AAm?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN25@future_che:

; 20   : 
; 21   :     names = s->v.ImportFrom.names;

  00039	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0003e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00042	48 89 44 24 28	 mov	 QWORD PTR names$[rsp], rax

; 22   :     for (i = 0; i < asdl_seq_LEN(names); i++) {

  00047	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0004f	eb 0a		 jmp	 SHORT $LN22@future_che
$LN21@future_che:
  00051	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00055	ff c0		 inc	 eax
  00057	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN22@future_che:
  0005b	48 83 7c 24 28
	00		 cmp	 QWORD PTR names$[rsp], 0
  00061	75 0b		 jne	 SHORT $LN26@future_che
  00063	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
  0006c	eb 0d		 jmp	 SHORT $LN27@future_che
$LN26@future_che:
  0006e	48 8b 44 24 28	 mov	 rax, QWORD PTR names$[rsp]
  00073	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00076	48 89 44 24 40	 mov	 QWORD PTR tv73[rsp], rax
$LN27@future_che:
  0007b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00080	48 3b 44 24 40	 cmp	 rax, QWORD PTR tv73[rsp]
  00085	0f 8d bf 01 00
	00		 jge	 $LN20@future_che

; 23   :         alias_ty name = (alias_ty)asdl_seq_GET(names, i);

  0008b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00090	48 8b 4c 24 28	 mov	 rcx, QWORD PTR names$[rsp]
  00095	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  0009a	48 89 44 24 38	 mov	 QWORD PTR name$21674[rsp], rax

; 24   :         const char *feature = _PyUnicode_AsString(name->name);

  0009f	48 8b 44 24 38	 mov	 rax, QWORD PTR name$21674[rsp]
  000a4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a7	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  000ac	48 89 44 24 30	 mov	 QWORD PTR feature$21676[rsp], rax

; 25   :         if (!feature)

  000b1	48 83 7c 24 30
	00		 cmp	 QWORD PTR feature$21676[rsp], 0
  000b7	75 07		 jne	 SHORT $LN19@future_che

; 26   :             return 0;

  000b9	33 c0		 xor	 eax, eax
  000bb	e9 8f 01 00 00	 jmp	 $LN23@future_che
$LN19@future_che:

; 27   :         if (strcmp(feature, FUTURE_NESTED_SCOPES) == 0) {

  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@LEAFGNOD@nested_scopes?$AA@
  000c7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR feature$21676[rsp]
  000cc	e8 00 00 00 00	 call	 strcmp
  000d1	85 c0		 test	 eax, eax
  000d3	75 0a		 jne	 SHORT $LN18@future_che

; 28   :             continue;

  000d5	e9 77 ff ff ff	 jmp	 $LN21@future_che
  000da	e9 66 01 00 00	 jmp	 $LN17@future_che
$LN18@future_che:

; 29   :         } else if (strcmp(feature, FUTURE_GENERATORS) == 0) {

  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@FCNMNMNJ@generators?$AA@
  000e6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR feature$21676[rsp]
  000eb	e8 00 00 00 00	 call	 strcmp
  000f0	85 c0		 test	 eax, eax
  000f2	75 0a		 jne	 SHORT $LN16@future_che

; 30   :             continue;

  000f4	e9 58 ff ff ff	 jmp	 $LN21@future_che
  000f9	e9 47 01 00 00	 jmp	 $LN15@future_che
$LN16@future_che:

; 31   :         } else if (strcmp(feature, FUTURE_DIVISION) == 0) {

  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08DHDHNDEI@division?$AA@
  00105	48 8b 4c 24 30	 mov	 rcx, QWORD PTR feature$21676[rsp]
  0010a	e8 00 00 00 00	 call	 strcmp
  0010f	85 c0		 test	 eax, eax
  00111	75 0a		 jne	 SHORT $LN14@future_che

; 32   :             continue;

  00113	e9 39 ff ff ff	 jmp	 $LN21@future_che
  00118	e9 28 01 00 00	 jmp	 $LN13@future_che
$LN14@future_che:

; 33   :         } else if (strcmp(feature, FUTURE_ABSOLUTE_IMPORT) == 0) {

  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@DKNAAIIE@absolute_import?$AA@
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR feature$21676[rsp]
  00129	e8 00 00 00 00	 call	 strcmp
  0012e	85 c0		 test	 eax, eax
  00130	75 0a		 jne	 SHORT $LN12@future_che

; 34   :             continue;

  00132	e9 1a ff ff ff	 jmp	 $LN21@future_che
  00137	e9 09 01 00 00	 jmp	 $LN11@future_che
$LN12@future_che:

; 35   :         } else if (strcmp(feature, FUTURE_WITH_STATEMENT) == 0) {

  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@KAIBPEGC@with_statement?$AA@
  00143	48 8b 4c 24 30	 mov	 rcx, QWORD PTR feature$21676[rsp]
  00148	e8 00 00 00 00	 call	 strcmp
  0014d	85 c0		 test	 eax, eax
  0014f	75 0a		 jne	 SHORT $LN10@future_che

; 36   :             continue;

  00151	e9 fb fe ff ff	 jmp	 $LN21@future_che
  00156	e9 ea 00 00 00	 jmp	 $LN9@future_che
$LN10@future_che:

; 37   :         } else if (strcmp(feature, FUTURE_PRINT_FUNCTION) == 0) {

  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@HDJNLGM@print_function?$AA@
  00162	48 8b 4c 24 30	 mov	 rcx, QWORD PTR feature$21676[rsp]
  00167	e8 00 00 00 00	 call	 strcmp
  0016c	85 c0		 test	 eax, eax
  0016e	75 0a		 jne	 SHORT $LN8@future_che

; 38   :             continue;

  00170	e9 dc fe ff ff	 jmp	 $LN21@future_che
  00175	e9 cb 00 00 00	 jmp	 $LN7@future_che
$LN8@future_che:

; 39   :         } else if (strcmp(feature, FUTURE_UNICODE_LITERALS) == 0) {

  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@GAMIIIAF@unicode_literals?$AA@
  00181	48 8b 4c 24 30	 mov	 rcx, QWORD PTR feature$21676[rsp]
  00186	e8 00 00 00 00	 call	 strcmp
  0018b	85 c0		 test	 eax, eax
  0018d	75 0a		 jne	 SHORT $LN6@future_che

; 40   :             continue;

  0018f	e9 bd fe ff ff	 jmp	 $LN21@future_che
  00194	e9 ac 00 00 00	 jmp	 $LN5@future_che
$LN6@future_che:

; 41   :         } else if (strcmp(feature, FUTURE_BARRY_AS_BDFL) == 0) {

  00199	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@CALPMJDK@barry_as_FLUFL?$AA@
  001a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR feature$21676[rsp]
  001a5	e8 00 00 00 00	 call	 strcmp
  001aa	85 c0		 test	 eax, eax
  001ac	75 17		 jne	 SHORT $LN4@future_che

; 42   :             ff->ff_features |= CO_FUTURE_BARRY_AS_BDFL;

  001ae	48 8b 44 24 60	 mov	 rax, QWORD PTR ff$[rsp]
  001b3	8b 00		 mov	 eax, DWORD PTR [rax]
  001b5	0f ba e8 12	 bts	 eax, 18
  001b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ff$[rsp]
  001be	89 01		 mov	 DWORD PTR [rcx], eax
  001c0	e9 80 00 00 00	 jmp	 $LN3@future_che
$LN4@future_che:

; 43   :         } else if (strcmp(feature, "braces") == 0) {

  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06PPJPPEGJ@braces?$AA@
  001cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR feature$21676[rsp]
  001d1	e8 00 00 00 00	 call	 strcmp
  001d6	85 c0		 test	 eax, eax
  001d8	75 34		 jne	 SHORT $LN2@future_che

; 44   :             PyErr_SetString(PyExc_SyntaxError,
; 45   :                             "not a chance");

  001da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JONJKGOD@not?5a?5chance?$AA@
  001e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  001e8	e8 00 00 00 00	 call	 PyErr_SetString

; 46   :             PyErr_SyntaxLocationEx(filename, s->lineno, s->col_offset);

  001ed	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  001f2	44 8b 40 44	 mov	 r8d, DWORD PTR [rax+68]
  001f6	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  001fb	8b 50 40	 mov	 edx, DWORD PTR [rax+64]
  001fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR filename$[rsp]
  00203	e8 00 00 00 00	 call	 PyErr_SyntaxLocationEx

; 47   :             return 0;

  00208	33 c0		 xor	 eax, eax
  0020a	eb 43		 jmp	 SHORT $LN23@future_che

; 48   :         } else {

  0020c	eb 37		 jmp	 SHORT $LN1@future_che
$LN2@future_che:

; 49   :             PyErr_Format(PyExc_SyntaxError,
; 50   :                          UNDEFINED_FUTURE_FEATURE, feature);

  0020e	4c 8b 44 24 30	 mov	 r8, QWORD PTR feature$21676[rsp]
  00213	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@KIGBMAPF@future?5feature?5?$CF?4100s?5is?5not?5def@
  0021a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  00221	e8 00 00 00 00	 call	 PyErr_Format

; 51   :             PyErr_SyntaxLocationEx(filename, s->lineno, s->col_offset);

  00226	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0022b	44 8b 40 44	 mov	 r8d, DWORD PTR [rax+68]
  0022f	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00234	8b 50 40	 mov	 edx, DWORD PTR [rax+64]
  00237	48 8b 4c 24 70	 mov	 rcx, QWORD PTR filename$[rsp]
  0023c	e8 00 00 00 00	 call	 PyErr_SyntaxLocationEx

; 52   :             return 0;

  00241	33 c0		 xor	 eax, eax
  00243	eb 0a		 jmp	 SHORT $LN23@future_che
$LN1@future_che:
$LN3@future_che:
$LN5@future_che:
$LN7@future_che:
$LN9@future_che:
$LN11@future_che:
$LN13@future_che:
$LN15@future_che:
$LN17@future_che:

; 53   :         }
; 54   :     }

  00245	e9 07 fe ff ff	 jmp	 $LN21@future_che
$LN20@future_che:

; 55   :     return 1;

  0024a	b8 01 00 00 00	 mov	 eax, 1
$LN23@future_che:

; 56   : }

  0024f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00253	c3		 ret	 0
future_check_features ENDP
_TEXT	ENDS
END
