; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_01DDCIFGEA@E?$AA@				; `string'
PUBLIC	??_C@_03LKNCIKJB@NAN?$AA@			; `string'
PUBLIC	??_C@_03OEIAHPBN@INF?$AA@			; `string'
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	??_C@_03LHCJEHON@nan?$AA@			; `string'
PUBLIC	??_C@_03OJHLLCGB@inf?$AA@			; `string'
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT
??_C@_01DDCIFGEA@E?$AA@ DB 'E', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LKNCIKJB@NAN?$AA@
CONST	SEGMENT
??_C@_03LKNCIKJB@NAN?$AA@ DB 'NAN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OEIAHPBN@INF?$AA@
CONST	SEGMENT
??_C@_03OEIAHPBN@INF?$AA@ DB 'INF', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
lc_float_strings DQ FLAT:??_C@_03OJHLLCGB@inf?$AA@
	DQ	FLAT:??_C@_03LHCJEHON@nan?$AA@
	DQ	FLAT:??_C@_01KGKMHCOC@e?$AA@
uc_float_strings DQ FLAT:??_C@_03OEIAHPBN@INF?$AA@
	DQ	FLAT:??_C@_03LKNCIKJB@NAN?$AA@
	DQ	FLAT:??_C@_01DDCIFGEA@E?$AA@
_DATA	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LHCJEHON@nan?$AA@
CONST	SEGMENT
??_C@_03LHCJEHON@nan?$AA@ DB 'nan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OJHLLCGB@inf?$AA@
CONST	SEGMENT
??_C@_03OJHLLCGB@inf?$AA@ DB 'inf', 00H			; `string'
CONST	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_05KMOPHDFI@inity?$AA@			; `string'
PUBLIC	_Py_parse_inf_or_nan
EXTRN	_Py_dg_stdnan:PROC
EXTRN	_Py_dg_infinity:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\python\pystrtod.c
pdata	SEGMENT
$pdata$_Py_parse_inf_or_nan DD imagerel $LN11
	DD	imagerel $LN11+281
	DD	imagerel $unwind$_Py_parse_inf_or_nan
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_parse_inf_or_nan DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_05KMOPHDFI@inity?$AA@
CONST	SEGMENT
??_C@_05KMOPHDFI@inity?$AA@ DB 'inity', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_parse_inf_or_nan
_TEXT	SEGMENT
s$ = 32
retval$ = 40
negate$ = 48
p$ = 80
endptr$ = 88
_Py_parse_inf_or_nan PROC				; COMDAT

; 29   : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 30   :     double retval;
; 31   :     const char *s;
; 32   :     int negate = 0;

  0000e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR negate$[rsp], 0

; 33   : 
; 34   :     s = p;

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0001b	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 35   :     if (*s == '-') {

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00025	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00028	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0002b	75 17		 jne	 SHORT $LN8@Py_parse_i

; 36   :         negate = 1;

  0002d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR negate$[rsp], 1

; 37   :         s++;

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0003a	48 ff c0	 inc	 rax
  0003d	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
  00042	eb 1a		 jmp	 SHORT $LN7@Py_parse_i
$LN8@Py_parse_i:

; 38   :     }
; 39   :     else if (*s == '+') {

  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00049	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004c	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0004f	75 0d		 jne	 SHORT $LN6@Py_parse_i

; 40   :         s++;

  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00056	48 ff c0	 inc	 rax
  00059	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
$LN6@Py_parse_i:
$LN7@Py_parse_i:

; 41   :     }
; 42   :     if (case_insensitive_match(s, "inf")) {

  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03OJHLLCGB@inf?$AA@
  00065	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0006a	e8 00 00 00 00	 call	 case_insensitive_match
  0006f	85 c0		 test	 eax, eax
  00071	74 42		 je	 SHORT $LN5@Py_parse_i

; 43   :         s += 3;

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00078	48 83 c0 03	 add	 rax, 3
  0007c	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 44   :         if (case_insensitive_match(s, "inity"))

  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KMOPHDFI@inity?$AA@
  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0008d	e8 00 00 00 00	 call	 case_insensitive_match
  00092	85 c0		 test	 eax, eax
  00094	74 0e		 je	 SHORT $LN4@Py_parse_i

; 45   :             s += 5;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0009b	48 83 c0 05	 add	 rax, 5
  0009f	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
$LN4@Py_parse_i:

; 46   :         retval = _Py_dg_infinity(negate);

  000a4	8b 4c 24 30	 mov	 ecx, DWORD PTR negate$[rsp]
  000a8	e8 00 00 00 00	 call	 _Py_dg_infinity
  000ad	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR retval$[rsp], xmm0
  000b3	eb 4c		 jmp	 SHORT $LN3@Py_parse_i
$LN5@Py_parse_i:

; 47   :     }
; 48   :     else if (case_insensitive_match(s, "nan")) {

  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LHCJEHON@nan?$AA@
  000bc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000c1	e8 00 00 00 00	 call	 case_insensitive_match
  000c6	85 c0		 test	 eax, eax
  000c8	74 1f		 je	 SHORT $LN2@Py_parse_i

; 49   :         s += 3;

  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000cf	48 83 c0 03	 add	 rax, 3
  000d3	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 50   :         retval = _Py_dg_stdnan(negate);

  000d8	8b 4c 24 30	 mov	 ecx, DWORD PTR negate$[rsp]
  000dc	e8 00 00 00 00	 call	 _Py_dg_stdnan
  000e1	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR retval$[rsp], xmm0

; 51   :     }
; 52   :     else {

  000e7	eb 18		 jmp	 SHORT $LN1@Py_parse_i
$LN2@Py_parse_i:

; 53   :         s = p;

  000e9	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  000ee	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 54   :         retval = -1.0;

  000f3	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  000fb	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR retval$[rsp], xmm0
$LN1@Py_parse_i:
$LN3@Py_parse_i:

; 55   :     }
; 56   :     *endptr = (char *)s;

  00101	48 8b 44 24 58	 mov	 rax, QWORD PTR endptr$[rsp]
  00106	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0010b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 57   :     return retval;

  0010e	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR retval$[rsp]

; 58   : }

  00114	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00118	c3		 ret	 0
_Py_parse_inf_or_nan ENDP
_TEXT	ENDS
EXTRN	_Py_ctype_tolower:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$case_insensitive_match DD imagerel case_insensitive_match
	DD	imagerel case_insensitive_match+129
	DD	imagerel $unwind$case_insensitive_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$case_insensitive_match DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT case_insensitive_match
_TEXT	SEGMENT
tv78 = 0
s$ = 32
t$ = 40
case_insensitive_match PROC				; COMDAT

; 11   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24
$LN2@case_insen:

; 12   :     while(*t && Py_TOLOWER(*s) == *t) {

  0000e	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00013	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00016	85 c0		 test	 eax, eax
  00018	74 43		 je	 SHORT $LN1@case_insen
  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0001f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00022	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00027	0f b6 c0	 movzx	 eax, al
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_tolower
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  0003a	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  0003d	3b c1		 cmp	 eax, ecx
  0003f	75 1c		 jne	 SHORT $LN1@case_insen

; 13   :         s++;

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00046	48 ff c0	 inc	 rax
  00049	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 14   :         t++;

  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00053	48 ff c0	 inc	 rax
  00056	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax

; 15   :     }

  0005b	eb b1		 jmp	 SHORT $LN2@case_insen
$LN1@case_insen:

; 16   :     return *t ? 0 : 1;

  0005d	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00062	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00065	85 c0		 test	 eax, eax
  00067	74 09		 je	 SHORT $LN5@case_insen
  00069	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv78[rsp], 0
  00070	eb 07		 jmp	 SHORT $LN6@case_insen
$LN5@case_insen:
  00072	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv78[rsp], 1
$LN6@case_insen:
  00079	8b 04 24	 mov	 eax, DWORD PTR tv78[rsp]

; 17   : }

  0007c	48 83 c4 18	 add	 rsp, 24
  00080	c3		 ret	 0
case_insensitive_match ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@POKIHDFE@value?5too?5large?5to?5convert?5to?5fl@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0CK@IAECOGLD@could?5not?5convert?5string?5to?5floa@ ; `string'
PUBLIC	PyOS_string_to_double
EXTRN	fabs:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyErr_NoMemory:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_string_to_double DD imagerel $LN13
	DD	imagerel $LN13+301
	DD	imagerel $unwind$PyOS_string_to_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_string_to_double DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0CM@POKIHDFE@value?5too?5large?5to?5convert?5to?5fl@
CONST	SEGMENT
??_C@_0CM@POKIHDFE@value?5too?5large?5to?5convert?5to?5fl@ DB 'value too '
	DB	'large to convert to float: %.200s', 00H	; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0CK@IAECOGLD@could?5not?5convert?5string?5to?5floa@
CONST	SEGMENT
??_C@_0CK@IAECOGLD@could?5not?5convert?5string?5to?5floa@ DB 'could not c'
	DB	'onvert string to float: %.200s', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyOS_string_to_double
_TEXT	SEGMENT
x$ = 32
fail_pos$ = 40
result$ = 48
s$ = 80
endptr$ = 88
overflow_exception$ = 96
PyOS_string_to_double PROC				; COMDAT

; 340  : {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 341  :     double x, result=-1.0;

  00013	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  0001b	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR result$[rsp], xmm0

; 342  :     char *fail_pos;
; 343  : 
; 344  :     errno = 0;

  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00027	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 345  :     PyFPE_START_PROTECT("PyOS_string_to_double", return -1.0)
; 346  :     x = _PyOS_ascii_strtod(s, &fail_pos);

  0002d	48 8d 54 24 28	 lea	 rdx, QWORD PTR fail_pos$[rsp]
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00037	e8 00 00 00 00	 call	 _PyOS_ascii_strtod
  0003c	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 347  :     PyFPE_END_PROTECT(x)
; 348  : 
; 349  :     if (errno == ENOMEM) {

  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00048	83 38 0c	 cmp	 DWORD PTR [rax], 12
  0004b	75 14		 jne	 SHORT $LN10@PyOS_strin

; 350  :         PyErr_NoMemory();

  0004d	e8 00 00 00 00	 call	 PyErr_NoMemory

; 351  :         fail_pos = (char *)s;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00057	48 89 44 24 28	 mov	 QWORD PTR fail_pos$[rsp], rax
  0005c	e9 ac 00 00 00	 jmp	 $LN9@PyOS_strin
$LN10@PyOS_strin:

; 352  :     }
; 353  :     else if (!endptr && (fail_pos == s || *fail_pos != '\0'))

  00061	48 83 7c 24 58
	00		 cmp	 QWORD PTR endptr$[rsp], 0
  00067	75 32		 jne	 SHORT $LN8@PyOS_strin
  00069	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0006e	48 39 44 24 28	 cmp	 QWORD PTR fail_pos$[rsp], rax
  00073	74 0c		 je	 SHORT $LN7@PyOS_strin
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR fail_pos$[rsp]
  0007a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0007d	85 c0		 test	 eax, eax
  0007f	74 1a		 je	 SHORT $LN8@PyOS_strin
$LN7@PyOS_strin:

; 354  :         PyErr_Format(PyExc_ValueError,
; 355  :                       "could not convert string to float: "
; 356  :                       "%.200s", s);

  00081	4c 8b 44 24 50	 mov	 r8, QWORD PTR s$[rsp]
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@IAECOGLD@could?5not?5convert?5string?5to?5floa@
  0008d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00094	e8 00 00 00 00	 call	 PyErr_Format
  00099	eb 72		 jmp	 SHORT $LN6@PyOS_strin
$LN8@PyOS_strin:

; 357  :     else if (fail_pos == s)

  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000a0	48 39 44 24 28	 cmp	 QWORD PTR fail_pos$[rsp], rax
  000a5	75 1a		 jne	 SHORT $LN5@PyOS_strin

; 358  :         PyErr_Format(PyExc_ValueError,
; 359  :                       "could not convert string to float: "
; 360  :                       "%.200s", s);

  000a7	4c 8b 44 24 50	 mov	 r8, QWORD PTR s$[rsp]
  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@IAECOGLD@could?5not?5convert?5string?5to?5floa@
  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ba	e8 00 00 00 00	 call	 PyErr_Format
  000bf	eb 4c		 jmp	 SHORT $LN4@PyOS_strin
$LN5@PyOS_strin:

; 361  :     else if (errno == ERANGE && fabs(x) >= 1.0 && overflow_exception)

  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c7	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  000ca	75 35		 jne	 SHORT $LN3@PyOS_strin
  000cc	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000d2	e8 00 00 00 00	 call	 fabs
  000d7	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  000df	72 20		 jb	 SHORT $LN3@PyOS_strin
  000e1	48 83 7c 24 60
	00		 cmp	 QWORD PTR overflow_exception$[rsp], 0
  000e7	74 18		 je	 SHORT $LN3@PyOS_strin

; 362  :         PyErr_Format(overflow_exception,
; 363  :                       "value too large to convert to float: "
; 364  :                       "%.200s", s);

  000e9	4c 8b 44 24 50	 mov	 r8, QWORD PTR s$[rsp]
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@POKIHDFE@value?5too?5large?5to?5convert?5to?5fl@
  000f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR overflow_exception$[rsp]
  000fa	e8 00 00 00 00	 call	 PyErr_Format

; 365  :     else

  000ff	eb 0c		 jmp	 SHORT $LN2@PyOS_strin
$LN3@PyOS_strin:

; 366  :         result = x;

  00101	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00107	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR result$[rsp], xmm0
$LN2@PyOS_strin:
$LN4@PyOS_strin:
$LN6@PyOS_strin:
$LN9@PyOS_strin:

; 367  : 
; 368  :     if (endptr != NULL)

  0010d	48 83 7c 24 58
	00		 cmp	 QWORD PTR endptr$[rsp], 0
  00113	74 0d		 je	 SHORT $LN1@PyOS_strin

; 369  :         *endptr = fail_pos;

  00115	48 8b 44 24 58	 mov	 rax, QWORD PTR endptr$[rsp]
  0011a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fail_pos$[rsp]
  0011f	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@PyOS_strin:

; 370  :     return result;

  00122	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR result$[rsp]

; 371  : }

  00128	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012c	c3		 ret	 0
PyOS_string_to_double ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BK@LAOAACLJ@?$AAn?$AAp?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@IBEGAGAB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAp?$AAy?$AAs?$AAt?$AAr?$AAt?$AAo?$AAd?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	_Py_dg_strtod:PROC
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyOS_ascii_strtod DD imagerel _PyOS_ascii_strtod
	DD	imagerel _PyOS_ascii_strtod+130
	DD	imagerel $unwind$_PyOS_ascii_strtod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyOS_ascii_strtod DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1BK@LAOAACLJ@?$AAn?$AAp?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@LAOAACLJ@?$AAn?$AAp?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'n'
	DB	00H, 'p', 00H, 't', 00H, 'r', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@IBEGAGAB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAp?$AAy?$AAs?$AAt?$AAr?$AAt?$AAo?$AAd?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@IBEGAGAB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAp?$AAy?$AAs?$AAt?$AAr?$AAt?$AAo?$AAd?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'y', 00H, 't', 00H, 'h', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'p', 00H, 'y', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 't', 00H, 'o', 00H, 'd', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyOS_ascii_strtod
_TEXT	SEGMENT
result$ = 32
nptr$ = 64
endptr$ = 72
_PyOS_ascii_strtod PROC					; COMDAT

; 132  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 133  :     double result;
; 134  :     _Py_SET_53BIT_PRECISION_HEADER;
; 135  : 
; 136  :     assert(nptr != NULL);

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR nptr$[rsp], 0
  00014	75 1c		 jne	 SHORT $LN4@PyOS_ascii
  00016	41 b8 88 00 00
	00		 mov	 r8d, 136		; 00000088H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@IBEGAGAB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAp?$AAy?$AAs?$AAt?$AAr?$AAt?$AAo?$AAd?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@LAOAACLJ@?$AAn?$AAp?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN4@PyOS_ascii:

; 137  :     /* Set errno to zero, so that we can distinguish zero results
; 138  :        and underflows */
; 139  :     errno = 0;

  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00038	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 140  : 
; 141  :     _Py_SET_53BIT_PRECISION_START;
; 142  :     result = _Py_dg_strtod(nptr, endptr);

  0003e	48 8b 54 24 48	 mov	 rdx, QWORD PTR endptr$[rsp]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR nptr$[rsp]
  00048	e8 00 00 00 00	 call	 _Py_dg_strtod
  0004d	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR result$[rsp], xmm0

; 143  :     _Py_SET_53BIT_PRECISION_END;
; 144  : 
; 145  :     if (*endptr == nptr)

  00053	48 8b 44 24 48	 mov	 rax, QWORD PTR endptr$[rsp]
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR nptr$[rsp]
  0005d	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00060	75 15		 jne	 SHORT $LN1@PyOS_ascii

; 146  :         /* string might represent an inf or nan */
; 147  :         result = _Py_parse_inf_or_nan(nptr, endptr);

  00062	48 8b 54 24 48	 mov	 rdx, QWORD PTR endptr$[rsp]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR nptr$[rsp]
  0006c	e8 00 00 00 00	 call	 _Py_parse_inf_or_nan
  00071	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR result$[rsp], xmm0
$LN1@PyOS_ascii:

; 148  : 
; 149  :     return result;

  00077	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR result$[rsp]

; 150  : 
; 151  : }

  0007d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00081	c3		 ret	 0
_PyOS_ascii_strtod ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@ ; `string'
PUBLIC	PyOS_double_to_string
EXTRN	_PyErr_BadInternalCall:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_double_to_string DD imagerel $LN17
	DD	imagerel $LN17+482
	DD	imagerel $unwind$PyOS_double_to_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_double_to_string DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT ??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@
CONST	SEGMENT
??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@ DB '..\Python\pystrtod.'
	DB	'c', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyOS_double_to_string
_TEXT	SEGMENT
mode$ = 80
float_strings$ = 88
tv65 = 96
val$ = 128
format_code$ = 136
precision$ = 144
flags$ = 152
type$ = 160
PyOS_double_to_string PROC				; COMDAT

; 1178 : {

$LN17:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1179 :     char **float_strings = lc_float_strings;

  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lc_float_strings
  0001f	48 89 44 24 58	 mov	 QWORD PTR float_strings$[rsp], rax

; 1180 :     int mode;
; 1181 : 
; 1182 :     /* Validate format_code, and map upper and lower case. Compute the
; 1183 :        mode and make any adjustments as needed. */
; 1184 :     switch (format_code) {

  00024	0f be 84 24 88
	00 00 00	 movsx	 eax, BYTE PTR format_code$[rsp]
  0002c	89 44 24 60	 mov	 DWORD PTR tv65[rsp], eax
  00030	8b 44 24 60	 mov	 eax, DWORD PTR tv65[rsp]
  00034	83 e8 45	 sub	 eax, 69			; 00000045H
  00037	89 44 24 60	 mov	 DWORD PTR tv65[rsp], eax
  0003b	83 7c 24 60 2d	 cmp	 DWORD PTR tv65[rsp], 45	; 0000002dH
  00040	0f 87 cb 00 00
	00		 ja	 $LN1@PyOS_doubl
  00046	48 63 44 24 60	 movsxd	 rax, DWORD PTR tv65[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00052	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN15@PyOS_doubl[rcx+rax]
  0005a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN16@PyOS_doubl[rcx+rax*4]
  00061	48 03 c1	 add	 rax, rcx
  00064	ff e0		 jmp	 rax
$LN10@PyOS_doubl:

; 1185 :     /* exponent */
; 1186 :     case 'E':
; 1187 :         float_strings = uc_float_strings;

  00066	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:uc_float_strings
  0006d	48 89 44 24 58	 mov	 QWORD PTR float_strings$[rsp], rax

; 1188 :         format_code = 'e';

  00072	c6 84 24 88 00
	00 00 65	 mov	 BYTE PTR format_code$[rsp], 101 ; 00000065H
$LN9@PyOS_doubl:

; 1189 :         /* Fall through. */
; 1190 :     case 'e':
; 1191 :         mode = 2;

  0007a	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR mode$[rsp], 2

; 1192 :         precision++;

  00082	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR precision$[rsp]
  00089	ff c0		 inc	 eax
  0008b	89 84 24 90 00
	00 00		 mov	 DWORD PTR precision$[rsp], eax

; 1193 :         break;

  00092	e9 8f 00 00 00	 jmp	 $LN11@PyOS_doubl
$LN8@PyOS_doubl:

; 1194 : 
; 1195 :     /* fixed */
; 1196 :     case 'F':
; 1197 :         float_strings = uc_float_strings;

  00097	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:uc_float_strings
  0009e	48 89 44 24 58	 mov	 QWORD PTR float_strings$[rsp], rax

; 1198 :         format_code = 'f';

  000a3	c6 84 24 88 00
	00 00 66	 mov	 BYTE PTR format_code$[rsp], 102 ; 00000066H
$LN7@PyOS_doubl:

; 1199 :         /* Fall through. */
; 1200 :     case 'f':
; 1201 :         mode = 3;

  000ab	c7 44 24 50 03
	00 00 00	 mov	 DWORD PTR mode$[rsp], 3

; 1202 :         break;

  000b3	eb 71		 jmp	 SHORT $LN11@PyOS_doubl
$LN6@PyOS_doubl:

; 1203 : 
; 1204 :     /* general */
; 1205 :     case 'G':
; 1206 :         float_strings = uc_float_strings;

  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:uc_float_strings
  000bc	48 89 44 24 58	 mov	 QWORD PTR float_strings$[rsp], rax

; 1207 :         format_code = 'g';

  000c1	c6 84 24 88 00
	00 00 67	 mov	 BYTE PTR format_code$[rsp], 103 ; 00000067H
$LN5@PyOS_doubl:

; 1208 :         /* Fall through. */
; 1209 :     case 'g':
; 1210 :         mode = 2;

  000c9	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR mode$[rsp], 2

; 1211 :         /* precision 0 makes no sense for 'g' format; interpret as 1 */
; 1212 :         if (precision == 0)

  000d1	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR precision$[rsp], 0
  000d9	75 0b		 jne	 SHORT $LN4@PyOS_doubl

; 1213 :             precision = 1;

  000db	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR precision$[rsp], 1
$LN4@PyOS_doubl:

; 1214 :         break;

  000e6	eb 3e		 jmp	 SHORT $LN11@PyOS_doubl
$LN3@PyOS_doubl:

; 1215 : 
; 1216 :     /* repr format */
; 1217 :     case 'r':
; 1218 :         mode = 0;

  000e8	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR mode$[rsp], 0

; 1219 :         /* Supplied precision is unused, must be 0. */
; 1220 :         if (precision != 0) {

  000f0	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR precision$[rsp], 0
  000f8	74 15		 je	 SHORT $LN2@PyOS_doubl

; 1221 :             PyErr_BadInternalCall();

  000fa	ba c5 04 00 00	 mov	 edx, 1221		; 000004c5H
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@
  00106	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1222 :             return NULL;

  0010b	33 c0		 xor	 eax, eax
  0010d	eb 7e		 jmp	 SHORT $LN13@PyOS_doubl
$LN2@PyOS_doubl:

; 1223 :         }
; 1224 :         break;

  0010f	eb 15		 jmp	 SHORT $LN11@PyOS_doubl
$LN1@PyOS_doubl:

; 1225 : 
; 1226 :     default:
; 1227 :         PyErr_BadInternalCall();

  00111	ba cb 04 00 00	 mov	 edx, 1227		; 000004cbH
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@
  0011d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1228 :         return NULL;

  00122	33 c0		 xor	 eax, eax
  00124	eb 67		 jmp	 SHORT $LN13@PyOS_doubl
$LN11@PyOS_doubl:

; 1229 :     }
; 1230 : 
; 1231 :     return format_float_short(val, format_code, mode, precision,
; 1232 :                               flags & Py_DTSF_SIGN,
; 1233 :                               flags & Py_DTSF_ADD_DOT_0,
; 1234 :                               flags & Py_DTSF_ALT,
; 1235 :                               float_strings, type);

  00126	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0012d	83 e0 04	 and	 eax, 4
  00130	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR flags$[rsp]
  00137	83 e1 02	 and	 ecx, 2
  0013a	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flags$[rsp]
  00141	83 e2 01	 and	 edx, 1
  00144	4c 63 84 24 90
	00 00 00	 movsxd	 r8, DWORD PTR precision$[rsp]
  0014c	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR type$[rsp]
  00154	4c 89 4c 24 40	 mov	 QWORD PTR [rsp+64], r9
  00159	4c 8b 4c 24 58	 mov	 r9, QWORD PTR float_strings$[rsp]
  0015e	4c 89 4c 24 38	 mov	 QWORD PTR [rsp+56], r9
  00163	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00167	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0016b	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  0016f	4d 8b c8	 mov	 r9, r8
  00172	44 8b 44 24 50	 mov	 r8d, DWORD PTR mode$[rsp]
  00177	0f b6 94 24 88
	00 00 00	 movzx	 edx, BYTE PTR format_code$[rsp]
  0017f	f2 0f 10 84 24
	80 00 00 00	 movsdx	 xmm0, QWORD PTR val$[rsp]
  00188	e8 00 00 00 00	 call	 format_float_short
$LN13@PyOS_doubl:

; 1236 : }

  0018d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00191	c3		 ret	 0
  00192	66 90		 npad	 2
$LN16@PyOS_doubl:
  00194	00 00 00 00	 DD	 $LN10@PyOS_doubl
  00198	00 00 00 00	 DD	 $LN8@PyOS_doubl
  0019c	00 00 00 00	 DD	 $LN6@PyOS_doubl
  001a0	00 00 00 00	 DD	 $LN9@PyOS_doubl
  001a4	00 00 00 00	 DD	 $LN7@PyOS_doubl
  001a8	00 00 00 00	 DD	 $LN5@PyOS_doubl
  001ac	00 00 00 00	 DD	 $LN3@PyOS_doubl
  001b0	00 00 00 00	 DD	 $LN1@PyOS_doubl
$LN15@PyOS_doubl:
  001b4	00		 DB	 0
  001b5	01		 DB	 1
  001b6	02		 DB	 2
  001b7	07		 DB	 7
  001b8	07		 DB	 7
  001b9	07		 DB	 7
  001ba	07		 DB	 7
  001bb	07		 DB	 7
  001bc	07		 DB	 7
  001bd	07		 DB	 7
  001be	07		 DB	 7
  001bf	07		 DB	 7
  001c0	07		 DB	 7
  001c1	07		 DB	 7
  001c2	07		 DB	 7
  001c3	07		 DB	 7
  001c4	07		 DB	 7
  001c5	07		 DB	 7
  001c6	07		 DB	 7
  001c7	07		 DB	 7
  001c8	07		 DB	 7
  001c9	07		 DB	 7
  001ca	07		 DB	 7
  001cb	07		 DB	 7
  001cc	07		 DB	 7
  001cd	07		 DB	 7
  001ce	07		 DB	 7
  001cf	07		 DB	 7
  001d0	07		 DB	 7
  001d1	07		 DB	 7
  001d2	07		 DB	 7
  001d3	07		 DB	 7
  001d4	03		 DB	 3
  001d5	04		 DB	 4
  001d6	05		 DB	 5
  001d7	07		 DB	 7
  001d8	07		 DB	 7
  001d9	07		 DB	 7
  001da	07		 DB	 7
  001db	07		 DB	 7
  001dc	07		 DB	 7
  001dd	07		 DB	 7
  001de	07		 DB	 7
  001df	07		 DB	 7
  001e0	07		 DB	 7
  001e1	06		 DB	 6
PyOS_double_to_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CA@CDHCKDIJ@?$AAp?$AA?9?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?5?$AAb?$AAu?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_06DKNJDFNG@?$CF?$CL?402d?$AA@		; `string'
PUBLIC	??_C@_1FM@FDHDDCGK@?$AAv?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?5?$AAd?$AAe?$AAc?$AAp?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAe?$AAc?$AAp?$AAt?$AA?5?$AA?$DM@ ; `string'
PUBLIC	??_C@_1IG@JBBCIDLM@?$AAv?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_03JFMEENOE@ERR?$AA@			; `string'
PUBLIC	??_C@_1FG@FHAGBBLM@?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAe?$AAn?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAe?$AAn?$AAd@ ; `string'
EXTRN	_Py_dg_freedtoa:PROC
EXTRN	__imp_sprintf:PROC
EXTRN	memset:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	_Py_ctype_table:BYTE
EXTRN	_Py_dg_dtoa:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_float_short DD imagerel format_float_short
	DD	imagerel format_float_short+2424
	DD	imagerel $unwind$format_float_short
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_float_short DD 021b01H
	DD	019011bH
xdata	ENDS
;	COMDAT ??_C@_1CA@CDHCKDIJ@?$AAp?$AA?9?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?5?$AAb?$AAu?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@CDHCKDIJ@?$AAp?$AA?9?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?5?$AAb?$AAu?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, '-', 00H, 'b', 00H, 'u', 00H, 'f', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKNJDFNG@?$CF?$CL?402d?$AA@
CONST	SEGMENT
??_C@_06DKNJDFNG@?$CF?$CL?402d?$AA@ DB '%+.02d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FM@FDHDDCGK@?$AAv?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?5?$AAd?$AAe?$AAc?$AAp?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAe?$AAc?$AAp?$AAt?$AA?5?$AA?$DM@
CONST	SEGMENT
??_C@_1FM@FDHDDCGK@?$AAv?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?5?$AAd?$AAe?$AAc?$AAp?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAe?$AAc?$AAp?$AAt?$AA?5?$AA?$DM@ DB 'v'
	DB	00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	'_', 00H, 's', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'c', 00H, 'p', 00H
	DB	't', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 'c', 00H, 'p', 00H, 't', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, 'v', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't'
	DB	00H, 's', 00H, '_', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IG@JBBCIDLM@?$AAv?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt@
CONST	SEGMENT
??_C@_1IG@JBBCIDLM@?$AAv?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt@ DB 'v'
	DB	00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	'_', 00H, 's', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '0', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	'_', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H
	DB	's', 00H, '_', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, 'v', 00H, 'd', 00H, 'i', 00H, 'g', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '_', 00H, 'e', 00H, 'n', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFMEENOE@ERR?$AA@
CONST	SEGMENT
??_C@_03JFMEENOE@ERR?$AA@ DB 'ERR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@FHAGBBLM@?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAe?$AAn?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAe?$AAn?$AAd@
CONST	SEGMENT
??_C@_1FG@FHAGBBLM@?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAe?$AAn?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAe?$AAn?$AAd@ DB 'd'
	DB	00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, 's', 00H, '_', 00H
	DB	'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't'
	DB	00H, 's', 00H, '_', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i'
	DB	00H, 't', 00H, 's', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT format_float_short
_TEXT	SEGMENT
vdigits_end$ = 48
p$ = 56
decpt$ = 64
exp_len$ = 72
exp$ = 76
digits$ = 80
use_exp$ = 88
bufsize$ = 96
sign$ = 104
vdigits_start$ = 112
digits_end$ = 120
buf$ = 128
digits_len$ = 136
decpt_as_int$ = 144
tv161 = 148
tv166 = 152
tv184 = 160
tv189 = 168
tv191 = 176
tv208 = 184
d$ = 208
format_code$ = 216
mode$ = 224
precision$ = 232
always_add_sign$ = 240
add_dot_0_if_integer$ = 248
use_alt_formatting$ = 256
float_strings$ = 264
type$ = 272
format_float_short PROC					; COMDAT

; 929  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00014	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 930  :     char *buf = NULL;

  0001b	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR buf$[rsp], 0

; 931  :     char *p = NULL;

  00027	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR p$[rsp], 0

; 932  :     Py_ssize_t bufsize = 0;

  00030	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR bufsize$[rsp], 0

; 933  :     char *digits, *digits_end;
; 934  :     int decpt_as_int, sign, exp_len, exp = 0, use_exp = 0;

  00039	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR exp$[rsp], 0
  00041	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR use_exp$[rsp], 0

; 935  :     Py_ssize_t decpt, digits_len, vdigits_start, vdigits_end;
; 936  :     _Py_SET_53BIT_PRECISION_HEADER;
; 937  : 
; 938  :     /* _Py_dg_dtoa returns a digit string (no decimal point or exponent).
; 939  :        Must be matched by a call to _Py_dg_freedtoa. */
; 940  :     _Py_SET_53BIT_PRECISION_START;
; 941  :     digits = _Py_dg_dtoa(d, mode, precision, &decpt_as_int, &sign,
; 942  :                          &digits_end);

  00049	48 8d 44 24 78	 lea	 rax, QWORD PTR digits_end$[rsp]
  0004e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00053	48 8d 44 24 68	 lea	 rax, QWORD PTR sign$[rsp]
  00058	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005d	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR decpt_as_int$[rsp]
  00065	44 8b 84 24 e8
	00 00 00	 mov	 r8d, DWORD PTR precision$[rsp]
  0006d	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR mode$[rsp]
  00074	f2 0f 10 84 24
	d0 00 00 00	 movsdx	 xmm0, QWORD PTR d$[rsp]
  0007d	e8 00 00 00 00	 call	 _Py_dg_dtoa
  00082	48 89 44 24 50	 mov	 QWORD PTR digits$[rsp], rax

; 943  :     _Py_SET_53BIT_PRECISION_END;
; 944  : 
; 945  :     decpt = (Py_ssize_t)decpt_as_int;

  00087	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR decpt_as_int$[rsp]
  0008f	48 89 44 24 40	 mov	 QWORD PTR decpt$[rsp], rax

; 946  :     if (digits == NULL) {

  00094	48 83 7c 24 50
	00		 cmp	 QWORD PTR digits$[rsp], 0
  0009a	75 0a		 jne	 SHORT $LN46@format_flo

; 947  :         /* The only failure mode is no memory. */
; 948  :         PyErr_NoMemory();

  0009c	e8 00 00 00 00	 call	 PyErr_NoMemory

; 949  :         goto exit;

  000a1	e9 67 08 00 00	 jmp	 $exit$20475
$LN46@format_flo:

; 950  :     }
; 951  :     assert(digits_end != NULL && digits_end >= digits);

  000a6	48 83 7c 24 78
	00		 cmp	 QWORD PTR digits_end$[rsp], 0
  000ac	74 0c		 je	 SHORT $LN49@format_flo
  000ae	48 8b 44 24 50	 mov	 rax, QWORD PTR digits$[rsp]
  000b3	48 39 44 24 78	 cmp	 QWORD PTR digits_end$[rsp], rax
  000b8	73 1c		 jae	 SHORT $LN50@format_flo
$LN49@format_flo:
  000ba	41 b8 b7 03 00
	00		 mov	 r8d, 951		; 000003b7H
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@IBEGAGAB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAp?$AAy?$AAs?$AAt?$AAr?$AAt?$AAo?$AAd?$AA?4?$AAc?$AA?$AA@
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FG@FHAGBBLM@?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAe?$AAn?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAe?$AAn?$AAd@
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d4	33 c0		 xor	 eax, eax
$LN50@format_flo:

; 952  :     digits_len = digits_end - digits;

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR digits$[rsp]
  000db	48 8b 4c 24 78	 mov	 rcx, QWORD PTR digits_end$[rsp]
  000e0	48 2b c8	 sub	 rcx, rax
  000e3	48 8b c1	 mov	 rax, rcx
  000e6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR digits_len$[rsp], rax

; 953  : 
; 954  :     if (digits_len && !Py_ISDIGIT(digits[0])) {

  000ee	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR digits_len$[rsp], 0
  000f7	0f 84 c2 01 00
	00		 je	 $LN45@format_flo
  000fd	48 8b 44 24 50	 mov	 rax, QWORD PTR digits$[rsp]
  00102	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00105	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0010a	0f b6 c0	 movzx	 eax, al
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00114	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00117	83 e0 04	 and	 eax, 4
  0011a	85 c0		 test	 eax, eax
  0011c	0f 85 9d 01 00
	00		 jne	 $LN45@format_flo

; 955  :         /* Infinities and nans here; adapt Gay's output,
; 956  :            so convert Infinity to inf and NaN to nan, and
; 957  :            ignore sign of nan. Then return. */
; 958  : 
; 959  :         /* ignore the actual sign of a nan */
; 960  :         if (digits[0] == 'n' || digits[0] == 'N')

  00122	48 8b 44 24 50	 mov	 rax, QWORD PTR digits$[rsp]
  00127	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0012a	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  0012d	74 0d		 je	 SHORT $LN43@format_flo
  0012f	48 8b 44 24 50	 mov	 rax, QWORD PTR digits$[rsp]
  00134	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00137	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  0013a	75 08		 jne	 SHORT $LN44@format_flo
$LN43@format_flo:

; 961  :             sign = 0;

  0013c	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR sign$[rsp], 0
$LN44@format_flo:

; 962  : 
; 963  :         /* We only need 5 bytes to hold the result "+inf\0" . */
; 964  :         bufsize = 5; /* Used later in an assert. */

  00144	48 c7 44 24 60
	05 00 00 00	 mov	 QWORD PTR bufsize$[rsp], 5

; 965  :         buf = (char *)PyMem_Malloc(bufsize);

  0014d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bufsize$[rsp]
  00152	e8 00 00 00 00	 call	 PyMem_Malloc
  00157	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 966  :         if (buf == NULL) {

  0015f	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00168	75 0a		 jne	 SHORT $LN42@format_flo

; 967  :             PyErr_NoMemory();

  0016a	e8 00 00 00 00	 call	 PyErr_NoMemory

; 968  :             goto exit;

  0016f	e9 99 07 00 00	 jmp	 $exit$20475
$LN42@format_flo:

; 969  :         }
; 970  :         p = buf;

  00174	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0017c	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 971  : 
; 972  :         if (sign == 1) {

  00181	83 7c 24 68 01	 cmp	 DWORD PTR sign$[rsp], 1
  00186	75 17		 jne	 SHORT $LN41@format_flo

; 973  :             *p++ = '-';

  00188	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  0018d	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH
  00190	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  00195	48 ff c0	 inc	 rax
  00198	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
  0019d	eb 1f		 jmp	 SHORT $LN40@format_flo
$LN41@format_flo:

; 974  :         }
; 975  :         else if (always_add_sign) {

  0019f	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR always_add_sign$[rsp], 0
  001a7	74 15		 je	 SHORT $LN39@format_flo

; 976  :             *p++ = '+';

  001a9	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  001ae	c6 00 2b	 mov	 BYTE PTR [rax], 43	; 0000002bH
  001b1	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  001b6	48 ff c0	 inc	 rax
  001b9	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
$LN39@format_flo:
$LN40@format_flo:

; 977  :         }
; 978  :         if (digits[0] == 'i' || digits[0] == 'I') {

  001be	48 8b 44 24 50	 mov	 rax, QWORD PTR digits$[rsp]
  001c3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001c6	83 f8 69	 cmp	 eax, 105		; 00000069H
  001c9	74 0d		 je	 SHORT $LN37@format_flo
  001cb	48 8b 44 24 50	 mov	 rax, QWORD PTR digits$[rsp]
  001d0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001d3	83 f8 49	 cmp	 eax, 73			; 00000049H
  001d6	75 48		 jne	 SHORT $LN38@format_flo
$LN37@format_flo:

; 979  :             strncpy(p, float_strings[OFS_INF], 3);

  001d8	41 b8 03 00 00
	00		 mov	 r8d, 3
  001de	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR float_strings$[rsp]
  001e6	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001e9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 980  :             p += 3;

  001f4	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  001f9	48 83 c0 03	 add	 rax, 3
  001fd	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 981  : 
; 982  :             if (type)

  00202	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR type$[rsp], 0
  0020b	74 0e		 je	 SHORT $LN36@format_flo

; 983  :                 *type = Py_DTST_INFINITE;

  0020d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR type$[rsp]
  00215	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN36@format_flo:

; 984  :         }
; 985  :         else if (digits[0] == 'n' || digits[0] == 'N') {

  0021b	e9 9a 00 00 00	 jmp	 $LN35@format_flo
$LN38@format_flo:
  00220	48 8b 44 24 50	 mov	 rax, QWORD PTR digits$[rsp]
  00225	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00228	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  0022b	74 0d		 je	 SHORT $LN33@format_flo
  0022d	48 8b 44 24 50	 mov	 rax, QWORD PTR digits$[rsp]
  00232	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00235	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00238	75 46		 jne	 SHORT $LN34@format_flo
$LN33@format_flo:

; 986  :             strncpy(p, float_strings[OFS_NAN], 3);

  0023a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00240	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR float_strings$[rsp]
  00248	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0024c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 987  :             p += 3;

  00257	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  0025c	48 83 c0 03	 add	 rax, 3
  00260	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 988  : 
; 989  :             if (type)

  00265	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR type$[rsp], 0
  0026e	74 0e		 je	 SHORT $LN32@format_flo

; 990  :                 *type = Py_DTST_NAN;

  00270	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR type$[rsp]
  00278	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN32@format_flo:

; 991  :         }
; 992  :         else {

  0027e	eb 3a		 jmp	 SHORT $LN31@format_flo
$LN34@format_flo:

; 993  :             /* shouldn't get here: Gay's code should always return
; 994  :                something starting with a digit, an 'I',  or 'N' */
; 995  :             strncpy(p, "ERR", 3);

  00280	41 b8 03 00 00
	00		 mov	 r8d, 3
  00286	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JFMEENOE@ERR?$AA@
  0028d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 996  :             /* p += 3; */
; 997  :             assert(0);

  00298	33 c0		 xor	 eax, eax
  0029a	85 c0		 test	 eax, eax
  0029c	75 1c		 jne	 SHORT $LN51@format_flo
  0029e	41 b8 e5 03 00
	00		 mov	 r8d, 997		; 000003e5H
  002a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@IBEGAGAB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAp?$AAy?$AAs?$AAt?$AAr?$AAt?$AAo?$AAd?$AA?4?$AAc?$AA?$AA@
  002ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  002b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002b8	33 c0		 xor	 eax, eax
$LN51@format_flo:
$LN31@format_flo:
$LN35@format_flo:

; 998  :         }
; 999  :         goto exit;

  002ba	e9 4e 06 00 00	 jmp	 $exit$20475
$LN45@format_flo:

; 1000 :     }
; 1001 : 
; 1002 :     /* The result must be finite (not inf or nan). */
; 1003 :     if (type)

  002bf	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR type$[rsp], 0
  002c8	74 0e		 je	 SHORT $LN30@format_flo

; 1004 :         *type = Py_DTST_FINITE;

  002ca	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR type$[rsp]
  002d2	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN30@format_flo:

; 1005 : 
; 1006 : 
; 1007 :     /* We got digits back, format them.  We may need to pad 'digits'
; 1008 :        either on the left or right (or both) with extra zeros, so in
; 1009 :        general the resulting string has the form
; 1010 : 
; 1011 :          [<sign>]<zeros><digits><zeros>[<exponent>]
; 1012 : 
; 1013 :        where either of the <zeros> pieces could be empty, and there's a
; 1014 :        decimal point that could appear either in <digits> or in the
; 1015 :        leading or trailing <zeros>.
; 1016 : 
; 1017 :        Imagine an infinite 'virtual' string vdigits, consisting of the
; 1018 :        string 'digits' (starting at index 0) padded on both the left and
; 1019 :        right with infinite strings of zeros.  We want to output a slice
; 1020 : 
; 1021 :          vdigits[vdigits_start : vdigits_end]
; 1022 : 
; 1023 :        of this virtual string.  Thus if vdigits_start < 0 then we'll end
; 1024 :        up producing some leading zeros; if vdigits_end > digits_len there
; 1025 :        will be trailing zeros in the output.  The next section of code
; 1026 :        determines whether to use an exponent or not, figures out the
; 1027 :        position 'decpt' of the decimal point, and computes 'vdigits_start'
; 1028 :        and 'vdigits_end'. */
; 1029 :     vdigits_end = digits_len;

  002d8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR digits_len$[rsp]
  002e0	48 89 44 24 30	 mov	 QWORD PTR vdigits_end$[rsp], rax

; 1030 :     switch (format_code) {

  002e5	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR format_code$[rsp]
  002ed	88 84 24 94 00
	00 00		 mov	 BYTE PTR tv161[rsp], al
  002f4	80 bc 24 94 00
	00 00 65	 cmp	 BYTE PTR tv161[rsp], 101 ; 00000065H
  002fc	74 27		 je	 SHORT $LN27@format_flo
  002fe	80 bc 24 94 00
	00 00 66	 cmp	 BYTE PTR tv161[rsp], 102 ; 00000066H
  00306	74 37		 je	 SHORT $LN26@format_flo
  00308	80 bc 24 94 00
	00 00 67	 cmp	 BYTE PTR tv161[rsp], 103 ; 00000067H
  00310	74 4a		 je	 SHORT $LN25@format_flo
  00312	80 bc 24 94 00
	00 00 72	 cmp	 BYTE PTR tv161[rsp], 114 ; 00000072H
  0031a	0f 84 a3 00 00
	00		 je	 $LN21@format_flo
  00320	e9 b8 00 00 00	 jmp	 $LN18@format_flo
$LN27@format_flo:

; 1031 :     case 'e':
; 1032 :         use_exp = 1;

  00325	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR use_exp$[rsp], 1

; 1033 :         vdigits_end = precision;

  0032d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR precision$[rsp]
  00335	48 89 44 24 30	 mov	 QWORD PTR vdigits_end$[rsp], rax

; 1034 :         break;

  0033a	e9 b4 00 00 00	 jmp	 $LN28@format_flo
$LN26@format_flo:

; 1035 :     case 'f':
; 1036 :         vdigits_end = decpt + precision;

  0033f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR precision$[rsp]
  00347	48 8b 4c 24 40	 mov	 rcx, QWORD PTR decpt$[rsp]
  0034c	48 03 c8	 add	 rcx, rax
  0034f	48 8b c1	 mov	 rax, rcx
  00352	48 89 44 24 30	 mov	 QWORD PTR vdigits_end$[rsp], rax

; 1037 :         break;

  00357	e9 97 00 00 00	 jmp	 $LN28@format_flo
$LN25@format_flo:

; 1038 :     case 'g':
; 1039 :         if (decpt <= -4 || decpt >
; 1040 :             (add_dot_0_if_integer ? precision-1 : precision))

  0035c	48 83 7c 24 40
	fc		 cmp	 QWORD PTR decpt$[rsp], -4
  00362	7e 3e		 jle	 SHORT $LN23@format_flo
  00364	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR add_dot_0_if_integer$[rsp], 0
  0036c	74 15		 je	 SHORT $LN52@format_flo
  0036e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR precision$[rsp]
  00376	48 ff c8	 dec	 rax
  00379	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  00381	eb 10		 jmp	 SHORT $LN53@format_flo
$LN52@format_flo:
  00383	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR precision$[rsp]
  0038b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
$LN53@format_flo:
  00393	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv166[rsp]
  0039b	48 39 44 24 40	 cmp	 QWORD PTR decpt$[rsp], rax
  003a0	7e 08		 jle	 SHORT $LN24@format_flo
$LN23@format_flo:

; 1041 :             use_exp = 1;

  003a2	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR use_exp$[rsp], 1
$LN24@format_flo:

; 1042 :         if (use_alt_formatting)

  003aa	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR use_alt_formatting$[rsp], 0
  003b2	74 0d		 je	 SHORT $LN22@format_flo

; 1043 :             vdigits_end = precision;

  003b4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR precision$[rsp]
  003bc	48 89 44 24 30	 mov	 QWORD PTR vdigits_end$[rsp], rax
$LN22@format_flo:

; 1044 :         break;

  003c1	eb 30		 jmp	 SHORT $LN28@format_flo
$LN21@format_flo:

; 1045 :     case 'r':
; 1046 :         /* convert to exponential format at 1e16.  We used to convert
; 1047 :            at 1e17, but that gives odd-looking results for some values
; 1048 :            when a 16-digit 'shortest' repr is padded with bogus zeros.
; 1049 :            For example, repr(2e16+8) would give 20000000000000010.0;
; 1050 :            the true value is 20000000000000008.0. */
; 1051 :         if (decpt <= -4 || decpt > 16)

  003c3	48 83 7c 24 40
	fc		 cmp	 QWORD PTR decpt$[rsp], -4
  003c9	7e 08		 jle	 SHORT $LN19@format_flo
  003cb	48 83 7c 24 40
	10		 cmp	 QWORD PTR decpt$[rsp], 16
  003d1	7e 08		 jle	 SHORT $LN20@format_flo
$LN19@format_flo:

; 1052 :             use_exp = 1;

  003d3	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR use_exp$[rsp], 1
$LN20@format_flo:

; 1053 :         break;

  003db	eb 16		 jmp	 SHORT $LN28@format_flo
$LN18@format_flo:

; 1054 :     default:
; 1055 :         PyErr_BadInternalCall();

  003dd	ba 1f 04 00 00	 mov	 edx, 1055		; 0000041fH
  003e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GKLBOEON@?4?4?2Python?2pystrtod?4c?$AA@
  003e9	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1056 :         goto exit;

  003ee	e9 1a 05 00 00	 jmp	 $exit$20475
$LN28@format_flo:

; 1057 :     }
; 1058 : 
; 1059 :     /* if using an exponent, reset decimal point position to 1 and adjust
; 1060 :        exponent accordingly.*/
; 1061 :     if (use_exp) {

  003f3	83 7c 24 58 00	 cmp	 DWORD PTR use_exp$[rsp], 0
  003f8	74 15		 je	 SHORT $LN17@format_flo

; 1062 :         exp = decpt - 1;

  003fa	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  003ff	48 ff c8	 dec	 rax
  00402	89 44 24 4c	 mov	 DWORD PTR exp$[rsp], eax

; 1063 :         decpt = 1;

  00406	48 c7 44 24 40
	01 00 00 00	 mov	 QWORD PTR decpt$[rsp], 1
$LN17@format_flo:

; 1064 :     }
; 1065 :     /* ensure vdigits_start < decpt <= vdigits_end, or vdigits_start <
; 1066 :        decpt < vdigits_end if add_dot_0_if_integer and no exponent */
; 1067 :     vdigits_start = decpt <= 0 ? decpt-1 : 0;

  0040f	48 83 7c 24 40
	00		 cmp	 QWORD PTR decpt$[rsp], 0
  00415	7f 12		 jg	 SHORT $LN54@format_flo
  00417	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  0041c	48 ff c8	 dec	 rax
  0041f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv184[rsp], rax
  00427	eb 0c		 jmp	 SHORT $LN55@format_flo
$LN54@format_flo:
  00429	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv184[rsp], 0
$LN55@format_flo:
  00435	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv184[rsp]
  0043d	48 89 44 24 70	 mov	 QWORD PTR vdigits_start$[rsp], rax

; 1068 :     if (!use_exp && add_dot_0_if_integer)

  00442	83 7c 24 58 00	 cmp	 DWORD PTR use_exp$[rsp], 0
  00447	75 44		 jne	 SHORT $LN16@format_flo
  00449	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR add_dot_0_if_integer$[rsp], 0
  00451	74 3a		 je	 SHORT $LN16@format_flo

; 1069 :         vdigits_end = vdigits_end > decpt ? vdigits_end : decpt + 1;

  00453	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  00458	48 39 44 24 30	 cmp	 QWORD PTR vdigits_end$[rsp], rax
  0045d	7e 0f		 jle	 SHORT $LN56@format_flo
  0045f	48 8b 44 24 30	 mov	 rax, QWORD PTR vdigits_end$[rsp]
  00464	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv189[rsp], rax
  0046c	eb 10		 jmp	 SHORT $LN57@format_flo
$LN56@format_flo:
  0046e	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  00473	48 ff c0	 inc	 rax
  00476	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv189[rsp], rax
$LN57@format_flo:
  0047e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv189[rsp]
  00486	48 89 44 24 30	 mov	 QWORD PTR vdigits_end$[rsp], rax

; 1070 :     else

  0048b	eb 35		 jmp	 SHORT $LN15@format_flo
$LN16@format_flo:

; 1071 :         vdigits_end = vdigits_end > decpt ? vdigits_end : decpt;

  0048d	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  00492	48 39 44 24 30	 cmp	 QWORD PTR vdigits_end$[rsp], rax
  00497	7e 0f		 jle	 SHORT $LN58@format_flo
  00499	48 8b 44 24 30	 mov	 rax, QWORD PTR vdigits_end$[rsp]
  0049e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv191[rsp], rax
  004a6	eb 0d		 jmp	 SHORT $LN59@format_flo
$LN58@format_flo:
  004a8	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  004ad	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv191[rsp], rax
$LN59@format_flo:
  004b5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv191[rsp]
  004bd	48 89 44 24 30	 mov	 QWORD PTR vdigits_end$[rsp], rax
$LN15@format_flo:

; 1072 : 
; 1073 :     /* double check inequalities */
; 1074 :     assert(vdigits_start <= 0 &&
; 1075 :            0 <= digits_len &&
; 1076 :            digits_len <= vdigits_end);

  004c2	48 83 7c 24 70
	00		 cmp	 QWORD PTR vdigits_start$[rsp], 0
  004c8	7f 1a		 jg	 SHORT $LN60@format_flo
  004ca	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR digits_len$[rsp], 0
  004d3	7c 0f		 jl	 SHORT $LN60@format_flo
  004d5	48 8b 44 24 30	 mov	 rax, QWORD PTR vdigits_end$[rsp]
  004da	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR digits_len$[rsp], rax
  004e2	7e 1c		 jle	 SHORT $LN61@format_flo
$LN60@format_flo:
  004e4	41 b8 34 04 00
	00		 mov	 r8d, 1076		; 00000434H
  004ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@IBEGAGAB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAp?$AAy?$AAs?$AAt?$AAr?$AAt?$AAo?$AAd?$AA?4?$AAc?$AA?$AA@
  004f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1IG@JBBCIDLM@?$AAv?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAd?$AAi?$AAg?$AAi?$AAt@
  004f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004fe	33 c0		 xor	 eax, eax
$LN61@format_flo:

; 1077 :     /* decimal point should be in (vdigits_start, vdigits_end] */
; 1078 :     assert(vdigits_start < decpt && decpt <= vdigits_end);

  00500	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  00505	48 39 44 24 70	 cmp	 QWORD PTR vdigits_start$[rsp], rax
  0050a	7d 0c		 jge	 SHORT $LN62@format_flo
  0050c	48 8b 44 24 30	 mov	 rax, QWORD PTR vdigits_end$[rsp]
  00511	48 39 44 24 40	 cmp	 QWORD PTR decpt$[rsp], rax
  00516	7e 1c		 jle	 SHORT $LN63@format_flo
$LN62@format_flo:
  00518	41 b8 36 04 00
	00		 mov	 r8d, 1078		; 00000436H
  0051e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@IBEGAGAB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAp?$AAy?$AAs?$AAt?$AAr?$AAt?$AAo?$AAd?$AA?4?$AAc?$AA?$AA@
  00525	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@FDHDDCGK@?$AAv?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?5?$AAd?$AAe?$AAc?$AAp?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AAe?$AAc?$AAp?$AAt?$AA?5?$AA?$DM@
  0052c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00532	33 c0		 xor	 eax, eax
$LN63@format_flo:

; 1079 : 
; 1080 :     /* Compute an upper bound how much memory we need. This might be a few
; 1081 :        chars too long, but no big deal. */
; 1082 :     bufsize =
; 1083 :         /* sign, decimal point and trailing 0 byte */
; 1084 :         3 +
; 1085 : 
; 1086 :         /* total digit count (including zero padding on both sides) */
; 1087 :         (vdigits_end - vdigits_start) +
; 1088 : 
; 1089 :         /* exponent "e+100", max 3 numerical digits */
; 1090 :         (use_exp ? 5 : 0);

  00534	83 7c 24 58 00	 cmp	 DWORD PTR use_exp$[rsp], 0
  00539	74 0d		 je	 SHORT $LN64@format_flo
  0053b	c7 84 24 b8 00
	00 00 05 00 00
	00		 mov	 DWORD PTR tv208[rsp], 5
  00546	eb 0b		 jmp	 SHORT $LN65@format_flo
$LN64@format_flo:
  00548	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv208[rsp], 0
$LN65@format_flo:
  00553	48 8b 44 24 70	 mov	 rax, QWORD PTR vdigits_start$[rsp]
  00558	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vdigits_end$[rsp]
  0055d	48 2b c8	 sub	 rcx, rax
  00560	48 8b c1	 mov	 rax, rcx
  00563	48 63 8c 24 b8
	00 00 00	 movsxd	 rcx, DWORD PTR tv208[rsp]
  0056b	48 8d 44 08 03	 lea	 rax, QWORD PTR [rax+rcx+3]
  00570	48 89 44 24 60	 mov	 QWORD PTR bufsize$[rsp], rax

; 1091 : 
; 1092 :     /* Now allocate the memory and initialize p to point to the start of
; 1093 :        it. */
; 1094 :     buf = (char *)PyMem_Malloc(bufsize);

  00575	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bufsize$[rsp]
  0057a	e8 00 00 00 00	 call	 PyMem_Malloc
  0057f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1095 :     if (buf == NULL) {

  00587	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00590	75 0a		 jne	 SHORT $LN14@format_flo

; 1096 :         PyErr_NoMemory();

  00592	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1097 :         goto exit;

  00597	e9 71 03 00 00	 jmp	 $exit$20475
$LN14@format_flo:

; 1098 :     }
; 1099 :     p = buf;

  0059c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  005a4	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1100 : 
; 1101 :     /* Add a negative sign if negative, and a plus sign if non-negative
; 1102 :        and always_add_sign is true. */
; 1103 :     if (sign == 1)

  005a9	83 7c 24 68 01	 cmp	 DWORD PTR sign$[rsp], 1
  005ae	75 17		 jne	 SHORT $LN13@format_flo

; 1104 :         *p++ = '-';

  005b0	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  005b5	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH
  005b8	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  005bd	48 ff c0	 inc	 rax
  005c0	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
  005c5	eb 1f		 jmp	 SHORT $LN12@format_flo
$LN13@format_flo:

; 1105 :     else if (always_add_sign)

  005c7	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR always_add_sign$[rsp], 0
  005cf	74 15		 je	 SHORT $LN11@format_flo

; 1106 :         *p++ = '+';

  005d1	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  005d6	c6 00 2b	 mov	 BYTE PTR [rax], 43	; 0000002bH
  005d9	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  005de	48 ff c0	 inc	 rax
  005e1	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
$LN11@format_flo:
$LN12@format_flo:

; 1107 : 
; 1108 :     /* note that exactly one of the three 'if' conditions is true,
; 1109 :        so we include exactly one decimal point */
; 1110 :     /* Zero padding on left of digit string */
; 1111 :     if (decpt <= 0) {

  005e6	48 83 7c 24 40
	00		 cmp	 QWORD PTR decpt$[rsp], 0
  005ec	0f 8f 89 00 00
	00		 jg	 $LN10@format_flo

; 1112 :         memset(p, '0', decpt-vdigits_start);

  005f2	48 8b 44 24 70	 mov	 rax, QWORD PTR vdigits_start$[rsp]
  005f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR decpt$[rsp]
  005fc	48 2b c8	 sub	 rcx, rax
  005ff	48 8b c1	 mov	 rax, rcx
  00602	4c 8b c0	 mov	 r8, rax
  00605	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0060a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  0060f	e8 00 00 00 00	 call	 memset

; 1113 :         p += decpt - vdigits_start;

  00614	48 8b 44 24 70	 mov	 rax, QWORD PTR vdigits_start$[rsp]
  00619	48 8b 4c 24 40	 mov	 rcx, QWORD PTR decpt$[rsp]
  0061e	48 2b c8	 sub	 rcx, rax
  00621	48 8b c1	 mov	 rax, rcx
  00624	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00629	48 03 c8	 add	 rcx, rax
  0062c	48 8b c1	 mov	 rax, rcx
  0062f	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1114 :         *p++ = '.';

  00634	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  00639	c6 00 2e	 mov	 BYTE PTR [rax], 46	; 0000002eH
  0063c	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  00641	48 ff c0	 inc	 rax
  00644	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1115 :         memset(p, '0', 0-decpt);

  00649	33 c0		 xor	 eax, eax
  0064b	48 2b 44 24 40	 sub	 rax, QWORD PTR decpt$[rsp]
  00650	4c 8b c0	 mov	 r8, rax
  00653	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  00658	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  0065d	e8 00 00 00 00	 call	 memset

; 1116 :         p += 0-decpt;

  00662	33 c0		 xor	 eax, eax
  00664	48 2b 44 24 40	 sub	 rax, QWORD PTR decpt$[rsp]
  00669	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  0066e	48 03 c8	 add	 rcx, rax
  00671	48 8b c1	 mov	 rax, rcx
  00674	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1117 :     }
; 1118 :     else {

  00679	eb 30		 jmp	 SHORT $LN9@format_flo
$LN10@format_flo:

; 1119 :         memset(p, '0', 0-vdigits_start);

  0067b	33 c0		 xor	 eax, eax
  0067d	48 2b 44 24 70	 sub	 rax, QWORD PTR vdigits_start$[rsp]
  00682	4c 8b c0	 mov	 r8, rax
  00685	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0068a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  0068f	e8 00 00 00 00	 call	 memset

; 1120 :         p += 0 - vdigits_start;

  00694	33 c0		 xor	 eax, eax
  00696	48 2b 44 24 70	 sub	 rax, QWORD PTR vdigits_start$[rsp]
  0069b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  006a0	48 03 c8	 add	 rcx, rax
  006a3	48 8b c1	 mov	 rax, rcx
  006a6	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
$LN9@format_flo:

; 1121 :     }
; 1122 : 
; 1123 :     /* Digits, with included decimal point */
; 1124 :     if (0 < decpt && decpt <= digits_len) {

  006ab	48 83 7c 24 40
	00		 cmp	 QWORD PTR decpt$[rsp], 0
  006b1	0f 8e ab 00 00
	00		 jle	 $LN8@format_flo
  006b7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR digits_len$[rsp]
  006bf	48 39 44 24 40	 cmp	 QWORD PTR decpt$[rsp], rax
  006c4	0f 8f 98 00 00
	00		 jg	 $LN8@format_flo

; 1125 :         strncpy(p, digits, decpt-0);

  006ca	4c 8b 44 24 40	 mov	 r8, QWORD PTR decpt$[rsp]
  006cf	48 8b 54 24 50	 mov	 rdx, QWORD PTR digits$[rsp]
  006d4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  006d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 1126 :         p += decpt-0;

  006df	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  006e4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  006e9	48 03 c8	 add	 rcx, rax
  006ec	48 8b c1	 mov	 rax, rcx
  006ef	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1127 :         *p++ = '.';

  006f4	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  006f9	c6 00 2e	 mov	 BYTE PTR [rax], 46	; 0000002eH
  006fc	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  00701	48 ff c0	 inc	 rax
  00704	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1128 :         strncpy(p, digits+decpt, digits_len-decpt);

  00709	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  0070e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR digits_len$[rsp]
  00716	48 2b c8	 sub	 rcx, rax
  00719	48 8b c1	 mov	 rax, rcx
  0071c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR decpt$[rsp]
  00721	48 8b 54 24 50	 mov	 rdx, QWORD PTR digits$[rsp]
  00726	48 03 d1	 add	 rdx, rcx
  00729	48 8b ca	 mov	 rcx, rdx
  0072c	4c 8b c0	 mov	 r8, rax
  0072f	48 8b d1	 mov	 rdx, rcx
  00732	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00737	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 1129 :         p += digits_len-decpt;

  0073d	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  00742	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR digits_len$[rsp]
  0074a	48 2b c8	 sub	 rcx, rax
  0074d	48 8b c1	 mov	 rax, rcx
  00750	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00755	48 03 c8	 add	 rcx, rax
  00758	48 8b c1	 mov	 rax, rcx
  0075b	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1130 :     }
; 1131 :     else {

  00760	eb 30		 jmp	 SHORT $LN7@format_flo
$LN8@format_flo:

; 1132 :         strncpy(p, digits, digits_len);

  00762	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR digits_len$[rsp]
  0076a	48 8b 54 24 50	 mov	 rdx, QWORD PTR digits$[rsp]
  0076f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00774	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 1133 :         p += digits_len;

  0077a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR digits_len$[rsp]
  00782	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00787	48 03 c8	 add	 rcx, rax
  0078a	48 8b c1	 mov	 rax, rcx
  0078d	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
$LN7@format_flo:

; 1134 :     }
; 1135 : 
; 1136 :     /* And zeros on the right */
; 1137 :     if (digits_len < decpt) {

  00792	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  00797	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR digits_len$[rsp], rax
  0079f	0f 8d a1 00 00
	00		 jge	 $LN6@format_flo

; 1138 :         memset(p, '0', decpt-digits_len);

  007a5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR digits_len$[rsp]
  007ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR decpt$[rsp]
  007b2	48 2b c8	 sub	 rcx, rax
  007b5	48 8b c1	 mov	 rax, rcx
  007b8	4c 8b c0	 mov	 r8, rax
  007bb	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  007c0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  007c5	e8 00 00 00 00	 call	 memset

; 1139 :         p += decpt-digits_len;

  007ca	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR digits_len$[rsp]
  007d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR decpt$[rsp]
  007d7	48 2b c8	 sub	 rcx, rax
  007da	48 8b c1	 mov	 rax, rcx
  007dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  007e2	48 03 c8	 add	 rcx, rax
  007e5	48 8b c1	 mov	 rax, rcx
  007e8	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1140 :         *p++ = '.';

  007ed	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  007f2	c6 00 2e	 mov	 BYTE PTR [rax], 46	; 0000002eH
  007f5	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  007fa	48 ff c0	 inc	 rax
  007fd	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1141 :         memset(p, '0', vdigits_end-decpt);

  00802	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  00807	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vdigits_end$[rsp]
  0080c	48 2b c8	 sub	 rcx, rax
  0080f	48 8b c1	 mov	 rax, rcx
  00812	4c 8b c0	 mov	 r8, rax
  00815	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0081a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  0081f	e8 00 00 00 00	 call	 memset

; 1142 :         p += vdigits_end-decpt;

  00824	48 8b 44 24 40	 mov	 rax, QWORD PTR decpt$[rsp]
  00829	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vdigits_end$[rsp]
  0082e	48 2b c8	 sub	 rcx, rax
  00831	48 8b c1	 mov	 rax, rcx
  00834	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00839	48 03 c8	 add	 rcx, rax
  0083c	48 8b c1	 mov	 rax, rcx
  0083f	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1143 :     }
; 1144 :     else {

  00844	eb 48		 jmp	 SHORT $LN5@format_flo
$LN6@format_flo:

; 1145 :         memset(p, '0', vdigits_end-digits_len);

  00846	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR digits_len$[rsp]
  0084e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vdigits_end$[rsp]
  00853	48 2b c8	 sub	 rcx, rax
  00856	48 8b c1	 mov	 rax, rcx
  00859	4c 8b c0	 mov	 r8, rax
  0085c	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  00861	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00866	e8 00 00 00 00	 call	 memset

; 1146 :         p += vdigits_end-digits_len;

  0086b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR digits_len$[rsp]
  00873	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vdigits_end$[rsp]
  00878	48 2b c8	 sub	 rcx, rax
  0087b	48 8b c1	 mov	 rax, rcx
  0087e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00883	48 03 c8	 add	 rcx, rax
  00886	48 8b c1	 mov	 rax, rcx
  00889	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
$LN5@format_flo:

; 1147 :     }
; 1148 : 
; 1149 :     /* Delete a trailing decimal pt unless using alternative formatting. */
; 1150 :     if (p[-1] == '.' && !use_alt_formatting)

  0088e	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  00893	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  00897	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0089a	75 17		 jne	 SHORT $LN4@format_flo
  0089c	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR use_alt_formatting$[rsp], 0
  008a4	75 0d		 jne	 SHORT $LN4@format_flo

; 1151 :         p--;

  008a6	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  008ab	48 ff c8	 dec	 rax
  008ae	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
$LN4@format_flo:

; 1152 : 
; 1153 :     /* Now that we've done zero padding, add an exponent if needed. */
; 1154 :     if (use_exp) {

  008b3	83 7c 24 58 00	 cmp	 DWORD PTR use_exp$[rsp], 0
  008b8	74 53		 je	 SHORT $LN3@format_flo

; 1155 :         *p++ = float_strings[OFS_E][0];

  008ba	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR float_strings$[rsp]
  008c2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  008c6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  008cb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  008ce	88 01		 mov	 BYTE PTR [rcx], al
  008d0	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  008d5	48 ff c0	 inc	 rax
  008d8	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 1156 :         exp_len = sprintf(p, "%+.02d", exp);

  008dd	44 8b 44 24 4c	 mov	 r8d, DWORD PTR exp$[rsp]
  008e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DKNJDFNG@?$CF?$CL?402d?$AA@
  008e9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  008ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
  008f4	89 44 24 48	 mov	 DWORD PTR exp_len$[rsp], eax

; 1157 :         p += exp_len;

  008f8	48 63 44 24 48	 movsxd	 rax, DWORD PTR exp_len$[rsp]
  008fd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00902	48 03 c8	 add	 rcx, rax
  00905	48 8b c1	 mov	 rax, rcx
  00908	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
$LN3@format_flo:
$exit$20475:

; 1158 :     }
; 1159 :   exit:
; 1160 :     if (buf) {

  0090d	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00916	74 3e		 je	 SHORT $LN2@format_flo

; 1161 :         *p = '\0';

  00918	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  0091d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1162 :         /* It's too late if this fails, as we've already stepped on
; 1163 :            memory that isn't ours. But it's an okay debugging test. */
; 1164 :         assert(p-buf < bufsize);

  00920	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00928	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  0092d	48 2b c8	 sub	 rcx, rax
  00930	48 8b c1	 mov	 rax, rcx
  00933	48 3b 44 24 60	 cmp	 rax, QWORD PTR bufsize$[rsp]
  00938	7c 1c		 jl	 SHORT $LN66@format_flo
  0093a	41 b8 8c 04 00
	00		 mov	 r8d, 1164		; 0000048cH
  00940	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@IBEGAGAB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAp?$AAy?$AAs?$AAt?$AAr?$AAt?$AAo?$AAd?$AA?4?$AAc?$AA?$AA@
  00947	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@CDHCKDIJ@?$AAp?$AA?9?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?5?$AAb?$AAu?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  0094e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00954	33 c0		 xor	 eax, eax
$LN66@format_flo:
$LN2@format_flo:

; 1165 :     }
; 1166 :     if (digits)

  00956	48 83 7c 24 50
	00		 cmp	 QWORD PTR digits$[rsp], 0
  0095c	74 0a		 je	 SHORT $LN1@format_flo

; 1167 :         _Py_dg_freedtoa(digits);

  0095e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR digits$[rsp]
  00963	e8 00 00 00 00	 call	 _Py_dg_freedtoa
$LN1@format_flo:

; 1168 : 
; 1169 :     return buf;

  00968	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]

; 1170 : }

  00970	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00977	c3		 ret	 0
format_float_short ENDP
_TEXT	ENDS
END
