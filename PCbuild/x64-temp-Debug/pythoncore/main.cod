; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0PH@PPPCLIAI@PYTHONHASHSEED?3?5if?5this?5variable@ ; `string'
PUBLIC	??_C@_0BEA@BALBKLFN@PYTHONHOME?5?5?5?3?5alternate?5?$DMprefix@ ; `string'
PUBLIC	??_C@_0BII@FPIDEIJE@file?5?5?5?3?5program?5read?5from?5scrip@ ; `string'
PUBLIC	??_C@_0CFC@NIJOBHPJ@?9u?5?5?5?5?5?3?5unbuffered?5binary?5stdou@ ; `string'
PUBLIC	??_C@_0CCE@ELHEAOKH@?9i?5?5?5?5?5?3?5inspect?5interactively?5a@ ; `string'
PUBLIC	??_C@_0CAO@BDKKHAC@Options?5and?5arguments?5?$CIand?5corre@ ; `string'
PUBLIC	??_C@_0EA@DDFOEECA@usage?3?5?$CFls?5?$FLoption?$FN?5?4?4?4?5?$FL?9c?5cmd?5@ ; `string'
;	COMDAT ??_C@_0PH@PPPCLIAI@PYTHONHASHSEED?3?5if?5this?5variable@
CONST	SEGMENT
??_C@_0PH@PPPCLIAI@PYTHONHASHSEED?3?5if?5this?5variable@ DB 'PYTHONHASHSE'
	DB	'ED: if this variable is set to ''random'', a random value is '
	DB	'used', 0aH, '   to seed the hashes of str, bytes and datetime'
	DB	' objects.  It can also be', 0aH, '   set to an integer in the'
	DB	' range [0,4294967295] to get hash values with a', 0aH, '   pr'
	DB	'edictable seed.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BEA@BALBKLFN@PYTHONHOME?5?5?5?3?5alternate?5?$DMprefix@
CONST	SEGMENT
??_C@_0BEA@BALBKLFN@PYTHONHOME?5?5?5?3?5alternate?5?$DMprefix@ DB 'PYTHON'
	DB	'HOME   : alternate <prefix> directory (or <prefix>%c<exec_pre'
	DB	'fix>).', 0aH, '               The default module search path '
	DB	'uses %s.', 0aH, 'PYTHONCASEOK : ignore case in ''import'' sta'
	DB	'tements (Windows).', 0aH, 'PYTHONIOENCODING: Encoding[:errors'
	DB	'] used for stdin/stdout/stderr.', 0aH, 'PYTHONFAULTHANDLER: d'
	DB	'ump the Python traceback on fatal errors.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BII@FPIDEIJE@file?5?5?5?3?5program?5read?5from?5scrip@
CONST	SEGMENT
??_C@_0BII@FPIDEIJE@file?5?5?5?3?5program?5read?5from?5scrip@ DB 'file   '
	DB	': program read from script file', 0aH, '-      : program read'
	DB	' from stdin (default; interactive mode if a tty)', 0aH, 'arg '
	DB	'...: arguments passed to program in sys.argv[1:]', 0aH, 0aH, 'O'
	DB	'ther environment variables:', 0aH, 'PYTHONSTARTUP: file execu'
	DB	'ted on interactive startup (no default)', 0aH, 'PYTHONPATH   '
	DB	': ''%c''-separated list of directories prefixed to the', 0aH, ' '
	DB	'              default module search path.  The result is sys.'
	DB	'path.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CFC@NIJOBHPJ@?9u?5?5?5?5?5?3?5unbuffered?5binary?5stdou@
CONST	SEGMENT
??_C@_0CFC@NIJOBHPJ@?9u?5?5?5?5?5?3?5unbuffered?5binary?5stdou@ DB '-u   '
	DB	'  : unbuffered binary stdout and stderr, stdin always buffere'
	DB	'd;', 0aH, '         also PYTHONUNBUFFERED=x', 0aH, '         '
	DB	'see man page for details on internal buffering relating to '''
	DB	'-u''', 0aH, '-v     : verbose (trace import statements); also'
	DB	' PYTHONVERBOSE=x', 0aH, '         can be supplied multiple ti'
	DB	'mes to increase verbosity', 0aH, '-V     : print the Python v'
	DB	'ersion number and exit (also --version)', 0aH, '-W arg : warn'
	DB	'ing control; arg is action:message:category:module:lineno', 0aH
	DB	'         also PYTHONWARNINGS=arg', 0aH, '-x     : skip first '
	DB	'line of source, allowing use of non-Unix forms of #!cmd', 0aH
	DB	'-X opt : set implementation-specific option', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CCE@ELHEAOKH@?9i?5?5?5?5?5?3?5inspect?5interactively?5a@
CONST	SEGMENT
??_C@_0CCE@ELHEAOKH@?9i?5?5?5?5?5?3?5inspect?5interactively?5a@ DB '-i   '
	DB	'  : inspect interactively after running script; forces a prom'
	DB	'pt even', 0aH, '         if stdin does not appear to be a ter'
	DB	'minal; also PYTHONINSPECT=x', 0aH, '-m mod : run library modu'
	DB	'le as a script (terminates option list)', 0aH, '-O     : opti'
	DB	'mize generated bytecode slightly; also PYTHONOPTIMIZE=x', 0aH
	DB	'-OO    : remove doc-strings in addition to the -O optimizatio'
	DB	'ns', 0aH, '-q     : don''t print version and copyright messag'
	DB	'es on interactive startup', 0aH, '-s     : don''t add user si'
	DB	'te directory to sys.path; also PYTHONNOUSERSITE', 0aH, '-S   '
	DB	'  : don''t imply ''import site'' on initialization', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CAO@BDKKHAC@Options?5and?5arguments?5?$CIand?5corre@
CONST	SEGMENT
??_C@_0CAO@BDKKHAC@Options?5and?5arguments?5?$CIand?5corre@ DB 'Options a'
	DB	'nd arguments (and corresponding environment variables):', 0aH
	DB	'-b     : issue warnings about str(bytes_instance), str(bytear'
	DB	'ray_instance)', 0aH, '         and comparing bytes/bytearray '
	DB	'with str. (-bb: issue errors)', 0aH, '-B     : don''t write .'
	DB	'py[co] files on import; also PYTHONDONTWRITEBYTECODE=x', 0aH, '-'
	DB	'c cmd : program passed in as string (terminates option list)', 0aH
	DB	'-d     : debug output from parser; also PYTHONDEBUG=x', 0aH, '-'
	DB	'E     : ignore PYTHON* environment variables (such as PYTHONP'
	DB	'ATH)', 0aH, '-h     : print this help message and exit (also '
	DB	'--help)', 0aH, 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
usage_line DQ	FLAT:??_C@_0EA@DDFOEECA@usage?3?5?$CFls?5?$FLoption?$FN?5?4?4?4?5?$FL?9c?5cmd?5@
usage_1	DQ	FLAT:??_C@_0CAO@BDKKHAC@Options?5and?5arguments?5?$CIand?5corre@
usage_2	DQ	FLAT:??_C@_0CCE@ELHEAOKH@?9i?5?5?5?5?5?3?5inspect?5interactively?5a@
usage_3	DQ	FLAT:??_C@_0CFC@NIJOBHPJ@?9u?5?5?5?5?5?3?5unbuffered?5binary?5stdou@
usage_4	DQ	FLAT:??_C@_0BII@FPIDEIJE@file?5?5?5?3?5program?5read?5from?5scrip@
usage_5	DQ	FLAT:??_C@_0BEA@BALBKLFN@PYTHONHOME?5?5?5?3?5alternate?5?$DMprefix@
usage_6	DQ	FLAT:??_C@_0PH@PPPCLIAI@PYTHONHASHSEED?3?5if?5this?5variable@
_DATA	ENDS
;	COMDAT ??_C@_0EA@DDFOEECA@usage?3?5?$CFls?5?$FLoption?$FN?5?4?4?4?5?$FL?9c?5cmd?5@
CONST	SEGMENT
??_C@_0EA@DDFOEECA@usage?3?5?$CFls?5?$FLoption?$FN?5?4?4?4?5?$FL?9c?5cmd?5@ DB 'u'
	DB	'sage: %ls [option] ... [-c cmd | -m mod | file | -] [arg] ...'
	DB	0aH, 00H					; `string'
CONST	ENDS
PUBLIC	??_C@_07CMJMHHJG@?$DMstdin?$DO?$AA@		; `string'
PUBLIC	??_C@_0CM@LPBAPCAP@?$CFls?3?5?8?$CFls?8?5is?5a?5directory?0?5canno@ ; `string'
PUBLIC	??_C@_0CK@KLLBLHEB@?$CFls?3?5can?8t?5open?5file?5?8?$CFs?8?3?5?$FLErrn@ ; `string'
PUBLIC	??_C@_0BI@PLNCLPPD@?$DMunprintable?5file?5name?$DO?$AA@ ; `string'
PUBLIC	??_C@_13BPINEIPE@?$AAr?$AA?$AA@			; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_15DMEDGHGK@?$AA?9?$AAm?$AA?$AA@		; `string'
PUBLIC	??_C@_15NMJMBAFJ@?$AA?9?$AAc?$AA?$AA@		; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0EH@JFFAKOEJ@Type?5?$CChelp?$CC?0?5?$CCcopyright?$CC?0?5?$CCcredi@ ; `string'
PUBLIC	??_C@_0BF@HCFAEEPL@PyParallel?5?$CFs?5on?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_13IMODFHAA@?$AA?9?$AA?$AA@		; `string'
PUBLIC	??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@		; `string'
PUBLIC	??_C@_0CJ@NCLJNGKO@not?5enough?5memory?5to?5copy?5PYTHON@ ; `string'
PUBLIC	??_C@_1BO@BIIJHIJI@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BB@HMANIOON@PYTHONNOUSERSITE?$AA@	; `string'
PUBLIC	??_C@_0BB@NFDOJAMJ@PYTHONUNBUFFERED?$AA@	; `string'
PUBLIC	??_C@_0O@DNGJAMOL@PYTHONINSPECT?$AA@		; `string'
PUBLIC	??_C@_0P@KBEEOCOJ@PyParallel?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_05MAFOEECJ@3?43?45?$AA@			; `string'
PUBLIC	??_C@_0CG@IAAIMCOI@not?5enough?5memory?5to?5copy?5?9c?5arg@ ; `string'
PUBLIC	??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@ ; `string'
PUBLIC	Py_Main
EXTRN	Py_Finalize:PROC
EXTRN	PyRun_AnyFileExFlags:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp_getc:PROC
EXTRN	PyMem_Free:PROC
EXTRN	__imp_strerror:PROC
EXTRN	_Py_wchar2char:PROC
EXTRN	__imp__errno:PROC
EXTRN	_Py_wfopen:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyImport_ImportModule:PROC
EXTRN	__imp_isatty:PROC
EXTRN	PySys_SetArgv:PROC
EXTRN	Py_GetVersion:PROC
EXTRN	Py_GetPlatform:PROC
EXTRN	Py_Initialize:PROC
EXTRN	Py_SetProgramName:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp__setmode:PROC
EXTRN	__imp_fileno:PROC
EXTRN	Py_FdIsInteractive:PROC
EXTRN	__imp_wcscmp:PROC
EXTRN	_PyOS_optind:DWORD
EXTRN	__imp_free:PROC
EXTRN	__imp_wcstok:PROC
EXTRN	__imp__wgetenv:PROC
EXTRN	__imp_getenv:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	Py_QuietFlag:DWORD
EXTRN	PySys_AddXOption:PROC
EXTRN	PySys_AddWarnOption:PROC
EXTRN	Py_VerboseFlag:DWORD
EXTRN	Py_UnbufferedStdioFlag:DWORD
EXTRN	Py_NoSiteFlag:DWORD
EXTRN	Py_NoUserSiteDirectory:DWORD
EXTRN	Py_DontWriteBytecodeFlag:DWORD
EXTRN	Py_OptimizeFlag:DWORD
EXTRN	Py_InteractiveFlag:DWORD
EXTRN	Py_InspectFlag:DWORD
EXTRN	Py_DebugFlag:DWORD
EXTRN	Py_BytesWarningFlag:DWORD
EXTRN	__ImageBase:BYTE
EXTRN	__imp_wcscpy:PROC
EXTRN	Py_FatalError:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_wcslen:PROC
EXTRN	_PyOS_optarg:QWORD
EXTRN	_PyOS_ResetGetOpt:PROC
EXTRN	PySys_ResetWarnOptions:PROC
EXTRN	_PyRandom_Init:PROC
EXTRN	Py_HashRandomizationFlag:DWORD
EXTRN	Py_IgnoreEnvironmentFlag:DWORD
EXTRN	_PyOS_GetOpt:PROC
EXTRN	_PyOS_opterr:DWORD
EXTRN	_PyParallel_Init:PROC
EXTRN	__imp___iob_func:PROC
_BSS	SEGMENT
orig_argv DQ	01H DUP (?)
orig_argc DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\main.c
pdata	SEGMENT
$pdata$Py_Main DD imagerel $LN92
	DD	imagerel $LN92+3334
	DD	imagerel $unwind$Py_Main
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_Main DD 021001H
	DD	02b0110H
xdata	ENDS
;	COMDAT ??_C@_07CMJMHHJG@?$DMstdin?$DO?$AA@
CONST	SEGMENT
??_C@_07CMJMHHJG@?$DMstdin?$DO?$AA@ DB '<stdin>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LPBAPCAP@?$CFls?3?5?8?$CFls?8?5is?5a?5directory?0?5canno@
CONST	SEGMENT
??_C@_0CM@LPBAPCAP@?$CFls?3?5?8?$CFls?8?5is?5a?5directory?0?5canno@ DB '%'
	DB	'ls: ''%ls'' is a directory, cannot continue', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KLLBLHEB@?$CFls?3?5can?8t?5open?5file?5?8?$CFs?8?3?5?$FLErrn@
CONST	SEGMENT
??_C@_0CK@KLLBLHEB@?$CFls?3?5can?8t?5open?5file?5?8?$CFs?8?3?5?$FLErrn@ DB '%'
	DB	'ls: can''t open file ''%s'': [Errno %d] %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PLNCLPPD@?$DMunprintable?5file?5name?$DO?$AA@
CONST	SEGMENT
??_C@_0BI@PLNCLPPD@?$DMunprintable?5file?5name?$DO?$AA@ DB '<unprintable '
	DB	'file name>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13BPINEIPE@?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_13BPINEIPE@?$AAr?$AA?$AA@ DB 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_15DMEDGHGK@?$AA?9?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_15DMEDGHGK@?$AA?9?$AAm?$AA?$AA@ DB '-', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15NMJMBAFJ@?$AA?9?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_15NMJMBAFJ@?$AA?9?$AAc?$AA?$AA@ DB '-', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@JFFAKOEJ@Type?5?$CChelp?$CC?0?5?$CCcopyright?$CC?0?5?$CCcredi@
CONST	SEGMENT
??_C@_0EH@JFFAKOEJ@Type?5?$CChelp?$CC?0?5?$CCcopyright?$CC?0?5?$CCcredi@ DB 'T'
	DB	'ype "help", "copyright", "credits" or "license" for more info'
	DB	'rmation.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HCFAEEPL@PyParallel?5?$CFs?5on?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BF@HCFAEEPL@PyParallel?5?$CFs?5on?5?$CFs?6?$AA@ DB 'PyParallel %s '
	DB	'on %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13IMODFHAA@?$AA?9?$AA?$AA@
CONST	SEGMENT
??_C@_13IMODFHAA@?$AA?9?$AA?$AA@ DB '-', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@
CONST	SEGMENT
??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@ DB ',', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NCLJNGKO@not?5enough?5memory?5to?5copy?5PYTHON@
CONST	SEGMENT
??_C@_0CJ@NCLJNGKO@not?5enough?5memory?5to?5copy?5PYTHON@ DB 'not enough '
	DB	'memory to copy PYTHONWARNINGS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@BIIJHIJI@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@BIIJHIJI@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AAS?$AA?$AA@ DB 'P'
	DB	00H, 'Y', 00H, 'T', 00H, 'H', 00H, 'O', 00H, 'N', 00H, 'W', 00H
	DB	'A', 00H, 'R', 00H, 'N', 00H, 'I', 00H, 'N', 00H, 'G', 00H, 'S'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HMANIOON@PYTHONNOUSERSITE?$AA@
CONST	SEGMENT
??_C@_0BB@HMANIOON@PYTHONNOUSERSITE?$AA@ DB 'PYTHONNOUSERSITE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NFDOJAMJ@PYTHONUNBUFFERED?$AA@
CONST	SEGMENT
??_C@_0BB@NFDOJAMJ@PYTHONUNBUFFERED?$AA@ DB 'PYTHONUNBUFFERED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DNGJAMOL@PYTHONINSPECT?$AA@
CONST	SEGMENT
??_C@_0O@DNGJAMOL@PYTHONINSPECT?$AA@ DB 'PYTHONINSPECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBEEOCOJ@PyParallel?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0P@KBEEOCOJ@PyParallel?5?$CFs?6?$AA@ DB 'PyParallel %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAFOEECJ@3?43?45?$AA@
CONST	SEGMENT
??_C@_05MAFOEECJ@3?43?45?$AA@ DB '3.3.5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IAAIMCOI@not?5enough?5memory?5to?5copy?5?9c?5arg@
CONST	SEGMENT
??_C@_0CG@IAAIMCOI@not?5enough?5memory?5to?5copy?5?9c?5arg@ DB 'not enoug'
	DB	'h memory to copy -c argument', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@ DB 'b'
	DB	00H, 'B', 00H, 'c', 00H, ':', 00H, 'd', 00H, 'E', 00H, 'h', 00H
	DB	'i', 00H, 'J', 00H, 'm', 00H, ':', 00H, 'O', 00H, 'q', 00H, 'R'
	DB	00H, 's', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'v', 00H, 'V', 00H
	DB	'W', 00H, ':', 00H, 'x', 00H, 'X', 00H, ':', 00H, '?', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Py_Main
_TEXT	SEGMENT
p$ = 48
sts$ = 56
saw_unbuffered_flag$ = 60
help$ = 64
command$ = 72
stdin_is_interactive$ = 80
fp$ = 88
skipfirstline$ = 96
wp$ = 104
cf$ = 112
module$ = 120
version$ = 128
c$ = 132
filename$ = 136
len$121264 = 144
buf$121309 = 152
warning$121310 = 160
v$121358 = 168
cfilename_buffer$121377 = 176
cfilename$121378 = 184
err$121379 = 192
ch$121389 = 196
sb$121395 = 200
tv130 = 248
tv164 = 256
tv172 = 264
tv180 = 272
tv276 = 280
tv278 = 288
tv361 = 296
tv380 = 304
tv423 = 312
tv439 = 320
argc$ = 352
argv$ = 360
Py_Main	PROC						; COMDAT

; 317  : {

$LN92:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H

; 318  :     int c;
; 319  :     int sts;
; 320  :     wchar_t *command = NULL;

  00010	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR command$[rsp], 0

; 321  :     wchar_t *filename = NULL;

  00019	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR filename$[rsp], 0

; 322  :     wchar_t *module = NULL;

  00025	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR module$[rsp], 0

; 323  :     FILE *fp = stdin;

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00034	48 89 44 24 58	 mov	 QWORD PTR fp$[rsp], rax

; 324  :     char *p;
; 325  : #ifdef MS_WINDOWS
; 326  :     wchar_t *wp;
; 327  : #endif
; 328  :     int skipfirstline = 0;

  00039	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR skipfirstline$[rsp], 0

; 329  :     int stdin_is_interactive = 0;

  00041	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR stdin_is_interactive$[rsp], 0

; 330  :     int help = 0;

  00049	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR help$[rsp], 0

; 331  :     int version = 0;

  00051	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR version$[rsp], 0

; 332  :     int saw_unbuffered_flag = 0;

  0005c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR saw_unbuffered_flag$[rsp], 0

; 333  :     PyCompilerFlags cf;
; 334  : 
; 335  :     cf.cf_flags = 0;

  00064	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR cf$[rsp], 0

; 336  : 
; 337  :     orig_argc = argc;           /* For Py_GetArgcArgv() */

  0006c	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00073	89 05 00 00 00
	00		 mov	 DWORD PTR orig_argc, eax

; 338  :     orig_argv = argv;

  00079	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00081	48 89 05 00 00
	00 00		 mov	 QWORD PTR orig_argv, rax

; 339  : 
; 340  : #ifdef WITH_PARALLEL
; 341  :     _PyParallel_Init();

  00088	e8 00 00 00 00	 call	 _PyParallel_Init

; 342  : #endif
; 343  : 
; 344  :     /* Hash randomization needed early for all string operations
; 345  :        (including -W and -X options). */
; 346  :     _PyOS_opterr = 0;  /* prevent printing the error in 1st pass */

  0008d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _PyOS_opterr, 0
$LN75@Py_Main:

; 347  :     while ((c = _PyOS_GetOpt(argc, argv, PROGRAM_OPTS)) != EOF) {

  00097	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@
  0009e	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000a6	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  000ad	e8 00 00 00 00	 call	 _PyOS_GetOpt
  000b2	89 84 24 84 00
	00 00		 mov	 DWORD PTR c$[rsp], eax
  000b9	83 bc 24 84 00
	00 00 ff	 cmp	 DWORD PTR c$[rsp], -1
  000c1	74 32		 je	 SHORT $LN74@Py_Main

; 348  :         if (c == 'm' || c == 'c') {

  000c3	83 bc 24 84 00
	00 00 6d	 cmp	 DWORD PTR c$[rsp], 109	; 0000006dH
  000cb	74 0a		 je	 SHORT $LN72@Py_Main
  000cd	83 bc 24 84 00
	00 00 63	 cmp	 DWORD PTR c$[rsp], 99	; 00000063H
  000d5	75 02		 jne	 SHORT $LN73@Py_Main
$LN72@Py_Main:

; 349  :             /* -c / -m is the last option: following arguments are
; 350  :                not interpreter options. */
; 351  :             break;

  000d7	eb 1c		 jmp	 SHORT $LN74@Py_Main
$LN73@Py_Main:

; 352  :         }
; 353  :         if (c == 'E') {

  000d9	83 bc 24 84 00
	00 00 45	 cmp	 DWORD PTR c$[rsp], 69	; 00000045H
  000e1	75 10		 jne	 SHORT $LN71@Py_Main

; 354  :             Py_IgnoreEnvironmentFlag++;

  000e3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_IgnoreEnvironmentFlag
  000e9	ff c0		 inc	 eax
  000eb	89 05 00 00 00
	00		 mov	 DWORD PTR Py_IgnoreEnvironmentFlag, eax

; 355  :             break;

  000f1	eb 02		 jmp	 SHORT $LN74@Py_Main
$LN71@Py_Main:

; 356  :         }
; 357  :     }

  000f3	eb a2		 jmp	 SHORT $LN75@Py_Main
$LN74@Py_Main:

; 358  : 
; 359  :     Py_HashRandomizationFlag = 1;

  000f5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR Py_HashRandomizationFlag, 1

; 360  :     _PyRandom_Init();

  000ff	e8 00 00 00 00	 call	 _PyRandom_Init

; 361  : 
; 362  :     PySys_ResetWarnOptions();

  00104	e8 00 00 00 00	 call	 PySys_ResetWarnOptions

; 363  :     _PyOS_ResetGetOpt();

  00109	e8 00 00 00 00	 call	 _PyOS_ResetGetOpt
$LN70@Py_Main:

; 364  : 
; 365  :     while ((c = _PyOS_GetOpt(argc, argv, PROGRAM_OPTS)) != EOF) {

  0010e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1DG@HILFBDGJ@?$AAb?$AAB?$AAc?$AA?3?$AAd?$AAE?$AAh?$AAi?$AAJ?$AAm?$AA?3?$AAO?$AAq?$AAR?$AAs?$AAS?$AAt?$AAu?$AAv?$AAV?$AAW?$AA?3?$AAx?$AAX?$AA?3?$AA?$DP?$AA?$AA@
  00115	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0011d	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00124	e8 00 00 00 00	 call	 _PyOS_GetOpt
  00129	89 84 24 84 00
	00 00		 mov	 DWORD PTR c$[rsp], eax
  00130	83 bc 24 84 00
	00 00 ff	 cmp	 DWORD PTR c$[rsp], -1
  00138	0f 84 3a 02 00
	00		 je	 $LN69@Py_Main

; 366  :         if (c == 'c') {

  0013e	83 bc 24 84 00
	00 00 63	 cmp	 DWORD PTR c$[rsp], 99	; 00000063H
  00146	0f 85 88 00 00
	00		 jne	 $LN68@Py_Main

; 367  :             size_t len;
; 368  :             /* -c is the last option; following arguments
; 369  :                that look like options are left for the
; 370  :                command to interpret. */
; 371  : 
; 372  :             len = wcslen(_PyOS_optarg) + 1 + 1;

  0014c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_optarg
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00159	48 83 c0 02	 add	 rax, 2
  0015d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR len$121264[rsp], rax

; 373  :             command = (wchar_t *)malloc(sizeof(wchar_t) * len);

  00165	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$121264[rsp]
  0016d	48 03 c0	 add	 rax, rax
  00170	48 8b c8	 mov	 rcx, rax
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00179	48 89 44 24 48	 mov	 QWORD PTR command$[rsp], rax

; 374  :             if (command == NULL)

  0017e	48 83 7c 24 48
	00		 cmp	 QWORD PTR command$[rsp], 0
  00184	75 0c		 jne	 SHORT $LN67@Py_Main

; 375  :                 Py_FatalError(
; 376  :                    "not enough memory to copy -c argument");

  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@IAAIMCOI@not?5enough?5memory?5to?5copy?5?9c?5arg@
  0018d	e8 00 00 00 00	 call	 Py_FatalError
$LN67@Py_Main:

; 377  :             wcscpy(command, _PyOS_optarg);

  00192	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyOS_optarg
  00199	48 8b 4c 24 48	 mov	 rcx, QWORD PTR command$[rsp]
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 378  :             command[len - 2] = '\n';

  001a4	b8 0a 00 00 00	 mov	 eax, 10
  001a9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR command$[rsp]
  001ae	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR len$121264[rsp]
  001b6	66 89 44 51 fc	 mov	 WORD PTR [rcx+rdx*2-4], ax

; 379  :             command[len - 1] = 0;

  001bb	33 c0		 xor	 eax, eax
  001bd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR command$[rsp]
  001c2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR len$121264[rsp]
  001ca	66 89 44 51 fe	 mov	 WORD PTR [rcx+rdx*2-2], ax

; 380  :             break;

  001cf	e9 a4 01 00 00	 jmp	 $LN69@Py_Main
$LN68@Py_Main:

; 381  :         }
; 382  : 
; 383  :         if (c == 'm') {

  001d4	83 bc 24 84 00
	00 00 6d	 cmp	 DWORD PTR c$[rsp], 109	; 0000006dH
  001dc	75 11		 jne	 SHORT $LN66@Py_Main

; 384  :             /* -m is the last option; following arguments
; 385  :                that look like options are left for the
; 386  :                module to interpret. */
; 387  :             module = _PyOS_optarg;

  001de	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyOS_optarg
  001e5	48 89 44 24 78	 mov	 QWORD PTR module$[rsp], rax

; 388  :             break;

  001ea	e9 89 01 00 00	 jmp	 $LN69@Py_Main
$LN66@Py_Main:

; 389  :         }
; 390  : 
; 391  :         switch (c) {

  001ef	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  001f6	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv130[rsp], eax
  001fd	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv130[rsp]
  00204	83 e8 3f	 sub	 eax, 63			; 0000003fH
  00207	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv130[rsp], eax
  0020e	83 bc 24 f8 00
	00 00 39	 cmp	 DWORD PTR tv130[rsp], 57 ; 00000039H
  00216	0f 87 3d 01 00
	00		 ja	 $LN45@Py_Main
  0021c	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR tv130[rsp]
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0022b	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN90@Py_Main[rcx+rax]
  00233	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN91@Py_Main[rcx+rax*4]
  0023a	48 03 c1	 add	 rax, rcx
  0023d	ff e0		 jmp	 rax
$LN63@Py_Main:

; 392  :         case 'b':
; 393  :             Py_BytesWarningFlag++;

  0023f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_BytesWarningFlag
  00245	ff c0		 inc	 eax
  00247	89 05 00 00 00
	00		 mov	 DWORD PTR Py_BytesWarningFlag, eax

; 394  :             break;

  0024d	e9 21 01 00 00	 jmp	 $LN64@Py_Main
$LN62@Py_Main:

; 395  : 
; 396  :         case 'd':
; 397  :             Py_DebugFlag++;

  00252	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_DebugFlag
  00258	ff c0		 inc	 eax
  0025a	89 05 00 00 00
	00		 mov	 DWORD PTR Py_DebugFlag, eax

; 398  :             break;

  00260	e9 0e 01 00 00	 jmp	 $LN64@Py_Main
$LN61@Py_Main:

; 399  : 
; 400  :         case 'i':
; 401  :             Py_InspectFlag++;

  00265	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_InspectFlag
  0026b	ff c0		 inc	 eax
  0026d	89 05 00 00 00
	00		 mov	 DWORD PTR Py_InspectFlag, eax

; 402  :             Py_InteractiveFlag++;

  00273	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_InteractiveFlag
  00279	ff c0		 inc	 eax
  0027b	89 05 00 00 00
	00		 mov	 DWORD PTR Py_InteractiveFlag, eax

; 403  :             break;

  00281	e9 ed 00 00 00	 jmp	 $LN64@Py_Main
$LN60@Py_Main:

; 404  : 
; 405  :         /* case 'J': reserved for Jython */
; 406  : 
; 407  :         case 'O':
; 408  :             Py_OptimizeFlag++;

  00286	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_OptimizeFlag
  0028c	ff c0		 inc	 eax
  0028e	89 05 00 00 00
	00		 mov	 DWORD PTR Py_OptimizeFlag, eax

; 409  :             break;

  00294	e9 da 00 00 00	 jmp	 $LN64@Py_Main
$LN59@Py_Main:

; 410  : 
; 411  :         case 'B':
; 412  :             Py_DontWriteBytecodeFlag++;

  00299	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_DontWriteBytecodeFlag
  0029f	ff c0		 inc	 eax
  002a1	89 05 00 00 00
	00		 mov	 DWORD PTR Py_DontWriteBytecodeFlag, eax

; 413  :             break;

  002a7	e9 c7 00 00 00	 jmp	 $LN64@Py_Main
$LN58@Py_Main:

; 414  : 
; 415  :         case 's':
; 416  :             Py_NoUserSiteDirectory++;

  002ac	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_NoUserSiteDirectory
  002b2	ff c0		 inc	 eax
  002b4	89 05 00 00 00
	00		 mov	 DWORD PTR Py_NoUserSiteDirectory, eax

; 417  :             break;

  002ba	e9 b4 00 00 00	 jmp	 $LN64@Py_Main
$LN57@Py_Main:

; 418  : 
; 419  :         case 'S':
; 420  :             Py_NoSiteFlag++;

  002bf	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_NoSiteFlag
  002c5	ff c0		 inc	 eax
  002c7	89 05 00 00 00
	00		 mov	 DWORD PTR Py_NoSiteFlag, eax

; 421  :             break;

  002cd	e9 a1 00 00 00	 jmp	 $LN64@Py_Main
$LN56@Py_Main:

; 422  : 
; 423  :         case 'E':
; 424  :             /* Already handled above */
; 425  :             break;

  002d2	e9 9c 00 00 00	 jmp	 $LN64@Py_Main
$LN55@Py_Main:

; 426  : 
; 427  :         case 't':
; 428  :             /* ignored for backwards compatibility */
; 429  :             break;

  002d7	e9 97 00 00 00	 jmp	 $LN64@Py_Main
$LN54@Py_Main:

; 430  : 
; 431  :         case 'u':
; 432  :             Py_UnbufferedStdioFlag = 1;

  002dc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR Py_UnbufferedStdioFlag, 1

; 433  :             saw_unbuffered_flag = 1;

  002e6	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR saw_unbuffered_flag$[rsp], 1

; 434  :             break;

  002ee	e9 80 00 00 00	 jmp	 $LN64@Py_Main
$LN53@Py_Main:

; 435  : 
; 436  :         case 'v':
; 437  :             Py_VerboseFlag++;

  002f3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_VerboseFlag
  002f9	ff c0		 inc	 eax
  002fb	89 05 00 00 00
	00		 mov	 DWORD PTR Py_VerboseFlag, eax

; 438  :             break;

  00301	eb 70		 jmp	 SHORT $LN64@Py_Main
$LN52@Py_Main:

; 439  : 
; 440  :         case 'x':
; 441  :             skipfirstline = 1;

  00303	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR skipfirstline$[rsp], 1

; 442  :             break;

  0030b	eb 66		 jmp	 SHORT $LN64@Py_Main
$LN51@Py_Main:

; 443  : 
; 444  :         case 'h':
; 445  :         case '?':
; 446  :             help++;

  0030d	8b 44 24 40	 mov	 eax, DWORD PTR help$[rsp]
  00311	ff c0		 inc	 eax
  00313	89 44 24 40	 mov	 DWORD PTR help$[rsp], eax

; 447  :             break;

  00317	eb 5a		 jmp	 SHORT $LN64@Py_Main
$LN50@Py_Main:

; 448  : 
; 449  :         case 'V':
; 450  :             version++;

  00319	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR version$[rsp]
  00320	ff c0		 inc	 eax
  00322	89 84 24 80 00
	00 00		 mov	 DWORD PTR version$[rsp], eax

; 451  :             break;

  00329	eb 48		 jmp	 SHORT $LN64@Py_Main
$LN49@Py_Main:

; 452  : 
; 453  :         case 'W':
; 454  :             PySys_AddWarnOption(_PyOS_optarg);

  0032b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_optarg
  00332	e8 00 00 00 00	 call	 PySys_AddWarnOption

; 455  :             break;

  00337	eb 3a		 jmp	 SHORT $LN64@Py_Main
$LN48@Py_Main:

; 456  : 
; 457  :         case 'X':
; 458  :             PySys_AddXOption(_PyOS_optarg);

  00339	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_optarg
  00340	e8 00 00 00 00	 call	 PySys_AddXOption

; 459  :             break;

  00345	eb 2c		 jmp	 SHORT $LN64@Py_Main
$LN47@Py_Main:

; 460  : 
; 461  :         case 'q':
; 462  :             Py_QuietFlag++;

  00347	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_QuietFlag
  0034d	ff c0		 inc	 eax
  0034f	89 05 00 00 00
	00		 mov	 DWORD PTR Py_QuietFlag, eax

; 463  :             break;

  00355	eb 1c		 jmp	 SHORT $LN64@Py_Main
$LN46@Py_Main:

; 464  : 
; 465  :         case 'R':
; 466  :             /* Ignored */
; 467  :             break;

  00357	eb 1a		 jmp	 SHORT $LN64@Py_Main
$LN45@Py_Main:

; 468  : 
; 469  :         /* This space reserved for other options */
; 470  : 
; 471  :         default:
; 472  :             return usage(2, argv[0]);

  00359	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00361	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00364	b9 02 00 00 00	 mov	 ecx, 2
  00369	e8 00 00 00 00	 call	 usage
  0036e	e9 02 09 00 00	 jmp	 $LN76@Py_Main
$LN64@Py_Main:

; 473  :             /*NOTREACHED*/
; 474  : 
; 475  :         }
; 476  :     }

  00373	e9 96 fd ff ff	 jmp	 $LN70@Py_Main
$LN69@Py_Main:

; 477  : 
; 478  :     if (help)

  00378	83 7c 24 40 00	 cmp	 DWORD PTR help$[rsp], 0
  0037d	74 17		 je	 SHORT $LN44@Py_Main

; 479  :         return usage(0, argv[0]);

  0037f	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00387	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0038a	33 c9		 xor	 ecx, ecx
  0038c	e8 00 00 00 00	 call	 usage
  00391	e9 df 08 00 00	 jmp	 $LN76@Py_Main
$LN44@Py_Main:

; 480  : 
; 481  :     if (version) {

  00396	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR version$[rsp], 0
  0039e	74 28		 je	 SHORT $LN43@Py_Main

; 482  :         fprintf(stderr, "PyParallel %s\n", PY_VERSION);

  003a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  003a6	48 83 c0 60	 add	 rax, 96			; 00000060H
  003aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05MAFOEECJ@3?43?45?$AA@
  003b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@KBEEOCOJ@PyParallel?5?$CFs?6?$AA@
  003b8	48 8b c8	 mov	 rcx, rax
  003bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 483  :         return 0;

  003c1	33 c0		 xor	 eax, eax
  003c3	e9 ad 08 00 00	 jmp	 $LN76@Py_Main
$LN43@Py_Main:

; 484  :     }
; 485  : 
; 486  :     if (!Py_InspectFlag &&
; 487  :         (p = Py_GETENV("PYTHONINSPECT")) && *p != '\0')

  003c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_InspectFlag, 0
  003cf	75 57		 jne	 SHORT $LN42@Py_Main
  003d1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  003d8	74 0e		 je	 SHORT $LN78@Py_Main
  003da	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv164[rsp], 0
  003e6	eb 15		 jmp	 SHORT $LN79@Py_Main
$LN78@Py_Main:
  003e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DNGJAMOL@PYTHONINSPECT?$AA@
  003ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  003f5	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv164[rsp], rax
$LN79@Py_Main:
  003fd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv164[rsp]
  00405	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax
  0040a	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  00410	74 16		 je	 SHORT $LN42@Py_Main
  00412	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00417	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0041a	85 c0		 test	 eax, eax
  0041c	74 0a		 je	 SHORT $LN42@Py_Main

; 488  :         Py_InspectFlag = 1;

  0041e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR Py_InspectFlag, 1
$LN42@Py_Main:

; 489  :     if (!saw_unbuffered_flag &&
; 490  :         (p = Py_GETENV("PYTHONUNBUFFERED")) && *p != '\0')

  00428	83 7c 24 3c 00	 cmp	 DWORD PTR saw_unbuffered_flag$[rsp], 0
  0042d	75 57		 jne	 SHORT $LN41@Py_Main
  0042f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  00436	74 0e		 je	 SHORT $LN80@Py_Main
  00438	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv172[rsp], 0
  00444	eb 15		 jmp	 SHORT $LN81@Py_Main
$LN80@Py_Main:
  00446	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NFDOJAMJ@PYTHONUNBUFFERED?$AA@
  0044d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  00453	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv172[rsp], rax
$LN81@Py_Main:
  0045b	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv172[rsp]
  00463	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax
  00468	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  0046e	74 16		 je	 SHORT $LN41@Py_Main
  00470	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00475	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00478	85 c0		 test	 eax, eax
  0047a	74 0a		 je	 SHORT $LN41@Py_Main

; 491  :         Py_UnbufferedStdioFlag = 1;

  0047c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR Py_UnbufferedStdioFlag, 1
$LN41@Py_Main:

; 492  : 
; 493  :     if (!Py_NoUserSiteDirectory &&
; 494  :         (p = Py_GETENV("PYTHONNOUSERSITE")) && *p != '\0')

  00486	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_NoUserSiteDirectory, 0
  0048d	75 57		 jne	 SHORT $LN40@Py_Main
  0048f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  00496	74 0e		 je	 SHORT $LN82@Py_Main
  00498	48 c7 84 24 10
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv180[rsp], 0
  004a4	eb 15		 jmp	 SHORT $LN83@Py_Main
$LN82@Py_Main:
  004a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@HMANIOON@PYTHONNOUSERSITE?$AA@
  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  004b3	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv180[rsp], rax
$LN83@Py_Main:
  004bb	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv180[rsp]
  004c3	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax
  004c8	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  004ce	74 16		 je	 SHORT $LN40@Py_Main
  004d0	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  004d5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004d8	85 c0		 test	 eax, eax
  004da	74 0a		 je	 SHORT $LN40@Py_Main

; 495  :         Py_NoUserSiteDirectory = 1;

  004dc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR Py_NoUserSiteDirectory, 1
$LN40@Py_Main:

; 496  : 
; 497  : #ifdef MS_WINDOWS
; 498  :     if (!Py_IgnoreEnvironmentFlag && (wp = _wgetenv(L"PYTHONWARNINGS")) &&
; 499  :         *wp != L'\0') {

  004e6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  004ed	0f 85 d7 00 00
	00		 jne	 $LN39@Py_Main
  004f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@BIIJHIJI@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AAS?$AA?$AA@
  004fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wgetenv
  00500	48 89 44 24 68	 mov	 QWORD PTR wp$[rsp], rax
  00505	48 83 7c 24 68
	00		 cmp	 QWORD PTR wp$[rsp], 0
  0050b	0f 84 b9 00 00
	00		 je	 $LN39@Py_Main
  00511	48 8b 44 24 68	 mov	 rax, QWORD PTR wp$[rsp]
  00516	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00519	85 c0		 test	 eax, eax
  0051b	0f 84 a9 00 00
	00		 je	 $LN39@Py_Main

; 500  :         wchar_t *buf, *warning;
; 501  : 
; 502  :         buf = (wchar_t *)malloc((wcslen(wp) + 1) * sizeof(wchar_t));

  00521	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wp$[rsp]
  00526	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  0052c	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  00531	48 8b c8	 mov	 rcx, rax
  00534	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0053a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR buf$121309[rsp], rax

; 503  :         if (buf == NULL)

  00542	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR buf$121309[rsp], 0
  0054b	75 0c		 jne	 SHORT $LN38@Py_Main

; 504  :             Py_FatalError(
; 505  :                "not enough memory to copy PYTHONWARNINGS");

  0054d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@NCLJNGKO@not?5enough?5memory?5to?5copy?5PYTHON@
  00554	e8 00 00 00 00	 call	 Py_FatalError
$LN38@Py_Main:

; 506  :         wcscpy(buf, wp);

  00559	48 8b 54 24 68	 mov	 rdx, QWORD PTR wp$[rsp]
  0055e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR buf$121309[rsp]
  00566	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 507  :         for (warning = wcstok(buf, L",");
; 508  :              warning != NULL;
; 509  :              warning = wcstok(NULL, L",")) {

  0056c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@
  00573	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR buf$121309[rsp]
  0057b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstok
  00581	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR warning$121310[rsp], rax
  00589	eb 17		 jmp	 SHORT $LN37@Py_Main
$LN36@Py_Main:
  0058b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@
  00592	33 c9		 xor	 ecx, ecx
  00594	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstok
  0059a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR warning$121310[rsp], rax
$LN37@Py_Main:
  005a2	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR warning$121310[rsp], 0
  005ab	74 0f		 je	 SHORT $LN35@Py_Main

; 510  :             PySys_AddWarnOption(warning);

  005ad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR warning$121310[rsp]
  005b5	e8 00 00 00 00	 call	 PySys_AddWarnOption

; 511  :         }

  005ba	eb cf		 jmp	 SHORT $LN36@Py_Main
$LN35@Py_Main:

; 512  :         free(buf);

  005bc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR buf$121309[rsp]
  005c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN39@Py_Main:

; 513  :     }
; 514  : #else
; 515  :     if ((p = Py_GETENV("PYTHONWARNINGS")) && *p != '\0') {
; 516  :         char *buf, *oldloc;
; 517  :         PyObject *unicode;
; 518  : 
; 519  :         /* settle for strtok here as there's no one standard
; 520  :            C89 wcstok */
; 521  :         buf = (char *)malloc(strlen(p) + 1);
; 522  :         if (buf == NULL)
; 523  :             Py_FatalError(
; 524  :                "not enough memory to copy PYTHONWARNINGS");
; 525  :         strcpy(buf, p);
; 526  :         oldloc = strdup(setlocale(LC_ALL, NULL));
; 527  :         setlocale(LC_ALL, "");
; 528  :         for (p = strtok(buf, ","); p != NULL; p = strtok(NULL, ",")) {
; 529  : #ifdef __APPLE__
; 530  :             /* Use utf-8 on Mac OS X */
; 531  :             unicode = PyUnicode_FromString(p);
; 532  : #else
; 533  :             unicode = PyUnicode_DecodeLocale(p, "surrogateescape");
; 534  : #endif
; 535  :             if (unicode == NULL) {
; 536  :                 /* ignore errors */
; 537  :                 PyErr_Clear();
; 538  :                 continue;
; 539  :             }
; 540  :             PySys_AddWarnOptionUnicode(unicode);
; 541  :             Py_DECREF(unicode);
; 542  :         }
; 543  :         setlocale(LC_ALL, oldloc);
; 544  :         free(oldloc);
; 545  :         free(buf);
; 546  :     }
; 547  : #endif
; 548  : 
; 549  :     if (command == NULL && module == NULL && _PyOS_optind < argc &&
; 550  :         wcscmp(argv[_PyOS_optind], L"-") != 0)

  005ca	48 83 7c 24 48
	00		 cmp	 QWORD PTR command$[rsp], 0
  005d0	75 56		 jne	 SHORT $LN34@Py_Main
  005d2	48 83 7c 24 78
	00		 cmp	 QWORD PTR module$[rsp], 0
  005d8	75 4e		 jne	 SHORT $LN34@Py_Main
  005da	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  005e1	39 05 00 00 00
	00		 cmp	 DWORD PTR _PyOS_optind, eax
  005e7	7d 3f		 jge	 SHORT $LN34@Py_Main
  005e9	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR _PyOS_optind
  005f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13IMODFHAA@?$AA?9?$AA?$AA@
  005f7	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005ff	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00603	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscmp
  00609	85 c0		 test	 eax, eax
  0060b	74 1b		 je	 SHORT $LN34@Py_Main

; 551  :     {
; 552  : #ifdef __VMS
; 553  :         filename = decc$translate_vms(argv[_PyOS_optind]);
; 554  :         if (filename == (char *)0 || filename == (char *)-1)
; 555  :             filename = argv[_PyOS_optind];
; 556  : 
; 557  : #else
; 558  :         filename = argv[_PyOS_optind];

  0060d	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR _PyOS_optind
  00614	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0061c	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00620	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR filename$[rsp], rax
$LN34@Py_Main:

; 559  : #endif
; 560  :     }
; 561  : 
; 562  :     stdin_is_interactive = Py_FdIsInteractive(stdin, (char *)0);

  00628	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0062e	33 d2		 xor	 edx, edx
  00630	48 8b c8	 mov	 rcx, rax
  00633	e8 00 00 00 00	 call	 Py_FdIsInteractive
  00638	89 44 24 50	 mov	 DWORD PTR stdin_is_interactive$[rsp], eax

; 563  : 
; 564  : #if defined(MS_WINDOWS) || defined(__CYGWIN__)
; 565  :     /* don't translate newlines (\r\n <=> \n) */
; 566  :     _setmode(fileno(stdin), O_BINARY);

  0063c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00642	48 8b c8	 mov	 rcx, rax
  00645	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0064b	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00650	8b c8		 mov	 ecx, eax
  00652	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode

; 567  :     _setmode(fileno(stdout), O_BINARY);

  00658	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0065e	48 83 c0 30	 add	 rax, 48			; 00000030H
  00662	48 8b c8	 mov	 rcx, rax
  00665	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0066b	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00670	8b c8		 mov	 ecx, eax
  00672	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode

; 568  :     _setmode(fileno(stderr), O_BINARY);

  00678	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0067e	48 83 c0 60	 add	 rax, 96			; 00000060H
  00682	48 8b c8	 mov	 rcx, rax
  00685	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0068b	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00690	8b c8		 mov	 ecx, eax
  00692	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode

; 569  : #endif
; 570  : 
; 571  :     if (Py_UnbufferedStdioFlag) {

  00698	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_UnbufferedStdioFlag, 0
  0069f	74 61		 je	 SHORT $LN33@Py_Main

; 572  : #ifdef HAVE_SETVBUF
; 573  :         setvbuf(stdin,  (char *)NULL, _IONBF, BUFSIZ);

  006a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  006a7	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  006ad	41 b8 04 00 00
	00		 mov	 r8d, 4
  006b3	33 d2		 xor	 edx, edx
  006b5	48 8b c8	 mov	 rcx, rax
  006b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf

; 574  :         setvbuf(stdout, (char *)NULL, _IONBF, BUFSIZ);

  006be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  006c4	48 83 c0 30	 add	 rax, 48			; 00000030H
  006c8	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  006ce	41 b8 04 00 00
	00		 mov	 r8d, 4
  006d4	33 d2		 xor	 edx, edx
  006d6	48 8b c8	 mov	 rcx, rax
  006d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf

; 575  :         setvbuf(stderr, (char *)NULL, _IONBF, BUFSIZ);

  006df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  006e5	48 83 c0 60	 add	 rax, 96			; 00000060H
  006e9	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  006ef	41 b8 04 00 00
	00		 mov	 r8d, 4
  006f5	33 d2		 xor	 edx, edx
  006f7	48 8b c8	 mov	 rcx, rax
  006fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf
  00700	eb 2a		 jmp	 SHORT $LN32@Py_Main
$LN33@Py_Main:

; 576  : #else /* !HAVE_SETVBUF */
; 577  :         setbuf(stdin,  (char *)NULL);
; 578  :         setbuf(stdout, (char *)NULL);
; 579  :         setbuf(stderr, (char *)NULL);
; 580  : #endif /* !HAVE_SETVBUF */
; 581  :     }
; 582  :     else if (Py_InteractiveFlag) {

  00702	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_InteractiveFlag, 0
  00709	74 21		 je	 SHORT $LN31@Py_Main

; 583  : #ifdef MS_WINDOWS
; 584  :         /* Doesn't have to have line-buffered -- use unbuffered */
; 585  :         /* Any set[v]buf(stdin, ...) screws up Tkinter :-( */
; 586  :         setvbuf(stdout, (char *)NULL, _IONBF, BUFSIZ);

  0070b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00711	48 83 c0 30	 add	 rax, 48			; 00000030H
  00715	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  0071b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00721	33 d2		 xor	 edx, edx
  00723	48 8b c8	 mov	 rcx, rax
  00726	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf
$LN31@Py_Main:
$LN32@Py_Main:

; 587  : #else /* !MS_WINDOWS */
; 588  : #ifdef HAVE_SETVBUF
; 589  :         setvbuf(stdin,  (char *)NULL, _IOLBF, BUFSIZ);
; 590  :         setvbuf(stdout, (char *)NULL, _IOLBF, BUFSIZ);
; 591  : #endif /* HAVE_SETVBUF */
; 592  : #endif /* !MS_WINDOWS */
; 593  :         /* Leave stderr alone - it should be unbuffered anyway. */
; 594  :     }
; 595  : #ifdef __VMS
; 596  :     else {
; 597  :         setvbuf (stdout, (char *)NULL, _IOLBF, BUFSIZ);
; 598  :     }
; 599  : #endif /* __VMS */
; 600  : 
; 601  : #ifdef __APPLE__
; 602  :     /* On MacOS X, when the Python interpreter is embedded in an
; 603  :        application bundle, it gets executed by a bootstrapping script
; 604  :        that does os.execve() with an argv[0] that's different from the
; 605  :        actual Python executable. This is needed to keep the Finder happy,
; 606  :        or rather, to work around Apple's overly strict requirements of
; 607  :        the process name. However, we still need a usable sys.executable,
; 608  :        so the actual executable path is passed in an environment variable.
; 609  :        See Lib/plat-mac/bundlebuiler.py for details about the bootstrap
; 610  :        script. */
; 611  :     if ((p = Py_GETENV("PYTHONEXECUTABLE")) && *p != '\0') {
; 612  :         wchar_t* buffer;
; 613  :         size_t len = strlen(p) + 1;
; 614  : 
; 615  :         buffer = malloc(len * sizeof(wchar_t));
; 616  :         if (buffer == NULL) {
; 617  :             Py_FatalError(
; 618  :                "not enough memory to copy PYTHONEXECUTABLE");
; 619  :         }
; 620  : 
; 621  :         mbstowcs(buffer, p, len);
; 622  :         Py_SetProgramName(buffer);
; 623  :         /* buffer is now handed off - do not free */
; 624  :     } else {
; 625  : #ifdef WITH_NEXT_FRAMEWORK
; 626  :         char* pyvenv_launcher = getenv("__PYVENV_LAUNCHER__");
; 627  : 
; 628  :         if (pyvenv_launcher && *pyvenv_launcher) {
; 629  :             /* Used by Mac/Tools/pythonw.c to forward
; 630  :              * the argv0 of the stub executable
; 631  :              */
; 632  :             wchar_t* wbuf = _Py_char2wchar(pyvenv_launcher, NULL);
; 633  : 
; 634  :             if (wbuf == NULL) {
; 635  :                 Py_FatalError("Cannot decode __PYVENV_LAUNCHER__");
; 636  :             }
; 637  :             Py_SetProgramName(wbuf);
; 638  : 
; 639  :             /* Don't free wbuf, the argument to Py_SetProgramName
; 640  :              * must remain valid until the Py_Finalize is called.
; 641  :              */
; 642  :         } else {
; 643  :             Py_SetProgramName(argv[0]);
; 644  :         }
; 645  : #else
; 646  :         Py_SetProgramName(argv[0]);
; 647  : #endif
; 648  :     }
; 649  : #else
; 650  :     Py_SetProgramName(argv[0]);

  0072c	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00734	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00737	e8 00 00 00 00	 call	 Py_SetProgramName

; 651  : #endif
; 652  :     Py_Initialize();

  0073c	e8 00 00 00 00	 call	 Py_Initialize

; 653  : 
; 654  :     if (!Py_QuietFlag && (Py_VerboseFlag ||
; 655  :                         (command == NULL && filename == NULL &&
; 656  :                          module == NULL && stdin_is_interactive))) {

  00741	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_QuietFlag, 0
  00748	0f 85 a7 00 00
	00		 jne	 $LN30@Py_Main
  0074e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_VerboseFlag, 0
  00755	75 2a		 jne	 SHORT $LN29@Py_Main
  00757	48 83 7c 24 48
	00		 cmp	 QWORD PTR command$[rsp], 0
  0075d	0f 85 92 00 00
	00		 jne	 $LN30@Py_Main
  00763	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR filename$[rsp], 0
  0076c	0f 85 83 00 00
	00		 jne	 $LN30@Py_Main
  00772	48 83 7c 24 78
	00		 cmp	 QWORD PTR module$[rsp], 0
  00778	75 7b		 jne	 SHORT $LN30@Py_Main
  0077a	83 7c 24 50 00	 cmp	 DWORD PTR stdin_is_interactive$[rsp], 0
  0077f	74 74		 je	 SHORT $LN30@Py_Main
$LN29@Py_Main:

; 657  :         fprintf(stderr, "PyParallel %s on %s\n",
; 658  :             Py_GetVersion(), Py_GetPlatform());

  00781	e8 00 00 00 00	 call	 Py_GetPlatform
  00786	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv276[rsp], rax
  0078e	e8 00 00 00 00	 call	 Py_GetVersion
  00793	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv278[rsp], rax
  0079b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  007a1	48 83 c0 60	 add	 rax, 96			; 00000060H
  007a5	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv276[rsp]
  007ad	4c 8b c9	 mov	 r9, rcx
  007b0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv278[rsp]
  007b8	4c 8b c1	 mov	 r8, rcx
  007bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HCFAEEPL@PyParallel?5?$CFs?5on?5?$CFs?6?$AA@
  007c2	48 8b c8	 mov	 rcx, rax
  007c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 659  :         if (!Py_NoSiteFlag)

  007cb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_NoSiteFlag, 0
  007d2	75 21		 jne	 SHORT $LN28@Py_Main

; 660  :             fprintf(stderr, "%s\n", COPYRIGHT);

  007d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  007da	48 83 c0 60	 add	 rax, 96			; 00000060H
  007de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EH@JFFAKOEJ@Type?5?$CChelp?$CC?0?5?$CCcopyright?$CC?0?5?$CCcredi@
  007e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6?$AA@
  007ec	48 8b c8	 mov	 rcx, rax
  007ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
$LN28@Py_Main:
$LN30@Py_Main:

; 661  :     }
; 662  : 
; 663  :     if (command != NULL) {

  007f5	48 83 7c 24 48
	00		 cmp	 QWORD PTR command$[rsp], 0
  007fb	74 28		 je	 SHORT $LN27@Py_Main

; 664  :         /* Backup _PyOS_optind and force sys.argv[0] = '-c' */
; 665  :         _PyOS_optind--;

  007fd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _PyOS_optind
  00803	ff c8		 dec	 eax
  00805	89 05 00 00 00
	00		 mov	 DWORD PTR _PyOS_optind, eax

; 666  :         argv[_PyOS_optind] = L"-c";

  0080b	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR _PyOS_optind
  00812	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0081a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15NMJMBAFJ@?$AA?9?$AAc?$AA?$AA@
  00821	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
$LN27@Py_Main:

; 667  :     }
; 668  : 
; 669  :     if (module != NULL) {

  00825	48 83 7c 24 78
	00		 cmp	 QWORD PTR module$[rsp], 0
  0082b	74 28		 je	 SHORT $LN26@Py_Main

; 670  :         /* Backup _PyOS_optind and force sys.argv[0] = '-m'*/
; 671  :         _PyOS_optind--;

  0082d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _PyOS_optind
  00833	ff c8		 dec	 eax
  00835	89 05 00 00 00
	00		 mov	 DWORD PTR _PyOS_optind, eax

; 672  :         argv[_PyOS_optind] = L"-m";

  0083b	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR _PyOS_optind
  00842	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0084a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15DMEDGHGK@?$AA?9?$AAm?$AA?$AA@
  00851	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
$LN26@Py_Main:

; 673  :     }
; 674  : 
; 675  :     PySys_SetArgv(argc-_PyOS_optind, argv+_PyOS_optind);

  00855	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR _PyOS_optind
  0085c	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00864	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00868	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PyOS_optind
  0086e	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR argc$[rsp]
  00875	2b d1		 sub	 edx, ecx
  00877	8b ca		 mov	 ecx, edx
  00879	48 8b d0	 mov	 rdx, rax
  0087c	e8 00 00 00 00	 call	 PySys_SetArgv

; 676  : 
; 677  :     if ((Py_InspectFlag || (command == NULL && filename == NULL && module == NULL)) &&
; 678  :         isatty(fileno(stdin))) {

  00881	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_InspectFlag, 0
  00888	75 1b		 jne	 SHORT $LN24@Py_Main
  0088a	48 83 7c 24 48
	00		 cmp	 QWORD PTR command$[rsp], 0
  00890	75 61		 jne	 SHORT $LN25@Py_Main
  00892	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR filename$[rsp], 0
  0089b	75 56		 jne	 SHORT $LN25@Py_Main
  0089d	48 83 7c 24 78
	00		 cmp	 QWORD PTR module$[rsp], 0
  008a3	75 4e		 jne	 SHORT $LN25@Py_Main
$LN24@Py_Main:
  008a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  008ab	48 8b c8	 mov	 rcx, rax
  008ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  008b4	8b c8		 mov	 ecx, eax
  008b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  008bc	85 c0		 test	 eax, eax
  008be	74 33		 je	 SHORT $LN25@Py_Main

; 679  :         PyObject *v;
; 680  :         v = PyImport_ImportModule("readline");

  008c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KBCDPPMN@readline?$AA@
  008c7	e8 00 00 00 00	 call	 PyImport_ImportModule
  008cc	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR v$121358[rsp], rax

; 681  :         if (v == NULL)

  008d4	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR v$121358[rsp], 0
  008dd	75 07		 jne	 SHORT $LN23@Py_Main

; 682  :             PyErr_Clear();

  008df	e8 00 00 00 00	 call	 PyErr_Clear

; 683  :         else

  008e4	eb 0d		 jmp	 SHORT $LN22@Py_Main
$LN23@Py_Main:

; 684  :             Py_DECREF(v);

  008e6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR v$121358[rsp]
  008ee	e8 00 00 00 00	 call	 _Py_DecRef
$LN22@Py_Main:
$LN25@Py_Main:

; 685  :     }
; 686  : 
; 687  :     if (command) {

  008f3	48 83 7c 24 48
	00		 cmp	 QWORD PTR command$[rsp], 0
  008f9	74 23		 je	 SHORT $LN21@Py_Main

; 688  :         sts = run_command(command, &cf);

  008fb	48 8d 54 24 70	 lea	 rdx, QWORD PTR cf$[rsp]
  00900	48 8b 4c 24 48	 mov	 rcx, QWORD PTR command$[rsp]
  00905	e8 00 00 00 00	 call	 run_command
  0090a	89 44 24 38	 mov	 DWORD PTR sts$[rsp], eax

; 689  :         free(command);

  0090e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR command$[rsp]
  00913	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00919	e9 75 02 00 00	 jmp	 $LN20@Py_Main
$LN21@Py_Main:

; 690  :     } else if (module) {

  0091e	48 83 7c 24 78
	00		 cmp	 QWORD PTR module$[rsp], 0
  00924	74 3b		 je	 SHORT $LN19@Py_Main

; 691  :         sts = (RunModule(module, 1) != 0);

  00926	ba 01 00 00 00	 mov	 edx, 1
  0092b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR module$[rsp]
  00930	e8 00 00 00 00	 call	 RunModule
  00935	85 c0		 test	 eax, eax
  00937	74 0d		 je	 SHORT $LN84@Py_Main
  00939	c7 84 24 28 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv361[rsp], 1
  00944	eb 0b		 jmp	 SHORT $LN85@Py_Main
$LN84@Py_Main:
  00946	c7 84 24 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv361[rsp], 0
$LN85@Py_Main:
  00951	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR tv361[rsp]
  00958	89 44 24 38	 mov	 DWORD PTR sts$[rsp], eax

; 692  :     }
; 693  :     else {

  0095c	e9 32 02 00 00	 jmp	 $LN18@Py_Main
$LN19@Py_Main:

; 694  : 
; 695  :         if (filename == NULL && stdin_is_interactive) {

  00961	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR filename$[rsp], 0
  0096a	75 1b		 jne	 SHORT $LN17@Py_Main
  0096c	83 7c 24 50 00	 cmp	 DWORD PTR stdin_is_interactive$[rsp], 0
  00971	74 14		 je	 SHORT $LN17@Py_Main

; 696  :             Py_InspectFlag = 0; /* do exit on SystemExit */

  00973	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR Py_InspectFlag, 0

; 697  :             RunStartupFile(&cf);

  0097d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR cf$[rsp]
  00982	e8 00 00 00 00	 call	 RunStartupFile
$LN17@Py_Main:

; 698  :         }
; 699  :         /* XXX */
; 700  : 
; 701  :         sts = -1;               /* keep track of whether we've already run __main__ */

  00987	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR sts$[rsp], -1

; 702  : 
; 703  :         if (filename != NULL) {

  0098f	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR filename$[rsp], 0
  00998	74 11		 je	 SHORT $LN16@Py_Main

; 704  :             sts = RunMainFromImporter(filename);

  0099a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  009a2	e8 00 00 00 00	 call	 RunMainFromImporter
  009a7	89 44 24 38	 mov	 DWORD PTR sts$[rsp], eax
$LN16@Py_Main:

; 705  :         }
; 706  : 
; 707  :         if (sts==-1 && filename!=NULL) {

  009ab	83 7c 24 38 ff	 cmp	 DWORD PTR sts$[rsp], -1
  009b0	0f 85 bb 01 00
	00		 jne	 $LN15@Py_Main
  009b6	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR filename$[rsp], 0
  009bf	0f 84 ac 01 00
	00		 je	 $LN15@Py_Main

; 708  :             fp = _Py_wfopen(filename, L"r");

  009c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13BPINEIPE@?$AAr?$AA?$AA@
  009cc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  009d4	e8 00 00 00 00	 call	 _Py_wfopen
  009d9	48 89 44 24 58	 mov	 QWORD PTR fp$[rsp], rax

; 709  :             if (fp == NULL) {

  009de	48 83 7c 24 58
	00		 cmp	 QWORD PTR fp$[rsp], 0
  009e4	0f 85 d0 00 00
	00		 jne	 $LN14@Py_Main

; 710  :                 char *cfilename_buffer;
; 711  :                 const char *cfilename;
; 712  :                 int err = errno;

  009ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  009f0	8b 00		 mov	 eax, DWORD PTR [rax]
  009f2	89 84 24 c0 00
	00 00		 mov	 DWORD PTR err$121379[rsp], eax

; 713  :                 cfilename_buffer = _Py_wchar2char(filename, NULL);

  009f9	33 d2		 xor	 edx, edx
  009fb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  00a03	e8 00 00 00 00	 call	 _Py_wchar2char
  00a08	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR cfilename_buffer$121377[rsp], rax

; 714  :                 if (cfilename_buffer != NULL)

  00a10	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR cfilename_buffer$121377[rsp], 0
  00a19	74 12		 je	 SHORT $LN13@Py_Main

; 715  :                     cfilename = cfilename_buffer;

  00a1b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cfilename_buffer$121377[rsp]
  00a23	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR cfilename$121378[rsp], rax

; 716  :                 else

  00a2b	eb 0f		 jmp	 SHORT $LN12@Py_Main
$LN13@Py_Main:

; 717  :                     cfilename = "<unprintable file name>";

  00a2d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BI@PLNCLPPD@?$DMunprintable?5file?5name?$DO?$AA@
  00a34	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR cfilename$121378[rsp], rax
$LN12@Py_Main:

; 718  :                 fprintf(stderr, "%ls: can't open file '%s': [Errno %d] %s\n",
; 719  :                     argv[0], cfilename, err, strerror(err));

  00a3c	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR err$121379[rsp]
  00a43	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00a49	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv380[rsp], rax
  00a51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00a57	48 83 c0 60	 add	 rax, 96			; 00000060H
  00a5b	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv380[rsp]
  00a63	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a68	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR err$121379[rsp]
  00a6f	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00a73	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR cfilename$121378[rsp]
  00a7b	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a83	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00a86	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@KLLBLHEB@?$CFls?3?5can?8t?5open?5file?5?8?$CFs?8?3?5?$FLErrn@
  00a8d	48 8b c8	 mov	 rcx, rax
  00a90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 720  :                 if (cfilename_buffer)

  00a96	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR cfilename_buffer$121377[rsp], 0
  00a9f	74 0d		 je	 SHORT $LN11@Py_Main

; 721  :                     PyMem_Free(cfilename_buffer);

  00aa1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR cfilename_buffer$121377[rsp]
  00aa9	e8 00 00 00 00	 call	 PyMem_Free
$LN11@Py_Main:

; 722  :                 return 2;

  00aae	b8 02 00 00 00	 mov	 eax, 2
  00ab3	e9 bd 01 00 00	 jmp	 $LN76@Py_Main
  00ab8	eb 43		 jmp	 SHORT $LN10@Py_Main
$LN14@Py_Main:

; 723  :             }
; 724  :             else if (skipfirstline) {

  00aba	83 7c 24 60 00	 cmp	 DWORD PTR skipfirstline$[rsp], 0
  00abf	74 3c		 je	 SHORT $LN9@Py_Main
$LN8@Py_Main:

; 725  :                 int ch;
; 726  :                 /* Push back first newline so line numbers
; 727  :                    remain the same */
; 728  :                 while ((ch = getc(fp)) != EOF) {

  00ac1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fp$[rsp]
  00ac6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getc
  00acc	89 84 24 c4 00
	00 00		 mov	 DWORD PTR ch$121389[rsp], eax
  00ad3	83 bc 24 c4 00
	00 00 ff	 cmp	 DWORD PTR ch$121389[rsp], -1
  00adb	74 20		 je	 SHORT $LN7@Py_Main

; 729  :                     if (ch == '\n') {

  00add	83 bc 24 c4 00
	00 00 0a	 cmp	 DWORD PTR ch$121389[rsp], 10
  00ae5	75 14		 jne	 SHORT $LN6@Py_Main

; 730  :                         (void)ungetc(ch, fp);

  00ae7	48 8b 54 24 58	 mov	 rdx, QWORD PTR fp$[rsp]
  00aec	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR ch$121389[rsp]
  00af3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc

; 731  :                         break;

  00af9	eb 02		 jmp	 SHORT $LN7@Py_Main
$LN6@Py_Main:

; 732  :                     }
; 733  :                 }

  00afb	eb c4		 jmp	 SHORT $LN8@Py_Main
$LN7@Py_Main:
$LN9@Py_Main:
$LN10@Py_Main:

; 734  :             }
; 735  :             {
; 736  :                 /* XXX: does this work on Win/Win64? (see posix_fstat) */
; 737  :                 struct stat sb;
; 738  :                 if (fstat(fileno(fp), &sb) == 0 &&
; 739  :                     S_ISDIR(sb.st_mode)) {

  00afd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fp$[rsp]
  00b02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  00b08	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR sb$121395[rsp]
  00b10	8b c8		 mov	 ecx, eax
  00b12	e8 00 00 00 00	 call	 fstat
  00b17	85 c0		 test	 eax, eax
  00b19	75 56		 jne	 SHORT $LN5@Py_Main
  00b1b	0f b7 84 24 ce
	00 00 00	 movzx	 eax, WORD PTR sb$121395[rsp+6]
  00b23	25 00 f0 00 00	 and	 eax, 61440		; 0000f000H
  00b28	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00b2d	75 42		 jne	 SHORT $LN5@Py_Main

; 740  :                     fprintf(stderr, "%ls: '%ls' is a directory, cannot continue\n", argv[0], filename);

  00b2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00b35	48 83 c0 60	 add	 rax, 96			; 00000060H
  00b39	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR filename$[rsp]
  00b41	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00b49	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00b4c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@LPBAPCAP@?$CFls?3?5?8?$CFls?8?5is?5a?5directory?0?5canno@
  00b53	48 8b c8	 mov	 rcx, rax
  00b56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 741  :                     fclose(fp);

  00b5c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fp$[rsp]
  00b61	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 742  :                     return 1;

  00b67	b8 01 00 00 00	 mov	 eax, 1
  00b6c	e9 04 01 00 00	 jmp	 $LN76@Py_Main
$LN5@Py_Main:
$LN15@Py_Main:

; 743  :                 }
; 744  :             }
; 745  :         }
; 746  : 
; 747  :         if (sts == -1)

  00b71	83 7c 24 38 ff	 cmp	 DWORD PTR sts$[rsp], -1
  00b76	75 1b		 jne	 SHORT $LN4@Py_Main

; 748  :             sts = run_file(fp, filename, &cf);

  00b78	4c 8d 44 24 70	 lea	 r8, QWORD PTR cf$[rsp]
  00b7d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  00b85	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fp$[rsp]
  00b8a	e8 00 00 00 00	 call	 run_file
  00b8f	89 44 24 38	 mov	 DWORD PTR sts$[rsp], eax
$LN4@Py_Main:
$LN18@Py_Main:
$LN20@Py_Main:

; 749  :     }
; 750  : 
; 751  :     /* Check this environment variable at the end, to give programs the
; 752  :      * opportunity to set it from Python.
; 753  :      */
; 754  :     if (!Py_InspectFlag &&
; 755  :         (p = Py_GETENV("PYTHONINSPECT")) && *p != '\0')

  00b93	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_InspectFlag, 0
  00b9a	75 57		 jne	 SHORT $LN3@Py_Main
  00b9c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  00ba3	74 0e		 je	 SHORT $LN86@Py_Main
  00ba5	48 c7 84 24 38
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv423[rsp], 0
  00bb1	eb 15		 jmp	 SHORT $LN87@Py_Main
$LN86@Py_Main:
  00bb3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DNGJAMOL@PYTHONINSPECT?$AA@
  00bba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  00bc0	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv423[rsp], rax
$LN87@Py_Main:
  00bc8	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR tv423[rsp]
  00bd0	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax
  00bd5	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  00bdb	74 16		 je	 SHORT $LN3@Py_Main
  00bdd	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00be2	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00be5	85 c0		 test	 eax, eax
  00be7	74 0a		 je	 SHORT $LN3@Py_Main

; 756  :     {
; 757  :         Py_InspectFlag = 1;

  00be9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR Py_InspectFlag, 1
$LN3@Py_Main:

; 758  :     }
; 759  : 
; 760  :     if (Py_InspectFlag && stdin_is_interactive &&
; 761  :         (filename != NULL || command != NULL || module != NULL)) {

  00bf3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_InspectFlag, 0
  00bfa	74 70		 je	 SHORT $LN2@Py_Main
  00bfc	83 7c 24 50 00	 cmp	 DWORD PTR stdin_is_interactive$[rsp], 0
  00c01	74 69		 je	 SHORT $LN2@Py_Main
  00c03	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR filename$[rsp], 0
  00c0c	75 10		 jne	 SHORT $LN1@Py_Main
  00c0e	48 83 7c 24 48
	00		 cmp	 QWORD PTR command$[rsp], 0
  00c14	75 08		 jne	 SHORT $LN1@Py_Main
  00c16	48 83 7c 24 78
	00		 cmp	 QWORD PTR module$[rsp], 0
  00c1c	74 4e		 je	 SHORT $LN2@Py_Main
$LN1@Py_Main:

; 762  :         Py_InspectFlag = 0;

  00c1e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR Py_InspectFlag, 0

; 763  :         /* XXX */
; 764  :         sts = PyRun_AnyFileFlags(stdin, "<stdin>", &cf) != 0;

  00c28	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00c2e	4c 8d 4c 24 70	 lea	 r9, QWORD PTR cf$[rsp]
  00c33	45 33 c0	 xor	 r8d, r8d
  00c36	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07CMJMHHJG@?$DMstdin?$DO?$AA@
  00c3d	48 8b c8	 mov	 rcx, rax
  00c40	e8 00 00 00 00	 call	 PyRun_AnyFileExFlags
  00c45	85 c0		 test	 eax, eax
  00c47	74 0d		 je	 SHORT $LN88@Py_Main
  00c49	c7 84 24 40 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv439[rsp], 1
  00c54	eb 0b		 jmp	 SHORT $LN89@Py_Main
$LN88@Py_Main:
  00c56	c7 84 24 40 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv439[rsp], 0
$LN89@Py_Main:
  00c61	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR tv439[rsp]
  00c68	89 44 24 38	 mov	 DWORD PTR sts$[rsp], eax
$LN2@Py_Main:

; 765  :     }
; 766  : 
; 767  :     Py_Finalize();

  00c6c	e8 00 00 00 00	 call	 Py_Finalize

; 768  : 
; 769  : #ifdef __INSURE__
; 770  :     /* Insure++ is a memory analysis tool that aids in discovering
; 771  :      * memory leaks and other memory problems.  On Python exit, the
; 772  :      * interned string dictionaries are flagged as being in use at exit
; 773  :      * (which it is).  Under normal circumstances, this is fine because
; 774  :      * the memory will be automatically reclaimed by the system.  Under
; 775  :      * memory debugging, it's a huge source of useless noise, so we
; 776  :      * trade off slower shutdown for less distraction in the memory
; 777  :      * reports.  -baw
; 778  :      */
; 779  :     _Py_ReleaseInternedUnicodeStrings();
; 780  : #endif /* __INSURE__ */
; 781  : 
; 782  :     return sts;

  00c71	8b 44 24 38	 mov	 eax, DWORD PTR sts$[rsp]
$LN76@Py_Main:

; 783  : }

  00c75	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  00c7c	c3		 ret	 0
  00c7d	0f 1f 00	 npad	 3
$LN91@Py_Main:
  00c80	00 00 00 00	 DD	 $LN51@Py_Main
  00c84	00 00 00 00	 DD	 $LN59@Py_Main
  00c88	00 00 00 00	 DD	 $LN56@Py_Main
  00c8c	00 00 00 00	 DD	 $LN60@Py_Main
  00c90	00 00 00 00	 DD	 $LN46@Py_Main
  00c94	00 00 00 00	 DD	 $LN57@Py_Main
  00c98	00 00 00 00	 DD	 $LN50@Py_Main
  00c9c	00 00 00 00	 DD	 $LN49@Py_Main
  00ca0	00 00 00 00	 DD	 $LN48@Py_Main
  00ca4	00 00 00 00	 DD	 $LN63@Py_Main
  00ca8	00 00 00 00	 DD	 $LN62@Py_Main
  00cac	00 00 00 00	 DD	 $LN61@Py_Main
  00cb0	00 00 00 00	 DD	 $LN47@Py_Main
  00cb4	00 00 00 00	 DD	 $LN58@Py_Main
  00cb8	00 00 00 00	 DD	 $LN55@Py_Main
  00cbc	00 00 00 00	 DD	 $LN54@Py_Main
  00cc0	00 00 00 00	 DD	 $LN53@Py_Main
  00cc4	00 00 00 00	 DD	 $LN52@Py_Main
  00cc8	00 00 00 00	 DD	 $LN45@Py_Main
$LN90@Py_Main:
  00ccc	00		 DB	 0
  00ccd	12		 DB	 18
  00cce	12		 DB	 18
  00ccf	01		 DB	 1
  00cd0	12		 DB	 18
  00cd1	12		 DB	 18
  00cd2	02		 DB	 2
  00cd3	12		 DB	 18
  00cd4	12		 DB	 18
  00cd5	12		 DB	 18
  00cd6	12		 DB	 18
  00cd7	12		 DB	 18
  00cd8	12		 DB	 18
  00cd9	12		 DB	 18
  00cda	12		 DB	 18
  00cdb	12		 DB	 18
  00cdc	03		 DB	 3
  00cdd	12		 DB	 18
  00cde	12		 DB	 18
  00cdf	04		 DB	 4
  00ce0	05		 DB	 5
  00ce1	12		 DB	 18
  00ce2	12		 DB	 18
  00ce3	06		 DB	 6
  00ce4	07		 DB	 7
  00ce5	08		 DB	 8
  00ce6	12		 DB	 18
  00ce7	12		 DB	 18
  00ce8	12		 DB	 18
  00ce9	12		 DB	 18
  00cea	12		 DB	 18
  00ceb	12		 DB	 18
  00cec	12		 DB	 18
  00ced	12		 DB	 18
  00cee	12		 DB	 18
  00cef	09		 DB	 9
  00cf0	12		 DB	 18
  00cf1	0a		 DB	 10
  00cf2	12		 DB	 18
  00cf3	12		 DB	 18
  00cf4	12		 DB	 18
  00cf5	00		 DB	 0
  00cf6	0b		 DB	 11
  00cf7	12		 DB	 18
  00cf8	12		 DB	 18
  00cf9	12		 DB	 18
  00cfa	12		 DB	 18
  00cfb	12		 DB	 18
  00cfc	12		 DB	 18
  00cfd	12		 DB	 18
  00cfe	0c		 DB	 12
  00cff	12		 DB	 18
  00d00	0d		 DB	 13
  00d01	0e		 DB	 14
  00d02	0f		 DB	 15
  00d03	10		 DB	 16
  00d04	12		 DB	 18
  00d05	11		 DB	 17
Py_Main	ENDP
_TEXT	ENDS
EXTRN	__imp__fstat64i32:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
pdata	SEGMENT
$pdata$fstat DD	imagerel fstat
	DD	imagerel fstat+33
	DD	imagerel $unwind$fstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fstat DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fstat
_TEXT	SEGMENT
_Desc$ = 48
_Stat$ = 56
fstat	PROC						; COMDAT

; 52   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 53   :     _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
; 54   :     return _fstat64i32(_Desc,(struct _stat64i32 *)_Stat);

  0000d	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Stat$[rsp]
  00012	8b 4c 24 30	 mov	 ecx, DWORD PTR _Desc$[rsp]
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64i32

; 55   : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
fstat	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@EFHGGAIP@?$DMprefix?$DO?2lib?$AA@	; `string'
PUBLIC	??_C@_0CH@EAKDMNDH@Try?5?$GApython?5?9h?8?5for?5more?5informa@ ; `string'
EXTRN	__imp_fputs:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\main.c
pdata	SEGMENT
$pdata$usage DD	imagerel usage
	DD	imagerel usage+248
	DD	imagerel $unwind$usage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$usage DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_0N@EFHGGAIP@?$DMprefix?$DO?2lib?$AA@
CONST	SEGMENT
??_C@_0N@EFHGGAIP@?$DMprefix?$DO?2lib?$AA@ DB '<prefix>\lib', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EAKDMNDH@Try?5?$GApython?5?9h?8?5for?5more?5informa@
CONST	SEGMENT
??_C@_0CH@EAKDMNDH@Try?5?$GApython?5?9h?8?5for?5more?5informa@ DB 'Try `p'
	DB	'ython -h'' for more information.', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT usage
_TEXT	SEGMENT
f$ = 32
tv69 = 40
exitcode$ = 64
program$ = 72
usage	PROC						; COMDAT

; 116  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 117  :     FILE *f = exitcode ? stderr : stdout;

  0000d	83 7c 24 40 00	 cmp	 DWORD PTR exitcode$[rsp], 0
  00012	74 11		 je	 SHORT $LN5@usage
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0001a	48 83 c0 60	 add	 rax, 96			; 00000060H
  0001e	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00023	eb 0f		 jmp	 SHORT $LN6@usage
$LN5@usage:
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0002b	48 83 c0 30	 add	 rax, 48			; 00000030H
  0002f	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
$LN6@usage:
  00034	48 8b 44 24 28	 mov	 rax, QWORD PTR tv69[rsp]
  00039	48 89 44 24 20	 mov	 QWORD PTR f$[rsp], rax

; 118  : 
; 119  :     fprintf(f, usage_line, program);

  0003e	4c 8b 44 24 48	 mov	 r8, QWORD PTR program$[rsp]
  00043	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR usage_line
  0004a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR f$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 120  :     if (exitcode)

  00055	83 7c 24 40 00	 cmp	 DWORD PTR exitcode$[rsp], 0
  0005a	74 14		 je	 SHORT $LN2@usage

; 121  :         fprintf(f, "Try `python -h' for more information.\n");

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@EAKDMNDH@Try?5?$GApython?5?9h?8?5for?5more?5informa@
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR f$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 122  :     else {

  0006e	eb 7f		 jmp	 SHORT $LN1@usage
$LN2@usage:

; 123  :         fputs(usage_1, f);

  00070	48 8b 54 24 20	 mov	 rdx, QWORD PTR f$[rsp]
  00075	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usage_1
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 124  :         fputs(usage_2, f);

  00082	48 8b 54 24 20	 mov	 rdx, QWORD PTR f$[rsp]
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usage_2
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 125  :         fputs(usage_3, f);

  00094	48 8b 54 24 20	 mov	 rdx, QWORD PTR f$[rsp]
  00099	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usage_3
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 126  :         fprintf(f, usage_4, DELIM);

  000a6	41 b8 3b 00 00
	00		 mov	 r8d, 59			; 0000003bH
  000ac	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR usage_4
  000b3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR f$[rsp]
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 127  :         fprintf(f, usage_5, DELIM, PYTHONHOMEHELP);

  000be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0N@EFHGGAIP@?$DMprefix?$DO?2lib?$AA@
  000c5	41 b8 3b 00 00
	00		 mov	 r8d, 59			; 0000003bH
  000cb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR usage_5
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR f$[rsp]
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 128  :         fputs(usage_6, f);

  000dd	48 8b 54 24 20	 mov	 rdx, QWORD PTR f$[rsp]
  000e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usage_6
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs
$LN1@usage:

; 129  :     }
; 130  : #if defined(__VMS)
; 131  :     if (exitcode == 0) {
; 132  :         /* suppress 'error' message */
; 133  :         return 1;
; 134  :     }
; 135  :     else {
; 136  :         /* STS$M_INHIB_MSG + SS$_ABORT */
; 137  :         return 0x1000002c;
; 138  :     }
; 139  : #else
; 140  :     return exitcode;

  000ef	8b 44 24 40	 mov	 eax, DWORD PTR exitcode$[rsp]

; 141  : #endif
; 142  :     /*NOTREACHED*/
; 143  : }

  000f3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f7	c3		 ret	 0
usage	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@DBLAKLMG@Could?5not?5open?5PYTHONSTARTUP?6?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0O@LDAADIEE@PYTHONSTARTUP?$AA@		; `string'
EXTRN	PyErr_Print:PROC
EXTRN	PyErr_SetFromErrnoWithFilename:PROC
EXTRN	PyExc_IOError:QWORD
EXTRN	PySys_WriteStderr:PROC
EXTRN	PyRun_SimpleFileExFlags:PROC
EXTRN	__imp_fopen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$RunStartupFile DD imagerel RunStartupFile
	DD	imagerel RunStartupFile+225
	DD	imagerel $unwind$RunStartupFile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RunStartupFile DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BO@DBLAKLMG@Could?5not?5open?5PYTHONSTARTUP?6?$AA@
CONST	SEGMENT
??_C@_0BO@DBLAKLMG@Could?5not?5open?5PYTHONSTARTUP?6?$AA@ DB 'Could not o'
	DB	'pen PYTHONSTARTUP', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LDAADIEE@PYTHONSTARTUP?$AA@
CONST	SEGMENT
??_C@_0O@LDAADIEE@PYTHONSTARTUP?$AA@ DB 'PYTHONSTARTUP', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT RunStartupFile
_TEXT	SEGMENT
startup$ = 32
fp$121104 = 40
save_errno$121110 = 48
tv67 = 56
cf$ = 80
RunStartupFile PROC					; COMDAT

; 146  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 147  :     char *startup = Py_GETENV("PYTHONSTARTUP");

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  00010	74 0b		 je	 SHORT $LN6@RunStartup
  00012	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
  0001b	eb 12		 jmp	 SHORT $LN7@RunStartup
$LN6@RunStartup:
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@LDAADIEE@PYTHONSTARTUP?$AA@
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  0002a	48 89 44 24 38	 mov	 QWORD PTR tv67[rsp], rax
$LN7@RunStartup:
  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR tv67[rsp]
  00034	48 89 44 24 20	 mov	 QWORD PTR startup$[rsp], rax

; 148  :     if (startup != NULL && startup[0] != '\0') {

  00039	48 83 7c 24 20
	00		 cmp	 QWORD PTR startup$[rsp], 0
  0003f	0f 84 97 00 00
	00		 je	 $LN3@RunStartup
  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR startup$[rsp]
  0004a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004d	85 c0		 test	 eax, eax
  0004f	0f 84 87 00 00
	00		 je	 $LN3@RunStartup

; 149  :         FILE *fp = fopen(startup, "r");

  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR startup$[rsp]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00067	48 89 44 24 28	 mov	 QWORD PTR fp$121104[rsp], rax

; 150  :         if (fp != NULL) {

  0006c	48 83 7c 24 28
	00		 cmp	 QWORD PTR fp$121104[rsp], 0
  00072	74 29		 je	 SHORT $LN2@RunStartup

; 151  :             (void) PyRun_SimpleFileExFlags(fp, startup, 0, cf);

  00074	4c 8b 4c 24 50	 mov	 r9, QWORD PTR cf$[rsp]
  00079	45 33 c0	 xor	 r8d, r8d
  0007c	48 8b 54 24 20	 mov	 rdx, QWORD PTR startup$[rsp]
  00081	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fp$121104[rsp]
  00086	e8 00 00 00 00	 call	 PyRun_SimpleFileExFlags

; 152  :             PyErr_Clear();

  0008b	e8 00 00 00 00	 call	 PyErr_Clear

; 153  :             fclose(fp);

  00090	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fp$121104[rsp]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 154  :         } else {

  0009b	eb 3f		 jmp	 SHORT $LN1@RunStartup
$LN2@RunStartup:

; 155  :             int save_errno;
; 156  : 
; 157  :             save_errno = errno;

  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a3	8b 00		 mov	 eax, DWORD PTR [rax]
  000a5	89 44 24 30	 mov	 DWORD PTR save_errno$121110[rsp], eax

; 158  :             PySys_WriteStderr("Could not open PYTHONSTARTUP\n");

  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@DBLAKLMG@Could?5not?5open?5PYTHONSTARTUP?6?$AA@
  000b0	e8 00 00 00 00	 call	 PySys_WriteStderr

; 159  :             errno = save_errno;

  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000bb	8b 4c 24 30	 mov	 ecx, DWORD PTR save_errno$121110[rsp]
  000bf	89 08		 mov	 DWORD PTR [rax], ecx

; 160  :             PyErr_SetFromErrnoWithFilename(PyExc_IOError,
; 161  :                             startup);

  000c1	48 8b 54 24 20	 mov	 rdx, QWORD PTR startup$[rsp]
  000c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  000cd	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilename

; 162  :             PyErr_Print();

  000d2	e8 00 00 00 00	 call	 PyErr_Print

; 163  :             PyErr_Clear();

  000d7	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@RunStartup:
$LN3@RunStartup:

; 164  :         }
; 165  :     }
; 166  : }

  000dc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e0	c3		 ret	 0
RunStartupFile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DK@PJLBBAF@Could?5not?5create?5arguments?5for?5r@ ; `string'
PUBLIC	??_C@_04IFLELAI@?$CIOi?$CJ?$AA@			; `string'
PUBLIC	??_C@_0CK@DPKAPBBI@Could?5not?5convert?5module?5name?5to@ ; `string'
PUBLIC	??_C@_0CM@NOBPIIPO@Could?5not?5access?5runpy?4_run_modu@ ; `string'
PUBLIC	??_C@_0BE@LIHJAHBD@_run_module_as_main?$AA@	; `string'
PUBLIC	??_C@_0BP@OFAJBJJI@Could?5not?5import?5runpy?5module?6?$AA@ ; `string'
PUBLIC	??_C@_05EIBALHPG@runpy?$AA@			; `string'
EXTRN	PyObject_Call:PROC
EXTRN	Py_BuildValue:PROC
EXTRN	PyUnicode_FromWideChar:PROC
EXTRN	PyObject_GetAttrString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$RunModule DD imagerel RunModule
	DD	imagerel RunModule+449
	DD	imagerel $unwind$RunModule
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RunModule DD 010d01H
	DD	0a20dH
xdata	ENDS
;	COMDAT ??_C@_0DK@PJLBBAF@Could?5not?5create?5arguments?5for?5r@
CONST	SEGMENT
??_C@_0DK@PJLBBAF@Could?5not?5create?5arguments?5for?5r@ DB 'Could not cr'
	DB	'eate arguments for runpy._run_module_as_main', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFLELAI@?$CIOi?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFLELAI@?$CIOi?$CJ?$AA@ DB '(Oi)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DPKAPBBI@Could?5not?5convert?5module?5name?5to@
CONST	SEGMENT
??_C@_0CK@DPKAPBBI@Could?5not?5convert?5module?5name?5to@ DB 'Could not c'
	DB	'onvert module name to unicode', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NOBPIIPO@Could?5not?5access?5runpy?4_run_modu@
CONST	SEGMENT
??_C@_0CM@NOBPIIPO@Could?5not?5access?5runpy?4_run_modu@ DB 'Could not ac'
	DB	'cess runpy._run_module_as_main', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LIHJAHBD@_run_module_as_main?$AA@
CONST	SEGMENT
??_C@_0BE@LIHJAHBD@_run_module_as_main?$AA@ DB '_run_module_as_main', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OFAJBJJI@Could?5not?5import?5runpy?5module?6?$AA@
CONST	SEGMENT
??_C@_0BP@OFAJBJJI@Could?5not?5import?5runpy?5module?6?$AA@ DB 'Could not'
	DB	' import runpy module', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EIBALHPG@runpy?$AA@
CONST	SEGMENT
??_C@_05EIBALHPG@runpy?$AA@ DB 'runpy', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT RunModule
_TEXT	SEGMENT
runpy$ = 32
module$ = 40
runargs$ = 48
result$ = 56
runmodule$ = 64
modname$ = 96
set_argv0$ = 104
RunModule PROC						; COMDAT

; 170  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 171  :     PyObject *module, *runpy, *runmodule, *runargs, *result;
; 172  :     runpy = PyImport_ImportModule("runpy");

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05EIBALHPG@runpy?$AA@
  00014	e8 00 00 00 00	 call	 PyImport_ImportModule
  00019	48 89 44 24 20	 mov	 QWORD PTR runpy$[rsp], rax

; 173  :     if (runpy == NULL) {

  0001e	48 83 7c 24 20
	00		 cmp	 QWORD PTR runpy$[rsp], 0
  00024	75 24		 jne	 SHORT $LN6@RunModule

; 174  :         fprintf(stderr, "Could not import runpy module\n");

  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0002c	48 83 c0 60	 add	 rax, 96			; 00000060H
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@OFAJBJJI@Could?5not?5import?5runpy?5module?6?$AA@
  00037	48 8b c8	 mov	 rcx, rax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 175  :         return -1;

  00040	b8 ff ff ff ff	 mov	 eax, -1
  00045	e9 72 01 00 00	 jmp	 $LN7@RunModule
$LN6@RunModule:

; 176  :     }
; 177  :     runmodule = PyObject_GetAttrString(runpy, "_run_module_as_main");

  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@LIHJAHBD@_run_module_as_main?$AA@
  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR runpy$[rsp]
  00056	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0005b	48 89 44 24 40	 mov	 QWORD PTR runmodule$[rsp], rax

; 178  :     if (runmodule == NULL) {

  00060	48 83 7c 24 40
	00		 cmp	 QWORD PTR runmodule$[rsp], 0
  00066	75 2e		 jne	 SHORT $LN5@RunModule

; 179  :         fprintf(stderr, "Could not access runpy._run_module_as_main\n");

  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0006e	48 83 c0 60	 add	 rax, 96			; 00000060H
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@NOBPIIPO@Could?5not?5access?5runpy?4_run_modu@
  00079	48 8b c8	 mov	 rcx, rax
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 180  :         Py_DECREF(runpy);

  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR runpy$[rsp]
  00087	e8 00 00 00 00	 call	 _Py_DecRef

; 181  :         return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	e9 26 01 00 00	 jmp	 $LN7@RunModule
$LN5@RunModule:

; 182  :     }
; 183  :     module = PyUnicode_FromWideChar(modname, wcslen(modname));

  00096	48 8b 4c 24 60	 mov	 rcx, QWORD PTR modname$[rsp]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  000a1	48 8b d0	 mov	 rdx, rax
  000a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR modname$[rsp]
  000a9	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  000ae	48 89 44 24 28	 mov	 QWORD PTR module$[rsp], rax

; 184  :     if (module == NULL) {

  000b3	48 83 7c 24 28
	00		 cmp	 QWORD PTR module$[rsp], 0
  000b9	75 38		 jne	 SHORT $LN4@RunModule

; 185  :         fprintf(stderr, "Could not convert module name to unicode\n");

  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  000c1	48 83 c0 60	 add	 rax, 96			; 00000060H
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@DPKAPBBI@Could?5not?5convert?5module?5name?5to@
  000cc	48 8b c8	 mov	 rcx, rax
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 186  :         Py_DECREF(runpy);

  000d5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR runpy$[rsp]
  000da	e8 00 00 00 00	 call	 _Py_DecRef

; 187  :         Py_DECREF(runmodule);

  000df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR runmodule$[rsp]
  000e4	e8 00 00 00 00	 call	 _Py_DecRef

; 188  :         return -1;

  000e9	b8 ff ff ff ff	 mov	 eax, -1
  000ee	e9 c9 00 00 00	 jmp	 $LN7@RunModule
$LN4@RunModule:

; 189  :     }
; 190  :     runargs = Py_BuildValue("(Oi)", module, set_argv0);

  000f3	44 8b 44 24 68	 mov	 r8d, DWORD PTR set_argv0$[rsp]
  000f8	48 8b 54 24 28	 mov	 rdx, QWORD PTR module$[rsp]
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IFLELAI@?$CIOi?$CJ?$AA@
  00104	e8 00 00 00 00	 call	 Py_BuildValue
  00109	48 89 44 24 30	 mov	 QWORD PTR runargs$[rsp], rax

; 191  :     if (runargs == NULL) {

  0010e	48 83 7c 24 30
	00		 cmp	 QWORD PTR runargs$[rsp], 0
  00114	75 3f		 jne	 SHORT $LN3@RunModule

; 192  :         fprintf(stderr,
; 193  :             "Could not create arguments for runpy._run_module_as_main\n");

  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0011c	48 83 c0 60	 add	 rax, 96			; 00000060H
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DK@PJLBBAF@Could?5not?5create?5arguments?5for?5r@
  00127	48 8b c8	 mov	 rcx, rax
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 194  :         Py_DECREF(runpy);

  00130	48 8b 4c 24 20	 mov	 rcx, QWORD PTR runpy$[rsp]
  00135	e8 00 00 00 00	 call	 _Py_DecRef

; 195  :         Py_DECREF(runmodule);

  0013a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR runmodule$[rsp]
  0013f	e8 00 00 00 00	 call	 _Py_DecRef

; 196  :         Py_DECREF(module);

  00144	48 8b 4c 24 28	 mov	 rcx, QWORD PTR module$[rsp]
  00149	e8 00 00 00 00	 call	 _Py_DecRef

; 197  :         return -1;

  0014e	b8 ff ff ff ff	 mov	 eax, -1
  00153	eb 67		 jmp	 SHORT $LN7@RunModule
$LN3@RunModule:

; 198  :     }
; 199  :     result = PyObject_Call(runmodule, runargs, NULL);

  00155	45 33 c0	 xor	 r8d, r8d
  00158	48 8b 54 24 30	 mov	 rdx, QWORD PTR runargs$[rsp]
  0015d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR runmodule$[rsp]
  00162	e8 00 00 00 00	 call	 PyObject_Call
  00167	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 200  :     if (result == NULL) {

  0016c	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  00172	75 05		 jne	 SHORT $LN2@RunModule

; 201  :         PyErr_Print();

  00174	e8 00 00 00 00	 call	 PyErr_Print
$LN2@RunModule:

; 202  :     }
; 203  :     Py_DECREF(runpy);

  00179	48 8b 4c 24 20	 mov	 rcx, QWORD PTR runpy$[rsp]
  0017e	e8 00 00 00 00	 call	 _Py_DecRef

; 204  :     Py_DECREF(runmodule);

  00183	48 8b 4c 24 40	 mov	 rcx, QWORD PTR runmodule$[rsp]
  00188	e8 00 00 00 00	 call	 _Py_DecRef

; 205  :     Py_DECREF(module);

  0018d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR module$[rsp]
  00192	e8 00 00 00 00	 call	 _Py_DecRef

; 206  :     Py_DECREF(runargs);

  00197	48 8b 4c 24 30	 mov	 rcx, QWORD PTR runargs$[rsp]
  0019c	e8 00 00 00 00	 call	 _Py_DecRef

; 207  :     if (result == NULL) {

  001a1	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  001a7	75 07		 jne	 SHORT $LN1@RunModule

; 208  :         return -1;

  001a9	b8 ff ff ff ff	 mov	 eax, -1
  001ae	eb 0c		 jmp	 SHORT $LN7@RunModule
$LN1@RunModule:

; 209  :     }
; 210  :     Py_DECREF(result);

  001b0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  001b5	e8 00 00 00 00	 call	 _Py_DecRef

; 211  :     return 0;

  001ba	33 c0		 xor	 eax, eax
$LN7@RunModule:

; 212  : }

  001bc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c0	c3		 ret	 0
RunModule ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BC@LCPDPAAM@?$AA_?$AA_?$AAm?$AAa?$AAi?$AAn?$AA_?$AA_?$AA?$AA@ ; `string'
PUBLIC	_Py_IncRef
PUBLIC	??_C@_04LNEJFJGI@path?$AA@			; `string'
EXTRN	PyList_SetItem:PROC
EXTRN	PySys_GetObject:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyImport_GetImporter:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$RunMainFromImporter DD imagerel RunMainFromImporter
	DD	imagerel RunMainFromImporter+299
	DD	imagerel $unwind$RunMainFromImporter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RunMainFromImporter DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_1BC@LCPDPAAM@?$AA_?$AA_?$AAm?$AAa?$AAi?$AAn?$AA_?$AA_?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@LCPDPAAM@?$AA_?$AA_?$AAm?$AAa?$AAi?$AAn?$AA_?$AA_?$AA?$AA@ DB '_'
	DB	00H, '_', 00H, 'm', 00H, 'a', 00H, 'i', 00H, 'n', 00H, '_', 00H
	DB	'_', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04LNEJFJGI@path?$AA@
CONST	SEGMENT
??_C@_04LNEJFJGI@path?$AA@ DB 'path', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT RunMainFromImporter
_TEXT	SEGMENT
sts$ = 32
argv0$ = 40
sys_path$ = 48
importer$ = 56
tv90 = 64
filename$ = 96
RunMainFromImporter PROC				; COMDAT

; 216  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 217  :     PyObject *argv0 = NULL, *importer, *sys_path;

  00009	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR argv0$[rsp], 0

; 218  :     int sts;
; 219  : 
; 220  :     argv0 = PyUnicode_FromWideChar(filename, wcslen(filename));

  00012	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  0001d	48 8b d0	 mov	 rdx, rax
  00020	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00025	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  0002a	48 89 44 24 28	 mov	 QWORD PTR argv0$[rsp], rax

; 221  :     if (argv0 == NULL)

  0002f	48 83 7c 24 28
	00		 cmp	 QWORD PTR argv0$[rsp], 0
  00035	75 05		 jne	 SHORT $LN9@RunMainFro

; 222  :         goto error;

  00037	e9 c8 00 00 00	 jmp	 $error$121165
$LN9@RunMainFro:

; 223  : 
; 224  :     importer = PyImport_GetImporter(argv0);

  0003c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR argv0$[rsp]
  00041	e8 00 00 00 00	 call	 PyImport_GetImporter
  00046	48 89 44 24 38	 mov	 QWORD PTR importer$[rsp], rax

; 225  :     if (importer == NULL)

  0004b	48 83 7c 24 38
	00		 cmp	 QWORD PTR importer$[rsp], 0
  00051	75 05		 jne	 SHORT $LN8@RunMainFro

; 226  :         goto error;

  00053	e9 ac 00 00 00	 jmp	 $error$121165
$LN8@RunMainFro:

; 227  : 
; 228  :     if (importer == Py_None) {

  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0005f	48 39 44 24 38	 cmp	 QWORD PTR importer$[rsp], rax
  00064	75 1e		 jne	 SHORT $LN7@RunMainFro

; 229  :         Py_DECREF(argv0);

  00066	48 8b 4c 24 28	 mov	 rcx, QWORD PTR argv0$[rsp]
  0006b	e8 00 00 00 00	 call	 _Py_DecRef

; 230  :         Py_DECREF(importer);

  00070	48 8b 4c 24 38	 mov	 rcx, QWORD PTR importer$[rsp]
  00075	e8 00 00 00 00	 call	 _Py_DecRef

; 231  :         return -1;

  0007a	b8 ff ff ff ff	 mov	 eax, -1
  0007f	e9 a2 00 00 00	 jmp	 $LN10@RunMainFro
$LN7@RunMainFro:

; 232  :     }
; 233  :     Py_DECREF(importer);

  00084	48 8b 4c 24 38	 mov	 rcx, QWORD PTR importer$[rsp]
  00089	e8 00 00 00 00	 call	 _Py_DecRef

; 234  : 
; 235  :     /* argv0 is usable as an import source, so put it in sys.path[0]
; 236  :        and import __main__ */
; 237  :     sys_path = PySys_GetObject("path");

  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  00095	e8 00 00 00 00	 call	 PySys_GetObject
  0009a	48 89 44 24 30	 mov	 QWORD PTR sys_path$[rsp], rax

; 238  :     if (sys_path == NULL)

  0009f	48 83 7c 24 30
	00		 cmp	 QWORD PTR sys_path$[rsp], 0
  000a5	75 02		 jne	 SHORT $LN6@RunMainFro

; 239  :         goto error;

  000a7	eb 5b		 jmp	 SHORT $error$121165
$LN6@RunMainFro:

; 240  :     if (PyList_SetItem(sys_path, 0, argv0)) {

  000a9	4c 8b 44 24 28	 mov	 r8, QWORD PTR argv0$[rsp]
  000ae	33 d2		 xor	 edx, edx
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sys_path$[rsp]
  000b5	e8 00 00 00 00	 call	 PyList_SetItem
  000ba	85 c0		 test	 eax, eax
  000bc	74 0b		 je	 SHORT $LN5@RunMainFro

; 241  :         argv0 = NULL;

  000be	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR argv0$[rsp], 0

; 242  :         goto error;

  000c7	eb 3b		 jmp	 SHORT $error$121165
$LN5@RunMainFro:

; 243  :     }
; 244  :     Py_INCREF(argv0);

  000c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR argv0$[rsp]
  000ce	e8 00 00 00 00	 call	 _Py_IncRef

; 245  : 
; 246  :     sts = RunModule(L"__main__", 0);

  000d3	33 d2		 xor	 edx, edx
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@LCPDPAAM@?$AA_?$AA_?$AAm?$AAa?$AAi?$AAn?$AA_?$AA_?$AA?$AA@
  000dc	e8 00 00 00 00	 call	 RunModule
  000e1	89 44 24 20	 mov	 DWORD PTR sts$[rsp], eax

; 247  :     return sts != 0;

  000e5	83 7c 24 20 00	 cmp	 DWORD PTR sts$[rsp], 0
  000ea	74 0a		 je	 SHORT $LN12@RunMainFro
  000ec	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  000f4	eb 08		 jmp	 SHORT $LN13@RunMainFro
$LN12@RunMainFro:
  000f6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN13@RunMainFro:
  000fe	8b 44 24 40	 mov	 eax, DWORD PTR tv90[rsp]
  00102	eb 22		 jmp	 SHORT $LN10@RunMainFro
$error$121165:
$LN4@RunMainFro:

; 248  : 
; 249  : error:
; 250  :     Py_XDECREF(argv0);

  00104	48 83 7c 24 28
	00		 cmp	 QWORD PTR argv0$[rsp], 0
  0010a	74 0a		 je	 SHORT $LN1@RunMainFro
  0010c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR argv0$[rsp]
  00111	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@RunMainFro:
  00116	33 c0		 xor	 eax, eax
  00118	85 c0		 test	 eax, eax
  0011a	75 e8		 jne	 SHORT $LN4@RunMainFro

; 251  :     PyErr_Print();

  0011c	e8 00 00 00 00	 call	 PyErr_Print

; 252  :     return 1;

  00121	b8 01 00 00 00	 mov	 eax, 1
$LN10@RunMainFro:

; 253  : }

  00126	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0012a	c3		 ret	 0
RunMainFromImporter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@NFIDFCFM@Unable?5to?5decode?5the?5command?5fro@ ; `string'
EXTRN	PyRun_SimpleStringFlags:PROC
EXTRN	PyBytes_AsString:PROC
EXTRN	PyUnicode_AsUTF8String:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\main.c
pdata	SEGMENT
$pdata$run_command DD imagerel run_command
	DD	imagerel run_command+176
	DD	imagerel $unwind$run_command
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$run_command DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0DF@NFIDFCFM@Unable?5to?5decode?5the?5command?5fro@
CONST	SEGMENT
??_C@_0DF@NFIDFCFM@Unable?5to?5decode?5the?5command?5fro@ DB 'Unable to d'
	DB	'ecode the command from the command line:', 0aH, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT run_command
_TEXT	SEGMENT
ret$ = 32
bytes$ = 40
unicode$ = 48
tv79 = 56
command$ = 80
cf$ = 88
run_command PROC					; COMDAT

; 257  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 258  :     PyObject *unicode, *bytes;
; 259  :     int ret;
; 260  : 
; 261  :     unicode = PyUnicode_FromWideChar(command, -1);

  0000e	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR command$[rsp]
  0001a	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  0001f	48 89 44 24 30	 mov	 QWORD PTR unicode$[rsp], rax

; 262  :     if (unicode == NULL)

  00024	48 83 7c 24 30
	00		 cmp	 QWORD PTR unicode$[rsp], 0
  0002a	75 02		 jne	 SHORT $LN2@run_comman

; 263  :         goto error;

  0002c	eb 67		 jmp	 SHORT $error$121195
$LN2@run_comman:

; 264  :     bytes = PyUnicode_AsUTF8String(unicode);

  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR unicode$[rsp]
  00033	e8 00 00 00 00	 call	 PyUnicode_AsUTF8String
  00038	48 89 44 24 28	 mov	 QWORD PTR bytes$[rsp], rax

; 265  :     Py_DECREF(unicode);

  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR unicode$[rsp]
  00042	e8 00 00 00 00	 call	 _Py_DecRef

; 266  :     if (bytes == NULL)

  00047	48 83 7c 24 28
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  0004d	75 02		 jne	 SHORT $LN1@run_comman

; 267  :         goto error;

  0004f	eb 44		 jmp	 SHORT $error$121195
$LN1@run_comman:

; 268  :     ret = PyRun_SimpleStringFlags(PyBytes_AsString(bytes), cf);

  00051	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  00056	e8 00 00 00 00	 call	 PyBytes_AsString
  0005b	48 8b 54 24 58	 mov	 rdx, QWORD PTR cf$[rsp]
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 PyRun_SimpleStringFlags
  00068	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 269  :     Py_DECREF(bytes);

  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  00071	e8 00 00 00 00	 call	 _Py_DecRef

; 270  :     return ret != 0;

  00076	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  0007b	74 0a		 je	 SHORT $LN5@run_comman
  0007d	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00085	eb 08		 jmp	 SHORT $LN6@run_comman
$LN5@run_comman:
  00087	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN6@run_comman:
  0008f	8b 44 24 38	 mov	 eax, DWORD PTR tv79[rsp]
  00093	eb 16		 jmp	 SHORT $LN3@run_comman
$error$121195:

; 271  : 
; 272  : error:
; 273  :     PySys_WriteStderr("Unable to decode the command from the command line:\n");

  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DF@NFIDFCFM@Unable?5to?5decode?5the?5command?5fro@
  0009c	e8 00 00 00 00	 call	 PySys_WriteStderr

; 274  :     PyErr_Print();

  000a1	e8 00 00 00 00	 call	 PyErr_Print

; 275  :     return 1;

  000a6	b8 01 00 00 00	 mov	 eax, 1
$LN3@run_comman:

; 276  : }

  000ab	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000af	c3		 ret	 0
run_command ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@MIIEBMAJ@?$DMencoding?5error?$DO?$AA@	; `string'
EXTRN	PyUnicode_EncodeFSDefault:PROC
EXTRN	Py_MakePendingCalls:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$run_file DD imagerel run_file
	DD	imagerel run_file+292
	DD	imagerel $unwind$run_file
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$run_file DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0BB@MIIEBMAJ@?$DMencoding?5error?$DO?$AA@
CONST	SEGMENT
??_C@_0BB@MIIEBMAJ@?$DMencoding?5error?$DO?$AA@ DB '<encoding error>', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT run_file
_TEXT	SEGMENT
filename_str$ = 32
bytes$ = 40
run$ = 48
unicode$ = 56
tv82 = 64
tv90 = 68
fp$ = 96
filename$ = 104
p_cf$ = 112
run_file PROC						; COMDAT

; 280  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 281  :     PyObject *unicode, *bytes = NULL;

  00013	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR bytes$[rsp], 0

; 282  :     char *filename_str;
; 283  :     int run;
; 284  : 
; 285  :     /* call pending calls like signal handlers (SIGINT) */
; 286  :     if (Py_MakePendingCalls() == -1) {

  0001c	e8 00 00 00 00	 call	 Py_MakePendingCalls
  00021	83 f8 ff	 cmp	 eax, -1
  00024	75 0f		 jne	 SHORT $LN10@run_file

; 287  :         PyErr_Print();

  00026	e8 00 00 00 00	 call	 PyErr_Print

; 288  :         return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	e9 ea 00 00 00	 jmp	 $LN11@run_file
$LN10@run_file:

; 289  :     }
; 290  : 
; 291  :     if (filename) {

  00035	48 83 7c 24 68
	00		 cmp	 QWORD PTR filename$[rsp], 0
  0003b	74 6a		 je	 SHORT $LN9@run_file

; 292  :         unicode = PyUnicode_FromWideChar(filename, wcslen(filename));

  0003d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR filename$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00048	48 8b d0	 mov	 rdx, rax
  0004b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR filename$[rsp]
  00050	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  00055	48 89 44 24 38	 mov	 QWORD PTR unicode$[rsp], rax

; 293  :         if (unicode != NULL) {

  0005a	48 83 7c 24 38
	00		 cmp	 QWORD PTR unicode$[rsp], 0
  00060	74 19		 je	 SHORT $LN8@run_file

; 294  :             bytes = PyUnicode_EncodeFSDefault(unicode);

  00062	48 8b 4c 24 38	 mov	 rcx, QWORD PTR unicode$[rsp]
  00067	e8 00 00 00 00	 call	 PyUnicode_EncodeFSDefault
  0006c	48 89 44 24 28	 mov	 QWORD PTR bytes$[rsp], rax

; 295  :             Py_DECREF(unicode);

  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR unicode$[rsp]
  00076	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@run_file:

; 296  :         }
; 297  :         if (bytes != NULL)

  0007b	48 83 7c 24 28
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  00081	74 11		 je	 SHORT $LN7@run_file

; 298  :             filename_str = PyBytes_AsString(bytes);

  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  00088	e8 00 00 00 00	 call	 PyBytes_AsString
  0008d	48 89 44 24 20	 mov	 QWORD PTR filename_str$[rsp], rax

; 299  :         else {

  00092	eb 11		 jmp	 SHORT $LN6@run_file
$LN7@run_file:

; 300  :             PyErr_Clear();

  00094	e8 00 00 00 00	 call	 PyErr_Clear

; 301  :             filename_str = "<encoding error>";

  00099	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@MIIEBMAJ@?$DMencoding?5error?$DO?$AA@
  000a0	48 89 44 24 20	 mov	 QWORD PTR filename_str$[rsp], rax
$LN6@run_file:

; 302  :         }
; 303  :     }
; 304  :     else

  000a5	eb 0c		 jmp	 SHORT $LN5@run_file
$LN9@run_file:

; 305  :         filename_str = "<stdin>";

  000a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07CMJMHHJG@?$DMstdin?$DO?$AA@
  000ae	48 89 44 24 20	 mov	 QWORD PTR filename_str$[rsp], rax
$LN5@run_file:

; 306  : 
; 307  :     run = PyRun_AnyFileExFlags(fp, filename_str, filename != NULL, p_cf);

  000b3	48 83 7c 24 68
	00		 cmp	 QWORD PTR filename$[rsp], 0
  000b9	74 0a		 je	 SHORT $LN13@run_file
  000bb	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  000c3	eb 08		 jmp	 SHORT $LN14@run_file
$LN13@run_file:
  000c5	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN14@run_file:
  000cd	4c 8b 4c 24 70	 mov	 r9, QWORD PTR p_cf$[rsp]
  000d2	44 8b 44 24 40	 mov	 r8d, DWORD PTR tv82[rsp]
  000d7	48 8b 54 24 20	 mov	 rdx, QWORD PTR filename_str$[rsp]
  000dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  000e1	e8 00 00 00 00	 call	 PyRun_AnyFileExFlags
  000e6	89 44 24 30	 mov	 DWORD PTR run$[rsp], eax
$LN4@run_file:

; 308  :     Py_XDECREF(bytes);

  000ea	48 83 7c 24 28
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  000f0	74 0a		 je	 SHORT $LN1@run_file
  000f2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@run_file:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 e8		 jne	 SHORT $LN4@run_file

; 309  :     return run != 0;

  00102	83 7c 24 30 00	 cmp	 DWORD PTR run$[rsp], 0
  00107	74 0a		 je	 SHORT $LN15@run_file
  00109	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  00111	eb 08		 jmp	 SHORT $LN16@run_file
$LN15@run_file:
  00113	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN16@run_file:
  0011b	8b 44 24 44	 mov	 eax, DWORD PTR tv90[rsp]
$LN11@run_file:

; 310  : }

  0011f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00123	c3		 ret	 0
run_file ENDP
_TEXT	ENDS
PUBLIC	Py_GetArgcArgv
; Function compile flags: /Odtp
;	COMDAT Py_GetArgcArgv
_TEXT	SEGMENT
argc$ = 8
argv$ = 16
Py_GetArgcArgv PROC					; COMDAT

; 794  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 795  :     *argc = orig_argc;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR argc$[rsp]
  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR orig_argc
  00015	89 08		 mov	 DWORD PTR [rax], ecx

; 796  :     *argv = orig_argv;

  00017	48 8b 44 24 10	 mov	 rax, QWORD PTR argv$[rsp]
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR orig_argv
  00023	48 89 08	 mov	 QWORD PTR [rax], rcx

; 797  : }

  00026	c3		 ret	 0
Py_GetArgcArgv ENDP
_TEXT	ENDS
END
