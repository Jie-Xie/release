; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BE@BBIKIFCE@default_int_handler?$AA@	; `string'
PUBLIC	??_C@_0O@BAIGEEFD@set_wakeup_fd?$AA@		; `string'
PUBLIC	??_C@_09JDGNOJPE@getsignal?$AA@			; `string'
PUBLIC	??_C@_06OAFOBKHE@signal?$AA@			; `string'
_BSS	SEGMENT
is_tripped DD	01H DUP (?)
	ALIGN	8

old_siginthandler DQ 01H DUP (?)
sigint_event DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BE@BBIKIFCE@default_int_handler?$AA@
CONST	SEGMENT
??_C@_0BE@BBIKIFCE@default_int_handler?$AA@ DB 'default_int_handler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BAIGEEFD@set_wakeup_fd?$AA@
CONST	SEGMENT
??_C@_0O@BAIGEEFD@set_wakeup_fd?$AA@ DB 'set_wakeup_fd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JDGNOJPE@getsignal?$AA@
CONST	SEGMENT
??_C@_09JDGNOJPE@getsignal?$AA@ DB 'getsignal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAFOBKHE@signal?$AA@
CONST	SEGMENT
??_C@_06OAFOBKHE@signal?$AA@ DB 'signal', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
wakeup_fd DD	0ffffffffH
	ORG $+12
default_int_handler_doc DB 'default_int_handler(...)', 0aH, 0aH, 'The def'
	DB	'ault handler for SIGINT installed by Python.', 0aH, 'It raise'
	DB	's KeyboardInterrupt.', 00H
	ORG $+5
signal_doc DB	'signal(sig, action) -> action', 0aH, 0aH, 'Set the actio'
	DB	'n for the given signal.  The action can be SIG_DFL,', 0aH, 'S'
	DB	'IG_IGN, or a callable Python object.  The previous action is', 0aH
	DB	'returned.  See getsignal() for possible return values.', 0aH, 0aH
	DB	'*** IMPORTANT NOTICE ***', 0aH, 'A signal handler function is'
	DB	' called with two arguments:', 0aH, 'the first is the signal n'
	DB	'umber, the second is the interrupted stack frame.', 00H
	ORG $+14
getsignal_doc DB 'getsignal(sig) -> action', 0aH, 0aH, 'Return the curren'
	DB	't action for the given signal.  The return value can be:', 0aH
	DB	'SIG_IGN -- if the signal is being ignored', 0aH, 'SIG_DFL -- '
	DB	'if the default action for the signal is in effect', 0aH, 'Non'
	DB	'e -- if an unknown handler is in effect', 0aH, 'anything else'
	DB	' -- the callable Python object used as a handler', 00H
	ORG $+12
set_wakeup_fd_doc DB 'set_wakeup_fd(fd) -> fd', 0aH, 0aH, 'Sets the fd to'
	DB	' be written to (with ''\0'') when a signal', 0aH, 'comes in. '
	DB	' A library can use this to wakeup select or poll.', 0aH, 'The'
	DB	' previous fd is returned.', 0aH, 0aH, 'The fd must be non-blo'
	DB	'cking.', 00H
	ORG $+9
signal_methods DQ FLAT:??_C@_06OAFOBKHE@signal?$AA@
	DQ	FLAT:signal_signal
	DD	01H
	ORG $+4
	DQ	FLAT:signal_doc
	DQ	FLAT:??_C@_09JDGNOJPE@getsignal?$AA@
	DQ	FLAT:signal_getsignal
	DD	01H
	ORG $+4
	DQ	FLAT:getsignal_doc
	DQ	FLAT:??_C@_0O@BAIGEEFD@set_wakeup_fd?$AA@
	DQ	FLAT:signal_set_wakeup_fd
	DD	01H
	ORG $+4
	DQ	FLAT:set_wakeup_fd_doc
	DQ	FLAT:??_C@_0BE@BBIKIFCE@default_int_handler?$AA@
	DQ	FLAT:signal_default_int_handler
	DD	01H
	ORG $+4
	DQ	FLAT:default_int_handler_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_doc DB	'This module provides mechanisms to use signal handlers i'
	DB	'n Python.', 0aH, 0aH, 'Functions:', 0aH, 0aH, 'alarm() -- cau'
	DB	'se SIGALRM after a specified time [Unix only]', 0aH, 'setitim'
	DB	'er() -- cause a signal (described below) after a specified', 0aH
	DB	'               float time and the timer may restart then [Uni'
	DB	'x only]', 0aH, 'getitimer() -- get current value of timer [Un'
	DB	'ix only]', 0aH, 'signal() -- set the action for a given signa'
	DB	'l', 0aH, 'getsignal() -- get the signal action for a given si'
	DB	'gnal', 0aH, 'pause() -- wait until a signal arrives [Unix onl'
	DB	'y]', 0aH, 'default_int_handler() -- default SIGINT handler', 0aH
	DB	0aH, 'signal constants:', 0aH, 'SIG_DFL -- used to refer to th'
	DB	'e system default handler', 0aH, 'SIG_IGN -- used to ignore th'
	DB	'e signal', 0aH, 'NSIG -- number of defined signals', 0aH, 'SI'
	DB	'GINT, SIGTERM, etc. -- signal numbers', 0aH, 0aH, 'itimer con'
	DB	'stants:', 0aH, 'ITIMER_REAL -- decrements in real time, and d'
	DB	'elivers SIGALRM upon', 0aH, '               expiration', 0aH, 'I'
	DB	'TIMER_VIRTUAL -- decrements only when the process is executin'
	DB	'g,', 0aH, '               and delivers SIGVTALRM upon expirat'
	DB	'ion', 0aH, 'ITIMER_PROF -- decrements both when the process i'
	DB	's executing and', 0aH, '               when the system is exe'
	DB	'cuting on behalf of the process.', 0aH, '               Coupl'
	DB	'ed with ITIMER_VIRTUAL, this timer is usually', 0aH, '       '
	DB	'        used to profile the time spent by the application', 0aH
	DB	'               in user and kernel space. SIGPROF is delivered'
	DB	' upon', 0aH, '               expiration.', 0aH, 0aH, 0aH, '**'
	DB	'* IMPORTANT NOTICE ***', 0aH, 'A signal handler function is c'
	DB	'alled with two arguments:', 0aH, 'the first is the signal num'
	DB	'ber, the second is the interrupted stack frame.', 00H
	ORG $+10
signalmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06OAFOBKHE@signal?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:signal_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	PyErr_SetNone:PROC
EXTRN	PyExc_KeyboardInterrupt:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\signalmodule.c
pdata	SEGMENT
$pdata$signal_default_int_handler DD imagerel signal_default_int_handler
	DD	imagerel signal_default_int_handler+33
	DD	imagerel $unwind$signal_default_int_handler
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$signal_default_int_handler DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT signal_default_int_handler
_TEXT	SEGMENT
self$ = 48
args$ = 56
signal_default_int_handler PROC				; COMDAT

; 165  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 166  :     PyErr_SetNone(PyExc_KeyboardInterrupt);

  0000e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyboardInterrupt
  00015	e8 00 00 00 00	 call	 PyErr_SetNone

; 167  :     return NULL;

  0001a	33 c0		 xor	 eax, eax

; 168  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
signal_default_int_handler ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0EM@JOAANLII@signal?5handler?5must?5be?5signal?4SI@ ; `string'
PUBLIC	??_C@_0BL@HNABDGJL@signal?5number?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0CB@OAIHALJA@signal?5only?5works?5in?5main?5thread@ ; `string'
PUBLIC	??_C@_0BF@POOAHGOC@invalid?5signal?5value?$AA@	; `string'
PUBLIC	??_C@_09KGGMABKF@iO?3signal?$AA@		; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OSError:QWORD
EXTRN	PyOS_setsig:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyCallable_Check:PROC
EXTRN	PyThread_get_thread_ident:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	PyArg_ParseTuple:PROC
_BSS	SEGMENT
Handlers DB	0170H DUP (?)
DefaultHandler DQ 01H DUP (?)
IgnoreHandler DQ 01H DUP (?)
main_thread DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$signal_signal DD imagerel signal_signal
	DD	imagerel signal_signal+572
	DD	imagerel $unwind$signal_signal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$signal_signal DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0EM@JOAANLII@signal?5handler?5must?5be?5signal?4SI@
CONST	SEGMENT
??_C@_0EM@JOAANLII@signal?5handler?5must?5be?5signal?4SI@ DB 'signal hand'
	DB	'ler must be signal.SIG_IGN, signal.SIG_DFL, or a callable obj'
	DB	'ect', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HNABDGJL@signal?5number?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BL@HNABDGJL@signal?5number?5out?5of?5range?$AA@ DB 'signal number '
	DB	'out of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OAIHALJA@signal?5only?5works?5in?5main?5thread@
CONST	SEGMENT
??_C@_0CB@OAIHALJA@signal?5only?5works?5in?5main?5thread@ DB 'signal only'
	DB	' works in main thread', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@POOAHGOC@invalid?5signal?5value?$AA@
CONST	SEGMENT
??_C@_0BF@POOAHGOC@invalid?5signal?5value?$AA@ DB 'invalid signal value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KGGMABKF@iO?3signal?$AA@
CONST	SEGMENT
??_C@_09KGGMABKF@iO?3signal?$AA@ DB 'iO:signal', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT signal_signal
_TEXT	SEGMENT
old_handler$ = 32
sig_num$ = 40
obj$ = 48
func$ = 56
tv70 = 64
self$ = 96
args$ = 104
signal_signal PROC					; COMDAT

; 290  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 291  :     PyObject *obj;
; 292  :     int sig_num;
; 293  :     PyObject *old_handler;
; 294  :     void (*func)(int);
; 295  :     if (!PyArg_ParseTuple(args, "iO:signal", &sig_num, &obj))

  0000e	4c 8d 4c 24 30	 lea	 r9, QWORD PTR obj$[rsp]
  00013	4c 8d 44 24 28	 lea	 r8, QWORD PTR sig_num$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09KGGMABKF@iO?3signal?$AA@
  0001f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN23@signal_sig

; 296  :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 ae 01 00 00	 jmp	 $LN24@signal_sig
$LN23@signal_sig:

; 297  : #ifdef MS_WINDOWS
; 298  :     /* Validate that sig_num is one of the allowable signals */
; 299  :     switch (sig_num) {

  00034	8b 44 24 28	 mov	 eax, DWORD PTR sig_num$[rsp]
  00038	89 44 24 40	 mov	 DWORD PTR tv70[rsp], eax
  0003c	8b 44 24 40	 mov	 eax, DWORD PTR tv70[rsp]
  00040	83 e8 02	 sub	 eax, 2
  00043	89 44 24 40	 mov	 DWORD PTR tv70[rsp], eax
  00047	83 7c 24 40 14	 cmp	 DWORD PTR tv70[rsp], 20
  0004c	77 26		 ja	 SHORT $LN13@signal_sig
  0004e	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv70[rsp]
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0005a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN26@signal_sig[rcx+rax*4]
  00061	48 03 c1	 add	 rax, rcx
  00064	ff e0		 jmp	 rax
$LN20@signal_sig:

; 300  :         case SIGABRT: break;

  00066	eb 26		 jmp	 SHORT $LN21@signal_sig
$LN19@signal_sig:

; 301  : #ifdef SIGBREAK
; 302  :         /* Issue #10003: SIGBREAK is not documented as permitted, but works
; 303  :            and corresponds to CTRL_BREAK_EVENT. */
; 304  :         case SIGBREAK: break;

  00068	eb 24		 jmp	 SHORT $LN21@signal_sig
$LN18@signal_sig:

; 305  : #endif
; 306  :         case SIGFPE: break;

  0006a	eb 22		 jmp	 SHORT $LN21@signal_sig
$LN17@signal_sig:

; 307  :         case SIGILL: break;

  0006c	eb 20		 jmp	 SHORT $LN21@signal_sig
$LN16@signal_sig:

; 308  :         case SIGINT: break;

  0006e	eb 1e		 jmp	 SHORT $LN21@signal_sig
$LN15@signal_sig:

; 309  :         case SIGSEGV: break;

  00070	eb 1c		 jmp	 SHORT $LN21@signal_sig
$LN14@signal_sig:

; 310  :         case SIGTERM: break;

  00072	eb 1a		 jmp	 SHORT $LN21@signal_sig
$LN13@signal_sig:

; 311  :         default:
; 312  :             PyErr_SetString(PyExc_ValueError, "invalid signal value");

  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@POOAHGOC@invalid?5signal?5value?$AA@
  0007b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00082	e8 00 00 00 00	 call	 PyErr_SetString

; 313  :             return NULL;

  00087	33 c0		 xor	 eax, eax
  00089	e9 54 01 00 00	 jmp	 $LN24@signal_sig
$LN21@signal_sig:

; 314  :     }
; 315  : #endif
; 316  : #ifdef WITH_THREAD
; 317  :     if (PyThread_get_thread_ident() != main_thread) {

  0008e	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00093	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread
  00099	74 1a		 je	 SHORT $LN12@signal_sig

; 318  :         PyErr_SetString(PyExc_ValueError,
; 319  :                         "signal only works in main thread");

  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@OAIHALJA@signal?5only?5works?5in?5main?5thread@
  000a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a9	e8 00 00 00 00	 call	 PyErr_SetString

; 320  :         return NULL;

  000ae	33 c0		 xor	 eax, eax
  000b0	e9 2d 01 00 00	 jmp	 $LN24@signal_sig
$LN12@signal_sig:

; 321  :     }
; 322  : #endif
; 323  :     if (sig_num < 1 || sig_num >= NSIG) {

  000b5	83 7c 24 28 01	 cmp	 DWORD PTR sig_num$[rsp], 1
  000ba	7c 07		 jl	 SHORT $LN10@signal_sig
  000bc	83 7c 24 28 17	 cmp	 DWORD PTR sig_num$[rsp], 23
  000c1	7c 1a		 jl	 SHORT $LN11@signal_sig
$LN10@signal_sig:

; 324  :         PyErr_SetString(PyExc_ValueError,
; 325  :                         "signal number out of range");

  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@HNABDGJL@signal?5number?5out?5of?5range?$AA@
  000ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000d1	e8 00 00 00 00	 call	 PyErr_SetString

; 326  :         return NULL;

  000d6	33 c0		 xor	 eax, eax
  000d8	e9 05 01 00 00	 jmp	 $LN24@signal_sig
$LN11@signal_sig:

; 327  :     }
; 328  :     if (obj == IgnoreHandler)

  000dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IgnoreHandler
  000e4	48 39 44 24 30	 cmp	 QWORD PTR obj$[rsp], rax
  000e9	75 0b		 jne	 SHORT $LN9@signal_sig

; 329  :         func = SIG_IGN;

  000eb	48 c7 44 24 38
	01 00 00 00	 mov	 QWORD PTR func$[rsp], 1
  000f4	eb 4f		 jmp	 SHORT $LN8@signal_sig
$LN9@signal_sig:

; 330  :     else if (obj == DefaultHandler)

  000f6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DefaultHandler
  000fd	48 39 44 24 30	 cmp	 QWORD PTR obj$[rsp], rax
  00102	75 0b		 jne	 SHORT $LN7@signal_sig

; 331  :         func = SIG_DFL;

  00104	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR func$[rsp], 0
  0010d	eb 36		 jmp	 SHORT $LN6@signal_sig
$LN7@signal_sig:

; 332  :     else if (!PyCallable_Check(obj)) {

  0010f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR obj$[rsp]
  00114	e8 00 00 00 00	 call	 PyCallable_Check
  00119	85 c0		 test	 eax, eax
  0011b	75 1c		 jne	 SHORT $LN5@signal_sig

; 333  :         PyErr_SetString(PyExc_TypeError,
; 334  : "signal handler must be signal.SIG_IGN, signal.SIG_DFL, or a callable object");

  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EM@JOAANLII@signal?5handler?5must?5be?5signal?4SI@
  00124	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0012b	e8 00 00 00 00	 call	 PyErr_SetString

; 335  :                 return NULL;

  00130	33 c0		 xor	 eax, eax
  00132	e9 ab 00 00 00	 jmp	 $LN24@signal_sig

; 336  :     }
; 337  :     else

  00137	eb 0c		 jmp	 SHORT $LN4@signal_sig
$LN5@signal_sig:

; 338  :         func = signal_handler;

  00139	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:signal_handler
  00140	48 89 44 24 38	 mov	 QWORD PTR func$[rsp], rax
$LN4@signal_sig:
$LN6@signal_sig:
$LN8@signal_sig:

; 339  :     if (PyOS_setsig(sig_num, func) == SIG_ERR) {

  00145	48 8b 54 24 38	 mov	 rdx, QWORD PTR func$[rsp]
  0014a	8b 4c 24 28	 mov	 ecx, DWORD PTR sig_num$[rsp]
  0014e	e8 00 00 00 00	 call	 PyOS_setsig
  00153	48 83 f8 ff	 cmp	 rax, -1
  00157	75 10		 jne	 SHORT $LN3@signal_sig

; 340  :         PyErr_SetFromErrno(PyExc_OSError);

  00159	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  00160	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 341  :         return NULL;

  00165	33 c0		 xor	 eax, eax
  00167	eb 79		 jmp	 SHORT $LN24@signal_sig
$LN3@signal_sig:

; 342  :     }
; 343  :     old_handler = Handlers[sig_num].func;

  00169	48 63 44 24 28	 movsxd	 rax, DWORD PTR sig_num$[rsp]
  0016e	48 6b c0 10	 imul	 rax, 16
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  00179	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0017e	48 89 44 24 20	 mov	 QWORD PTR old_handler$[rsp], rax

; 344  :     Handlers[sig_num].tripped = 0;

  00183	48 63 44 24 28	 movsxd	 rax, DWORD PTR sig_num$[rsp]
  00188	48 6b c0 10	 imul	 rax, 16
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  00193	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [rcx+rax], 0

; 345  :     Py_INCREF(obj);

  0019a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR obj$[rsp]
  0019f	e8 00 00 00 00	 call	 _Py_IncRef

; 346  :     Handlers[sig_num].func = obj;

  001a4	48 63 44 24 28	 movsxd	 rax, DWORD PTR sig_num$[rsp]
  001a9	48 6b c0 10	 imul	 rax, 16
  001ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  001b4	48 8b 54 24 30	 mov	 rdx, QWORD PTR obj$[rsp]
  001b9	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 347  :     if (old_handler != NULL)

  001be	48 83 7c 24 20
	00		 cmp	 QWORD PTR old_handler$[rsp], 0
  001c4	74 09		 je	 SHORT $LN2@signal_sig

; 348  :         return old_handler;

  001c6	48 8b 44 24 20	 mov	 rax, QWORD PTR old_handler$[rsp]
  001cb	eb 15		 jmp	 SHORT $LN24@signal_sig

; 349  :     else

  001cd	eb 13		 jmp	 SHORT $LN1@signal_sig
$LN2@signal_sig:

; 350  :         Py_RETURN_NONE;

  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  001d6	e8 00 00 00 00	 call	 _Py_IncRef
  001db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN1@signal_sig:
$LN24@signal_sig:

; 351  : }

  001e2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e6	c3		 ret	 0
  001e7	90		 npad	 1
$LN26@signal_sig:
  001e8	00 00 00 00	 DD	 $LN16@signal_sig
  001ec	00 00 00 00	 DD	 $LN13@signal_sig
  001f0	00 00 00 00	 DD	 $LN17@signal_sig
  001f4	00 00 00 00	 DD	 $LN13@signal_sig
  001f8	00 00 00 00	 DD	 $LN13@signal_sig
  001fc	00 00 00 00	 DD	 $LN13@signal_sig
  00200	00 00 00 00	 DD	 $LN18@signal_sig
  00204	00 00 00 00	 DD	 $LN13@signal_sig
  00208	00 00 00 00	 DD	 $LN13@signal_sig
  0020c	00 00 00 00	 DD	 $LN15@signal_sig
  00210	00 00 00 00	 DD	 $LN13@signal_sig
  00214	00 00 00 00	 DD	 $LN13@signal_sig
  00218	00 00 00 00	 DD	 $LN13@signal_sig
  0021c	00 00 00 00	 DD	 $LN14@signal_sig
  00220	00 00 00 00	 DD	 $LN13@signal_sig
  00224	00 00 00 00	 DD	 $LN13@signal_sig
  00228	00 00 00 00	 DD	 $LN13@signal_sig
  0022c	00 00 00 00	 DD	 $LN13@signal_sig
  00230	00 00 00 00	 DD	 $LN13@signal_sig
  00234	00 00 00 00	 DD	 $LN19@signal_sig
  00238	00 00 00 00	 DD	 $LN20@signal_sig
signal_signal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
EXTRN	__imp_SetEvent:PROC
EXTRN	__imp_getpid:PROC
EXTRN	__imp__errno:PROC
_BSS	SEGMENT
main_pid DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\signalmodule.c
pdata	SEGMENT
$pdata$signal_handler DD imagerel signal_handler
	DD	imagerel signal_handler+96
	DD	imagerel $unwind$signal_handler
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$signal_handler DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT signal_handler
_TEXT	SEGMENT
save_errno$ = 32
sig_num$ = 64
signal_handler PROC					; COMDAT

; 203  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 204  :     int save_errno = errno;

  00008	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 44 24 20	 mov	 DWORD PTR save_errno$[rsp], eax

; 205  : 
; 206  : #if defined(WITH_THREAD) && defined(WITH_PTH)
; 207  :     if (PyThread_get_thread_ident() != main_thread) {
; 208  :         pth_raise(*(pth_t *) main_thread, sig_num);
; 209  :     }
; 210  :     else
; 211  : #endif
; 212  :     {
; 213  : #ifdef WITH_THREAD
; 214  :     /* See NOTES section above */
; 215  :     if (getpid() == main_pid)

  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  0001a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_pid
  00020	75 09		 jne	 SHORT $LN2@signal_han

; 216  : #endif
; 217  :     {
; 218  :         trip_signal(sig_num);

  00022	8b 4c 24 40	 mov	 ecx, DWORD PTR sig_num$[rsp]
  00026	e8 00 00 00 00	 call	 trip_signal
$LN2@signal_han:

; 219  :     }
; 220  : 
; 221  : #ifndef HAVE_SIGACTION
; 222  : #ifdef SIGCHLD
; 223  :     /* To avoid infinite recursion, this signal remains
; 224  :        reset until explicit re-instated.
; 225  :        Don't clear the 'func' field as it is our pointer
; 226  :        to the Python handler... */
; 227  :     if (sig_num != SIGCHLD)
; 228  : #endif
; 229  :     /* If the handler was not set up with sigaction, reinstall it.  See
; 230  :      * Python/pythonrun.c for the implementation of PyOS_setsig which
; 231  :      * makes this true.  See also issue8354. */
; 232  :     PyOS_setsig(sig_num, signal_handler);

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:signal_handler
  00032	8b 4c 24 40	 mov	 ecx, DWORD PTR sig_num$[rsp]
  00036	e8 00 00 00 00	 call	 PyOS_setsig

; 233  : #endif
; 234  :     }
; 235  : 
; 236  :     /* Issue #10311: asynchronously executing signal handlers should not
; 237  :        mutate errno under the feet of unsuspecting C code. */
; 238  :     errno = save_errno;

  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00041	8b 4c 24 20	 mov	 ecx, DWORD PTR save_errno$[rsp]
  00045	89 08		 mov	 DWORD PTR [rax], ecx

; 239  : 
; 240  : #ifdef MS_WINDOWS
; 241  :     if (sig_num == SIGINT)

  00047	83 7c 24 40 02	 cmp	 DWORD PTR sig_num$[rsp], 2
  0004c	75 0d		 jne	 SHORT $LN1@signal_han

; 242  :         SetEvent(sigint_event);

  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sigint_event
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEvent
$LN1@signal_han:

; 243  : #endif
; 244  : }

  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	c3		 ret	 0
signal_handler ENDP
_TEXT	ENDS
EXTRN	Py_AddPendingCall:PROC
EXTRN	__imp_write:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$trip_signal DD imagerel trip_signal
	DD	imagerel trip_signal+115
	DD	imagerel $unwind$trip_signal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$trip_signal DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT trip_signal
_TEXT	SEGMENT
byte$ = 32
sig_num$ = 64
trip_signal PROC					; COMDAT

; 185  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 186  :     unsigned char byte;
; 187  : 
; 188  :     Handlers[sig_num].tripped = 1;

  00008	48 63 44 24 40	 movsxd	 rax, DWORD PTR sig_num$[rsp]
  0000d	48 6b c0 10	 imul	 rax, 16
  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  00018	c7 04 01 01 00
	00 00		 mov	 DWORD PTR [rcx+rax], 1

; 189  :     if (wakeup_fd != -1) {

  0001f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR wakeup_fd
  00025	83 f8 ff	 cmp	 eax, -1
  00028	74 20		 je	 SHORT $LN2@trip_signa

; 190  :         byte = (unsigned char)sig_num;

  0002a	0f b6 44 24 40	 movzx	 eax, BYTE PTR sig_num$[rsp]
  0002f	88 44 24 20	 mov	 BYTE PTR byte$[rsp], al

; 191  :         write(wakeup_fd, &byte, 1);

  00033	41 b8 01 00 00
	00		 mov	 r8d, 1
  00039	48 8d 54 24 20	 lea	 rdx, QWORD PTR byte$[rsp]
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR wakeup_fd
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
$LN2@trip_signa:

; 192  :     }
; 193  :     if (is_tripped)

  0004a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR is_tripped
  00050	85 c0		 test	 eax, eax
  00052	74 02		 je	 SHORT $LN1@trip_signa

; 194  :         return;

  00054	eb 18		 jmp	 SHORT $LN3@trip_signa
$LN1@trip_signa:

; 195  :     /* Set is_tripped after setting .tripped, as it gets
; 196  :        cleared in PyErr_CheckSignals() before .tripped. */
; 197  :     is_tripped = 1;

  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR is_tripped, 1

; 198  :     Py_AddPendingCall(checksignals_witharg, NULL);

  00060	33 d2		 xor	 edx, edx
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:checksignals_witharg
  00069	e8 00 00 00 00	 call	 Py_AddPendingCall
$LN3@trip_signa:

; 199  : }

  0006e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00072	c3		 ret	 0
trip_signal ENDP
_TEXT	ENDS
PUBLIC	PyErr_CheckSignals
;	COMDAT pdata
pdata	SEGMENT
$pdata$checksignals_witharg DD imagerel checksignals_witharg
	DD	imagerel checksignals_witharg+19
	DD	imagerel $unwind$checksignals_witharg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$checksignals_witharg DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT checksignals_witharg
_TEXT	SEGMENT
unused$ = 48
checksignals_witharg PROC				; COMDAT

; 179  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 180  :     return PyErr_CheckSignals();

  00009	e8 00 00 00 00	 call	 PyErr_CheckSignals

; 181  : }

  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
checksignals_witharg ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@HEAMACOM@i?3getsignal?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$signal_getsignal DD imagerel signal_getsignal
	DD	imagerel signal_getsignal+158
	DD	imagerel $unwind$signal_getsignal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$signal_getsignal DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0M@HEAMACOM@i?3getsignal?$AA@
CONST	SEGMENT
??_C@_0M@HEAMACOM@i?3getsignal?$AA@ DB 'i:getsignal', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT signal_getsignal
_TEXT	SEGMENT
old_handler$ = 32
sig_num$ = 40
self$ = 64
args$ = 72
signal_getsignal PROC					; COMDAT

; 367  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 368  :     int sig_num;
; 369  :     PyObject *old_handler;
; 370  :     if (!PyArg_ParseTuple(args, "i:getsignal", &sig_num))

  0000e	4c 8d 44 24 28	 lea	 r8, QWORD PTR sig_num$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@HEAMACOM@i?3getsignal?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN5@signal_get

; 371  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 6d		 jmp	 SHORT $LN6@signal_get
$LN5@signal_get:

; 372  :     if (sig_num < 1 || sig_num >= NSIG) {

  0002c	83 7c 24 28 01	 cmp	 DWORD PTR sig_num$[rsp], 1
  00031	7c 07		 jl	 SHORT $LN3@signal_get
  00033	83 7c 24 28 17	 cmp	 DWORD PTR sig_num$[rsp], 23
  00038	7c 17		 jl	 SHORT $LN4@signal_get
$LN3@signal_get:

; 373  :         PyErr_SetString(PyExc_ValueError,
; 374  :                         "signal number out of range");

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@HNABDGJL@signal?5number?5out?5of?5range?$AA@
  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00048	e8 00 00 00 00	 call	 PyErr_SetString

; 375  :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 48		 jmp	 SHORT $LN6@signal_get
$LN4@signal_get:

; 376  :     }
; 377  :     old_handler = Handlers[sig_num].func;

  00051	48 63 44 24 28	 movsxd	 rax, DWORD PTR sig_num$[rsp]
  00056	48 6b c0 10	 imul	 rax, 16
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  00061	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00066	48 89 44 24 20	 mov	 QWORD PTR old_handler$[rsp], rax

; 378  :     if (old_handler != NULL) {

  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR old_handler$[rsp], 0
  00071	74 13		 je	 SHORT $LN2@signal_get

; 379  :         Py_INCREF(old_handler);

  00073	48 8b 4c 24 20	 mov	 rcx, QWORD PTR old_handler$[rsp]
  00078	e8 00 00 00 00	 call	 _Py_IncRef

; 380  :         return old_handler;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR old_handler$[rsp]
  00082	eb 15		 jmp	 SHORT $LN6@signal_get

; 381  :     }
; 382  :     else {

  00084	eb 13		 jmp	 SHORT $LN1@signal_get
$LN2@signal_get:

; 383  :         Py_RETURN_NONE;

  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0008d	e8 00 00 00 00	 call	 _Py_IncRef
  00092	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN1@signal_get:
$LN6@signal_get:

; 384  :     }
; 385  : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
signal_getsignal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@NJBNHJG@invalid?5fd?$AA@		; `string'
PUBLIC	??_C@_0CI@NILBGOFJ@set_wakeup_fd?5only?5works?5in?5main@ ; `string'
PUBLIC	??_C@_0BA@GCBECJFP@i?3set_wakeup_fd?$AA@	; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	_PyVerify_fd:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$signal_set_wakeup_fd DD imagerel signal_set_wakeup_fd
	DD	imagerel signal_set_wakeup_fd+175
	DD	imagerel $unwind$signal_set_wakeup_fd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$signal_set_wakeup_fd DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0L@NJBNHJG@invalid?5fd?$AA@
CONST	SEGMENT
??_C@_0L@NJBNHJG@invalid?5fd?$AA@ DB 'invalid fd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NILBGOFJ@set_wakeup_fd?5only?5works?5in?5main@
CONST	SEGMENT
??_C@_0CI@NILBGOFJ@set_wakeup_fd?5only?5works?5in?5main@ DB 'set_wakeup_f'
	DB	'd only works in main thread', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GCBECJFP@i?3set_wakeup_fd?$AA@
CONST	SEGMENT
??_C@_0BA@GCBECJFP@i?3set_wakeup_fd?$AA@ DB 'i:set_wakeup_fd', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT signal_set_wakeup_fd
_TEXT	SEGMENT
old_fd$ = 32
buf$ = 40
fd$ = 88
self$ = 112
args$ = 120
signal_set_wakeup_fd PROC				; COMDAT

; 429  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 430  :     struct stat buf;
; 431  :     int fd, old_fd;
; 432  :     if (!PyArg_ParseTuple(args, "i:set_wakeup_fd", &fd))

  0000e	4c 8d 44 24 58	 lea	 r8, QWORD PTR fd$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GCBECJFP@i?3set_wakeup_fd?$AA@
  0001a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN4@signal_set

; 433  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 7e		 jmp	 SHORT $LN5@signal_set
$LN4@signal_set:

; 434  : #ifdef WITH_THREAD
; 435  :     if (PyThread_get_thread_ident() != main_thread) {

  0002c	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00031	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread
  00037	74 17		 je	 SHORT $LN3@signal_set

; 436  :         PyErr_SetString(PyExc_ValueError,
; 437  :                         "set_wakeup_fd only works in main thread");

  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@NILBGOFJ@set_wakeup_fd?5only?5works?5in?5main@
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00047	e8 00 00 00 00	 call	 PyErr_SetString

; 438  :         return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 5a		 jmp	 SHORT $LN5@signal_set
$LN3@signal_set:

; 439  :     }
; 440  : #endif
; 441  :     if (fd != -1 && (!_PyVerify_fd(fd) || fstat(fd, &buf) != 0)) {

  00050	83 7c 24 58 ff	 cmp	 DWORD PTR fd$[rsp], -1
  00055	74 36		 je	 SHORT $LN2@signal_set
  00057	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  0005b	e8 00 00 00 00	 call	 _PyVerify_fd
  00060	85 c0		 test	 eax, eax
  00062	74 12		 je	 SHORT $LN1@signal_set
  00064	48 8d 54 24 28	 lea	 rdx, QWORD PTR buf$[rsp]
  00069	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  0006d	e8 00 00 00 00	 call	 fstat
  00072	85 c0		 test	 eax, eax
  00074	74 17		 je	 SHORT $LN2@signal_set
$LN1@signal_set:

; 442  :         PyErr_SetString(PyExc_ValueError, "invalid fd");

  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@NJBNHJG@invalid?5fd?$AA@
  0007d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00084	e8 00 00 00 00	 call	 PyErr_SetString

; 443  :         return NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	eb 1d		 jmp	 SHORT $LN5@signal_set
$LN2@signal_set:

; 444  :     }
; 445  :     old_fd = wakeup_fd;

  0008d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR wakeup_fd
  00093	89 44 24 20	 mov	 DWORD PTR old_fd$[rsp], eax

; 446  :     wakeup_fd = fd;

  00097	8b 44 24 58	 mov	 eax, DWORD PTR fd$[rsp]
  0009b	89 05 00 00 00
	00		 mov	 DWORD PTR wakeup_fd, eax

; 447  :     return PyLong_FromLong(old_fd);

  000a1	8b 4c 24 20	 mov	 ecx, DWORD PTR old_fd$[rsp]
  000a5	e8 00 00 00 00	 call	 PyLong_FromLong
$LN5@signal_set:

; 448  : }

  000aa	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ae	c3		 ret	 0
signal_set_wakeup_fd ENDP
_TEXT	ENDS
EXTRN	__imp__fstat64i32:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
pdata	SEGMENT
$pdata$fstat DD	imagerel fstat
	DD	imagerel fstat+33
	DD	imagerel $unwind$fstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fstat DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fstat
_TEXT	SEGMENT
_Desc$ = 48
_Stat$ = 56
fstat	PROC						; COMDAT

; 52   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 53   :     _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
; 54   :     return _fstat64i32(_Desc,(struct _stat64i32 *)_Stat);

  0000d	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Stat$[rsp]
  00012	8b 4c 24 30	 mov	 ecx, DWORD PTR _Desc$[rsp]
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64i32

; 55   : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
fstat	ENDP
_TEXT	ENDS
PUBLIC	PySignal_SetWakeupFd
;	COMDAT pdata
; File c:\src\pyparallel\modules\signalmodule.c
pdata	SEGMENT
$pdata$PySignal_SetWakeupFd DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$PySignal_SetWakeupFd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySignal_SetWakeupFd DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySignal_SetWakeupFd
_TEXT	SEGMENT
old_fd$ = 0
fd$ = 32
PySignal_SetWakeupFd PROC				; COMDAT

; 462  : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 463  :     int old_fd = wakeup_fd;

  00008	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR wakeup_fd
  0000e	89 04 24	 mov	 DWORD PTR old_fd$[rsp], eax

; 464  :     if (fd < 0)

  00011	83 7c 24 20 00	 cmp	 DWORD PTR fd$[rsp], 0
  00016	7d 08		 jge	 SHORT $LN1@PySignal_S

; 465  :         fd = -1;

  00018	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR fd$[rsp], -1
$LN1@PySignal_S:

; 466  :     wakeup_fd = fd;

  00020	8b 44 24 20	 mov	 eax, DWORD PTR fd$[rsp]
  00024	89 05 00 00 00
	00		 mov	 DWORD PTR wakeup_fd, eax

; 467  :     return old_fd;

  0002a	8b 04 24	 mov	 eax, DWORD PTR old_fd$[rsp]

; 468  : }

  0002d	48 83 c4 18	 add	 rsp, 24
  00031	c3		 ret	 0
PySignal_SetWakeupFd ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@ELEIIFAE@CTRL_BREAK_EVENT?$AA@	; `string'
PUBLIC	??_C@_0N@FEFOEFHG@CTRL_C_EVENT?$AA@		; `string'
PUBLIC	??_C@_07MJAMNEFP@SIGTERM?$AA@			; `string'
PUBLIC	??_C@_07MIPHKCEO@SIGSEGV?$AA@			; `string'
PUBLIC	??_C@_06ONOHJOEH@SIGFPE?$AA@			; `string'
PUBLIC	??_C@_07GHNLFNAM@SIGABRT?$AA@			; `string'
PUBLIC	??_C@_06HBHKGPEM@SIGILL?$AA@			; `string'
PUBLIC	??_C@_08CLALOKCJ@SIGBREAK?$AA@			; `string'
PUBLIC	??_C@_06PAOFCDHL@SIGINT?$AA@			; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_04MHNFCBAL@NSIG?$AA@			; `string'
PUBLIC	??_C@_07MFMKGIKO@SIG_IGN?$AA@			; `string'
PUBLIC	??_C@_07EFELIMG@SIG_DFL?$AA@			; `string'
PUBLIC	PyInit_signal
EXTRN	PyErr_Occurred:PROC
EXTRN	__imp_CreateEventA:PROC
EXTRN	PyOS_getsig:PROC
EXTRN	PyDict_GetItemString:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyLong_FromVoidPtr:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
_BSS	SEGMENT
IntHandler DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_signal DD imagerel $LN48
	DD	imagerel $LN48+1211
	DD	imagerel $unwind$PyInit_signal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_signal DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0BB@ELEIIFAE@CTRL_BREAK_EVENT?$AA@
CONST	SEGMENT
??_C@_0BB@ELEIIFAE@CTRL_BREAK_EVENT?$AA@ DB 'CTRL_BREAK_EVENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FEFOEFHG@CTRL_C_EVENT?$AA@
CONST	SEGMENT
??_C@_0N@FEFOEFHG@CTRL_C_EVENT?$AA@ DB 'CTRL_C_EVENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MJAMNEFP@SIGTERM?$AA@
CONST	SEGMENT
??_C@_07MJAMNEFP@SIGTERM?$AA@ DB 'SIGTERM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIPHKCEO@SIGSEGV?$AA@
CONST	SEGMENT
??_C@_07MIPHKCEO@SIGSEGV?$AA@ DB 'SIGSEGV', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ONOHJOEH@SIGFPE?$AA@
CONST	SEGMENT
??_C@_06ONOHJOEH@SIGFPE?$AA@ DB 'SIGFPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHNLFNAM@SIGABRT?$AA@
CONST	SEGMENT
??_C@_07GHNLFNAM@SIGABRT?$AA@ DB 'SIGABRT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HBHKGPEM@SIGILL?$AA@
CONST	SEGMENT
??_C@_06HBHKGPEM@SIGILL?$AA@ DB 'SIGILL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLALOKCJ@SIGBREAK?$AA@
CONST	SEGMENT
??_C@_08CLALOKCJ@SIGBREAK?$AA@ DB 'SIGBREAK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PAOFCDHL@SIGINT?$AA@
CONST	SEGMENT
??_C@_06PAOFCDHL@SIGINT?$AA@ DB 'SIGINT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MHNFCBAL@NSIG?$AA@
CONST	SEGMENT
??_C@_04MHNFCBAL@NSIG?$AA@ DB 'NSIG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFMKGIKO@SIG_IGN?$AA@
CONST	SEGMENT
??_C@_07MFMKGIKO@SIG_IGN?$AA@ DB 'SIG_IGN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFELIMG@SIG_DFL?$AA@
CONST	SEGMENT
??_C@_07EFELIMG@SIG_DFL?$AA@ DB 'SIG_DFL', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit_signal
_TEXT	SEGMENT
x$ = 32
i$ = 40
d$ = 48
m$ = 56
t$120986 = 64
PyInit_signal PROC					; COMDAT

; 971  : {

$LN48:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 972  :     PyObject *m, *d, *x;
; 973  :     int i;
; 974  : 
; 975  : #ifdef WITH_THREAD
; 976  :     main_thread = PyThread_get_thread_ident();

  00004	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00009	89 05 00 00 00
	00		 mov	 DWORD PTR main_thread, eax

; 977  :     main_pid = getpid();

  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  00015	89 05 00 00 00
	00		 mov	 DWORD PTR main_pid, eax

; 978  : #endif
; 979  : 
; 980  :     /* Create the module and add the functions */
; 981  :     m = PyModule_Create(&signalmodule);

  0001b	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:signalmodule
  00027	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  0002c	48 89 44 24 38	 mov	 QWORD PTR m$[rsp], rax

; 982  :     if (m == NULL)

  00031	48 83 7c 24 38
	00		 cmp	 QWORD PTR m$[rsp], 0
  00037	75 07		 jne	 SHORT $LN45@PyInit_sig

; 983  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 76 04 00 00	 jmp	 $LN46@PyInit_sig
$LN45@PyInit_sig:

; 984  : 
; 985  : #if defined(HAVE_SIGWAITINFO) || defined(HAVE_SIGTIMEDWAIT)
; 986  :     if (!initialized)
; 987  :         PyStructSequence_InitType(&SiginfoType, &struct_siginfo_desc);
; 988  : 
; 989  :     Py_INCREF((PyObject*) &SiginfoType);
; 990  :     PyModule_AddObject(m, "struct_siginfo", (PyObject*) &SiginfoType);
; 991  :     initialized = 1;
; 992  : #endif
; 993  : 
; 994  :     /* Add some symbolic constants to the module */
; 995  :     d = PyModule_GetDict(m);

  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00045	e8 00 00 00 00	 call	 PyModule_GetDict
  0004a	48 89 44 24 30	 mov	 QWORD PTR d$[rsp], rax

; 996  : 
; 997  :     x = DefaultHandler = PyLong_FromVoidPtr((void *)SIG_DFL);

  0004f	33 c9		 xor	 ecx, ecx
  00051	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  00056	48 89 05 00 00
	00 00		 mov	 QWORD PTR DefaultHandler, rax
  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DefaultHandler
  00064	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 998  :     if (!x || PyDict_SetItemString(d, "SIG_DFL", x) < 0)

  00069	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  0006f	74 1a		 je	 SHORT $LN43@PyInit_sig
  00071	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EFELIMG@SIG_DFL?$AA@
  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00082	e8 00 00 00 00	 call	 PyDict_SetItemString
  00087	85 c0		 test	 eax, eax
  00089	7d 05		 jge	 SHORT $LN44@PyInit_sig
$LN43@PyInit_sig:

; 999  :         goto finally;

  0008b	e9 21 04 00 00	 jmp	 $finally$120968
$LN44@PyInit_sig:

; 1000 : 
; 1001 :     x = IgnoreHandler = PyLong_FromVoidPtr((void *)SIG_IGN);

  00090	b9 01 00 00 00	 mov	 ecx, 1
  00095	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  0009a	48 89 05 00 00
	00 00		 mov	 QWORD PTR IgnoreHandler, rax
  000a1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IgnoreHandler
  000a8	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1002 :     if (!x || PyDict_SetItemString(d, "SIG_IGN", x) < 0)

  000ad	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  000b3	74 1a		 je	 SHORT $LN41@PyInit_sig
  000b5	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07MFMKGIKO@SIG_IGN?$AA@
  000c1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  000c6	e8 00 00 00 00	 call	 PyDict_SetItemString
  000cb	85 c0		 test	 eax, eax
  000cd	7d 05		 jge	 SHORT $LN42@PyInit_sig
$LN41@PyInit_sig:

; 1003 :         goto finally;

  000cf	e9 dd 03 00 00	 jmp	 $finally$120968
$LN42@PyInit_sig:

; 1004 : 
; 1005 :     x = PyLong_FromLong((long)NSIG);

  000d4	b9 17 00 00 00	 mov	 ecx, 23
  000d9	e8 00 00 00 00	 call	 PyLong_FromLong
  000de	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1006 :     if (!x || PyDict_SetItemString(d, "NSIG", x) < 0)

  000e3	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  000e9	74 1a		 je	 SHORT $LN39@PyInit_sig
  000eb	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MHNFCBAL@NSIG?$AA@
  000f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  000fc	e8 00 00 00 00	 call	 PyDict_SetItemString
  00101	85 c0		 test	 eax, eax
  00103	7d 05		 jge	 SHORT $LN40@PyInit_sig
$LN39@PyInit_sig:

; 1007 :         goto finally;

  00105	e9 a7 03 00 00	 jmp	 $finally$120968
$LN40@PyInit_sig:

; 1008 :     Py_DECREF(x);

  0010a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  0010f	e8 00 00 00 00	 call	 _Py_DecRef

; 1009 : 
; 1010 : #ifdef SIG_BLOCK
; 1011 :     if (PyModule_AddIntMacro(m, SIG_BLOCK))
; 1012 :          goto finally;
; 1013 : #endif
; 1014 : #ifdef SIG_UNBLOCK
; 1015 :     if (PyModule_AddIntMacro(m, SIG_UNBLOCK))
; 1016 :          goto finally;
; 1017 : #endif
; 1018 : #ifdef SIG_SETMASK
; 1019 :     if (PyModule_AddIntMacro(m, SIG_SETMASK))
; 1020 :          goto finally;
; 1021 : #endif
; 1022 : 
; 1023 :     x = IntHandler = PyDict_GetItemString(d, "default_int_handler");

  00114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@BBIKIFCE@default_int_handler?$AA@
  0011b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00120	e8 00 00 00 00	 call	 PyDict_GetItemString
  00125	48 89 05 00 00
	00 00		 mov	 QWORD PTR IntHandler, rax
  0012c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IntHandler
  00133	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1024 :     if (!x)

  00138	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  0013e	75 05		 jne	 SHORT $LN38@PyInit_sig

; 1025 :         goto finally;

  00140	e9 6c 03 00 00	 jmp	 $finally$120968
$LN38@PyInit_sig:

; 1026 :     Py_INCREF(IntHandler);

  00145	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IntHandler
  0014c	e8 00 00 00 00	 call	 _Py_IncRef

; 1027 : 
; 1028 :     Handlers[0].tripped = 0;

  00151	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR Handlers, 0

; 1029 :     for (i = 1; i < NSIG; i++) {

  0015b	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00163	eb 0a		 jmp	 SHORT $LN37@PyInit_sig
$LN36@PyInit_sig:
  00165	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00169	ff c0		 inc	 eax
  0016b	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN37@PyInit_sig:
  0016f	83 7c 24 28 17	 cmp	 DWORD PTR i$[rsp], 23
  00174	0f 8d ac 00 00
	00		 jge	 $LN35@PyInit_sig

; 1030 :         void (*t)(int);
; 1031 :         t = PyOS_getsig(i);

  0017a	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  0017e	e8 00 00 00 00	 call	 PyOS_getsig
  00183	48 89 44 24 40	 mov	 QWORD PTR t$120986[rsp], rax

; 1032 :         Handlers[i].tripped = 0;

  00188	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0018d	48 6b c0 10	 imul	 rax, 16
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  00198	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [rcx+rax], 0

; 1033 :         if (t == SIG_DFL)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR t$120986[rsp], 0
  001a5	75 1e		 jne	 SHORT $LN34@PyInit_sig

; 1034 :             Handlers[i].func = DefaultHandler;

  001a7	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  001ac	48 6b c0 10	 imul	 rax, 16
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  001b7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR DefaultHandler
  001be	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx
  001c3	eb 42		 jmp	 SHORT $LN33@PyInit_sig
$LN34@PyInit_sig:

; 1035 :         else if (t == SIG_IGN)

  001c5	48 83 7c 24 40
	01		 cmp	 QWORD PTR t$120986[rsp], 1
  001cb	75 1e		 jne	 SHORT $LN32@PyInit_sig

; 1036 :             Handlers[i].func = IgnoreHandler;

  001cd	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  001d2	48 6b c0 10	 imul	 rax, 16
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  001dd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR IgnoreHandler
  001e4	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 1037 :         else

  001e9	eb 1c		 jmp	 SHORT $LN31@PyInit_sig
$LN32@PyInit_sig:

; 1038 :             Handlers[i].func = Py_None; /* None of our business */

  001eb	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  001f0	48 6b c0 10	 imul	 rax, 16
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  00202	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx
$LN31@PyInit_sig:
$LN33@PyInit_sig:

; 1039 :         Py_INCREF(Handlers[i].func);

  00207	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0020c	48 6b c0 10	 imul	 rax, 16
  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  00217	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  0021c	e8 00 00 00 00	 call	 _Py_IncRef

; 1040 :     }

  00221	e9 3f ff ff ff	 jmp	 $LN36@PyInit_sig
$LN35@PyInit_sig:

; 1041 :     if (Handlers[SIGINT].func == DefaultHandler) {

  00226	48 8b 05 28 00
	00 00		 mov	 rax, QWORD PTR Handlers+40
  0022d	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR DefaultHandler
  00234	75 3e		 jne	 SHORT $LN30@PyInit_sig

; 1042 :         /* Install default int handler */
; 1043 :         Py_INCREF(IntHandler);

  00236	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IntHandler
  0023d	e8 00 00 00 00	 call	 _Py_IncRef

; 1044 :         Py_DECREF(Handlers[SIGINT].func);

  00242	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR Handlers+40
  00249	e8 00 00 00 00	 call	 _Py_DecRef

; 1045 :         Handlers[SIGINT].func = IntHandler;

  0024e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IntHandler
  00255	48 89 05 28 00
	00 00		 mov	 QWORD PTR Handlers+40, rax

; 1046 :         old_siginthandler = PyOS_setsig(SIGINT, signal_handler);

  0025c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:signal_handler
  00263	b9 02 00 00 00	 mov	 ecx, 2
  00268	e8 00 00 00 00	 call	 PyOS_setsig
  0026d	48 89 05 00 00
	00 00		 mov	 QWORD PTR old_siginthandler, rax
$LN30@PyInit_sig:

; 1047 :     }
; 1048 : 
; 1049 : #ifdef SIGHUP
; 1050 :     x = PyLong_FromLong(SIGHUP);
; 1051 :     PyDict_SetItemString(d, "SIGHUP", x);
; 1052 :     Py_XDECREF(x);
; 1053 : #endif
; 1054 : #ifdef SIGINT
; 1055 :     x = PyLong_FromLong(SIGINT);

  00274	b9 02 00 00 00	 mov	 ecx, 2
  00279	e8 00 00 00 00	 call	 PyLong_FromLong
  0027e	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1056 :     PyDict_SetItemString(d, "SIGINT", x);

  00283	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  00288	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06PAOFCDHL@SIGINT?$AA@
  0028f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00294	e8 00 00 00 00	 call	 PyDict_SetItemString
$LN29@PyInit_sig:

; 1057 :     Py_XDECREF(x);

  00299	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  0029f	74 0a		 je	 SHORT $LN26@PyInit_sig
  002a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  002a6	e8 00 00 00 00	 call	 _Py_DecRef
$LN26@PyInit_sig:
  002ab	33 c0		 xor	 eax, eax
  002ad	85 c0		 test	 eax, eax
  002af	75 e8		 jne	 SHORT $LN29@PyInit_sig

; 1058 : #endif
; 1059 : #ifdef SIGBREAK
; 1060 :     x = PyLong_FromLong(SIGBREAK);

  002b1	b9 15 00 00 00	 mov	 ecx, 21
  002b6	e8 00 00 00 00	 call	 PyLong_FromLong
  002bb	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1061 :     PyDict_SetItemString(d, "SIGBREAK", x);

  002c0	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  002c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CLALOKCJ@SIGBREAK?$AA@
  002cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  002d1	e8 00 00 00 00	 call	 PyDict_SetItemString
$LN25@PyInit_sig:

; 1062 :     Py_XDECREF(x);

  002d6	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  002dc	74 0a		 je	 SHORT $LN22@PyInit_sig
  002de	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  002e3	e8 00 00 00 00	 call	 _Py_DecRef
$LN22@PyInit_sig:
  002e8	33 c0		 xor	 eax, eax
  002ea	85 c0		 test	 eax, eax
  002ec	75 e8		 jne	 SHORT $LN25@PyInit_sig

; 1063 : #endif
; 1064 : #ifdef SIGQUIT
; 1065 :     x = PyLong_FromLong(SIGQUIT);
; 1066 :     PyDict_SetItemString(d, "SIGQUIT", x);
; 1067 :     Py_XDECREF(x);
; 1068 : #endif
; 1069 : #ifdef SIGILL
; 1070 :     x = PyLong_FromLong(SIGILL);

  002ee	b9 04 00 00 00	 mov	 ecx, 4
  002f3	e8 00 00 00 00	 call	 PyLong_FromLong
  002f8	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1071 :     PyDict_SetItemString(d, "SIGILL", x);

  002fd	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  00302	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06HBHKGPEM@SIGILL?$AA@
  00309	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  0030e	e8 00 00 00 00	 call	 PyDict_SetItemString
$LN21@PyInit_sig:

; 1072 :     Py_XDECREF(x);

  00313	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  00319	74 0a		 je	 SHORT $LN18@PyInit_sig
  0031b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00320	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@PyInit_sig:
  00325	33 c0		 xor	 eax, eax
  00327	85 c0		 test	 eax, eax
  00329	75 e8		 jne	 SHORT $LN21@PyInit_sig

; 1073 : #endif
; 1074 : #ifdef SIGTRAP
; 1075 :     x = PyLong_FromLong(SIGTRAP);
; 1076 :     PyDict_SetItemString(d, "SIGTRAP", x);
; 1077 :     Py_XDECREF(x);
; 1078 : #endif
; 1079 : #ifdef SIGIOT
; 1080 :     x = PyLong_FromLong(SIGIOT);
; 1081 :     PyDict_SetItemString(d, "SIGIOT", x);
; 1082 :     Py_XDECREF(x);
; 1083 : #endif
; 1084 : #ifdef SIGABRT
; 1085 :     x = PyLong_FromLong(SIGABRT);

  0032b	b9 16 00 00 00	 mov	 ecx, 22
  00330	e8 00 00 00 00	 call	 PyLong_FromLong
  00335	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1086 :     PyDict_SetItemString(d, "SIGABRT", x);

  0033a	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  0033f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07GHNLFNAM@SIGABRT?$AA@
  00346	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  0034b	e8 00 00 00 00	 call	 PyDict_SetItemString
$LN17@PyInit_sig:

; 1087 :     Py_XDECREF(x);

  00350	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  00356	74 0a		 je	 SHORT $LN14@PyInit_sig
  00358	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  0035d	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@PyInit_sig:
  00362	33 c0		 xor	 eax, eax
  00364	85 c0		 test	 eax, eax
  00366	75 e8		 jne	 SHORT $LN17@PyInit_sig

; 1088 : #endif
; 1089 : #ifdef SIGEMT
; 1090 :     x = PyLong_FromLong(SIGEMT);
; 1091 :     PyDict_SetItemString(d, "SIGEMT", x);
; 1092 :     Py_XDECREF(x);
; 1093 : #endif
; 1094 : #ifdef SIGFPE
; 1095 :     x = PyLong_FromLong(SIGFPE);

  00368	b9 08 00 00 00	 mov	 ecx, 8
  0036d	e8 00 00 00 00	 call	 PyLong_FromLong
  00372	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1096 :     PyDict_SetItemString(d, "SIGFPE", x);

  00377	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  0037c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06ONOHJOEH@SIGFPE?$AA@
  00383	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00388	e8 00 00 00 00	 call	 PyDict_SetItemString
$LN13@PyInit_sig:

; 1097 :     Py_XDECREF(x);

  0038d	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  00393	74 0a		 je	 SHORT $LN10@PyInit_sig
  00395	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  0039a	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@PyInit_sig:
  0039f	33 c0		 xor	 eax, eax
  003a1	85 c0		 test	 eax, eax
  003a3	75 e8		 jne	 SHORT $LN13@PyInit_sig

; 1098 : #endif
; 1099 : #ifdef SIGKILL
; 1100 :     x = PyLong_FromLong(SIGKILL);
; 1101 :     PyDict_SetItemString(d, "SIGKILL", x);
; 1102 :     Py_XDECREF(x);
; 1103 : #endif
; 1104 : #ifdef SIGBUS
; 1105 :     x = PyLong_FromLong(SIGBUS);
; 1106 :     PyDict_SetItemString(d, "SIGBUS", x);
; 1107 :     Py_XDECREF(x);
; 1108 : #endif
; 1109 : #ifdef SIGSEGV
; 1110 :     x = PyLong_FromLong(SIGSEGV);

  003a5	b9 0b 00 00 00	 mov	 ecx, 11
  003aa	e8 00 00 00 00	 call	 PyLong_FromLong
  003af	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1111 :     PyDict_SetItemString(d, "SIGSEGV", x);

  003b4	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  003b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07MIPHKCEO@SIGSEGV?$AA@
  003c0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  003c5	e8 00 00 00 00	 call	 PyDict_SetItemString
$LN9@PyInit_sig:

; 1112 :     Py_XDECREF(x);

  003ca	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  003d0	74 0a		 je	 SHORT $LN6@PyInit_sig
  003d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  003d7	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@PyInit_sig:
  003dc	33 c0		 xor	 eax, eax
  003de	85 c0		 test	 eax, eax
  003e0	75 e8		 jne	 SHORT $LN9@PyInit_sig

; 1113 : #endif
; 1114 : #ifdef SIGSYS
; 1115 :     x = PyLong_FromLong(SIGSYS);
; 1116 :     PyDict_SetItemString(d, "SIGSYS", x);
; 1117 :     Py_XDECREF(x);
; 1118 : #endif
; 1119 : #ifdef SIGPIPE
; 1120 :     x = PyLong_FromLong(SIGPIPE);
; 1121 :     PyDict_SetItemString(d, "SIGPIPE", x);
; 1122 :     Py_XDECREF(x);
; 1123 : #endif
; 1124 : #ifdef SIGALRM
; 1125 :     x = PyLong_FromLong(SIGALRM);
; 1126 :     PyDict_SetItemString(d, "SIGALRM", x);
; 1127 :     Py_XDECREF(x);
; 1128 : #endif
; 1129 : #ifdef SIGTERM
; 1130 :     x = PyLong_FromLong(SIGTERM);

  003e2	b9 0f 00 00 00	 mov	 ecx, 15
  003e7	e8 00 00 00 00	 call	 PyLong_FromLong
  003ec	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1131 :     PyDict_SetItemString(d, "SIGTERM", x);

  003f1	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  003f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07MJAMNEFP@SIGTERM?$AA@
  003fd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00402	e8 00 00 00 00	 call	 PyDict_SetItemString
$LN5@PyInit_sig:

; 1132 :     Py_XDECREF(x);

  00407	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  0040d	74 0a		 je	 SHORT $LN2@PyInit_sig
  0040f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00414	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PyInit_sig:
  00419	33 c0		 xor	 eax, eax
  0041b	85 c0		 test	 eax, eax
  0041d	75 e8		 jne	 SHORT $LN5@PyInit_sig

; 1133 : #endif
; 1134 : #ifdef SIGUSR1
; 1135 :     x = PyLong_FromLong(SIGUSR1);
; 1136 :     PyDict_SetItemString(d, "SIGUSR1", x);
; 1137 :     Py_XDECREF(x);
; 1138 : #endif
; 1139 : #ifdef SIGUSR2
; 1140 :     x = PyLong_FromLong(SIGUSR2);
; 1141 :     PyDict_SetItemString(d, "SIGUSR2", x);
; 1142 :     Py_XDECREF(x);
; 1143 : #endif
; 1144 : #ifdef SIGCLD
; 1145 :     x = PyLong_FromLong(SIGCLD);
; 1146 :     PyDict_SetItemString(d, "SIGCLD", x);
; 1147 :     Py_XDECREF(x);
; 1148 : #endif
; 1149 : #ifdef SIGCHLD
; 1150 :     x = PyLong_FromLong(SIGCHLD);
; 1151 :     PyDict_SetItemString(d, "SIGCHLD", x);
; 1152 :     Py_XDECREF(x);
; 1153 : #endif
; 1154 : #ifdef SIGPWR
; 1155 :     x = PyLong_FromLong(SIGPWR);
; 1156 :     PyDict_SetItemString(d, "SIGPWR", x);
; 1157 :     Py_XDECREF(x);
; 1158 : #endif
; 1159 : #ifdef SIGIO
; 1160 :     x = PyLong_FromLong(SIGIO);
; 1161 :     PyDict_SetItemString(d, "SIGIO", x);
; 1162 :     Py_XDECREF(x);
; 1163 : #endif
; 1164 : #ifdef SIGURG
; 1165 :     x = PyLong_FromLong(SIGURG);
; 1166 :     PyDict_SetItemString(d, "SIGURG", x);
; 1167 :     Py_XDECREF(x);
; 1168 : #endif
; 1169 : #ifdef SIGWINCH
; 1170 :     x = PyLong_FromLong(SIGWINCH);
; 1171 :     PyDict_SetItemString(d, "SIGWINCH", x);
; 1172 :     Py_XDECREF(x);
; 1173 : #endif
; 1174 : #ifdef SIGPOLL
; 1175 :     x = PyLong_FromLong(SIGPOLL);
; 1176 :     PyDict_SetItemString(d, "SIGPOLL", x);
; 1177 :     Py_XDECREF(x);
; 1178 : #endif
; 1179 : #ifdef SIGSTOP
; 1180 :     x = PyLong_FromLong(SIGSTOP);
; 1181 :     PyDict_SetItemString(d, "SIGSTOP", x);
; 1182 :     Py_XDECREF(x);
; 1183 : #endif
; 1184 : #ifdef SIGTSTP
; 1185 :     x = PyLong_FromLong(SIGTSTP);
; 1186 :     PyDict_SetItemString(d, "SIGTSTP", x);
; 1187 :     Py_XDECREF(x);
; 1188 : #endif
; 1189 : #ifdef SIGCONT
; 1190 :     x = PyLong_FromLong(SIGCONT);
; 1191 :     PyDict_SetItemString(d, "SIGCONT", x);
; 1192 :     Py_XDECREF(x);
; 1193 : #endif
; 1194 : #ifdef SIGTTIN
; 1195 :     x = PyLong_FromLong(SIGTTIN);
; 1196 :     PyDict_SetItemString(d, "SIGTTIN", x);
; 1197 :     Py_XDECREF(x);
; 1198 : #endif
; 1199 : #ifdef SIGTTOU
; 1200 :     x = PyLong_FromLong(SIGTTOU);
; 1201 :     PyDict_SetItemString(d, "SIGTTOU", x);
; 1202 :     Py_XDECREF(x);
; 1203 : #endif
; 1204 : #ifdef SIGVTALRM
; 1205 :     x = PyLong_FromLong(SIGVTALRM);
; 1206 :     PyDict_SetItemString(d, "SIGVTALRM", x);
; 1207 :     Py_XDECREF(x);
; 1208 : #endif
; 1209 : #ifdef SIGPROF
; 1210 :     x = PyLong_FromLong(SIGPROF);
; 1211 :     PyDict_SetItemString(d, "SIGPROF", x);
; 1212 :     Py_XDECREF(x);
; 1213 : #endif
; 1214 : #ifdef SIGXCPU
; 1215 :     x = PyLong_FromLong(SIGXCPU);
; 1216 :     PyDict_SetItemString(d, "SIGXCPU", x);
; 1217 :     Py_XDECREF(x);
; 1218 : #endif
; 1219 : #ifdef SIGXFSZ
; 1220 :     x = PyLong_FromLong(SIGXFSZ);
; 1221 :     PyDict_SetItemString(d, "SIGXFSZ", x);
; 1222 :     Py_XDECREF(x);
; 1223 : #endif
; 1224 : #ifdef SIGRTMIN
; 1225 :     x = PyLong_FromLong(SIGRTMIN);
; 1226 :     PyDict_SetItemString(d, "SIGRTMIN", x);
; 1227 :     Py_XDECREF(x);
; 1228 : #endif
; 1229 : #ifdef SIGRTMAX
; 1230 :     x = PyLong_FromLong(SIGRTMAX);
; 1231 :     PyDict_SetItemString(d, "SIGRTMAX", x);
; 1232 :     Py_XDECREF(x);
; 1233 : #endif
; 1234 : #ifdef SIGINFO
; 1235 :     x = PyLong_FromLong(SIGINFO);
; 1236 :     PyDict_SetItemString(d, "SIGINFO", x);
; 1237 :     Py_XDECREF(x);
; 1238 : #endif
; 1239 : 
; 1240 : #ifdef ITIMER_REAL
; 1241 :     x = PyLong_FromLong(ITIMER_REAL);
; 1242 :     PyDict_SetItemString(d, "ITIMER_REAL", x);
; 1243 :     Py_DECREF(x);
; 1244 : #endif
; 1245 : #ifdef ITIMER_VIRTUAL
; 1246 :     x = PyLong_FromLong(ITIMER_VIRTUAL);
; 1247 :     PyDict_SetItemString(d, "ITIMER_VIRTUAL", x);
; 1248 :     Py_DECREF(x);
; 1249 : #endif
; 1250 : #ifdef ITIMER_PROF
; 1251 :     x = PyLong_FromLong(ITIMER_PROF);
; 1252 :     PyDict_SetItemString(d, "ITIMER_PROF", x);
; 1253 :     Py_DECREF(x);
; 1254 : #endif
; 1255 : 
; 1256 : #if defined (HAVE_SETITIMER) || defined (HAVE_GETITIMER)
; 1257 :     ItimerError = PyErr_NewException("signal.ItimerError",
; 1258 :      PyExc_IOError, NULL);
; 1259 :     if (ItimerError != NULL)
; 1260 :     PyDict_SetItemString(d, "ItimerError", ItimerError);
; 1261 : #endif
; 1262 : 
; 1263 : #ifdef CTRL_C_EVENT
; 1264 :     x = PyLong_FromLong(CTRL_C_EVENT);

  0041f	33 c9		 xor	 ecx, ecx
  00421	e8 00 00 00 00	 call	 PyLong_FromLong
  00426	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1265 :     PyDict_SetItemString(d, "CTRL_C_EVENT", x);

  0042b	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  00430	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@FEFOEFHG@CTRL_C_EVENT?$AA@
  00437	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  0043c	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1266 :     Py_DECREF(x);

  00441	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00446	e8 00 00 00 00	 call	 _Py_DecRef

; 1267 : #endif
; 1268 : 
; 1269 : #ifdef CTRL_BREAK_EVENT
; 1270 :     x = PyLong_FromLong(CTRL_BREAK_EVENT);

  0044b	b9 01 00 00 00	 mov	 ecx, 1
  00450	e8 00 00 00 00	 call	 PyLong_FromLong
  00455	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1271 :     PyDict_SetItemString(d, "CTRL_BREAK_EVENT", x);

  0045a	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  0045f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@ELEIIFAE@CTRL_BREAK_EVENT?$AA@
  00466	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  0046b	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1272 :     Py_DECREF(x);

  00470	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00475	e8 00 00 00 00	 call	 _Py_DecRef

; 1273 : #endif
; 1274 : 
; 1275 : #ifdef MS_WINDOWS
; 1276 :     /* Create manual-reset event, initially unset */
; 1277 :     sigint_event = CreateEvent(NULL, TRUE, FALSE, FALSE);

  0047a	45 33 c9	 xor	 r9d, r9d
  0047d	45 33 c0	 xor	 r8d, r8d
  00480	ba 01 00 00 00	 mov	 edx, 1
  00485	33 c9		 xor	 ecx, ecx
  00487	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateEventA
  0048d	48 89 05 00 00
	00 00		 mov	 QWORD PTR sigint_event, rax

; 1278 : #endif
; 1279 : 
; 1280 :     if (PyErr_Occurred()) {

  00494	e8 00 00 00 00	 call	 PyErr_Occurred
  00499	48 85 c0	 test	 rax, rax
  0049c	74 13		 je	 SHORT $LN1@PyInit_sig

; 1281 :         Py_DECREF(m);

  0049e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  004a3	e8 00 00 00 00	 call	 _Py_DecRef

; 1282 :         m = NULL;

  004a8	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR m$[rsp], 0
$LN1@PyInit_sig:
$finally$120968:

; 1283 :     }
; 1284 : 
; 1285 :   finally:
; 1286 :     return m;

  004b1	48 8b 44 24 38	 mov	 rax, QWORD PTR m$[rsp]
$LN46@PyInit_sig:

; 1287 : }

  004b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  004ba	c3		 ret	 0
PyInit_signal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@		; `string'
EXTRN	PyEval_CallObjectWithKeywords:PROC
EXTRN	Py_BuildValue:PROC
EXTRN	PyEval_GetFrame:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\signalmodule.c
pdata	SEGMENT
$pdata$PyErr_CheckSignals DD imagerel $LN13
	DD	imagerel $LN13+307
	DD	imagerel $unwind$PyErr_CheckSignals
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyErr_CheckSignals DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@
CONST	SEGMENT
??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@ DB '(iO)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyErr_CheckSignals
_TEXT	SEGMENT
i$ = 32
f$ = 40
arglist$121110 = 48
result$121108 = 56
PyErr_CheckSignals PROC					; COMDAT

; 1317 : {

$LN13:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1318 :     int i;
; 1319 :     PyObject *f;
; 1320 : 
; 1321 : #ifdef WITH_PARALLEL
; 1322 :     if (Py_PXCTX)

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN10@PyErr_Chec

; 1323 :         return 0;

  0000d	33 c0		 xor	 eax, eax
  0000f	e9 1a 01 00 00	 jmp	 $LN11@PyErr_Chec
$LN10@PyErr_Chec:

; 1324 : #endif
; 1325 : 
; 1326 :     if (!is_tripped)

  00014	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR is_tripped
  0001a	85 c0		 test	 eax, eax
  0001c	75 07		 jne	 SHORT $LN9@PyErr_Chec

; 1327 :         return 0;

  0001e	33 c0		 xor	 eax, eax
  00020	e9 09 01 00 00	 jmp	 $LN11@PyErr_Chec
$LN9@PyErr_Chec:

; 1328 : 
; 1329 : #ifdef WITH_THREAD
; 1330 :     if (PyThread_get_thread_ident() != main_thread)

  00025	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0002a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread
  00030	74 07		 je	 SHORT $LN8@PyErr_Chec

; 1331 :         return 0;

  00032	33 c0		 xor	 eax, eax
  00034	e9 f5 00 00 00	 jmp	 $LN11@PyErr_Chec
$LN8@PyErr_Chec:

; 1332 : #endif
; 1333 : 
; 1334 :     /*
; 1335 :      * The is_tripped variable is meant to speed up the calls to
; 1336 :      * PyErr_CheckSignals (both directly or via pending calls) when no
; 1337 :      * signal has arrived. This variable is set to 1 when a signal arrives
; 1338 :      * and it is set to 0 here, when we know some signals arrived. This way
; 1339 :      * we can run the registered handlers with no signals blocked.
; 1340 :      *
; 1341 :      * NOTE: with this approach we can have a situation where is_tripped is
; 1342 :      *       1 but we have no more signals to handle (Handlers[i].tripped
; 1343 :      *       is 0 for every signal i). This won't do us any harm (except
; 1344 :      *       we're gonna spent some cycles for nothing). This happens when
; 1345 :      *       we receive a signal i after we zero is_tripped and before we
; 1346 :      *       check Handlers[i].tripped.
; 1347 :      */
; 1348 :     is_tripped = 0;

  00039	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR is_tripped, 0

; 1349 : 
; 1350 :     if (!(f = (PyObject *)PyEval_GetFrame()))

  00043	e8 00 00 00 00	 call	 PyEval_GetFrame
  00048	48 89 44 24 28	 mov	 QWORD PTR f$[rsp], rax
  0004d	48 83 7c 24 28
	00		 cmp	 QWORD PTR f$[rsp], 0
  00053	75 0c		 jne	 SHORT $LN7@PyErr_Chec

; 1351 :         f = Py_None;

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0005c	48 89 44 24 28	 mov	 QWORD PTR f$[rsp], rax
$LN7@PyErr_Chec:

; 1352 : 
; 1353 :     for (i = 1; i < NSIG; i++) {

  00061	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00069	eb 0a		 jmp	 SHORT $LN6@PyErr_Chec
$LN5@PyErr_Chec:
  0006b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0006f	ff c0		 inc	 eax
  00071	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN6@PyErr_Chec:
  00075	83 7c 24 20 17	 cmp	 DWORD PTR i$[rsp], 23
  0007a	0f 8d ac 00 00
	00		 jge	 $LN4@PyErr_Chec

; 1354 :         if (Handlers[i].tripped) {

  00080	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00085	48 6b c0 10	 imul	 rax, 16
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  00090	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00093	85 c0		 test	 eax, eax
  00095	0f 84 8c 00 00
	00		 je	 $LN3@PyErr_Chec

; 1355 :             PyObject *result = NULL;

  0009b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR result$121108[rsp], 0

; 1356 :             PyObject *arglist = Py_BuildValue("(iO)", i, f);

  000a4	4c 8b 44 24 28	 mov	 r8, QWORD PTR f$[rsp]
  000a9	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@
  000b4	e8 00 00 00 00	 call	 Py_BuildValue
  000b9	48 89 44 24 30	 mov	 QWORD PTR arglist$121110[rsp], rax

; 1357 :             Handlers[i].tripped = 0;

  000be	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000c3	48 6b c0 10	 imul	 rax, 16
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  000ce	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [rcx+rax], 0

; 1358 : 
; 1359 :             if (arglist) {

  000d5	48 83 7c 24 30
	00		 cmp	 QWORD PTR arglist$121110[rsp], 0
  000db	74 31		 je	 SHORT $LN2@PyErr_Chec

; 1360 :                 result = PyEval_CallObject(Handlers[i].func,
; 1361 :                                            arglist);

  000dd	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000e2	48 6b c0 10	 imul	 rax, 16
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  000ed	45 33 c0	 xor	 r8d, r8d
  000f0	48 8b 54 24 30	 mov	 rdx, QWORD PTR arglist$121110[rsp]
  000f5	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  000fa	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords
  000ff	48 89 44 24 38	 mov	 QWORD PTR result$121108[rsp], rax

; 1362 :                 Py_DECREF(arglist);

  00104	48 8b 4c 24 30	 mov	 rcx, QWORD PTR arglist$121110[rsp]
  00109	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PyErr_Chec:

; 1363 :             }
; 1364 :             if (!result)

  0010e	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$121108[rsp], 0
  00114	75 07		 jne	 SHORT $LN1@PyErr_Chec

; 1365 :                 return -1;

  00116	b8 ff ff ff ff	 mov	 eax, -1
  0011b	eb 11		 jmp	 SHORT $LN11@PyErr_Chec
$LN1@PyErr_Chec:

; 1366 : 
; 1367 :             Py_DECREF(result);

  0011d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$121108[rsp]
  00122	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyErr_Chec:

; 1368 :         }
; 1369 :     }

  00127	e9 3f ff ff ff	 jmp	 $LN5@PyErr_Chec
$LN4@PyErr_Chec:

; 1370 : 
; 1371 :     return 0;

  0012c	33 c0		 xor	 eax, eax
$LN11@PyErr_Chec:

; 1372 : }

  0012e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00132	c3		 ret	 0
PyErr_CheckSignals ENDP
_TEXT	ENDS
PUBLIC	PyErr_SetInterrupt
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyErr_SetInterrupt DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$PyErr_SetInterrupt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyErr_SetInterrupt DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyErr_SetInterrupt
_TEXT	SEGMENT
PyErr_SetInterrupt PROC					; COMDAT

; 1380 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1381 :     trip_signal(SIGINT);

  00004	b9 02 00 00 00	 mov	 ecx, 2
  00009	e8 00 00 00 00	 call	 trip_signal

; 1382 : }

  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
PyErr_SetInterrupt ENDP
_TEXT	ENDS
PUBLIC	PyOS_InitInterrupts
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_InitInterrupts DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$PyOS_InitInterrupts
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_InitInterrupts DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyOS_InitInterrupts
_TEXT	SEGMENT
m$ = 32
PyOS_InitInterrupts PROC				; COMDAT

; 1386 : {

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1387 :     PyObject *m = PyImport_ImportModule("signal");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06OAFOBKHE@signal?$AA@
  0000b	e8 00 00 00 00	 call	 PyImport_ImportModule
  00010	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1388 :     if (m) {

  00015	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  0001b	74 0a		 je	 SHORT $LN1@PyOS_InitI

; 1389 :         Py_DECREF(m);

  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  00022	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyOS_InitI:

; 1390 :     }
; 1391 : }

  00027	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002b	c3		 ret	 0
PyOS_InitInterrupts ENDP
_TEXT	ENDS
PUBLIC	PyOS_FiniInterrupts
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_FiniInterrupts DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$PyOS_FiniInterrupts
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_FiniInterrupts DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyOS_FiniInterrupts
_TEXT	SEGMENT
PyOS_FiniInterrupts PROC				; COMDAT

; 1395 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1396 :     finisignal();

  00004	e8 00 00 00 00	 call	 finisignal

; 1397 : }

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
PyOS_FiniInterrupts ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@NICDOGIB@finisignal?$AA@		; `string'
PUBLIC	??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$finisignal DD imagerel finisignal
	DD	imagerel finisignal+518
	DD	imagerel $unwind$finisignal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$finisignal DD 010401H
	DD	0c204H
xdata	ENDS
;	COMDAT ??_C@_0L@NICDOGIB@finisignal?$AA@
CONST	SEGMENT
??_C@_0L@NICDOGIB@finisignal?$AA@ DB 'finisignal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@
CONST	SEGMENT
??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@ DB '..\Modules\sig'
	DB	'nalmodule.c', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT finisignal
_TEXT	SEGMENT
i$ = 48
func$ = 56
_py_tmp$121075 = 64
_py_tmp$121083 = 72
_py_tmp$121091 = 80
finisignal PROC						; COMDAT

; 1291 : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1292 :     int i;
; 1293 :     PyObject *func;
; 1294 : 
; 1295 :     PyOS_setsig(SIGINT, old_siginthandler);

  00004	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR old_siginthandler
  0000b	b9 02 00 00 00	 mov	 ecx, 2
  00010	e8 00 00 00 00	 call	 PyOS_setsig

; 1296 :     old_siginthandler = SIG_DFL;

  00015	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR old_siginthandler, 0

; 1297 : 
; 1298 :     for (i = 1; i < NSIG; i++) {

  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00028	eb 0a		 jmp	 SHORT $LN20@finisignal
$LN19@finisignal:
  0002a	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0002e	ff c0		 inc	 eax
  00030	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN20@finisignal:
  00034	83 7c 24 30 17	 cmp	 DWORD PTR i$[rsp], 23
  00039	0f 8d ab 00 00
	00		 jge	 $LN18@finisignal

; 1299 :         func = Handlers[i].func;

  0003f	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00044	48 6b c0 10	 imul	 rax, 16
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  0004f	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00054	48 89 44 24 38	 mov	 QWORD PTR func$[rsp], rax

; 1300 :         Handlers[i].tripped = 0;

  00059	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0005e	48 6b c0 10	 imul	 rax, 16
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  00069	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [rcx+rax], 0

; 1301 :         Handlers[i].func = NULL;

  00070	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00075	48 6b c0 10	 imul	 rax, 16
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  00080	48 c7 44 01 08
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+8], 0

; 1302 :         if (i != SIGINT && func != NULL && func != Py_None &&
; 1303 :             func != DefaultHandler && func != IgnoreHandler)

  00089	83 7c 24 30 02	 cmp	 DWORD PTR i$[rsp], 2
  0008e	74 3d		 je	 SHORT $LN17@finisignal
  00090	48 83 7c 24 38
	00		 cmp	 QWORD PTR func$[rsp], 0
  00096	74 35		 je	 SHORT $LN17@finisignal
  00098	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0009f	48 39 44 24 38	 cmp	 QWORD PTR func$[rsp], rax
  000a4	74 27		 je	 SHORT $LN17@finisignal
  000a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DefaultHandler
  000ad	48 39 44 24 38	 cmp	 QWORD PTR func$[rsp], rax
  000b2	74 19		 je	 SHORT $LN17@finisignal
  000b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IgnoreHandler
  000bb	48 39 44 24 38	 cmp	 QWORD PTR func$[rsp], rax
  000c0	74 0b		 je	 SHORT $LN17@finisignal

; 1304 :             PyOS_setsig(i, SIG_DFL);

  000c2	33 d2		 xor	 edx, edx
  000c4	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  000c8	e8 00 00 00 00	 call	 PyOS_setsig
$LN17@finisignal:
$LN16@finisignal:

; 1305 :         Py_XDECREF(func);

  000cd	48 83 7c 24 38
	00		 cmp	 QWORD PTR func$[rsp], 0
  000d3	74 0a		 je	 SHORT $LN13@finisignal
  000d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR func$[rsp]
  000da	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@finisignal:
  000df	33 c0		 xor	 eax, eax
  000e1	85 c0		 test	 eax, eax
  000e3	75 e8		 jne	 SHORT $LN16@finisignal

; 1306 :     }

  000e5	e9 40 ff ff ff	 jmp	 $LN19@finisignal
$LN18@finisignal:
$LN12@finisignal:

; 1307 : 
; 1308 :     Py_CLEAR(IntHandler);

  000ea	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR IntHandler, 0
  000f2	74 4d		 je	 SHORT $LN9@finisignal
  000f4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000fc	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR IntHandler
  00103	41 b8 1c 05 00
	00		 mov	 r8d, 1308		; 0000051cH
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NICDOGIB@finisignal?$AA@
  00117	e8 00 00 00 00	 call	 _PyParallel_Guard
  0011c	85 c0		 test	 eax, eax
  0011e	75 21		 jne	 SHORT $LN9@finisignal
  00120	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IntHandler
  00127	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$121075[rsp], rax
  0012c	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR IntHandler, 0
  00137	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$121075[rsp]
  0013c	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@finisignal:
  00141	33 c0		 xor	 eax, eax
  00143	85 c0		 test	 eax, eax
  00145	75 a3		 jne	 SHORT $LN12@finisignal
$LN8@finisignal:

; 1309 :     Py_CLEAR(DefaultHandler);

  00147	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR DefaultHandler, 0
  0014f	74 4d		 je	 SHORT $LN5@finisignal
  00151	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00159	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR DefaultHandler
  00160	41 b8 1d 05 00
	00		 mov	 r8d, 1309		; 0000051dH
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NICDOGIB@finisignal?$AA@
  00174	e8 00 00 00 00	 call	 _PyParallel_Guard
  00179	85 c0		 test	 eax, eax
  0017b	75 21		 jne	 SHORT $LN5@finisignal
  0017d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DefaultHandler
  00184	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$121083[rsp], rax
  00189	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR DefaultHandler, 0
  00194	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$121083[rsp]
  00199	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@finisignal:
  0019e	33 c0		 xor	 eax, eax
  001a0	85 c0		 test	 eax, eax
  001a2	75 a3		 jne	 SHORT $LN8@finisignal
$LN4@finisignal:

; 1310 :     Py_CLEAR(IgnoreHandler);

  001a4	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR IgnoreHandler, 0
  001ac	74 4d		 je	 SHORT $LN1@finisignal
  001ae	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001b6	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR IgnoreHandler
  001bd	41 b8 1e 05 00
	00		 mov	 r8d, 1310		; 0000051eH
  001c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NICDOGIB@finisignal?$AA@
  001d1	e8 00 00 00 00	 call	 _PyParallel_Guard
  001d6	85 c0		 test	 eax, eax
  001d8	75 21		 jne	 SHORT $LN1@finisignal
  001da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IgnoreHandler
  001e1	48 89 44 24 50	 mov	 QWORD PTR _py_tmp$121091[rsp], rax
  001e6	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR IgnoreHandler, 0
  001f1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _py_tmp$121091[rsp]
  001f6	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@finisignal:
  001fb	33 c0		 xor	 eax, eax
  001fd	85 c0		 test	 eax, eax
  001ff	75 a3		 jne	 SHORT $LN4@finisignal

; 1311 : }

  00201	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00205	c3		 ret	 0
finisignal ENDP
_TEXT	ENDS
PUBLIC	PyOS_InterruptOccurred
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_InterruptOccurred DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$PyOS_InterruptOccurred
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_InterruptOccurred DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyOS_InterruptOccurred
_TEXT	SEGMENT
PyOS_InterruptOccurred PROC				; COMDAT

; 1401 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1402 :     if (Handlers[SIGINT].tripped) {

  00004	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR Handlers+32
  0000a	85 c0		 test	 eax, eax
  0000c	74 22		 je	 SHORT $LN2@PyOS_Inter

; 1403 : #ifdef WITH_THREAD
; 1404 :         if (PyThread_get_thread_ident() != main_thread)

  0000e	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00013	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread
  00019	74 04		 je	 SHORT $LN1@PyOS_Inter

; 1405 :             return 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 13		 jmp	 SHORT $LN3@PyOS_Inter
$LN1@PyOS_Inter:

; 1406 : #endif
; 1407 :         Handlers[SIGINT].tripped = 0;

  0001f	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR Handlers+32, 0

; 1408 :         return 1;

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	eb 02		 jmp	 SHORT $LN3@PyOS_Inter
$LN2@PyOS_Inter:

; 1409 :     }
; 1410 :     return 0;

  00030	33 c0		 xor	 eax, eax
$LN3@PyOS_Inter:

; 1411 : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
PyOS_InterruptOccurred ENDP
_TEXT	ENDS
PUBLIC	PyOS_AfterFork
EXTRN	_PyImport_ReInitLock:PROC
EXTRN	PyEval_ReInitThreads:PROC
EXTRN	_PyGILState_Reinit:PROC
EXTRN	PyThread_ReInitTLS:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_AfterFork DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$PyOS_AfterFork
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_AfterFork DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyOS_AfterFork
_TEXT	SEGMENT
PyOS_AfterFork PROC					; COMDAT

; 1427 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1428 :     /* Clear the signal flags after forking so that they aren't handled
; 1429 :      * in both processes if they came in just before the fork() but before
; 1430 :      * the interpreter had an opportunity to call the handlers.  issue9535. */
; 1431 :     _clear_pending_signals();

  00004	e8 00 00 00 00	 call	 _clear_pending_signals

; 1432 : #ifdef WITH_THREAD
; 1433 :     /* PyThread_ReInitTLS() must be called early, to make sure that the TLS API
; 1434 :      * can be called safely. */
; 1435 :     PyThread_ReInitTLS();

  00009	e8 00 00 00 00	 call	 PyThread_ReInitTLS

; 1436 :     _PyGILState_Reinit();

  0000e	e8 00 00 00 00	 call	 _PyGILState_Reinit

; 1437 :     PyEval_ReInitThreads();

  00013	e8 00 00 00 00	 call	 PyEval_ReInitThreads

; 1438 :     main_thread = PyThread_get_thread_ident();

  00018	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0001d	89 05 00 00 00
	00		 mov	 DWORD PTR main_thread, eax

; 1439 :     main_pid = getpid();

  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  00029	89 05 00 00 00
	00		 mov	 DWORD PTR main_pid, eax

; 1440 :     _PyImport_ReInitLock();

  0002f	e8 00 00 00 00	 call	 _PyImport_ReInitLock

; 1441 : #endif
; 1442 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
PyOS_AfterFork ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_clear_pending_signals DD imagerel _clear_pending_signals
	DD	imagerel _clear_pending_signals+78
	DD	imagerel $unwind$_clear_pending_signals
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_clear_pending_signals DD 010401H
	DD	02204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _clear_pending_signals
_TEXT	SEGMENT
i$ = 0
_clear_pending_signals PROC				; COMDAT

; 1415 : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 1416 :     int i;
; 1417 :     if (!is_tripped)

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR is_tripped
  0000a	85 c0		 test	 eax, eax
  0000c	75 02		 jne	 SHORT $LN4@clear_pend

; 1418 :         return;

  0000e	eb 39		 jmp	 SHORT $LN5@clear_pend
$LN4@clear_pend:

; 1419 :     is_tripped = 0;

  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR is_tripped, 0

; 1420 :     for (i = 1; i < NSIG; ++i) {

  0001a	c7 04 24 01 00
	00 00		 mov	 DWORD PTR i$[rsp], 1
  00021	eb 08		 jmp	 SHORT $LN3@clear_pend
$LN2@clear_pend:
  00023	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00026	ff c0		 inc	 eax
  00028	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN3@clear_pend:
  0002b	83 3c 24 17	 cmp	 DWORD PTR i$[rsp], 23
  0002f	7d 18		 jge	 SHORT $LN1@clear_pend

; 1421 :         Handlers[i].tripped = 0;

  00031	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00035	48 6b c0 10	 imul	 rax, 16
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Handlers
  00040	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [rcx+rax], 0

; 1422 :     }

  00047	eb da		 jmp	 SHORT $LN2@clear_pend
$LN1@clear_pend:
$LN5@clear_pend:

; 1423 : }

  00049	48 83 c4 18	 add	 rsp, 24
  0004d	c3		 ret	 0
_clear_pending_signals ENDP
_TEXT	ENDS
PUBLIC	_PyOS_IsMainThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyOS_IsMainThread DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$_PyOS_IsMainThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyOS_IsMainThread DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyOS_IsMainThread
_TEXT	SEGMENT
tv66 = 32
_PyOS_IsMainThread PROC					; COMDAT

; 1446 : {

$LN5:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1447 : #ifdef WITH_THREAD
; 1448 :     return PyThread_get_thread_ident() == main_thread;

  00004	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00009	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread
  0000f	75 0a		 jne	 SHORT $LN3@PyOS_IsMai
  00011	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00019	eb 08		 jmp	 SHORT $LN4@PyOS_IsMai
$LN3@PyOS_IsMai:
  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN4@PyOS_IsMai:
  00023	8b 44 24 20	 mov	 eax, DWORD PTR tv66[rsp]

; 1449 : #else
; 1450 :     return 1;
; 1451 : #endif
; 1452 : }

  00027	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002b	c3		 ret	 0
_PyOS_IsMainThread ENDP
_TEXT	ENDS
PUBLIC	_PyOS_SigintEvent
; Function compile flags: /Odtp
;	COMDAT _PyOS_SigintEvent
_TEXT	SEGMENT
_PyOS_SigintEvent PROC					; COMDAT

; 1457 :     /* Returns a manual-reset event which gets tripped whenever
; 1458 :        SIGINT is received.
; 1459 : 
; 1460 :        Python.h does not include windows.h so we do cannot use HANDLE
; 1461 :        as the return type of this function.  We use void* instead. */
; 1462 :     return sigint_event;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR sigint_event

; 1463 : }

  00007	c3		 ret	 0
_PyOS_SigintEvent ENDP
_TEXT	ENDS
END
