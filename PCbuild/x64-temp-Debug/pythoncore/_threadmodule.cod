; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07CNDFADNJ@_thread?$AA@			; `string'
PUBLIC	??_C@_0L@NELPJPHD@stack_size?$AA@		; `string'
PUBLIC	??_C@_06HHPHCOMB@_count?$AA@			; `string'
PUBLIC	??_C@_09ICJGJIKJ@get_ident?$AA@			; `string'
PUBLIC	??_C@_0P@GILDALKM@interrupt_main?$AA@		; `string'
PUBLIC	??_C@_04MKNBDEPB@exit?$AA@			; `string'
PUBLIC	??_C@_0M@EHGPAPBC@exit_thread?$AA@		; `string'
PUBLIC	??_C@_08HGGEJCMJ@allocate?$AA@			; `string'
PUBLIC	??_C@_0O@MLDABOCH@allocate_lock?$AA@		; `string'
PUBLIC	??_C@_09BEJJCLOL@start_new?$AA@			; `string'
PUBLIC	??_C@_0BB@NIEJKBPO@start_new_thread?$AA@	; `string'
PUBLIC	??_C@_0BC@GKOPAEKP@Thread?9local?5data?$AA@	; `string'
PUBLIC	??_C@_0P@HHKNGPPL@_thread?4_local?$AA@		; `string'
PUBLIC	??_C@_0BG@MBDGPDAK@_localdummy_destroyed?$AA@	; `string'
PUBLIC	??_C@_0BD@JJFEDPB@Thread?9local?5dummy?$AA@	; `string'
PUBLIC	??_C@_0BE@DIJGDAPK@_thread?4_localdummy?$AA@	; `string'
PUBLIC	??_C@_0O@GJOLJECC@_thread?4RLock?$AA@		; `string'
PUBLIC	??_C@_0O@GAANLLMC@_release_save?$AA@		; `string'
PUBLIC	??_C@_0BB@LNGBJLEI@_acquire_restore?$AA@	; `string'
PUBLIC	??_C@_09HFMMNEJG@_is_owned?$AA@			; `string'
PUBLIC	??_C@_0N@FKGDBBBI@_thread?4lock?$AA@		; `string'
PUBLIC	??_C@_08CMFIGCJD@__exit__?$AA@			; `string'
PUBLIC	??_C@_09OAJHKKGH@__enter__?$AA@			; `string'
PUBLIC	??_C@_06KKBPGBGI@locked?$AA@			; `string'
PUBLIC	??_C@_0M@GHINBMOK@locked_lock?$AA@		; `string'
PUBLIC	??_C@_07EOGFDLKI@release?$AA@			; `string'
PUBLIC	??_C@_0N@EJFMMAJJ@release_lock?$AA@		; `string'
PUBLIC	??_C@_07MEFPPMEF@acquire?$AA@			; `string'
PUBLIC	??_C@_0N@JKBCAFMP@acquire_lock?$AA@		; `string'
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyType_Type:BYTE
_BSS	SEGMENT
nb_threads DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_07CNDFADNJ@_thread?$AA@
CONST	SEGMENT
??_C@_07CNDFADNJ@_thread?$AA@ DB '_thread', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NELPJPHD@stack_size?$AA@
CONST	SEGMENT
??_C@_0L@NELPJPHD@stack_size?$AA@ DB 'stack_size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HHPHCOMB@_count?$AA@
CONST	SEGMENT
??_C@_06HHPHCOMB@_count?$AA@ DB '_count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICJGJIKJ@get_ident?$AA@
CONST	SEGMENT
??_C@_09ICJGJIKJ@get_ident?$AA@ DB 'get_ident', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GILDALKM@interrupt_main?$AA@
CONST	SEGMENT
??_C@_0P@GILDALKM@interrupt_main?$AA@ DB 'interrupt_main', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit?$AA@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit?$AA@ DB 'exit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EHGPAPBC@exit_thread?$AA@
CONST	SEGMENT
??_C@_0M@EHGPAPBC@exit_thread?$AA@ DB 'exit_thread', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HGGEJCMJ@allocate?$AA@
CONST	SEGMENT
??_C@_08HGGEJCMJ@allocate?$AA@ DB 'allocate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLDABOCH@allocate_lock?$AA@
CONST	SEGMENT
??_C@_0O@MLDABOCH@allocate_lock?$AA@ DB 'allocate_lock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BEJJCLOL@start_new?$AA@
CONST	SEGMENT
??_C@_09BEJJCLOL@start_new?$AA@ DB 'start_new', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NIEJKBPO@start_new_thread?$AA@
CONST	SEGMENT
??_C@_0BB@NIEJKBPO@start_new_thread?$AA@ DB 'start_new_thread', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GKOPAEKP@Thread?9local?5data?$AA@
CONST	SEGMENT
??_C@_0BC@GKOPAEKP@Thread?9local?5data?$AA@ DB 'Thread-local data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHKNGPPL@_thread?4_local?$AA@
CONST	SEGMENT
??_C@_0P@HHKNGPPL@_thread?4_local?$AA@ DB '_thread._local', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MBDGPDAK@_localdummy_destroyed?$AA@
CONST	SEGMENT
??_C@_0BG@MBDGPDAK@_localdummy_destroyed?$AA@ DB '_localdummy_destroyed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JJFEDPB@Thread?9local?5dummy?$AA@
CONST	SEGMENT
??_C@_0BD@JJFEDPB@Thread?9local?5dummy?$AA@ DB 'Thread-local dummy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DIJGDAPK@_thread?4_localdummy?$AA@
CONST	SEGMENT
??_C@_0BE@DIJGDAPK@_thread?4_localdummy?$AA@ DB '_thread._localdummy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GJOLJECC@_thread?4RLock?$AA@
CONST	SEGMENT
??_C@_0O@GJOLJECC@_thread?4RLock?$AA@ DB '_thread.RLock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GAANLLMC@_release_save?$AA@
CONST	SEGMENT
??_C@_0O@GAANLLMC@_release_save?$AA@ DB '_release_save', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNGBJLEI@_acquire_restore?$AA@
CONST	SEGMENT
??_C@_0BB@LNGBJLEI@_acquire_restore?$AA@ DB '_acquire_restore', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HFMMNEJG@_is_owned?$AA@
CONST	SEGMENT
??_C@_09HFMMNEJG@_is_owned?$AA@ DB '_is_owned', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FKGDBBBI@_thread?4lock?$AA@
CONST	SEGMENT
??_C@_0N@FKGDBBBI@_thread?4lock?$AA@ DB '_thread.lock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMFIGCJD@__exit__?$AA@
CONST	SEGMENT
??_C@_08CMFIGCJD@__exit__?$AA@ DB '__exit__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAJHKKGH@__enter__?$AA@
CONST	SEGMENT
??_C@_09OAJHKKGH@__enter__?$AA@ DB '__enter__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KKBPGBGI@locked?$AA@
CONST	SEGMENT
??_C@_06KKBPGBGI@locked?$AA@ DB 'locked', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GHINBMOK@locked_lock?$AA@
CONST	SEGMENT
??_C@_0M@GHINBMOK@locked_lock?$AA@ DB 'locked_lock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOGFDLKI@release?$AA@
CONST	SEGMENT
??_C@_07EOGFDLKI@release?$AA@ DB 'release', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EJFMMAJJ@release_lock?$AA@
CONST	SEGMENT
??_C@_0N@EJFMMAJJ@release_lock?$AA@ DB 'release_lock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEFPPMEF@acquire?$AA@
CONST	SEGMENT
??_C@_07MEFPPMEF@acquire?$AA@ DB 'acquire', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JKBCAFMP@acquire_lock?$AA@
CONST	SEGMENT
??_C@_0N@JKBCAFMP@acquire_lock?$AA@ DB 'acquire_lock', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
acquire_doc DB	'acquire([wait]) -> bool', 0aH, '(acquire_lock() is an ob'
	DB	'solete synonym)', 0aH, 0aH, 'Lock the lock.  Without argument'
	DB	', this blocks if the lock is already', 0aH, 'locked (even by '
	DB	'the same thread), waiting for another thread to release', 0aH
	DB	'the lock, and return True once the lock is acquired.', 0aH, 'W'
	DB	'ith an argument, this will only block if the argument is true'
	DB	',', 0aH, 'and the return value reflects whether the lock is a'
	DB	'cquired.', 0aH, 'The blocking operation is interruptible.', 00H
	ORG $+8
release_doc DB	'release()', 0aH, '(release_lock() is an obsolete synonym'
	DB	')', 0aH, 0aH, 'Release the lock, allowing another thread that'
	DB	' is blocked waiting for', 0aH, 'the lock to acquire the lock.'
	DB	'  The lock must be in the locked state,', 0aH, 'but it needn'''
	DB	't be locked by the same thread that unlocks it.', 00H
	ORG $+5
locked_doc DB	'locked() -> bool', 0aH, '(locked_lock() is an obsolete s'
	DB	'ynonym)', 0aH, 0aH, 'Return whether the lock is in the locked'
	DB	' state.', 00H
	ORG $+7
lock_methods DQ	FLAT:??_C@_0N@JKBCAFMP@acquire_lock?$AA@
	DQ	FLAT:lock_PyThread_acquire_lock
	DD	03H
	ORG $+4
	DQ	FLAT:acquire_doc
	DQ	FLAT:??_C@_07MEFPPMEF@acquire?$AA@
	DQ	FLAT:lock_PyThread_acquire_lock
	DD	03H
	ORG $+4
	DQ	FLAT:acquire_doc
	DQ	FLAT:??_C@_0N@EJFMMAJJ@release_lock?$AA@
	DQ	FLAT:lock_PyThread_release_lock
	DD	04H
	ORG $+4
	DQ	FLAT:release_doc
	DQ	FLAT:??_C@_07EOGFDLKI@release?$AA@
	DQ	FLAT:lock_PyThread_release_lock
	DD	04H
	ORG $+4
	DQ	FLAT:release_doc
	DQ	FLAT:??_C@_0M@GHINBMOK@locked_lock?$AA@
	DQ	FLAT:lock_locked_lock
	DD	04H
	ORG $+4
	DQ	FLAT:locked_doc
	DQ	FLAT:??_C@_06KKBPGBGI@locked?$AA@
	DQ	FLAT:lock_locked_lock
	DD	04H
	ORG $+4
	DQ	FLAT:locked_doc
	DQ	FLAT:??_C@_09OAJHKKGH@__enter__?$AA@
	DQ	FLAT:lock_PyThread_acquire_lock
	DD	03H
	ORG $+4
	DQ	FLAT:acquire_doc
	DQ	FLAT:??_C@_08CMFIGCJD@__exit__?$AA@
	DQ	FLAT:lock_PyThread_release_lock
	DD	01H
	ORG $+4
	DQ	FLAT:release_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
Locktype DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0N@FKGDBBBI@_thread?4lock?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:lock_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000068H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:lock_methods
	ORG $+152
rlock_acquire_doc DB 'acquire(blocking=True) -> bool', 0aH, 0aH, 'Lock th'
	DB	'e lock.  `blocking` indicates whether we should wait', 0aH, 'f'
	DB	'or the lock to be available or not.  If `blocking` is False', 0aH
	DB	'and another thread holds the lock, the method will return Fal'
	DB	'se', 0aH, 'immediately.  If `blocking` is True and another th'
	DB	'read holds', 0aH, 'the lock, the method will wait for the loc'
	DB	'k to be released,', 0aH, 'take it and then return True.', 0aH
	DB	'(note: the blocking operation is interruptible.)', 0aH, 0aH, 'I'
	DB	'n all other cases, the method will return True immediately.', 0aH
	DB	'Precisely, if the current thread already holds the lock, its', 0aH
	DB	'internal counter is simply incremented. If nobody holds the l'
	DB	'ock,', 0aH, 'the lock is taken and its internal counter initi'
	DB	'alized to 1.', 00H
	ORG $+5
rlock_release_doc DB 'release()', 0aH, 0aH, 'Release the lock, allowing a'
	DB	'nother thread that is blocked waiting for', 0aH, 'the lock to'
	DB	' acquire the lock.  The lock must be in the locked state,', 0aH
	DB	'and must be locked by the same thread that unlocks it; otherw'
	DB	'ise a', 0aH, '`RuntimeError` is raised.', 0aH, 0aH, 'Do note '
	DB	'that if the lock was acquire()d several times in a row by the'
	DB	0aH, 'current thread, release() needs to be called as many tim'
	DB	'es for the lock', 0aH, 'to be available for other threads.', 00H
	ORG $+11
rlock_acquire_restore_doc DB '_acquire_restore(state) -> None', 0aH, 0aH, 'F'
	DB	'or internal use by `threading.Condition`.', 00H
	ORG $+4
rlock_release_save_doc DB '_release_save() -> tuple', 0aH, 0aH, 'For inte'
	DB	'rnal use by `threading.Condition`.', 00H
	ORG $+11
rlock_is_owned_doc DB '_is_owned() -> bool', 0aH, 0aH, 'For internal use '
	DB	'by `threading.Condition`.', 00H
rlock_methods DQ FLAT:??_C@_07MEFPPMEF@acquire?$AA@
	DQ	FLAT:rlock_acquire
	DD	03H
	ORG $+4
	DQ	FLAT:rlock_acquire_doc
	DQ	FLAT:??_C@_07EOGFDLKI@release?$AA@
	DQ	FLAT:rlock_release
	DD	04H
	ORG $+4
	DQ	FLAT:rlock_release_doc
	DQ	FLAT:??_C@_09HFMMNEJG@_is_owned?$AA@
	DQ	FLAT:rlock_is_owned
	DD	04H
	ORG $+4
	DQ	FLAT:rlock_is_owned_doc
	DQ	FLAT:??_C@_0BB@LNGBJLEI@_acquire_restore?$AA@
	DQ	FLAT:rlock_acquire_restore
	DD	08H
	ORG $+4
	DQ	FLAT:rlock_acquire_restore_doc
	DQ	FLAT:??_C@_0O@GAANLLMC@_release_save?$AA@
	DQ	FLAT:rlock_release_save
	DD	04H
	ORG $+4
	DQ	FLAT:rlock_release_save_doc
	DQ	FLAT:??_C@_09OAJHKKGH@__enter__?$AA@
	DQ	FLAT:rlock_acquire
	DD	03H
	ORG $+4
	DQ	FLAT:rlock_acquire_doc
	DQ	FLAT:??_C@_08CMFIGCJD@__exit__?$AA@
	DQ	FLAT:rlock_release
	DD	01H
	ORG $+4
	DQ	FLAT:rlock_release_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
RLocktype DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@GJOLJECC@_thread?4RLock?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:rlock_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:rlock_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:rlock_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:rlock_new
	ORG $+72
localdummytype DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BE@DIJGDAPK@_thread?4_localdummy?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:localdummy_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	FLAT:??_C@_0BD@JJFEDPB@Thread?9local?5dummy?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000068H
	ORG $+176
?wr_callback_def@?1??local_new@@9@9 DQ FLAT:??_C@_0BG@MBDGPDAK@_localdummy_destroyed?$AA@ ; `local_new'::`2'::wr_callback_def
	DQ	FLAT:_localdummy_destroyed
	DD	08H
	ORG $+4
	ORG $+8
localtype DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0P@HHKNGPPL@_thread?4_local?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:local_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:local_getattro
	DQ	FLAT:local_setattro
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:??_C@_0BC@GKOPAEKP@Thread?9local?5data?$AA@
	DQ	FLAT:local_traverse
	DQ	FLAT:local_clear
	DQ	0000000000000000H
	DQ	0000000000000078H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:local_new
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+56
start_new_doc DB 'start_new_thread(function, args[, kwargs])', 0aH, '(sta'
	DB	'rt_new() is an obsolete synonym)', 0aH, 0aH, 'Start a new thr'
	DB	'ead and return its identifier.  The thread will call the', 0aH
	DB	'function with positional arguments from the tuple args and ke'
	DB	'yword arguments', 0aH, 'taken from the optional dictionary kw'
	DB	'args.  The thread exits when the', 0aH, 'function returns; th'
	DB	'e return value is ignored.  The thread will also exit', 0aH, 'w'
	DB	'hen the function raises an unhandled exception; a stack trace'
	DB	' will be', 0aH, 'printed unless the exception is SystemExit.', 0aH
	DB	00H
	ORG $+6
exit_doc DB	'exit()', 0aH, '(exit_thread() is an obsolete synonym)', 0aH
	DB	0aH, 'This is synonymous to ``raise SystemExit''''.  It will c'
	DB	'ause the current', 0aH, 'thread to exit silently unless the e'
	DB	'xception is caught.', 00H
	ORG $+2
interrupt_doc DB 'interrupt_main()', 0aH, 0aH, 'Raise a KeyboardInterrupt'
	DB	' in the main thread.', 0aH, 'A subthread can use this functio'
	DB	'n to interrupt the main thread.', 00H
allocate_doc DB	'allocate_lock() -> lock object', 0aH, '(allocate() is an'
	DB	' obsolete synonym)', 0aH, 0aH, 'Create a new lock object.  Se'
	DB	'e help(LockType) for information about locks.', 00H
	ORG $+1
get_ident_doc DB 'get_ident() -> integer', 0aH, 0aH, 'Return a non-zero i'
	DB	'nteger that uniquely identifies the current thread', 0aH, 'am'
	DB	'ongst other threads that exist simultaneously.', 0aH, 'This m'
	DB	'ay be used to identify per-thread resources.', 0aH, 'Even tho'
	DB	'ugh on some platforms threads identities may appear to be', 0aH
	DB	'allocated consecutive numbers starting at 1, this behavior sh'
	DB	'ould not', 0aH, 'be relied upon, and the number should be see'
	DB	'n purely as a magic cookie.', 0aH, 'A thread''s identity may '
	DB	'be reused for another thread after it exits.', 00H
	ORG $+9
_count_doc DB	'_count() -> integer', 0aH, 0aH, 'Return the number of cu'
	DB	'rrently running Python threads, excluding ', 0aH, 'the main t'
	DB	'hread. The returned number comprises all threads created', 0aH
	DB	'through `start_new_thread()` as well as `threading.Thread`, a'
	DB	'nd not', 0aH, 'yet finished.', 0aH, 0aH, 'This function is me'
	DB	'ant for internal and specialized purposes only.', 0aH, 'In mo'
	DB	'st applications `threading.enumerate()` should be used instea'
	DB	'd.', 00H
	ORG $+11
stack_size_doc DB 'stack_size([size]) -> size', 0aH, 0aH, 'Return the thr'
	DB	'ead stack size used when creating new threads.  The', 0aH, 'o'
	DB	'ptional size argument specifies the stack size (in bytes) to '
	DB	'be used', 0aH, 'for subsequently created threads, and must be'
	DB	' 0 (use platform or', 0aH, 'configured default) or a positive'
	DB	' integer value of at least 32,768 (32k).', 0aH, 'If changing '
	DB	'the thread stack size is unsupported, a ThreadError', 0aH, 'e'
	DB	'xception is raised.  If the specified size is invalid, a Valu'
	DB	'eError', 0aH, 'exception is raised, and the stack size is unm'
	DB	'odified.  32k bytes', 0aH, ' currently the minimum supported '
	DB	'stack size value to guarantee', 0aH, 'sufficient stack space '
	DB	'for the interpreter itself.', 0aH, 0aH, 'Note that some platf'
	DB	'orms may have particular restrictions on values for', 0aH, 't'
	DB	'he stack size, such as requiring a minimum stack size larger '
	DB	'than 32kB or', 0aH, 'requiring allocation in multiples of the'
	DB	' system memory page size', 0aH, '- platform documentation sho'
	DB	'uld be referred to for more information', 0aH, '(4kB pages ar'
	DB	'e common; using multiples of 4096 for the stack size is', 0aH
	DB	'the suggested approach in the absence of more specific inform'
	DB	'ation).', 00H
	ORG $+5
thread_methods DQ FLAT:??_C@_0BB@NIEJKBPO@start_new_thread?$AA@
	DQ	FLAT:thread_PyThread_start_new_thread
	DD	01H
	ORG $+4
	DQ	FLAT:start_new_doc
	DQ	FLAT:??_C@_09BEJJCLOL@start_new?$AA@
	DQ	FLAT:thread_PyThread_start_new_thread
	DD	01H
	ORG $+4
	DQ	FLAT:start_new_doc
	DQ	FLAT:??_C@_0O@MLDABOCH@allocate_lock?$AA@
	DQ	FLAT:thread_PyThread_allocate_lock
	DD	04H
	ORG $+4
	DQ	FLAT:allocate_doc
	DQ	FLAT:??_C@_08HGGEJCMJ@allocate?$AA@
	DQ	FLAT:thread_PyThread_allocate_lock
	DD	04H
	ORG $+4
	DQ	FLAT:allocate_doc
	DQ	FLAT:??_C@_0M@EHGPAPBC@exit_thread?$AA@
	DQ	FLAT:thread_PyThread_exit_thread
	DD	04H
	ORG $+4
	DQ	FLAT:exit_doc
	DQ	FLAT:??_C@_04MKNBDEPB@exit?$AA@
	DQ	FLAT:thread_PyThread_exit_thread
	DD	04H
	ORG $+4
	DQ	FLAT:exit_doc
	DQ	FLAT:??_C@_0P@GILDALKM@interrupt_main?$AA@
	DQ	FLAT:thread_PyThread_interrupt_main
	DD	04H
	ORG $+4
	DQ	FLAT:interrupt_doc
	DQ	FLAT:??_C@_09ICJGJIKJ@get_ident?$AA@
	DQ	FLAT:thread_get_ident
	DD	04H
	ORG $+4
	DQ	FLAT:get_ident_doc
	DQ	FLAT:??_C@_06HHPHCOMB@_count?$AA@
	DQ	FLAT:thread__count
	DD	04H
	ORG $+4
	DQ	FLAT:_count_doc
	DQ	FLAT:??_C@_0L@NELPJPHD@stack_size?$AA@
	DQ	FLAT:thread_stack_size
	DD	01H
	ORG $+4
	DQ	FLAT:stack_size_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
thread_doc DB	'This module provides primitive operations to write multi'
	DB	'-threaded programs.', 0aH, 'The ''threading'' module provides'
	DB	' a more convenient interface.', 00H
	ORG $+7
lock_doc DB	'A lock object is a synchronization primitive.  To create'
	DB	' a lock,', 0aH, 'call the PyThread_allocate_lock() function. '
	DB	' Methods are:', 0aH, 0aH, 'acquire() -- lock the lock, possib'
	DB	'ly blocking until it can be obtained', 0aH, 'release() -- unl'
	DB	'ock of the lock', 0aH, 'locked() -- test whether the lock is '
	DB	'currently locked', 0aH, 0aH, 'A lock is not owned by the thre'
	DB	'ad that locked it; another thread may', 0aH, 'unlock it.  A t'
	DB	'hread attempting to lock a lock that it has already locked', 0aH
	DB	'will block until another thread unlocks it.  Deadlocks may en'
	DB	'sue.', 00H
	ORG $+5
threadmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07CNDFADNJ@_thread?$AA@
	DQ	FLAT:thread_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:thread_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PyThread_free_lock:PROC
EXTRN	PyThread_release_lock:PROC
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_threadmodule.c
pdata	SEGMENT
$pdata$lock_dealloc DD imagerel lock_dealloc
	DD	imagerel lock_dealloc+99
	DD	imagerel $unwind$lock_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lock_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lock_dealloc
_TEXT	SEGMENT
self$ = 48
lock_dealloc PROC					; COMDAT

; 31   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 32   :     if (self->in_weakreflist != NULL)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	74 0a		 je	 SHORT $LN3@lock_deall

; 33   :         PyObject_ClearWeakRefs((PyObject *) self);

  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0001a	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN3@lock_deall:

; 34   :     if (self->lock_lock != NULL) {

  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00024	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00029	74 29		 je	 SHORT $LN2@lock_deall

; 35   :         /* Unlock the lock so it's safe to free it */
; 36   :         if (self->locked)

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00030	0f be 40 70	 movsx	 eax, BYTE PTR [rax+112]
  00034	85 c0		 test	 eax, eax
  00036	74 0e		 je	 SHORT $LN1@lock_deall

; 37   :             PyThread_release_lock(self->lock_lock);

  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00041	e8 00 00 00 00	 call	 PyThread_release_lock
$LN1@lock_deall:

; 38   :         PyThread_free_lock(self->lock_lock);

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004b	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0004f	e8 00 00 00 00	 call	 PyThread_free_lock
$LN2@lock_deall:

; 39   :     }
; 40   :     PyObject_Del(self);

  00054	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00059	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 41   : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
lock_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@ ; `string'
PUBLIC	__real@428f3fffffe0c000
PUBLIC	__real@412e848000000000
PUBLIC	??_C@_0CI@BGNBOFIL@timeout?5value?5must?5be?5strictly?5p@ ; `string'
PUBLIC	??_C@_0DA@KAHGEHOF@can?8t?5specify?5a?5timeout?5for?5a?5no@ ; `string'
PUBLIC	??_C@_0M@LDGCGPMN@?$HMid?3acquire?$AA@		; `string'
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_07DDHNKDGP@timeout?$AA@			; `string'
PUBLIC	??_C@_08NPIAFDOA@blocking?$AA@			; `string'
EXTRN	PyBool_FromLong:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyArg_ParseTupleAndKeywords:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$lock_PyThread_acquire_lock DD imagerel lock_PyThread_acquire_lock
	DD	imagerel lock_PyThread_acquire_lock+458
	DD	imagerel $unwind$lock_PyThread_acquire_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lock_PyThread_acquire_lock DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@ DB 'timeout value '
	DB	'is too large', 00H				; `string'
CONST	ENDS
;	COMDAT __real@428f3fffffe0c000
CONST	SEGMENT
__real@428f3fffffe0c000 DQ 0428f3fffffe0c000r	; 4.29497e+012
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
CONST	ENDS
;	COMDAT ??_C@_0CI@BGNBOFIL@timeout?5value?5must?5be?5strictly?5p@
CONST	SEGMENT
??_C@_0CI@BGNBOFIL@timeout?5value?5must?5be?5strictly?5p@ DB 'timeout val'
	DB	'ue must be strictly positive', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KAHGEHOF@can?8t?5specify?5a?5timeout?5for?5a?5no@
CONST	SEGMENT
??_C@_0DA@KAHGEHOF@can?8t?5specify?5a?5timeout?5for?5a?5no@ DB 'can''t sp'
	DB	'ecify a timeout for a non-blocking call', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LDGCGPMN@?$HMid?3acquire?$AA@
CONST	SEGMENT
??_C@_0M@LDGCGPMN@?$HMid?3acquire?$AA@ DB '|id:acquire', 00H ; `string'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_07DDHNKDGP@timeout?$AA@
CONST	SEGMENT
??_C@_07DDHNKDGP@timeout?$AA@ DB 'timeout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NPIAFDOA@blocking?$AA@
CONST	SEGMENT
??_C@_08NPIAFDOA@blocking?$AA@ DB 'blocking', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT lock_PyThread_acquire_lock
_TEXT	SEGMENT
kwlist$ = 48
blocking$ = 72
r$ = 76
timeout$ = 80
microseconds$ = 88
tv128 = 96
self$ = 128
args$ = 136
kwds$ = 144
lock_PyThread_acquire_lock PROC				; COMDAT

; 102  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 103  :     char *kwlist[] = {"blocking", "timeout", NULL};

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08NPIAFDOA@blocking?$AA@
  0001a	48 89 44 24 30	 mov	 QWORD PTR kwlist$[rsp], rax
  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07DDHNKDGP@timeout?$AA@
  00026	48 89 44 24 38	 mov	 QWORD PTR kwlist$[rsp+8], rax
  0002b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR kwlist$[rsp+16], 0

; 104  :     int blocking = 1;

  00034	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR blocking$[rsp], 1

; 105  :     double timeout = -1;

  0003c	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  00044	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR timeout$[rsp], xmm0

; 106  :     PY_TIMEOUT_T microseconds;
; 107  :     PyLockStatus r;
; 108  : 
; 109  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|id:acquire", kwlist,
; 110  :                                      &blocking, &timeout))

  0004a	48 8d 44 24 50	 lea	 rax, QWORD PTR timeout$[rsp]
  0004f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00054	48 8d 44 24 48	 lea	 rax, QWORD PTR blocking$[rsp]
  00059	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005e	4c 8d 4c 24 30	 lea	 r9, QWORD PTR kwlist$[rsp]
  00063	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@LDGCGPMN@?$HMid?3acquire?$AA@
  0006a	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00072	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0007a	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0007f	85 c0		 test	 eax, eax
  00081	75 07		 jne	 SHORT $LN10@lock_PyThr

; 111  :         return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	e9 3b 01 00 00	 jmp	 $LN11@lock_PyThr
$LN10@lock_PyThr:

; 112  : 
; 113  :     if (!blocking && timeout != -1) {

  0008a	83 7c 24 48 00	 cmp	 DWORD PTR blocking$[rsp], 0
  0008f	75 2c		 jne	 SHORT $LN9@lock_PyThr
  00091	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  00097	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0009f	7a 02		 jp	 SHORT $LN16@lock_PyThr
  000a1	74 1a		 je	 SHORT $LN9@lock_PyThr
$LN16@lock_PyThr:

; 114  :         PyErr_SetString(PyExc_ValueError, "can't specify a timeout "
; 115  :                         "for a non-blocking call");

  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@KAHGEHOF@can?8t?5specify?5a?5timeout?5for?5a?5no@
  000aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000b1	e8 00 00 00 00	 call	 PyErr_SetString

; 116  :         return NULL;

  000b6	33 c0		 xor	 eax, eax
  000b8	e9 08 01 00 00	 jmp	 $LN11@lock_PyThr
$LN9@lock_PyThr:

; 117  :     }
; 118  :     if (timeout < 0 && timeout != -1) {

  000bd	66 0f 57 c0	 xorpd	 xmm0, xmm0
  000c1	66 0f 2f 44 24
	50		 comisd	 xmm0, QWORD PTR timeout$[rsp]
  000c7	76 2c		 jbe	 SHORT $LN8@lock_PyThr
  000c9	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  000cf	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  000d7	7a 02		 jp	 SHORT $LN15@lock_PyThr
  000d9	74 1a		 je	 SHORT $LN8@lock_PyThr
$LN15@lock_PyThr:

; 119  :         PyErr_SetString(PyExc_ValueError, "timeout value must be "
; 120  :                         "strictly positive");

  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@BGNBOFIL@timeout?5value?5must?5be?5strictly?5p@
  000e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000e9	e8 00 00 00 00	 call	 PyErr_SetString

; 121  :         return NULL;

  000ee	33 c0		 xor	 eax, eax
  000f0	e9 d0 00 00 00	 jmp	 $LN11@lock_PyThr
$LN8@lock_PyThr:

; 122  :     }
; 123  :     if (!blocking)

  000f5	83 7c 24 48 00	 cmp	 DWORD PTR blocking$[rsp], 0
  000fa	75 0b		 jne	 SHORT $LN7@lock_PyThr

; 124  :         microseconds = 0;

  000fc	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR microseconds$[rsp], 0
  00105	eb 64		 jmp	 SHORT $LN6@lock_PyThr
$LN7@lock_PyThr:

; 125  :     else if (timeout == -1)

  00107	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  0010d	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00115	7a 0d		 jp	 SHORT $LN5@lock_PyThr
  00117	75 0b		 jne	 SHORT $LN5@lock_PyThr

; 126  :         microseconds = -1;

  00119	48 c7 44 24 58
	ff ff ff ff	 mov	 QWORD PTR microseconds$[rsp], -1

; 127  :     else {

  00122	eb 47		 jmp	 SHORT $LN4@lock_PyThr
$LN5@lock_PyThr:

; 128  :         timeout *= 1e6;

  00124	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  0012a	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  00132	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR timeout$[rsp], xmm0

; 129  :         if (timeout >= (double) PY_TIMEOUT_MAX) {

  00138	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  0013e	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@428f3fffffe0c000
  00146	72 17		 jb	 SHORT $LN3@lock_PyThr

; 130  :             PyErr_SetString(PyExc_OverflowError,
; 131  :                             "timeout value is too large");

  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@
  0014f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00156	e8 00 00 00 00	 call	 PyErr_SetString

; 132  :             return NULL;

  0015b	33 c0		 xor	 eax, eax
  0015d	eb 66		 jmp	 SHORT $LN11@lock_PyThr
$LN3@lock_PyThr:

; 133  :         }
; 134  :         microseconds = (PY_TIMEOUT_T) timeout;

  0015f	f2 48 0f 2c 44
	24 50		 cvttsd2si rax, QWORD PTR timeout$[rsp]
  00166	48 89 44 24 58	 mov	 QWORD PTR microseconds$[rsp], rax
$LN4@lock_PyThr:
$LN6@lock_PyThr:

; 135  :     }
; 136  : 
; 137  :     r = acquire_timed(self->lock_lock, microseconds);

  0016b	48 8b 54 24 58	 mov	 rdx, QWORD PTR microseconds$[rsp]
  00170	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00178	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0017c	e8 00 00 00 00	 call	 acquire_timed
  00181	89 44 24 4c	 mov	 DWORD PTR r$[rsp], eax

; 138  :     if (r == PY_LOCK_INTR) {

  00185	83 7c 24 4c 02	 cmp	 DWORD PTR r$[rsp], 2
  0018a	75 04		 jne	 SHORT $LN2@lock_PyThr

; 139  :         return NULL;

  0018c	33 c0		 xor	 eax, eax
  0018e	eb 35		 jmp	 SHORT $LN11@lock_PyThr
$LN2@lock_PyThr:

; 140  :     }
; 141  : 
; 142  :     if (r == PY_LOCK_ACQUIRED)

  00190	83 7c 24 4c 01	 cmp	 DWORD PTR r$[rsp], 1
  00195	75 0c		 jne	 SHORT $LN1@lock_PyThr

; 143  :         self->locked = 1;

  00197	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0019f	c6 40 70 01	 mov	 BYTE PTR [rax+112], 1
$LN1@lock_PyThr:

; 144  :     return PyBool_FromLong(r == PY_LOCK_ACQUIRED);

  001a3	83 7c 24 4c 01	 cmp	 DWORD PTR r$[rsp], 1
  001a8	75 0a		 jne	 SHORT $LN13@lock_PyThr
  001aa	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  001b2	eb 08		 jmp	 SHORT $LN14@lock_PyThr
$LN13@lock_PyThr:
  001b4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN14@lock_PyThr:
  001bc	8b 4c 24 60	 mov	 ecx, DWORD PTR tv128[rsp]
  001c0	e8 00 00 00 00	 call	 PyBool_FromLong
$LN11@lock_PyThr:

; 145  : }

  001c5	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001c9	c3		 ret	 0
lock_PyThread_acquire_lock ENDP
_TEXT	ENDS
EXTRN	Py_MakePendingCalls:PROC
EXTRN	PyEval_RestoreThread:PROC
EXTRN	PyEval_SaveThread:PROC
EXTRN	PyThread_acquire_lock_timed:PROC
EXTRN	_PyTime_gettimeofday:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$acquire_timed DD imagerel acquire_timed
	DD	imagerel acquire_timed+298
	DD	imagerel $unwind$acquire_timed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$acquire_timed DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT acquire_timed
_TEXT	SEGMENT
curtime$ = 32
endtime$ = 48
r$ = 64
_save$20418 = 72
lock$ = 96
microseconds$ = 104
acquire_timed PROC					; COMDAT

; 51   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 52   :     PyLockStatus r;
; 53   :     _PyTime_timeval curtime;
; 54   :     _PyTime_timeval endtime;
; 55   : 
; 56   : 
; 57   :     if (microseconds > 0) {

  0000e	48 83 7c 24 68
	00		 cmp	 QWORD PTR microseconds$[rsp], 0
  00014	7e 4a		 jle	 SHORT $LN9@acquire_ti

; 58   :         _PyTime_gettimeofday(&endtime);

  00016	48 8d 4c 24 30	 lea	 rcx, QWORD PTR endtime$[rsp]
  0001b	e8 00 00 00 00	 call	 _PyTime_gettimeofday

; 59   :         endtime.tv_sec += microseconds / (1000 * 1000);

  00020	48 8b 44 24 68	 mov	 rax, QWORD PTR microseconds$[rsp]
  00025	48 99		 cdq
  00027	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0002c	48 f7 f9	 idiv	 rcx
  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR endtime$[rsp]
  00034	48 03 c8	 add	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 89 44 24 30	 mov	 QWORD PTR endtime$[rsp], rax

; 60   :         endtime.tv_usec += microseconds % (1000 * 1000);

  0003f	48 8b 44 24 68	 mov	 rax, QWORD PTR microseconds$[rsp]
  00044	48 99		 cdq
  00046	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0004b	48 f7 f9	 idiv	 rcx
  0004e	48 8b c2	 mov	 rax, rdx
  00051	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR endtime$[rsp+8]
  00056	48 03 c8	 add	 rcx, rax
  00059	48 8b c1	 mov	 rax, rcx
  0005c	89 44 24 38	 mov	 DWORD PTR endtime$[rsp+8], eax
$LN9@acquire_ti:
$LN8@acquire_ti:

; 61   :     }
; 62   : 
; 63   : 
; 64   :     do {
; 65   :         /* first a simple non-blocking try without releasing the GIL */
; 66   :         r = PyThread_acquire_lock_timed(lock, 0, 0);

  00060	45 33 c0	 xor	 r8d, r8d
  00063	33 d2		 xor	 edx, edx
  00065	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lock$[rsp]
  0006a	e8 00 00 00 00	 call	 PyThread_acquire_lock_timed
  0006f	89 44 24 40	 mov	 DWORD PTR r$[rsp], eax

; 67   :         if (r == PY_LOCK_FAILURE && microseconds != 0) {

  00073	83 7c 24 40 00	 cmp	 DWORD PTR r$[rsp], 0
  00078	75 35		 jne	 SHORT $LN5@acquire_ti
  0007a	48 83 7c 24 68
	00		 cmp	 QWORD PTR microseconds$[rsp], 0
  00080	74 2d		 je	 SHORT $LN5@acquire_ti

; 68   :             Py_BEGIN_ALLOW_THREADS

  00082	e8 00 00 00 00	 call	 PyEval_SaveThread
  00087	48 89 44 24 48	 mov	 QWORD PTR _save$20418[rsp], rax

; 69   :             r = PyThread_acquire_lock_timed(lock, microseconds, 1);

  0008c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00092	48 8b 54 24 68	 mov	 rdx, QWORD PTR microseconds$[rsp]
  00097	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lock$[rsp]
  0009c	e8 00 00 00 00	 call	 PyThread_acquire_lock_timed
  000a1	89 44 24 40	 mov	 DWORD PTR r$[rsp], eax

; 70   :             Py_END_ALLOW_THREADS

  000a5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _save$20418[rsp]
  000aa	e8 00 00 00 00	 call	 PyEval_RestoreThread
$LN5@acquire_ti:

; 71   :         } 
; 72   : 
; 73   :         if (r == PY_LOCK_INTR) {

  000af	83 7c 24 40 02	 cmp	 DWORD PTR r$[rsp], 2
  000b4	75 60		 jne	 SHORT $LN4@acquire_ti

; 74   :             /* Run signal handlers if we were interrupted.  Propagate
; 75   :              * exceptions from signal handlers, such as KeyboardInterrupt, by
; 76   :              * passing up PY_LOCK_INTR.  */
; 77   :             if (Py_MakePendingCalls() < 0) {

  000b6	e8 00 00 00 00	 call	 Py_MakePendingCalls
  000bb	85 c0		 test	 eax, eax
  000bd	7d 07		 jge	 SHORT $LN3@acquire_ti

; 78   :                 return PY_LOCK_INTR;

  000bf	b8 02 00 00 00	 mov	 eax, 2
  000c4	eb 5f		 jmp	 SHORT $LN10@acquire_ti
$LN3@acquire_ti:

; 79   :             }
; 80   : 
; 81   :             /* If we're using a timeout, recompute the timeout after processing
; 82   :              * signals, since those can take time.  */
; 83   :             if (microseconds > 0) {

  000c6	48 83 7c 24 68
	00		 cmp	 QWORD PTR microseconds$[rsp], 0
  000cc	7e 48		 jle	 SHORT $LN2@acquire_ti

; 84   :                 _PyTime_gettimeofday(&curtime);

  000ce	48 8d 4c 24 20	 lea	 rcx, QWORD PTR curtime$[rsp]
  000d3	e8 00 00 00 00	 call	 _PyTime_gettimeofday

; 85   :                 microseconds = ((endtime.tv_sec - curtime.tv_sec) * 1000000 +
; 86   :                                 (endtime.tv_usec - curtime.tv_usec));

  000d8	48 8b 44 24 20	 mov	 rax, QWORD PTR curtime$[rsp]
  000dd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR endtime$[rsp]
  000e2	48 2b c8	 sub	 rcx, rax
  000e5	48 8b c1	 mov	 rax, rcx
  000e8	48 69 c0 40 42
	0f 00		 imul	 rax, 1000000		; 000f4240H
  000ef	8b 4c 24 28	 mov	 ecx, DWORD PTR curtime$[rsp+8]
  000f3	8b 54 24 38	 mov	 edx, DWORD PTR endtime$[rsp+8]
  000f7	2b d1		 sub	 edx, ecx
  000f9	8b ca		 mov	 ecx, edx
  000fb	48 63 c9	 movsxd	 rcx, ecx
  000fe	48 03 c1	 add	 rax, rcx
  00101	48 89 44 24 68	 mov	 QWORD PTR microseconds$[rsp], rax

; 87   : 
; 88   :                 /* Check for negative values, since those mean block forever.
; 89   :                  */
; 90   :                 if (microseconds <= 0) {

  00106	48 83 7c 24 68
	00		 cmp	 QWORD PTR microseconds$[rsp], 0
  0010c	7f 08		 jg	 SHORT $LN1@acquire_ti

; 91   :                     r = PY_LOCK_FAILURE;

  0010e	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR r$[rsp], 0
$LN1@acquire_ti:
$LN2@acquire_ti:
$LN4@acquire_ti:

; 92   :                 }
; 93   :             }
; 94   :         }
; 95   :     } while (r == PY_LOCK_INTR);  /* Retry if we were interrupted. */

  00116	83 7c 24 40 02	 cmp	 DWORD PTR r$[rsp], 2
  0011b	0f 84 3f ff ff
	ff		 je	 $LN8@acquire_ti

; 96   : 
; 97   :     return r;

  00121	8b 44 24 40	 mov	 eax, DWORD PTR r$[rsp]
$LN10@acquire_ti:

; 98   : }

  00125	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00129	c3		 ret	 0
acquire_timed ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0BG@KCPOFNEH@release?5unlocked?5lock?$AA@	; `string'
EXTRN	_Py_NoneStruct:BYTE
_BSS	SEGMENT
	ALIGN	8

ThreadError DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lock_PyThread_release_lock DD imagerel lock_PyThread_release_lock
	DD	imagerel lock_PyThread_release_lock+92
	DD	imagerel $unwind$lock_PyThread_release_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lock_PyThread_release_lock DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BG@KCPOFNEH@release?5unlocked?5lock?$AA@
CONST	SEGMENT
??_C@_0BG@KCPOFNEH@release?5unlocked?5lock?$AA@ DB 'release unlocked lock'
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT lock_PyThread_release_lock
_TEXT	SEGMENT
self$ = 48
lock_PyThread_release_lock PROC				; COMDAT

; 160  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 161  :     /* Sanity check: the lock must be locked */
; 162  :     if (!self->locked) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f be 40 70	 movsx	 eax, BYTE PTR [rax+112]
  00012	85 c0		 test	 eax, eax
  00014	75 17		 jne	 SHORT $LN1@lock_PyThr@2

; 163  :         PyErr_SetString(ThreadError, "release unlocked lock");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@KCPOFNEH@release?5unlocked?5lock?$AA@
  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ThreadError
  00024	e8 00 00 00 00	 call	 PyErr_SetString

; 164  :         return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 2a		 jmp	 SHORT $LN2@lock_PyThr@2
$LN1@lock_PyThr@2:

; 165  :     }
; 166  : 
; 167  :     PyThread_release_lock(self->lock_lock);

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00032	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00036	e8 00 00 00 00	 call	 PyThread_release_lock

; 168  :     self->locked = 0;

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00040	c6 40 70 00	 mov	 BYTE PTR [rax+112], 0

; 169  :     Py_INCREF(Py_None);

  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0004b	e8 00 00 00 00	 call	 _Py_IncRef

; 170  :     return Py_None;

  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@lock_PyThr@2:

; 171  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
lock_PyThread_release_lock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\_threadmodule.c
pdata	SEGMENT
$pdata$lock_locked_lock DD imagerel lock_locked_lock
	DD	imagerel lock_locked_lock+30
	DD	imagerel $unwind$lock_locked_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lock_locked_lock DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lock_locked_lock
_TEXT	SEGMENT
self$ = 48
lock_locked_lock PROC					; COMDAT

; 183  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 184  :     return PyBool_FromLong((long)self->locked);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f be 40 70	 movsx	 eax, BYTE PTR [rax+112]
  00012	8b c8		 mov	 ecx, eax
  00014	e8 00 00 00 00	 call	 PyBool_FromLong

; 185  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
lock_locked_lock ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@GLMBGBOH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAl?$AAo?$AAc?$AAk?$AA_?$AAl?$AAo?$AAc?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@GPAGHMAF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$rlock_dealloc DD imagerel rlock_dealloc
	DD	imagerel rlock_dealloc+135
	DD	imagerel $unwind$rlock_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rlock_dealloc DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1CC@GLMBGBOH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAl?$AAo?$AAc?$AAk?$AA_?$AAl?$AAo?$AAc?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@GLMBGBOH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAl?$AAo?$AAc?$AAk?$AA_?$AAl?$AAo?$AAc?$AAk?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'r', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '_', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'k', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@GPAGHMAF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@GPAGHMAF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, '_', 00H, 't', 00H, 'h'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'm', 00H, 'o', 00H
	DB	'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT rlock_dealloc
_TEXT	SEGMENT
self$ = 48
rlock_dealloc PROC					; COMDAT

; 257  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 258  :     assert(self->rlock_lock);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	75 1c		 jne	 SHORT $LN5@rlock_deal
  00015	41 b8 02 01 00
	00		 mov	 r8d, 258		; 00000102H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DG@GPAGHMAF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@GLMBGBOH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAl?$AAo?$AAc?$AAk?$AA_?$AAl?$AAo?$AAc?$AAk?$AA?$AA@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	33 c0		 xor	 eax, eax
$LN5@rlock_deal:

; 259  :     if (self->in_weakreflist != NULL)

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00036	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0003b	74 0a		 je	 SHORT $LN2@rlock_deal

; 260  :         PyObject_ClearWeakRefs((PyObject *) self);

  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00042	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN2@rlock_deal:

; 261  :     /* Unlock the lock so it's safe to free it */
; 262  :     if (self->rlock_count > 0)

  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004c	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00050	76 0e		 jbe	 SHORT $LN1@rlock_deal

; 263  :         PyThread_release_lock(self->rlock_lock);

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00057	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0005b	e8 00 00 00 00	 call	 PyThread_release_lock
$LN1@rlock_deal:

; 264  : 
; 265  :     PyThread_free_lock(self->rlock_lock);

  00060	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00065	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00069	e8 00 00 00 00	 call	 PyThread_free_lock

; 266  :     Py_TYPE(self)->tp_free(self);

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00073	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00077	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007c	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 267  : }

  00082	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00086	c3		 ret	 0
rlock_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CO@PNLAKJKH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAl?$AAo?$AAc?$AAk?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BP@BAPLEJKM@Internal?5lock?5count?5overflowed?$AA@ ; `string'
EXTRN	_Py_TrueStruct:BYTE
EXTRN	PyThread_get_thread_ident:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$rlock_acquire DD imagerel rlock_acquire
	DD	imagerel rlock_acquire+670
	DD	imagerel $unwind$rlock_acquire
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rlock_acquire DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_1CO@PNLAKJKH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAl?$AAo?$AAc?$AAk?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@PNLAKJKH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAl?$AAo?$AAc?$AAk?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'r', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BAPLEJKM@Internal?5lock?5count?5overflowed?$AA@
CONST	SEGMENT
??_C@_0BP@BAPLEJKM@Internal?5lock?5count?5overflowed?$AA@ DB 'Internal lo'
	DB	'ck count overflowed', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT rlock_acquire
_TEXT	SEGMENT
kwlist$ = 48
tid$ = 72
blocking$ = 76
r$ = 80
timeout$ = 88
microseconds$ = 96
count$20563 = 104
tv148 = 108
self$ = 128
args$ = 136
kwds$ = 144
rlock_acquire PROC					; COMDAT

; 271  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 272  :     char *kwlist[] = {"blocking", "timeout", NULL};

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08NPIAFDOA@blocking?$AA@
  0001a	48 89 44 24 30	 mov	 QWORD PTR kwlist$[rsp], rax
  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07DDHNKDGP@timeout?$AA@
  00026	48 89 44 24 38	 mov	 QWORD PTR kwlist$[rsp+8], rax
  0002b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR kwlist$[rsp+16], 0

; 273  :     int blocking = 1;

  00034	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR blocking$[rsp], 1

; 274  :     double timeout = -1;

  0003c	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  00044	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR timeout$[rsp], xmm0

; 275  :     PY_TIMEOUT_T microseconds;
; 276  :     long tid;
; 277  :     PyLockStatus r = PY_LOCK_ACQUIRED;

  0004a	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR r$[rsp], 1

; 278  : 
; 279  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|id:acquire", kwlist,
; 280  :                                      &blocking, &timeout))

  00052	48 8d 44 24 58	 lea	 rax, QWORD PTR timeout$[rsp]
  00057	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005c	48 8d 44 24 4c	 lea	 rax, QWORD PTR blocking$[rsp]
  00061	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00066	4c 8d 4c 24 30	 lea	 r9, QWORD PTR kwlist$[rsp]
  0006b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@LDGCGPMN@?$HMid?3acquire?$AA@
  00072	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  0007a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00082	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00087	85 c0		 test	 eax, eax
  00089	75 07		 jne	 SHORT $LN13@rlock_acqu

; 281  :         return NULL;

  0008b	33 c0		 xor	 eax, eax
  0008d	e9 07 02 00 00	 jmp	 $LN14@rlock_acqu
$LN13@rlock_acqu:

; 282  : 
; 283  :     if (!blocking && timeout != -1) {

  00092	83 7c 24 4c 00	 cmp	 DWORD PTR blocking$[rsp], 0
  00097	75 2c		 jne	 SHORT $LN12@rlock_acqu
  00099	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  0009f	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  000a7	7a 02		 jp	 SHORT $LN20@rlock_acqu
  000a9	74 1a		 je	 SHORT $LN12@rlock_acqu
$LN20@rlock_acqu:

; 284  :         PyErr_SetString(PyExc_ValueError, "can't specify a timeout "
; 285  :                         "for a non-blocking call");

  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@KAHGEHOF@can?8t?5specify?5a?5timeout?5for?5a?5no@
  000b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000b9	e8 00 00 00 00	 call	 PyErr_SetString

; 286  :         return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	e9 d4 01 00 00	 jmp	 $LN14@rlock_acqu
$LN12@rlock_acqu:

; 287  :     }
; 288  :     if (timeout < 0 && timeout != -1) {

  000c5	66 0f 57 c0	 xorpd	 xmm0, xmm0
  000c9	66 0f 2f 44 24
	58		 comisd	 xmm0, QWORD PTR timeout$[rsp]
  000cf	76 2c		 jbe	 SHORT $LN11@rlock_acqu
  000d1	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  000d7	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  000df	7a 02		 jp	 SHORT $LN19@rlock_acqu
  000e1	74 1a		 je	 SHORT $LN11@rlock_acqu
$LN19@rlock_acqu:

; 289  :         PyErr_SetString(PyExc_ValueError, "timeout value must be "
; 290  :                         "strictly positive");

  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@BGNBOFIL@timeout?5value?5must?5be?5strictly?5p@
  000ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000f1	e8 00 00 00 00	 call	 PyErr_SetString

; 291  :         return NULL;

  000f6	33 c0		 xor	 eax, eax
  000f8	e9 9c 01 00 00	 jmp	 $LN14@rlock_acqu
$LN11@rlock_acqu:

; 292  :     }
; 293  :     if (!blocking)

  000fd	83 7c 24 4c 00	 cmp	 DWORD PTR blocking$[rsp], 0
  00102	75 0b		 jne	 SHORT $LN10@rlock_acqu

; 294  :         microseconds = 0;

  00104	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR microseconds$[rsp], 0
  0010d	eb 67		 jmp	 SHORT $LN9@rlock_acqu
$LN10@rlock_acqu:

; 295  :     else if (timeout == -1)

  0010f	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  00115	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0011d	7a 0d		 jp	 SHORT $LN8@rlock_acqu
  0011f	75 0b		 jne	 SHORT $LN8@rlock_acqu

; 296  :         microseconds = -1;

  00121	48 c7 44 24 60
	ff ff ff ff	 mov	 QWORD PTR microseconds$[rsp], -1

; 297  :     else {

  0012a	eb 4a		 jmp	 SHORT $LN7@rlock_acqu
$LN8@rlock_acqu:

; 298  :         timeout *= 1e6;

  0012c	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  00132	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  0013a	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR timeout$[rsp], xmm0

; 299  :         if (timeout >= (double) PY_TIMEOUT_MAX) {

  00140	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  00146	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@428f3fffffe0c000
  0014e	72 1a		 jb	 SHORT $LN6@rlock_acqu

; 300  :             PyErr_SetString(PyExc_OverflowError,
; 301  :                             "timeout value is too large");

  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@
  00157	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0015e	e8 00 00 00 00	 call	 PyErr_SetString

; 302  :             return NULL;

  00163	33 c0		 xor	 eax, eax
  00165	e9 2f 01 00 00	 jmp	 $LN14@rlock_acqu
$LN6@rlock_acqu:

; 303  :         }
; 304  :         microseconds = (PY_TIMEOUT_T) timeout;

  0016a	f2 48 0f 2c 44
	24 58		 cvttsd2si rax, QWORD PTR timeout$[rsp]
  00171	48 89 44 24 60	 mov	 QWORD PTR microseconds$[rsp], rax
$LN7@rlock_acqu:
$LN9@rlock_acqu:

; 305  :     }
; 306  : 
; 307  :     tid = PyThread_get_thread_ident();

  00176	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0017b	89 44 24 48	 mov	 DWORD PTR tid$[rsp], eax

; 308  :     if (self->rlock_count > 0 && tid == self->rlock_owner) {

  0017f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00187	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  0018b	76 74		 jbe	 SHORT $LN5@rlock_acqu
  0018d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00195	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00198	39 44 24 48	 cmp	 DWORD PTR tid$[rsp], eax
  0019c	75 63		 jne	 SHORT $LN5@rlock_acqu

; 309  :         unsigned long count = self->rlock_count + 1;

  0019e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001a6	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  001a9	ff c0		 inc	 eax
  001ab	89 44 24 68	 mov	 DWORD PTR count$20563[rsp], eax

; 310  :         if (count <= self->rlock_count) {

  001af	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001b7	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  001ba	39 44 24 68	 cmp	 DWORD PTR count$20563[rsp], eax
  001be	77 1a		 ja	 SHORT $LN4@rlock_acqu

; 311  :             PyErr_SetString(PyExc_OverflowError,
; 312  :                             "Internal lock count overflowed");

  001c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@BAPLEJKM@Internal?5lock?5count?5overflowed?$AA@
  001c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001ce	e8 00 00 00 00	 call	 PyErr_SetString

; 313  :             return NULL;

  001d3	33 c0		 xor	 eax, eax
  001d5	e9 bf 00 00 00	 jmp	 $LN14@rlock_acqu
$LN4@rlock_acqu:

; 314  :         }
; 315  :         self->rlock_count = count;

  001da	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001e2	8b 4c 24 68	 mov	 ecx, DWORD PTR count$20563[rsp]
  001e6	89 48 6c	 mov	 DWORD PTR [rax+108], ecx

; 316  :         Py_RETURN_TRUE;

  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  001f0	e8 00 00 00 00	 call	 _Py_IncRef
  001f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  001fc	e9 98 00 00 00	 jmp	 $LN14@rlock_acqu
$LN5@rlock_acqu:

; 317  :     }
; 318  :     r = acquire_timed(self->rlock_lock, microseconds);

  00201	48 8b 54 24 60	 mov	 rdx, QWORD PTR microseconds$[rsp]
  00206	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0020e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00212	e8 00 00 00 00	 call	 acquire_timed
  00217	89 44 24 50	 mov	 DWORD PTR r$[rsp], eax

; 319  :     if (r == PY_LOCK_ACQUIRED) {

  0021b	83 7c 24 50 01	 cmp	 DWORD PTR r$[rsp], 1
  00220	75 4a		 jne	 SHORT $LN3@rlock_acqu

; 320  :         assert(self->rlock_count == 0);

  00222	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0022a	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  0022e	74 1c		 je	 SHORT $LN16@rlock_acqu
  00230	41 b8 40 01 00
	00		 mov	 r8d, 320		; 00000140H
  00236	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DG@GPAGHMAF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0023d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@PNLAKJKH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAl?$AAo?$AAc?$AAk?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00244	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0024a	33 c0		 xor	 eax, eax
$LN16@rlock_acqu:

; 321  :         self->rlock_owner = tid;

  0024c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00254	8b 4c 24 48	 mov	 ecx, DWORD PTR tid$[rsp]
  00258	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 322  :         self->rlock_count = 1;

  0025b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00263	c7 40 6c 01 00
	00 00		 mov	 DWORD PTR [rax+108], 1
  0026a	eb 0b		 jmp	 SHORT $LN2@rlock_acqu
$LN3@rlock_acqu:

; 323  :     }
; 324  :     else if (r == PY_LOCK_INTR) {

  0026c	83 7c 24 50 02	 cmp	 DWORD PTR r$[rsp], 2
  00271	75 04		 jne	 SHORT $LN1@rlock_acqu

; 325  :         return NULL;

  00273	33 c0		 xor	 eax, eax
  00275	eb 22		 jmp	 SHORT $LN14@rlock_acqu
$LN1@rlock_acqu:
$LN2@rlock_acqu:

; 326  :     }
; 327  : 
; 328  :     return PyBool_FromLong(r == PY_LOCK_ACQUIRED);

  00277	83 7c 24 50 01	 cmp	 DWORD PTR r$[rsp], 1
  0027c	75 0a		 jne	 SHORT $LN17@rlock_acqu
  0027e	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv148[rsp], 1
  00286	eb 08		 jmp	 SHORT $LN18@rlock_acqu
$LN17@rlock_acqu:
  00288	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv148[rsp], 0
$LN18@rlock_acqu:
  00290	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv148[rsp]
  00294	e8 00 00 00 00	 call	 PyBool_FromLong
$LN14@rlock_acqu:

; 329  : }

  00299	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0029d	c3		 ret	 0
rlock_acquire ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@KLNHBMKC@cannot?5release?5un?9acquired?5lock?$AA@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$rlock_release DD imagerel rlock_release
	DD	imagerel rlock_release+149
	DD	imagerel $unwind$rlock_release
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rlock_release DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CA@KLNHBMKC@cannot?5release?5un?9acquired?5lock?$AA@
CONST	SEGMENT
??_C@_0CA@KLNHBMKC@cannot?5release?5un?9acquired?5lock?$AA@ DB 'cannot re'
	DB	'lease un-acquired lock', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT rlock_release
_TEXT	SEGMENT
tid$ = 32
tv73 = 36
self$ = 64
rlock_release PROC					; COMDAT

; 349  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 350  :     long tid = PyThread_get_thread_ident();

  00009	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0000e	89 44 24 20	 mov	 DWORD PTR tid$[rsp], eax

; 351  : 
; 352  :     if (self->rlock_count == 0 || self->rlock_owner != tid) {

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00017	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  0001b	74 0e		 je	 SHORT $LN2@rlock_rele
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00022	8b 4c 24 20	 mov	 ecx, DWORD PTR tid$[rsp]
  00026	39 48 68	 cmp	 DWORD PTR [rax+104], ecx
  00029	74 17		 je	 SHORT $LN3@rlock_rele
$LN2@rlock_rele:

; 353  :         PyErr_SetString(PyExc_RuntimeError,
; 354  :                         "cannot release un-acquired lock");

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KLNHBMKC@cannot?5release?5un?9acquired?5lock?$AA@
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 355  :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 4e		 jmp	 SHORT $LN4@rlock_rele
$LN3@rlock_rele:

; 356  :     }
; 357  :     if (--self->rlock_count == 0) {

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00047	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0004a	ff c8		 dec	 eax
  0004c	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00055	8b 4c 24 24	 mov	 ecx, DWORD PTR tv73[rsp]
  00059	89 48 6c	 mov	 DWORD PTR [rax+108], ecx
  0005c	83 7c 24 24 00	 cmp	 DWORD PTR tv73[rsp], 0
  00061	75 1a		 jne	 SHORT $LN1@rlock_rele

; 358  :         self->rlock_owner = 0;

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00068	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 359  :         PyThread_release_lock(self->rlock_lock);

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00074	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00078	e8 00 00 00 00	 call	 PyThread_release_lock
$LN1@rlock_rele:

; 360  :     }
; 361  :     Py_RETURN_NONE;

  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00084	e8 00 00 00 00	 call	 _Py_IncRef
  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@rlock_rele:

; 362  : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	c3		 ret	 0
rlock_release ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@IJIDEDFH@couldn?8t?5acquire?5lock?$AA@ ; `string'
PUBLIC	??_C@_0BE@IMAIDBOB@kl?3_acquire_restore?$AA@	; `string'
EXTRN	PyThread_acquire_lock:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$rlock_acquire_restore DD imagerel rlock_acquire_restore
	DD	imagerel rlock_acquire_restore+240
	DD	imagerel $unwind$rlock_acquire_restore
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rlock_acquire_restore DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BG@IJIDEDFH@couldn?8t?5acquire?5lock?$AA@
CONST	SEGMENT
??_C@_0BG@IJIDEDFH@couldn?8t?5acquire?5lock?$AA@ DB 'couldn''t acquire lo'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IMAIDBOB@kl?3_acquire_restore?$AA@
CONST	SEGMENT
??_C@_0BE@IMAIDBOB@kl?3_acquire_restore?$AA@ DB 'kl:_acquire_restore', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT rlock_acquire_restore
_TEXT	SEGMENT
count$ = 32
owner$ = 36
r$ = 40
_save$20602 = 48
self$ = 80
arg$ = 88
rlock_acquire_restore PROC				; COMDAT

; 378  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 379  :     long owner;
; 380  :     unsigned long count;
; 381  :     int r = 1;

  0000e	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR r$[rsp], 1

; 382  : 
; 383  :     if (!PyArg_ParseTuple(arg, "kl:_acquire_restore", &count, &owner))

  00016	4c 8d 4c 24 24	 lea	 r9, QWORD PTR owner$[rsp]
  0001b	4c 8d 44 24 20	 lea	 r8, QWORD PTR count$[rsp]
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@IMAIDBOB@kl?3_acquire_restore?$AA@
  00027	48 8b 4c 24 58	 mov	 rcx, QWORD PTR arg$[rsp]
  0002c	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00031	85 c0		 test	 eax, eax
  00033	75 07		 jne	 SHORT $LN3@rlock_acqu@2

; 384  :         return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	e9 af 00 00 00	 jmp	 $LN4@rlock_acqu@2
$LN3@rlock_acqu@2:

; 385  : 
; 386  :     if (!PyThread_acquire_lock(self->rlock_lock, 0)) {

  0003c	33 d2		 xor	 edx, edx
  0003e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00043	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00047	e8 00 00 00 00	 call	 PyThread_acquire_lock
  0004c	85 c0		 test	 eax, eax
  0004e	75 2b		 jne	 SHORT $LN2@rlock_acqu@2

; 387  :         Py_BEGIN_ALLOW_THREADS

  00050	e8 00 00 00 00	 call	 PyEval_SaveThread
  00055	48 89 44 24 30	 mov	 QWORD PTR _save$20602[rsp], rax

; 388  :         r = PyThread_acquire_lock(self->rlock_lock, 1);

  0005a	ba 01 00 00 00	 mov	 edx, 1
  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00064	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00068	e8 00 00 00 00	 call	 PyThread_acquire_lock
  0006d	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 389  :         Py_END_ALLOW_THREADS

  00071	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _save$20602[rsp]
  00076	e8 00 00 00 00	 call	 PyEval_RestoreThread
$LN2@rlock_acqu@2:

; 390  :     }
; 391  :     if (!r) {

  0007b	83 7c 24 28 00	 cmp	 DWORD PTR r$[rsp], 0
  00080	75 17		 jne	 SHORT $LN1@rlock_acqu@2

; 392  :         PyErr_SetString(ThreadError, "couldn't acquire lock");

  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@IJIDEDFH@couldn?8t?5acquire?5lock?$AA@
  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ThreadError
  00090	e8 00 00 00 00	 call	 PyErr_SetString

; 393  :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	eb 52		 jmp	 SHORT $LN4@rlock_acqu@2
$LN1@rlock_acqu@2:

; 394  :     }
; 395  :     assert(self->rlock_count == 0);

  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0009e	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  000a2	74 1c		 je	 SHORT $LN6@rlock_acqu@2
  000a4	41 b8 8b 01 00
	00		 mov	 r8d, 395		; 0000018bH
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DG@GPAGHMAF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@PNLAKJKH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAl?$AAo?$AAc?$AAk?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000be	33 c0		 xor	 eax, eax
$LN6@rlock_acqu@2:

; 396  :     self->rlock_owner = owner;

  000c0	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c5	8b 4c 24 24	 mov	 ecx, DWORD PTR owner$[rsp]
  000c9	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 397  :     self->rlock_count = count;

  000cc	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d1	8b 4c 24 20	 mov	 ecx, DWORD PTR count$[rsp]
  000d5	89 48 6c	 mov	 DWORD PTR [rax+108], ecx

; 398  :     Py_RETURN_NONE;

  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000df	e8 00 00 00 00	 call	 _Py_IncRef
  000e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@rlock_acqu@2:

; 399  : }

  000eb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ef	c3		 ret	 0
rlock_acquire_restore ENDP
_TEXT	ENDS
PUBLIC	??_C@_02INHECGIH@kl?$AA@			; `string'
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$rlock_release_save DD imagerel rlock_release_save
	DD	imagerel rlock_release_save+131
	DD	imagerel $unwind$rlock_release_save
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rlock_release_save DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_02INHECGIH@kl?$AA@
CONST	SEGMENT
??_C@_02INHECGIH@kl?$AA@ DB 'kl', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT rlock_release_save
_TEXT	SEGMENT
count$ = 32
owner$ = 36
self$ = 64
rlock_release_save PROC					; COMDAT

; 408  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 409  :     long owner;
; 410  :     unsigned long count;
; 411  : 
; 412  :     if (self->rlock_count == 0) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00012	75 17		 jne	 SHORT $LN1@rlock_rele@2

; 413  :         PyErr_SetString(PyExc_RuntimeError,
; 414  :                         "cannot release un-acquired lock");

  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KLNHBMKC@cannot?5release?5un?9acquired?5lock?$AA@
  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00022	e8 00 00 00 00	 call	 PyErr_SetString

; 415  :         return NULL;

  00027	33 c0		 xor	 eax, eax
  00029	eb 53		 jmp	 SHORT $LN2@rlock_rele@2
$LN1@rlock_rele@2:

; 416  :     }
; 417  : 
; 418  :     owner = self->rlock_owner;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00030	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00033	89 44 24 24	 mov	 DWORD PTR owner$[rsp], eax

; 419  :     count = self->rlock_count;

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003c	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0003f	89 44 24 20	 mov	 DWORD PTR count$[rsp], eax

; 420  :     self->rlock_count = 0;

  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00048	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [rax+108], 0

; 421  :     self->rlock_owner = 0;

  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00054	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 422  :     PyThread_release_lock(self->rlock_lock);

  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00060	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00064	e8 00 00 00 00	 call	 PyThread_release_lock

; 423  :     return Py_BuildValue("kl", count, owner);

  00069	44 8b 44 24 24	 mov	 r8d, DWORD PTR owner$[rsp]
  0006e	8b 54 24 20	 mov	 edx, DWORD PTR count$[rsp]
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02INHECGIH@kl?$AA@
  00079	e8 00 00 00 00	 call	 Py_BuildValue
$LN2@rlock_rele@2:

; 424  : }

  0007e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00082	c3		 ret	 0
rlock_release_save ENDP
_TEXT	ENDS
EXTRN	_Py_FalseStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$rlock_is_owned DD imagerel rlock_is_owned
	DD	imagerel rlock_is_owned+88
	DD	imagerel $unwind$rlock_is_owned
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rlock_is_owned DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT rlock_is_owned
_TEXT	SEGMENT
tid$ = 32
self$ = 64
rlock_is_owned PROC					; COMDAT

; 434  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 435  :     long tid = PyThread_get_thread_ident();

  00009	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0000e	89 44 24 20	 mov	 DWORD PTR tid$[rsp], eax

; 436  : 
; 437  :     if (self->rlock_count > 0 && self->rlock_owner == tid) {

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00017	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  0001b	76 23		 jbe	 SHORT $LN1@rlock_is_o
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00022	8b 4c 24 20	 mov	 ecx, DWORD PTR tid$[rsp]
  00026	39 48 68	 cmp	 DWORD PTR [rax+104], ecx
  00029	75 15		 jne	 SHORT $LN1@rlock_is_o

; 438  :         Py_RETURN_TRUE;

  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00032	e8 00 00 00 00	 call	 _Py_IncRef
  00037	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0003e	eb 13		 jmp	 SHORT $LN2@rlock_is_o
$LN1@rlock_is_o:

; 439  :     }
; 440  :     Py_RETURN_FALSE;

  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00047	e8 00 00 00 00	 call	 _Py_IncRef
  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
$LN2@rlock_is_o:

; 441  : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
rlock_is_owned ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@KAKMLBKC@can?8t?5allocate?5lock?$AA@	; `string'
EXTRN	PyThread_allocate_lock:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$rlock_new DD imagerel rlock_new
	DD	imagerel rlock_new+162
	DD	imagerel $unwind$rlock_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rlock_new DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BE@KAKMLBKC@can?8t?5allocate?5lock?$AA@
CONST	SEGMENT
??_C@_0BE@KAKMLBKC@can?8t?5allocate?5lock?$AA@ DB 'can''t allocate lock', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT rlock_new
_TEXT	SEGMENT
self$ = 32
type$ = 64
args$ = 72
kwds$ = 80
rlock_new PROC						; COMDAT

; 450  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 451  :     rlockobject *self;
; 452  : 
; 453  :     self = (rlockobject *) type->tp_alloc(type, 0);

  00013	33 d2		 xor	 edx, edx
  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  0001f	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00025	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 454  :     if (self != NULL) {

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00030	74 66		 je	 SHORT $LN2@rlock_new

; 455  :         self->rlock_lock = PyThread_allocate_lock();

  00032	e8 00 00 00 00	 call	 PyThread_allocate_lock
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  0003c	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 456  :         if (self->rlock_lock == NULL) {

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00045	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0004a	75 27		 jne	 SHORT $LN1@rlock_new

; 457  :             type->tp_free(self);

  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  00056	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 458  :             PyErr_SetString(ThreadError, "can't allocate lock");

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@KAKMLBKC@can?8t?5allocate?5lock?$AA@
  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ThreadError
  0006a	e8 00 00 00 00	 call	 PyErr_SetString

; 459  :             return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	eb 2a		 jmp	 SHORT $LN3@rlock_new
$LN1@rlock_new:

; 460  :         }
; 461  :         self->in_weakreflist = NULL;

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00078	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 462  :         self->rlock_owner = 0;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00085	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 463  :         self->rlock_count = 0;

  0008c	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00091	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [rax+108], 0
$LN2@rlock_new:

; 464  :     }
; 465  : 
; 466  :     return (PyObject *) self;

  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
$LN3@rlock_new:

; 467  : }

  0009d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a1	c3		 ret	 0
rlock_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@OELOMNJN@?$DM?$CFs?5owner?$DN?$CFld?5count?$DN?$CFlu?$DO?$AA@ ; `string'
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$rlock_repr DD imagerel rlock_repr
	DD	imagerel rlock_repr+57
	DD	imagerel $unwind$rlock_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rlock_repr DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BJ@OELOMNJN@?$DM?$CFs?5owner?$DN?$CFld?5count?$DN?$CFlu?$DO?$AA@
CONST	SEGMENT
??_C@_0BJ@OELOMNJN@?$DM?$CFs?5owner?$DN?$CFld?5count?$DN?$CFlu?$DO?$AA@ DB '<'
	DB	'%s owner=%ld count=%lu>', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT rlock_repr
_TEXT	SEGMENT
self$ = 48
rlock_repr PROC						; COMDAT

; 471  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 472  :     return PyUnicode_FromFormat("<%s owner=%ld count=%lu>",
; 473  :         Py_TYPE(self)->tp_name, self->rlock_owner, self->rlock_count);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00017	44 8b 49 6c	 mov	 r9d, DWORD PTR [rcx+108]
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00020	44 8b 41 68	 mov	 r8d, DWORD PTR [rcx+104]
  00024	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@OELOMNJN@?$DM?$CFs?5owner?$DN?$CFld?5count?$DN?$CFlu?$DO?$AA@
  0002f	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 474  : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
rlock_repr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$localdummy_dealloc DD imagerel localdummy_dealloc
	DD	imagerel localdummy_dealloc+56
	DD	imagerel $unwind$localdummy_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$localdummy_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT localdummy_dealloc
_TEXT	SEGMENT
self$ = 48
localdummy_dealloc PROC					; COMDAT

; 607  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 608  :     if (self->weakreflist != NULL)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	74 0a		 je	 SHORT $LN1@localdummy

; 609  :         PyObject_ClearWeakRefs((PyObject *) self);

  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0001a	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN1@localdummy:

; 610  :     Py_TYPE(self)->tp_free((PyObject*)self);

  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00024	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0002d	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 611  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
localdummy_dealloc ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0BA@EIOLNPNH@thread?4local?4?$CFp?$AA@	; `string'
PUBLIC	??_C@_0CL@NGBDAHFO@Initialization?5arguments?5are?5not@ ; `string'
EXTRN	PyCFunction_NewEx:PROC
EXTRN	PyWeakref_NewRef:PROC
EXTRN	PyDict_New:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyBaseObject_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$local_new DD imagerel local_new
	DD	imagerel local_new+428
	DD	imagerel $unwind$local_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$local_new DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BA@EIOLNPNH@thread?4local?4?$CFp?$AA@
CONST	SEGMENT
??_C@_0BA@EIOLNPNH@thread?4local?4?$CFp?$AA@ DB 'thread.local.%p', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NGBDAHFO@Initialization?5arguments?5are?5not@
CONST	SEGMENT
??_C@_0CL@NGBDAHFO@Initialization?5arguments?5are?5not@ DB 'Initializatio'
	DB	'n arguments are not supported', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT local_new
_TEXT	SEGMENT
wr$ = 32
self$ = 40
type$ = 64
args$ = 72
kw$ = 80
local_new PROC						; COMDAT

; 708  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 709  :     localobject *self;
; 710  :     PyObject *wr;
; 711  :     static PyMethodDef wr_callback_def = {
; 712  :         "_localdummy_destroyed", (PyCFunction) _localdummy_destroyed, METH_O
; 713  :     };
; 714  : 
; 715  :     if (type->tp_init == PyBaseObject_Type.tp_init
; 716  :         && ((args && PyObject_IsTrue(args))
; 717  :         || (kw && PyObject_IsTrue(kw)))) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  00018	48 8b 0d 80 01
	00 00		 mov	 rcx, QWORD PTR PyBaseObject_Type+384
  0001f	48 39 88 80 01
	00 00		 cmp	 QWORD PTR [rax+384], rcx
  00026	75 46		 jne	 SHORT $LN17@local_new
  00028	48 83 7c 24 48
	00		 cmp	 QWORD PTR args$[rsp], 0
  0002e	74 0e		 je	 SHORT $LN15@local_new
  00030	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00035	e8 00 00 00 00	 call	 PyObject_IsTrue
  0003a	85 c0		 test	 eax, eax
  0003c	75 16		 jne	 SHORT $LN16@local_new
$LN15@local_new:
  0003e	48 83 7c 24 50
	00		 cmp	 QWORD PTR kw$[rsp], 0
  00044	74 28		 je	 SHORT $LN17@local_new
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR kw$[rsp]
  0004b	e8 00 00 00 00	 call	 PyObject_IsTrue
  00050	85 c0		 test	 eax, eax
  00052	74 1a		 je	 SHORT $LN17@local_new
$LN16@local_new:

; 718  :         PyErr_SetString(PyExc_TypeError,
; 719  :                   "Initialization arguments are not supported");

  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@NGBDAHFO@Initialization?5arguments?5are?5not@
  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00062	e8 00 00 00 00	 call	 PyErr_SetString

; 720  :         return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	e9 39 01 00 00	 jmp	 $LN18@local_new
$LN17@local_new:

; 721  :     }
; 722  : 
; 723  :     self = (localobject *)type->tp_alloc(type, 0);

  0006e	33 d2		 xor	 edx, edx
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  0007a	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00080	48 89 44 24 28	 mov	 QWORD PTR self$[rsp], rax

; 724  :     if (self == NULL)

  00085	48 83 7c 24 28
	00		 cmp	 QWORD PTR self$[rsp], 0
  0008b	75 07		 jne	 SHORT $LN14@local_new

; 725  :         return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	e9 13 01 00 00	 jmp	 $LN18@local_new
$LN14@local_new:
$LN13@local_new:

; 726  : 
; 727  :     Py_XINCREF(args);

  00094	48 83 7c 24 48
	00		 cmp	 QWORD PTR args$[rsp], 0
  0009a	74 0a		 je	 SHORT $LN10@local_new
  0009c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  000a1	e8 00 00 00 00	 call	 _Py_IncRef
$LN10@local_new:
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 e8		 jne	 SHORT $LN13@local_new

; 728  :     self->args = args;

  000ac	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  000b1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  000b6	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN9@local_new:

; 729  :     Py_XINCREF(kw);

  000ba	48 83 7c 24 50
	00		 cmp	 QWORD PTR kw$[rsp], 0
  000c0	74 0a		 je	 SHORT $LN6@local_new
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR kw$[rsp]
  000c7	e8 00 00 00 00	 call	 _Py_IncRef
$LN6@local_new:
  000cc	33 c0		 xor	 eax, eax
  000ce	85 c0		 test	 eax, eax
  000d0	75 e8		 jne	 SHORT $LN9@local_new

; 730  :     self->kw = kw;

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  000d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR kw$[rsp]
  000dc	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 731  :     self->key = PyUnicode_FromFormat("thread.local.%p", self);

  000e0	48 8b 54 24 28	 mov	 rdx, QWORD PTR self$[rsp]
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@EIOLNPNH@thread?4local?4?$CFp?$AA@
  000ec	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  000f6	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 732  :     if (self->key == NULL)

  000fa	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  000ff	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00104	75 05		 jne	 SHORT $LN5@local_new

; 733  :         goto err;

  00106	e9 90 00 00 00	 jmp	 $err$20853
$LN5@local_new:

; 734  : 
; 735  :     self->dummies = PyDict_New();

  0010b	e8 00 00 00 00	 call	 PyDict_New
  00110	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  00115	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 736  :     if (self->dummies == NULL)

  0011c	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  00121	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00129	75 02		 jne	 SHORT $LN4@local_new

; 737  :         goto err;

  0012b	eb 6e		 jmp	 SHORT $err$20853
$LN4@local_new:

; 738  : 
; 739  :     /* We use a weak reference to self in the callback closure
; 740  :        in order to avoid spurious reference cycles */
; 741  :     wr = PyWeakref_NewRef((PyObject *) self, NULL);

  0012d	33 d2		 xor	 edx, edx
  0012f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  00134	e8 00 00 00 00	 call	 PyWeakref_NewRef
  00139	48 89 44 24 20	 mov	 QWORD PTR wr$[rsp], rax

; 742  :     if (wr == NULL)

  0013e	48 83 7c 24 20
	00		 cmp	 QWORD PTR wr$[rsp], 0
  00144	75 02		 jne	 SHORT $LN3@local_new

; 743  :         goto err;

  00146	eb 53		 jmp	 SHORT $err$20853
$LN3@local_new:

; 744  :     self->wr_callback = PyCFunction_New(&wr_callback_def, wr);

  00148	45 33 c0	 xor	 r8d, r8d
  0014b	48 8b 54 24 20	 mov	 rdx, QWORD PTR wr$[rsp]
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?wr_callback_def@?1??local_new@@9@9
  00157	e8 00 00 00 00	 call	 PyCFunction_NewEx
  0015c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  00161	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 745  :     Py_DECREF(wr);

  00168	48 8b 4c 24 20	 mov	 rcx, QWORD PTR wr$[rsp]
  0016d	e8 00 00 00 00	 call	 _Py_DecRef

; 746  :     if (self->wr_callback == NULL)

  00172	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  00177	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0017f	75 02		 jne	 SHORT $LN2@local_new

; 747  :         goto err;

  00181	eb 18		 jmp	 SHORT $err$20853
$LN2@local_new:

; 748  : 
; 749  :     if (_local_create_dummy(self) == NULL)

  00183	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  00188	e8 00 00 00 00	 call	 _local_create_dummy
  0018d	48 85 c0	 test	 rax, rax
  00190	75 02		 jne	 SHORT $LN1@local_new

; 750  :         goto err;

  00192	eb 07		 jmp	 SHORT $err$20853
$LN1@local_new:

; 751  : 
; 752  :     return (PyObject *)self;

  00194	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  00199	eb 0c		 jmp	 SHORT $LN18@local_new
$err$20853:

; 753  : 
; 754  :   err:
; 755  :     Py_DECREF(self);

  0019b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  001a0	e8 00 00 00 00	 call	 _Py_DecRef

; 756  :     return NULL;

  001a5	33 c0		 xor	 eax, eax
$LN18@local_new:

; 757  : }

  001a7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ab	c3		 ret	 0
local_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@FDKGLEIF@_local_create_dummy?$AA@	; `string'
PUBLIC	??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@ ; `string'
PUBLIC	??_C@_0CF@PEAODEFD@Couldn?8t?5get?5thread?9state?5dictio@ ; `string'
EXTRN	PyDict_SetItem:PROC
EXTRN	PyExc_SystemError:QWORD
EXTRN	PyThreadState_GetDict:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_threadmodule.c
pdata	SEGMENT
$pdata$_local_create_dummy DD imagerel _local_create_dummy
	DD	imagerel _local_create_dummy+543
	DD	imagerel $unwind$_local_create_dummy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_local_create_dummy DD 010901H
	DD	0e209H
xdata	ENDS
;	COMDAT ??_C@_0BE@FDKGLEIF@_local_create_dummy?$AA@
CONST	SEGMENT
??_C@_0BE@FDKGLEIF@_local_create_dummy?$AA@ DB '_local_create_dummy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@
CONST	SEGMENT
??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@ DB '..\Modules\_t'
	DB	'hreadmodule.c', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PEAODEFD@Couldn?8t?5get?5thread?9state?5dictio@
CONST	SEGMENT
??_C@_0CF@PEAODEFD@Couldn?8t?5get?5thread?9state?5dictio@ DB 'Couldn''t g'
	DB	'et thread-state dictionary', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _local_create_dummy
_TEXT	SEGMENT
tdict$ = 48
wr$ = 56
dummy$ = 64
ldict$ = 72
r$ = 80
_py_tmp$20786 = 88
_py_tmp$20796 = 96
self$ = 128
_local_create_dummy PROC				; COMDAT

; 662  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 663  :     PyObject *tdict, *ldict = NULL, *wr = NULL;

  00009	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR ldict$[rsp], 0
  00012	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR wr$[rsp], 0

; 664  :     localdummyobject *dummy = NULL;

  0001b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR dummy$[rsp], 0

; 665  :     int r;
; 666  : 
; 667  :     tdict = PyThreadState_GetDict();

  00024	e8 00 00 00 00	 call	 PyThreadState_GetDict
  00029	48 89 44 24 30	 mov	 QWORD PTR tdict$[rsp], rax

; 668  :     if (tdict == NULL) {

  0002e	48 83 7c 24 30
	00		 cmp	 QWORD PTR tdict$[rsp], 0
  00034	75 18		 jne	 SHORT $LN26@local_crea

; 669  :         PyErr_SetString(PyExc_SystemError,
; 670  :                         "Couldn't get thread-state dictionary");

  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@PEAODEFD@Couldn?8t?5get?5thread?9state?5dictio@
  0003d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00044	e8 00 00 00 00	 call	 PyErr_SetString

; 671  :         goto err;

  00049	e9 82 01 00 00	 jmp	 $err$20770
$LN26@local_crea:

; 672  :     }
; 673  : 
; 674  :     ldict = PyDict_New();

  0004e	e8 00 00 00 00	 call	 PyDict_New
  00053	48 89 44 24 48	 mov	 QWORD PTR ldict$[rsp], rax

; 675  :     if (ldict == NULL)

  00058	48 83 7c 24 48
	00		 cmp	 QWORD PTR ldict$[rsp], 0
  0005e	75 05		 jne	 SHORT $LN25@local_crea

; 676  :         goto err;

  00060	e9 6b 01 00 00	 jmp	 $err$20770
$LN25@local_crea:

; 677  :     dummy = (localdummyobject *) localdummytype.tp_alloc(&localdummytype, 0);

  00065	33 d2		 xor	 edx, edx
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:localdummytype
  0006e	ff 15 88 01 00
	00		 call	 QWORD PTR localdummytype+392
  00074	48 89 44 24 40	 mov	 QWORD PTR dummy$[rsp], rax

; 678  :     if (dummy == NULL)

  00079	48 83 7c 24 40
	00		 cmp	 QWORD PTR dummy$[rsp], 0
  0007f	75 05		 jne	 SHORT $LN24@local_crea

; 679  :         goto err;

  00081	e9 4a 01 00 00	 jmp	 $err$20770
$LN24@local_crea:

; 680  :     dummy->localdict = ldict;

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR dummy$[rsp]
  0008b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ldict$[rsp]
  00090	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 681  :     wr = PyWeakref_NewRef((PyObject *) dummy, self->wr_callback);

  00094	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 8b 90 88 00
	00 00		 mov	 rdx, QWORD PTR [rax+136]
  000a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dummy$[rsp]
  000a8	e8 00 00 00 00	 call	 PyWeakref_NewRef
  000ad	48 89 44 24 38	 mov	 QWORD PTR wr$[rsp], rax

; 682  :     if (wr == NULL)

  000b2	48 83 7c 24 38
	00		 cmp	 QWORD PTR wr$[rsp], 0
  000b8	75 05		 jne	 SHORT $LN23@local_crea

; 683  :         goto err;

  000ba	e9 11 01 00 00	 jmp	 $err$20770
$LN23@local_crea:

; 684  : 
; 685  :     /* As a side-effect, this will cache the weakref's hash before the
; 686  :        dummy gets deleted */
; 687  :     r = PyDict_SetItem(self->dummies, wr, ldict);

  000bf	4c 8b 44 24 48	 mov	 r8, QWORD PTR ldict$[rsp]
  000c4	48 8b 54 24 38	 mov	 rdx, QWORD PTR wr$[rsp]
  000c9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000d1	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000d8	e8 00 00 00 00	 call	 PyDict_SetItem
  000dd	89 44 24 50	 mov	 DWORD PTR r$[rsp], eax

; 688  :     if (r < 0)

  000e1	83 7c 24 50 00	 cmp	 DWORD PTR r$[rsp], 0
  000e6	7d 05		 jge	 SHORT $LN22@local_crea

; 689  :         goto err;

  000e8	e9 e3 00 00 00	 jmp	 $err$20770
$LN22@local_crea:
$LN21@local_crea:

; 690  :     Py_CLEAR(wr);

  000ed	48 83 7c 24 38
	00		 cmp	 QWORD PTR wr$[rsp], 0
  000f3	74 47		 je	 SHORT $LN18@local_crea
  000f5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000fd	4c 8b 4c 24 38	 mov	 r9, QWORD PTR wr$[rsp]
  00102	41 b8 b2 02 00
	00		 mov	 r8d, 690		; 000002b2H
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@
  0010f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@FDKGLEIF@_local_create_dummy?$AA@
  00116	e8 00 00 00 00	 call	 _PyParallel_Guard
  0011b	85 c0		 test	 eax, eax
  0011d	75 1d		 jne	 SHORT $LN18@local_crea
  0011f	48 8b 44 24 38	 mov	 rax, QWORD PTR wr$[rsp]
  00124	48 89 44 24 58	 mov	 QWORD PTR _py_tmp$20786[rsp], rax
  00129	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR wr$[rsp], 0
  00132	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _py_tmp$20786[rsp]
  00137	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@local_crea:
  0013c	33 c0		 xor	 eax, eax
  0013e	85 c0		 test	 eax, eax
  00140	75 ab		 jne	 SHORT $LN21@local_crea

; 691  :     r = PyDict_SetItem(tdict, self->key, (PyObject *) dummy);

  00142	4c 8b 44 24 40	 mov	 r8, QWORD PTR dummy$[rsp]
  00147	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0014f	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00153	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tdict$[rsp]
  00158	e8 00 00 00 00	 call	 PyDict_SetItem
  0015d	89 44 24 50	 mov	 DWORD PTR r$[rsp], eax

; 692  :     if (r < 0)

  00161	83 7c 24 50 00	 cmp	 DWORD PTR r$[rsp], 0
  00166	7d 02		 jge	 SHORT $LN17@local_crea

; 693  :         goto err;

  00168	eb 66		 jmp	 SHORT $err$20770
$LN17@local_crea:
$LN16@local_crea:

; 694  :     Py_CLEAR(dummy);

  0016a	48 83 7c 24 40
	00		 cmp	 QWORD PTR dummy$[rsp], 0
  00170	74 47		 je	 SHORT $LN13@local_crea
  00172	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR dummy$[rsp]
  0017f	41 b8 b6 02 00
	00		 mov	 r8d, 694		; 000002b6H
  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@FDKGLEIF@_local_create_dummy?$AA@
  00193	e8 00 00 00 00	 call	 _PyParallel_Guard
  00198	85 c0		 test	 eax, eax
  0019a	75 1d		 jne	 SHORT $LN13@local_crea
  0019c	48 8b 44 24 40	 mov	 rax, QWORD PTR dummy$[rsp]
  001a1	48 89 44 24 60	 mov	 QWORD PTR _py_tmp$20796[rsp], rax
  001a6	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR dummy$[rsp], 0
  001af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _py_tmp$20796[rsp]
  001b4	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@local_crea:
  001b9	33 c0		 xor	 eax, eax
  001bb	85 c0		 test	 eax, eax
  001bd	75 ab		 jne	 SHORT $LN16@local_crea

; 695  : 
; 696  :     Py_DECREF(ldict);

  001bf	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ldict$[rsp]
  001c4	e8 00 00 00 00	 call	 _Py_DecRef

; 697  :     return ldict;

  001c9	48 8b 44 24 48	 mov	 rax, QWORD PTR ldict$[rsp]
  001ce	eb 4a		 jmp	 SHORT $LN27@local_crea
$err$20770:
$LN12@local_crea:

; 698  : 
; 699  : err:
; 700  :     Py_XDECREF(ldict);

  001d0	48 83 7c 24 48
	00		 cmp	 QWORD PTR ldict$[rsp], 0
  001d6	74 0a		 je	 SHORT $LN9@local_crea
  001d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ldict$[rsp]
  001dd	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@local_crea:
  001e2	33 c0		 xor	 eax, eax
  001e4	85 c0		 test	 eax, eax
  001e6	75 e8		 jne	 SHORT $LN12@local_crea
$LN8@local_crea:

; 701  :     Py_XDECREF(wr);

  001e8	48 83 7c 24 38
	00		 cmp	 QWORD PTR wr$[rsp], 0
  001ee	74 0a		 je	 SHORT $LN5@local_crea
  001f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR wr$[rsp]
  001f5	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@local_crea:
  001fa	33 c0		 xor	 eax, eax
  001fc	85 c0		 test	 eax, eax
  001fe	75 e8		 jne	 SHORT $LN8@local_crea
$LN4@local_crea:

; 702  :     Py_XDECREF(dummy);

  00200	48 83 7c 24 40
	00		 cmp	 QWORD PTR dummy$[rsp], 0
  00206	74 0a		 je	 SHORT $LN1@local_crea
  00208	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dummy$[rsp]
  0020d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@local_crea:
  00212	33 c0		 xor	 eax, eax
  00214	85 c0		 test	 eax, eax
  00216	75 e8		 jne	 SHORT $LN4@local_crea

; 703  :     return NULL;

  00218	33 c0		 xor	 eax, eax
$LN27@local_crea:

; 704  : }

  0021a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0021e	c3		 ret	 0
_local_create_dummy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@IKOIBAHF@local_traverse?$AA@		; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$local_traverse DD imagerel local_traverse
	DD	imagerel local_traverse+305
	DD	imagerel $unwind$local_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$local_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0P@IKOIBAHF@local_traverse?$AA@
CONST	SEGMENT
??_C@_0P@IKOIBAHF@local_traverse?$AA@ DB 'local_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT local_traverse
_TEXT	SEGMENT
vret$20883 = 32
vret$20891 = 36
vret$20899 = 40
self$ = 64
visit$ = 72
arg$ = 80
local_traverse PROC					; COMDAT

; 761  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN18@local_trav:

; 762  :     Py_VISIT(self->args);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN15@local_trav
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 fa 02 00
	00		 mov	 r8d, 762		; 000002faH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IKOIBAHF@local_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@local_trav:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 26		 je	 SHORT $LN14@local_trav
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$20883[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$20883[rsp], 0
  0005f	74 09		 je	 SHORT $LN13@local_trav
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$20883[rsp]
  00065	e9 c2 00 00 00	 jmp	 $LN19@local_trav
$LN13@local_trav:
$LN14@local_trav:
  0006a	33 c0		 xor	 eax, eax
  0006c	85 c0		 test	 eax, eax
  0006e	75 a3		 jne	 SHORT $LN18@local_trav
$LN12@local_trav:

; 763  :     Py_VISIT(self->kw);

  00070	e8 00 00 00 00	 call	 _Py_PXCTX
  00075	85 c0		 test	 eax, eax
  00077	74 1c		 je	 SHORT $LN9@local_trav
  00079	45 33 c9	 xor	 r9d, r9d
  0007c	41 b8 fb 02 00
	00		 mov	 r8d, 763		; 000002fbH
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IKOIBAHF@local_traverse?$AA@
  00090	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@local_trav:
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009a	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0009f	74 23		 je	 SHORT $LN8@local_trav
  000a1	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a6	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000ab	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000af	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b3	89 44 24 24	 mov	 DWORD PTR vret$20891[rsp], eax
  000b7	83 7c 24 24 00	 cmp	 DWORD PTR vret$20891[rsp], 0
  000bc	74 06		 je	 SHORT $LN7@local_trav
  000be	8b 44 24 24	 mov	 eax, DWORD PTR vret$20891[rsp]
  000c2	eb 68		 jmp	 SHORT $LN19@local_trav
$LN7@local_trav:
$LN8@local_trav:
  000c4	33 c0		 xor	 eax, eax
  000c6	85 c0		 test	 eax, eax
  000c8	75 a6		 jne	 SHORT $LN12@local_trav
$LN6@local_trav:

; 764  :     Py_VISIT(self->dummies);

  000ca	e8 00 00 00 00	 call	 _Py_PXCTX
  000cf	85 c0		 test	 eax, eax
  000d1	74 1c		 je	 SHORT $LN3@local_trav
  000d3	45 33 c9	 xor	 r9d, r9d
  000d6	41 b8 fc 02 00
	00		 mov	 r8d, 764		; 000002fcH
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IKOIBAHF@local_traverse?$AA@
  000ea	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@local_trav:
  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000f4	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000fc	74 26		 je	 SHORT $LN2@local_trav
  000fe	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00108	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0010f	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00113	89 44 24 28	 mov	 DWORD PTR vret$20899[rsp], eax
  00117	83 7c 24 28 00	 cmp	 DWORD PTR vret$20899[rsp], 0
  0011c	74 06		 je	 SHORT $LN1@local_trav
  0011e	8b 44 24 28	 mov	 eax, DWORD PTR vret$20899[rsp]
  00122	eb 08		 jmp	 SHORT $LN19@local_trav
$LN1@local_trav:
$LN2@local_trav:
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 a0		 jne	 SHORT $LN6@local_trav

; 765  :     return 0;

  0012a	33 c0		 xor	 eax, eax
$LN19@local_trav:

; 766  : }

  0012c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00130	c3		 ret	 0
local_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@MDAJCGDD@local_clear?$AA@		; `string'
EXTRN	PyDict_DelItem:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyThreadState_Next:PROC
EXTRN	PyInterpreterState_ThreadHead:PROC
EXTRN	PyThreadState_Get:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$local_clear DD imagerel local_clear
	DD	imagerel local_clear+599
	DD	imagerel $unwind$local_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$local_clear DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_0M@MDAJCGDD@local_clear?$AA@
CONST	SEGMENT
??_C@_0M@MDAJCGDD@local_clear?$AA@ DB 'local_clear', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT local_clear
_TEXT	SEGMENT
tstate$ = 48
_py_tmp$20912 = 56
_py_tmp$20920 = 64
_py_tmp$20928 = 72
_py_tmp$20936 = 80
self$ = 112
local_clear PROC					; COMDAT

; 770  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN21@local_clea:

; 771  :     PyThreadState *tstate;
; 772  :     Py_CLEAR(self->args);

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	74 53		 je	 SHORT $LN18@local_clea
  00015	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0001d	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00022	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  00026	41 b8 04 03 00
	00		 mov	 r8d, 772		; 00000304H
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MDAJCGDD@local_clear?$AA@
  0003a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003f	85 c0		 test	 eax, eax
  00041	75 25		 jne	 SHORT $LN18@local_clea
  00043	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00048	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004c	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$20912[rsp], rax
  00051	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00056	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
  0005e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$20912[rsp]
  00063	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@local_clea:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 9b		 jne	 SHORT $LN21@local_clea
$LN17@local_clea:

; 773  :     Py_CLEAR(self->kw);

  0006e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00073	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00078	74 53		 je	 SHORT $LN14@local_clea
  0007a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00082	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00087	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  0008b	41 b8 05 03 00
	00		 mov	 r8d, 773		; 00000305H
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MDAJCGDD@local_clear?$AA@
  0009f	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a4	85 c0		 test	 eax, eax
  000a6	75 25		 jne	 SHORT $LN14@local_clea
  000a8	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000ad	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b1	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$20920[rsp], rax
  000b6	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000bb	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  000c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$20920[rsp]
  000c8	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@local_clea:
  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 9b		 jne	 SHORT $LN17@local_clea
$LN13@local_clea:

; 774  :     Py_CLEAR(self->dummies);

  000d3	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000d8	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000e0	74 5c		 je	 SHORT $LN10@local_clea
  000e2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ea	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000ef	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  000f6	41 b8 06 03 00
	00		 mov	 r8d, 774		; 00000306H
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MDAJCGDD@local_clear?$AA@
  0010a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010f	85 c0		 test	 eax, eax
  00111	75 2b		 jne	 SHORT $LN10@local_clea
  00113	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00118	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0011f	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$20928[rsp], rax
  00124	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00129	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
  00134	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$20928[rsp]
  00139	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@local_clea:
  0013e	33 c0		 xor	 eax, eax
  00140	85 c0		 test	 eax, eax
  00142	75 8f		 jne	 SHORT $LN13@local_clea
$LN9@local_clea:

; 775  :     Py_CLEAR(self->wr_callback);

  00144	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00149	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00151	74 5c		 je	 SHORT $LN6@local_clea
  00153	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0015b	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00160	4c 8b 88 88 00
	00 00		 mov	 r9, QWORD PTR [rax+136]
  00167	41 b8 07 03 00
	00		 mov	 r8d, 775		; 00000307H
  0016d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@IPFPCOMB@?4?4?2Modules?2_threadmodule?4c?$AA@
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MDAJCGDD@local_clear?$AA@
  0017b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00180	85 c0		 test	 eax, eax
  00182	75 2b		 jne	 SHORT $LN6@local_clea
  00184	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00189	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00190	48 89 44 24 50	 mov	 QWORD PTR _py_tmp$20936[rsp], rax
  00195	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0019a	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0
  001a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _py_tmp$20936[rsp]
  001aa	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@local_clea:
  001af	33 c0		 xor	 eax, eax
  001b1	85 c0		 test	 eax, eax
  001b3	75 8f		 jne	 SHORT $LN9@local_clea

; 776  :     /* Remove all strong references to dummies from the thread states */
; 777  :     if (self->key
; 778  :         && (tstate = PyThreadState_Get())
; 779  :         && tstate->interp) {

  001b5	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001ba	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001bf	0f 84 8b 00 00
	00		 je	 $LN5@local_clea
  001c5	e8 00 00 00 00	 call	 PyThreadState_Get
  001ca	48 89 44 24 30	 mov	 QWORD PTR tstate$[rsp], rax
  001cf	48 83 7c 24 30
	00		 cmp	 QWORD PTR tstate$[rsp], 0
  001d5	74 79		 je	 SHORT $LN5@local_clea
  001d7	48 8b 44 24 30	 mov	 rax, QWORD PTR tstate$[rsp]
  001dc	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  001e1	74 6d		 je	 SHORT $LN5@local_clea

; 780  :         for(tstate = PyInterpreterState_ThreadHead(tstate->interp);
; 781  :             tstate;
; 782  :             tstate = PyThreadState_Next(tstate))

  001e3	48 8b 44 24 30	 mov	 rax, QWORD PTR tstate$[rsp]
  001e8	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001ec	e8 00 00 00 00	 call	 PyInterpreterState_ThreadHead
  001f1	48 89 44 24 30	 mov	 QWORD PTR tstate$[rsp], rax
  001f6	eb 0f		 jmp	 SHORT $LN4@local_clea
$LN3@local_clea:
  001f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tstate$[rsp]
  001fd	e8 00 00 00 00	 call	 PyThreadState_Next
  00202	48 89 44 24 30	 mov	 QWORD PTR tstate$[rsp], rax
$LN4@local_clea:
  00207	48 83 7c 24 30
	00		 cmp	 QWORD PTR tstate$[rsp], 0
  0020d	74 41		 je	 SHORT $LN2@local_clea

; 783  :             if (tstate->dict &&
; 784  :                 PyDict_GetItem(tstate->dict, self->key))

  0020f	48 8b 44 24 30	 mov	 rax, QWORD PTR tstate$[rsp]
  00214	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00219	74 33		 je	 SHORT $LN1@local_clea
  0021b	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00220	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00224	48 8b 44 24 30	 mov	 rax, QWORD PTR tstate$[rsp]
  00229	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  0022d	e8 00 00 00 00	 call	 PyDict_GetItem
  00232	48 85 c0	 test	 rax, rax
  00235	74 17		 je	 SHORT $LN1@local_clea

; 785  :                 PyDict_DelItem(tstate->dict, self->key);

  00237	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0023c	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00240	48 8b 44 24 30	 mov	 rax, QWORD PTR tstate$[rsp]
  00245	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00249	e8 00 00 00 00	 call	 PyDict_DelItem
$LN1@local_clea:

; 786  :     }

  0024e	eb a8		 jmp	 SHORT $LN3@local_clea
$LN2@local_clea:
$LN5@local_clea:

; 787  :     return 0;

  00250	33 c0		 xor	 eax, eax

; 788  : }

  00252	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00256	c3		 ret	 0
local_clear ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_UnTrack:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$local_dealloc DD imagerel local_dealloc
	DD	imagerel local_dealloc+108
	DD	imagerel $unwind$local_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$local_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT local_dealloc
_TEXT	SEGMENT
self$ = 48
local_dealloc PROC					; COMDAT

; 792  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 793  :     /* Weakrefs must be invalidated right now, otherwise they can be used
; 794  :        from code called below, which is very dangerous since Py_REFCNT(self) == 0 */
; 795  :     if (self->weakreflist != NULL)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00013	74 0a		 je	 SHORT $LN5@local_deal

; 796  :         PyObject_ClearWeakRefs((PyObject *) self);

  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0001a	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN5@local_deal:

; 797  : 
; 798  :     PyObject_GC_UnTrack(self);

  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00024	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 799  : 
; 800  :     local_clear(self);

  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0002e	e8 00 00 00 00	 call	 local_clear
$LN4@local_deal:

; 801  :     Py_XDECREF(self->key);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00038	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0003d	74 0e		 je	 SHORT $LN1@local_deal
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00044	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@local_deal:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN4@local_deal

; 802  :     Py_TYPE(self)->tp_free((PyObject*)self);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00061	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 803  : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
local_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@MBODLJBI@?8?$CF?450s?8?5object?5attribute?5?8?$CFU?8?5is@ ; `string'
EXTRN	_PyObject_GenericSetAttrWithDict:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_AttributeError:QWORD
EXTRN	PyObject_RichCompareBool:PROC
_BSS	SEGMENT
str_dict DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$local_setattro DD imagerel local_setattro
	DD	imagerel local_setattro+171
	DD	imagerel $unwind$local_setattro
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$local_setattro DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CL@MBODLJBI@?8?$CF?450s?8?5object?5attribute?5?8?$CFU?8?5is@
CONST	SEGMENT
??_C@_0CL@MBODLJBI@?8?$CF?450s?8?5object?5attribute?5?8?$CFU?8?5is@ DB ''''
	DB	'%.50s'' object attribute ''%U'' is read-only', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT local_setattro
_TEXT	SEGMENT
ldict$ = 32
r$ = 40
self$ = 64
name$ = 72
v$ = 80
local_setattro PROC					; COMDAT

; 844  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 845  :     PyObject *ldict;
; 846  :     int r;
; 847  : 
; 848  :     ldict = _ldict(self);

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00018	e8 00 00 00 00	 call	 _ldict
  0001d	48 89 44 24 20	 mov	 QWORD PTR ldict$[rsp], rax

; 849  :     if (ldict == NULL)

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR ldict$[rsp], 0
  00028	75 07		 jne	 SHORT $LN3@local_seta

; 850  :         return -1;

  0002a	b8 ff ff ff ff	 mov	 eax, -1
  0002f	eb 75		 jmp	 SHORT $LN4@local_seta
$LN3@local_seta:

; 851  : 
; 852  :     r = PyObject_RichCompareBool(name, str_dict, Py_EQ);

  00031	41 b8 02 00 00
	00		 mov	 r8d, 2
  00037	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR str_dict
  0003e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  00043	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00048	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 853  :     if (r == 1) {

  0004c	83 7c 24 28 01	 cmp	 DWORD PTR r$[rsp], 1
  00051	75 2c		 jne	 SHORT $LN2@local_seta

; 854  :         PyErr_Format(PyExc_AttributeError,
; 855  :                      "'%.50s' object attribute '%U' is read-only",
; 856  :                      Py_TYPE(self)->tp_name, name);

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	4c 8b 4c 24 48	 mov	 r9, QWORD PTR name$[rsp]
  00061	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@MBODLJBI@?8?$CF?450s?8?5object?5attribute?5?8?$CFU?8?5is@
  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00073	e8 00 00 00 00	 call	 PyErr_Format

; 857  :         return -1;

  00078	b8 ff ff ff ff	 mov	 eax, -1
  0007d	eb 27		 jmp	 SHORT $LN4@local_seta
$LN2@local_seta:

; 858  :     }
; 859  :     if (r == -1)

  0007f	83 7c 24 28 ff	 cmp	 DWORD PTR r$[rsp], -1
  00084	75 07		 jne	 SHORT $LN1@local_seta

; 860  :         return -1;

  00086	b8 ff ff ff ff	 mov	 eax, -1
  0008b	eb 19		 jmp	 SHORT $LN4@local_seta
$LN1@local_seta:

; 861  : 
; 862  :     return _PyObject_GenericSetAttrWithDict((PyObject *)self, name, v, ldict);

  0008d	4c 8b 4c 24 20	 mov	 r9, QWORD PTR ldict$[rsp]
  00092	4c 8b 44 24 50	 mov	 r8, QWORD PTR v$[rsp]
  00097	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000a1	e8 00 00 00 00	 call	 _PyObject_GenericSetAttrWithDict
$LN4@local_seta:

; 863  : }

  000a6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000aa	c3		 ret	 0
local_setattro ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EE@EAGBGOAN@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAd?$AAu?$AAm?$AAm?$AAy?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CG?$AAl?$AAo?$AAc?$AAa?$AAl?$AAd?$AAu?$AAm?$AAm?$AAy?$AAt?$AAy?$AAp@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ldict DD imagerel _ldict
	DD	imagerel _ldict+277
	DD	imagerel $unwind$_ldict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ldict DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_1EE@EAGBGOAN@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAd?$AAu?$AAm?$AAm?$AAy?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CG?$AAl?$AAo?$AAc?$AAa?$AAl?$AAd?$AAu?$AAm?$AAm?$AAy?$AAt?$AAy?$AAp@
CONST	SEGMENT
??_C@_1EE@EAGBGOAN@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAd?$AAu?$AAm?$AAm?$AAy?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CG?$AAl?$AAo?$AAc?$AAa?$AAl?$AAd?$AAu?$AAm?$AAm?$AAy?$AAt?$AAy?$AAp@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H
	DB	'(', 00H, 'd', 00H, 'u', 00H, 'm', 00H, 'm', 00H, 'y', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '&', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'd', 00H, 'u', 00H, 'm'
	DB	00H, 'm', 00H, 'y', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _ldict
_TEXT	SEGMENT
tdict$ = 32
dummy$ = 40
ldict$ = 48
self$ = 80
_ldict	PROC						; COMDAT

; 808  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 809  :     PyObject *tdict, *ldict, *dummy;
; 810  : 
; 811  :     tdict = PyThreadState_GetDict();

  00009	e8 00 00 00 00	 call	 PyThreadState_GetDict
  0000e	48 89 44 24 20	 mov	 QWORD PTR tdict$[rsp], rax

; 812  :     if (tdict == NULL) {

  00013	48 83 7c 24 20
	00		 cmp	 QWORD PTR tdict$[rsp], 0
  00019	75 1a		 jne	 SHORT $LN5@ldict

; 813  :         PyErr_SetString(PyExc_SystemError,
; 814  :                         "Couldn't get thread-state dictionary");

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@PEAODEFD@Couldn?8t?5get?5thread?9state?5dictio@
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00029	e8 00 00 00 00	 call	 PyErr_SetString

; 815  :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 db 00 00 00	 jmp	 $LN6@ldict
$LN5@ldict:

; 816  :     }
; 817  : 
; 818  :     dummy = PyDict_GetItem(tdict, self->key);

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0003a	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tdict$[rsp]
  00043	e8 00 00 00 00	 call	 PyDict_GetItem
  00048	48 89 44 24 28	 mov	 QWORD PTR dummy$[rsp], rax

; 819  :     if (dummy == NULL) {

  0004d	48 83 7c 24 28
	00		 cmp	 QWORD PTR dummy$[rsp], 0
  00053	75 7a		 jne	 SHORT $LN4@ldict

; 820  :         ldict = _local_create_dummy(self);

  00055	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0005a	e8 00 00 00 00	 call	 _local_create_dummy
  0005f	48 89 44 24 30	 mov	 QWORD PTR ldict$[rsp], rax

; 821  :         if (ldict == NULL)

  00064	48 83 7c 24 30
	00		 cmp	 QWORD PTR ldict$[rsp], 0
  0006a	75 07		 jne	 SHORT $LN3@ldict

; 822  :             return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 9d 00 00 00	 jmp	 $LN6@ldict
$LN3@ldict:

; 823  : 
; 824  :         if (Py_TYPE(self)->tp_init != PyBaseObject_Type.tp_init &&
; 825  :             Py_TYPE(self)->tp_init((PyObject*)self,
; 826  :                                    self->args, self->kw) < 0) {

  00073	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00078	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0007c	48 8b 0d 80 01
	00 00		 mov	 rcx, QWORD PTR PyBaseObject_Type+384
  00083	48 39 88 80 01
	00 00		 cmp	 QWORD PTR [rax+384], rcx
  0008a	74 41		 je	 SHORT $LN2@ldict
  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00091	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0009a	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000a3	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  000a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000ac	ff 90 80 01 00
	00		 call	 QWORD PTR [rax+384]
  000b2	85 c0		 test	 eax, eax
  000b4	7d 17		 jge	 SHORT $LN2@ldict

; 827  :             /* we need to get rid of ldict from thread so
; 828  :                we create a new one the next time we do an attr
; 829  :                access */
; 830  :             PyDict_DelItem(tdict, self->key);

  000b6	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000bb	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tdict$[rsp]
  000c4	e8 00 00 00 00	 call	 PyDict_DelItem

; 831  :             return NULL;

  000c9	33 c0		 xor	 eax, eax
  000cb	eb 43		 jmp	 SHORT $LN6@ldict
$LN2@ldict:

; 832  :         }
; 833  :     }
; 834  :     else {

  000cd	eb 3c		 jmp	 SHORT $LN1@ldict
$LN4@ldict:

; 835  :         assert(Py_TYPE(dummy) == &localdummytype);

  000cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:localdummytype
  000d6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dummy$[rsp]
  000db	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000df	74 1c		 je	 SHORT $LN8@ldict
  000e1	41 b8 43 03 00
	00		 mov	 r8d, 835		; 00000343H
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DG@GPAGHMAF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@EAGBGOAN@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAd?$AAu?$AAm?$AAm?$AAy?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CG?$AAl?$AAo?$AAc?$AAa?$AAl?$AAd?$AAu?$AAm?$AAm?$AAy?$AAt?$AAy?$AAp@
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fb	33 c0		 xor	 eax, eax
$LN8@ldict:

; 836  :         ldict = ((localdummyobject *) dummy)->localdict;

  000fd	48 8b 44 24 28	 mov	 rax, QWORD PTR dummy$[rsp]
  00102	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00106	48 89 44 24 30	 mov	 QWORD PTR ldict$[rsp], rax
$LN1@ldict:

; 837  :     }
; 838  : 
; 839  :     return ldict;

  0010b	48 8b 44 24 30	 mov	 rax, QWORD PTR ldict$[rsp]
$LN6@ldict:

; 840  : }

  00110	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00114	c3		 ret	 0
_ldict	ENDP
_TEXT	ENDS
EXTRN	_PyObject_GenericGetAttrWithDict:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$local_getattro DD imagerel local_getattro
	DD	imagerel local_getattro+216
	DD	imagerel $unwind$local_getattro
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$local_getattro DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT local_getattro
_TEXT	SEGMENT
value$ = 32
ldict$ = 40
r$ = 48
self$ = 80
name$ = 88
local_getattro PROC					; COMDAT

; 913  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 914  :     PyObject *ldict, *value;
; 915  :     int r;
; 916  : 
; 917  :     ldict = _ldict(self);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 _ldict
  00018	48 89 44 24 28	 mov	 QWORD PTR ldict$[rsp], rax

; 918  :     if (ldict == NULL)

  0001d	48 83 7c 24 28
	00		 cmp	 QWORD PTR ldict$[rsp], 0
  00023	75 07		 jne	 SHORT $LN5@local_geta

; 919  :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	e9 a7 00 00 00	 jmp	 $LN6@local_geta
$LN5@local_geta:

; 920  : 
; 921  :     r = PyObject_RichCompareBool(name, str_dict, Py_EQ);

  0002c	41 b8 02 00 00
	00		 mov	 r8d, 2
  00032	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR str_dict
  00039	48 8b 4c 24 58	 mov	 rcx, QWORD PTR name$[rsp]
  0003e	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00043	89 44 24 30	 mov	 DWORD PTR r$[rsp], eax

; 922  :     if (r == 1) {

  00047	83 7c 24 30 01	 cmp	 DWORD PTR r$[rsp], 1
  0004c	75 11		 jne	 SHORT $LN4@local_geta

; 923  :         Py_INCREF(ldict);

  0004e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ldict$[rsp]
  00053	e8 00 00 00 00	 call	 _Py_IncRef

; 924  :         return ldict;

  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR ldict$[rsp]
  0005d	eb 74		 jmp	 SHORT $LN6@local_geta
$LN4@local_geta:

; 925  :     }
; 926  :     if (r == -1)

  0005f	83 7c 24 30 ff	 cmp	 DWORD PTR r$[rsp], -1
  00064	75 04		 jne	 SHORT $LN3@local_geta

; 927  :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	eb 69		 jmp	 SHORT $LN6@local_geta
$LN3@local_geta:

; 928  : 
; 929  :     if (Py_TYPE(self) != &localtype)

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:localtype
  00071	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00076	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0007a	74 16		 je	 SHORT $LN2@local_geta

; 930  :         /* use generic lookup for subtypes */
; 931  :         return _PyObject_GenericGetAttrWithDict((PyObject *)self, name, ldict);

  0007c	4c 8b 44 24 28	 mov	 r8, QWORD PTR ldict$[rsp]
  00081	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  00086	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0008b	e8 00 00 00 00	 call	 _PyObject_GenericGetAttrWithDict
  00090	eb 41		 jmp	 SHORT $LN6@local_geta
$LN2@local_geta:

; 932  : 
; 933  :     /* Optimization: just look in dict ourselves */
; 934  :     value = PyDict_GetItem(ldict, name);

  00092	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  00097	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ldict$[rsp]
  0009c	e8 00 00 00 00	 call	 PyDict_GetItem
  000a1	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 935  :     if (value == NULL)

  000a6	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  000ac	75 16		 jne	 SHORT $LN1@local_geta

; 936  :         /* Fall back on generic to get __class__ and __dict__ */
; 937  :         return _PyObject_GenericGetAttrWithDict((PyObject *)self, name, ldict);

  000ae	4c 8b 44 24 28	 mov	 r8, QWORD PTR ldict$[rsp]
  000b3	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  000b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000bd	e8 00 00 00 00	 call	 _PyObject_GenericGetAttrWithDict
  000c2	eb 0f		 jmp	 SHORT $LN6@local_geta
$LN1@local_geta:

; 938  : 
; 939  :     Py_INCREF(value);

  000c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  000c9	e8 00 00 00 00	 call	 _Py_IncRef

; 940  :     return value;

  000ce	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
$LN6@local_geta:

; 941  : }

  000d3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d7	c3		 ret	 0
local_getattro ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EI@DDOHOLNJ@?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA_?$AAT?$AAy?$AAp?$AAe?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?0?$AA?5?$AA?$CG?$AAl?$AAo?$AAc?$AAa?$AAl?$AAt?$AAy@ ; `string'
PUBLIC	??_C@_1EC@IIJEONPF@?$AAP?$AAy?$AAW?$AAe?$AAa?$AAk?$AAr?$AAe?$AAf?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAR?$AAe?$AAf?$AA?$CI?$AAl?$AAo?$AAc?$AAa?$AAl?$AAw?$AAe?$AAa?$AAk?$AAr?$AAe?$AAf?$AA?$CJ@ ; `string'
EXTRN	PyErr_WriteUnraisable:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	_PyWeakref_RefType:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_localdummy_destroyed DD imagerel _localdummy_destroyed
	DD	imagerel _localdummy_destroyed+394
	DD	imagerel $unwind$_localdummy_destroyed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_localdummy_destroyed DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1EI@DDOHOLNJ@?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA_?$AAT?$AAy?$AAp?$AAe?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?0?$AA?5?$AA?$CG?$AAl?$AAo?$AAc?$AAa?$AAl?$AAt?$AAy@
CONST	SEGMENT
??_C@_1EI@DDOHOLNJ@?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA_?$AAT?$AAy?$AAp?$AAe?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?0?$AA?5?$AA?$CG?$AAl?$AAo?$AAc?$AAa?$AAl?$AAt?$AAy@ DB 'P'
	DB	00H, 'y', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, '_', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 'C'
	DB	00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'o', 00H
	DB	'b', 00H, 'j', 00H, ',', 00H, ' ', 00H, '&', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'a', 00H, 'l', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@IIJEONPF@?$AAP?$AAy?$AAW?$AAe?$AAa?$AAk?$AAr?$AAe?$AAf?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAR?$AAe?$AAf?$AA?$CI?$AAl?$AAo?$AAc?$AAa?$AAl?$AAw?$AAe?$AAa?$AAk?$AAr?$AAe?$AAf?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@IIJEONPF@?$AAP?$AAy?$AAW?$AAe?$AAa?$AAk?$AAr?$AAe?$AAf?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAR?$AAe?$AAf?$AA?$CI?$AAl?$AAo?$AAc?$AAa?$AAl?$AAw?$AAe?$AAa?$AAk?$AAr?$AAe?$AAf?$AA?$CJ@ DB 'P'
	DB	00H, 'y', 00H, 'W', 00H, 'e', 00H, 'a', 00H, 'k', 00H, 'r', 00H
	DB	'e', 00H, 'f', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, 'R', 00H, 'e', 00H, 'f', 00H, '(', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'w', 00H, 'e', 00H, 'a'
	DB	00H, 'k', 00H, 'r', 00H, 'e', 00H, 'f', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _localdummy_destroyed
_TEXT	SEGMENT
self$ = 32
obj$ = 40
ldict$21074 = 48
tv79 = 56
localweakref$ = 80
dummyweakref$ = 88
_localdummy_destroyed PROC				; COMDAT

; 946  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 947  :     PyObject *obj;
; 948  :     localobject *self;
; 949  :     assert(PyWeakref_CheckRef(localweakref));

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyWeakref_RefType
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR localweakref$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 35		 je	 SHORT $LN7@localdummy@2
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_PyWeakref_RefType
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR localweakref$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 1c		 jne	 SHORT $LN7@localdummy@2
  00039	41 b8 b5 03 00
	00		 mov	 r8d, 949		; 000003b5H
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DG@GPAGHMAF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@IIJEONPF@?$AAP?$AAy?$AAW?$AAe?$AAa?$AAk?$AAr?$AAe?$AAf?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAR?$AAe?$AAf?$AA?$CI?$AAl?$AAo?$AAc?$AAa?$AAl?$AAw?$AAe?$AAa?$AAk?$AAr?$AAe?$AAf?$AA?$CJ@
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00053	33 c0		 xor	 eax, eax
$LN7@localdummy@2:

; 950  :     obj = PyWeakref_GET_OBJECT(localweakref);

  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR localweakref$[rsp]
  0005a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0005e	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  00063	7e 10		 jle	 SHORT $LN8@localdummy@2
  00065	48 8b 44 24 50	 mov	 rax, QWORD PTR localweakref$[rsp]
  0006a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006e	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
  00073	eb 0c		 jmp	 SHORT $LN9@localdummy@2
$LN8@localdummy@2:
  00075	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007c	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
$LN9@localdummy@2:
  00081	48 8b 44 24 38	 mov	 rax, QWORD PTR tv79[rsp]
  00086	48 89 44 24 28	 mov	 QWORD PTR obj$[rsp], rax

; 951  :     if (obj == Py_None)

  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00092	48 39 44 24 28	 cmp	 QWORD PTR obj$[rsp], rax
  00097	75 18		 jne	 SHORT $LN4@localdummy@2

; 952  :         Py_RETURN_NONE;

  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000a0	e8 00 00 00 00	 call	 _Py_IncRef
  000a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ac	e9 d4 00 00 00	 jmp	 $LN5@localdummy@2
$LN4@localdummy@2:

; 953  :     Py_INCREF(obj);

  000b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR obj$[rsp]
  000b6	e8 00 00 00 00	 call	 _Py_IncRef

; 954  :     assert(PyObject_TypeCheck(obj, &localtype));

  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:localtype
  000c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR obj$[rsp]
  000c7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000cb	74 35		 je	 SHORT $LN10@localdummy@2
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:localtype
  000d4	48 8b 44 24 28	 mov	 rax, QWORD PTR obj$[rsp]
  000d9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000dd	e8 00 00 00 00	 call	 PyType_IsSubtype
  000e2	85 c0		 test	 eax, eax
  000e4	75 1c		 jne	 SHORT $LN10@localdummy@2
  000e6	41 b8 ba 03 00
	00		 mov	 r8d, 954		; 000003baH
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DG@GPAGHMAF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@DDOHOLNJ@?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA_?$AAT?$AAy?$AAp?$AAe?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?0?$AA?5?$AA?$CG?$AAl?$AAo?$AAc?$AAa?$AAl?$AAt?$AAy@
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00100	33 c0		 xor	 eax, eax
$LN10@localdummy@2:

; 955  :     /* If the thread-local object is still alive and not being cleared,
; 956  :        remove the corresponding local dict */
; 957  :     self = (localobject *) obj;

  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR obj$[rsp]
  00107	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 958  :     if (self->dummies != NULL) {

  0010c	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00111	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00119	74 4d		 je	 SHORT $LN3@localdummy@2

; 959  :         PyObject *ldict;
; 960  :         ldict = PyDict_GetItem(self->dummies, dummyweakref);

  0011b	48 8b 54 24 58	 mov	 rdx, QWORD PTR dummyweakref$[rsp]
  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00125	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0012c	e8 00 00 00 00	 call	 PyDict_GetItem
  00131	48 89 44 24 30	 mov	 QWORD PTR ldict$21074[rsp], rax

; 961  :         if (ldict != NULL) {

  00136	48 83 7c 24 30
	00		 cmp	 QWORD PTR ldict$21074[rsp], 0
  0013c	74 16		 je	 SHORT $LN2@localdummy@2

; 962  :             PyDict_DelItem(self->dummies, dummyweakref);

  0013e	48 8b 54 24 58	 mov	 rdx, QWORD PTR dummyweakref$[rsp]
  00143	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00148	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0014f	e8 00 00 00 00	 call	 PyDict_DelItem
$LN2@localdummy@2:

; 963  :         }
; 964  :         if (PyErr_Occurred())

  00154	e8 00 00 00 00	 call	 PyErr_Occurred
  00159	48 85 c0	 test	 rax, rax
  0015c	74 0a		 je	 SHORT $LN1@localdummy@2

; 965  :             PyErr_WriteUnraisable(obj);

  0015e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR obj$[rsp]
  00163	e8 00 00 00 00	 call	 PyErr_WriteUnraisable
$LN1@localdummy@2:
$LN3@localdummy@2:

; 966  :     }
; 967  :     Py_DECREF(obj);

  00168	48 8b 4c 24 28	 mov	 rcx, QWORD PTR obj$[rsp]
  0016d	e8 00 00 00 00	 call	 _Py_DecRef

; 968  :     Py_RETURN_NONE;

  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00179	e8 00 00 00 00	 call	 _Py_IncRef
  0017e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN5@localdummy@2:

; 969  : }

  00185	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00189	c3		 ret	 0
_localdummy_destroyed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@ODCFJGAK@can?8t?5start?5new?5thread?$AA@ ; `string'
PUBLIC	??_C@_0CG@MFDKJLAE@optional?53rd?5arg?5must?5be?5a?5dicti@ ; `string'
PUBLIC	??_C@_0BI@FCDOBOF@2nd?5arg?5must?5be?5a?5tuple?$AA@ ; `string'
PUBLIC	??_C@_0BL@JGMPDGMG@first?5arg?5must?5be?5callable?$AA@ ; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	PyThreadState_Clear:PROC
EXTRN	PyThread_start_new_thread:PROC
EXTRN	PyEval_InitThreads:PROC
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	_PyThreadState_Prealloc:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	PyCallable_Check:PROC
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$thread_PyThread_start_new_thread DD imagerel thread_PyThread_start_new_thread
	DD	imagerel thread_PyThread_start_new_thread+692
	DD	imagerel $unwind$thread_PyThread_start_new_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$thread_PyThread_start_new_thread DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0BH@ODCFJGAK@can?8t?5start?5new?5thread?$AA@
CONST	SEGMENT
??_C@_0BH@ODCFJGAK@can?8t?5start?5new?5thread?$AA@ DB 'can''t start new t'
	DB	'hread', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MFDKJLAE@optional?53rd?5arg?5must?5be?5a?5dicti@
CONST	SEGMENT
??_C@_0CG@MFDKJLAE@optional?53rd?5arg?5must?5be?5a?5dicti@ DB 'optional 3'
	DB	'rd arg must be a dictionary', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FCDOBOF@2nd?5arg?5must?5be?5a?5tuple?$AA@
CONST	SEGMENT
??_C@_0BI@FCDOBOF@2nd?5arg?5must?5be?5a?5tuple?$AA@ DB '2nd arg must be a'
	DB	' tuple', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JGMPDGMG@first?5arg?5must?5be?5callable?$AA@
CONST	SEGMENT
??_C@_0BL@JGMPDGMG@first?5arg?5must?5be?5callable?$AA@ DB 'first arg must'
	DB	' be callable', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT thread_PyThread_start_new_thread
_TEXT	SEGMENT
boot$ = 64
args$ = 72
keyw$ = 80
ident$ = 88
func$ = 96
tv129 = 104
tv146 = 112
tv170 = 116
self$ = 144
fargs$ = 152
thread_PyThread_start_new_thread PROC			; COMDAT

; 1028 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1029 :     PyObject *func, *args, *keyw = NULL;

  00011	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR keyw$[rsp], 0

; 1030 :     struct bootstate *boot;
; 1031 :     long ident;
; 1032 : 
; 1033 :     if (!PyArg_UnpackTuple(fargs, "start_new_thread", 2, 3,
; 1034 :                            &func, &args, &keyw))

  0001a	48 8d 44 24 50	 lea	 rax, QWORD PTR keyw$[rsp]
  0001f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00024	48 8d 44 24 48	 lea	 rax, QWORD PTR args$[rsp]
  00029	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002e	48 8d 44 24 60	 lea	 rax, QWORD PTR func$[rsp]
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	41 b9 03 00 00
	00		 mov	 r9d, 3
  0003e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@NIEJKBPO@start_new_thread?$AA@
  0004b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR fargs$[rsp]
  00053	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00058	85 c0		 test	 eax, eax
  0005a	75 07		 jne	 SHORT $LN15@thread_PyT

; 1035 :         return NULL;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 49 02 00 00	 jmp	 $LN16@thread_PyT
$LN15@thread_PyT:

; 1036 :     if (!PyCallable_Check(func)) {

  00063	48 8b 4c 24 60	 mov	 rcx, QWORD PTR func$[rsp]
  00068	e8 00 00 00 00	 call	 PyCallable_Check
  0006d	85 c0		 test	 eax, eax
  0006f	75 1a		 jne	 SHORT $LN14@thread_PyT

; 1037 :         PyErr_SetString(PyExc_TypeError,
; 1038 :                         "first arg must be callable");

  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@JGMPDGMG@first?5arg?5must?5be?5callable?$AA@
  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007f	e8 00 00 00 00	 call	 PyErr_SetString

; 1039 :         return NULL;

  00084	33 c0		 xor	 eax, eax
  00086	e9 21 02 00 00	 jmp	 $LN16@thread_PyT
$LN14@thread_PyT:

; 1040 :     }
; 1041 :     if (!PyTuple_Check(args)) {

  0008b	48 8b 44 24 48	 mov	 rax, QWORD PTR args$[rsp]
  00090	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00094	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009a	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0009f	85 c0		 test	 eax, eax
  000a1	75 1a		 jne	 SHORT $LN13@thread_PyT

; 1042 :         PyErr_SetString(PyExc_TypeError,
; 1043 :                         "2nd arg must be a tuple");

  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@FCDOBOF@2nd?5arg?5must?5be?5a?5tuple?$AA@
  000aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b1	e8 00 00 00 00	 call	 PyErr_SetString

; 1044 :         return NULL;

  000b6	33 c0		 xor	 eax, eax
  000b8	e9 ef 01 00 00	 jmp	 $LN16@thread_PyT
$LN13@thread_PyT:

; 1045 :     }
; 1046 :     if (keyw != NULL && !PyDict_Check(keyw)) {

  000bd	48 83 7c 24 50
	00		 cmp	 QWORD PTR keyw$[rsp], 0
  000c3	74 32		 je	 SHORT $LN12@thread_PyT
  000c5	48 8b 44 24 50	 mov	 rax, QWORD PTR keyw$[rsp]
  000ca	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ce	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d4	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  000d9	85 c0		 test	 eax, eax
  000db	75 1a		 jne	 SHORT $LN12@thread_PyT

; 1047 :         PyErr_SetString(PyExc_TypeError,
; 1048 :                         "optional 3rd arg must be a dictionary");

  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@MFDKJLAE@optional?53rd?5arg?5must?5be?5a?5dicti@
  000e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000eb	e8 00 00 00 00	 call	 PyErr_SetString

; 1049 :         return NULL;

  000f0	33 c0		 xor	 eax, eax
  000f2	e9 b5 01 00 00	 jmp	 $LN16@thread_PyT
$LN12@thread_PyT:

; 1050 :     }
; 1051 :     boot = PyMem_NEW(struct bootstate, 1);

  000f7	e8 00 00 00 00	 call	 _Py_PXCTX
  000fc	85 c0		 test	 eax, eax
  000fe	74 11		 je	 SHORT $LN18@thread_PyT
  00100	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00105	e8 00 00 00 00	 call	 _PxMem_Malloc
  0010a	48 89 44 24 68	 mov	 QWORD PTR tv129[rsp], rax
  0010f	eb 0f		 jmp	 SHORT $LN19@thread_PyT
$LN18@thread_PyT:
  00111	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00116	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0011b	48 89 44 24 68	 mov	 QWORD PTR tv129[rsp], rax
$LN19@thread_PyT:
  00120	48 8b 44 24 68	 mov	 rax, QWORD PTR tv129[rsp]
  00125	48 89 44 24 40	 mov	 QWORD PTR boot$[rsp], rax

; 1052 :     if (boot == NULL)

  0012a	48 83 7c 24 40
	00		 cmp	 QWORD PTR boot$[rsp], 0
  00130	75 0a		 jne	 SHORT $LN11@thread_PyT

; 1053 :         return PyErr_NoMemory();

  00132	e8 00 00 00 00	 call	 PyErr_NoMemory
  00137	e9 70 01 00 00	 jmp	 $LN16@thread_PyT
$LN11@thread_PyT:

; 1054 :     boot->interp = PyThreadState_GET()->interp;

  0013c	e8 00 00 00 00	 call	 PyThreadState_Get
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR boot$[rsp]
  00146	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0014a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1055 :     boot->func = func;

  0014d	48 8b 44 24 40	 mov	 rax, QWORD PTR boot$[rsp]
  00152	48 8b 4c 24 60	 mov	 rcx, QWORD PTR func$[rsp]
  00157	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1056 :     boot->args = args;

  0015b	48 8b 44 24 40	 mov	 rax, QWORD PTR boot$[rsp]
  00160	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00165	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1057 :     boot->keyw = keyw;

  00169	48 8b 44 24 40	 mov	 rax, QWORD PTR boot$[rsp]
  0016e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR keyw$[rsp]
  00173	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1058 :     boot->tstate = _PyThreadState_Prealloc(boot->interp);

  00177	48 8b 44 24 40	 mov	 rax, QWORD PTR boot$[rsp]
  0017c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0017f	e8 00 00 00 00	 call	 _PyThreadState_Prealloc
  00184	48 8b 4c 24 40	 mov	 rcx, QWORD PTR boot$[rsp]
  00189	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1059 :     if (boot->tstate == NULL) {

  0018d	48 8b 44 24 40	 mov	 rax, QWORD PTR boot$[rsp]
  00192	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00197	75 39		 jne	 SHORT $LN10@thread_PyT

; 1060 :         PyMem_DEL(boot);

  00199	e8 00 00 00 00	 call	 _Py_PXCTX
  0019e	85 c0		 test	 eax, eax
  001a0	74 14		 je	 SHORT $LN20@thread_PyT
  001a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR boot$[rsp]
  001a7	e8 00 00 00 00	 call	 _PxMem_Free
  001ac	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
  001b4	eb 12		 jmp	 SHORT $LN21@thread_PyT
$LN20@thread_PyT:
  001b6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR boot$[rsp]
  001bb	e8 00 00 00 00	 call	 _PyMem_DebugFree
  001c0	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
$LN21@thread_PyT:

; 1061 :         return PyErr_NoMemory();

  001c8	e8 00 00 00 00	 call	 PyErr_NoMemory
  001cd	e9 da 00 00 00	 jmp	 $LN16@thread_PyT
$LN10@thread_PyT:

; 1062 :     }
; 1063 :     Py_INCREF(func);

  001d2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR func$[rsp]
  001d7	e8 00 00 00 00	 call	 _Py_IncRef

; 1064 :     Py_INCREF(args);

  001dc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  001e1	e8 00 00 00 00	 call	 _Py_IncRef
$LN9@thread_PyT:

; 1065 :     Py_XINCREF(keyw);

  001e6	48 83 7c 24 50
	00		 cmp	 QWORD PTR keyw$[rsp], 0
  001ec	74 0a		 je	 SHORT $LN6@thread_PyT
  001ee	48 8b 4c 24 50	 mov	 rcx, QWORD PTR keyw$[rsp]
  001f3	e8 00 00 00 00	 call	 _Py_IncRef
$LN6@thread_PyT:
  001f8	33 c0		 xor	 eax, eax
  001fa	85 c0		 test	 eax, eax
  001fc	75 e8		 jne	 SHORT $LN9@thread_PyT

; 1066 :     PyEval_InitThreads(); /* Start the interpreter's thread-awareness */

  001fe	e8 00 00 00 00	 call	 PyEval_InitThreads

; 1067 :     ident = PyThread_start_new_thread(t_bootstrap, (void*) boot);

  00203	48 8b 54 24 40	 mov	 rdx, QWORD PTR boot$[rsp]
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:t_bootstrap
  0020f	e8 00 00 00 00	 call	 PyThread_start_new_thread
  00214	89 44 24 58	 mov	 DWORD PTR ident$[rsp], eax

; 1068 :     if (ident == -1) {

  00218	83 7c 24 58 ff	 cmp	 DWORD PTR ident$[rsp], -1
  0021d	0f 85 80 00 00
	00		 jne	 $LN5@thread_PyT

; 1069 :         PyErr_SetString(ThreadError, "can't start new thread");

  00223	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@ODCFJGAK@can?8t?5start?5new?5thread?$AA@
  0022a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ThreadError
  00231	e8 00 00 00 00	 call	 PyErr_SetString

; 1070 :         Py_DECREF(func);

  00236	48 8b 4c 24 60	 mov	 rcx, QWORD PTR func$[rsp]
  0023b	e8 00 00 00 00	 call	 _Py_DecRef

; 1071 :         Py_DECREF(args);

  00240	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00245	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@thread_PyT:

; 1072 :         Py_XDECREF(keyw);

  0024a	48 83 7c 24 50
	00		 cmp	 QWORD PTR keyw$[rsp], 0
  00250	74 0a		 je	 SHORT $LN1@thread_PyT
  00252	48 8b 4c 24 50	 mov	 rcx, QWORD PTR keyw$[rsp]
  00257	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@thread_PyT:
  0025c	33 c0		 xor	 eax, eax
  0025e	85 c0		 test	 eax, eax
  00260	75 e8		 jne	 SHORT $LN4@thread_PyT

; 1073 :         PyThreadState_Clear(boot->tstate);

  00262	48 8b 44 24 40	 mov	 rax, QWORD PTR boot$[rsp]
  00267	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0026b	e8 00 00 00 00	 call	 PyThreadState_Clear

; 1074 :         PyMem_DEL(boot);

  00270	e8 00 00 00 00	 call	 _Py_PXCTX
  00275	85 c0		 test	 eax, eax
  00277	74 14		 je	 SHORT $LN22@thread_PyT
  00279	48 8b 4c 24 40	 mov	 rcx, QWORD PTR boot$[rsp]
  0027e	e8 00 00 00 00	 call	 _PxMem_Free
  00283	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv170[rsp], 0
  0028b	eb 12		 jmp	 SHORT $LN23@thread_PyT
$LN22@thread_PyT:
  0028d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR boot$[rsp]
  00292	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00297	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv170[rsp], 0
$LN23@thread_PyT:

; 1075 :         return NULL;

  0029f	33 c0		 xor	 eax, eax
  002a1	eb 09		 jmp	 SHORT $LN16@thread_PyT
$LN5@thread_PyT:

; 1076 :     }
; 1077 :     return PyLong_FromLong(ident);

  002a3	8b 4c 24 58	 mov	 ecx, DWORD PTR ident$[rsp]
  002a7	e8 00 00 00 00	 call	 PyLong_FromLong
$LN16@thread_PyT:

; 1078 : }

  002ac	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002b3	c3		 ret	 0
thread_PyThread_start_new_thread ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_06FJGNEBG@stderr?$AA@			; `string'
PUBLIC	??_C@_0CK@OCFOHGPE@Unhandled?5exception?5in?5thread?5st@ ; `string'
EXTRN	PyThread_exit_thread:PROC
EXTRN	PyThreadState_DeleteCurrent:PROC
EXTRN	PyErr_PrintEx:PROC
EXTRN	PyErr_Restore:PROC
EXTRN	PyObject_Print:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	PyFile_WriteObject:PROC
EXTRN	PySys_GetObject:PROC
EXTRN	PyErr_Fetch:PROC
EXTRN	PySys_WriteStderr:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_SystemExit:QWORD
EXTRN	PyEval_CallObjectWithKeywords:PROC
EXTRN	PyEval_AcquireThread:PROC
EXTRN	_PyThreadState_Init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$t_bootstrap DD imagerel t_bootstrap
	DD	imagerel t_bootstrap+480
	DD	imagerel $unwind$t_bootstrap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$t_bootstrap DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FJGNEBG@stderr?$AA@
CONST	SEGMENT
??_C@_06FJGNEBG@stderr?$AA@ DB 'stderr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OCFOHGPE@Unhandled?5exception?5in?5thread?5st@
CONST	SEGMENT
??_C@_0CK@OCFOHGPE@Unhandled?5exception?5in?5thread?5st@ DB 'Unhandled ex'
	DB	'ception in thread started by ', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT t_bootstrap
_TEXT	SEGMENT
boot$ = 32
res$ = 40
tstate$ = 48
value$21100 = 56
file$21098 = 64
tb$21101 = 72
exc$21099 = 80
tv150 = 88
boot_raw$ = 112
t_bootstrap PROC					; COMDAT

; 983  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 984  :     struct bootstate *boot = (struct bootstate *) boot_raw;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR boot_raw$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR boot$[rsp], rax

; 985  :     PyThreadState *tstate;
; 986  :     PyObject *res;
; 987  : 
; 988  :     tstate = boot->tstate;

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR boot$[rsp]
  00018	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001c	48 89 44 24 30	 mov	 QWORD PTR tstate$[rsp], rax

; 989  :     tstate->thread_id = PyThread_get_thread_ident();

  00021	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tstate$[rsp]
  0002b	89 81 90 00 00
	00		 mov	 DWORD PTR [rcx+144], eax

; 990  :     _PyThreadState_Init(tstate);

  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tstate$[rsp]
  00036	e8 00 00 00 00	 call	 _PyThreadState_Init

; 991  :     PyEval_AcquireThread(tstate);

  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tstate$[rsp]
  00040	e8 00 00 00 00	 call	 PyEval_AcquireThread

; 992  :     nb_threads++;

  00045	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nb_threads
  0004b	ff c0		 inc	 eax
  0004d	89 05 00 00 00
	00		 mov	 DWORD PTR nb_threads, eax

; 993  :     res = PyEval_CallObjectWithKeywords(
; 994  :         boot->func, boot->args, boot->keyw);

  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR boot$[rsp]
  00058	4c 8b 40 18	 mov	 r8, QWORD PTR [rax+24]
  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR boot$[rsp]
  00061	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR boot$[rsp]
  0006a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0006e	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords
  00073	48 89 44 24 28	 mov	 QWORD PTR res$[rsp], rax

; 995  :     if (res == NULL) {

  00078	48 83 7c 24 28
	00		 cmp	 QWORD PTR res$[rsp], 0
  0007e	0f 85 c0 00 00
	00		 jne	 $LN10@t_bootstra

; 996  :         if (PyErr_ExceptionMatches(PyExc_SystemExit))

  00084	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemExit
  0008b	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00090	85 c0		 test	 eax, eax
  00092	74 0a		 je	 SHORT $LN9@t_bootstra

; 997  :             PyErr_Clear();

  00094	e8 00 00 00 00	 call	 PyErr_Clear

; 998  :         else {

  00099	e9 a4 00 00 00	 jmp	 $LN8@t_bootstra
$LN9@t_bootstra:

; 999  :             PyObject *file;
; 1000 :             PyObject *exc, *value, *tb;
; 1001 :             PySys_WriteStderr(
; 1002 :                 "Unhandled exception in thread started by ");

  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@OCFOHGPE@Unhandled?5exception?5in?5thread?5st@
  000a5	e8 00 00 00 00	 call	 PySys_WriteStderr

; 1003 :             PyErr_Fetch(&exc, &value, &tb);

  000aa	4c 8d 44 24 48	 lea	 r8, QWORD PTR tb$21101[rsp]
  000af	48 8d 54 24 38	 lea	 rdx, QWORD PTR value$21100[rsp]
  000b4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR exc$21099[rsp]
  000b9	e8 00 00 00 00	 call	 PyErr_Fetch

; 1004 :             file = PySys_GetObject("stderr");

  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06FJGNEBG@stderr?$AA@
  000c5	e8 00 00 00 00	 call	 PySys_GetObject
  000ca	48 89 44 24 40	 mov	 QWORD PTR file$21098[rsp], rax

; 1005 :             if (file != NULL && file != Py_None)

  000cf	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$21098[rsp], 0
  000d5	74 26		 je	 SHORT $LN7@t_bootstra
  000d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000de	48 39 44 24 40	 cmp	 QWORD PTR file$21098[rsp], rax
  000e3	74 18		 je	 SHORT $LN7@t_bootstra

; 1006 :                 PyFile_WriteObject(boot->func, file, 0);

  000e5	45 33 c0	 xor	 r8d, r8d
  000e8	48 8b 54 24 40	 mov	 rdx, QWORD PTR file$21098[rsp]
  000ed	48 8b 44 24 20	 mov	 rax, QWORD PTR boot$[rsp]
  000f2	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000f6	e8 00 00 00 00	 call	 PyFile_WriteObject

; 1007 :             else

  000fb	eb 1e		 jmp	 SHORT $LN6@t_bootstra
$LN7@t_bootstra:

; 1008 :                 PyObject_Print(boot->func, stderr, 0);

  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00103	48 83 c0 60	 add	 rax, 96			; 00000060H
  00107	45 33 c0	 xor	 r8d, r8d
  0010a	48 8b d0	 mov	 rdx, rax
  0010d	48 8b 44 24 20	 mov	 rax, QWORD PTR boot$[rsp]
  00112	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00116	e8 00 00 00 00	 call	 PyObject_Print
$LN6@t_bootstra:

; 1009 :             PySys_WriteStderr("\n");

  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00122	e8 00 00 00 00	 call	 PySys_WriteStderr

; 1010 :             PyErr_Restore(exc, value, tb);

  00127	4c 8b 44 24 48	 mov	 r8, QWORD PTR tb$21101[rsp]
  0012c	48 8b 54 24 38	 mov	 rdx, QWORD PTR value$21100[rsp]
  00131	48 8b 4c 24 50	 mov	 rcx, QWORD PTR exc$21099[rsp]
  00136	e8 00 00 00 00	 call	 PyErr_Restore

; 1011 :             PyErr_PrintEx(0);

  0013b	33 c9		 xor	 ecx, ecx
  0013d	e8 00 00 00 00	 call	 PyErr_PrintEx
$LN8@t_bootstra:

; 1012 :         }
; 1013 :     }
; 1014 :     else

  00142	eb 0a		 jmp	 SHORT $LN5@t_bootstra
$LN10@t_bootstra:

; 1015 :         Py_DECREF(res);

  00144	48 8b 4c 24 28	 mov	 rcx, QWORD PTR res$[rsp]
  00149	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@t_bootstra:

; 1016 :     Py_DECREF(boot->func);

  0014e	48 8b 44 24 20	 mov	 rax, QWORD PTR boot$[rsp]
  00153	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00157	e8 00 00 00 00	 call	 _Py_DecRef

; 1017 :     Py_DECREF(boot->args);

  0015c	48 8b 44 24 20	 mov	 rax, QWORD PTR boot$[rsp]
  00161	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00165	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@t_bootstra:

; 1018 :     Py_XDECREF(boot->keyw);

  0016a	48 8b 44 24 20	 mov	 rax, QWORD PTR boot$[rsp]
  0016f	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00174	74 0e		 je	 SHORT $LN1@t_bootstra
  00176	48 8b 44 24 20	 mov	 rax, QWORD PTR boot$[rsp]
  0017b	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0017f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@t_bootstra:
  00184	33 c0		 xor	 eax, eax
  00186	85 c0		 test	 eax, eax
  00188	75 e0		 jne	 SHORT $LN4@t_bootstra

; 1019 :     PyMem_DEL(boot_raw);

  0018a	e8 00 00 00 00	 call	 _Py_PXCTX
  0018f	85 c0		 test	 eax, eax
  00191	74 14		 je	 SHORT $LN13@t_bootstra
  00193	48 8b 4c 24 70	 mov	 rcx, QWORD PTR boot_raw$[rsp]
  00198	e8 00 00 00 00	 call	 _PxMem_Free
  0019d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
  001a5	eb 12		 jmp	 SHORT $LN14@t_bootstra
$LN13@t_bootstra:
  001a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR boot_raw$[rsp]
  001ac	e8 00 00 00 00	 call	 _PyMem_DebugFree
  001b1	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
$LN14@t_bootstra:

; 1020 :     nb_threads--;

  001b9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nb_threads
  001bf	ff c8		 dec	 eax
  001c1	89 05 00 00 00
	00		 mov	 DWORD PTR nb_threads, eax

; 1021 :     PyThreadState_Clear(tstate);

  001c7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tstate$[rsp]
  001cc	e8 00 00 00 00	 call	 PyThreadState_Clear

; 1022 :     PyThreadState_DeleteCurrent();

  001d1	e8 00 00 00 00	 call	 PyThreadState_DeleteCurrent

; 1023 :     PyThread_exit_thread();

  001d6	e8 00 00 00 00	 call	 PyThread_exit_thread

; 1024 : }

  001db	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001df	c3		 ret	 0
t_bootstrap ENDP
_TEXT	ENDS
EXTRN	PyErr_SetNone:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$thread_PyThread_exit_thread DD imagerel thread_PyThread_exit_thread
	DD	imagerel thread_PyThread_exit_thread+28
	DD	imagerel $unwind$thread_PyThread_exit_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$thread_PyThread_exit_thread DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT thread_PyThread_exit_thread
_TEXT	SEGMENT
self$ = 48
thread_PyThread_exit_thread PROC			; COMDAT

; 1093 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1094 :     PyErr_SetNone(PyExc_SystemExit);

  00009	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemExit
  00010	e8 00 00 00 00	 call	 PyErr_SetNone

; 1095 :     return NULL;

  00015	33 c0		 xor	 eax, eax

; 1096 : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
thread_PyThread_exit_thread ENDP
_TEXT	ENDS
EXTRN	PyErr_SetInterrupt:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$thread_PyThread_interrupt_main DD imagerel thread_PyThread_interrupt_main
	DD	imagerel thread_PyThread_interrupt_main+38
	DD	imagerel $unwind$thread_PyThread_interrupt_main
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$thread_PyThread_interrupt_main DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT thread_PyThread_interrupt_main
_TEXT	SEGMENT
self$ = 48
thread_PyThread_interrupt_main PROC			; COMDAT

; 1107 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1108 :     PyErr_SetInterrupt();

  00009	e8 00 00 00 00	 call	 PyErr_SetInterrupt

; 1109 :     Py_INCREF(Py_None);

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00015	e8 00 00 00 00	 call	 _Py_IncRef

; 1110 :     return Py_None;

  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1111 : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
thread_PyThread_interrupt_main ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$thread_PyThread_allocate_lock DD imagerel thread_PyThread_allocate_lock
	DD	imagerel thread_PyThread_allocate_lock+19
	DD	imagerel $unwind$thread_PyThread_allocate_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$thread_PyThread_allocate_lock DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT thread_PyThread_allocate_lock
_TEXT	SEGMENT
self$ = 48
thread_PyThread_allocate_lock PROC			; COMDAT

; 1124 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1125 :     return (PyObject *) newlockobject();

  00009	e8 00 00 00 00	 call	 newlockobject

; 1126 : }

  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
thread_PyThread_allocate_lock ENDP
_TEXT	ENDS
EXTRN	_PyObject_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$newlockobject DD imagerel newlockobject
	DD	imagerel newlockobject+162
	DD	imagerel $unwind$newlockobject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newlockobject DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT newlockobject
_TEXT	SEGMENT
self$ = 32
tv70 = 40
newlockobject PROC					; COMDAT

; 540  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 541  :     lockobject *self;
; 542  :     self = PyObject_New(lockobject, &Locktype);

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 13		 je	 SHORT $LN5@newlockobj
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Locktype
  00014	e8 00 00 00 00	 call	 _PxObject_New
  00019	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  0001e	eb 11		 jmp	 SHORT $LN6@newlockobj
$LN5@newlockobj:
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Locktype
  00027	e8 00 00 00 00	 call	 _PyObject_New
  0002c	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN6@newlockobj:
  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  00036	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 543  :     if (self == NULL)

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00041	75 04		 jne	 SHORT $LN2@newlockobj

; 544  :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	eb 56		 jmp	 SHORT $LN3@newlockobj
$LN2@newlockobj:

; 545  :     self->lock_lock = PyThread_allocate_lock();

  00047	e8 00 00 00 00	 call	 PyThread_allocate_lock
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00051	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 546  :     self->locked = 0;

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0005a	c6 40 70 00	 mov	 BYTE PTR [rax+112], 0

; 547  :     self->in_weakreflist = NULL;

  0005e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00063	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 548  :     if (self->lock_lock == NULL) {

  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00070	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00075	75 21		 jne	 SHORT $LN1@newlockobj

; 549  :         Py_DECREF(self);

  00077	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  0007c	e8 00 00 00 00	 call	 _Py_DecRef

; 550  :         PyErr_SetString(ThreadError, "can't allocate lock");

  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@KAKMLBKC@can?8t?5allocate?5lock?$AA@
  00088	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ThreadError
  0008f	e8 00 00 00 00	 call	 PyErr_SetString

; 551  :         return NULL;

  00094	33 c0		 xor	 eax, eax
  00096	eb 05		 jmp	 SHORT $LN3@newlockobj
$LN1@newlockobj:

; 552  :     }
; 553  :     return self;

  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
$LN3@newlockobj:

; 554  : }

  0009d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a1	c3		 ret	 0
newlockobject ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@KPPNMFGL@no?5current?5thread?5ident?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$thread_get_ident DD imagerel thread_get_ident
	DD	imagerel thread_get_ident+62
	DD	imagerel $unwind$thread_get_ident
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$thread_get_ident DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BI@KPPNMFGL@no?5current?5thread?5ident?$AA@
CONST	SEGMENT
??_C@_0BI@KPPNMFGL@no?5current?5thread?5ident?$AA@ DB 'no current thread '
	DB	'ident', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT thread_get_ident
_TEXT	SEGMENT
ident$ = 32
self$ = 64
thread_get_ident PROC					; COMDAT

; 1136 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1137 :     long ident;
; 1138 :     ident = PyThread_get_thread_ident();

  00009	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0000e	89 44 24 20	 mov	 DWORD PTR ident$[rsp], eax

; 1139 :     if (ident == -1) {

  00012	83 7c 24 20 ff	 cmp	 DWORD PTR ident$[rsp], -1
  00017	75 17		 jne	 SHORT $LN1@thread_get

; 1140 :         PyErr_SetString(ThreadError, "no current thread ident");

  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@KPPNMFGL@no?5current?5thread?5ident?$AA@
  00020	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ThreadError
  00027	e8 00 00 00 00	 call	 PyErr_SetString

; 1141 :         return NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 09		 jmp	 SHORT $LN2@thread_get
$LN1@thread_get:

; 1142 :     }
; 1143 :     return PyLong_FromLong(ident);

  00030	8b 4c 24 20	 mov	 ecx, DWORD PTR ident$[rsp]
  00034	e8 00 00 00 00	 call	 PyLong_FromLong
$LN2@thread_get:

; 1144 : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
thread_get_ident ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$thread__count DD imagerel thread__count
	DD	imagerel thread__count+25
	DD	imagerel $unwind$thread__count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$thread__count DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT thread__count
_TEXT	SEGMENT
self$ = 48
thread__count PROC					; COMDAT

; 1159 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1160 :     return PyLong_FromLong(nb_threads);

  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nb_threads
  0000f	e8 00 00 00 00	 call	 PyLong_FromLong

; 1161 : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
thread__count ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@GBKBPAJK@setting?5stack?5size?5not?5supported@ ; `string'
PUBLIC	??_C@_0BK@NJKGHHMM@size?5not?5valid?3?5?$CFzd?5bytes?$AA@ ; `string'
PUBLIC	??_C@_0CD@HBAEJLFK@size?5must?5be?50?5or?5a?5positive?5val@ ; `string'
PUBLIC	??_C@_0O@KEBCHNLL@?$HMn?3stack_size?$AA@	; `string'
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	PyThread_set_stacksize:PROC
EXTRN	PyThread_get_stacksize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$thread_stack_size DD imagerel thread_stack_size
	DD	imagerel thread_stack_size+191
	DD	imagerel $unwind$thread_stack_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$thread_stack_size DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0CB@GBKBPAJK@setting?5stack?5size?5not?5supported@
CONST	SEGMENT
??_C@_0CB@GBKBPAJK@setting?5stack?5size?5not?5supported@ DB 'setting stac'
	DB	'k size not supported', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NJKGHHMM@size?5not?5valid?3?5?$CFzd?5bytes?$AA@
CONST	SEGMENT
??_C@_0BK@NJKGHHMM@size?5not?5valid?3?5?$CFzd?5bytes?$AA@ DB 'size not va'
	DB	'lid: %zd bytes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HBAEJLFK@size?5must?5be?50?5or?5a?5positive?5val@
CONST	SEGMENT
??_C@_0CD@HBAEJLFK@size?5must?5be?50?5or?5a?5positive?5val@ DB 'size must'
	DB	' be 0 or a positive value', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KEBCHNLL@?$HMn?3stack_size?$AA@
CONST	SEGMENT
??_C@_0O@KEBCHNLL@?$HMn?3stack_size?$AA@ DB '|n:stack_size', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT thread_stack_size
_TEXT	SEGMENT
rc$ = 32
new_size$ = 40
old_size$ = 48
self$ = 80
args$ = 88
thread_stack_size PROC					; COMDAT

; 1177 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1178 :     size_t old_size;
; 1179 :     Py_ssize_t new_size = 0;

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR new_size$[rsp], 0

; 1180 :     int rc;
; 1181 : 
; 1182 :     if (!PyArg_ParseTuple(args, "|n:stack_size", &new_size))

  00017	4c 8d 44 24 28	 lea	 r8, QWORD PTR new_size$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@KEBCHNLL@?$HMn?3stack_size?$AA@
  00023	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN4@thread_sta

; 1183 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 82 00 00 00	 jmp	 $LN5@thread_sta
$LN4@thread_sta:

; 1184 : 
; 1185 :     if (new_size < 0) {

  00038	48 83 7c 24 28
	00		 cmp	 QWORD PTR new_size$[rsp], 0
  0003e	7d 17		 jge	 SHORT $LN3@thread_sta

; 1186 :         PyErr_SetString(PyExc_ValueError,
; 1187 :                         "size must be 0 or a positive value");

  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HBAEJLFK@size?5must?5be?50?5or?5a?5positive?5val@
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0004e	e8 00 00 00 00	 call	 PyErr_SetString

; 1188 :         return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	eb 63		 jmp	 SHORT $LN5@thread_sta
$LN3@thread_sta:

; 1189 :     }
; 1190 : 
; 1191 :     old_size = PyThread_get_stacksize();

  00057	e8 00 00 00 00	 call	 PyThread_get_stacksize
  0005c	48 89 44 24 30	 mov	 QWORD PTR old_size$[rsp], rax

; 1192 : 
; 1193 :     rc = PyThread_set_stacksize((size_t) new_size);

  00061	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_size$[rsp]
  00066	e8 00 00 00 00	 call	 PyThread_set_stacksize
  0006b	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1194 :     if (rc == -1) {

  0006f	83 7c 24 20 ff	 cmp	 DWORD PTR rc$[rsp], -1
  00074	75 1c		 jne	 SHORT $LN2@thread_sta

; 1195 :         PyErr_Format(PyExc_ValueError,
; 1196 :                      "size not valid: %zd bytes",
; 1197 :                      new_size);

  00076	4c 8b 44 24 28	 mov	 r8, QWORD PTR new_size$[rsp]
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@NJKGHHMM@size?5not?5valid?3?5?$CFzd?5bytes?$AA@
  00082	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00089	e8 00 00 00 00	 call	 PyErr_Format

; 1198 :         return NULL;

  0008e	33 c0		 xor	 eax, eax
  00090	eb 28		 jmp	 SHORT $LN5@thread_sta
$LN2@thread_sta:

; 1199 :     }
; 1200 :     if (rc == -2) {

  00092	83 7c 24 20 fe	 cmp	 DWORD PTR rc$[rsp], -2
  00097	75 17		 jne	 SHORT $LN1@thread_sta

; 1201 :         PyErr_SetString(ThreadError,
; 1202 :                         "setting stack size not supported");

  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@GBKBPAJK@setting?5stack?5size?5not?5supported@
  000a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ThreadError
  000a7	e8 00 00 00 00	 call	 PyErr_SetString

; 1203 :         return NULL;

  000ac	33 c0		 xor	 eax, eax
  000ae	eb 0a		 jmp	 SHORT $LN5@thread_sta
$LN1@thread_sta:

; 1204 :     }
; 1205 : 
; 1206 :     return PyLong_FromSsize_t((Py_ssize_t) old_size);

  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR old_size$[rsp]
  000b5	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN5@thread_sta:

; 1207 : }

  000ba	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000be	c3		 ret	 0
thread_stack_size ENDP
_TEXT	ENDS
PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_06HKJEELDD@_local?$AA@			; `string'
PUBLIC	??_C@_05DNKFGCKI@RLock?$AA@			; `string'
PUBLIC	??_C@_08GHCJHBBL@LockType?$AA@			; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_0M@CPFLABDA@TIMEOUT_MAX?$AA@		; `string'
PUBLIC	PyInit__thread
EXTRN	PyThread_init_thread:PROC
EXTRN	PyUnicode_InternFromString:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_AddObject:PROC
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__thread DD imagerel $LN13
	DD	imagerel $LN13+466
	DD	imagerel $unwind$PyInit__thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__thread DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HKJEELDD@_local?$AA@
CONST	SEGMENT
??_C@_06HKJEELDD@_local?$AA@ DB '_local', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNKFGCKI@RLock?$AA@
CONST	SEGMENT
??_C@_05DNKFGCKI@RLock?$AA@ DB 'RLock', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHCJHBBL@LockType?$AA@
CONST	SEGMENT
??_C@_08GHCJHBBL@LockType?$AA@ DB 'LockType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CPFLABDA@TIMEOUT_MAX?$AA@
CONST	SEGMENT
??_C@_0M@CPFLABDA@TIMEOUT_MAX?$AA@ DB 'TIMEOUT_MAX', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit__thread
_TEXT	SEGMENT
timeout_max$ = 32
d$ = 40
m$ = 48
PyInit__thread PROC					; COMDAT

; 1287 : {

$LN13:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1288 :     PyObject *m, *d, *timeout_max;
; 1289 : 
; 1290 :     /* Initialize types: */
; 1291 :     if (PyType_Ready(&localdummytype) < 0)

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:localdummytype
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	7d 07		 jge	 SHORT $LN10@PyInit__th

; 1292 :         return NULL;

  00014	33 c0		 xor	 eax, eax
  00016	e9 b2 01 00 00	 jmp	 $LN11@PyInit__th
$LN10@PyInit__th:

; 1293 :     if (PyType_Ready(&localtype) < 0)

  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:localtype
  00022	e8 00 00 00 00	 call	 PyType_Ready
  00027	85 c0		 test	 eax, eax
  00029	7d 07		 jge	 SHORT $LN9@PyInit__th

; 1294 :         return NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 9b 01 00 00	 jmp	 $LN11@PyInit__th
$LN9@PyInit__th:

; 1295 :     if (PyType_Ready(&Locktype) < 0)

  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Locktype
  00039	e8 00 00 00 00	 call	 PyType_Ready
  0003e	85 c0		 test	 eax, eax
  00040	7d 07		 jge	 SHORT $LN8@PyInit__th

; 1296 :         return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	e9 84 01 00 00	 jmp	 $LN11@PyInit__th
$LN8@PyInit__th:

; 1297 :     if (PyType_Ready(&RLocktype) < 0)

  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RLocktype
  00050	e8 00 00 00 00	 call	 PyType_Ready
  00055	85 c0		 test	 eax, eax
  00057	7d 07		 jge	 SHORT $LN7@PyInit__th

; 1298 :         return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 6d 01 00 00	 jmp	 $LN11@PyInit__th
$LN7@PyInit__th:

; 1299 : 
; 1300 :     /* Create the module and add the functions */
; 1301 :     m = PyModule_Create(&threadmodule);

  00060	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadmodule
  0006c	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00071	48 89 44 24 30	 mov	 QWORD PTR m$[rsp], rax

; 1302 :     if (m == NULL)

  00076	48 83 7c 24 30
	00		 cmp	 QWORD PTR m$[rsp], 0
  0007c	75 07		 jne	 SHORT $LN6@PyInit__th

; 1303 :         return NULL;

  0007e	33 c0		 xor	 eax, eax
  00080	e9 48 01 00 00	 jmp	 $LN11@PyInit__th
$LN6@PyInit__th:

; 1304 : 
; 1305 :     timeout_max = PyFloat_FromDouble(PY_TIMEOUT_MAX / 1000000);

  00085	b8 37 89 41 00	 mov	 eax, 4294967		; 00418937H
  0008a	66 0f ef c0	 pxor	 xmm0, xmm0
  0008e	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00093	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00098	48 89 44 24 20	 mov	 QWORD PTR timeout_max$[rsp], rax

; 1306 :     if (!timeout_max)

  0009d	48 83 7c 24 20
	00		 cmp	 QWORD PTR timeout_max$[rsp], 0
  000a3	75 07		 jne	 SHORT $LN5@PyInit__th

; 1307 :         return NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	e9 21 01 00 00	 jmp	 $LN11@PyInit__th
$LN5@PyInit__th:

; 1308 :     if (PyModule_AddObject(m, "TIMEOUT_MAX", timeout_max) < 0)

  000ac	4c 8b 44 24 20	 mov	 r8, QWORD PTR timeout_max$[rsp]
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@CPFLABDA@TIMEOUT_MAX?$AA@
  000b8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR m$[rsp]
  000bd	e8 00 00 00 00	 call	 PyModule_AddObject
  000c2	85 c0		 test	 eax, eax
  000c4	7d 07		 jge	 SHORT $LN4@PyInit__th

; 1309 :         return NULL;

  000c6	33 c0		 xor	 eax, eax
  000c8	e9 00 01 00 00	 jmp	 $LN11@PyInit__th
$LN4@PyInit__th:

; 1310 : 
; 1311 :     /* Add a symbolic constant */
; 1312 :     d = PyModule_GetDict(m);

  000cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR m$[rsp]
  000d2	e8 00 00 00 00	 call	 PyModule_GetDict
  000d7	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax

; 1313 :     ThreadError = PyExc_RuntimeError;

  000dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyExc_RuntimeError
  000e3	48 89 05 00 00
	00 00		 mov	 QWORD PTR ThreadError, rax

; 1314 :     Py_INCREF(ThreadError);

  000ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ThreadError
  000f1	e8 00 00 00 00	 call	 _Py_IncRef

; 1315 : 
; 1316 :     PyDict_SetItemString(d, "error", ThreadError);

  000f6	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ThreadError
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  00104	48 8b 4c 24 28	 mov	 rcx, QWORD PTR d$[rsp]
  00109	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1317 :     Locktype.tp_doc = lock_doc;

  0010e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lock_doc
  00115	48 89 05 08 01
	00 00		 mov	 QWORD PTR Locktype+264, rax

; 1318 :     Py_INCREF(&Locktype);

  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Locktype
  00123	e8 00 00 00 00	 call	 _Py_IncRef

; 1319 :     PyDict_SetItemString(d, "LockType", (PyObject *)&Locktype);

  00128	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Locktype
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08GHCJHBBL@LockType?$AA@
  00136	48 8b 4c 24 28	 mov	 rcx, QWORD PTR d$[rsp]
  0013b	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1320 : 
; 1321 :     Py_INCREF(&RLocktype);

  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:RLocktype
  00147	e8 00 00 00 00	 call	 _Py_IncRef

; 1322 :     if (PyModule_AddObject(m, "RLock", (PyObject *)&RLocktype) < 0)

  0014c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:RLocktype
  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05DNKFGCKI@RLock?$AA@
  0015a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR m$[rsp]
  0015f	e8 00 00 00 00	 call	 PyModule_AddObject
  00164	85 c0		 test	 eax, eax
  00166	7d 04		 jge	 SHORT $LN3@PyInit__th

; 1323 :         return NULL;

  00168	33 c0		 xor	 eax, eax
  0016a	eb 61		 jmp	 SHORT $LN11@PyInit__th
$LN3@PyInit__th:

; 1324 : 
; 1325 :     Py_INCREF(&localtype);

  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:localtype
  00173	e8 00 00 00 00	 call	 _Py_IncRef

; 1326 :     if (PyModule_AddObject(m, "_local", (PyObject *)&localtype) < 0)

  00178	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:localtype
  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06HKJEELDD@_local?$AA@
  00186	48 8b 4c 24 30	 mov	 rcx, QWORD PTR m$[rsp]
  0018b	e8 00 00 00 00	 call	 PyModule_AddObject
  00190	85 c0		 test	 eax, eax
  00192	7d 04		 jge	 SHORT $LN2@PyInit__th

; 1327 :         return NULL;

  00194	33 c0		 xor	 eax, eax
  00196	eb 35		 jmp	 SHORT $LN11@PyInit__th
$LN2@PyInit__th:

; 1328 : 
; 1329 :     nb_threads = 0;

  00198	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR nb_threads, 0

; 1330 : 
; 1331 :     str_dict = PyUnicode_InternFromString("__dict__");

  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08IBFKALI@__dict__?$AA@
  001a9	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  001ae	48 89 05 00 00
	00 00		 mov	 QWORD PTR str_dict, rax

; 1332 :     if (str_dict == NULL)

  001b5	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR str_dict, 0
  001bd	75 04		 jne	 SHORT $LN1@PyInit__th

; 1333 :         return NULL;

  001bf	33 c0		 xor	 eax, eax
  001c1	eb 0a		 jmp	 SHORT $LN11@PyInit__th
$LN1@PyInit__th:

; 1334 : 
; 1335 :     /* Initialize the C thread library */
; 1336 :     PyThread_init_thread();

  001c3	e8 00 00 00 00	 call	 PyThread_init_thread

; 1337 :     return m;

  001c8	48 8b 44 24 30	 mov	 rax, QWORD PTR m$[rsp]
$LN11@PyInit__th:

; 1338 : }

  001cd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001d1	c3		 ret	 0
PyInit__thread ENDP
_TEXT	ENDS
END
