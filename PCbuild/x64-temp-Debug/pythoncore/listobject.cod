; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@EBOOGILH@list_reverseiterator?$AA@	; `string'
PUBLIC	??_C@_0O@NAJHOHI@list_iterator?$AA@		; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
PUBLIC	??_C@_04DONFEANM@list?$AA@			; `string'
PUBLIC	??_C@_04PIMMHFGE@sort?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_06LEMKAMD@remove?$AA@			; `string'
PUBLIC	??_C@_03NJDAHFJE@pop?$AA@			; `string'
PUBLIC	??_C@_06BPBOMFNI@extend?$AA@			; `string'
PUBLIC	??_C@_06OAOPNKHP@insert?$AA@			; `string'
PUBLIC	??_C@_06PCICMFGG@append?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_05MEHLAELG@clear?$AA@			; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0N@FDLIKANA@__reversed__?$AA@		; `string'
PUBLIC	??_C@_0M@GAJGCIJD@__getitem__?$AA@		; `string'
PUBLIC	??_C@_08IBBDGPOF@sequence?$AA@			; `string'
PUBLIC	??_C@_07KOIEOCCE@reverse?$AA@			; `string'
PUBLIC	??_C@_03ICHNJLJF@key?$AA@			; `string'
PUBLIC	PyList_Type
PUBLIC	PyListIter_Type
PUBLIC	PyListRevIter_Type
EXTRN	PyObject_SelfIter:PROC
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyType_GenericNew:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyObject_HashNotImplemented:PROC
EXTRN	PyType_Type:BYTE
_BSS	SEGMENT
numfree	DD	01H DUP (?)
	ALIGN	8

indexerr DQ	01H DUP (?)
?sep@?1??list_repr@@9@9 DQ 01H DUP (?)			; `list_repr'::`2'::sep
_BSS	ENDS
;	COMDAT ??_C@_0BF@EBOOGILH@list_reverseiterator?$AA@
CONST	SEGMENT
??_C@_0BF@EBOOGILH@list_reverseiterator?$AA@ DB 'list_reverseiterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NAJHOHI@list_iterator?$AA@
CONST	SEGMENT
??_C@_0O@NAJHOHI@list_iterator?$AA@ DB 'list_iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DONFEANM@list?$AA@
CONST	SEGMENT
??_C@_04DONFEANM@list?$AA@ DB 'list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PIMMHFGE@sort?$AA@
CONST	SEGMENT
??_C@_04PIMMHFGE@sort?$AA@ DB 'sort', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEMKAMD@remove?$AA@
CONST	SEGMENT
??_C@_06LEMKAMD@remove?$AA@ DB 'remove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJDAHFJE@pop?$AA@
CONST	SEGMENT
??_C@_03NJDAHFJE@pop?$AA@ DB 'pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPBOMFNI@extend?$AA@
CONST	SEGMENT
??_C@_06BPBOMFNI@extend?$AA@ DB 'extend', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAOPNKHP@insert?$AA@
CONST	SEGMENT
??_C@_06OAOPNKHP@insert?$AA@ DB 'insert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCICMFGG@append?$AA@
CONST	SEGMENT
??_C@_06PCICMFGG@append?$AA@ DB 'append', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEHLAELG@clear?$AA@
CONST	SEGMENT
??_C@_05MEHLAELG@clear?$AA@ DB 'clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDLIKANA@__reversed__?$AA@
CONST	SEGMENT
??_C@_0N@FDLIKANA@__reversed__?$AA@ DB '__reversed__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GAJGCIJD@__getitem__?$AA@
CONST	SEGMENT
??_C@_0M@GAJGCIJD@__getitem__?$AA@ DB '__getitem__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBBDGPOF@sequence?$AA@
CONST	SEGMENT
??_C@_08IBBDGPOF@sequence?$AA@ DB 'sequence', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?kwlist@?1??listsort@@9@9 DQ FLAT:??_C@_03ICHNJLJF@key?$AA@ ; `listsort'::`2'::kwlist
	DQ	FLAT:??_C@_07KOIEOCCE@reverse?$AA@
	DQ	0000000000000000H
?kwlist@?1??list_init@@9@9 DQ FLAT:??_C@_08IBBDGPOF@sequence?$AA@ ; `list_init'::`2'::kwlist
	DQ	0000000000000000H
getitem_doc DB	'x.__getitem__(y) <==> x[y]', 00H
	ORG $+5
reversed_doc DB	'L.__reversed__() -- return a reverse iterator over the l'
	DB	'ist', 00H
	ORG $+4
sizeof_doc DB	'L.__sizeof__() -- size of L in memory, in bytes', 00H
clear_doc DB	'L.clear() -> None -- remove all items from L', 00H
	ORG $+3
copy_doc DB	'L.copy() -> list -- a shallow copy of L', 00H
append_doc DB	'L.append(object) -> None -- append object to end', 00H
	ORG $+15
extend_doc DB	'L.extend(iterable) -> None -- extend list by appending e'
	DB	'lements from the iterable', 00H
	ORG $+6
insert_doc DB	'L.insert(index, object) -- insert object before index', 00H
	ORG $+2
pop_doc	DB	'L.pop([index]) -> item -- remove and return item at inde'
	DB	'x (default last).', 0aH, 'Raises IndexError if list is empty '
	DB	'or index is out of range.', 00H
	ORG $+9
remove_doc DB	'L.remove(value) -> None -- remove first occurrence of va'
	DB	'lue.', 0aH, 'Raises ValueError if the value is not present.', 00H
	ORG $+4
index_doc DB	'L.index(value, [start, [stop]]) -> integer -- return fir'
	DB	'st index of value.', 0aH, 'Raises ValueError if the value is '
	DB	'not present.', 00H
	ORG $+6
count_doc DB	'L.count(value) -> integer -- return number of occurrence'
	DB	's of value', 00H
	ORG $+5
reverse_doc DB	'L.reverse() -- reverse *IN PLACE*', 00H
	ORG $+6
sort_doc DB	'L.sort(key=None, reverse=False) -> None -- stable sort *'
	DB	'IN PLACE*', 00H
	ORG $+14
list_methods DQ	FLAT:??_C@_0M@GAJGCIJD@__getitem__?$AA@
	DQ	FLAT:list_subscript
	DD	048H
	ORG $+4
	DQ	FLAT:getitem_doc
	DQ	FLAT:??_C@_0N@FDLIKANA@__reversed__?$AA@
	DQ	FLAT:list_reversed
	DD	04H
	ORG $+4
	DQ	FLAT:reversed_doc
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:list_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof_doc
	DQ	FLAT:??_C@_05MEHLAELG@clear?$AA@
	DQ	FLAT:listclear
	DD	04H
	ORG $+4
	DQ	FLAT:clear_doc
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:listcopy
	DD	04H
	ORG $+4
	DQ	FLAT:copy_doc
	DQ	FLAT:??_C@_06PCICMFGG@append?$AA@
	DQ	FLAT:listappend
	DD	08H
	ORG $+4
	DQ	FLAT:append_doc
	DQ	FLAT:??_C@_06OAOPNKHP@insert?$AA@
	DQ	FLAT:listinsert
	DD	01H
	ORG $+4
	DQ	FLAT:insert_doc
	DQ	FLAT:??_C@_06BPBOMFNI@extend?$AA@
	DQ	FLAT:listextend
	DD	08H
	ORG $+4
	DQ	FLAT:extend_doc
	DQ	FLAT:??_C@_03NJDAHFJE@pop?$AA@
	DQ	FLAT:listpop
	DD	01H
	ORG $+4
	DQ	FLAT:pop_doc
	DQ	FLAT:??_C@_06LEMKAMD@remove?$AA@
	DQ	FLAT:listremove
	DD	08H
	ORG $+4
	DQ	FLAT:remove_doc
	DQ	FLAT:??_C@_05FKHKFDID@index?$AA@
	DQ	FLAT:listindex
	DD	01H
	ORG $+4
	DQ	FLAT:index_doc
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	FLAT:listcount
	DD	08H
	ORG $+4
	DQ	FLAT:count_doc
	DQ	FLAT:??_C@_07KOIEOCCE@reverse?$AA@
	DQ	FLAT:listreverse
	DD	04H
	ORG $+4
	DQ	FLAT:reverse_doc
	DQ	FLAT:??_C@_04PIMMHFGE@sort?$AA@
	DQ	FLAT:listsort
	DD	03H
	ORG $+4
	DQ	FLAT:sort_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
list_as_sequence DQ FLAT:list_length
	DQ	FLAT:list_concat
	DQ	FLAT:list_repeat
	DQ	FLAT:list_item
	DQ	0000000000000000H
	DQ	FLAT:list_ass_item
	DQ	0000000000000000H
	DQ	FLAT:list_contains
	DQ	FLAT:list_inplace_concat
	DQ	FLAT:list_inplace_repeat
list_doc DB	'list() -> new empty list', 0aH, 'list(iterable) -> new l'
	DB	'ist initialized from iterable''s items', 00H
	ORG $+2
list_as_mapping DQ FLAT:list_length
	DQ	FLAT:list_subscript
	DQ	FLAT:list_ass_subscript
PyList_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04DONFEANM@list?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:list_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:list_repr
	DQ	0000000000000000H
	DQ	FLAT:list_as_sequence
	DQ	FLAT:list_as_mapping
	DQ	FLAT:PyObject_HashNotImplemented
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	02044400H
	ORG $+4
	DQ	FLAT:list_doc
	DQ	FLAT:list_traverse
	DQ	FLAT:list_clear
	DQ	FLAT:list_richcompare
	DQ	0000000000000000H
	DQ	FLAT:list_iter
	DQ	0000000000000000H
	DQ	FLAT:list_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:list_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:PyType_GenericNew
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
length_hint_doc DB 'Private method returning an estimate of len(list(it))'
	DB	'.', 00H
	ORG $+1
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+1
setstate_doc DB	'Set state information for unpickling.', 00H
	ORG $+10
listiter_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:listiter_len
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:listiter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:listiter_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyListIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@NAJHOHI@list_iterator?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:listiter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:listiter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:listiter_next
	DQ	FLAT:listiter_methods
	DQ	0000000000000000H
	ORG $+144
listreviter_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:listreviter_len
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:listreviter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:listreviter_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyListRevIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BF@EBOOGILH@list_reverseiterator?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:listreviter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:listreviter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:listreviter_next
	DQ	FLAT:listreviter_methods
	DQ	0000000000000000H
	ORG $+144
_DATA	ENDS
;	COMDAT ??_C@_07KOIEOCCE@reverse?$AA@
CONST	SEGMENT
??_C@_07KOIEOCCE@reverse?$AA@ DB 'reverse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICHNJLJF@key?$AA@
CONST	SEGMENT
??_C@_03ICHNJLJF@key?$AA@ DB 'key', 00H			; `string'
CONST	ENDS
PUBLIC	??_C@_1CM@CNNMDFEO@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	PyList_ClearFreeList
EXTRN	__imp__wassert:PROC
EXTRN	_Py_PXCTX:PROC
_BSS	SEGMENT
free_list DQ	050H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\listobject.c
pdata	SEGMENT
$pdata$PyList_ClearFreeList DD imagerel $LN7
	DD	imagerel $LN7+140
	DD	imagerel $unwind$PyList_ClearFreeList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_ClearFreeList DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_1CM@CNNMDFEO@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@CNNMDFEO@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'E', 00H, 'x'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, '(', 00H, 'o', 00H, 'p', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, 'o', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, '.', 00H, 'c', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyList_ClearFreeList
_TEXT	SEGMENT
ret$ = 32
op$ = 40
PyList_ClearFreeList PROC				; COMDAT

; 110  : {

$LN7:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 111  :     PyListObject *op;
; 112  :     int ret = numfree;

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  0000a	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 113  :     if (Py_PXCTX)

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 04		 je	 SHORT $LN3@PyList_Cle

; 114  :         return 0;

  00017	33 c0		 xor	 eax, eax
  00019	eb 6c		 jmp	 SHORT $LN4@PyList_Cle
$LN3@PyList_Cle:
$LN2@PyList_Cle:

; 115  :     while (numfree) {

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR numfree, 0
  00022	74 5f		 je	 SHORT $LN1@PyList_Cle

; 116  :         op = free_list[--numfree];

  00024	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  0002a	ff c8		 dec	 eax
  0002c	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax
  00032	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR numfree
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:free_list
  00040	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00044	48 89 44 24 28	 mov	 QWORD PTR op$[rsp], rax

; 117  :         assert(PyList_CheckExact(op));

  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  00050	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op$[rsp]
  00055	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00059	74 1c		 je	 SHORT $LN6@PyList_Cle
  0005b	41 b8 75 00 00
	00		 mov	 r8d, 117		; 00000075H
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CNNMDFEO@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00075	33 c0		 xor	 eax, eax
$LN6@PyList_Cle:

; 118  :         PyObject_GC_Del(op);

  00077	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op$[rsp]
  0007c	e8 00 00 00 00	 call	 PyObject_GC_Del

; 119  :     }

  00081	eb 98		 jmp	 SHORT $LN2@PyList_Cle
$LN1@PyList_Cle:

; 120  :     return ret;

  00083	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
$LN4@PyList_Cle:

; 121  : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
PyList_ClearFreeList ENDP
_TEXT	ENDS
PUBLIC	PyList_Fini
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_Fini DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$PyList_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Fini DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyList_Fini
_TEXT	SEGMENT
PyList_Fini PROC					; COMDAT

; 125  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 126  :     PyList_ClearFreeList();

  00004	e8 00 00 00 00	 call	 PyList_ClearFreeList

; 127  : }

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
PyList_Fini ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@LHCEILJJ@free?5PyListObject?$AA@	; `string'
PUBLIC	_PyList_DebugMallocStats
EXTRN	_PyDebugAllocatorStats:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyList_DebugMallocStats DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$_PyList_DebugMallocStats
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyList_DebugMallocStats DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BC@LHCEILJJ@free?5PyListObject?$AA@
CONST	SEGMENT
??_C@_0BC@LHCEILJJ@free?5PyListObject?$AA@ DB 'free PyListObject', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyList_DebugMallocStats
_TEXT	SEGMENT
out$ = 48
_PyList_DebugMallocStats PROC				; COMDAT

; 132  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 133  :     _PyDebugAllocatorStats(out,
; 134  :                            "free PyListObject",
; 135  :                            numfree, sizeof(PyListObject));

  00009	41 b9 80 00 00
	00		 mov	 r9d, 128		; 00000080H
  0000f	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR numfree
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LHCEILJJ@free?5PyListObject?$AA@
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00022	e8 00 00 00 00	 call	 _PyDebugAllocatorStats

; 136  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
_PyList_DebugMallocStats ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_0L@LDEBGCGJ@PyList_New?$AA@		; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@ ; `string'
PUBLIC	PyList_New
EXTRN	_PyGC_generation0:QWORD
EXTRN	Py_FatalError:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	memset:PROC
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
EXTRN	_Py_NewReference:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_New DD imagerel $LN22
	DD	imagerel $LN22+626
	DD	imagerel $unwind$PyList_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_New DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LDEBGCGJ@PyList_New?$AA@
CONST	SEGMENT
??_C@_0L@LDEBGCGJ@PyList_New?$AA@ DB 'PyList_New', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
CONST	SEGMENT
??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@ DB '..\Objects\listo'
	DB	'bject.c', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyList_New
_TEXT	SEGMENT
nbytes$ = 48
op$ = 56
g$20402 = 64
tv84 = 72
tv95 = 80
tv153 = 88
size$ = 112
PyList_New PROC						; COMDAT

; 140  : {

$LN22:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 141  :     PyListObject *op;
; 142  :     size_t nbytes;
; 143  : #ifdef SHOW_ALLOC_COUNT
; 144  :     static int initialized = 0;
; 145  :     if (!initialized) {
; 146  :         Py_AtExit(show_alloc);
; 147  :         initialized = 1;
; 148  :     }
; 149  : #endif
; 150  : 
; 151  :     if (size < 0) {

  00009	48 83 7c 24 70
	00		 cmp	 QWORD PTR size$[rsp], 0
  0000f	7d 18		 jge	 SHORT $LN13@PyList_New

; 152  :         PyErr_BadInternalCall();

  00011	ba 98 00 00 00	 mov	 edx, 152		; 00000098H
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0001d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 153  :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 44 02 00 00	 jmp	 $LN14@PyList_New
$LN13@PyList_New:

; 154  :     }
; 155  :     /* Check for overflow without an actual overflow,
; 156  :      *  which can cause compiler to optimise out */
; 157  :     if ((size_t)size > PY_SIZE_MAX / sizeof(PyObject *))

  00029	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00033	48 39 44 24 70	 cmp	 QWORD PTR size$[rsp], rax
  00038	76 0a		 jbe	 SHORT $LN12@PyList_New

; 158  :         return PyErr_NoMemory();

  0003a	e8 00 00 00 00	 call	 PyErr_NoMemory
  0003f	e9 29 02 00 00	 jmp	 $LN14@PyList_New
$LN12@PyList_New:

; 159  :     nbytes = size * sizeof(PyObject *);

  00044	48 8b 44 24 70	 mov	 rax, QWORD PTR size$[rsp]
  00049	48 c1 e0 03	 shl	 rax, 3
  0004d	48 89 44 24 30	 mov	 QWORD PTR nbytes$[rsp], rax

; 160  :     if (!Py_PXCTX && numfree) {

  00052	e8 00 00 00 00	 call	 _Py_PXCTX
  00057	85 c0		 test	 eax, eax
  00059	75 3a		 jne	 SHORT $LN11@PyList_New
  0005b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR numfree, 0
  00062	74 31		 je	 SHORT $LN11@PyList_New

; 161  :         numfree--;

  00064	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  0006a	ff c8		 dec	 eax
  0006c	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax

; 162  :         op = free_list[numfree];

  00072	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR numfree
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:free_list
  00080	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00084	48 89 44 24 38	 mov	 QWORD PTR op$[rsp], rax

; 163  :         _Py_NewReference((PyObject *)op);

  00089	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$[rsp]
  0008e	e8 00 00 00 00	 call	 _Py_NewReference

; 164  : #ifdef SHOW_ALLOC_COUNT
; 165  :         count_reuse++;
; 166  : #endif
; 167  :     } else {

  00093	eb 46		 jmp	 SHORT $LN10@PyList_New
$LN11@PyList_New:

; 168  :         op = PyObject_GC_New(PyListObject, &PyList_Type);

  00095	e8 00 00 00 00	 call	 _Py_PXCTX
  0009a	85 c0		 test	 eax, eax
  0009c	74 13		 je	 SHORT $LN16@PyList_New
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyList_Type
  000a5	e8 00 00 00 00	 call	 _PxObject_New
  000aa	48 89 44 24 48	 mov	 QWORD PTR tv84[rsp], rax
  000af	eb 11		 jmp	 SHORT $LN17@PyList_New
$LN16@PyList_New:
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyList_Type
  000b8	e8 00 00 00 00	 call	 _PyObject_GC_New
  000bd	48 89 44 24 48	 mov	 QWORD PTR tv84[rsp], rax
$LN17@PyList_New:
  000c2	48 8b 44 24 48	 mov	 rax, QWORD PTR tv84[rsp]
  000c7	48 89 44 24 38	 mov	 QWORD PTR op$[rsp], rax

; 169  :         if (op == NULL)

  000cc	48 83 7c 24 38
	00		 cmp	 QWORD PTR op$[rsp], 0
  000d2	75 07		 jne	 SHORT $LN9@PyList_New

; 170  :             return NULL;

  000d4	33 c0		 xor	 eax, eax
  000d6	e9 92 01 00 00	 jmp	 $LN14@PyList_New
$LN9@PyList_New:
$LN10@PyList_New:

; 171  : #ifdef SHOW_ALLOC_COUNT
; 172  :         count_alloc++;
; 173  : #endif
; 174  :     }
; 175  :     if (size <= 0)

  000db	48 83 7c 24 70
	00		 cmp	 QWORD PTR size$[rsp], 0
  000e1	7f 0f		 jg	 SHORT $LN8@PyList_New

; 176  :         op->ob_item = NULL;

  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  000e8	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 177  :     else {

  000f0	eb 6c		 jmp	 SHORT $LN7@PyList_New
$LN8@PyList_New:

; 178  :         op->ob_item = (PyObject **) PyMem_MALLOC(nbytes);

  000f2	e8 00 00 00 00	 call	 _Py_PXCTX
  000f7	85 c0		 test	 eax, eax
  000f9	74 11		 je	 SHORT $LN18@PyList_New
  000fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00100	e8 00 00 00 00	 call	 _PxMem_Malloc
  00105	48 89 44 24 50	 mov	 QWORD PTR tv95[rsp], rax
  0010a	eb 0f		 jmp	 SHORT $LN19@PyList_New
$LN18@PyList_New:
  0010c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00111	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00116	48 89 44 24 50	 mov	 QWORD PTR tv95[rsp], rax
$LN19@PyList_New:
  0011b	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  00120	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv95[rsp]
  00125	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 179  :         if (op->ob_item == NULL) {

  00129	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  0012e	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00133	75 14		 jne	 SHORT $LN6@PyList_New

; 180  :             Py_DECREF(op);

  00135	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$[rsp]
  0013a	e8 00 00 00 00	 call	 _Py_DecRef

; 181  :             return PyErr_NoMemory();

  0013f	e8 00 00 00 00	 call	 PyErr_NoMemory
  00144	e9 24 01 00 00	 jmp	 $LN14@PyList_New
$LN6@PyList_New:

; 182  :         }
; 183  :         memset(op->ob_item, 0, nbytes);

  00149	4c 8b 44 24 30	 mov	 r8, QWORD PTR nbytes$[rsp]
  0014e	33 d2		 xor	 edx, edx
  00150	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  00155	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00159	e8 00 00 00 00	 call	 memset
$LN7@PyList_New:

; 184  :     }
; 185  :     Py_SIZE(op) = size;

  0015e	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  00163	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size$[rsp]
  00168	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 186  :     op->allocated = size;

  0016c	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  00171	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size$[rsp]
  00176	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 187  :     _PyObject_GC_TRACK(op);

  0017a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00182	4c 8b 4c 24 38	 mov	 r9, QWORD PTR op$[rsp]
  00187	41 b8 bb 00 00
	00		 mov	 r8d, 187		; 000000bbH
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LDEBGCGJ@PyList_New?$AA@
  0019b	e8 00 00 00 00	 call	 _PyParallel_Guard
  001a0	85 c0		 test	 eax, eax
  001a2	0f 85 c0 00 00
	00		 jne	 $LN5@PyList_New
$LN4@PyList_New:
  001a8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001b0	4c 8b 4c 24 38	 mov	 r9, QWORD PTR op$[rsp]
  001b5	41 b8 bb 00 00
	00		 mov	 r8d, 187		; 000000bbH
  001bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LDEBGCGJ@PyList_New?$AA@
  001c9	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ce	85 c0		 test	 eax, eax
  001d0	74 0b		 je	 SHORT $LN20@PyList_New
  001d2	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv153[rsp], 0
  001db	eb 0e		 jmp	 SHORT $LN21@PyList_New
$LN20@PyList_New:
  001dd	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
  001e2	48 83 e8 18	 sub	 rax, 24
  001e6	48 89 44 24 58	 mov	 QWORD PTR tv153[rsp], rax
$LN21@PyList_New:
  001eb	48 8b 44 24 58	 mov	 rax, QWORD PTR tv153[rsp]
  001f0	48 89 44 24 40	 mov	 QWORD PTR g$20402[rsp], rax
  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR g$20402[rsp]
  001fa	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  001ff	74 0c		 je	 SHORT $LN1@PyList_New
  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  00208	e8 00 00 00 00	 call	 Py_FatalError
$LN1@PyList_New:
  0020d	48 8b 44 24 40	 mov	 rax, QWORD PTR g$20402[rsp]
  00212	48 c7 40 10 fd
	ff ff ff	 mov	 QWORD PTR [rax+16], -3
  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR g$20402[rsp]
  0021f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  00226	48 89 08	 mov	 QWORD PTR [rax], rcx
  00229	48 8b 44 24 40	 mov	 rax, QWORD PTR g$20402[rsp]
  0022e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  00235	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00239	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0023d	48 8b 44 24 40	 mov	 rax, QWORD PTR g$20402[rsp]
  00242	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00246	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$20402[rsp]
  0024b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0024e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00255	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$20402[rsp]
  0025a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0025e	33 c0		 xor	 eax, eax
  00260	85 c0		 test	 eax, eax
  00262	0f 85 40 ff ff
	ff		 jne	 $LN4@PyList_New
$LN5@PyList_New:

; 188  :     return (PyObject *) op;

  00268	48 8b 44 24 38	 mov	 rax, QWORD PTR op$[rsp]
$LN14@PyList_New:

; 189  : }

  0026d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00271	c3		 ret	 0
PyList_New ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	PyList_Size
;	COMDAT pdata
; File c:\src\pyparallel\objects\listobject.c
pdata	SEGMENT
$pdata$PyList_Size DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$PyList_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Size DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyList_Size
_TEXT	SEGMENT
op$ = 48
PyList_Size PROC					; COMDAT

; 193  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 194  :     if (!PyList_Check(op)) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN2@PyList_Siz

; 195  :         PyErr_BadInternalCall();

  00021	ba c3 00 00 00	 mov	 edx, 195		; 000000c3H
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0002d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 196  :         return -1;

  00032	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00039	eb 0b		 jmp	 SHORT $LN3@PyList_Siz

; 197  :     }
; 198  :     else

  0003b	eb 09		 jmp	 SHORT $LN1@PyList_Siz
$LN2@PyList_Siz:

; 199  :         return Py_SIZE(op);

  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00042	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
$LN1@PyList_Siz:
$LN3@PyList_Siz:

; 200  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
PyList_Size ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PPFNPBPL@list?5index?5out?5of?5range?$AA@ ; `string'
PUBLIC	PyList_GetItem
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_IndexError:QWORD
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_GetItem DD imagerel $LN8
	DD	imagerel $LN8+172
	DD	imagerel $unwind$PyList_GetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_GetItem DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0BI@PPFNPBPL@list?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BI@PPFNPBPL@list?5index?5out?5of?5range?$AA@ DB 'list index out of'
	DB	' range', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyList_GetItem
_TEXT	SEGMENT
op$ = 48
i$ = 56
PyList_GetItem PROC					; COMDAT

; 206  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 207  :     if (!PyList_Check(op)) {

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00022	85 c0		 test	 eax, eax
  00024	75 15		 jne	 SHORT $LN5@PyList_Get

; 208  :         PyErr_BadInternalCall();

  00026	ba d0 00 00 00	 mov	 edx, 208		; 000000d0H
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00032	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 209  :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	eb 6c		 jmp	 SHORT $LN6@PyList_Get
$LN5@PyList_Get:

; 210  :     }
; 211  :     if (i < 0 || i >= Py_SIZE(op)) {

  0003b	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  00041	7c 10		 jl	 SHORT $LN3@PyList_Get
  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00048	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004c	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00051	7c 42		 jl	 SHORT $LN4@PyList_Get
$LN3@PyList_Get:

; 212  :         if (indexerr == NULL) {

  00053	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR indexerr, 0
  0005b	75 21		 jne	 SHORT $LN2@PyList_Get

; 213  :             indexerr = PyUnicode_FromString(
; 214  :                 "list index out of range");

  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PPFNPBPL@list?5index?5out?5of?5range?$AA@
  00064	e8 00 00 00 00	 call	 PyUnicode_FromString
  00069	48 89 05 00 00
	00 00		 mov	 QWORD PTR indexerr, rax

; 215  :             if (indexerr == NULL)

  00070	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR indexerr, 0
  00078	75 04		 jne	 SHORT $LN1@PyList_Get

; 216  :                 return NULL;

  0007a	33 c0		 xor	 eax, eax
  0007c	eb 29		 jmp	 SHORT $LN6@PyList_Get
$LN1@PyList_Get:
$LN2@PyList_Get:

; 217  :         }
; 218  :         PyErr_SetObject(PyExc_IndexError, indexerr);

  0007e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR indexerr
  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0008c	e8 00 00 00 00	 call	 PyErr_SetObject

; 219  :         return NULL;

  00091	33 c0		 xor	 eax, eax
  00093	eb 12		 jmp	 SHORT $LN6@PyList_Get
$LN4@PyList_Get:

; 220  :     }
; 221  :     return ((PyListObject *)op) -> ob_item[i];

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0009a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0009e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000a3	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
$LN6@PyList_Get:

; 222  : }

  000a7	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ab	c3		 ret	 0
PyList_GetItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@MGPAAEOB@list?5assignment?5index?5out?5of?5ran@ ; `string'
PUBLIC	PyList_SetItem
EXTRN	PyErr_SetString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_SetItem DD imagerel $LN18
	DD	imagerel $LN18+248
	DD	imagerel $unwind$PyList_SetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_SetItem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CD@MGPAAEOB@list?5assignment?5index?5out?5of?5ran@
CONST	SEGMENT
??_C@_0CD@MGPAAEOB@list?5assignment?5index?5out?5of?5ran@ DB 'list assign'
	DB	'ment index out of range', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyList_SetItem
_TEXT	SEGMENT
p$ = 32
olditem$ = 40
op$ = 64
i$ = 72
newitem$ = 80
PyList_SetItem PROC					; COMDAT

; 227  : {

$LN18:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 228  :     register PyObject *olditem;
; 229  :     register PyObject **p;
; 230  :     if (!PyList_Check(op)) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00027	85 c0		 test	 eax, eax
  00029	75 33		 jne	 SHORT $LN15@PyList_Set
$LN14@PyList_Set:

; 231  :         Py_XDECREF(newitem);

  0002b	48 83 7c 24 50
	00		 cmp	 QWORD PTR newitem$[rsp], 0
  00031	74 0a		 je	 SHORT $LN11@PyList_Set
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newitem$[rsp]
  00038	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyList_Set:
  0003d	33 c0		 xor	 eax, eax
  0003f	85 c0		 test	 eax, eax
  00041	75 e8		 jne	 SHORT $LN14@PyList_Set

; 232  :         PyErr_BadInternalCall();

  00043	ba e8 00 00 00	 mov	 edx, 232		; 000000e8H
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0004f	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 233  :         return -1;

  00054	b8 ff ff ff ff	 mov	 eax, -1
  00059	e9 95 00 00 00	 jmp	 $LN16@PyList_Set
$LN15@PyList_Set:

; 234  :     }
; 235  : 
; 236  :     /*
; 237  :     if (Px_PROTECTION_ERROR(op))
; 238  :         return -1;
; 239  :     */
; 240  : 
; 241  :     if (i < 0 || i >= Py_SIZE(op)) {

  0005e	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  00064	7c 10		 jl	 SHORT $LN9@PyList_Set
  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006f	48 39 44 24 48	 cmp	 QWORD PTR i$[rsp], rax
  00074	7c 32		 jl	 SHORT $LN10@PyList_Set
$LN9@PyList_Set:
$LN8@PyList_Set:

; 242  :         Py_XDECREF(newitem);

  00076	48 83 7c 24 50
	00		 cmp	 QWORD PTR newitem$[rsp], 0
  0007c	74 0a		 je	 SHORT $LN5@PyList_Set
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newitem$[rsp]
  00083	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@PyList_Set:
  00088	33 c0		 xor	 eax, eax
  0008a	85 c0		 test	 eax, eax
  0008c	75 e8		 jne	 SHORT $LN8@PyList_Set

; 243  :         PyErr_SetString(PyExc_IndexError,
; 244  :                         "list assignment index out of range");

  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@MGPAAEOB@list?5assignment?5index?5out?5of?5ran@
  00095	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0009c	e8 00 00 00 00	 call	 PyErr_SetString

; 245  :         return -1;

  000a1	b8 ff ff ff ff	 mov	 eax, -1
  000a6	eb 4b		 jmp	 SHORT $LN16@PyList_Set
$LN10@PyList_Set:

; 246  :     }
; 247  :     p = ((PyListObject *)op) -> ob_item + i;

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  000ad	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  000b6	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  000ba	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 248  :     olditem = *p;

  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000c4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c7	48 89 44 24 28	 mov	 QWORD PTR olditem$[rsp], rax

; 249  :     /*
; 250  :     if (Px_ASSIGNMENT_ERROR(op, olditem))
; 251  :         return -1;
; 252  :     */
; 253  :     *p = newitem;

  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000d1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newitem$[rsp]
  000d6	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN4@PyList_Set:

; 254  :     Py_XDECREF(olditem);

  000d9	48 83 7c 24 28
	00		 cmp	 QWORD PTR olditem$[rsp], 0
  000df	74 0a		 je	 SHORT $LN1@PyList_Set
  000e1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR olditem$[rsp]
  000e6	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyList_Set:
  000eb	33 c0		 xor	 eax, eax
  000ed	85 c0		 test	 eax, eax
  000ef	75 e8		 jne	 SHORT $LN4@PyList_Set

; 255  :     return 0;

  000f1	33 c0		 xor	 eax, eax
$LN16@PyList_Set:

; 256  : }

  000f3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f7	c3		 ret	 0
PyList_SetItem ENDP
_TEXT	ENDS
PUBLIC	PyList_Insert
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_Insert DD imagerel $LN4
	DD	imagerel $LN4+92
	DD	imagerel $unwind$PyList_Insert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Insert DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyList_Insert
_TEXT	SEGMENT
op$ = 48
where$ = 56
newitem$ = 64
PyList_Insert PROC					; COMDAT

; 294  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 295  :     if (!PyList_Check(op)) {

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00027	85 c0		 test	 eax, eax
  00029	75 18		 jne	 SHORT $LN1@PyList_Ins

; 296  :         PyErr_BadInternalCall();

  0002b	ba 28 01 00 00	 mov	 edx, 296		; 00000128H
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00037	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 297  :         return -1;

  0003c	b8 ff ff ff ff	 mov	 eax, -1
  00041	eb 14		 jmp	 SHORT $LN2@PyList_Ins
$LN1@PyList_Ins:

; 298  :     }
; 299  :     /* Px_CHECK_PROTECTION handled by inst1()->list_resize() */
; 300  :     return ins1((PyListObject *)op, where, newitem);

  00043	4c 8b 44 24 40	 mov	 r8, QWORD PTR newitem$[rsp]
  00048	48 8b 54 24 38	 mov	 rdx, QWORD PTR where$[rsp]
  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00052	e8 00 00 00 00	 call	 ins1
$LN2@PyList_Ins:

; 301  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
PyList_Insert ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0CA@KPHNNLBH@cannot?5add?5more?5objects?5to?5list?$AA@ ; `string'
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$ins1 DD	imagerel ins1
	DD	imagerel ins1+334
	DD	imagerel $unwind$ins1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ins1 DD	011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0CA@KPHNNLBH@cannot?5add?5more?5objects?5to?5list?$AA@
CONST	SEGMENT
??_C@_0CA@KPHNNLBH@cannot?5add?5more?5objects?5to?5list?$AA@ DB 'cannot a'
	DB	'dd more objects to list', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ins1
_TEXT	SEGMENT
n$ = 32
i$ = 40
items$ = 48
self$ = 80
where$ = 88
v$ = 96
ins1	PROC						; COMDAT

; 260  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 261  :     Py_ssize_t i, n = Py_SIZE(self);

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001c	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 262  :     PyObject **items;
; 263  :     if (v == NULL) {

  00021	48 83 7c 24 60
	00		 cmp	 QWORD PTR v$[rsp], 0
  00027	75 1b		 jne	 SHORT $LN8@ins1

; 264  :         PyErr_BadInternalCall();

  00029	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00035	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 265  :         return -1;

  0003a	b8 ff ff ff ff	 mov	 eax, -1
  0003f	e9 05 01 00 00	 jmp	 $LN9@ins1
$LN8@ins1:

; 266  :     }
; 267  :     if (n == PY_SSIZE_T_MAX) {

  00044	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0004e	48 39 44 24 20	 cmp	 QWORD PTR n$[rsp], rax
  00053	75 1d		 jne	 SHORT $LN7@ins1

; 268  :         PyErr_SetString(PyExc_OverflowError,
; 269  :             "cannot add more objects to list");

  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KPHNNLBH@cannot?5add?5more?5objects?5to?5list?$AA@
  0005c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00063	e8 00 00 00 00	 call	 PyErr_SetString

; 270  :         return -1;

  00068	b8 ff ff ff ff	 mov	 eax, -1
  0006d	e9 d7 00 00 00	 jmp	 $LN9@ins1
$LN7@ins1:

; 271  :     }
; 272  : 
; 273  :     /* Px_CHECK_PROTECTION handled by list_resize() */
; 274  :     if (list_resize(self, n+1) == -1)

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00077	48 ff c0	 inc	 rax
  0007a	48 8b d0	 mov	 rdx, rax
  0007d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00082	e8 00 00 00 00	 call	 list_resize
  00087	83 f8 ff	 cmp	 eax, -1
  0008a	75 0a		 jne	 SHORT $LN6@ins1

; 275  :         return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	e9 b3 00 00 00	 jmp	 $LN9@ins1
$LN6@ins1:

; 276  : 
; 277  :     if (where < 0) {

  00096	48 83 7c 24 58
	00		 cmp	 QWORD PTR where$[rsp], 0
  0009c	7d 26		 jge	 SHORT $LN5@ins1

; 278  :         where += n;

  0009e	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR where$[rsp]
  000a8	48 03 c8	 add	 rcx, rax
  000ab	48 8b c1	 mov	 rax, rcx
  000ae	48 89 44 24 58	 mov	 QWORD PTR where$[rsp], rax

; 279  :         if (where < 0)

  000b3	48 83 7c 24 58
	00		 cmp	 QWORD PTR where$[rsp], 0
  000b9	7d 09		 jge	 SHORT $LN4@ins1

; 280  :             where = 0;

  000bb	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR where$[rsp], 0
$LN4@ins1:
$LN5@ins1:

; 281  :     }
; 282  :     if (where > n)

  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000c9	48 39 44 24 58	 cmp	 QWORD PTR where$[rsp], rax
  000ce	7e 0a		 jle	 SHORT $LN3@ins1

; 283  :         where = n;

  000d0	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000d5	48 89 44 24 58	 mov	 QWORD PTR where$[rsp], rax
$LN3@ins1:

; 284  :     items = self->ob_item;

  000da	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000df	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000e3	48 89 44 24 30	 mov	 QWORD PTR items$[rsp], rax

; 285  :     for (i = n; --i >= where; )

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000ed	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN2@ins1:
  000f2	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000f7	48 ff c8	 dec	 rax
  000fa	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  000ff	48 8b 44 24 58	 mov	 rax, QWORD PTR where$[rsp]
  00104	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00109	7c 1f		 jl	 SHORT $LN1@ins1

; 286  :         items[i+1] = items[i];

  0010b	48 8b 44 24 30	 mov	 rax, QWORD PTR items$[rsp]
  00110	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00115	48 8b 54 24 30	 mov	 rdx, QWORD PTR items$[rsp]
  0011a	4c 8b 44 24 28	 mov	 r8, QWORD PTR i$[rsp]
  0011f	4a 8b 14 c2	 mov	 rdx, QWORD PTR [rdx+r8*8]
  00123	48 89 54 c8 08	 mov	 QWORD PTR [rax+rcx*8+8], rdx
  00128	eb c8		 jmp	 SHORT $LN2@ins1
$LN1@ins1:

; 287  :     Py_INCREF(v);

  0012a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  0012f	e8 00 00 00 00	 call	 _Py_IncRef

; 288  :     items[where] = v;

  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR items$[rsp]
  00139	48 8b 4c 24 58	 mov	 rcx, QWORD PTR where$[rsp]
  0013e	48 8b 54 24 60	 mov	 rdx, QWORD PTR v$[rsp]
  00143	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 289  :     return 0;

  00147	33 c0		 xor	 eax, eax
$LN9@ins1:

; 290  : }

  00149	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0014d	c3		 ret	 0
ins1	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@MDNNEGKD@list_resize?5from?5px?5thread?$AA@ ; `string'
PUBLIC	??_C@_0M@CEKCPCJF@list_resize?$AA@		; `string'
PUBLIC	??_C@_1EM@HFDLILCI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe@ ; `string'
EXTRN	_PyMem_DebugRealloc:PROC
EXTRN	_PxMem_Realloc:PROC
EXTRN	PyExc_AssignmentError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\objects\listobject.c
pdata	SEGMENT
$pdata$list_resize DD imagerel list_resize
	DD	imagerel list_resize+550
	DD	imagerel $unwind$list_resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_resize DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0BL@MDNNEGKD@list_resize?5from?5px?5thread?$AA@
CONST	SEGMENT
??_C@_0BL@MDNNEGKD@list_resize?5from?5px?5thread?$AA@ DB 'list_resize fro'
	DB	'm px thread', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CEKCPCJF@list_resize?$AA@
CONST	SEGMENT
??_C@_0M@CEKCPCJF@list_resize?$AA@ DB 'list_resize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@HFDLILCI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1EM@HFDLILCI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'o', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'm', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'n', 00H, 'e'
	DB	00H, 'w', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT list_resize
_TEXT	SEGMENT
allocated$ = 48
new_allocated$ = 56
items$ = 64
tv89 = 72
tv142 = 80
tv141 = 88
self$ = 112
newsize$ = 120
list_resize PROC					; COMDAT

; 27   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 28   :     PyObject **items;
; 29   :     size_t new_allocated;
; 30   :     Py_ssize_t allocated = self->allocated;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00017	48 89 44 24 30	 mov	 QWORD PTR allocated$[rsp], rax

; 31   : 
; 32   :     /* Bypass realloc() when a previous overallocation is large enough
; 33   :        to accommodate the newsize.  If the newsize falls lower than half
; 34   :        the allocated size, then proceed with the realloc() to shrink the list.
; 35   :     */
; 36   :     if (allocated >= newsize && newsize >= (allocated >> 1)) {

  0001c	48 8b 44 24 78	 mov	 rax, QWORD PTR newsize$[rsp]
  00021	48 39 44 24 30	 cmp	 QWORD PTR allocated$[rsp], rax
  00026	7c 54		 jl	 SHORT $LN8@list_resiz
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR allocated$[rsp]
  0002d	48 d1 f8	 sar	 rax, 1
  00030	48 39 44 24 78	 cmp	 QWORD PTR newsize$[rsp], rax
  00035	7c 45		 jl	 SHORT $LN8@list_resiz

; 37   :         assert(self->ob_item != NULL || newsize == 0);

  00037	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0003c	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00041	75 24		 jne	 SHORT $LN11@list_resiz
  00043	48 83 7c 24 78
	00		 cmp	 QWORD PTR newsize$[rsp], 0
  00049	74 1c		 je	 SHORT $LN11@list_resiz
  0004b	41 b8 25 00 00
	00		 mov	 r8d, 37			; 00000025H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@HFDLILCI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe@
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00065	33 c0		 xor	 eax, eax
$LN11@list_resiz:

; 38   :         Py_SIZE(self) = newsize;

  00067	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0006c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR newsize$[rsp]
  00071	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 39   :         return 0;

  00075	33 c0		 xor	 eax, eax
  00077	e9 a5 01 00 00	 jmp	 $LN9@list_resiz
$LN8@list_resiz:

; 40   :     }
; 41   : 
; 42   : #ifdef WITH_PARALLEL
; 43   :     if (Py_PXCTX && Py_ISPY(self)) {

  0007c	e8 00 00 00 00	 call	 _Py_PXCTX
  00081	85 c0		 test	 eax, eax
  00083	74 47		 je	 SHORT $LN7@list_resiz
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 4c 24 70	 mov	 r9, QWORD PTR self$[rsp]
  00092	41 b8 2b 00 00
	00		 mov	 r8d, 43			; 0000002bH
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@CEKCPCJF@list_resize?$AA@
  000a6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ab	85 c0		 test	 eax, eax
  000ad	74 1d		 je	 SHORT $LN7@list_resiz

; 44   :         PyErr_SetString(PyExc_AssignmentError, "list_resize from px thread");

  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@MDNNEGKD@list_resize?5from?5px?5thread?$AA@
  000b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AssignmentError
  000bd	e8 00 00 00 00	 call	 PyErr_SetString

; 45   :         return -1;

  000c2	b8 ff ff ff ff	 mov	 eax, -1
  000c7	e9 55 01 00 00	 jmp	 $LN9@list_resiz
$LN7@list_resiz:

; 46   :     }
; 47   : #endif
; 48   : 
; 49   :     /* This over-allocates proportional to the list size, making room
; 50   :      * for additional growth.  The over-allocation is mild, but is
; 51   :      * enough to give linear-time amortized behavior over a long
; 52   :      * sequence of appends() in the presence of a poorly-performing
; 53   :      * system realloc().
; 54   :      * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
; 55   :      */
; 56   :     new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6);

  000cc	48 83 7c 24 78
	09		 cmp	 QWORD PTR newsize$[rsp], 9
  000d2	7d 0a		 jge	 SHORT $LN12@list_resiz
  000d4	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR tv89[rsp], 3
  000dc	eb 08		 jmp	 SHORT $LN13@list_resiz
$LN12@list_resiz:
  000de	c7 44 24 48 06
	00 00 00	 mov	 DWORD PTR tv89[rsp], 6
$LN13@list_resiz:
  000e6	48 8b 44 24 78	 mov	 rax, QWORD PTR newsize$[rsp]
  000eb	48 c1 f8 03	 sar	 rax, 3
  000ef	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR tv89[rsp]
  000f4	48 03 c1	 add	 rax, rcx
  000f7	48 89 44 24 38	 mov	 QWORD PTR new_allocated$[rsp], rax

; 57   : 
; 58   :     /* check for integer overflow */
; 59   :     if (new_allocated > PY_SIZE_MAX - newsize) {

  000fc	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00103	48 2b 44 24 78	 sub	 rax, QWORD PTR newsize$[rsp]
  00108	48 39 44 24 38	 cmp	 QWORD PTR new_allocated$[rsp], rax
  0010d	76 11		 jbe	 SHORT $LN6@list_resiz

; 60   :         PyErr_NoMemory();

  0010f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 61   :         return -1;

  00114	b8 ff ff ff ff	 mov	 eax, -1
  00119	e9 03 01 00 00	 jmp	 $LN9@list_resiz

; 62   :     } else {

  0011e	eb 15		 jmp	 SHORT $LN5@list_resiz
$LN6@list_resiz:

; 63   :         new_allocated += newsize;

  00120	48 8b 44 24 78	 mov	 rax, QWORD PTR newsize$[rsp]
  00125	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new_allocated$[rsp]
  0012a	48 03 c8	 add	 rcx, rax
  0012d	48 8b c1	 mov	 rax, rcx
  00130	48 89 44 24 38	 mov	 QWORD PTR new_allocated$[rsp], rax
$LN5@list_resiz:

; 64   :     }
; 65   : 
; 66   :     if (newsize == 0)

  00135	48 83 7c 24 78
	00		 cmp	 QWORD PTR newsize$[rsp], 0
  0013b	75 09		 jne	 SHORT $LN4@list_resiz

; 67   :         new_allocated = 0;

  0013d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR new_allocated$[rsp], 0
$LN4@list_resiz:

; 68   :     items = self->ob_item;

  00146	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0014b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0014f	48 89 44 24 40	 mov	 QWORD PTR items$[rsp], rax

; 69   :     if (new_allocated <= (PY_SIZE_MAX / sizeof(PyObject *)))

  00154	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  0015e	48 39 44 24 38	 cmp	 QWORD PTR new_allocated$[rsp], rax
  00163	77 73		 ja	 SHORT $LN3@list_resiz

; 70   :         PyMem_RESIZE(items, PyObject *, new_allocated);

  00165	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  0016f	48 39 44 24 38	 cmp	 QWORD PTR new_allocated$[rsp], rax
  00174	76 0b		 jbe	 SHORT $LN16@list_resiz
  00176	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv142[rsp], 0
  0017f	eb 4b		 jmp	 SHORT $LN17@list_resiz
$LN16@list_resiz:
  00181	e8 00 00 00 00	 call	 _Py_PXCTX
  00186	85 c0		 test	 eax, eax
  00188	74 1d		 je	 SHORT $LN14@list_resiz
  0018a	48 8b 44 24 38	 mov	 rax, QWORD PTR new_allocated$[rsp]
  0018f	48 c1 e0 03	 shl	 rax, 3
  00193	48 8b d0	 mov	 rdx, rax
  00196	48 8b 4c 24 40	 mov	 rcx, QWORD PTR items$[rsp]
  0019b	e8 00 00 00 00	 call	 _PxMem_Realloc
  001a0	48 89 44 24 58	 mov	 QWORD PTR tv141[rsp], rax
  001a5	eb 1b		 jmp	 SHORT $LN15@list_resiz
$LN14@list_resiz:
  001a7	48 8b 44 24 38	 mov	 rax, QWORD PTR new_allocated$[rsp]
  001ac	48 c1 e0 03	 shl	 rax, 3
  001b0	48 8b d0	 mov	 rdx, rax
  001b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR items$[rsp]
  001b8	e8 00 00 00 00	 call	 _PyMem_DebugRealloc
  001bd	48 89 44 24 58	 mov	 QWORD PTR tv141[rsp], rax
$LN15@list_resiz:
  001c2	48 8b 44 24 58	 mov	 rax, QWORD PTR tv141[rsp]
  001c7	48 89 44 24 50	 mov	 QWORD PTR tv142[rsp], rax
$LN17@list_resiz:
  001cc	48 8b 44 24 50	 mov	 rax, QWORD PTR tv142[rsp]
  001d1	48 89 44 24 40	 mov	 QWORD PTR items$[rsp], rax

; 71   :     else

  001d6	eb 09		 jmp	 SHORT $LN2@list_resiz
$LN3@list_resiz:

; 72   :         items = NULL;

  001d8	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR items$[rsp], 0
$LN2@list_resiz:

; 73   :     if (items == NULL) {

  001e1	48 83 7c 24 40
	00		 cmp	 QWORD PTR items$[rsp], 0
  001e7	75 0c		 jne	 SHORT $LN1@list_resiz

; 74   :         PyErr_NoMemory();

  001e9	e8 00 00 00 00	 call	 PyErr_NoMemory

; 75   :         return -1;

  001ee	b8 ff ff ff ff	 mov	 eax, -1
  001f3	eb 2c		 jmp	 SHORT $LN9@list_resiz
$LN1@list_resiz:

; 76   :     }
; 77   :     self->ob_item = items;

  001f5	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001fa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR items$[rsp]
  001ff	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 78   :     Py_SIZE(self) = newsize;

  00203	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00208	48 8b 4c 24 78	 mov	 rcx, QWORD PTR newsize$[rsp]
  0020d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 79   :     self->allocated = new_allocated;

  00211	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00216	48 8b 4c 24 38	 mov	 rcx, QWORD PTR new_allocated$[rsp]
  0021b	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 80   :     return 0;

  0021f	33 c0		 xor	 eax, eax
$LN9@list_resiz:

; 81   : }

  00221	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00225	c3		 ret	 0
list_resize ENDP
_TEXT	ENDS
PUBLIC	PyList_Append
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_Append DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$PyList_Append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Append DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyList_Append
_TEXT	SEGMENT
op$ = 48
newitem$ = 56
PyList_Append PROC					; COMDAT

; 326  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 327  :     if (PyList_Check(op) && (newitem != NULL))

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00022	85 c0		 test	 eax, eax
  00024	74 19		 je	 SHORT $LN1@PyList_App
  00026	48 83 7c 24 38
	00		 cmp	 QWORD PTR newitem$[rsp], 0
  0002c	74 11		 je	 SHORT $LN1@PyList_App

; 328  :         /* Px_CHECK_PROTECTION handled by app1()->list_resize() */
; 329  :         return app1((PyListObject *)op, newitem);

  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR newitem$[rsp]
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00038	e8 00 00 00 00	 call	 app1
  0003d	eb 16		 jmp	 SHORT $LN2@PyList_App
$LN1@PyList_App:

; 330  :     PyErr_BadInternalCall();

  0003f	ba 4a 01 00 00	 mov	 edx, 330		; 0000014aH
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0004b	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 331  :     return -1;

  00050	b8 ff ff ff ff	 mov	 eax, -1
$LN2@PyList_App:

; 332  : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
PyList_Append ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$app1 DD	imagerel app1
	DD	imagerel app1+180
	DD	imagerel $unwind$app1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$app1 DD	010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'v'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT app1
_TEXT	SEGMENT
n$ = 32
self$ = 64
v$ = 72
app1	PROC						; COMDAT

; 305  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 306  :     Py_ssize_t n = PyList_GET_SIZE(self);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 307  : 
; 308  :     assert (v != NULL);

  0001c	48 83 7c 24 48
	00		 cmp	 QWORD PTR v$[rsp], 0
  00022	75 1c		 jne	 SHORT $LN5@app1
  00024	41 b8 34 01 00
	00		 mov	 r8d, 308		; 00000134H
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003e	33 c0		 xor	 eax, eax
$LN5@app1:

; 309  :     if (n == PY_SSIZE_T_MAX) {

  00040	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0004a	48 39 44 24 20	 cmp	 QWORD PTR n$[rsp], rax
  0004f	75 1a		 jne	 SHORT $LN2@app1

; 310  :         PyErr_SetString(PyExc_OverflowError,
; 311  :             "cannot add more objects to list");

  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KPHNNLBH@cannot?5add?5more?5objects?5to?5list?$AA@
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0005f	e8 00 00 00 00	 call	 PyErr_SetString

; 312  :         return -1;

  00064	b8 ff ff ff ff	 mov	 eax, -1
  00069	eb 44		 jmp	 SHORT $LN3@app1
$LN2@app1:

; 313  :     }
; 314  : 
; 315  :     /* Px_CHECK_PROTECTION handled by list_resize() */
; 316  :     if (list_resize(self, n+1) == -1)

  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00070	48 ff c0	 inc	 rax
  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0007b	e8 00 00 00 00	 call	 list_resize
  00080	83 f8 ff	 cmp	 eax, -1
  00083	75 07		 jne	 SHORT $LN1@app1

; 317  :         return -1;

  00085	b8 ff ff ff ff	 mov	 eax, -1
  0008a	eb 23		 jmp	 SHORT $LN3@app1
$LN1@app1:

; 318  : 
; 319  :     Py_INCREF(v);

  0008c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00091	e8 00 00 00 00	 call	 _Py_IncRef

; 320  :     PyList_SET_ITEM(self, n, v);

  00096	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0009f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  000a4	48 8b 54 24 48	 mov	 rdx, QWORD PTR v$[rsp]
  000a9	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 321  :     return 0;

  000ad	33 c0		 xor	 eax, eax
$LN3@app1:

; 322  : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
app1	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@IKFOGEIE@list_dealloc?$AA@		; `string'
EXTRN	_PyTrash_thread_deposit_object:PROC
EXTRN	_PyTrash_thread_destroy_chain:PROC
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	PyThreadState_Get:PROC
EXTRN	PyObject_GC_UnTrack:PROC
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_dealloc DD imagerel list_dealloc
	DD	imagerel list_dealloc+437
	DD	imagerel $unwind$list_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_dealloc DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0N@IKFOGEIE@list_dealloc?$AA@
CONST	SEGMENT
??_C@_0N@IKFOGEIE@list_dealloc?$AA@ DB 'list_dealloc', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT list_dealloc
_TEXT	SEGMENT
i$ = 32
_tstate$20539 = 40
tv129 = 48
op$ = 80
list_dealloc PROC					; COMDAT

; 338  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 339  :     Py_ssize_t i;
; 340  :     Py_GUARD

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN16@list_deall
  00012	45 33 c9	 xor	 r9d, r9d
  00015	41 b8 54 01 00
	00		 mov	 r8d, 340		; 00000154H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@IKFOGEIE@list_dealloc?$AA@
  00029	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN16@list_deall:

; 341  :     PyObject_GC_UnTrack(op);

  0002e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00033	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN15@list_deall:

; 342  :     Py_TRASHCAN_SAFE_BEGIN(op)

  00038	e8 00 00 00 00	 call	 PyThreadState_Get
  0003d	48 89 44 24 28	 mov	 QWORD PTR _tstate$20539[rsp], rax
  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR _tstate$20539[rsp]
  00047	83 b8 94 00 00
	00 32		 cmp	 DWORD PTR [rax+148], 50	; 00000032H
  0004e	0f 8d 48 01 00
	00		 jge	 $LN12@list_deall
  00054	48 8b 44 24 28	 mov	 rax, QWORD PTR _tstate$20539[rsp]
  00059	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0005f	ff c0		 inc	 eax
  00061	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _tstate$20539[rsp]
  00066	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 343  :     if (op->ob_item != NULL) {

  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00071	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00076	0f 84 8e 00 00
	00		 je	 $LN11@list_deall

; 344  :         /* Do it backwards, for Christian Tismer.
; 345  :            There's a simple test case where somehow this reduces
; 346  :            thrashing when a *very* large list is created and
; 347  :            immediately deleted. */
; 348  :         i = Py_SIZE(op);

  0007c	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00081	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00085	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN10@list_deall:

; 349  :         while (--i >= 0) {

  0008a	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0008f	48 ff c8	 dec	 rax
  00092	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00097	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0009d	7c 34		 jl	 SHORT $LN9@list_deall
$LN8@list_deall:

; 350  :             Py_XDECREF(op->ob_item[i]);

  0009f	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000a4	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000a8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000ad	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  000b2	74 17		 je	 SHORT $LN5@list_deall
  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000b9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000c2	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  000c6	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@list_deall:
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	75 ce		 jne	 SHORT $LN8@list_deall

; 351  :         }

  000d1	eb b7		 jmp	 SHORT $LN10@list_deall
$LN9@list_deall:

; 352  :         PyMem_FREE(op->ob_item);

  000d3	e8 00 00 00 00	 call	 _Py_PXCTX
  000d8	85 c0		 test	 eax, eax
  000da	74 18		 je	 SHORT $LN19@list_deall
  000dc	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000e1	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000e5	e8 00 00 00 00	 call	 _PxMem_Free
  000ea	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
  000f2	eb 16		 jmp	 SHORT $LN20@list_deall
$LN19@list_deall:
  000f4	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000f9	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000fd	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00102	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN20@list_deall:
$LN11@list_deall:

; 353  :     }
; 354  :     if (numfree < PyList_MAXFREELIST && PyList_CheckExact(op))

  0010a	83 3d 00 00 00
	00 50		 cmp	 DWORD PTR numfree, 80	; 00000050H
  00111	7d 39		 jge	 SHORT $LN4@list_deall
  00113	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  0011a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  0011f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00123	75 27		 jne	 SHORT $LN4@list_deall

; 355  :         free_list[numfree++] = op;

  00125	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR numfree
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:free_list
  00133	48 8b 54 24 50	 mov	 rdx, QWORD PTR op$[rsp]
  00138	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  0013c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  00142	ff c0		 inc	 eax
  00144	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax

; 356  :     else

  0014a	eb 14		 jmp	 SHORT $LN3@list_deall
$LN4@list_deall:

; 357  :         Py_TYPE(op)->tp_free((PyObject *)op);

  0014c	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00151	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00155	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  0015a	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]
$LN3@list_deall:

; 358  :     Py_TRASHCAN_SAFE_END(op)

  00160	48 8b 44 24 28	 mov	 rax, QWORD PTR _tstate$20539[rsp]
  00165	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0016b	ff c8		 dec	 eax
  0016d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _tstate$20539[rsp]
  00172	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax
  00178	48 8b 44 24 28	 mov	 rax, QWORD PTR _tstate$20539[rsp]
  0017d	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  00185	74 13		 je	 SHORT $LN2@list_deall
  00187	48 8b 44 24 28	 mov	 rax, QWORD PTR _tstate$20539[rsp]
  0018c	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  00193	7f 05		 jg	 SHORT $LN2@list_deall
  00195	e8 00 00 00 00	 call	 _PyTrash_thread_destroy_chain
$LN2@list_deall:
  0019a	eb 0a		 jmp	 SHORT $LN1@list_deall
$LN12@list_deall:
  0019c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  001a1	e8 00 00 00 00	 call	 _PyTrash_thread_deposit_object
$LN1@list_deall:
  001a6	33 c0		 xor	 eax, eax
  001a8	85 c0		 test	 eax, eax
  001aa	0f 85 88 fe ff
	ff		 jne	 $LN15@list_deall

; 359  : }

  001b0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b4	c3		 ret	 0
list_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_0CC@LCJMBFL@?5while?5getting?5the?5repr?5of?5a?5lis@ ; `string'
PUBLIC	??_C@_09CGFMFLFL@list_repr?$AA@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_05CLKOKHPD@?$FL?4?4?4?$FN?$AA@		; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
EXTRN	_PyAccu_Destroy:PROC
EXTRN	_PyAccu_Finish:PROC
EXTRN	Py_ReprLeave:PROC
EXTRN	PyObject_Repr:PROC
EXTRN	_Py_CheckRecursiveCall:PROC
EXTRN	_Py_CheckRecursionLimit:DWORD
EXTRN	_PyAccu_Accumulate:PROC
EXTRN	_PyAccu_Init:PROC
EXTRN	Py_ReprEnter:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_repr DD imagerel list_repr
	DD	imagerel list_repr+949
	DD	imagerel $unwind$list_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_repr DD 020c01H
	DD	013010cH
xdata	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LCJMBFL@?5while?5getting?5the?5repr?5of?5a?5lis@
CONST	SEGMENT
??_C@_0CC@LCJMBFL@?5while?5getting?5the?5repr?5of?5a?5lis@ DB ' while get'
	DB	'ting the repr of a list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CGFMFLFL@list_repr?$AA@
CONST	SEGMENT
??_C@_09CGFMFLFL@list_repr?$AA@ DB 'list_repr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CLKOKHPD@?$FL?4?4?4?$FN?$AA@
CONST	SEGMENT
??_C@_05CLKOKHPD@?$FL?4?4?4?$FN?$AA@ DB '[...]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT list_repr
_TEXT	SEGMENT
i$ = 48
s$ = 56
acc$ = 64
_py_tmp$20595 = 80
_py_tmp$20617 = 88
_py_tmp$20629 = 96
tv79 = 104
tv137 = 112
tv156 = 120
tv150 = 128
v$ = 160
list_repr PROC						; COMDAT

; 363  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 364  :     Py_ssize_t i;
; 365  :     PyObject *s = NULL;

  0000c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR s$[rsp], 0

; 366  :     _PyAccu acc;
; 367  :     static PyObject *sep = NULL;
; 368  : 
; 369  :     if (Py_SIZE(v) == 0) {

  00015	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0001d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00022	75 11		 jne	 SHORT $LN36@list_repr

; 370  :         return PyUnicode_FromString("[]");

  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02GPECMEKF@?$FL?$FN?$AA@
  0002b	e8 00 00 00 00	 call	 PyUnicode_FromString
  00030	e9 78 03 00 00	 jmp	 $LN37@list_repr
$LN36@list_repr:

; 371  :     }
; 372  : 
; 373  :     if (sep == NULL) {

  00035	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?sep@?1??list_repr@@9@9, 0
  0003d	75 24		 jne	 SHORT $LN35@list_repr

; 374  :         sep = PyUnicode_FromString(", ");

  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
  00046	e8 00 00 00 00	 call	 PyUnicode_FromString
  0004b	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?sep@?1??list_repr@@9@9, rax

; 375  :         if (sep == NULL)

  00052	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?sep@?1??list_repr@@9@9, 0
  0005a	75 07		 jne	 SHORT $LN34@list_repr

; 376  :             return NULL;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 4a 03 00 00	 jmp	 $LN37@list_repr
$LN34@list_repr:
$LN35@list_repr:

; 377  :     }
; 378  : 
; 379  :     i = Py_ReprEnter((PyObject*)v);

  00063	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0006b	e8 00 00 00 00	 call	 Py_ReprEnter
  00070	48 98		 cdqe
  00072	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 380  :     if (i != 0) {

  00077	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  0007d	74 2e		 je	 SHORT $LN33@list_repr

; 381  :         return i > 0 ? PyUnicode_FromString("[...]") : NULL;

  0007f	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  00085	7e 13		 jle	 SHORT $LN39@list_repr
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05CLKOKHPD@?$FL?4?4?4?$FN?$AA@
  0008e	e8 00 00 00 00	 call	 PyUnicode_FromString
  00093	48 89 44 24 68	 mov	 QWORD PTR tv79[rsp], rax
  00098	eb 09		 jmp	 SHORT $LN40@list_repr
$LN39@list_repr:
  0009a	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
$LN40@list_repr:
  000a3	48 8b 44 24 68	 mov	 rax, QWORD PTR tv79[rsp]
  000a8	e9 00 03 00 00	 jmp	 $LN37@list_repr
$LN33@list_repr:

; 382  :     }
; 383  : 
; 384  :     if (_PyAccu_Init(&acc))

  000ad	48 8d 4c 24 40	 lea	 rcx, QWORD PTR acc$[rsp]
  000b2	e8 00 00 00 00	 call	 _PyAccu_Init
  000b7	85 c0		 test	 eax, eax
  000b9	74 05		 je	 SHORT $LN32@list_repr

; 385  :         goto error;

  000bb	e9 bc 02 00 00	 jmp	 $error$20585
$LN32@list_repr:

; 386  : 
; 387  :     s = PyUnicode_FromString("[");

  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01OHGJGJJP@?$FL?$AA@
  000c7	e8 00 00 00 00	 call	 PyUnicode_FromString
  000cc	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 388  :     if (s == NULL || _PyAccu_Accumulate(&acc, s))

  000d1	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  000d7	74 13		 je	 SHORT $LN30@list_repr
  000d9	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$[rsp]
  000de	48 8d 4c 24 40	 lea	 rcx, QWORD PTR acc$[rsp]
  000e3	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  000e8	85 c0		 test	 eax, eax
  000ea	74 05		 je	 SHORT $LN31@list_repr
$LN30@list_repr:

; 389  :         goto error;

  000ec	e9 8b 02 00 00	 jmp	 $error$20585
$LN31@list_repr:
$LN29@list_repr:

; 390  :     Py_CLEAR(s);

  000f1	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  000f7	74 47		 je	 SHORT $LN26@list_repr
  000f9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00101	4c 8b 4c 24 38	 mov	 r9, QWORD PTR s$[rsp]
  00106	41 b8 86 01 00
	00		 mov	 r8d, 390		; 00000186H
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09CGFMFLFL@list_repr?$AA@
  0011a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0011f	85 c0		 test	 eax, eax
  00121	75 1d		 jne	 SHORT $LN26@list_repr
  00123	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00128	48 89 44 24 50	 mov	 QWORD PTR _py_tmp$20595[rsp], rax
  0012d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR s$[rsp], 0
  00136	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _py_tmp$20595[rsp]
  0013b	e8 00 00 00 00	 call	 _Py_DecRef
$LN26@list_repr:
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 ab		 jne	 SHORT $LN29@list_repr

; 391  : 
; 392  :     /* Do repr() on each element.  Note that this may mutate the list,
; 393  :        so must refetch the list size on each iteration. */
; 394  :     for (i = 0; i < Py_SIZE(v); ++i) {

  00146	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0014f	eb 0d		 jmp	 SHORT $LN25@list_repr
$LN24@list_repr:
  00151	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00156	48 ff c0	 inc	 rax
  00159	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN25@list_repr:
  0015e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00166	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0016a	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0016f	0f 8d 6b 01 00
	00		 jge	 $LN23@list_repr

; 395  :         if (Py_EnterRecursiveCall(" while getting the repr of a list"))

  00175	e8 00 00 00 00	 call	 PyThreadState_Get
  0017a	48 83 c0 18	 add	 rax, 24
  0017e	48 89 44 24 70	 mov	 QWORD PTR tv137[rsp], rax
  00183	48 8b 44 24 70	 mov	 rax, QWORD PTR tv137[rsp]
  00188	8b 00		 mov	 eax, DWORD PTR [rax]
  0018a	ff c0		 inc	 eax
  0018c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv137[rsp]
  00191	89 01		 mov	 DWORD PTR [rcx], eax
  00193	48 8b 44 24 70	 mov	 rax, QWORD PTR tv137[rsp]
  00198	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  0019e	39 08		 cmp	 DWORD PTR [rax], ecx
  001a0	7e 15		 jle	 SHORT $LN22@list_repr
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@LCJMBFL@?5while?5getting?5the?5repr?5of?5a?5lis@
  001a9	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  001ae	85 c0		 test	 eax, eax
  001b0	74 05		 je	 SHORT $LN22@list_repr

; 396  :             goto error;

  001b2	e9 c5 01 00 00	 jmp	 $error$20585
$LN22@list_repr:

; 397  :         s = PyObject_Repr(v->ob_item[i]);

  001b7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  001bf	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  001c8	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  001cc	e8 00 00 00 00	 call	 PyObject_Repr
  001d1	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax
$LN21@list_repr:

; 398  :         Py_LeaveRecursiveCall();

  001d6	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  001dd	7e 0f		 jle	 SHORT $LN41@list_repr
  001df	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  001e5	83 e8 32	 sub	 eax, 50			; 00000032H
  001e8	89 44 24 78	 mov	 DWORD PTR tv156[rsp], eax
  001ec	eb 10		 jmp	 SHORT $LN42@list_repr
$LN41@list_repr:
  001ee	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  001f4	c1 f8 02	 sar	 eax, 2
  001f7	6b c0 03	 imul	 eax, 3
  001fa	89 44 24 78	 mov	 DWORD PTR tv156[rsp], eax
$LN42@list_repr:
  001fe	e8 00 00 00 00	 call	 PyThreadState_Get
  00203	48 83 c0 18	 add	 rax, 24
  00207	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  0020f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv150[rsp]
  00217	8b 00		 mov	 eax, DWORD PTR [rax]
  00219	ff c8		 dec	 eax
  0021b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv150[rsp]
  00223	89 01		 mov	 DWORD PTR [rcx], eax
  00225	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv150[rsp]
  0022d	8b 4c 24 78	 mov	 ecx, DWORD PTR tv156[rsp]
  00231	39 08		 cmp	 DWORD PTR [rax], ecx
  00233	7d 09		 jge	 SHORT $LN18@list_repr
  00235	e8 00 00 00 00	 call	 PyThreadState_Get
  0023a	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN18@list_repr:
  0023e	33 c0		 xor	 eax, eax
  00240	85 c0		 test	 eax, eax
  00242	75 92		 jne	 SHORT $LN21@list_repr

; 399  :         if (i > 0 && _PyAccu_Accumulate(&acc, sep))

  00244	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  0024a	7e 1a		 jle	 SHORT $LN17@list_repr
  0024c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?sep@?1??list_repr@@9@9
  00253	48 8d 4c 24 40	 lea	 rcx, QWORD PTR acc$[rsp]
  00258	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  0025d	85 c0		 test	 eax, eax
  0025f	74 05		 je	 SHORT $LN17@list_repr

; 400  :             goto error;

  00261	e9 16 01 00 00	 jmp	 $error$20585
$LN17@list_repr:

; 401  :         if (s == NULL || _PyAccu_Accumulate(&acc, s))

  00266	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  0026c	74 13		 je	 SHORT $LN15@list_repr
  0026e	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$[rsp]
  00273	48 8d 4c 24 40	 lea	 rcx, QWORD PTR acc$[rsp]
  00278	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  0027d	85 c0		 test	 eax, eax
  0027f	74 05		 je	 SHORT $LN16@list_repr
$LN15@list_repr:

; 402  :             goto error;

  00281	e9 f6 00 00 00	 jmp	 $error$20585
$LN16@list_repr:
$LN14@list_repr:

; 403  :         Py_CLEAR(s);

  00286	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  0028c	74 47		 je	 SHORT $LN11@list_repr
  0028e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00296	4c 8b 4c 24 38	 mov	 r9, QWORD PTR s$[rsp]
  0029b	41 b8 93 01 00
	00		 mov	 r8d, 403		; 00000193H
  002a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09CGFMFLFL@list_repr?$AA@
  002af	e8 00 00 00 00	 call	 _PyParallel_Guard
  002b4	85 c0		 test	 eax, eax
  002b6	75 1d		 jne	 SHORT $LN11@list_repr
  002b8	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  002bd	48 89 44 24 58	 mov	 QWORD PTR _py_tmp$20617[rsp], rax
  002c2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR s$[rsp], 0
  002cb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _py_tmp$20617[rsp]
  002d0	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@list_repr:
  002d5	33 c0		 xor	 eax, eax
  002d7	85 c0		 test	 eax, eax
  002d9	75 ab		 jne	 SHORT $LN14@list_repr

; 404  :     }

  002db	e9 71 fe ff ff	 jmp	 $LN24@list_repr
$LN23@list_repr:

; 405  :     s = PyUnicode_FromString("]");

  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN?$AA@
  002e7	e8 00 00 00 00	 call	 PyUnicode_FromString
  002ec	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 406  :     if (s == NULL || _PyAccu_Accumulate(&acc, s))

  002f1	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  002f7	74 13		 je	 SHORT $LN9@list_repr
  002f9	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$[rsp]
  002fe	48 8d 4c 24 40	 lea	 rcx, QWORD PTR acc$[rsp]
  00303	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  00308	85 c0		 test	 eax, eax
  0030a	74 02		 je	 SHORT $LN10@list_repr
$LN9@list_repr:

; 407  :         goto error;

  0030c	eb 6e		 jmp	 SHORT $error$20585
$LN10@list_repr:
$LN8@list_repr:

; 408  :     Py_CLEAR(s);

  0030e	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  00314	74 47		 je	 SHORT $LN5@list_repr
  00316	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0031e	4c 8b 4c 24 38	 mov	 r9, QWORD PTR s$[rsp]
  00323	41 b8 98 01 00
	00		 mov	 r8d, 408		; 00000198H
  00329	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00330	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09CGFMFLFL@list_repr?$AA@
  00337	e8 00 00 00 00	 call	 _PyParallel_Guard
  0033c	85 c0		 test	 eax, eax
  0033e	75 1d		 jne	 SHORT $LN5@list_repr
  00340	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00345	48 89 44 24 60	 mov	 QWORD PTR _py_tmp$20629[rsp], rax
  0034a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR s$[rsp], 0
  00353	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _py_tmp$20629[rsp]
  00358	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@list_repr:
  0035d	33 c0		 xor	 eax, eax
  0035f	85 c0		 test	 eax, eax
  00361	75 ab		 jne	 SHORT $LN8@list_repr

; 409  : 
; 410  :     Py_ReprLeave((PyObject *)v);

  00363	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0036b	e8 00 00 00 00	 call	 Py_ReprLeave

; 411  :     return _PyAccu_Finish(&acc);

  00370	48 8d 4c 24 40	 lea	 rcx, QWORD PTR acc$[rsp]
  00375	e8 00 00 00 00	 call	 _PyAccu_Finish
  0037a	eb 31		 jmp	 SHORT $LN37@list_repr
$error$20585:

; 412  : 
; 413  : error:
; 414  :     _PyAccu_Destroy(&acc);

  0037c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR acc$[rsp]
  00381	e8 00 00 00 00	 call	 _PyAccu_Destroy
$LN4@list_repr:

; 415  :     Py_XDECREF(s);

  00386	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  0038c	74 0a		 je	 SHORT $LN1@list_repr
  0038e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00393	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@list_repr:
  00398	33 c0		 xor	 eax, eax
  0039a	85 c0		 test	 eax, eax
  0039c	75 e8		 jne	 SHORT $LN4@list_repr

; 416  :     Py_ReprLeave((PyObject *)v);

  0039e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  003a6	e8 00 00 00 00	 call	 Py_ReprLeave

; 417  :     return NULL;

  003ab	33 c0		 xor	 eax, eax
$LN37@list_repr:

; 418  : }

  003ad	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  003b4	c3		 ret	 0
list_repr ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT list_length
_TEXT	SEGMENT
a$ = 8
list_length PROC					; COMDAT

; 422  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 423  :     return Py_SIZE(a);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR a$[rsp]
  0000a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]

; 424  : }

  0000e	c3		 ret	 0
list_length ENDP
_TEXT	ENDS
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_contains DD imagerel list_contains
	DD	imagerel list_contains+118
	DD	imagerel $unwind$list_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_contains DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_contains
_TEXT	SEGMENT
i$ = 32
cmp$ = 40
a$ = 64
el$ = 72
list_contains PROC					; COMDAT

; 428  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 429  :     Py_ssize_t i;
; 430  :     int cmp;
; 431  : 
; 432  :     for (i = 0, cmp = 0 ; cmp == 0 && i < Py_SIZE(a); ++i)

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR cmp$[rsp], 0
  0001f	eb 0d		 jmp	 SHORT $LN3@list_conta
$LN2@list_conta:
  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00026	48 ff c0	 inc	 rax
  00029	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@list_conta:
  0002e	83 7c 24 28 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00033	75 38		 jne	 SHORT $LN1@list_conta
  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0003a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003e	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00043	7d 28		 jge	 SHORT $LN1@list_conta

; 433  :         cmp = PyObject_RichCompareBool(el, PyList_GET_ITEM(a, i),
; 434  :                                            Py_EQ);

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0004a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0004e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00059	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  0005d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR el$[rsp]
  00062	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00067	89 44 24 28	 mov	 DWORD PTR cmp$[rsp], eax
  0006b	eb b4		 jmp	 SHORT $LN2@list_conta
$LN1@list_conta:

; 435  :     return cmp;

  0006d	8b 44 24 28	 mov	 eax, DWORD PTR cmp$[rsp]

; 436  : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
list_contains ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_item DD imagerel list_item
	DD	imagerel list_item+150
	DD	imagerel $unwind$list_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_item DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_item
_TEXT	SEGMENT
a$ = 48
i$ = 56
list_item PROC						; COMDAT

; 440  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 441  :     if (i < 0 || i >= Py_SIZE(a)) {

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  00014	7c 10		 jl	 SHORT $LN3@list_item
  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0001b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001f	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00024	7c 42		 jl	 SHORT $LN4@list_item
$LN3@list_item:

; 442  :         if (indexerr == NULL) {

  00026	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR indexerr, 0
  0002e	75 21		 jne	 SHORT $LN2@list_item

; 443  :             indexerr = PyUnicode_FromString(
; 444  :                 "list index out of range");

  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PPFNPBPL@list?5index?5out?5of?5range?$AA@
  00037	e8 00 00 00 00	 call	 PyUnicode_FromString
  0003c	48 89 05 00 00
	00 00		 mov	 QWORD PTR indexerr, rax

; 445  :             if (indexerr == NULL)

  00043	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR indexerr, 0
  0004b	75 04		 jne	 SHORT $LN1@list_item

; 446  :                 return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 40		 jmp	 SHORT $LN5@list_item
$LN1@list_item:
$LN2@list_item:

; 447  :         }
; 448  :         PyErr_SetObject(PyExc_IndexError, indexerr);

  00051	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR indexerr
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0005f	e8 00 00 00 00	 call	 PyErr_SetObject

; 449  :         return NULL;

  00064	33 c0		 xor	 eax, eax
  00066	eb 29		 jmp	 SHORT $LN5@list_item
$LN4@list_item:

; 450  :     }
; 451  :     Py_INCREF(a->ob_item[i]);

  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0006d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00076	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0007a	e8 00 00 00 00	 call	 _Py_IncRef

; 452  :     return a->ob_item[i];

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00084	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0008d	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
$LN5@list_item:

; 453  : }

  00091	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00095	c3		 ret	 0
list_item ENDP
_TEXT	ENDS
PUBLIC	PyList_GetSlice
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_GetSlice DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$PyList_GetSlice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_GetSlice DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyList_GetSlice
_TEXT	SEGMENT
a$ = 48
ilow$ = 56
ihigh$ = 64
PyList_GetSlice PROC					; COMDAT

; 486  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 487  :     if (!PyList_Check(a)) {

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00027	85 c0		 test	 eax, eax
  00029	75 15		 jne	 SHORT $LN1@PyList_Get@2

; 488  :         PyErr_BadInternalCall();

  0002b	ba e8 01 00 00	 mov	 edx, 488		; 000001e8H
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00037	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 489  :         return NULL;

  0003c	33 c0		 xor	 eax, eax
  0003e	eb 14		 jmp	 SHORT $LN2@PyList_Get@2
$LN1@PyList_Get@2:

; 490  :     }
; 491  :     return list_slice((PyListObject *)a, ilow, ihigh);

  00040	4c 8b 44 24 40	 mov	 r8, QWORD PTR ihigh$[rsp]
  00045	48 8b 54 24 38	 mov	 rdx, QWORD PTR ilow$[rsp]
  0004a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  0004f	e8 00 00 00 00	 call	 list_slice
$LN2@PyList_Get@2:

; 492  : }

  00054	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00058	c3		 ret	 0
PyList_GetSlice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_slice DD imagerel list_slice
	DD	imagerel list_slice+306
	DD	imagerel $unwind$list_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_slice DD 011301H
	DD	0a213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_slice
_TEXT	SEGMENT
i$ = 32
dest$ = 40
len$ = 48
src$ = 56
np$ = 64
v$20705 = 72
a$ = 96
ilow$ = 104
ihigh$ = 112
list_slice PROC						; COMDAT

; 457  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 458  :     PyListObject *np;
; 459  :     PyObject **src, **dest;
; 460  :     Py_ssize_t i, len;
; 461  :     if (ilow < 0)

  00013	48 83 7c 24 68
	00		 cmp	 QWORD PTR ilow$[rsp], 0
  00019	7d 0b		 jge	 SHORT $LN10@list_slice

; 462  :         ilow = 0;

  0001b	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR ilow$[rsp], 0
  00024	eb 1e		 jmp	 SHORT $LN9@list_slice
$LN10@list_slice:

; 463  :     else if (ilow > Py_SIZE(a))

  00026	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0002b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002f	48 39 44 24 68	 cmp	 QWORD PTR ilow$[rsp], rax
  00034	7e 0e		 jle	 SHORT $LN8@list_slice

; 464  :         ilow = Py_SIZE(a);

  00036	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0003b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003f	48 89 44 24 68	 mov	 QWORD PTR ilow$[rsp], rax
$LN8@list_slice:
$LN9@list_slice:

; 465  :     if (ihigh < ilow)

  00044	48 8b 44 24 68	 mov	 rax, QWORD PTR ilow$[rsp]
  00049	48 39 44 24 70	 cmp	 QWORD PTR ihigh$[rsp], rax
  0004e	7d 0c		 jge	 SHORT $LN7@list_slice

; 466  :         ihigh = ilow;

  00050	48 8b 44 24 68	 mov	 rax, QWORD PTR ilow$[rsp]
  00055	48 89 44 24 70	 mov	 QWORD PTR ihigh$[rsp], rax
  0005a	eb 1e		 jmp	 SHORT $LN6@list_slice
$LN7@list_slice:

; 467  :     else if (ihigh > Py_SIZE(a))

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00061	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00065	48 39 44 24 70	 cmp	 QWORD PTR ihigh$[rsp], rax
  0006a	7e 0e		 jle	 SHORT $LN5@list_slice

; 468  :         ihigh = Py_SIZE(a);

  0006c	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00071	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00075	48 89 44 24 70	 mov	 QWORD PTR ihigh$[rsp], rax
$LN5@list_slice:
$LN6@list_slice:

; 469  :     len = ihigh - ilow;

  0007a	48 8b 44 24 68	 mov	 rax, QWORD PTR ilow$[rsp]
  0007f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ihigh$[rsp]
  00084	48 2b c8	 sub	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 470  :     np = (PyListObject *) PyList_New(len);

  0008f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR len$[rsp]
  00094	e8 00 00 00 00	 call	 PyList_New
  00099	48 89 44 24 40	 mov	 QWORD PTR np$[rsp], rax

; 471  :     if (np == NULL)

  0009e	48 83 7c 24 40
	00		 cmp	 QWORD PTR np$[rsp], 0
  000a4	75 07		 jne	 SHORT $LN4@list_slice

; 472  :         return NULL;

  000a6	33 c0		 xor	 eax, eax
  000a8	e9 80 00 00 00	 jmp	 $LN11@list_slice
$LN4@list_slice:

; 473  : 
; 474  :     src = a->ob_item + ilow;

  000ad	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  000b2	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ilow$[rsp]
  000bb	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  000bf	48 89 44 24 38	 mov	 QWORD PTR src$[rsp], rax

; 475  :     dest = np->ob_item;

  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR np$[rsp]
  000c9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000cd	48 89 44 24 28	 mov	 QWORD PTR dest$[rsp], rax

; 476  :     for (i = 0; i < len; i++) {

  000d2	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000db	eb 0d		 jmp	 SHORT $LN3@list_slice
$LN2@list_slice:
  000dd	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000e2	48 ff c0	 inc	 rax
  000e5	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@list_slice:
  000ea	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  000ef	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000f4	7d 32		 jge	 SHORT $LN1@list_slice

; 477  :         PyObject *v = src[i];

  000f6	48 8b 44 24 38	 mov	 rax, QWORD PTR src$[rsp]
  000fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00100	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00104	48 89 44 24 48	 mov	 QWORD PTR v$20705[rsp], rax

; 478  :         Py_INCREF(v);

  00109	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$20705[rsp]
  0010e	e8 00 00 00 00	 call	 _Py_IncRef

; 479  :         dest[i] = v;

  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$[rsp]
  00118	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0011d	48 8b 54 24 48	 mov	 rdx, QWORD PTR v$20705[rsp]
  00122	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 480  :     }

  00126	eb b5		 jmp	 SHORT $LN2@list_slice
$LN1@list_slice:

; 481  :     return (PyObject *)np;

  00128	48 8b 44 24 40	 mov	 rax, QWORD PTR np$[rsp]
$LN11@list_slice:

; 482  : }

  0012d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00131	c3		 ret	 0
list_slice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@BIAFAIAC@can?5only?5concatenate?5list?5?$CInot?5?$CC@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_concat DD imagerel list_concat
	DD	imagerel list_concat+407
	DD	imagerel $unwind$list_concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_concat DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0DB@BIAFAIAC@can?5only?5concatenate?5list?5?$CInot?5?$CC@
CONST	SEGMENT
??_C@_0DB@BIAFAIAC@can?5only?5concatenate?5list?5?$CInot?5?$CC@ DB 'can o'
	DB	'nly concatenate list (not "%.200s") to list', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT list_concat
_TEXT	SEGMENT
i$ = 32
dest$ = 40
size$ = 48
np$ = 56
src$ = 64
v$20747 = 72
v$20756 = 80
a$ = 112
bb$ = 120
list_concat PROC					; COMDAT

; 496  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 497  :     Py_ssize_t size;
; 498  :     Py_ssize_t i;
; 499  :     PyObject **src, **dest;
; 500  :     PyListObject *np;
; 501  :     if (!PyList_Check(bb)) {

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR bb$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00022	85 c0		 test	 eax, eax
  00024	75 27		 jne	 SHORT $LN9@list_conca

; 502  :         PyErr_Format(PyExc_TypeError,
; 503  :                   "can only concatenate list (not \"%.200s\") to list",
; 504  :                   bb->ob_type->tp_name);

  00026	48 8b 44 24 78	 mov	 rax, QWORD PTR bb$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@BIAFAIAC@can?5only?5concatenate?5list?5?$CInot?5?$CC@
  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00041	e8 00 00 00 00	 call	 PyErr_Format

; 505  :         return NULL;

  00046	33 c0		 xor	 eax, eax
  00048	e9 45 01 00 00	 jmp	 $LN10@list_conca
$LN9@list_conca:

; 506  :     }
; 507  : #define b ((PyListObject *)bb)
; 508  :     size = Py_SIZE(a) + Py_SIZE(b);

  0004d	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00052	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00056	48 8b 4c 24 78	 mov	 rcx, QWORD PTR bb$[rsp]
  0005b	48 03 41 60	 add	 rax, QWORD PTR [rcx+96]
  0005f	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 509  :     if (size < 0)

  00064	48 83 7c 24 30
	00		 cmp	 QWORD PTR size$[rsp], 0
  0006a	7d 0a		 jge	 SHORT $LN8@list_conca

; 510  :         return PyErr_NoMemory();

  0006c	e8 00 00 00 00	 call	 PyErr_NoMemory
  00071	e9 1c 01 00 00	 jmp	 $LN10@list_conca
$LN8@list_conca:

; 511  :     np = (PyListObject *) PyList_New(size);

  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$[rsp]
  0007b	e8 00 00 00 00	 call	 PyList_New
  00080	48 89 44 24 38	 mov	 QWORD PTR np$[rsp], rax

; 512  :     if (np == NULL) {

  00085	48 83 7c 24 38
	00		 cmp	 QWORD PTR np$[rsp], 0
  0008b	75 07		 jne	 SHORT $LN7@list_conca

; 513  :         return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	e9 fe 00 00 00	 jmp	 $LN10@list_conca
$LN7@list_conca:

; 514  :     }
; 515  :     src = a->ob_item;

  00094	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00099	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0009d	48 89 44 24 40	 mov	 QWORD PTR src$[rsp], rax

; 516  :     dest = np->ob_item;

  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR np$[rsp]
  000a7	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000ab	48 89 44 24 28	 mov	 QWORD PTR dest$[rsp], rax

; 517  :     for (i = 0; i < Py_SIZE(a); i++) {

  000b0	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000b9	eb 0d		 jmp	 SHORT $LN6@list_conca
$LN5@list_conca:
  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000c0	48 ff c0	 inc	 rax
  000c3	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@list_conca:
  000c8	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  000cd	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d1	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000d6	7d 32		 jge	 SHORT $LN4@list_conca

; 518  :         PyObject *v = src[i];

  000d8	48 8b 44 24 40	 mov	 rax, QWORD PTR src$[rsp]
  000dd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000e2	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000e6	48 89 44 24 48	 mov	 QWORD PTR v$20747[rsp], rax

; 519  :         Py_INCREF(v);

  000eb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$20747[rsp]
  000f0	e8 00 00 00 00	 call	 _Py_IncRef

; 520  :         dest[i] = v;

  000f5	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$[rsp]
  000fa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000ff	48 8b 54 24 48	 mov	 rdx, QWORD PTR v$20747[rsp]
  00104	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 521  :     }

  00108	eb b1		 jmp	 SHORT $LN5@list_conca
$LN4@list_conca:

; 522  :     src = b->ob_item;

  0010a	48 8b 44 24 78	 mov	 rax, QWORD PTR bb$[rsp]
  0010f	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00113	48 89 44 24 40	 mov	 QWORD PTR src$[rsp], rax

; 523  :     dest = np->ob_item + Py_SIZE(a);

  00118	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  0011d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00121	48 8b 4c 24 38	 mov	 rcx, QWORD PTR np$[rsp]
  00126	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0012a	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0012e	48 89 44 24 28	 mov	 QWORD PTR dest$[rsp], rax

; 524  :     for (i = 0; i < Py_SIZE(b); i++) {

  00133	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0013c	eb 0d		 jmp	 SHORT $LN3@list_conca
$LN2@list_conca:
  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00143	48 ff c0	 inc	 rax
  00146	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@list_conca:
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR bb$[rsp]
  00150	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00154	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00159	7d 32		 jge	 SHORT $LN1@list_conca

; 525  :         PyObject *v = src[i];

  0015b	48 8b 44 24 40	 mov	 rax, QWORD PTR src$[rsp]
  00160	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00165	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00169	48 89 44 24 50	 mov	 QWORD PTR v$20756[rsp], rax

; 526  :         Py_INCREF(v);

  0016e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$20756[rsp]
  00173	e8 00 00 00 00	 call	 _Py_IncRef

; 527  :         dest[i] = v;

  00178	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$[rsp]
  0017d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00182	48 8b 54 24 50	 mov	 rdx, QWORD PTR v$20756[rsp]
  00187	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 528  :     }

  0018b	eb b1		 jmp	 SHORT $LN2@list_conca
$LN1@list_conca:

; 529  :     return (PyObject *)np;

  0018d	48 8b 44 24 38	 mov	 rax, QWORD PTR np$[rsp]
$LN10@list_conca:

; 530  : #undef b
; 531  : }

  00192	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00196	c3		 ret	 0
list_concat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_repeat DD imagerel list_repeat
	DD	imagerel list_repeat+434
	DD	imagerel $unwind$list_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_repeat DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_repeat
_TEXT	SEGMENT
p$ = 32
elem$ = 40
i$ = 48
size$ = 56
items$ = 64
np$ = 72
j$ = 80
a$ = 112
n$ = 120
list_repeat PROC					; COMDAT

; 535  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 536  :     Py_ssize_t i, j;
; 537  :     Py_ssize_t size;
; 538  :     PyListObject *np;
; 539  :     PyObject **p, **items;
; 540  :     PyObject *elem;
; 541  :     if (n < 0)

  0000e	48 83 7c 24 78
	00		 cmp	 QWORD PTR n$[rsp], 0
  00014	7d 09		 jge	 SHORT $LN14@list_repea

; 542  :         n = 0;

  00016	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0
$LN14@list_repea:

; 543  :     if (n > 0 && Py_SIZE(a) > PY_SSIZE_T_MAX / n)

  0001f	48 83 7c 24 78
	00		 cmp	 QWORD PTR n$[rsp], 0
  00025	7e 26		 jle	 SHORT $LN13@list_repea
  00027	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00031	48 99		 cdq
  00033	48 f7 7c 24 78	 idiv	 QWORD PTR n$[rsp]
  00038	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a$[rsp]
  0003d	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00041	7e 0a		 jle	 SHORT $LN13@list_repea

; 544  :         return PyErr_NoMemory();

  00043	e8 00 00 00 00	 call	 PyErr_NoMemory
  00048	e9 60 01 00 00	 jmp	 $LN15@list_repea
$LN13@list_repea:

; 545  :     size = Py_SIZE(a) * n;

  0004d	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00052	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00056	48 0f af 44 24
	78		 imul	 rax, QWORD PTR n$[rsp]
  0005c	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax

; 546  :     if (size == 0)

  00061	48 83 7c 24 38
	00		 cmp	 QWORD PTR size$[rsp], 0
  00067	75 0c		 jne	 SHORT $LN12@list_repea

; 547  :         return PyList_New(0);

  00069	33 c9		 xor	 ecx, ecx
  0006b	e8 00 00 00 00	 call	 PyList_New
  00070	e9 38 01 00 00	 jmp	 $LN15@list_repea
$LN12@list_repea:

; 548  :     np = (PyListObject *) PyList_New(size);

  00075	48 8b 4c 24 38	 mov	 rcx, QWORD PTR size$[rsp]
  0007a	e8 00 00 00 00	 call	 PyList_New
  0007f	48 89 44 24 48	 mov	 QWORD PTR np$[rsp], rax

; 549  :     if (np == NULL)

  00084	48 83 7c 24 48
	00		 cmp	 QWORD PTR np$[rsp], 0
  0008a	75 07		 jne	 SHORT $LN11@list_repea

; 550  :         return NULL;

  0008c	33 c0		 xor	 eax, eax
  0008e	e9 1a 01 00 00	 jmp	 $LN15@list_repea
$LN11@list_repea:

; 551  : 
; 552  :     items = np->ob_item;

  00093	48 8b 44 24 48	 mov	 rax, QWORD PTR np$[rsp]
  00098	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0009c	48 89 44 24 40	 mov	 QWORD PTR items$[rsp], rax

; 553  :     if (Py_SIZE(a) == 1) {

  000a1	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  000a6	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  000ab	75 5e		 jne	 SHORT $LN10@list_repea

; 554  :         elem = a->ob_item[0];

  000ad	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  000b2	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b9	48 89 44 24 28	 mov	 QWORD PTR elem$[rsp], rax

; 555  :         for (i = 0; i < n; i++) {

  000be	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000c7	eb 0d		 jmp	 SHORT $LN9@list_repea
$LN8@list_repea:
  000c9	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000ce	48 ff c0	 inc	 rax
  000d1	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN9@list_repea:
  000d6	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000db	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  000e0	7d 1f		 jge	 SHORT $LN7@list_repea

; 556  :             items[i] = elem;

  000e2	48 8b 44 24 40	 mov	 rax, QWORD PTR items$[rsp]
  000e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  000ec	48 8b 54 24 28	 mov	 rdx, QWORD PTR elem$[rsp]
  000f1	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 557  :             Py_INCREF(elem);

  000f5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  000fa	e8 00 00 00 00	 call	 _Py_IncRef

; 558  :         }

  000ff	eb c8		 jmp	 SHORT $LN8@list_repea
$LN7@list_repea:

; 559  :         return (PyObject *) np;

  00101	48 8b 44 24 48	 mov	 rax, QWORD PTR np$[rsp]
  00106	e9 a2 00 00 00	 jmp	 $LN15@list_repea
$LN10@list_repea:

; 560  :     }
; 561  :     p = np->ob_item;

  0010b	48 8b 44 24 48	 mov	 rax, QWORD PTR np$[rsp]
  00110	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00114	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 562  :     items = a->ob_item;

  00119	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  0011e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00122	48 89 44 24 40	 mov	 QWORD PTR items$[rsp], rax

; 563  :     for (i = 0; i < n; i++) {

  00127	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00130	eb 0d		 jmp	 SHORT $LN6@list_repea
$LN5@list_repea:
  00132	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00137	48 ff c0	 inc	 rax
  0013a	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN6@list_repea:
  0013f	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00144	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00149	7d 5d		 jge	 SHORT $LN4@list_repea

; 564  :         for (j = 0; j < Py_SIZE(a); j++) {

  0014b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00154	eb 0d		 jmp	 SHORT $LN3@list_repea
$LN2@list_repea:
  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0015b	48 ff c0	 inc	 rax
  0015e	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax
$LN3@list_repea:
  00163	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00168	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0016c	48 39 44 24 50	 cmp	 QWORD PTR j$[rsp], rax
  00171	7d 33		 jge	 SHORT $LN1@list_repea

; 565  :             *p = items[j];

  00173	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00178	48 8b 4c 24 40	 mov	 rcx, QWORD PTR items$[rsp]
  0017d	48 8b 54 24 50	 mov	 rdx, QWORD PTR j$[rsp]
  00182	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00186	48 89 08	 mov	 QWORD PTR [rax], rcx

; 566  :             Py_INCREF(*p);

  00189	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0018e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00191	e8 00 00 00 00	 call	 _Py_IncRef

; 567  :             p++;

  00196	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0019b	48 83 c0 08	 add	 rax, 8
  0019f	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 568  :         }

  001a4	eb b0		 jmp	 SHORT $LN2@list_repea
$LN1@list_repea:

; 569  :     }

  001a6	eb 8a		 jmp	 SHORT $LN5@list_repea
$LN4@list_repea:

; 570  :     return (PyObject *) np;

  001a8	48 8b 44 24 48	 mov	 rax, QWORD PTR np$[rsp]
$LN15@list_repea:

; 571  : }

  001ad	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001b1	c3		 ret	 0
list_repeat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_clear DD imagerel list_clear
	DD	imagerel list_clear+207
	DD	imagerel $unwind$list_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_clear DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_clear
_TEXT	SEGMENT
i$ = 32
item$ = 40
tv83 = 48
a$ = 80
list_clear PROC						; COMDAT

; 575  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 576  :     Py_ssize_t i;
; 577  :     PyObject **item = a->ob_item;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0000e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00012	48 89 44 24 28	 mov	 QWORD PTR item$[rsp], rax

; 578  :     if (item != NULL) {

  00017	48 83 7c 24 28
	00		 cmp	 QWORD PTR item$[rsp], 0
  0001d	0f 84 a5 00 00
	00		 je	 $LN7@list_clear

; 579  :         /* Because XDECREF can recursively invoke operations on
; 580  :            this list, we make it empty first. */
; 581  :         i = Py_SIZE(a);

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00028	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002c	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 582  :         Py_SIZE(a) = 0;

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00036	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 583  :         a->ob_item = NULL;

  0003e	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00043	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 584  :         a->allocated = 0;

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00050	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
$LN6@list_clear:

; 585  :         while (--i >= 0) {

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0005d	48 ff c8	 dec	 rax
  00060	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0006b	7c 2c		 jl	 SHORT $LN5@list_clear
$LN4@list_clear:

; 586  :             Py_XDECREF(item[i]);

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR item$[rsp]
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00077	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  0007c	74 13		 je	 SHORT $LN1@list_clear
  0007e	48 8b 44 24 28	 mov	 rax, QWORD PTR item$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00088	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0008c	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@list_clear:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 d6		 jne	 SHORT $LN4@list_clear

; 587  :         }

  00097	eb bf		 jmp	 SHORT $LN6@list_clear
$LN5@list_clear:

; 588  :         PyMem_FREE(item);

  00099	e8 00 00 00 00	 call	 _Py_PXCTX
  0009e	85 c0		 test	 eax, eax
  000a0	74 14		 je	 SHORT $LN10@list_clear
  000a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR item$[rsp]
  000a7	e8 00 00 00 00	 call	 _PxMem_Free
  000ac	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  000b4	eb 12		 jmp	 SHORT $LN11@list_clear
$LN10@list_clear:
  000b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR item$[rsp]
  000bb	e8 00 00 00 00	 call	 _PyMem_DebugFree
  000c0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN11@list_clear:
$LN7@list_clear:

; 589  :     }
; 590  :     /* Never fails; the return value can be ignored.
; 591  :        Note that there is no guarantee that the list is actually empty
; 592  :        at this point, because XDECREF may have populated it again! */
; 593  :     return 0;

  000c8	33 c0		 xor	 eax, eax

; 594  : }

  000ca	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ce	c3		 ret	 0
list_clear ENDP
_TEXT	ENDS
PUBLIC	PyList_SetSlice
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_SetSlice DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$PyList_SetSlice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_SetSlice DD 011801H
	DD	04218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyList_SetSlice
_TEXT	SEGMENT
a$ = 48
ilow$ = 56
ihigh$ = 64
v$ = 72
PyList_SetSlice PROC					; COMDAT

; 710  : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 711  :     if (!PyList_Check(a)) {

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00027	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0002c	85 c0		 test	 eax, eax
  0002e	75 18		 jne	 SHORT $LN1@PyList_Set@2

; 712  :         PyErr_BadInternalCall();

  00030	ba c8 02 00 00	 mov	 edx, 712		; 000002c8H
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0003c	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 713  :         return -1;

  00041	b8 ff ff ff ff	 mov	 eax, -1
  00046	eb 19		 jmp	 SHORT $LN2@PyList_Set@2
$LN1@PyList_Set@2:

; 714  :     }
; 715  : 
; 716  :     /* Px_CHECK_PROTECTION handled by list_ass_slice(). */
; 717  :     return list_ass_slice((PyListObject *)a, ilow, ihigh, v);

  00048	4c 8b 4c 24 48	 mov	 r9, QWORD PTR v$[rsp]
  0004d	4c 8b 44 24 40	 mov	 r8, QWORD PTR ihigh$[rsp]
  00052	48 8b 54 24 38	 mov	 rdx, QWORD PTR ilow$[rsp]
  00057	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  0005c	e8 00 00 00 00	 call	 list_ass_slice
$LN2@PyList_Set@2:

; 718  : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
PyList_SetSlice ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BG@MLPMIIJE@?$AAn?$AAo?$AAr?$AAi?$AAg?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BM@INPHMALO@can?5only?5assign?5an?5iterable?$AA@ ; `string'
PUBLIC	??_C@_0EF@DGJDNGLM@parallel?5thread?5attempted?5to?5ass@ ; `string'
EXTRN	__imp_memmove:PROC
EXTRN	memcpy:PROC
EXTRN	PySequence_Fast:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_ass_slice DD imagerel list_ass_slice
	DD	imagerel list_ass_slice+1773
	DD	imagerel $unwind$list_ass_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_ass_slice DD 021b01H
	DD	01f011bH
xdata	ENDS
;	COMDAT ??_C@_1BG@MLPMIIJE@?$AAn?$AAo?$AAr?$AAi?$AAg?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@MLPMIIJE@?$AAn?$AAo?$AAr?$AAi?$AAg?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 'o', 00H, 'r', 00H, 'i', 00H, 'g', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@INPHMALO@can?5only?5assign?5an?5iterable?$AA@
CONST	SEGMENT
??_C@_0BM@INPHMALO@can?5only?5assign?5an?5iterable?$AA@ DB 'can only assi'
	DB	'gn an iterable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DGJDNGLM@parallel?5thread?5attempted?5to?5ass@
CONST	SEGMENT
??_C@_0EF@DGJDNGLM@parallel?5thread?5attempted?5to?5ass@ DB 'parallel thr'
	DB	'ead attempted to assign to a slice of a main thread list', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT list_ass_slice
_TEXT	SEGMENT
vitem$ = 32
norig$ = 40
recycle_on_stack$ = 48
n$ = 112
s$ = 120
recycle$ = 128
k$ = 136
result$ = 144
d$ = 152
item$ = 160
v_as_SF$ = 168
w$20904 = 176
tv95 = 184
tv134 = 192
tv167 = 200
tv185 = 208
tv208 = 216
tv234 = 224
a$ = 256
ilow$ = 264
ihigh$ = 272
v$ = 280
list_ass_slice PROC					; COMDAT

; 604  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 605  :     /* Because [X]DECREF can recursively invoke list operations on
; 606  :        this list, we must postpone all [X]DECREF activity until
; 607  :        after the list is back in its canonical shape.  Therefore
; 608  :        we must allocate an additional array, 'recycle', into which
; 609  :        we temporarily copy the items that are deleted from the
; 610  :        list. :-( */
; 611  :     PyObject *recycle_on_stack[8];
; 612  :     PyObject **recycle = recycle_on_stack; /* will allocate more if needed */

  0001b	48 8d 44 24 30	 lea	 rax, QWORD PTR recycle_on_stack$[rsp]
  00020	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR recycle$[rsp], rax

; 613  :     PyObject **item;
; 614  :     PyObject **vitem = NULL;

  00028	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR vitem$[rsp], 0

; 615  :     PyObject *v_as_SF = NULL; /* PySequence_Fast(v) */

  00031	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR v_as_SF$[rsp], 0

; 616  :     Py_ssize_t n; /* # of elements in replacement list */
; 617  :     Py_ssize_t norig; /* # of elements in list getting replaced */
; 618  :     Py_ssize_t d; /* Change in size */
; 619  :     Py_ssize_t k;
; 620  :     size_t s;
; 621  :     int result = -1;            /* guilty until proved innocent */

  0003d	c7 84 24 90 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR result$[rsp], -1

; 622  : #ifdef WITH_PARALLEL
; 623  :     if (Py_PXCTX && Px_ISPY(a)) {

  00048	e8 00 00 00 00	 call	 _Py_PXCTX
  0004d	85 c0		 test	 eax, eax
  0004f	74 34		 je	 SHORT $LN42@list_ass_s
  00051	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00059	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0005d	48 83 e0 01	 and	 rax, 1
  00061	48 85 c0	 test	 rax, rax
  00064	74 1f		 je	 SHORT $LN42@list_ass_s

; 624  :         PyErr_SetString(PyExc_AssignmentError,
; 625  :                         "parallel thread attempted to assign to a slice "
; 626  :                         "of a main thread list");

  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@DGJDNGLM@parallel?5thread?5attempted?5to?5ass@
  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AssignmentError
  00074	e8 00 00 00 00	 call	 PyErr_SetString

; 627  :         return result;

  00079	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR result$[rsp]
  00080	e9 60 06 00 00	 jmp	 $LN43@list_ass_s
$LN42@list_ass_s:

; 628  :     }
; 629  : #endif
; 630  : #define b ((PyListObject *)v)
; 631  :     if (v == NULL)

  00085	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR v$[rsp], 0
  0008e	75 0e		 jne	 SHORT $LN41@list_ass_s

; 632  :         n = 0;

  00090	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0

; 633  :     else {

  00099	e9 61 01 00 00	 jmp	 $LN40@list_ass_s
$LN41@list_ass_s:

; 634  :         if (a == b) {

  0009e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  000a6	48 39 84 24 00
	01 00 00	 cmp	 QWORD PTR a$[rsp], rax
  000ae	75 7f		 jne	 SHORT $LN39@list_ass_s

; 635  :             /* Special case "a[i:j] = a" -- copy b first */
; 636  :             v = list_slice(b, 0, Py_SIZE(b));

  000b0	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  000b8	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  000bc	33 d2		 xor	 edx, edx
  000be	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  000c6	e8 00 00 00 00	 call	 list_slice
  000cb	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR v$[rsp], rax

; 637  :             if (v == NULL)

  000d3	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR v$[rsp], 0
  000dc	75 0c		 jne	 SHORT $LN38@list_ass_s

; 638  :                 return result;

  000de	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR result$[rsp]
  000e5	e9 fb 05 00 00	 jmp	 $LN43@list_ass_s
$LN38@list_ass_s:

; 639  :             result = list_ass_slice(a, ilow, ihigh, v);

  000ea	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR v$[rsp]
  000f2	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR ihigh$[rsp]
  000fa	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR ilow$[rsp]
  00102	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0010a	e8 00 00 00 00	 call	 list_ass_slice
  0010f	89 84 24 90 00
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 640  :             Py_DECREF(v);

  00116	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0011e	e8 00 00 00 00	 call	 _Py_DecRef

; 641  :             return result;

  00123	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR result$[rsp]
  0012a	e9 b6 05 00 00	 jmp	 $LN43@list_ass_s
$LN39@list_ass_s:

; 642  :         }
; 643  :         v_as_SF = PySequence_Fast(v, "can only assign an iterable");

  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@INPHMALO@can?5only?5assign?5an?5iterable?$AA@
  00136	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0013e	e8 00 00 00 00	 call	 PySequence_Fast
  00143	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR v_as_SF$[rsp], rax

; 644  :         if(v_as_SF == NULL)

  0014b	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR v_as_SF$[rsp], 0
  00154	75 05		 jne	 SHORT $LN37@list_ass_s

; 645  :             goto Error;

  00156	e9 1b 05 00 00	 jmp	 $Error$20859
$LN37@list_ass_s:

; 646  :         n = PySequence_Fast_GET_SIZE(v_as_SF);

  0015b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR v_as_SF$[rsp]
  00163	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00167	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0016d	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00172	85 c0		 test	 eax, eax
  00174	74 16		 je	 SHORT $LN45@list_ass_s
  00176	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR v_as_SF$[rsp]
  0017e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00182	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
  0018a	eb 14		 jmp	 SHORT $LN46@list_ass_s
$LN45@list_ass_s:
  0018c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR v_as_SF$[rsp]
  00194	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00198	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
$LN46@list_ass_s:
  001a0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv95[rsp]
  001a8	48 89 44 24 70	 mov	 QWORD PTR n$[rsp], rax

; 647  :         vitem = PySequence_Fast_ITEMS(v_as_SF);

  001ad	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR v_as_SF$[rsp]
  001b5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001b9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001bf	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  001c4	85 c0		 test	 eax, eax
  001c6	74 16		 je	 SHORT $LN47@list_ass_s
  001c8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR v_as_SF$[rsp]
  001d0	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001d4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv134[rsp], rax
  001dc	eb 14		 jmp	 SHORT $LN48@list_ass_s
$LN47@list_ass_s:
  001de	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR v_as_SF$[rsp]
  001e6	48 83 c0 70	 add	 rax, 112		; 00000070H
  001ea	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv134[rsp], rax
$LN48@list_ass_s:
  001f2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv134[rsp]
  001fa	48 89 44 24 20	 mov	 QWORD PTR vitem$[rsp], rax
$LN40@list_ass_s:

; 648  :     }
; 649  :     if (ilow < 0)

  001ff	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR ilow$[rsp], 0
  00208	7d 0e		 jge	 SHORT $LN36@list_ass_s

; 650  :         ilow = 0;

  0020a	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR ilow$[rsp], 0
  00216	eb 2a		 jmp	 SHORT $LN35@list_ass_s
$LN36@list_ass_s:

; 651  :     else if (ilow > Py_SIZE(a))

  00218	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00220	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00224	48 39 84 24 08
	01 00 00	 cmp	 QWORD PTR ilow$[rsp], rax
  0022c	7e 14		 jle	 SHORT $LN34@list_ass_s

; 652  :         ilow = Py_SIZE(a);

  0022e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00236	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0023a	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR ilow$[rsp], rax
$LN34@list_ass_s:
$LN35@list_ass_s:

; 653  : 
; 654  :     if (ihigh < ilow)

  00242	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR ilow$[rsp]
  0024a	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR ihigh$[rsp], rax
  00252	7d 12		 jge	 SHORT $LN33@list_ass_s

; 655  :         ihigh = ilow;

  00254	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR ilow$[rsp]
  0025c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR ihigh$[rsp], rax
  00264	eb 2a		 jmp	 SHORT $LN32@list_ass_s
$LN33@list_ass_s:

; 656  :     else if (ihigh > Py_SIZE(a))

  00266	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0026e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00272	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR ihigh$[rsp], rax
  0027a	7e 14		 jle	 SHORT $LN31@list_ass_s

; 657  :         ihigh = Py_SIZE(a);

  0027c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00284	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00288	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR ihigh$[rsp], rax
$LN31@list_ass_s:
$LN32@list_ass_s:

; 658  : 
; 659  :     norig = ihigh - ilow;

  00290	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR ilow$[rsp]
  00298	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ihigh$[rsp]
  002a0	48 2b c8	 sub	 rcx, rax
  002a3	48 8b c1	 mov	 rax, rcx
  002a6	48 89 44 24 28	 mov	 QWORD PTR norig$[rsp], rax

; 660  :     assert(norig >= 0);

  002ab	48 83 7c 24 28
	00		 cmp	 QWORD PTR norig$[rsp], 0
  002b1	7d 1c		 jge	 SHORT $LN49@list_ass_s
  002b3	41 b8 94 02 00
	00		 mov	 r8d, 660		; 00000294H
  002b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@MLPMIIJE@?$AAn?$AAo?$AAr?$AAi?$AAg?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  002c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002cd	33 c0		 xor	 eax, eax
$LN49@list_ass_s:

; 661  :     d = n - norig;

  002cf	48 8b 44 24 28	 mov	 rax, QWORD PTR norig$[rsp]
  002d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR n$[rsp]
  002d9	48 2b c8	 sub	 rcx, rax
  002dc	48 8b c1	 mov	 rax, rcx
  002df	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR d$[rsp], rax

; 662  :     if (Py_SIZE(a) + d == 0) {

  002e7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002ef	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002f3	48 03 84 24 98
	00 00 00	 add	 rax, QWORD PTR d$[rsp]
  002fb	48 85 c0	 test	 rax, rax
  002fe	75 30		 jne	 SHORT $LN30@list_ass_s
$LN29@list_ass_s:

; 663  :         Py_XDECREF(v_as_SF);

  00300	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR v_as_SF$[rsp], 0
  00309	74 0d		 je	 SHORT $LN26@list_ass_s
  0030b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR v_as_SF$[rsp]
  00313	e8 00 00 00 00	 call	 _Py_DecRef
$LN26@list_ass_s:
  00318	33 c0		 xor	 eax, eax
  0031a	85 c0		 test	 eax, eax
  0031c	75 e2		 jne	 SHORT $LN29@list_ass_s

; 664  :         return list_clear(a);

  0031e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00326	e8 00 00 00 00	 call	 list_clear
  0032b	e9 b5 03 00 00	 jmp	 $LN43@list_ass_s
$LN30@list_ass_s:

; 665  :     }
; 666  :     item = a->ob_item;

  00330	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00338	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0033c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR item$[rsp], rax

; 667  :     /* recycle the items that we are about to remove */
; 668  :     s = norig * sizeof(PyObject *);

  00344	48 8b 44 24 28	 mov	 rax, QWORD PTR norig$[rsp]
  00349	48 c1 e0 03	 shl	 rax, 3
  0034d	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax

; 669  :     if (s > sizeof(recycle_on_stack)) {

  00352	48 83 7c 24 78
	40		 cmp	 QWORD PTR s$[rsp], 64	; 00000040H
  00358	76 54		 jbe	 SHORT $LN25@list_ass_s

; 670  :         recycle = (PyObject **)PyMem_MALLOC(s);

  0035a	e8 00 00 00 00	 call	 _Py_PXCTX
  0035f	85 c0		 test	 eax, eax
  00361	74 14		 je	 SHORT $LN50@list_ass_s
  00363	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  00368	e8 00 00 00 00	 call	 _PxMem_Malloc
  0036d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv167[rsp], rax
  00375	eb 12		 jmp	 SHORT $LN51@list_ass_s
$LN50@list_ass_s:
  00377	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  0037c	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00381	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv167[rsp], rax
$LN51@list_ass_s:
  00389	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv167[rsp]
  00391	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR recycle$[rsp], rax

; 671  :         if (recycle == NULL) {

  00399	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR recycle$[rsp], 0
  003a2	75 0a		 jne	 SHORT $LN24@list_ass_s

; 672  :             PyErr_NoMemory();

  003a4	e8 00 00 00 00	 call	 PyErr_NoMemory

; 673  :             goto Error;

  003a9	e9 c8 02 00 00	 jmp	 $Error$20859
$LN24@list_ass_s:
$LN25@list_ass_s:

; 674  :         }
; 675  :     }
; 676  :     memcpy(recycle, &item[ilow], s);

  003ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  003b6	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ilow$[rsp]
  003be	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  003c2	4c 8b 44 24 78	 mov	 r8, QWORD PTR s$[rsp]
  003c7	48 8b d0	 mov	 rdx, rax
  003ca	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR recycle$[rsp]
  003d2	e8 00 00 00 00	 call	 memcpy

; 677  : 
; 678  :     if (d < 0) { /* Delete -d items */

  003d7	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR d$[rsp], 0
  003e0	0f 8d ad 00 00
	00		 jge	 $LN23@list_ass_s

; 679  :         memmove(&item[ihigh+d], &item[ihigh],
; 680  :             (Py_SIZE(a) - ihigh)*sizeof(PyObject *));

  003e6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  003ee	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ihigh$[rsp]
  003f6	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  003fa	48 2b c1	 sub	 rax, rcx
  003fd	48 c1 e0 03	 shl	 rax, 3
  00401	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00409	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR ihigh$[rsp]
  00411	48 8d 0c d1	 lea	 rcx, QWORD PTR [rcx+rdx*8]
  00415	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR d$[rsp]
  0041d	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR ihigh$[rsp]
  00425	4c 03 c2	 add	 r8, rdx
  00428	49 8b d0	 mov	 rdx, r8
  0042b	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR item$[rsp]
  00433	49 8d 14 d0	 lea	 rdx, QWORD PTR [r8+rdx*8]
  00437	48 89 94 24 d0
	00 00 00	 mov	 QWORD PTR tv185[rsp], rdx
  0043f	4c 8b c0	 mov	 r8, rax
  00442	48 8b d1	 mov	 rdx, rcx
  00445	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv185[rsp]
  0044d	48 8b c8	 mov	 rcx, rax
  00450	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 681  :         list_resize(a, Py_SIZE(a) + d);

  00456	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0045e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00462	48 03 84 24 98
	00 00 00	 add	 rax, QWORD PTR d$[rsp]
  0046a	48 8b d0	 mov	 rdx, rax
  0046d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00475	e8 00 00 00 00	 call	 list_resize

; 682  :         item = a->ob_item;

  0047a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00482	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00486	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR item$[rsp], rax
  0048e	e9 d5 00 00 00	 jmp	 $LN22@list_ass_s
$LN23@list_ass_s:

; 683  :     }
; 684  :     else if (d > 0) { /* Insert d items */

  00493	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR d$[rsp], 0
  0049c	0f 8e c6 00 00
	00		 jle	 $LN21@list_ass_s

; 685  :         k = Py_SIZE(a);

  004a2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  004aa	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  004ae	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR k$[rsp], rax

; 686  :         if (list_resize(a, k+d) < 0)

  004b6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR d$[rsp]
  004be	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  004c6	48 03 c8	 add	 rcx, rax
  004c9	48 8b c1	 mov	 rax, rcx
  004cc	48 8b d0	 mov	 rdx, rax
  004cf	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  004d7	e8 00 00 00 00	 call	 list_resize
  004dc	85 c0		 test	 eax, eax
  004de	7d 05		 jge	 SHORT $LN20@list_ass_s

; 687  :             goto Error;

  004e0	e9 91 01 00 00	 jmp	 $Error$20859
$LN20@list_ass_s:

; 688  :         item = a->ob_item;

  004e5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  004ed	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  004f1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR item$[rsp], rax

; 689  :         memmove(&item[ihigh+d], &item[ihigh],
; 690  :             (k - ihigh)*sizeof(PyObject *));

  004f9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR ihigh$[rsp]
  00501	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  00509	48 2b c8	 sub	 rcx, rax
  0050c	48 8b c1	 mov	 rax, rcx
  0050f	48 c1 e0 03	 shl	 rax, 3
  00513	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  0051b	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR ihigh$[rsp]
  00523	48 8d 0c d1	 lea	 rcx, QWORD PTR [rcx+rdx*8]
  00527	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR d$[rsp]
  0052f	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR ihigh$[rsp]
  00537	4c 03 c2	 add	 r8, rdx
  0053a	49 8b d0	 mov	 rdx, r8
  0053d	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR item$[rsp]
  00545	49 8d 14 d0	 lea	 rdx, QWORD PTR [r8+rdx*8]
  00549	48 89 94 24 d8
	00 00 00	 mov	 QWORD PTR tv208[rsp], rdx
  00551	4c 8b c0	 mov	 r8, rax
  00554	48 8b d1	 mov	 rdx, rcx
  00557	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv208[rsp]
  0055f	48 8b c8	 mov	 rcx, rax
  00562	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN21@list_ass_s:
$LN22@list_ass_s:

; 691  :     }
; 692  :     for (k = 0; k < n; k++, ilow++) {

  00568	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR k$[rsp], 0
  00574	eb 26		 jmp	 SHORT $LN19@list_ass_s
$LN18@list_ass_s:
  00576	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR k$[rsp]
  0057e	48 ff c0	 inc	 rax
  00581	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR k$[rsp], rax
  00589	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR ilow$[rsp]
  00591	48 ff c0	 inc	 rax
  00594	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR ilow$[rsp], rax
$LN19@list_ass_s:
  0059c	48 8b 44 24 70	 mov	 rax, QWORD PTR n$[rsp]
  005a1	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR k$[rsp], rax
  005a9	7d 58		 jge	 SHORT $LN17@list_ass_s

; 693  :         PyObject *w = vitem[k];

  005ab	48 8b 44 24 20	 mov	 rax, QWORD PTR vitem$[rsp]
  005b0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  005b8	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  005bc	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR w$20904[rsp], rax
$LN16@list_ass_s:

; 694  :         Py_XINCREF(w);

  005c4	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR w$20904[rsp], 0
  005cd	74 0d		 je	 SHORT $LN13@list_ass_s
  005cf	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR w$20904[rsp]
  005d7	e8 00 00 00 00	 call	 _Py_IncRef
$LN13@list_ass_s:
  005dc	33 c0		 xor	 eax, eax
  005de	85 c0		 test	 eax, eax
  005e0	75 e2		 jne	 SHORT $LN16@list_ass_s

; 695  :         item[ilow] = w;

  005e2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  005ea	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ilow$[rsp]
  005f2	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR w$20904[rsp]
  005fa	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 696  :     }

  005fe	e9 73 ff ff ff	 jmp	 $LN18@list_ass_s
$LN17@list_ass_s:

; 697  :     for (k = norig - 1; k >= 0; --k)

  00603	48 8b 44 24 28	 mov	 rax, QWORD PTR norig$[rsp]
  00608	48 ff c8	 dec	 rax
  0060b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR k$[rsp], rax
  00613	eb 13		 jmp	 SHORT $LN12@list_ass_s
$LN11@list_ass_s:
  00615	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR k$[rsp]
  0061d	48 ff c8	 dec	 rax
  00620	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR k$[rsp], rax
$LN12@list_ass_s:
  00628	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR k$[rsp], 0
  00631	7c 38		 jl	 SHORT $LN10@list_ass_s
$LN9@list_ass_s:

; 698  :         Py_XDECREF(recycle[k]);

  00633	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR recycle$[rsp]
  0063b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  00643	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00648	74 19		 je	 SHORT $LN6@list_ass_s
  0064a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR recycle$[rsp]
  00652	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  0065a	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0065e	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@list_ass_s:
  00663	33 c0		 xor	 eax, eax
  00665	85 c0		 test	 eax, eax
  00667	75 ca		 jne	 SHORT $LN9@list_ass_s
  00669	eb aa		 jmp	 SHORT $LN11@list_ass_s
$LN10@list_ass_s:

; 699  :     result = 0;

  0066b	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR result$[rsp], 0
$Error$20859:

; 700  :  Error:
; 701  :     if (recycle != recycle_on_stack)

  00676	48 8d 44 24 30	 lea	 rax, QWORD PTR recycle_on_stack$[rsp]
  0067b	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR recycle$[rsp], rax
  00683	74 3b		 je	 SHORT $LN5@list_ass_s

; 702  :         PyMem_FREE(recycle);

  00685	e8 00 00 00 00	 call	 _Py_PXCTX
  0068a	85 c0		 test	 eax, eax
  0068c	74 1a		 je	 SHORT $LN52@list_ass_s
  0068e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR recycle$[rsp]
  00696	e8 00 00 00 00	 call	 _PxMem_Free
  0069b	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv234[rsp], 0
  006a6	eb 18		 jmp	 SHORT $LN53@list_ass_s
$LN52@list_ass_s:
  006a8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR recycle$[rsp]
  006b0	e8 00 00 00 00	 call	 _PyMem_DebugFree
  006b5	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv234[rsp], 0
$LN53@list_ass_s:
$LN5@list_ass_s:
$LN4@list_ass_s:

; 703  :     Py_XDECREF(v_as_SF);

  006c0	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR v_as_SF$[rsp], 0
  006c9	74 0d		 je	 SHORT $LN1@list_ass_s
  006cb	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR v_as_SF$[rsp]
  006d3	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@list_ass_s:
  006d8	33 c0		 xor	 eax, eax
  006da	85 c0		 test	 eax, eax
  006dc	75 e2		 jne	 SHORT $LN4@list_ass_s

; 704  :     return result;

  006de	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR result$[rsp]
$LN43@list_ass_s:

; 705  : #undef b
; 706  : }

  006e5	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  006ec	c3		 ret	 0
list_ass_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_inplace_repeat DD imagerel list_inplace_repeat
	DD	imagerel list_inplace_repeat+353
	DD	imagerel $unwind$list_inplace_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_inplace_repeat DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_inplace_repeat
_TEXT	SEGMENT
p$ = 32
i$ = 40
size$ = 48
items$ = 56
j$ = 64
o$20967 = 72
self$ = 96
n$ = 104
list_inplace_repeat PROC				; COMDAT

; 722  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 723  :     PyObject **items;
; 724  :     Py_ssize_t size, i, j, p;
; 725  : 
; 726  :     /*
; 727  :     if (Px_PROTECTION_ERROR(self))
; 728  :         return NULL;
; 729  :     */
; 730  : 
; 731  :     size = PyList_GET_SIZE(self);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 732  :     if (size == 0 || n == 1) {

  0001c	48 83 7c 24 30
	00		 cmp	 QWORD PTR size$[rsp], 0
  00022	74 08		 je	 SHORT $LN10@list_inpla
  00024	48 83 7c 24 68
	01		 cmp	 QWORD PTR n$[rsp], 1
  0002a	75 14		 jne	 SHORT $LN11@list_inpla
$LN10@list_inpla:

; 733  :         Py_INCREF(self);

  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00031	e8 00 00 00 00	 call	 _Py_IncRef

; 734  :         return (PyObject *)self;

  00036	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0003b	e9 1c 01 00 00	 jmp	 $LN12@list_inpla
$LN11@list_inpla:

; 735  :     }
; 736  : 
; 737  :     if (n < 1) {

  00040	48 83 7c 24 68
	01		 cmp	 QWORD PTR n$[rsp], 1
  00046	7d 1e		 jge	 SHORT $LN9@list_inpla

; 738  :         (void)list_clear(self);

  00048	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0004d	e8 00 00 00 00	 call	 list_clear

; 739  :         Py_INCREF(self);

  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00057	e8 00 00 00 00	 call	 _Py_IncRef

; 740  :         return (PyObject *)self;

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00061	e9 f6 00 00 00	 jmp	 $LN12@list_inpla
$LN9@list_inpla:

; 741  :     }
; 742  : 
; 743  :     if (size > PY_SSIZE_T_MAX / n) {

  00066	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00070	48 99		 cdq
  00072	48 f7 7c 24 68	 idiv	 QWORD PTR n$[rsp]
  00077	48 39 44 24 30	 cmp	 QWORD PTR size$[rsp], rax
  0007c	7e 0a		 jle	 SHORT $LN8@list_inpla

; 744  :         return PyErr_NoMemory();

  0007e	e8 00 00 00 00	 call	 PyErr_NoMemory
  00083	e9 d4 00 00 00	 jmp	 $LN12@list_inpla
$LN8@list_inpla:

; 745  :     }
; 746  : 
; 747  :     if (list_resize(self, size*n) == -1)

  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  0008d	48 0f af 44 24
	68		 imul	 rax, QWORD PTR n$[rsp]
  00093	48 8b d0	 mov	 rdx, rax
  00096	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0009b	e8 00 00 00 00	 call	 list_resize
  000a0	83 f8 ff	 cmp	 eax, -1
  000a3	75 07		 jne	 SHORT $LN7@list_inpla

; 748  :         return NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	e9 b0 00 00 00	 jmp	 $LN12@list_inpla
$LN7@list_inpla:

; 749  : 
; 750  :     p = size;

  000ac	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  000b1	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 751  :     items = self->ob_item;

  000b6	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000bb	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000bf	48 89 44 24 38	 mov	 QWORD PTR items$[rsp], rax

; 752  :     for (i = 1; i < n; i++) { /* Start counting at 1, not 0 */

  000c4	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR i$[rsp], 1
  000cd	eb 0d		 jmp	 SHORT $LN6@list_inpla
$LN5@list_inpla:
  000cf	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000d4	48 ff c0	 inc	 rax
  000d7	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN6@list_inpla:
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000e1	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000e6	7d 65		 jge	 SHORT $LN4@list_inpla

; 753  :         for (j = 0; j < size; j++) {

  000e8	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  000f1	eb 0d		 jmp	 SHORT $LN3@list_inpla
$LN2@list_inpla:
  000f3	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000f8	48 ff c0	 inc	 rax
  000fb	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
$LN3@list_inpla:
  00100	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  00105	48 39 44 24 40	 cmp	 QWORD PTR j$[rsp], rax
  0010a	7d 3f		 jge	 SHORT $LN1@list_inpla

; 754  :             PyObject *o = items[j];

  0010c	48 8b 44 24 38	 mov	 rax, QWORD PTR items$[rsp]
  00111	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00116	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0011a	48 89 44 24 48	 mov	 QWORD PTR o$20967[rsp], rax

; 755  :             Py_INCREF(o);

  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR o$20967[rsp]
  00124	e8 00 00 00 00	 call	 _Py_IncRef

; 756  :             items[p++] = o;

  00129	48 8b 44 24 38	 mov	 rax, QWORD PTR items$[rsp]
  0012e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00133	48 8b 54 24 48	 mov	 rdx, QWORD PTR o$20967[rsp]
  00138	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  0013c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00141	48 ff c0	 inc	 rax
  00144	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 757  :         }

  00149	eb a8		 jmp	 SHORT $LN2@list_inpla
$LN1@list_inpla:

; 758  :     }

  0014b	eb 82		 jmp	 SHORT $LN5@list_inpla
$LN4@list_inpla:

; 759  :     Py_INCREF(self);

  0014d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00152	e8 00 00 00 00	 call	 _Py_IncRef

; 760  :     return (PyObject *)self;

  00157	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
$LN12@list_inpla:

; 761  : }

  0015c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00160	c3		 ret	 0
list_inplace_repeat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_ass_item DD imagerel list_ass_item
	DD	imagerel list_ass_item+183
	DD	imagerel $unwind$list_ass_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_ass_item DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_ass_item
_TEXT	SEGMENT
old_value$ = 32
a$ = 64
i$ = 72
v$ = 80
list_ass_item PROC					; COMDAT

; 765  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 766  :     PyObject *old_value;
; 767  :     if (i < 0 || i >= Py_SIZE(a)) {

  00013	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  00019	7c 10		 jl	 SHORT $LN2@list_ass_i
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00020	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00024	48 39 44 24 48	 cmp	 QWORD PTR i$[rsp], rax
  00029	7c 1a		 jl	 SHORT $LN3@list_ass_i
$LN2@list_ass_i:

; 768  :         PyErr_SetString(PyExc_IndexError,
; 769  :                         "list assignment index out of range");

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@MGPAAEOB@list?5assignment?5index?5out?5of?5ran@
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 770  :         return -1;

  0003e	b8 ff ff ff ff	 mov	 eax, -1
  00043	eb 6d		 jmp	 SHORT $LN4@list_ass_i
$LN3@list_ass_i:

; 771  :     }
; 772  :     if (v == NULL)

  00045	48 83 7c 24 50
	00		 cmp	 QWORD PTR v$[rsp], 0
  0004b	75 21		 jne	 SHORT $LN1@list_ass_i

; 773  :         /* Px_CHECK_PROTECTION handled by list_ass_slice() */
; 774  :         return list_ass_slice(a, i, i+1, v);

  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR i$[rsp]
  00052	48 ff c0	 inc	 rax
  00055	4c 8b 4c 24 50	 mov	 r9, QWORD PTR v$[rsp]
  0005a	4c 8b c0	 mov	 r8, rax
  0005d	48 8b 54 24 48	 mov	 rdx, QWORD PTR i$[rsp]
  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00067	e8 00 00 00 00	 call	 list_ass_slice
  0006c	eb 44		 jmp	 SHORT $LN4@list_ass_i
$LN1@list_ass_i:

; 775  :     old_value = a->ob_item[i];

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00073	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0007c	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00080	48 89 44 24 20	 mov	 QWORD PTR old_value$[rsp], rax

; 776  :     /*
; 777  :     if (Px_ASSIGNMENT_ERROR(a, old_value))
; 778  :         return -1;
; 779  :     */
; 780  :     Py_INCREF(v);

  00085	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0008a	e8 00 00 00 00	 call	 _Py_IncRef

; 781  :     a->ob_item[i] = v;

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00094	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00098	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0009d	48 8b 54 24 50	 mov	 rdx, QWORD PTR v$[rsp]
  000a2	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 782  :     Py_DECREF(old_value);

  000a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR old_value$[rsp]
  000ab	e8 00 00 00 00	 call	 _Py_DecRef

; 783  :     return 0;

  000b0	33 c0		 xor	 eax, eax
$LN4@list_ass_i:

; 784  : }

  000b2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b6	c3		 ret	 0
list_ass_item ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EEABNKNH@nO?3insert?$AA@		; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$listinsert DD imagerel listinsert
	DD	imagerel listinsert+101
	DD	imagerel $unwind$listinsert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listinsert DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_09EEABNKNH@nO?3insert?$AA@
CONST	SEGMENT
??_C@_09EEABNKNH@nO?3insert?$AA@ DB 'nO:insert', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listinsert
_TEXT	SEGMENT
v$ = 32
i$ = 40
self$ = 64
args$ = 72
listinsert PROC						; COMDAT

; 788  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 789  :     Py_ssize_t i;
; 790  :     PyObject *v;
; 791  :     if (!PyArg_ParseTuple(args, "nO:insert", &i, &v))

  0000e	4c 8d 4c 24 20	 lea	 r9, QWORD PTR v$[rsp]
  00013	4c 8d 44 24 28	 lea	 r8, QWORD PTR i$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EEABNKNH@nO?3insert?$AA@
  0001f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN2@listinsert

; 792  :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 2f		 jmp	 SHORT $LN3@listinsert
$LN2@listinsert:

; 793  :     /* Px_CHECK_PROTECTION handled by ins1()->list_resize() */
; 794  :     if (ins1(self, i, v) == 0)

  00031	4c 8b 44 24 20	 mov	 r8, QWORD PTR v$[rsp]
  00036	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00040	e8 00 00 00 00	 call	 ins1
  00045	85 c0		 test	 eax, eax
  00047	75 15		 jne	 SHORT $LN1@listinsert

; 795  :         Py_RETURN_NONE;

  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00050	e8 00 00 00 00	 call	 _Py_IncRef
  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0005c	eb 02		 jmp	 SHORT $LN3@listinsert
$LN1@listinsert:

; 796  :     return NULL;

  0005e	33 c0		 xor	 eax, eax
$LN3@listinsert:

; 797  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
listinsert ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listclear DD imagerel listclear
	DD	imagerel listclear+43
	DD	imagerel $unwind$listclear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listclear DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listclear
_TEXT	SEGMENT
self$ = 48
listclear PROC						; COMDAT

; 801  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 802  :     /*
; 803  :     if (Px_PROTECTION_ERROR(self))
; 804  :         return NULL;
; 805  :     */
; 806  :     list_clear(self);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 list_clear

; 807  :     Py_RETURN_NONE;

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0001a	e8 00 00 00 00	 call	 _Py_IncRef
  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 808  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
listclear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listcopy DD imagerel listcopy
	DD	imagerel listcopy+35
	DD	imagerel $unwind$listcopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listcopy DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listcopy
_TEXT	SEGMENT
self$ = 48
listcopy PROC						; COMDAT

; 812  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 813  :     return list_slice(self, 0, Py_SIZE(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00012	33 d2		 xor	 edx, edx
  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 list_slice

; 814  : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
listcopy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listappend DD imagerel listappend
	DD	imagerel listappend+61
	DD	imagerel $unwind$listappend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listappend DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listappend
_TEXT	SEGMENT
self$ = 48
v$ = 56
listappend PROC						; COMDAT

; 818  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 819  :     /* Px_CHECK_PROTECTION handled by app1()->list_resize() */
; 820  :     if (app1(self, v) == 0)

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR v$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00018	e8 00 00 00 00	 call	 app1
  0001d	85 c0		 test	 eax, eax
  0001f	75 15		 jne	 SHORT $LN1@listappend

; 821  :         Py_RETURN_NONE;

  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00028	e8 00 00 00 00	 call	 _Py_IncRef
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00034	eb 02		 jmp	 SHORT $LN2@listappend
$LN1@listappend:

; 822  :     return NULL;

  00036	33 c0		 xor	 eax, eax
$LN2@listappend:

; 823  : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	c3		 ret	 0
listappend ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PNNFBCAN@argument?5must?5be?5iterable?$AA@ ; `string'
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_StopIteration:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	_PyObject_LengthHint:PROC
EXTRN	PyObject_GetIter:PROC
EXTRN	PyTuple_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$listextend DD imagerel listextend
	DD	imagerel listextend+1048
	DD	imagerel $unwind$listextend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listextend DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0BK@PNNFBCAN@argument?5must?5be?5iterable?$AA@
CONST	SEGMENT
??_C@_0BK@PNNFBCAN@argument?5must?5be?5iterable?$AA@ DB 'argument must be'
	DB	' iterable', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listextend
_TEXT	SEGMENT
it$ = 32
iternext$ = 40
i$ = 48
mn$ = 56
n$ = 64
m$ = 72
dest$21039 = 80
src$21038 = 88
o$21059 = 96
item$21077 = 104
status$21089 = 112
tv79 = 120
tv128 = 128
self$ = 160
b$ = 168
listextend PROC						; COMDAT

; 827  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 828  :     PyObject *it;      /* iter(v) */
; 829  :     Py_ssize_t m;                  /* size of self */
; 830  :     Py_ssize_t n;                  /* guess for size of b */
; 831  :     Py_ssize_t mn;                 /* m + n */
; 832  :     Py_ssize_t i;
; 833  :     PyObject *(*iternext)(PyObject *);
; 834  : 
; 835  :     /*
; 836  :     if (Px_PROTECTION_ERROR(self))
; 837  :         return NULL;
; 838  :     */
; 839  : 
; 840  :     /* Special cases:
; 841  :        1) lists and tuples which can use PySequence_Fast ops
; 842  :        2) extending self to self requires making a copy first
; 843  :     */
; 844  :     if (PyList_CheckExact(b) || PyTuple_CheckExact(b) || (PyObject *)self == b) {

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  00018	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00020	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00024	74 2b		 je	 SHORT $LN21@listextend
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  0002d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00035	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00039	74 16		 je	 SHORT $LN21@listextend
  0003b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00043	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR self$[rsp], rax
  0004b	0f 85 d5 01 00
	00		 jne	 $LN22@listextend
$LN21@listextend:

; 845  :         PyObject **src, **dest;
; 846  :         b = PySequence_Fast(b, "argument must be iterable");

  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PNNFBCAN@argument?5must?5be?5iterable?$AA@
  00058	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00060	e8 00 00 00 00	 call	 PySequence_Fast
  00065	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 847  :         if (!b)

  0006d	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  00076	75 07		 jne	 SHORT $LN20@listextend

; 848  :             return NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	e9 91 03 00 00	 jmp	 $LN23@listextend
$LN20@listextend:

; 849  :         n = PySequence_Fast_GET_SIZE(b);

  0007f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00087	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00091	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00096	85 c0		 test	 eax, eax
  00098	74 13		 je	 SHORT $LN25@listextend
  0009a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000a2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a6	48 89 44 24 78	 mov	 QWORD PTR tv79[rsp], rax
  000ab	eb 11		 jmp	 SHORT $LN26@listextend
$LN25@listextend:
  000ad	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000b5	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b9	48 89 44 24 78	 mov	 QWORD PTR tv79[rsp], rax
$LN26@listextend:
  000be	48 8b 44 24 78	 mov	 rax, QWORD PTR tv79[rsp]
  000c3	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax

; 850  :         if (n == 0) {

  000c8	48 83 7c 24 40
	00		 cmp	 QWORD PTR n$[rsp], 0
  000ce	75 25		 jne	 SHORT $LN19@listextend

; 851  :             /* short circuit when b is empty */
; 852  :             Py_DECREF(b);

  000d0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  000d8	e8 00 00 00 00	 call	 _Py_DecRef

; 853  :             Py_RETURN_NONE;

  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000e4	e8 00 00 00 00	 call	 _Py_IncRef
  000e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000f0	e9 1b 03 00 00	 jmp	 $LN23@listextend
$LN19@listextend:

; 854  :         }
; 855  :         m = Py_SIZE(self);

  000f5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000fd	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00101	48 89 44 24 48	 mov	 QWORD PTR m$[rsp], rax

; 856  :         if (list_resize(self, m + n) == -1) {

  00106	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  0010b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  00110	48 03 c8	 add	 rcx, rax
  00113	48 8b c1	 mov	 rax, rcx
  00116	48 8b d0	 mov	 rdx, rax
  00119	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00121	e8 00 00 00 00	 call	 list_resize
  00126	83 f8 ff	 cmp	 eax, -1
  00129	75 14		 jne	 SHORT $LN18@listextend

; 857  :             Py_DECREF(b);

  0012b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00133	e8 00 00 00 00	 call	 _Py_DecRef

; 858  :             return NULL;

  00138	33 c0		 xor	 eax, eax
  0013a	e9 d1 02 00 00	 jmp	 $LN23@listextend
$LN18@listextend:

; 859  :         }
; 860  :         /* note that we may still have self == b here for the
; 861  :          * situation a.extend(a), but the following code works
; 862  :          * in that case too.  Just make sure to resize self
; 863  :          * before calling PySequence_Fast_ITEMS.
; 864  :          */
; 865  :         /* populate the end of self with b's items */
; 866  :         src = PySequence_Fast_ITEMS(b);

  0013f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00147	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0014b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00151	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00156	85 c0		 test	 eax, eax
  00158	74 16		 je	 SHORT $LN27@listextend
  0015a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00162	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00166	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv128[rsp], rax
  0016e	eb 14		 jmp	 SHORT $LN28@listextend
$LN27@listextend:
  00170	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00178	48 83 c0 70	 add	 rax, 112		; 00000070H
  0017c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv128[rsp], rax
$LN28@listextend:
  00184	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv128[rsp]
  0018c	48 89 44 24 58	 mov	 QWORD PTR src$21038[rsp], rax

; 867  :         dest = self->ob_item + m;

  00191	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00199	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0019d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  001a2	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  001a6	48 89 44 24 50	 mov	 QWORD PTR dest$21039[rsp], rax

; 868  :         for (i = 0; i < n; i++) {

  001ab	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001b4	eb 0d		 jmp	 SHORT $LN17@listextend
$LN16@listextend:
  001b6	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  001bb	48 ff c0	 inc	 rax
  001be	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN17@listextend:
  001c3	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  001c8	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  001cd	7d 32		 jge	 SHORT $LN15@listextend

; 869  :             PyObject *o = src[i];

  001cf	48 8b 44 24 58	 mov	 rax, QWORD PTR src$21038[rsp]
  001d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  001d9	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  001dd	48 89 44 24 60	 mov	 QWORD PTR o$21059[rsp], rax

; 870  :             Py_INCREF(o);

  001e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR o$21059[rsp]
  001e7	e8 00 00 00 00	 call	 _Py_IncRef

; 871  :             dest[i] = o;

  001ec	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$21039[rsp]
  001f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  001f6	48 8b 54 24 60	 mov	 rdx, QWORD PTR o$21059[rsp]
  001fb	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 872  :         }

  001ff	eb b5		 jmp	 SHORT $LN16@listextend
$LN15@listextend:

; 873  :         Py_DECREF(b);

  00201	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00209	e8 00 00 00 00	 call	 _Py_DecRef

; 874  :         Py_RETURN_NONE;

  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00215	e8 00 00 00 00	 call	 _Py_IncRef
  0021a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00221	e9 ea 01 00 00	 jmp	 $LN23@listextend
$LN22@listextend:

; 875  :     }
; 876  : 
; 877  :     it = PyObject_GetIter(b);

  00226	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0022e	e8 00 00 00 00	 call	 PyObject_GetIter
  00233	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 878  :     if (it == NULL)

  00238	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  0023e	75 07		 jne	 SHORT $LN14@listextend

; 879  :         return NULL;

  00240	33 c0		 xor	 eax, eax
  00242	e9 c9 01 00 00	 jmp	 $LN23@listextend
$LN14@listextend:

; 880  :     iternext = *it->ob_type->tp_iternext;

  00247	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  0024c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00250	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00257	48 89 44 24 28	 mov	 QWORD PTR iternext$[rsp], rax

; 881  : 
; 882  :     /* Guess a result list size. */
; 883  :     n = _PyObject_LengthHint(b, 8);

  0025c	ba 08 00 00 00	 mov	 edx, 8
  00261	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00269	e8 00 00 00 00	 call	 _PyObject_LengthHint
  0026e	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax

; 884  :     if (n == -1) {

  00273	48 83 7c 24 40
	ff		 cmp	 QWORD PTR n$[rsp], -1
  00279	75 11		 jne	 SHORT $LN13@listextend

; 885  :         Py_DECREF(it);

  0027b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00280	e8 00 00 00 00	 call	 _Py_DecRef

; 886  :         return NULL;

  00285	33 c0		 xor	 eax, eax
  00287	e9 84 01 00 00	 jmp	 $LN23@listextend
$LN13@listextend:

; 887  :     }
; 888  :     m = Py_SIZE(self);

  0028c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00294	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00298	48 89 44 24 48	 mov	 QWORD PTR m$[rsp], rax

; 889  :     mn = m + n;

  0029d	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  002a2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  002a7	48 03 c8	 add	 rcx, rax
  002aa	48 8b c1	 mov	 rax, rcx
  002ad	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 890  :     if (mn >= m) {

  002b2	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  002b7	48 39 44 24 38	 cmp	 QWORD PTR mn$[rsp], rax
  002bc	7c 2d		 jl	 SHORT $LN12@listextend

; 891  :         /* Make room. */
; 892  :         if (list_resize(self, mn) == -1)

  002be	48 8b 54 24 38	 mov	 rdx, QWORD PTR mn$[rsp]
  002c3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002cb	e8 00 00 00 00	 call	 list_resize
  002d0	83 f8 ff	 cmp	 eax, -1
  002d3	75 05		 jne	 SHORT $LN11@listextend

; 893  :             goto error;

  002d5	e9 2a 01 00 00	 jmp	 $error$21072
$LN11@listextend:

; 894  :         /* Make the list sane again. */
; 895  :         Py_SIZE(self) = m;

  002da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  002e7	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
$LN12@listextend:
$LN10@listextend:

; 896  :     }
; 897  :     /* Else m + n overflowed; on the chance that n lied, and there really
; 898  :      * is enough room, ignore it.  If n was telling the truth, we'll
; 899  :      * eventually run out of memory during the loop.
; 900  :      */
; 901  : 
; 902  :     /* Run iterator to exhaustion. */
; 903  :     for (;;) {
; 904  :         PyObject *item = iternext(it);

  002eb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  002f0	ff 54 24 28	 call	 QWORD PTR iternext$[rsp]
  002f4	48 89 44 24 68	 mov	 QWORD PTR item$21077[rsp], rax

; 905  :         if (item == NULL) {

  002f9	48 83 7c 24 68
	00		 cmp	 QWORD PTR item$21077[rsp], 0
  002ff	75 2b		 jne	 SHORT $LN8@listextend

; 906  :             if (PyErr_Occurred()) {

  00301	e8 00 00 00 00	 call	 PyErr_Occurred
  00306	48 85 c0	 test	 rax, rax
  00309	74 1c		 je	 SHORT $LN7@listextend

; 907  :                 if (PyErr_ExceptionMatches(PyExc_StopIteration))

  0030b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  00312	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00317	85 c0		 test	 eax, eax
  00319	74 07		 je	 SHORT $LN6@listextend

; 908  :                     PyErr_Clear();

  0031b	e8 00 00 00 00	 call	 PyErr_Clear

; 909  :                 else

  00320	eb 05		 jmp	 SHORT $LN5@listextend
$LN6@listextend:

; 910  :                     goto error;

  00322	e9 dd 00 00 00	 jmp	 $error$21072
$LN5@listextend:
$LN7@listextend:

; 911  :             }
; 912  :             break;

  00327	e9 86 00 00 00	 jmp	 $LN9@listextend
$LN8@listextend:

; 913  :         }
; 914  :         if (Py_SIZE(self) < self->allocated) {

  0032c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00334	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0033c	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00340	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00344	7d 3e		 jge	 SHORT $LN4@listextend

; 915  :             /* steals ref */
; 916  :             PyList_SET_ITEM(self, Py_SIZE(self), item);

  00346	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0034e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00352	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0035a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0035e	48 8b 54 24 68	 mov	 rdx, QWORD PTR item$21077[rsp]
  00363	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 917  :             ++Py_SIZE(self);

  00367	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0036f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00373	48 ff c0	 inc	 rax
  00376	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0037e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 918  :         }
; 919  :         else {

  00382	eb 29		 jmp	 SHORT $LN3@listextend
$LN4@listextend:

; 920  :             int status = app1(self, item);

  00384	48 8b 54 24 68	 mov	 rdx, QWORD PTR item$21077[rsp]
  00389	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00391	e8 00 00 00 00	 call	 app1
  00396	89 44 24 70	 mov	 DWORD PTR status$21089[rsp], eax

; 921  :             Py_DECREF(item);  /* append creates a new ref */

  0039a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR item$21077[rsp]
  0039f	e8 00 00 00 00	 call	 _Py_DecRef

; 922  :             if (status < 0)

  003a4	83 7c 24 70 00	 cmp	 DWORD PTR status$21089[rsp], 0
  003a9	7d 02		 jge	 SHORT $LN2@listextend

; 923  :                 goto error;

  003ab	eb 57		 jmp	 SHORT $error$21072
$LN2@listextend:
$LN3@listextend:

; 924  :         }
; 925  :     }

  003ad	e9 39 ff ff ff	 jmp	 $LN10@listextend
$LN9@listextend:

; 926  : 
; 927  :     /* Cut back result list if initial guess was too large. */
; 928  :     if (Py_SIZE(self) < self->allocated)

  003b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003ba	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  003c2	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  003c6	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  003ca	7d 19		 jge	 SHORT $LN1@listextend

; 929  :         list_resize(self, Py_SIZE(self));  /* shrinking can't fail */

  003cc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003d4	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  003d8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  003e0	e8 00 00 00 00	 call	 list_resize
$LN1@listextend:

; 930  : 
; 931  :     Py_DECREF(it);

  003e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  003ea	e8 00 00 00 00	 call	 _Py_DecRef

; 932  :     Py_RETURN_NONE;

  003ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  003f6	e8 00 00 00 00	 call	 _Py_IncRef
  003fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00402	eb 0c		 jmp	 SHORT $LN23@listextend
$error$21072:

; 933  : 
; 934  :   error:
; 935  :     Py_DECREF(it);

  00404	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00409	e8 00 00 00 00	 call	 _Py_DecRef

; 936  :     return NULL;

  0040e	33 c0		 xor	 eax, eax
$LN23@listextend:

; 937  : }

  00410	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00417	c3		 ret	 0
listextend ENDP
_TEXT	ENDS
PUBLIC	_PyList_Extend
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyList_Extend DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$_PyList_Extend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyList_Extend DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyList_Extend
_TEXT	SEGMENT
self$ = 48
b$ = 56
_PyList_Extend PROC					; COMDAT

; 941  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 942  :     /* Px_CHECK_PROTECTION handled by listextend() */
; 943  :     return listextend(self, b);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR b$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00018	e8 00 00 00 00	 call	 listextend

; 944  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
_PyList_Extend ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_inplace_concat DD imagerel list_inplace_concat
	DD	imagerel list_inplace_concat+79
	DD	imagerel $unwind$list_inplace_concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_inplace_concat DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_inplace_concat
_TEXT	SEGMENT
result$ = 32
self$ = 64
other$ = 72
list_inplace_concat PROC				; COMDAT

; 948  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 949  :     PyObject *result;
; 950  : 
; 951  :     /* Px_CHECK_PROTECTION handled by listextend() */
; 952  :     result = listextend(self, other);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR other$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00018	e8 00 00 00 00	 call	 listextend
  0001d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 953  :     if (result == NULL)

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00028	75 07		 jne	 SHORT $LN1@list_inpla@2

; 954  :         return result;

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002f	eb 19		 jmp	 SHORT $LN2@list_inpla@2
$LN1@list_inpla@2:

; 955  :     Py_DECREF(result);

  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00036	e8 00 00 00 00	 call	 _Py_DecRef

; 956  :     Py_INCREF(self);

  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00040	e8 00 00 00 00	 call	 _Py_IncRef

; 957  :     return (PyObject *)self;

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
$LN2@list_inpla@2:

; 958  : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
list_inplace_concat ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@CIBACNIM@?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0BE@BLOKHBKG@pop?5from?5empty?5list?$AA@	; `string'
PUBLIC	??_C@_06JHLPABKE@?$HMn?3pop?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$listpop DD imagerel listpop
	DD	imagerel listpop+378
	DD	imagerel $unwind$listpop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listpop DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1BI@CIBACNIM@?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@CIBACNIM@?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'u', 00H, 's', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ DB 'pop index out of r'
	DB	'ange', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BLOKHBKG@pop?5from?5empty?5list?$AA@
CONST	SEGMENT
??_C@_0BE@BLOKHBKG@pop?5from?5empty?5list?$AA@ DB 'pop from empty list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHLPABKE@?$HMn?3pop?$AA@
CONST	SEGMENT
??_C@_06JHLPABKE@?$HMn?3pop?$AA@ DB '|n:pop', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listpop
_TEXT	SEGMENT
v$ = 32
i$ = 40
status$ = 48
self$ = 80
args$ = 88
listpop	PROC						; COMDAT

; 962  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 963  :     Py_ssize_t i = -1;

  0000e	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR i$[rsp], -1

; 964  :     PyObject *v;
; 965  :     int status;
; 966  : 
; 967  :     if (!PyArg_ParseTuple(args, "|n:pop", &i))

  00017	4c 8d 44 24 28	 lea	 r8, QWORD PTR i$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JHLPABKE@?$HMn?3pop?$AA@
  00023	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN6@listpop

; 968  :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 3d 01 00 00	 jmp	 $LN7@listpop
$LN6@listpop:

; 969  : 
; 970  :     if (Py_SIZE(self) == 0) {

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	75 1a		 jne	 SHORT $LN5@listpop

; 971  :         /* Special-case most common failure cause */
; 972  :         PyErr_SetString(PyExc_IndexError, "pop from empty list");

  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@BLOKHBKG@pop?5from?5empty?5list?$AA@
  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00052	e8 00 00 00 00	 call	 PyErr_SetString

; 973  :         return NULL;

  00057	33 c0		 xor	 eax, eax
  00059	e9 17 01 00 00	 jmp	 $LN7@listpop
$LN5@listpop:

; 974  :     }
; 975  :     if (i < 0)

  0005e	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00064	7d 19		 jge	 SHORT $LN4@listpop

; 976  :         i += Py_SIZE(self);

  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00074	48 03 c8	 add	 rcx, rax
  00077	48 8b c1	 mov	 rax, rcx
  0007a	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN4@listpop:

; 977  :     if (i < 0 || i >= Py_SIZE(self)) {

  0007f	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00085	7c 10		 jl	 SHORT $LN2@listpop
  00087	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0008c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00090	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00095	7c 1a		 jl	 SHORT $LN3@listpop
$LN2@listpop:

; 978  :         PyErr_SetString(PyExc_IndexError, "pop index out of range");

  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000a5	e8 00 00 00 00	 call	 PyErr_SetString

; 979  :         return NULL;

  000aa	33 c0		 xor	 eax, eax
  000ac	e9 c4 00 00 00	 jmp	 $LN7@listpop
$LN3@listpop:

; 980  :     }
; 981  :     v = self->ob_item[i];

  000b1	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000b6	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000ba	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000bf	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000c3	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 982  :     /* Px_CHECK_PROTECTION handled by list_resize() or list_ass_slice() */
; 983  :     if (i == Py_SIZE(self) - 1) {

  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000cd	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d1	48 ff c8	 dec	 rax
  000d4	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000d9	75 47		 jne	 SHORT $LN1@listpop

; 984  :         status = list_resize(self, Py_SIZE(self) - 1);

  000db	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000e0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000e4	48 ff c8	 dec	 rax
  000e7	48 8b d0	 mov	 rdx, rax
  000ea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000ef	e8 00 00 00 00	 call	 list_resize
  000f4	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 985  :         assert(status >= 0);

  000f8	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  000fd	7d 1c		 jge	 SHORT $LN9@listpop
  000ff	41 b8 d9 03 00
	00		 mov	 r8d, 985		; 000003d9H
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@CIBACNIM@?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00119	33 c0		 xor	 eax, eax
$LN9@listpop:

; 986  :         return v; /* and v now owns the reference the list had */

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00120	eb 53		 jmp	 SHORT $LN7@listpop
$LN1@listpop:

; 987  :     }
; 988  :     Py_INCREF(v);

  00122	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00127	e8 00 00 00 00	 call	 _Py_IncRef

; 989  :     status = list_ass_slice(self, i, i+1, (PyObject *)NULL);

  0012c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00131	48 ff c0	 inc	 rax
  00134	45 33 c9	 xor	 r9d, r9d
  00137	4c 8b c0	 mov	 r8, rax
  0013a	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0013f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00144	e8 00 00 00 00	 call	 list_ass_slice
  00149	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax

; 990  :     assert(status >= 0);

  0014d	83 7c 24 30 00	 cmp	 DWORD PTR status$[rsp], 0
  00152	7d 1c		 jge	 SHORT $LN10@listpop
  00154	41 b8 de 03 00
	00		 mov	 r8d, 990		; 000003deH
  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@CIBACNIM@?$AAs?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0016e	33 c0		 xor	 eax, eax
$LN10@listpop:

; 991  :     /* Use status, so that in a release build compilers don't
; 992  :      * complain about the unused name.
; 993  :      */
; 994  :     (void) status;
; 995  : 
; 996  :     return v;

  00170	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN7@listpop:

; 997  : }

  00175	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00179	c3		 ret	 0
listpop	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BOEBAINE@list?5modified?5during?5sort?$AA@ ; `string'
PUBLIC	??_C@_1EG@IMBMBMLO@?$AAm?$AAs?$AA?4?$AAp?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$FL?$AA0?$AA?$FN?$AA?4?$AAl?$AAe?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAa?$AAv?$AAe?$AAd?$AA_?$AAo?$AAb?$AA_?$AAs?$AAi@ ; `string'
PUBLIC	??_C@_1LM@FKLCHDEB@?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$DP?$AA?5?$AAm?$AAs?$AA?4?$AAp?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$FL?$AA0?$AA?$FN?$AA?4?$AAb?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1BE@OOKFICLJ@?$AAm?$AAs?$AA?4?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@PLPKLELL@?$AAm?$AAs?$AA?4?$AAn?$AA?5?$AA?$DM?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAM?$AAE?$AAR?$AAG?$AAE?$AA_?$AAP?$AAE?$AAN?$AAD?$AAI?$AAN?$AAG?$AA?$AA@ ; `string'
PUBLIC	$T23300
PUBLIC	??_C@_0CL@HOEKIDMG@must?5use?5keyword?5argument?5for?5ke@ ; `string'
PUBLIC	??_C@_08IFACFLKK@?$HMOi?3sort?$AA@		; `string'
PUBLIC	??_C@_1CG@HIEBMCAP@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@KLMFOMEM@?$AAs?$AAe?$AAl?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
EXTRN	__chkstk:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$listsort DD imagerel listsort
	DD	imagerel listsort+2442
	DD	imagerel $unwind$listsort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listsort DD 041e01H
	DD	0225011eH
	DD	060107011H
xdata	ENDS
;	COMDAT ??_C@_0BK@BOEBAINE@list?5modified?5during?5sort?$AA@
CONST	SEGMENT
??_C@_0BK@BOEBAINE@list?5modified?5during?5sort?$AA@ DB 'list modified du'
	DB	'ring sort', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@IMBMBMLO@?$AAm?$AAs?$AA?4?$AAp?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$FL?$AA0?$AA?$FN?$AA?4?$AAl?$AAe?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAa?$AAv?$AAe?$AAd?$AA_?$AAo?$AAb?$AA_?$AAs?$AAi@
CONST	SEGMENT
??_C@_1EG@IMBMBMLO@?$AAm?$AAs?$AA?4?$AAp?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$FL?$AA0?$AA?$FN?$AA?4?$AAl?$AAe?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAa?$AAv?$AAe?$AAd?$AA_?$AAo?$AAb?$AA_?$AAs?$AAi@ DB 'm'
	DB	00H, 's', 00H, '.', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, '[', 00H, '0', 00H, ']', 00H, '.'
	DB	00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 's', 00H, 'a', 00H, 'v', 00H, 'e', 00H, 'd', 00H, '_'
	DB	00H, 'o', 00H, 'b', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1LM@FKLCHDEB@?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$DP?$AA?5?$AAm?$AAs?$AA?4?$AAp?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$FL?$AA0?$AA?$FN?$AA?4?$AAb?$AAa?$AAs@
CONST	SEGMENT
??_C@_1LM@FKLCHDEB@?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$DP?$AA?5?$AAm?$AAs?$AA?4?$AAp?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$FL?$AA0?$AA?$FN?$AA?4?$AAb?$AAa?$AAs@ DB 'k'
	DB	00H, 'e', 00H, 'y', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '?'
	DB	00H, ' ', 00H, 'm', 00H, 's', 00H, '.', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '[', 00H, '0'
	DB	00H, ']', 00H, '.', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	'.', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 's', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 's', 00H, 'a', 00H, 'v', 00H, 'e', 00H
	DB	'd', 00H, '_', 00H, 'o', 00H, 'b', 00H, '_', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'm', 00H, ' ', 00H, ':', 00H, ' ', 00H, 'm', 00H
	DB	's', 00H, '.', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, '[', 00H, '0', 00H, ']', 00H, '.', 00H
	DB	'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, '.', 00H, 'k', 00H, 'e'
	DB	00H, 'y', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'&', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 's', 00H, '[', 00H, '0'
	DB	00H, ']', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@OOKFICLJ@?$AAm?$AAs?$AA?4?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@OOKFICLJ@?$AAm?$AAs?$AA?4?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'm'
	DB	00H, 's', 00H, '.', 00H, 'n', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@PLPKLELL@?$AAm?$AAs?$AA?4?$AAn?$AA?5?$AA?$DM?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAM?$AAE?$AAR?$AAG?$AAE?$AA_?$AAP?$AAE?$AAN?$AAD?$AAI?$AAN?$AAG?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@PLPKLELL@?$AAm?$AAs?$AA?4?$AAn?$AA?5?$AA?$DM?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAM?$AAE?$AAR?$AAG?$AAE?$AA_?$AAP?$AAE?$AAN?$AAD?$AAI?$AAN?$AAG?$AA?$AA@ DB 'm'
	DB	00H, 's', 00H, '.', 00H, 'n', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'M', 00H, 'A', 00H, 'X', 00H, '_', 00H, 'M', 00H, 'E', 00H, 'R'
	DB	00H, 'G', 00H, 'E', 00H, '_', 00H, 'P', 00H, 'E', 00H, 'N', 00H
	DB	'D', 00H, 'I', 00H, 'N', 00H, 'G', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HOEKIDMG@must?5use?5keyword?5argument?5for?5ke@
CONST	SEGMENT
??_C@_0CL@HOEKIDMG@must?5use?5keyword?5argument?5for?5ke@ DB 'must use ke'
	DB	'yword argument for key function', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IFACFLKK@?$HMOi?3sort?$AA@
CONST	SEGMENT
??_C@_08IFACFLKK@?$HMOi?3sort?$AA@ DB '|Oi:sort', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@HIEBMCAP@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@HIEBMCAP@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@KLMFOMEM@?$AAs?$AAe?$AAl?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@KLMFOMEM@?$AAs?$AAe?$AAl?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listsort
_TEXT	SEGMENT
lo$ = 48
i$ = 64
nremaining$ = 72
ms$ = 80
saved_ob_item$ = 4208
keyfunc$ = 4216
minrun$ = 4224
keys$ = 4232
saved_ob_size$ = 4240
reverse$ = 4248
result$ = 4256
final_ob_item$ = 4264
saved_allocated$ = 4272
n$21731 = 4280
descending$21730 = 4288
force$21736 = 4296
$T23300 = 4304
tv142 = 4320
tv171 = 4328
tv173 = 4332
tv202 = 4336
tv208 = 4344
tv244 = 4352
tv245 = 4356
tv243 = 4360
tv270 = 4364
tv302 = 4368
self$ = 4416
args$ = 4424
kwds$ = 4432
listsort PROC						; COMDAT

; 1964 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	b8 28 11 00 00	 mov	 eax, 4392		; 00001128H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	48 2b e0	 sub	 rsp, rax

; 1965 :     MergeState ms;
; 1966 :     Py_ssize_t nremaining;
; 1967 :     Py_ssize_t minrun;
; 1968 :     sortslice lo;
; 1969 :     Py_ssize_t saved_ob_size, saved_allocated;
; 1970 :     PyObject **saved_ob_item;
; 1971 :     PyObject **final_ob_item;
; 1972 :     PyObject *result = NULL;            /* guilty until proved innocent */

  0001e	48 c7 84 24 a0
	10 00 00 00 00
	00 00		 mov	 QWORD PTR result$[rsp], 0

; 1973 :     int reverse = 0;

  0002a	c7 84 24 98 10
	00 00 00 00 00
	00		 mov	 DWORD PTR reverse$[rsp], 0

; 1974 :     PyObject *keyfunc = NULL;

  00035	48 c7 84 24 78
	10 00 00 00 00
	00 00		 mov	 QWORD PTR keyfunc$[rsp], 0

; 1975 :     Py_ssize_t i;
; 1976 :     static char *kwlist[] = {"key", "reverse", 0};
; 1977 :     PyObject **keys;
; 1978 : 
; 1979 :     assert(self != NULL);

  00041	48 83 bc 24 40
	11 00 00 00	 cmp	 QWORD PTR self$[rsp], 0
  0004a	75 1c		 jne	 SHORT $LN50@listsort
  0004c	41 b8 bb 07 00
	00		 mov	 r8d, 1979		; 000007bbH
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@KLMFOMEM@?$AAs?$AAe?$AAl?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00066	33 c0		 xor	 eax, eax
$LN50@listsort:

; 1980 :     assert (PyList_Check(self));

  00068	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00070	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00074	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0007a	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0007f	85 c0		 test	 eax, eax
  00081	75 1c		 jne	 SHORT $LN51@listsort
  00083	41 b8 bc 07 00
	00		 mov	 r8d, 1980		; 000007bcH
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@HIEBMCAP@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009d	33 c0		 xor	 eax, eax
$LN51@listsort:

; 1981 : 
; 1982 :     /*
; 1983 :     if (Px_PROTECTION_ERROR(self))
; 1984 :         return NULL;
; 1985 :     */
; 1986 : 
; 1987 :     if (args != NULL) {

  0009f	48 83 bc 24 48
	11 00 00 00	 cmp	 QWORD PTR args$[rsp], 0
  000a8	74 71		 je	 SHORT $LN47@listsort

; 1988 :         if (!PyArg_ParseTupleAndKeywords(args, kwds, "|Oi:sort",
; 1989 :             kwlist, &keyfunc, &reverse))

  000aa	48 8d 84 24 98
	10 00 00	 lea	 rax, QWORD PTR reverse$[rsp]
  000b2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b7	48 8d 84 24 78
	10 00 00	 lea	 rax, QWORD PTR keyfunc$[rsp]
  000bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??listsort@@9@9
  000cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08IFACFLKK@?$HMOi?3sort?$AA@
  000d2	48 8b 94 24 50
	11 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  000da	48 8b 8c 24 48
	11 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000e2	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000e7	85 c0		 test	 eax, eax
  000e9	75 07		 jne	 SHORT $LN46@listsort

; 1990 :             return NULL;

  000eb	33 c0		 xor	 eax, eax
  000ed	e9 8e 08 00 00	 jmp	 $LN48@listsort
$LN46@listsort:

; 1991 :         if (Py_SIZE(args) > 0) {

  000f2	48 8b 84 24 48
	11 00 00	 mov	 rax, QWORD PTR args$[rsp]
  000fa	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000ff	7e 1a		 jle	 SHORT $LN45@listsort

; 1992 :             PyErr_SetString(PyExc_TypeError,
; 1993 :                 "must use keyword argument for key function");

  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@HOEKIDMG@must?5use?5keyword?5argument?5for?5ke@
  00108	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0010f	e8 00 00 00 00	 call	 PyErr_SetString

; 1994 :             return NULL;

  00114	33 c0		 xor	 eax, eax
  00116	e9 65 08 00 00	 jmp	 $LN48@listsort
$LN45@listsort:
$LN47@listsort:

; 1995 :         }
; 1996 :     }
; 1997 :     if (keyfunc == Py_None)

  0011b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00122	48 39 84 24 78
	10 00 00	 cmp	 QWORD PTR keyfunc$[rsp], rax
  0012a	75 0c		 jne	 SHORT $LN44@listsort

; 1998 :         keyfunc = NULL;

  0012c	48 c7 84 24 78
	10 00 00 00 00
	00 00		 mov	 QWORD PTR keyfunc$[rsp], 0
$LN44@listsort:

; 1999 : 
; 2000 :     /* The list is temporarily made empty, so that mutations performed
; 2001 :      * by comparison functions can't affect the slice of memory we're
; 2002 :      * sorting (allowing mutations during sorting is a core-dump
; 2003 :      * factory, since ob_item may change).
; 2004 :      */
; 2005 :     saved_ob_size = Py_SIZE(self);

  00138	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00140	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00144	48 89 84 24 90
	10 00 00	 mov	 QWORD PTR saved_ob_size$[rsp], rax

; 2006 :     saved_ob_item = self->ob_item;

  0014c	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00154	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00158	48 89 84 24 70
	10 00 00	 mov	 QWORD PTR saved_ob_item$[rsp], rax

; 2007 :     saved_allocated = self->allocated;

  00160	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00168	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0016c	48 89 84 24 b0
	10 00 00	 mov	 QWORD PTR saved_allocated$[rsp], rax

; 2008 :     Py_SIZE(self) = 0;

  00174	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0017c	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 2009 :     self->ob_item = NULL;

  00184	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0018c	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 2010 :     self->allocated = -1; /* any operation will reset it to >= 0 */

  00194	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0019c	48 c7 40 78 ff
	ff ff ff	 mov	 QWORD PTR [rax+120], -1

; 2011 : 
; 2012 :     if (keyfunc == NULL) {

  001a4	48 83 bc 24 78
	10 00 00 00	 cmp	 QWORD PTR keyfunc$[rsp], 0
  001ad	75 27		 jne	 SHORT $LN43@listsort

; 2013 :         keys = NULL;

  001af	48 c7 84 24 88
	10 00 00 00 00
	00 00		 mov	 QWORD PTR keys$[rsp], 0

; 2014 :         lo.keys = saved_ob_item;

  001bb	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR saved_ob_item$[rsp]
  001c3	48 89 44 24 30	 mov	 QWORD PTR lo$[rsp], rax

; 2015 :         lo.values = NULL;

  001c8	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR lo$[rsp+8], 0

; 2016 :     }
; 2017 :     else {

  001d1	e9 b7 01 00 00	 jmp	 $LN42@listsort
$LN43@listsort:

; 2018 :         if (saved_ob_size < MERGESTATE_TEMP_SIZE/2)

  001d6	48 81 bc 24 90
	10 00 00 80 00
	00 00		 cmp	 QWORD PTR saved_ob_size$[rsp], 128 ; 00000080H
  001e2	7d 1a		 jge	 SHORT $LN41@listsort

; 2019 :             /* Leverage stack space we allocated but won't otherwise use */
; 2020 :             keys = &ms.temparray[saved_ob_size+1];

  001e4	48 8b 84 24 90
	10 00 00	 mov	 rax, QWORD PTR saved_ob_size$[rsp]
  001ec	48 8d 84 c4 78
	08 00 00	 lea	 rax, QWORD PTR ms$[rsp+rax*8+2088]
  001f4	48 89 84 24 88
	10 00 00	 mov	 QWORD PTR keys$[rsp], rax

; 2021 :         else {

  001fc	eb 65		 jmp	 SHORT $LN40@listsort
$LN41@listsort:

; 2022 :             keys = PyMem_MALLOC(sizeof(PyObject *) * saved_ob_size);

  001fe	e8 00 00 00 00	 call	 _Py_PXCTX
  00203	85 c0		 test	 eax, eax
  00205	74 1e		 je	 SHORT $LN52@listsort
  00207	48 8b 84 24 90
	10 00 00	 mov	 rax, QWORD PTR saved_ob_size$[rsp]
  0020f	48 c1 e0 03	 shl	 rax, 3
  00213	48 8b c8	 mov	 rcx, rax
  00216	e8 00 00 00 00	 call	 _PxMem_Malloc
  0021b	48 89 84 24 e0
	10 00 00	 mov	 QWORD PTR tv142[rsp], rax
  00223	eb 1c		 jmp	 SHORT $LN53@listsort
$LN52@listsort:
  00225	48 8b 84 24 90
	10 00 00	 mov	 rax, QWORD PTR saved_ob_size$[rsp]
  0022d	48 c1 e0 03	 shl	 rax, 3
  00231	48 8b c8	 mov	 rcx, rax
  00234	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00239	48 89 84 24 e0
	10 00 00	 mov	 QWORD PTR tv142[rsp], rax
$LN53@listsort:
  00241	48 8b 84 24 e0
	10 00 00	 mov	 rax, QWORD PTR tv142[rsp]
  00249	48 89 84 24 88
	10 00 00	 mov	 QWORD PTR keys$[rsp], rax

; 2023 :             if (keys == NULL)

  00251	48 83 bc 24 88
	10 00 00 00	 cmp	 QWORD PTR keys$[rsp], 0
  0025a	75 07		 jne	 SHORT $LN39@listsort

; 2024 :                 return NULL;

  0025c	33 c0		 xor	 eax, eax
  0025e	e9 1d 07 00 00	 jmp	 $LN48@listsort
$LN39@listsort:
$LN40@listsort:

; 2025 :         }
; 2026 : 
; 2027 :         for (i = 0; i < saved_ob_size ; i++) {

  00263	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0026c	eb 0d		 jmp	 SHORT $LN38@listsort
$LN37@listsort:
  0026e	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00273	48 ff c0	 inc	 rax
  00276	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN38@listsort:
  0027b	48 8b 84 24 90
	10 00 00	 mov	 rax, QWORD PTR saved_ob_size$[rsp]
  00283	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  00288	0f 8d e5 00 00
	00		 jge	 $LN36@listsort

; 2028 :             keys[i] = PyObject_CallFunctionObjArgs(keyfunc, saved_ob_item[i],
; 2029 :                                                    NULL);

  0028e	45 33 c0	 xor	 r8d, r8d
  00291	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR saved_ob_item$[rsp]
  00299	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  0029e	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  002a2	48 8b 8c 24 78
	10 00 00	 mov	 rcx, QWORD PTR keyfunc$[rsp]
  002aa	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  002af	48 8b 8c 24 88
	10 00 00	 mov	 rcx, QWORD PTR keys$[rsp]
  002b7	48 8b 54 24 40	 mov	 rdx, QWORD PTR i$[rsp]
  002bc	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 2030 :             if (keys[i] == NULL) {

  002c0	48 8b 84 24 88
	10 00 00	 mov	 rax, QWORD PTR keys$[rsp]
  002c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  002cd	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  002d2	0f 85 96 00 00
	00		 jne	 $LN35@listsort

; 2031 :                 for (i=i-1 ; i>=0 ; i--)

  002d8	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  002dd	48 ff c8	 dec	 rax
  002e0	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  002e5	eb 0d		 jmp	 SHORT $LN34@listsort
$LN33@listsort:
  002e7	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  002ec	48 ff c8	 dec	 rax
  002ef	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN34@listsort:
  002f4	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  002fa	7c 18		 jl	 SHORT $LN32@listsort

; 2032 :                     Py_DECREF(keys[i]);

  002fc	48 8b 84 24 88
	10 00 00	 mov	 rax, QWORD PTR keys$[rsp]
  00304	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00309	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0030d	e8 00 00 00 00	 call	 _Py_DecRef
  00312	eb d3		 jmp	 SHORT $LN33@listsort
$LN32@listsort:

; 2033 :                 if (keys != &ms.temparray[saved_ob_size+1])

  00314	48 8b 84 24 90
	10 00 00	 mov	 rax, QWORD PTR saved_ob_size$[rsp]
  0031c	48 8d 84 c4 78
	08 00 00	 lea	 rax, QWORD PTR ms$[rsp+rax*8+2088]
  00324	48 39 84 24 88
	10 00 00	 cmp	 QWORD PTR keys$[rsp], rax
  0032c	74 3b		 je	 SHORT $LN31@listsort

; 2034 :                     PyMem_FREE(keys);

  0032e	e8 00 00 00 00	 call	 _Py_PXCTX
  00333	85 c0		 test	 eax, eax
  00335	74 1a		 je	 SHORT $LN54@listsort
  00337	48 8b 8c 24 88
	10 00 00	 mov	 rcx, QWORD PTR keys$[rsp]
  0033f	e8 00 00 00 00	 call	 _PxMem_Free
  00344	c7 84 24 e8 10
	00 00 00 00 00
	00		 mov	 DWORD PTR tv171[rsp], 0
  0034f	eb 18		 jmp	 SHORT $LN55@listsort
$LN54@listsort:
  00351	48 8b 8c 24 88
	10 00 00	 mov	 rcx, QWORD PTR keys$[rsp]
  00359	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0035e	c7 84 24 e8 10
	00 00 00 00 00
	00		 mov	 DWORD PTR tv171[rsp], 0
$LN55@listsort:
$LN31@listsort:

; 2035 :                 goto keyfunc_fail;

  00369	e9 fa 04 00 00	 jmp	 $keyfunc_fail$21720
$LN35@listsort:

; 2036 :             }
; 2037 :         }

  0036e	e9 fb fe ff ff	 jmp	 $LN37@listsort
$LN36@listsort:

; 2038 : 
; 2039 :         lo.keys = keys;

  00373	48 8b 84 24 88
	10 00 00	 mov	 rax, QWORD PTR keys$[rsp]
  0037b	48 89 44 24 30	 mov	 QWORD PTR lo$[rsp], rax

; 2040 :         lo.values = saved_ob_item;

  00380	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR saved_ob_item$[rsp]
  00388	48 89 44 24 38	 mov	 QWORD PTR lo$[rsp+8], rax
$LN42@listsort:

; 2041 :     }
; 2042 : 
; 2043 :     merge_init(&ms, saved_ob_size, keys != NULL);

  0038d	48 83 bc 24 88
	10 00 00 00	 cmp	 QWORD PTR keys$[rsp], 0
  00396	74 0d		 je	 SHORT $LN56@listsort
  00398	c7 84 24 ec 10
	00 00 01 00 00
	00		 mov	 DWORD PTR tv173[rsp], 1
  003a3	eb 0b		 jmp	 SHORT $LN57@listsort
$LN56@listsort:
  003a5	c7 84 24 ec 10
	00 00 00 00 00
	00		 mov	 DWORD PTR tv173[rsp], 0
$LN57@listsort:
  003b0	44 8b 84 24 ec
	10 00 00	 mov	 r8d, DWORD PTR tv173[rsp]
  003b8	48 8b 94 24 90
	10 00 00	 mov	 rdx, QWORD PTR saved_ob_size$[rsp]
  003c0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ms$[rsp]
  003c5	e8 00 00 00 00	 call	 merge_init

; 2044 : 
; 2045 :     nremaining = saved_ob_size;

  003ca	48 8b 84 24 90
	10 00 00	 mov	 rax, QWORD PTR saved_ob_size$[rsp]
  003d2	48 89 44 24 48	 mov	 QWORD PTR nremaining$[rsp], rax

; 2046 :     if (nremaining < 2)

  003d7	48 83 7c 24 48
	02		 cmp	 QWORD PTR nremaining$[rsp], 2
  003dd	7d 05		 jge	 SHORT $LN30@listsort

; 2047 :         goto succeed;

  003df	e9 56 03 00 00	 jmp	 $succeed$21723
$LN30@listsort:

; 2048 : 
; 2049 :     /* Reverse sort stability achieved by initially reversing the list,
; 2050 :     applying a stable forward sort, then reversing the final result. */
; 2051 :     if (reverse) {

  003e4	83 bc 24 98 10
	00 00 00	 cmp	 DWORD PTR reverse$[rsp], 0
  003ec	74 53		 je	 SHORT $LN29@listsort

; 2052 :         if (keys != NULL)

  003ee	48 83 bc 24 88
	10 00 00 00	 cmp	 QWORD PTR keys$[rsp], 0
  003f7	74 24		 je	 SHORT $LN28@listsort

; 2053 :             reverse_slice(&keys[0], &keys[saved_ob_size]);

  003f9	48 8b 84 24 88
	10 00 00	 mov	 rax, QWORD PTR keys$[rsp]
  00401	48 8b 8c 24 90
	10 00 00	 mov	 rcx, QWORD PTR saved_ob_size$[rsp]
  00409	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0040d	48 8b d0	 mov	 rdx, rax
  00410	48 8b 8c 24 88
	10 00 00	 mov	 rcx, QWORD PTR keys$[rsp]
  00418	e8 00 00 00 00	 call	 reverse_slice
$LN28@listsort:

; 2054 :         reverse_slice(&saved_ob_item[0], &saved_ob_item[saved_ob_size]);

  0041d	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR saved_ob_item$[rsp]
  00425	48 8b 8c 24 90
	10 00 00	 mov	 rcx, QWORD PTR saved_ob_size$[rsp]
  0042d	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00431	48 8b d0	 mov	 rdx, rax
  00434	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR saved_ob_item$[rsp]
  0043c	e8 00 00 00 00	 call	 reverse_slice
$LN29@listsort:

; 2055 :     }
; 2056 : 
; 2057 :     /* March over the array once, left to right, finding natural runs,
; 2058 :      * and extending short natural runs to minrun elements.
; 2059 :      */
; 2060 :     minrun = merge_compute_minrun(nremaining);

  00441	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nremaining$[rsp]
  00446	e8 00 00 00 00	 call	 merge_compute_minrun
  0044b	48 89 84 24 80
	10 00 00	 mov	 QWORD PTR minrun$[rsp], rax
$LN27@listsort:

; 2061 :     do {
; 2062 :         int descending;
; 2063 :         Py_ssize_t n;
; 2064 : 
; 2065 :         /* Identify next run. */
; 2066 :         n = count_run(lo.keys, lo.keys + nremaining, &descending);

  00453	48 8b 44 24 30	 mov	 rax, QWORD PTR lo$[rsp]
  00458	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nremaining$[rsp]
  0045d	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00461	4c 8d 84 24 c0
	10 00 00	 lea	 r8, QWORD PTR descending$21730[rsp]
  00469	48 8b d0	 mov	 rdx, rax
  0046c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lo$[rsp]
  00471	e8 00 00 00 00	 call	 count_run
  00476	48 89 84 24 b8
	10 00 00	 mov	 QWORD PTR n$21731[rsp], rax

; 2067 :         if (n < 0)

  0047e	48 83 bc 24 b8
	10 00 00 00	 cmp	 QWORD PTR n$21731[rsp], 0
  00487	7d 05		 jge	 SHORT $LN24@listsort

; 2068 :             goto fail;

  00489	e9 bb 02 00 00	 jmp	 $fail$21733
$LN24@listsort:

; 2069 :         if (descending)

  0048e	83 bc 24 c0 10
	00 00 00	 cmp	 DWORD PTR descending$21730[rsp], 0
  00496	74 12		 je	 SHORT $LN23@listsort

; 2070 :             reverse_sortslice(&lo, n);

  00498	48 8b 94 24 b8
	10 00 00	 mov	 rdx, QWORD PTR n$21731[rsp]
  004a0	48 8d 4c 24 30	 lea	 rcx, QWORD PTR lo$[rsp]
  004a5	e8 00 00 00 00	 call	 reverse_sortslice
$LN23@listsort:

; 2071 :         /* If short, extend to min(minrun, nremaining). */
; 2072 :         if (n < minrun) {

  004aa	48 8b 84 24 80
	10 00 00	 mov	 rax, QWORD PTR minrun$[rsp]
  004b2	48 39 84 24 b8
	10 00 00	 cmp	 QWORD PTR n$21731[rsp], rax
  004ba	0f 8d b6 00 00
	00		 jge	 $LN22@listsort

; 2073 :             const Py_ssize_t force = nremaining <= minrun ?
; 2074 :                               nremaining : minrun;

  004c0	48 8b 84 24 80
	10 00 00	 mov	 rax, QWORD PTR minrun$[rsp]
  004c8	48 39 44 24 48	 cmp	 QWORD PTR nremaining$[rsp], rax
  004cd	7f 0f		 jg	 SHORT $LN58@listsort
  004cf	48 8b 44 24 48	 mov	 rax, QWORD PTR nremaining$[rsp]
  004d4	48 89 84 24 f0
	10 00 00	 mov	 QWORD PTR tv202[rsp], rax
  004dc	eb 10		 jmp	 SHORT $LN59@listsort
$LN58@listsort:
  004de	48 8b 84 24 80
	10 00 00	 mov	 rax, QWORD PTR minrun$[rsp]
  004e6	48 89 84 24 f0
	10 00 00	 mov	 QWORD PTR tv202[rsp], rax
$LN59@listsort:
  004ee	48 8b 84 24 f0
	10 00 00	 mov	 rax, QWORD PTR tv202[rsp]
  004f6	48 89 84 24 c8
	10 00 00	 mov	 QWORD PTR force$21736[rsp], rax

; 2075 :             if (binarysort(lo, lo.keys + force, lo.keys + n) < 0)

  004fe	48 8b 44 24 30	 mov	 rax, QWORD PTR lo$[rsp]
  00503	48 8b 8c 24 b8
	10 00 00	 mov	 rcx, QWORD PTR n$21731[rsp]
  0050b	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0050f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lo$[rsp]
  00514	48 8b 94 24 c8
	10 00 00	 mov	 rdx, QWORD PTR force$21736[rsp]
  0051c	48 8d 0c d1	 lea	 rcx, QWORD PTR [rcx+rdx*8]
  00520	48 89 8c 24 f8
	10 00 00	 mov	 QWORD PTR tv208[rsp], rcx
  00528	48 8d 94 24 d0
	10 00 00	 lea	 rdx, QWORD PTR $T23300[rsp]
  00530	4c 8d 44 24 30	 lea	 r8, QWORD PTR lo$[rsp]
  00535	48 8b fa	 mov	 rdi, rdx
  00538	49 8b f0	 mov	 rsi, r8
  0053b	b9 10 00 00 00	 mov	 ecx, 16
  00540	f3 a4		 rep movsb
  00542	4c 8b c0	 mov	 r8, rax
  00545	48 8b 84 24 f8
	10 00 00	 mov	 rax, QWORD PTR tv208[rsp]
  0054d	48 8b d0	 mov	 rdx, rax
  00550	48 8d 8c 24 d0
	10 00 00	 lea	 rcx, QWORD PTR $T23300[rsp]
  00558	e8 00 00 00 00	 call	 binarysort
  0055d	85 c0		 test	 eax, eax
  0055f	7d 05		 jge	 SHORT $LN21@listsort

; 2076 :                 goto fail;

  00561	e9 e3 01 00 00	 jmp	 $fail$21733
$LN21@listsort:

; 2077 :             n = force;

  00566	48 8b 84 24 c8
	10 00 00	 mov	 rax, QWORD PTR force$21736[rsp]
  0056e	48 89 84 24 b8
	10 00 00	 mov	 QWORD PTR n$21731[rsp], rax
$LN22@listsort:

; 2078 :         }
; 2079 :         /* Push run onto pending-runs stack, and maybe merge. */
; 2080 :         assert(ms.n < MAX_MERGE_PENDING);

  00576	83 7c 24 70 55	 cmp	 DWORD PTR ms$[rsp+32], 85 ; 00000055H
  0057b	7c 1c		 jl	 SHORT $LN60@listsort
  0057d	41 b8 20 08 00
	00		 mov	 r8d, 2080		; 00000820H
  00583	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0058a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@PLPKLELL@?$AAm?$AAs?$AA?4?$AAn?$AA?5?$AA?$DM?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAM?$AAE?$AAR?$AAG?$AAE?$AA_?$AAP?$AAE?$AAN?$AAD?$AAI?$AAN?$AAG?$AA?$AA@
  00591	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00597	33 c0		 xor	 eax, eax
$LN60@listsort:

; 2081 :         ms.pending[ms.n].base = lo;

  00599	48 63 44 24 70	 movsxd	 rax, DWORD PTR ms$[rsp+32]
  0059e	48 6b c0 18	 imul	 rax, 24
  005a2	48 8d 4c 24 30	 lea	 rcx, QWORD PTR lo$[rsp]
  005a7	48 8d 7c 04 78	 lea	 rdi, QWORD PTR ms$[rsp+rax+40]
  005ac	48 8b f1	 mov	 rsi, rcx
  005af	b9 10 00 00 00	 mov	 ecx, 16
  005b4	f3 a4		 rep movsb

; 2082 :         ms.pending[ms.n].len = n;

  005b6	48 63 44 24 70	 movsxd	 rax, DWORD PTR ms$[rsp+32]
  005bb	48 6b c0 18	 imul	 rax, 24
  005bf	48 8b 8c 24 b8
	10 00 00	 mov	 rcx, QWORD PTR n$21731[rsp]
  005c7	48 89 8c 04 88
	00 00 00	 mov	 QWORD PTR ms$[rsp+rax+56], rcx

; 2083 :         ++ms.n;

  005cf	8b 44 24 70	 mov	 eax, DWORD PTR ms$[rsp+32]
  005d3	ff c0		 inc	 eax
  005d5	89 44 24 70	 mov	 DWORD PTR ms$[rsp+32], eax

; 2084 :         if (merge_collapse(&ms) < 0)

  005d9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ms$[rsp]
  005de	e8 00 00 00 00	 call	 merge_collapse
  005e3	85 c0		 test	 eax, eax
  005e5	7d 05		 jge	 SHORT $LN20@listsort

; 2085 :             goto fail;

  005e7	e9 5d 01 00 00	 jmp	 $fail$21733
$LN20@listsort:

; 2086 :         /* Advance to find next run. */
; 2087 :         sortslice_advance(&lo, n);

  005ec	48 8b 94 24 b8
	10 00 00	 mov	 rdx, QWORD PTR n$21731[rsp]
  005f4	48 8d 4c 24 30	 lea	 rcx, QWORD PTR lo$[rsp]
  005f9	e8 00 00 00 00	 call	 sortslice_advance

; 2088 :         nremaining -= n;

  005fe	48 8b 84 24 b8
	10 00 00	 mov	 rax, QWORD PTR n$21731[rsp]
  00606	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nremaining$[rsp]
  0060b	48 2b c8	 sub	 rcx, rax
  0060e	48 8b c1	 mov	 rax, rcx
  00611	48 89 44 24 48	 mov	 QWORD PTR nremaining$[rsp], rax

; 2089 :     } while (nremaining);

  00616	48 83 7c 24 48
	00		 cmp	 QWORD PTR nremaining$[rsp], 0
  0061c	0f 85 31 fe ff
	ff		 jne	 $LN27@listsort

; 2090 : 
; 2091 :     if (merge_force_collapse(&ms) < 0)

  00622	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ms$[rsp]
  00627	e8 00 00 00 00	 call	 merge_force_collapse
  0062c	85 c0		 test	 eax, eax
  0062e	7d 05		 jge	 SHORT $LN19@listsort

; 2092 :         goto fail;

  00630	e9 14 01 00 00	 jmp	 $fail$21733
$LN19@listsort:

; 2093 :     assert(ms.n == 1);

  00635	83 7c 24 70 01	 cmp	 DWORD PTR ms$[rsp+32], 1
  0063a	74 1c		 je	 SHORT $LN61@listsort
  0063c	41 b8 2d 08 00
	00		 mov	 r8d, 2093		; 0000082dH
  00642	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00649	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@OOKFICLJ@?$AAm?$AAs?$AA?4?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00650	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00656	33 c0		 xor	 eax, eax
$LN61@listsort:

; 2094 :     assert(keys == NULL
; 2095 :            ? ms.pending[0].base.keys == saved_ob_item
; 2096 :            : ms.pending[0].base.keys == &keys[0]);

  00658	48 83 bc 24 88
	10 00 00 00	 cmp	 QWORD PTR keys$[rsp], 0
  00661	75 37		 jne	 SHORT $LN66@listsort
  00663	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR saved_ob_item$[rsp]
  0066b	48 39 44 24 78	 cmp	 QWORD PTR ms$[rsp+40], rax
  00670	75 0d		 jne	 SHORT $LN64@listsort
  00672	c7 84 24 00 11
	00 00 01 00 00
	00		 mov	 DWORD PTR tv244[rsp], 1
  0067d	eb 0b		 jmp	 SHORT $LN65@listsort
$LN64@listsort:
  0067f	c7 84 24 00 11
	00 00 00 00 00
	00		 mov	 DWORD PTR tv244[rsp], 0
$LN65@listsort:
  0068a	8b 84 24 00 11
	00 00		 mov	 eax, DWORD PTR tv244[rsp]
  00691	89 84 24 04 11
	00 00		 mov	 DWORD PTR tv245[rsp], eax
  00698	eb 35		 jmp	 SHORT $LN67@listsort
$LN66@listsort:
  0069a	48 8b 84 24 88
	10 00 00	 mov	 rax, QWORD PTR keys$[rsp]
  006a2	48 39 44 24 78	 cmp	 QWORD PTR ms$[rsp+40], rax
  006a7	75 0d		 jne	 SHORT $LN62@listsort
  006a9	c7 84 24 08 11
	00 00 01 00 00
	00		 mov	 DWORD PTR tv243[rsp], 1
  006b4	eb 0b		 jmp	 SHORT $LN63@listsort
$LN62@listsort:
  006b6	c7 84 24 08 11
	00 00 00 00 00
	00		 mov	 DWORD PTR tv243[rsp], 0
$LN63@listsort:
  006c1	8b 84 24 08 11
	00 00		 mov	 eax, DWORD PTR tv243[rsp]
  006c8	89 84 24 04 11
	00 00		 mov	 DWORD PTR tv245[rsp], eax
$LN67@listsort:
  006cf	83 bc 24 04 11
	00 00 00	 cmp	 DWORD PTR tv245[rsp], 0
  006d7	75 1c		 jne	 SHORT $LN68@listsort
  006d9	41 b8 30 08 00
	00		 mov	 r8d, 2096		; 00000830H
  006df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  006e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LM@FKLCHDEB@?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$DP?$AA?5?$AAm?$AAs?$AA?4?$AAp?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$FL?$AA0?$AA?$FN?$AA?4?$AAb?$AAa?$AAs@
  006ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006f3	33 c0		 xor	 eax, eax
$LN68@listsort:

; 2097 :     assert(ms.pending[0].len == saved_ob_size);

  006f5	48 8b 84 24 90
	10 00 00	 mov	 rax, QWORD PTR saved_ob_size$[rsp]
  006fd	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR ms$[rsp+56], rax
  00705	74 1c		 je	 SHORT $LN69@listsort
  00707	41 b8 31 08 00
	00		 mov	 r8d, 2097		; 00000831H
  0070d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00714	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@IMBMBMLO@?$AAm?$AAs?$AA?4?$AAp?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$FL?$AA0?$AA?$FN?$AA?4?$AAl?$AAe?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAa?$AAv?$AAe?$AAd?$AA_?$AAo?$AAb?$AA_?$AAs?$AAi@
  0071b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00721	33 c0		 xor	 eax, eax
$LN69@listsort:

; 2098 :     lo = ms.pending[0].base;

  00723	48 8d 44 24 30	 lea	 rax, QWORD PTR lo$[rsp]
  00728	48 8d 4c 24 78	 lea	 rcx, QWORD PTR ms$[rsp+40]
  0072d	48 8b f8	 mov	 rdi, rax
  00730	48 8b f1	 mov	 rsi, rcx
  00733	b9 10 00 00 00	 mov	 ecx, 16
  00738	f3 a4		 rep movsb
$succeed$21723:

; 2099 : 
; 2100 : succeed:
; 2101 :     result = Py_None;

  0073a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00741	48 89 84 24 a0
	10 00 00	 mov	 QWORD PTR result$[rsp], rax
$fail$21733:

; 2102 : fail:
; 2103 :     if (keys != NULL) {

  00749	48 83 bc 24 88
	10 00 00 00	 cmp	 QWORD PTR keys$[rsp], 0
  00752	0f 84 94 00 00
	00		 je	 $LN18@listsort

; 2104 :         for (i = 0; i < saved_ob_size; i++)

  00758	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00761	eb 0d		 jmp	 SHORT $LN17@listsort
$LN16@listsort:
  00763	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00768	48 ff c0	 inc	 rax
  0076b	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN17@listsort:
  00770	48 8b 84 24 90
	10 00 00	 mov	 rax, QWORD PTR saved_ob_size$[rsp]
  00778	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  0077d	7d 18		 jge	 SHORT $LN15@listsort

; 2105 :             Py_DECREF(keys[i]);

  0077f	48 8b 84 24 88
	10 00 00	 mov	 rax, QWORD PTR keys$[rsp]
  00787	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  0078c	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00790	e8 00 00 00 00	 call	 _Py_DecRef
  00795	eb cc		 jmp	 SHORT $LN16@listsort
$LN15@listsort:

; 2106 :         if (keys != &ms.temparray[saved_ob_size+1])

  00797	48 8b 84 24 90
	10 00 00	 mov	 rax, QWORD PTR saved_ob_size$[rsp]
  0079f	48 8d 84 c4 78
	08 00 00	 lea	 rax, QWORD PTR ms$[rsp+rax*8+2088]
  007a7	48 39 84 24 88
	10 00 00	 cmp	 QWORD PTR keys$[rsp], rax
  007af	74 3b		 je	 SHORT $LN14@listsort

; 2107 :             PyMem_FREE(keys);

  007b1	e8 00 00 00 00	 call	 _Py_PXCTX
  007b6	85 c0		 test	 eax, eax
  007b8	74 1a		 je	 SHORT $LN70@listsort
  007ba	48 8b 8c 24 88
	10 00 00	 mov	 rcx, QWORD PTR keys$[rsp]
  007c2	e8 00 00 00 00	 call	 _PxMem_Free
  007c7	c7 84 24 0c 11
	00 00 00 00 00
	00		 mov	 DWORD PTR tv270[rsp], 0
  007d2	eb 18		 jmp	 SHORT $LN71@listsort
$LN70@listsort:
  007d4	48 8b 8c 24 88
	10 00 00	 mov	 rcx, QWORD PTR keys$[rsp]
  007dc	e8 00 00 00 00	 call	 _PyMem_DebugFree
  007e1	c7 84 24 0c 11
	00 00 00 00 00
	00		 mov	 DWORD PTR tv270[rsp], 0
$LN71@listsort:
$LN14@listsort:
$LN18@listsort:

; 2108 :     }
; 2109 : 
; 2110 :     if (self->allocated != -1 && result != NULL) {

  007ec	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  007f4	48 83 78 78 ff	 cmp	 QWORD PTR [rax+120], -1
  007f9	74 2a		 je	 SHORT $LN13@listsort
  007fb	48 83 bc 24 a0
	10 00 00 00	 cmp	 QWORD PTR result$[rsp], 0
  00804	74 1f		 je	 SHORT $LN13@listsort

; 2111 :         /* The user mucked with the list during the sort,
; 2112 :          * and we don't already have another error to report.
; 2113 :          */
; 2114 :         PyErr_SetString(PyExc_ValueError, "list modified during sort");

  00806	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@BOEBAINE@list?5modified?5during?5sort?$AA@
  0080d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00814	e8 00 00 00 00	 call	 PyErr_SetString

; 2115 :         result = NULL;

  00819	48 c7 84 24 a0
	10 00 00 00 00
	00 00		 mov	 QWORD PTR result$[rsp], 0
$LN13@listsort:

; 2116 :     }
; 2117 : 
; 2118 :     if (reverse && saved_ob_size > 1)

  00825	83 bc 24 98 10
	00 00 00	 cmp	 DWORD PTR reverse$[rsp], 0
  0082d	74 2f		 je	 SHORT $LN12@listsort
  0082f	48 83 bc 24 90
	10 00 00 01	 cmp	 QWORD PTR saved_ob_size$[rsp], 1
  00838	7e 24		 jle	 SHORT $LN12@listsort

; 2119 :         reverse_slice(saved_ob_item, saved_ob_item + saved_ob_size);

  0083a	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR saved_ob_item$[rsp]
  00842	48 8b 8c 24 90
	10 00 00	 mov	 rcx, QWORD PTR saved_ob_size$[rsp]
  0084a	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0084e	48 8b d0	 mov	 rdx, rax
  00851	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR saved_ob_item$[rsp]
  00859	e8 00 00 00 00	 call	 reverse_slice
$LN12@listsort:

; 2120 : 
; 2121 :     merge_freemem(&ms);

  0085e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ms$[rsp]
  00863	e8 00 00 00 00	 call	 merge_freemem
$keyfunc_fail$21720:

; 2122 : 
; 2123 : keyfunc_fail:
; 2124 :     final_ob_item = self->ob_item;

  00868	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00870	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00874	48 89 84 24 a8
	10 00 00	 mov	 QWORD PTR final_ob_item$[rsp], rax

; 2125 :     i = Py_SIZE(self);

  0087c	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00884	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00888	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax

; 2126 :     Py_SIZE(self) = saved_ob_size;

  0088d	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00895	48 8b 8c 24 90
	10 00 00	 mov	 rcx, QWORD PTR saved_ob_size$[rsp]
  0089d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 2127 :     self->ob_item = saved_ob_item;

  008a1	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  008a9	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR saved_ob_item$[rsp]
  008b1	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2128 :     self->allocated = saved_allocated;

  008b5	48 8b 84 24 40
	11 00 00	 mov	 rax, QWORD PTR self$[rsp]
  008bd	48 8b 8c 24 b0
	10 00 00	 mov	 rcx, QWORD PTR saved_allocated$[rsp]
  008c5	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 2129 :     if (final_ob_item != NULL) {

  008c9	48 83 bc 24 a8
	10 00 00 00	 cmp	 QWORD PTR final_ob_item$[rsp], 0
  008d2	0f 84 82 00 00
	00		 je	 $LN11@listsort
$LN10@listsort:

; 2130 :         /* we cannot use list_clear() for this because it does not
; 2131 :            guarantee that the list is really empty when it returns */
; 2132 :         while (--i >= 0) {

  008d8	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  008dd	48 ff c8	 dec	 rax
  008e0	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  008e5	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  008eb	7c 32		 jl	 SHORT $LN9@listsort
$LN8@listsort:

; 2133 :             Py_XDECREF(final_ob_item[i]);

  008ed	48 8b 84 24 a8
	10 00 00	 mov	 rax, QWORD PTR final_ob_item$[rsp]
  008f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  008fa	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  008ff	74 16		 je	 SHORT $LN5@listsort
  00901	48 8b 84 24 a8
	10 00 00	 mov	 rax, QWORD PTR final_ob_item$[rsp]
  00909	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  0090e	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00912	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@listsort:
  00917	33 c0		 xor	 eax, eax
  00919	85 c0		 test	 eax, eax
  0091b	75 d0		 jne	 SHORT $LN8@listsort

; 2134 :         }

  0091d	eb b9		 jmp	 SHORT $LN10@listsort
$LN9@listsort:

; 2135 :         PyMem_FREE(final_ob_item);

  0091f	e8 00 00 00 00	 call	 _Py_PXCTX
  00924	85 c0		 test	 eax, eax
  00926	74 1a		 je	 SHORT $LN72@listsort
  00928	48 8b 8c 24 a8
	10 00 00	 mov	 rcx, QWORD PTR final_ob_item$[rsp]
  00930	e8 00 00 00 00	 call	 _PxMem_Free
  00935	c7 84 24 10 11
	00 00 00 00 00
	00		 mov	 DWORD PTR tv302[rsp], 0
  00940	eb 18		 jmp	 SHORT $LN73@listsort
$LN72@listsort:
  00942	48 8b 8c 24 a8
	10 00 00	 mov	 rcx, QWORD PTR final_ob_item$[rsp]
  0094a	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0094f	c7 84 24 10 11
	00 00 00 00 00
	00		 mov	 DWORD PTR tv302[rsp], 0
$LN73@listsort:
$LN11@listsort:
$LN4@listsort:

; 2136 :     }
; 2137 :     Py_XINCREF(result);

  0095a	48 83 bc 24 a0
	10 00 00 00	 cmp	 QWORD PTR result$[rsp], 0
  00963	74 0d		 je	 SHORT $LN1@listsort
  00965	48 8b 8c 24 a0
	10 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  0096d	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@listsort:
  00972	33 c0		 xor	 eax, eax
  00974	85 c0		 test	 eax, eax
  00976	75 e2		 jne	 SHORT $LN4@listsort

; 2138 :     return result;

  00978	48 8b 84 24 a0
	10 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN48@listsort:

; 2139 : }

  00980	48 81 c4 28 11
	00 00		 add	 rsp, 4392		; 00001128H
  00987	5f		 pop	 rdi
  00988	5e		 pop	 rsi
  00989	c3		 ret	 0
listsort ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BC@PHKJEJOK@?$AAl?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh?$AAi?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$reverse_slice DD imagerel reverse_slice
	DD	imagerel reverse_slice+161
	DD	imagerel $unwind$reverse_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reverse_slice DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1BC@PHKJEJOK@?$AAl?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@PHKJEJOK@?$AAl?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh?$AAi?$AA?$AA@ DB 'l'
	DB	00H, 'o', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'h', 00H
	DB	'i', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT reverse_slice
_TEXT	SEGMENT
t$21160 = 32
lo$ = 64
hi$ = 72
reverse_slice PROC					; COMDAT

; 1002 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1003 :     assert(lo && hi);

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR lo$[rsp], 0
  00014	74 08		 je	 SHORT $LN5@reverse_sl
  00016	48 83 7c 24 48
	00		 cmp	 QWORD PTR hi$[rsp], 0
  0001c	75 1c		 jne	 SHORT $LN6@reverse_sl
$LN5@reverse_sl:
  0001e	41 b8 eb 03 00
	00		 mov	 r8d, 1003		; 000003ebH
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@PHKJEJOK@?$AAl?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh?$AAi?$AA?$AA@
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00038	33 c0		 xor	 eax, eax
$LN6@reverse_sl:

; 1004 : 
; 1005 :     /* Px_CHECK_PROTECTION handled by callers (listreverse, listsort,
; 1006 :      * PyList_Reverse()).
; 1007 :      */
; 1008 : 
; 1009 :     --hi;

  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR hi$[rsp]
  0003f	48 83 e8 08	 sub	 rax, 8
  00043	48 89 44 24 48	 mov	 QWORD PTR hi$[rsp], rax
$LN2@reverse_sl:

; 1010 :     while (lo < hi) {

  00048	48 8b 44 24 48	 mov	 rax, QWORD PTR hi$[rsp]
  0004d	48 39 44 24 40	 cmp	 QWORD PTR lo$[rsp], rax
  00052	73 48		 jae	 SHORT $LN1@reverse_sl

; 1011 :         PyObject *t = *lo;

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  00059	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005c	48 89 44 24 20	 mov	 QWORD PTR t$21160[rsp], rax

; 1012 :         *lo = *hi;

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  00066	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hi$[rsp]
  0006b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0006e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1013 :         *hi = t;

  00071	48 8b 44 24 48	 mov	 rax, QWORD PTR hi$[rsp]
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR t$21160[rsp]
  0007b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1014 :         ++lo;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  00083	48 83 c0 08	 add	 rax, 8
  00087	48 89 44 24 40	 mov	 QWORD PTR lo$[rsp], rax

; 1015 :         --hi;

  0008c	48 8b 44 24 48	 mov	 rax, QWORD PTR hi$[rsp]
  00091	48 83 e8 08	 sub	 rax, 8
  00095	48 89 44 24 48	 mov	 QWORD PTR hi$[rsp], rax

; 1016 :     }

  0009a	eb ac		 jmp	 SHORT $LN2@reverse_sl
$LN1@reverse_sl:

; 1017 : }

  0009c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a0	c3		 ret	 0
reverse_slice ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT sortslice_advance
_TEXT	SEGMENT
slice$ = 8
n$ = 16
sortslice_advance PROC					; COMDAT

; 1082 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1083 :     slice->keys += n;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR slice$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 10	 mov	 rcx, QWORD PTR n$[rsp]
  00017	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0001b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR slice$[rsp]
  00020	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1084 :     if (slice->values != NULL)

  00023	48 8b 44 24 08	 mov	 rax, QWORD PTR slice$[rsp]
  00028	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0002d	74 1b		 je	 SHORT $LN1@sortslice_

; 1085 :         slice->values += n;

  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR slice$[rsp]
  00034	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00038	48 8b 4c 24 10	 mov	 rcx, QWORD PTR n$[rsp]
  0003d	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00041	48 8b 4c 24 08	 mov	 rcx, QWORD PTR slice$[rsp]
  00046	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN1@sortslice_:

; 1086 : }

  0004a	f3 c3		 fatret	 0
sortslice_advance ENDP
_TEXT	ENDS
PUBLIC	??_C@_1O@NFACGBMB@?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PCNHDANK@?$AAl?$AA?5?$AA?$DM?$AA?5?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@CMEFGAPF@?$AAl?$AAo?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAh?$AAi?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binarysort DD imagerel binarysort
	DD	imagerel binarysort+639
	DD	imagerel $unwind$binarysort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binarysort DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_1O@NFACGBMB@?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1O@NFACGBMB@?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AA?$AA@ DB 'l', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PCNHDANK@?$AAl?$AA?5?$AA?$DM?$AA?5?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PCNHDANK@?$AAl?$AA?5?$AA?$DM?$AA?5?$AAr?$AA?$AA@ DB 'l', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@CMEFGAPF@?$AAl?$AAo?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAh?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@CMEFGAPF@?$AAl?$AAo?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAh?$AAi?$AA?$AA@ DB 'l'
	DB	00H, 'o', 00H, '.', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 's', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 's', 00H, 't', 00H, 'a'
	DB	00H, 'r', 00H, 't', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, 'h', 00H, 'i', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binarysort
_TEXT	SEGMENT
p$ = 32
pivot$ = 40
k$ = 48
l$ = 56
r$ = 64
offset$21270 = 72
lo$ = 96
hi$ = 104
start$ = 112
binarysort PROC						; COMDAT

; 1114 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1115 :     register Py_ssize_t k;
; 1116 :     register PyObject **l, **p, **r;
; 1117 :     register PyObject *pivot;
; 1118 : 
; 1119 :     assert(lo.keys <= start && start <= hi);

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR lo$[rsp]
  00018	48 8b 4c 24 70	 mov	 rcx, QWORD PTR start$[rsp]
  0001d	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00020	77 0c		 ja	 SHORT $LN20@binarysort
  00022	48 8b 44 24 68	 mov	 rax, QWORD PTR hi$[rsp]
  00027	48 39 44 24 70	 cmp	 QWORD PTR start$[rsp], rax
  0002c	76 1c		 jbe	 SHORT $LN21@binarysort
$LN20@binarysort:
  0002e	41 b8 5f 04 00
	00		 mov	 r8d, 1119		; 0000045fH
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@CMEFGAPF@?$AAl?$AAo?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAh?$AAi?$AA?$AA@
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00048	33 c0		 xor	 eax, eax
$LN21@binarysort:

; 1120 :     /* assert [lo, start) is sorted */
; 1121 :     if (lo.keys == start)

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR lo$[rsp]
  0004f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR start$[rsp]
  00054	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00057	75 0e		 jne	 SHORT $LN17@binarysort

; 1122 :         ++start;

  00059	48 8b 44 24 70	 mov	 rax, QWORD PTR start$[rsp]
  0005e	48 83 c0 08	 add	 rax, 8
  00062	48 89 44 24 70	 mov	 QWORD PTR start$[rsp], rax
$LN17@binarysort:

; 1123 :     for (; start < hi; ++start) {

  00067	eb 0e		 jmp	 SHORT $LN16@binarysort
$LN15@binarysort:
  00069	48 8b 44 24 70	 mov	 rax, QWORD PTR start$[rsp]
  0006e	48 83 c0 08	 add	 rax, 8
  00072	48 89 44 24 70	 mov	 QWORD PTR start$[rsp], rax
$LN16@binarysort:
  00077	48 8b 44 24 68	 mov	 rax, QWORD PTR hi$[rsp]
  0007c	48 39 44 24 70	 cmp	 QWORD PTR start$[rsp], rax
  00081	0f 83 ea 01 00
	00		 jae	 $LN14@binarysort

; 1124 :         /* set l to where *start belongs */
; 1125 :         l = lo.keys;

  00087	48 8b 44 24 60	 mov	 rax, QWORD PTR lo$[rsp]
  0008c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008f	48 89 44 24 38	 mov	 QWORD PTR l$[rsp], rax

; 1126 :         r = start;

  00094	48 8b 44 24 70	 mov	 rax, QWORD PTR start$[rsp]
  00099	48 89 44 24 40	 mov	 QWORD PTR r$[rsp], rax

; 1127 :         pivot = *r;

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR r$[rsp]
  000a3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a6	48 89 44 24 28	 mov	 QWORD PTR pivot$[rsp], rax

; 1128 :         /* Invariants:
; 1129 :          * pivot >= all in [lo, l).
; 1130 :          * pivot  < all in [r, start).
; 1131 :          * The second is vacuously true at the start.
; 1132 :          */
; 1133 :         assert(l < r);

  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR r$[rsp]
  000b0	48 39 44 24 38	 cmp	 QWORD PTR l$[rsp], rax
  000b5	72 1c		 jb	 SHORT $LN22@binarysort
  000b7	41 b8 6d 04 00
	00		 mov	 r8d, 1133		; 0000046dH
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1M@PCNHDANK@?$AAl?$AA?5?$AA?$DM?$AA?5?$AAr?$AA?$AA@
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d1	33 c0		 xor	 eax, eax
$LN22@binarysort:
$LN13@binarysort:

; 1134 :         do {
; 1135 :             p = l + ((r - l) >> 1);

  000d3	48 8b 44 24 38	 mov	 rax, QWORD PTR l$[rsp]
  000d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR r$[rsp]
  000dd	48 2b c8	 sub	 rcx, rax
  000e0	48 8b c1	 mov	 rax, rcx
  000e3	48 c1 f8 03	 sar	 rax, 3
  000e7	48 d1 f8	 sar	 rax, 1
  000ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR l$[rsp]
  000ef	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000f3	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1136 :             IFLT(pivot, *p)

  000f8	45 33 c0	 xor	 r8d, r8d
  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00100	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00103	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pivot$[rsp]
  00108	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0010d	48 98		 cdqe
  0010f	48 89 44 24 30	 mov	 QWORD PTR k$[rsp], rax
  00114	48 83 7c 24 30
	00		 cmp	 QWORD PTR k$[rsp], 0
  0011a	7d 05		 jge	 SHORT $LN10@binarysort
  0011c	e9 54 01 00 00	 jmp	 $fail$21260
$LN10@binarysort:
  00121	48 83 7c 24 30
	00		 cmp	 QWORD PTR k$[rsp], 0
  00127	74 0c		 je	 SHORT $LN9@binarysort

; 1137 :                 r = p;

  00129	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0012e	48 89 44 24 40	 mov	 QWORD PTR r$[rsp], rax

; 1138 :             else

  00133	eb 0e		 jmp	 SHORT $LN8@binarysort
$LN9@binarysort:

; 1139 :                 l = p+1;

  00135	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0013a	48 83 c0 08	 add	 rax, 8
  0013e	48 89 44 24 38	 mov	 QWORD PTR l$[rsp], rax
$LN8@binarysort:

; 1140 :         } while (l < r);

  00143	48 8b 44 24 40	 mov	 rax, QWORD PTR r$[rsp]
  00148	48 39 44 24 38	 cmp	 QWORD PTR l$[rsp], rax
  0014d	72 84		 jb	 SHORT $LN13@binarysort

; 1141 :         assert(l == r);

  0014f	48 8b 44 24 40	 mov	 rax, QWORD PTR r$[rsp]
  00154	48 39 44 24 38	 cmp	 QWORD PTR l$[rsp], rax
  00159	74 1c		 je	 SHORT $LN23@binarysort
  0015b	41 b8 75 04 00
	00		 mov	 r8d, 1141		; 00000475H
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@NFACGBMB@?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AA?$AA@
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00175	33 c0		 xor	 eax, eax
$LN23@binarysort:

; 1142 :         /* The invariants still hold, so pivot >= all in [lo, l) and
; 1143 :            pivot < all in [l, start), so pivot belongs at l.  Note
; 1144 :            that if there are elements equal to pivot, l points to the
; 1145 :            first slot after them -- that's why this sort is stable.
; 1146 :            Slide over to make room.
; 1147 :            Caution: using memmove is much slower under MSVC 5;
; 1148 :            we're not usually moving many slots. */
; 1149 :         for (p = start; p > l; --p)

  00177	48 8b 44 24 70	 mov	 rax, QWORD PTR start$[rsp]
  0017c	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00181	eb 0e		 jmp	 SHORT $LN7@binarysort
$LN6@binarysort:
  00183	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00188	48 83 e8 08	 sub	 rax, 8
  0018c	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN7@binarysort:
  00191	48 8b 44 24 38	 mov	 rax, QWORD PTR l$[rsp]
  00196	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  0019b	76 13		 jbe	 SHORT $LN5@binarysort

; 1150 :             *p = *(p-1);

  0019d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001a7	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  001ab	48 89 08	 mov	 QWORD PTR [rax], rcx
  001ae	eb d3		 jmp	 SHORT $LN6@binarysort
$LN5@binarysort:

; 1151 :         *l = pivot;

  001b0	48 8b 44 24 38	 mov	 rax, QWORD PTR l$[rsp]
  001b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pivot$[rsp]
  001ba	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1152 :         if (lo.values != NULL) {

  001bd	48 8b 44 24 60	 mov	 rax, QWORD PTR lo$[rsp]
  001c2	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  001c7	0f 84 9f 00 00
	00		 je	 $LN4@binarysort

; 1153 :             Py_ssize_t offset = lo.values - lo.keys;

  001cd	48 8b 44 24 60	 mov	 rax, QWORD PTR lo$[rsp]
  001d2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lo$[rsp]
  001d7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001da	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001de	48 2b c1	 sub	 rax, rcx
  001e1	48 c1 f8 03	 sar	 rax, 3
  001e5	48 89 44 24 48	 mov	 QWORD PTR offset$21270[rsp], rax

; 1154 :             p = start + offset;

  001ea	48 8b 44 24 70	 mov	 rax, QWORD PTR start$[rsp]
  001ef	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$21270[rsp]
  001f4	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  001f8	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1155 :             pivot = *p;

  001fd	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00202	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00205	48 89 44 24 28	 mov	 QWORD PTR pivot$[rsp], rax

; 1156 :             l += offset;

  0020a	48 8b 44 24 38	 mov	 rax, QWORD PTR l$[rsp]
  0020f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$21270[rsp]
  00214	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00218	48 89 44 24 38	 mov	 QWORD PTR l$[rsp], rax

; 1157 :             for (p = start + offset; p > l; --p)

  0021d	48 8b 44 24 70	 mov	 rax, QWORD PTR start$[rsp]
  00222	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$21270[rsp]
  00227	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0022b	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00230	eb 0e		 jmp	 SHORT $LN3@binarysort
$LN2@binarysort:
  00232	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00237	48 83 e8 08	 sub	 rax, 8
  0023b	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN3@binarysort:
  00240	48 8b 44 24 38	 mov	 rax, QWORD PTR l$[rsp]
  00245	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  0024a	76 13		 jbe	 SHORT $LN1@binarysort

; 1158 :                 *p = *(p-1);

  0024c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00251	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00256	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0025a	48 89 08	 mov	 QWORD PTR [rax], rcx
  0025d	eb d3		 jmp	 SHORT $LN2@binarysort
$LN1@binarysort:

; 1159 :             *l = pivot;

  0025f	48 8b 44 24 38	 mov	 rax, QWORD PTR l$[rsp]
  00264	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pivot$[rsp]
  00269	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN4@binarysort:

; 1160 :         }
; 1161 :     }

  0026c	e9 f8 fd ff ff	 jmp	 $LN15@binarysort
$LN14@binarysort:

; 1162 :     return 0;

  00271	33 c0		 xor	 eax, eax
  00273	eb 05		 jmp	 SHORT $LN18@binarysort
$fail$21260:

; 1163 : 
; 1164 :  fail:
; 1165 :     return -1;

  00275	b8 ff ff ff ff	 mov	 eax, -1
$LN18@binarysort:

; 1166 : }

  0027a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0027e	c3		 ret	 0
binarysort ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BA@GGGPDPJM@?$AAl?$AAo?$AA?5?$AA?$DM?$AA?5?$AAh?$AAi?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_run DD imagerel count_run
	DD	imagerel count_run+423
	DD	imagerel $unwind$count_run
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_run DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1BA@GGGPDPJM@?$AAl?$AAo?$AA?5?$AA?$DM?$AA?5?$AAh?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@GGGPDPJM@?$AAl?$AAo?$AA?5?$AA?$DM?$AA?5?$AAh?$AAi?$AA?$AA@ DB 'l'
	DB	00H, 'o', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'h', 00H, 'i', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT count_run
_TEXT	SEGMENT
n$ = 32
k$ = 40
lo$ = 64
hi$ = 72
descending$ = 80
count_run PROC						; COMDAT

; 1188 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1189 :     Py_ssize_t k;
; 1190 :     Py_ssize_t n;
; 1191 : 
; 1192 :     assert(lo < hi);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR hi$[rsp]
  00018	48 39 44 24 40	 cmp	 QWORD PTR lo$[rsp], rax
  0001d	72 1c		 jb	 SHORT $LN18@count_run
  0001f	41 b8 a8 04 00
	00		 mov	 r8d, 1192		; 000004a8H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BA@GGGPDPJM@?$AAl?$AAo?$AA?5?$AA?$DM?$AA?5?$AAh?$AAi?$AA?$AA@
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00039	33 c0		 xor	 eax, eax
$LN18@count_run:

; 1193 :     *descending = 0;

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR descending$[rsp]
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1194 :     ++lo;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  0004b	48 83 c0 08	 add	 rax, 8
  0004f	48 89 44 24 40	 mov	 QWORD PTR lo$[rsp], rax

; 1195 :     if (lo == hi)

  00054	48 8b 44 24 48	 mov	 rax, QWORD PTR hi$[rsp]
  00059	48 39 44 24 40	 cmp	 QWORD PTR lo$[rsp], rax
  0005e	75 0a		 jne	 SHORT $LN15@count_run

; 1196 :         return 1;

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	e9 38 01 00 00	 jmp	 $LN16@count_run
$LN15@count_run:

; 1197 : 
; 1198 :     n = 2;

  0006a	48 c7 44 24 20
	02 00 00 00	 mov	 QWORD PTR n$[rsp], 2

; 1199 :     IFLT(*lo, *(lo-1)) {

  00073	45 33 c0	 xor	 r8d, r8d
  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  0007b	48 8b 50 f8	 mov	 rdx, QWORD PTR [rax-8]
  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  00084	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00087	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0008c	48 98		 cdqe
  0008e	48 89 44 24 28	 mov	 QWORD PTR k$[rsp], rax
  00093	48 83 7c 24 28
	00		 cmp	 QWORD PTR k$[rsp], 0
  00099	7d 05		 jge	 SHORT $LN14@count_run
  0009b	e9 fb 00 00 00	 jmp	 $fail$21288
$LN14@count_run:
  000a0	48 83 7c 24 28
	00		 cmp	 QWORD PTR k$[rsp], 0
  000a6	74 7f		 je	 SHORT $LN13@count_run

; 1200 :         *descending = 1;

  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR descending$[rsp]
  000ad	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 1201 :         for (lo = lo+1; lo < hi; ++lo, ++n) {

  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  000b8	48 83 c0 08	 add	 rax, 8
  000bc	48 89 44 24 40	 mov	 QWORD PTR lo$[rsp], rax
  000c1	eb 1b		 jmp	 SHORT $LN12@count_run
$LN11@count_run:
  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  000c8	48 83 c0 08	 add	 rax, 8
  000cc	48 89 44 24 40	 mov	 QWORD PTR lo$[rsp], rax
  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000d6	48 ff c0	 inc	 rax
  000d9	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax
$LN12@count_run:
  000de	48 8b 44 24 48	 mov	 rax, QWORD PTR hi$[rsp]
  000e3	48 39 44 24 40	 cmp	 QWORD PTR lo$[rsp], rax
  000e8	73 3b		 jae	 SHORT $LN10@count_run

; 1202 :             IFLT(*lo, *(lo-1))

  000ea	45 33 c0	 xor	 r8d, r8d
  000ed	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  000f2	48 8b 50 f8	 mov	 rdx, QWORD PTR [rax-8]
  000f6	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  000fb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000fe	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00103	48 98		 cdqe
  00105	48 89 44 24 28	 mov	 QWORD PTR k$[rsp], rax
  0010a	48 83 7c 24 28
	00		 cmp	 QWORD PTR k$[rsp], 0
  00110	7d 05		 jge	 SHORT $LN9@count_run
  00112	e9 84 00 00 00	 jmp	 $fail$21288
$LN9@count_run:
  00117	48 83 7c 24 28
	00		 cmp	 QWORD PTR k$[rsp], 0
  0011d	74 02		 je	 SHORT $LN8@count_run

; 1203 :                 ;
; 1204 :             else

  0011f	eb 02		 jmp	 SHORT $LN7@count_run
$LN8@count_run:

; 1205 :                 break;

  00121	eb 02		 jmp	 SHORT $LN10@count_run
$LN7@count_run:

; 1206 :         }

  00123	eb 9e		 jmp	 SHORT $LN11@count_run
$LN10@count_run:

; 1207 :     }
; 1208 :     else {

  00125	eb 6d		 jmp	 SHORT $LN6@count_run
$LN13@count_run:

; 1209 :         for (lo = lo+1; lo < hi; ++lo, ++n) {

  00127	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  0012c	48 83 c0 08	 add	 rax, 8
  00130	48 89 44 24 40	 mov	 QWORD PTR lo$[rsp], rax
  00135	eb 1b		 jmp	 SHORT $LN5@count_run
$LN4@count_run:
  00137	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  0013c	48 83 c0 08	 add	 rax, 8
  00140	48 89 44 24 40	 mov	 QWORD PTR lo$[rsp], rax
  00145	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  0014a	48 ff c0	 inc	 rax
  0014d	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax
$LN5@count_run:
  00152	48 8b 44 24 48	 mov	 rax, QWORD PTR hi$[rsp]
  00157	48 39 44 24 40	 cmp	 QWORD PTR lo$[rsp], rax
  0015c	73 36		 jae	 SHORT $LN3@count_run

; 1210 :             IFLT(*lo, *(lo-1))

  0015e	45 33 c0	 xor	 r8d, r8d
  00161	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  00166	48 8b 50 f8	 mov	 rdx, QWORD PTR [rax-8]
  0016a	48 8b 44 24 40	 mov	 rax, QWORD PTR lo$[rsp]
  0016f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00172	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00177	48 98		 cdqe
  00179	48 89 44 24 28	 mov	 QWORD PTR k$[rsp], rax
  0017e	48 83 7c 24 28
	00		 cmp	 QWORD PTR k$[rsp], 0
  00184	7d 02		 jge	 SHORT $LN2@count_run
  00186	eb 13		 jmp	 SHORT $fail$21288
$LN2@count_run:
  00188	48 83 7c 24 28
	00		 cmp	 QWORD PTR k$[rsp], 0
  0018e	74 02		 je	 SHORT $LN1@count_run

; 1211 :                 break;

  00190	eb 02		 jmp	 SHORT $LN3@count_run
$LN1@count_run:

; 1212 :         }

  00192	eb a3		 jmp	 SHORT $LN4@count_run
$LN3@count_run:
$LN6@count_run:

; 1213 :     }
; 1214 : 
; 1215 :     return n;

  00194	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00199	eb 07		 jmp	 SHORT $LN16@count_run
$fail$21288:

; 1216 : fail:
; 1217 :     return -1;

  0019b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN16@count_run:

; 1218 : }

  001a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001a6	c3		 ret	 0
count_run ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BG@FDEHGCMB@?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_init DD imagerel merge_init
	DD	imagerel merge_init+223
	DD	imagerel $unwind$merge_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_init DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_1BG@FDEHGCMB@?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@FDEHGCMB@?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'm'
	DB	00H, 's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT merge_init
_TEXT	SEGMENT
ms$ = 48
list_size$ = 56
has_keyfunc$ = 64
merge_init PROC						; COMDAT

; 1465 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1466 :     assert(ms != NULL);

  00013	48 83 7c 24 30
	00		 cmp	 QWORD PTR ms$[rsp], 0
  00019	75 1c		 jne	 SHORT $LN6@merge_init
  0001b	41 b8 ba 05 00
	00		 mov	 r8d, 1466		; 000005baH
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@FDEHGCMB@?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00035	33 c0		 xor	 eax, eax
$LN6@merge_init:

; 1467 :     if (has_keyfunc) {

  00037	83 7c 24 40 00	 cmp	 DWORD PTR has_keyfunc$[rsp], 0
  0003c	74 56		 je	 SHORT $LN3@merge_init

; 1468 :         /* The temporary space for merging will need at most half the list
; 1469 :          * size rounded up.  Use the minimum possible space so we can use the
; 1470 :          * rest of temparray for other things.  In particular, if there is
; 1471 :          * enough extra space, listsort() will use it to store the keys.
; 1472 :          */
; 1473 :         ms->alloced = (list_size + 1) / 2;

  0003e	48 8b 44 24 38	 mov	 rax, QWORD PTR list_size$[rsp]
  00043	48 ff c0	 inc	 rax
  00046	48 99		 cdq
  00048	48 2b c2	 sub	 rax, rdx
  0004b	48 d1 f8	 sar	 rax, 1
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ms$[rsp]
  00053	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1474 : 
; 1475 :         /* ms->alloced describes how many keys will be stored at
; 1476 :            ms->temparray, but we also need to store the values.  Hence,
; 1477 :            ms->alloced is capped at half of MERGESTATE_TEMP_SIZE. */
; 1478 :         if (MERGESTATE_TEMP_SIZE / 2 < ms->alloced)

  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR ms$[rsp]
  0005c	48 81 78 18 80
	00 00 00	 cmp	 QWORD PTR [rax+24], 128	; 00000080H
  00064	7e 0d		 jle	 SHORT $LN2@merge_init

; 1479 :             ms->alloced = MERGESTATE_TEMP_SIZE / 2;

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR ms$[rsp]
  0006b	48 c7 40 18 80
	00 00 00	 mov	 QWORD PTR [rax+24], 128	; 00000080H
$LN2@merge_init:

; 1480 :         ms->a.values = &ms->temparray[ms->alloced];

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR ms$[rsp]
  00078	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ms$[rsp]
  00081	48 8d 84 c1 20
	08 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+2080]
  00089	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ms$[rsp]
  0008e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1481 :     }
; 1482 :     else {

  00092	eb 1a		 jmp	 SHORT $LN1@merge_init
$LN3@merge_init:

; 1483 :         ms->alloced = MERGESTATE_TEMP_SIZE;

  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR ms$[rsp]
  00099	48 c7 40 18 00
	01 00 00	 mov	 QWORD PTR [rax+24], 256	; 00000100H

; 1484 :         ms->a.values = NULL;

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR ms$[rsp]
  000a6	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN1@merge_init:

; 1485 :     }
; 1486 :     ms->a.keys = ms->temparray;

  000ae	48 8b 44 24 30	 mov	 rax, QWORD PTR ms$[rsp]
  000b3	48 05 20 08 00
	00		 add	 rax, 2080		; 00000820H
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ms$[rsp]
  000be	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1487 :     ms->n = 0;

  000c2	48 8b 44 24 30	 mov	 rax, QWORD PTR ms$[rsp]
  000c7	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 1488 :     ms->min_gallop = MIN_GALLOP;

  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR ms$[rsp]
  000d3	48 c7 00 07 00
	00 00		 mov	 QWORD PTR [rax], 7

; 1489 : }

  000da	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000de	c3		 ret	 0
merge_init ENDP
_TEXT	ENDS
EXTRN	PyMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_freemem DD imagerel merge_freemem
	DD	imagerel merge_freemem+86
	DD	imagerel $unwind$merge_freemem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_freemem DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT merge_freemem
_TEXT	SEGMENT
ms$ = 48
merge_freemem PROC					; COMDAT

; 1497 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1498 :     assert(ms != NULL);

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR ms$[rsp], 0
  0000f	75 1c		 jne	 SHORT $LN4@merge_free
  00011	41 b8 da 05 00
	00		 mov	 r8d, 1498		; 000005daH
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@FDEHGCMB@?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002b	33 c0		 xor	 eax, eax
$LN4@merge_free:

; 1499 :     if (ms->a.keys != ms->temparray)

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR ms$[rsp]
  00032	48 05 20 08 00
	00		 add	 rax, 2080		; 00000820H
  00038	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ms$[rsp]
  0003d	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00041	74 0e		 je	 SHORT $LN1@merge_free

; 1500 :         PyMem_Free(ms->a.keys);

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR ms$[rsp]
  00048	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0004c	e8 00 00 00 00	 call	 PyMem_Free
$LN1@merge_free:

; 1501 : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
merge_freemem ENDP
_TEXT	ENDS
PUBLIC	??_C@_15IDNNENKK@?$AAm?$AAs?$AA?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_collapse DD imagerel merge_collapse
	DD	imagerel merge_collapse+343
	DD	imagerel $unwind$merge_collapse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_collapse DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_15IDNNENKK@?$AAm?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15IDNNENKK@?$AAm?$AAs?$AA?$AA@ DB 'm', 00H, 's', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT merge_collapse
_TEXT	SEGMENT
p$ = 32
n$21610 = 40
ms$ = 64
merge_collapse PROC					; COMDAT

; 1883 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1884 :     struct s_slice *p = ms->pending;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  0000e	48 83 c0 28	 add	 rax, 40			; 00000028H
  00012	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1885 : 
; 1886 :     assert(ms);

  00017	48 83 7c 24 40
	00		 cmp	 QWORD PTR ms$[rsp], 0
  0001d	75 1c		 jne	 SHORT $LN12@merge_coll
  0001f	41 b8 5e 07 00
	00		 mov	 r8d, 1886		; 0000075eH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_15IDNNENKK@?$AAm?$AAs?$AA?$AA@
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00039	33 c0		 xor	 eax, eax
$LN12@merge_coll:
$LN9@merge_coll:

; 1887 :     while (ms->n > 1) {

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  00040	83 78 20 01	 cmp	 DWORD PTR [rax+32], 1
  00044	0f 8e 06 01 00
	00		 jle	 $LN8@merge_coll

; 1888 :         Py_ssize_t n = ms->n - 2;

  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  0004f	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00052	83 e8 02	 sub	 eax, 2
  00055	48 98		 cdqe
  00057	48 89 44 24 28	 mov	 QWORD PTR n$21610[rsp], rax

; 1889 :         if (n > 0 && p[n-1].len <= p[n].len + p[n+1].len) {

  0005c	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$21610[rsp], 0
  00062	0f 8e 99 00 00
	00		 jle	 $LN7@merge_coll
  00068	48 8b 44 24 28	 mov	 rax, QWORD PTR n$21610[rsp]
  0006d	48 ff c8	 dec	 rax
  00070	48 6b c0 18	 imul	 rax, 24
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$21610[rsp]
  00079	48 6b c9 18	 imul	 rcx, 24
  0007d	48 8b 54 24 28	 mov	 rdx, QWORD PTR n$21610[rsp]
  00082	48 ff c2	 inc	 rdx
  00085	48 6b d2 18	 imul	 rdx, 24
  00089	4c 8b 44 24 20	 mov	 r8, QWORD PTR p$[rsp]
  0008e	49 8b 4c 08 10	 mov	 rcx, QWORD PTR [r8+rcx+16]
  00093	4c 8b 44 24 20	 mov	 r8, QWORD PTR p$[rsp]
  00098	49 03 4c 10 10	 add	 rcx, QWORD PTR [r8+rdx+16]
  0009d	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  000a2	48 39 4c 02 10	 cmp	 QWORD PTR [rdx+rax+16], rcx
  000a7	7f 58		 jg	 SHORT $LN7@merge_coll

; 1890 :             if (p[n-1].len < p[n+1].len)

  000a9	48 8b 44 24 28	 mov	 rax, QWORD PTR n$21610[rsp]
  000ae	48 ff c8	 dec	 rax
  000b1	48 6b c0 18	 imul	 rax, 24
  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$21610[rsp]
  000ba	48 ff c1	 inc	 rcx
  000bd	48 6b c9 18	 imul	 rcx, 24
  000c1	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  000c6	4c 8b 44 24 20	 mov	 r8, QWORD PTR p$[rsp]
  000cb	49 8b 4c 08 10	 mov	 rcx, QWORD PTR [r8+rcx+16]
  000d0	48 39 4c 02 10	 cmp	 QWORD PTR [rdx+rax+16], rcx
  000d5	7d 0d		 jge	 SHORT $LN6@merge_coll

; 1891 :                 --n;

  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR n$21610[rsp]
  000dc	48 ff c8	 dec	 rax
  000df	48 89 44 24 28	 mov	 QWORD PTR n$21610[rsp], rax
$LN6@merge_coll:

; 1892 :             if (merge_at(ms, n) < 0)

  000e4	48 8b 54 24 28	 mov	 rdx, QWORD PTR n$21610[rsp]
  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ms$[rsp]
  000ee	e8 00 00 00 00	 call	 merge_at
  000f3	48 85 c0	 test	 rax, rax
  000f6	7d 07		 jge	 SHORT $LN5@merge_coll

; 1893 :                 return -1;

  000f8	b8 ff ff ff ff	 mov	 eax, -1
  000fd	eb 53		 jmp	 SHORT $LN10@merge_coll
$LN5@merge_coll:

; 1894 :         }
; 1895 :         else if (p[n].len <= p[n+1].len) {

  000ff	eb 4a		 jmp	 SHORT $LN4@merge_coll
$LN7@merge_coll:
  00101	48 8b 44 24 28	 mov	 rax, QWORD PTR n$21610[rsp]
  00106	48 6b c0 18	 imul	 rax, 24
  0010a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$21610[rsp]
  0010f	48 ff c1	 inc	 rcx
  00112	48 6b c9 18	 imul	 rcx, 24
  00116	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  0011b	4c 8b 44 24 20	 mov	 r8, QWORD PTR p$[rsp]
  00120	49 8b 4c 08 10	 mov	 rcx, QWORD PTR [r8+rcx+16]
  00125	48 39 4c 02 10	 cmp	 QWORD PTR [rdx+rax+16], rcx
  0012a	7f 1d		 jg	 SHORT $LN3@merge_coll

; 1896 :                  if (merge_at(ms, n) < 0)

  0012c	48 8b 54 24 28	 mov	 rdx, QWORD PTR n$21610[rsp]
  00131	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ms$[rsp]
  00136	e8 00 00 00 00	 call	 merge_at
  0013b	48 85 c0	 test	 rax, rax
  0013e	7d 07		 jge	 SHORT $LN2@merge_coll

; 1897 :                         return -1;

  00140	b8 ff ff ff ff	 mov	 eax, -1
  00145	eb 0b		 jmp	 SHORT $LN10@merge_coll
$LN2@merge_coll:

; 1898 :         }
; 1899 :         else

  00147	eb 02		 jmp	 SHORT $LN1@merge_coll
$LN3@merge_coll:

; 1900 :             break;

  00149	eb 05		 jmp	 SHORT $LN8@merge_coll
$LN1@merge_coll:
$LN4@merge_coll:

; 1901 :     }

  0014b	e9 eb fe ff ff	 jmp	 $LN9@merge_coll
$LN8@merge_coll:

; 1902 :     return 0;

  00150	33 c0		 xor	 eax, eax
$LN10@merge_coll:

; 1903 : }

  00152	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00156	c3		 ret	 0
merge_collapse ENDP
_TEXT	ENDS
PUBLIC	$T23365
PUBLIC	$T23366
PUBLIC	$T23363
PUBLIC	$T23364
PUBLIC	$T23367
PUBLIC	??_C@_1DE@HPMMPCN@?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CL?$AA?5?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@MKONKGEB@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	$T23368
PUBLIC	$T23369
PUBLIC	??_C@_1EC@GDKBDCIN@?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?9?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?9?$AA?5?$AA3@ ; `string'
PUBLIC	??_C@_1O@ILILCEBJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@JCNKDMNA@?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_at DD imagerel merge_at
	DD	imagerel merge_at+1078
	DD	imagerel $unwind$merge_at
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_at DD 041301H
	DD	01f0113H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_1DE@HPMMPCN@?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CL?$AA?5?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@HPMMPCN@?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CL?$AA?5?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?$AA@ DB 's'
	DB	00H, 's', 00H, 'a', 00H, '.', 00H, 'k', 00H, 'e', 00H, 'y', 00H
	DB	's', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'n', 00H, 'a', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 's', 00H, 's', 00H, 'b', 00H
	DB	'.', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@MKONKGEB@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MKONKGEB@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 'a', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'n', 00H, 'b', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@GDKBDCIN@?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?9?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?9?$AA?5?$AA3@
CONST	SEGMENT
??_C@_1EC@GDKBDCIN@?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?9?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?9?$AA?5?$AA3@ DB 'i'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'm', 00H, 's', 00H
	DB	'-', 00H, '>', 00H, 'n', 00H, ' ', 00H, '-', 00H, ' ', 00H, '2'
	DB	00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'i', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'm', 00H, 's', 00H, '-', 00H, '>'
	DB	00H, 'n', 00H, ' ', 00H, '-', 00H, ' ', 00H, '3', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@ILILCEBJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1O@ILILCEBJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'i', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@JCNKDMNA@?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@JCNKDMNA@?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?$AA@ DB 'm'
	DB	00H, 's', 00H, '-', 00H, '>', 00H, 'n', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '2', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT merge_at
_TEXT	SEGMENT
ssa$ = 48
na$ = 64
ssb$ = 72
k$ = 88
nb$ = 96
$T23363 = 112
$T23364 = 128
$T23365 = 144
$T23366 = 160
$T23367 = 176
$T23368 = 200
$T23369 = 216
ms$ = 272
i$ = 280
merge_at PROC						; COMDAT

; 1818 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 1819 :     sortslice ssa, ssb;
; 1820 :     Py_ssize_t na, nb;
; 1821 :     Py_ssize_t k;
; 1822 : 
; 1823 :     assert(ms != NULL);

  00013	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR ms$[rsp], 0
  0001c	75 1c		 jne	 SHORT $LN9@merge_at
  0001e	41 b8 1f 07 00
	00		 mov	 r8d, 1823		; 0000071fH
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@FDEHGCMB@?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00038	33 c0		 xor	 eax, eax
$LN9@merge_at:

; 1824 :     assert(ms->n >= 2);

  0003a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  00042	83 78 20 02	 cmp	 DWORD PTR [rax+32], 2
  00046	7d 1c		 jge	 SHORT $LN10@merge_at
  00048	41 b8 20 07 00
	00		 mov	 r8d, 1824		; 00000720H
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@JCNKDMNA@?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN10@merge_at:

; 1825 :     assert(i >= 0);

  00064	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR i$[rsp], 0
  0006d	7d 1c		 jge	 SHORT $LN11@merge_at
  0006f	41 b8 21 07 00
	00		 mov	 r8d, 1825		; 00000721H
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@ILILCEBJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00089	33 c0		 xor	 eax, eax
$LN11@merge_at:

; 1826 :     assert(i == ms->n - 2 || i == ms->n - 3);

  0008b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  00093	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00096	83 e8 02	 sub	 eax, 2
  00099	48 98		 cdqe
  0009b	48 39 84 24 18
	01 00 00	 cmp	 QWORD PTR i$[rsp], rax
  000a3	74 36		 je	 SHORT $LN12@merge_at
  000a5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  000ad	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000b0	83 e8 03	 sub	 eax, 3
  000b3	48 98		 cdqe
  000b5	48 39 84 24 18
	01 00 00	 cmp	 QWORD PTR i$[rsp], rax
  000bd	74 1c		 je	 SHORT $LN12@merge_at
  000bf	41 b8 22 07 00
	00		 mov	 r8d, 1826		; 00000722H
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@GDKBDCIN@?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?9?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAs?$AA?9?$AA?$DO?$AAn?$AA?5?$AA?9?$AA?5?$AA3@
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d9	33 c0		 xor	 eax, eax
$LN12@merge_at:

; 1827 : 
; 1828 :     ssa = ms->pending[i].base;

  000db	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR i$[rsp]
  000e3	48 6b c0 18	 imul	 rax, 24
  000e7	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR $T23369[rsp]
  000ef	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR ms$[rsp]
  000f7	48 8b f9	 mov	 rdi, rcx
  000fa	48 8d 74 02 28	 lea	 rsi, QWORD PTR [rdx+rax+40]
  000ff	b9 10 00 00 00	 mov	 ecx, 16
  00104	f3 a4		 rep movsb
  00106	48 8d 44 24 30	 lea	 rax, QWORD PTR ssa$[rsp]
  0010b	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR $T23369[rsp]
  00113	48 8b f8	 mov	 rdi, rax
  00116	48 8b f1	 mov	 rsi, rcx
  00119	b9 10 00 00 00	 mov	 ecx, 16
  0011e	f3 a4		 rep movsb

; 1829 :     na = ms->pending[i].len;

  00120	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR i$[rsp]
  00128	48 6b c0 18	 imul	 rax, 24
  0012c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  00134	48 8b 44 01 38	 mov	 rax, QWORD PTR [rcx+rax+56]
  00139	48 89 44 24 40	 mov	 QWORD PTR na$[rsp], rax

; 1830 :     ssb = ms->pending[i+1].base;

  0013e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR i$[rsp]
  00146	48 ff c0	 inc	 rax
  00149	48 6b c0 18	 imul	 rax, 24
  0014d	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR $T23368[rsp]
  00155	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR ms$[rsp]
  0015d	48 8b f9	 mov	 rdi, rcx
  00160	48 8d 74 02 28	 lea	 rsi, QWORD PTR [rdx+rax+40]
  00165	b9 10 00 00 00	 mov	 ecx, 16
  0016a	f3 a4		 rep movsb
  0016c	48 8d 44 24 48	 lea	 rax, QWORD PTR ssb$[rsp]
  00171	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR $T23368[rsp]
  00179	48 8b f8	 mov	 rdi, rax
  0017c	48 8b f1	 mov	 rsi, rcx
  0017f	b9 10 00 00 00	 mov	 ecx, 16
  00184	f3 a4		 rep movsb

; 1831 :     nb = ms->pending[i+1].len;

  00186	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0018e	48 ff c0	 inc	 rax
  00191	48 6b c0 18	 imul	 rax, 24
  00195	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  0019d	48 8b 44 01 38	 mov	 rax, QWORD PTR [rcx+rax+56]
  001a2	48 89 44 24 60	 mov	 QWORD PTR nb$[rsp], rax

; 1832 :     assert(na > 0 && nb > 0);

  001a7	48 83 7c 24 40
	00		 cmp	 QWORD PTR na$[rsp], 0
  001ad	7e 08		 jle	 SHORT $LN13@merge_at
  001af	48 83 7c 24 60
	00		 cmp	 QWORD PTR nb$[rsp], 0
  001b5	7f 1c		 jg	 SHORT $LN14@merge_at
$LN13@merge_at:
  001b7	41 b8 28 07 00
	00		 mov	 r8d, 1832		; 00000728H
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MKONKGEB@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d1	33 c0		 xor	 eax, eax
$LN14@merge_at:

; 1833 :     assert(ssa.keys + na == ssb.keys);

  001d3	48 8b 44 24 30	 mov	 rax, QWORD PTR ssa$[rsp]
  001d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR na$[rsp]
  001dd	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  001e1	48 3b 44 24 48	 cmp	 rax, QWORD PTR ssb$[rsp]
  001e6	74 1c		 je	 SHORT $LN15@merge_at
  001e8	41 b8 29 07 00
	00		 mov	 r8d, 1833		; 00000729H
  001ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@HPMMPCN@?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CL?$AA?5?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?$AA@
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00202	33 c0		 xor	 eax, eax
$LN15@merge_at:

; 1834 : 
; 1835 :     /* Record the length of the combined runs; if i is the 3rd-last
; 1836 :      * run now, also slide over the last run (which isn't involved
; 1837 :      * in this merge).  The current run i+1 goes away in any case.
; 1838 :      */
; 1839 :     ms->pending[i].len = na + nb;

  00204	48 8b 44 24 60	 mov	 rax, QWORD PTR nb$[rsp]
  00209	48 8b 4c 24 40	 mov	 rcx, QWORD PTR na$[rsp]
  0020e	48 03 c8	 add	 rcx, rax
  00211	48 8b c1	 mov	 rax, rcx
  00214	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  0021c	48 6b c9 18	 imul	 rcx, 24
  00220	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR ms$[rsp]
  00228	48 89 44 0a 38	 mov	 QWORD PTR [rdx+rcx+56], rax

; 1840 :     if (i == ms->n - 3)

  0022d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  00235	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00238	83 e8 03	 sub	 eax, 3
  0023b	48 98		 cdqe
  0023d	48 39 84 24 18
	01 00 00	 cmp	 QWORD PTR i$[rsp], rax
  00245	75 5d		 jne	 SHORT $LN6@merge_at

; 1841 :         ms->pending[i+1] = ms->pending[i+2];

  00247	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0024f	48 83 c0 02	 add	 rax, 2
  00253	48 6b c0 18	 imul	 rax, 24
  00257	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T23367[rsp]
  0025f	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR ms$[rsp]
  00267	48 8b f9	 mov	 rdi, rcx
  0026a	48 8d 74 02 28	 lea	 rsi, QWORD PTR [rdx+rax+40]
  0026f	b9 18 00 00 00	 mov	 ecx, 24
  00274	f3 a4		 rep movsb
  00276	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0027e	48 ff c0	 inc	 rax
  00281	48 6b c0 18	 imul	 rax, 24
  00285	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  0028d	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR $T23367[rsp]
  00295	48 8d 7c 01 28	 lea	 rdi, QWORD PTR [rcx+rax+40]
  0029a	48 8b f2	 mov	 rsi, rdx
  0029d	b9 18 00 00 00	 mov	 ecx, 24
  002a2	f3 a4		 rep movsb
$LN6@merge_at:

; 1842 :     --ms->n;

  002a4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  002ac	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  002af	ff c8		 dec	 eax
  002b1	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  002b9	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 1843 : 
; 1844 :     /* Where does b start in a?  Elements in a before that can be
; 1845 :      * ignored (already in place).
; 1846 :      */
; 1847 :     k = gallop_right(*ssb.keys, ssa.keys, na, 0);

  002bc	45 33 c9	 xor	 r9d, r9d
  002bf	4c 8b 44 24 40	 mov	 r8, QWORD PTR na$[rsp]
  002c4	48 8b 54 24 30	 mov	 rdx, QWORD PTR ssa$[rsp]
  002c9	48 8b 44 24 48	 mov	 rax, QWORD PTR ssb$[rsp]
  002ce	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002d1	e8 00 00 00 00	 call	 gallop_right
  002d6	48 89 44 24 58	 mov	 QWORD PTR k$[rsp], rax

; 1848 :     if (k < 0)

  002db	48 83 7c 24 58
	00		 cmp	 QWORD PTR k$[rsp], 0
  002e1	7d 0c		 jge	 SHORT $LN5@merge_at

; 1849 :         return -1;

  002e3	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  002ea	e9 3d 01 00 00	 jmp	 $LN7@merge_at
$LN5@merge_at:

; 1850 :     sortslice_advance(&ssa, k);

  002ef	48 8b 54 24 58	 mov	 rdx, QWORD PTR k$[rsp]
  002f4	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ssa$[rsp]
  002f9	e8 00 00 00 00	 call	 sortslice_advance

; 1851 :     na -= k;

  002fe	48 8b 44 24 58	 mov	 rax, QWORD PTR k$[rsp]
  00303	48 8b 4c 24 40	 mov	 rcx, QWORD PTR na$[rsp]
  00308	48 2b c8	 sub	 rcx, rax
  0030b	48 8b c1	 mov	 rax, rcx
  0030e	48 89 44 24 40	 mov	 QWORD PTR na$[rsp], rax

; 1852 :     if (na == 0)

  00313	48 83 7c 24 40
	00		 cmp	 QWORD PTR na$[rsp], 0
  00319	75 07		 jne	 SHORT $LN4@merge_at

; 1853 :         return 0;

  0031b	33 c0		 xor	 eax, eax
  0031d	e9 0a 01 00 00	 jmp	 $LN7@merge_at
$LN4@merge_at:

; 1854 : 
; 1855 :     /* Where does a end in b?  Elements in b after that can be
; 1856 :      * ignored (already in place).
; 1857 :      */
; 1858 :     nb = gallop_left(ssa.keys[na-1], ssb.keys, nb, nb-1);

  00322	48 8b 44 24 60	 mov	 rax, QWORD PTR nb$[rsp]
  00327	48 ff c8	 dec	 rax
  0032a	4c 8b c8	 mov	 r9, rax
  0032d	4c 8b 44 24 60	 mov	 r8, QWORD PTR nb$[rsp]
  00332	48 8b 54 24 48	 mov	 rdx, QWORD PTR ssb$[rsp]
  00337	48 8b 44 24 30	 mov	 rax, QWORD PTR ssa$[rsp]
  0033c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR na$[rsp]
  00341	48 8b 4c c8 f8	 mov	 rcx, QWORD PTR [rax+rcx*8-8]
  00346	e8 00 00 00 00	 call	 gallop_left
  0034b	48 89 44 24 60	 mov	 QWORD PTR nb$[rsp], rax

; 1859 :     if (nb <= 0)

  00350	48 83 7c 24 60
	00		 cmp	 QWORD PTR nb$[rsp], 0
  00356	7f 0a		 jg	 SHORT $LN3@merge_at

; 1860 :         return nb;

  00358	48 8b 44 24 60	 mov	 rax, QWORD PTR nb$[rsp]
  0035d	e9 ca 00 00 00	 jmp	 $LN7@merge_at
$LN3@merge_at:

; 1861 : 
; 1862 :     /* Merge what remains of the runs, using a temp array with
; 1863 :      * min(na, nb) elements.
; 1864 :      */
; 1865 :     if (na <= nb)

  00362	48 8b 44 24 60	 mov	 rax, QWORD PTR nb$[rsp]
  00367	48 39 44 24 40	 cmp	 QWORD PTR na$[rsp], rax
  0036c	7f 5e		 jg	 SHORT $LN2@merge_at

; 1866 :         return merge_lo(ms, ssa, na, ssb, nb);

  0036e	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T23364[rsp]
  00376	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ssb$[rsp]
  0037b	48 8b f8	 mov	 rdi, rax
  0037e	48 8b f1	 mov	 rsi, rcx
  00381	b9 10 00 00 00	 mov	 ecx, 16
  00386	f3 a4		 rep movsb
  00388	48 8d 44 24 70	 lea	 rax, QWORD PTR $T23363[rsp]
  0038d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ssa$[rsp]
  00392	48 8b f8	 mov	 rdi, rax
  00395	48 8b f1	 mov	 rsi, rcx
  00398	b9 10 00 00 00	 mov	 ecx, 16
  0039d	f3 a4		 rep movsb
  0039f	48 8b 44 24 60	 mov	 rax, QWORD PTR nb$[rsp]
  003a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a9	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR $T23364[rsp]
  003b1	4c 8b 44 24 40	 mov	 r8, QWORD PTR na$[rsp]
  003b6	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T23363[rsp]
  003bb	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  003c3	e8 00 00 00 00	 call	 merge_lo
  003c8	eb 62		 jmp	 SHORT $LN7@merge_at

; 1867 :     else

  003ca	eb 60		 jmp	 SHORT $LN1@merge_at
$LN2@merge_at:

; 1868 :         return merge_hi(ms, ssa, na, ssb, nb);

  003cc	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T23366[rsp]
  003d4	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ssb$[rsp]
  003d9	48 8b f8	 mov	 rdi, rax
  003dc	48 8b f1	 mov	 rsi, rcx
  003df	b9 10 00 00 00	 mov	 ecx, 16
  003e4	f3 a4		 rep movsb
  003e6	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T23365[rsp]
  003ee	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ssa$[rsp]
  003f3	48 8b f8	 mov	 rdi, rax
  003f6	48 8b f1	 mov	 rsi, rcx
  003f9	b9 10 00 00 00	 mov	 ecx, 16
  003fe	f3 a4		 rep movsb
  00400	48 8b 44 24 60	 mov	 rax, QWORD PTR nb$[rsp]
  00405	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0040a	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR $T23366[rsp]
  00412	4c 8b 44 24 40	 mov	 r8, QWORD PTR na$[rsp]
  00417	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T23365[rsp]
  0041f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  00427	e8 00 00 00 00	 call	 merge_hi
$LN1@merge_at:
$LN7@merge_at:

; 1869 : }

  0042c	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00433	5f		 pop	 rdi
  00434	5e		 pop	 rsi
  00435	c3		 ret	 0
merge_at ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BO@DOKJOHEI@?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAf?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FG@OFKJHNKN@?$AA?9?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$DM?$AA?5?$AAo?$AAf?$AAs?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_1FG@GHKBPEIB@?$AAk?$AAe?$AAy?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh?$AAi?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$gallop_left DD imagerel gallop_left
	DD	imagerel gallop_left+885
	DD	imagerel $unwind$gallop_left
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gallop_left DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT ??_C@_1BO@DOKJOHEI@?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAf?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@DOKJOHEI@?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAf?$AAs?$AA?$AA@ DB 'l'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, 'o', 00H, 'f', 00H, 's', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o', 00H, 'f', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@OFKJHNKN@?$AA?9?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$DM?$AA?5?$AAo?$AAf?$AAs?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1FG@OFKJHNKN@?$AA?9?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$DM?$AA?5?$AAo?$AAf?$AAs?$AA?5?$AA?$CG@ DB '-'
	DB	00H, '1', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'l', 00H
	DB	'a', 00H, 's', 00H, 't', 00H, 'o', 00H, 'f', 00H, 's', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	't', 00H, 'o', 00H, 'f', 00H, 's', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 'o', 00H, 'f', 00H, 's', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, 's', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, 'n', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@GHKBPEIB@?$AAk?$AAe?$AAy?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh?$AAi?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1FG@GHKBPEIB@?$AAk?$AAe?$AAy?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh?$AAi?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@ DB 'k'
	DB	00H, 'e', 00H, 'y', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'a', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'n', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 'h', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' ', 00H, '>'
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 'h', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, 'n', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT gallop_left
_TEXT	SEGMENT
k$ = 32
lastofs$ = 40
ofs$ = 48
maxofs$21320 = 56
maxofs$21330 = 64
m$21343 = 72
key$ = 96
a$ = 104
n$ = 112
hint$ = 120
gallop_left PROC					; COMDAT

; 1243 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1244 :     Py_ssize_t ofs;
; 1245 :     Py_ssize_t lastofs;
; 1246 :     Py_ssize_t k;
; 1247 : 
; 1248 :     assert(key && a && n > 0 && hint >= 0 && hint < n);

  00018	48 83 7c 24 60
	00		 cmp	 QWORD PTR key$[rsp], 0
  0001e	74 24		 je	 SHORT $LN24@gallop_lef
  00020	48 83 7c 24 68
	00		 cmp	 QWORD PTR a$[rsp], 0
  00026	74 1c		 je	 SHORT $LN24@gallop_lef
  00028	48 83 7c 24 70
	00		 cmp	 QWORD PTR n$[rsp], 0
  0002e	7e 14		 jle	 SHORT $LN24@gallop_lef
  00030	48 83 7c 24 78
	00		 cmp	 QWORD PTR hint$[rsp], 0
  00036	7c 0c		 jl	 SHORT $LN24@gallop_lef
  00038	48 8b 44 24 70	 mov	 rax, QWORD PTR n$[rsp]
  0003d	48 39 44 24 78	 cmp	 QWORD PTR hint$[rsp], rax
  00042	7c 1c		 jl	 SHORT $LN25@gallop_lef
$LN24@gallop_lef:
  00044	41 b8 e0 04 00
	00		 mov	 r8d, 1248		; 000004e0H
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FG@GHKBPEIB@?$AAk?$AAe?$AAy?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh?$AAi?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005e	33 c0		 xor	 eax, eax
$LN25@gallop_lef:

; 1249 : 
; 1250 :     a += hint;

  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp]
  00065	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hint$[rsp]
  0006a	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0006e	48 89 44 24 68	 mov	 QWORD PTR a$[rsp], rax

; 1251 :     lastofs = 0;

  00073	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR lastofs$[rsp], 0

; 1252 :     ofs = 1;

  0007c	48 c7 44 24 30
	01 00 00 00	 mov	 QWORD PTR ofs$[rsp], 1

; 1253 :     IFLT(*a, key) {

  00085	45 33 c0	 xor	 r8d, r8d
  00088	48 8b 54 24 60	 mov	 rdx, QWORD PTR key$[rsp]
  0008d	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp]
  00092	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00095	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0009a	48 98		 cdqe
  0009c	48 89 44 24 20	 mov	 QWORD PTR k$[rsp], rax
  000a1	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  000a7	7d 05		 jge	 SHORT $LN21@gallop_lef
  000a9	e9 bb 02 00 00	 jmp	 $fail$21318
$LN21@gallop_lef:
  000ae	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  000b4	0f 84 ce 00 00
	00		 je	 $LN20@gallop_lef

; 1254 :         /* a[hint] < key -- gallop right, until
; 1255 :          * a[hint + lastofs] < key <= a[hint + ofs]
; 1256 :          */
; 1257 :         const Py_ssize_t maxofs = n - hint;             /* &a[n-1] is highest */

  000ba	48 8b 44 24 78	 mov	 rax, QWORD PTR hint$[rsp]
  000bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR n$[rsp]
  000c4	48 2b c8	 sub	 rcx, rax
  000c7	48 8b c1	 mov	 rax, rcx
  000ca	48 89 44 24 38	 mov	 QWORD PTR maxofs$21320[rsp], rax
$LN19@gallop_lef:

; 1258 :         while (ofs < maxofs) {

  000cf	48 8b 44 24 38	 mov	 rax, QWORD PTR maxofs$21320[rsp]
  000d4	48 39 44 24 30	 cmp	 QWORD PTR ofs$[rsp], rax
  000d9	7d 68		 jge	 SHORT $LN18@gallop_lef

; 1259 :             IFLT(a[ofs], key) {

  000db	45 33 c0	 xor	 r8d, r8d
  000de	48 8b 54 24 60	 mov	 rdx, QWORD PTR key$[rsp]
  000e3	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp]
  000e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ofs$[rsp]
  000ed	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  000f1	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000f6	48 98		 cdqe
  000f8	48 89 44 24 20	 mov	 QWORD PTR k$[rsp], rax
  000fd	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  00103	7d 05		 jge	 SHORT $LN17@gallop_lef
  00105	e9 5f 02 00 00	 jmp	 $fail$21318
$LN17@gallop_lef:
  0010a	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  00110	74 2d		 je	 SHORT $LN16@gallop_lef

; 1260 :                 lastofs = ofs;

  00112	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  00117	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax

; 1261 :                 ofs = (ofs << 1) + 1;

  0011c	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  00121	48 8d 44 00 01	 lea	 rax, QWORD PTR [rax+rax+1]
  00126	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax

; 1262 :                 if (ofs <= 0)                   /* int overflow */

  0012b	48 83 7c 24 30
	00		 cmp	 QWORD PTR ofs$[rsp], 0
  00131	7f 0a		 jg	 SHORT $LN15@gallop_lef

; 1263 :                     ofs = maxofs;

  00133	48 8b 44 24 38	 mov	 rax, QWORD PTR maxofs$21320[rsp]
  00138	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN15@gallop_lef:

; 1264 :             }
; 1265 :             else                /* key <= a[hint + ofs] */

  0013d	eb 02		 jmp	 SHORT $LN14@gallop_lef
$LN16@gallop_lef:

; 1266 :                 break;

  0013f	eb 02		 jmp	 SHORT $LN18@gallop_lef
$LN14@gallop_lef:

; 1267 :         }

  00141	eb 8c		 jmp	 SHORT $LN19@gallop_lef
$LN18@gallop_lef:

; 1268 :         if (ofs > maxofs)

  00143	48 8b 44 24 38	 mov	 rax, QWORD PTR maxofs$21320[rsp]
  00148	48 39 44 24 30	 cmp	 QWORD PTR ofs$[rsp], rax
  0014d	7e 0a		 jle	 SHORT $LN13@gallop_lef

; 1269 :             ofs = maxofs;

  0014f	48 8b 44 24 38	 mov	 rax, QWORD PTR maxofs$21320[rsp]
  00154	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN13@gallop_lef:

; 1270 :         /* Translate back to offsets relative to &a[0]. */
; 1271 :         lastofs += hint;

  00159	48 8b 44 24 78	 mov	 rax, QWORD PTR hint$[rsp]
  0015e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lastofs$[rsp]
  00163	48 03 c8	 add	 rcx, rax
  00166	48 8b c1	 mov	 rax, rcx
  00169	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax

; 1272 :         ofs += hint;

  0016e	48 8b 44 24 78	 mov	 rax, QWORD PTR hint$[rsp]
  00173	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ofs$[rsp]
  00178	48 03 c8	 add	 rcx, rax
  0017b	48 8b c1	 mov	 rax, rcx
  0017e	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax

; 1273 :     }
; 1274 :     else {

  00183	e9 d2 00 00 00	 jmp	 $LN12@gallop_lef
$LN20@gallop_lef:

; 1275 :         /* key <= a[hint] -- gallop left, until
; 1276 :          * a[hint - ofs] < key <= a[hint - lastofs]
; 1277 :          */
; 1278 :         const Py_ssize_t maxofs = hint + 1;             /* &a[0] is lowest */

  00188	48 8b 44 24 78	 mov	 rax, QWORD PTR hint$[rsp]
  0018d	48 ff c0	 inc	 rax
  00190	48 89 44 24 40	 mov	 QWORD PTR maxofs$21330[rsp], rax
$LN11@gallop_lef:

; 1279 :         while (ofs < maxofs) {

  00195	48 8b 44 24 40	 mov	 rax, QWORD PTR maxofs$21330[rsp]
  0019a	48 39 44 24 30	 cmp	 QWORD PTR ofs$[rsp], rax
  0019f	7d 6f		 jge	 SHORT $LN10@gallop_lef

; 1280 :             IFLT(*(a-ofs), key)

  001a1	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  001a6	48 c1 e0 03	 shl	 rax, 3
  001aa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR a$[rsp]
  001af	48 2b c8	 sub	 rcx, rax
  001b2	48 8b c1	 mov	 rax, rcx
  001b5	45 33 c0	 xor	 r8d, r8d
  001b8	48 8b 54 24 60	 mov	 rdx, QWORD PTR key$[rsp]
  001bd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001c0	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  001c5	48 98		 cdqe
  001c7	48 89 44 24 20	 mov	 QWORD PTR k$[rsp], rax
  001cc	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  001d2	7d 05		 jge	 SHORT $LN9@gallop_lef
  001d4	e9 90 01 00 00	 jmp	 $fail$21318
$LN9@gallop_lef:
  001d9	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  001df	74 02		 je	 SHORT $LN8@gallop_lef

; 1281 :                 break;

  001e1	eb 2d		 jmp	 SHORT $LN10@gallop_lef
$LN8@gallop_lef:

; 1282 :             /* key <= a[hint - ofs] */
; 1283 :             lastofs = ofs;

  001e3	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  001e8	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax

; 1284 :             ofs = (ofs << 1) + 1;

  001ed	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  001f2	48 8d 44 00 01	 lea	 rax, QWORD PTR [rax+rax+1]
  001f7	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax

; 1285 :             if (ofs <= 0)               /* int overflow */

  001fc	48 83 7c 24 30
	00		 cmp	 QWORD PTR ofs$[rsp], 0
  00202	7f 0a		 jg	 SHORT $LN7@gallop_lef

; 1286 :                 ofs = maxofs;

  00204	48 8b 44 24 40	 mov	 rax, QWORD PTR maxofs$21330[rsp]
  00209	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN7@gallop_lef:

; 1287 :         }

  0020e	eb 85		 jmp	 SHORT $LN11@gallop_lef
$LN10@gallop_lef:

; 1288 :         if (ofs > maxofs)

  00210	48 8b 44 24 40	 mov	 rax, QWORD PTR maxofs$21330[rsp]
  00215	48 39 44 24 30	 cmp	 QWORD PTR ofs$[rsp], rax
  0021a	7e 0a		 jle	 SHORT $LN6@gallop_lef

; 1289 :             ofs = maxofs;

  0021c	48 8b 44 24 40	 mov	 rax, QWORD PTR maxofs$21330[rsp]
  00221	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN6@gallop_lef:

; 1290 :         /* Translate back to positive offsets relative to &a[0]. */
; 1291 :         k = lastofs;

  00226	48 8b 44 24 28	 mov	 rax, QWORD PTR lastofs$[rsp]
  0022b	48 89 44 24 20	 mov	 QWORD PTR k$[rsp], rax

; 1292 :         lastofs = hint - ofs;

  00230	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  00235	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hint$[rsp]
  0023a	48 2b c8	 sub	 rcx, rax
  0023d	48 8b c1	 mov	 rax, rcx
  00240	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax

; 1293 :         ofs = hint - k;

  00245	48 8b 44 24 20	 mov	 rax, QWORD PTR k$[rsp]
  0024a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hint$[rsp]
  0024f	48 2b c8	 sub	 rcx, rax
  00252	48 8b c1	 mov	 rax, rcx
  00255	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN12@gallop_lef:

; 1294 :     }
; 1295 :     a -= hint;

  0025a	48 8b 44 24 78	 mov	 rax, QWORD PTR hint$[rsp]
  0025f	48 c1 e0 03	 shl	 rax, 3
  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR a$[rsp]
  00268	48 2b c8	 sub	 rcx, rax
  0026b	48 8b c1	 mov	 rax, rcx
  0026e	48 89 44 24 68	 mov	 QWORD PTR a$[rsp], rax

; 1296 : 
; 1297 :     assert(-1 <= lastofs && lastofs < ofs && ofs <= n);

  00273	48 83 7c 24 28
	ff		 cmp	 QWORD PTR lastofs$[rsp], -1
  00279	7c 18		 jl	 SHORT $LN26@gallop_lef
  0027b	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  00280	48 39 44 24 28	 cmp	 QWORD PTR lastofs$[rsp], rax
  00285	7d 0c		 jge	 SHORT $LN26@gallop_lef
  00287	48 8b 44 24 70	 mov	 rax, QWORD PTR n$[rsp]
  0028c	48 39 44 24 30	 cmp	 QWORD PTR ofs$[rsp], rax
  00291	7e 1c		 jle	 SHORT $LN27@gallop_lef
$LN26@gallop_lef:
  00293	41 b8 11 05 00
	00		 mov	 r8d, 1297		; 00000511H
  00299	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FG@OFKJHNKN@?$AA?9?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$DM?$AA?5?$AAo?$AAf?$AAs?$AA?5?$AA?$CG@
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ad	33 c0		 xor	 eax, eax
$LN27@gallop_lef:

; 1298 :     /* Now a[lastofs] < key <= a[ofs], so key belongs somewhere to the
; 1299 :      * right of lastofs but no farther right than ofs.  Do a binary
; 1300 :      * search, with invariant a[lastofs-1] < key <= a[ofs].
; 1301 :      */
; 1302 :     ++lastofs;

  002af	48 8b 44 24 28	 mov	 rax, QWORD PTR lastofs$[rsp]
  002b4	48 ff c0	 inc	 rax
  002b7	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax
$LN5@gallop_lef:

; 1303 :     while (lastofs < ofs) {

  002bc	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  002c1	48 39 44 24 28	 cmp	 QWORD PTR lastofs$[rsp], rax
  002c6	7d 72		 jge	 SHORT $LN4@gallop_lef

; 1304 :         Py_ssize_t m = lastofs + ((ofs - lastofs) >> 1);

  002c8	48 8b 44 24 28	 mov	 rax, QWORD PTR lastofs$[rsp]
  002cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ofs$[rsp]
  002d2	48 2b c8	 sub	 rcx, rax
  002d5	48 8b c1	 mov	 rax, rcx
  002d8	48 d1 f8	 sar	 rax, 1
  002db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lastofs$[rsp]
  002e0	48 03 c8	 add	 rcx, rax
  002e3	48 8b c1	 mov	 rax, rcx
  002e6	48 89 44 24 48	 mov	 QWORD PTR m$21343[rsp], rax

; 1305 : 
; 1306 :         IFLT(a[m], key)

  002eb	45 33 c0	 xor	 r8d, r8d
  002ee	48 8b 54 24 60	 mov	 rdx, QWORD PTR key$[rsp]
  002f3	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp]
  002f8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$21343[rsp]
  002fd	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00301	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00306	48 98		 cdqe
  00308	48 89 44 24 20	 mov	 QWORD PTR k$[rsp], rax
  0030d	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  00313	7d 02		 jge	 SHORT $LN3@gallop_lef
  00315	eb 52		 jmp	 SHORT $fail$21318
$LN3@gallop_lef:
  00317	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  0031d	74 0f		 je	 SHORT $LN2@gallop_lef

; 1307 :             lastofs = m+1;              /* a[m] < key */

  0031f	48 8b 44 24 48	 mov	 rax, QWORD PTR m$21343[rsp]
  00324	48 ff c0	 inc	 rax
  00327	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax

; 1308 :         else

  0032c	eb 0a		 jmp	 SHORT $LN1@gallop_lef
$LN2@gallop_lef:

; 1309 :             ofs = m;                    /* key <= a[m] */

  0032e	48 8b 44 24 48	 mov	 rax, QWORD PTR m$21343[rsp]
  00333	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN1@gallop_lef:

; 1310 :     }

  00338	eb 82		 jmp	 SHORT $LN5@gallop_lef
$LN4@gallop_lef:

; 1311 :     assert(lastofs == ofs);             /* so a[ofs-1] < key <= a[ofs] */

  0033a	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  0033f	48 39 44 24 28	 cmp	 QWORD PTR lastofs$[rsp], rax
  00344	74 1c		 je	 SHORT $LN28@gallop_lef
  00346	41 b8 1f 05 00
	00		 mov	 r8d, 1311		; 0000051fH
  0034c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00353	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@DOKJOHEI@?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAf?$AAs?$AA?$AA@
  0035a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00360	33 c0		 xor	 eax, eax
$LN28@gallop_lef:

; 1312 :     return ofs;

  00362	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  00367	eb 07		 jmp	 SHORT $LN22@gallop_lef
$fail$21318:

; 1313 : 
; 1314 : fail:
; 1315 :     return -1;

  00369	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN22@gallop_lef:

; 1316 : }

  00370	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00374	c3		 ret	 0
gallop_left ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gallop_right DD imagerel gallop_right
	DD	imagerel gallop_right+885
	DD	imagerel $unwind$gallop_right
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gallop_right DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gallop_right
_TEXT	SEGMENT
k$ = 32
lastofs$ = 40
ofs$ = 48
maxofs$21366 = 56
maxofs$21376 = 64
m$21388 = 72
key$ = 96
a$ = 104
n$ = 112
hint$ = 120
gallop_right PROC					; COMDAT

; 1334 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1335 :     Py_ssize_t ofs;
; 1336 :     Py_ssize_t lastofs;
; 1337 :     Py_ssize_t k;
; 1338 : 
; 1339 :     assert(key && a && n > 0 && hint >= 0 && hint < n);

  00018	48 83 7c 24 60
	00		 cmp	 QWORD PTR key$[rsp], 0
  0001e	74 24		 je	 SHORT $LN24@gallop_rig
  00020	48 83 7c 24 68
	00		 cmp	 QWORD PTR a$[rsp], 0
  00026	74 1c		 je	 SHORT $LN24@gallop_rig
  00028	48 83 7c 24 70
	00		 cmp	 QWORD PTR n$[rsp], 0
  0002e	7e 14		 jle	 SHORT $LN24@gallop_rig
  00030	48 83 7c 24 78
	00		 cmp	 QWORD PTR hint$[rsp], 0
  00036	7c 0c		 jl	 SHORT $LN24@gallop_rig
  00038	48 8b 44 24 70	 mov	 rax, QWORD PTR n$[rsp]
  0003d	48 39 44 24 78	 cmp	 QWORD PTR hint$[rsp], rax
  00042	7c 1c		 jl	 SHORT $LN25@gallop_rig
$LN24@gallop_rig:
  00044	41 b8 3b 05 00
	00		 mov	 r8d, 1339		; 0000053bH
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FG@GHKBPEIB@?$AAk?$AAe?$AAy?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh?$AAi?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005e	33 c0		 xor	 eax, eax
$LN25@gallop_rig:

; 1340 : 
; 1341 :     a += hint;

  00060	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp]
  00065	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hint$[rsp]
  0006a	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0006e	48 89 44 24 68	 mov	 QWORD PTR a$[rsp], rax

; 1342 :     lastofs = 0;

  00073	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR lastofs$[rsp], 0

; 1343 :     ofs = 1;

  0007c	48 c7 44 24 30
	01 00 00 00	 mov	 QWORD PTR ofs$[rsp], 1

; 1344 :     IFLT(key, *a) {

  00085	45 33 c0	 xor	 r8d, r8d
  00088	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp]
  0008d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00090	48 8b 4c 24 60	 mov	 rcx, QWORD PTR key$[rsp]
  00095	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0009a	48 98		 cdqe
  0009c	48 89 44 24 20	 mov	 QWORD PTR k$[rsp], rax
  000a1	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  000a7	7d 05		 jge	 SHORT $LN21@gallop_rig
  000a9	e9 bb 02 00 00	 jmp	 $fail$21364
$LN21@gallop_rig:
  000ae	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  000b4	0f 84 d9 00 00
	00		 je	 $LN20@gallop_rig

; 1345 :         /* key < a[hint] -- gallop left, until
; 1346 :          * a[hint - ofs] <= key < a[hint - lastofs]
; 1347 :          */
; 1348 :         const Py_ssize_t maxofs = hint + 1;             /* &a[0] is lowest */

  000ba	48 8b 44 24 78	 mov	 rax, QWORD PTR hint$[rsp]
  000bf	48 ff c0	 inc	 rax
  000c2	48 89 44 24 38	 mov	 QWORD PTR maxofs$21366[rsp], rax
$LN19@gallop_rig:

; 1349 :         while (ofs < maxofs) {

  000c7	48 8b 44 24 38	 mov	 rax, QWORD PTR maxofs$21366[rsp]
  000cc	48 39 44 24 30	 cmp	 QWORD PTR ofs$[rsp], rax
  000d1	7d 71		 jge	 SHORT $LN18@gallop_rig

; 1350 :             IFLT(key, *(a-ofs)) {

  000d3	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  000d8	48 c1 e0 03	 shl	 rax, 3
  000dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR a$[rsp]
  000e1	48 2b c8	 sub	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	45 33 c0	 xor	 r8d, r8d
  000ea	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR key$[rsp]
  000f2	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000f7	48 98		 cdqe
  000f9	48 89 44 24 20	 mov	 QWORD PTR k$[rsp], rax
  000fe	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  00104	7d 05		 jge	 SHORT $LN17@gallop_rig
  00106	e9 5e 02 00 00	 jmp	 $fail$21364
$LN17@gallop_rig:
  0010b	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  00111	74 2d		 je	 SHORT $LN16@gallop_rig

; 1351 :                 lastofs = ofs;

  00113	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  00118	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax

; 1352 :                 ofs = (ofs << 1) + 1;

  0011d	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  00122	48 8d 44 00 01	 lea	 rax, QWORD PTR [rax+rax+1]
  00127	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax

; 1353 :                 if (ofs <= 0)                   /* int overflow */

  0012c	48 83 7c 24 30
	00		 cmp	 QWORD PTR ofs$[rsp], 0
  00132	7f 0a		 jg	 SHORT $LN15@gallop_rig

; 1354 :                     ofs = maxofs;

  00134	48 8b 44 24 38	 mov	 rax, QWORD PTR maxofs$21366[rsp]
  00139	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN15@gallop_rig:

; 1355 :             }
; 1356 :             else                /* a[hint - ofs] <= key */

  0013e	eb 02		 jmp	 SHORT $LN14@gallop_rig
$LN16@gallop_rig:

; 1357 :                 break;

  00140	eb 02		 jmp	 SHORT $LN18@gallop_rig
$LN14@gallop_rig:

; 1358 :         }

  00142	eb 83		 jmp	 SHORT $LN19@gallop_rig
$LN18@gallop_rig:

; 1359 :         if (ofs > maxofs)

  00144	48 8b 44 24 38	 mov	 rax, QWORD PTR maxofs$21366[rsp]
  00149	48 39 44 24 30	 cmp	 QWORD PTR ofs$[rsp], rax
  0014e	7e 0a		 jle	 SHORT $LN13@gallop_rig

; 1360 :             ofs = maxofs;

  00150	48 8b 44 24 38	 mov	 rax, QWORD PTR maxofs$21366[rsp]
  00155	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN13@gallop_rig:

; 1361 :         /* Translate back to positive offsets relative to &a[0]. */
; 1362 :         k = lastofs;

  0015a	48 8b 44 24 28	 mov	 rax, QWORD PTR lastofs$[rsp]
  0015f	48 89 44 24 20	 mov	 QWORD PTR k$[rsp], rax

; 1363 :         lastofs = hint - ofs;

  00164	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  00169	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hint$[rsp]
  0016e	48 2b c8	 sub	 rcx, rax
  00171	48 8b c1	 mov	 rax, rcx
  00174	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax

; 1364 :         ofs = hint - k;

  00179	48 8b 44 24 20	 mov	 rax, QWORD PTR k$[rsp]
  0017e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hint$[rsp]
  00183	48 2b c8	 sub	 rcx, rax
  00186	48 8b c1	 mov	 rax, rcx
  00189	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax

; 1365 :     }
; 1366 :     else {

  0018e	e9 c7 00 00 00	 jmp	 $LN12@gallop_rig
$LN20@gallop_rig:

; 1367 :         /* a[hint] <= key -- gallop right, until
; 1368 :          * a[hint + lastofs] <= key < a[hint + ofs]
; 1369 :         */
; 1370 :         const Py_ssize_t maxofs = n - hint;             /* &a[n-1] is highest */

  00193	48 8b 44 24 78	 mov	 rax, QWORD PTR hint$[rsp]
  00198	48 8b 4c 24 70	 mov	 rcx, QWORD PTR n$[rsp]
  0019d	48 2b c8	 sub	 rcx, rax
  001a0	48 8b c1	 mov	 rax, rcx
  001a3	48 89 44 24 40	 mov	 QWORD PTR maxofs$21376[rsp], rax
$LN11@gallop_rig:

; 1371 :         while (ofs < maxofs) {

  001a8	48 8b 44 24 40	 mov	 rax, QWORD PTR maxofs$21376[rsp]
  001ad	48 39 44 24 30	 cmp	 QWORD PTR ofs$[rsp], rax
  001b2	7d 66		 jge	 SHORT $LN10@gallop_rig

; 1372 :             IFLT(key, a[ofs])

  001b4	45 33 c0	 xor	 r8d, r8d
  001b7	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp]
  001bc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ofs$[rsp]
  001c1	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  001c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR key$[rsp]
  001ca	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  001cf	48 98		 cdqe
  001d1	48 89 44 24 20	 mov	 QWORD PTR k$[rsp], rax
  001d6	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  001dc	7d 05		 jge	 SHORT $LN9@gallop_rig
  001de	e9 86 01 00 00	 jmp	 $fail$21364
$LN9@gallop_rig:
  001e3	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  001e9	74 02		 je	 SHORT $LN8@gallop_rig

; 1373 :                 break;

  001eb	eb 2d		 jmp	 SHORT $LN10@gallop_rig
$LN8@gallop_rig:

; 1374 :             /* a[hint + ofs] <= key */
; 1375 :             lastofs = ofs;

  001ed	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  001f2	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax

; 1376 :             ofs = (ofs << 1) + 1;

  001f7	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  001fc	48 8d 44 00 01	 lea	 rax, QWORD PTR [rax+rax+1]
  00201	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax

; 1377 :             if (ofs <= 0)               /* int overflow */

  00206	48 83 7c 24 30
	00		 cmp	 QWORD PTR ofs$[rsp], 0
  0020c	7f 0a		 jg	 SHORT $LN7@gallop_rig

; 1378 :                 ofs = maxofs;

  0020e	48 8b 44 24 40	 mov	 rax, QWORD PTR maxofs$21376[rsp]
  00213	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN7@gallop_rig:

; 1379 :         }

  00218	eb 8e		 jmp	 SHORT $LN11@gallop_rig
$LN10@gallop_rig:

; 1380 :         if (ofs > maxofs)

  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR maxofs$21376[rsp]
  0021f	48 39 44 24 30	 cmp	 QWORD PTR ofs$[rsp], rax
  00224	7e 0a		 jle	 SHORT $LN6@gallop_rig

; 1381 :             ofs = maxofs;

  00226	48 8b 44 24 40	 mov	 rax, QWORD PTR maxofs$21376[rsp]
  0022b	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN6@gallop_rig:

; 1382 :         /* Translate back to offsets relative to &a[0]. */
; 1383 :         lastofs += hint;

  00230	48 8b 44 24 78	 mov	 rax, QWORD PTR hint$[rsp]
  00235	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lastofs$[rsp]
  0023a	48 03 c8	 add	 rcx, rax
  0023d	48 8b c1	 mov	 rax, rcx
  00240	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax

; 1384 :         ofs += hint;

  00245	48 8b 44 24 78	 mov	 rax, QWORD PTR hint$[rsp]
  0024a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ofs$[rsp]
  0024f	48 03 c8	 add	 rcx, rax
  00252	48 8b c1	 mov	 rax, rcx
  00255	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax
$LN12@gallop_rig:

; 1385 :     }
; 1386 :     a -= hint;

  0025a	48 8b 44 24 78	 mov	 rax, QWORD PTR hint$[rsp]
  0025f	48 c1 e0 03	 shl	 rax, 3
  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR a$[rsp]
  00268	48 2b c8	 sub	 rcx, rax
  0026b	48 8b c1	 mov	 rax, rcx
  0026e	48 89 44 24 68	 mov	 QWORD PTR a$[rsp], rax

; 1387 : 
; 1388 :     assert(-1 <= lastofs && lastofs < ofs && ofs <= n);

  00273	48 83 7c 24 28
	ff		 cmp	 QWORD PTR lastofs$[rsp], -1
  00279	7c 18		 jl	 SHORT $LN26@gallop_rig
  0027b	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  00280	48 39 44 24 28	 cmp	 QWORD PTR lastofs$[rsp], rax
  00285	7d 0c		 jge	 SHORT $LN26@gallop_rig
  00287	48 8b 44 24 70	 mov	 rax, QWORD PTR n$[rsp]
  0028c	48 39 44 24 30	 cmp	 QWORD PTR ofs$[rsp], rax
  00291	7e 1c		 jle	 SHORT $LN27@gallop_rig
$LN26@gallop_rig:
  00293	41 b8 6c 05 00
	00		 mov	 r8d, 1388		; 0000056cH
  00299	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FG@OFKJHNKN@?$AA?9?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$DM?$AA?5?$AAo?$AAf?$AAs?$AA?5?$AA?$CG@
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ad	33 c0		 xor	 eax, eax
$LN27@gallop_rig:

; 1389 :     /* Now a[lastofs] <= key < a[ofs], so key belongs somewhere to the
; 1390 :      * right of lastofs but no farther right than ofs.  Do a binary
; 1391 :      * search, with invariant a[lastofs-1] <= key < a[ofs].
; 1392 :      */
; 1393 :     ++lastofs;

  002af	48 8b 44 24 28	 mov	 rax, QWORD PTR lastofs$[rsp]
  002b4	48 ff c0	 inc	 rax
  002b7	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax
$LN5@gallop_rig:

; 1394 :     while (lastofs < ofs) {

  002bc	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  002c1	48 39 44 24 28	 cmp	 QWORD PTR lastofs$[rsp], rax
  002c6	7d 72		 jge	 SHORT $LN4@gallop_rig

; 1395 :         Py_ssize_t m = lastofs + ((ofs - lastofs) >> 1);

  002c8	48 8b 44 24 28	 mov	 rax, QWORD PTR lastofs$[rsp]
  002cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ofs$[rsp]
  002d2	48 2b c8	 sub	 rcx, rax
  002d5	48 8b c1	 mov	 rax, rcx
  002d8	48 d1 f8	 sar	 rax, 1
  002db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lastofs$[rsp]
  002e0	48 03 c8	 add	 rcx, rax
  002e3	48 8b c1	 mov	 rax, rcx
  002e6	48 89 44 24 48	 mov	 QWORD PTR m$21388[rsp], rax

; 1396 : 
; 1397 :         IFLT(key, a[m])

  002eb	45 33 c0	 xor	 r8d, r8d
  002ee	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp]
  002f3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$21388[rsp]
  002f8	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  002fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR key$[rsp]
  00301	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00306	48 98		 cdqe
  00308	48 89 44 24 20	 mov	 QWORD PTR k$[rsp], rax
  0030d	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  00313	7d 02		 jge	 SHORT $LN3@gallop_rig
  00315	eb 52		 jmp	 SHORT $fail$21364
$LN3@gallop_rig:
  00317	48 83 7c 24 20
	00		 cmp	 QWORD PTR k$[rsp], 0
  0031d	74 0c		 je	 SHORT $LN2@gallop_rig

; 1398 :             ofs = m;                    /* key < a[m] */

  0031f	48 8b 44 24 48	 mov	 rax, QWORD PTR m$21388[rsp]
  00324	48 89 44 24 30	 mov	 QWORD PTR ofs$[rsp], rax

; 1399 :         else

  00329	eb 0d		 jmp	 SHORT $LN1@gallop_rig
$LN2@gallop_rig:

; 1400 :             lastofs = m+1;              /* a[m] <= key */

  0032b	48 8b 44 24 48	 mov	 rax, QWORD PTR m$21388[rsp]
  00330	48 ff c0	 inc	 rax
  00333	48 89 44 24 28	 mov	 QWORD PTR lastofs$[rsp], rax
$LN1@gallop_rig:

; 1401 :     }

  00338	eb 82		 jmp	 SHORT $LN5@gallop_rig
$LN4@gallop_rig:

; 1402 :     assert(lastofs == ofs);             /* so a[ofs-1] <= key < a[ofs] */

  0033a	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  0033f	48 39 44 24 28	 cmp	 QWORD PTR lastofs$[rsp], rax
  00344	74 1c		 je	 SHORT $LN28@gallop_rig
  00346	41 b8 7a 05 00
	00		 mov	 r8d, 1402		; 0000057aH
  0034c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00353	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@DOKJOHEI@?$AAl?$AAa?$AAs?$AAt?$AAo?$AAf?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAf?$AAs?$AA?$AA@
  0035a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00360	33 c0		 xor	 eax, eax
$LN28@gallop_rig:

; 1403 :     return ofs;

  00362	48 8b 44 24 30	 mov	 rax, QWORD PTR ofs$[rsp]
  00367	eb 07		 jmp	 SHORT $LN22@gallop_rig
$fail$21364:

; 1404 : 
; 1405 : fail:
; 1406 :     return -1;

  00369	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN22@gallop_rig:

; 1407 : }

  00370	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00374	c3		 ret	 0
gallop_right ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@PAIPNADB@?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@ELMIMDGG@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	$T23412
PUBLIC	$T23413
PUBLIC	??_C@_1FO@PGIMGMIE@?$AAm?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAa@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_lo DD imagerel merge_lo
	DD	imagerel merge_lo+1695
	DD	imagerel $unwind$merge_lo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_lo DD 041d01H
	DD	015011dH
	DD	060157016H
xdata	ENDS
;	COMDAT ??_C@_1CE@PAIPNADB@?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@PAIPNADB@?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 'a', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'n', 00H, 'b', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@ELMIMDGG@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@ELMIMDGG@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 'a', 00H, ' ', 00H, '>', 00H, ' ', 00H, '1', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'n', 00H, 'b', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@PGIMGMIE@?$AAm?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAa@
CONST	SEGMENT
??_C@_1FO@PGIMGMIE@?$AAm?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAa@ DB 'm'
	DB	00H, 's', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 's', 00H
	DB	's', 00H, 'a', 00H, '.', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 's'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 's', 00H, 's', 00H
	DB	'b', 00H, '.', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 's', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'n', 00H, 'a', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'n', 00H, 'b', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT merge_lo
_TEXT	SEGMENT
min_gallop$ = 48
dest$ = 56
k$ = 72
result$ = 80
acount$21480 = 88
bcount$21481 = 96
$T23412 = 104
$T23413 = 120
tv85 = 136
tv168 = 144
ms$ = 192
ssa$ = 200
na$ = 208
ssb$ = 216
nb$ = 224
merge_lo PROC						; COMDAT

; 1548 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1549 :     Py_ssize_t k;
; 1550 :     sortslice dest;
; 1551 :     int result = -1;            /* guilty until proved innocent */

  0001d	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR result$[rsp], -1

; 1552 :     Py_ssize_t min_gallop;
; 1553 : 
; 1554 :     assert(ms && ssa.keys && ssb.keys && na > 0 && nb > 0);

  00025	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR ms$[rsp], 0
  0002e	74 32		 je	 SHORT $LN30@merge_lo
  00030	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR ssa$[rsp]
  00038	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003c	74 24		 je	 SHORT $LN30@merge_lo
  0003e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR ssb$[rsp]
  00046	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004a	74 16		 je	 SHORT $LN30@merge_lo
  0004c	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  00055	7e 0b		 jle	 SHORT $LN30@merge_lo
  00057	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  00060	7f 1c		 jg	 SHORT $LN31@merge_lo
$LN30@merge_lo:
  00062	41 b8 12 06 00
	00		 mov	 r8d, 1554		; 00000612H
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@PGIMGMIE@?$AAm?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAa@
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007c	33 c0		 xor	 eax, eax
$LN31@merge_lo:

; 1555 :     assert(ssa.keys + na == ssb.keys);

  0007e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR ssa$[rsp]
  00086	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00089	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR na$[rsp]
  00091	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00095	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR ssb$[rsp]
  0009d	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  000a0	74 1c		 je	 SHORT $LN32@merge_lo
  000a2	41 b8 13 06 00
	00		 mov	 r8d, 1555		; 00000613H
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@HPMMPCN@?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CL?$AA?5?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?$AA@
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000bc	33 c0		 xor	 eax, eax
$LN32@merge_lo:

; 1556 :     if (MERGE_GETMEM(ms, na) < 0)

  000be	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  000c6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ca	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR na$[rsp], rax
  000d2	7f 0d		 jg	 SHORT $LN33@merge_lo
  000d4	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv85[rsp], 0
  000df	eb 1c		 jmp	 SHORT $LN34@merge_lo
$LN33@merge_lo:
  000e1	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR na$[rsp]
  000e9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  000f1	e8 00 00 00 00	 call	 merge_getmem
  000f6	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv85[rsp], eax
$LN34@merge_lo:
  000fd	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tv85[rsp], 0
  00105	7d 0c		 jge	 SHORT $LN27@merge_lo

; 1557 :         return -1;

  00107	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0010e	e9 82 05 00 00	 jmp	 $LN28@merge_lo
$LN27@merge_lo:

; 1558 :     sortslice_memcpy(&ms->a, 0, &ssa, 0, na);

  00113	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  0011b	48 83 c0 08	 add	 rax, 8
  0011f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR na$[rsp]
  00127	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0012c	45 33 c9	 xor	 r9d, r9d
  0012f	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR ssa$[rsp]
  00137	33 d2		 xor	 edx, edx
  00139	48 8b c8	 mov	 rcx, rax
  0013c	e8 00 00 00 00	 call	 sortslice_memcpy

; 1559 :     dest = ssa;

  00141	48 8d 44 24 78	 lea	 rax, QWORD PTR $T23413[rsp]
  00146	48 8b f8	 mov	 rdi, rax
  00149	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR ssa$[rsp]
  00151	b9 10 00 00 00	 mov	 ecx, 16
  00156	f3 a4		 rep movsb
  00158	48 8d 44 24 38	 lea	 rax, QWORD PTR dest$[rsp]
  0015d	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T23413[rsp]
  00162	48 8b f8	 mov	 rdi, rax
  00165	48 8b f1	 mov	 rsi, rcx
  00168	b9 10 00 00 00	 mov	 ecx, 16
  0016d	f3 a4		 rep movsb

; 1560 :     ssa = ms->a;

  0016f	48 8d 44 24 68	 lea	 rax, QWORD PTR $T23412[rsp]
  00174	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  0017c	48 8b f8	 mov	 rdi, rax
  0017f	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  00183	b9 10 00 00 00	 mov	 ecx, 16
  00188	f3 a4		 rep movsb
  0018a	48 8d 44 24 68	 lea	 rax, QWORD PTR $T23412[rsp]
  0018f	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR ssa$[rsp]
  00197	48 8b f0	 mov	 rsi, rax
  0019a	b9 10 00 00 00	 mov	 ecx, 16
  0019f	f3 a4		 rep movsb

; 1561 : 
; 1562 :     sortslice_copy_incr(&dest, &ssb);

  001a1	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR ssb$[rsp]
  001a9	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  001ae	e8 00 00 00 00	 call	 sortslice_copy_incr

; 1563 :     --nb;

  001b3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR nb$[rsp]
  001bb	48 ff c8	 dec	 rax
  001be	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR nb$[rsp], rax

; 1564 :     if (nb == 0)

  001c6	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  001cf	75 05		 jne	 SHORT $LN26@merge_lo

; 1565 :         goto Succeed;

  001d1	e9 0c 04 00 00	 jmp	 $Succeed$21474
$LN26@merge_lo:

; 1566 :     if (na == 1)

  001d6	48 83 bc 24 d0
	00 00 00 01	 cmp	 QWORD PTR na$[rsp], 1
  001df	75 05		 jne	 SHORT $LN25@merge_lo

; 1567 :         goto CopyB;

  001e1	e9 3a 04 00 00	 jmp	 $CopyB$21476
$LN25@merge_lo:

; 1568 : 
; 1569 :     min_gallop = ms->min_gallop;

  001e6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  001ee	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f1	48 89 44 24 30	 mov	 QWORD PTR min_gallop$[rsp], rax
$LN24@merge_lo:

; 1570 :     for (;;) {
; 1571 :         Py_ssize_t acount = 0;          /* # of times A won in a row */

  001f6	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR acount$21480[rsp], 0

; 1572 :         Py_ssize_t bcount = 0;          /* # of times B won in a row */

  001ff	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR bcount$21481[rsp], 0
$LN22@merge_lo:

; 1573 : 
; 1574 :         /* Do the straightforward thing until (if ever) one run
; 1575 :          * appears to win consistently.
; 1576 :          */
; 1577 :         for (;;) {
; 1578 :             assert(na > 1 && nb > 0);

  00208	48 83 bc 24 d0
	00 00 00 01	 cmp	 QWORD PTR na$[rsp], 1
  00211	7e 0b		 jle	 SHORT $LN35@merge_lo
  00213	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  0021c	7f 1c		 jg	 SHORT $LN36@merge_lo
$LN35@merge_lo:
  0021e	41 b8 2a 06 00
	00		 mov	 r8d, 1578		; 0000062aH
  00224	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@ELMIMDGG@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00238	33 c0		 xor	 eax, eax
$LN36@merge_lo:

; 1579 :             k = ISLT(ssb.keys[0], ssa.keys[0]);

  0023a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR ssa$[rsp]
  00242	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00245	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR ssb$[rsp]
  0024d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00250	45 33 c0	 xor	 r8d, r8d
  00253	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00256	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00259	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0025e	48 98		 cdqe
  00260	48 89 44 24 48	 mov	 QWORD PTR k$[rsp], rax

; 1580 :             if (k) {

  00265	48 83 7c 24 48
	00		 cmp	 QWORD PTR k$[rsp], 0
  0026b	74 68		 je	 SHORT $LN20@merge_lo

; 1581 :                 if (k < 0)

  0026d	48 83 7c 24 48
	00		 cmp	 QWORD PTR k$[rsp], 0
  00273	7d 05		 jge	 SHORT $LN19@merge_lo

; 1582 :                     goto Fail;

  00275	e9 70 03 00 00	 jmp	 $Fail$21489
$LN19@merge_lo:

; 1583 :                 sortslice_copy_incr(&dest, &ssb);

  0027a	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR ssb$[rsp]
  00282	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  00287	e8 00 00 00 00	 call	 sortslice_copy_incr

; 1584 :                 ++bcount;

  0028c	48 8b 44 24 60	 mov	 rax, QWORD PTR bcount$21481[rsp]
  00291	48 ff c0	 inc	 rax
  00294	48 89 44 24 60	 mov	 QWORD PTR bcount$21481[rsp], rax

; 1585 :                 acount = 0;

  00299	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR acount$21480[rsp], 0

; 1586 :                 --nb;

  002a2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR nb$[rsp]
  002aa	48 ff c8	 dec	 rax
  002ad	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR nb$[rsp], rax

; 1587 :                 if (nb == 0)

  002b5	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  002be	75 05		 jne	 SHORT $LN18@merge_lo

; 1588 :                     goto Succeed;

  002c0	e9 1d 03 00 00	 jmp	 $Succeed$21474
$LN18@merge_lo:

; 1589 :                 if (bcount >= min_gallop)

  002c5	48 8b 44 24 30	 mov	 rax, QWORD PTR min_gallop$[rsp]
  002ca	48 39 44 24 60	 cmp	 QWORD PTR bcount$21481[rsp], rax
  002cf	7c 02		 jl	 SHORT $LN17@merge_lo

; 1590 :                     break;

  002d1	eb 60		 jmp	 SHORT $LN21@merge_lo
$LN17@merge_lo:

; 1591 :             }
; 1592 :             else {

  002d3	eb 59		 jmp	 SHORT $LN16@merge_lo
$LN20@merge_lo:

; 1593 :                 sortslice_copy_incr(&dest, &ssa);

  002d5	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR ssa$[rsp]
  002dd	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  002e2	e8 00 00 00 00	 call	 sortslice_copy_incr

; 1594 :                 ++acount;

  002e7	48 8b 44 24 58	 mov	 rax, QWORD PTR acount$21480[rsp]
  002ec	48 ff c0	 inc	 rax
  002ef	48 89 44 24 58	 mov	 QWORD PTR acount$21480[rsp], rax

; 1595 :                 bcount = 0;

  002f4	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR bcount$21481[rsp], 0

; 1596 :                 --na;

  002fd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR na$[rsp]
  00305	48 ff c8	 dec	 rax
  00308	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR na$[rsp], rax

; 1597 :                 if (na == 1)

  00310	48 83 bc 24 d0
	00 00 00 01	 cmp	 QWORD PTR na$[rsp], 1
  00319	75 05		 jne	 SHORT $LN15@merge_lo

; 1598 :                     goto CopyB;

  0031b	e9 00 03 00 00	 jmp	 $CopyB$21476
$LN15@merge_lo:

; 1599 :                 if (acount >= min_gallop)

  00320	48 8b 44 24 30	 mov	 rax, QWORD PTR min_gallop$[rsp]
  00325	48 39 44 24 58	 cmp	 QWORD PTR acount$21480[rsp], rax
  0032a	7c 02		 jl	 SHORT $LN14@merge_lo

; 1600 :                     break;

  0032c	eb 05		 jmp	 SHORT $LN21@merge_lo
$LN14@merge_lo:
$LN16@merge_lo:

; 1601 :             }
; 1602 :         }

  0032e	e9 d5 fe ff ff	 jmp	 $LN22@merge_lo
$LN21@merge_lo:

; 1603 : 
; 1604 :         /* One run is winning so consistently that galloping may
; 1605 :          * be a huge win.  So try that, and continue galloping until
; 1606 :          * (if ever) neither run appears to be winning consistently
; 1607 :          * anymore.
; 1608 :          */
; 1609 :         ++min_gallop;

  00333	48 8b 44 24 30	 mov	 rax, QWORD PTR min_gallop$[rsp]
  00338	48 ff c0	 inc	 rax
  0033b	48 89 44 24 30	 mov	 QWORD PTR min_gallop$[rsp], rax
$LN43@merge_lo:
$LN13@merge_lo:

; 1610 :         do {
; 1611 :             assert(na > 1 && nb > 0);

  00340	48 83 bc 24 d0
	00 00 00 01	 cmp	 QWORD PTR na$[rsp], 1
  00349	7e 0b		 jle	 SHORT $LN37@merge_lo
  0034b	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  00354	7f 1c		 jg	 SHORT $LN38@merge_lo
$LN37@merge_lo:
  00356	41 b8 4b 06 00
	00		 mov	 r8d, 1611		; 0000064bH
  0035c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@ELMIMDGG@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00370	33 c0		 xor	 eax, eax
$LN38@merge_lo:

; 1612 :             min_gallop -= min_gallop > 1;

  00372	48 83 7c 24 30
	01		 cmp	 QWORD PTR min_gallop$[rsp], 1
  00378	7e 0e		 jle	 SHORT $LN39@merge_lo
  0037a	48 c7 84 24 90
	00 00 00 01 00
	00 00		 mov	 QWORD PTR tv168[rsp], 1
  00386	eb 0c		 jmp	 SHORT $LN40@merge_lo
$LN39@merge_lo:
  00388	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv168[rsp], 0
$LN40@merge_lo:
  00394	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv168[rsp]
  0039c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR min_gallop$[rsp]
  003a1	48 2b c8	 sub	 rcx, rax
  003a4	48 8b c1	 mov	 rax, rcx
  003a7	48 89 44 24 30	 mov	 QWORD PTR min_gallop$[rsp], rax

; 1613 :             ms->min_gallop = min_gallop;

  003ac	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  003b4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR min_gallop$[rsp]
  003b9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1614 :             k = gallop_right(ssb.keys[0], ssa.keys, na, 0);

  003bc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR ssb$[rsp]
  003c4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c7	45 33 c9	 xor	 r9d, r9d
  003ca	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR na$[rsp]
  003d2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR ssa$[rsp]
  003da	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  003dd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003e0	e8 00 00 00 00	 call	 gallop_right
  003e5	48 89 44 24 48	 mov	 QWORD PTR k$[rsp], rax

; 1615 :             acount = k;

  003ea	48 8b 44 24 48	 mov	 rax, QWORD PTR k$[rsp]
  003ef	48 89 44 24 58	 mov	 QWORD PTR acount$21480[rsp], rax

; 1616 :             if (k) {

  003f4	48 83 7c 24 48
	00		 cmp	 QWORD PTR k$[rsp], 0
  003fa	0f 84 8a 00 00
	00		 je	 $LN10@merge_lo

; 1617 :                 if (k < 0)

  00400	48 83 7c 24 48
	00		 cmp	 QWORD PTR k$[rsp], 0
  00406	7d 05		 jge	 SHORT $LN9@merge_lo

; 1618 :                     goto Fail;

  00408	e9 dd 01 00 00	 jmp	 $Fail$21489
$LN9@merge_lo:

; 1619 :                 sortslice_memcpy(&dest, 0, &ssa, 0, k);

  0040d	48 8b 44 24 48	 mov	 rax, QWORD PTR k$[rsp]
  00412	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00417	45 33 c9	 xor	 r9d, r9d
  0041a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR ssa$[rsp]
  00422	33 d2		 xor	 edx, edx
  00424	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  00429	e8 00 00 00 00	 call	 sortslice_memcpy

; 1620 :                 sortslice_advance(&dest, k);

  0042e	48 8b 54 24 48	 mov	 rdx, QWORD PTR k$[rsp]
  00433	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  00438	e8 00 00 00 00	 call	 sortslice_advance

; 1621 :                 sortslice_advance(&ssa, k);

  0043d	48 8b 54 24 48	 mov	 rdx, QWORD PTR k$[rsp]
  00442	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR ssa$[rsp]
  0044a	e8 00 00 00 00	 call	 sortslice_advance

; 1622 :                 na -= k;

  0044f	48 8b 44 24 48	 mov	 rax, QWORD PTR k$[rsp]
  00454	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR na$[rsp]
  0045c	48 2b c8	 sub	 rcx, rax
  0045f	48 8b c1	 mov	 rax, rcx
  00462	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR na$[rsp], rax

; 1623 :                 if (na == 1)

  0046a	48 83 bc 24 d0
	00 00 00 01	 cmp	 QWORD PTR na$[rsp], 1
  00473	75 05		 jne	 SHORT $LN8@merge_lo

; 1624 :                     goto CopyB;

  00475	e9 a6 01 00 00	 jmp	 $CopyB$21476
$LN8@merge_lo:

; 1625 :                 /* na==0 is impossible now if the comparison
; 1626 :                  * function is consistent, but we can't assume
; 1627 :                  * that it is.
; 1628 :                  */
; 1629 :                 if (na == 0)

  0047a	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  00483	75 05		 jne	 SHORT $LN7@merge_lo

; 1630 :                     goto Succeed;

  00485	e9 58 01 00 00	 jmp	 $Succeed$21474
$LN7@merge_lo:
$LN10@merge_lo:

; 1631 :             }
; 1632 :             sortslice_copy_incr(&dest, &ssb);

  0048a	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR ssb$[rsp]
  00492	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  00497	e8 00 00 00 00	 call	 sortslice_copy_incr

; 1633 :             --nb;

  0049c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR nb$[rsp]
  004a4	48 ff c8	 dec	 rax
  004a7	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR nb$[rsp], rax

; 1634 :             if (nb == 0)

  004af	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  004b8	75 05		 jne	 SHORT $LN6@merge_lo

; 1635 :                 goto Succeed;

  004ba	e9 23 01 00 00	 jmp	 $Succeed$21474
$LN6@merge_lo:

; 1636 : 
; 1637 :             k = gallop_left(ssa.keys[0], ssb.keys, nb, 0);

  004bf	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR ssa$[rsp]
  004c7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004ca	45 33 c9	 xor	 r9d, r9d
  004cd	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR nb$[rsp]
  004d5	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR ssb$[rsp]
  004dd	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  004e0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  004e3	e8 00 00 00 00	 call	 gallop_left
  004e8	48 89 44 24 48	 mov	 QWORD PTR k$[rsp], rax

; 1638 :             bcount = k;

  004ed	48 8b 44 24 48	 mov	 rax, QWORD PTR k$[rsp]
  004f2	48 89 44 24 60	 mov	 QWORD PTR bcount$21481[rsp], rax

; 1639 :             if (k) {

  004f7	48 83 7c 24 48
	00		 cmp	 QWORD PTR k$[rsp], 0
  004fd	74 77		 je	 SHORT $LN5@merge_lo

; 1640 :                 if (k < 0)

  004ff	48 83 7c 24 48
	00		 cmp	 QWORD PTR k$[rsp], 0
  00505	7d 05		 jge	 SHORT $LN4@merge_lo

; 1641 :                     goto Fail;

  00507	e9 de 00 00 00	 jmp	 $Fail$21489
$LN4@merge_lo:

; 1642 :                 sortslice_memmove(&dest, 0, &ssb, 0, k);

  0050c	48 8b 44 24 48	 mov	 rax, QWORD PTR k$[rsp]
  00511	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00516	45 33 c9	 xor	 r9d, r9d
  00519	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR ssb$[rsp]
  00521	33 d2		 xor	 edx, edx
  00523	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  00528	e8 00 00 00 00	 call	 sortslice_memmove

; 1643 :                 sortslice_advance(&dest, k);

  0052d	48 8b 54 24 48	 mov	 rdx, QWORD PTR k$[rsp]
  00532	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  00537	e8 00 00 00 00	 call	 sortslice_advance

; 1644 :                 sortslice_advance(&ssb, k);

  0053c	48 8b 54 24 48	 mov	 rdx, QWORD PTR k$[rsp]
  00541	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR ssb$[rsp]
  00549	e8 00 00 00 00	 call	 sortslice_advance

; 1645 :                 nb -= k;

  0054e	48 8b 44 24 48	 mov	 rax, QWORD PTR k$[rsp]
  00553	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR nb$[rsp]
  0055b	48 2b c8	 sub	 rcx, rax
  0055e	48 8b c1	 mov	 rax, rcx
  00561	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR nb$[rsp], rax

; 1646 :                 if (nb == 0)

  00569	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  00572	75 02		 jne	 SHORT $LN3@merge_lo

; 1647 :                     goto Succeed;

  00574	eb 6c		 jmp	 SHORT $Succeed$21474
$LN3@merge_lo:
$LN5@merge_lo:

; 1648 :             }
; 1649 :             sortslice_copy_incr(&dest, &ssa);

  00576	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR ssa$[rsp]
  0057e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  00583	e8 00 00 00 00	 call	 sortslice_copy_incr

; 1650 :             --na;

  00588	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR na$[rsp]
  00590	48 ff c8	 dec	 rax
  00593	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR na$[rsp], rax

; 1651 :             if (na == 1)

  0059b	48 83 bc 24 d0
	00 00 00 01	 cmp	 QWORD PTR na$[rsp], 1
  005a4	75 02		 jne	 SHORT $LN2@merge_lo

; 1652 :                 goto CopyB;

  005a6	eb 78		 jmp	 SHORT $CopyB$21476
$LN2@merge_lo:

; 1653 :         } while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);

  005a8	48 83 7c 24 58
	07		 cmp	 QWORD PTR acount$21480[rsp], 7
  005ae	0f 8d 8c fd ff
	ff		 jge	 $LN13@merge_lo
  005b4	48 83 7c 24 60
	07		 cmp	 QWORD PTR bcount$21481[rsp], 7
  005ba	0f 8d 80 fd ff
	ff		 jge	 $LN43@merge_lo

; 1654 :         ++min_gallop;           /* penalize it for leaving galloping mode */

  005c0	48 8b 44 24 30	 mov	 rax, QWORD PTR min_gallop$[rsp]
  005c5	48 ff c0	 inc	 rax
  005c8	48 89 44 24 30	 mov	 QWORD PTR min_gallop$[rsp], rax

; 1655 :         ms->min_gallop = min_gallop;

  005cd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  005d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR min_gallop$[rsp]
  005da	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1656 :     }

  005dd	e9 14 fc ff ff	 jmp	 $LN24@merge_lo
$Succeed$21474:

; 1657 : Succeed:
; 1658 :     result = 0;

  005e2	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0
$Fail$21489:

; 1659 : Fail:
; 1660 :     if (na)

  005ea	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  005f3	74 24		 je	 SHORT $LN1@merge_lo

; 1661 :         sortslice_memcpy(&dest, 0, &ssa, 0, na);

  005f5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR na$[rsp]
  005fd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00602	45 33 c9	 xor	 r9d, r9d
  00605	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR ssa$[rsp]
  0060d	33 d2		 xor	 edx, edx
  0060f	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  00614	e8 00 00 00 00	 call	 sortslice_memcpy
$LN1@merge_lo:

; 1662 :     return result;

  00619	48 63 44 24 50	 movsxd	 rax, DWORD PTR result$[rsp]
  0061e	eb 75		 jmp	 SHORT $LN28@merge_lo
$CopyB$21476:

; 1663 : CopyB:
; 1664 :     assert(na == 1 && nb > 0);

  00620	48 83 bc 24 d0
	00 00 00 01	 cmp	 QWORD PTR na$[rsp], 1
  00629	75 0b		 jne	 SHORT $LN41@merge_lo
  0062b	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  00634	7f 1c		 jg	 SHORT $LN42@merge_lo
$LN41@merge_lo:
  00636	41 b8 80 06 00
	00		 mov	 r8d, 1664		; 00000680H
  0063c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00643	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@PAIPNADB@?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0064a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00650	33 c0		 xor	 eax, eax
$LN42@merge_lo:

; 1665 :     /* The last element of ssa belongs at the end of the merge. */
; 1666 :     sortslice_memmove(&dest, 0, &ssb, 0, nb);

  00652	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR nb$[rsp]
  0065a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0065f	45 33 c9	 xor	 r9d, r9d
  00662	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR ssb$[rsp]
  0066a	33 d2		 xor	 edx, edx
  0066c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  00671	e8 00 00 00 00	 call	 sortslice_memmove

; 1667 :     sortslice_copy(&dest, nb, &ssa, 0);

  00676	45 33 c9	 xor	 r9d, r9d
  00679	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR ssa$[rsp]
  00681	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR nb$[rsp]
  00689	48 8d 4c 24 38	 lea	 rcx, QWORD PTR dest$[rsp]
  0068e	e8 00 00 00 00	 call	 sortslice_copy

; 1668 :     return 0;

  00693	33 c0		 xor	 eax, eax
$LN28@merge_lo:

; 1669 : }

  00695	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0069c	5f		 pop	 rdi
  0069d	5e		 pop	 rsi
  0069e	c3		 ret	 0
merge_lo ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT sortslice_copy
_TEXT	SEGMENT
s1$ = 8
i$ = 16
s2$ = 24
j$ = 32
sortslice_copy PROC					; COMDAT

; 1039 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1040 :     s1->keys[i] = s2->keys[j];

  00014	48 8b 44 24 18	 mov	 rax, QWORD PTR s2$[rsp]
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s1$[rsp]
  00021	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00024	48 8b 54 24 10	 mov	 rdx, QWORD PTR i$[rsp]
  00029	4c 8b 44 24 20	 mov	 r8, QWORD PTR j$[rsp]
  0002e	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  00032	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 1041 :     if (s1->values != NULL)

  00036	48 8b 44 24 08	 mov	 rax, QWORD PTR s1$[rsp]
  0003b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00040	74 24		 je	 SHORT $LN1@sortslice_@2

; 1042 :         s1->values[i] = s2->values[j];

  00042	48 8b 44 24 18	 mov	 rax, QWORD PTR s2$[rsp]
  00047	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s1$[rsp]
  00050	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00054	48 8b 54 24 10	 mov	 rdx, QWORD PTR i$[rsp]
  00059	4c 8b 44 24 20	 mov	 r8, QWORD PTR j$[rsp]
  0005e	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  00062	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
$LN1@sortslice_@2:

; 1043 : }

  00066	f3 c3		 fatret	 0
sortslice_copy ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT sortslice_copy_incr
_TEXT	SEGMENT
dst$ = 8
src$ = 16
sortslice_copy_incr PROC				; COMDAT

; 1047 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1048 :     *dst->keys++ = *src->keys++;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR src$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dst$[rsp]
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax
  00020	48 8b 44 24 08	 mov	 rax, QWORD PTR dst$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 83 c0 08	 add	 rax, 8
  0002c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dst$[rsp]
  00031	48 89 01	 mov	 QWORD PTR [rcx], rax
  00034	48 8b 44 24 10	 mov	 rax, QWORD PTR src$[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 83 c0 08	 add	 rax, 8
  00040	48 8b 4c 24 10	 mov	 rcx, QWORD PTR src$[rsp]
  00045	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1049 :     if (dst->values != NULL)

  00048	48 8b 44 24 08	 mov	 rax, QWORD PTR dst$[rsp]
  0004d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00052	74 44		 je	 SHORT $LN1@sortslice_@3

; 1050 :         *dst->values++ = *src->values++;

  00054	48 8b 44 24 10	 mov	 rax, QWORD PTR src$[rsp]
  00059	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dst$[rsp]
  00062	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 89 01	 mov	 QWORD PTR [rcx], rax
  0006c	48 8b 44 24 08	 mov	 rax, QWORD PTR dst$[rsp]
  00071	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00075	48 83 c0 08	 add	 rax, 8
  00079	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dst$[rsp]
  0007e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00082	48 8b 44 24 10	 mov	 rax, QWORD PTR src$[rsp]
  00087	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008b	48 83 c0 08	 add	 rax, 8
  0008f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR src$[rsp]
  00094	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN1@sortslice_@3:

; 1051 : }

  00098	f3 c3		 fatret	 0
sortslice_copy_incr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sortslice_memcpy DD imagerel sortslice_memcpy
	DD	imagerel sortslice_memcpy+177
	DD	imagerel $unwind$sortslice_memcpy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sortslice_memcpy DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT sortslice_memcpy
_TEXT	SEGMENT
tv71 = 32
tv83 = 40
s1$ = 64
i$ = 72
s2$ = 80
j$ = 88
n$ = 96
sortslice_memcpy PROC					; COMDAT

; 1065 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1066 :     memcpy(&s1->keys[i], &s2->keys[j], sizeof(PyObject *) * n);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR n$[rsp]
  0001d	48 c1 e0 03	 shl	 rax, 3
  00021	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s2$[rsp]
  00026	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00029	48 8b 54 24 58	 mov	 rdx, QWORD PTR j$[rsp]
  0002e	48 8d 0c d1	 lea	 rcx, QWORD PTR [rcx+rdx*8]
  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR s1$[rsp]
  00037	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0003a	4c 8b 44 24 48	 mov	 r8, QWORD PTR i$[rsp]
  0003f	4a 8d 14 c2	 lea	 rdx, QWORD PTR [rdx+r8*8]
  00043	48 89 54 24 20	 mov	 QWORD PTR tv71[rsp], rdx
  00048	4c 8b c0	 mov	 r8, rax
  0004b	48 8b d1	 mov	 rdx, rcx
  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR tv71[rsp]
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 memcpy

; 1067 :     if (s1->values != NULL)

  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR s1$[rsp]
  00060	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00065	74 45		 je	 SHORT $LN1@sortslice_@4

; 1068 :         memcpy(&s1->values[i], &s2->values[j], sizeof(PyObject *) * n);

  00067	48 8b 44 24 60	 mov	 rax, QWORD PTR n$[rsp]
  0006c	48 c1 e0 03	 shl	 rax, 3
  00070	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s2$[rsp]
  00075	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00079	48 8b 54 24 58	 mov	 rdx, QWORD PTR j$[rsp]
  0007e	48 8d 0c d1	 lea	 rcx, QWORD PTR [rcx+rdx*8]
  00082	48 8b 54 24 40	 mov	 rdx, QWORD PTR s1$[rsp]
  00087	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0008b	4c 8b 44 24 48	 mov	 r8, QWORD PTR i$[rsp]
  00090	4a 8d 14 c2	 lea	 rdx, QWORD PTR [rdx+r8*8]
  00094	48 89 54 24 28	 mov	 QWORD PTR tv83[rsp], rdx
  00099	4c 8b c0	 mov	 r8, rax
  0009c	48 8b d1	 mov	 rdx, rcx
  0009f	48 8b 44 24 28	 mov	 rax, QWORD PTR tv83[rsp]
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 memcpy
$LN1@sortslice_@4:

; 1069 : }

  000ac	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b0	c3		 ret	 0
sortslice_memcpy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sortslice_memmove DD imagerel sortslice_memmove
	DD	imagerel sortslice_memmove+179
	DD	imagerel $unwind$sortslice_memmove
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sortslice_memmove DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT sortslice_memmove
_TEXT	SEGMENT
tv71 = 32
tv83 = 40
s1$ = 64
i$ = 72
s2$ = 80
j$ = 88
n$ = 96
sortslice_memmove PROC					; COMDAT

; 1074 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1075 :     memmove(&s1->keys[i], &s2->keys[j], sizeof(PyObject *) * n);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR n$[rsp]
  0001d	48 c1 e0 03	 shl	 rax, 3
  00021	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s2$[rsp]
  00026	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00029	48 8b 54 24 58	 mov	 rdx, QWORD PTR j$[rsp]
  0002e	48 8d 0c d1	 lea	 rcx, QWORD PTR [rcx+rdx*8]
  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR s1$[rsp]
  00037	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0003a	4c 8b 44 24 48	 mov	 r8, QWORD PTR i$[rsp]
  0003f	4a 8d 14 c2	 lea	 rdx, QWORD PTR [rdx+r8*8]
  00043	48 89 54 24 20	 mov	 QWORD PTR tv71[rsp], rdx
  00048	4c 8b c0	 mov	 r8, rax
  0004b	48 8b d1	 mov	 rdx, rcx
  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR tv71[rsp]
  00053	48 8b c8	 mov	 rcx, rax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 1076 :     if (s1->values != NULL)

  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR s1$[rsp]
  00061	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00066	74 46		 je	 SHORT $LN1@sortslice_@5

; 1077 :         memmove(&s1->values[i], &s2->values[j], sizeof(PyObject *) * n);

  00068	48 8b 44 24 60	 mov	 rax, QWORD PTR n$[rsp]
  0006d	48 c1 e0 03	 shl	 rax, 3
  00071	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s2$[rsp]
  00076	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0007a	48 8b 54 24 58	 mov	 rdx, QWORD PTR j$[rsp]
  0007f	48 8d 0c d1	 lea	 rcx, QWORD PTR [rcx+rdx*8]
  00083	48 8b 54 24 40	 mov	 rdx, QWORD PTR s1$[rsp]
  00088	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0008c	4c 8b 44 24 48	 mov	 r8, QWORD PTR i$[rsp]
  00091	4a 8d 14 c2	 lea	 rdx, QWORD PTR [rdx+r8*8]
  00095	48 89 54 24 28	 mov	 QWORD PTR tv83[rsp], rdx
  0009a	4c 8b c0	 mov	 r8, rax
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	48 8b 44 24 28	 mov	 rax, QWORD PTR tv83[rsp]
  000a5	48 8b c8	 mov	 rcx, rax
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN1@sortslice_@5:

; 1078 : }

  000ae	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b2	c3		 ret	 0
sortslice_memmove ENDP
_TEXT	ENDS
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_getmem DD imagerel merge_getmem
	DD	imagerel merge_getmem+286
	DD	imagerel $unwind$merge_getmem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_getmem DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT merge_getmem
_TEXT	SEGMENT
multiplier$ = 32
tv73 = 36
tv75 = 40
ms$ = 64
need$ = 72
merge_getmem PROC					; COMDAT

; 1508 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1509 :     int multiplier;
; 1510 : 
; 1511 :     assert(ms != NULL);

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR ms$[rsp], 0
  00014	75 1c		 jne	 SHORT $LN7@merge_getm
  00016	41 b8 e7 05 00
	00		 mov	 r8d, 1511		; 000005e7H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@FDEHGCMB@?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN7@merge_getm:

; 1512 :     if (need <= ms->alloced)

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  00037	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003b	48 39 44 24 48	 cmp	 QWORD PTR need$[rsp], rax
  00040	7f 07		 jg	 SHORT $LN4@merge_getm

; 1513 :         return 0;

  00042	33 c0		 xor	 eax, eax
  00044	e9 d0 00 00 00	 jmp	 $LN5@merge_getm
$LN4@merge_getm:

; 1514 : 
; 1515 :     multiplier = ms->a.values != NULL ? 2 : 1;

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  0004e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00053	74 0a		 je	 SHORT $LN8@merge_getm
  00055	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR tv73[rsp], 2
  0005d	eb 08		 jmp	 SHORT $LN9@merge_getm
$LN8@merge_getm:
  0005f	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN9@merge_getm:
  00067	8b 44 24 24	 mov	 eax, DWORD PTR tv73[rsp]
  0006b	89 44 24 20	 mov	 DWORD PTR multiplier$[rsp], eax

; 1516 : 
; 1517 :     /* Don't realloc!  That can cost cycles to copy the old data, but
; 1518 :      * we don't care what's in the block.
; 1519 :      */
; 1520 :     merge_freemem(ms);

  0006f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ms$[rsp]
  00074	e8 00 00 00 00	 call	 merge_freemem

; 1521 :     if ((size_t)need > PY_SSIZE_T_MAX / sizeof(PyObject*) / multiplier) {

  00079	48 63 44 24 20	 movsxd	 rax, DWORD PTR multiplier$[rsp]
  0007e	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
  00083	33 d2		 xor	 edx, edx
  00085	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  0008f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv75[rsp]
  00094	48 f7 f1	 div	 rcx
  00097	48 39 44 24 48	 cmp	 QWORD PTR need$[rsp], rax
  0009c	76 0c		 jbe	 SHORT $LN3@merge_getm

; 1522 :         PyErr_NoMemory();

  0009e	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1523 :         return -1;

  000a3	b8 ff ff ff ff	 mov	 eax, -1
  000a8	eb 6f		 jmp	 SHORT $LN5@merge_getm
$LN3@merge_getm:

; 1524 :     }
; 1525 :     ms->a.keys = (PyObject**)PyMem_Malloc(multiplier * need
; 1526 :                                           * sizeof(PyObject *));

  000aa	48 63 44 24 20	 movsxd	 rax, DWORD PTR multiplier$[rsp]
  000af	48 0f af 44 24
	48		 imul	 rax, QWORD PTR need$[rsp]
  000b5	48 c1 e0 03	 shl	 rax, 3
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 PyMem_Malloc
  000c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ms$[rsp]
  000c6	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1527 :     if (ms->a.keys != NULL) {

  000ca	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  000cf	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000d4	74 39		 je	 SHORT $LN2@merge_getm

; 1528 :         ms->alloced = need;

  000d6	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  000db	48 8b 4c 24 48	 mov	 rcx, QWORD PTR need$[rsp]
  000e0	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1529 :         if (ms->a.values != NULL)

  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  000e9	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000ee	74 1b		 je	 SHORT $LN1@merge_getm

; 1530 :             ms->a.values = &ms->a.keys[need];

  000f0	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  000f5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000f9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR need$[rsp]
  000fe	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00102	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ms$[rsp]
  00107	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN1@merge_getm:

; 1531 :         return 0;

  0010b	33 c0		 xor	 eax, eax
  0010d	eb 0a		 jmp	 SHORT $LN5@merge_getm
$LN2@merge_getm:

; 1532 :     }
; 1533 :     PyErr_NoMemory();

  0010f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1534 :     return -1;

  00114	b8 ff ff ff ff	 mov	 eax, -1
$LN5@merge_getm:

; 1535 : }

  00119	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011d	c3		 ret	 0
merge_getmem ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@OKJHPBJL@?$AAn?$AAb?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@HCFBMBCE@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	$T23459
PUBLIC	$T23460
PUBLIC	$T23461
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_hi DD imagerel merge_hi
	DD	imagerel merge_hi+2100
	DD	imagerel $unwind$merge_hi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_hi DD 041d01H
	DD	01b011dH
	DD	060157016H
xdata	ENDS
;	COMDAT ??_C@_1CE@OKJHPBJL@?$AAn?$AAb?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@OKJHPBJL@?$AAn?$AAb?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 'b', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'n', 00H, 'a', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@HCFBMBCE@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@HCFBMBCE@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?$AA@ DB 'n'
	DB	00H, 'a', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'n', 00H, 'b', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '1', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT merge_hi
_TEXT	SEGMENT
baseb$ = 48
basea$ = 64
min_gallop$ = 80
dest$ = 88
k$ = 104
result$ = 112
acount$21541 = 120
bcount$21542 = 128
$T23459 = 136
$T23460 = 152
$T23461 = 168
tv85 = 184
tv186 = 192
ms$ = 240
ssa$ = 248
na$ = 256
ssb$ = 264
nb$ = 272
merge_hi PROC						; COMDAT

; 1680 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1681 :     Py_ssize_t k;
; 1682 :     sortslice dest, basea, baseb;
; 1683 :     int result = -1;            /* guilty until proved innocent */

  0001d	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR result$[rsp], -1

; 1684 :     Py_ssize_t min_gallop;
; 1685 : 
; 1686 :     assert(ms && ssa.keys && ssb.keys && na > 0 && nb > 0);

  00025	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR ms$[rsp], 0
  0002e	74 32		 je	 SHORT $LN31@merge_hi
  00030	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR ssa$[rsp]
  00038	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003c	74 24		 je	 SHORT $LN31@merge_hi
  0003e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR ssb$[rsp]
  00046	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004a	74 16		 je	 SHORT $LN31@merge_hi
  0004c	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  00055	7e 0b		 jle	 SHORT $LN31@merge_hi
  00057	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  00060	7f 1c		 jg	 SHORT $LN32@merge_hi
$LN31@merge_hi:
  00062	41 b8 96 06 00
	00		 mov	 r8d, 1686		; 00000696H
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@PGIMGMIE@?$AAm?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAa@
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007c	33 c0		 xor	 eax, eax
$LN32@merge_hi:

; 1687 :     assert(ssa.keys + na == ssb.keys);

  0007e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR ssa$[rsp]
  00086	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00089	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR na$[rsp]
  00091	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00095	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ssb$[rsp]
  0009d	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  000a0	74 1c		 je	 SHORT $LN33@merge_hi
  000a2	41 b8 97 06 00
	00		 mov	 r8d, 1687		; 00000697H
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@HPMMPCN@?$AAs?$AAs?$AAa?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?5?$AA?$CL?$AA?5?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAs?$AAb?$AA?4?$AAk?$AAe?$AAy?$AAs?$AA?$AA@
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000bc	33 c0		 xor	 eax, eax
$LN33@merge_hi:

; 1688 :     if (MERGE_GETMEM(ms, nb) < 0)

  000be	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  000c6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ca	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR nb$[rsp], rax
  000d2	7f 0d		 jg	 SHORT $LN34@merge_hi
  000d4	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv85[rsp], 0
  000df	eb 1c		 jmp	 SHORT $LN35@merge_hi
$LN34@merge_hi:
  000e1	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR nb$[rsp]
  000e9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  000f1	e8 00 00 00 00	 call	 merge_getmem
  000f6	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv85[rsp], eax
$LN35@merge_hi:
  000fd	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR tv85[rsp], 0
  00105	7d 0c		 jge	 SHORT $LN28@merge_hi

; 1689 :         return -1;

  00107	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0010e	e9 17 07 00 00	 jmp	 $LN29@merge_hi
$LN28@merge_hi:

; 1690 :     dest = ssb;

  00113	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR $T23461[rsp]
  0011b	48 8b f8	 mov	 rdi, rax
  0011e	48 8b b4 24 08
	01 00 00	 mov	 rsi, QWORD PTR ssb$[rsp]
  00126	b9 10 00 00 00	 mov	 ecx, 16
  0012b	f3 a4		 rep movsb
  0012d	48 8d 44 24 58	 lea	 rax, QWORD PTR dest$[rsp]
  00132	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR $T23461[rsp]
  0013a	48 8b f8	 mov	 rdi, rax
  0013d	48 8b f1	 mov	 rsi, rcx
  00140	b9 10 00 00 00	 mov	 ecx, 16
  00145	f3 a4		 rep movsb

; 1691 :     sortslice_advance(&dest, nb-1);

  00147	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR nb$[rsp]
  0014f	48 ff c8	 dec	 rax
  00152	48 8b d0	 mov	 rdx, rax
  00155	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  0015a	e8 00 00 00 00	 call	 sortslice_advance

; 1692 :     sortslice_memcpy(&ms->a, 0, &ssb, 0, nb);

  0015f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  00167	48 83 c0 08	 add	 rax, 8
  0016b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR nb$[rsp]
  00173	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00178	45 33 c9	 xor	 r9d, r9d
  0017b	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR ssb$[rsp]
  00183	33 d2		 xor	 edx, edx
  00185	48 8b c8	 mov	 rcx, rax
  00188	e8 00 00 00 00	 call	 sortslice_memcpy

; 1693 :     basea = ssa;

  0018d	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR $T23460[rsp]
  00195	48 8b f8	 mov	 rdi, rax
  00198	48 8b b4 24 f8
	00 00 00	 mov	 rsi, QWORD PTR ssa$[rsp]
  001a0	b9 10 00 00 00	 mov	 ecx, 16
  001a5	f3 a4		 rep movsb
  001a7	48 8d 44 24 40	 lea	 rax, QWORD PTR basea$[rsp]
  001ac	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T23460[rsp]
  001b4	48 8b f8	 mov	 rdi, rax
  001b7	48 8b f1	 mov	 rsi, rcx
  001ba	b9 10 00 00 00	 mov	 ecx, 16
  001bf	f3 a4		 rep movsb

; 1694 :     baseb = ms->a;

  001c1	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR $T23459[rsp]
  001c9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  001d1	48 8b f8	 mov	 rdi, rax
  001d4	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  001d8	b9 10 00 00 00	 mov	 ecx, 16
  001dd	f3 a4		 rep movsb
  001df	48 8d 44 24 30	 lea	 rax, QWORD PTR baseb$[rsp]
  001e4	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR $T23459[rsp]
  001ec	48 8b f8	 mov	 rdi, rax
  001ef	48 8b f1	 mov	 rsi, rcx
  001f2	b9 10 00 00 00	 mov	 ecx, 16
  001f7	f3 a4		 rep movsb

; 1695 :     ssb.keys = ms->a.keys + nb - 1;

  001f9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  00201	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00205	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR nb$[rsp]
  0020d	48 8d 44 c8 f8	 lea	 rax, QWORD PTR [rax+rcx*8-8]
  00212	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ssb$[rsp]
  0021a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1696 :     if (ssb.values != NULL)

  0021d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR ssb$[rsp]
  00225	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0022a	74 25		 je	 SHORT $LN27@merge_hi

; 1697 :         ssb.values = ms->a.values + nb - 1;

  0022c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  00234	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00238	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR nb$[rsp]
  00240	48 8d 44 c8 f8	 lea	 rax, QWORD PTR [rax+rcx*8-8]
  00245	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ssb$[rsp]
  0024d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN27@merge_hi:

; 1698 :     sortslice_advance(&ssa, na - 1);

  00251	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR na$[rsp]
  00259	48 ff c8	 dec	 rax
  0025c	48 8b d0	 mov	 rdx, rax
  0025f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR ssa$[rsp]
  00267	e8 00 00 00 00	 call	 sortslice_advance

; 1699 : 
; 1700 :     sortslice_copy_decr(&dest, &ssa);

  0026c	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR ssa$[rsp]
  00274	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  00279	e8 00 00 00 00	 call	 sortslice_copy_decr

; 1701 :     --na;

  0027e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR na$[rsp]
  00286	48 ff c8	 dec	 rax
  00289	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR na$[rsp], rax

; 1702 :     if (na == 0)

  00291	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  0029a	75 05		 jne	 SHORT $LN26@merge_hi

; 1703 :         goto Succeed;

  0029c	e9 7f 04 00 00	 jmp	 $Succeed$21535
$LN26@merge_hi:

; 1704 :     if (nb == 1)

  002a1	48 83 bc 24 10
	01 00 00 01	 cmp	 QWORD PTR nb$[rsp], 1
  002aa	75 05		 jne	 SHORT $LN25@merge_hi

; 1705 :         goto CopyA;

  002ac	e9 bc 04 00 00	 jmp	 $CopyA$21537
$LN25@merge_hi:

; 1706 : 
; 1707 :     min_gallop = ms->min_gallop;

  002b1	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  002b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002bc	48 89 44 24 50	 mov	 QWORD PTR min_gallop$[rsp], rax
$LN24@merge_hi:

; 1708 :     for (;;) {
; 1709 :         Py_ssize_t acount = 0;          /* # of times A won in a row */

  002c1	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR acount$21541[rsp], 0

; 1710 :         Py_ssize_t bcount = 0;          /* # of times B won in a row */

  002ca	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR bcount$21542[rsp], 0
$LN22@merge_hi:

; 1711 : 
; 1712 :         /* Do the straightforward thing until (if ever) one run
; 1713 :          * appears to win consistently.
; 1714 :          */
; 1715 :         for (;;) {
; 1716 :             assert(na > 0 && nb > 1);

  002d6	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  002df	7e 0b		 jle	 SHORT $LN36@merge_hi
  002e1	48 83 bc 24 10
	01 00 00 01	 cmp	 QWORD PTR nb$[rsp], 1
  002ea	7f 1c		 jg	 SHORT $LN37@merge_hi
$LN36@merge_hi:
  002ec	41 b8 b4 06 00
	00		 mov	 r8d, 1716		; 000006b4H
  002f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@HCFBMBCE@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?$AA@
  00300	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00306	33 c0		 xor	 eax, eax
$LN37@merge_hi:

; 1717 :             k = ISLT(ssb.keys[0], ssa.keys[0]);

  00308	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR ssa$[rsp]
  00310	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00313	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ssb$[rsp]
  0031b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0031e	45 33 c0	 xor	 r8d, r8d
  00321	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00324	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00327	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0032c	48 98		 cdqe
  0032e	48 89 44 24 68	 mov	 QWORD PTR k$[rsp], rax

; 1718 :             if (k) {

  00333	48 83 7c 24 68
	00		 cmp	 QWORD PTR k$[rsp], 0
  00339	74 6b		 je	 SHORT $LN20@merge_hi

; 1719 :                 if (k < 0)

  0033b	48 83 7c 24 68
	00		 cmp	 QWORD PTR k$[rsp], 0
  00341	7d 05		 jge	 SHORT $LN19@merge_hi

; 1720 :                     goto Fail;

  00343	e9 e0 03 00 00	 jmp	 $Fail$21550
$LN19@merge_hi:

; 1721 :                 sortslice_copy_decr(&dest, &ssa);

  00348	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR ssa$[rsp]
  00350	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  00355	e8 00 00 00 00	 call	 sortslice_copy_decr

; 1722 :                 ++acount;

  0035a	48 8b 44 24 78	 mov	 rax, QWORD PTR acount$21541[rsp]
  0035f	48 ff c0	 inc	 rax
  00362	48 89 44 24 78	 mov	 QWORD PTR acount$21541[rsp], rax

; 1723 :                 bcount = 0;

  00367	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR bcount$21542[rsp], 0

; 1724 :                 --na;

  00373	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR na$[rsp]
  0037b	48 ff c8	 dec	 rax
  0037e	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR na$[rsp], rax

; 1725 :                 if (na == 0)

  00386	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  0038f	75 05		 jne	 SHORT $LN18@merge_hi

; 1726 :                     goto Succeed;

  00391	e9 8a 03 00 00	 jmp	 $Succeed$21535
$LN18@merge_hi:

; 1727 :                 if (acount >= min_gallop)

  00396	48 8b 44 24 50	 mov	 rax, QWORD PTR min_gallop$[rsp]
  0039b	48 39 44 24 78	 cmp	 QWORD PTR acount$21541[rsp], rax
  003a0	7c 02		 jl	 SHORT $LN17@merge_hi

; 1728 :                     break;

  003a2	eb 69		 jmp	 SHORT $LN21@merge_hi
$LN17@merge_hi:

; 1729 :             }
; 1730 :             else {

  003a4	eb 62		 jmp	 SHORT $LN16@merge_hi
$LN20@merge_hi:

; 1731 :                 sortslice_copy_decr(&dest, &ssb);

  003a6	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR ssb$[rsp]
  003ae	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  003b3	e8 00 00 00 00	 call	 sortslice_copy_decr

; 1732 :                 ++bcount;

  003b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR bcount$21542[rsp]
  003c0	48 ff c0	 inc	 rax
  003c3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR bcount$21542[rsp], rax

; 1733 :                 acount = 0;

  003cb	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR acount$21541[rsp], 0

; 1734 :                 --nb;

  003d4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR nb$[rsp]
  003dc	48 ff c8	 dec	 rax
  003df	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR nb$[rsp], rax

; 1735 :                 if (nb == 1)

  003e7	48 83 bc 24 10
	01 00 00 01	 cmp	 QWORD PTR nb$[rsp], 1
  003f0	75 05		 jne	 SHORT $LN15@merge_hi

; 1736 :                     goto CopyA;

  003f2	e9 76 03 00 00	 jmp	 $CopyA$21537
$LN15@merge_hi:

; 1737 :                 if (bcount >= min_gallop)

  003f7	48 8b 44 24 50	 mov	 rax, QWORD PTR min_gallop$[rsp]
  003fc	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR bcount$21542[rsp], rax
  00404	7c 02		 jl	 SHORT $LN14@merge_hi

; 1738 :                     break;

  00406	eb 05		 jmp	 SHORT $LN21@merge_hi
$LN14@merge_hi:
$LN16@merge_hi:

; 1739 :             }
; 1740 :         }

  00408	e9 c9 fe ff ff	 jmp	 $LN22@merge_hi
$LN21@merge_hi:

; 1741 : 
; 1742 :         /* One run is winning so consistently that galloping may
; 1743 :          * be a huge win.  So try that, and continue galloping until
; 1744 :          * (if ever) neither run appears to be winning consistently
; 1745 :          * anymore.
; 1746 :          */
; 1747 :         ++min_gallop;

  0040d	48 8b 44 24 50	 mov	 rax, QWORD PTR min_gallop$[rsp]
  00412	48 ff c0	 inc	 rax
  00415	48 89 44 24 50	 mov	 QWORD PTR min_gallop$[rsp], rax
$LN44@merge_hi:
$LN13@merge_hi:

; 1748 :         do {
; 1749 :             assert(na > 0 && nb > 1);

  0041a	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  00423	7e 0b		 jle	 SHORT $LN38@merge_hi
  00425	48 83 bc 24 10
	01 00 00 01	 cmp	 QWORD PTR nb$[rsp], 1
  0042e	7f 1c		 jg	 SHORT $LN39@merge_hi
$LN38@merge_hi:
  00430	41 b8 d5 06 00
	00		 mov	 r8d, 1749		; 000006d5H
  00436	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0043d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@HCFBMBCE@?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAb?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?$AA@
  00444	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0044a	33 c0		 xor	 eax, eax
$LN39@merge_hi:

; 1750 :             min_gallop -= min_gallop > 1;

  0044c	48 83 7c 24 50
	01		 cmp	 QWORD PTR min_gallop$[rsp], 1
  00452	7e 0e		 jle	 SHORT $LN40@merge_hi
  00454	48 c7 84 24 c0
	00 00 00 01 00
	00 00		 mov	 QWORD PTR tv186[rsp], 1
  00460	eb 0c		 jmp	 SHORT $LN41@merge_hi
$LN40@merge_hi:
  00462	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv186[rsp], 0
$LN41@merge_hi:
  0046e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv186[rsp]
  00476	48 8b 4c 24 50	 mov	 rcx, QWORD PTR min_gallop$[rsp]
  0047b	48 2b c8	 sub	 rcx, rax
  0047e	48 8b c1	 mov	 rax, rcx
  00481	48 89 44 24 50	 mov	 QWORD PTR min_gallop$[rsp], rax

; 1751 :             ms->min_gallop = min_gallop;

  00486	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  0048e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR min_gallop$[rsp]
  00493	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1752 :             k = gallop_right(ssb.keys[0], basea.keys, na, na-1);

  00496	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR na$[rsp]
  0049e	48 ff c8	 dec	 rax
  004a1	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ssb$[rsp]
  004a9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004ac	4c 8b c8	 mov	 r9, rax
  004af	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR na$[rsp]
  004b7	48 8b 54 24 40	 mov	 rdx, QWORD PTR basea$[rsp]
  004bc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004bf	e8 00 00 00 00	 call	 gallop_right
  004c4	48 89 44 24 68	 mov	 QWORD PTR k$[rsp], rax

; 1753 :             if (k < 0)

  004c9	48 83 7c 24 68
	00		 cmp	 QWORD PTR k$[rsp], 0
  004cf	7d 05		 jge	 SHORT $LN10@merge_hi

; 1754 :                 goto Fail;

  004d1	e9 52 02 00 00	 jmp	 $Fail$21550
$LN10@merge_hi:

; 1755 :             k = na - k;

  004d6	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  004db	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR na$[rsp]
  004e3	48 2b c8	 sub	 rcx, rax
  004e6	48 8b c1	 mov	 rax, rcx
  004e9	48 89 44 24 68	 mov	 QWORD PTR k$[rsp], rax

; 1756 :             acount = k;

  004ee	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  004f3	48 89 44 24 78	 mov	 QWORD PTR acount$21541[rsp], rax

; 1757 :             if (k) {

  004f8	48 83 7c 24 68
	00		 cmp	 QWORD PTR k$[rsp], 0
  004fe	74 7f		 je	 SHORT $LN9@merge_hi

; 1758 :                 sortslice_advance(&dest, -k);

  00500	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  00505	48 f7 d8	 neg	 rax
  00508	48 8b d0	 mov	 rdx, rax
  0050b	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  00510	e8 00 00 00 00	 call	 sortslice_advance

; 1759 :                 sortslice_advance(&ssa, -k);

  00515	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  0051a	48 f7 d8	 neg	 rax
  0051d	48 8b d0	 mov	 rdx, rax
  00520	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR ssa$[rsp]
  00528	e8 00 00 00 00	 call	 sortslice_advance

; 1760 :                 sortslice_memmove(&dest, 1, &ssa, 1, k);

  0052d	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  00532	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00537	41 b9 01 00 00
	00		 mov	 r9d, 1
  0053d	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR ssa$[rsp]
  00545	ba 01 00 00 00	 mov	 edx, 1
  0054a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  0054f	e8 00 00 00 00	 call	 sortslice_memmove

; 1761 :                 na -= k;

  00554	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  00559	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR na$[rsp]
  00561	48 2b c8	 sub	 rcx, rax
  00564	48 8b c1	 mov	 rax, rcx
  00567	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR na$[rsp], rax

; 1762 :                 if (na == 0)

  0056f	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  00578	75 05		 jne	 SHORT $LN8@merge_hi

; 1763 :                     goto Succeed;

  0057a	e9 a1 01 00 00	 jmp	 $Succeed$21535
$LN8@merge_hi:
$LN9@merge_hi:

; 1764 :             }
; 1765 :             sortslice_copy_decr(&dest, &ssb);

  0057f	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR ssb$[rsp]
  00587	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  0058c	e8 00 00 00 00	 call	 sortslice_copy_decr

; 1766 :             --nb;

  00591	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR nb$[rsp]
  00599	48 ff c8	 dec	 rax
  0059c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR nb$[rsp], rax

; 1767 :             if (nb == 1)

  005a4	48 83 bc 24 10
	01 00 00 01	 cmp	 QWORD PTR nb$[rsp], 1
  005ad	75 05		 jne	 SHORT $LN7@merge_hi

; 1768 :                 goto CopyA;

  005af	e9 b9 01 00 00	 jmp	 $CopyA$21537
$LN7@merge_hi:

; 1769 : 
; 1770 :             k = gallop_left(ssa.keys[0], baseb.keys, nb, nb-1);

  005b4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR nb$[rsp]
  005bc	48 ff c8	 dec	 rax
  005bf	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR ssa$[rsp]
  005c7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  005ca	4c 8b c8	 mov	 r9, rax
  005cd	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR nb$[rsp]
  005d5	48 8b 54 24 30	 mov	 rdx, QWORD PTR baseb$[rsp]
  005da	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  005dd	e8 00 00 00 00	 call	 gallop_left
  005e2	48 89 44 24 68	 mov	 QWORD PTR k$[rsp], rax

; 1771 :             if (k < 0)

  005e7	48 83 7c 24 68
	00		 cmp	 QWORD PTR k$[rsp], 0
  005ed	7d 05		 jge	 SHORT $LN6@merge_hi

; 1772 :                 goto Fail;

  005ef	e9 34 01 00 00	 jmp	 $Fail$21550
$LN6@merge_hi:

; 1773 :             k = nb - k;

  005f4	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  005f9	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR nb$[rsp]
  00601	48 2b c8	 sub	 rcx, rax
  00604	48 8b c1	 mov	 rax, rcx
  00607	48 89 44 24 68	 mov	 QWORD PTR k$[rsp], rax

; 1774 :             bcount = k;

  0060c	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  00611	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR bcount$21542[rsp], rax

; 1775 :             if (k) {

  00619	48 83 7c 24 68
	00		 cmp	 QWORD PTR k$[rsp], 0
  0061f	0f 84 8c 00 00
	00		 je	 $LN5@merge_hi

; 1776 :                 sortslice_advance(&dest, -k);

  00625	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  0062a	48 f7 d8	 neg	 rax
  0062d	48 8b d0	 mov	 rdx, rax
  00630	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  00635	e8 00 00 00 00	 call	 sortslice_advance

; 1777 :                 sortslice_advance(&ssb, -k);

  0063a	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  0063f	48 f7 d8	 neg	 rax
  00642	48 8b d0	 mov	 rdx, rax
  00645	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ssb$[rsp]
  0064d	e8 00 00 00 00	 call	 sortslice_advance

; 1778 :                 sortslice_memcpy(&dest, 1, &ssb, 1, k);

  00652	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  00657	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0065c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00662	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR ssb$[rsp]
  0066a	ba 01 00 00 00	 mov	 edx, 1
  0066f	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  00674	e8 00 00 00 00	 call	 sortslice_memcpy

; 1779 :                 nb -= k;

  00679	48 8b 44 24 68	 mov	 rax, QWORD PTR k$[rsp]
  0067e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR nb$[rsp]
  00686	48 2b c8	 sub	 rcx, rax
  00689	48 8b c1	 mov	 rax, rcx
  0068c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR nb$[rsp], rax

; 1780 :                 if (nb == 1)

  00694	48 83 bc 24 10
	01 00 00 01	 cmp	 QWORD PTR nb$[rsp], 1
  0069d	75 05		 jne	 SHORT $LN4@merge_hi

; 1781 :                     goto CopyA;

  0069f	e9 c9 00 00 00	 jmp	 $CopyA$21537
$LN4@merge_hi:

; 1782 :                 /* nb==0 is impossible now if the comparison
; 1783 :                  * function is consistent, but we can't assume
; 1784 :                  * that it is.
; 1785 :                  */
; 1786 :                 if (nb == 0)

  006a4	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  006ad	75 02		 jne	 SHORT $LN3@merge_hi

; 1787 :                     goto Succeed;

  006af	eb 6f		 jmp	 SHORT $Succeed$21535
$LN3@merge_hi:
$LN5@merge_hi:

; 1788 :             }
; 1789 :             sortslice_copy_decr(&dest, &ssa);

  006b1	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR ssa$[rsp]
  006b9	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  006be	e8 00 00 00 00	 call	 sortslice_copy_decr

; 1790 :             --na;

  006c3	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR na$[rsp]
  006cb	48 ff c8	 dec	 rax
  006ce	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR na$[rsp], rax

; 1791 :             if (na == 0)

  006d6	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  006df	75 02		 jne	 SHORT $LN2@merge_hi

; 1792 :                 goto Succeed;

  006e1	eb 3d		 jmp	 SHORT $Succeed$21535
$LN2@merge_hi:

; 1793 :         } while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);

  006e3	48 83 7c 24 78
	07		 cmp	 QWORD PTR acount$21541[rsp], 7
  006e9	0f 8d 2b fd ff
	ff		 jge	 $LN13@merge_hi
  006ef	48 83 bc 24 80
	00 00 00 07	 cmp	 QWORD PTR bcount$21542[rsp], 7
  006f8	0f 8d 1c fd ff
	ff		 jge	 $LN44@merge_hi

; 1794 :         ++min_gallop;           /* penalize it for leaving galloping mode */

  006fe	48 8b 44 24 50	 mov	 rax, QWORD PTR min_gallop$[rsp]
  00703	48 ff c0	 inc	 rax
  00706	48 89 44 24 50	 mov	 QWORD PTR min_gallop$[rsp], rax

; 1795 :         ms->min_gallop = min_gallop;

  0070b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  00713	48 8b 4c 24 50	 mov	 rcx, QWORD PTR min_gallop$[rsp]
  00718	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1796 :     }

  0071b	e9 a1 fb ff ff	 jmp	 $LN24@merge_hi
$Succeed$21535:

; 1797 : Succeed:
; 1798 :     result = 0;

  00720	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0
$Fail$21550:

; 1799 : Fail:
; 1800 :     if (nb)

  00728	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR nb$[rsp], 0
  00731	74 30		 je	 SHORT $LN1@merge_hi

; 1801 :         sortslice_memcpy(&dest, -(nb-1), &baseb, 0, nb);

  00733	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR nb$[rsp]
  0073b	48 ff c8	 dec	 rax
  0073e	48 f7 d8	 neg	 rax
  00741	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR nb$[rsp]
  00749	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0074e	45 33 c9	 xor	 r9d, r9d
  00751	4c 8d 44 24 30	 lea	 r8, QWORD PTR baseb$[rsp]
  00756	48 8b d0	 mov	 rdx, rax
  00759	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  0075e	e8 00 00 00 00	 call	 sortslice_memcpy
$LN1@merge_hi:

; 1802 :     return result;

  00763	48 63 44 24 70	 movsxd	 rax, DWORD PTR result$[rsp]
  00768	e9 bd 00 00 00	 jmp	 $LN29@merge_hi
$CopyA$21537:

; 1803 : CopyA:
; 1804 :     assert(nb == 1 && na > 0);

  0076d	48 83 bc 24 10
	01 00 00 01	 cmp	 QWORD PTR nb$[rsp], 1
  00776	75 0b		 jne	 SHORT $LN42@merge_hi
  00778	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR na$[rsp], 0
  00781	7f 1c		 jg	 SHORT $LN43@merge_hi
$LN42@merge_hi:
  00783	41 b8 0c 07 00
	00		 mov	 r8d, 1804		; 0000070cH
  00789	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00790	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@OKJHPBJL@?$AAn?$AAb?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAa?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00797	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0079d	33 c0		 xor	 eax, eax
$LN43@merge_hi:

; 1805 :     /* The first element of ssb belongs at the front of the merge. */
; 1806 :     sortslice_memmove(&dest, 1-na, &ssa, 1-na, na);

  0079f	b8 01 00 00 00	 mov	 eax, 1
  007a4	48 2b 84 24 00
	01 00 00	 sub	 rax, QWORD PTR na$[rsp]
  007ac	b9 01 00 00 00	 mov	 ecx, 1
  007b1	48 2b 8c 24 00
	01 00 00	 sub	 rcx, QWORD PTR na$[rsp]
  007b9	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR na$[rsp]
  007c1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  007c6	4c 8b c8	 mov	 r9, rax
  007c9	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR ssa$[rsp]
  007d1	48 8b d1	 mov	 rdx, rcx
  007d4	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  007d9	e8 00 00 00 00	 call	 sortslice_memmove

; 1807 :     sortslice_advance(&dest, -na);

  007de	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR na$[rsp]
  007e6	48 f7 d8	 neg	 rax
  007e9	48 8b d0	 mov	 rdx, rax
  007ec	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  007f1	e8 00 00 00 00	 call	 sortslice_advance

; 1808 :     sortslice_advance(&ssa, -na);

  007f6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR na$[rsp]
  007fe	48 f7 d8	 neg	 rax
  00801	48 8b d0	 mov	 rdx, rax
  00804	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR ssa$[rsp]
  0080c	e8 00 00 00 00	 call	 sortslice_advance

; 1809 :     sortslice_copy(&dest, 0, &ssb, 0);

  00811	45 33 c9	 xor	 r9d, r9d
  00814	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR ssb$[rsp]
  0081c	33 d2		 xor	 edx, edx
  0081e	48 8d 4c 24 58	 lea	 rcx, QWORD PTR dest$[rsp]
  00823	e8 00 00 00 00	 call	 sortslice_copy

; 1810 :     return 0;

  00828	33 c0		 xor	 eax, eax
$LN29@merge_hi:

; 1811 : }

  0082a	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00831	5f		 pop	 rdi
  00832	5e		 pop	 rsi
  00833	c3		 ret	 0
merge_hi ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT sortslice_copy_decr
_TEXT	SEGMENT
dst$ = 8
src$ = 16
sortslice_copy_decr PROC				; COMDAT

; 1055 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1056 :     *dst->keys-- = *src->keys--;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR src$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dst$[rsp]
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax
  00020	48 8b 44 24 08	 mov	 rax, QWORD PTR dst$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 83 e8 08	 sub	 rax, 8
  0002c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dst$[rsp]
  00031	48 89 01	 mov	 QWORD PTR [rcx], rax
  00034	48 8b 44 24 10	 mov	 rax, QWORD PTR src$[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 83 e8 08	 sub	 rax, 8
  00040	48 8b 4c 24 10	 mov	 rcx, QWORD PTR src$[rsp]
  00045	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1057 :     if (dst->values != NULL)

  00048	48 8b 44 24 08	 mov	 rax, QWORD PTR dst$[rsp]
  0004d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00052	74 44		 je	 SHORT $LN1@sortslice_@6

; 1058 :         *dst->values-- = *src->values--;

  00054	48 8b 44 24 10	 mov	 rax, QWORD PTR src$[rsp]
  00059	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dst$[rsp]
  00062	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 89 01	 mov	 QWORD PTR [rcx], rax
  0006c	48 8b 44 24 08	 mov	 rax, QWORD PTR dst$[rsp]
  00071	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00075	48 83 e8 08	 sub	 rax, 8
  00079	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dst$[rsp]
  0007e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00082	48 8b 44 24 10	 mov	 rax, QWORD PTR src$[rsp]
  00087	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008b	48 83 e8 08	 sub	 rax, 8
  0008f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR src$[rsp]
  00094	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN1@sortslice_@6:

; 1059 : }

  00098	f3 c3		 fatret	 0
sortslice_copy_decr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_force_collapse DD imagerel merge_force_collapse
	DD	imagerel merge_force_collapse+191
	DD	imagerel $unwind$merge_force_collapse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_force_collapse DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT merge_force_collapse
_TEXT	SEGMENT
p$ = 32
n$21627 = 40
ms$ = 64
merge_force_collapse PROC				; COMDAT

; 1912 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1913 :     struct s_slice *p = ms->pending;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  0000e	48 83 c0 28	 add	 rax, 40			; 00000028H
  00012	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1914 : 
; 1915 :     assert(ms);

  00017	48 83 7c 24 40
	00		 cmp	 QWORD PTR ms$[rsp], 0
  0001d	75 1c		 jne	 SHORT $LN7@merge_forc
  0001f	41 b8 7b 07 00
	00		 mov	 r8d, 1915		; 0000077bH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_15IDNNENKK@?$AAm?$AAs?$AA?$AA@
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00039	33 c0		 xor	 eax, eax
$LN7@merge_forc:
$LN4@merge_forc:

; 1916 :     while (ms->n > 1) {

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  00040	83 78 20 01	 cmp	 DWORD PTR [rax+32], 1
  00044	7e 72		 jle	 SHORT $LN3@merge_forc

; 1917 :         Py_ssize_t n = ms->n - 2;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR ms$[rsp]
  0004b	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0004e	83 e8 02	 sub	 eax, 2
  00051	48 98		 cdqe
  00053	48 89 44 24 28	 mov	 QWORD PTR n$21627[rsp], rax

; 1918 :         if (n > 0 && p[n-1].len < p[n+1].len)

  00058	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$21627[rsp], 0
  0005e	7e 3b		 jle	 SHORT $LN2@merge_forc
  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR n$21627[rsp]
  00065	48 ff c8	 dec	 rax
  00068	48 6b c0 18	 imul	 rax, 24
  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$21627[rsp]
  00071	48 ff c1	 inc	 rcx
  00074	48 6b c9 18	 imul	 rcx, 24
  00078	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  0007d	4c 8b 44 24 20	 mov	 r8, QWORD PTR p$[rsp]
  00082	49 8b 4c 08 10	 mov	 rcx, QWORD PTR [r8+rcx+16]
  00087	48 39 4c 02 10	 cmp	 QWORD PTR [rdx+rax+16], rcx
  0008c	7d 0d		 jge	 SHORT $LN2@merge_forc

; 1919 :             --n;

  0008e	48 8b 44 24 28	 mov	 rax, QWORD PTR n$21627[rsp]
  00093	48 ff c8	 dec	 rax
  00096	48 89 44 24 28	 mov	 QWORD PTR n$21627[rsp], rax
$LN2@merge_forc:

; 1920 :         if (merge_at(ms, n) < 0)

  0009b	48 8b 54 24 28	 mov	 rdx, QWORD PTR n$21627[rsp]
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ms$[rsp]
  000a5	e8 00 00 00 00	 call	 merge_at
  000aa	48 85 c0	 test	 rax, rax
  000ad	7d 07		 jge	 SHORT $LN1@merge_forc

; 1921 :             return -1;

  000af	b8 ff ff ff ff	 mov	 eax, -1
  000b4	eb 04		 jmp	 SHORT $LN5@merge_forc
$LN1@merge_forc:

; 1922 :     }

  000b6	eb 83		 jmp	 SHORT $LN4@merge_forc
$LN3@merge_forc:

; 1923 :     return 0;

  000b8	33 c0		 xor	 eax, eax
$LN5@merge_forc:

; 1924 : }

  000ba	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000be	c3		 ret	 0
merge_force_collapse ENDP
_TEXT	ENDS
PUBLIC	??_C@_1O@OOEGIONJ@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_compute_minrun DD imagerel merge_compute_minrun
	DD	imagerel merge_compute_minrun+123
	DD	imagerel $unwind$merge_compute_minrun
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_compute_minrun DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1O@OOEGIONJ@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1O@OOEGIONJ@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'n', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT merge_compute_minrun
_TEXT	SEGMENT
r$ = 32
n$ = 64
merge_compute_minrun PROC				; COMDAT

; 1938 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1939 :     Py_ssize_t r = 0;           /* becomes 1 if any 1 bits are shifted off */

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR r$[rsp], 0

; 1940 : 
; 1941 :     assert(n >= 0);

  00012	48 83 7c 24 40
	00		 cmp	 QWORD PTR n$[rsp], 0
  00018	7d 1c		 jge	 SHORT $LN5@merge_comp
  0001a	41 b8 95 07 00
	00		 mov	 r8d, 1941		; 00000795H
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@OOEGIONJ@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00034	33 c0		 xor	 eax, eax
$LN5@merge_comp:
$LN2@merge_comp:

; 1942 :     while (n >= 64) {

  00036	48 83 7c 24 40
	40		 cmp	 QWORD PTR n$[rsp], 64	; 00000040H
  0003c	7c 28		 jl	 SHORT $LN1@merge_comp

; 1943 :         r |= n & 1;

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  00043	48 83 e0 01	 and	 rax, 1
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR r$[rsp]
  0004c	48 0b c8	 or	 rcx, rax
  0004f	48 8b c1	 mov	 rax, rcx
  00052	48 89 44 24 20	 mov	 QWORD PTR r$[rsp], rax

; 1944 :         n >>= 1;

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  0005c	48 d1 f8	 sar	 rax, 1
  0005f	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax

; 1945 :     }

  00064	eb d0		 jmp	 SHORT $LN2@merge_comp
$LN1@merge_comp:

; 1946 :     return n + r;

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR r$[rsp]
  0006b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx

; 1947 : }

  00076	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007a	c3		 ret	 0
merge_compute_minrun ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reverse_sortslice DD imagerel reverse_sortslice
	DD	imagerel reverse_sortslice+99
	DD	imagerel $unwind$reverse_sortslice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reverse_sortslice DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT reverse_sortslice
_TEXT	SEGMENT
s$ = 48
n$ = 56
reverse_sortslice PROC					; COMDAT

; 1951 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1952 :     reverse_slice(s->keys, &s->keys[n]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  0001b	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0001f	48 8b d0	 mov	 rdx, rax
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00027	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002a	e8 00 00 00 00	 call	 reverse_slice

; 1953 :     if (s->values != NULL)

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00034	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00039	74 23		 je	 SHORT $LN1@reverse_so

; 1954 :         reverse_slice(s->values, &s->values[n]);

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  00049	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0004d	48 8b d0	 mov	 rdx, rax
  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00055	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00059	e8 00 00 00 00	 call	 reverse_slice
$LN1@reverse_so:

; 1955 : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
reverse_sortslice ENDP
_TEXT	ENDS
PUBLIC	PyList_Sort
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_Sort DD imagerel $LN6
	DD	imagerel $LN6+117
	DD	imagerel $unwind$PyList_Sort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Sort DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyList_Sort
_TEXT	SEGMENT
v$ = 48
PyList_Sort PROC					; COMDAT

; 2145 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2146 :     if (v == NULL || !PyList_Check(v)) {

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  0000f	74 18		 je	 SHORT $LN2@PyList_Sor
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  00016	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00020	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00025	85 c0		 test	 eax, eax
  00027	75 18		 jne	 SHORT $LN3@PyList_Sor
$LN2@PyList_Sor:

; 2147 :         PyErr_BadInternalCall();

  00029	ba 63 08 00 00	 mov	 edx, 2147		; 00000863H
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00035	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2148 :         return -1;

  0003a	b8 ff ff ff ff	 mov	 eax, -1
  0003f	eb 2f		 jmp	 SHORT $LN4@PyList_Sor
$LN3@PyList_Sor:

; 2149 :     }
; 2150 :     /*
; 2151 :     if (Px_CHECK_PROTECTION(v, NULL, NULL))
; 2152 :         return -1;
; 2153 :     */
; 2154 :     v = listsort((PyListObject *)v, (PyObject *)NULL, (PyObject *)NULL);

  00041	45 33 c0	 xor	 r8d, r8d
  00044	33 d2		 xor	 edx, edx
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0004b	e8 00 00 00 00	 call	 listsort
  00050	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax

; 2155 :     if (v == NULL)

  00055	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  0005b	75 07		 jne	 SHORT $LN1@PyList_Sor

; 2156 :         return -1;

  0005d	b8 ff ff ff ff	 mov	 eax, -1
  00062	eb 0c		 jmp	 SHORT $LN4@PyList_Sor
$LN1@PyList_Sor:

; 2157 :     Py_DECREF(v);

  00064	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00069	e8 00 00 00 00	 call	 _Py_DecRef

; 2158 :     return 0;

  0006e	33 c0		 xor	 eax, eax
$LN4@PyList_Sor:

; 2159 : }

  00070	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00074	c3		 ret	 0
PyList_Sort ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listreverse DD imagerel listreverse
	DD	imagerel listreverse+84
	DD	imagerel $unwind$listreverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreverse DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listreverse
_TEXT	SEGMENT
self$ = 48
listreverse PROC					; COMDAT

; 2163 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2164 :     if (Py_SIZE(self) > 1)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  00013	7e 27		 jle	 SHORT $LN1@listrevers

; 2165 :         reverse_slice(self->ob_item, self->ob_item + Py_SIZE(self));

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00023	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00027	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0002b	48 8b d0	 mov	 rdx, rax
  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00033	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00037	e8 00 00 00 00	 call	 reverse_slice
$LN1@listrevers:

; 2166 :     Py_RETURN_NONE;

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00043	e8 00 00 00 00	 call	 _Py_IncRef
  00048	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2167 : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
listreverse ENDP
_TEXT	ENDS
PUBLIC	PyList_Reverse
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_Reverse DD imagerel $LN6
	DD	imagerel $LN6+133
	DD	imagerel $unwind$PyList_Reverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Reverse DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyList_Reverse
_TEXT	SEGMENT
self$ = 32
v$ = 64
PyList_Reverse PROC					; COMDAT

; 2171 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2172 :     PyListObject *self = (PyListObject *)v;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 2173 : 
; 2174 :     /*
; 2175 :     if (Px_CHECK_PROTECTION(v, NULL, NULL))
; 2176 :         return -1;
; 2177 :     */
; 2178 : 
; 2179 :     if (v == NULL || !PyList_Check(v)) {

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  00019	74 18		 je	 SHORT $LN2@PyList_Rev
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00020	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00024	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002a	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0002f	85 c0		 test	 eax, eax
  00031	75 18		 jne	 SHORT $LN3@PyList_Rev
$LN2@PyList_Rev:

; 2180 :         PyErr_BadInternalCall();

  00033	ba 84 08 00 00	 mov	 edx, 2180		; 00000884H
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0003f	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2181 :         return -1;

  00044	b8 ff ff ff ff	 mov	 eax, -1
  00049	eb 35		 jmp	 SHORT $LN4@PyList_Rev
$LN3@PyList_Rev:

; 2182 :     }
; 2183 :     if (Py_SIZE(self) > 1)

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00050	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  00055	7e 27		 jle	 SHORT $LN1@PyList_Rev

; 2184 :         reverse_slice(self->ob_item, self->ob_item + Py_SIZE(self));

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0005c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00065	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00069	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00075	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00079	e8 00 00 00 00	 call	 reverse_slice
$LN1@PyList_Rev:

; 2185 :     return 0;

  0007e	33 c0		 xor	 eax, eax
$LN4@PyList_Rev:

; 2186 : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	c3		 ret	 0
PyList_Reverse ENDP
_TEXT	ENDS
PUBLIC	PyList_AsTuple
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_AsTuple DD imagerel $LN8
	DD	imagerel $LN8+224
	DD	imagerel $unwind$PyList_AsTuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_AsTuple DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyList_AsTuple
_TEXT	SEGMENT
p$ = 32
w$ = 40
n$ = 48
q$ = 56
v$ = 80
PyList_AsTuple PROC					; COMDAT

; 2190 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2191 :     PyObject *w;
; 2192 :     PyObject **p, **q;
; 2193 :     Py_ssize_t n;
; 2194 :     if (v == NULL || !PyList_Check(v)) {

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR v$[rsp], 0
  0000f	74 18		 je	 SHORT $LN4@PyList_AsT
  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00016	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00020	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00025	85 c0		 test	 eax, eax
  00027	75 18		 jne	 SHORT $LN5@PyList_AsT
$LN4@PyList_AsT:

; 2195 :         PyErr_BadInternalCall();

  00029	ba 93 08 00 00	 mov	 edx, 2195		; 00000893H
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00035	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2196 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 9a 00 00 00	 jmp	 $LN6@PyList_AsT
$LN5@PyList_AsT:

; 2197 :     }
; 2198 :     n = Py_SIZE(v);

  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00046	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004a	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 2199 :     w = PyTuple_New(n);

  0004f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  00054	e8 00 00 00 00	 call	 PyTuple_New
  00059	48 89 44 24 28	 mov	 QWORD PTR w$[rsp], rax

; 2200 :     if (w == NULL)

  0005e	48 83 7c 24 28
	00		 cmp	 QWORD PTR w$[rsp], 0
  00064	75 04		 jne	 SHORT $LN3@PyList_AsT

; 2201 :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	eb 71		 jmp	 SHORT $LN6@PyList_AsT
$LN3@PyList_AsT:

; 2202 :     p = ((PyTupleObject *)w)->ob_item;

  0006a	48 8b 44 24 28	 mov	 rax, QWORD PTR w$[rsp]
  0006f	48 83 c0 70	 add	 rax, 112		; 00000070H
  00073	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 2203 :     q = ((PyListObject *)v)->ob_item;

  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0007d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00081	48 89 44 24 38	 mov	 QWORD PTR q$[rsp], rax
$LN2@PyList_AsT:

; 2204 :     while (--n >= 0) {

  00086	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0008b	48 ff c8	 dec	 rax
  0008e	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax
  00093	48 83 7c 24 30
	00		 cmp	 QWORD PTR n$[rsp], 0
  00099	7c 3b		 jl	 SHORT $LN1@PyList_AsT

; 2205 :         Py_INCREF(*q);

  0009b	48 8b 44 24 38	 mov	 rax, QWORD PTR q$[rsp]
  000a0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a3	e8 00 00 00 00	 call	 _Py_IncRef

; 2206 :         *p = *q;

  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR q$[rsp]
  000b2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2207 :         p++;

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000bd	48 83 c0 08	 add	 rax, 8
  000c1	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 2208 :         q++;

  000c6	48 8b 44 24 38	 mov	 rax, QWORD PTR q$[rsp]
  000cb	48 83 c0 08	 add	 rax, 8
  000cf	48 89 44 24 38	 mov	 QWORD PTR q$[rsp], rax

; 2209 :     }

  000d4	eb b0		 jmp	 SHORT $LN2@PyList_AsT
$LN1@PyList_AsT:

; 2210 :     return w;

  000d6	48 8b 44 24 28	 mov	 rax, QWORD PTR w$[rsp]
$LN6@PyList_AsT:

; 2211 : }

  000db	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000df	c3		 ret	 0
PyList_AsTuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@NCOFMKDI@?$CFR?5is?5not?5in?5list?$AA@ ; `string'
PUBLIC	??_C@_0N@GKKDPPOM@O?$HMO?$CGO?$CG?3index?$AA@	; `string'
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	_PyEval_SliceIndex:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$listindex DD imagerel listindex
	DD	imagerel listindex+383
	DD	imagerel $unwind$listindex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listindex DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0BC@NCOFMKDI@?$CFR?5is?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BC@NCOFMKDI@?$CFR?5is?5not?5in?5list?$AA@ DB '%R is not in list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GKKDPPOM@O?$HMO?$CGO?$CG?3index?$AA@
CONST	SEGMENT
??_C@_0N@GKKDPPOM@O?$HMO?$CGO?$CG?3index?$AA@ DB 'O|O&O&:index', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listindex
_TEXT	SEGMENT
v$ = 64
i$ = 72
stop$ = 80
start$ = 88
cmp$21859 = 96
self$ = 128
args$ = 136
listindex PROC						; COMDAT

; 2215 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2216 :     Py_ssize_t i, start=0, stop=Py_SIZE(self);

  0000e	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  00017	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00023	48 89 44 24 50	 mov	 QWORD PTR stop$[rsp], rax

; 2217 :     PyObject *v;
; 2218 : 
; 2219 :     if (!PyArg_ParseTuple(args, "O|O&O&:index", &v,
; 2220 :                                 _PyEval_SliceIndex, &start,
; 2221 :                                 _PyEval_SliceIndex, &stop))

  00028	48 8d 44 24 50	 lea	 rax, QWORD PTR stop$[rsp]
  0002d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyEval_SliceIndex
  00039	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003e	48 8d 44 24 58	 lea	 rax, QWORD PTR start$[rsp]
  00043	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00048	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_PyEval_SliceIndex
  0004f	4c 8d 44 24 40	 lea	 r8, QWORD PTR v$[rsp]
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@GKKDPPOM@O?$HMO?$CGO?$CG?3index?$AA@
  0005b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00063	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00068	85 c0		 test	 eax, eax
  0006a	75 07		 jne	 SHORT $LN11@listindex

; 2222 :         return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 07 01 00 00	 jmp	 $LN12@listindex
$LN11@listindex:

; 2223 :     if (start < 0) {

  00073	48 83 7c 24 58
	00		 cmp	 QWORD PTR start$[rsp], 0
  00079	7d 2d		 jge	 SHORT $LN10@listindex

; 2224 :         start += Py_SIZE(self);

  0007b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00083	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00087	48 8b 4c 24 58	 mov	 rcx, QWORD PTR start$[rsp]
  0008c	48 03 c8	 add	 rcx, rax
  0008f	48 8b c1	 mov	 rax, rcx
  00092	48 89 44 24 58	 mov	 QWORD PTR start$[rsp], rax

; 2225 :         if (start < 0)

  00097	48 83 7c 24 58
	00		 cmp	 QWORD PTR start$[rsp], 0
  0009d	7d 09		 jge	 SHORT $LN9@listindex

; 2226 :             start = 0;

  0009f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
$LN9@listindex:
$LN10@listindex:

; 2227 :     }
; 2228 :     if (stop < 0) {

  000a8	48 83 7c 24 50
	00		 cmp	 QWORD PTR stop$[rsp], 0
  000ae	7d 2d		 jge	 SHORT $LN8@listindex

; 2229 :         stop += Py_SIZE(self);

  000b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000b8	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stop$[rsp]
  000c1	48 03 c8	 add	 rcx, rax
  000c4	48 8b c1	 mov	 rax, rcx
  000c7	48 89 44 24 50	 mov	 QWORD PTR stop$[rsp], rax

; 2230 :         if (stop < 0)

  000cc	48 83 7c 24 50
	00		 cmp	 QWORD PTR stop$[rsp], 0
  000d2	7d 09		 jge	 SHORT $LN7@listindex

; 2231 :             stop = 0;

  000d4	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR stop$[rsp], 0
$LN7@listindex:
$LN8@listindex:

; 2232 :     }
; 2233 :     for (i = start; i < stop && i < Py_SIZE(self); i++) {

  000dd	48 8b 44 24 58	 mov	 rax, QWORD PTR start$[rsp]
  000e2	48 89 44 24 48	 mov	 QWORD PTR i$[rsp], rax
  000e7	eb 0d		 jmp	 SHORT $LN6@listindex
$LN5@listindex:
  000e9	48 8b 44 24 48	 mov	 rax, QWORD PTR i$[rsp]
  000ee	48 ff c0	 inc	 rax
  000f1	48 89 44 24 48	 mov	 QWORD PTR i$[rsp], rax
$LN6@listindex:
  000f6	48 8b 44 24 50	 mov	 rax, QWORD PTR stop$[rsp]
  000fb	48 39 44 24 48	 cmp	 QWORD PTR i$[rsp], rax
  00100	7d 5e		 jge	 SHORT $LN4@listindex
  00102	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0010a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0010e	48 39 44 24 48	 cmp	 QWORD PTR i$[rsp], rax
  00113	7d 4b		 jge	 SHORT $LN4@listindex

; 2234 :         int cmp = PyObject_RichCompareBool(self->ob_item[i], v, Py_EQ);

  00115	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0011d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00121	41 b8 02 00 00
	00		 mov	 r8d, 2
  00127	48 8b 54 24 40	 mov	 rdx, QWORD PTR v$[rsp]
  0012c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  00131	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00135	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0013a	89 44 24 60	 mov	 DWORD PTR cmp$21859[rsp], eax

; 2235 :         if (cmp > 0)

  0013e	83 7c 24 60 00	 cmp	 DWORD PTR cmp$21859[rsp], 0
  00143	7e 0e		 jle	 SHORT $LN3@listindex

; 2236 :             return PyLong_FromSsize_t(i);

  00145	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0014a	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0014f	eb 29		 jmp	 SHORT $LN12@listindex
  00151	eb 0b		 jmp	 SHORT $LN2@listindex
$LN3@listindex:

; 2237 :         else if (cmp < 0)

  00153	83 7c 24 60 00	 cmp	 DWORD PTR cmp$21859[rsp], 0
  00158	7d 04		 jge	 SHORT $LN1@listindex

; 2238 :             return NULL;

  0015a	33 c0		 xor	 eax, eax
  0015c	eb 1c		 jmp	 SHORT $LN12@listindex
$LN1@listindex:
$LN2@listindex:

; 2239 :     }

  0015e	eb 89		 jmp	 SHORT $LN5@listindex
$LN4@listindex:

; 2240 :     PyErr_Format(PyExc_ValueError, "%R is not in list", v);

  00160	4c 8b 44 24 40	 mov	 r8, QWORD PTR v$[rsp]
  00165	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@NCOFMKDI@?$CFR?5is?5not?5in?5list?$AA@
  0016c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00173	e8 00 00 00 00	 call	 PyErr_Format

; 2241 :     return NULL;

  00178	33 c0		 xor	 eax, eax
$LN12@listindex:

; 2242 : }

  0017a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0017e	c3		 ret	 0
listindex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listcount DD imagerel listcount
	DD	imagerel listcount+151
	DD	imagerel $unwind$listcount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listcount DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listcount
_TEXT	SEGMENT
count$ = 32
i$ = 40
cmp$21878 = 48
self$ = 80
v$ = 88
listcount PROC						; COMDAT

; 2246 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2247 :     Py_ssize_t count = 0;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 2248 :     Py_ssize_t i;
; 2249 : 
; 2250 :     for (i = 0; i < Py_SIZE(self); i++) {

  00017	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00020	eb 0d		 jmp	 SHORT $LN6@listcount
$LN5@listcount:
  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00027	48 ff c0	 inc	 rax
  0002a	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN6@listcount:
  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00034	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00038	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0003d	7d 49		 jge	 SHORT $LN4@listcount

; 2251 :         int cmp = PyObject_RichCompareBool(self->ob_item[i], v, Py_EQ);

  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00044	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00048	41 b8 02 00 00
	00		 mov	 r8d, 2
  0004e	48 8b 54 24 58	 mov	 rdx, QWORD PTR v$[rsp]
  00053	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00058	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0005c	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00061	89 44 24 30	 mov	 DWORD PTR cmp$21878[rsp], eax

; 2252 :         if (cmp > 0)

  00065	83 7c 24 30 00	 cmp	 DWORD PTR cmp$21878[rsp], 0
  0006a	7e 0f		 jle	 SHORT $LN3@listcount

; 2253 :             count++;

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00071	48 ff c0	 inc	 rax
  00074	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
  00079	eb 0b		 jmp	 SHORT $LN2@listcount
$LN3@listcount:

; 2254 :         else if (cmp < 0)

  0007b	83 7c 24 30 00	 cmp	 DWORD PTR cmp$21878[rsp], 0
  00080	7d 04		 jge	 SHORT $LN1@listcount

; 2255 :             return NULL;

  00082	33 c0		 xor	 eax, eax
  00084	eb 0c		 jmp	 SHORT $LN7@listcount
$LN1@listcount:
$LN2@listcount:

; 2256 :     }

  00086	eb 9a		 jmp	 SHORT $LN5@listcount
$LN4@listcount:

; 2257 :     return PyLong_FromSsize_t(count);

  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  0008d	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN7@listcount:

; 2258 : }

  00092	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00096	c3		 ret	 0
listcount ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@DNOMBHLJ@list?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$listremove DD imagerel listremove
	DD	imagerel listremove+201
	DD	imagerel $unwind$listremove
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listremove DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BO@DNOMBHLJ@list?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BO@DNOMBHLJ@list?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ DB 'lis'
	DB	't.remove(x): x not in list', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listremove
_TEXT	SEGMENT
i$ = 32
cmp$21894 = 40
self$ = 64
v$ = 72
listremove PROC						; COMDAT

; 2262 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2263 :     Py_ssize_t i;
; 2264 : 
; 2265 :     /*
; 2266 :     if (Px_PROTECTION_ERROR(self))
; 2267 :         return NULL;
; 2268 :     */
; 2269 : 
; 2270 :     for (i = 0; i < Py_SIZE(self); i++) {

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	eb 0d		 jmp	 SHORT $LN7@listremove
$LN6@listremove:
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0001e	48 ff c0	 inc	 rax
  00021	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN7@listremove:
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002f	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00034	7d 79		 jge	 SHORT $LN5@listremove

; 2271 :         int cmp = PyObject_RichCompareBool(self->ob_item[i], v, Py_EQ);

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0003f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00045	48 8b 54 24 48	 mov	 rdx, QWORD PTR v$[rsp]
  0004a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0004f	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00053	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00058	89 44 24 28	 mov	 DWORD PTR cmp$21894[rsp], eax

; 2272 :         if (cmp > 0) {

  0005c	83 7c 24 28 00	 cmp	 DWORD PTR cmp$21894[rsp], 0
  00061	7e 3c		 jle	 SHORT $LN4@listremove

; 2273 :             if (list_ass_slice(self, i, i+1,
; 2274 :                                (PyObject *)NULL) == 0)

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00068	48 ff c0	 inc	 rax
  0006b	45 33 c9	 xor	 r9d, r9d
  0006e	4c 8b c0	 mov	 r8, rax
  00071	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0007b	e8 00 00 00 00	 call	 list_ass_slice
  00080	85 c0		 test	 eax, eax
  00082	75 15		 jne	 SHORT $LN3@listremove

; 2275 :                 Py_RETURN_NONE;

  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0008b	e8 00 00 00 00	 call	 _Py_IncRef
  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00097	eb 2b		 jmp	 SHORT $LN8@listremove
$LN3@listremove:

; 2276 :             return NULL;

  00099	33 c0		 xor	 eax, eax
  0009b	eb 27		 jmp	 SHORT $LN8@listremove
  0009d	eb 0b		 jmp	 SHORT $LN2@listremove
$LN4@listremove:

; 2277 :         }
; 2278 :         else if (cmp < 0)

  0009f	83 7c 24 28 00	 cmp	 DWORD PTR cmp$21894[rsp], 0
  000a4	7d 04		 jge	 SHORT $LN1@listremove

; 2279 :             return NULL;

  000a6	33 c0		 xor	 eax, eax
  000a8	eb 1a		 jmp	 SHORT $LN8@listremove
$LN1@listremove:
$LN2@listremove:

; 2280 :     }

  000aa	e9 6a ff ff ff	 jmp	 $LN6@listremove
$LN5@listremove:

; 2281 :     PyErr_SetString(PyExc_ValueError, "list.remove(x): x not in list");

  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@DNOMBHLJ@list?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
  000b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000bd	e8 00 00 00 00	 call	 PyErr_SetString

; 2282 :     return NULL;

  000c2	33 c0		 xor	 eax, eax
$LN8@listremove:

; 2283 : }

  000c4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c8	c3		 ret	 0
listremove ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@DJGDJDEC@list_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_traverse DD imagerel list_traverse
	DD	imagerel list_traverse+174
	DD	imagerel $unwind$list_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0O@DJGDJDEC@list_traverse?$AA@
CONST	SEGMENT
??_C@_0O@DJGDJDEC@list_traverse?$AA@ DB 'list_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT list_traverse
_TEXT	SEGMENT
i$ = 32
vret$21925 = 40
o$ = 64
visit$ = 72
arg$ = 80
list_traverse PROC					; COMDAT

; 2287 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2288 :     Py_ssize_t i;
; 2289 : 
; 2290 :     for (i = Py_SIZE(o); --i >= 0; )

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00018	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001c	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN8@list_trave:
  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00026	48 ff c8	 dec	 rax
  00029	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  0002e	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  00034	7c 71		 jl	 SHORT $LN7@list_trave
$LN6@list_trave:

; 2291 :         Py_VISIT(o->ob_item[i]);

  00036	e8 00 00 00 00	 call	 _Py_PXCTX
  0003b	85 c0		 test	 eax, eax
  0003d	74 1c		 je	 SHORT $LN3@list_trave
  0003f	45 33 c9	 xor	 r9d, r9d
  00042	41 b8 f3 08 00
	00		 mov	 r8d, 2291		; 000008f3H
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DJGDJDEC@list_traverse?$AA@
  00056	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@list_trave:
  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00060	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00069	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  0006e	74 2c		 je	 SHORT $LN2@list_trave
  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00075	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00079	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  0007e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00083	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00087	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  0008b	89 44 24 28	 mov	 DWORD PTR vret$21925[rsp], eax
  0008f	83 7c 24 28 00	 cmp	 DWORD PTR vret$21925[rsp], 0
  00094	74 06		 je	 SHORT $LN1@list_trave
  00096	8b 44 24 28	 mov	 eax, DWORD PTR vret$21925[rsp]
  0009a	eb 0d		 jmp	 SHORT $LN9@list_trave
$LN1@list_trave:
$LN2@list_trave:
  0009c	33 c0		 xor	 eax, eax
  0009e	85 c0		 test	 eax, eax
  000a0	75 94		 jne	 SHORT $LN6@list_trave
  000a2	e9 7a ff ff ff	 jmp	 $LN8@list_trave
$LN7@list_trave:

; 2292 :     return 0;

  000a7	33 c0		 xor	 eax, eax
$LN9@list_trave:

; 2293 : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
list_traverse ENDP
_TEXT	ENDS
EXTRN	PyObject_RichCompare:PROC
EXTRN	__ImageBase:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_richcompare DD imagerel list_richcompare
	DD	imagerel list_richcompare+912
	DD	imagerel $unwind$list_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_richcompare DD 021601H
	DD	0110116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_richcompare
_TEXT	SEGMENT
vl$ = 32
i$ = 40
wl$ = 48
res$21950 = 56
k$21961 = 64
res$21974 = 72
vs$21969 = 80
ws$21971 = 88
cmp$21973 = 96
tv135 = 100
tv137 = 104
tv139 = 108
tv141 = 112
tv143 = 116
tv145 = 120
tv147 = 124
v$ = 144
w$ = 152
op$ = 160
list_richcompare PROC					; COMDAT

; 2297 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2298 :     PyListObject *vl, *wl;
; 2299 :     Py_ssize_t i;
; 2300 : 
; 2301 :     if (!PyList_Check(v) || !PyList_Check(w))

  00016	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0001e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00022	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00028	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0002d	85 c0		 test	 eax, eax
  0002f	74 1b		 je	 SHORT $LN25@list_richc
  00031	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00039	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00043	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00048	85 c0		 test	 eax, eax
  0004a	75 18		 jne	 SHORT $LN26@list_richc
$LN25@list_richc:

; 2302 :         Py_RETURN_NOTIMPLEMENTED;

  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00053	e8 00 00 00 00	 call	 _Py_IncRef
  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0005f	e9 0a 03 00 00	 jmp	 $LN27@list_richc
$LN26@list_richc:

; 2303 : 
; 2304 :     vl = (PyListObject *)v;

  00064	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0006c	48 89 44 24 20	 mov	 QWORD PTR vl$[rsp], rax

; 2305 :     wl = (PyListObject *)w;

  00071	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00079	48 89 44 24 30	 mov	 QWORD PTR wl$[rsp], rax

; 2306 : 
; 2307 :     if (Py_SIZE(vl) != Py_SIZE(wl) && (op == Py_EQ || op == Py_NE)) {

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR vl$[rsp]
  00083	48 8b 4c 24 30	 mov	 rcx, QWORD PTR wl$[rsp]
  00088	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0008c	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00090	74 4c		 je	 SHORT $LN24@list_richc
  00092	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  0009a	74 0a		 je	 SHORT $LN23@list_richc
  0009c	83 bc 24 a0 00
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  000a4	75 38		 jne	 SHORT $LN24@list_richc
$LN23@list_richc:

; 2308 :         /* Shortcut: if the lengths differ, the lists differ */
; 2309 :         PyObject *res;
; 2310 :         if (op == Py_EQ)

  000a6	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  000ae	75 0e		 jne	 SHORT $LN22@list_richc

; 2311 :             res = Py_False;

  000b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000b7	48 89 44 24 38	 mov	 QWORD PTR res$21950[rsp], rax

; 2312 :         else

  000bc	eb 0c		 jmp	 SHORT $LN21@list_richc
$LN22@list_richc:

; 2313 :             res = Py_True;

  000be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000c5	48 89 44 24 38	 mov	 QWORD PTR res$21950[rsp], rax
$LN21@list_richc:

; 2314 :         Py_INCREF(res);

  000ca	48 8b 4c 24 38	 mov	 rcx, QWORD PTR res$21950[rsp]
  000cf	e8 00 00 00 00	 call	 _Py_IncRef

; 2315 :         return res;

  000d4	48 8b 44 24 38	 mov	 rax, QWORD PTR res$21950[rsp]
  000d9	e9 90 02 00 00	 jmp	 $LN27@list_richc
$LN24@list_richc:

; 2316 :     }
; 2317 : 
; 2318 :     /* Search for the first index where items are different */
; 2319 :     for (i = 0; i < Py_SIZE(vl) && i < Py_SIZE(wl); i++) {

  000de	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000e7	eb 0d		 jmp	 SHORT $LN20@list_richc
$LN19@list_richc:
  000e9	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000ee	48 ff c0	 inc	 rax
  000f1	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN20@list_richc:
  000f6	48 8b 44 24 20	 mov	 rax, QWORD PTR vl$[rsp]
  000fb	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ff	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00104	7d 5c		 jge	 SHORT $LN18@list_richc
  00106	48 8b 44 24 30	 mov	 rax, QWORD PTR wl$[rsp]
  0010b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0010f	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00114	7d 4c		 jge	 SHORT $LN18@list_richc

; 2320 :         int k = PyObject_RichCompareBool(vl->ob_item[i],
; 2321 :                                          wl->ob_item[i], Py_EQ);

  00116	48 8b 44 24 30	 mov	 rax, QWORD PTR wl$[rsp]
  0011b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0011f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vl$[rsp]
  00124	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00128	41 b8 02 00 00
	00		 mov	 r8d, 2
  0012e	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00133	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]
  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0013c	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00140	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00145	89 44 24 40	 mov	 DWORD PTR k$21961[rsp], eax

; 2322 :         if (k < 0)

  00149	83 7c 24 40 00	 cmp	 DWORD PTR k$21961[rsp], 0
  0014e	7d 07		 jge	 SHORT $LN17@list_richc

; 2323 :             return NULL;

  00150	33 c0		 xor	 eax, eax
  00152	e9 17 02 00 00	 jmp	 $LN27@list_richc
$LN17@list_richc:

; 2324 :         if (!k)

  00157	83 7c 24 40 00	 cmp	 DWORD PTR k$21961[rsp], 0
  0015c	75 02		 jne	 SHORT $LN16@list_richc

; 2325 :             break;

  0015e	eb 02		 jmp	 SHORT $LN18@list_richc
$LN16@list_richc:

; 2326 :     }

  00160	eb 87		 jmp	 SHORT $LN19@list_richc
$LN18@list_richc:

; 2327 : 
; 2328 :     if (i >= Py_SIZE(vl) || i >= Py_SIZE(wl)) {

  00162	48 8b 44 24 20	 mov	 rax, QWORD PTR vl$[rsp]
  00167	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0016b	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00170	7d 14		 jge	 SHORT $LN14@list_richc
  00172	48 8b 44 24 30	 mov	 rax, QWORD PTR wl$[rsp]
  00177	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0017b	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00180	0f 8c 79 01 00
	00		 jl	 $LN15@list_richc
$LN14@list_richc:

; 2329 :         /* No more items to compare -- compare sizes */
; 2330 :         Py_ssize_t vs = Py_SIZE(vl);

  00186	48 8b 44 24 20	 mov	 rax, QWORD PTR vl$[rsp]
  0018b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0018f	48 89 44 24 50	 mov	 QWORD PTR vs$21969[rsp], rax

; 2331 :         Py_ssize_t ws = Py_SIZE(wl);

  00194	48 8b 44 24 30	 mov	 rax, QWORD PTR wl$[rsp]
  00199	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0019d	48 89 44 24 58	 mov	 QWORD PTR ws$21971[rsp], rax

; 2332 :         int cmp;
; 2333 :         PyObject *res;
; 2334 :         switch (op) {

  001a2	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  001a9	89 44 24 64	 mov	 DWORD PTR tv135[rsp], eax
  001ad	83 7c 24 64 05	 cmp	 DWORD PTR tv135[rsp], 5
  001b2	0f 87 0e 01 00
	00		 ja	 $LN5@list_richc
  001b8	48 63 44 24 64	 movsxd	 rax, DWORD PTR tv135[rsp]
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  001c4	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN41@list_richc[rcx+rax*4]
  001cb	48 03 c1	 add	 rax, rcx
  001ce	ff e0		 jmp	 rax
$LN11@list_richc:

; 2335 :         case Py_LT: cmp = vs <  ws; break;

  001d0	48 8b 44 24 58	 mov	 rax, QWORD PTR ws$21971[rsp]
  001d5	48 39 44 24 50	 cmp	 QWORD PTR vs$21969[rsp], rax
  001da	7d 0a		 jge	 SHORT $LN29@list_richc
  001dc	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  001e4	eb 08		 jmp	 SHORT $LN30@list_richc
$LN29@list_richc:
  001e6	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN30@list_richc:
  001ee	8b 44 24 68	 mov	 eax, DWORD PTR tv137[rsp]
  001f2	89 44 24 60	 mov	 DWORD PTR cmp$21973[rsp], eax
  001f6	e9 d2 00 00 00	 jmp	 $LN12@list_richc
$LN10@list_richc:

; 2336 :         case Py_LE: cmp = vs <= ws; break;

  001fb	48 8b 44 24 58	 mov	 rax, QWORD PTR ws$21971[rsp]
  00200	48 39 44 24 50	 cmp	 QWORD PTR vs$21969[rsp], rax
  00205	7f 0a		 jg	 SHORT $LN31@list_richc
  00207	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv139[rsp], 1
  0020f	eb 08		 jmp	 SHORT $LN32@list_richc
$LN31@list_richc:
  00211	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN32@list_richc:
  00219	8b 44 24 6c	 mov	 eax, DWORD PTR tv139[rsp]
  0021d	89 44 24 60	 mov	 DWORD PTR cmp$21973[rsp], eax
  00221	e9 a7 00 00 00	 jmp	 $LN12@list_richc
$LN9@list_richc:

; 2337 :         case Py_EQ: cmp = vs == ws; break;

  00226	48 8b 44 24 58	 mov	 rax, QWORD PTR ws$21971[rsp]
  0022b	48 39 44 24 50	 cmp	 QWORD PTR vs$21969[rsp], rax
  00230	75 0a		 jne	 SHORT $LN33@list_richc
  00232	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv141[rsp], 1
  0023a	eb 08		 jmp	 SHORT $LN34@list_richc
$LN33@list_richc:
  0023c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
$LN34@list_richc:
  00244	8b 44 24 70	 mov	 eax, DWORD PTR tv141[rsp]
  00248	89 44 24 60	 mov	 DWORD PTR cmp$21973[rsp], eax
  0024c	eb 7f		 jmp	 SHORT $LN12@list_richc
$LN8@list_richc:

; 2338 :         case Py_NE: cmp = vs != ws; break;

  0024e	48 8b 44 24 58	 mov	 rax, QWORD PTR ws$21971[rsp]
  00253	48 39 44 24 50	 cmp	 QWORD PTR vs$21969[rsp], rax
  00258	74 0a		 je	 SHORT $LN35@list_richc
  0025a	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  00262	eb 08		 jmp	 SHORT $LN36@list_richc
$LN35@list_richc:
  00264	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN36@list_richc:
  0026c	8b 44 24 74	 mov	 eax, DWORD PTR tv143[rsp]
  00270	89 44 24 60	 mov	 DWORD PTR cmp$21973[rsp], eax
  00274	eb 57		 jmp	 SHORT $LN12@list_richc
$LN7@list_richc:

; 2339 :         case Py_GT: cmp = vs >  ws; break;

  00276	48 8b 44 24 58	 mov	 rax, QWORD PTR ws$21971[rsp]
  0027b	48 39 44 24 50	 cmp	 QWORD PTR vs$21969[rsp], rax
  00280	7e 0a		 jle	 SHORT $LN37@list_richc
  00282	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  0028a	eb 08		 jmp	 SHORT $LN38@list_richc
$LN37@list_richc:
  0028c	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN38@list_richc:
  00294	8b 44 24 78	 mov	 eax, DWORD PTR tv145[rsp]
  00298	89 44 24 60	 mov	 DWORD PTR cmp$21973[rsp], eax
  0029c	eb 2f		 jmp	 SHORT $LN12@list_richc
$LN6@list_richc:

; 2340 :         case Py_GE: cmp = vs >= ws; break;

  0029e	48 8b 44 24 58	 mov	 rax, QWORD PTR ws$21971[rsp]
  002a3	48 39 44 24 50	 cmp	 QWORD PTR vs$21969[rsp], rax
  002a8	7c 0a		 jl	 SHORT $LN39@list_richc
  002aa	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  002b2	eb 08		 jmp	 SHORT $LN40@list_richc
$LN39@list_richc:
  002b4	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN40@list_richc:
  002bc	8b 44 24 7c	 mov	 eax, DWORD PTR tv147[rsp]
  002c0	89 44 24 60	 mov	 DWORD PTR cmp$21973[rsp], eax
  002c4	eb 07		 jmp	 SHORT $LN12@list_richc
$LN5@list_richc:

; 2341 :         default: return NULL; /* cannot happen */

  002c6	33 c0		 xor	 eax, eax
  002c8	e9 a1 00 00 00	 jmp	 $LN27@list_richc
$LN12@list_richc:

; 2342 :         }
; 2343 :         if (cmp)

  002cd	83 7c 24 60 00	 cmp	 DWORD PTR cmp$21973[rsp], 0
  002d2	74 0e		 je	 SHORT $LN4@list_richc

; 2344 :             res = Py_True;

  002d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  002db	48 89 44 24 48	 mov	 QWORD PTR res$21974[rsp], rax

; 2345 :         else

  002e0	eb 0c		 jmp	 SHORT $LN3@list_richc
$LN4@list_richc:

; 2346 :             res = Py_False;

  002e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  002e9	48 89 44 24 48	 mov	 QWORD PTR res$21974[rsp], rax
$LN3@list_richc:

; 2347 :         Py_INCREF(res);

  002ee	48 8b 4c 24 48	 mov	 rcx, QWORD PTR res$21974[rsp]
  002f3	e8 00 00 00 00	 call	 _Py_IncRef

; 2348 :         return res;

  002f8	48 8b 44 24 48	 mov	 rax, QWORD PTR res$21974[rsp]
  002fd	eb 6f		 jmp	 SHORT $LN27@list_richc
$LN15@list_richc:

; 2349 :     }
; 2350 : 
; 2351 :     /* We have an item that differs -- shortcuts for EQ/NE */
; 2352 :     if (op == Py_EQ) {

  002ff	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  00307	75 15		 jne	 SHORT $LN2@list_richc

; 2353 :         Py_INCREF(Py_False);

  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00310	e8 00 00 00 00	 call	 _Py_IncRef

; 2354 :         return Py_False;

  00315	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0031c	eb 50		 jmp	 SHORT $LN27@list_richc
$LN2@list_richc:

; 2355 :     }
; 2356 :     if (op == Py_NE) {

  0031e	83 bc 24 a0 00
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  00326	75 15		 jne	 SHORT $LN1@list_richc

; 2357 :         Py_INCREF(Py_True);

  00328	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  0032f	e8 00 00 00 00	 call	 _Py_IncRef

; 2358 :         return Py_True;

  00334	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0033b	eb 31		 jmp	 SHORT $LN27@list_richc
$LN1@list_richc:

; 2359 :     }
; 2360 : 
; 2361 :     /* Compare the final item again using the proper operator */
; 2362 :     return PyObject_RichCompare(vl->ob_item[i], wl->ob_item[i], op);

  0033d	48 8b 44 24 30	 mov	 rax, QWORD PTR wl$[rsp]
  00342	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00346	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vl$[rsp]
  0034b	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0034f	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR op$[rsp]
  00357	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0035c	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]
  00360	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00365	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00369	e8 00 00 00 00	 call	 PyObject_RichCompare
$LN27@list_richc:

; 2363 : }

  0036e	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00375	c3		 ret	 0
  00376	66 90		 npad	 2
$LN41@list_richc:
  00378	00 00 00 00	 DD	 $LN11@list_richc
  0037c	00 00 00 00	 DD	 $LN10@list_richc
  00380	00 00 00 00	 DD	 $LN9@list_richc
  00384	00 00 00 00	 DD	 $LN8@list_richc
  00388	00 00 00 00	 DD	 $LN7@list_richc
  0038c	00 00 00 00	 DD	 $LN6@list_richc
list_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_1IO@CJIBAPEB@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAa@ ; `string'
PUBLIC	??_C@_1HE@FNCKCEG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd@ ; `string'
PUBLIC	??_C@_1CG@BJICKDJC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_07HBIIMNCM@?$HMO?3list?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_init DD imagerel list_init
	DD	imagerel list_init+327
	DD	imagerel $unwind$list_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_init DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_1IO@CJIBAPEB@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAa@
CONST	SEGMENT
??_C@_1IO@CJIBAPEB@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAa@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'o', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'm', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'a', 00H, 'l', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'f'
	DB	00H, '-', 00H, '>', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H
	DB	'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '-', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@FNCKCEG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd@
CONST	SEGMENT
??_C@_1HE@FNCKCEG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'(', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'f', 00H, ')', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'l', 00H
	DB	'f', 00H, '-', 00H, '>', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'f'
	DB	00H, '-', 00H, '>', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H
	DB	'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '-', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@BJICKDJC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@BJICKDJC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'y', 00H
	DB	'_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '(', 00H, 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HBIIMNCM@?$HMO?3list?$AA@
CONST	SEGMENT
??_C@_07HBIIMNCM@?$HMO?3list?$AA@ DB '|O:list', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT list_init
_TEXT	SEGMENT
arg$ = 48
rv$22029 = 56
self$ = 80
args$ = 88
kw$ = 96
list_init PROC						; COMDAT

; 2367 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2368 :     PyObject *arg = NULL;

  00013	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR arg$[rsp], 0

; 2369 :     static char *kwlist[] = {"sequence", 0};
; 2370 : 
; 2371 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:list", kwlist, &arg))

  0001c	48 8d 44 24 30	 lea	 rax, QWORD PTR arg$[rsp]
  00021	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00026	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??list_init@@9@9
  0002d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07HBIIMNCM@?$HMO?3list?$AA@
  00034	48 8b 54 24 60	 mov	 rdx, QWORD PTR kw$[rsp]
  00039	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0003e	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00043	85 c0		 test	 eax, eax
  00045	75 0a		 jne	 SHORT $LN4@list_init

; 2372 :         return -1;

  00047	b8 ff ff ff ff	 mov	 eax, -1
  0004c	e9 f1 00 00 00	 jmp	 $LN5@list_init
$LN4@list_init:

; 2373 : 
; 2374 :     /* Verify list invariants established by PyType_GenericAlloc() */
; 2375 :     assert(0 <= Py_SIZE(self));

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00056	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0005b	7d 1c		 jge	 SHORT $LN7@list_init
  0005d	41 b8 47 09 00
	00		 mov	 r8d, 2375		; 00000947H
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BJICKDJC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00077	33 c0		 xor	 eax, eax
$LN7@list_init:

; 2376 :     assert(Py_SIZE(self) <= self->allocated || self->allocated == -1);

  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00083	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00087	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0008b	7e 28		 jle	 SHORT $LN8@list_init
  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00092	48 83 78 78 ff	 cmp	 QWORD PTR [rax+120], -1
  00097	74 1c		 je	 SHORT $LN8@list_init
  00099	41 b8 48 09 00
	00		 mov	 r8d, 2376		; 00000948H
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HE@FNCKCEG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd@
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b3	33 c0		 xor	 eax, eax
$LN8@list_init:

; 2377 :     assert(self->ob_item != NULL ||
; 2378 :            self->allocated == 0 || self->allocated == -1);

  000b5	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ba	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  000bf	75 34		 jne	 SHORT $LN9@list_init
  000c1	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c6	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  000cb	74 28		 je	 SHORT $LN9@list_init
  000cd	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d2	48 83 78 78 ff	 cmp	 QWORD PTR [rax+120], -1
  000d7	74 1c		 je	 SHORT $LN9@list_init
  000d9	41 b8 4a 09 00
	00		 mov	 r8d, 2378		; 0000094aH
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1IO@CJIBAPEB@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAa@
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f3	33 c0		 xor	 eax, eax
$LN9@list_init:

; 2379 : 
; 2380 :     /* Empty previous contents */
; 2381 :     if (self->ob_item != NULL) {

  000f5	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000fa	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  000ff	74 0a		 je	 SHORT $LN3@list_init

; 2382 :         (void)list_clear(self);

  00101	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00106	e8 00 00 00 00	 call	 list_clear
$LN3@list_init:

; 2383 :     }
; 2384 :     if (arg != NULL) {

  0010b	48 83 7c 24 30
	00		 cmp	 QWORD PTR arg$[rsp], 0
  00111	74 2d		 je	 SHORT $LN2@list_init

; 2385 :         PyObject *rv = listextend(self, arg);

  00113	48 8b 54 24 30	 mov	 rdx, QWORD PTR arg$[rsp]
  00118	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0011d	e8 00 00 00 00	 call	 listextend
  00122	48 89 44 24 38	 mov	 QWORD PTR rv$22029[rsp], rax

; 2386 :         if (rv == NULL)

  00127	48 83 7c 24 38
	00		 cmp	 QWORD PTR rv$22029[rsp], 0
  0012d	75 07		 jne	 SHORT $LN1@list_init

; 2387 :             return -1;

  0012f	b8 ff ff ff ff	 mov	 eax, -1
  00134	eb 0c		 jmp	 SHORT $LN5@list_init
$LN1@list_init:

; 2388 :         Py_DECREF(rv);

  00136	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rv$22029[rsp]
  0013b	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@list_init:

; 2389 :     }
; 2390 :     return 0;

  00140	33 c0		 xor	 eax, eax
$LN5@list_init:

; 2391 : }

  00142	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00146	c3		 ret	 0
list_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_sizeof DD imagerel list_sizeof
	DD	imagerel list_sizeof+46
	DD	imagerel $unwind$list_sizeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_sizeof DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_sizeof
_TEXT	SEGMENT
res$ = 32
self$ = 64
list_sizeof PROC					; COMDAT

; 2395 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2396 :     Py_ssize_t res;
; 2397 : 
; 2398 :     res = sizeof(PyListObject) + self->allocated * sizeof(void*);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00012	48 8d 04 c5 80
	00 00 00	 lea	 rax, QWORD PTR [rax*8+128]
  0001a	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 2399 :     return PyLong_FromSsize_t(res);

  0001f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  00024	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 2400 : }

  00029	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002d	c3		 ret	 0
list_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@NOMKDFOD@list?5indices?5must?5be?5integers?0?5n@ ; `string'
EXTRN	PySlice_GetIndicesEx:PROC
EXTRN	PySlice_Type:BYTE
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_subscript DD imagerel list_subscript
	DD	imagerel list_subscript+581
	DD	imagerel $unwind$list_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_subscript DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0CK@NOMKDFOD@list?5indices?5must?5be?5integers?0?5n@
CONST	SEGMENT
??_C@_0CK@NOMKDFOD@list?5indices?5must?5be?5integers?0?5n@ DB 'list indic'
	DB	'es must be integers, not %.200s', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT list_subscript
_TEXT	SEGMENT
i$22113 = 48
it$22128 = 56
i$22126 = 64
cur$22125 = 72
dest$22130 = 80
slicelength$22124 = 88
step$22123 = 96
stop$22122 = 104
start$22121 = 112
result$22127 = 120
src$22129 = 128
self$ = 160
item$ = 168
list_subscript PROC					; COMDAT

; 2476 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2477 :     if (PyIndex_Check(item)) {

  00011	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00019	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001d	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00025	0f 84 8f 00 00
	00		 je	 $LN15@list_subsc
  0002b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00033	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00037	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0003e	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00046	74 72		 je	 SHORT $LN15@list_subsc

; 2478 :         Py_ssize_t i;
; 2479 :         i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  00048	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  0004f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00057	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0005c	48 89 44 24 30	 mov	 QWORD PTR i$22113[rsp], rax

; 2480 :         if (i == -1 && PyErr_Occurred())

  00061	48 83 7c 24 30
	ff		 cmp	 QWORD PTR i$22113[rsp], -1
  00067	75 11		 jne	 SHORT $LN14@list_subsc
  00069	e8 00 00 00 00	 call	 PyErr_Occurred
  0006e	48 85 c0	 test	 rax, rax
  00071	74 07		 je	 SHORT $LN14@list_subsc

; 2481 :             return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	e9 c3 01 00 00	 jmp	 $LN16@list_subsc
$LN14@list_subsc:

; 2482 :         if (i < 0)

  0007a	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$22113[rsp], 0
  00080	7d 1c		 jge	 SHORT $LN13@list_subsc

; 2483 :             i += PyList_GET_SIZE(self);

  00082	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0008a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$22113[rsp]
  00093	48 03 c8	 add	 rcx, rax
  00096	48 8b c1	 mov	 rax, rcx
  00099	48 89 44 24 30	 mov	 QWORD PTR i$22113[rsp], rax
$LN13@list_subsc:

; 2484 :         return list_item(self, i);

  0009e	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$22113[rsp]
  000a3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000ab	e8 00 00 00 00	 call	 list_item
  000b0	e9 88 01 00 00	 jmp	 $LN16@list_subsc
  000b5	e9 83 01 00 00	 jmp	 $LN12@list_subsc
$LN15@list_subsc:

; 2485 :     }
; 2486 :     else if (PySlice_Check(item)) {

  000ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  000c1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  000c9	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000cd	0f 85 45 01 00
	00		 jne	 $LN11@list_subsc

; 2487 :         Py_ssize_t start, stop, step, slicelength, cur, i;
; 2488 :         PyObject* result;
; 2489 :         PyObject* it;
; 2490 :         PyObject **src, **dest;
; 2491 : 
; 2492 :         if (PySlice_GetIndicesEx(item, Py_SIZE(self),
; 2493 :                          &start, &stop, &step, &slicelength) < 0) {

  000d3	48 8d 44 24 58	 lea	 rax, QWORD PTR slicelength$22124[rsp]
  000d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000dd	48 8d 44 24 60	 lea	 rax, QWORD PTR step$22123[rsp]
  000e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e7	4c 8d 4c 24 68	 lea	 r9, QWORD PTR stop$22122[rsp]
  000ec	4c 8d 44 24 70	 lea	 r8, QWORD PTR start$22121[rsp]
  000f1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000f9	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000fd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00105	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  0010a	85 c0		 test	 eax, eax
  0010c	7d 07		 jge	 SHORT $LN10@list_subsc

; 2494 :             return NULL;

  0010e	33 c0		 xor	 eax, eax
  00110	e9 28 01 00 00	 jmp	 $LN16@list_subsc
$LN10@list_subsc:

; 2495 :         }
; 2496 : 
; 2497 :         if (slicelength <= 0) {

  00115	48 83 7c 24 58
	00		 cmp	 QWORD PTR slicelength$22124[rsp], 0
  0011b	7f 11		 jg	 SHORT $LN9@list_subsc

; 2498 :             return PyList_New(0);

  0011d	33 c9		 xor	 ecx, ecx
  0011f	e8 00 00 00 00	 call	 PyList_New
  00124	e9 14 01 00 00	 jmp	 $LN16@list_subsc
  00129	e9 e8 00 00 00	 jmp	 $LN8@list_subsc
$LN9@list_subsc:

; 2499 :         }
; 2500 :         else if (step == 1) {

  0012e	48 83 7c 24 60
	01		 cmp	 QWORD PTR step$22123[rsp], 1
  00134	75 21		 jne	 SHORT $LN7@list_subsc

; 2501 :             return list_slice(self, start, stop);

  00136	4c 8b 44 24 68	 mov	 r8, QWORD PTR stop$22122[rsp]
  0013b	48 8b 54 24 70	 mov	 rdx, QWORD PTR start$22121[rsp]
  00140	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00148	e8 00 00 00 00	 call	 list_slice
  0014d	e9 eb 00 00 00	 jmp	 $LN16@list_subsc

; 2502 :         }
; 2503 :         else {

  00152	e9 bf 00 00 00	 jmp	 $LN6@list_subsc
$LN7@list_subsc:

; 2504 :             result = PyList_New(slicelength);

  00157	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slicelength$22124[rsp]
  0015c	e8 00 00 00 00	 call	 PyList_New
  00161	48 89 44 24 78	 mov	 QWORD PTR result$22127[rsp], rax

; 2505 :             if (!result) return NULL;

  00166	48 83 7c 24 78
	00		 cmp	 QWORD PTR result$22127[rsp], 0
  0016c	75 07		 jne	 SHORT $LN5@list_subsc
  0016e	33 c0		 xor	 eax, eax
  00170	e9 c8 00 00 00	 jmp	 $LN16@list_subsc
$LN5@list_subsc:

; 2506 : 
; 2507 :             src = self->ob_item;

  00175	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0017d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00181	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR src$22129[rsp], rax

; 2508 :             dest = ((PyListObject *)result)->ob_item;

  00189	48 8b 44 24 78	 mov	 rax, QWORD PTR result$22127[rsp]
  0018e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00192	48 89 44 24 50	 mov	 QWORD PTR dest$22130[rsp], rax

; 2509 :             for (cur = start, i = 0; i < slicelength;
; 2510 :                  cur += (size_t)step, i++) {

  00197	48 8b 44 24 70	 mov	 rax, QWORD PTR start$22121[rsp]
  0019c	48 89 44 24 48	 mov	 QWORD PTR cur$22125[rsp], rax
  001a1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$22126[rsp], 0
  001aa	eb 22		 jmp	 SHORT $LN4@list_subsc
$LN3@list_subsc:
  001ac	48 8b 44 24 60	 mov	 rax, QWORD PTR step$22123[rsp]
  001b1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cur$22125[rsp]
  001b6	48 03 c8	 add	 rcx, rax
  001b9	48 8b c1	 mov	 rax, rcx
  001bc	48 89 44 24 48	 mov	 QWORD PTR cur$22125[rsp], rax
  001c1	48 8b 44 24 40	 mov	 rax, QWORD PTR i$22126[rsp]
  001c6	48 ff c0	 inc	 rax
  001c9	48 89 44 24 40	 mov	 QWORD PTR i$22126[rsp], rax
$LN4@list_subsc:
  001ce	48 8b 44 24 58	 mov	 rax, QWORD PTR slicelength$22124[rsp]
  001d3	48 39 44 24 40	 cmp	 QWORD PTR i$22126[rsp], rax
  001d8	7d 35		 jge	 SHORT $LN2@list_subsc

; 2511 :                 it = src[cur];

  001da	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR src$22129[rsp]
  001e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cur$22125[rsp]
  001e7	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  001eb	48 89 44 24 38	 mov	 QWORD PTR it$22128[rsp], rax

; 2512 :                 Py_INCREF(it);

  001f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR it$22128[rsp]
  001f5	e8 00 00 00 00	 call	 _Py_IncRef

; 2513 :                 dest[i] = it;

  001fa	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$22130[rsp]
  001ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$22126[rsp]
  00204	48 8b 54 24 38	 mov	 rdx, QWORD PTR it$22128[rsp]
  00209	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 2514 :             }

  0020d	eb 9d		 jmp	 SHORT $LN3@list_subsc
$LN2@list_subsc:

; 2515 : 
; 2516 :             return result;

  0020f	48 8b 44 24 78	 mov	 rax, QWORD PTR result$22127[rsp]
  00214	eb 27		 jmp	 SHORT $LN16@list_subsc
$LN6@list_subsc:
$LN8@list_subsc:

; 2517 :         }
; 2518 :     }
; 2519 :     else {

  00216	eb 25		 jmp	 SHORT $LN1@list_subsc
$LN11@list_subsc:

; 2520 :         PyErr_Format(PyExc_TypeError,
; 2521 :                      "list indices must be integers, not %.200s",
; 2522 :                      item->ob_type->tp_name);

  00218	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00220	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00224	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00228	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NOMKDFOD@list?5indices?5must?5be?5integers?0?5n@
  0022f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00236	e8 00 00 00 00	 call	 PyErr_Format

; 2523 :         return NULL;

  0023b	33 c0		 xor	 eax, eax
$LN1@list_subsc:
$LN12@list_subsc:
$LN16@list_subsc:

; 2524 :     }
; 2525 : }

  0023d	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00244	c3		 ret	 0
list_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EF@EIODKBFE@attempt?5to?5assign?5sequence?5of?5si@ ; `string'
PUBLIC	??_C@_0CH@ECOCECDB@must?5assign?5iterable?5to?5extended@ ; `string'
PUBLIC	??_C@_1GO@PNDGKGN@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AAs?$AAl?$AAi?$AAc?$AAe?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAM@ ; `string'
PUBLIC	??_C@_0DI@BCOHAMCP@parallel?5thread?5attempted?5to?5ass@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_ass_subscript DD imagerel list_ass_subscript
	DD	imagerel list_ass_subscript+2247
	DD	imagerel $unwind$list_ass_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_ass_subscript DD 021601H
	DD	0210116H
xdata	ENDS
;	COMDAT ??_C@_0EF@EIODKBFE@attempt?5to?5assign?5sequence?5of?5si@
CONST	SEGMENT
??_C@_0EF@EIODKBFE@attempt?5to?5assign?5sequence?5of?5si@ DB 'attempt to '
	DB	'assign sequence of size %zd to extended slice of size %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@ECOCECDB@must?5assign?5iterable?5to?5extended@
CONST	SEGMENT
??_C@_0CH@ECOCECDB@must?5assign?5iterable?5to?5extended@ DB 'must assign '
	DB	'iterable to extended slice', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GO@PNDGKGN@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AAs?$AAl?$AAi?$AAc?$AAe?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAM@
CONST	SEGMENT
??_C@_1GO@PNDGKGN@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AAs?$AAl?$AAi?$AAc?$AAe?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAM@ DB '('
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	')', 00H, 's', 00H, 'l', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'l'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'Y', 00H, '_', 00H, 'S'
	DB	00H, 'I', 00H, 'Z', 00H, 'E', 00H, '_', 00H, 'M', 00H, 'A', 00H
	DB	'X', 00H, ' ', 00H, '/', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H, 'P', 00H, 'y', 00H
	DB	'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, '*'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@BCOHAMCP@parallel?5thread?5attempted?5to?5ass@
CONST	SEGMENT
??_C@_0DI@BCOHAMCP@parallel?5thread?5attempted?5to?5ass@ DB 'parallel thr'
	DB	'ead attempted to assign to main thread list', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT list_ass_subscript
_TEXT	SEGMENT
i$22163 = 48
slicelength$22173 = 56
step$22172 = 64
stop$22171 = 72
start$22170 = 80
garbage$22182 = 88
i$22184 = 96
cur$22183 = 104
lim$22201 = 112
garbage$22223 = 120
i$22227 = 128
cur$22226 = 136
seqitems$22224 = 144
seq$22222 = 152
ins$22221 = 160
selfitems$22225 = 168
tv166 = 176
tv195 = 184
tv213 = 192
tv229 = 200
tv246 = 208
tv256 = 216
tv270 = 224
tv280 = 232
tv302 = 240
self$ = 272
item$ = 280
value$ = 288
list_ass_subscript PROC					; COMDAT

; 2529 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 2530 : #ifdef WITH_PARALLEL
; 2531 :     if (Py_PXCTX && Px_ISPY(self)) {

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	74 32		 je	 SHORT $LN37@list_ass_s@2
  0001f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0002b	48 83 e0 01	 and	 rax, 1
  0002f	48 85 c0	 test	 rax, rax
  00032	74 1d		 je	 SHORT $LN37@list_ass_s@2

; 2532 :         PyErr_SetString(PyExc_AssignmentError,
; 2533 :                         "parallel thread attempted to "
; 2534 :                         "assign to main thread list");

  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@BCOHAMCP@parallel?5thread?5attempted?5to?5ass@
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AssignmentError
  00042	e8 00 00 00 00	 call	 PyErr_SetString

; 2535 :         return -1;

  00047	b8 ff ff ff ff	 mov	 eax, -1
  0004c	e9 6e 08 00 00	 jmp	 $LN38@list_ass_s@2
$LN37@list_ass_s@2:

; 2536 :     }
; 2537 : #endif
; 2538 : 
; 2539 :     if (PyIndex_Check(item)) {

  00051	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00059	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005d	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00065	0f 84 9a 00 00
	00		 je	 $LN36@list_ass_s@2
  0006b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00073	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00077	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0007e	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00086	74 7d		 je	 SHORT $LN36@list_ass_s@2

; 2540 :         Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  00088	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  0008f	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00097	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0009c	48 89 44 24 30	 mov	 QWORD PTR i$22163[rsp], rax

; 2541 :         if (i == -1 && PyErr_Occurred())

  000a1	48 83 7c 24 30
	ff		 cmp	 QWORD PTR i$22163[rsp], -1
  000a7	75 14		 jne	 SHORT $LN35@list_ass_s@2
  000a9	e8 00 00 00 00	 call	 PyErr_Occurred
  000ae	48 85 c0	 test	 rax, rax
  000b1	74 0a		 je	 SHORT $LN35@list_ass_s@2

; 2542 :             return -1;

  000b3	b8 ff ff ff ff	 mov	 eax, -1
  000b8	e9 02 08 00 00	 jmp	 $LN38@list_ass_s@2
$LN35@list_ass_s@2:

; 2543 :         if (i < 0)

  000bd	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$22163[rsp], 0
  000c3	7d 1c		 jge	 SHORT $LN34@list_ass_s@2

; 2544 :             i += PyList_GET_SIZE(self);

  000c5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000cd	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$22163[rsp]
  000d6	48 03 c8	 add	 rcx, rax
  000d9	48 8b c1	 mov	 rax, rcx
  000dc	48 89 44 24 30	 mov	 QWORD PTR i$22163[rsp], rax
$LN34@list_ass_s@2:

; 2545 :         return list_ass_item(self, i, value);

  000e1	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR value$[rsp]
  000e9	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$22163[rsp]
  000ee	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000f6	e8 00 00 00 00	 call	 list_ass_item
  000fb	e9 bf 07 00 00	 jmp	 $LN38@list_ass_s@2
  00100	e9 ba 07 00 00	 jmp	 $LN33@list_ass_s@2
$LN36@list_ass_s@2:

; 2546 :     }
; 2547 :     else if (PySlice_Check(item)) {

  00105	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  0010c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00114	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00118	0f 85 79 07 00
	00		 jne	 $LN32@list_ass_s@2

; 2548 :         Py_ssize_t start, stop, step, slicelength;
; 2549 : 
; 2550 :         if (PySlice_GetIndicesEx(item, Py_SIZE(self),
; 2551 :                          &start, &stop, &step, &slicelength) < 0) {

  0011e	48 8d 44 24 38	 lea	 rax, QWORD PTR slicelength$22173[rsp]
  00123	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00128	48 8d 44 24 40	 lea	 rax, QWORD PTR step$22172[rsp]
  0012d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00132	4c 8d 4c 24 48	 lea	 r9, QWORD PTR stop$22171[rsp]
  00137	4c 8d 44 24 50	 lea	 r8, QWORD PTR start$22170[rsp]
  0013c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00144	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00148	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00150	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  00155	85 c0		 test	 eax, eax
  00157	7d 0a		 jge	 SHORT $LN31@list_ass_s@2

; 2552 :             return -1;

  00159	b8 ff ff ff ff	 mov	 eax, -1
  0015e	e9 5c 07 00 00	 jmp	 $LN38@list_ass_s@2
$LN31@list_ass_s@2:

; 2553 :         }
; 2554 : 
; 2555 :         if (step == 1)

  00163	48 83 7c 24 40
	01		 cmp	 QWORD PTR step$22172[rsp], 1
  00169	75 24		 jne	 SHORT $LN30@list_ass_s@2

; 2556 :             return list_ass_slice(self, start, stop, value);

  0016b	4c 8b 8c 24 20
	01 00 00	 mov	 r9, QWORD PTR value$[rsp]
  00173	4c 8b 44 24 48	 mov	 r8, QWORD PTR stop$22171[rsp]
  00178	48 8b 54 24 50	 mov	 rdx, QWORD PTR start$22170[rsp]
  0017d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00185	e8 00 00 00 00	 call	 list_ass_slice
  0018a	e9 30 07 00 00	 jmp	 $LN38@list_ass_s@2
$LN30@list_ass_s@2:

; 2557 : 
; 2558 :         /* Make sure s[5:2] = [..] inserts at the right place:
; 2559 :            before 5, not before 2. */
; 2560 :         if ((step < 0 && start < stop) ||
; 2561 :             (step > 0 && start > stop))

  0018f	48 83 7c 24 40
	00		 cmp	 QWORD PTR step$22172[rsp], 0
  00195	7d 0c		 jge	 SHORT $LN27@list_ass_s@2
  00197	48 8b 44 24 48	 mov	 rax, QWORD PTR stop$22171[rsp]
  0019c	48 39 44 24 50	 cmp	 QWORD PTR start$22170[rsp], rax
  001a1	7c 14		 jl	 SHORT $LN28@list_ass_s@2
$LN27@list_ass_s@2:
  001a3	48 83 7c 24 40
	00		 cmp	 QWORD PTR step$22172[rsp], 0
  001a9	7e 16		 jle	 SHORT $LN29@list_ass_s@2
  001ab	48 8b 44 24 48	 mov	 rax, QWORD PTR stop$22171[rsp]
  001b0	48 39 44 24 50	 cmp	 QWORD PTR start$22170[rsp], rax
  001b5	7e 0a		 jle	 SHORT $LN29@list_ass_s@2
$LN28@list_ass_s@2:

; 2562 :             stop = start;

  001b7	48 8b 44 24 50	 mov	 rax, QWORD PTR start$22170[rsp]
  001bc	48 89 44 24 48	 mov	 QWORD PTR stop$22171[rsp], rax
$LN29@list_ass_s@2:

; 2563 : 
; 2564 :         if (value == NULL) {

  001c1	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR value$[rsp], 0
  001ca	0f 85 45 03 00
	00		 jne	 $LN26@list_ass_s@2

; 2565 :             /* delete slice */
; 2566 :             PyObject **garbage;
; 2567 :             size_t cur;
; 2568 :             Py_ssize_t i;
; 2569 : 
; 2570 :             if (slicelength <= 0)

  001d0	48 83 7c 24 38
	00		 cmp	 QWORD PTR slicelength$22173[rsp], 0
  001d6	7f 07		 jg	 SHORT $LN25@list_ass_s@2

; 2571 :                 return 0;

  001d8	33 c0		 xor	 eax, eax
  001da	e9 e0 06 00 00	 jmp	 $LN38@list_ass_s@2
$LN25@list_ass_s@2:

; 2572 : 
; 2573 :             if (step < 0) {

  001df	48 83 7c 24 40
	00		 cmp	 QWORD PTR step$22172[rsp], 0
  001e5	7d 3d		 jge	 SHORT $LN24@list_ass_s@2

; 2574 :                 stop = start + 1;

  001e7	48 8b 44 24 50	 mov	 rax, QWORD PTR start$22170[rsp]
  001ec	48 ff c0	 inc	 rax
  001ef	48 89 44 24 48	 mov	 QWORD PTR stop$22171[rsp], rax

; 2575 :                 start = stop + step*(slicelength - 1) - 1;

  001f4	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$22173[rsp]
  001f9	48 ff c8	 dec	 rax
  001fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR step$22172[rsp]
  00201	48 0f af c8	 imul	 rcx, rax
  00205	48 8b c1	 mov	 rax, rcx
  00208	48 8b 4c 24 48	 mov	 rcx, QWORD PTR stop$22171[rsp]
  0020d	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  00212	48 89 44 24 50	 mov	 QWORD PTR start$22170[rsp], rax

; 2576 :                 step = -step;

  00217	48 8b 44 24 40	 mov	 rax, QWORD PTR step$22172[rsp]
  0021c	48 f7 d8	 neg	 rax
  0021f	48 89 44 24 40	 mov	 QWORD PTR step$22172[rsp], rax
$LN24@list_ass_s@2:

; 2577 :             }
; 2578 : 
; 2579 :             assert((size_t)slicelength <=
; 2580 :                    PY_SIZE_MAX / sizeof(PyObject*));

  00224	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  0022e	48 39 44 24 38	 cmp	 QWORD PTR slicelength$22173[rsp], rax
  00233	76 1c		 jbe	 SHORT $LN40@list_ass_s@2
  00235	41 b8 14 0a 00
	00		 mov	 r8d, 2580		; 00000a14H
  0023b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GO@PNDGKGN@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AAs?$AAl?$AAi?$AAc?$AAe?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAM@
  00249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0024f	33 c0		 xor	 eax, eax
$LN40@list_ass_s@2:

; 2581 : 
; 2582 :             garbage = (PyObject**)
; 2583 :                 PyMem_MALLOC(slicelength*sizeof(PyObject*));

  00251	e8 00 00 00 00	 call	 _Py_PXCTX
  00256	85 c0		 test	 eax, eax
  00258	74 1b		 je	 SHORT $LN41@list_ass_s@2
  0025a	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$22173[rsp]
  0025f	48 c1 e0 03	 shl	 rax, 3
  00263	48 8b c8	 mov	 rcx, rax
  00266	e8 00 00 00 00	 call	 _PxMem_Malloc
  0026b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  00273	eb 19		 jmp	 SHORT $LN42@list_ass_s@2
$LN41@list_ass_s@2:
  00275	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$22173[rsp]
  0027a	48 c1 e0 03	 shl	 rax, 3
  0027e	48 8b c8	 mov	 rcx, rax
  00281	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00286	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
$LN42@list_ass_s@2:
  0028e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv166[rsp]
  00296	48 89 44 24 58	 mov	 QWORD PTR garbage$22182[rsp], rax

; 2584 :             if (!garbage) {

  0029b	48 83 7c 24 58
	00		 cmp	 QWORD PTR garbage$22182[rsp], 0
  002a1	75 0f		 jne	 SHORT $LN23@list_ass_s@2

; 2585 :                 PyErr_NoMemory();

  002a3	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2586 :                 return -1;

  002a8	b8 ff ff ff ff	 mov	 eax, -1
  002ad	e9 0d 06 00 00	 jmp	 $LN38@list_ass_s@2
$LN23@list_ass_s@2:

; 2587 :             }
; 2588 : 
; 2589 :             /* drawing pictures might help understand these for
; 2590 :                loops. Basically, we memmove the parts of the
; 2591 :                list that are *not* part of the slice: step-1
; 2592 :                items for each item that is part of the slice,
; 2593 :                and then tail end of the list that was not
; 2594 :                covered by the slice */
; 2595 :             for (cur = start, i = 0;
; 2596 :                  cur < (size_t)stop;
; 2597 :                  cur += step, i++) {

  002b2	48 8b 44 24 50	 mov	 rax, QWORD PTR start$22170[rsp]
  002b7	48 89 44 24 68	 mov	 QWORD PTR cur$22183[rsp], rax
  002bc	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR i$22184[rsp], 0
  002c5	eb 22		 jmp	 SHORT $LN22@list_ass_s@2
$LN21@list_ass_s@2:
  002c7	48 8b 44 24 40	 mov	 rax, QWORD PTR step$22172[rsp]
  002cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cur$22183[rsp]
  002d1	48 03 c8	 add	 rcx, rax
  002d4	48 8b c1	 mov	 rax, rcx
  002d7	48 89 44 24 68	 mov	 QWORD PTR cur$22183[rsp], rax
  002dc	48 8b 44 24 60	 mov	 rax, QWORD PTR i$22184[rsp]
  002e1	48 ff c0	 inc	 rax
  002e4	48 89 44 24 60	 mov	 QWORD PTR i$22184[rsp], rax
$LN22@list_ass_s@2:
  002e9	48 8b 44 24 48	 mov	 rax, QWORD PTR stop$22171[rsp]
  002ee	48 39 44 24 68	 cmp	 QWORD PTR cur$22183[rsp], rax
  002f3	0f 83 ce 00 00
	00		 jae	 $LN20@list_ass_s@2

; 2598 :                 Py_ssize_t lim = step - 1;

  002f9	48 8b 44 24 40	 mov	 rax, QWORD PTR step$22172[rsp]
  002fe	48 ff c8	 dec	 rax
  00301	48 89 44 24 70	 mov	 QWORD PTR lim$22201[rsp], rax

; 2599 : 
; 2600 :                 garbage[i] = PyList_GET_ITEM(self, cur);

  00306	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0030e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00312	48 8b 4c 24 58	 mov	 rcx, QWORD PTR garbage$22182[rsp]
  00317	48 8b 54 24 60	 mov	 rdx, QWORD PTR i$22184[rsp]
  0031c	4c 8b 44 24 68	 mov	 r8, QWORD PTR cur$22183[rsp]
  00321	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  00325	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 2601 : 
; 2602 :                 if (cur + step >= (size_t)Py_SIZE(self)) {

  00329	48 8b 44 24 40	 mov	 rax, QWORD PTR step$22172[rsp]
  0032e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cur$22183[rsp]
  00333	48 03 c8	 add	 rcx, rax
  00336	48 8b c1	 mov	 rax, rcx
  00339	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00341	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  00345	72 1c		 jb	 SHORT $LN19@list_ass_s@2

; 2603 :                     lim = Py_SIZE(self) - cur - 1;

  00347	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0034f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cur$22183[rsp]
  00354	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00358	48 2b c1	 sub	 rax, rcx
  0035b	48 ff c8	 dec	 rax
  0035e	48 89 44 24 70	 mov	 QWORD PTR lim$22201[rsp], rax
$LN19@list_ass_s@2:

; 2604 :                 }
; 2605 : 
; 2606 :                 memmove(self->ob_item + cur - i,
; 2607 :                     self->ob_item + cur + 1,
; 2608 :                     lim * sizeof(PyObject *));

  00363	48 8b 44 24 70	 mov	 rax, QWORD PTR lim$22201[rsp]
  00368	48 c1 e0 03	 shl	 rax, 3
  0036c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00374	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00378	48 8b 54 24 68	 mov	 rdx, QWORD PTR cur$22183[rsp]
  0037d	48 8d 4c d1 08	 lea	 rcx, QWORD PTR [rcx+rdx*8+8]
  00382	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  0038a	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0038e	4c 8b 44 24 68	 mov	 r8, QWORD PTR cur$22183[rsp]
  00393	4a 8d 14 c2	 lea	 rdx, QWORD PTR [rdx+r8*8]
  00397	4c 8b 44 24 60	 mov	 r8, QWORD PTR i$22184[rsp]
  0039c	49 c1 e0 03	 shl	 r8, 3
  003a0	49 2b d0	 sub	 rdx, r8
  003a3	48 89 94 24 b8
	00 00 00	 mov	 QWORD PTR tv195[rsp], rdx
  003ab	4c 8b c0	 mov	 r8, rax
  003ae	48 8b d1	 mov	 rdx, rcx
  003b1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv195[rsp]
  003b9	48 8b c8	 mov	 rcx, rax
  003bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2609 :             }

  003c2	e9 00 ff ff ff	 jmp	 $LN21@list_ass_s@2
$LN20@list_ass_s@2:

; 2610 :             cur = start + (size_t)slicelength * step;

  003c7	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$22173[rsp]
  003cc	48 0f af 44 24
	40		 imul	 rax, QWORD PTR step$22172[rsp]
  003d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR start$22170[rsp]
  003d7	48 03 c8	 add	 rcx, rax
  003da	48 8b c1	 mov	 rax, rcx
  003dd	48 89 44 24 68	 mov	 QWORD PTR cur$22183[rsp], rax

; 2611 :             if (cur < (size_t)Py_SIZE(self)) {

  003e2	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003ea	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  003ee	48 39 44 24 68	 cmp	 QWORD PTR cur$22183[rsp], rax
  003f3	73 6d		 jae	 SHORT $LN18@list_ass_s@2

; 2612 :                 memmove(self->ob_item + cur - slicelength,
; 2613 :                     self->ob_item + cur,
; 2614 :                     (Py_SIZE(self) - cur) *
; 2615 :                      sizeof(PyObject *));

  003f5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cur$22183[rsp]
  00402	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00406	48 2b c1	 sub	 rax, rcx
  00409	48 c1 e0 03	 shl	 rax, 3
  0040d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00415	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00419	48 8b 54 24 68	 mov	 rdx, QWORD PTR cur$22183[rsp]
  0041e	48 8d 0c d1	 lea	 rcx, QWORD PTR [rcx+rdx*8]
  00422	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  0042a	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0042e	4c 8b 44 24 68	 mov	 r8, QWORD PTR cur$22183[rsp]
  00433	4a 8d 14 c2	 lea	 rdx, QWORD PTR [rdx+r8*8]
  00437	4c 8b 44 24 38	 mov	 r8, QWORD PTR slicelength$22173[rsp]
  0043c	49 c1 e0 03	 shl	 r8, 3
  00440	49 2b d0	 sub	 rdx, r8
  00443	48 89 94 24 c0
	00 00 00	 mov	 QWORD PTR tv213[rsp], rdx
  0044b	4c 8b c0	 mov	 r8, rax
  0044e	48 8b d1	 mov	 rdx, rcx
  00451	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv213[rsp]
  00459	48 8b c8	 mov	 rcx, rax
  0045c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN18@list_ass_s@2:

; 2616 :             }
; 2617 : 
; 2618 :             Py_SIZE(self) -= slicelength;

  00462	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0046a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR slicelength$22173[rsp]
  0046f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00473	48 2b c1	 sub	 rax, rcx
  00476	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0047e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 2619 :             list_resize(self, Py_SIZE(self));

  00482	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0048a	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0048e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00496	e8 00 00 00 00	 call	 list_resize

; 2620 : 
; 2621 :             for (i = 0; i < slicelength; i++) {

  0049b	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR i$22184[rsp], 0
  004a4	eb 0d		 jmp	 SHORT $LN17@list_ass_s@2
$LN16@list_ass_s@2:
  004a6	48 8b 44 24 60	 mov	 rax, QWORD PTR i$22184[rsp]
  004ab	48 ff c0	 inc	 rax
  004ae	48 89 44 24 60	 mov	 QWORD PTR i$22184[rsp], rax
$LN17@list_ass_s@2:
  004b3	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$22173[rsp]
  004b8	48 39 44 24 60	 cmp	 QWORD PTR i$22184[rsp], rax
  004bd	7d 15		 jge	 SHORT $LN15@list_ass_s@2

; 2622 :                 Py_DECREF(garbage[i]);

  004bf	48 8b 44 24 58	 mov	 rax, QWORD PTR garbage$22182[rsp]
  004c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR i$22184[rsp]
  004c9	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  004cd	e8 00 00 00 00	 call	 _Py_DecRef

; 2623 :             }

  004d2	eb d2		 jmp	 SHORT $LN16@list_ass_s@2
$LN15@list_ass_s@2:

; 2624 :             PyMem_FREE(garbage);

  004d4	e8 00 00 00 00	 call	 _Py_PXCTX
  004d9	85 c0		 test	 eax, eax
  004db	74 17		 je	 SHORT $LN43@list_ass_s@2
  004dd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR garbage$22182[rsp]
  004e2	e8 00 00 00 00	 call	 _PxMem_Free
  004e7	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv229[rsp], 0
  004f2	eb 15		 jmp	 SHORT $LN44@list_ass_s@2
$LN43@list_ass_s@2:
  004f4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR garbage$22182[rsp]
  004f9	e8 00 00 00 00	 call	 _PyMem_DebugFree
  004fe	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv229[rsp], 0
$LN44@list_ass_s@2:

; 2625 : 
; 2626 :             return 0;

  00509	33 c0		 xor	 eax, eax
  0050b	e9 af 03 00 00	 jmp	 $LN38@list_ass_s@2

; 2627 :         }
; 2628 :         else {

  00510	e9 80 03 00 00	 jmp	 $LN14@list_ass_s@2
$LN26@list_ass_s@2:

; 2629 :             /* assign slice */
; 2630 :             PyObject *ins, *seq;
; 2631 :             PyObject **garbage, **seqitems, **selfitems;
; 2632 :             Py_ssize_t cur, i;
; 2633 : 
; 2634 :             /* protect against a[::-1] = a */
; 2635 :             if (self == (PyListObject*)value) {

  00515	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR value$[rsp]
  0051d	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR self$[rsp], rax
  00525	75 25		 jne	 SHORT $LN13@list_ass_s@2

; 2636 :                 seq = list_slice((PyListObject*)value, 0,
; 2637 :                                    PyList_GET_SIZE(value));

  00527	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR value$[rsp]
  0052f	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00533	33 d2		 xor	 edx, edx
  00535	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  0053d	e8 00 00 00 00	 call	 list_slice
  00542	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR seq$22222[rsp], rax

; 2638 :             }
; 2639 :             else {

  0054a	eb 1c		 jmp	 SHORT $LN12@list_ass_s@2
$LN13@list_ass_s@2:

; 2640 :                 seq = PySequence_Fast(value,
; 2641 :                                       "must assign iterable "
; 2642 :                                       "to extended slice");

  0054c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@ECOCECDB@must?5assign?5iterable?5to?5extended@
  00553	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  0055b	e8 00 00 00 00	 call	 PySequence_Fast
  00560	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR seq$22222[rsp], rax
$LN12@list_ass_s@2:

; 2643 :             }
; 2644 :             if (!seq)

  00568	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR seq$22222[rsp], 0
  00571	75 0a		 jne	 SHORT $LN11@list_ass_s@2

; 2645 :                 return -1;

  00573	b8 ff ff ff ff	 mov	 eax, -1
  00578	e9 42 03 00 00	 jmp	 $LN38@list_ass_s@2
$LN11@list_ass_s@2:

; 2646 : 
; 2647 :             if (PySequence_Fast_GET_SIZE(seq) != slicelength) {

  0057d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR seq$22222[rsp]
  00585	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00589	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0058f	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00594	85 c0		 test	 eax, eax
  00596	74 16		 je	 SHORT $LN45@list_ass_s@2
  00598	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR seq$22222[rsp]
  005a0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  005a4	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv246[rsp], rax
  005ac	eb 14		 jmp	 SHORT $LN46@list_ass_s@2
$LN45@list_ass_s@2:
  005ae	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR seq$22222[rsp]
  005b6	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  005ba	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv246[rsp], rax
$LN46@list_ass_s@2:
  005c2	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$22173[rsp]
  005c7	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR tv246[rsp], rax
  005cf	74 7c		 je	 SHORT $LN10@list_ass_s@2

; 2648 :                 PyErr_Format(PyExc_ValueError,
; 2649 :                     "attempt to assign sequence of "
; 2650 :                     "size %zd to extended slice of "
; 2651 :                     "size %zd",
; 2652 :                          PySequence_Fast_GET_SIZE(seq),
; 2653 :                          slicelength);

  005d1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR seq$22222[rsp]
  005d9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005dd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005e3	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  005e8	85 c0		 test	 eax, eax
  005ea	74 16		 je	 SHORT $LN47@list_ass_s@2
  005ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR seq$22222[rsp]
  005f4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  005f8	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv256[rsp], rax
  00600	eb 14		 jmp	 SHORT $LN48@list_ass_s@2
$LN47@list_ass_s@2:
  00602	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR seq$22222[rsp]
  0060a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0060e	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv256[rsp], rax
$LN48@list_ass_s@2:
  00616	4c 8b 4c 24 38	 mov	 r9, QWORD PTR slicelength$22173[rsp]
  0061b	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR tv256[rsp]
  00623	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@EIODKBFE@attempt?5to?5assign?5sequence?5of?5si@
  0062a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00631	e8 00 00 00 00	 call	 PyErr_Format

; 2654 :                 Py_DECREF(seq);

  00636	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR seq$22222[rsp]
  0063e	e8 00 00 00 00	 call	 _Py_DecRef

; 2655 :                 return -1;

  00643	b8 ff ff ff ff	 mov	 eax, -1
  00648	e9 72 02 00 00	 jmp	 $LN38@list_ass_s@2
$LN10@list_ass_s@2:

; 2656 :             }
; 2657 : 
; 2658 :             if (!slicelength) {

  0064d	48 83 7c 24 38
	00		 cmp	 QWORD PTR slicelength$22173[rsp], 0
  00653	75 14		 jne	 SHORT $LN9@list_ass_s@2

; 2659 :                 Py_DECREF(seq);

  00655	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR seq$22222[rsp]
  0065d	e8 00 00 00 00	 call	 _Py_DecRef

; 2660 :                 return 0;

  00662	33 c0		 xor	 eax, eax
  00664	e9 56 02 00 00	 jmp	 $LN38@list_ass_s@2
$LN9@list_ass_s@2:

; 2661 :             }
; 2662 : 
; 2663 :             garbage = (PyObject**)
; 2664 :                 PyMem_MALLOC(slicelength*sizeof(PyObject*));

  00669	e8 00 00 00 00	 call	 _Py_PXCTX
  0066e	85 c0		 test	 eax, eax
  00670	74 1b		 je	 SHORT $LN49@list_ass_s@2
  00672	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$22173[rsp]
  00677	48 c1 e0 03	 shl	 rax, 3
  0067b	48 8b c8	 mov	 rcx, rax
  0067e	e8 00 00 00 00	 call	 _PxMem_Malloc
  00683	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv270[rsp], rax
  0068b	eb 19		 jmp	 SHORT $LN50@list_ass_s@2
$LN49@list_ass_s@2:
  0068d	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$22173[rsp]
  00692	48 c1 e0 03	 shl	 rax, 3
  00696	48 8b c8	 mov	 rcx, rax
  00699	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0069e	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv270[rsp], rax
$LN50@list_ass_s@2:
  006a6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv270[rsp]
  006ae	48 89 44 24 78	 mov	 QWORD PTR garbage$22223[rsp], rax

; 2665 :             if (!garbage) {

  006b3	48 83 7c 24 78
	00		 cmp	 QWORD PTR garbage$22223[rsp], 0
  006b9	75 1c		 jne	 SHORT $LN8@list_ass_s@2

; 2666 :                 Py_DECREF(seq);

  006bb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR seq$22222[rsp]
  006c3	e8 00 00 00 00	 call	 _Py_DecRef

; 2667 :                 PyErr_NoMemory();

  006c8	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2668 :                 return -1;

  006cd	b8 ff ff ff ff	 mov	 eax, -1
  006d2	e9 e8 01 00 00	 jmp	 $LN38@list_ass_s@2
$LN8@list_ass_s@2:

; 2669 :             }
; 2670 : 
; 2671 :             selfitems = self->ob_item;

  006d7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  006df	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  006e3	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR selfitems$22225[rsp], rax

; 2672 :             seqitems = PySequence_Fast_ITEMS(seq);

  006eb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR seq$22222[rsp]
  006f3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  006f7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  006fd	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00702	85 c0		 test	 eax, eax
  00704	74 16		 je	 SHORT $LN51@list_ass_s@2
  00706	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR seq$22222[rsp]
  0070e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00712	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
  0071a	eb 14		 jmp	 SHORT $LN52@list_ass_s@2
$LN51@list_ass_s@2:
  0071c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR seq$22222[rsp]
  00724	48 83 c0 70	 add	 rax, 112		; 00000070H
  00728	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
$LN52@list_ass_s@2:
  00730	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv280[rsp]
  00738	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR seqitems$22224[rsp], rax

; 2673 :             for (cur = start, i = 0; i < slicelength;
; 2674 :                  cur += (size_t)step, i++) {

  00740	48 8b 44 24 50	 mov	 rax, QWORD PTR start$22170[rsp]
  00745	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR cur$22226[rsp], rax
  0074d	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$22227[rsp], 0
  00759	eb 2e		 jmp	 SHORT $LN7@list_ass_s@2
$LN6@list_ass_s@2:
  0075b	48 8b 44 24 40	 mov	 rax, QWORD PTR step$22172[rsp]
  00760	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cur$22226[rsp]
  00768	48 03 c8	 add	 rcx, rax
  0076b	48 8b c1	 mov	 rax, rcx
  0076e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR cur$22226[rsp], rax
  00776	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR i$22227[rsp]
  0077e	48 ff c0	 inc	 rax
  00781	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR i$22227[rsp], rax
$LN7@list_ass_s@2:
  00789	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$22173[rsp]
  0078e	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR i$22227[rsp], rax
  00796	7d 6f		 jge	 SHORT $LN5@list_ass_s@2

; 2675 :                 garbage[i] = selfitems[cur];

  00798	48 8b 44 24 78	 mov	 rax, QWORD PTR garbage$22223[rsp]
  0079d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR i$22227[rsp]
  007a5	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR selfitems$22225[rsp]
  007ad	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR cur$22226[rsp]
  007b5	4a 8b 14 c2	 mov	 rdx, QWORD PTR [rdx+r8*8]
  007b9	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 2676 :                 ins = seqitems[i];

  007bd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR seqitems$22224[rsp]
  007c5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR i$22227[rsp]
  007cd	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  007d1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ins$22221[rsp], rax

; 2677 :                 Py_INCREF(ins);

  007d9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR ins$22221[rsp]
  007e1	e8 00 00 00 00	 call	 _Py_IncRef

; 2678 :                 selfitems[cur] = ins;

  007e6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR selfitems$22225[rsp]
  007ee	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cur$22226[rsp]
  007f6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR ins$22221[rsp]
  007fe	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 2679 :             }

  00802	e9 54 ff ff ff	 jmp	 $LN6@list_ass_s@2
$LN5@list_ass_s@2:

; 2680 : 
; 2681 :             for (i = 0; i < slicelength; i++) {

  00807	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$22227[rsp], 0
  00813	eb 13		 jmp	 SHORT $LN4@list_ass_s@2
$LN3@list_ass_s@2:
  00815	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR i$22227[rsp]
  0081d	48 ff c0	 inc	 rax
  00820	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR i$22227[rsp], rax
$LN4@list_ass_s@2:
  00828	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$22173[rsp]
  0082d	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR i$22227[rsp], rax
  00835	7d 18		 jge	 SHORT $LN2@list_ass_s@2

; 2682 :                 Py_DECREF(garbage[i]);

  00837	48 8b 44 24 78	 mov	 rax, QWORD PTR garbage$22223[rsp]
  0083c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR i$22227[rsp]
  00844	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00848	e8 00 00 00 00	 call	 _Py_DecRef

; 2683 :             }

  0084d	eb c6		 jmp	 SHORT $LN3@list_ass_s@2
$LN2@list_ass_s@2:

; 2684 : 
; 2685 :             PyMem_FREE(garbage);

  0084f	e8 00 00 00 00	 call	 _Py_PXCTX
  00854	85 c0		 test	 eax, eax
  00856	74 17		 je	 SHORT $LN53@list_ass_s@2
  00858	48 8b 4c 24 78	 mov	 rcx, QWORD PTR garbage$22223[rsp]
  0085d	e8 00 00 00 00	 call	 _PxMem_Free
  00862	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv302[rsp], 0
  0086d	eb 15		 jmp	 SHORT $LN54@list_ass_s@2
$LN53@list_ass_s@2:
  0086f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR garbage$22223[rsp]
  00874	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00879	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv302[rsp], 0
$LN54@list_ass_s@2:

; 2686 :             Py_DECREF(seq);

  00884	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR seq$22222[rsp]
  0088c	e8 00 00 00 00	 call	 _Py_DecRef

; 2687 : 
; 2688 :             return 0;

  00891	33 c0		 xor	 eax, eax
  00893	eb 2a		 jmp	 SHORT $LN38@list_ass_s@2
$LN14@list_ass_s@2:

; 2689 :         }
; 2690 :     }
; 2691 :     else {

  00895	eb 28		 jmp	 SHORT $LN1@list_ass_s@2
$LN32@list_ass_s@2:

; 2692 :         PyErr_Format(PyExc_TypeError,
; 2693 :                      "list indices must be integers, not %.200s",
; 2694 :                      item->ob_type->tp_name);

  00897	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR item$[rsp]
  0089f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  008a3	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  008a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NOMKDFOD@list?5indices?5must?5be?5integers?0?5n@
  008ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  008b5	e8 00 00 00 00	 call	 PyErr_Format

; 2695 :         return -1;

  008ba	b8 ff ff ff ff	 mov	 eax, -1
$LN1@list_ass_s@2:
$LN33@list_ass_s@2:
$LN38@list_ass_s@2:

; 2696 :     }
; 2697 : }

  008bf	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  008c6	c3		 ret	 0
list_ass_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_09MDCEKMKJ@list_iter?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_iter DD imagerel list_iter
	DD	imagerel list_iter+411
	DD	imagerel $unwind$list_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_iter DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_09MDCEKMKJ@list_iter?$AA@
CONST	SEGMENT
??_C@_09MDCEKMKJ@list_iter?$AA@ DB 'list_iter', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT list_iter
_TEXT	SEGMENT
it$ = 48
g$22365 = 56
tv76 = 64
tv128 = 72
seq$ = 96
list_iter PROC						; COMDAT

; 2813 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2814 :     listiterobject *it;
; 2815 : 
; 2816 :     if (!PyList_Check(seq)) {

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR seq$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 18		 jne	 SHORT $LN7@list_iter

; 2817 :         PyErr_BadInternalCall();

  00021	ba 01 0b 00 00	 mov	 edx, 2817		; 00000b01H
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0002d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2818 :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 5d 01 00 00	 jmp	 $LN8@list_iter
$LN7@list_iter:

; 2819 :     }
; 2820 :     it = PyObject_GC_New(listiterobject, &PyListIter_Type);

  00039	e8 00 00 00 00	 call	 _Py_PXCTX
  0003e	85 c0		 test	 eax, eax
  00040	74 13		 je	 SHORT $LN10@list_iter
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyListIter_Type
  00049	e8 00 00 00 00	 call	 _PxObject_New
  0004e	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
  00053	eb 11		 jmp	 SHORT $LN11@list_iter
$LN10@list_iter:
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyListIter_Type
  0005c	e8 00 00 00 00	 call	 _PyObject_GC_New
  00061	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
$LN11@list_iter:
  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR tv76[rsp]
  0006b	48 89 44 24 30	 mov	 QWORD PTR it$[rsp], rax

; 2821 :     if (it == NULL)

  00070	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$[rsp], 0
  00076	75 07		 jne	 SHORT $LN6@list_iter

; 2822 :         return NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	e9 17 01 00 00	 jmp	 $LN8@list_iter
$LN6@list_iter:

; 2823 :     it->it_index = 0;

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  00084	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [rax+96], 0

; 2824 :     Py_INCREF(seq);

  0008b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR seq$[rsp]
  00090	e8 00 00 00 00	 call	 _Py_IncRef

; 2825 :     it->it_seq = (PyListObject *)seq;

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  0009a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR seq$[rsp]
  0009f	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 2826 :     _PyObject_GC_TRACK(it);

  000a3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ab	4c 8b 4c 24 30	 mov	 r9, QWORD PTR it$[rsp]
  000b0	41 b8 0a 0b 00
	00		 mov	 r8d, 2826		; 00000b0aH
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MDCEKMKJ@list_iter?$AA@
  000c4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c9	85 c0		 test	 eax, eax
  000cb	0f 85 c0 00 00
	00		 jne	 $LN5@list_iter
$LN4@list_iter:
  000d1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d9	4c 8b 4c 24 30	 mov	 r9, QWORD PTR it$[rsp]
  000de	41 b8 0a 0b 00
	00		 mov	 r8d, 2826		; 00000b0aH
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MDCEKMKJ@list_iter?$AA@
  000f2	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f7	85 c0		 test	 eax, eax
  000f9	74 0b		 je	 SHORT $LN12@list_iter
  000fb	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv128[rsp], 0
  00104	eb 0e		 jmp	 SHORT $LN13@list_iter
$LN12@list_iter:
  00106	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  0010b	48 83 e8 18	 sub	 rax, 24
  0010f	48 89 44 24 48	 mov	 QWORD PTR tv128[rsp], rax
$LN13@list_iter:
  00114	48 8b 44 24 48	 mov	 rax, QWORD PTR tv128[rsp]
  00119	48 89 44 24 38	 mov	 QWORD PTR g$22365[rsp], rax
  0011e	48 8b 44 24 38	 mov	 rax, QWORD PTR g$22365[rsp]
  00123	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  00128	74 0c		 je	 SHORT $LN1@list_iter
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  00131	e8 00 00 00 00	 call	 Py_FatalError
$LN1@list_iter:
  00136	48 8b 44 24 38	 mov	 rax, QWORD PTR g$22365[rsp]
  0013b	48 c7 40 10 fd
	ff ff ff	 mov	 QWORD PTR [rax+16], -3
  00143	48 8b 44 24 38	 mov	 rax, QWORD PTR g$22365[rsp]
  00148	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  0014f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00152	48 8b 44 24 38	 mov	 rax, QWORD PTR g$22365[rsp]
  00157	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  0015e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00162	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00166	48 8b 44 24 38	 mov	 rax, QWORD PTR g$22365[rsp]
  0016b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0016f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$22365[rsp]
  00174	48 89 08	 mov	 QWORD PTR [rax], rcx
  00177	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0017e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$22365[rsp]
  00183	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00187	33 c0		 xor	 eax, eax
  00189	85 c0		 test	 eax, eax
  0018b	0f 85 40 ff ff
	ff		 jne	 $LN4@list_iter
$LN5@list_iter:

; 2827 :     return (PyObject *)it;

  00191	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
$LN8@list_iter:

; 2828 : }

  00196	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0019a	c3		 ret	 0
list_iter ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ ; `string'
PUBLIC	??_C@_0BB@GOCFMCPI@listiter_dealloc?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$listiter_dealloc DD imagerel listiter_dealloc
	DD	imagerel listiter_dealloc+295
	DD	imagerel $unwind$listiter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_dealloc DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
CONST	SEGMENT
??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ DB 'g'
	DB	00H, '-', 00H, '>', 00H, 'g', 00H, 'c', 00H, '.', 00H, 'g', 00H
	DB	'c', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 's', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H, 'y', 00H
	DB	'G', 00H, 'C', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'S'
	DB	00H, '_', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H
	DB	'C', 00H, 'K', 00H, 'E', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GOCFMCPI@listiter_dealloc?$AA@
CONST	SEGMENT
??_C@_0BB@GOCFMCPI@listiter_dealloc?$AA@ DB 'listiter_dealloc', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listiter_dealloc
_TEXT	SEGMENT
g$22378 = 48
tv79 = 56
it$ = 80
listiter_dealloc PROC					; COMDAT

; 2832 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2833 :     _PyObject_GC_UNTRACK(it);

  00009	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00011	4c 8b 4c 24 50	 mov	 r9, QWORD PTR it$[rsp]
  00016	41 b8 11 0b 00
	00		 mov	 r8d, 2833		; 00000b11H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GOCFMCPI@listiter_dealloc?$AA@
  0002a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0002f	85 c0		 test	 eax, eax
  00031	0f 85 c1 00 00
	00		 jne	 $LN8@listiter_d
$LN7@listiter_d:
  00037	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0003f	4c 8b 4c 24 50	 mov	 r9, QWORD PTR it$[rsp]
  00044	41 b8 11 0b 00
	00		 mov	 r8d, 2833		; 00000b11H
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GOCFMCPI@listiter_dealloc?$AA@
  00058	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005d	85 c0		 test	 eax, eax
  0005f	74 0b		 je	 SHORT $LN11@listiter_d
  00061	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  0006a	eb 0e		 jmp	 SHORT $LN12@listiter_d
$LN11@listiter_d:
  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  00071	48 83 e8 18	 sub	 rax, 24
  00075	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
$LN12@listiter_d:
  0007a	48 8b 44 24 38	 mov	 rax, QWORD PTR tv79[rsp]
  0007f	48 89 44 24 30	 mov	 QWORD PTR g$22378[rsp], rax
  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR g$22378[rsp]
  00089	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  0008e	75 1c		 jne	 SHORT $LN13@listiter_d
  00090	41 b8 11 0b 00
	00		 mov	 r8d, 2833		; 00000b11H
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000aa	33 c0		 xor	 eax, eax
$LN13@listiter_d:
  000ac	48 8b 44 24 30	 mov	 rax, QWORD PTR g$22378[rsp]
  000b1	48 c7 40 10 fe
	ff ff ff	 mov	 QWORD PTR [rax+16], -2
  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR g$22378[rsp]
  000be	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$22378[rsp]
  000c7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ca	48 89 08	 mov	 QWORD PTR [rax], rcx
  000cd	48 8b 44 24 30	 mov	 rax, QWORD PTR g$22378[rsp]
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$22378[rsp]
  000da	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000de	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR g$22378[rsp]
  000e7	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 85 3f ff ff
	ff		 jne	 $LN7@listiter_d
$LN8@listiter_d:
$LN4@listiter_d:

; 2834 :     Py_XDECREF(it->it_seq);

  000f8	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  000fd	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00102	74 0e		 je	 SHORT $LN1@listiter_d
  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  00109	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  0010d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@listiter_d:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 e0		 jne	 SHORT $LN4@listiter_d

; 2835 :     PyObject_GC_Del(it);

  00118	48 8b 4c 24 50	 mov	 rcx, QWORD PTR it$[rsp]
  0011d	e8 00 00 00 00	 call	 PyObject_GC_Del

; 2836 : }

  00122	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00126	c3		 ret	 0
listiter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@GADENFPD@listiter_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$listiter_traverse DD imagerel listiter_traverse
	DD	imagerel listiter_traverse+116
	DD	imagerel $unwind$listiter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BC@GADENFPD@listiter_traverse?$AA@
CONST	SEGMENT
??_C@_0BC@GADENFPD@listiter_traverse?$AA@ DB 'listiter_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listiter_traverse
_TEXT	SEGMENT
vret$22402 = 32
it$ = 64
visit$ = 72
arg$ = 80
listiter_traverse PROC					; COMDAT

; 2840 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@listiter_t:

; 2841 :     Py_VISIT(it->it_seq);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@listiter_t
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 19 0b 00
	00		 mov	 r8d, 2841		; 00000b19H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@GADENFPD@listiter_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@listiter_t:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 23		 je	 SHORT $LN2@listiter_t
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$22402[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$22402[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@listiter_t
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$22402[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@listiter_t
$LN1@listiter_t:
$LN2@listiter_t:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@listiter_t

; 2842 :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@listiter_t:

; 2843 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
listiter_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@FKGKPHGK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$listiter_next DD imagerel listiter_next
	DD	imagerel listiter_next+238
	DD	imagerel $unwind$listiter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_next DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1CE@FKGKPHGK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@FKGKPHGK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 's'
	DB	00H, 'e', 00H, 'q', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'i'
	DB	00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listiter_next
_TEXT	SEGMENT
seq$ = 32
item$ = 40
it$ = 64
listiter_next PROC					; COMDAT

; 2847 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2848 :     PyListObject *seq;
; 2849 :     PyObject *item;
; 2850 : 
; 2851 :     assert(it != NULL);

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR it$[rsp], 0
  0000f	75 1c		 jne	 SHORT $LN5@listiter_n
  00011	41 b8 23 0b 00
	00		 mov	 r8d, 2851		; 00000b23H
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002b	33 c0		 xor	 eax, eax
$LN5@listiter_n:

; 2852 :     seq = it->it_seq;

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00032	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00036	48 89 44 24 20	 mov	 QWORD PTR seq$[rsp], rax

; 2853 :     if (seq == NULL)

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00041	75 07		 jne	 SHORT $LN2@listiter_n

; 2854 :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 9f 00 00 00	 jmp	 $LN3@listiter_n
$LN2@listiter_n:

; 2855 :     assert(PyList_Check(seq));

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR seq$[rsp]
  0004f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00053	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00059	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0005e	85 c0		 test	 eax, eax
  00060	75 1c		 jne	 SHORT $LN6@listiter_n
  00062	41 b8 27 0b 00
	00		 mov	 r8d, 2855		; 00000b27H
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@FKGKPHGK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007c	33 c0		 xor	 eax, eax
$LN6@listiter_n:

; 2856 : 
; 2857 :     if (it->it_index < PyList_GET_SIZE(seq)) {

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00083	48 63 40 60	 movsxd	 rax, DWORD PTR [rax+96]
  00087	48 8b 4c 24 20	 mov	 rcx, QWORD PTR seq$[rsp]
  0008c	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  00090	7d 3e		 jge	 SHORT $LN1@listiter_n

; 2858 :         item = PyList_GET_ITEM(seq, it->it_index);

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00097	48 63 40 60	 movsxd	 rax, DWORD PTR [rax+96]
  0009b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR seq$[rsp]
  000a0	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000a4	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000a8	48 89 44 24 28	 mov	 QWORD PTR item$[rsp], rax

; 2859 :         ++it->it_index;

  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  000b2	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  000b5	ff c0		 inc	 eax
  000b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  000bc	89 41 60	 mov	 DWORD PTR [rcx+96], eax

; 2860 :         Py_INCREF(item);

  000bf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR item$[rsp]
  000c4	e8 00 00 00 00	 call	 _Py_IncRef

; 2861 :         return item;

  000c9	48 8b 44 24 28	 mov	 rax, QWORD PTR item$[rsp]
  000ce	eb 19		 jmp	 SHORT $LN3@listiter_n
$LN1@listiter_n:

; 2862 :     }
; 2863 : 
; 2864 :     Py_DECREF(seq);

  000d0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR seq$[rsp]
  000d5	e8 00 00 00 00	 call	 _Py_DecRef

; 2865 :     it->it_seq = NULL;

  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  000df	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 2866 :     return NULL;

  000e7	33 c0		 xor	 eax, eax
$LN3@listiter_n:

; 2867 : }

  000e9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ed	c3		 ret	 0
listiter_next ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$listiter_len DD imagerel listiter_len
	DD	imagerel listiter_len+83
	DD	imagerel $unwind$listiter_len
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_len DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listiter_len
_TEXT	SEGMENT
len$ = 32
it$ = 64
listiter_len PROC					; COMDAT

; 2871 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2872 :     Py_ssize_t len;
; 2873 :     if (it->it_seq) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	74 32		 je	 SHORT $LN2@listiter_l

; 2874 :         len = PyList_GET_SIZE(it->it_seq) - it->it_index;

  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0001a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  00023	48 63 49 60	 movsxd	 rcx, DWORD PTR [rcx+96]
  00027	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002b	48 2b c1	 sub	 rax, rcx
  0002e	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 2875 :         if (len >= 0)

  00033	48 83 7c 24 20
	00		 cmp	 QWORD PTR len$[rsp], 0
  00039	7c 0c		 jl	 SHORT $LN1@listiter_l

; 2876 :             return PyLong_FromSsize_t(len);

  0003b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  00040	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00045	eb 07		 jmp	 SHORT $LN3@listiter_l
$LN1@listiter_l:
$LN2@listiter_l:

; 2877 :     }
; 2878 :     return PyLong_FromLong(0);

  00047	33 c9		 xor	 ecx, ecx
  00049	e8 00 00 00 00	 call	 PyLong_FromLong
$LN3@listiter_l:

; 2879 : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
listiter_len ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listiter_reduce DD imagerel listiter_reduce
	DD	imagerel listiter_reduce+29
	DD	imagerel $unwind$listiter_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_reduce DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listiter_reduce
_TEXT	SEGMENT
it$ = 48
listiter_reduce PROC					; COMDAT

; 2883 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2884 :     return listiter_reduce_general(it, 1);

  00009	ba 01 00 00 00	 mov	 edx, 1
  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  00013	e8 00 00 00 00	 call	 listiter_reduce_general

; 2885 : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
listiter_reduce ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$listiter_setstate DD imagerel listiter_setstate
	DD	imagerel listiter_setstate+112
	DD	imagerel $unwind$listiter_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_setstate DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listiter_setstate
_TEXT	SEGMENT
index$ = 32
it$ = 64
state$ = 72
listiter_setstate PROC					; COMDAT

; 2889 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2890 :     long index = PyLong_AsLong(state);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00013	e8 00 00 00 00	 call	 PyLong_AsLong
  00018	89 44 24 20	 mov	 DWORD PTR index$[rsp], eax

; 2891 :     if (index == -1 && PyErr_Occurred())

  0001c	83 7c 24 20 ff	 cmp	 DWORD PTR index$[rsp], -1
  00021	75 0e		 jne	 SHORT $LN3@listiter_s
  00023	e8 00 00 00 00	 call	 PyErr_Occurred
  00028	48 85 c0	 test	 rax, rax
  0002b	74 04		 je	 SHORT $LN3@listiter_s

; 2892 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 3a		 jmp	 SHORT $LN4@listiter_s
$LN3@listiter_s:

; 2893 :     if (it->it_seq != NULL) {

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00036	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0003b	74 1b		 je	 SHORT $LN2@listiter_s

; 2894 :         if (index < 0)

  0003d	83 7c 24 20 00	 cmp	 DWORD PTR index$[rsp], 0
  00042	7d 08		 jge	 SHORT $LN1@listiter_s

; 2895 :             index = 0;

  00044	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR index$[rsp], 0
$LN1@listiter_s:

; 2896 :         it->it_index = index;

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00051	8b 4c 24 20	 mov	 ecx, DWORD PTR index$[rsp]
  00055	89 48 60	 mov	 DWORD PTR [rax+96], ecx
$LN2@listiter_s:

; 2897 :     }
; 2898 :     Py_RETURN_NONE;

  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0005f	e8 00 00 00 00	 call	 _Py_IncRef
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@listiter_s:

; 2899 : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
listiter_setstate ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Track:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_reversed DD imagerel list_reversed
	DD	imagerel list_reversed+198
	DD	imagerel $unwind$list_reversed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_reversed DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list_reversed
_TEXT	SEGMENT
it$ = 32
tv70 = 40
seq$ = 64
unused$ = 72
list_reversed PROC					; COMDAT

; 2959 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2960 :     listreviterobject *it;
; 2961 : 
; 2962 :     it = PyObject_GC_New(listreviterobject, &PyListRevIter_Type);

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 13		 je	 SHORT $LN4@list_rever
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyListRevIter_Type
  0001e	e8 00 00 00 00	 call	 _PxObject_New
  00023	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00028	eb 11		 jmp	 SHORT $LN5@list_rever
$LN4@list_rever:
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyListRevIter_Type
  00031	e8 00 00 00 00	 call	 _PyObject_GC_New
  00036	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN5@list_rever:
  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  00040	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 2963 :     if (it == NULL)

  00045	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  0004b	75 04		 jne	 SHORT $LN1@list_rever

; 2964 :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 70		 jmp	 SHORT $LN2@list_rever
$LN1@list_rever:

; 2965 :     assert(PyList_Check(seq));

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$[rsp]
  00056	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00060	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00065	85 c0		 test	 eax, eax
  00067	75 1c		 jne	 SHORT $LN6@list_rever
  00069	41 b8 95 0b 00
	00		 mov	 r8d, 2965		; 00000b95H
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FFHCLKCK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAi?$AAs?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@FKGKPHGK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00083	33 c0		 xor	 eax, eax
$LN6@list_rever:

; 2966 :     it->it_index = PyList_GET_SIZE(seq) - 1;

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$[rsp]
  0008a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008e	48 ff c8	 dec	 rax
  00091	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00096	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 2967 :     Py_INCREF(seq);

  0009a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$[rsp]
  0009f	e8 00 00 00 00	 call	 _Py_IncRef

; 2968 :     it->it_seq = seq;

  000a4	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  000a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$[rsp]
  000ae	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 2969 :     PyObject_GC_Track(it);

  000b2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000b7	e8 00 00 00 00	 call	 PyObject_GC_Track

; 2970 :     return (PyObject *)it;

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
$LN2@list_rever:

; 2971 : }

  000c1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c5	c3		 ret	 0
list_reversed ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listreviter_dealloc DD imagerel listreviter_dealloc
	DD	imagerel listreviter_dealloc+66
	DD	imagerel $unwind$listreviter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreviter_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listreviter_dealloc
_TEXT	SEGMENT
it$ = 48
listreviter_dealloc PROC				; COMDAT

; 2975 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2976 :     PyObject_GC_UnTrack(it);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN4@listrevite:

; 2977 :     Py_XDECREF(it->it_seq);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  00018	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0001d	74 0e		 je	 SHORT $LN1@listrevite
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  00024	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@listrevite:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN4@listrevite

; 2978 :     PyObject_GC_Del(it);

  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  00038	e8 00 00 00 00	 call	 PyObject_GC_Del

; 2979 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
listreviter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@JIDABJDP@listreviter_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$listreviter_traverse DD imagerel listreviter_traverse
	DD	imagerel listreviter_traverse+116
	DD	imagerel $unwind$listreviter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreviter_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BF@JIDABJDP@listreviter_traverse?$AA@
CONST	SEGMENT
??_C@_0BF@JIDABJDP@listreviter_traverse?$AA@ DB 'listreviter_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listreviter_traverse
_TEXT	SEGMENT
vret$22530 = 32
it$ = 64
visit$ = 72
arg$ = 80
listreviter_traverse PROC				; COMDAT

; 2983 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@listrevite@2:

; 2984 :     Py_VISIT(it->it_seq);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@listrevite@2
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 a8 0b 00
	00		 mov	 r8d, 2984		; 00000ba8H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@JIDABJDP@listreviter_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@listrevite@2:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 23		 je	 SHORT $LN2@listrevite@2
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$22530[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$22530[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@listrevite@2
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$22530[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@listrevite@2
$LN1@listrevite@2:
$LN2@listrevite@2:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@listrevite@2

; 2985 :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@listrevite@2:

; 2986 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
listreviter_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listreviter_next DD imagerel listreviter_next
	DD	imagerel listreviter_next+173
	DD	imagerel $unwind$listreviter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreviter_next DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listreviter_next
_TEXT	SEGMENT
index$ = 32
seq$ = 40
item$ = 48
it$ = 80
listreviter_next PROC					; COMDAT

; 2990 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2991 :     PyObject *item;
; 2992 :     Py_ssize_t index = it->it_index;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 89 44 24 20	 mov	 QWORD PTR index$[rsp], rax

; 2993 :     PyListObject *seq = it->it_seq;

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  0001c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00020	48 89 44 24 28	 mov	 QWORD PTR seq$[rsp], rax

; 2994 : 
; 2995 :     if (index>=0 && index < PyList_GET_SIZE(seq)) {

  00025	48 83 7c 24 20
	00		 cmp	 QWORD PTR index$[rsp], 0
  0002b	7c 4d		 jl	 SHORT $LN2@listrevite@3
  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR seq$[rsp]
  00032	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00036	48 39 44 24 20	 cmp	 QWORD PTR index$[rsp], rax
  0003b	7d 3d		 jge	 SHORT $LN2@listrevite@3

; 2996 :         item = PyList_GET_ITEM(seq, index);

  0003d	48 8b 44 24 28	 mov	 rax, QWORD PTR seq$[rsp]
  00042	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR index$[rsp]
  0004b	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0004f	48 89 44 24 30	 mov	 QWORD PTR item$[rsp], rax

; 2997 :         it->it_index--;

  00054	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  00059	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0005d	48 ff c8	 dec	 rax
  00060	48 8b 4c 24 50	 mov	 rcx, QWORD PTR it$[rsp]
  00065	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 2998 :         Py_INCREF(item);

  00069	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  0006e	e8 00 00 00 00	 call	 _Py_IncRef

; 2999 :         return item;

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR item$[rsp]
  00078	eb 2e		 jmp	 SHORT $LN3@listrevite@3
$LN2@listrevite@3:

; 3000 :     }
; 3001 :     it->it_index = -1;

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  0007f	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 3002 :     if (seq != NULL) {

  00087	48 83 7c 24 28
	00		 cmp	 QWORD PTR seq$[rsp], 0
  0008d	74 17		 je	 SHORT $LN1@listrevite@3

; 3003 :         it->it_seq = NULL;

  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  00094	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 3004 :         Py_DECREF(seq);

  0009c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR seq$[rsp]
  000a1	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@listrevite@3:

; 3005 :     }
; 3006 :     return NULL;

  000a6	33 c0		 xor	 eax, eax
$LN3@listrevite@3:

; 3007 : }

  000a8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ac	c3		 ret	 0
listreviter_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listreviter_len DD imagerel listreviter_len
	DD	imagerel listreviter_len+82
	DD	imagerel $unwind$listreviter_len
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreviter_len DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listreviter_len
_TEXT	SEGMENT
len$ = 32
it$ = 64
listreviter_len PROC					; COMDAT

; 3011 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3012 :     Py_ssize_t len = it->it_index + 1;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 ff c0	 inc	 rax
  00015	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 3013 :     if (it->it_seq == NULL || PyList_GET_SIZE(it->it_seq) < len)

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0001f	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00024	74 14		 je	 SHORT $LN1@listrevite@4
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0002b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0002f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  00034	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00038	7d 09		 jge	 SHORT $LN2@listrevite@4
$LN1@listrevite@4:

; 3014 :         len = 0;

  0003a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0
$LN2@listrevite@4:

; 3015 :     return PyLong_FromSsize_t(len);

  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  00048	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 3016 : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
listreviter_len ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listreviter_reduce DD imagerel listreviter_reduce
	DD	imagerel listreviter_reduce+26
	DD	imagerel $unwind$listreviter_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreviter_reduce DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listreviter_reduce
_TEXT	SEGMENT
it$ = 48
listreviter_reduce PROC					; COMDAT

; 3020 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3021 :     return listiter_reduce_general(it, 0);

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  00010	e8 00 00 00 00	 call	 listiter_reduce_general

; 3022 : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
listreviter_reduce ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$listreviter_setstate DD imagerel listreviter_setstate
	DD	imagerel listreviter_setstate+164
	DD	imagerel $unwind$listreviter_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreviter_setstate DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT listreviter_setstate
_TEXT	SEGMENT
index$ = 32
it$ = 64
state$ = 72
listreviter_setstate PROC				; COMDAT

; 3026 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3027 :     Py_ssize_t index = PyLong_AsSsize_t(state);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00013	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00018	48 89 44 24 20	 mov	 QWORD PTR index$[rsp], rax

; 3028 :     if (index == -1 && PyErr_Occurred())

  0001d	48 83 7c 24 20
	ff		 cmp	 QWORD PTR index$[rsp], -1
  00023	75 0e		 jne	 SHORT $LN5@listrevite@5
  00025	e8 00 00 00 00	 call	 PyErr_Occurred
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 04		 je	 SHORT $LN5@listrevite@5

; 3029 :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 6c		 jmp	 SHORT $LN6@listrevite@5
$LN5@listrevite@5:

; 3030 :     if (it->it_seq != NULL) {

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00038	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0003d	74 4d		 je	 SHORT $LN4@listrevite@5

; 3031 :         if (index < -1)

  0003f	48 83 7c 24 20
	ff		 cmp	 QWORD PTR index$[rsp], -1
  00045	7d 0b		 jge	 SHORT $LN3@listrevite@5

; 3032 :             index = -1;

  00047	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR index$[rsp], -1
  00050	eb 2c		 jmp	 SHORT $LN2@listrevite@5
$LN3@listrevite@5:

; 3033 :         else if (index > PyList_GET_SIZE(it->it_seq) - 1)

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0005f	48 ff c8	 dec	 rax
  00062	48 39 44 24 20	 cmp	 QWORD PTR index$[rsp], rax
  00067	7e 15		 jle	 SHORT $LN1@listrevite@5

; 3034 :             index = PyList_GET_SIZE(it->it_seq) - 1;

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0006e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00072	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00076	48 ff c8	 dec	 rax
  00079	48 89 44 24 20	 mov	 QWORD PTR index$[rsp], rax
$LN1@listrevite@5:
$LN2@listrevite@5:

; 3035 :         it->it_index = index;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR index$[rsp]
  00088	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
$LN4@listrevite@5:

; 3036 :     }
; 3037 :     Py_RETURN_NONE;

  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00093	e8 00 00 00 00	 call	 _Py_IncRef
  00098	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN6@listrevite@5:

; 3038 : }

  0009f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a3	c3		 ret	 0
listreviter_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@		; `string'
PUBLIC	??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@		; `string'
PUBLIC	??_C@_08DNDMMOJA@reversed?$AA@			; `string'
PUBLIC	??_C@_05LHHNEACK@N?$CIO?$CJl?$AA@		; `string'
PUBLIC	??_C@_04BKLHDIKK@iter?$AA@			; `string'
EXTRN	Py_BuildValue:PROC
EXTRN	_PyObject_GetBuiltin:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$listiter_reduce_general DD imagerel listiter_reduce_general
	DD	imagerel listiter_reduce_general+221
	DD	imagerel $unwind$listiter_reduce_general
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_reduce_general DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT ??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@ DB 'N(N)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
CONST	SEGMENT
??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@ DB 'N(O)n', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DNDMMOJA@reversed?$AA@
CONST	SEGMENT
??_C@_08DNDMMOJA@reversed?$AA@ DB 'reversed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LHHNEACK@N?$CIO?$CJl?$AA@
CONST	SEGMENT
??_C@_05LHHNEACK@N?$CIO?$CJl?$AA@ DB 'N(O)l', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLHDIKK@iter?$AA@
CONST	SEGMENT
??_C@_04BKLHDIKK@iter?$AA@ DB 'iter', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT listiter_reduce_general
_TEXT	SEGMENT
list$ = 32
it$22582 = 40
it$22588 = 48
_it$ = 80
forward$ = 88
listiter_reduce_general PROC				; COMDAT

; 3044 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3045 :     PyObject *list;
; 3046 : 
; 3047 :     /* the objects are not the same, index is of different types! */
; 3048 :     if (forward) {

  0000d	83 7c 24 58 00	 cmp	 DWORD PTR forward$[rsp], 0
  00012	74 47		 je	 SHORT $LN5@listiter_r

; 3049 :         listiterobject *it = (listiterobject *)_it;

  00014	48 8b 44 24 50	 mov	 rax, QWORD PTR _it$[rsp]
  00019	48 89 44 24 28	 mov	 QWORD PTR it$22582[rsp], rax

; 3050 :         if (it->it_seq)

  0001e	48 8b 44 24 28	 mov	 rax, QWORD PTR it$22582[rsp]
  00023	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00028	74 2f		 je	 SHORT $LN4@listiter_r

; 3051 :             return Py_BuildValue("N(O)l", _PyObject_GetBuiltin("iter"),
; 3052 :                                  it->it_seq, it->it_index);

  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  00031	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR it$22582[rsp]
  0003b	44 8b 49 60	 mov	 r9d, DWORD PTR [rcx+96]
  0003f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR it$22582[rsp]
  00044	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  00048	48 8b d0	 mov	 rdx, rax
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LHHNEACK@N?$CIO?$CJl?$AA@
  00052	e8 00 00 00 00	 call	 Py_BuildValue
  00057	eb 7f		 jmp	 SHORT $LN6@listiter_r
$LN4@listiter_r:

; 3053 :     } else {

  00059	eb 45		 jmp	 SHORT $LN3@listiter_r
$LN5@listiter_r:

; 3054 :         listreviterobject *it = (listreviterobject *)_it;

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR _it$[rsp]
  00060	48 89 44 24 30	 mov	 QWORD PTR it$22588[rsp], rax

; 3055 :         if (it->it_seq)

  00065	48 8b 44 24 30	 mov	 rax, QWORD PTR it$22588[rsp]
  0006a	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0006f	74 2f		 je	 SHORT $LN2@listiter_r

; 3056 :             return Py_BuildValue("N(O)n", _PyObject_GetBuiltin("reversed"),
; 3057 :                                  it->it_seq, it->it_index);

  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DNDMMOJA@reversed?$AA@
  00078	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$22588[rsp]
  00082	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  00086	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$22588[rsp]
  0008b	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  0008f	48 8b d0	 mov	 rdx, rax
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
  00099	e8 00 00 00 00	 call	 Py_BuildValue
  0009e	eb 38		 jmp	 SHORT $LN6@listiter_r
$LN2@listiter_r:
$LN3@listiter_r:

; 3058 :     }
; 3059 :     /* empty iterator, create an empty list */
; 3060 :     list = PyList_New(0);

  000a0	33 c9		 xor	 ecx, ecx
  000a2	e8 00 00 00 00	 call	 PyList_New
  000a7	48 89 44 24 20	 mov	 QWORD PTR list$[rsp], rax

; 3061 :     if (list == NULL)

  000ac	48 83 7c 24 20
	00		 cmp	 QWORD PTR list$[rsp], 0
  000b2	75 04		 jne	 SHORT $LN1@listiter_r

; 3062 :         return NULL;

  000b4	33 c0		 xor	 eax, eax
  000b6	eb 20		 jmp	 SHORT $LN6@listiter_r
$LN1@listiter_r:

; 3063 :     return Py_BuildValue("N(N)", _PyObject_GetBuiltin("iter"), list);

  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  000bf	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  000c4	4c 8b 44 24 20	 mov	 r8, QWORD PTR list$[rsp]
  000c9	48 8b d0	 mov	 rdx, rax
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
  000d3	e8 00 00 00 00	 call	 Py_BuildValue
$LN6@listiter_r:

; 3064 : }

  000d8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000dc	c3		 ret	 0
listiter_reduce_general ENDP
_TEXT	ENDS
END
