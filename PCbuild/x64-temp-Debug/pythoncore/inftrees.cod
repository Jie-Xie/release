; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	inflate_copyright
CONST	SEGMENT
inflate_copyright DB ' inflate 1.2.5 Copyright 1995-2010 Mark Adler ', 00H
	ORG $+1
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	049H
	DW	0c3H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
CONST	ENDS
PUBLIC	inflate_table
;	COMDAT pdata
; File c:\src\pyparallel\modules\zlib\inftrees.c
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN71
	DD	imagerel $LN71+2453
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 021a01H
	DD	019011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflate_table
_TEXT	SEGMENT
count$ = 0
here$ = 32
extra$ = 40
base$ = 48
huff$ = 56
min$ = 60
mask$ = 64
drop$ = 68
curr$ = 72
root$ = 76
next$ = 80
left$ = 88
len$ = 92
end$ = 96
incr$ = 100
offs$ = 104
fill$ = 136
sym$ = 140
low$ = 144
used$ = 148
max$ = 152
tv201 = 156
tv459 = 160
tv477 = 164
tv480 = 168
tv492 = 172
tv297 = 176
tv515 = 180
tv525 = 184
tv553 = 188
type$ = 208
lens$ = 216
codes$ = 224
table$ = 232
bits$ = 240
work$ = 248
inflate_table PROC					; COMDAT

; 39   : {

$LN71:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 195};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  0001a	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  00022	eb 0a		 jmp	 SHORT $LN68@inflate_ta
$LN67@inflate_ta:
  00024	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00028	ff c0		 inc	 eax
  0002a	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax
$LN68@inflate_ta:
  0002e	83 7c 24 5c 0f	 cmp	 DWORD PTR len$[rsp], 15
  00033	77 0c		 ja	 SHORT $LN66@inflate_ta

; 108  :         count[len] = 0;

  00035	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00039	33 c9		 xor	 ecx, ecx
  0003b	66 89 0c 44	 mov	 WORD PTR count$[rsp+rax*2], cx
  0003f	eb e3		 jmp	 SHORT $LN67@inflate_ta
$LN66@inflate_ta:

; 109  :     for (sym = 0; sym < codes; sym++)

  00041	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sym$[rsp], 0
  0004c	eb 10		 jmp	 SHORT $LN65@inflate_ta
$LN64@inflate_ta:
  0004e	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  00055	ff c0		 inc	 eax
  00057	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sym$[rsp], eax
$LN65@inflate_ta:
  0005e	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR codes$[rsp]
  00065	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR sym$[rsp], eax
  0006c	73 33		 jae	 SHORT $LN63@inflate_ta

; 110  :         count[lens[sym]]++;

  0006e	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  00075	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR lens$[rsp]
  0007d	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00081	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  00085	66 ff c0	 inc	 ax
  00088	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  0008f	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR lens$[rsp]
  00097	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  0009b	66 89 04 4c	 mov	 WORD PTR count$[rsp+rcx*2], ax
  0009f	eb ad		 jmp	 SHORT $LN64@inflate_ta
$LN63@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  000a1	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR bits$[rsp]
  000a9	8b 00		 mov	 eax, DWORD PTR [rax]
  000ab	89 44 24 4c	 mov	 DWORD PTR root$[rsp], eax

; 114  :     for (max = MAXBITS; max >= 1; max--)

  000af	c7 84 24 98 00
	00 00 0f 00 00
	00		 mov	 DWORD PTR max$[rsp], 15
  000ba	eb 10		 jmp	 SHORT $LN62@inflate_ta
$LN61@inflate_ta:
  000bc	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000c3	ff c8		 dec	 eax
  000c5	89 84 24 98 00
	00 00		 mov	 DWORD PTR max$[rsp], eax
$LN62@inflate_ta:
  000cc	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR max$[rsp], 1
  000d4	72 13		 jb	 SHORT $LN60@inflate_ta

; 115  :         if (count[max] != 0) break;

  000d6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000dd	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  000e1	85 c0		 test	 eax, eax
  000e3	74 02		 je	 SHORT $LN59@inflate_ta
  000e5	eb 02		 jmp	 SHORT $LN60@inflate_ta
$LN59@inflate_ta:

; 116  :     if (root > max) root = max;

  000e7	eb d3		 jmp	 SHORT $LN61@inflate_ta
$LN60@inflate_ta:
  000e9	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000f0	39 44 24 4c	 cmp	 DWORD PTR root$[rsp], eax
  000f4	76 0b		 jbe	 SHORT $LN58@inflate_ta
  000f6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000fd	89 44 24 4c	 mov	 DWORD PTR root$[rsp], eax
$LN58@inflate_ta:

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  00101	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR max$[rsp], 0
  00109	75 7c		 jne	 SHORT $LN57@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */

  0010b	c6 44 24 20 40	 mov	 BYTE PTR here$[rsp], 64	; 00000040H

; 119  :         here.bits = (unsigned char)1;

  00110	c6 44 24 21 01	 mov	 BYTE PTR here$[rsp+1], 1

; 120  :         here.val = (unsigned short)0;

  00115	33 c0		 xor	 eax, eax
  00117	66 89 44 24 22	 mov	 WORD PTR here$[rsp+2], ax

; 121  :         *(*table)++ = here;             /* make a table to force an error */

  0011c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00124	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00127	8b 4c 24 20	 mov	 ecx, DWORD PTR here$[rsp]
  0012b	89 08		 mov	 DWORD PTR [rax], ecx
  0012d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00135	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00138	48 83 c0 04	 add	 rax, 4
  0013c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00144	48 89 01	 mov	 QWORD PTR [rcx], rax

; 122  :         *(*table)++ = here;

  00147	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  0014f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00152	8b 4c 24 20	 mov	 ecx, DWORD PTR here$[rsp]
  00156	89 08		 mov	 DWORD PTR [rax], ecx
  00158	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00160	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00163	48 83 c0 04	 add	 rax, 4
  00167	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0016f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 123  :         *bits = 1;

  00172	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR bits$[rsp]
  0017a	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  00180	33 c0		 xor	 eax, eax
  00182	e9 06 08 00 00	 jmp	 $LN69@inflate_ta
$LN57@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00187	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR min$[rsp], 1
  0018f	eb 0a		 jmp	 SHORT $LN56@inflate_ta
$LN55@inflate_ta:
  00191	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  00195	ff c0		 inc	 eax
  00197	89 44 24 3c	 mov	 DWORD PTR min$[rsp], eax
$LN56@inflate_ta:
  0019b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  001a2	39 44 24 3c	 cmp	 DWORD PTR min$[rsp], eax
  001a6	73 10		 jae	 SHORT $LN54@inflate_ta

; 127  :         if (count[min] != 0) break;

  001a8	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  001ac	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  001b0	85 c0		 test	 eax, eax
  001b2	74 02		 je	 SHORT $LN53@inflate_ta
  001b4	eb 02		 jmp	 SHORT $LN54@inflate_ta
$LN53@inflate_ta:

; 128  :     if (root < min) root = min;

  001b6	eb d9		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:
  001b8	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  001bc	39 44 24 4c	 cmp	 DWORD PTR root$[rsp], eax
  001c0	73 08		 jae	 SHORT $LN52@inflate_ta
  001c2	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  001c6	89 44 24 4c	 mov	 DWORD PTR root$[rsp], eax
$LN52@inflate_ta:

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  001ca	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR left$[rsp], 1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  001d2	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR len$[rsp], 1
  001da	eb 0a		 jmp	 SHORT $LN51@inflate_ta
$LN50@inflate_ta:
  001dc	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  001e0	ff c0		 inc	 eax
  001e2	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax
$LN51@inflate_ta:
  001e6	83 7c 24 5c 0f	 cmp	 DWORD PTR len$[rsp], 15
  001eb	77 31		 ja	 SHORT $LN49@inflate_ta

; 133  :         left <<= 1;

  001ed	8b 44 24 58	 mov	 eax, DWORD PTR left$[rsp]
  001f1	d1 e0		 shl	 eax, 1
  001f3	89 44 24 58	 mov	 DWORD PTR left$[rsp], eax

; 134  :         left -= count[len];

  001f7	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  001fb	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  001ff	8b 4c 24 58	 mov	 ecx, DWORD PTR left$[rsp]
  00203	2b c8		 sub	 ecx, eax
  00205	8b c1		 mov	 eax, ecx
  00207	89 44 24 58	 mov	 DWORD PTR left$[rsp], eax

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  0020b	83 7c 24 58 00	 cmp	 DWORD PTR left$[rsp], 0
  00210	7d 0a		 jge	 SHORT $LN48@inflate_ta
  00212	b8 ff ff ff ff	 mov	 eax, -1
  00217	e9 71 07 00 00	 jmp	 $LN69@inflate_ta
$LN48@inflate_ta:

; 136  :     }

  0021c	eb be		 jmp	 SHORT $LN50@inflate_ta
$LN49@inflate_ta:

; 137  :     if (left > 0 && (type == CODES || max != 1))

  0021e	83 7c 24 58 00	 cmp	 DWORD PTR left$[rsp], 0
  00223	7e 1e		 jle	 SHORT $LN47@inflate_ta
  00225	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR type$[rsp], 0
  0022d	74 0a		 je	 SHORT $LN46@inflate_ta
  0022f	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR max$[rsp], 1
  00237	74 0a		 je	 SHORT $LN47@inflate_ta
$LN46@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  00239	b8 ff ff ff ff	 mov	 eax, -1
  0023e	e9 4a 07 00 00	 jmp	 $LN69@inflate_ta
$LN47@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  00243	33 c0		 xor	 eax, eax
  00245	66 89 44 24 6a	 mov	 WORD PTR offs$[rsp+2], ax

; 142  :     for (len = 1; len < MAXBITS; len++)

  0024a	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR len$[rsp], 1
  00252	eb 0a		 jmp	 SHORT $LN45@inflate_ta
$LN44@inflate_ta:
  00254	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00258	ff c0		 inc	 eax
  0025a	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax
$LN45@inflate_ta:
  0025e	83 7c 24 5c 0f	 cmp	 DWORD PTR len$[rsp], 15
  00263	73 22		 jae	 SHORT $LN43@inflate_ta

; 143  :         offs[len + 1] = offs[len] + count[len];

  00265	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00269	0f b7 44 44 68	 movzx	 eax, WORD PTR offs$[rsp+rax*2]
  0026e	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$[rsp]
  00272	0f b7 0c 4c	 movzx	 ecx, WORD PTR count$[rsp+rcx*2]
  00276	03 c1		 add	 eax, ecx
  00278	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$[rsp]
  0027c	ff c1		 inc	 ecx
  0027e	8b c9		 mov	 ecx, ecx
  00280	66 89 44 4c 68	 mov	 WORD PTR offs$[rsp+rcx*2], ax
  00285	eb cd		 jmp	 SHORT $LN44@inflate_ta
$LN43@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00287	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sym$[rsp], 0
  00292	eb 10		 jmp	 SHORT $LN42@inflate_ta
$LN41@inflate_ta:
  00294	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  0029b	ff c0		 inc	 eax
  0029d	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sym$[rsp], eax
$LN42@inflate_ta:
  002a4	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR codes$[rsp]
  002ab	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR sym$[rsp], eax
  002b2	73 7b		 jae	 SHORT $LN40@inflate_ta

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  002b4	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  002bb	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR lens$[rsp]
  002c3	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  002c7	85 c0		 test	 eax, eax
  002c9	74 5f		 je	 SHORT $LN39@inflate_ta
  002cb	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  002d2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR lens$[rsp]
  002da	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  002de	0f b7 44 44 68	 movzx	 eax, WORD PTR offs$[rsp+rax*2]
  002e3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  002eb	0f b7 94 24 8c
	00 00 00	 movzx	 edx, WORD PTR sym$[rsp]
  002f3	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  002f7	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  002fe	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR lens$[rsp]
  00306	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0030a	0f b7 44 44 68	 movzx	 eax, WORD PTR offs$[rsp+rax*2]
  0030f	66 ff c0	 inc	 ax
  00312	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00319	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR lens$[rsp]
  00321	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  00325	66 89 44 4c 68	 mov	 WORD PTR offs$[rsp+rcx*2], ax
$LN39@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  0032a	e9 65 ff ff ff	 jmp	 $LN41@inflate_ta
$LN40@inflate_ta:
  0032f	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR type$[rsp]
  00336	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv201[rsp], eax
  0033d	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv201[rsp], 0
  00345	74 0c		 je	 SHORT $LN36@inflate_ta
  00347	83 bc 24 9c 00
	00 00 01	 cmp	 DWORD PTR tv201[rsp], 1
  0034f	74 23		 je	 SHORT $LN35@inflate_ta
  00351	eb 63		 jmp	 SHORT $LN34@inflate_ta
$LN36@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  00353	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  0035b	48 89 44 24 28	 mov	 QWORD PTR extra$[rsp], rax
  00360	48 8b 44 24 28	 mov	 rax, QWORD PTR extra$[rsp]
  00365	48 89 44 24 30	 mov	 QWORD PTR base$[rsp], rax

; 184  :         end = 19;

  0036a	c7 44 24 60 13
	00 00 00	 mov	 DWORD PTR end$[rsp], 19

; 185  :         break;

  00372	eb 62		 jmp	 SHORT $LN37@inflate_ta
$LN35@inflate_ta:

; 186  :     case LENS:
; 187  :         base = lbase;

  00374	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9
  0037b	48 89 44 24 30	 mov	 QWORD PTR base$[rsp], rax

; 188  :         base -= 257;

  00380	48 8b 44 24 30	 mov	 rax, QWORD PTR base$[rsp]
  00385	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  0038b	48 89 44 24 30	 mov	 QWORD PTR base$[rsp], rax

; 189  :         extra = lext;

  00390	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  00397	48 89 44 24 28	 mov	 QWORD PTR extra$[rsp], rax

; 190  :         extra -= 257;

  0039c	48 8b 44 24 28	 mov	 rax, QWORD PTR extra$[rsp]
  003a1	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  003a7	48 89 44 24 28	 mov	 QWORD PTR extra$[rsp], rax

; 191  :         end = 256;

  003ac	c7 44 24 60 00
	01 00 00	 mov	 DWORD PTR end$[rsp], 256 ; 00000100H

; 192  :         break;

  003b4	eb 20		 jmp	 SHORT $LN37@inflate_ta
$LN34@inflate_ta:

; 193  :     default:            /* DISTS */
; 194  :         base = dbase;

  003b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dbase@?1??inflate_table@@9@9
  003bd	48 89 44 24 30	 mov	 QWORD PTR base$[rsp], rax

; 195  :         extra = dext;

  003c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  003c9	48 89 44 24 28	 mov	 QWORD PTR extra$[rsp], rax

; 196  :         end = -1;

  003ce	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR end$[rsp], -1
$LN37@inflate_ta:

; 197  :     }
; 198  : 
; 199  :     /* initialize state for loop */
; 200  :     huff = 0;                   /* starting code */

  003d6	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0

; 201  :     sym = 0;                    /* starting code symbol */

  003de	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sym$[rsp], 0

; 202  :     len = min;                  /* starting code length */

  003e9	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  003ed	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax

; 203  :     next = *table;              /* current table to fill in */

  003f1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  003f9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003fc	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 204  :     curr = root;                /* current table index bits */

  00401	8b 44 24 4c	 mov	 eax, DWORD PTR root$[rsp]
  00405	89 44 24 48	 mov	 DWORD PTR curr$[rsp], eax

; 205  :     drop = 0;                   /* current bits to drop from code for index */

  00409	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR drop$[rsp], 0

; 206  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */

  00411	c7 84 24 90 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR low$[rsp], -1	; ffffffffH

; 207  :     used = 1U << root;          /* use root table entries */

  0041c	8b 44 24 4c	 mov	 eax, DWORD PTR root$[rsp]
  00420	b9 01 00 00 00	 mov	 ecx, 1
  00425	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv459[rsp], ecx
  0042c	0f b6 c8	 movzx	 ecx, al
  0042f	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv459[rsp]
  00436	d3 e0		 shl	 eax, cl
  00438	89 84 24 94 00
	00 00		 mov	 DWORD PTR used$[rsp], eax

; 208  :     mask = used - 1;            /* mask for comparing low */

  0043f	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR used$[rsp]
  00446	ff c8		 dec	 eax
  00448	89 44 24 40	 mov	 DWORD PTR mask$[rsp], eax

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used >= ENOUGH_LENS) ||
; 212  :         (type == DISTS && used >= ENOUGH_DISTS))

  0044c	83 bc 24 d0 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00454	75 0d		 jne	 SHORT $LN31@inflate_ta
  00456	81 bc 24 94 00
	00 00 54 03 00
	00		 cmp	 DWORD PTR used$[rsp], 852 ; 00000354H
  00461	73 17		 jae	 SHORT $LN32@inflate_ta
$LN31@inflate_ta:
  00463	83 bc 24 d0 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  0046b	75 17		 jne	 SHORT $LN33@inflate_ta
  0046d	81 bc 24 94 00
	00 00 50 02 00
	00		 cmp	 DWORD PTR used$[rsp], 592 ; 00000250H
  00478	72 0a		 jb	 SHORT $LN33@inflate_ta
$LN32@inflate_ta:

; 213  :         return 1;

  0047a	b8 01 00 00 00	 mov	 eax, 1
  0047f	e9 09 05 00 00	 jmp	 $LN69@inflate_ta
$LN33@inflate_ta:
$LN30@inflate_ta:

; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);

  00484	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  00488	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$[rsp]
  0048c	2b c8		 sub	 ecx, eax
  0048e	8b c1		 mov	 eax, ecx
  00490	88 44 24 21	 mov	 BYTE PTR here$[rsp+1], al

; 219  :         if ((int)(work[sym]) < end) {

  00494	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  0049b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  004a3	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  004a7	3b 44 24 60	 cmp	 eax, DWORD PTR end$[rsp]
  004ab	7d 1f		 jge	 SHORT $LN28@inflate_ta

; 220  :             here.op = (unsigned char)0;

  004ad	c6 44 24 20 00	 mov	 BYTE PTR here$[rsp], 0

; 221  :             here.val = work[sym];

  004b2	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  004b9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  004c1	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  004c5	66 89 44 24 22	 mov	 WORD PTR here$[rsp+2], ax
  004ca	eb 68		 jmp	 SHORT $LN27@inflate_ta
$LN28@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  004cc	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  004d3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  004db	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  004df	3b 44 24 60	 cmp	 eax, DWORD PTR end$[rsp]
  004e3	7e 43		 jle	 SHORT $LN26@inflate_ta

; 224  :             here.op = (unsigned char)(extra[work[sym]]);

  004e5	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  004ec	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  004f4	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  004f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR extra$[rsp]
  004fd	0f b6 04 41	 movzx	 eax, BYTE PTR [rcx+rax*2]
  00501	88 44 24 20	 mov	 BYTE PTR here$[rsp], al

; 225  :             here.val = base[work[sym]];

  00505	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  0050c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  00514	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00518	48 8b 4c 24 30	 mov	 rcx, QWORD PTR base$[rsp]
  0051d	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00521	66 89 44 24 22	 mov	 WORD PTR here$[rsp+2], ax

; 226  :         }
; 227  :         else {

  00526	eb 0c		 jmp	 SHORT $LN25@inflate_ta
$LN26@inflate_ta:

; 228  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  00528	c6 44 24 20 60	 mov	 BYTE PTR here$[rsp], 96	; 00000060H

; 229  :             here.val = 0;

  0052d	33 c0		 xor	 eax, eax
  0052f	66 89 44 24 22	 mov	 WORD PTR here$[rsp+2], ax
$LN25@inflate_ta:
$LN27@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  00534	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  00538	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$[rsp]
  0053c	2b c8		 sub	 ecx, eax
  0053e	8b c1		 mov	 eax, ecx
  00540	b9 01 00 00 00	 mov	 ecx, 1
  00545	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv477[rsp], ecx
  0054c	0f b6 c8	 movzx	 ecx, al
  0054f	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv477[rsp]
  00556	d3 e0		 shl	 eax, cl
  00558	89 44 24 64	 mov	 DWORD PTR incr$[rsp], eax

; 234  :         fill = 1U << curr;

  0055c	8b 44 24 48	 mov	 eax, DWORD PTR curr$[rsp]
  00560	b9 01 00 00 00	 mov	 ecx, 1
  00565	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv480[rsp], ecx
  0056c	0f b6 c8	 movzx	 ecx, al
  0056f	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv480[rsp]
  00576	d3 e0		 shl	 eax, cl
  00578	89 84 24 88 00
	00 00		 mov	 DWORD PTR fill$[rsp], eax

; 235  :         min = fill;                 /* save offset to next table */

  0057f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR fill$[rsp]
  00586	89 44 24 3c	 mov	 DWORD PTR min$[rsp], eax
$LN24@inflate_ta:

; 236  :         do {
; 237  :             fill -= incr;

  0058a	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  0058e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fill$[rsp]
  00595	2b c8		 sub	 ecx, eax
  00597	8b c1		 mov	 eax, ecx
  00599	89 84 24 88 00
	00 00		 mov	 DWORD PTR fill$[rsp], eax

; 238  :             next[(huff >> drop) + fill] = here;

  005a0	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  005a4	0f b6 c8	 movzx	 ecx, al
  005a7	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  005ab	d3 e8		 shr	 eax, cl
  005ad	03 84 24 88 00
	00 00		 add	 eax, DWORD PTR fill$[rsp]
  005b4	8b c0		 mov	 eax, eax
  005b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  005bb	8b 54 24 20	 mov	 edx, DWORD PTR here$[rsp]
  005bf	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 239  :         } while (fill != 0);

  005c2	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR fill$[rsp], 0
  005ca	75 be		 jne	 SHORT $LN24@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  005cc	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  005d0	ff c8		 dec	 eax
  005d2	b9 01 00 00 00	 mov	 ecx, 1
  005d7	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv492[rsp], ecx
  005de	0f b6 c8	 movzx	 ecx, al
  005e1	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv492[rsp]
  005e8	d3 e0		 shl	 eax, cl
  005ea	89 44 24 64	 mov	 DWORD PTR incr$[rsp], eax
$LN21@inflate_ta:

; 243  :         while (huff & incr)

  005ee	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  005f2	8b 4c 24 38	 mov	 ecx, DWORD PTR huff$[rsp]
  005f6	23 c8		 and	 ecx, eax
  005f8	8b c1		 mov	 eax, ecx
  005fa	85 c0		 test	 eax, eax
  005fc	74 0c		 je	 SHORT $LN20@inflate_ta

; 244  :             incr >>= 1;

  005fe	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  00602	d1 e8		 shr	 eax, 1
  00604	89 44 24 64	 mov	 DWORD PTR incr$[rsp], eax
  00608	eb e4		 jmp	 SHORT $LN21@inflate_ta
$LN20@inflate_ta:

; 245  :         if (incr != 0) {

  0060a	83 7c 24 64 00	 cmp	 DWORD PTR incr$[rsp], 0
  0060f	74 24		 je	 SHORT $LN19@inflate_ta

; 246  :             huff &= incr - 1;

  00611	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  00615	ff c8		 dec	 eax
  00617	8b 4c 24 38	 mov	 ecx, DWORD PTR huff$[rsp]
  0061b	23 c8		 and	 ecx, eax
  0061d	8b c1		 mov	 eax, ecx
  0061f	89 44 24 38	 mov	 DWORD PTR huff$[rsp], eax

; 247  :             huff += incr;

  00623	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  00627	8b 4c 24 38	 mov	 ecx, DWORD PTR huff$[rsp]
  0062b	03 c8		 add	 ecx, eax
  0062d	8b c1		 mov	 eax, ecx
  0062f	89 44 24 38	 mov	 DWORD PTR huff$[rsp], eax

; 248  :         }
; 249  :         else

  00633	eb 08		 jmp	 SHORT $LN18@inflate_ta
$LN19@inflate_ta:

; 250  :             huff = 0;

  00635	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0
$LN18@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  0063d	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  00644	ff c0		 inc	 eax
  00646	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sym$[rsp], eax

; 254  :         if (--(count[len]) == 0) {

  0064d	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00651	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  00655	66 ff c8	 dec	 ax
  00658	66 89 84 24 b0
	00 00 00	 mov	 WORD PTR tv297[rsp], ax
  00660	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00664	0f b7 8c 24 b0
	00 00 00	 movzx	 ecx, WORD PTR tv297[rsp]
  0066c	66 89 0c 44	 mov	 WORD PTR count$[rsp+rax*2], cx
  00670	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR tv297[rsp]
  00678	85 c0		 test	 eax, eax
  0067a	75 35		 jne	 SHORT $LN17@inflate_ta

; 255  :             if (len == max) break;

  0067c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00683	39 44 24 5c	 cmp	 DWORD PTR len$[rsp], eax
  00687	75 05		 jne	 SHORT $LN16@inflate_ta
  00689	e9 d1 01 00 00	 jmp	 $LN29@inflate_ta
$LN16@inflate_ta:

; 256  :             len = lens[work[sym]];

  0068e	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  00695	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  0069d	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  006a1	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR lens$[rsp]
  006a9	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  006ad	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax
$LN17@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  006b1	8b 44 24 4c	 mov	 eax, DWORD PTR root$[rsp]
  006b5	39 44 24 5c	 cmp	 DWORD PTR len$[rsp], eax
  006b9	0f 86 9b 01 00
	00		 jbe	 $LN15@inflate_ta
  006bf	8b 44 24 40	 mov	 eax, DWORD PTR mask$[rsp]
  006c3	8b 4c 24 38	 mov	 ecx, DWORD PTR huff$[rsp]
  006c7	23 c8		 and	 ecx, eax
  006c9	8b c1		 mov	 eax, ecx
  006cb	3b 84 24 90 00
	00 00		 cmp	 eax, DWORD PTR low$[rsp]
  006d2	0f 84 82 01 00
	00		 je	 $LN15@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)

  006d8	83 7c 24 44 00	 cmp	 DWORD PTR drop$[rsp], 0
  006dd	75 08		 jne	 SHORT $LN14@inflate_ta

; 263  :                 drop = root;

  006df	8b 44 24 4c	 mov	 eax, DWORD PTR root$[rsp]
  006e3	89 44 24 44	 mov	 DWORD PTR drop$[rsp], eax
$LN14@inflate_ta:

; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  006e7	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  006eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  006f0	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  006f4	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  006f9	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  006fd	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$[rsp]
  00701	2b c8		 sub	 ecx, eax
  00703	8b c1		 mov	 eax, ecx
  00705	89 44 24 48	 mov	 DWORD PTR curr$[rsp], eax

; 270  :             left = (int)(1 << curr);

  00709	8b 44 24 48	 mov	 eax, DWORD PTR curr$[rsp]
  0070d	b9 01 00 00 00	 mov	 ecx, 1
  00712	89 8c 24 b4 00
	00 00		 mov	 DWORD PTR tv515[rsp], ecx
  00719	0f b6 c8	 movzx	 ecx, al
  0071c	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv515[rsp]
  00723	d3 e0		 shl	 eax, cl
  00725	89 44 24 58	 mov	 DWORD PTR left$[rsp], eax
$LN13@inflate_ta:

; 271  :             while (curr + drop < max) {

  00729	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  0072d	8b 4c 24 48	 mov	 ecx, DWORD PTR curr$[rsp]
  00731	03 c8		 add	 ecx, eax
  00733	8b c1		 mov	 eax, ecx
  00735	3b 84 24 98 00
	00 00		 cmp	 eax, DWORD PTR max$[rsp]
  0073c	73 3d		 jae	 SHORT $LN12@inflate_ta

; 272  :                 left -= count[curr + drop];

  0073e	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  00742	8b 4c 24 48	 mov	 ecx, DWORD PTR curr$[rsp]
  00746	03 c8		 add	 ecx, eax
  00748	8b c1		 mov	 eax, ecx
  0074a	8b c0		 mov	 eax, eax
  0074c	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  00750	8b 4c 24 58	 mov	 ecx, DWORD PTR left$[rsp]
  00754	2b c8		 sub	 ecx, eax
  00756	8b c1		 mov	 eax, ecx
  00758	89 44 24 58	 mov	 DWORD PTR left$[rsp], eax

; 273  :                 if (left <= 0) break;

  0075c	83 7c 24 58 00	 cmp	 DWORD PTR left$[rsp], 0
  00761	7f 02		 jg	 SHORT $LN11@inflate_ta
  00763	eb 16		 jmp	 SHORT $LN12@inflate_ta
$LN11@inflate_ta:

; 274  :                 curr++;

  00765	8b 44 24 48	 mov	 eax, DWORD PTR curr$[rsp]
  00769	ff c0		 inc	 eax
  0076b	89 44 24 48	 mov	 DWORD PTR curr$[rsp], eax

; 275  :                 left <<= 1;

  0076f	8b 44 24 58	 mov	 eax, DWORD PTR left$[rsp]
  00773	d1 e0		 shl	 eax, 1
  00775	89 44 24 58	 mov	 DWORD PTR left$[rsp], eax

; 276  :             }

  00779	eb ae		 jmp	 SHORT $LN13@inflate_ta
$LN12@inflate_ta:

; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  0077b	8b 44 24 48	 mov	 eax, DWORD PTR curr$[rsp]
  0077f	b9 01 00 00 00	 mov	 ecx, 1
  00784	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv525[rsp], ecx
  0078b	0f b6 c8	 movzx	 ecx, al
  0078e	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv525[rsp]
  00795	d3 e0		 shl	 eax, cl
  00797	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR used$[rsp]
  0079e	03 c8		 add	 ecx, eax
  007a0	8b c1		 mov	 eax, ecx
  007a2	89 84 24 94 00
	00 00		 mov	 DWORD PTR used$[rsp], eax

; 280  :             if ((type == LENS && used >= ENOUGH_LENS) ||
; 281  :                 (type == DISTS && used >= ENOUGH_DISTS))

  007a9	83 bc 24 d0 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  007b1	75 0d		 jne	 SHORT $LN8@inflate_ta
  007b3	81 bc 24 94 00
	00 00 54 03 00
	00		 cmp	 DWORD PTR used$[rsp], 852 ; 00000354H
  007be	73 17		 jae	 SHORT $LN9@inflate_ta
$LN8@inflate_ta:
  007c0	83 bc 24 d0 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  007c8	75 17		 jne	 SHORT $LN10@inflate_ta
  007ca	81 bc 24 94 00
	00 00 50 02 00
	00		 cmp	 DWORD PTR used$[rsp], 592 ; 00000250H
  007d5	72 0a		 jb	 SHORT $LN10@inflate_ta
$LN9@inflate_ta:

; 282  :                 return 1;

  007d7	b8 01 00 00 00	 mov	 eax, 1
  007dc	e9 ac 01 00 00	 jmp	 $LN69@inflate_ta
$LN10@inflate_ta:

; 283  : 
; 284  :             /* point entry in root table to sub-table */
; 285  :             low = huff & mask;

  007e1	8b 44 24 40	 mov	 eax, DWORD PTR mask$[rsp]
  007e5	8b 4c 24 38	 mov	 ecx, DWORD PTR huff$[rsp]
  007e9	23 c8		 and	 ecx, eax
  007eb	8b c1		 mov	 eax, ecx
  007ed	89 84 24 90 00
	00 00		 mov	 DWORD PTR low$[rsp], eax

; 286  :             (*table)[low].op = (unsigned char)curr;

  007f4	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR low$[rsp]
  007fb	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00803	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00806	0f b6 54 24 48	 movzx	 edx, BYTE PTR curr$[rsp]
  0080b	88 14 81	 mov	 BYTE PTR [rcx+rax*4], dl

; 287  :             (*table)[low].bits = (unsigned char)root;

  0080e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR low$[rsp]
  00815	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0081d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00820	0f b6 54 24 4c	 movzx	 edx, BYTE PTR root$[rsp]
  00825	88 54 81 01	 mov	 BYTE PTR [rcx+rax*4+1], dl

; 288  :             (*table)[low].val = (unsigned short)(next - *table);

  00829	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00831	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00834	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00839	48 2b c8	 sub	 rcx, rax
  0083c	48 8b c1	 mov	 rax, rcx
  0083f	48 c1 f8 02	 sar	 rax, 2
  00843	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR low$[rsp]
  0084a	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR table$[rsp]
  00852	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00855	66 89 44 8a 02	 mov	 WORD PTR [rdx+rcx*4+2], ax
$LN15@inflate_ta:

; 289  :         }
; 290  :     }

  0085a	e9 25 fc ff ff	 jmp	 $LN30@inflate_ta
$LN29@inflate_ta:

; 291  : 
; 292  :     /*
; 293  :        Fill in rest of table for incomplete codes.  This loop is similar to the
; 294  :        loop above in incrementing huff for table indices.  It is assumed that
; 295  :        len is equal to curr + drop, so there is no loop needed to increment
; 296  :        through high index bits.  When the current sub-table is filled, the loop
; 297  :        drops back to the root table to fill in any remaining entries there.
; 298  :      */
; 299  :     here.op = (unsigned char)64;                /* invalid code marker */

  0085f	c6 44 24 20 40	 mov	 BYTE PTR here$[rsp], 64	; 00000040H

; 300  :     here.bits = (unsigned char)(len - drop);

  00864	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  00868	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$[rsp]
  0086c	2b c8		 sub	 ecx, eax
  0086e	8b c1		 mov	 eax, ecx
  00870	88 44 24 21	 mov	 BYTE PTR here$[rsp+1], al

; 301  :     here.val = (unsigned short)0;

  00874	33 c0		 xor	 eax, eax
  00876	66 89 44 24 22	 mov	 WORD PTR here$[rsp+2], ax
$LN7@inflate_ta:

; 302  :     while (huff != 0) {

  0087b	83 7c 24 38 00	 cmp	 DWORD PTR huff$[rsp], 0
  00880	0f 84 d6 00 00
	00		 je	 $LN6@inflate_ta

; 303  :         /* when done with sub-table, drop back to root table */
; 304  :         if (drop != 0 && (huff & mask) != low) {

  00886	83 7c 24 44 00	 cmp	 DWORD PTR drop$[rsp], 0
  0088b	74 3e		 je	 SHORT $LN5@inflate_ta
  0088d	8b 44 24 40	 mov	 eax, DWORD PTR mask$[rsp]
  00891	8b 4c 24 38	 mov	 ecx, DWORD PTR huff$[rsp]
  00895	23 c8		 and	 ecx, eax
  00897	8b c1		 mov	 eax, ecx
  00899	3b 84 24 90 00
	00 00		 cmp	 eax, DWORD PTR low$[rsp]
  008a0	74 29		 je	 SHORT $LN5@inflate_ta

; 305  :             drop = 0;

  008a2	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR drop$[rsp], 0

; 306  :             len = root;

  008aa	8b 44 24 4c	 mov	 eax, DWORD PTR root$[rsp]
  008ae	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax

; 307  :             next = *table;

  008b2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  008ba	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008bd	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 308  :             here.bits = (unsigned char)len;

  008c2	0f b6 44 24 5c	 movzx	 eax, BYTE PTR len$[rsp]
  008c7	88 44 24 21	 mov	 BYTE PTR here$[rsp+1], al
$LN5@inflate_ta:

; 309  :         }
; 310  : 
; 311  :         /* put invalid code marker in table */
; 312  :         next[huff >> drop] = here;

  008cb	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  008cf	0f b6 c8	 movzx	 ecx, al
  008d2	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  008d6	d3 e8		 shr	 eax, cl
  008d8	8b c0		 mov	 eax, eax
  008da	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  008df	8b 54 24 20	 mov	 edx, DWORD PTR here$[rsp]
  008e3	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 313  : 
; 314  :         /* backwards increment the len-bit code huff */
; 315  :         incr = 1U << (len - 1);

  008e6	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  008ea	ff c8		 dec	 eax
  008ec	b9 01 00 00 00	 mov	 ecx, 1
  008f1	89 8c 24 bc 00
	00 00		 mov	 DWORD PTR tv553[rsp], ecx
  008f8	0f b6 c8	 movzx	 ecx, al
  008fb	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv553[rsp]
  00902	d3 e0		 shl	 eax, cl
  00904	89 44 24 64	 mov	 DWORD PTR incr$[rsp], eax
$LN4@inflate_ta:

; 316  :         while (huff & incr)

  00908	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  0090c	8b 4c 24 38	 mov	 ecx, DWORD PTR huff$[rsp]
  00910	23 c8		 and	 ecx, eax
  00912	8b c1		 mov	 eax, ecx
  00914	85 c0		 test	 eax, eax
  00916	74 0c		 je	 SHORT $LN3@inflate_ta

; 317  :             incr >>= 1;

  00918	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  0091c	d1 e8		 shr	 eax, 1
  0091e	89 44 24 64	 mov	 DWORD PTR incr$[rsp], eax
  00922	eb e4		 jmp	 SHORT $LN4@inflate_ta
$LN3@inflate_ta:

; 318  :         if (incr != 0) {

  00924	83 7c 24 64 00	 cmp	 DWORD PTR incr$[rsp], 0
  00929	74 24		 je	 SHORT $LN2@inflate_ta

; 319  :             huff &= incr - 1;

  0092b	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  0092f	ff c8		 dec	 eax
  00931	8b 4c 24 38	 mov	 ecx, DWORD PTR huff$[rsp]
  00935	23 c8		 and	 ecx, eax
  00937	8b c1		 mov	 eax, ecx
  00939	89 44 24 38	 mov	 DWORD PTR huff$[rsp], eax

; 320  :             huff += incr;

  0093d	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  00941	8b 4c 24 38	 mov	 ecx, DWORD PTR huff$[rsp]
  00945	03 c8		 add	 ecx, eax
  00947	8b c1		 mov	 eax, ecx
  00949	89 44 24 38	 mov	 DWORD PTR huff$[rsp], eax

; 321  :         }
; 322  :         else

  0094d	eb 08		 jmp	 SHORT $LN1@inflate_ta
$LN2@inflate_ta:

; 323  :             huff = 0;

  0094f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0
$LN1@inflate_ta:

; 324  :     }

  00957	e9 1f ff ff ff	 jmp	 $LN7@inflate_ta
$LN6@inflate_ta:

; 325  : 
; 326  :     /* set return parameters */
; 327  :     *table += used;

  0095c	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR used$[rsp]
  00963	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0096b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0096e	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00972	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0097a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 328  :     *bits = root;

  0097d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR bits$[rsp]
  00985	8b 4c 24 4c	 mov	 ecx, DWORD PTR root$[rsp]
  00989	89 08		 mov	 DWORD PTR [rax], ecx

; 329  :     return 0;

  0098b	33 c0		 xor	 eax, eax
$LN69@inflate_ta:

; 330  : }

  0098d	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00994	c3		 ret	 0
inflate_table ENDP
_TEXT	ENDS
END
