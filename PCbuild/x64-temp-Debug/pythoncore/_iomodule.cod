; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_02KFNNKBCK@io?$AA@			; `string'
PUBLIC	??_C@_04PMOCAHAA@open?$AA@			; `string'
PUBLIC	??_C@_04GMGOKAFF@mode?$AA@			; `string'
PUBLIC	??_C@_06FFBIALPD@fileno?$AA@			; `string'
PUBLIC	??_C@_06BMABDNNN@isatty?$AA@			; `string'
PUBLIC	_PyIO_Module
_DATA	SEGMENT
COMM	_PyIO_zero:QWORD
COMM	_PyIO_str_write:QWORD
COMM	_PyIO_empty_bytes:QWORD
COMM	_PyIO_str_reset:QWORD
COMM	_PyIO_str_readline:QWORD
COMM	_PyIO_str_readall:QWORD
COMM	_PyIO_str_encode:QWORD
COMM	_PyIO_str_readable:QWORD
COMM	_PyIO_str_close:QWORD
COMM	_PyIO_str_decode:QWORD
COMM	_PyIO_empty_str:QWORD
COMM	_PyIO_str_newlines:QWORD
COMM	_PyIO_str_seek:QWORD
COMM	_PyIO_str_writable:QWORD
COMM	_PyIO_str_seekable:QWORD
COMM	_PyIO_str_closed:QWORD
COMM	_PyIO_str_flush:QWORD
COMM	_PyIO_str_readinto:QWORD
COMM	_PyIO_str_fileno:QWORD
COMM	_PyIO_str_setstate:QWORD
COMM	_PyIO_str_truncate:QWORD
COMM	_PyIO_str_isatty:QWORD
COMM	_PyIO_str_read1:QWORD
COMM	_PyIO_str_tell:QWORD
COMM	_PyIO_str_getstate:QWORD
COMM	_PyIO_str_nl:QWORD
COMM	_PyIO_str_read:QWORD
_DATA	ENDS
;	COMDAT ??_C@_02KFNNKBCK@io?$AA@
CONST	SEGMENT
??_C@_02KFNNKBCK@io?$AA@ DB 'io', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open?$AA@
CONST	SEGMENT
??_C@_04PMOCAHAA@open?$AA@ DB 'open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMGOKAFF@mode?$AA@
CONST	SEGMENT
??_C@_04GMGOKAFF@mode?$AA@ DB 'mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFBIALPD@fileno?$AA@
CONST	SEGMENT
??_C@_06FFBIALPD@fileno?$AA@ DB 'fileno', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_mode@?1??io_open@@9@9 DQ 0000000000000000H	; `io_open'::`2'::PyId_mode
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	0000000000000000H
?PyId_fileno@?1??io_open@@9@9 DQ 0000000000000000H	; `io_open'::`2'::PyId_fileno
	DQ	FLAT:??_C@_06FFBIALPD@fileno?$AA@
	DQ	0000000000000000H
?PyId_isatty@?1??io_open@@9@9 DQ 0000000000000000H	; `io_open'::`2'::PyId_isatty
	DQ	FLAT:??_C@_06BMABDNNN@isatty?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_06BMABDNNN@isatty?$AA@
CONST	SEGMENT
??_C@_06BMABDNNN@isatty?$AA@ DB 'isatty', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
module_doc DB	'The io module provides the Python interfaces to stream h'
	DB	'andling. The', 0aH, 'builtin open function is defined in this'
	DB	' module.', 0aH, 0aH, 'At the top of the I/O hierarchy is the '
	DB	'abstract base class IOBase. It', 0aH, 'defines the basic inte'
	DB	'rface to a stream. Note, however, that there is no', 0aH, 'se'
	DB	'paration between reading and writing to streams; implementati'
	DB	'ons are', 0aH, 'allowed to raise an IOError if they do not su'
	DB	'pport a given operation.', 0aH, 0aH, 'Extending IOBase is Raw'
	DB	'IOBase which deals simply with the reading and', 0aH, 'writin'
	DB	'g of raw bytes to a stream. FileIO subclasses RawIOBase to pr'
	DB	'ovide', 0aH, 'an interface to OS files.', 0aH, 0aH, 'Buffered'
	DB	'IOBase deals with buffering on a raw byte stream (RawIOBase).'
	DB	' Its', 0aH, 'subclasses, BufferedWriter, BufferedReader, and '
	DB	'BufferedRWPair buffer', 0aH, 'streams that are readable, writ'
	DB	'able, and both respectively.', 0aH, 'BufferedRandom provides '
	DB	'a buffered interface to random access', 0aH, 'streams. BytesI'
	DB	'O is a simple stream of in-memory bytes.', 0aH, 0aH, 'Another'
	DB	' IOBase subclass, TextIOBase, deals with the encoding and dec'
	DB	'oding', 0aH, 'of streams into text. TextIOWrapper, which exte'
	DB	'nds it, is a buffered text', 0aH, 'interface to a buffered ra'
	DB	'w stream (`BufferedIOBase`). Finally, StringIO', 0aH, 'is a i'
	DB	'n-memory stream for text.', 0aH, 0aH, 'Argument names are not'
	DB	' part of the specification, and only the arguments', 0aH, 'of'
	DB	' open() are intended to be used as keyword arguments.', 0aH, 0aH
	DB	'data:', 0aH, 0aH, 'DEFAULT_BUFFER_SIZE', 0aH, 0aH, '   An int'
	DB	' containing the default buffer size used by the module''s buf'
	DB	'fered', 0aH, '   I/O classes. open() uses the file''s blksize'
	DB	' (as obtained by os.stat) if', 0aH, '   possible.', 0aH, 00H
	ORG $+15
open_doc DB	'open(file, mode=''r'', buffering=-1, encoding=None,', 0aH
	DB	'     errors=None, newline=None, closefd=True, opener=None) ->'
	DB	' file object', 0aH, 0aH, 'Open file and return a stream.  Rai'
	DB	'se IOError upon failure.', 0aH, 0aH, 'file is either a text o'
	DB	'r byte string giving the name (and the path', 0aH, 'if the fi'
	DB	'le isn''t in the current working directory) of the file to', 0aH
	DB	'be opened or an integer file descriptor of the file to be', 0aH
	DB	'wrapped. (If a file descriptor is given, it is closed when th'
	DB	'e', 0aH, 'returned I/O object is closed, unless closefd is se'
	DB	't to False.)', 0aH, 0aH, 'mode is an optional string that spe'
	DB	'cifies the mode in which the file', 0aH, 'is opened. It defau'
	DB	'lts to ''r'' which means open for reading in text', 0aH, 'mod'
	DB	'e.  Other common values are ''w'' for writing (truncating the'
	DB	' file if', 0aH, 'it already exists), ''x'' for creating and w'
	DB	'riting to a new file, and', 0aH, '''a'' for appending (which '
	DB	'on some Unix systems, means that all writes', 0aH, 'append to'
	DB	' the end of the file regardless of the current seek position)'
	DB	'.', 0aH, 'In text mode, if encoding is not specified the enco'
	DB	'ding used is platform', 0aH, 'dependent: locale.getpreferrede'
	DB	'ncoding(False) is called to get the', 0aH, 'current locale en'
	DB	'coding. (For reading and writing raw bytes use binary', 0aH, 'm'
	DB	'ode and leave encoding unspecified.) The available modes are:'
	DB	0aH, 0aH, '========= ========================================='
	DB	'======================', 0aH, 'Character Meaning', 0aH, '----'
	DB	'----- -------------------------------------------------------'
	DB	'--------', 0aH, '''r''       open for reading (default)', 0aH
	DB	'''w''       open for writing, truncating the file first', 0aH
	DB	'''x''       create a new file and open it for writing', 0aH, ''''
	DB	'a''       open for writing, appending to the end of the file '
	DB	'if it exists', 0aH, '''b''       binary mode', 0aH, '''t''   '
	DB	'    text mode (default)', 0aH, '''+''       open a disk file '
	DB	'for updating (reading and writing)', 0aH, '''U''       univer'
	DB	'sal newline mode (for backwards compatibility; unneeded', 0aH
	DB	'          for new code)', 0aH, '========= ==================='
	DB	'============================================', 0aH, 0aH, 'The'
	DB	' default mode is ''rt'' (open for reading text). For binary r'
	DB	'andom', 0aH, 'access, the mode ''w+b'' opens and truncates th'
	DB	'e file to 0 bytes, while', 0aH, '''r+b'' opens the file witho'
	DB	'ut truncation. The ''x'' mode implies ''w'' and', 0aH, 'raise'
	DB	's an `FileExistsError` if the file already exists.', 0aH, 0aH
	DB	'Python distinguishes between files opened in binary and text '
	DB	'modes,', 0aH, 'even when the underlying operating system does'
	DB	'n''t. Files opened in', 0aH, 'binary mode (appending ''b'' to'
	DB	' the mode argument) return contents as', 0aH, 'bytes objects '
	DB	'without any decoding. In text mode (the default, or when', 0aH
	DB	'''t'' is appended to the mode argument), the contents of the '
	DB	'file are', 0aH, 'returned as strings, the bytes having been f'
	DB	'irst decoded using a', 0aH, 'platform-dependent encoding or u'
	DB	'sing the specified encoding if given.', 0aH, 0aH, 'buffering '
	DB	'is an optional integer used to set the buffering policy.', 0aH
	DB	'Pass 0 to switch buffering off (only allowed in binary mode),'
	DB	' 1 to select', 0aH, 'line buffering (only usable in text mode'
	DB	'), and an integer > 1 to indicate', 0aH, 'the size of a fixed'
	DB	'-size chunk buffer.  When no buffering argument is', 0aH, 'gi'
	DB	'ven, the default buffering policy works as follows:', 0aH, 0aH
	DB	'* Binary files are buffered in fixed-size chunks; the size of'
	DB	' the buffer', 0aH, '  is chosen using a heuristic trying to d'
	DB	'etermine the underlying device''s', 0aH, '  "block size" and '
	DB	'falling back on `io.DEFAULT_BUFFER_SIZE`.', 0aH, '  On many s'
	DB	'ystems, the buffer will typically be 4096 or 8192 bytes long.'
	DB	0aH, 0aH, '* "Interactive" text files (files for which isatty('
	DB	') returns True)', 0aH, '  use line buffering.  Other text fil'
	DB	'es use the policy described above', 0aH, '  for binary files.'
	DB	0aH, 0aH, 'encoding is the name of the encoding used to decode'
	DB	' or encode the', 0aH, 'file. This should only be used in text'
	DB	' mode. The default encoding is', 0aH, 'platform dependent, bu'
	DB	't any encoding supported by Python can be', 0aH, 'passed.  Se'
	DB	'e the codecs module for the list of supported encodings.', 0aH
	DB	0aH, 'errors is an optional string that specifies how encoding'
	DB	' errors are to', 0aH, 'be handled---this argument should not '
	DB	'be used in binary mode. Pass', 0aH, '''strict'' to raise a Va'
	DB	'lueError exception if there is an encoding error', 0aH, '(the'
	DB	' default of None has the same effect), or pass ''ignore'' to '
	DB	'ignore', 0aH, 'errors. (Note that ignoring encoding errors ca'
	DB	'n lead to data loss.)', 0aH, 'See the documentation for codec'
	DB	's.register or run ''help(codecs.Codec)''', 0aH, 'for a list o'
	DB	'f the permitted encoding error strings.', 0aH, 0aH, 'newline '
	DB	'controls how universal newlines works (it only applies to tex'
	DB	't', 0aH, 'mode). It can be None, '''', ''\n'', ''\r'', and '''
	DB	'\r\n''.  It works as', 0aH, 'follows:', 0aH, 0aH, '* On input'
	DB	', if newline is None, universal newlines mode is', 0aH, '  en'
	DB	'abled. Lines in the input can end in ''\n'', ''\r'', or ''\r\'
	DB	'n'', and', 0aH, '  these are translated into ''\n'' before be'
	DB	'ing returned to the', 0aH, '  caller. If it is '''', universa'
	DB	'l newline mode is enabled, but line', 0aH, '  endings are ret'
	DB	'urned to the caller untranslated. If it has any of', 0aH, '  '
	DB	'the other legal values, input lines are only terminated by th'
	DB	'e given', 0aH, '  string, and the line ending is returned to '
	DB	'the caller untranslated.', 0aH, 0aH, '* On output, if newline'
	DB	' is None, any ''\n'' characters written are', 0aH, '  transla'
	DB	'ted to the system default line separator, os.linesep. If', 0aH
	DB	'  newline is '''' or ''\n'', no translation takes place. If n'
	DB	'ewline is any', 0aH, '  of the other legal values, any ''\n'''
	DB	' characters written are translated', 0aH, '  to the given str'
	DB	'ing.', 0aH, 0aH, 'If closefd is False, the underlying file de'
	DB	'scriptor will be kept open', 0aH, 'when the file is closed. T'
	DB	'his does not work when a file name is given', 0aH, 'and must '
	DB	'be True in that case.', 0aH, 0aH, 'A custom opener can be use'
	DB	'd by passing a callable as *opener*. The', 0aH, 'underlying f'
	DB	'ile descriptor for the file object is then obtained by', 0aH, 'c'
	DB	'alling *opener* with (*file*, *flags*). *opener* must return '
	DB	'an open', 0aH, 'file descriptor (passing os.open as *opener* '
	DB	'results in functionality', 0aH, 'similar to passing None).', 0aH
	DB	0aH, 'open() returns a file object whose type depends on the m'
	DB	'ode, and', 0aH, 'through which the standard file operations s'
	DB	'uch as reading and writing', 0aH, 'are performed. When open()'
	DB	' is used to open a file in a text mode (''w'',', 0aH, '''r'','
	DB	' ''wt'', ''rt'', etc.), it returns a TextIOWrapper. When used'
	DB	' to open', 0aH, 'a file in a binary mode, the returned class '
	DB	'varies: in read binary', 0aH, 'mode, it returns a BufferedRea'
	DB	'der; in write binary and append binary', 0aH, 'modes, it retu'
	DB	'rns a BufferedWriter, and in read/write mode, it returns', 0aH
	DB	'a BufferedRandom.', 0aH, 0aH, 'It is also possible to use a s'
	DB	'tring or bytearray as a file for both', 0aH, 'reading and wri'
	DB	'ting. For strings StringIO can be used like a file', 0aH, 'op'
	DB	'ened in a text mode, and for bytes a BytesIO can be used like'
	DB	' a file', 0aH, 'opened in a binary mode.', 0aH, 00H
	ORG $+13
module_methods DQ FLAT:??_C@_04PMOCAHAA@open?$AA@
	DQ	FLAT:io_open
	DD	03H
	ORG $+4
	DQ	FLAT:open_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
_PyIO_Module DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_02KFNNKBCK@io?$AA@
	DQ	FLAT:module_doc
	DQ	0000000000000018H
	DQ	FLAT:module_methods
	DQ	0000000000000000H
	DQ	FLAT:iomodule_traverse
	DQ	FLAT:iomodule_clear
	DQ	FLAT:iomodule_free
_DATA	ENDS
PUBLIC	??_C@_05JFEDHFGP@Osssi?$AA@			; `string'
PUBLIC	??_C@_07BAGABCMK@io_open?$AA@			; `string'
PUBLIC	??_C@_0BL@KHFLOKNA@?4?4?2Modules?2_io?2_iomodule?4c?$AA@ ; `string'
PUBLIC	??_C@_02MPEHDMPO@Oi?$AA@			; `string'
PUBLIC	??_C@_0BD@HGCBKHPL@unknown?5mode?3?5?8?$CFs?8?$AA@ ; `string'
PUBLIC	??_C@_0BP@PHGBMNHL@can?8t?5have?5unbuffered?5text?5I?1O?$AA@ ; `string'
PUBLIC	??_C@_0BH@HEILGHFA@invalid?5buffering?5size?$AA@ ; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_04KKBDGLGN@OsiO?$AA@			; `string'
PUBLIC	??_C@_0CM@OMAPNBPG@binary?5mode?5doesn?8t?5take?5a?5newli@ ; `string'
PUBLIC	??_C@_0CM@CCNHIIDC@binary?5mode?5doesn?8t?5take?5an?5erro@ ; `string'
PUBLIC	??_C@_0CO@CAFNFBNN@binary?5mode?5doesn?8t?5take?5an?5enco@ ; `string'
PUBLIC	??_C@_0DH@EAEIFFCJ@must?5have?5exactly?5one?5of?5create?1@ ; `string'
PUBLIC	??_C@_0CI@NLGHEIMK@can?8t?5have?5text?5and?5binary?5mode?5@ ; `string'
PUBLIC	??_C@_0CF@EBAHAMKP@can?8t?5use?5U?5and?5writing?5mode?5at?5@ ; `string'
PUBLIC	??_C@_0BD@IIKELEHA@invalid?5mode?3?5?8?$CFs?8?$AA@ ; `string'
PUBLIC	??_C@_0BB@IPEMFKOI@invalid?5file?3?5?$CFR?$AA@	; `string'
PUBLIC	??_C@_0P@EBFCODAH@O?$HMsizzziO?3open?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_06MNHBHLPO@opener?$AA@			; `string'
PUBLIC	??_C@_07IOEMJIMP@closefd?$AA@			; `string'
PUBLIC	??_C@_07NADKJHCJ@newline?$AA@			; `string'
PUBLIC	??_C@_06EOMHCNPI@errors?$AA@			; `string'
PUBLIC	??_C@_08MLPGAEIK@encoding?$AA@			; `string'
PUBLIC	??_C@_09HIEBJLDI@buffering?$AA@			; `string'
PUBLIC	??_C@_04DAMGJPCA@file?$AA@			; `string'
EXTRN	_PyObject_SetAttrId:PROC
EXTRN	PyTextIOWrapper_Type:BYTE
EXTRN	_PyParallel_Guard:PROC
EXTRN	PyBufferedReader_Type:BYTE
EXTRN	PyBufferedWriter_Type:BYTE
EXTRN	PyBufferedRandom_Type:BYTE
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsLong:PROC
EXTRN	_PyObject_CallMethodId_SizeT:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	_PyObject_CallFunction_SizeT:PROC
EXTRN	PyFileIO_Type:BYTE
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	__imp_strchr:PROC
EXTRN	__ImageBase:BYTE
EXTRN	strlen:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyNumber_Check:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\_io\_iomodule.c
pdata	SEGMENT
$pdata$io_open DD imagerel io_open
	DD	imagerel io_open+2822
	DD	imagerel $unwind$io_open
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$io_open DD 021601H
	DD	0330116H
xdata	ENDS
;	COMDAT ??_C@_05JFEDHFGP@Osssi?$AA@
CONST	SEGMENT
??_C@_05JFEDHFGP@Osssi?$AA@ DB 'Osssi', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BAGABCMK@io_open?$AA@
CONST	SEGMENT
??_C@_07BAGABCMK@io_open?$AA@ DB 'io_open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KHFLOKNA@?4?4?2Modules?2_io?2_iomodule?4c?$AA@
CONST	SEGMENT
??_C@_0BL@KHFLOKNA@?4?4?2Modules?2_io?2_iomodule?4c?$AA@ DB '..\Modules\_'
	DB	'io\_iomodule.c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MPEHDMPO@Oi?$AA@
CONST	SEGMENT
??_C@_02MPEHDMPO@Oi?$AA@ DB 'Oi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HGCBKHPL@unknown?5mode?3?5?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0BD@HGCBKHPL@unknown?5mode?3?5?8?$CFs?8?$AA@ DB 'unknown mode: ''%s'
	DB	'''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PHGBMNHL@can?8t?5have?5unbuffered?5text?5I?1O?$AA@
CONST	SEGMENT
??_C@_0BP@PHGBMNHL@can?8t?5have?5unbuffered?5text?5I?1O?$AA@ DB 'can''t h'
	DB	'ave unbuffered text I/O', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HEILGHFA@invalid?5buffering?5size?$AA@
CONST	SEGMENT
??_C@_0BH@HEILGHFA@invalid?5buffering?5size?$AA@ DB 'invalid buffering si'
	DB	'ze', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04KKBDGLGN@OsiO?$AA@
CONST	SEGMENT
??_C@_04KKBDGLGN@OsiO?$AA@ DB 'OsiO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OMAPNBPG@binary?5mode?5doesn?8t?5take?5a?5newli@
CONST	SEGMENT
??_C@_0CM@OMAPNBPG@binary?5mode?5doesn?8t?5take?5a?5newli@ DB 'binary mod'
	DB	'e doesn''t take a newline argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CCNHIIDC@binary?5mode?5doesn?8t?5take?5an?5erro@
CONST	SEGMENT
??_C@_0CM@CCNHIIDC@binary?5mode?5doesn?8t?5take?5an?5erro@ DB 'binary mod'
	DB	'e doesn''t take an errors argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CAFNFBNN@binary?5mode?5doesn?8t?5take?5an?5enco@
CONST	SEGMENT
??_C@_0CO@CAFNFBNN@binary?5mode?5doesn?8t?5take?5an?5enco@ DB 'binary mod'
	DB	'e doesn''t take an encoding argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EAEIFFCJ@must?5have?5exactly?5one?5of?5create?1@
CONST	SEGMENT
??_C@_0DH@EAEIFFCJ@must?5have?5exactly?5one?5of?5create?1@ DB 'must have '
	DB	'exactly one of create/read/write/append mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NLGHEIMK@can?8t?5have?5text?5and?5binary?5mode?5@
CONST	SEGMENT
??_C@_0CI@NLGHEIMK@can?8t?5have?5text?5and?5binary?5mode?5@ DB 'can''t ha'
	DB	've text and binary mode at once', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EBAHAMKP@can?8t?5use?5U?5and?5writing?5mode?5at?5@
CONST	SEGMENT
??_C@_0CF@EBAHAMKP@can?8t?5use?5U?5and?5writing?5mode?5at?5@ DB 'can''t u'
	DB	'se U and writing mode at once', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IIKELEHA@invalid?5mode?3?5?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0BD@IIKELEHA@invalid?5mode?3?5?8?$CFs?8?$AA@ DB 'invalid mode: ''%s'
	DB	'''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IPEMFKOI@invalid?5file?3?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BB@IPEMFKOI@invalid?5file?3?5?$CFR?$AA@ DB 'invalid file: %R', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EBFCODAH@O?$HMsizzziO?3open?$AA@
CONST	SEGMENT
??_C@_0P@EBFCODAH@O?$HMsizzziO?3open?$AA@ DB 'O|sizzziO:open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNHBHLPO@opener?$AA@
CONST	SEGMENT
??_C@_06MNHBHLPO@opener?$AA@ DB 'opener', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IOEMJIMP@closefd?$AA@
CONST	SEGMENT
??_C@_07IOEMJIMP@closefd?$AA@ DB 'closefd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NADKJHCJ@newline?$AA@
CONST	SEGMENT
??_C@_07NADKJHCJ@newline?$AA@ DB 'newline', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOMHCNPI@errors?$AA@
CONST	SEGMENT
??_C@_06EOMHCNPI@errors?$AA@ DB 'errors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPGAEIK@encoding?$AA@
CONST	SEGMENT
??_C@_08MLPGAEIK@encoding?$AA@ DB 'encoding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HIEBJLDI@buffering?$AA@
CONST	SEGMENT
??_C@_09HIEBJLDI@buffering?$AA@ DB 'buffering', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAMGJPCA@file?$AA@
CONST	SEGMENT
??_C@_04DAMGJPCA@file?$AA@ DB 'file', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT io_open
_TEXT	SEGMENT
rawmode$ = 96
kwlist$ = 112
text$ = 192
creating$ = 196
buffering$ = 200
updating$ = 204
raw$ = 208
line_buffering$ = 216
i$ = 220
newline$ = 224
mode$ = 232
errors$ = 240
closefd$ = 248
isatty$ = 252
file$ = 256
wrapper$ = 264
appending$ = 272
encoding$ = 280
universal$ = 288
reading$ = 292
modeobj$ = 296
buffer$ = 304
writing$ = 312
m$ = 320
binary$ = 328
opener$ = 336
c$20517 = 344
res$20571 = 352
Buffered_class$20587 = 360
_py_tmp$20606 = 368
_py_tmp$20620 = 376
tv93 = 384
tv164 = 392
self$ = 416
args$ = 424
kwds$ = 432
io_open	PROC						; COMDAT

; 219  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H

; 220  :     char *kwlist[] = {"file", "mode", "buffering",

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04DAMGJPCA@file?$AA@
  0001d	48 89 44 24 70	 mov	 QWORD PTR kwlist$[rsp], rax
  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04GMGOKAFF@mode?$AA@
  00029	48 89 44 24 78	 mov	 QWORD PTR kwlist$[rsp+8], rax
  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09HIEBJLDI@buffering?$AA@
  00035	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR kwlist$[rsp+16], rax

; 221  :                       "encoding", "errors", "newline",

  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08MLPGAEIK@encoding?$AA@
  00044	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR kwlist$[rsp+24], rax
  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06EOMHCNPI@errors?$AA@
  00053	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR kwlist$[rsp+32], rax
  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07NADKJHCJ@newline?$AA@
  00062	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR kwlist$[rsp+40], rax

; 222  :                       "closefd", "opener", NULL};

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07IOEMJIMP@closefd?$AA@
  00071	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR kwlist$[rsp+48], rax
  00079	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06MNHBHLPO@opener?$AA@
  00080	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR kwlist$[rsp+56], rax
  00088	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR kwlist$[rsp+64], 0

; 223  :     PyObject *file, *opener = Py_None;

  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0009b	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR opener$[rsp], rax

; 224  :     char *mode = "r";

  000a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
  000aa	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR mode$[rsp], rax

; 225  :     int buffering = -1, closefd = 1;

  000b2	c7 84 24 c8 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR buffering$[rsp], -1
  000bd	c7 84 24 f8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR closefd$[rsp], 1

; 226  :     char *encoding = NULL, *errors = NULL, *newline = NULL;

  000c8	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR encoding$[rsp], 0
  000d4	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR errors$[rsp], 0
  000e0	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR newline$[rsp], 0

; 227  :     unsigned i;
; 228  : 
; 229  :     int creating = 0, reading = 0, writing = 0, appending = 0, updating = 0;

  000ec	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR creating$[rsp], 0
  000f7	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR reading$[rsp], 0
  00102	c7 84 24 38 01
	00 00 00 00 00
	00		 mov	 DWORD PTR writing$[rsp], 0
  0010d	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR appending$[rsp], 0
  00118	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR updating$[rsp], 0

; 230  :     int text = 0, binary = 0, universal = 0;

  00123	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR text$[rsp], 0
  0012e	c7 84 24 48 01
	00 00 00 00 00
	00		 mov	 DWORD PTR binary$[rsp], 0
  00139	c7 84 24 20 01
	00 00 00 00 00
	00		 mov	 DWORD PTR universal$[rsp], 0

; 231  : 
; 232  :     char rawmode[6], *m;
; 233  :     int line_buffering, isatty;
; 234  : 
; 235  :     PyObject *raw, *modeobj = NULL, *buffer = NULL, *wrapper = NULL;

  00144	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR modeobj$[rsp], 0
  00150	48 c7 84 24 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR buffer$[rsp], 0
  0015c	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR wrapper$[rsp], 0

; 236  : 
; 237  :     _Py_IDENTIFIER(isatty);
; 238  :     _Py_IDENTIFIER(fileno);
; 239  :     _Py_IDENTIFIER(mode);
; 240  : 
; 241  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|sizzziO:open", kwlist,
; 242  :                                      &file, &mode, &buffering,
; 243  :                                      &encoding, &errors, &newline,
; 244  :                                      &closefd, &opener)) {

  00168	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR opener$[rsp]
  00170	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00175	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR closefd$[rsp]
  0017d	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00182	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR newline$[rsp]
  0018a	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0018f	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR errors$[rsp]
  00197	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0019c	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR encoding$[rsp]
  001a4	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  001a9	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR buffering$[rsp]
  001b1	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001b6	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR mode$[rsp]
  001be	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c3	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR file$[rsp]
  001cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d0	4c 8d 4c 24 70	 lea	 r9, QWORD PTR kwlist$[rsp]
  001d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@EBFCODAH@O?$HMsizzziO?3open?$AA@
  001dc	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  001e4	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  001ec	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  001f1	85 c0		 test	 eax, eax
  001f3	75 07		 jne	 SHORT $LN76@io_open

; 245  :         return NULL;

  001f5	33 c0		 xor	 eax, eax
  001f7	e9 8d 08 00 00	 jmp	 $LN77@io_open
$LN76@io_open:

; 246  :     }
; 247  : 
; 248  :     if (!PyUnicode_Check(file) &&
; 249  : 	!PyBytes_Check(file) &&
; 250  : 	!PyNumber_Check(file)) {

  001fc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR file$[rsp]
  00204	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00208	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0020e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00213	85 c0		 test	 eax, eax
  00215	75 4e		 jne	 SHORT $LN75@io_open
  00217	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR file$[rsp]
  0021f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00223	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00229	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0022e	85 c0		 test	 eax, eax
  00230	75 33		 jne	 SHORT $LN75@io_open
  00232	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0023a	e8 00 00 00 00	 call	 PyNumber_Check
  0023f	85 c0		 test	 eax, eax
  00241	75 22		 jne	 SHORT $LN75@io_open

; 251  :         PyErr_Format(PyExc_TypeError, "invalid file: %R", file);

  00243	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR file$[rsp]
  0024b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@IPEMFKOI@invalid?5file?3?5?$CFR?$AA@
  00252	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00259	e8 00 00 00 00	 call	 PyErr_Format

; 252  :         return NULL;

  0025e	33 c0		 xor	 eax, eax
  00260	e9 24 08 00 00	 jmp	 $LN77@io_open
$LN75@io_open:

; 253  :     }
; 254  : 
; 255  :     /* Decode mode */
; 256  :     for (i = 0; i < strlen(mode); i++) {

  00265	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00270	eb 10		 jmp	 SHORT $LN74@io_open
$LN73@io_open:
  00272	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00279	ff c0		 inc	 eax
  0027b	89 84 24 dc 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN74@io_open:
  00282	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00289	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv93[rsp], rax
  00291	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR mode$[rsp]
  00299	e8 00 00 00 00	 call	 strlen
  0029e	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv93[rsp]
  002a6	48 3b c8	 cmp	 rcx, rax
  002a9	0f 83 30 01 00
	00		 jae	 $LN72@io_open

; 257  :         char c = mode[i];

  002af	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  002b6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR mode$[rsp]
  002be	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c2	88 84 24 58 01
	00 00		 mov	 BYTE PTR c$20517[rsp], al

; 258  : 
; 259  :         switch (c) {

  002c9	0f be 84 24 58
	01 00 00	 movsx	 eax, BYTE PTR c$20517[rsp]
  002d1	89 84 24 88 01
	00 00		 mov	 DWORD PTR tv164[rsp], eax
  002d8	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR tv164[rsp]
  002df	83 e8 2b	 sub	 eax, 43			; 0000002bH
  002e2	89 84 24 88 01
	00 00		 mov	 DWORD PTR tv164[rsp], eax
  002e9	83 bc 24 88 01
	00 00 4d	 cmp	 DWORD PTR tv164[rsp], 77 ; 0000004dH
  002f1	0f 87 96 00 00
	00		 ja	 $LN61@io_open
  002f7	48 63 84 24 88
	01 00 00	 movsxd	 rax, DWORD PTR tv164[rsp]
  002ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00306	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN79@io_open[rcx+rax]
  0030e	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN80@io_open[rcx+rax*4]
  00315	48 03 c1	 add	 rax, rcx
  00318	ff e0		 jmp	 rax
$LN69@io_open:

; 260  :         case 'x':
; 261  :             creating = 1;

  0031a	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR creating$[rsp], 1

; 262  :             break;

  00325	eb 68		 jmp	 SHORT $LN70@io_open
$LN68@io_open:

; 263  :         case 'r':
; 264  :             reading = 1;

  00327	c7 84 24 24 01
	00 00 01 00 00
	00		 mov	 DWORD PTR reading$[rsp], 1

; 265  :             break;

  00332	eb 5b		 jmp	 SHORT $LN70@io_open
$LN67@io_open:

; 266  :         case 'w':
; 267  :             writing = 1;

  00334	c7 84 24 38 01
	00 00 01 00 00
	00		 mov	 DWORD PTR writing$[rsp], 1

; 268  :             break;

  0033f	eb 4e		 jmp	 SHORT $LN70@io_open
$LN66@io_open:

; 269  :         case 'a':
; 270  :             appending = 1;

  00341	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR appending$[rsp], 1

; 271  :             break;

  0034c	eb 41		 jmp	 SHORT $LN70@io_open
$LN65@io_open:

; 272  :         case '+':
; 273  :             updating = 1;

  0034e	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR updating$[rsp], 1

; 274  :             break;

  00359	eb 34		 jmp	 SHORT $LN70@io_open
$LN64@io_open:

; 275  :         case 't':
; 276  :             text = 1;

  0035b	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR text$[rsp], 1

; 277  :             break;

  00366	eb 27		 jmp	 SHORT $LN70@io_open
$LN63@io_open:

; 278  :         case 'b':
; 279  :             binary = 1;

  00368	c7 84 24 48 01
	00 00 01 00 00
	00		 mov	 DWORD PTR binary$[rsp], 1

; 280  :             break;

  00373	eb 1a		 jmp	 SHORT $LN70@io_open
$LN62@io_open:

; 281  :         case 'U':
; 282  :             universal = 1;

  00375	c7 84 24 20 01
	00 00 01 00 00
	00		 mov	 DWORD PTR universal$[rsp], 1

; 283  :             reading = 1;

  00380	c7 84 24 24 01
	00 00 01 00 00
	00		 mov	 DWORD PTR reading$[rsp], 1

; 284  :             break;

  0038b	eb 02		 jmp	 SHORT $LN70@io_open
$LN61@io_open:

; 285  :         default:
; 286  :             goto invalid_mode;

  0038d	eb 29		 jmp	 SHORT $invalid_mode$20531
$LN70@io_open:

; 287  :         }
; 288  : 
; 289  :         /* c must not be duplicated */
; 290  :         if (strchr(mode+i+1, c)) {

  0038f	0f be 84 24 58
	01 00 00	 movsx	 eax, BYTE PTR c$20517[rsp]
  00397	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0039e	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR mode$[rsp]
  003a6	48 8d 4c 0a 01	 lea	 rcx, QWORD PTR [rdx+rcx+1]
  003ab	8b d0		 mov	 edx, eax
  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  003b3	48 85 c0	 test	 rax, rax
  003b6	74 22		 je	 SHORT $LN60@io_open
$invalid_mode$20531:

; 291  :           invalid_mode:
; 292  :             PyErr_Format(PyExc_ValueError, "invalid mode: '%s'", mode);

  003b8	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR mode$[rsp]
  003c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@IIKELEHA@invalid?5mode?3?5?8?$CFs?8?$AA@
  003c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  003ce	e8 00 00 00 00	 call	 PyErr_Format

; 293  :             return NULL;

  003d3	33 c0		 xor	 eax, eax
  003d5	e9 af 06 00 00	 jmp	 $LN77@io_open
$LN60@io_open:

; 294  :         }
; 295  : 
; 296  :     }

  003da	e9 93 fe ff ff	 jmp	 $LN73@io_open
$LN72@io_open:

; 297  : 
; 298  :     m = rawmode;

  003df	48 8d 44 24 60	 lea	 rax, QWORD PTR rawmode$[rsp]
  003e4	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR m$[rsp], rax

; 299  :     if (creating)  *(m++) = 'x';

  003ec	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR creating$[rsp], 0
  003f4	74 1e		 je	 SHORT $LN59@io_open
  003f6	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  003fe	c6 00 78	 mov	 BYTE PTR [rax], 120	; 00000078H
  00401	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00409	48 ff c0	 inc	 rax
  0040c	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR m$[rsp], rax
$LN59@io_open:

; 300  :     if (reading)   *(m++) = 'r';

  00414	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR reading$[rsp], 0
  0041c	74 1e		 je	 SHORT $LN58@io_open
  0041e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00426	c6 00 72	 mov	 BYTE PTR [rax], 114	; 00000072H
  00429	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00431	48 ff c0	 inc	 rax
  00434	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR m$[rsp], rax
$LN58@io_open:

; 301  :     if (writing)   *(m++) = 'w';

  0043c	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR writing$[rsp], 0
  00444	74 1e		 je	 SHORT $LN57@io_open
  00446	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  0044e	c6 00 77	 mov	 BYTE PTR [rax], 119	; 00000077H
  00451	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00459	48 ff c0	 inc	 rax
  0045c	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR m$[rsp], rax
$LN57@io_open:

; 302  :     if (appending) *(m++) = 'a';

  00464	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR appending$[rsp], 0
  0046c	74 1e		 je	 SHORT $LN56@io_open
  0046e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00476	c6 00 61	 mov	 BYTE PTR [rax], 97	; 00000061H
  00479	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00481	48 ff c0	 inc	 rax
  00484	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR m$[rsp], rax
$LN56@io_open:

; 303  :     if (updating)  *(m++) = '+';

  0048c	83 bc 24 cc 00
	00 00 00	 cmp	 DWORD PTR updating$[rsp], 0
  00494	74 1e		 je	 SHORT $LN55@io_open
  00496	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  0049e	c6 00 2b	 mov	 BYTE PTR [rax], 43	; 0000002bH
  004a1	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  004a9	48 ff c0	 inc	 rax
  004ac	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR m$[rsp], rax
$LN55@io_open:

; 304  :     *m = '\0';

  004b4	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  004bc	c6 00 00	 mov	 BYTE PTR [rax], 0

; 305  : 
; 306  :     /* Parameters validation */
; 307  :     if (universal) {

  004bf	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR universal$[rsp], 0
  004c7	74 39		 je	 SHORT $LN54@io_open

; 308  :         if (writing || appending) {

  004c9	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR writing$[rsp], 0
  004d1	75 0a		 jne	 SHORT $LN52@io_open
  004d3	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR appending$[rsp], 0
  004db	74 1a		 je	 SHORT $LN53@io_open
$LN52@io_open:

; 309  :             PyErr_SetString(PyExc_ValueError,
; 310  :                             "can't use U and writing mode at once");

  004dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@EBAHAMKP@can?8t?5use?5U?5and?5writing?5mode?5at?5@
  004e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  004eb	e8 00 00 00 00	 call	 PyErr_SetString

; 311  :             return NULL;

  004f0	33 c0		 xor	 eax, eax
  004f2	e9 92 05 00 00	 jmp	 $LN77@io_open
$LN53@io_open:

; 312  :         }
; 313  :         reading = 1;

  004f7	c7 84 24 24 01
	00 00 01 00 00
	00		 mov	 DWORD PTR reading$[rsp], 1
$LN54@io_open:

; 314  :     }
; 315  : 
; 316  :     if (text && binary) {

  00502	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR text$[rsp], 0
  0050a	74 24		 je	 SHORT $LN51@io_open
  0050c	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR binary$[rsp], 0
  00514	74 1a		 je	 SHORT $LN51@io_open

; 317  :         PyErr_SetString(PyExc_ValueError,
; 318  :                         "can't have text and binary mode at once");

  00516	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@NLGHEIMK@can?8t?5have?5text?5and?5binary?5mode?5@
  0051d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00524	e8 00 00 00 00	 call	 PyErr_SetString

; 319  :         return NULL;

  00529	33 c0		 xor	 eax, eax
  0052b	e9 59 05 00 00	 jmp	 $LN77@io_open
$LN51@io_open:

; 320  :     }
; 321  : 
; 322  :     if (creating + reading + writing + appending > 1) {

  00530	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR reading$[rsp]
  00537	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR creating$[rsp]
  0053e	03 c8		 add	 ecx, eax
  00540	8b c1		 mov	 eax, ecx
  00542	03 84 24 38 01
	00 00		 add	 eax, DWORD PTR writing$[rsp]
  00549	03 84 24 10 01
	00 00		 add	 eax, DWORD PTR appending$[rsp]
  00550	83 f8 01	 cmp	 eax, 1
  00553	7e 1a		 jle	 SHORT $LN50@io_open

; 323  :         PyErr_SetString(PyExc_ValueError,
; 324  :                         "must have exactly one of create/read/write/append mode");

  00555	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@EAEIFFCJ@must?5have?5exactly?5one?5of?5create?1@
  0055c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00563	e8 00 00 00 00	 call	 PyErr_SetString

; 325  :         return NULL;

  00568	33 c0		 xor	 eax, eax
  0056a	e9 1a 05 00 00	 jmp	 $LN77@io_open
$LN50@io_open:

; 326  :     }
; 327  : 
; 328  :     if (binary && encoding != NULL) {

  0056f	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR binary$[rsp], 0
  00577	74 25		 je	 SHORT $LN49@io_open
  00579	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR encoding$[rsp], 0
  00582	74 1a		 je	 SHORT $LN49@io_open

; 329  :         PyErr_SetString(PyExc_ValueError,
; 330  :                         "binary mode doesn't take an encoding argument");

  00584	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@CAFNFBNN@binary?5mode?5doesn?8t?5take?5an?5enco@
  0058b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00592	e8 00 00 00 00	 call	 PyErr_SetString

; 331  :         return NULL;

  00597	33 c0		 xor	 eax, eax
  00599	e9 eb 04 00 00	 jmp	 $LN77@io_open
$LN49@io_open:

; 332  :     }
; 333  : 
; 334  :     if (binary && errors != NULL) {

  0059e	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR binary$[rsp], 0
  005a6	74 25		 je	 SHORT $LN48@io_open
  005a8	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR errors$[rsp], 0
  005b1	74 1a		 je	 SHORT $LN48@io_open

; 335  :         PyErr_SetString(PyExc_ValueError,
; 336  :                         "binary mode doesn't take an errors argument");

  005b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@CCNHIIDC@binary?5mode?5doesn?8t?5take?5an?5erro@
  005ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  005c1	e8 00 00 00 00	 call	 PyErr_SetString

; 337  :         return NULL;

  005c6	33 c0		 xor	 eax, eax
  005c8	e9 bc 04 00 00	 jmp	 $LN77@io_open
$LN48@io_open:

; 338  :     }
; 339  : 
; 340  :     if (binary && newline != NULL) {

  005cd	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR binary$[rsp], 0
  005d5	74 25		 je	 SHORT $LN47@io_open
  005d7	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR newline$[rsp], 0
  005e0	74 1a		 je	 SHORT $LN47@io_open

; 341  :         PyErr_SetString(PyExc_ValueError,
; 342  :                         "binary mode doesn't take a newline argument");

  005e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@OMAPNBPG@binary?5mode?5doesn?8t?5take?5a?5newli@
  005e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  005f0	e8 00 00 00 00	 call	 PyErr_SetString

; 343  :         return NULL;

  005f5	33 c0		 xor	 eax, eax
  005f7	e9 8d 04 00 00	 jmp	 $LN77@io_open
$LN47@io_open:

; 344  :     }
; 345  : 
; 346  :     /* Create the Raw file stream */
; 347  :     raw = PyObject_CallFunction((PyObject *)&PyFileIO_Type,
; 348  :                                 "OsiO", file, rawmode, closefd, opener);

  005fc	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR opener$[rsp]
  00604	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00609	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR closefd$[rsp]
  00610	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00614	4c 8d 4c 24 60	 lea	 r9, QWORD PTR rawmode$[rsp]
  00619	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR file$[rsp]
  00621	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04KKBDGLGN@OsiO?$AA@
  00628	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFileIO_Type
  0062f	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT
  00634	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 349  :     if (raw == NULL)

  0063c	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR raw$[rsp], 0
  00645	75 07		 jne	 SHORT $LN46@io_open

; 350  :         return NULL;

  00647	33 c0		 xor	 eax, eax
  00649	e9 3b 04 00 00	 jmp	 $LN77@io_open
$LN46@io_open:

; 351  : 
; 352  :     modeobj = PyUnicode_FromString(mode);

  0064e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR mode$[rsp]
  00656	e8 00 00 00 00	 call	 PyUnicode_FromString
  0065b	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR modeobj$[rsp], rax

; 353  :     if (modeobj == NULL)

  00663	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR modeobj$[rsp], 0
  0066c	75 05		 jne	 SHORT $LN45@io_open

; 354  :         goto error;

  0066e	e9 9c 03 00 00	 jmp	 $error$20570
$LN45@io_open:

; 355  : 
; 356  :     /* buffering */
; 357  :     {
; 358  :         PyObject *res = _PyObject_CallMethodId(raw, &PyId_isatty, NULL);

  00673	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_isatty@?1??io_open@@9@9
  00678	8b c0		 mov	 eax, eax
  0067a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00680	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00689	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0068d	45 33 c0	 xor	 r8d, r8d
  00690	48 8b d0	 mov	 rdx, rax
  00693	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  0069b	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  006a0	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR res$20571[rsp], rax

; 359  :         if (res == NULL)

  006a8	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR res$20571[rsp], 0
  006b1	75 05		 jne	 SHORT $LN44@io_open

; 360  :             goto error;

  006b3	e9 57 03 00 00	 jmp	 $error$20570
$LN44@io_open:

; 361  :         isatty = PyLong_AsLong(res);

  006b8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR res$20571[rsp]
  006c0	e8 00 00 00 00	 call	 PyLong_AsLong
  006c5	89 84 24 fc 00
	00 00		 mov	 DWORD PTR isatty$[rsp], eax

; 362  :         Py_DECREF(res);

  006cc	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR res$20571[rsp]
  006d4	e8 00 00 00 00	 call	 _Py_DecRef

; 363  :         if (isatty == -1 && PyErr_Occurred())

  006d9	83 bc 24 fc 00
	00 00 ff	 cmp	 DWORD PTR isatty$[rsp], -1
  006e1	75 0f		 jne	 SHORT $LN43@io_open
  006e3	e8 00 00 00 00	 call	 PyErr_Occurred
  006e8	48 85 c0	 test	 rax, rax
  006eb	74 05		 je	 SHORT $LN43@io_open

; 364  :             goto error;

  006ed	e9 1d 03 00 00	 jmp	 $error$20570
$LN43@io_open:

; 365  :     }
; 366  : 
; 367  :     if (buffering == 1 || (buffering < 0 && isatty)) {

  006f2	83 bc 24 c8 00
	00 00 01	 cmp	 DWORD PTR buffering$[rsp], 1
  006fa	74 14		 je	 SHORT $LN41@io_open
  006fc	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR buffering$[rsp], 0
  00704	7d 22		 jge	 SHORT $LN42@io_open
  00706	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR isatty$[rsp], 0
  0070e	74 18		 je	 SHORT $LN42@io_open
$LN41@io_open:

; 368  :         buffering = -1;

  00710	c7 84 24 c8 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR buffering$[rsp], -1

; 369  :         line_buffering = 1;

  0071b	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR line_buffering$[rsp], 1

; 370  :     }
; 371  :     else

  00726	eb 0b		 jmp	 SHORT $LN40@io_open
$LN42@io_open:

; 372  :         line_buffering = 0;

  00728	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR line_buffering$[rsp], 0
$LN40@io_open:

; 373  : 
; 374  :     if (buffering < 0) {

  00733	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR buffering$[rsp], 0
  0073b	7d 0b		 jge	 SHORT $LN39@io_open

; 375  :         buffering = DEFAULT_BUFFER_SIZE;

  0073d	c7 84 24 c8 00
	00 00 00 20 00
	00		 mov	 DWORD PTR buffering$[rsp], 8192 ; 00002000H
$LN39@io_open:

; 376  : #ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
; 377  :         {
; 378  :             struct stat st;
; 379  :             long fileno;
; 380  :             PyObject *res = _PyObject_CallMethodId(raw, &PyId_fileno, NULL);
; 381  :             if (res == NULL)
; 382  :                 goto error;
; 383  : 
; 384  :             fileno = PyLong_AsLong(res);
; 385  :             Py_DECREF(res);
; 386  :             if (fileno == -1 && PyErr_Occurred())
; 387  :                 goto error;
; 388  : 
; 389  :             if (fstat(fileno, &st) >= 0 && st.st_blksize > 1)
; 390  :                 buffering = st.st_blksize;
; 391  :         }
; 392  : #endif
; 393  :     }
; 394  :     if (buffering < 0) {

  00748	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR buffering$[rsp], 0
  00750	7d 18		 jge	 SHORT $LN38@io_open

; 395  :         PyErr_SetString(PyExc_ValueError,
; 396  :                         "invalid buffering size");

  00752	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@HEILGHFA@invalid?5buffering?5size?$AA@
  00759	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00760	e8 00 00 00 00	 call	 PyErr_SetString

; 397  :         goto error;

  00765	e9 a5 02 00 00	 jmp	 $error$20570
$LN38@io_open:

; 398  :     }
; 399  : 
; 400  :     /* if not buffering, returns the raw file object */
; 401  :     if (buffering == 0) {

  0076a	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR buffering$[rsp], 0
  00772	75 3c		 jne	 SHORT $LN37@io_open

; 402  :         if (!binary) {

  00774	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR binary$[rsp], 0
  0077c	75 18		 jne	 SHORT $LN36@io_open

; 403  :             PyErr_SetString(PyExc_ValueError,
; 404  :                             "can't have unbuffered text I/O");

  0077e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@PHGBMNHL@can?8t?5have?5unbuffered?5text?5I?1O?$AA@
  00785	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0078c	e8 00 00 00 00	 call	 PyErr_SetString

; 405  :             goto error;

  00791	e9 79 02 00 00	 jmp	 $error$20570
$LN36@io_open:

; 406  :         }
; 407  : 
; 408  :         Py_DECREF(modeobj);

  00796	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR modeobj$[rsp]
  0079e	e8 00 00 00 00	 call	 _Py_DecRef

; 409  :         return raw;

  007a3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR raw$[rsp]
  007ab	e9 d9 02 00 00	 jmp	 $LN77@io_open
$LN37@io_open:

; 410  :     }
; 411  : 
; 412  :     /* wraps into a buffered file */
; 413  :     {
; 414  :         PyObject *Buffered_class;
; 415  : 
; 416  :         if (updating)

  007b0	83 bc 24 cc 00
	00 00 00	 cmp	 DWORD PTR updating$[rsp], 0
  007b8	74 11		 je	 SHORT $LN35@io_open

; 417  :             Buffered_class = (PyObject *)&PyBufferedRandom_Type;

  007ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBufferedRandom_Type
  007c1	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR Buffered_class$20587[rsp], rax
  007c9	eb 6a		 jmp	 SHORT $LN34@io_open
$LN35@io_open:

; 418  :         else if (creating || writing || appending)

  007cb	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR creating$[rsp], 0
  007d3	75 14		 jne	 SHORT $LN32@io_open
  007d5	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR writing$[rsp], 0
  007dd	75 0a		 jne	 SHORT $LN32@io_open
  007df	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR appending$[rsp], 0
  007e7	74 11		 je	 SHORT $LN33@io_open
$LN32@io_open:

; 419  :             Buffered_class = (PyObject *)&PyBufferedWriter_Type;

  007e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBufferedWriter_Type
  007f0	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR Buffered_class$20587[rsp], rax
  007f8	eb 3b		 jmp	 SHORT $LN31@io_open
$LN33@io_open:

; 420  :         else if (reading)

  007fa	83 bc 24 24 01
	00 00 00	 cmp	 DWORD PTR reading$[rsp], 0
  00802	74 11		 je	 SHORT $LN30@io_open

; 421  :             Buffered_class = (PyObject *)&PyBufferedReader_Type;

  00804	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBufferedReader_Type
  0080b	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR Buffered_class$20587[rsp], rax

; 422  :         else {

  00813	eb 20		 jmp	 SHORT $LN29@io_open
$LN30@io_open:

; 423  :             PyErr_Format(PyExc_ValueError,
; 424  :                          "unknown mode: '%s'", mode);

  00815	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR mode$[rsp]
  0081d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@HGCBKHPL@unknown?5mode?3?5?8?$CFs?8?$AA@
  00824	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0082b	e8 00 00 00 00	 call	 PyErr_Format

; 425  :             goto error;

  00830	e9 da 01 00 00	 jmp	 $error$20570
$LN29@io_open:
$LN31@io_open:
$LN34@io_open:

; 426  :         }
; 427  : 
; 428  :         buffer = PyObject_CallFunction(Buffered_class, "Oi", raw, buffering);

  00835	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR buffering$[rsp]
  0083d	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR raw$[rsp]
  00845	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MPEHDMPO@Oi?$AA@
  0084c	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR Buffered_class$20587[rsp]
  00854	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT
  00859	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR buffer$[rsp], rax
$LN28@io_open:

; 429  :     }
; 430  :     Py_CLEAR(raw);

  00861	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR raw$[rsp], 0
  0086a	74 56		 je	 SHORT $LN25@io_open
  0086c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00874	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR raw$[rsp]
  0087c	41 b8 ae 01 00
	00		 mov	 r8d, 430		; 000001aeH
  00882	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@KHFLOKNA@?4?4?2Modules?2_io?2_iomodule?4c?$AA@
  00889	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07BAGABCMK@io_open?$AA@
  00890	e8 00 00 00 00	 call	 _PyParallel_Guard
  00895	85 c0		 test	 eax, eax
  00897	75 29		 jne	 SHORT $LN25@io_open
  00899	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR raw$[rsp]
  008a1	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR _py_tmp$20606[rsp], rax
  008a9	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR raw$[rsp], 0
  008b5	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR _py_tmp$20606[rsp]
  008bd	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@io_open:
  008c2	33 c0		 xor	 eax, eax
  008c4	85 c0		 test	 eax, eax
  008c6	75 99		 jne	 SHORT $LN28@io_open

; 431  :     if (buffer == NULL)

  008c8	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  008d1	75 05		 jne	 SHORT $LN24@io_open

; 432  :         goto error;

  008d3	e9 37 01 00 00	 jmp	 $error$20570
$LN24@io_open:

; 433  : 
; 434  : 
; 435  :     /* if binary, returns the buffered file */
; 436  :     if (binary) {

  008d8	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR binary$[rsp], 0
  008e0	74 1a		 je	 SHORT $LN23@io_open

; 437  :         Py_DECREF(modeobj);

  008e2	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR modeobj$[rsp]
  008ea	e8 00 00 00 00	 call	 _Py_DecRef

; 438  :         return buffer;

  008ef	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  008f7	e9 8d 01 00 00	 jmp	 $LN77@io_open
$LN23@io_open:

; 439  :     }
; 440  : 
; 441  :     /* wraps into a TextIOWrapper */
; 442  :     wrapper = PyObject_CallFunction((PyObject *)&PyTextIOWrapper_Type,
; 443  : 				    "Osssi",
; 444  : 				    buffer,
; 445  : 				    encoding, errors, newline,
; 446  : 				    line_buffering);

  008fc	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR line_buffering$[rsp]
  00903	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00907	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR newline$[rsp]
  0090f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00914	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR errors$[rsp]
  0091c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00921	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR encoding$[rsp]
  00929	4c 8b 84 24 30
	01 00 00	 mov	 r8, QWORD PTR buffer$[rsp]
  00931	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05JFEDHFGP@Osssi?$AA@
  00938	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTextIOWrapper_Type
  0093f	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT
  00944	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR wrapper$[rsp], rax
$LN22@io_open:

; 447  :     Py_CLEAR(buffer);

  0094c	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00955	74 56		 je	 SHORT $LN19@io_open
  00957	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0095f	4c 8b 8c 24 30
	01 00 00	 mov	 r9, QWORD PTR buffer$[rsp]
  00967	41 b8 bf 01 00
	00		 mov	 r8d, 447		; 000001bfH
  0096d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@KHFLOKNA@?4?4?2Modules?2_io?2_iomodule?4c?$AA@
  00974	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07BAGABCMK@io_open?$AA@
  0097b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00980	85 c0		 test	 eax, eax
  00982	75 29		 jne	 SHORT $LN19@io_open
  00984	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0098c	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR _py_tmp$20620[rsp], rax
  00994	48 c7 84 24 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR buffer$[rsp], 0
  009a0	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR _py_tmp$20620[rsp]
  009a8	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@io_open:
  009ad	33 c0		 xor	 eax, eax
  009af	85 c0		 test	 eax, eax
  009b1	75 99		 jne	 SHORT $LN22@io_open

; 448  :     if (wrapper == NULL)

  009b3	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR wrapper$[rsp], 0
  009bc	75 02		 jne	 SHORT $LN18@io_open

; 449  :         goto error;

  009be	eb 4f		 jmp	 SHORT $error$20570
$LN18@io_open:

; 450  : 
; 451  :     if (_PyObject_SetAttrId(wrapper, &PyId_mode, modeobj) < 0)

  009c0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_mode@?1??io_open@@9@9
  009c5	8b c0		 mov	 eax, eax
  009c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  009cd	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  009d6	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  009da	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR modeobj$[rsp]
  009e2	48 8b d0	 mov	 rdx, rax
  009e5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR wrapper$[rsp]
  009ed	e8 00 00 00 00	 call	 _PyObject_SetAttrId
  009f2	85 c0		 test	 eax, eax
  009f4	7d 02		 jge	 SHORT $LN17@io_open

; 452  :         goto error;

  009f6	eb 17		 jmp	 SHORT $error$20570
$LN17@io_open:

; 453  :     Py_DECREF(modeobj);

  009f8	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR modeobj$[rsp]
  00a00	e8 00 00 00 00	 call	 _Py_DecRef

; 454  :     return wrapper;

  00a05	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR wrapper$[rsp]
  00a0d	eb 7a		 jmp	 SHORT $LN77@io_open
$error$20570:
$LN16@io_open:

; 455  : 
; 456  :   error:
; 457  :     Py_XDECREF(raw);

  00a0f	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR raw$[rsp], 0
  00a18	74 0d		 je	 SHORT $LN13@io_open
  00a1a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00a22	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@io_open:
  00a27	33 c0		 xor	 eax, eax
  00a29	85 c0		 test	 eax, eax
  00a2b	75 e2		 jne	 SHORT $LN16@io_open
$LN12@io_open:

; 458  :     Py_XDECREF(modeobj);

  00a2d	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR modeobj$[rsp], 0
  00a36	74 0d		 je	 SHORT $LN9@io_open
  00a38	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR modeobj$[rsp]
  00a40	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@io_open:
  00a45	33 c0		 xor	 eax, eax
  00a47	85 c0		 test	 eax, eax
  00a49	75 e2		 jne	 SHORT $LN12@io_open
$LN8@io_open:

; 459  :     Py_XDECREF(buffer);

  00a4b	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00a54	74 0d		 je	 SHORT $LN5@io_open
  00a56	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00a5e	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@io_open:
  00a63	33 c0		 xor	 eax, eax
  00a65	85 c0		 test	 eax, eax
  00a67	75 e2		 jne	 SHORT $LN8@io_open
$LN4@io_open:

; 460  :     Py_XDECREF(wrapper);

  00a69	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR wrapper$[rsp], 0
  00a72	74 0d		 je	 SHORT $LN1@io_open
  00a74	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR wrapper$[rsp]
  00a7c	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@io_open:
  00a81	33 c0		 xor	 eax, eax
  00a83	85 c0		 test	 eax, eax
  00a85	75 e2		 jne	 SHORT $LN4@io_open

; 461  :     return NULL;

  00a87	33 c0		 xor	 eax, eax
$LN77@io_open:

; 462  : }

  00a89	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00a90	c3		 ret	 0
  00a91	0f 1f 00	 npad	 3
$LN80@io_open:
  00a94	00 00 00 00	 DD	 $LN65@io_open
  00a98	00 00 00 00	 DD	 $LN62@io_open
  00a9c	00 00 00 00	 DD	 $LN66@io_open
  00aa0	00 00 00 00	 DD	 $LN63@io_open
  00aa4	00 00 00 00	 DD	 $LN68@io_open
  00aa8	00 00 00 00	 DD	 $LN64@io_open
  00aac	00 00 00 00	 DD	 $LN67@io_open
  00ab0	00 00 00 00	 DD	 $LN69@io_open
  00ab4	00 00 00 00	 DD	 $LN61@io_open
$LN79@io_open:
  00ab8	00		 DB	 0
  00ab9	08		 DB	 8
  00aba	08		 DB	 8
  00abb	08		 DB	 8
  00abc	08		 DB	 8
  00abd	08		 DB	 8
  00abe	08		 DB	 8
  00abf	08		 DB	 8
  00ac0	08		 DB	 8
  00ac1	08		 DB	 8
  00ac2	08		 DB	 8
  00ac3	08		 DB	 8
  00ac4	08		 DB	 8
  00ac5	08		 DB	 8
  00ac6	08		 DB	 8
  00ac7	08		 DB	 8
  00ac8	08		 DB	 8
  00ac9	08		 DB	 8
  00aca	08		 DB	 8
  00acb	08		 DB	 8
  00acc	08		 DB	 8
  00acd	08		 DB	 8
  00ace	08		 DB	 8
  00acf	08		 DB	 8
  00ad0	08		 DB	 8
  00ad1	08		 DB	 8
  00ad2	08		 DB	 8
  00ad3	08		 DB	 8
  00ad4	08		 DB	 8
  00ad5	08		 DB	 8
  00ad6	08		 DB	 8
  00ad7	08		 DB	 8
  00ad8	08		 DB	 8
  00ad9	08		 DB	 8
  00ada	08		 DB	 8
  00adb	08		 DB	 8
  00adc	08		 DB	 8
  00add	08		 DB	 8
  00ade	08		 DB	 8
  00adf	08		 DB	 8
  00ae0	08		 DB	 8
  00ae1	08		 DB	 8
  00ae2	01		 DB	 1
  00ae3	08		 DB	 8
  00ae4	08		 DB	 8
  00ae5	08		 DB	 8
  00ae6	08		 DB	 8
  00ae7	08		 DB	 8
  00ae8	08		 DB	 8
  00ae9	08		 DB	 8
  00aea	08		 DB	 8
  00aeb	08		 DB	 8
  00aec	08		 DB	 8
  00aed	08		 DB	 8
  00aee	02		 DB	 2
  00aef	03		 DB	 3
  00af0	08		 DB	 8
  00af1	08		 DB	 8
  00af2	08		 DB	 8
  00af3	08		 DB	 8
  00af4	08		 DB	 8
  00af5	08		 DB	 8
  00af6	08		 DB	 8
  00af7	08		 DB	 8
  00af8	08		 DB	 8
  00af9	08		 DB	 8
  00afa	08		 DB	 8
  00afb	08		 DB	 8
  00afc	08		 DB	 8
  00afd	08		 DB	 8
  00afe	08		 DB	 8
  00aff	04		 DB	 4
  00b00	08		 DB	 8
  00b01	05		 DB	 5
  00b02	08		 DB	 8
  00b03	08		 DB	 8
  00b04	06		 DB	 6
  00b05	07		 DB	 7
io_open	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@KDIDCMCC@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5offs@ ; `string'
PUBLIC	??_C@_1CI@LDJODEPI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@KOOEOEP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AA_?$AAi?$AAo?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	PyNumber_AsOff_t
EXTRN	_PyLong_Sign:PROC
EXTRN	__imp__wassert:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_GivenExceptionMatches:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyLong_AsLongLong:PROC
EXTRN	PyNumber_Index:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_io\_iomodule.c
pdata	SEGMENT
$pdata$PyNumber_AsOff_t DD imagerel $LN12
	DD	imagerel $LN12+284
	DD	imagerel $unwind$PyNumber_AsOff_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_AsOff_t DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0DB@KDIDCMCC@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5offs@
CONST	SEGMENT
??_C@_0DB@KDIDCMCC@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5offs@ DB 'canno'
	DB	't fit ''%.200s'' into an offset-sized integer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@LDJODEPI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@LDJODEPI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@KOOEOEP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AA_?$AAi?$AAo?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@KOOEOEP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AA_?$AAi?$AAo?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, '_', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '_', 00H, 'i', 00H, 'o', 00H, 'm', 00H, 'o', 00H
	DB	'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_AsOff_t
_TEXT	SEGMENT
value$ = 32
result$ = 40
runerr$ = 48
item$ = 80
err$ = 88
PyNumber_AsOff_t PROC					; COMDAT

; 470  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 471  :     Py_off_t result;
; 472  :     PyObject *runerr;
; 473  :     PyObject *value = PyNumber_Index(item);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR item$[rsp]
  00013	e8 00 00 00 00	 call	 PyNumber_Index
  00018	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 474  :     if (value == NULL)

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  00023	75 0c		 jne	 SHORT $LN8@PyNumber_A

; 475  :         return -1;

  00025	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0002c	e9 e6 00 00 00	 jmp	 $LN9@PyNumber_A
$LN8@PyNumber_A:

; 476  : 
; 477  :     /* We're done if PyLong_AsSsize_t() returns without error. */
; 478  :     result = PyLong_AsOff_t(value);

  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00036	e8 00 00 00 00	 call	 PyLong_AsLongLong
  0003b	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 479  :     if (result != -1 || !(runerr = PyErr_Occurred()))

  00040	48 83 7c 24 28
	ff		 cmp	 QWORD PTR result$[rsp], -1
  00046	75 12		 jne	 SHORT $LN6@PyNumber_A
  00048	e8 00 00 00 00	 call	 PyErr_Occurred
  0004d	48 89 44 24 30	 mov	 QWORD PTR runerr$[rsp], rax
  00052	48 83 7c 24 30
	00		 cmp	 QWORD PTR runerr$[rsp], 0
  00058	75 05		 jne	 SHORT $LN7@PyNumber_A
$LN6@PyNumber_A:

; 480  :         goto finish;

  0005a	e9 a9 00 00 00	 jmp	 $finish$20661
$LN7@PyNumber_A:

; 481  : 
; 482  :     /* Error handling code -- only manage OverflowError differently */
; 483  :     if (!PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError))

  0005f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR runerr$[rsp]
  0006b	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches
  00070	85 c0		 test	 eax, eax
  00072	75 05		 jne	 SHORT $LN5@PyNumber_A

; 484  :         goto finish;

  00074	e9 8f 00 00 00	 jmp	 $finish$20661
$LN5@PyNumber_A:

; 485  : 
; 486  :     PyErr_Clear();

  00079	e8 00 00 00 00	 call	 PyErr_Clear

; 487  :     /* If no error-handling desired then the default clipping
; 488  :        is sufficient.
; 489  :      */
; 490  :     if (!err) {

  0007e	48 83 7c 24 58
	00		 cmp	 QWORD PTR err$[rsp], 0
  00084	75 64		 jne	 SHORT $LN4@PyNumber_A

; 491  :         assert(PyLong_Check(value));

  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  0008b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00095	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0009a	85 c0		 test	 eax, eax
  0009c	75 1c		 jne	 SHORT $LN11@PyNumber_A
  0009e	41 b8 eb 01 00
	00		 mov	 r8d, 491		; 000001ebH
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DG@KOOEOEP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AA_?$AAi?$AAo?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@LDJODEPI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?$CJ?$AA?$AA@
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b8	33 c0		 xor	 eax, eax
$LN11@PyNumber_A:

; 492  :         /* Whether or not it is less than or equal to
; 493  :            zero is determined by the sign of ob_size
; 494  :         */
; 495  :         if (_PyLong_Sign(value) < 0)

  000ba	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  000bf	e8 00 00 00 00	 call	 _PyLong_Sign
  000c4	85 c0		 test	 eax, eax
  000c6	7d 11		 jge	 SHORT $LN3@PyNumber_A

; 496  :             result = PY_OFF_T_MIN;

  000c8	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  000d2	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 497  :         else

  000d7	eb 0f		 jmp	 SHORT $LN2@PyNumber_A
$LN3@PyNumber_A:

; 498  :             result = PY_OFF_T_MAX;

  000d9	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000e3	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax
$LN2@PyNumber_A:

; 499  :     }
; 500  :     else {

  000e8	eb 1e		 jmp	 SHORT $LN1@PyNumber_A
$LN4@PyNumber_A:

; 501  :         /* Otherwise replace the error with caller's error object. */
; 502  :         PyErr_Format(err,
; 503  :                      "cannot fit '%.200s' into an offset-sized integer",
; 504  :                      item->ob_type->tp_name);

  000ea	48 8b 44 24 50	 mov	 rax, QWORD PTR item$[rsp]
  000ef	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f3	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@KDIDCMCC@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5offs@
  000fe	48 8b 4c 24 58	 mov	 rcx, QWORD PTR err$[rsp]
  00103	e8 00 00 00 00	 call	 PyErr_Format
$LN1@PyNumber_A:
$finish$20661:

; 505  :     }
; 506  : 
; 507  :  finish:
; 508  :     Py_DECREF(value);

  00108	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  0010d	e8 00 00 00 00	 call	 _Py_DecRef

; 509  :     return result;

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN9@PyNumber_A:

; 510  : }

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
PyNumber_AsOff_t ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@INOFDAGI@integer?5argument?5expected?0?5got?5?8@ ; `string'
PUBLIC	_PyIO_ConvertSsize_t
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyIO_ConvertSsize_t DD imagerel $LN8
	DD	imagerel $LN8+158
	DD	imagerel $unwind$_PyIO_ConvertSsize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyIO_ConvertSsize_t DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CI@INOFDAGI@integer?5argument?5expected?0?5got?5?8@
CONST	SEGMENT
??_C@_0CI@INOFDAGI@integer?5argument?5expected?0?5got?5?8@ DB 'integer ar'
	DB	'gument expected, got ''%.200s''', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyIO_ConvertSsize_t
_TEXT	SEGMENT
limit$ = 32
obj$ = 64
result$ = 72
_PyIO_ConvertSsize_t PROC				; COMDAT

; 515  : _PyIO_ConvertSsize_t(PyObject *obj, void *result) {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 516  :     Py_ssize_t limit;
; 517  :     if (obj == Py_None) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00015	48 39 44 24 40	 cmp	 QWORD PTR obj$[rsp], rax
  0001a	75 0b		 jne	 SHORT $LN5@PyIO_Conve

; 518  :         limit = -1;

  0001c	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR limit$[rsp], -1
  00025	eb 60		 jmp	 SHORT $LN4@PyIO_Conve
$LN5@PyIO_Conve:

; 519  :     }
; 520  :     else if (PyNumber_Check(obj)) {

  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  0002c	e8 00 00 00 00	 call	 PyNumber_Check
  00031	85 c0		 test	 eax, eax
  00033	74 2e		 je	 SHORT $LN3@PyIO_Conve

; 521  :         limit = PyNumber_AsSsize_t(obj, PyExc_OverflowError);

  00035	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  00041	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00046	48 89 44 24 20	 mov	 QWORD PTR limit$[rsp], rax

; 522  :         if (limit == -1 && PyErr_Occurred())

  0004b	48 83 7c 24 20
	ff		 cmp	 QWORD PTR limit$[rsp], -1
  00051	75 0e		 jne	 SHORT $LN2@PyIO_Conve
  00053	e8 00 00 00 00	 call	 PyErr_Occurred
  00058	48 85 c0	 test	 rax, rax
  0005b	74 04		 je	 SHORT $LN2@PyIO_Conve

; 523  :             return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 38		 jmp	 SHORT $LN6@PyIO_Conve
$LN2@PyIO_Conve:

; 524  :     }
; 525  :     else {

  00061	eb 24		 jmp	 SHORT $LN1@PyIO_Conve
$LN3@PyIO_Conve:

; 526  :         PyErr_Format(PyExc_TypeError,
; 527  :                      "integer argument expected, got '%.200s'",
; 528  :                      Py_TYPE(obj)->tp_name);

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  00068	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006c	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@INOFDAGI@integer?5argument?5expected?0?5got?5?8@
  00077	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007e	e8 00 00 00 00	 call	 PyErr_Format

; 529  :         return 0;

  00083	33 c0		 xor	 eax, eax
  00085	eb 12		 jmp	 SHORT $LN6@PyIO_Conve
$LN1@PyIO_Conve:
$LN4@PyIO_Conve:

; 530  :     }
; 531  :     *((Py_ssize_t *)result) = limit;

  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR limit$[rsp]
  00091	48 89 08	 mov	 QWORD PTR [rax], rcx

; 532  :     return 1;

  00094	b8 01 00 00 00	 mov	 eax, 1
$LN6@PyIO_Conve:

; 533  : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
_PyIO_ConvertSsize_t ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@PMBLAJP@iomodule_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
EXTRN	PyModule_GetState:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$iomodule_traverse DD imagerel iomodule_traverse
	DD	imagerel iomodule_traverse+250
	DD	imagerel $unwind$iomodule_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iomodule_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BC@PMBLAJP@iomodule_traverse?$AA@
CONST	SEGMENT
??_C@_0BC@PMBLAJP@iomodule_traverse?$AA@ DB 'iomodule_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT iomodule_traverse
_TEXT	SEGMENT
state$ = 32
vret$20706 = 40
vret$20714 = 44
mod$ = 64
visit$ = 72
arg$ = 80
iomodule_traverse PROC					; COMDAT

; 537  : iomodule_traverse(PyObject *mod, visitproc visit, void *arg) {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 538  :     _PyIO_State *state = IO_MOD_STATE(mod);

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mod$[rsp]
  00018	e8 00 00 00 00	 call	 PyModule_GetState
  0001d	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 539  :     if (!state->initialized)

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00027	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002a	75 07		 jne	 SHORT $LN14@iomodule_t

; 540  :         return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 c2 00 00 00	 jmp	 $LN15@iomodule_t
$LN14@iomodule_t:

; 541  :     if (state->locale_module != NULL) {

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00038	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003d	74 5a		 je	 SHORT $LN13@iomodule_t
$LN12@iomodule_t:

; 542  :         Py_VISIT(state->locale_module);

  0003f	e8 00 00 00 00	 call	 _Py_PXCTX
  00044	85 c0		 test	 eax, eax
  00046	74 1c		 je	 SHORT $LN9@iomodule_t
  00048	45 33 c9	 xor	 r9d, r9d
  0004b	41 b8 1e 02 00
	00		 mov	 r8d, 542		; 0000021eH
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@KHFLOKNA@?4?4?2Modules?2_io?2_iomodule?4c?$AA@
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@PMBLAJP@iomodule_traverse?$AA@
  0005f	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@iomodule_t:
  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00069	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0006e	74 23		 je	 SHORT $LN8@iomodule_t
  00070	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0007a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0007e	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00082	89 44 24 28	 mov	 DWORD PTR vret$20706[rsp], eax
  00086	83 7c 24 28 00	 cmp	 DWORD PTR vret$20706[rsp], 0
  0008b	74 06		 je	 SHORT $LN7@iomodule_t
  0008d	8b 44 24 28	 mov	 eax, DWORD PTR vret$20706[rsp]
  00091	eb 62		 jmp	 SHORT $LN15@iomodule_t
$LN7@iomodule_t:
$LN8@iomodule_t:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 a6		 jne	 SHORT $LN12@iomodule_t
$LN13@iomodule_t:
$LN6@iomodule_t:

; 543  :     }
; 544  :     Py_VISIT(state->unsupported_operation);

  00099	e8 00 00 00 00	 call	 _Py_PXCTX
  0009e	85 c0		 test	 eax, eax
  000a0	74 1c		 je	 SHORT $LN3@iomodule_t
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	41 b8 20 02 00
	00		 mov	 r8d, 544		; 00000220H
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@KHFLOKNA@?4?4?2Modules?2_io?2_iomodule?4c?$AA@
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@PMBLAJP@iomodule_traverse?$AA@
  000b9	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@iomodule_t:
  000be	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000c3	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000c8	74 23		 je	 SHORT $LN2@iomodule_t
  000ca	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000cf	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000d4	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000d8	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000dc	89 44 24 2c	 mov	 DWORD PTR vret$20714[rsp], eax
  000e0	83 7c 24 2c 00	 cmp	 DWORD PTR vret$20714[rsp], 0
  000e5	74 06		 je	 SHORT $LN1@iomodule_t
  000e7	8b 44 24 2c	 mov	 eax, DWORD PTR vret$20714[rsp]
  000eb	eb 08		 jmp	 SHORT $LN15@iomodule_t
$LN1@iomodule_t:
$LN2@iomodule_t:
  000ed	33 c0		 xor	 eax, eax
  000ef	85 c0		 test	 eax, eax
  000f1	75 a6		 jne	 SHORT $LN6@iomodule_t

; 545  :     return 0;

  000f3	33 c0		 xor	 eax, eax
$LN15@iomodule_t:

; 546  : }

  000f5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f9	c3		 ret	 0
iomodule_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@FINKGIKP@iomodule_clear?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$iomodule_clear DD imagerel iomodule_clear
	DD	imagerel iomodule_clear+262
	DD	imagerel $unwind$iomodule_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iomodule_clear DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0P@FINKGIKP@iomodule_clear?$AA@
CONST	SEGMENT
??_C@_0P@FINKGIKP@iomodule_clear?$AA@ DB 'iomodule_clear', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT iomodule_clear
_TEXT	SEGMENT
state$ = 48
_py_tmp$20731 = 56
_py_tmp$20739 = 64
mod$ = 96
iomodule_clear PROC					; COMDAT

; 550  : iomodule_clear(PyObject *mod) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 551  :     _PyIO_State *state = IO_MOD_STATE(mod);

  00009	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mod$[rsp]
  0000e	e8 00 00 00 00	 call	 PyModule_GetState
  00013	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 552  :     if (!state->initialized)

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0001d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00020	75 07		 jne	 SHORT $LN10@iomodule_c

; 553  :         return 0;

  00022	33 c0		 xor	 eax, eax
  00024	e9 d8 00 00 00	 jmp	 $LN11@iomodule_c
$LN10@iomodule_c:

; 554  :     if (state->locale_module != NULL)

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0002e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00033	74 65		 je	 SHORT $LN9@iomodule_c
$LN8@iomodule_c:

; 555  :         Py_CLEAR(state->locale_module);

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0003a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003f	74 53		 je	 SHORT $LN5@iomodule_c
  00041	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0004e	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00052	41 b8 2b 02 00
	00		 mov	 r8d, 555		; 0000022bH
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@KHFLOKNA@?4?4?2Modules?2_io?2_iomodule?4c?$AA@
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@FINKGIKP@iomodule_clear?$AA@
  00066	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006b	85 c0		 test	 eax, eax
  0006d	75 25		 jne	 SHORT $LN5@iomodule_c
  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00074	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00078	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$20731[rsp], rax
  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00082	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0008a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$20731[rsp]
  0008f	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@iomodule_c:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 9b		 jne	 SHORT $LN8@iomodule_c
$LN9@iomodule_c:
$LN4@iomodule_c:

; 556  :     Py_CLEAR(state->unsupported_operation);

  0009a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0009f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000a4	74 53		 je	 SHORT $LN1@iomodule_c
  000a6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ae	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000b3	4c 8b 48 10	 mov	 r9, QWORD PTR [rax+16]
  000b7	41 b8 2c 02 00
	00		 mov	 r8d, 556		; 0000022cH
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@KHFLOKNA@?4?4?2Modules?2_io?2_iomodule?4c?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@FINKGIKP@iomodule_clear?$AA@
  000cb	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d0	85 c0		 test	 eax, eax
  000d2	75 25		 jne	 SHORT $LN1@iomodule_c
  000d4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000d9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000dd	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$20739[rsp], rax
  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000e7	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  000ef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$20739[rsp]
  000f4	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@iomodule_c:
  000f9	33 c0		 xor	 eax, eax
  000fb	85 c0		 test	 eax, eax
  000fd	75 9b		 jne	 SHORT $LN4@iomodule_c

; 557  :     return 0;

  000ff	33 c0		 xor	 eax, eax
$LN11@iomodule_c:

; 558  : }

  00101	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00105	c3		 ret	 0
iomodule_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iomodule_free DD imagerel iomodule_free
	DD	imagerel iomodule_free+24
	DD	imagerel $unwind$iomodule_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iomodule_free DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT iomodule_free
_TEXT	SEGMENT
mod$ = 48
iomodule_free PROC					; COMDAT

; 561  : iomodule_free(PyObject *mod) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 562  :     iomodule_clear(mod);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mod$[rsp]
  0000e	e8 00 00 00 00	 call	 iomodule_clear

; 563  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
iomodule_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_08IBOGFJJC@writable?$AA@			; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_08MABILMFG@truncate?$AA@			; `string'
PUBLIC	??_C@_04LBPCFPDD@tell?$AA@			; `string'
PUBLIC	??_C@_08BJPILIMO@setstate?$AA@			; `string'
PUBLIC	??_C@_08JPFEOKJG@seekable?$AA@			; `string'
PUBLIC	??_C@_04EDECCOGL@seek?$AA@			; `string'
PUBLIC	??_C@_05CFMALAOA@reset?$AA@			; `string'
PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_08BPEKIGCI@readinto?$AA@			; `string'
PUBLIC	??_C@_07JCDFOMC@readall?$AA@			; `string'
PUBLIC	??_C@_08INDGGIBD@readable?$AA@			; `string'
PUBLIC	??_C@_05FDBMPOID@read1?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_08EGHAIIMO@newlines?$AA@			; `string'
PUBLIC	??_C@_08OINEKLLD@getstate?$AA@			; `string'
PUBLIC	??_C@_05GLCAEPFP@flush?$AA@			; `string'
PUBLIC	??_C@_06GDGADLDP@encode?$AA@			; `string'
PUBLIC	??_C@_06KPNAMAEI@decode?$AA@			; `string'
PUBLIC	??_C@_06IKJOPBFO@closed?$AA@			; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	??_C@_0BK@KBKOCGBL@IncrementalNewlineDecoder?$AA@ ; `string'
PUBLIC	??_C@_0O@CKECCIPK@TextIOWrapper?$AA@		; `string'
PUBLIC	??_C@_0P@KKPCDGCM@BufferedRandom?$AA@		; `string'
PUBLIC	??_C@_0P@JIMJFGGF@BufferedRWPair?$AA@		; `string'
PUBLIC	??_C@_0P@FPHMGJHJ@BufferedWriter?$AA@		; `string'
PUBLIC	??_C@_0P@HDPOGIKD@BufferedReader?$AA@		; `string'
PUBLIC	??_C@_08KGGGHFAL@StringIO?$AA@			; `string'
PUBLIC	??_C@_07DINECNOD@BytesIO?$AA@			; `string'
PUBLIC	??_C@_06DCCDEGKI@FileIO?$AA@			; `string'
PUBLIC	??_C@_0M@JGAEDJGP@_TextIOBase?$AA@		; `string'
PUBLIC	??_C@_0BA@GBFMJPJJ@_BufferedIOBase?$AA@		; `string'
PUBLIC	??_C@_0L@OPFLGGFN@_RawIOBase?$AA@		; `string'
PUBLIC	??_C@_07NGNCJLEL@_IOBase?$AA@			; `string'
PUBLIC	??_C@_0BA@JGPGLFDG@BlockingIOError?$AA@		; `string'
PUBLIC	_Py_IncRef
PUBLIC	??_C@_07HPPCNGIB@s?$CIOO?$CJ?$HL?$HN?$AA@	; `string'
PUBLIC	??_C@_0BF@INDAPHCC@UnsupportedOperation?$AA@	; `string'
PUBLIC	??_C@_0BE@NAHCEAI@DEFAULT_BUFFER_SIZE?$AA@	; `string'
PUBLIC	PyInit__io
EXTRN	PyLong_FromLong:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	PyUnicode_FromStringAndSize:PROC
EXTRN	PyUnicode_InternFromString:PROC
EXTRN	PyIncrementalNewlineDecoder_Type:BYTE
EXTRN	PyBufferedRWPair_Type:BYTE
EXTRN	PyStringIO_Type:BYTE
EXTRN	_PyBytesIOBuffer_Type:BYTE
EXTRN	PyBytesIO_Type:BYTE
EXTRN	PyTextIOBase_Type:BYTE
EXTRN	PyBufferedIOBase_Type:BYTE
EXTRN	PyRawIOBase_Type:BYTE
EXTRN	PyType_Ready:PROC
EXTRN	PyIOBase_Type:BYTE
EXTRN	PyExc_BlockingIOError:QWORD
EXTRN	PyModule_AddObject:PROC
EXTRN	PyType_Type:BYTE
EXTRN	PyExc_IOError:QWORD
EXTRN	PyModule_AddIntConstant:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__io DD imagerel $LN66
	DD	imagerel $LN66+2655
	DD	imagerel $unwind$PyInit__io
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__io DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBOGFJJC@writable?$AA@
CONST	SEGMENT
??_C@_08IBOGFJJC@writable?$AA@ DB 'writable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MABILMFG@truncate?$AA@
CONST	SEGMENT
??_C@_08MABILMFG@truncate?$AA@ DB 'truncate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBPCFPDD@tell?$AA@
CONST	SEGMENT
??_C@_04LBPCFPDD@tell?$AA@ DB 'tell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BJPILIMO@setstate?$AA@
CONST	SEGMENT
??_C@_08BJPILIMO@setstate?$AA@ DB 'setstate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPFEOKJG@seekable?$AA@
CONST	SEGMENT
??_C@_08JPFEOKJG@seekable?$AA@ DB 'seekable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDECCOGL@seek?$AA@
CONST	SEGMENT
??_C@_04EDECCOGL@seek?$AA@ DB 'seek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFMALAOA@reset?$AA@
CONST	SEGMENT
??_C@_05CFMALAOA@reset?$AA@ DB 'reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BPEKIGCI@readinto?$AA@
CONST	SEGMENT
??_C@_08BPEKIGCI@readinto?$AA@ DB 'readinto', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JCDFOMC@readall?$AA@
CONST	SEGMENT
??_C@_07JCDFOMC@readall?$AA@ DB 'readall', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08INDGGIBD@readable?$AA@
CONST	SEGMENT
??_C@_08INDGGIBD@readable?$AA@ DB 'readable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FDBMPOID@read1?$AA@
CONST	SEGMENT
??_C@_05FDBMPOID@read1?$AA@ DB 'read1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EGHAIIMO@newlines?$AA@
CONST	SEGMENT
??_C@_08EGHAIIMO@newlines?$AA@ DB 'newlines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OINEKLLD@getstate?$AA@
CONST	SEGMENT
??_C@_08OINEKLLD@getstate?$AA@ DB 'getstate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GLCAEPFP@flush?$AA@
CONST	SEGMENT
??_C@_05GLCAEPFP@flush?$AA@ DB 'flush', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GDGADLDP@encode?$AA@
CONST	SEGMENT
??_C@_06GDGADLDP@encode?$AA@ DB 'encode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KPNAMAEI@decode?$AA@
CONST	SEGMENT
??_C@_06KPNAMAEI@decode?$AA@ DB 'decode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJOPBFO@closed?$AA@
CONST	SEGMENT
??_C@_06IKJOPBFO@closed?$AA@ DB 'closed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KBKOCGBL@IncrementalNewlineDecoder?$AA@
CONST	SEGMENT
??_C@_0BK@KBKOCGBL@IncrementalNewlineDecoder?$AA@ DB 'IncrementalNewlineD'
	DB	'ecoder', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CKECCIPK@TextIOWrapper?$AA@
CONST	SEGMENT
??_C@_0O@CKECCIPK@TextIOWrapper?$AA@ DB 'TextIOWrapper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KKPCDGCM@BufferedRandom?$AA@
CONST	SEGMENT
??_C@_0P@KKPCDGCM@BufferedRandom?$AA@ DB 'BufferedRandom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JIMJFGGF@BufferedRWPair?$AA@
CONST	SEGMENT
??_C@_0P@JIMJFGGF@BufferedRWPair?$AA@ DB 'BufferedRWPair', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FPHMGJHJ@BufferedWriter?$AA@
CONST	SEGMENT
??_C@_0P@FPHMGJHJ@BufferedWriter?$AA@ DB 'BufferedWriter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HDPOGIKD@BufferedReader?$AA@
CONST	SEGMENT
??_C@_0P@HDPOGIKD@BufferedReader?$AA@ DB 'BufferedReader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KGGGHFAL@StringIO?$AA@
CONST	SEGMENT
??_C@_08KGGGHFAL@StringIO?$AA@ DB 'StringIO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DINECNOD@BytesIO?$AA@
CONST	SEGMENT
??_C@_07DINECNOD@BytesIO?$AA@ DB 'BytesIO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DCCDEGKI@FileIO?$AA@
CONST	SEGMENT
??_C@_06DCCDEGKI@FileIO?$AA@ DB 'FileIO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGAEDJGP@_TextIOBase?$AA@
CONST	SEGMENT
??_C@_0M@JGAEDJGP@_TextIOBase?$AA@ DB '_TextIOBase', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GBFMJPJJ@_BufferedIOBase?$AA@
CONST	SEGMENT
??_C@_0BA@GBFMJPJJ@_BufferedIOBase?$AA@ DB '_BufferedIOBase', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPFLGGFN@_RawIOBase?$AA@
CONST	SEGMENT
??_C@_0L@OPFLGGFN@_RawIOBase?$AA@ DB '_RawIOBase', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NGNCJLEL@_IOBase?$AA@
CONST	SEGMENT
??_C@_07NGNCJLEL@_IOBase?$AA@ DB '_IOBase', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGPGLFDG@BlockingIOError?$AA@
CONST	SEGMENT
??_C@_0BA@JGPGLFDG@BlockingIOError?$AA@ DB 'BlockingIOError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HPPCNGIB@s?$CIOO?$CJ?$HL?$HN?$AA@
CONST	SEGMENT
??_C@_07HPPCNGIB@s?$CIOO?$CJ?$HL?$HN?$AA@ DB 's(OO){}', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@INDAPHCC@UnsupportedOperation?$AA@
CONST	SEGMENT
??_C@_0BF@INDAPHCC@UnsupportedOperation?$AA@ DB 'UnsupportedOperation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NAHCEAI@DEFAULT_BUFFER_SIZE?$AA@
CONST	SEGMENT
??_C@_0BE@NAHCEAI@DEFAULT_BUFFER_SIZE?$AA@ DB 'DEFAULT_BUFFER_SIZE', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit__io
_TEXT	SEGMENT
state$ = 48
m$ = 56
PyInit__io PROC						; COMDAT

; 589  : {

$LN66:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 590  :     PyObject *m = PyModule_Create(&_PyIO_Module);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyIO_Module
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 38	 mov	 QWORD PTR m$[rsp], rax

; 591  :     _PyIO_State *state = NULL;

  0001a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR state$[rsp], 0

; 592  :     if (m == NULL)

  00023	48 83 7c 24 38
	00		 cmp	 QWORD PTR m$[rsp], 0
  00029	75 07		 jne	 SHORT $LN63@PyInit__io

; 593  :         return NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 28 0a 00 00	 jmp	 $LN64@PyInit__io
$LN63@PyInit__io:

; 594  :     state = IO_MOD_STATE(m);

  00032	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00037	e8 00 00 00 00	 call	 PyModule_GetState
  0003c	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 595  :     state->initialized = 0;

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00046	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 596  : 
; 597  : #define ADD_TYPE(type, name) \
; 598  :     if (PyType_Ready(type) < 0) \
; 599  :         goto fail; \
; 600  :     Py_INCREF(type); \
; 601  :     if (PyModule_AddObject(m, name, (PyObject *)type) < 0) {  \
; 602  :         Py_DECREF(type); \
; 603  :         goto fail; \
; 604  :     }
; 605  : 
; 606  :     /* DEFAULT_BUFFER_SIZE */
; 607  :     if (PyModule_AddIntMacro(m, DEFAULT_BUFFER_SIZE) < 0)

  0004c	41 b8 00 20 00
	00		 mov	 r8d, 8192		; 00002000H
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@NAHCEAI@DEFAULT_BUFFER_SIZE?$AA@
  00059	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  0005e	e8 00 00 00 00	 call	 PyModule_AddIntConstant
  00063	85 c0		 test	 eax, eax
  00065	7d 05		 jge	 SHORT $LN62@PyInit__io

; 608  :         goto fail;

  00067	e9 c2 09 00 00	 jmp	 $fail$20784
$LN62@PyInit__io:

; 609  : 
; 610  :     /* UnsupportedOperation inherits from ValueError and IOError */
; 611  :     state->unsupported_operation = PyObject_CallFunction(
; 612  :         (PyObject *)&PyType_Type, "s(OO){}",
; 613  :         "UnsupportedOperation", PyExc_ValueError, PyExc_IOError);

  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyExc_IOError
  00073	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00078	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR PyExc_ValueError
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BF@INDAPHCC@UnsupportedOperation?$AA@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07HPPCNGIB@s?$CIOO?$CJ?$HL?$HN?$AA@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyType_Type
  00094	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0009e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 614  :     if (state->unsupported_operation == NULL)

  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000a7	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000ac	75 05		 jne	 SHORT $LN61@PyInit__io

; 615  :         goto fail;

  000ae	e9 7b 09 00 00	 jmp	 $fail$20784
$LN61@PyInit__io:

; 616  :     Py_INCREF(state->unsupported_operation);

  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000b8	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000bc	e8 00 00 00 00	 call	 _Py_IncRef

; 617  :     if (PyModule_AddObject(m, "UnsupportedOperation",
; 618  :                            state->unsupported_operation) < 0)

  000c1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000c6	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@INDAPHCC@UnsupportedOperation?$AA@
  000d1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  000d6	e8 00 00 00 00	 call	 PyModule_AddObject
  000db	85 c0		 test	 eax, eax
  000dd	7d 05		 jge	 SHORT $LN60@PyInit__io

; 619  :         goto fail;

  000df	e9 4a 09 00 00	 jmp	 $fail$20784
$LN60@PyInit__io:

; 620  : 
; 621  :     /* BlockingIOError, for compatibility */
; 622  :     Py_INCREF(PyExc_BlockingIOError);

  000e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BlockingIOError
  000eb	e8 00 00 00 00	 call	 _Py_IncRef

; 623  :     if (PyModule_AddObject(m, "BlockingIOError",
; 624  :                            (PyObject *) PyExc_BlockingIOError) < 0)

  000f0	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PyExc_BlockingIOError
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JGPGLFDG@BlockingIOError?$AA@
  000fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00103	e8 00 00 00 00	 call	 PyModule_AddObject
  00108	85 c0		 test	 eax, eax
  0010a	7d 05		 jge	 SHORT $LN59@PyInit__io

; 625  :         goto fail;

  0010c	e9 1d 09 00 00	 jmp	 $fail$20784
$LN59@PyInit__io:

; 626  : 
; 627  :     /* Concrete base types of the IO ABCs.
; 628  :        (the ABCs themselves are declared through inheritance in io.py)
; 629  :     */
; 630  :     ADD_TYPE(&PyIOBase_Type, "_IOBase");

  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyIOBase_Type
  00118	e8 00 00 00 00	 call	 PyType_Ready
  0011d	85 c0		 test	 eax, eax
  0011f	7d 05		 jge	 SHORT $LN58@PyInit__io
  00121	e9 08 09 00 00	 jmp	 $fail$20784
$LN58@PyInit__io:
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyIOBase_Type
  0012d	e8 00 00 00 00	 call	 _Py_IncRef
  00132	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyIOBase_Type
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07NGNCJLEL@_IOBase?$AA@
  00140	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00145	e8 00 00 00 00	 call	 PyModule_AddObject
  0014a	85 c0		 test	 eax, eax
  0014c	7d 11		 jge	 SHORT $LN57@PyInit__io
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyIOBase_Type
  00155	e8 00 00 00 00	 call	 _Py_DecRef
  0015a	e9 cf 08 00 00	 jmp	 $fail$20784
$LN57@PyInit__io:

; 631  :     ADD_TYPE(&PyRawIOBase_Type, "_RawIOBase");

  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyRawIOBase_Type
  00166	e8 00 00 00 00	 call	 PyType_Ready
  0016b	85 c0		 test	 eax, eax
  0016d	7d 05		 jge	 SHORT $LN56@PyInit__io
  0016f	e9 ba 08 00 00	 jmp	 $fail$20784
$LN56@PyInit__io:
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyRawIOBase_Type
  0017b	e8 00 00 00 00	 call	 _Py_IncRef
  00180	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyRawIOBase_Type
  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@OPFLGGFN@_RawIOBase?$AA@
  0018e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00193	e8 00 00 00 00	 call	 PyModule_AddObject
  00198	85 c0		 test	 eax, eax
  0019a	7d 11		 jge	 SHORT $LN55@PyInit__io
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyRawIOBase_Type
  001a3	e8 00 00 00 00	 call	 _Py_DecRef
  001a8	e9 81 08 00 00	 jmp	 $fail$20784
$LN55@PyInit__io:

; 632  :     ADD_TYPE(&PyBufferedIOBase_Type, "_BufferedIOBase");

  001ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedIOBase_Type
  001b4	e8 00 00 00 00	 call	 PyType_Ready
  001b9	85 c0		 test	 eax, eax
  001bb	7d 05		 jge	 SHORT $LN54@PyInit__io
  001bd	e9 6c 08 00 00	 jmp	 $fail$20784
$LN54@PyInit__io:
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedIOBase_Type
  001c9	e8 00 00 00 00	 call	 _Py_IncRef
  001ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyBufferedIOBase_Type
  001d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GBFMJPJJ@_BufferedIOBase?$AA@
  001dc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  001e1	e8 00 00 00 00	 call	 PyModule_AddObject
  001e6	85 c0		 test	 eax, eax
  001e8	7d 11		 jge	 SHORT $LN53@PyInit__io
  001ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedIOBase_Type
  001f1	e8 00 00 00 00	 call	 _Py_DecRef
  001f6	e9 33 08 00 00	 jmp	 $fail$20784
$LN53@PyInit__io:

; 633  :     ADD_TYPE(&PyTextIOBase_Type, "_TextIOBase");

  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTextIOBase_Type
  00202	e8 00 00 00 00	 call	 PyType_Ready
  00207	85 c0		 test	 eax, eax
  00209	7d 05		 jge	 SHORT $LN52@PyInit__io
  0020b	e9 1e 08 00 00	 jmp	 $fail$20784
$LN52@PyInit__io:
  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTextIOBase_Type
  00217	e8 00 00 00 00	 call	 _Py_IncRef
  0021c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyTextIOBase_Type
  00223	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@JGAEDJGP@_TextIOBase?$AA@
  0022a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  0022f	e8 00 00 00 00	 call	 PyModule_AddObject
  00234	85 c0		 test	 eax, eax
  00236	7d 11		 jge	 SHORT $LN51@PyInit__io
  00238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTextIOBase_Type
  0023f	e8 00 00 00 00	 call	 _Py_DecRef
  00244	e9 e5 07 00 00	 jmp	 $fail$20784
$LN51@PyInit__io:

; 634  : 
; 635  :     /* Implementation of concrete IO objects. */
; 636  :     /* FileIO */
; 637  :     PyFileIO_Type.tp_base = &PyRawIOBase_Type;

  00249	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyRawIOBase_Type
  00250	48 89 05 58 01
	00 00		 mov	 QWORD PTR PyFileIO_Type+344, rax

; 638  :     ADD_TYPE(&PyFileIO_Type, "FileIO");

  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFileIO_Type
  0025e	e8 00 00 00 00	 call	 PyType_Ready
  00263	85 c0		 test	 eax, eax
  00265	7d 05		 jge	 SHORT $LN50@PyInit__io
  00267	e9 c2 07 00 00	 jmp	 $fail$20784
$LN50@PyInit__io:
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFileIO_Type
  00273	e8 00 00 00 00	 call	 _Py_IncRef
  00278	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyFileIO_Type
  0027f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DCCDEGKI@FileIO?$AA@
  00286	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  0028b	e8 00 00 00 00	 call	 PyModule_AddObject
  00290	85 c0		 test	 eax, eax
  00292	7d 11		 jge	 SHORT $LN49@PyInit__io
  00294	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFileIO_Type
  0029b	e8 00 00 00 00	 call	 _Py_DecRef
  002a0	e9 89 07 00 00	 jmp	 $fail$20784
$LN49@PyInit__io:

; 639  : 
; 640  :     /* BytesIO */
; 641  :     PyBytesIO_Type.tp_base = &PyBufferedIOBase_Type;

  002a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBufferedIOBase_Type
  002ac	48 89 05 58 01
	00 00		 mov	 QWORD PTR PyBytesIO_Type+344, rax

; 642  :     ADD_TYPE(&PyBytesIO_Type, "BytesIO");

  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBytesIO_Type
  002ba	e8 00 00 00 00	 call	 PyType_Ready
  002bf	85 c0		 test	 eax, eax
  002c1	7d 05		 jge	 SHORT $LN48@PyInit__io
  002c3	e9 66 07 00 00	 jmp	 $fail$20784
$LN48@PyInit__io:
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBytesIO_Type
  002cf	e8 00 00 00 00	 call	 _Py_IncRef
  002d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyBytesIO_Type
  002db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07DINECNOD@BytesIO?$AA@
  002e2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  002e7	e8 00 00 00 00	 call	 PyModule_AddObject
  002ec	85 c0		 test	 eax, eax
  002ee	7d 11		 jge	 SHORT $LN47@PyInit__io
  002f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBytesIO_Type
  002f7	e8 00 00 00 00	 call	 _Py_DecRef
  002fc	e9 2d 07 00 00	 jmp	 $fail$20784
$LN47@PyInit__io:

; 643  :     if (PyType_Ready(&_PyBytesIOBuffer_Type) < 0)

  00301	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyBytesIOBuffer_Type
  00308	e8 00 00 00 00	 call	 PyType_Ready
  0030d	85 c0		 test	 eax, eax
  0030f	7d 05		 jge	 SHORT $LN46@PyInit__io

; 644  :         goto fail;

  00311	e9 18 07 00 00	 jmp	 $fail$20784
$LN46@PyInit__io:

; 645  : 
; 646  :     /* StringIO */
; 647  :     PyStringIO_Type.tp_base = &PyTextIOBase_Type;

  00316	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTextIOBase_Type
  0031d	48 89 05 58 01
	00 00		 mov	 QWORD PTR PyStringIO_Type+344, rax

; 648  :     ADD_TYPE(&PyStringIO_Type, "StringIO");

  00324	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyStringIO_Type
  0032b	e8 00 00 00 00	 call	 PyType_Ready
  00330	85 c0		 test	 eax, eax
  00332	7d 05		 jge	 SHORT $LN45@PyInit__io
  00334	e9 f5 06 00 00	 jmp	 $fail$20784
$LN45@PyInit__io:
  00339	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyStringIO_Type
  00340	e8 00 00 00 00	 call	 _Py_IncRef
  00345	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyStringIO_Type
  0034c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KGGGHFAL@StringIO?$AA@
  00353	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00358	e8 00 00 00 00	 call	 PyModule_AddObject
  0035d	85 c0		 test	 eax, eax
  0035f	7d 11		 jge	 SHORT $LN44@PyInit__io
  00361	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyStringIO_Type
  00368	e8 00 00 00 00	 call	 _Py_DecRef
  0036d	e9 bc 06 00 00	 jmp	 $fail$20784
$LN44@PyInit__io:

; 649  : 
; 650  :     /* BufferedReader */
; 651  :     PyBufferedReader_Type.tp_base = &PyBufferedIOBase_Type;

  00372	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBufferedIOBase_Type
  00379	48 89 05 58 01
	00 00		 mov	 QWORD PTR PyBufferedReader_Type+344, rax

; 652  :     ADD_TYPE(&PyBufferedReader_Type, "BufferedReader");

  00380	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedReader_Type
  00387	e8 00 00 00 00	 call	 PyType_Ready
  0038c	85 c0		 test	 eax, eax
  0038e	7d 05		 jge	 SHORT $LN43@PyInit__io
  00390	e9 99 06 00 00	 jmp	 $fail$20784
$LN43@PyInit__io:
  00395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedReader_Type
  0039c	e8 00 00 00 00	 call	 _Py_IncRef
  003a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyBufferedReader_Type
  003a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@HDPOGIKD@BufferedReader?$AA@
  003af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  003b4	e8 00 00 00 00	 call	 PyModule_AddObject
  003b9	85 c0		 test	 eax, eax
  003bb	7d 11		 jge	 SHORT $LN42@PyInit__io
  003bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedReader_Type
  003c4	e8 00 00 00 00	 call	 _Py_DecRef
  003c9	e9 60 06 00 00	 jmp	 $fail$20784
$LN42@PyInit__io:

; 653  : 
; 654  :     /* BufferedWriter */
; 655  :     PyBufferedWriter_Type.tp_base = &PyBufferedIOBase_Type;

  003ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBufferedIOBase_Type
  003d5	48 89 05 58 01
	00 00		 mov	 QWORD PTR PyBufferedWriter_Type+344, rax

; 656  :     ADD_TYPE(&PyBufferedWriter_Type, "BufferedWriter");

  003dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedWriter_Type
  003e3	e8 00 00 00 00	 call	 PyType_Ready
  003e8	85 c0		 test	 eax, eax
  003ea	7d 05		 jge	 SHORT $LN41@PyInit__io
  003ec	e9 3d 06 00 00	 jmp	 $fail$20784
$LN41@PyInit__io:
  003f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedWriter_Type
  003f8	e8 00 00 00 00	 call	 _Py_IncRef
  003fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyBufferedWriter_Type
  00404	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FPHMGJHJ@BufferedWriter?$AA@
  0040b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00410	e8 00 00 00 00	 call	 PyModule_AddObject
  00415	85 c0		 test	 eax, eax
  00417	7d 11		 jge	 SHORT $LN40@PyInit__io
  00419	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedWriter_Type
  00420	e8 00 00 00 00	 call	 _Py_DecRef
  00425	e9 04 06 00 00	 jmp	 $fail$20784
$LN40@PyInit__io:

; 657  : 
; 658  :     /* BufferedRWPair */
; 659  :     PyBufferedRWPair_Type.tp_base = &PyBufferedIOBase_Type;

  0042a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBufferedIOBase_Type
  00431	48 89 05 58 01
	00 00		 mov	 QWORD PTR PyBufferedRWPair_Type+344, rax

; 660  :     ADD_TYPE(&PyBufferedRWPair_Type, "BufferedRWPair");

  00438	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedRWPair_Type
  0043f	e8 00 00 00 00	 call	 PyType_Ready
  00444	85 c0		 test	 eax, eax
  00446	7d 05		 jge	 SHORT $LN39@PyInit__io
  00448	e9 e1 05 00 00	 jmp	 $fail$20784
$LN39@PyInit__io:
  0044d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedRWPair_Type
  00454	e8 00 00 00 00	 call	 _Py_IncRef
  00459	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyBufferedRWPair_Type
  00460	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@JIMJFGGF@BufferedRWPair?$AA@
  00467	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  0046c	e8 00 00 00 00	 call	 PyModule_AddObject
  00471	85 c0		 test	 eax, eax
  00473	7d 11		 jge	 SHORT $LN38@PyInit__io
  00475	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedRWPair_Type
  0047c	e8 00 00 00 00	 call	 _Py_DecRef
  00481	e9 a8 05 00 00	 jmp	 $fail$20784
$LN38@PyInit__io:

; 661  : 
; 662  :     /* BufferedRandom */
; 663  :     PyBufferedRandom_Type.tp_base = &PyBufferedIOBase_Type;

  00486	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBufferedIOBase_Type
  0048d	48 89 05 58 01
	00 00		 mov	 QWORD PTR PyBufferedRandom_Type+344, rax

; 664  :     ADD_TYPE(&PyBufferedRandom_Type, "BufferedRandom");

  00494	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedRandom_Type
  0049b	e8 00 00 00 00	 call	 PyType_Ready
  004a0	85 c0		 test	 eax, eax
  004a2	7d 05		 jge	 SHORT $LN37@PyInit__io
  004a4	e9 85 05 00 00	 jmp	 $fail$20784
$LN37@PyInit__io:
  004a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedRandom_Type
  004b0	e8 00 00 00 00	 call	 _Py_IncRef
  004b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyBufferedRandom_Type
  004bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@KKPCDGCM@BufferedRandom?$AA@
  004c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  004c8	e8 00 00 00 00	 call	 PyModule_AddObject
  004cd	85 c0		 test	 eax, eax
  004cf	7d 11		 jge	 SHORT $LN36@PyInit__io
  004d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedRandom_Type
  004d8	e8 00 00 00 00	 call	 _Py_DecRef
  004dd	e9 4c 05 00 00	 jmp	 $fail$20784
$LN36@PyInit__io:

; 665  : 
; 666  :     /* TextIOWrapper */
; 667  :     PyTextIOWrapper_Type.tp_base = &PyTextIOBase_Type;

  004e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTextIOBase_Type
  004e9	48 89 05 58 01
	00 00		 mov	 QWORD PTR PyTextIOWrapper_Type+344, rax

; 668  :     ADD_TYPE(&PyTextIOWrapper_Type, "TextIOWrapper");

  004f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTextIOWrapper_Type
  004f7	e8 00 00 00 00	 call	 PyType_Ready
  004fc	85 c0		 test	 eax, eax
  004fe	7d 05		 jge	 SHORT $LN35@PyInit__io
  00500	e9 29 05 00 00	 jmp	 $fail$20784
$LN35@PyInit__io:
  00505	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTextIOWrapper_Type
  0050c	e8 00 00 00 00	 call	 _Py_IncRef
  00511	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyTextIOWrapper_Type
  00518	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@CKECCIPK@TextIOWrapper?$AA@
  0051f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00524	e8 00 00 00 00	 call	 PyModule_AddObject
  00529	85 c0		 test	 eax, eax
  0052b	7d 11		 jge	 SHORT $LN34@PyInit__io
  0052d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTextIOWrapper_Type
  00534	e8 00 00 00 00	 call	 _Py_DecRef
  00539	e9 f0 04 00 00	 jmp	 $fail$20784
$LN34@PyInit__io:

; 669  : 
; 670  :     /* IncrementalNewlineDecoder */
; 671  :     ADD_TYPE(&PyIncrementalNewlineDecoder_Type, "IncrementalNewlineDecoder");

  0053e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyIncrementalNewlineDecoder_Type
  00545	e8 00 00 00 00	 call	 PyType_Ready
  0054a	85 c0		 test	 eax, eax
  0054c	7d 05		 jge	 SHORT $LN33@PyInit__io
  0054e	e9 db 04 00 00	 jmp	 $fail$20784
$LN33@PyInit__io:
  00553	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyIncrementalNewlineDecoder_Type
  0055a	e8 00 00 00 00	 call	 _Py_IncRef
  0055f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyIncrementalNewlineDecoder_Type
  00566	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@KBKOCGBL@IncrementalNewlineDecoder?$AA@
  0056d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00572	e8 00 00 00 00	 call	 PyModule_AddObject
  00577	85 c0		 test	 eax, eax
  00579	7d 11		 jge	 SHORT $LN32@PyInit__io
  0057b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyIncrementalNewlineDecoder_Type
  00582	e8 00 00 00 00	 call	 _Py_DecRef
  00587	e9 a2 04 00 00	 jmp	 $fail$20784
$LN32@PyInit__io:

; 672  : 
; 673  :     /* Interned strings */
; 674  : #define ADD_INTERNED(name) \
; 675  :     if (!_PyIO_str_ ## name && \
; 676  :         !(_PyIO_str_ ## name = PyUnicode_InternFromString(# name))) \
; 677  :         goto fail;
; 678  : 
; 679  :     ADD_INTERNED(close)

  0058c	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_close, 0
  00594	75 22		 jne	 SHORT $LN31@PyInit__io
  00596	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LBOHBHFK@close?$AA@
  0059d	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  005a2	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_close, rax
  005a9	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_close, 0
  005b1	75 05		 jne	 SHORT $LN31@PyInit__io
  005b3	e9 76 04 00 00	 jmp	 $fail$20784
$LN31@PyInit__io:

; 680  :     ADD_INTERNED(closed)

  005b8	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_closed, 0
  005c0	75 22		 jne	 SHORT $LN30@PyInit__io
  005c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06IKJOPBFO@closed?$AA@
  005c9	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  005ce	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_closed, rax
  005d5	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_closed, 0
  005dd	75 05		 jne	 SHORT $LN30@PyInit__io
  005df	e9 4a 04 00 00	 jmp	 $fail$20784
$LN30@PyInit__io:

; 681  :     ADD_INTERNED(decode)

  005e4	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_decode, 0
  005ec	75 22		 jne	 SHORT $LN29@PyInit__io
  005ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06KPNAMAEI@decode?$AA@
  005f5	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  005fa	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_decode, rax
  00601	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_decode, 0
  00609	75 05		 jne	 SHORT $LN29@PyInit__io
  0060b	e9 1e 04 00 00	 jmp	 $fail$20784
$LN29@PyInit__io:

; 682  :     ADD_INTERNED(encode)

  00610	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_encode, 0
  00618	75 22		 jne	 SHORT $LN28@PyInit__io
  0061a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06GDGADLDP@encode?$AA@
  00621	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00626	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_encode, rax
  0062d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_encode, 0
  00635	75 05		 jne	 SHORT $LN28@PyInit__io
  00637	e9 f2 03 00 00	 jmp	 $fail$20784
$LN28@PyInit__io:

; 683  :     ADD_INTERNED(fileno)

  0063c	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_fileno, 0
  00644	75 22		 jne	 SHORT $LN27@PyInit__io
  00646	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06FFBIALPD@fileno?$AA@
  0064d	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00652	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_fileno, rax
  00659	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_fileno, 0
  00661	75 05		 jne	 SHORT $LN27@PyInit__io
  00663	e9 c6 03 00 00	 jmp	 $fail$20784
$LN27@PyInit__io:

; 684  :     ADD_INTERNED(flush)

  00668	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_flush, 0
  00670	75 22		 jne	 SHORT $LN26@PyInit__io
  00672	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05GLCAEPFP@flush?$AA@
  00679	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0067e	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_flush, rax
  00685	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_flush, 0
  0068d	75 05		 jne	 SHORT $LN26@PyInit__io
  0068f	e9 9a 03 00 00	 jmp	 $fail$20784
$LN26@PyInit__io:

; 685  :     ADD_INTERNED(getstate)

  00694	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_getstate, 0
  0069c	75 22		 jne	 SHORT $LN25@PyInit__io
  0069e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08OINEKLLD@getstate?$AA@
  006a5	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  006aa	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_getstate, rax
  006b1	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_getstate, 0
  006b9	75 05		 jne	 SHORT $LN25@PyInit__io
  006bb	e9 6e 03 00 00	 jmp	 $fail$20784
$LN25@PyInit__io:

; 686  :     ADD_INTERNED(isatty)

  006c0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_isatty, 0
  006c8	75 22		 jne	 SHORT $LN24@PyInit__io
  006ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06BMABDNNN@isatty?$AA@
  006d1	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  006d6	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_isatty, rax
  006dd	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_isatty, 0
  006e5	75 05		 jne	 SHORT $LN24@PyInit__io
  006e7	e9 42 03 00 00	 jmp	 $fail$20784
$LN24@PyInit__io:

; 687  :     ADD_INTERNED(newlines)

  006ec	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_newlines, 0
  006f4	75 22		 jne	 SHORT $LN23@PyInit__io
  006f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08EGHAIIMO@newlines?$AA@
  006fd	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00702	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_newlines, rax
  00709	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_newlines, 0
  00711	75 05		 jne	 SHORT $LN23@PyInit__io
  00713	e9 16 03 00 00	 jmp	 $fail$20784
$LN23@PyInit__io:

; 688  :     ADD_INTERNED(read)

  00718	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_read, 0
  00720	75 22		 jne	 SHORT $LN22@PyInit__io
  00722	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04POLDLDMI@read?$AA@
  00729	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0072e	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_read, rax
  00735	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_read, 0
  0073d	75 05		 jne	 SHORT $LN22@PyInit__io
  0073f	e9 ea 02 00 00	 jmp	 $fail$20784
$LN22@PyInit__io:

; 689  :     ADD_INTERNED(read1)

  00744	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_read1, 0
  0074c	75 22		 jne	 SHORT $LN21@PyInit__io
  0074e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05FDBMPOID@read1?$AA@
  00755	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0075a	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_read1, rax
  00761	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_read1, 0
  00769	75 05		 jne	 SHORT $LN21@PyInit__io
  0076b	e9 be 02 00 00	 jmp	 $fail$20784
$LN21@PyInit__io:

; 690  :     ADD_INTERNED(readable)

  00770	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_readable, 0
  00778	75 22		 jne	 SHORT $LN20@PyInit__io
  0077a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08INDGGIBD@readable?$AA@
  00781	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00786	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_readable, rax
  0078d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_readable, 0
  00795	75 05		 jne	 SHORT $LN20@PyInit__io
  00797	e9 92 02 00 00	 jmp	 $fail$20784
$LN20@PyInit__io:

; 691  :     ADD_INTERNED(readall)

  0079c	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_readall, 0
  007a4	75 22		 jne	 SHORT $LN19@PyInit__io
  007a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07JCDFOMC@readall?$AA@
  007ad	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  007b2	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_readall, rax
  007b9	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_readall, 0
  007c1	75 05		 jne	 SHORT $LN19@PyInit__io
  007c3	e9 66 02 00 00	 jmp	 $fail$20784
$LN19@PyInit__io:

; 692  :     ADD_INTERNED(readinto)

  007c8	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_readinto, 0
  007d0	75 22		 jne	 SHORT $LN18@PyInit__io
  007d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08BPEKIGCI@readinto?$AA@
  007d9	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  007de	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_readinto, rax
  007e5	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_readinto, 0
  007ed	75 05		 jne	 SHORT $LN18@PyInit__io
  007ef	e9 3a 02 00 00	 jmp	 $fail$20784
$LN18@PyInit__io:

; 693  :     ADD_INTERNED(readline)

  007f4	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_readline, 0
  007fc	75 22		 jne	 SHORT $LN17@PyInit__io
  007fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KBCDPPMN@readline?$AA@
  00805	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0080a	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_readline, rax
  00811	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_readline, 0
  00819	75 05		 jne	 SHORT $LN17@PyInit__io
  0081b	e9 0e 02 00 00	 jmp	 $fail$20784
$LN17@PyInit__io:

; 694  :     ADD_INTERNED(reset)

  00820	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_reset, 0
  00828	75 22		 jne	 SHORT $LN16@PyInit__io
  0082a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05CFMALAOA@reset?$AA@
  00831	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00836	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_reset, rax
  0083d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_reset, 0
  00845	75 05		 jne	 SHORT $LN16@PyInit__io
  00847	e9 e2 01 00 00	 jmp	 $fail$20784
$LN16@PyInit__io:

; 695  :     ADD_INTERNED(seek)

  0084c	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_seek, 0
  00854	75 22		 jne	 SHORT $LN15@PyInit__io
  00856	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04EDECCOGL@seek?$AA@
  0085d	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00862	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_seek, rax
  00869	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_seek, 0
  00871	75 05		 jne	 SHORT $LN15@PyInit__io
  00873	e9 b6 01 00 00	 jmp	 $fail$20784
$LN15@PyInit__io:

; 696  :     ADD_INTERNED(seekable)

  00878	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_seekable, 0
  00880	75 22		 jne	 SHORT $LN14@PyInit__io
  00882	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08JPFEOKJG@seekable?$AA@
  00889	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0088e	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_seekable, rax
  00895	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_seekable, 0
  0089d	75 05		 jne	 SHORT $LN14@PyInit__io
  0089f	e9 8a 01 00 00	 jmp	 $fail$20784
$LN14@PyInit__io:

; 697  :     ADD_INTERNED(setstate)

  008a4	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_setstate, 0
  008ac	75 22		 jne	 SHORT $LN13@PyInit__io
  008ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08BJPILIMO@setstate?$AA@
  008b5	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  008ba	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_setstate, rax
  008c1	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_setstate, 0
  008c9	75 05		 jne	 SHORT $LN13@PyInit__io
  008cb	e9 5e 01 00 00	 jmp	 $fail$20784
$LN13@PyInit__io:

; 698  :     ADD_INTERNED(tell)

  008d0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_tell, 0
  008d8	75 22		 jne	 SHORT $LN12@PyInit__io
  008da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LBPCFPDD@tell?$AA@
  008e1	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  008e6	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_tell, rax
  008ed	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_tell, 0
  008f5	75 05		 jne	 SHORT $LN12@PyInit__io
  008f7	e9 32 01 00 00	 jmp	 $fail$20784
$LN12@PyInit__io:

; 699  :     ADD_INTERNED(truncate)

  008fc	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_truncate, 0
  00904	75 22		 jne	 SHORT $LN11@PyInit__io
  00906	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08MABILMFG@truncate?$AA@
  0090d	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00912	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_truncate, rax
  00919	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_truncate, 0
  00921	75 05		 jne	 SHORT $LN11@PyInit__io
  00923	e9 06 01 00 00	 jmp	 $fail$20784
$LN11@PyInit__io:

; 700  :     ADD_INTERNED(write)

  00928	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_write, 0
  00930	75 22		 jne	 SHORT $LN10@PyInit__io
  00932	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05NGFEDHGN@write?$AA@
  00939	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0093e	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_write, rax
  00945	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_write, 0
  0094d	75 05		 jne	 SHORT $LN10@PyInit__io
  0094f	e9 da 00 00 00	 jmp	 $fail$20784
$LN10@PyInit__io:

; 701  :     ADD_INTERNED(writable)

  00954	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_writable, 0
  0095c	75 22		 jne	 SHORT $LN9@PyInit__io
  0095e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08IBOGFJJC@writable?$AA@
  00965	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0096a	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_writable, rax
  00971	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_writable, 0
  00979	75 05		 jne	 SHORT $LN9@PyInit__io
  0097b	e9 ae 00 00 00	 jmp	 $fail$20784
$LN9@PyInit__io:

; 702  : 
; 703  :     if (!_PyIO_str_nl &&
; 704  :         !(_PyIO_str_nl = PyUnicode_InternFromString("\n")))

  00980	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_nl, 0
  00988	75 22		 jne	 SHORT $LN8@PyInit__io
  0098a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00991	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00996	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_str_nl, rax
  0099d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_str_nl, 0
  009a5	75 05		 jne	 SHORT $LN8@PyInit__io

; 705  :         goto fail;

  009a7	e9 82 00 00 00	 jmp	 $fail$20784
$LN8@PyInit__io:

; 706  : 
; 707  :     if (!_PyIO_empty_str &&
; 708  :         !(_PyIO_empty_str = PyUnicode_FromStringAndSize(NULL, 0)))

  009ac	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_empty_str, 0
  009b4	75 1c		 jne	 SHORT $LN7@PyInit__io
  009b6	33 d2		 xor	 edx, edx
  009b8	33 c9		 xor	 ecx, ecx
  009ba	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  009bf	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_empty_str, rax
  009c6	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_empty_str, 0
  009ce	75 02		 jne	 SHORT $LN7@PyInit__io

; 709  :         goto fail;

  009d0	eb 5c		 jmp	 SHORT $fail$20784
$LN7@PyInit__io:

; 710  :     if (!_PyIO_empty_bytes &&
; 711  :         !(_PyIO_empty_bytes = PyBytes_FromStringAndSize(NULL, 0)))

  009d2	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_empty_bytes, 0
  009da	75 1c		 jne	 SHORT $LN6@PyInit__io
  009dc	33 d2		 xor	 edx, edx
  009de	33 c9		 xor	 ecx, ecx
  009e0	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  009e5	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_empty_bytes, rax
  009ec	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_empty_bytes, 0
  009f4	75 02		 jne	 SHORT $LN6@PyInit__io

; 712  :         goto fail;

  009f6	eb 36		 jmp	 SHORT $fail$20784
$LN6@PyInit__io:

; 713  :     if (!_PyIO_zero &&
; 714  :         !(_PyIO_zero = PyLong_FromLong(0L)))

  009f8	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_zero, 0
  00a00	75 1a		 jne	 SHORT $LN5@PyInit__io
  00a02	33 c9		 xor	 ecx, ecx
  00a04	e8 00 00 00 00	 call	 PyLong_FromLong
  00a09	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyIO_zero, rax
  00a10	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyIO_zero, 0
  00a18	75 02		 jne	 SHORT $LN5@PyInit__io

; 715  :         goto fail;

  00a1a	eb 12		 jmp	 SHORT $fail$20784
$LN5@PyInit__io:

; 716  : 
; 717  :     state->initialized = 1;

  00a1c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00a21	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 718  : 
; 719  :     return m;

  00a27	48 8b 44 24 38	 mov	 rax, QWORD PTR m$[rsp]
  00a2c	eb 2c		 jmp	 SHORT $LN64@PyInit__io
$fail$20784:
$LN4@PyInit__io:

; 720  : 
; 721  :   fail:
; 722  :     Py_XDECREF(state->unsupported_operation);

  00a2e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00a33	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00a38	74 0e		 je	 SHORT $LN1@PyInit__io
  00a3a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00a3f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00a43	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyInit__io:
  00a48	33 c0		 xor	 eax, eax
  00a4a	85 c0		 test	 eax, eax
  00a4c	75 e0		 jne	 SHORT $LN4@PyInit__io

; 723  :     Py_DECREF(m);

  00a4e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00a53	e8 00 00 00 00	 call	 _Py_DecRef

; 724  :     return NULL;

  00a58	33 c0		 xor	 eax, eax
$LN64@PyInit__io:

; 725  : }

  00a5a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00a5e	c3		 ret	 0
PyInit__io ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
END
