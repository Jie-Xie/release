; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Py_HashSecret_Initialized
_BSS	SEGMENT
_Py_HashSecret_Initialized DD 01H DUP (?)
	ALIGN	8

pCryptGenRandom DQ 01H DUP (?)
hCryptProv DQ	01H DUP (?)
_BSS	ENDS
PUBLIC	??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@ ; `string'
PUBLIC	_PyOS_URandom
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\python\random.c
pdata	SEGMENT
$pdata$_PyOS_URandom DD imagerel $LN5
	DD	imagerel $LN5+86
	DD	imagerel $unwind$_PyOS_URandom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyOS_URandom DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@
CONST	SEGMENT
??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@ DB 'negative arg'
	DB	'ument not allowed', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyOS_URandom
_TEXT	SEGMENT
buffer$ = 48
size$ = 56
_PyOS_URandom PROC					; COMDAT

; 234  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 235  :     if (size < 0) {

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR size$[rsp], 0
  00014	7d 1a		 jge	 SHORT $LN2@PyOS_URand

; 236  :         PyErr_Format(PyExc_ValueError,
; 237  :                      "negative argument not allowed");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@
  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00024	e8 00 00 00 00	 call	 PyErr_Format

; 238  :         return -1;

  00029	b8 ff ff ff ff	 mov	 eax, -1
  0002e	eb 21		 jmp	 SHORT $LN3@PyOS_URand
$LN2@PyOS_URand:

; 239  :     }
; 240  :     if (size == 0)

  00030	48 83 7c 24 38
	00		 cmp	 QWORD PTR size$[rsp], 0
  00036	75 04		 jne	 SHORT $LN1@PyOS_URand

; 241  :         return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 15		 jmp	 SHORT $LN3@PyOS_URand
$LN1@PyOS_URand:

; 242  : 
; 243  : #ifdef MS_WINDOWS
; 244  :     return win32_urandom((unsigned char *)buffer, size, 1);

  0003c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00042	48 8b 54 24 38	 mov	 rdx, QWORD PTR size$[rsp]
  00047	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buffer$[rsp]
  0004c	e8 00 00 00 00	 call	 win32_urandom
$LN3@PyOS_URand:

; 245  : #else
; 246  : # ifdef __VMS
; 247  :     return vms_urandom((unsigned char *)buffer, size, 1);
; 248  : # else
; 249  :     return dev_urandom_python((char*)buffer, size);
; 250  : # endif
; 251  : #endif
; 252  : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
_PyOS_URandom ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@MBOFJODN@Failed?5to?5initialized?5the?5random@ ; `string'
EXTRN	Py_FatalError:PROC
EXTRN	PyErr_SetFromWindowsErr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_urandom DD imagerel win32_urandom
	DD	imagerel win32_urandom+222
	DD	imagerel $unwind$win32_urandom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_urandom DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0EC@MBOFJODN@Failed?5to?5initialized?5the?5random@
CONST	SEGMENT
??_C@_0EC@MBOFJODN@Failed?5to?5initialized?5the?5random@ DB 'Failed to in'
	DB	'itialized the randomized hash secret using CryptoGen)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win32_urandom
_TEXT	SEGMENT
chunk$ = 32
tv70 = 40
buffer$ = 64
size$ = 72
raise$ = 80
win32_urandom PROC					; COMDAT

; 68   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 69   :     Py_ssize_t chunk;
; 70   : 
; 71   :     if (hCryptProv == 0)

  00013	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hCryptProv, 0
  0001b	75 18		 jne	 SHORT $LN7@win32_uran

; 72   :     {
; 73   :         if (win32_urandom_init(raise) == -1)

  0001d	8b 4c 24 50	 mov	 ecx, DWORD PTR raise$[rsp]
  00021	e8 00 00 00 00	 call	 win32_urandom_init
  00026	83 f8 ff	 cmp	 eax, -1
  00029	75 0a		 jne	 SHORT $LN6@win32_uran

; 74   :             return -1;

  0002b	b8 ff ff ff ff	 mov	 eax, -1
  00030	e9 a4 00 00 00	 jmp	 $LN8@win32_uran
$LN6@win32_uran:
$LN7@win32_uran:
$LN5@win32_uran:

; 75   :     }
; 76   : 
; 77   :     while (size > 0)

  00035	48 83 7c 24 48
	00		 cmp	 QWORD PTR size$[rsp], 0
  0003b	0f 8e 96 00 00
	00		 jle	 $LN4@win32_uran

; 78   :     {
; 79   :         chunk = size > INT_MAX ? INT_MAX : size;

  00041	48 81 7c 24 48
	ff ff ff 7f	 cmp	 QWORD PTR size$[rsp], 2147483647 ; 7fffffffH
  0004a	7e 0b		 jle	 SHORT $LN10@win32_uran
  0004c	48 c7 44 24 28
	ff ff ff 7f	 mov	 QWORD PTR tv70[rsp], 2147483647 ; 7fffffffH
  00055	eb 0a		 jmp	 SHORT $LN11@win32_uran
$LN10@win32_uran:
  00057	48 8b 44 24 48	 mov	 rax, QWORD PTR size$[rsp]
  0005c	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN11@win32_uran:
  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  00066	48 89 44 24 20	 mov	 QWORD PTR chunk$[rsp], rax

; 80   :         if (!pCryptGenRandom(hCryptProv, chunk, buffer))

  0006b	4c 8b 44 24 40	 mov	 r8, QWORD PTR buffer$[rsp]
  00070	8b 54 24 20	 mov	 edx, DWORD PTR chunk$[rsp]
  00074	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hCryptProv
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR pCryptGenRandom
  00081	85 c0		 test	 eax, eax
  00083	75 23		 jne	 SHORT $LN3@win32_uran

; 81   :         {
; 82   :             /* CryptGenRandom() failed */
; 83   :             if (raise)

  00085	83 7c 24 50 00	 cmp	 DWORD PTR raise$[rsp], 0
  0008a	74 09		 je	 SHORT $LN2@win32_uran

; 84   :                 PyErr_SetFromWindowsErr(0);

  0008c	33 c9		 xor	 ecx, ecx
  0008e	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 85   :             else

  00093	eb 0c		 jmp	 SHORT $LN1@win32_uran
$LN2@win32_uran:

; 86   :                 Py_FatalError("Failed to initialized the randomized hash "
; 87   :                         "secret using CryptoGen)");

  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EC@MBOFJODN@Failed?5to?5initialized?5the?5random@
  0009c	e8 00 00 00 00	 call	 Py_FatalError
$LN1@win32_uran:

; 88   :             return -1;

  000a1	b8 ff ff ff ff	 mov	 eax, -1
  000a6	eb 31		 jmp	 SHORT $LN8@win32_uran
$LN3@win32_uran:

; 89   :         }
; 90   :         buffer += chunk;

  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR chunk$[rsp]
  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000b2	48 03 c8	 add	 rcx, rax
  000b5	48 8b c1	 mov	 rax, rcx
  000b8	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 91   :         size -= chunk;

  000bd	48 8b 44 24 20	 mov	 rax, QWORD PTR chunk$[rsp]
  000c2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR size$[rsp]
  000c7	48 2b c8	 sub	 rcx, rax
  000ca	48 8b c1	 mov	 rax, rcx
  000cd	48 89 44 24 48	 mov	 QWORD PTR size$[rsp], rax

; 92   :     }

  000d2	e9 5e ff ff ff	 jmp	 $LN5@win32_uran
$LN4@win32_uran:

; 93   :     return 0;

  000d7	33 c0		 xor	 eax, eax
$LN8@win32_uran:

; 94   : }

  000d9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dd	c3		 ret	 0
win32_urandom ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@FCHIGGOP@Failed?5to?5initialize?5Windows?5ran@ ; `string'
PUBLIC	??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@		; `string'
PUBLIC	??_C@_0BF@ILOJAFDL@CryptAcquireContextA?$AA@	; `string'
PUBLIC	??_C@_0N@INAGJMNN@advapi32?4dll?$AA@		; `string'
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_GetModuleHandleA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_urandom_init DD imagerel win32_urandom_init
	DD	imagerel win32_urandom_init+202
	DD	imagerel $unwind$win32_urandom_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_urandom_init DD 010801H
	DD	08208H
xdata	ENDS
;	COMDAT ??_C@_0DE@FCHIGGOP@Failed?5to?5initialize?5Windows?5ran@
CONST	SEGMENT
??_C@_0DE@FCHIGGOP@Failed?5to?5initialize?5Windows?5ran@ DB 'Failed to in'
	DB	'itialize Windows random API (CryptoGen)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@
CONST	SEGMENT
??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@ DB 'CryptGenRandom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ILOJAFDL@CryptAcquireContextA?$AA@
CONST	SEGMENT
??_C@_0BF@ILOJAFDL@CryptAcquireContextA?$AA@ DB 'CryptAcquireContextA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INAGJMNN@advapi32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@INAGJMNN@advapi32?4dll?$AA@ DB 'advapi32.dll', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win32_urandom_init
_TEXT	SEGMENT
hAdvAPI32$ = 48
pCryptAcquireContext$ = 56
raise$ = 80
win32_urandom_init PROC					; COMDAT

; 28   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 29   :     HINSTANCE hAdvAPI32 = NULL;

  00008	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR hAdvAPI32$[rsp], 0

; 30   :     CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;

  00011	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pCryptAcquireContext$[rsp], 0

; 31   : 
; 32   :     /* Obtain handle to the DLL containing CryptoAPI. This should not fail. */
; 33   :     hAdvAPI32 = GetModuleHandle("advapi32.dll");

  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@INAGJMNN@advapi32?4dll?$AA@
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  00027	48 89 44 24 30	 mov	 QWORD PTR hAdvAPI32$[rsp], rax

; 34   :     if(hAdvAPI32 == NULL)

  0002c	48 83 7c 24 30
	00		 cmp	 QWORD PTR hAdvAPI32$[rsp], 0
  00032	75 02		 jne	 SHORT $LN6@win32_uran@2

; 35   :         goto error;

  00034	eb 6e		 jmp	 SHORT $error$120429
$LN6@win32_uran@2:

; 36   : 
; 37   :     /* Obtain pointers to the CryptoAPI functions. This will fail on some early
; 38   :        versions of Win95. */
; 39   :     pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(
; 40   :                                hAdvAPI32, "CryptAcquireContextA");

  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@ILOJAFDL@CryptAcquireContextA?$AA@
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hAdvAPI32$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00048	48 89 44 24 38	 mov	 QWORD PTR pCryptAcquireContext$[rsp], rax

; 41   :     if (pCryptAcquireContext == NULL)

  0004d	48 83 7c 24 38
	00		 cmp	 QWORD PTR pCryptAcquireContext$[rsp], 0
  00053	75 02		 jne	 SHORT $LN5@win32_uran@2

; 42   :         goto error;

  00055	eb 4d		 jmp	 SHORT $error$120429
$LN5@win32_uran@2:

; 43   : 
; 44   :     pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32,
; 45   :                                                      "CryptGenRandom");

  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hAdvAPI32$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00069	48 89 05 00 00
	00 00		 mov	 QWORD PTR pCryptGenRandom, rax

; 46   :     if (pCryptGenRandom == NULL)

  00070	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pCryptGenRandom, 0
  00078	75 02		 jne	 SHORT $LN4@win32_uran@2

; 47   :         goto error;

  0007a	eb 28		 jmp	 SHORT $error$120429
$LN4@win32_uran@2:

; 48   : 
; 49   :     /* Acquire context */
; 50   :     if (! pCryptAcquireContext(&hCryptProv, NULL, NULL,
; 51   :                                PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))

  0007c	c7 44 24 20 00
	00 00 f0	 mov	 DWORD PTR [rsp+32], -268435456 ; f0000000H
  00084	41 b9 01 00 00
	00		 mov	 r9d, 1
  0008a	45 33 c0	 xor	 r8d, r8d
  0008d	33 d2		 xor	 edx, edx
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hCryptProv
  00096	ff 54 24 38	 call	 QWORD PTR pCryptAcquireContext$[rsp]
  0009a	85 c0		 test	 eax, eax
  0009c	75 02		 jne	 SHORT $LN3@win32_uran@2

; 52   :         goto error;

  0009e	eb 04		 jmp	 SHORT $error$120429
$LN3@win32_uran@2:

; 53   : 
; 54   :     return 0;

  000a0	33 c0		 xor	 eax, eax
  000a2	eb 21		 jmp	 SHORT $LN7@win32_uran@2
$error$120429:

; 55   : 
; 56   : error:
; 57   :     if (raise)

  000a4	83 7c 24 50 00	 cmp	 DWORD PTR raise$[rsp], 0
  000a9	74 09		 je	 SHORT $LN2@win32_uran@2

; 58   :         PyErr_SetFromWindowsErr(0);

  000ab	33 c9		 xor	 ecx, ecx
  000ad	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 59   :     else

  000b2	eb 0c		 jmp	 SHORT $LN1@win32_uran@2
$LN2@win32_uran@2:

; 60   :         Py_FatalError("Failed to initialize Windows random API (CryptoGen)");

  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DE@FCHIGGOP@Failed?5to?5initialize?5Windows?5ran@
  000bb	e8 00 00 00 00	 call	 Py_FatalError
$LN1@win32_uran@2:

; 61   :     return -1;

  000c0	b8 ff ff ff ff	 mov	 eax, -1
$LN7@win32_uran@2:

; 62   : }

  000c5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c9	c3		 ret	 0
win32_urandom_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@INPDKPJA@PYTHONHASHSEED?5must?5be?5?$CCrandom?$CC?5@ ; `string'
PUBLIC	??_C@_06NLFCANPD@random?$AA@			; `string'
PUBLIC	??_C@_0P@FFABKKFN@PYTHONHASHSEED?$AA@		; `string'
PUBLIC	_PyRandom_Init
EXTRN	memset:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_strtoul:PROC
EXTRN	strcmp:PROC
EXTRN	__imp_getenv:PROC
EXTRN	Py_IgnoreEnvironmentFlag:DWORD
EXTRN	_Py_HashSecret:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyRandom_Init DD imagerel $LN12
	DD	imagerel $LN12+305
	DD	imagerel $unwind$_PyRandom_Init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyRandom_Init DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0EH@INPDKPJA@PYTHONHASHSEED?5must?5be?5?$CCrandom?$CC?5@
CONST	SEGMENT
??_C@_0EH@INPDKPJA@PYTHONHASHSEED?5must?5be?5?$CCrandom?$CC?5@ DB 'PYTHON'
	DB	'HASHSEED must be "random" or an integer in range [0; 42949672'
	DB	'95]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06NLFCANPD@random?$AA@
CONST	SEGMENT
??_C@_06NLFCANPD@random?$AA@ DB 'random', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FFABKKFN@PYTHONHASHSEED?$AA@
CONST	SEGMENT
??_C@_0P@FFABKKFN@PYTHONHASHSEED?$AA@ DB 'PYTHONHASHSEED', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyRandom_Init
_TEXT	SEGMENT
env$ = 32
secret_size$ = 40
secret$ = 48
endptr$120495 = 56
seed$120496 = 64
tv68 = 72
_PyRandom_Init PROC					; COMDAT

; 256  : {

$LN12:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 257  :     char *env;
; 258  :     void *secret = &_Py_HashSecret;

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_HashSecret
  0000b	48 89 44 24 30	 mov	 QWORD PTR secret$[rsp], rax

; 259  :     Py_ssize_t secret_size = sizeof(_Py_HashSecret_t);

  00010	48 c7 44 24 28
	10 00 00 00	 mov	 QWORD PTR secret_size$[rsp], 16

; 260  : 
; 261  :     if (_Py_HashSecret_Initialized)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Py_HashSecret_Initialized, 0
  00020	74 05		 je	 SHORT $LN7@PyRandom_I

; 262  :         return;

  00022	e9 05 01 00 00	 jmp	 $LN8@PyRandom_I
$LN7@PyRandom_I:

; 263  :     _Py_HashSecret_Initialized = 1;

  00027	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Py_HashSecret_Initialized, 1

; 264  : 
; 265  :     /*
; 266  :       Hash randomization is enabled.  Generate a per-process secret,
; 267  :       using PYTHONHASHSEED if provided.
; 268  :     */
; 269  : 
; 270  :     env = Py_GETENV("PYTHONHASHSEED");

  00031	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  00038	74 0b		 je	 SHORT $LN10@PyRandom_I
  0003a	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
  00043	eb 12		 jmp	 SHORT $LN11@PyRandom_I
$LN10@PyRandom_I:
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@FFABKKFN@PYTHONHASHSEED?$AA@
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  00052	48 89 44 24 48	 mov	 QWORD PTR tv68[rsp], rax
$LN11@PyRandom_I:
  00057	48 8b 44 24 48	 mov	 rax, QWORD PTR tv68[rsp]
  0005c	48 89 44 24 20	 mov	 QWORD PTR env$[rsp], rax

; 271  :     if (env && *env != '\0' && strcmp(env, "random") != 0) {

  00061	48 83 7c 24 20
	00		 cmp	 QWORD PTR env$[rsp], 0
  00067	0f 84 ad 00 00
	00		 je	 $LN6@PyRandom_I
  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR env$[rsp]
  00072	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00075	85 c0		 test	 eax, eax
  00077	0f 84 9d 00 00
	00		 je	 $LN6@PyRandom_I
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06NLFCANPD@random?$AA@
  00084	48 8b 4c 24 20	 mov	 rcx, QWORD PTR env$[rsp]
  00089	e8 00 00 00 00	 call	 strcmp
  0008e	85 c0		 test	 eax, eax
  00090	0f 84 84 00 00
	00		 je	 $LN6@PyRandom_I

; 272  :         char *endptr = env;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR env$[rsp]
  0009b	48 89 44 24 38	 mov	 QWORD PTR endptr$120495[rsp], rax

; 273  :         unsigned long seed;
; 274  :         seed = strtoul(env, &endptr, 10);

  000a0	41 b8 0a 00 00
	00		 mov	 r8d, 10
  000a6	48 8d 54 24 38	 lea	 rdx, QWORD PTR endptr$120495[rsp]
  000ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR env$[rsp]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  000b6	89 44 24 40	 mov	 DWORD PTR seed$120496[rsp], eax

; 275  :         if (*endptr != '\0'
; 276  :             || seed > 4294967295UL
; 277  :             || (errno == ERANGE && seed == ULONG_MAX))

  000ba	48 8b 44 24 38	 mov	 rax, QWORD PTR endptr$120495[rsp]
  000bf	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c2	85 c0		 test	 eax, eax
  000c4	75 19		 jne	 SHORT $LN4@PyRandom_I
  000c6	83 7c 24 40 ff	 cmp	 DWORD PTR seed$120496[rsp], -1 ; ffffffffH
  000cb	77 12		 ja	 SHORT $LN4@PyRandom_I
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d3	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  000d6	75 13		 jne	 SHORT $LN5@PyRandom_I
  000d8	83 7c 24 40 ff	 cmp	 DWORD PTR seed$120496[rsp], -1 ; ffffffffH
  000dd	75 0c		 jne	 SHORT $LN5@PyRandom_I
$LN4@PyRandom_I:

; 278  :         {
; 279  :             Py_FatalError("PYTHONHASHSEED must be \"random\" or an integer "
; 280  :                           "in range [0; 4294967295]");

  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EH@INPDKPJA@PYTHONHASHSEED?5must?5be?5?$CCrandom?$CC?5@
  000e6	e8 00 00 00 00	 call	 Py_FatalError
$LN5@PyRandom_I:

; 281  :         }
; 282  :         if (seed == 0) {

  000eb	83 7c 24 40 00	 cmp	 DWORD PTR seed$120496[rsp], 0
  000f0	75 13		 jne	 SHORT $LN3@PyRandom_I

; 283  :             /* disable the randomized hash */
; 284  :             memset(secret, 0, secret_size);

  000f2	4c 8b 44 24 28	 mov	 r8, QWORD PTR secret_size$[rsp]
  000f7	33 d2		 xor	 edx, edx
  000f9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR secret$[rsp]
  000fe	e8 00 00 00 00	 call	 memset

; 285  :         }
; 286  :         else {

  00103	eb 13		 jmp	 SHORT $LN2@PyRandom_I
$LN3@PyRandom_I:

; 287  :             lcg_urandom(seed, (unsigned char*)secret, secret_size);

  00105	4c 8b 44 24 28	 mov	 r8, QWORD PTR secret_size$[rsp]
  0010a	48 8b 54 24 30	 mov	 rdx, QWORD PTR secret$[rsp]
  0010f	8b 4c 24 40	 mov	 ecx, DWORD PTR seed$120496[rsp]
  00113	e8 00 00 00 00	 call	 lcg_urandom
$LN2@PyRandom_I:

; 288  :         }
; 289  :     }
; 290  :     else {

  00118	eb 12		 jmp	 SHORT $LN1@PyRandom_I
$LN6@PyRandom_I:

; 291  : #ifdef MS_WINDOWS
; 292  :         (void)win32_urandom((unsigned char *)secret, secret_size, 0);

  0011a	45 33 c0	 xor	 r8d, r8d
  0011d	48 8b 54 24 28	 mov	 rdx, QWORD PTR secret_size$[rsp]
  00122	48 8b 4c 24 30	 mov	 rcx, QWORD PTR secret$[rsp]
  00127	e8 00 00 00 00	 call	 win32_urandom
$LN1@PyRandom_I:
$LN8@PyRandom_I:

; 293  : #else /* #ifdef MS_WINDOWS */
; 294  : # ifdef __VMS
; 295  :         vms_urandom((unsigned char *)secret, secret_size, 0);
; 296  : # else
; 297  :         dev_urandom_noraise((char*)secret, secret_size);
; 298  : # endif
; 299  : #endif
; 300  :     }
; 301  : }

  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	c3		 ret	 0
_PyRandom_Init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lcg_urandom DD imagerel lcg_urandom
	DD	imagerel lcg_urandom+120
	DD	imagerel $unwind$lcg_urandom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lcg_urandom DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lcg_urandom
_TEXT	SEGMENT
x$ = 0
index$ = 8
x0$ = 32
buffer$ = 40
size$ = 48
lcg_urandom PROC					; COMDAT

; 214  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 215  :     size_t index;
; 216  :     unsigned int x;
; 217  : 
; 218  :     x = x0;

  00012	8b 44 24 20	 mov	 eax, DWORD PTR x0$[rsp]
  00016	89 04 24	 mov	 DWORD PTR x$[rsp], eax

; 219  :     for (index=0; index < size; index++) {

  00019	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR index$[rsp], 0
  00022	eb 0d		 jmp	 SHORT $LN3@lcg_urando
$LN2@lcg_urando:
  00024	48 8b 44 24 08	 mov	 rax, QWORD PTR index$[rsp]
  00029	48 ff c0	 inc	 rax
  0002c	48 89 44 24 08	 mov	 QWORD PTR index$[rsp], rax
$LN3@lcg_urando:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  00036	48 39 44 24 08	 cmp	 QWORD PTR index$[rsp], rax
  0003b	73 36		 jae	 SHORT $LN1@lcg_urando

; 220  :         x *= 214013;

  0003d	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  00040	69 c0 fd 43 03
	00		 imul	 eax, 214013		; 000343fdH
  00046	89 04 24	 mov	 DWORD PTR x$[rsp], eax

; 221  :         x += 2531011;

  00049	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  0004c	05 c3 9e 26 00	 add	 eax, 2531011		; 00269ec3H
  00051	89 04 24	 mov	 DWORD PTR x$[rsp], eax

; 222  :         /* modulo 2 ^ (8 * sizeof(int)) */
; 223  :         buffer[index] = (x >> 16) & 0xff;

  00054	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  00057	c1 e8 10	 shr	 eax, 16
  0005a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR index$[rsp]
  00064	48 8b 54 24 28	 mov	 rdx, QWORD PTR buffer$[rsp]
  00069	48 03 d1	 add	 rdx, rcx
  0006c	48 8b ca	 mov	 rcx, rdx
  0006f	88 01		 mov	 BYTE PTR [rcx], al

; 224  :     }

  00071	eb b1		 jmp	 SHORT $LN2@lcg_urando
$LN1@lcg_urando:

; 225  : }

  00073	48 83 c4 18	 add	 rsp, 24
  00077	c3		 ret	 0
lcg_urandom ENDP
_TEXT	ENDS
END
