; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@NBDGFOAF@_codecs_iso2022?$AA@		; `string'
PUBLIC	??_C@_0P@BALMELIG@iso2022_jp_ext?$AA@		; `string'
PUBLIC	??_C@_0N@IFNIFDHC@iso2022_jp_3?$AA@		; `string'
PUBLIC	??_C@_0BA@BMOBCPLM@iso2022_jp_2004?$AA@		; `string'
PUBLIC	??_C@_0N@JMMDGCDD@iso2022_jp_2?$AA@		; `string'
PUBLIC	??_C@_0N@LHOODBPA@iso2022_jp_1?$AA@		; `string'
PUBLIC	??_C@_0L@CFIMACKG@iso2022_jp?$AA@		; `string'
PUBLIC	??_C@_0L@BGHIAKBD@iso2022_kr?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_08IAFCJBEI@getcodec?$AA@			; `string'
_BSS	SEGMENT
?cofunc@?1??getmultibytecodec@@9@9 DQ 01H DUP (?)	; `getmultibytecodec'::`2'::cofunc
cp949_encmap DQ	01H DUP (?)
ksx1001_decmap DQ 01H DUP (?)
jisxcommon_encmap DQ 01H DUP (?)
jisx0208_decmap DQ 01H DUP (?)
jisx0212_decmap DQ 01H DUP (?)
jisx0213_bmp_encmap DQ 01H DUP (?)
jisx0213_1_bmp_decmap DQ 01H DUP (?)
jisx0213_2_bmp_decmap DQ 01H DUP (?)
jisx0213_emp_encmap DQ 01H DUP (?)
jisx0213_1_emp_decmap DQ 01H DUP (?)
jisx0213_2_emp_decmap DQ 01H DUP (?)
gbcommon_encmap DQ 01H DUP (?)
gb2312_decmap DQ 01H DUP (?)
?initialized@?1??ksx1001_init@@9@9 DD 01H DUP (?)	; `ksx1001_init'::`2'::initialized
?initialized@?1??jisx0208_init@@9@9 DD 01H DUP (?)	; `jisx0208_init'::`2'::initialized
?initialized@?1??jisx0212_init@@9@9 DD 01H DUP (?)	; `jisx0212_init'::`2'::initialized
?initialized@?1??jisx0213_init@@9@9 DD 01H DUP (?)	; `jisx0213_init'::`2'::initialized
?initialized@?1??gb2312_init@@9@9 DD 01H DUP (?)	; `gb2312_init'::`2'::initialized
_BSS	ENDS
;	COMDAT ??_C@_0BA@NBDGFOAF@_codecs_iso2022?$AA@
CONST	SEGMENT
??_C@_0BA@NBDGFOAF@_codecs_iso2022?$AA@ DB '_codecs_iso2022', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BALMELIG@iso2022_jp_ext?$AA@
CONST	SEGMENT
??_C@_0P@BALMELIG@iso2022_jp_ext?$AA@ DB 'iso2022_jp_ext', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFNIFDHC@iso2022_jp_3?$AA@
CONST	SEGMENT
??_C@_0N@IFNIFDHC@iso2022_jp_3?$AA@ DB 'iso2022_jp_3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BMOBCPLM@iso2022_jp_2004?$AA@
CONST	SEGMENT
??_C@_0BA@BMOBCPLM@iso2022_jp_2004?$AA@ DB 'iso2022_jp_2004', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JMMDGCDD@iso2022_jp_2?$AA@
CONST	SEGMENT
??_C@_0N@JMMDGCDD@iso2022_jp_2?$AA@ DB 'iso2022_jp_2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LHOODBPA@iso2022_jp_1?$AA@
CONST	SEGMENT
??_C@_0N@LHOODBPA@iso2022_jp_1?$AA@ DB 'iso2022_jp_1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CFIMACKG@iso2022_jp?$AA@
CONST	SEGMENT
??_C@_0L@CFIMACKG@iso2022_jp?$AA@ DB 'iso2022_jp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BGHIAKBD@iso2022_kr?$AA@
CONST	SEGMENT
??_C@_0L@BGHIAKBD@iso2022_kr?$AA@ DB 'iso2022_kr', 00H	; `string'
CONST	ENDS
CONST	SEGMENT
iso2022_kr_designations DB 0c3H
	DB	01H
	DB	02H
	ORG $+5
	DQ	FLAT:ksx1001_init
	DQ	FLAT:ksx1001_decoder
	DQ	FLAT:ksx1001_encoder
	DB	00H
	ORG $+31
iso2022_kr_config DD 00H
	ORG $+4
	DQ	FLAT:iso2022_kr_designations
iso2022_jp_designations DB 0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	04aH
	DB	00H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:jisx0201_r_decoder
	DQ	FLAT:jisx0201_r_encoder
	DB	0c0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	00H
	ORG $+31
iso2022_jp_config DD 05H
	ORG $+4
	DQ	FLAT:iso2022_jp_designations
iso2022_jp_1_designations DB 0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	0c4H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0212_init
	DQ	FLAT:jisx0212_decoder
	DQ	FLAT:jisx0212_encoder
	DB	04aH
	DB	00H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:jisx0201_r_decoder
	DQ	FLAT:jisx0201_r_encoder
	DB	0c0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	00H
	ORG $+31
iso2022_jp_1_config DD 05H
	ORG $+4
	DQ	FLAT:iso2022_jp_1_designations
iso2022_jp_2_designations DB 0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	0c4H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0212_init
	DQ	FLAT:jisx0212_decoder
	DQ	FLAT:jisx0212_encoder
	DB	0c3H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:ksx1001_init
	DQ	FLAT:ksx1001_decoder
	DQ	FLAT:ksx1001_encoder
	DB	0c1H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:gb2312_init
	DQ	FLAT:gb2312_decoder
	DQ	FLAT:gb2312_encoder
	DB	04aH
	DB	00H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:jisx0201_r_decoder
	DQ	FLAT:jisx0201_r_encoder
	DB	0c0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	041H
	DB	02H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:dummy_decoder
	DQ	FLAT:dummy_encoder
	DB	046H
	DB	02H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:dummy_decoder
	DQ	FLAT:dummy_encoder
	DB	00H
	ORG $+31
iso2022_jp_2_config DD 07H
	ORG $+4
	DQ	FLAT:iso2022_jp_2_designations
iso2022_jp_2004_designations DB 0d1H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2004_1_decoder
	DQ	FLAT:jisx0213_2004_1_encoder_paironly
	DB	0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	0d1H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2004_1_decoder
	DQ	FLAT:jisx0213_2004_1_encoder
	DB	0d0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2004_2_decoder
	DQ	FLAT:jisx0213_2004_2_encoder
	DB	00H
	ORG $+31
iso2022_jp_2004_config DD 05H
	ORG $+4
	DQ	FLAT:iso2022_jp_2004_designations
iso2022_jp_3_designations DB 0cfH
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2000_1_decoder
	DQ	FLAT:jisx0213_2000_1_encoder_paironly
	DB	0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	0cfH
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2000_1_decoder
	DQ	FLAT:jisx0213_2000_1_encoder
	DB	0d0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2000_2_decoder
	DQ	FLAT:jisx0213_2000_2_encoder
	DB	00H
	ORG $+31
iso2022_jp_3_config DD 05H
	ORG $+4
	DQ	FLAT:iso2022_jp_3_designations
iso2022_jp_ext_designations DB 0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	0c4H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0212_init
	DQ	FLAT:jisx0212_decoder
	DQ	FLAT:jisx0212_encoder
	DB	04aH
	DB	00H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:jisx0201_r_decoder
	DQ	FLAT:jisx0201_r_encoder
	DB	049H
	DB	00H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:jisx0201_k_decoder
	DQ	FLAT:jisx0201_k_encoder
	DB	0c0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	00H
	ORG $+31
iso2022_jp_ext_config DD 05H
	ORG $+4
	DQ	FLAT:iso2022_jp_ext_designations
_mapping_list DQ FLAT:??_C@_00CNPNBAHC@?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
_codec_list DQ	FLAT:??_C@_0L@BGHIAKBD@iso2022_kr?$AA@
	DQ	FLAT:iso2022_kr_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0L@CFIMACKG@iso2022_jp?$AA@
	DQ	FLAT:iso2022_jp_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0N@LHOODBPA@iso2022_jp_1?$AA@
	DQ	FLAT:iso2022_jp_1_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0N@JMMDGCDD@iso2022_jp_2?$AA@
	DQ	FLAT:iso2022_jp_2_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0BA@BMOBCPLM@iso2022_jp_2004?$AA@
	DQ	FLAT:iso2022_jp_2004_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0N@IFNIFDHC@iso2022_jp_3?$AA@
	DQ	FLAT:iso2022_jp_3_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0P@BALMELIG@iso2022_jp_ext?$AA@
	DQ	FLAT:iso2022_jp_ext_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	DQ	0000000000000000H
	ORG $+56
CONST	ENDS
_DATA	SEGMENT
__methods DQ	FLAT:??_C@_08IAFCJBEI@getcodec?$AA@
	DQ	FLAT:getcodec
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
mapping_list DQ	FLAT:_mapping_list
codec_list DQ	FLAT:_codec_list
__module DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BA@NBDGFOAF@_codecs_iso2022?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:__methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAFCJBEI@getcodec?$AA@
CONST	SEGMENT
??_C@_08IAFCJBEI@getcodec?$AA@ DB 'getcodec', 00H	; `string'
CONST	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BM@KLNFDHAL@no?5such?5codec?5is?5supported?4?$AA@ ; `string'
PUBLIC	??_C@_0CA@DAHDGLOA@encoding?5name?5must?5be?5a?5string?4?$AA@ ; `string'
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyCapsule_New:PROC
EXTRN	PyExc_LookupError:QWORD
EXTRN	strcmp:PROC
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\cjkcodecs\cjkcodecs.h
pdata	SEGMENT
$pdata$getcodec DD imagerel getcodec
	DD	imagerel getcodec+306
	DD	imagerel $unwind$getcodec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getcodec DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@
CONST	SEGMENT
??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@ DB 'multibytecodec.__m'
	DB	'ap_*', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KLNFDHAL@no?5such?5codec?5is?5supported?4?$AA@
CONST	SEGMENT
??_C@_0BM@KLNFDHAL@no?5such?5codec?5is?5supported?4?$AA@ DB 'no such code'
	DB	'c is supported.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DAHDGLOA@encoding?5name?5must?5be?5a?5string?4?$AA@
CONST	SEGMENT
??_C@_0CA@DAHDGLOA@encoding?5name?5must?5be?5a?5string?4?$AA@ DB 'encodin'
	DB	'g name must be a string.', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT getcodec
_TEXT	SEGMENT
codecobj$ = 32
codec$ = 40
cofunc$ = 48
r$ = 56
enc$ = 64
self$ = 96
encoding$ = 104
getcodec PROC						; COMDAT

; 261  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 262  :     PyObject *codecobj, *r, *cofunc;
; 263  :     const MultibyteCodec *codec;
; 264  :     const char *enc;
; 265  : 
; 266  :     if (!PyUnicode_Check(encoding)) {

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR encoding$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00022	85 c0		 test	 eax, eax
  00024	75 1a		 jne	 SHORT $LN9@getcodec

; 267  :         PyErr_SetString(PyExc_TypeError,
; 268  :                         "encoding name must be a string.");

  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@DAHDGLOA@encoding?5name?5must?5be?5a?5string?4?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00034	e8 00 00 00 00	 call	 PyErr_SetString

; 269  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 ed 00 00 00	 jmp	 $LN10@getcodec
$LN9@getcodec:

; 270  :     }
; 271  :     enc = _PyUnicode_AsString(encoding);

  00040	48 8b 4c 24 68	 mov	 rcx, QWORD PTR encoding$[rsp]
  00045	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  0004a	48 89 44 24 40	 mov	 QWORD PTR enc$[rsp], rax

; 272  :     if (enc == NULL)

  0004f	48 83 7c 24 40
	00		 cmp	 QWORD PTR enc$[rsp], 0
  00055	75 07		 jne	 SHORT $LN8@getcodec

; 273  :         return NULL;

  00057	33 c0		 xor	 eax, eax
  00059	e9 cf 00 00 00	 jmp	 $LN10@getcodec
$LN8@getcodec:

; 274  : 
; 275  :     cofunc = getmultibytecodec();

  0005e	e8 00 00 00 00	 call	 getmultibytecodec
  00063	48 89 44 24 30	 mov	 QWORD PTR cofunc$[rsp], rax

; 276  :     if (cofunc == NULL)

  00068	48 83 7c 24 30
	00		 cmp	 QWORD PTR cofunc$[rsp], 0
  0006e	75 07		 jne	 SHORT $LN7@getcodec

; 277  :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	e9 b6 00 00 00	 jmp	 $LN10@getcodec
$LN7@getcodec:

; 278  : 
; 279  :     for (codec = codec_list; codec->encoding[0]; codec++)

  00077	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR codec_list
  0007e	48 89 44 24 28	 mov	 QWORD PTR codec$[rsp], rax
  00083	eb 0e		 jmp	 SHORT $LN6@getcodec
$LN5@getcodec:
  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR codec$[rsp]
  0008a	48 83 c0 48	 add	 rax, 72			; 00000048H
  0008e	48 89 44 24 28	 mov	 QWORD PTR codec$[rsp], rax
$LN6@getcodec:
  00093	48 8b 44 24 28	 mov	 rax, QWORD PTR codec$[rsp]
  00098	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1a		 je	 SHORT $LN4@getcodec

; 280  :         if (strcmp(codec->encoding, enc) == 0)

  000a2	48 8b 54 24 40	 mov	 rdx, QWORD PTR enc$[rsp]
  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR codec$[rsp]
  000ac	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000af	e8 00 00 00 00	 call	 strcmp
  000b4	85 c0		 test	 eax, eax
  000b6	75 02		 jne	 SHORT $LN3@getcodec

; 281  :             break;

  000b8	eb 02		 jmp	 SHORT $LN4@getcodec
$LN3@getcodec:

; 282  : 
; 283  :     if (codec->encoding[0] == '\0') {

  000ba	eb c9		 jmp	 SHORT $LN5@getcodec
$LN4@getcodec:
  000bc	48 8b 44 24 28	 mov	 rax, QWORD PTR codec$[rsp]
  000c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c7	85 c0		 test	 eax, eax
  000c9	75 17		 jne	 SHORT $LN2@getcodec

; 284  :         PyErr_SetString(PyExc_LookupError,
; 285  :                         "no such codec is supported.");

  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@KLNFDHAL@no?5such?5codec?5is?5supported?4?$AA@
  000d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_LookupError
  000d9	e8 00 00 00 00	 call	 PyErr_SetString

; 286  :         return NULL;

  000de	33 c0		 xor	 eax, eax
  000e0	eb 4b		 jmp	 SHORT $LN10@getcodec
$LN2@getcodec:

; 287  :     }
; 288  : 
; 289  :     codecobj = PyCapsule_New((void *)codec, PyMultibyteCodec_CAPSULE_NAME, NULL);

  000e2	45 33 c0	 xor	 r8d, r8d
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@
  000ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR codec$[rsp]
  000f1	e8 00 00 00 00	 call	 PyCapsule_New
  000f6	48 89 44 24 20	 mov	 QWORD PTR codecobj$[rsp], rax

; 290  :     if (codecobj == NULL)

  000fb	48 83 7c 24 20
	00		 cmp	 QWORD PTR codecobj$[rsp], 0
  00101	75 04		 jne	 SHORT $LN1@getcodec

; 291  :         return NULL;

  00103	33 c0		 xor	 eax, eax
  00105	eb 26		 jmp	 SHORT $LN10@getcodec
$LN1@getcodec:

; 292  : 
; 293  :     r = PyObject_CallFunctionObjArgs(cofunc, codecobj, NULL);

  00107	45 33 c0	 xor	 r8d, r8d
  0010a	48 8b 54 24 20	 mov	 rdx, QWORD PTR codecobj$[rsp]
  0010f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cofunc$[rsp]
  00114	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00119	48 89 44 24 38	 mov	 QWORD PTR r$[rsp], rax

; 294  :     Py_DECREF(codecobj);

  0011e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR codecobj$[rsp]
  00123	e8 00 00 00 00	 call	 _Py_DecRef

; 295  : 
; 296  :     return r;

  00128	48 8b 44 24 38	 mov	 rax, QWORD PTR r$[rsp]
$LN10@getcodec:

; 297  : }

  0012d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00131	c3		 ret	 0
getcodec ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@CGBPDBNI@__create_codec?$AA@		; `string'
PUBLIC	??_C@_0BA@EEJLBBNI@_multibytecodec?$AA@		; `string'
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_ImportModuleNoBlock:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\cjkcodecs\cjkcodecs.h
pdata	SEGMENT
$pdata$getmultibytecodec DD imagerel getmultibytecodec
	DD	imagerel getmultibytecodec+89
	DD	imagerel $unwind$getmultibytecodec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getmultibytecodec DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0P@CGBPDBNI@__create_codec?$AA@
CONST	SEGMENT
??_C@_0P@CGBPDBNI@__create_codec?$AA@ DB '__create_codec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EEJLBBNI@_multibytecodec?$AA@
CONST	SEGMENT
??_C@_0BA@EEJLBBNI@_multibytecodec?$AA@ DB '_multibytecodec', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT getmultibytecodec
_TEXT	SEGMENT
mod$20545 = 32
getmultibytecodec PROC					; COMDAT

; 246  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 247  :     static PyObject *cofunc = NULL;
; 248  : 
; 249  :     if (cofunc == NULL) {

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?cofunc@?1??getmultibytecodec@@9@9, 0
  0000c	75 3f		 jne	 SHORT $LN2@getmultiby

; 250  :         PyObject *mod = PyImport_ImportModuleNoBlock("_multibytecodec");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@EEJLBBNI@_multibytecodec?$AA@
  00015	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  0001a	48 89 44 24 20	 mov	 QWORD PTR mod$20545[rsp], rax

; 251  :         if (mod == NULL)

  0001f	48 83 7c 24 20
	00		 cmp	 QWORD PTR mod$20545[rsp], 0
  00025	75 04		 jne	 SHORT $LN1@getmultiby

; 252  :             return NULL;

  00027	33 c0		 xor	 eax, eax
  00029	eb 29		 jmp	 SHORT $LN3@getmultiby
$LN1@getmultiby:

; 253  :         cofunc = PyObject_GetAttrString(mod, "__create_codec");

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@CGBPDBNI@__create_codec?$AA@
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mod$20545[rsp]
  00037	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0003c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?cofunc@?1??getmultibytecodec@@9@9, rax

; 254  :         Py_DECREF(mod);

  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mod$20545[rsp]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@getmultiby:

; 255  :     }
; 256  :     return cofunc;

  0004d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?cofunc@?1??getmultibytecodec@@9@9
$LN3@getmultiby:

; 257  : }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
getmultibytecodec ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\cjkcodecs\_codecs_iso2022.c
pdata	SEGMENT
$pdata$iso2022_codec_init DD imagerel iso2022_codec_init
	DD	imagerel iso2022_codec_init+91
	DD	imagerel $unwind$iso2022_codec_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso2022_codec_init DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT iso2022_codec_init
_TEXT	SEGMENT
desig$ = 32
config$ = 64
iso2022_codec_init PROC					; COMDAT

; 125  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 126  :     const struct iso2022_designation *desig;
; 127  :     for (desig = CONFIG_DESIGNATIONS; desig->mark; desig++)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR config$[rsp]
  0000e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00012	48 89 44 24 20	 mov	 QWORD PTR desig$[rsp], rax
  00017	eb 0e		 jmp	 SHORT $LN4@iso2022_co
$LN3@iso2022_co:
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR desig$[rsp]
  0001e	48 83 c0 20	 add	 rax, 32			; 00000020H
  00022	48 89 44 24 20	 mov	 QWORD PTR desig$[rsp], rax
$LN4@iso2022_co:
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR desig$[rsp]
  0002c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002f	85 c0		 test	 eax, eax
  00031	74 21		 je	 SHORT $LN2@iso2022_co

; 128  :         if (desig->initializer != NULL && desig->initializer() != 0)

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR desig$[rsp]
  00038	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003d	74 13		 je	 SHORT $LN1@iso2022_co
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR desig$[rsp]
  00044	ff 50 08	 call	 QWORD PTR [rax+8]
  00047	85 c0		 test	 eax, eax
  00049	74 07		 je	 SHORT $LN1@iso2022_co

; 129  :             return -1;

  0004b	b8 ff ff ff ff	 mov	 eax, -1
  00050	eb 04		 jmp	 SHORT $LN5@iso2022_co
$LN1@iso2022_co:

; 130  :     return 0;

  00052	eb c5		 jmp	 SHORT $LN3@iso2022_co
$LN2@iso2022_co:
  00054	33 c0		 xor	 eax, eax
$LN5@iso2022_co:

; 131  : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
iso2022_codec_init ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT iso2022_encode_init
_TEXT	SEGMENT
state$ = 8
config$ = 16
iso2022_encode_init PROC				; COMDAT

; 134  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 135  :     STATE_CLEARFLAGS()

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0000f	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 136  :     STATE_SETG0(CHARSET_ASCII)

  00013	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00018	c6 00 42	 mov	 BYTE PTR [rax], 66	; 00000042H

; 137  :     STATE_SETG1(CHARSET_ASCII)

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00020	c6 40 01 42	 mov	 BYTE PTR [rax+1], 66	; 00000042H

; 138  :     return 0;

  00024	33 c0		 xor	 eax, eax

; 139  : }

  00026	c3		 ret	 0
iso2022_encode_init ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT iso2022_encode_reset
_TEXT	SEGMENT
state$ = 8
config$ = 16
outbuf$ = 24
outleft$ = 32
iso2022_encode_reset PROC				; COMDAT

; 142  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 143  :     if (STATE_GETFLAG(F_SHIFTED)) {

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00019	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0001d	83 e0 01	 and	 eax, 1
  00020	85 c0		 test	 eax, eax
  00022	74 53		 je	 SHORT $LN4@iso2022_en

; 144  :         WRITE1(SI)

  00024	48 83 7c 24 20
	01		 cmp	 QWORD PTR outleft$[rsp], 1
  0002a	7d 0c		 jge	 SHORT $LN3@iso2022_en
  0002c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00033	e9 ac 00 00 00	 jmp	 $LN5@iso2022_en
$LN3@iso2022_en:
  00038	48 8b 44 24 18	 mov	 rax, QWORD PTR outbuf$[rsp]
  0003d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00040	c6 00 0f	 mov	 BYTE PTR [rax], 15

; 145  :         NEXT_OUT(1)

  00043	48 8b 44 24 18	 mov	 rax, QWORD PTR outbuf$[rsp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 ff c0	 inc	 rax
  0004e	48 8b 4c 24 18	 mov	 rcx, QWORD PTR outbuf$[rsp]
  00053	48 89 01	 mov	 QWORD PTR [rcx], rax
  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR outleft$[rsp]
  0005b	48 ff c8	 dec	 rax
  0005e	48 89 44 24 20	 mov	 QWORD PTR outleft$[rsp], rax

; 146  :         STATE_CLEARFLAG(F_SHIFTED)

  00063	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00068	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0006c	83 e0 fe	 and	 eax, -2
  0006f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR state$[rsp]
  00074	88 41 04	 mov	 BYTE PTR [rcx+4], al
$LN4@iso2022_en:

; 147  :     }
; 148  :     if (STATE_G0 != CHARSET_ASCII) {

  00077	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0007c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007f	83 f8 42	 cmp	 eax, 66			; 00000042H
  00082	74 5e		 je	 SHORT $LN2@iso2022_en

; 149  :         WRITE3(ESC, '(', 'B')

  00084	48 83 7c 24 20
	03		 cmp	 QWORD PTR outleft$[rsp], 3
  0008a	7d 09		 jge	 SHORT $LN1@iso2022_en
  0008c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00093	eb 4f		 jmp	 SHORT $LN5@iso2022_en
$LN1@iso2022_en:
  00095	48 8b 44 24 18	 mov	 rax, QWORD PTR outbuf$[rsp]
  0009a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009d	c6 00 1b	 mov	 BYTE PTR [rax], 27
  000a0	48 8b 44 24 18	 mov	 rax, QWORD PTR outbuf$[rsp]
  000a5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a8	c6 40 01 28	 mov	 BYTE PTR [rax+1], 40	; 00000028H
  000ac	48 8b 44 24 18	 mov	 rax, QWORD PTR outbuf$[rsp]
  000b1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b4	c6 40 02 42	 mov	 BYTE PTR [rax+2], 66	; 00000042H

; 150  :         NEXT_OUT(3)

  000b8	48 8b 44 24 18	 mov	 rax, QWORD PTR outbuf$[rsp]
  000bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c0	48 83 c0 03	 add	 rax, 3
  000c4	48 8b 4c 24 18	 mov	 rcx, QWORD PTR outbuf$[rsp]
  000c9	48 89 01	 mov	 QWORD PTR [rcx], rax
  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR outleft$[rsp]
  000d1	48 83 e8 03	 sub	 rax, 3
  000d5	48 89 44 24 20	 mov	 QWORD PTR outleft$[rsp], rax

; 151  :         STATE_SETG0(CHARSET_ASCII)

  000da	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  000df	c6 00 42	 mov	 BYTE PTR [rax], 66	; 00000042H
$LN2@iso2022_en:

; 152  :     }
; 153  :     return 0;

  000e2	33 c0		 xor	 eax, eax
$LN5@iso2022_en:

; 154  : }

  000e4	f3 c3		 fatret	 0
iso2022_encode_reset ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EG@CCFLAEJE@?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_1EO@MBLKAJOP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAc?$AAj?$AAk?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA?2?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA_?$AAi?$AAs?$AAo@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$iso2022_encode DD imagerel iso2022_encode
	DD	imagerel iso2022_encode+2383
	DD	imagerel $unwind$iso2022_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso2022_encode DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT ??_C@_1EG@CCFLAEJE@?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1EG@CCFLAEJE@?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN@ DB 'd'
	DB	00H, 's', 00H, 'g', 00H, '-', 00H, '>', 00H, 'w', 00H, 'i', 00H
	DB	'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '1', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'd', 00H
	DB	's', 00H, 'g', 00H, '-', 00H, '>', 00H, 'w', 00H, 'i', 00H, 'd'
	DB	00H, 't', 00H, 'h', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'2', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@MBLKAJOP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAc?$AAj?$AAk?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA?2?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA_?$AAi?$AAs?$AAo@
CONST	SEGMENT
??_C@_1EO@MBLKAJOP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAc?$AAj?$AAk?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA?2?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA_?$AAi?$AAs?$AAo@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'c', 00H, 'j', 00H, 'k'
	DB	00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c', 00H, 's', 00H
	DB	'\', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, 's', 00H, '_', 00H, 'i', 00H, 's', 00H, 'o', 00H, '2', 00H
	DB	'0', 00H, '2', 00H, '2', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT iso2022_encode
_TEXT	SEGMENT
encoded$20804 = 32
dsg$20803 = 40
insize$20806 = 48
c$20805 = 56
length$20823 = 64
u4in$20829 = 72
tv142 = 80
tv189 = 84
state$ = 112
config$ = 120
inbuf$ = 128
inleft$ = 136
outbuf$ = 144
outleft$ = 152
flags$ = 160
iso2022_encode PROC					; COMDAT

; 157  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN56@iso2022_en@2:
$LN50@iso2022_en@2:

; 158  :     while (inleft > 0) {

  00018	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR inleft$[rsp], 0
  00021	0f 8e 21 09 00
	00		 jle	 $LN49@iso2022_en@2

; 159  :         const struct iso2022_designation *dsg;
; 160  :         DBCHAR encoded;
; 161  :         ucs4_t c = **inbuf;

  00027	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00035	89 44 24 38	 mov	 DWORD PTR c$20805[rsp], eax

; 162  :         Py_ssize_t insize;
; 163  : 
; 164  :         if (c < 0x80) {

  00039	81 7c 24 38 80
	00 00 00	 cmp	 DWORD PTR c$20805[rsp], 128 ; 00000080H
  00041	0f 83 82 01 00
	00		 jae	 $LN48@iso2022_en@2

; 165  :             if (STATE_G0 != CHARSET_ASCII) {

  00047	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0004c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004f	83 f8 42	 cmp	 eax, 66			; 00000042H
  00052	74 79		 je	 SHORT $LN47@iso2022_en@2

; 166  :                 WRITE3(ESC, '(', 'B')

  00054	48 83 bc 24 98
	00 00 00 03	 cmp	 QWORD PTR outleft$[rsp], 3
  0005d	7d 0c		 jge	 SHORT $LN46@iso2022_en@2
  0005f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00066	e9 df 08 00 00	 jmp	 $LN51@iso2022_en@2
$LN46@iso2022_en@2:
  0006b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00073	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00076	c6 00 1b	 mov	 BYTE PTR [rax], 27
  00079	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00081	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00084	c6 40 01 28	 mov	 BYTE PTR [rax+1], 40	; 00000028H
  00088	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00090	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00093	c6 40 02 42	 mov	 BYTE PTR [rax+2], 66	; 00000042H

; 167  :                 STATE_SETG0(CHARSET_ASCII)

  00097	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0009c	c6 00 42	 mov	 BYTE PTR [rax], 66	; 00000042H

; 168  :                 NEXT_OUT(3)

  0009f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  000a7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000aa	48 83 c0 03	 add	 rax, 3
  000ae	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  000b6	48 89 01	 mov	 QWORD PTR [rcx], rax
  000b9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  000c1	48 83 e8 03	 sub	 rax, 3
  000c5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
$LN47@iso2022_en@2:

; 169  :             }
; 170  :             if (STATE_GETFLAG(F_SHIFTED)) {

  000cd	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000d2	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000d6	83 e0 01	 and	 eax, 1
  000d9	85 c0		 test	 eax, eax
  000db	74 65		 je	 SHORT $LN45@iso2022_en@2

; 171  :                 WRITE1(SI)

  000dd	48 83 bc 24 98
	00 00 00 01	 cmp	 QWORD PTR outleft$[rsp], 1
  000e6	7d 0c		 jge	 SHORT $LN44@iso2022_en@2
  000e8	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000ef	e9 56 08 00 00	 jmp	 $LN51@iso2022_en@2
$LN44@iso2022_en@2:
  000f4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  000fc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ff	c6 00 0f	 mov	 BYTE PTR [rax], 15

; 172  :                 STATE_CLEARFLAG(F_SHIFTED)

  00102	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00107	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0010b	83 e0 fe	 and	 eax, -2
  0010e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00113	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 173  :                 NEXT_OUT(1)

  00116	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0011e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00121	48 ff c0	 inc	 rax
  00124	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0012c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0012f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  00137	48 ff c8	 dec	 rax
  0013a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
$LN45@iso2022_en@2:

; 174  :             }
; 175  :             WRITE1((unsigned char)c)

  00142	48 83 bc 24 98
	00 00 00 01	 cmp	 QWORD PTR outleft$[rsp], 1
  0014b	7d 0c		 jge	 SHORT $LN43@iso2022_en@2
  0014d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00154	e9 f1 07 00 00	 jmp	 $LN51@iso2022_en@2
$LN43@iso2022_en@2:
  00159	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00161	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00164	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR c$20805[rsp]
  00169	88 08		 mov	 BYTE PTR [rax], cl

; 176  :             NEXT(1, 1)

  0016b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00173	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00176	48 83 c0 02	 add	 rax, 2
  0017a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  00182	48 89 01	 mov	 QWORD PTR [rcx], rax
  00185	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR inleft$[rsp]
  0018d	48 ff c8	 dec	 rax
  00190	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR inleft$[rsp], rax
  00198	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  001a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a3	48 ff c0	 inc	 rax
  001a6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  001ae	48 89 01	 mov	 QWORD PTR [rcx], rax
  001b1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  001b9	48 ff c8	 dec	 rax
  001bc	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax

; 177  :             continue;

  001c4	e9 4f fe ff ff	 jmp	 $LN50@iso2022_en@2
$LN48@iso2022_en@2:

; 178  :         }
; 179  : 
; 180  :         DECODE_SURROGATE(c)

  001c9	8b 44 24 38	 mov	 eax, DWORD PTR c$20805[rsp]
  001cd	c1 e8 0a	 shr	 eax, 10
  001d0	83 f8 36	 cmp	 eax, 54			; 00000036H
  001d3	75 54		 jne	 SHORT $LN42@iso2022_en@2
  001d5	48 83 bc 24 88
	00 00 00 02	 cmp	 QWORD PTR inleft$[rsp], 2
  001de	7d 0c		 jge	 SHORT $LN41@iso2022_en@2
  001e0	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  001e7	e9 5e 07 00 00	 jmp	 $LN51@iso2022_en@2
$LN41@iso2022_en@2:
  001ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  001f4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f7	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  001fb	c1 f8 0a	 sar	 eax, 10
  001fe	83 f8 37	 cmp	 eax, 55			; 00000037H
  00201	75 26		 jne	 SHORT $LN40@iso2022_en@2
  00203	8b 44 24 38	 mov	 eax, DWORD PTR c$20805[rsp]
  00207	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  0020c	c1 e0 0a	 shl	 eax, 10
  0020f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  00217	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0021a	0f b7 49 02	 movzx	 ecx, WORD PTR [rcx+2]
  0021e	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  00225	89 44 24 38	 mov	 DWORD PTR c$20805[rsp], eax
$LN40@iso2022_en@2:
$LN42@iso2022_en@2:

; 181  :         insize = GET_INSIZE(c);

  00229	81 7c 24 38 ff
	ff 00 00	 cmp	 DWORD PTR c$20805[rsp], 65535 ; 0000ffffH
  00231	76 0a		 jbe	 SHORT $LN53@iso2022_en@2
  00233	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR tv142[rsp], 2
  0023b	eb 08		 jmp	 SHORT $LN54@iso2022_en@2
$LN53@iso2022_en@2:
  0023d	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
$LN54@iso2022_en@2:
  00245	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv142[rsp]
  0024a	48 89 44 24 30	 mov	 QWORD PTR insize$20806[rsp], rax

; 182  : 
; 183  :         encoded = MAP_UNMAPPABLE;

  0024f	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00254	66 89 44 24 20	 mov	 WORD PTR encoded$20804[rsp], ax

; 184  :         for (dsg = CONFIG_DESIGNATIONS; dsg->mark; dsg++) {

  00259	48 8b 44 24 78	 mov	 rax, QWORD PTR config$[rsp]
  0025e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00262	48 89 44 24 28	 mov	 QWORD PTR dsg$20803[rsp], rax
  00267	eb 0e		 jmp	 SHORT $LN39@iso2022_en@2
$LN38@iso2022_en@2:
  00269	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  0026e	48 83 c0 20	 add	 rax, 32			; 00000020H
  00272	48 89 44 24 28	 mov	 QWORD PTR dsg$20803[rsp], rax
$LN39@iso2022_en@2:
  00277	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  0027c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0027f	85 c0		 test	 eax, eax
  00281	0f 84 f3 00 00
	00		 je	 $LN37@iso2022_en@2

; 185  :             Py_ssize_t length = 1;

  00287	48 c7 44 24 40
	01 00 00 00	 mov	 QWORD PTR length$20823[rsp], 1

; 186  :             encoded = dsg->encoder(&c, &length);

  00290	48 8d 54 24 40	 lea	 rdx, QWORD PTR length$20823[rsp]
  00295	48 8d 4c 24 38	 lea	 rcx, QWORD PTR c$20805[rsp]
  0029a	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  0029f	ff 50 18	 call	 QWORD PTR [rax+24]
  002a2	66 89 44 24 20	 mov	 WORD PTR encoded$20804[rsp], ax

; 187  :             if (encoded == MAP_MULTIPLE_AVAIL) {

  002a7	0f b7 44 24 20	 movzx	 eax, WORD PTR encoded$20804[rsp]
  002ac	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  002b1	0f 85 b0 00 00
	00		 jne	 $LN36@iso2022_en@2

; 188  :                 /* this implementation won't work for pair
; 189  :                  * of non-bmp characters. */
; 190  :                 if (inleft < 2) {

  002b7	48 83 bc 24 88
	00 00 00 02	 cmp	 QWORD PTR inleft$[rsp], 2
  002c0	7d 25		 jge	 SHORT $LN35@iso2022_en@2

; 191  :                     if (!(flags & MBENC_FLUSH))

  002c2	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  002c9	83 e0 01	 and	 eax, 1
  002cc	85 c0		 test	 eax, eax
  002ce	75 0c		 jne	 SHORT $LN34@iso2022_en@2

; 192  :                         return MBERR_TOOFEW;

  002d0	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  002d7	e9 6e 06 00 00	 jmp	 $LN51@iso2022_en@2
$LN34@iso2022_en@2:

; 193  :                     length = -1;

  002dc	48 c7 44 24 40
	ff ff ff ff	 mov	 QWORD PTR length$20823[rsp], -1

; 194  :                 }
; 195  :                 else

  002e5	eb 09		 jmp	 SHORT $LN33@iso2022_en@2
$LN35@iso2022_en@2:

; 196  :                     length = 2;

  002e7	48 c7 44 24 40
	02 00 00 00	 mov	 QWORD PTR length$20823[rsp], 2
$LN33@iso2022_en@2:

; 197  : #if Py_UNICODE_SIZE == 2
; 198  :                 if (length == 2) {

  002f0	48 83 7c 24 40
	02		 cmp	 QWORD PTR length$20823[rsp], 2
  002f6	75 3e		 jne	 SHORT $LN32@iso2022_en@2

; 199  :                     ucs4_t u4in[2];
; 200  :                     u4in[0] = (ucs4_t)IN1;

  002f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00300	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00303	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00306	89 44 24 48	 mov	 DWORD PTR u4in$20829[rsp], eax

; 201  :                     u4in[1] = (ucs4_t)IN2;

  0030a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00312	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00315	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00319	89 44 24 4c	 mov	 DWORD PTR u4in$20829[rsp+4], eax

; 202  :                     encoded = dsg->encoder(u4in, &length);

  0031d	48 8d 54 24 40	 lea	 rdx, QWORD PTR length$20823[rsp]
  00322	48 8d 4c 24 48	 lea	 rcx, QWORD PTR u4in$20829[rsp]
  00327	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  0032c	ff 50 18	 call	 QWORD PTR [rax+24]
  0032f	66 89 44 24 20	 mov	 WORD PTR encoded$20804[rsp], ax

; 203  :                 } else

  00334	eb 17		 jmp	 SHORT $LN31@iso2022_en@2
$LN32@iso2022_en@2:

; 204  :                     encoded = dsg->encoder(&c, &length);

  00336	48 8d 54 24 40	 lea	 rdx, QWORD PTR length$20823[rsp]
  0033b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR c$20805[rsp]
  00340	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  00345	ff 50 18	 call	 QWORD PTR [rax+24]
  00348	66 89 44 24 20	 mov	 WORD PTR encoded$20804[rsp], ax
$LN31@iso2022_en@2:

; 205  : #else
; 206  :                 encoded = dsg->encoder(&c, &length);
; 207  : #endif
; 208  :                 if (encoded != MAP_UNMAPPABLE) {

  0034d	0f b7 44 24 20	 movzx	 eax, WORD PTR encoded$20804[rsp]
  00352	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00357	74 0c		 je	 SHORT $LN30@iso2022_en@2

; 209  :                     insize = length;

  00359	48 8b 44 24 40	 mov	 rax, QWORD PTR length$20823[rsp]
  0035e	48 89 44 24 30	 mov	 QWORD PTR insize$20806[rsp], rax

; 210  :                     break;

  00363	eb 15		 jmp	 SHORT $LN37@iso2022_en@2
$LN30@iso2022_en@2:

; 211  :                 }

  00365	eb 0e		 jmp	 SHORT $LN29@iso2022_en@2
$LN36@iso2022_en@2:

; 212  :             }
; 213  :             else if (encoded != MAP_UNMAPPABLE)

  00367	0f b7 44 24 20	 movzx	 eax, WORD PTR encoded$20804[rsp]
  0036c	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00371	74 02		 je	 SHORT $LN28@iso2022_en@2

; 214  :                 break;

  00373	eb 05		 jmp	 SHORT $LN37@iso2022_en@2
$LN28@iso2022_en@2:
$LN29@iso2022_en@2:

; 215  :         }

  00375	e9 ef fe ff ff	 jmp	 $LN38@iso2022_en@2
$LN37@iso2022_en@2:

; 216  : 
; 217  :         if (!dsg->mark)

  0037a	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  0037f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00382	85 c0		 test	 eax, eax
  00384	75 0a		 jne	 SHORT $LN27@iso2022_en@2

; 218  :             return 1;

  00386	b8 01 00 00 00	 mov	 eax, 1
  0038b	e9 ba 05 00 00	 jmp	 $LN51@iso2022_en@2
$LN27@iso2022_en@2:

; 219  :         assert(dsg->width == 1 || dsg->width == 2);

  00390	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  00395	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00399	83 f8 01	 cmp	 eax, 1
  0039c	74 2a		 je	 SHORT $LN55@iso2022_en@2
  0039e	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  003a3	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003a7	83 f8 02	 cmp	 eax, 2
  003aa	74 1c		 je	 SHORT $LN55@iso2022_en@2
  003ac	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  003b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MBLKAJOP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAc?$AAj?$AAk?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA?2?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA_?$AAi?$AAs?$AAo@
  003b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@CCFLAEJE@?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN@
  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003c6	33 c0		 xor	 eax, eax
$LN55@iso2022_en@2:

; 220  : 
; 221  :         switch (dsg->plane) {

  003c8	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  003cd	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003d1	88 44 24 54	 mov	 BYTE PTR tv189[rsp], al
  003d5	80 7c 24 54 00	 cmp	 BYTE PTR tv189[rsp], 0
  003da	74 10		 je	 SHORT $LN24@iso2022_en@2
  003dc	80 7c 24 54 01	 cmp	 BYTE PTR tv189[rsp], 1
  003e1	0f 84 73 02 00
	00		 je	 $LN13@iso2022_en@2
  003e7	e9 3a 04 00 00	 jmp	 $LN5@iso2022_en@2
$LN24@iso2022_en@2:

; 222  :         case 0: /* G0 */
; 223  :             if (STATE_GETFLAG(F_SHIFTED)) {

  003ec	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  003f1	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  003f5	83 e0 01	 and	 eax, 1
  003f8	85 c0		 test	 eax, eax
  003fa	74 65		 je	 SHORT $LN23@iso2022_en@2

; 224  :                 WRITE1(SI)

  003fc	48 83 bc 24 98
	00 00 00 01	 cmp	 QWORD PTR outleft$[rsp], 1
  00405	7d 0c		 jge	 SHORT $LN22@iso2022_en@2
  00407	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0040e	e9 37 05 00 00	 jmp	 $LN51@iso2022_en@2
$LN22@iso2022_en@2:
  00413	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0041b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0041e	c6 00 0f	 mov	 BYTE PTR [rax], 15

; 225  :                 STATE_CLEARFLAG(F_SHIFTED)

  00421	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00426	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0042a	83 e0 fe	 and	 eax, -2
  0042d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00432	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 226  :                 NEXT_OUT(1)

  00435	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0043d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00440	48 ff c0	 inc	 rax
  00443	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0044b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0044e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  00456	48 ff c8	 dec	 rax
  00459	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
$LN23@iso2022_en@2:

; 227  :             }
; 228  :             if (STATE_G0 != dsg->mark) {

  00461	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00466	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00469	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dsg$20803[rsp]
  0046e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00471	3b c1		 cmp	 eax, ecx
  00473	0f 84 dc 01 00
	00		 je	 $LN21@iso2022_en@2

; 229  :                 if (dsg->width == 1) {

  00479	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  0047e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00482	83 f8 01	 cmp	 eax, 1
  00485	0f 85 8f 00 00
	00		 jne	 $LN20@iso2022_en@2

; 230  :                     WRITE3(ESC, '(', ESCMARK(dsg->mark))

  0048b	48 83 bc 24 98
	00 00 00 03	 cmp	 QWORD PTR outleft$[rsp], 3
  00494	7d 0c		 jge	 SHORT $LN19@iso2022_en@2
  00496	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0049d	e9 a8 04 00 00	 jmp	 $LN51@iso2022_en@2
$LN19@iso2022_en@2:
  004a2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  004aa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004ad	c6 00 1b	 mov	 BYTE PTR [rax], 27
  004b0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  004b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004bb	c6 40 01 28	 mov	 BYTE PTR [rax+1], 40	; 00000028H
  004bf	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  004c4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004c7	83 e0 7f	 and	 eax, 127		; 0000007fH
  004ca	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  004d2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004d5	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 231  :                     STATE_SETG0(dsg->mark)

  004d8	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  004dd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dsg$20803[rsp]
  004e2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  004e5	88 08		 mov	 BYTE PTR [rax], cl

; 232  :                     NEXT_OUT(3)

  004e7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  004ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f2	48 83 c0 03	 add	 rax, 3
  004f6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  004fe	48 89 01	 mov	 QWORD PTR [rcx], rax
  00501	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  00509	48 83 e8 03	 sub	 rax, 3
  0050d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
  00515	e9 3b 01 00 00	 jmp	 $LN18@iso2022_en@2
$LN20@iso2022_en@2:

; 233  :                 }
; 234  :                 else if (dsg->mark == CHARSET_JISX0208) {

  0051a	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  0051f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00522	3d c2 00 00 00	 cmp	 eax, 194		; 000000c2H
  00527	0f 85 8f 00 00
	00		 jne	 $LN17@iso2022_en@2

; 235  :                     WRITE3(ESC, '$', ESCMARK(dsg->mark))

  0052d	48 83 bc 24 98
	00 00 00 03	 cmp	 QWORD PTR outleft$[rsp], 3
  00536	7d 0c		 jge	 SHORT $LN16@iso2022_en@2
  00538	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0053f	e9 06 04 00 00	 jmp	 $LN51@iso2022_en@2
$LN16@iso2022_en@2:
  00544	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0054c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0054f	c6 00 1b	 mov	 BYTE PTR [rax], 27
  00552	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0055a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0055d	c6 40 01 24	 mov	 BYTE PTR [rax+1], 36	; 00000024H
  00561	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  00566	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00569	83 e0 7f	 and	 eax, 127		; 0000007fH
  0056c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  00574	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00577	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 236  :                     STATE_SETG0(dsg->mark)

  0057a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0057f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dsg$20803[rsp]
  00584	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00587	88 08		 mov	 BYTE PTR [rax], cl

; 237  :                     NEXT_OUT(3)

  00589	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00591	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00594	48 83 c0 03	 add	 rax, 3
  00598	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  005a0	48 89 01	 mov	 QWORD PTR [rcx], rax
  005a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  005ab	48 83 e8 03	 sub	 rax, 3
  005af	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax

; 238  :                 }
; 239  :                 else {

  005b7	e9 99 00 00 00	 jmp	 $LN15@iso2022_en@2
$LN17@iso2022_en@2:

; 240  :                     WRITE4(ESC, '$', '(',
; 241  :                         ESCMARK(dsg->mark))

  005bc	48 83 bc 24 98
	00 00 00 04	 cmp	 QWORD PTR outleft$[rsp], 4
  005c5	7d 0c		 jge	 SHORT $LN14@iso2022_en@2
  005c7	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  005ce	e9 77 03 00 00	 jmp	 $LN51@iso2022_en@2
$LN14@iso2022_en@2:
  005d3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  005db	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005de	c6 00 1b	 mov	 BYTE PTR [rax], 27
  005e1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  005e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005ec	c6 40 01 24	 mov	 BYTE PTR [rax+1], 36	; 00000024H
  005f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  005f8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005fb	c6 40 02 28	 mov	 BYTE PTR [rax+2], 40	; 00000028H
  005ff	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  00604	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00607	83 e0 7f	 and	 eax, 127		; 0000007fH
  0060a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  00612	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00615	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 242  :                     STATE_SETG0(dsg->mark)

  00618	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0061d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dsg$20803[rsp]
  00622	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00625	88 08		 mov	 BYTE PTR [rax], cl

; 243  :                     NEXT_OUT(4)

  00627	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0062f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00632	48 83 c0 04	 add	 rax, 4
  00636	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0063e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00641	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  00649	48 83 e8 04	 sub	 rax, 4
  0064d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
$LN15@iso2022_en@2:
$LN18@iso2022_en@2:
$LN21@iso2022_en@2:

; 244  :                 }
; 245  :             }
; 246  :             break;

  00655	e9 d8 01 00 00	 jmp	 $LN25@iso2022_en@2
$LN13@iso2022_en@2:

; 247  :         case 1: /* G1 */
; 248  :             if (STATE_G1 != dsg->mark) {

  0065a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0065f	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00663	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dsg$20803[rsp]
  00668	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0066b	3b c1		 cmp	 eax, ecx
  0066d	0f 84 3c 01 00
	00		 je	 $LN12@iso2022_en@2

; 249  :                 if (dsg->width == 1) {

  00673	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  00678	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0067c	83 f8 01	 cmp	 eax, 1
  0067f	0f 85 90 00 00
	00		 jne	 $LN11@iso2022_en@2

; 250  :                     WRITE3(ESC, ')', ESCMARK(dsg->mark))

  00685	48 83 bc 24 98
	00 00 00 03	 cmp	 QWORD PTR outleft$[rsp], 3
  0068e	7d 0c		 jge	 SHORT $LN10@iso2022_en@2
  00690	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00697	e9 ae 02 00 00	 jmp	 $LN51@iso2022_en@2
$LN10@iso2022_en@2:
  0069c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  006a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006a7	c6 00 1b	 mov	 BYTE PTR [rax], 27
  006aa	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  006b2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006b5	c6 40 01 29	 mov	 BYTE PTR [rax+1], 41	; 00000029H
  006b9	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  006be	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006c1	83 e0 7f	 and	 eax, 127		; 0000007fH
  006c4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  006cc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006cf	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 251  :                     STATE_SETG1(dsg->mark)

  006d2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006d7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dsg$20803[rsp]
  006dc	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  006df	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 252  :                     NEXT_OUT(3)

  006e2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  006ea	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006ed	48 83 c0 03	 add	 rax, 3
  006f1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  006f9	48 89 01	 mov	 QWORD PTR [rcx], rax
  006fc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  00704	48 83 e8 03	 sub	 rax, 3
  00708	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax

; 253  :                 }
; 254  :                 else {

  00710	e9 9a 00 00 00	 jmp	 $LN9@iso2022_en@2
$LN11@iso2022_en@2:

; 255  :                     WRITE4(ESC, '$', ')',
; 256  :                         ESCMARK(dsg->mark))

  00715	48 83 bc 24 98
	00 00 00 04	 cmp	 QWORD PTR outleft$[rsp], 4
  0071e	7d 0c		 jge	 SHORT $LN8@iso2022_en@2
  00720	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00727	e9 1e 02 00 00	 jmp	 $LN51@iso2022_en@2
$LN8@iso2022_en@2:
  0072c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00734	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00737	c6 00 1b	 mov	 BYTE PTR [rax], 27
  0073a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00742	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00745	c6 40 01 24	 mov	 BYTE PTR [rax+1], 36	; 00000024H
  00749	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00751	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00754	c6 40 02 29	 mov	 BYTE PTR [rax+2], 41	; 00000029H
  00758	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  0075d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00760	83 e0 7f	 and	 eax, 127		; 0000007fH
  00763	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0076b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0076e	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 257  :                     STATE_SETG1(dsg->mark)

  00771	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00776	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dsg$20803[rsp]
  0077b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0077e	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 258  :                     NEXT_OUT(4)

  00781	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00789	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0078c	48 83 c0 04	 add	 rax, 4
  00790	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  00798	48 89 01	 mov	 QWORD PTR [rcx], rax
  0079b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  007a3	48 83 e8 04	 sub	 rax, 4
  007a7	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
$LN9@iso2022_en@2:
$LN12@iso2022_en@2:

; 259  :                 }
; 260  :             }
; 261  :             if (!STATE_GETFLAG(F_SHIFTED)) {

  007af	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007b4	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  007b8	83 e0 01	 and	 eax, 1
  007bb	85 c0		 test	 eax, eax
  007bd	75 65		 jne	 SHORT $LN7@iso2022_en@2

; 262  :                 WRITE1(SO)

  007bf	48 83 bc 24 98
	00 00 00 01	 cmp	 QWORD PTR outleft$[rsp], 1
  007c8	7d 0c		 jge	 SHORT $LN6@iso2022_en@2
  007ca	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  007d1	e9 74 01 00 00	 jmp	 $LN51@iso2022_en@2
$LN6@iso2022_en@2:
  007d6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  007de	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007e1	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 263  :                 STATE_SETFLAG(F_SHIFTED)

  007e4	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007e9	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  007ed	83 c8 01	 or	 eax, 1
  007f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  007f5	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 264  :                 NEXT_OUT(1)

  007f8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00800	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00803	48 ff c0	 inc	 rax
  00806	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0080e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00811	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  00819	48 ff c8	 dec	 rax
  0081c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
$LN7@iso2022_en@2:

; 265  :             }
; 266  :             break;

  00824	eb 0c		 jmp	 SHORT $LN25@iso2022_en@2
$LN5@iso2022_en@2:

; 267  :         default: /* G2 and G3 is not supported: no encoding in
; 268  :                   * CJKCodecs are using them yet */
; 269  :             return MBERR_INTERNAL;

  00826	48 c7 c0 fd ff
	ff ff		 mov	 rax, -3
  0082d	e9 18 01 00 00	 jmp	 $LN51@iso2022_en@2
$LN25@iso2022_en@2:

; 270  :         }
; 271  : 
; 272  :         if (dsg->width == 1) {

  00832	48 8b 44 24 28	 mov	 rax, QWORD PTR dsg$20803[rsp]
  00837	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0083b	83 f8 01	 cmp	 eax, 1
  0083e	75 57		 jne	 SHORT $LN4@iso2022_en@2

; 273  :             WRITE1((unsigned char)encoded)

  00840	48 83 bc 24 98
	00 00 00 01	 cmp	 QWORD PTR outleft$[rsp], 1
  00849	7d 0c		 jge	 SHORT $LN3@iso2022_en@2
  0084b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00852	e9 f3 00 00 00	 jmp	 $LN51@iso2022_en@2
$LN3@iso2022_en@2:
  00857	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0085f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00862	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR encoded$20804[rsp]
  00867	88 08		 mov	 BYTE PTR [rax], cl

; 274  :             NEXT_OUT(1)

  00869	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00871	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00874	48 ff c0	 inc	 rax
  00877	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0087f	48 89 01	 mov	 QWORD PTR [rcx], rax
  00882	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  0088a	48 ff c8	 dec	 rax
  0088d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax

; 275  :         }
; 276  :         else {

  00895	eb 72		 jmp	 SHORT $LN2@iso2022_en@2
$LN4@iso2022_en@2:

; 277  :             WRITE2(encoded >> 8, encoded & 0xff)

  00897	48 83 bc 24 98
	00 00 00 02	 cmp	 QWORD PTR outleft$[rsp], 2
  008a0	7d 0c		 jge	 SHORT $LN1@iso2022_en@2
  008a2	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  008a9	e9 9c 00 00 00	 jmp	 $LN51@iso2022_en@2
$LN1@iso2022_en@2:
  008ae	0f b7 44 24 20	 movzx	 eax, WORD PTR encoded$20804[rsp]
  008b3	c1 f8 08	 sar	 eax, 8
  008b6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  008be	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  008c1	88 01		 mov	 BYTE PTR [rcx], al
  008c3	0f b7 44 24 20	 movzx	 eax, WORD PTR encoded$20804[rsp]
  008c8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008cd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  008d5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  008d8	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 278  :             NEXT_OUT(2)

  008db	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  008e3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008e6	48 83 c0 02	 add	 rax, 2
  008ea	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  008f2	48 89 01	 mov	 QWORD PTR [rcx], rax
  008f5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  008fd	48 83 e8 02	 sub	 rax, 2
  00901	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
$LN2@iso2022_en@2:

; 279  :         }
; 280  :         NEXT_IN(insize)

  00909	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00911	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00914	48 8b 4c 24 30	 mov	 rcx, QWORD PTR insize$20806[rsp]
  00919	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  0091d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  00925	48 89 01	 mov	 QWORD PTR [rcx], rax
  00928	48 8b 44 24 30	 mov	 rax, QWORD PTR insize$20806[rsp]
  0092d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR inleft$[rsp]
  00935	48 2b c8	 sub	 rcx, rax
  00938	48 8b c1	 mov	 rax, rcx
  0093b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR inleft$[rsp], rax

; 281  :     }

  00943	e9 d0 f6 ff ff	 jmp	 $LN56@iso2022_en@2
$LN49@iso2022_en@2:

; 282  : 
; 283  :     return 0;

  00948	33 c0		 xor	 eax, eax
$LN51@iso2022_en@2:

; 284  : }

  0094a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0094e	c3		 ret	 0
iso2022_encode ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT iso2022_decode_init
_TEXT	SEGMENT
state$ = 8
config$ = 16
iso2022_decode_init PROC				; COMDAT

; 287  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 288  :     STATE_CLEARFLAGS()

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0000f	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 289  :     STATE_SETG0(CHARSET_ASCII)

  00013	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00018	c6 00 42	 mov	 BYTE PTR [rax], 66	; 00000042H

; 290  :     STATE_SETG1(CHARSET_ASCII)

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00020	c6 40 01 42	 mov	 BYTE PTR [rax+1], 66	; 00000042H

; 291  :     STATE_SETG2(CHARSET_ASCII)

  00024	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00029	c6 40 02 42	 mov	 BYTE PTR [rax+2], 66	; 00000042H

; 292  :     return 0;

  0002d	33 c0		 xor	 eax, eax

; 293  : }

  0002f	c3		 ret	 0
iso2022_decode_init ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT iso2022_decode_reset
_TEXT	SEGMENT
state$ = 8
config$ = 16
iso2022_decode_reset PROC				; COMDAT

; 296  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 297  :     STATE_SETG0(CHARSET_ASCII)

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0000f	c6 00 42	 mov	 BYTE PTR [rax], 66	; 00000042H

; 298  :     STATE_CLEARFLAG(F_SHIFTED)

  00012	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00017	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0001b	83 e0 fe	 and	 eax, -2
  0001e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR state$[rsp]
  00023	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 299  :     return 0;

  00026	33 c0		 xor	 eax, eax

; 300  : }

  00028	c3		 ret	 0
iso2022_decode_reset ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@PAGOCFHD@?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAm?$AAa?$AAr?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?8?$AA?2?$AA0?$AA?8?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$iso2022_decode DD imagerel iso2022_decode
	DD	imagerel iso2022_decode+2045
	DD	imagerel $unwind$iso2022_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso2022_decode DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT ??_C@_1CE@PAGOCFHD@?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAm?$AAa?$AAr?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?8?$AA?2?$AA0?$AA?8?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@PAGOCFHD@?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAm?$AAa?$AAr?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?8?$AA?2?$AA0?$AA?8?$AA?$AA@ DB 'd'
	DB	00H, 's', 00H, 'g', 00H, '-', 00H, '>', 00H, 'm', 00H, 'a', 00H
	DB	'r', 00H, 'k', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, ''''
	DB	00H, '\', 00H, '0', 00H, '''', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT iso2022_decode
_TEXT	SEGMENT
dsgcache$ = 48
err$20997 = 56
c$20996 = 64
decoded$21035 = 68
dsg$21033 = 72
charset$21034 = 80
tv89 = 84
state$ = 112
config$ = 120
inbuf$ = 128
inleft$ = 136
outbuf$ = 144
outleft$ = 152
iso2022_decode PROC					; COMDAT

; 422  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 423  :     const struct iso2022_designation *dsgcache = NULL;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR dsgcache$[rsp], 0
$LN53@iso2022_de:
$LN49@iso2022_de:

; 424  : 
; 425  :     while (inleft > 0) {

  00021	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR inleft$[rsp], 0
  0002a	0f 8e c6 07 00
	00		 jle	 $LN48@iso2022_de

; 426  :         unsigned char c = IN1;

  00030	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00038	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	88 44 24 40	 mov	 BYTE PTR c$20996[rsp], al

; 427  :         Py_ssize_t err;
; 428  : 
; 429  :         if (STATE_GETFLAG(F_ESCTHROUGHOUT)) {

  00042	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00047	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0004b	83 e0 02	 and	 eax, 2
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 ba 00 00
	00		 je	 $LN47@iso2022_de

; 430  :             /* ESC throughout mode:
; 431  :              * for non-iso2022 escape sequences */
; 432  :             WRITE1(c) /* assume as ISO-8859-1 */

  00056	48 83 bc 24 98
	00 00 00 01	 cmp	 QWORD PTR outleft$[rsp], 1
  0005f	7d 0c		 jge	 SHORT $LN46@iso2022_de
  00061	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00068	e9 8b 07 00 00	 jmp	 $LN50@iso2022_de
$LN46@iso2022_de:
  0006d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00078	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR c$20996[rsp]
  0007d	66 89 08	 mov	 WORD PTR [rax], cx

; 433  :             NEXT(1, 1)

  00080	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00088	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008b	48 ff c0	 inc	 rax
  0008e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  00096	48 89 01	 mov	 QWORD PTR [rcx], rax
  00099	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR inleft$[rsp]
  000a1	48 ff c8	 dec	 rax
  000a4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR inleft$[rsp], rax
  000ac	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  000b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b7	48 83 c0 02	 add	 rax, 2
  000bb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  000c3	48 89 01	 mov	 QWORD PTR [rcx], rax
  000c6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  000ce	48 ff c8	 dec	 rax
  000d1	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax

; 434  :             if (IS_ESCEND(c)) {

  000d9	0f b6 44 24 40	 movzx	 eax, BYTE PTR c$20996[rsp]
  000de	83 f8 41	 cmp	 eax, 65			; 00000041H
  000e1	7c 0a		 jl	 SHORT $LN43@iso2022_de
  000e3	0f b6 44 24 40	 movzx	 eax, BYTE PTR c$20996[rsp]
  000e8	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  000eb	7e 0a		 jle	 SHORT $LN44@iso2022_de
$LN43@iso2022_de:
  000ed	0f b6 44 24 40	 movzx	 eax, BYTE PTR c$20996[rsp]
  000f2	83 f8 40	 cmp	 eax, 64			; 00000040H
  000f5	75 14		 jne	 SHORT $LN45@iso2022_de
$LN44@iso2022_de:

; 435  :                 STATE_CLEARFLAG(F_ESCTHROUGHOUT)

  000f7	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000fc	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00100	83 e0 fd	 and	 eax, -3
  00103	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00108	88 41 04	 mov	 BYTE PTR [rcx+4], al
$LN45@iso2022_de:

; 436  :             }
; 437  :             continue;

  0010b	e9 11 ff ff ff	 jmp	 $LN49@iso2022_de
$LN47@iso2022_de:

; 438  :         }
; 439  : 
; 440  :         switch (c) {

  00110	0f b6 44 24 40	 movzx	 eax, BYTE PTR c$20996[rsp]
  00115	88 44 24 54	 mov	 BYTE PTR tv89[rsp], al
  00119	80 7c 24 54 0a	 cmp	 BYTE PTR tv89[rsp], 10
  0011e	0f 84 b6 02 00
	00		 je	 $LN25@iso2022_de
  00124	80 7c 24 54 0e	 cmp	 BYTE PTR tv89[rsp], 14
  00129	0f 84 53 02 00
	00		 je	 $LN27@iso2022_de
  0012f	80 7c 24 54 0f	 cmp	 BYTE PTR tv89[rsp], 15
  00134	0f 84 f0 01 00
	00		 je	 $LN29@iso2022_de
  0013a	80 7c 24 54 1b	 cmp	 BYTE PTR tv89[rsp], 27
  0013f	74 05		 je	 SHORT $LN40@iso2022_de
  00141	e9 30 03 00 00	 jmp	 $LN23@iso2022_de
$LN40@iso2022_de:

; 441  :         case ESC:
; 442  :             REQUIRE_INBUF(2)

  00146	48 83 bc 24 88
	00 00 00 02	 cmp	 QWORD PTR inleft$[rsp], 2
  0014f	7d 0c		 jge	 SHORT $LN39@iso2022_de
  00151	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00158	e9 9b 06 00 00	 jmp	 $LN50@iso2022_de
$LN39@iso2022_de:

; 443  :             if (IS_ISO2022ESC(IN2)) {

  0015d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00165	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00168	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0016c	83 f8 28	 cmp	 eax, 40			; 00000028H
  0016f	74 50		 je	 SHORT $LN37@iso2022_de
  00171	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00179	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00180	83 f8 29	 cmp	 eax, 41			; 00000029H
  00183	74 3c		 je	 SHORT $LN37@iso2022_de
  00185	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  0018d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00190	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00194	83 f8 24	 cmp	 eax, 36			; 00000024H
  00197	74 28		 je	 SHORT $LN37@iso2022_de
  00199	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  001a1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a4	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001a8	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001ab	74 14		 je	 SHORT $LN37@iso2022_de
  001ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  001b5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b8	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001bc	83 f8 26	 cmp	 eax, 38			; 00000026H
  001bf	75 3b		 jne	 SHORT $LN38@iso2022_de
$LN37@iso2022_de:

; 444  :                 err = iso2022processesc(config, state,
; 445  :                                         inbuf, &inleft);

  001c1	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR inleft$[rsp]
  001c9	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR inbuf$[rsp]
  001d1	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  001d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR config$[rsp]
  001db	e8 00 00 00 00	 call	 iso2022processesc
  001e0	48 89 44 24 38	 mov	 QWORD PTR err$20997[rsp], rax

; 446  :                 if (err != 0)

  001e5	48 83 7c 24 38
	00		 cmp	 QWORD PTR err$20997[rsp], 0
  001eb	74 0a		 je	 SHORT $LN36@iso2022_de

; 447  :                     return err;

  001ed	48 8b 44 24 38	 mov	 rax, QWORD PTR err$20997[rsp]
  001f2	e9 01 06 00 00	 jmp	 $LN50@iso2022_de
$LN36@iso2022_de:

; 448  :             }
; 449  :             else if (CONFIG_ISSET(USE_G2) && IN2 == 'N') {/* SS2 */

  001f7	e9 29 01 00 00	 jmp	 $LN35@iso2022_de
$LN38@iso2022_de:
  001fc	48 8b 44 24 78	 mov	 rax, QWORD PTR config$[rsp]
  00201	8b 00		 mov	 eax, DWORD PTR [rax]
  00203	83 e0 02	 and	 eax, 2
  00206	85 c0		 test	 eax, eax
  00208	0f 84 80 00 00
	00		 je	 $LN34@iso2022_de
  0020e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00216	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00219	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0021d	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00220	75 6c		 jne	 SHORT $LN34@iso2022_de

; 450  :                 REQUIRE_INBUF(3)

  00222	48 83 bc 24 88
	00 00 00 03	 cmp	 QWORD PTR inleft$[rsp], 3
  0022b	7d 0c		 jge	 SHORT $LN33@iso2022_de
  0022d	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00234	e9 bf 05 00 00	 jmp	 $LN50@iso2022_de
$LN33@iso2022_de:

; 451  :                 err = iso2022processg2(config, state,
; 452  :                     inbuf, &inleft, outbuf, &outleft);

  00239	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR outleft$[rsp]
  00241	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00246	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0024e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00253	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR inleft$[rsp]
  0025b	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR inbuf$[rsp]
  00263	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  00268	48 8b 4c 24 78	 mov	 rcx, QWORD PTR config$[rsp]
  0026d	e8 00 00 00 00	 call	 iso2022processg2
  00272	48 89 44 24 38	 mov	 QWORD PTR err$20997[rsp], rax

; 453  :                 if (err != 0)

  00277	48 83 7c 24 38
	00		 cmp	 QWORD PTR err$20997[rsp], 0
  0027d	74 0a		 je	 SHORT $LN32@iso2022_de

; 454  :                     return err;

  0027f	48 8b 44 24 38	 mov	 rax, QWORD PTR err$20997[rsp]
  00284	e9 6f 05 00 00	 jmp	 $LN50@iso2022_de
$LN32@iso2022_de:

; 455  :             }
; 456  :             else {

  00289	e9 97 00 00 00	 jmp	 $LN31@iso2022_de
$LN34@iso2022_de:

; 457  :                 WRITE1(ESC)

  0028e	48 83 bc 24 98
	00 00 00 01	 cmp	 QWORD PTR outleft$[rsp], 1
  00297	7d 0c		 jge	 SHORT $LN30@iso2022_de
  00299	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  002a0	e9 53 05 00 00	 jmp	 $LN50@iso2022_de
$LN30@iso2022_de:
  002a5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  002ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b0	b9 1b 00 00 00	 mov	 ecx, 27
  002b5	66 89 08	 mov	 WORD PTR [rax], cx

; 458  :                 STATE_SETFLAG(F_ESCTHROUGHOUT)

  002b8	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  002bd	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  002c1	83 c8 02	 or	 eax, 2
  002c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  002c9	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 459  :                 NEXT(1, 1)

  002cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  002d4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d7	48 ff c0	 inc	 rax
  002da	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  002e2	48 89 01	 mov	 QWORD PTR [rcx], rax
  002e5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR inleft$[rsp]
  002ed	48 ff c8	 dec	 rax
  002f0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR inleft$[rsp], rax
  002f8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00300	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00303	48 83 c0 02	 add	 rax, 2
  00307	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0030f	48 89 01	 mov	 QWORD PTR [rcx], rax
  00312	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  0031a	48 ff c8	 dec	 rax
  0031d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
$LN31@iso2022_de:
$LN35@iso2022_de:

; 460  :             }
; 461  :             break;

  00325	e9 c7 04 00 00	 jmp	 $LN41@iso2022_de
$LN29@iso2022_de:

; 462  :         case SI:
; 463  :             if (CONFIG_ISSET(NO_SHIFT))

  0032a	48 8b 44 24 78	 mov	 rax, QWORD PTR config$[rsp]
  0032f	8b 00		 mov	 eax, DWORD PTR [rax]
  00331	83 e0 01	 and	 eax, 1
  00334	85 c0		 test	 eax, eax
  00336	74 05		 je	 SHORT $LN28@iso2022_de

; 464  :                 goto bypass;

  00338	e9 9e 01 00 00	 jmp	 $bypass$21022
$LN28@iso2022_de:

; 465  :             STATE_CLEARFLAG(F_SHIFTED)

  0033d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00342	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00346	83 e0 fe	 and	 eax, -2
  00349	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0034e	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 466  :             NEXT_IN(1)

  00351	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00359	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0035c	48 ff c0	 inc	 rax
  0035f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  00367	48 89 01	 mov	 QWORD PTR [rcx], rax
  0036a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR inleft$[rsp]
  00372	48 ff c8	 dec	 rax
  00375	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR inleft$[rsp], rax

; 467  :             break;

  0037d	e9 6f 04 00 00	 jmp	 $LN41@iso2022_de
$LN27@iso2022_de:

; 468  :         case SO:
; 469  :             if (CONFIG_ISSET(NO_SHIFT))

  00382	48 8b 44 24 78	 mov	 rax, QWORD PTR config$[rsp]
  00387	8b 00		 mov	 eax, DWORD PTR [rax]
  00389	83 e0 01	 and	 eax, 1
  0038c	85 c0		 test	 eax, eax
  0038e	74 05		 je	 SHORT $LN26@iso2022_de

; 470  :                 goto bypass;

  00390	e9 46 01 00 00	 jmp	 $bypass$21022
$LN26@iso2022_de:

; 471  :             STATE_SETFLAG(F_SHIFTED)

  00395	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0039a	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0039e	83 c8 01	 or	 eax, 1
  003a1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  003a6	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 472  :             NEXT_IN(1)

  003a9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  003b1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003b4	48 ff c0	 inc	 rax
  003b7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  003bf	48 89 01	 mov	 QWORD PTR [rcx], rax
  003c2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR inleft$[rsp]
  003ca	48 ff c8	 dec	 rax
  003cd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR inleft$[rsp], rax

; 473  :             break;

  003d5	e9 17 04 00 00	 jmp	 $LN41@iso2022_de
$LN25@iso2022_de:

; 474  :         case LF:
; 475  :             STATE_CLEARFLAG(F_SHIFTED)

  003da	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  003df	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  003e3	83 e0 fe	 and	 eax, -2
  003e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  003eb	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 476  :             WRITE1(LF)

  003ee	48 83 bc 24 98
	00 00 00 01	 cmp	 QWORD PTR outleft$[rsp], 1
  003f7	7d 0c		 jge	 SHORT $LN24@iso2022_de
  003f9	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00400	e9 f3 03 00 00	 jmp	 $LN50@iso2022_de
$LN24@iso2022_de:
  00405	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0040d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00410	b9 0a 00 00 00	 mov	 ecx, 10
  00415	66 89 08	 mov	 WORD PTR [rax], cx

; 477  :             NEXT(1, 1)

  00418	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  00420	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00423	48 ff c0	 inc	 rax
  00426	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  0042e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00431	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR inleft$[rsp]
  00439	48 ff c8	 dec	 rax
  0043c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR inleft$[rsp], rax
  00444	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0044c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0044f	48 83 c0 02	 add	 rax, 2
  00453	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0045b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0045e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  00466	48 ff c8	 dec	 rax
  00469	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax

; 478  :             break;

  00471	e9 7b 03 00 00	 jmp	 $LN41@iso2022_de
$LN23@iso2022_de:

; 479  :         default:
; 480  :             if (c < 0x20) /* C0 */

  00476	0f b6 44 24 40	 movzx	 eax, BYTE PTR c$20996[rsp]
  0047b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0047e	7d 07		 jge	 SHORT $LN22@iso2022_de

; 481  :                 goto bypass;

  00480	eb 59		 jmp	 SHORT $bypass$21022
  00482	e9 6a 03 00 00	 jmp	 $LN21@iso2022_de
$LN22@iso2022_de:

; 482  :             else if (c >= 0x80)

  00487	0f b6 44 24 40	 movzx	 eax, BYTE PTR c$20996[rsp]
  0048c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00491	7c 0f		 jl	 SHORT $LN20@iso2022_de

; 483  :                 return 1;

  00493	b8 01 00 00 00	 mov	 eax, 1
  00498	e9 5b 03 00 00	 jmp	 $LN50@iso2022_de

; 484  :             else {

  0049d	e9 4f 03 00 00	 jmp	 $LN19@iso2022_de
$LN20@iso2022_de:

; 485  :                 const struct iso2022_designation *dsg;
; 486  :                 unsigned char charset;
; 487  :                 ucs4_t decoded;
; 488  : 
; 489  :                 if (STATE_GETFLAG(F_SHIFTED))

  004a2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  004a7	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  004ab	83 e0 01	 and	 eax, 1
  004ae	85 c0		 test	 eax, eax
  004b0	74 0f		 je	 SHORT $LN18@iso2022_de

; 490  :                     charset = STATE_G1;

  004b2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  004b7	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  004bb	88 44 24 50	 mov	 BYTE PTR charset$21034[rsp], al

; 491  :                 else

  004bf	eb 0c		 jmp	 SHORT $LN17@iso2022_de
$LN18@iso2022_de:

; 492  :                     charset = STATE_G0;

  004c1	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  004c6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004c9	88 44 24 50	 mov	 BYTE PTR charset$21034[rsp], al
$LN17@iso2022_de:

; 493  : 
; 494  :                 if (charset == CHARSET_ASCII) {

  004cd	0f b6 44 24 50	 movzx	 eax, BYTE PTR charset$21034[rsp]
  004d2	83 f8 42	 cmp	 eax, 66			; 00000042H
  004d5	0f 85 88 00 00
	00		 jne	 $LN16@iso2022_de
$bypass$21022:

; 495  : bypass:                                 WRITE1(c)

  004db	48 83 bc 24 98
	00 00 00 01	 cmp	 QWORD PTR outleft$[rsp], 1
  004e4	7d 0c		 jge	 SHORT $LN15@iso2022_de
  004e6	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  004ed	e9 06 03 00 00	 jmp	 $LN50@iso2022_de
$LN15@iso2022_de:
  004f2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  004fa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004fd	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR c$20996[rsp]
  00502	66 89 08	 mov	 WORD PTR [rax], cx

; 496  :                                         NEXT(1, 1)

  00505	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  0050d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00510	48 ff c0	 inc	 rax
  00513	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  0051b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0051e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR inleft$[rsp]
  00526	48 ff c8	 dec	 rax
  00529	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR inleft$[rsp], rax
  00531	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00539	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0053c	48 83 c0 02	 add	 rax, 2
  00540	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  00548	48 89 01	 mov	 QWORD PTR [rcx], rax
  0054b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  00553	48 ff c8	 dec	 rax
  00556	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax

; 497  :                                         break;

  0055e	e9 8e 02 00 00	 jmp	 $LN41@iso2022_de
$LN16@iso2022_de:

; 498  :                                 }
; 499  : 
; 500  :                                 if (dsgcache != NULL &&
; 501  :                                     dsgcache->mark == charset)

  00563	48 83 7c 24 30
	00		 cmp	 QWORD PTR dsgcache$[rsp], 0
  00569	74 1d		 je	 SHORT $LN14@iso2022_de
  0056b	48 8b 44 24 30	 mov	 rax, QWORD PTR dsgcache$[rsp]
  00570	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00573	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR charset$21034[rsp]
  00578	3b c1		 cmp	 eax, ecx
  0057a	75 0c		 jne	 SHORT $LN14@iso2022_de

; 502  :                                         dsg = dsgcache;

  0057c	48 8b 44 24 30	 mov	 rax, QWORD PTR dsgcache$[rsp]
  00581	48 89 44 24 48	 mov	 QWORD PTR dsg$21033[rsp], rax

; 503  :                                 else {

  00586	eb 6f		 jmp	 SHORT $LN13@iso2022_de
$LN14@iso2022_de:

; 504  :                                         for (dsg = CONFIG_DESIGNATIONS;
; 505  :                                              dsg->mark != charset
; 506  : #ifdef Py_DEBUG
; 507  :                                                 && dsg->mark != '\0'
; 508  : #endif
; 509  :                                              ;dsg++)

  00588	48 8b 44 24 78	 mov	 rax, QWORD PTR config$[rsp]
  0058d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00591	48 89 44 24 48	 mov	 QWORD PTR dsg$21033[rsp], rax
  00596	eb 0e		 jmp	 SHORT $LN12@iso2022_de
$LN11@iso2022_de:
  00598	48 8b 44 24 48	 mov	 rax, QWORD PTR dsg$21033[rsp]
  0059d	48 83 c0 20	 add	 rax, 32			; 00000020H
  005a1	48 89 44 24 48	 mov	 QWORD PTR dsg$21033[rsp], rax
$LN12@iso2022_de:
  005a6	48 8b 44 24 48	 mov	 rax, QWORD PTR dsg$21033[rsp]
  005ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005ae	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR charset$21034[rsp]
  005b3	3b c1		 cmp	 eax, ecx
  005b5	74 0e		 je	 SHORT $LN10@iso2022_de
  005b7	48 8b 44 24 48	 mov	 rax, QWORD PTR dsg$21033[rsp]
  005bc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005bf	85 c0		 test	 eax, eax
  005c1	74 02		 je	 SHORT $LN10@iso2022_de

; 510  :                                                 /* noop */;

  005c3	eb d3		 jmp	 SHORT $LN11@iso2022_de
$LN10@iso2022_de:

; 511  :                                         assert(dsg->mark != '\0');

  005c5	48 8b 44 24 48	 mov	 rax, QWORD PTR dsg$21033[rsp]
  005ca	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005cd	85 c0		 test	 eax, eax
  005cf	75 1c		 jne	 SHORT $LN52@iso2022_de
  005d1	41 b8 ff 01 00
	00		 mov	 r8d, 511		; 000001ffH
  005d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MBLKAJOP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAc?$AAj?$AAk?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA?2?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA_?$AAi?$AAs?$AAo@
  005de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@PAGOCFHD@?$AAd?$AAs?$AAg?$AA?9?$AA?$DO?$AAm?$AAa?$AAr?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?8?$AA?2?$AA0?$AA?8?$AA?$AA@
  005e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005eb	33 c0		 xor	 eax, eax
$LN52@iso2022_de:

; 512  :                                         dsgcache = dsg;

  005ed	48 8b 44 24 48	 mov	 rax, QWORD PTR dsg$21033[rsp]
  005f2	48 89 44 24 30	 mov	 QWORD PTR dsgcache$[rsp], rax
$LN13@iso2022_de:

; 513  :                                 }
; 514  : 
; 515  :                                 REQUIRE_INBUF(dsg->width)

  005f7	48 8b 44 24 48	 mov	 rax, QWORD PTR dsg$21033[rsp]
  005fc	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00600	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR inleft$[rsp], rax
  00608	7d 0c		 jge	 SHORT $LN9@iso2022_de
  0060a	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00611	e9 e2 01 00 00	 jmp	 $LN50@iso2022_de
$LN9@iso2022_de:

; 516  :                                 decoded = dsg->decoder(*inbuf);

  00616	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inbuf$[rsp]
  0061e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00621	48 8b 44 24 48	 mov	 rax, QWORD PTR dsg$21033[rsp]
  00626	ff 50 10	 call	 QWORD PTR [rax+16]
  00629	89 44 24 44	 mov	 DWORD PTR decoded$21035[rsp], eax

; 517  :                                 if (decoded == MAP_UNMAPPABLE)

  0062d	81 7c 24 44 ff
	ff 00 00	 cmp	 DWORD PTR decoded$21035[rsp], 65535 ; 0000ffffH
  00635	75 0e		 jne	 SHORT $LN8@iso2022_de

; 518  :                                         return dsg->width;

  00637	48 8b 44 24 48	 mov	 rax, QWORD PTR dsg$21033[rsp]
  0063c	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00640	e9 b3 01 00 00	 jmp	 $LN50@iso2022_de
$LN8@iso2022_de:

; 519  : 
; 520  :                                 if (decoded < 0x10000) {

  00645	81 7c 24 44 00
	00 01 00	 cmp	 DWORD PTR decoded$21035[rsp], 65536 ; 00010000H
  0064d	73 5c		 jae	 SHORT $LN7@iso2022_de

; 521  :                                         WRITE1(decoded)

  0064f	48 83 bc 24 98
	00 00 00 01	 cmp	 QWORD PTR outleft$[rsp], 1
  00658	7d 0c		 jge	 SHORT $LN6@iso2022_de
  0065a	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00661	e9 92 01 00 00	 jmp	 $LN50@iso2022_de
$LN6@iso2022_de:
  00666	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0066e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00671	0f b7 4c 24 44	 movzx	 ecx, WORD PTR decoded$21035[rsp]
  00676	66 89 08	 mov	 WORD PTR [rax], cx

; 522  :                                         NEXT_OUT(1)

  00679	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00681	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00684	48 83 c0 02	 add	 rax, 2
  00688	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  00690	48 89 01	 mov	 QWORD PTR [rcx], rax
  00693	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  0069b	48 ff c8	 dec	 rax
  0069e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
  006a6	e9 08 01 00 00	 jmp	 $LN5@iso2022_de
$LN7@iso2022_de:

; 523  :                                 }
; 524  :                                 else if (decoded < 0x30000) {

  006ab	81 7c 24 44 00
	00 03 00	 cmp	 DWORD PTR decoded$21035[rsp], 196608 ; 00030000H
  006b3	0f 83 88 00 00
	00		 jae	 $LN4@iso2022_de

; 525  :                                         WRITEUCS4(decoded)

  006b9	48 83 bc 24 98
	00 00 00 02	 cmp	 QWORD PTR outleft$[rsp], 2
  006c2	7d 0c		 jge	 SHORT $LN3@iso2022_de
  006c4	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  006cb	e9 28 01 00 00	 jmp	 $LN50@iso2022_de
$LN3@iso2022_de:
  006d0	8b 44 24 44	 mov	 eax, DWORD PTR decoded$21035[rsp]
  006d4	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  006d9	c1 e8 0a	 shr	 eax, 10
  006dc	05 00 d8 00 00	 add	 eax, 55296		; 0000d800H
  006e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  006e9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006ec	66 89 01	 mov	 WORD PTR [rcx], ax
  006ef	8b 44 24 44	 mov	 eax, DWORD PTR decoded$21035[rsp]
  006f3	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  006f8	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  006fd	05 00 dc 00 00	 add	 eax, 56320		; 0000dc00H
  00702	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0070a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0070d	66 89 41 02	 mov	 WORD PTR [rcx+2], ax
  00711	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  00719	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0071c	48 83 c0 04	 add	 rax, 4
  00720	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  00728	48 89 01	 mov	 QWORD PTR [rcx], rax
  0072b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  00733	48 83 e8 02	 sub	 rax, 2
  00737	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax

; 526  :                                 }
; 527  :                                 else { /* JIS X 0213 pairs */

  0073f	eb 72		 jmp	 SHORT $LN2@iso2022_de
$LN4@iso2022_de:

; 528  :                     WRITE2(decoded >> 16, decoded & 0xffff)

  00741	48 83 bc 24 98
	00 00 00 02	 cmp	 QWORD PTR outleft$[rsp], 2
  0074a	7d 0c		 jge	 SHORT $LN1@iso2022_de
  0074c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00753	e9 a0 00 00 00	 jmp	 $LN50@iso2022_de
$LN1@iso2022_de:
  00758	8b 44 24 44	 mov	 eax, DWORD PTR decoded$21035[rsp]
  0075c	c1 e8 10	 shr	 eax, 16
  0075f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  00767	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0076a	66 89 01	 mov	 WORD PTR [rcx], ax
  0076d	8b 44 24 44	 mov	 eax, DWORD PTR decoded$21035[rsp]
  00771	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00776	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0077e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00781	66 89 41 02	 mov	 WORD PTR [rcx+2], ax

; 529  :                     NEXT_OUT(2)

  00785	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR outbuf$[rsp]
  0078d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00790	48 83 c0 04	 add	 rax, 4
  00794	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0079c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0079f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR outleft$[rsp]
  007a7	48 83 e8 02	 sub	 rax, 2
  007ab	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rax
$LN2@iso2022_de:
$LN5@iso2022_de:

; 530  :                 }
; 531  :                 NEXT_IN(dsg->width)

  007b3	48 8b 44 24 48	 mov	 rax, QWORD PTR dsg$21033[rsp]
  007b8	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  007bc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  007c4	48 03 01	 add	 rax, QWORD PTR [rcx]
  007c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inbuf$[rsp]
  007cf	48 89 01	 mov	 QWORD PTR [rcx], rax
  007d2	48 8b 44 24 48	 mov	 rax, QWORD PTR dsg$21033[rsp]
  007d7	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  007db	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR inleft$[rsp]
  007e3	48 2b c8	 sub	 rcx, rax
  007e6	48 8b c1	 mov	 rax, rcx
  007e9	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR inleft$[rsp], rax
$LN19@iso2022_de:
$LN21@iso2022_de:
$LN41@iso2022_de:

; 532  :             }
; 533  :             break;
; 534  :         }
; 535  :     }

  007f1	e9 2b f8 ff ff	 jmp	 $LN53@iso2022_de
$LN48@iso2022_de:

; 536  :     return 0;

  007f6	33 c0		 xor	 eax, eax
$LN50@iso2022_de:

; 537  : }

  007f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  007fc	c3		 ret	 0
iso2022_decode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iso2022processesc DD imagerel iso2022processesc
	DD	imagerel iso2022processesc+854
	DD	imagerel $unwind$iso2022processesc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso2022processesc DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT iso2022processesc
_TEXT	SEGMENT
esclen$ = 0
i$ = 8
designation$ = 16
charset$ = 17
dsg$20932 = 24
tv90 = 32
config$ = 64
state$ = 72
inbuf$ = 80
inleft$ = 88
iso2022processesc PROC					; COMDAT

; 305  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 306  :     unsigned char charset, designation;
; 307  :     Py_ssize_t i, esclen;
; 308  : 
; 309  :     for (i = 1;i < MAX_ESCSEQLEN;i++) {

  00018	48 c7 44 24 08
	01 00 00 00	 mov	 QWORD PTR i$[rsp], 1
  00021	eb 0d		 jmp	 SHORT $LN37@iso2022pro
$LN36@iso2022pro:
  00023	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  00028	48 ff c0	 inc	 rax
  0002b	48 89 44 24 08	 mov	 QWORD PTR i$[rsp], rax
$LN37@iso2022pro:
  00030	48 83 7c 24 08
	10		 cmp	 QWORD PTR i$[rsp], 16
  00036	0f 8d cd 00 00
	00		 jge	 $LN35@iso2022pro

; 310  :         if (i >= *inleft)

  0003c	48 8b 44 24 58	 mov	 rax, QWORD PTR inleft$[rsp]
  00041	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00044	48 39 44 24 08	 cmp	 QWORD PTR i$[rsp], rax
  00049	7c 0c		 jl	 SHORT $LN34@iso2022pro

; 311  :             return MBERR_TOOFEW;

  0004b	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00052	e9 fa 02 00 00	 jmp	 $LN38@iso2022pro
$LN34@iso2022pro:

; 312  :         if (IS_ESCEND((*inbuf)[i])) {

  00057	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  0005c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR i$[rsp]
  00064	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00068	83 f8 41	 cmp	 eax, 65			; 00000041H
  0006b	7c 16		 jl	 SHORT $LN31@iso2022pro
  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  00072	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00075	48 8b 4c 24 08	 mov	 rcx, QWORD PTR i$[rsp]
  0007a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0007e	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00081	7e 16		 jle	 SHORT $LN32@iso2022pro
$LN31@iso2022pro:
  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  00088	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR i$[rsp]
  00090	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00094	83 f8 40	 cmp	 eax, 64			; 00000040H
  00097	75 10		 jne	 SHORT $LN33@iso2022pro
$LN32@iso2022pro:

; 313  :             esclen = i + 1;

  00099	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0009e	48 ff c0	 inc	 rax
  000a1	48 89 04 24	 mov	 QWORD PTR esclen$[rsp], rax

; 314  :             break;

  000a5	eb 62		 jmp	 SHORT $LN35@iso2022pro

; 315  :         }
; 316  :         else if (CONFIG_ISSET(USE_JISX0208_EXT) && i+1 < *inleft &&

  000a7	eb 5b		 jmp	 SHORT $LN30@iso2022pro
$LN33@iso2022pro:

; 317  :                  (*inbuf)[i] == '&' && (*inbuf)[i+1] == '@')

  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR config$[rsp]
  000ae	8b 00		 mov	 eax, DWORD PTR [rax]
  000b0	83 e0 04	 and	 eax, 4
  000b3	85 c0		 test	 eax, eax
  000b5	74 4d		 je	 SHORT $LN29@iso2022pro
  000b7	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  000bc	48 ff c0	 inc	 rax
  000bf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR inleft$[rsp]
  000c4	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  000c7	7d 3b		 jge	 SHORT $LN29@iso2022pro
  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  000ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d1	48 8b 4c 24 08	 mov	 rcx, QWORD PTR i$[rsp]
  000d6	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000da	83 f8 26	 cmp	 eax, 38			; 00000026H
  000dd	75 25		 jne	 SHORT $LN29@iso2022pro
  000df	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  000e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR i$[rsp]
  000ec	0f b6 44 08 01	 movzx	 eax, BYTE PTR [rax+rcx+1]
  000f1	83 f8 40	 cmp	 eax, 64			; 00000040H
  000f4	75 0e		 jne	 SHORT $LN29@iso2022pro

; 318  :             i += 2;

  000f6	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  000fb	48 83 c0 02	 add	 rax, 2
  000ff	48 89 44 24 08	 mov	 QWORD PTR i$[rsp], rax
$LN29@iso2022pro:
$LN30@iso2022pro:

; 319  :     }

  00104	e9 1a ff ff ff	 jmp	 $LN36@iso2022pro
$LN35@iso2022pro:

; 320  : 
; 321  :     if (i >= MAX_ESCSEQLEN)

  00109	48 83 7c 24 08
	10		 cmp	 QWORD PTR i$[rsp], 16
  0010f	7c 0a		 jl	 SHORT $LN28@iso2022pro

; 322  :         return 1; /* unterminated escape sequence */

  00111	b8 01 00 00 00	 mov	 eax, 1
  00116	e9 36 02 00 00	 jmp	 $LN38@iso2022pro
$LN28@iso2022pro:

; 323  : 
; 324  :     switch (esclen) {

  0011b	48 8b 04 24	 mov	 rax, QWORD PTR esclen$[rsp]
  0011f	48 89 44 24 20	 mov	 QWORD PTR tv90[rsp], rax
  00124	48 83 7c 24 20
	03		 cmp	 QWORD PTR tv90[rsp], 3
  0012a	74 1d		 je	 SHORT $LN25@iso2022pro
  0012c	48 83 7c 24 20
	04		 cmp	 QWORD PTR tv90[rsp], 4
  00132	0f 84 b2 00 00
	00		 je	 $LN16@iso2022pro
  00138	48 83 7c 24 20
	06		 cmp	 QWORD PTR tv90[rsp], 6
  0013e	0f 84 11 01 00
	00		 je	 $LN10@iso2022pro
  00144	e9 65 01 00 00	 jmp	 $LN7@iso2022pro
$LN25@iso2022pro:

; 325  :     case 3:
; 326  :         if (IN2 == '$') {

  00149	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  0014e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00151	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00155	83 f8 24	 cmp	 eax, 36			; 00000024H
  00158	75 1b		 jne	 SHORT $LN24@iso2022pro

; 327  :             charset = IN3 | CHARSET_DBCS;

  0015a	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  0015f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00162	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00166	0f ba e8 07	 bts	 eax, 7
  0016a	88 44 24 11	 mov	 BYTE PTR charset$[rsp], al

; 328  :             designation = 0;

  0016e	c6 44 24 10 00	 mov	 BYTE PTR designation$[rsp], 0

; 329  :         }
; 330  :         else {

  00173	eb 70		 jmp	 SHORT $LN23@iso2022pro
$LN24@iso2022pro:

; 331  :             charset = IN3;

  00175	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  0017a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017d	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00181	88 44 24 11	 mov	 BYTE PTR charset$[rsp], al

; 332  :             if (IN2 == '(') designation = 0;

  00185	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  0018a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0018d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00191	83 f8 28	 cmp	 eax, 40			; 00000028H
  00194	75 07		 jne	 SHORT $LN22@iso2022pro
  00196	c6 44 24 10 00	 mov	 BYTE PTR designation$[rsp], 0
  0019b	eb 48		 jmp	 SHORT $LN21@iso2022pro
$LN22@iso2022pro:

; 333  :             else if (IN2 == ')') designation = 1;

  0019d	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  001a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a5	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001a9	83 f8 29	 cmp	 eax, 41			; 00000029H
  001ac	75 07		 jne	 SHORT $LN20@iso2022pro
  001ae	c6 44 24 10 01	 mov	 BYTE PTR designation$[rsp], 1
  001b3	eb 30		 jmp	 SHORT $LN19@iso2022pro
$LN20@iso2022pro:

; 334  :             else if (CONFIG_ISSET(USE_G2) && IN2 == '.')

  001b5	48 8b 44 24 40	 mov	 rax, QWORD PTR config$[rsp]
  001ba	8b 00		 mov	 eax, DWORD PTR [rax]
  001bc	83 e0 02	 and	 eax, 2
  001bf	85 c0		 test	 eax, eax
  001c1	74 18		 je	 SHORT $LN18@iso2022pro
  001c3	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  001c8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cb	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001cf	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001d2	75 07		 jne	 SHORT $LN18@iso2022pro

; 335  :                 designation = 2;

  001d4	c6 44 24 10 02	 mov	 BYTE PTR designation$[rsp], 2
  001d9	eb 0a		 jmp	 SHORT $LN17@iso2022pro
$LN18@iso2022pro:

; 336  :             else return 3;

  001db	b8 03 00 00 00	 mov	 eax, 3
  001e0	e9 6c 01 00 00	 jmp	 $LN38@iso2022pro
$LN17@iso2022pro:
$LN19@iso2022pro:
$LN21@iso2022pro:
$LN23@iso2022pro:

; 337  :         }
; 338  :         break;

  001e5	e9 cd 00 00 00	 jmp	 $LN26@iso2022pro
$LN16@iso2022pro:

; 339  :     case 4:
; 340  :         if (IN2 != '$')

  001ea	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  001ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f2	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001f6	83 f8 24	 cmp	 eax, 36			; 00000024H
  001f9	74 0a		 je	 SHORT $LN15@iso2022pro

; 341  :             return 4;

  001fb	b8 04 00 00 00	 mov	 eax, 4
  00200	e9 4c 01 00 00	 jmp	 $LN38@iso2022pro
$LN15@iso2022pro:

; 342  : 
; 343  :         charset = IN4 | CHARSET_DBCS;

  00205	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  0020a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020d	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00211	0f ba e8 07	 bts	 eax, 7
  00215	88 44 24 11	 mov	 BYTE PTR charset$[rsp], al

; 344  :         if (IN3 == '(') designation = 0;

  00219	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  0021e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00221	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00225	83 f8 28	 cmp	 eax, 40			; 00000028H
  00228	75 07		 jne	 SHORT $LN14@iso2022pro
  0022a	c6 44 24 10 00	 mov	 BYTE PTR designation$[rsp], 0
  0022f	eb 22		 jmp	 SHORT $LN13@iso2022pro
$LN14@iso2022pro:

; 345  :         else if (IN3 == ')') designation = 1;

  00231	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  00236	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00239	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0023d	83 f8 29	 cmp	 eax, 41			; 00000029H
  00240	75 07		 jne	 SHORT $LN12@iso2022pro
  00242	c6 44 24 10 01	 mov	 BYTE PTR designation$[rsp], 1
  00247	eb 0a		 jmp	 SHORT $LN11@iso2022pro
$LN12@iso2022pro:

; 346  :         else return 4;

  00249	b8 04 00 00 00	 mov	 eax, 4
  0024e	e9 fe 00 00 00	 jmp	 $LN38@iso2022pro
$LN11@iso2022pro:
$LN13@iso2022pro:

; 347  :         break;

  00253	eb 62		 jmp	 SHORT $LN26@iso2022pro
$LN10@iso2022pro:

; 348  :     case 6: /* designation with prefix */
; 349  :         if (CONFIG_ISSET(USE_JISX0208_EXT) &&
; 350  :             (*inbuf)[3] == ESC && (*inbuf)[4] == '$' &&
; 351  :             (*inbuf)[5] == 'B') {

  00255	48 8b 44 24 40	 mov	 rax, QWORD PTR config$[rsp]
  0025a	8b 00		 mov	 eax, DWORD PTR [rax]
  0025c	83 e0 04	 and	 eax, 4
  0025f	85 c0		 test	 eax, eax
  00261	74 3f		 je	 SHORT $LN9@iso2022pro
  00263	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  00268	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0026b	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0026f	83 f8 1b	 cmp	 eax, 27
  00272	75 2e		 jne	 SHORT $LN9@iso2022pro
  00274	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  00279	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0027c	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00280	83 f8 24	 cmp	 eax, 36			; 00000024H
  00283	75 1d		 jne	 SHORT $LN9@iso2022pro
  00285	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  0028a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0028d	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00291	83 f8 42	 cmp	 eax, 66			; 00000042H
  00294	75 0c		 jne	 SHORT $LN9@iso2022pro

; 352  :             charset = 'B' | CHARSET_DBCS;

  00296	c6 44 24 11 c2	 mov	 BYTE PTR charset$[rsp], 194 ; 000000c2H

; 353  :             designation = 0;

  0029b	c6 44 24 10 00	 mov	 BYTE PTR designation$[rsp], 0

; 354  :         }
; 355  :         else

  002a0	eb 0a		 jmp	 SHORT $LN8@iso2022pro
$LN9@iso2022pro:

; 356  :             return 6;

  002a2	b8 06 00 00 00	 mov	 eax, 6
  002a7	e9 a5 00 00 00	 jmp	 $LN38@iso2022pro
$LN8@iso2022pro:

; 357  :         break;

  002ac	eb 09		 jmp	 SHORT $LN26@iso2022pro
$LN7@iso2022pro:

; 358  :     default:
; 359  :         return esclen;

  002ae	48 8b 04 24	 mov	 rax, QWORD PTR esclen$[rsp]
  002b2	e9 9a 00 00 00	 jmp	 $LN38@iso2022pro
$LN26@iso2022pro:

; 360  :     }
; 361  : 
; 362  :     /* raise error when the charset is not designated for this encoding */
; 363  :     if (charset != CHARSET_ASCII) {

  002b7	0f b6 44 24 11	 movzx	 eax, BYTE PTR charset$[rsp]
  002bc	83 f8 42	 cmp	 eax, 66			; 00000042H
  002bf	74 51		 je	 SHORT $LN6@iso2022pro

; 364  :         const struct iso2022_designation *dsg;
; 365  : 
; 366  :         for (dsg = CONFIG_DESIGNATIONS; dsg->mark; dsg++)

  002c1	48 8b 44 24 40	 mov	 rax, QWORD PTR config$[rsp]
  002c6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002ca	48 89 44 24 18	 mov	 QWORD PTR dsg$20932[rsp], rax
  002cf	eb 0e		 jmp	 SHORT $LN5@iso2022pro
$LN4@iso2022pro:
  002d1	48 8b 44 24 18	 mov	 rax, QWORD PTR dsg$20932[rsp]
  002d6	48 83 c0 20	 add	 rax, 32			; 00000020H
  002da	48 89 44 24 18	 mov	 QWORD PTR dsg$20932[rsp], rax
$LN5@iso2022pro:
  002df	48 8b 44 24 18	 mov	 rax, QWORD PTR dsg$20932[rsp]
  002e4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002e7	85 c0		 test	 eax, eax
  002e9	74 15		 je	 SHORT $LN3@iso2022pro

; 367  :             if (dsg->mark == charset)

  002eb	48 8b 44 24 18	 mov	 rax, QWORD PTR dsg$20932[rsp]
  002f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f3	0f b6 4c 24 11	 movzx	 ecx, BYTE PTR charset$[rsp]
  002f8	3b c1		 cmp	 eax, ecx
  002fa	75 02		 jne	 SHORT $LN2@iso2022pro

; 368  :                 break;

  002fc	eb 02		 jmp	 SHORT $LN3@iso2022pro
$LN2@iso2022pro:

; 369  :         if (!dsg->mark)

  002fe	eb d1		 jmp	 SHORT $LN4@iso2022pro
$LN3@iso2022pro:
  00300	48 8b 44 24 18	 mov	 rax, QWORD PTR dsg$20932[rsp]
  00305	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00308	85 c0		 test	 eax, eax
  0030a	75 06		 jne	 SHORT $LN1@iso2022pro

; 370  :             return esclen;

  0030c	48 8b 04 24	 mov	 rax, QWORD PTR esclen$[rsp]
  00310	eb 3f		 jmp	 SHORT $LN38@iso2022pro
$LN1@iso2022pro:
$LN6@iso2022pro:

; 371  :     }
; 372  : 
; 373  :     STATE_SETG(designation, charset)

  00312	0f b6 44 24 10	 movzx	 eax, BYTE PTR designation$[rsp]
  00317	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  0031c	0f b6 54 24 11	 movzx	 edx, BYTE PTR charset$[rsp]
  00321	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 374  :     *inleft -= esclen;

  00324	48 8b 44 24 58	 mov	 rax, QWORD PTR inleft$[rsp]
  00329	48 8b 0c 24	 mov	 rcx, QWORD PTR esclen$[rsp]
  0032d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00330	48 2b c1	 sub	 rax, rcx
  00333	48 8b 4c 24 58	 mov	 rcx, QWORD PTR inleft$[rsp]
  00338	48 89 01	 mov	 QWORD PTR [rcx], rax

; 375  :     (*inbuf) += esclen;

  0033b	48 8b 44 24 50	 mov	 rax, QWORD PTR inbuf$[rsp]
  00340	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00343	48 03 04 24	 add	 rax, QWORD PTR esclen$[rsp]
  00347	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inbuf$[rsp]
  0034c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 376  :     return 0;

  0034f	33 c0		 xor	 eax, eax
$LN38@iso2022pro:

; 377  : }

  00351	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00355	c3		 ret	 0
iso2022processesc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iso2022processg2 DD imagerel iso2022processg2
	DD	imagerel iso2022processg2+733
	DD	imagerel $unwind$iso2022processg2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso2022processg2 DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT iso2022processg2
_TEXT	SEGMENT
tv236 = 0
tv252 = 4
config$ = 32
state$ = 40
inbuf$ = 48
inleft$ = 56
outbuf$ = 64
outleft$ = 72
iso2022processg2 PROC					; COMDAT

; 394  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 395  :     /* not written to use encoder, decoder functions because only few
; 396  :      * encodings use G2 designations in CJKCodecs */
; 397  :     if (STATE_G2 == CHARSET_ISO8859_1) {

  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0001d	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00021	83 f8 41	 cmp	 eax, 65			; 00000041H
  00024	75 40		 jne	 SHORT $LN23@iso2022pro@2

; 398  :         if (IN3 < 0x80)

  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00032	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00037	7d 1e		 jge	 SHORT $LN22@iso2022pro@2

; 399  :             OUT1(IN3 + 0x80)

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  0003e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00041	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00045	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outbuf$[rsp]
  0004f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00052	66 89 01	 mov	 WORD PTR [rcx], ax

; 400  :         else

  00055	eb 0a		 jmp	 SHORT $LN21@iso2022pro@2
$LN22@iso2022pro@2:

; 401  :             return 3;

  00057	b8 03 00 00 00	 mov	 eax, 3
  0005c	e9 77 02 00 00	 jmp	 $LN24@iso2022pro@2
$LN21@iso2022pro@2:

; 402  :     }
; 403  :     else if (STATE_G2 == CHARSET_ISO8859_7) {

  00061	e9 21 02 00 00	 jmp	 $LN20@iso2022pro@2
$LN23@iso2022pro@2:
  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0006b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0006f	83 f8 46	 cmp	 eax, 70			; 00000046H
  00072	0f 85 c1 01 00
	00		 jne	 $LN19@iso2022pro@2

; 404  :         ISO8859_7_DECODE(IN3 ^ 0x80, **outbuf)

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  0007d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00080	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00084	0f ba f8 07	 btc	 eax, 7
  00088	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  0008d	7d 20		 jge	 SHORT $LN18@iso2022pro@2
  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  00094	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00097	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0009b	0f ba f8 07	 btc	 eax, 7
  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outbuf$[rsp]
  000a4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a7	66 89 01	 mov	 WORD PTR [rcx], ax
  000aa	e9 88 01 00 00	 jmp	 $LN17@iso2022pro@2
$LN18@iso2022pro@2:
  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  000b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b7	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000bb	0f ba f8 07	 btc	 eax, 7
  000bf	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000c4	7d 4e		 jge	 SHORT $LN16@iso2022pro@2
  000c6	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  000cb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ce	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000d2	0f ba f8 07	 btc	 eax, 7
  000d6	2d a0 00 00 00	 sub	 eax, 160		; 000000a0H
  000db	b9 01 00 00 00	 mov	 ecx, 1
  000e0	89 0c 24	 mov	 DWORD PTR tv236[rsp], ecx
  000e3	0f b6 c8	 movzx	 ecx, al
  000e6	8b 04 24	 mov	 eax, DWORD PTR tv236[rsp]
  000e9	d3 e0		 shl	 eax, cl
  000eb	25 c9 3b 8f 28	 and	 eax, 680475593		; 288f3bc9H
  000f0	85 c0		 test	 eax, eax
  000f2	74 20		 je	 SHORT $LN16@iso2022pro@2
  000f4	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  000f9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fc	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00100	0f ba f8 07	 btc	 eax, 7
  00104	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outbuf$[rsp]
  00109	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0010c	66 89 01	 mov	 WORD PTR [rcx], ax
  0010f	e9 23 01 00 00	 jmp	 $LN15@iso2022pro@2
$LN16@iso2022pro@2:
  00114	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  00119	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011c	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00120	0f ba f8 07	 btc	 eax, 7
  00124	3d b4 00 00 00	 cmp	 eax, 180		; 000000b4H
  00129	0f 8c 83 00 00
	00		 jl	 $LN14@iso2022pro@2
  0012f	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  00134	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00137	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0013b	0f ba f8 07	 btc	 eax, 7
  0013f	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00144	7f 6c		 jg	 SHORT $LN14@iso2022pro@2
  00146	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  0014b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0014e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00152	0f ba f8 07	 btc	 eax, 7
  00156	3d d4 00 00 00	 cmp	 eax, 212		; 000000d4H
  0015b	7d 30		 jge	 SHORT $LN13@iso2022pro@2
  0015d	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  00162	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00165	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00169	0f ba f8 07	 btc	 eax, 7
  0016d	2d b4 00 00 00	 sub	 eax, 180		; 000000b4H
  00172	b9 01 00 00 00	 mov	 ecx, 1
  00177	89 4c 24 04	 mov	 DWORD PTR tv252[rsp], ecx
  0017b	0f b6 c8	 movzx	 ecx, al
  0017e	8b 44 24 04	 mov	 eax, DWORD PTR tv252[rsp]
  00182	d3 e0		 shl	 eax, cl
  00184	25 77 fd ff bf	 and	 eax, -1073742473	; bffffd77H
  00189	85 c0		 test	 eax, eax
  0018b	74 25		 je	 SHORT $LN14@iso2022pro@2
$LN13@iso2022pro@2:
  0018d	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  00192	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00195	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00199	0f ba f8 07	 btc	 eax, 7
  0019d	05 d0 02 00 00	 add	 eax, 720		; 000002d0H
  001a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outbuf$[rsp]
  001a7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001aa	66 89 01	 mov	 WORD PTR [rcx], ax
  001ad	e9 85 00 00 00	 jmp	 $LN12@iso2022pro@2
$LN14@iso2022pro@2:
  001b2	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  001b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ba	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001be	0f ba f8 07	 btc	 eax, 7
  001c2	3d a1 00 00 00	 cmp	 eax, 161		; 000000a1H
  001c7	75 12		 jne	 SHORT $LN11@iso2022pro@2
  001c9	48 8b 44 24 40	 mov	 rax, QWORD PTR outbuf$[rsp]
  001ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001d1	b9 18 20 00 00	 mov	 ecx, 8216		; 00002018H
  001d6	66 89 08	 mov	 WORD PTR [rax], cx
  001d9	eb 5c		 jmp	 SHORT $LN10@iso2022pro@2
$LN11@iso2022pro@2:
  001db	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  001e0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e3	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001e7	0f ba f8 07	 btc	 eax, 7
  001eb	3d a2 00 00 00	 cmp	 eax, 162		; 000000a2H
  001f0	75 12		 jne	 SHORT $LN9@iso2022pro@2
  001f2	48 8b 44 24 40	 mov	 rax, QWORD PTR outbuf$[rsp]
  001f7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001fa	b9 19 20 00 00	 mov	 ecx, 8217		; 00002019H
  001ff	66 89 08	 mov	 WORD PTR [rax], cx
  00202	eb 33		 jmp	 SHORT $LN8@iso2022pro@2
$LN9@iso2022pro@2:
  00204	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  00209	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020c	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00210	0f ba f8 07	 btc	 eax, 7
  00214	3d af 00 00 00	 cmp	 eax, 175		; 000000afH
  00219	75 12		 jne	 SHORT $LN7@iso2022pro@2
  0021b	48 8b 44 24 40	 mov	 rax, QWORD PTR outbuf$[rsp]
  00220	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00223	b9 15 20 00 00	 mov	 ecx, 8213		; 00002015H
  00228	66 89 08	 mov	 WORD PTR [rax], cx
  0022b	eb 0a		 jmp	 SHORT $LN6@iso2022pro@2
$LN7@iso2022pro@2:

; 405  :         else return 3;

  0022d	b8 03 00 00 00	 mov	 eax, 3
  00232	e9 a1 00 00 00	 jmp	 $LN24@iso2022pro@2
$LN6@iso2022pro@2:
$LN8@iso2022pro@2:
$LN10@iso2022pro@2:
$LN12@iso2022pro@2:
$LN15@iso2022pro@2:
$LN17@iso2022pro@2:

; 406  :     }
; 407  :     else if (STATE_G2 == CHARSET_ASCII) {

  00237	eb 4e		 jmp	 SHORT $LN5@iso2022pro@2
$LN19@iso2022pro@2:
  00239	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0023e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00242	83 f8 42	 cmp	 eax, 66			; 00000042H
  00245	75 37		 jne	 SHORT $LN4@iso2022pro@2

; 408  :         if (IN3 & 0x80) return 3;

  00247	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  0024c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0024f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00253	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00258	85 c0		 test	 eax, eax
  0025a	74 09		 je	 SHORT $LN3@iso2022pro@2
  0025c	b8 03 00 00 00	 mov	 eax, 3
  00261	eb 75		 jmp	 SHORT $LN24@iso2022pro@2
  00263	eb 17		 jmp	 SHORT $LN2@iso2022pro@2
$LN3@iso2022pro@2:

; 409  :         else **outbuf = IN3;

  00265	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  0026a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0026d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outbuf$[rsp]
  00272	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00275	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00279	66 89 01	 mov	 WORD PTR [rcx], ax
$LN2@iso2022pro@2:

; 410  :     }
; 411  :     else

  0027c	eb 09		 jmp	 SHORT $LN1@iso2022pro@2
$LN4@iso2022pro@2:

; 412  :         return MBERR_INTERNAL;

  0027e	48 c7 c0 fd ff
	ff ff		 mov	 rax, -3
  00285	eb 51		 jmp	 SHORT $LN24@iso2022pro@2
$LN1@iso2022pro@2:
$LN5@iso2022pro@2:
$LN20@iso2022pro@2:

; 413  : 
; 414  :     (*inbuf) += 3;

  00287	48 8b 44 24 30	 mov	 rax, QWORD PTR inbuf$[rsp]
  0028c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0028f	48 83 c0 03	 add	 rax, 3
  00293	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inbuf$[rsp]
  00298	48 89 01	 mov	 QWORD PTR [rcx], rax

; 415  :     *inleft -= 3;

  0029b	48 8b 44 24 38	 mov	 rax, QWORD PTR inleft$[rsp]
  002a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002a3	48 83 e8 03	 sub	 rax, 3
  002a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR inleft$[rsp]
  002ac	48 89 01	 mov	 QWORD PTR [rcx], rax

; 416  :     (*outbuf) += 1;

  002af	48 8b 44 24 40	 mov	 rax, QWORD PTR outbuf$[rsp]
  002b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b7	48 83 c0 02	 add	 rax, 2
  002bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outbuf$[rsp]
  002c0	48 89 01	 mov	 QWORD PTR [rcx], rax

; 417  :     *outleft -= 1;

  002c3	48 8b 44 24 48	 mov	 rax, QWORD PTR outleft$[rsp]
  002c8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002cb	48 ff c8	 dec	 rax
  002ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR outleft$[rsp]
  002d3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 418  :     return 0;

  002d6	33 c0		 xor	 eax, eax
$LN24@iso2022pro@2:

; 419  : }

  002d8	48 83 c4 18	 add	 rsp, 24
  002dc	c3		 ret	 0
iso2022processg2 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@DEAIEGHE@__map_ksx1001?$AA@		; `string'
PUBLIC	??_C@_0L@LBOMJMFO@_codecs_kr?$AA@		; `string'
PUBLIC	??_C@_0M@OADICNAA@__map_cp949?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ksx1001_init DD imagerel ksx1001_init
	DD	imagerel ksx1001_init+103
	DD	imagerel $unwind$ksx1001_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ksx1001_init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0O@DEAIEGHE@__map_ksx1001?$AA@
CONST	SEGMENT
??_C@_0O@DEAIEGHE@__map_ksx1001?$AA@ DB '__map_ksx1001', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LBOMJMFO@_codecs_kr?$AA@
CONST	SEGMENT
??_C@_0L@LBOMJMFO@_codecs_kr?$AA@ DB '_codecs_kr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OADICNAA@__map_cp949?$AA@
CONST	SEGMENT
??_C@_0M@OADICNAA@__map_cp949?$AA@ DB '__map_cp949', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ksx1001_init
_TEXT	SEGMENT
ksx1001_init PROC					; COMDAT

; 569  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 570  :     static int initialized = 0;
; 571  : 
; 572  :     if (!initialized && (
; 573  :                     IMPORT_MAP(kr, cp949, &cp949_encmap, NULL) ||
; 574  :                     IMPORT_MAP(kr, ksx1001, NULL, &ksx1001_decmap)))

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??ksx1001_init@@9@9, 0
  0000b	75 49		 jne	 SHORT $LN2@ksx1001_in
  0000d	45 33 c9	 xor	 r9d, r9d
  00010	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cp949_encmap
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OADICNAA@__map_cp949?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LBOMJMFO@_codecs_kr?$AA@
  00025	e8 00 00 00 00	 call	 importmap
  0002a	85 c0		 test	 eax, eax
  0002c	75 21		 jne	 SHORT $LN1@ksx1001_in
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:ksx1001_decmap
  00035	45 33 c0	 xor	 r8d, r8d
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@DEAIEGHE@__map_ksx1001?$AA@
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LBOMJMFO@_codecs_kr?$AA@
  00046	e8 00 00 00 00	 call	 importmap
  0004b	85 c0		 test	 eax, eax
  0004d	74 07		 je	 SHORT $LN2@ksx1001_in
$LN1@ksx1001_in:

; 575  :         return -1;

  0004f	b8 ff ff ff ff	 mov	 eax, -1
  00054	eb 0c		 jmp	 SHORT $LN3@ksx1001_in
$LN2@ksx1001_in:

; 576  :     initialized = 1;

  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??ksx1001_init@@9@9, 1

; 577  :     return 0;

  00060	33 c0		 xor	 eax, eax
$LN3@ksx1001_in:

; 578  : }

  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	c3		 ret	 0
ksx1001_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@JBGGBAKI@map?5data?5must?5be?5a?5Capsule?4?$AA@ ; `string'
EXTRN	PyCapsule_GetPointer:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyCapsule_IsValid:PROC
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\cjkcodecs\cjkcodecs.h
pdata	SEGMENT
$pdata$importmap DD imagerel importmap
	DD	imagerel importmap+252
	DD	imagerel $unwind$importmap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$importmap DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT ??_C@_0BM@JBGGBAKI@map?5data?5must?5be?5a?5Capsule?4?$AA@
CONST	SEGMENT
??_C@_0BM@JBGGBAKI@map?5data?5must?5be?5a?5Capsule?4?$AA@ DB 'map data mu'
	DB	'st be a Capsule.', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT importmap
_TEXT	SEGMENT
mod$ = 32
o$ = 40
map$20659 = 48
modname$ = 80
symbol$ = 88
encmap$ = 96
decmap$ = 104
importmap PROC						; COMDAT

; 359  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 360  :     PyObject *o, *mod;
; 361  : 
; 362  :     mod = PyImport_ImportModule((char *)modname);

  00018	48 8b 4c 24 50	 mov	 rcx, QWORD PTR modname$[rsp]
  0001d	e8 00 00 00 00	 call	 PyImport_ImportModule
  00022	48 89 44 24 20	 mov	 QWORD PTR mod$[rsp], rax

; 363  :     if (mod == NULL)

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR mod$[rsp], 0
  0002d	75 0a		 jne	 SHORT $LN7@importmap

; 364  :         return -1;

  0002f	b8 ff ff ff ff	 mov	 eax, -1
  00034	e9 be 00 00 00	 jmp	 $LN8@importmap
$LN7@importmap:

; 365  : 
; 366  :     o = PyObject_GetAttrString(mod, (char*)symbol);

  00039	48 8b 54 24 58	 mov	 rdx, QWORD PTR symbol$[rsp]
  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mod$[rsp]
  00043	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00048	48 89 44 24 28	 mov	 QWORD PTR o$[rsp], rax

; 367  :     if (o == NULL)

  0004d	48 83 7c 24 28
	00		 cmp	 QWORD PTR o$[rsp], 0
  00053	75 07		 jne	 SHORT $LN6@importmap

; 368  :         goto errorexit;

  00055	e9 8e 00 00 00	 jmp	 $errorexit$20654
  0005a	eb 7e		 jmp	 SHORT $LN5@importmap
$LN6@importmap:

; 369  :     else if (!PyCapsule_IsValid(o, PyMultibyteCodec_CAPSULE_NAME)) {

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@
  00063	48 8b 4c 24 28	 mov	 rcx, QWORD PTR o$[rsp]
  00068	e8 00 00 00 00	 call	 PyCapsule_IsValid
  0006d	85 c0		 test	 eax, eax
  0006f	75 17		 jne	 SHORT $LN4@importmap

; 370  :         PyErr_SetString(PyExc_ValueError,
; 371  :                         "map data must be a Capsule.");

  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@JBGGBAKI@map?5data?5must?5be?5a?5Capsule?4?$AA@
  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0007f	e8 00 00 00 00	 call	 PyErr_SetString

; 372  :         goto errorexit;

  00084	eb 62		 jmp	 SHORT $errorexit$20654

; 373  :     }
; 374  :     else {

  00086	eb 52		 jmp	 SHORT $LN3@importmap
$LN4@importmap:

; 375  :         struct dbcs_map *map;
; 376  :         map = PyCapsule_GetPointer(o, PyMultibyteCodec_CAPSULE_NAME);

  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@
  0008f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR o$[rsp]
  00094	e8 00 00 00 00	 call	 PyCapsule_GetPointer
  00099	48 89 44 24 30	 mov	 QWORD PTR map$20659[rsp], rax

; 377  :         if (encmap != NULL)

  0009e	48 83 7c 24 60
	00		 cmp	 QWORD PTR encmap$[rsp], 0
  000a4	74 11		 je	 SHORT $LN2@importmap

; 378  :             *encmap = map->encmap;

  000a6	48 8b 44 24 60	 mov	 rax, QWORD PTR encmap$[rsp]
  000ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR map$20659[rsp]
  000b0	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b4	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@importmap:

; 379  :         if (decmap != NULL)

  000b7	48 83 7c 24 68
	00		 cmp	 QWORD PTR decmap$[rsp], 0
  000bd	74 11		 je	 SHORT $LN1@importmap

; 380  :             *decmap = map->decmap;

  000bf	48 8b 44 24 68	 mov	 rax, QWORD PTR decmap$[rsp]
  000c4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR map$20659[rsp]
  000c9	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000cd	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@importmap:

; 381  :         Py_DECREF(o);

  000d0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR o$[rsp]
  000d5	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@importmap:
$LN5@importmap:

; 382  :     }
; 383  : 
; 384  :     Py_DECREF(mod);

  000da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mod$[rsp]
  000df	e8 00 00 00 00	 call	 _Py_DecRef

; 385  :     return 0;

  000e4	33 c0		 xor	 eax, eax
  000e6	eb 0f		 jmp	 SHORT $LN8@importmap
$errorexit$20654:

; 386  : 
; 387  : errorexit:
; 388  :     Py_DECREF(mod);

  000e8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mod$[rsp]
  000ed	e8 00 00 00 00	 call	 _Py_DecRef

; 389  :     return -1;

  000f2	b8 ff ff ff ff	 mov	 eax, -1
$LN8@importmap:

; 390  : }

  000f7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fb	c3		 ret	 0
importmap ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\cjkcodecs\_codecs_iso2022.c
pdata	SEGMENT
$pdata$ksx1001_decoder DD imagerel ksx1001_decoder
	DD	imagerel ksx1001_decoder+208
	DD	imagerel $unwind$ksx1001_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ksx1001_decoder DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ksx1001_decoder
_TEXT	SEGMENT
u$ = 0
data$ = 32
ksx1001_decoder PROC					; COMDAT

; 582  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 583  :     ucs4_t u;
; 584  :     TRYMAP_DEC(ksx1001, u, data[0], data[1])

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0000e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00011	48 6b c0 10	 imul	 rax, 16
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ksx1001_decmap
  0001c	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00021	0f 84 9f 00 00
	00		 je	 $LN2@ksx1001_de
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0002c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00035	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00038	48 6b c9 10	 imul	 rcx, 16
  0003c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ksx1001_decmap
  00043	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00048	3b c1		 cmp	 eax, ecx
  0004a	7c 7a		 jl	 SHORT $LN2@ksx1001_de
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00051	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0005a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0005d	48 6b c9 10	 imul	 rcx, 16
  00061	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ksx1001_decmap
  00068	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  0006d	3b c1		 cmp	 eax, ecx
  0006f	7f 55		 jg	 SHORT $LN2@ksx1001_de
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00076	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00079	48 6b c0 10	 imul	 rax, 16
  0007d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00082	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00086	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0008b	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  0008e	48 6b d2 10	 imul	 rdx, 16
  00092	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ksx1001_decmap
  00099	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  0009f	2b ca		 sub	 ecx, edx
  000a1	48 63 c9	 movsxd	 rcx, ecx
  000a4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ksx1001_decmap
  000ab	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000af	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  000b3	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  000b6	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  000bd	74 07		 je	 SHORT $LN2@ksx1001_de

; 585  :         return u;

  000bf	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
  000c2	eb 07		 jmp	 SHORT $LN3@ksx1001_de

; 586  :     else

  000c4	eb 05		 jmp	 SHORT $LN1@ksx1001_de
$LN2@ksx1001_de:

; 587  :         return MAP_UNMAPPABLE;

  000c6	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN1@ksx1001_de:
$LN3@ksx1001_de:

; 588  : }

  000cb	48 83 c4 18	 add	 rsp, 24
  000cf	c3		 ret	 0
ksx1001_decoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BK@KFPJGOKE@?$AA?$CK?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ksx1001_encoder DD imagerel ksx1001_encoder
	DD	imagerel ksx1001_encoder+321
	DD	imagerel $unwind$ksx1001_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ksx1001_encoder DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1BK@KFPJGOKE@?$AA?$CK?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@KFPJGOKE@?$AA?$CK?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB '*'
	DB	00H, 'l', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ksx1001_encoder
_TEXT	SEGMENT
coded$ = 32
data$ = 64
length$ = 72
ksx1001_encoder PROC					; COMDAT

; 592  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 593  :     DBCHAR coded;
; 594  :     assert(*length == 1);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR length$[rsp]
  00013	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00017	74 1c		 je	 SHORT $LN6@ksx1001_en
  00019	41 b8 52 02 00
	00		 mov	 r8d, 594		; 00000252H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MBLKAJOP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAc?$AAj?$AAk?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA?2?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA_?$AAi?$AAs?$AAo@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@KFPJGOKE@?$AA?$CK?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00033	33 c0		 xor	 eax, eax
$LN6@ksx1001_en:

; 595  :     if (*data < 0x10000) {

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0003a	81 38 00 00 01
	00		 cmp	 DWORD PTR [rax], 65536	; 00010000H
  00040	0f 83 f1 00 00
	00		 jae	 $LN3@ksx1001_en

; 596  :         TRYMAP_ENC(cp949, coded, *data)

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0004b	8b 00		 mov	 eax, DWORD PTR [rax]
  0004d	c1 e8 08	 shr	 eax, 8
  00050	8b c0		 mov	 eax, eax
  00052	48 6b c0 10	 imul	 rax, 16
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cp949_encmap
  0005d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00062	0f 84 cf 00 00
	00		 je	 $LN2@ksx1001_en
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0006d	8b 00		 mov	 eax, DWORD PTR [rax]
  0006f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00079	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0007b	c1 e9 08	 shr	 ecx, 8
  0007e	8b c9		 mov	 ecx, ecx
  00080	48 6b c9 10	 imul	 rcx, 16
  00084	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR cp949_encmap
  0008b	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00090	3b c1		 cmp	 eax, ecx
  00092	0f 82 9f 00 00
	00		 jb	 $LN2@ksx1001_en
  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0009d	8b 00		 mov	 eax, DWORD PTR [rax]
  0009f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000a9	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000ab	c1 e9 08	 shr	 ecx, 8
  000ae	8b c9		 mov	 ecx, ecx
  000b0	48 6b c9 10	 imul	 rcx, 16
  000b4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR cp949_encmap
  000bb	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  000c0	3b c1		 cmp	 eax, ecx
  000c2	77 73		 ja	 SHORT $LN2@ksx1001_en
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  000c9	8b 00		 mov	 eax, DWORD PTR [rax]
  000cb	c1 e8 08	 shr	 eax, 8
  000ce	8b c0		 mov	 eax, eax
  000d0	48 6b c0 10	 imul	 rax, 16
  000d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000d9	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000db	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000e1	48 8b 54 24 40	 mov	 rdx, QWORD PTR data$[rsp]
  000e6	8b 12		 mov	 edx, DWORD PTR [rdx]
  000e8	c1 ea 08	 shr	 edx, 8
  000eb	8b d2		 mov	 edx, edx
  000ed	48 6b d2 10	 imul	 rdx, 16
  000f1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR cp949_encmap
  000f8	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  000fe	2b ca		 sub	 ecx, edx
  00100	8b c9		 mov	 ecx, ecx
  00102	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR cp949_encmap
  00109	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0010d	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00111	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax
  00116	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0011b	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00120	74 15		 je	 SHORT $LN2@ksx1001_en

; 597  :             if (!(coded & 0x8000))

  00122	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00127	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  0012c	85 c0		 test	 eax, eax
  0012e	75 07		 jne	 SHORT $LN1@ksx1001_en

; 598  :                 return coded;

  00130	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00135	eb 05		 jmp	 SHORT $LN4@ksx1001_en
$LN1@ksx1001_en:
$LN2@ksx1001_en:
$LN3@ksx1001_en:

; 599  :     }
; 600  :     return MAP_UNMAPPABLE;

  00137	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN4@ksx1001_en:

; 601  : }

  0013c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00140	c3		 ret	 0
ksx1001_encoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@DLFIJFNK@__map_jisx0208?$AA@		; `string'
PUBLIC	??_C@_0L@ICBIJEOL@_codecs_jp?$AA@		; `string'
PUBLIC	??_C@_0BB@NNDKKHNL@__map_jisxcommon?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0208_init DD imagerel jisx0208_init
	DD	imagerel jisx0208_init+103
	DD	imagerel $unwind$jisx0208_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0208_init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0P@DLFIJFNK@__map_jisx0208?$AA@
CONST	SEGMENT
??_C@_0P@DLFIJFNK@__map_jisx0208?$AA@ DB '__map_jisx0208', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
CONST	SEGMENT
??_C@_0L@ICBIJEOL@_codecs_jp?$AA@ DB '_codecs_jp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NNDKKHNL@__map_jisxcommon?$AA@
CONST	SEGMENT
??_C@_0BB@NNDKKHNL@__map_jisxcommon?$AA@ DB '__map_jisxcommon', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT jisx0208_init
_TEXT	SEGMENT
jisx0208_init PROC					; COMDAT

; 605  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 606  :     static int initialized = 0;
; 607  : 
; 608  :     if (!initialized && (
; 609  :                     IMPORT_MAP(jp, jisxcommon, &jisxcommon_encmap, NULL) ||
; 610  :                     IMPORT_MAP(jp, jisx0208, NULL, &jisx0208_decmap)))

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??jisx0208_init@@9@9, 0
  0000b	75 49		 jne	 SHORT $LN2@jisx0208_i
  0000d	45 33 c9	 xor	 r9d, r9d
  00010	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:jisxcommon_encmap
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@NNDKKHNL@__map_jisxcommon?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00025	e8 00 00 00 00	 call	 importmap
  0002a	85 c0		 test	 eax, eax
  0002c	75 21		 jne	 SHORT $LN1@jisx0208_i
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0208_decmap
  00035	45 33 c0	 xor	 r8d, r8d
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DLFIJFNK@__map_jisx0208?$AA@
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00046	e8 00 00 00 00	 call	 importmap
  0004b	85 c0		 test	 eax, eax
  0004d	74 07		 je	 SHORT $LN2@jisx0208_i
$LN1@jisx0208_i:

; 611  :         return -1;

  0004f	b8 ff ff ff ff	 mov	 eax, -1
  00054	eb 0c		 jmp	 SHORT $LN3@jisx0208_i
$LN2@jisx0208_i:

; 612  :     initialized = 1;

  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??jisx0208_init@@9@9, 1

; 613  :     return 0;

  00060	33 c0		 xor	 eax, eax
$LN3@jisx0208_i:

; 614  : }

  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	c3		 ret	 0
jisx0208_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0208_decoder DD imagerel jisx0208_decoder
	DD	imagerel jisx0208_decoder+250
	DD	imagerel $unwind$jisx0208_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0208_decoder DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0208_decoder
_TEXT	SEGMENT
u$ = 0
data$ = 32
jisx0208_decoder PROC					; COMDAT

; 618  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 619  :     ucs4_t u;
; 620  :     if (data[0] == 0x21 && data[1] == 0x40) /* F/W REVERSE SOLIDUS */

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0000e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00011	83 f8 21	 cmp	 eax, 33			; 00000021H
  00014	75 1d		 jne	 SHORT $LN4@jisx0208_d
  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0001b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001f	83 f8 40	 cmp	 eax, 64			; 00000040H
  00022	75 0f		 jne	 SHORT $LN4@jisx0208_d

; 621  :         return 0xff3c;

  00024	b8 3c ff 00 00	 mov	 eax, 65340		; 0000ff3cH
  00029	e9 c7 00 00 00	 jmp	 $LN5@jisx0208_d
  0002e	e9 c2 00 00 00	 jmp	 $LN3@jisx0208_d
$LN4@jisx0208_d:

; 622  :     else TRYMAP_DEC(jisx0208, u, data[0], data[1])

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00038	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003b	48 6b c0 10	 imul	 rax, 16
  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0208_decmap
  00046	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0004b	0f 84 9f 00 00
	00		 je	 $LN2@jisx0208_d
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00056	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0005f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00062	48 6b c9 10	 imul	 rcx, 16
  00066	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0208_decmap
  0006d	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00072	3b c1		 cmp	 eax, ecx
  00074	7c 7a		 jl	 SHORT $LN2@jisx0208_d
  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0007b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0007f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00084	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00087	48 6b c9 10	 imul	 rcx, 16
  0008b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0208_decmap
  00092	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  00097	3b c1		 cmp	 eax, ecx
  00099	7f 55		 jg	 SHORT $LN2@jisx0208_d
  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000a0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a3	48 6b c0 10	 imul	 rax, 16
  000a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  000ac	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  000b0	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  000b5	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  000b8	48 6b d2 10	 imul	 rdx, 16
  000bc	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0208_decmap
  000c3	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  000c9	2b ca		 sub	 ecx, edx
  000cb	48 63 c9	 movsxd	 rcx, ecx
  000ce	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0208_decmap
  000d5	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000d9	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  000dd	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  000e0	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  000e7	74 07		 je	 SHORT $LN2@jisx0208_d

; 623  :         return u;

  000e9	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
  000ec	eb 07		 jmp	 SHORT $LN5@jisx0208_d

; 624  :     else

  000ee	eb 05		 jmp	 SHORT $LN1@jisx0208_d
$LN2@jisx0208_d:

; 625  :         return MAP_UNMAPPABLE;

  000f0	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN1@jisx0208_d:
$LN3@jisx0208_d:
$LN5@jisx0208_d:

; 626  : }

  000f5	48 83 c4 18	 add	 rsp, 24
  000f9	c3		 ret	 0
jisx0208_decoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0208_encoder DD imagerel jisx0208_encoder
	DD	imagerel jisx0208_encoder+349
	DD	imagerel $unwind$jisx0208_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0208_encoder DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0208_encoder
_TEXT	SEGMENT
coded$ = 32
data$ = 64
length$ = 72
jisx0208_encoder PROC					; COMDAT

; 630  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 631  :     DBCHAR coded;
; 632  :     assert(*length == 1);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR length$[rsp]
  00013	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00017	74 1c		 je	 SHORT $LN8@jisx0208_e
  00019	41 b8 78 02 00
	00		 mov	 r8d, 632		; 00000278H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MBLKAJOP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAc?$AAj?$AAk?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA?2?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA_?$AAi?$AAs?$AAo@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@KFPJGOKE@?$AA?$CK?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00033	33 c0		 xor	 eax, eax
$LN8@jisx0208_e:

; 633  :     if (*data < 0x10000) {

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0003a	81 38 00 00 01
	00		 cmp	 DWORD PTR [rax], 65536	; 00010000H
  00040	0f 83 0d 01 00
	00		 jae	 $LN5@jisx0208_e

; 634  :         if (*data == 0xff3c) /* F/W REVERSE SOLIDUS */

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0004b	81 38 3c ff 00
	00		 cmp	 DWORD PTR [rax], 65340	; 0000ff3cH
  00051	75 0f		 jne	 SHORT $LN4@jisx0208_e

; 635  :             return 0x2140;

  00053	b8 40 21 00 00	 mov	 eax, 8512		; 00002140H
  00058	e9 fb 00 00 00	 jmp	 $LN6@jisx0208_e
  0005d	e9 f1 00 00 00	 jmp	 $LN3@jisx0208_e
$LN4@jisx0208_e:

; 636  :         else TRYMAP_ENC(jisxcommon, coded, *data) {

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00067	8b 00		 mov	 eax, DWORD PTR [rax]
  00069	c1 e8 08	 shr	 eax, 8
  0006c	8b c0		 mov	 eax, eax
  0006e	48 6b c0 10	 imul	 rax, 16
  00072	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisxcommon_encmap
  00079	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0007e	0f 84 cf 00 00
	00		 je	 $LN2@jisx0208_e
  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00089	8b 00		 mov	 eax, DWORD PTR [rax]
  0008b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00090	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00095	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00097	c1 e9 08	 shr	 ecx, 8
  0009a	8b c9		 mov	 ecx, ecx
  0009c	48 6b c9 10	 imul	 rcx, 16
  000a0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisxcommon_encmap
  000a7	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  000ac	3b c1		 cmp	 eax, ecx
  000ae	0f 82 9f 00 00
	00		 jb	 $LN2@jisx0208_e
  000b4	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  000b9	8b 00		 mov	 eax, DWORD PTR [rax]
  000bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000c5	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000c7	c1 e9 08	 shr	 ecx, 8
  000ca	8b c9		 mov	 ecx, ecx
  000cc	48 6b c9 10	 imul	 rcx, 16
  000d0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisxcommon_encmap
  000d7	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  000dc	3b c1		 cmp	 eax, ecx
  000de	77 73		 ja	 SHORT $LN2@jisx0208_e
  000e0	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  000e5	8b 00		 mov	 eax, DWORD PTR [rax]
  000e7	c1 e8 08	 shr	 eax, 8
  000ea	8b c0		 mov	 eax, eax
  000ec	48 6b c0 10	 imul	 rax, 16
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000f5	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000f7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000fd	48 8b 54 24 40	 mov	 rdx, QWORD PTR data$[rsp]
  00102	8b 12		 mov	 edx, DWORD PTR [rdx]
  00104	c1 ea 08	 shr	 edx, 8
  00107	8b d2		 mov	 edx, edx
  00109	48 6b d2 10	 imul	 rdx, 16
  0010d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisxcommon_encmap
  00114	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  0011a	2b ca		 sub	 ecx, edx
  0011c	8b c9		 mov	 ecx, ecx
  0011e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisxcommon_encmap
  00125	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00129	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0012d	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax
  00132	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00137	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0013c	74 15		 je	 SHORT $LN2@jisx0208_e

; 637  :             if (!(coded & 0x8000))

  0013e	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00143	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00148	85 c0		 test	 eax, eax
  0014a	75 07		 jne	 SHORT $LN1@jisx0208_e

; 638  :                 return coded;

  0014c	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00151	eb 05		 jmp	 SHORT $LN6@jisx0208_e
$LN1@jisx0208_e:
$LN2@jisx0208_e:
$LN3@jisx0208_e:
$LN5@jisx0208_e:

; 639  :         }
; 640  :     }
; 641  :     return MAP_UNMAPPABLE;

  00153	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN6@jisx0208_e:

; 642  : }

  00158	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015c	c3		 ret	 0
jisx0208_encoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@MAHFBHGH@__map_jisx0212?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0212_init DD imagerel jisx0212_init
	DD	imagerel jisx0212_init+103
	DD	imagerel $unwind$jisx0212_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0212_init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0P@MAHFBHGH@__map_jisx0212?$AA@
CONST	SEGMENT
??_C@_0P@MAHFBHGH@__map_jisx0212?$AA@ DB '__map_jisx0212', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT jisx0212_init
_TEXT	SEGMENT
jisx0212_init PROC					; COMDAT

; 646  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 647  :     static int initialized = 0;
; 648  : 
; 649  :     if (!initialized && (
; 650  :                     IMPORT_MAP(jp, jisxcommon, &jisxcommon_encmap, NULL) ||
; 651  :                     IMPORT_MAP(jp, jisx0212, NULL, &jisx0212_decmap)))

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??jisx0212_init@@9@9, 0
  0000b	75 49		 jne	 SHORT $LN2@jisx0212_i
  0000d	45 33 c9	 xor	 r9d, r9d
  00010	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:jisxcommon_encmap
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@NNDKKHNL@__map_jisxcommon?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00025	e8 00 00 00 00	 call	 importmap
  0002a	85 c0		 test	 eax, eax
  0002c	75 21		 jne	 SHORT $LN1@jisx0212_i
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0212_decmap
  00035	45 33 c0	 xor	 r8d, r8d
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@MAHFBHGH@__map_jisx0212?$AA@
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00046	e8 00 00 00 00	 call	 importmap
  0004b	85 c0		 test	 eax, eax
  0004d	74 07		 je	 SHORT $LN2@jisx0212_i
$LN1@jisx0212_i:

; 652  :         return -1;

  0004f	b8 ff ff ff ff	 mov	 eax, -1
  00054	eb 0c		 jmp	 SHORT $LN3@jisx0212_i
$LN2@jisx0212_i:

; 653  :     initialized = 1;

  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??jisx0212_init@@9@9, 1

; 654  :     return 0;

  00060	33 c0		 xor	 eax, eax
$LN3@jisx0212_i:

; 655  : }

  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	c3		 ret	 0
jisx0212_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0212_decoder DD imagerel jisx0212_decoder
	DD	imagerel jisx0212_decoder+208
	DD	imagerel $unwind$jisx0212_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0212_decoder DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0212_decoder
_TEXT	SEGMENT
u$ = 0
data$ = 32
jisx0212_decoder PROC					; COMDAT

; 659  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 660  :     ucs4_t u;
; 661  :     TRYMAP_DEC(jisx0212, u, data[0], data[1])

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0000e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00011	48 6b c0 10	 imul	 rax, 16
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0212_decmap
  0001c	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00021	0f 84 9f 00 00
	00		 je	 $LN2@jisx0212_d
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0002c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00035	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00038	48 6b c9 10	 imul	 rcx, 16
  0003c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0212_decmap
  00043	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00048	3b c1		 cmp	 eax, ecx
  0004a	7c 7a		 jl	 SHORT $LN2@jisx0212_d
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00051	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0005a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0005d	48 6b c9 10	 imul	 rcx, 16
  00061	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0212_decmap
  00068	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  0006d	3b c1		 cmp	 eax, ecx
  0006f	7f 55		 jg	 SHORT $LN2@jisx0212_d
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00076	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00079	48 6b c0 10	 imul	 rax, 16
  0007d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00082	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00086	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0008b	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  0008e	48 6b d2 10	 imul	 rdx, 16
  00092	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0212_decmap
  00099	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  0009f	2b ca		 sub	 ecx, edx
  000a1	48 63 c9	 movsxd	 rcx, ecx
  000a4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0212_decmap
  000ab	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000af	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  000b3	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  000b6	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  000bd	74 07		 je	 SHORT $LN2@jisx0212_d

; 662  :         return u;

  000bf	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
  000c2	eb 07		 jmp	 SHORT $LN3@jisx0212_d

; 663  :     else

  000c4	eb 05		 jmp	 SHORT $LN1@jisx0212_d
$LN2@jisx0212_d:

; 664  :         return MAP_UNMAPPABLE;

  000c6	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN1@jisx0212_d:
$LN3@jisx0212_d:

; 665  : }

  000cb	48 83 c4 18	 add	 rsp, 24
  000cf	c3		 ret	 0
jisx0212_decoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0212_encoder DD imagerel jisx0212_encoder
	DD	imagerel jisx0212_encoder+326
	DD	imagerel $unwind$jisx0212_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0212_encoder DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0212_encoder
_TEXT	SEGMENT
coded$ = 32
data$ = 64
length$ = 72
jisx0212_encoder PROC					; COMDAT

; 669  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 670  :     DBCHAR coded;
; 671  :     assert(*length == 1);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR length$[rsp]
  00013	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00017	74 1c		 je	 SHORT $LN6@jisx0212_e
  00019	41 b8 9f 02 00
	00		 mov	 r8d, 671		; 0000029fH
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MBLKAJOP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAc?$AAj?$AAk?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA?2?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA_?$AAi?$AAs?$AAo@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@KFPJGOKE@?$AA?$CK?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00033	33 c0		 xor	 eax, eax
$LN6@jisx0212_e:

; 672  :     if (*data < 0x10000) {

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0003a	81 38 00 00 01
	00		 cmp	 DWORD PTR [rax], 65536	; 00010000H
  00040	0f 83 f6 00 00
	00		 jae	 $LN3@jisx0212_e

; 673  :         TRYMAP_ENC(jisxcommon, coded, *data) {

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0004b	8b 00		 mov	 eax, DWORD PTR [rax]
  0004d	c1 e8 08	 shr	 eax, 8
  00050	8b c0		 mov	 eax, eax
  00052	48 6b c0 10	 imul	 rax, 16
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisxcommon_encmap
  0005d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00062	0f 84 d4 00 00
	00		 je	 $LN2@jisx0212_e
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0006d	8b 00		 mov	 eax, DWORD PTR [rax]
  0006f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00079	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0007b	c1 e9 08	 shr	 ecx, 8
  0007e	8b c9		 mov	 ecx, ecx
  00080	48 6b c9 10	 imul	 rcx, 16
  00084	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisxcommon_encmap
  0008b	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00090	3b c1		 cmp	 eax, ecx
  00092	0f 82 a4 00 00
	00		 jb	 $LN2@jisx0212_e
  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0009d	8b 00		 mov	 eax, DWORD PTR [rax]
  0009f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000a9	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000ab	c1 e9 08	 shr	 ecx, 8
  000ae	8b c9		 mov	 ecx, ecx
  000b0	48 6b c9 10	 imul	 rcx, 16
  000b4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisxcommon_encmap
  000bb	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  000c0	3b c1		 cmp	 eax, ecx
  000c2	77 78		 ja	 SHORT $LN2@jisx0212_e
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  000c9	8b 00		 mov	 eax, DWORD PTR [rax]
  000cb	c1 e8 08	 shr	 eax, 8
  000ce	8b c0		 mov	 eax, eax
  000d0	48 6b c0 10	 imul	 rax, 16
  000d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000d9	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000db	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000e1	48 8b 54 24 40	 mov	 rdx, QWORD PTR data$[rsp]
  000e6	8b 12		 mov	 edx, DWORD PTR [rdx]
  000e8	c1 ea 08	 shr	 edx, 8
  000eb	8b d2		 mov	 edx, edx
  000ed	48 6b d2 10	 imul	 rdx, 16
  000f1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisxcommon_encmap
  000f8	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  000fe	2b ca		 sub	 ecx, edx
  00100	8b c9		 mov	 ecx, ecx
  00102	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisxcommon_encmap
  00109	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0010d	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00111	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax
  00116	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0011b	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00120	74 1a		 je	 SHORT $LN2@jisx0212_e

; 674  :             if (coded & 0x8000)

  00122	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00127	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  0012c	85 c0		 test	 eax, eax
  0012e	74 0c		 je	 SHORT $LN1@jisx0212_e

; 675  :                 return coded & 0x7fff;

  00130	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00135	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  0013a	eb 05		 jmp	 SHORT $LN4@jisx0212_e
$LN1@jisx0212_e:
$LN2@jisx0212_e:
$LN3@jisx0212_e:

; 676  :         }
; 677  :     }
; 678  :     return MAP_UNMAPPABLE;

  0013c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN4@jisx0212_e:

; 679  : }

  00141	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00145	c3		 ret	 0
jisx0212_encoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@EPEJDGK@__map_jisx0213_pair?$AA@	; `string'
PUBLIC	??_C@_0BF@IDHBPDFG@__map_jisx0213_2_emp?$AA@	; `string'
PUBLIC	??_C@_0BF@FOFIBPI@__map_jisx0213_1_emp?$AA@	; `string'
PUBLIC	??_C@_0BD@GEGDJIEH@__map_jisx0213_emp?$AA@	; `string'
PUBLIC	??_C@_0BF@BOKGMLOP@__map_jisx0213_2_bmp?$AA@	; `string'
PUBLIC	??_C@_0BF@JIDCLJEB@__map_jisx0213_1_bmp?$AA@	; `string'
PUBLIC	??_C@_0BD@PJLEKAPO@__map_jisx0213_bmp?$AA@	; `string'
_BSS	SEGMENT
	ALIGN	8

jisx0213_pair_encmap DQ 01H DUP (?)
jisx0213_pair_decmap DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_init DD imagerel jisx0213_init
	DD	imagerel jisx0213_init+301
	DD	imagerel $unwind$jisx0213_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BE@EPEJDGK@__map_jisx0213_pair?$AA@
CONST	SEGMENT
??_C@_0BE@EPEJDGK@__map_jisx0213_pair?$AA@ DB '__map_jisx0213_pair', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IDHBPDFG@__map_jisx0213_2_emp?$AA@
CONST	SEGMENT
??_C@_0BF@IDHBPDFG@__map_jisx0213_2_emp?$AA@ DB '__map_jisx0213_2_emp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FOFIBPI@__map_jisx0213_1_emp?$AA@
CONST	SEGMENT
??_C@_0BF@FOFIBPI@__map_jisx0213_1_emp?$AA@ DB '__map_jisx0213_1_emp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GEGDJIEH@__map_jisx0213_emp?$AA@
CONST	SEGMENT
??_C@_0BD@GEGDJIEH@__map_jisx0213_emp?$AA@ DB '__map_jisx0213_emp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BOKGMLOP@__map_jisx0213_2_bmp?$AA@
CONST	SEGMENT
??_C@_0BF@BOKGMLOP@__map_jisx0213_2_bmp?$AA@ DB '__map_jisx0213_2_bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JIDCLJEB@__map_jisx0213_1_bmp?$AA@
CONST	SEGMENT
??_C@_0BF@JIDCLJEB@__map_jisx0213_1_bmp?$AA@ DB '__map_jisx0213_1_bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJLEKAPO@__map_jisx0213_bmp?$AA@
CONST	SEGMENT
??_C@_0BD@PJLEKAPO@__map_jisx0213_bmp?$AA@ DB '__map_jisx0213_bmp', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT jisx0213_init
_TEXT	SEGMENT
jisx0213_init PROC					; COMDAT

; 683  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 684  :     static int initialized = 0;
; 685  : 
; 686  :     if (!initialized && (
; 687  :                     jisx0208_init() ||
; 688  :                     IMPORT_MAP(jp, jisx0213_bmp,
; 689  :                                &jisx0213_bmp_encmap, NULL) ||
; 690  :                     IMPORT_MAP(jp, jisx0213_1_bmp,
; 691  :                                NULL, &jisx0213_1_bmp_decmap) ||
; 692  :                     IMPORT_MAP(jp, jisx0213_2_bmp,
; 693  :                                NULL, &jisx0213_2_bmp_decmap) ||
; 694  :                     IMPORT_MAP(jp, jisx0213_emp,
; 695  :                                &jisx0213_emp_encmap, NULL) ||
; 696  :                     IMPORT_MAP(jp, jisx0213_1_emp,
; 697  :                                NULL, &jisx0213_1_emp_decmap) ||
; 698  :                     IMPORT_MAP(jp, jisx0213_2_emp,
; 699  :                                NULL, &jisx0213_2_emp_decmap) ||
; 700  :                     IMPORT_MAP(jp, jisx0213_pair, &jisx0213_pair_encmap,
; 701  :                                &jisx0213_pair_decmap)))

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??jisx0213_init@@9@9, 0
  0000b	0f 85 0b 01 00
	00		 jne	 $LN2@jisx0213_i
  00011	e8 00 00 00 00	 call	 jisx0208_init
  00016	85 c0		 test	 eax, eax
  00018	0f 85 f7 00 00
	00		 jne	 $LN1@jisx0213_i
  0001e	45 33 c9	 xor	 r9d, r9d
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:jisx0213_bmp_encmap
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@PJLEKAPO@__map_jisx0213_bmp?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00036	e8 00 00 00 00	 call	 importmap
  0003b	85 c0		 test	 eax, eax
  0003d	0f 85 d2 00 00
	00		 jne	 $LN1@jisx0213_i
  00043	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0213_1_bmp_decmap
  0004a	45 33 c0	 xor	 r8d, r8d
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@JIDCLJEB@__map_jisx0213_1_bmp?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  0005b	e8 00 00 00 00	 call	 importmap
  00060	85 c0		 test	 eax, eax
  00062	0f 85 ad 00 00
	00		 jne	 $LN1@jisx0213_i
  00068	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0213_2_bmp_decmap
  0006f	45 33 c0	 xor	 r8d, r8d
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@BOKGMLOP@__map_jisx0213_2_bmp?$AA@
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00080	e8 00 00 00 00	 call	 importmap
  00085	85 c0		 test	 eax, eax
  00087	0f 85 88 00 00
	00		 jne	 $LN1@jisx0213_i
  0008d	45 33 c9	 xor	 r9d, r9d
  00090	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:jisx0213_emp_encmap
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@GEGDJIEH@__map_jisx0213_emp?$AA@
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  000a5	e8 00 00 00 00	 call	 importmap
  000aa	85 c0		 test	 eax, eax
  000ac	75 67		 jne	 SHORT $LN1@jisx0213_i
  000ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0213_1_emp_decmap
  000b5	45 33 c0	 xor	 r8d, r8d
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@FOFIBPI@__map_jisx0213_1_emp?$AA@
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  000c6	e8 00 00 00 00	 call	 importmap
  000cb	85 c0		 test	 eax, eax
  000cd	75 46		 jne	 SHORT $LN1@jisx0213_i
  000cf	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0213_2_emp_decmap
  000d6	45 33 c0	 xor	 r8d, r8d
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@IDHBPDFG@__map_jisx0213_2_emp?$AA@
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  000e7	e8 00 00 00 00	 call	 importmap
  000ec	85 c0		 test	 eax, eax
  000ee	75 25		 jne	 SHORT $LN1@jisx0213_i
  000f0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0213_pair_decmap
  000f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:jisx0213_pair_encmap
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EPEJDGK@__map_jisx0213_pair?$AA@
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  0010c	e8 00 00 00 00	 call	 importmap
  00111	85 c0		 test	 eax, eax
  00113	74 07		 je	 SHORT $LN2@jisx0213_i
$LN1@jisx0213_i:

; 702  :         return -1;

  00115	b8 ff ff ff ff	 mov	 eax, -1
  0011a	eb 0c		 jmp	 SHORT $LN3@jisx0213_i
$LN2@jisx0213_i:

; 703  :     initialized = 1;

  0011c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??jisx0213_init@@9@9, 1

; 704  :     return 0;

  00126	33 c0		 xor	 eax, eax
$LN3@jisx0213_i:

; 705  : }

  00128	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0012c	c3		 ret	 0
jisx0213_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2000_1_decoder DD imagerel jisx0213_2000_1_decoder
	DD	imagerel jisx0213_2000_1_decoder+1140
	DD	imagerel $unwind$jisx0213_2000_1_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2000_1_decoder DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_2000_1_decoder
_TEXT	SEGMENT
u$ = 0
data$ = 32
jisx0213_2000_1_decoder PROC				; COMDAT

; 710  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 711  :     ucs4_t u;
; 712  :     EMULATE_JISX0213_2000_DECODE_PLANE1(u, data[0], data[1])

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 31 01 00
	00		 je	 $LN22@jisx0213_2
  00014	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00019	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001c	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0001f	75 12		 jne	 SHORT $LN20@jisx0213_2
  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00026	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0002a	83 f8 21	 cmp	 eax, 33			; 00000021H
  0002d	0f 84 03 01 00
	00		 je	 $LN21@jisx0213_2
$LN20@jisx0213_2:
  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00038	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003b	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0003e	75 12		 jne	 SHORT $LN19@jisx0213_2
  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00045	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00049	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  0004c	0f 84 e4 00 00
	00		 je	 $LN21@jisx0213_2
$LN19@jisx0213_2:
  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00057	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005a	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  0005d	75 12		 jne	 SHORT $LN18@jisx0213_2
  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00064	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00068	83 f8 54	 cmp	 eax, 84			; 00000054H
  0006b	0f 84 c5 00 00
	00		 je	 $LN21@jisx0213_2
$LN18@jisx0213_2:
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00076	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00079	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  0007c	75 12		 jne	 SHORT $LN17@jisx0213_2
  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00083	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00087	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  0008a	0f 84 a6 00 00
	00		 je	 $LN21@jisx0213_2
$LN17@jisx0213_2:
  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00095	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00098	83 f8 74	 cmp	 eax, 116		; 00000074H
  0009b	75 12		 jne	 SHORT $LN16@jisx0213_2
  0009d	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000a2	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000a6	83 f8 27	 cmp	 eax, 39			; 00000027H
  000a9	0f 84 87 00 00
	00		 je	 $LN21@jisx0213_2
$LN16@jisx0213_2:
  000af	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000b4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b7	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  000ba	75 0e		 jne	 SHORT $LN15@jisx0213_2
  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000c1	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000c5	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  000c8	74 6c		 je	 SHORT $LN21@jisx0213_2
$LN15@jisx0213_2:
  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000cf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d2	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  000d5	75 0e		 jne	 SHORT $LN14@jisx0213_2
  000d7	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000dc	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000e0	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  000e3	74 51		 je	 SHORT $LN21@jisx0213_2
$LN14@jisx0213_2:
  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ed	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  000f0	75 0e		 jne	 SHORT $LN13@jisx0213_2
  000f2	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000f7	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000fb	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  000fe	74 36		 je	 SHORT $LN21@jisx0213_2
$LN13@jisx0213_2:
  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00105	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00108	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  0010b	75 0e		 jne	 SHORT $LN12@jisx0213_2
  0010d	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00112	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00116	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  00119	74 1b		 je	 SHORT $LN21@jisx0213_2
$LN12@jisx0213_2:
  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00120	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00123	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  00126	75 1d		 jne	 SHORT $LN22@jisx0213_2
  00128	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0012d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00131	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  00134	75 0f		 jne	 SHORT $LN22@jisx0213_2
$LN21@jisx0213_2:
  00136	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0013b	e9 2f 03 00 00	 jmp	 $LN23@jisx0213_2
  00140	e9 27 03 00 00	 jmp	 $LN11@jisx0213_2
$LN22@jisx0213_2:

; 713  :     else if (data[0] == 0x21 && data[1] == 0x40) /* F/W REVERSE SOLIDUS */

  00145	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0014a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0014d	83 f8 21	 cmp	 eax, 33			; 00000021H
  00150	75 1d		 jne	 SHORT $LN10@jisx0213_2
  00152	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00157	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0015b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0015e	75 0f		 jne	 SHORT $LN10@jisx0213_2

; 714  :         return 0xff3c;

  00160	b8 3c ff 00 00	 mov	 eax, 65340		; 0000ff3cH
  00165	e9 05 03 00 00	 jmp	 $LN23@jisx0213_2
  0016a	e9 fd 02 00 00	 jmp	 $LN9@jisx0213_2
$LN10@jisx0213_2:

; 715  :     else TRYMAP_DEC(jisx0208, u, data[0], data[1]);

  0016f	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00174	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00177	48 6b c0 10	 imul	 rax, 16
  0017b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0208_decmap
  00182	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00187	0f 84 9d 00 00
	00		 je	 $LN8@jisx0213_2
  0018d	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00192	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00196	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0019b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0019e	48 6b c9 10	 imul	 rcx, 16
  001a2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0208_decmap
  001a9	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  001ae	3b c1		 cmp	 eax, ecx
  001b0	7c 78		 jl	 SHORT $LN8@jisx0213_2
  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  001b7	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001bb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  001c0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001c3	48 6b c9 10	 imul	 rcx, 16
  001c7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0208_decmap
  001ce	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  001d3	3b c1		 cmp	 eax, ecx
  001d5	7f 53		 jg	 SHORT $LN8@jisx0213_2
  001d7	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  001dc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001df	48 6b c0 10	 imul	 rax, 16
  001e3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  001e8	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  001ec	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  001f1	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  001f4	48 6b d2 10	 imul	 rdx, 16
  001f8	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0208_decmap
  001ff	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  00205	2b ca		 sub	 ecx, edx
  00207	48 63 c9	 movsxd	 rcx, ecx
  0020a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0208_decmap
  00211	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00215	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00219	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  0021c	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  00223	74 05		 je	 SHORT $LN8@jisx0213_2
  00225	e9 42 02 00 00	 jmp	 $LN7@jisx0213_2
$LN8@jisx0213_2:

; 716  :     else TRYMAP_DEC(jisx0213_1_bmp, u, data[0], data[1]);

  0022a	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0022f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00232	48 6b c0 10	 imul	 rax, 16
  00236	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_1_bmp_decmap
  0023d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00242	0f 84 9d 00 00
	00		 je	 $LN6@jisx0213_2
  00248	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0024d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00251	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00256	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00259	48 6b c9 10	 imul	 rcx, 16
  0025d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_bmp_decmap
  00264	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00269	3b c1		 cmp	 eax, ecx
  0026b	7c 78		 jl	 SHORT $LN6@jisx0213_2
  0026d	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00272	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00276	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0027b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0027e	48 6b c9 10	 imul	 rcx, 16
  00282	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_bmp_decmap
  00289	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  0028e	3b c1		 cmp	 eax, ecx
  00290	7f 53		 jg	 SHORT $LN6@jisx0213_2
  00292	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00297	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0029a	48 6b c0 10	 imul	 rax, 16
  0029e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  002a3	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  002a7	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  002ac	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  002af	48 6b d2 10	 imul	 rdx, 16
  002b3	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_1_bmp_decmap
  002ba	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  002c0	2b ca		 sub	 ecx, edx
  002c2	48 63 c9	 movsxd	 rcx, ecx
  002c5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_bmp_decmap
  002cc	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  002d0	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  002d4	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  002d7	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  002de	74 05		 je	 SHORT $LN6@jisx0213_2
  002e0	e9 87 01 00 00	 jmp	 $LN5@jisx0213_2
$LN6@jisx0213_2:

; 717  :     else TRYMAP_DEC(jisx0213_1_emp, u, data[0], data[1])

  002e5	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  002ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002ed	48 6b c0 10	 imul	 rax, 16
  002f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_1_emp_decmap
  002f8	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  002fd	0f 84 ab 00 00
	00		 je	 $LN4@jisx0213_2
  00303	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00308	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0030c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00311	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00314	48 6b c9 10	 imul	 rcx, 16
  00318	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_emp_decmap
  0031f	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00324	3b c1		 cmp	 eax, ecx
  00326	0f 8c 82 00 00
	00		 jl	 $LN4@jisx0213_2
  0032c	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00331	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00335	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0033a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0033d	48 6b c9 10	 imul	 rcx, 16
  00341	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_emp_decmap
  00348	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  0034d	3b c1		 cmp	 eax, ecx
  0034f	7f 5d		 jg	 SHORT $LN4@jisx0213_2
  00351	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00356	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00359	48 6b c0 10	 imul	 rax, 16
  0035d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00362	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00366	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0036b	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  0036e	48 6b d2 10	 imul	 rdx, 16
  00372	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_1_emp_decmap
  00379	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  0037f	2b ca		 sub	 ecx, edx
  00381	48 63 c9	 movsxd	 rcx, ecx
  00384	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_emp_decmap
  0038b	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0038f	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00393	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  00396	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  0039d	74 0f		 je	 SHORT $LN4@jisx0213_2

; 718  :         u |= 0x20000;

  0039f	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
  003a2	0f ba e8 11	 bts	 eax, 17
  003a6	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  003a9	e9 be 00 00 00	 jmp	 $LN3@jisx0213_2
$LN4@jisx0213_2:

; 719  :     else TRYMAP_DEC(jisx0213_pair, u, data[0], data[1]);

  003ae	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  003b3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003b6	48 6b c0 10	 imul	 rax, 16
  003ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_pair_decmap
  003c1	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  003c6	0f 84 99 00 00
	00		 je	 $LN2@jisx0213_2
  003cc	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  003d1	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003d5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  003da	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  003dd	48 6b c9 10	 imul	 rcx, 16
  003e1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_pair_decmap
  003e8	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  003ed	3b c1		 cmp	 eax, ecx
  003ef	7c 74		 jl	 SHORT $LN2@jisx0213_2
  003f1	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  003f6	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003fa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  003ff	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00402	48 6b c9 10	 imul	 rcx, 16
  00406	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_pair_decmap
  0040d	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  00412	3b c1		 cmp	 eax, ecx
  00414	7f 4f		 jg	 SHORT $LN2@jisx0213_2
  00416	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0041b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0041e	48 6b c0 10	 imul	 rax, 16
  00422	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00427	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0042b	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  00430	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00433	48 6b d2 10	 imul	 rdx, 16
  00437	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_pair_decmap
  0043e	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  00444	2b ca		 sub	 ecx, edx
  00446	48 63 c9	 movsxd	 rcx, ecx
  00449	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_pair_decmap
  00450	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00454	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00457	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  0045a	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  00461	74 02		 je	 SHORT $LN2@jisx0213_2

; 720  :     else

  00463	eb 07		 jmp	 SHORT $LN1@jisx0213_2
$LN2@jisx0213_2:

; 721  :         return MAP_UNMAPPABLE;

  00465	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0046a	eb 03		 jmp	 SHORT $LN23@jisx0213_2
$LN1@jisx0213_2:
$LN3@jisx0213_2:
$LN5@jisx0213_2:
$LN7@jisx0213_2:
$LN9@jisx0213_2:
$LN11@jisx0213_2:

; 722  :     return u;

  0046c	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
$LN23@jisx0213_2:

; 723  : }

  0046f	48 83 c4 18	 add	 rsp, 24
  00473	c3		 ret	 0
jisx0213_2000_1_decoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2000_2_decoder DD imagerel jisx0213_2000_2_decoder
	DD	imagerel jisx0213_2000_2_decoder+446
	DD	imagerel $unwind$jisx0213_2000_2_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2000_2_decoder DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_2000_2_decoder
_TEXT	SEGMENT
u$ = 0
data$ = 32
jisx0213_2000_2_decoder PROC				; COMDAT

; 727  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 728  :     ucs4_t u;
; 729  :     EMULATE_JISX0213_2000_DECODE_PLANE2(u, data[0], data[1])

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	74 22		 je	 SHORT $LN5@jisx0213_2@2
  00010	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00015	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00018	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  0001b	75 15		 jne	 SHORT $LN5@jisx0213_2@2
  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00022	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00026	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00029	75 07		 jne	 SHORT $LN5@jisx0213_2@2
  0002b	c7 04 24 1d 9b
	00 00		 mov	 DWORD PTR u$[rsp], 39709 ; 00009b1dH
$LN5@jisx0213_2@2:

; 730  :     TRYMAP_DEC(jisx0213_2_bmp, u, data[0], data[1]);

  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00037	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003a	48 6b c0 10	 imul	 rax, 16
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_2_bmp_decmap
  00045	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0004a	0f 84 9d 00 00
	00		 je	 $LN4@jisx0213_2@2
  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00055	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00059	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	48 6b c9 10	 imul	 rcx, 16
  00065	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_bmp_decmap
  0006c	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00071	3b c1		 cmp	 eax, ecx
  00073	7c 78		 jl	 SHORT $LN4@jisx0213_2@2
  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0007a	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0007e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00083	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00086	48 6b c9 10	 imul	 rcx, 16
  0008a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_bmp_decmap
  00091	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  00096	3b c1		 cmp	 eax, ecx
  00098	7f 53		 jg	 SHORT $LN4@jisx0213_2@2
  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0009f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a2	48 6b c0 10	 imul	 rax, 16
  000a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  000ab	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  000af	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  000b4	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  000b7	48 6b d2 10	 imul	 rdx, 16
  000bb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_2_bmp_decmap
  000c2	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  000c8	2b ca		 sub	 ecx, edx
  000ca	48 63 c9	 movsxd	 rcx, ecx
  000cd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_bmp_decmap
  000d4	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000d8	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  000dc	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  000df	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  000e6	74 05		 je	 SHORT $LN4@jisx0213_2@2
  000e8	e9 c9 00 00 00	 jmp	 $LN3@jisx0213_2@2
$LN4@jisx0213_2@2:

; 731  :     else TRYMAP_DEC(jisx0213_2_emp, u, data[0], data[1])

  000ed	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000f2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f5	48 6b c0 10	 imul	 rax, 16
  000f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_2_emp_decmap
  00100	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00105	0f 84 a4 00 00
	00		 je	 $LN2@jisx0213_2@2
  0010b	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00110	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00114	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00119	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0011c	48 6b c9 10	 imul	 rcx, 16
  00120	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_emp_decmap
  00127	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  0012c	3b c1		 cmp	 eax, ecx
  0012e	7c 7f		 jl	 SHORT $LN2@jisx0213_2@2
  00130	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00135	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00139	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0013e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00141	48 6b c9 10	 imul	 rcx, 16
  00145	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_emp_decmap
  0014c	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  00151	3b c1		 cmp	 eax, ecx
  00153	7f 5a		 jg	 SHORT $LN2@jisx0213_2@2
  00155	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0015a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0015d	48 6b c0 10	 imul	 rax, 16
  00161	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00166	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0016a	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0016f	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00172	48 6b d2 10	 imul	 rdx, 16
  00176	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_2_emp_decmap
  0017d	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  00183	2b ca		 sub	 ecx, edx
  00185	48 63 c9	 movsxd	 rcx, ecx
  00188	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_emp_decmap
  0018f	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00193	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00197	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  0019a	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  001a1	74 0c		 je	 SHORT $LN2@jisx0213_2@2

; 732  :         u |= 0x20000;

  001a3	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
  001a6	0f ba e8 11	 bts	 eax, 17
  001aa	89 04 24	 mov	 DWORD PTR u$[rsp], eax

; 733  :     else

  001ad	eb 07		 jmp	 SHORT $LN1@jisx0213_2@2
$LN2@jisx0213_2@2:

; 734  :         return MAP_UNMAPPABLE;

  001af	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001b4	eb 03		 jmp	 SHORT $LN6@jisx0213_2@2
$LN1@jisx0213_2@2:
$LN3@jisx0213_2@2:

; 735  :     return u;

  001b6	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
$LN6@jisx0213_2@2:

; 736  : }

  001b9	48 83 c4 18	 add	 rsp, 24
  001bd	c3		 ret	 0
jisx0213_2000_2_decoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2004_1_decoder DD imagerel jisx0213_2004_1_decoder
	DD	imagerel jisx0213_2004_1_decoder+824
	DD	imagerel $unwind$jisx0213_2004_1_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2004_1_decoder DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_2004_1_decoder
_TEXT	SEGMENT
u$ = 0
data$ = 32
jisx0213_2004_1_decoder PROC				; COMDAT

; 741  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 742  :     ucs4_t u;
; 743  :     if (data[0] == 0x21 && data[1] == 0x40) /* F/W REVERSE SOLIDUS */

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0000e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00011	83 f8 21	 cmp	 eax, 33			; 00000021H
  00014	75 1d		 jne	 SHORT $LN10@jisx0213_2@3
  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0001b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001f	83 f8 40	 cmp	 eax, 64			; 00000040H
  00022	75 0f		 jne	 SHORT $LN10@jisx0213_2@3

; 744  :         return 0xff3c;

  00024	b8 3c ff 00 00	 mov	 eax, 65340		; 0000ff3cH
  00029	e9 05 03 00 00	 jmp	 $LN11@jisx0213_2@3
  0002e	e9 fd 02 00 00	 jmp	 $LN9@jisx0213_2@3
$LN10@jisx0213_2@3:

; 745  :     else TRYMAP_DEC(jisx0208, u, data[0], data[1]);

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00038	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003b	48 6b c0 10	 imul	 rax, 16
  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0208_decmap
  00046	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0004b	0f 84 9d 00 00
	00		 je	 $LN8@jisx0213_2@3
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00056	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0005f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00062	48 6b c9 10	 imul	 rcx, 16
  00066	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0208_decmap
  0006d	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00072	3b c1		 cmp	 eax, ecx
  00074	7c 78		 jl	 SHORT $LN8@jisx0213_2@3
  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0007b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0007f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00084	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00087	48 6b c9 10	 imul	 rcx, 16
  0008b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0208_decmap
  00092	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  00097	3b c1		 cmp	 eax, ecx
  00099	7f 53		 jg	 SHORT $LN8@jisx0213_2@3
  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000a0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a3	48 6b c0 10	 imul	 rax, 16
  000a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  000ac	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  000b0	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  000b5	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  000b8	48 6b d2 10	 imul	 rdx, 16
  000bc	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0208_decmap
  000c3	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  000c9	2b ca		 sub	 ecx, edx
  000cb	48 63 c9	 movsxd	 rcx, ecx
  000ce	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0208_decmap
  000d5	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000d9	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  000dd	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  000e0	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  000e7	74 05		 je	 SHORT $LN8@jisx0213_2@3
  000e9	e9 42 02 00 00	 jmp	 $LN7@jisx0213_2@3
$LN8@jisx0213_2@3:

; 746  :     else TRYMAP_DEC(jisx0213_1_bmp, u, data[0], data[1]);

  000ee	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000f3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f6	48 6b c0 10	 imul	 rax, 16
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_1_bmp_decmap
  00101	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00106	0f 84 9d 00 00
	00		 je	 $LN6@jisx0213_2@3
  0010c	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00111	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00115	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0011a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0011d	48 6b c9 10	 imul	 rcx, 16
  00121	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_bmp_decmap
  00128	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  0012d	3b c1		 cmp	 eax, ecx
  0012f	7c 78		 jl	 SHORT $LN6@jisx0213_2@3
  00131	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00136	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0013a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0013f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00142	48 6b c9 10	 imul	 rcx, 16
  00146	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_bmp_decmap
  0014d	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  00152	3b c1		 cmp	 eax, ecx
  00154	7f 53		 jg	 SHORT $LN6@jisx0213_2@3
  00156	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0015b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0015e	48 6b c0 10	 imul	 rax, 16
  00162	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00167	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0016b	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  00170	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00173	48 6b d2 10	 imul	 rdx, 16
  00177	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_1_bmp_decmap
  0017e	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  00184	2b ca		 sub	 ecx, edx
  00186	48 63 c9	 movsxd	 rcx, ecx
  00189	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_bmp_decmap
  00190	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00194	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00198	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  0019b	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  001a2	74 05		 je	 SHORT $LN6@jisx0213_2@3
  001a4	e9 87 01 00 00	 jmp	 $LN5@jisx0213_2@3
$LN6@jisx0213_2@3:

; 747  :     else TRYMAP_DEC(jisx0213_1_emp, u, data[0], data[1])

  001a9	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  001ae	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b1	48 6b c0 10	 imul	 rax, 16
  001b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_1_emp_decmap
  001bc	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  001c1	0f 84 ab 00 00
	00		 je	 $LN4@jisx0213_2@3
  001c7	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  001cc	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001d0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  001d5	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001d8	48 6b c9 10	 imul	 rcx, 16
  001dc	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_emp_decmap
  001e3	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  001e8	3b c1		 cmp	 eax, ecx
  001ea	0f 8c 82 00 00
	00		 jl	 $LN4@jisx0213_2@3
  001f0	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  001f5	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001f9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  001fe	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00201	48 6b c9 10	 imul	 rcx, 16
  00205	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_emp_decmap
  0020c	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  00211	3b c1		 cmp	 eax, ecx
  00213	7f 5d		 jg	 SHORT $LN4@jisx0213_2@3
  00215	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0021a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0021d	48 6b c0 10	 imul	 rax, 16
  00221	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00226	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0022a	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0022f	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00232	48 6b d2 10	 imul	 rdx, 16
  00236	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_1_emp_decmap
  0023d	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  00243	2b ca		 sub	 ecx, edx
  00245	48 63 c9	 movsxd	 rcx, ecx
  00248	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_1_emp_decmap
  0024f	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00253	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00257	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  0025a	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  00261	74 0f		 je	 SHORT $LN4@jisx0213_2@3

; 748  :         u |= 0x20000;

  00263	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
  00266	0f ba e8 11	 bts	 eax, 17
  0026a	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  0026d	e9 be 00 00 00	 jmp	 $LN3@jisx0213_2@3
$LN4@jisx0213_2@3:

; 749  :     else TRYMAP_DEC(jisx0213_pair, u, data[0], data[1]);

  00272	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00277	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0027a	48 6b c0 10	 imul	 rax, 16
  0027e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_pair_decmap
  00285	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0028a	0f 84 99 00 00
	00		 je	 $LN2@jisx0213_2@3
  00290	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00295	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00299	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0029e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002a1	48 6b c9 10	 imul	 rcx, 16
  002a5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_pair_decmap
  002ac	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  002b1	3b c1		 cmp	 eax, ecx
  002b3	7c 74		 jl	 SHORT $LN2@jisx0213_2@3
  002b5	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  002ba	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  002be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  002c3	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002c6	48 6b c9 10	 imul	 rcx, 16
  002ca	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_pair_decmap
  002d1	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  002d6	3b c1		 cmp	 eax, ecx
  002d8	7f 4f		 jg	 SHORT $LN2@jisx0213_2@3
  002da	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  002df	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002e2	48 6b c0 10	 imul	 rax, 16
  002e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  002eb	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  002ef	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  002f4	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  002f7	48 6b d2 10	 imul	 rdx, 16
  002fb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_pair_decmap
  00302	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  00308	2b ca		 sub	 ecx, edx
  0030a	48 63 c9	 movsxd	 rcx, ecx
  0030d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_pair_decmap
  00314	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00318	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0031b	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  0031e	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  00325	74 02		 je	 SHORT $LN2@jisx0213_2@3

; 750  :     else

  00327	eb 07		 jmp	 SHORT $LN1@jisx0213_2@3
$LN2@jisx0213_2@3:

; 751  :         return MAP_UNMAPPABLE;

  00329	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0032e	eb 03		 jmp	 SHORT $LN11@jisx0213_2@3
$LN1@jisx0213_2@3:
$LN3@jisx0213_2@3:
$LN5@jisx0213_2@3:
$LN7@jisx0213_2@3:
$LN9@jisx0213_2@3:

; 752  :     return u;

  00330	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
$LN11@jisx0213_2@3:

; 753  : }

  00333	48 83 c4 18	 add	 rsp, 24
  00337	c3		 ret	 0
jisx0213_2004_1_decoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2004_2_decoder DD imagerel jisx0213_2004_2_decoder
	DD	imagerel jisx0213_2004_2_decoder+405
	DD	imagerel $unwind$jisx0213_2004_2_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2004_2_decoder DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_2004_2_decoder
_TEXT	SEGMENT
u$ = 0
data$ = 32
jisx0213_2004_2_decoder PROC				; COMDAT

; 757  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 758  :     ucs4_t u;
; 759  :     TRYMAP_DEC(jisx0213_2_bmp, u, data[0], data[1]);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0000e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00011	48 6b c0 10	 imul	 rax, 16
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_2_bmp_decmap
  0001c	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00021	0f 84 9d 00 00
	00		 je	 $LN4@jisx0213_2@4
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0002c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00035	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00038	48 6b c9 10	 imul	 rcx, 16
  0003c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_bmp_decmap
  00043	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00048	3b c1		 cmp	 eax, ecx
  0004a	7c 78		 jl	 SHORT $LN4@jisx0213_2@4
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00051	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0005a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0005d	48 6b c9 10	 imul	 rcx, 16
  00061	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_bmp_decmap
  00068	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  0006d	3b c1		 cmp	 eax, ecx
  0006f	7f 53		 jg	 SHORT $LN4@jisx0213_2@4
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00076	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00079	48 6b c0 10	 imul	 rax, 16
  0007d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00082	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00086	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0008b	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  0008e	48 6b d2 10	 imul	 rdx, 16
  00092	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_2_bmp_decmap
  00099	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  0009f	2b ca		 sub	 ecx, edx
  000a1	48 63 c9	 movsxd	 rcx, ecx
  000a4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_bmp_decmap
  000ab	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000af	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  000b3	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  000b6	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  000bd	74 05		 je	 SHORT $LN4@jisx0213_2@4
  000bf	e9 c9 00 00 00	 jmp	 $LN3@jisx0213_2@4
$LN4@jisx0213_2@4:

; 760  :     else TRYMAP_DEC(jisx0213_2_emp, u, data[0], data[1])

  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000c9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000cc	48 6b c0 10	 imul	 rax, 16
  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_2_emp_decmap
  000d7	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000dc	0f 84 a4 00 00
	00		 je	 $LN2@jisx0213_2@4
  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  000e7	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000eb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  000f0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000f3	48 6b c9 10	 imul	 rcx, 16
  000f7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_emp_decmap
  000fe	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00103	3b c1		 cmp	 eax, ecx
  00105	7c 7f		 jl	 SHORT $LN2@jisx0213_2@4
  00107	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0010c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00110	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00115	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00118	48 6b c9 10	 imul	 rcx, 16
  0011c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_emp_decmap
  00123	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  00128	3b c1		 cmp	 eax, ecx
  0012a	7f 5a		 jg	 SHORT $LN2@jisx0213_2@4
  0012c	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00131	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00134	48 6b c0 10	 imul	 rax, 16
  00138	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0013d	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00141	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  00146	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00149	48 6b d2 10	 imul	 rdx, 16
  0014d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_2_emp_decmap
  00154	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  0015a	2b ca		 sub	 ecx, edx
  0015c	48 63 c9	 movsxd	 rcx, ecx
  0015f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_2_emp_decmap
  00166	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0016a	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0016e	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  00171	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  00178	74 0c		 je	 SHORT $LN2@jisx0213_2@4

; 761  :         u |= 0x20000;

  0017a	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
  0017d	0f ba e8 11	 bts	 eax, 17
  00181	89 04 24	 mov	 DWORD PTR u$[rsp], eax

; 762  :     else

  00184	eb 07		 jmp	 SHORT $LN1@jisx0213_2@4
$LN2@jisx0213_2@4:

; 763  :         return MAP_UNMAPPABLE;

  00186	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0018b	eb 03		 jmp	 SHORT $LN5@jisx0213_2@4
$LN1@jisx0213_2@4:
$LN3@jisx0213_2@4:

; 764  :     return u;

  0018d	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
$LN5@jisx0213_2@4:

; 765  : }

  00190	48 83 c4 18	 add	 rsp, 24
  00194	c3		 ret	 0
jisx0213_2004_2_decoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2000_1_encoder DD imagerel jisx0213_2000_1_encoder
	DD	imagerel jisx0213_2000_1_encoder+106
	DD	imagerel $unwind$jisx0213_2000_1_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2000_1_encoder DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_2000_1_encoder
_TEXT	SEGMENT
coded$ = 32
data$ = 64
length$ = 72
jisx0213_2000_1_encoder PROC				; COMDAT

; 823  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 824  :     DBCHAR coded = jisx0213_encoder(data, length, (void *)2000);

  0000e	41 b8 d0 07 00
	00		 mov	 r8d, 2000		; 000007d0H
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR length$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0001e	e8 00 00 00 00	 call	 jisx0213_encoder
  00023	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax

; 825  :     if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)

  00028	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0002d	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00032	74 0c		 je	 SHORT $LN4@jisx0213_2@5
  00034	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00039	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0003e	75 09		 jne	 SHORT $LN5@jisx0213_2@5
$LN4@jisx0213_2@5:

; 826  :         return coded;

  00040	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00045	eb 1e		 jmp	 SHORT $LN6@jisx0213_2@5
  00047	eb 1c		 jmp	 SHORT $LN3@jisx0213_2@5
$LN5@jisx0213_2@5:

; 827  :     else if (coded & 0x8000)

  00049	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0004e	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00053	85 c0		 test	 eax, eax
  00055	74 09		 je	 SHORT $LN2@jisx0213_2@5

; 828  :         return MAP_UNMAPPABLE;

  00057	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0005c	eb 07		 jmp	 SHORT $LN6@jisx0213_2@5

; 829  :     else

  0005e	eb 05		 jmp	 SHORT $LN1@jisx0213_2@5
$LN2@jisx0213_2@5:

; 830  :         return coded;

  00060	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
$LN1@jisx0213_2@5:
$LN3@jisx0213_2@5:
$LN6@jisx0213_2@5:

; 831  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
jisx0213_2000_1_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_encoder DD imagerel jisx0213_encoder
	DD	imagerel jisx0213_encoder+1348
	DD	imagerel $unwind$jisx0213_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_encoder DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_encoder
_TEXT	SEGMENT
coded$ = 32
tv64 = 40
data$ = 64
length$ = 72
config$ = 80
jisx0213_encoder PROC					; COMDAT

; 769  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 770  :     DBCHAR coded;
; 771  : 
; 772  :     switch (*length) {

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR length$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 28	 mov	 QWORD PTR tv64[rsp], rax
  00020	48 83 7c 24 28
	ff		 cmp	 QWORD PTR tv64[rsp], -1
  00026	0f 84 c5 04 00
	00		 je	 $LN4@jisx0213_e
  0002c	48 83 7c 24 28
	01		 cmp	 QWORD PTR tv64[rsp], 1
  00032	74 11		 je	 SHORT $LN25@jisx0213_e
  00034	48 83 7c 24 28
	02		 cmp	 QWORD PTR tv64[rsp], 2
  0003a	0f 84 34 04 00
	00		 je	 $LN8@jisx0213_e
  00040	e9 f5 04 00 00	 jmp	 $LN1@jisx0213_e
$LN25@jisx0213_e:

; 773  :     case 1: /* first character */
; 774  :         if (*data >= 0x10000) {

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0004a	81 38 00 00 01
	00		 cmp	 DWORD PTR [rax], 65536	; 00010000H
  00050	0f 82 56 01 00
	00		 jb	 $LN24@jisx0213_e

; 775  :             if ((*data) >> 16 == 0x20000 >> 16) {

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0005b	8b 00		 mov	 eax, DWORD PTR [rax]
  0005d	c1 e8 10	 shr	 eax, 16
  00060	83 f8 02	 cmp	 eax, 2
  00063	0f 85 39 01 00
	00		 jne	 $LN23@jisx0213_e

; 776  :                 EMULATE_JISX0213_2000_ENCODE_EMP(coded, *data)

  00069	48 81 7c 24 50
	d0 07 00 00	 cmp	 QWORD PTR config$[rsp], 2000 ; 000007d0H
  00072	75 1c		 jne	 SHORT $LN22@jisx0213_e
  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00079	81 38 9f 0b 02
	00		 cmp	 DWORD PTR [rax], 134047	; 00020b9fH
  0007f	75 0f		 jne	 SHORT $LN22@jisx0213_e
  00081	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00086	e9 b4 04 00 00	 jmp	 $LN28@jisx0213_e

; 777  :                 else TRYMAP_ENC(jisx0213_emp, coded,

  0008b	e9 12 01 00 00	 jmp	 $LN21@jisx0213_e
$LN22@jisx0213_e:

; 778  :                                 (*data) & 0xffff)

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00095	8b 00		 mov	 eax, DWORD PTR [rax]
  00097	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0009c	c1 e8 08	 shr	 eax, 8
  0009f	8b c0		 mov	 eax, eax
  000a1	48 6b c0 10	 imul	 rax, 16
  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_emp_encmap
  000ac	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000b1	0f 84 eb 00 00
	00		 je	 $LN20@jisx0213_e
  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  000bc	8b 00		 mov	 eax, DWORD PTR [rax]
  000be	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000c3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000cd	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000cf	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000d5	c1 e9 08	 shr	 ecx, 8
  000d8	8b c9		 mov	 ecx, ecx
  000da	48 6b c9 10	 imul	 rcx, 16
  000de	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_emp_encmap
  000e5	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  000ea	3b c1		 cmp	 eax, ecx
  000ec	0f 82 b0 00 00
	00		 jb	 $LN20@jisx0213_e
  000f2	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  000f7	8b 00		 mov	 eax, DWORD PTR [rax]
  000f9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000fe	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00103	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00108	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0010a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00110	c1 e9 08	 shr	 ecx, 8
  00113	8b c9		 mov	 ecx, ecx
  00115	48 6b c9 10	 imul	 rcx, 16
  00119	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_emp_encmap
  00120	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  00125	3b c1		 cmp	 eax, ecx
  00127	77 79		 ja	 SHORT $LN20@jisx0213_e
  00129	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0012e	8b 00		 mov	 eax, DWORD PTR [rax]
  00130	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00135	c1 e8 08	 shr	 eax, 8
  00138	8b c0		 mov	 eax, eax
  0013a	48 6b c0 10	 imul	 rax, 16
  0013e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00143	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00145	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0014b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00151	48 8b 54 24 40	 mov	 rdx, QWORD PTR data$[rsp]
  00156	8b 12		 mov	 edx, DWORD PTR [rdx]
  00158	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0015e	c1 ea 08	 shr	 edx, 8
  00161	8b d2		 mov	 edx, edx
  00163	48 6b d2 10	 imul	 rdx, 16
  00167	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_emp_encmap
  0016e	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  00174	2b ca		 sub	 ecx, edx
  00176	8b c9		 mov	 ecx, ecx
  00178	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_emp_encmap
  0017f	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00183	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00187	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax
  0018c	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00191	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00196	74 0a		 je	 SHORT $LN20@jisx0213_e

; 779  :                     return coded;

  00198	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0019d	e9 9d 03 00 00	 jmp	 $LN28@jisx0213_e
$LN20@jisx0213_e:
$LN21@jisx0213_e:
$LN23@jisx0213_e:

; 780  :             }
; 781  :             return MAP_UNMAPPABLE;

  001a2	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001a7	e9 93 03 00 00	 jmp	 $LN28@jisx0213_e
$LN24@jisx0213_e:

; 782  :         }
; 783  : 
; 784  :         EMULATE_JISX0213_2000_ENCODE_BMP(coded, *data)

  001ac	48 81 7c 24 50
	d0 07 00 00	 cmp	 QWORD PTR config$[rsp], 2000 ; 000007d0H
  001b5	0f 85 91 00 00
	00		 jne	 $LN19@jisx0213_e
  001bb	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  001c0	81 38 1c 9b 00
	00		 cmp	 DWORD PTR [rax], 39708	; 00009b1cH
  001c6	74 75		 je	 SHORT $LN18@jisx0213_e
  001c8	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  001cd	81 38 f1 4f 00
	00		 cmp	 DWORD PTR [rax], 20465	; 00004ff1H
  001d3	74 68		 je	 SHORT $LN18@jisx0213_e
  001d5	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  001da	81 38 5d 52 00
	00		 cmp	 DWORD PTR [rax], 21085	; 0000525dH
  001e0	74 5b		 je	 SHORT $LN18@jisx0213_e
  001e2	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  001e7	81 38 1e 54 00
	00		 cmp	 DWORD PTR [rax], 21534	; 0000541eH
  001ed	74 4e		 je	 SHORT $LN18@jisx0213_e
  001ef	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  001f4	81 38 53 56 00
	00		 cmp	 DWORD PTR [rax], 22099	; 00005653H
  001fa	74 41		 je	 SHORT $LN18@jisx0213_e
  001fc	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00201	81 38 f8 59 00
	00		 cmp	 DWORD PTR [rax], 23032	; 000059f8H
  00207	74 34		 je	 SHORT $LN18@jisx0213_e
  00209	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0020e	81 38 5b 5c 00
	00		 cmp	 DWORD PTR [rax], 23643	; 00005c5bH
  00214	74 27		 je	 SHORT $LN18@jisx0213_e
  00216	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0021b	81 38 77 5e 00
	00		 cmp	 DWORD PTR [rax], 24183	; 00005e77H
  00221	74 1a		 je	 SHORT $LN18@jisx0213_e
  00223	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00228	81 38 26 76 00
	00		 cmp	 DWORD PTR [rax], 30246	; 00007626H
  0022e	74 0d		 je	 SHORT $LN18@jisx0213_e
  00230	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00235	81 38 6b 7e 00
	00		 cmp	 DWORD PTR [rax], 32363	; 00007e6bH
  0023b	75 0f		 jne	 SHORT $LN19@jisx0213_e
$LN18@jisx0213_e:
  0023d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00242	e9 f8 02 00 00	 jmp	 $LN28@jisx0213_e
  00247	e9 1e 02 00 00	 jmp	 $LN17@jisx0213_e
$LN19@jisx0213_e:
  0024c	48 81 7c 24 50
	d0 07 00 00	 cmp	 QWORD PTR config$[rsp], 2000 ; 000007d0H
  00255	75 1c		 jne	 SHORT $LN16@jisx0213_e
  00257	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0025c	81 38 1d 9b 00
	00		 cmp	 DWORD PTR [rax], 39709	; 00009b1dH
  00262	75 0f		 jne	 SHORT $LN16@jisx0213_e
  00264	b8 3b fd 00 00	 mov	 eax, 64827		; 0000fd3bH
  00269	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax
  0026e	e9 f7 01 00 00	 jmp	 $LN15@jisx0213_e
$LN16@jisx0213_e:

; 785  :         else TRYMAP_ENC(jisx0213_bmp, coded, *data) {

  00273	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00278	8b 00		 mov	 eax, DWORD PTR [rax]
  0027a	c1 e8 08	 shr	 eax, 8
  0027d	8b c0		 mov	 eax, eax
  0027f	48 6b c0 10	 imul	 rax, 16
  00283	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisx0213_bmp_encmap
  0028a	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0028f	0f 84 d5 00 00
	00		 je	 $LN14@jisx0213_e
  00295	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0029a	8b 00		 mov	 eax, DWORD PTR [rax]
  0029c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  002a6	8b 09		 mov	 ecx, DWORD PTR [rcx]
  002a8	c1 e9 08	 shr	 ecx, 8
  002ab	8b c9		 mov	 ecx, ecx
  002ad	48 6b c9 10	 imul	 rcx, 16
  002b1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_bmp_encmap
  002b8	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  002bd	3b c1		 cmp	 eax, ecx
  002bf	0f 82 a5 00 00
	00		 jb	 $LN14@jisx0213_e
  002c5	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  002ca	8b 00		 mov	 eax, DWORD PTR [rax]
  002cc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  002d6	8b 09		 mov	 ecx, DWORD PTR [rcx]
  002d8	c1 e9 08	 shr	 ecx, 8
  002db	8b c9		 mov	 ecx, ecx
  002dd	48 6b c9 10	 imul	 rcx, 16
  002e1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_bmp_encmap
  002e8	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  002ed	3b c1		 cmp	 eax, ecx
  002ef	77 79		 ja	 SHORT $LN14@jisx0213_e
  002f1	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  002f6	8b 00		 mov	 eax, DWORD PTR [rax]
  002f8	c1 e8 08	 shr	 eax, 8
  002fb	8b c0		 mov	 eax, eax
  002fd	48 6b c0 10	 imul	 rax, 16
  00301	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00306	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00308	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0030e	48 8b 54 24 40	 mov	 rdx, QWORD PTR data$[rsp]
  00313	8b 12		 mov	 edx, DWORD PTR [rdx]
  00315	c1 ea 08	 shr	 edx, 8
  00318	8b d2		 mov	 edx, edx
  0031a	48 6b d2 10	 imul	 rdx, 16
  0031e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_bmp_encmap
  00325	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  0032b	2b ca		 sub	 ecx, edx
  0032d	8b c9		 mov	 ecx, ecx
  0032f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0213_bmp_encmap
  00336	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0033a	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0033e	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax
  00343	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00348	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0034d	74 1b		 je	 SHORT $LN14@jisx0213_e

; 786  :             if (coded == MULTIC)

  0034f	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00354	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  00359	75 0a		 jne	 SHORT $LN13@jisx0213_e

; 787  :                 return MAP_MULTIPLE_AVAIL;

  0035b	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  00360	e9 da 01 00 00	 jmp	 $LN28@jisx0213_e
$LN13@jisx0213_e:

; 788  :         }
; 789  :         else TRYMAP_ENC(jisxcommon, coded, *data) {

  00365	e9 00 01 00 00	 jmp	 $LN12@jisx0213_e
$LN14@jisx0213_e:
  0036a	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0036f	8b 00		 mov	 eax, DWORD PTR [rax]
  00371	c1 e8 08	 shr	 eax, 8
  00374	8b c0		 mov	 eax, eax
  00376	48 6b c0 10	 imul	 rax, 16
  0037a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR jisxcommon_encmap
  00381	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00386	0f 84 d4 00 00
	00		 je	 $LN11@jisx0213_e
  0038c	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00391	8b 00		 mov	 eax, DWORD PTR [rax]
  00393	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00398	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0039d	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0039f	c1 e9 08	 shr	 ecx, 8
  003a2	8b c9		 mov	 ecx, ecx
  003a4	48 6b c9 10	 imul	 rcx, 16
  003a8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisxcommon_encmap
  003af	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  003b4	3b c1		 cmp	 eax, ecx
  003b6	0f 82 a4 00 00
	00		 jb	 $LN11@jisx0213_e
  003bc	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  003c1	8b 00		 mov	 eax, DWORD PTR [rax]
  003c3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  003cd	8b 09		 mov	 ecx, DWORD PTR [rcx]
  003cf	c1 e9 08	 shr	 ecx, 8
  003d2	8b c9		 mov	 ecx, ecx
  003d4	48 6b c9 10	 imul	 rcx, 16
  003d8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisxcommon_encmap
  003df	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  003e4	3b c1		 cmp	 eax, ecx
  003e6	77 78		 ja	 SHORT $LN11@jisx0213_e
  003e8	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  003ed	8b 00		 mov	 eax, DWORD PTR [rax]
  003ef	c1 e8 08	 shr	 eax, 8
  003f2	8b c0		 mov	 eax, eax
  003f4	48 6b c0 10	 imul	 rax, 16
  003f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  003fd	8b 09		 mov	 ecx, DWORD PTR [rcx]
  003ff	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00405	48 8b 54 24 40	 mov	 rdx, QWORD PTR data$[rsp]
  0040a	8b 12		 mov	 edx, DWORD PTR [rdx]
  0040c	c1 ea 08	 shr	 edx, 8
  0040f	8b d2		 mov	 edx, edx
  00411	48 6b d2 10	 imul	 rdx, 16
  00415	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisxcommon_encmap
  0041c	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  00422	2b ca		 sub	 ecx, edx
  00424	8b c9		 mov	 ecx, ecx
  00426	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisxcommon_encmap
  0042d	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00431	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00435	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax
  0043a	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0043f	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00444	74 1a		 je	 SHORT $LN11@jisx0213_e

; 790  :             if (coded & 0x8000)

  00446	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0044b	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00450	85 c0		 test	 eax, eax
  00452	74 0a		 je	 SHORT $LN10@jisx0213_e

; 791  :                 return MAP_UNMAPPABLE;

  00454	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00459	e9 e1 00 00 00	 jmp	 $LN28@jisx0213_e
$LN10@jisx0213_e:

; 792  :         }
; 793  :         else

  0045e	eb 0a		 jmp	 SHORT $LN9@jisx0213_e
$LN11@jisx0213_e:

; 794  :             return MAP_UNMAPPABLE;

  00460	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00465	e9 d5 00 00 00	 jmp	 $LN28@jisx0213_e
$LN9@jisx0213_e:
$LN12@jisx0213_e:
$LN15@jisx0213_e:
$LN17@jisx0213_e:

; 795  :         return coded;

  0046a	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0046f	e9 cb 00 00 00	 jmp	 $LN28@jisx0213_e
$LN8@jisx0213_e:

; 796  :     case 2: /* second character of unicode pair */
; 797  :         coded = find_pairencmap((ucs2_t)data[0], (ucs2_t)data[1],
; 798  :                         jisx0213_pair_encmap, JISX0213_ENCPAIRS);

  00474	41 b9 2e 00 00
	00		 mov	 r9d, 46			; 0000002eH
  0047a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_pair_encmap
  00481	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00486	0f b7 50 04	 movzx	 edx, WORD PTR [rax+4]
  0048a	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0048f	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00492	e8 00 00 00 00	 call	 find_pairencmap
  00497	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax

; 799  :         if (coded == DBCINV) {

  0049c	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  004a1	3d fd ff 00 00	 cmp	 eax, 65533		; 0000fffdH
  004a6	75 42		 jne	 SHORT $LN7@jisx0213_e

; 800  :             *length = 1;

  004a8	48 8b 44 24 48	 mov	 rax, QWORD PTR length$[rsp]
  004ad	48 c7 00 01 00
	00 00		 mov	 QWORD PTR [rax], 1

; 801  :             coded = find_pairencmap((ucs2_t)data[0], 0,
; 802  :                       jisx0213_pair_encmap, JISX0213_ENCPAIRS);

  004b4	41 b9 2e 00 00
	00		 mov	 r9d, 46			; 0000002eH
  004ba	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_pair_encmap
  004c1	33 d2		 xor	 edx, edx
  004c3	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  004c8	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  004cb	e8 00 00 00 00	 call	 find_pairencmap
  004d0	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax

; 803  :             if (coded == DBCINV)

  004d5	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  004da	3d fd ff 00 00	 cmp	 eax, 65533		; 0000fffdH
  004df	75 07		 jne	 SHORT $LN6@jisx0213_e

; 804  :                 return MAP_UNMAPPABLE;

  004e1	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  004e6	eb 57		 jmp	 SHORT $LN28@jisx0213_e
$LN6@jisx0213_e:

; 805  :         }
; 806  :         else

  004e8	eb 07		 jmp	 SHORT $LN5@jisx0213_e
$LN7@jisx0213_e:

; 807  :             return coded;

  004ea	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  004ef	eb 4e		 jmp	 SHORT $LN28@jisx0213_e
$LN5@jisx0213_e:
$LN4@jisx0213_e:

; 808  :     case -1: /* flush unterminated */
; 809  :         *length = 1;

  004f1	48 8b 44 24 48	 mov	 rax, QWORD PTR length$[rsp]
  004f6	48 c7 00 01 00
	00 00		 mov	 QWORD PTR [rax], 1

; 810  :         coded = find_pairencmap((ucs2_t)data[0], 0,
; 811  :                         jisx0213_pair_encmap, JISX0213_ENCPAIRS);

  004fd	41 b9 2e 00 00
	00		 mov	 r9d, 46			; 0000002eH
  00503	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_pair_encmap
  0050a	33 d2		 xor	 edx, edx
  0050c	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00511	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00514	e8 00 00 00 00	 call	 find_pairencmap
  00519	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax

; 812  :         if (coded == DBCINV)

  0051e	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00523	3d fd ff 00 00	 cmp	 eax, 65533		; 0000fffdH
  00528	75 09		 jne	 SHORT $LN3@jisx0213_e

; 813  :             return MAP_UNMAPPABLE;

  0052a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0052f	eb 0e		 jmp	 SHORT $LN28@jisx0213_e

; 814  :         else

  00531	eb 07		 jmp	 SHORT $LN2@jisx0213_e
$LN3@jisx0213_e:

; 815  :             return coded;

  00533	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00538	eb 05		 jmp	 SHORT $LN28@jisx0213_e
$LN2@jisx0213_e:
$LN1@jisx0213_e:

; 816  :     default:
; 817  :         return MAP_UNMAPPABLE;

  0053a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN28@jisx0213_e:

; 818  :     }
; 819  : }

  0053f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00543	c3		 ret	 0
jisx0213_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\cjkcodecs\cjkcodecs.h
pdata	SEGMENT
$pdata$find_pairencmap DD imagerel find_pairencmap
	DD	imagerel find_pairencmap+233
	DD	imagerel $unwind$find_pairencmap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$find_pairencmap DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT find_pairencmap
_TEXT	SEGMENT
value$ = 0
min$ = 4
max$ = 8
pos$ = 12
body$ = 32
modifier$ = 40
haystack$ = 48
haystacksize$ = 56
find_pairencmap PROC					; COMDAT

; 325  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 18	 sub	 rsp, 24

; 326  :     int pos, min, max;
; 327  :     ucs4_t value = body << 16 | modifier;

  00018	0f b7 44 24 20	 movzx	 eax, WORD PTR body$[rsp]
  0001d	c1 e0 10	 shl	 eax, 16
  00020	0f b7 4c 24 28	 movzx	 ecx, WORD PTR modifier$[rsp]
  00025	0b c1		 or	 eax, ecx
  00027	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 328  : 
; 329  :     min = 0;

  0002a	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR min$[rsp], 0

; 330  :     max = haystacksize;

  00032	8b 44 24 38	 mov	 eax, DWORD PTR haystacksize$[rsp]
  00036	89 44 24 08	 mov	 DWORD PTR max$[rsp], eax

; 331  : 
; 332  :     for (pos = haystacksize >> 1; min != max; pos = (min + max) >> 1)

  0003a	8b 44 24 38	 mov	 eax, DWORD PTR haystacksize$[rsp]
  0003e	d1 f8		 sar	 eax, 1
  00040	89 44 24 0c	 mov	 DWORD PTR pos$[rsp], eax
  00044	eb 12		 jmp	 SHORT $LN13@find_paire
$LN12@find_paire:
  00046	8b 44 24 08	 mov	 eax, DWORD PTR max$[rsp]
  0004a	8b 4c 24 04	 mov	 ecx, DWORD PTR min$[rsp]
  0004e	03 c8		 add	 ecx, eax
  00050	8b c1		 mov	 eax, ecx
  00052	d1 f8		 sar	 eax, 1
  00054	89 44 24 0c	 mov	 DWORD PTR pos$[rsp], eax
$LN13@find_paire:
  00058	8b 44 24 08	 mov	 eax, DWORD PTR max$[rsp]
  0005c	39 44 24 04	 cmp	 DWORD PTR min$[rsp], eax
  00060	74 58		 je	 SHORT $LN11@find_paire

; 333  :         if (value < haystack[pos].uniseq) {

  00062	48 63 44 24 0c	 movsxd	 rax, DWORD PTR pos$[rsp]
  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR haystack$[rsp]
  0006c	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  0006f	39 04 24	 cmp	 DWORD PTR value$[rsp], eax
  00072	73 18		 jae	 SHORT $LN10@find_paire

; 334  :             if (max == pos) break;

  00074	8b 44 24 0c	 mov	 eax, DWORD PTR pos$[rsp]
  00078	39 44 24 08	 cmp	 DWORD PTR max$[rsp], eax
  0007c	75 04		 jne	 SHORT $LN9@find_paire
  0007e	eb 3a		 jmp	 SHORT $LN11@find_paire
  00080	eb 08		 jmp	 SHORT $LN8@find_paire
$LN9@find_paire:

; 335  :             else max = pos;

  00082	8b 44 24 0c	 mov	 eax, DWORD PTR pos$[rsp]
  00086	89 44 24 08	 mov	 DWORD PTR max$[rsp], eax
$LN8@find_paire:

; 336  :         }
; 337  :         else if (value > haystack[pos].uniseq) {

  0008a	eb 2c		 jmp	 SHORT $LN7@find_paire
$LN10@find_paire:
  0008c	48 63 44 24 0c	 movsxd	 rax, DWORD PTR pos$[rsp]
  00091	48 8b 4c 24 30	 mov	 rcx, QWORD PTR haystack$[rsp]
  00096	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  00099	39 04 24	 cmp	 DWORD PTR value$[rsp], eax
  0009c	76 18		 jbe	 SHORT $LN6@find_paire

; 338  :             if (min == pos) break;

  0009e	8b 44 24 0c	 mov	 eax, DWORD PTR pos$[rsp]
  000a2	39 44 24 04	 cmp	 DWORD PTR min$[rsp], eax
  000a6	75 04		 jne	 SHORT $LN5@find_paire
  000a8	eb 10		 jmp	 SHORT $LN11@find_paire
  000aa	eb 08		 jmp	 SHORT $LN4@find_paire
$LN5@find_paire:

; 339  :             else min = pos;

  000ac	8b 44 24 0c	 mov	 eax, DWORD PTR pos$[rsp]
  000b0	89 44 24 04	 mov	 DWORD PTR min$[rsp], eax
$LN4@find_paire:

; 340  :         }
; 341  :         else

  000b4	eb 02		 jmp	 SHORT $LN3@find_paire
$LN6@find_paire:

; 342  :             break;

  000b6	eb 02		 jmp	 SHORT $LN11@find_paire
$LN3@find_paire:
$LN7@find_paire:
  000b8	eb 8c		 jmp	 SHORT $LN12@find_paire
$LN11@find_paire:

; 343  : 
; 344  :         if (value == haystack[pos].uniseq)

  000ba	48 63 44 24 0c	 movsxd	 rax, DWORD PTR pos$[rsp]
  000bf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR haystack$[rsp]
  000c4	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  000c7	39 04 24	 cmp	 DWORD PTR value$[rsp], eax
  000ca	75 13		 jne	 SHORT $LN2@find_paire

; 345  :             return haystack[pos].code;

  000cc	48 63 44 24 0c	 movsxd	 rax, DWORD PTR pos$[rsp]
  000d1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR haystack$[rsp]
  000d6	0f b7 44 c1 04	 movzx	 eax, WORD PTR [rcx+rax*8+4]
  000db	eb 07		 jmp	 SHORT $LN14@find_paire

; 346  :         else

  000dd	eb 05		 jmp	 SHORT $LN1@find_paire
$LN2@find_paire:

; 347  :             return DBCINV;

  000df	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH
$LN1@find_paire:
$LN14@find_paire:

; 348  : }

  000e4	48 83 c4 18	 add	 rsp, 24
  000e8	c3		 ret	 0
find_pairencmap ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\cjkcodecs\_codecs_iso2022.c
pdata	SEGMENT
$pdata$jisx0213_2000_1_encoder_paironly DD imagerel jisx0213_2000_1_encoder_paironly
	DD	imagerel jisx0213_2000_1_encoder_paironly+146
	DD	imagerel $unwind$jisx0213_2000_1_encoder_paironly
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2000_1_encoder_paironly DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_2000_1_encoder_paironly
_TEXT	SEGMENT
coded$ = 32
ilength$ = 40
tv68 = 48
data$ = 80
length$ = 88
jisx0213_2000_1_encoder_paironly PROC			; COMDAT

; 835  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 836  :     DBCHAR coded;
; 837  :     Py_ssize_t ilength = *length;

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR length$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 28	 mov	 QWORD PTR ilength$[rsp], rax

; 838  : 
; 839  :     coded = jisx0213_encoder(data, length, (void *)2000);

  0001b	41 b8 d0 07 00
	00		 mov	 r8d, 2000		; 000007d0H
  00021	48 8b 54 24 58	 mov	 rdx, QWORD PTR length$[rsp]
  00026	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  0002b	e8 00 00 00 00	 call	 jisx0213_encoder
  00030	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax

; 840  :     switch (ilength) {

  00035	48 8b 44 24 28	 mov	 rax, QWORD PTR ilength$[rsp]
  0003a	48 89 44 24 30	 mov	 QWORD PTR tv68[rsp], rax
  0003f	48 83 7c 24 30
	01		 cmp	 QWORD PTR tv68[rsp], 1
  00045	74 0a		 je	 SHORT $LN7@jisx0213_2@6
  00047	48 83 7c 24 30
	02		 cmp	 QWORD PTR tv68[rsp], 2
  0004d	74 1e		 je	 SHORT $LN4@jisx0213_2@6
  0004f	eb 37		 jmp	 SHORT $LN1@jisx0213_2@6
$LN7@jisx0213_2@6:

; 841  :     case 1:
; 842  :         if (coded == MAP_MULTIPLE_AVAIL)

  00051	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00056	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0005b	75 09		 jne	 SHORT $LN6@jisx0213_2@6

; 843  :             return MAP_MULTIPLE_AVAIL;

  0005d	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  00062	eb 29		 jmp	 SHORT $LN10@jisx0213_2@6

; 844  :         else

  00064	eb 07		 jmp	 SHORT $LN5@jisx0213_2@6
$LN6@jisx0213_2@6:

; 845  :             return MAP_UNMAPPABLE;

  00066	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0006b	eb 20		 jmp	 SHORT $LN10@jisx0213_2@6
$LN5@jisx0213_2@6:
$LN4@jisx0213_2@6:

; 846  :     case 2:
; 847  :         if (*length != 2)

  0006d	48 8b 44 24 58	 mov	 rax, QWORD PTR length$[rsp]
  00072	48 83 38 02	 cmp	 QWORD PTR [rax], 2
  00076	74 09		 je	 SHORT $LN3@jisx0213_2@6

; 848  :             return MAP_UNMAPPABLE;

  00078	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0007d	eb 0e		 jmp	 SHORT $LN10@jisx0213_2@6

; 849  :         else

  0007f	eb 07		 jmp	 SHORT $LN2@jisx0213_2@6
$LN3@jisx0213_2@6:

; 850  :             return coded;

  00081	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00086	eb 05		 jmp	 SHORT $LN10@jisx0213_2@6
$LN2@jisx0213_2@6:
$LN1@jisx0213_2@6:

; 851  :     default:
; 852  :         return MAP_UNMAPPABLE;

  00088	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN10@jisx0213_2@6:

; 853  :     }
; 854  : }

  0008d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00091	c3		 ret	 0
jisx0213_2000_1_encoder_paironly ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2000_2_encoder DD imagerel jisx0213_2000_2_encoder
	DD	imagerel jisx0213_2000_2_encoder+111
	DD	imagerel $unwind$jisx0213_2000_2_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2000_2_encoder DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_2000_2_encoder
_TEXT	SEGMENT
coded$ = 32
data$ = 64
length$ = 72
jisx0213_2000_2_encoder PROC				; COMDAT

; 858  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 859  :     DBCHAR coded = jisx0213_encoder(data, length, (void *)2000);

  0000e	41 b8 d0 07 00
	00		 mov	 r8d, 2000		; 000007d0H
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR length$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0001e	e8 00 00 00 00	 call	 jisx0213_encoder
  00023	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax

; 860  :     if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)

  00028	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0002d	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00032	74 0c		 je	 SHORT $LN4@jisx0213_2@7
  00034	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00039	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0003e	75 09		 jne	 SHORT $LN5@jisx0213_2@7
$LN4@jisx0213_2@7:

; 861  :         return coded;

  00040	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00045	eb 23		 jmp	 SHORT $LN6@jisx0213_2@7
  00047	eb 21		 jmp	 SHORT $LN3@jisx0213_2@7
$LN5@jisx0213_2@7:

; 862  :     else if (coded & 0x8000)

  00049	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0004e	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00053	85 c0		 test	 eax, eax
  00055	74 0e		 je	 SHORT $LN2@jisx0213_2@7

; 863  :         return coded & 0x7fff;

  00057	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0005c	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00061	eb 07		 jmp	 SHORT $LN6@jisx0213_2@7

; 864  :     else

  00063	eb 05		 jmp	 SHORT $LN1@jisx0213_2@7
$LN2@jisx0213_2@7:

; 865  :         return MAP_UNMAPPABLE;

  00065	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN1@jisx0213_2@7:
$LN3@jisx0213_2@7:
$LN6@jisx0213_2@7:

; 866  : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
jisx0213_2000_2_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2004_1_encoder DD imagerel jisx0213_2004_1_encoder
	DD	imagerel jisx0213_2004_1_encoder+103
	DD	imagerel $unwind$jisx0213_2004_1_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2004_1_encoder DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_2004_1_encoder
_TEXT	SEGMENT
coded$ = 32
data$ = 64
length$ = 72
jisx0213_2004_1_encoder PROC				; COMDAT

; 870  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 871  :     DBCHAR coded = jisx0213_encoder(data, length, NULL);

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 48	 mov	 rdx, QWORD PTR length$[rsp]
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0001b	e8 00 00 00 00	 call	 jisx0213_encoder
  00020	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax

; 872  :     if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)

  00025	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0002a	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0002f	74 0c		 je	 SHORT $LN4@jisx0213_2@8
  00031	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00036	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0003b	75 09		 jne	 SHORT $LN5@jisx0213_2@8
$LN4@jisx0213_2@8:

; 873  :         return coded;

  0003d	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00042	eb 1e		 jmp	 SHORT $LN6@jisx0213_2@8
  00044	eb 1c		 jmp	 SHORT $LN3@jisx0213_2@8
$LN5@jisx0213_2@8:

; 874  :     else if (coded & 0x8000)

  00046	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0004b	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00050	85 c0		 test	 eax, eax
  00052	74 09		 je	 SHORT $LN2@jisx0213_2@8

; 875  :         return MAP_UNMAPPABLE;

  00054	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00059	eb 07		 jmp	 SHORT $LN6@jisx0213_2@8

; 876  :     else

  0005b	eb 05		 jmp	 SHORT $LN1@jisx0213_2@8
$LN2@jisx0213_2@8:

; 877  :         return coded;

  0005d	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
$LN1@jisx0213_2@8:
$LN3@jisx0213_2@8:
$LN6@jisx0213_2@8:

; 878  : }

  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	c3		 ret	 0
jisx0213_2004_1_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2004_1_encoder_paironly DD imagerel jisx0213_2004_1_encoder_paironly
	DD	imagerel jisx0213_2004_1_encoder_paironly+143
	DD	imagerel $unwind$jisx0213_2004_1_encoder_paironly
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2004_1_encoder_paironly DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_2004_1_encoder_paironly
_TEXT	SEGMENT
coded$ = 32
ilength$ = 40
tv68 = 48
data$ = 80
length$ = 88
jisx0213_2004_1_encoder_paironly PROC			; COMDAT

; 882  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 883  :     DBCHAR coded;
; 884  :     Py_ssize_t ilength = *length;

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR length$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 28	 mov	 QWORD PTR ilength$[rsp], rax

; 885  : 
; 886  :     coded = jisx0213_encoder(data, length, NULL);

  0001b	45 33 c0	 xor	 r8d, r8d
  0001e	48 8b 54 24 58	 mov	 rdx, QWORD PTR length$[rsp]
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  00028	e8 00 00 00 00	 call	 jisx0213_encoder
  0002d	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax

; 887  :     switch (ilength) {

  00032	48 8b 44 24 28	 mov	 rax, QWORD PTR ilength$[rsp]
  00037	48 89 44 24 30	 mov	 QWORD PTR tv68[rsp], rax
  0003c	48 83 7c 24 30
	01		 cmp	 QWORD PTR tv68[rsp], 1
  00042	74 0a		 je	 SHORT $LN7@jisx0213_2@9
  00044	48 83 7c 24 30
	02		 cmp	 QWORD PTR tv68[rsp], 2
  0004a	74 1e		 je	 SHORT $LN4@jisx0213_2@9
  0004c	eb 37		 jmp	 SHORT $LN1@jisx0213_2@9
$LN7@jisx0213_2@9:

; 888  :     case 1:
; 889  :         if (coded == MAP_MULTIPLE_AVAIL)

  0004e	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00053	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  00058	75 09		 jne	 SHORT $LN6@jisx0213_2@9

; 890  :             return MAP_MULTIPLE_AVAIL;

  0005a	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  0005f	eb 29		 jmp	 SHORT $LN10@jisx0213_2@9

; 891  :         else

  00061	eb 07		 jmp	 SHORT $LN5@jisx0213_2@9
$LN6@jisx0213_2@9:

; 892  :             return MAP_UNMAPPABLE;

  00063	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00068	eb 20		 jmp	 SHORT $LN10@jisx0213_2@9
$LN5@jisx0213_2@9:
$LN4@jisx0213_2@9:

; 893  :     case 2:
; 894  :         if (*length != 2)

  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR length$[rsp]
  0006f	48 83 38 02	 cmp	 QWORD PTR [rax], 2
  00073	74 09		 je	 SHORT $LN3@jisx0213_2@9

; 895  :             return MAP_UNMAPPABLE;

  00075	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0007a	eb 0e		 jmp	 SHORT $LN10@jisx0213_2@9

; 896  :         else

  0007c	eb 07		 jmp	 SHORT $LN2@jisx0213_2@9
$LN3@jisx0213_2@9:

; 897  :             return coded;

  0007e	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00083	eb 05		 jmp	 SHORT $LN10@jisx0213_2@9
$LN2@jisx0213_2@9:
$LN1@jisx0213_2@9:

; 898  :     default:
; 899  :         return MAP_UNMAPPABLE;

  00085	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN10@jisx0213_2@9:

; 900  :     }
; 901  : }

  0008a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008e	c3		 ret	 0
jisx0213_2004_1_encoder_paironly ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2004_2_encoder DD imagerel jisx0213_2004_2_encoder
	DD	imagerel jisx0213_2004_2_encoder+108
	DD	imagerel $unwind$jisx0213_2004_2_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2004_2_encoder DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0213_2004_2_encoder
_TEXT	SEGMENT
coded$ = 32
data$ = 64
length$ = 72
jisx0213_2004_2_encoder PROC				; COMDAT

; 905  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 906  :     DBCHAR coded = jisx0213_encoder(data, length, NULL);

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 48	 mov	 rdx, QWORD PTR length$[rsp]
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0001b	e8 00 00 00 00	 call	 jisx0213_encoder
  00020	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax

; 907  :     if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)

  00025	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0002a	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0002f	74 0c		 je	 SHORT $LN4@jisx0213_2@10
  00031	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00036	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0003b	75 09		 jne	 SHORT $LN5@jisx0213_2@10
$LN4@jisx0213_2@10:

; 908  :         return coded;

  0003d	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00042	eb 23		 jmp	 SHORT $LN6@jisx0213_2@10
  00044	eb 21		 jmp	 SHORT $LN3@jisx0213_2@10
$LN5@jisx0213_2@10:

; 909  :     else if (coded & 0x8000)

  00046	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0004b	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00050	85 c0		 test	 eax, eax
  00052	74 0e		 je	 SHORT $LN2@jisx0213_2@10

; 910  :         return coded & 0x7fff;

  00054	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00059	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  0005e	eb 07		 jmp	 SHORT $LN6@jisx0213_2@10

; 911  :     else

  00060	eb 05		 jmp	 SHORT $LN1@jisx0213_2@10
$LN2@jisx0213_2@10:

; 912  :         return MAP_UNMAPPABLE;

  00062	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN1@jisx0213_2@10:
$LN3@jisx0213_2@10:
$LN6@jisx0213_2@10:

; 913  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
jisx0213_2004_2_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0201_r_decoder DD imagerel jisx0201_r_decoder
	DD	imagerel jisx0201_r_decoder+142
	DD	imagerel $unwind$jisx0201_r_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0201_r_decoder DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0201_r_decoder
_TEXT	SEGMENT
u$ = 0
data$ = 32
jisx0201_r_decoder PROC					; COMDAT

; 917  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 918  :     ucs4_t u;
; 919  :     JISX0201_R_DECODE(*data, u)

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0000e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00011	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00014	7d 0d		 jge	 SHORT $LN10@jisx0201_r
  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0001b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001e	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  00021	eb 63		 jmp	 SHORT $LN9@jisx0201_r
$LN10@jisx0201_r:
  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00028	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002b	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0002e	75 09		 jne	 SHORT $LN8@jisx0201_r
  00030	c7 04 24 a5 00
	00 00		 mov	 DWORD PTR u$[rsp], 165	; 000000a5H
  00037	eb 4d		 jmp	 SHORT $LN7@jisx0201_r
$LN8@jisx0201_r:
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0003e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00041	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  00044	7d 0d		 jge	 SHORT $LN6@jisx0201_r
  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0004b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004e	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  00051	eb 33		 jmp	 SHORT $LN5@jisx0201_r
$LN6@jisx0201_r:
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00058	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005b	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  0005e	75 09		 jne	 SHORT $LN4@jisx0201_r
  00060	c7 04 24 3e 20
	00 00		 mov	 DWORD PTR u$[rsp], 8254	; 0000203eH
  00067	eb 1d		 jmp	 SHORT $LN3@jisx0201_r
$LN4@jisx0201_r:
  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0006e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00071	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00074	75 09		 jne	 SHORT $LN2@jisx0201_r
  00076	c7 04 24 7f 00
	00 00		 mov	 DWORD PTR u$[rsp], 127	; 0000007fH
  0007d	eb 07		 jmp	 SHORT $LN1@jisx0201_r
$LN2@jisx0201_r:

; 920  :     else return MAP_UNMAPPABLE;

  0007f	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00084	eb 03		 jmp	 SHORT $LN11@jisx0201_r
$LN1@jisx0201_r:
$LN3@jisx0201_r:
$LN5@jisx0201_r:
$LN7@jisx0201_r:
$LN9@jisx0201_r:

; 921  :     return u;

  00086	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
$LN11@jisx0201_r:

; 922  : }

  00089	48 83 c4 18	 add	 rsp, 24
  0008d	c3		 ret	 0
jisx0201_r_decoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0201_r_encoder DD imagerel jisx0201_r_encoder
	DD	imagerel jisx0201_r_encoder+125
	DD	imagerel $unwind$jisx0201_r_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0201_r_encoder DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0201_r_encoder
_TEXT	SEGMENT
coded$ = 0
data$ = 32
length$ = 40
jisx0201_r_encoder PROC					; COMDAT

; 926  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 927  :     DBCHAR coded;
; 928  :     JISX0201_R_ENCODE(*data, coded)

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00013	81 38 80 00 00
	00		 cmp	 DWORD PTR [rax], 128	; 00000080H
  00019	73 22		 jae	 SHORT $LN6@jisx0201_r@2
  0001b	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00020	83 38 5c	 cmp	 DWORD PTR [rax], 92	; 0000005cH
  00023	74 18		 je	 SHORT $LN6@jisx0201_r@2
  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0002a	83 38 7e	 cmp	 DWORD PTR [rax], 126	; 0000007eH
  0002d	74 0e		 je	 SHORT $LN6@jisx0201_r@2
  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00034	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00037	66 89 04 24	 mov	 WORD PTR coded$[rsp], ax
  0003b	eb 37		 jmp	 SHORT $LN5@jisx0201_r@2
$LN6@jisx0201_r@2:
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00042	81 38 a5 00 00
	00		 cmp	 DWORD PTR [rax], 165	; 000000a5H
  00048	75 0b		 jne	 SHORT $LN4@jisx0201_r@2
  0004a	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  0004f	66 89 04 24	 mov	 WORD PTR coded$[rsp], ax
  00053	eb 1f		 jmp	 SHORT $LN3@jisx0201_r@2
$LN4@jisx0201_r@2:
  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0005a	81 38 3e 20 00
	00		 cmp	 DWORD PTR [rax], 8254	; 0000203eH
  00060	75 0b		 jne	 SHORT $LN2@jisx0201_r@2
  00062	b8 7e 00 00 00	 mov	 eax, 126		; 0000007eH
  00067	66 89 04 24	 mov	 WORD PTR coded$[rsp], ax
  0006b	eb 07		 jmp	 SHORT $LN1@jisx0201_r@2
$LN2@jisx0201_r@2:

; 929  :     else return MAP_UNMAPPABLE;

  0006d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00072	eb 04		 jmp	 SHORT $LN7@jisx0201_r@2
$LN1@jisx0201_r@2:
$LN3@jisx0201_r@2:
$LN5@jisx0201_r@2:

; 930  :     return coded;

  00074	0f b7 04 24	 movzx	 eax, WORD PTR coded$[rsp]
$LN7@jisx0201_r@2:

; 931  : }

  00078	48 83 c4 18	 add	 rsp, 24
  0007c	c3		 ret	 0
jisx0201_r_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0201_k_decoder DD imagerel jisx0201_k_decoder
	DD	imagerel jisx0201_k_decoder+84
	DD	imagerel $unwind$jisx0201_k_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0201_k_decoder DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0201_k_decoder
_TEXT	SEGMENT
u$ = 0
data$ = 32
jisx0201_k_decoder PROC					; COMDAT

; 935  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 936  :     ucs4_t u;
; 937  :     JISX0201_K_DECODE(*data ^ 0x80, u)

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0000e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00011	0f ba f8 07	 btc	 eax, 7
  00015	3d a1 00 00 00	 cmp	 eax, 161		; 000000a1H
  0001a	7c 29		 jl	 SHORT $LN2@jisx0201_k
  0001c	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00021	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00024	0f ba f8 07	 btc	 eax, 7
  00028	3d df 00 00 00	 cmp	 eax, 223		; 000000dfH
  0002d	7f 16		 jg	 SHORT $LN2@jisx0201_k
  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00034	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00037	0f ba f8 07	 btc	 eax, 7
  0003b	05 c0 fe 00 00	 add	 eax, 65216		; 0000fec0H
  00040	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  00043	eb 07		 jmp	 SHORT $LN1@jisx0201_k
$LN2@jisx0201_k:

; 938  :     else return MAP_UNMAPPABLE;

  00045	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0004a	eb 03		 jmp	 SHORT $LN3@jisx0201_k
$LN1@jisx0201_k:

; 939  :     return u;

  0004c	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
$LN3@jisx0201_k:

; 940  : }

  0004f	48 83 c4 18	 add	 rsp, 24
  00053	c3		 ret	 0
jisx0201_k_decoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0201_k_encoder DD imagerel jisx0201_k_encoder
	DD	imagerel jisx0201_k_encoder+79
	DD	imagerel $unwind$jisx0201_k_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0201_k_encoder DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT jisx0201_k_encoder
_TEXT	SEGMENT
coded$ = 0
data$ = 32
length$ = 40
jisx0201_k_encoder PROC					; COMDAT

; 944  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 945  :     DBCHAR coded;
; 946  :     JISX0201_K_ENCODE(*data, coded)

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00013	81 38 61 ff 00
	00		 cmp	 DWORD PTR [rax], 65377	; 0000ff61H
  00019	72 1f		 jb	 SHORT $LN2@jisx0201_k@2
  0001b	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00020	81 38 9f ff 00
	00		 cmp	 DWORD PTR [rax], 65439	; 0000ff9fH
  00026	77 12		 ja	 SHORT $LN2@jisx0201_k@2
  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0002d	8b 00		 mov	 eax, DWORD PTR [rax]
  0002f	2d c0 fe 00 00	 sub	 eax, 65216		; 0000fec0H
  00034	66 89 04 24	 mov	 WORD PTR coded$[rsp], ax
  00038	eb 07		 jmp	 SHORT $LN1@jisx0201_k@2
$LN2@jisx0201_k@2:

; 947  :     else return MAP_UNMAPPABLE;

  0003a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0003f	eb 09		 jmp	 SHORT $LN3@jisx0201_k@2
$LN1@jisx0201_k@2:

; 948  :     return coded - 0x80;

  00041	0f b7 04 24	 movzx	 eax, WORD PTR coded$[rsp]
  00045	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
$LN3@jisx0201_k@2:

; 949  : }

  0004a	48 83 c4 18	 add	 rsp, 24
  0004e	c3		 ret	 0
jisx0201_k_encoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@LDNFLDMP@__map_gb2312?$AA@		; `string'
PUBLIC	??_C@_0L@FJIIJALL@_codecs_cn?$AA@		; `string'
PUBLIC	??_C@_0P@DGJMEHOH@__map_gbcommon?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$gb2312_init DD imagerel gb2312_init
	DD	imagerel gb2312_init+103
	DD	imagerel $unwind$gb2312_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gb2312_init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0N@LDNFLDMP@__map_gb2312?$AA@
CONST	SEGMENT
??_C@_0N@LDNFLDMP@__map_gb2312?$AA@ DB '__map_gb2312', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FJIIJALL@_codecs_cn?$AA@
CONST	SEGMENT
??_C@_0L@FJIIJALL@_codecs_cn?$AA@ DB '_codecs_cn', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DGJMEHOH@__map_gbcommon?$AA@
CONST	SEGMENT
??_C@_0P@DGJMEHOH@__map_gbcommon?$AA@ DB '__map_gbcommon', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT gb2312_init
_TEXT	SEGMENT
gb2312_init PROC					; COMDAT

; 953  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 954  :     static int initialized = 0;
; 955  : 
; 956  :     if (!initialized && (
; 957  :                     IMPORT_MAP(cn, gbcommon, &gbcommon_encmap, NULL) ||
; 958  :                     IMPORT_MAP(cn, gb2312, NULL, &gb2312_decmap)))

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??gb2312_init@@9@9, 0
  0000b	75 49		 jne	 SHORT $LN2@gb2312_ini
  0000d	45 33 c9	 xor	 r9d, r9d
  00010	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:gbcommon_encmap
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DGJMEHOH@__map_gbcommon?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@FJIIJALL@_codecs_cn?$AA@
  00025	e8 00 00 00 00	 call	 importmap
  0002a	85 c0		 test	 eax, eax
  0002c	75 21		 jne	 SHORT $LN1@gb2312_ini
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:gb2312_decmap
  00035	45 33 c0	 xor	 r8d, r8d
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LDNFLDMP@__map_gb2312?$AA@
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@FJIIJALL@_codecs_cn?$AA@
  00046	e8 00 00 00 00	 call	 importmap
  0004b	85 c0		 test	 eax, eax
  0004d	74 07		 je	 SHORT $LN2@gb2312_ini
$LN1@gb2312_ini:

; 959  :         return -1;

  0004f	b8 ff ff ff ff	 mov	 eax, -1
  00054	eb 0c		 jmp	 SHORT $LN3@gb2312_ini
$LN2@gb2312_ini:

; 960  :     initialized = 1;

  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??gb2312_init@@9@9, 1

; 961  :     return 0;

  00060	33 c0		 xor	 eax, eax
$LN3@gb2312_ini:

; 962  : }

  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	c3		 ret	 0
gb2312_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gb2312_decoder DD imagerel gb2312_decoder
	DD	imagerel gb2312_decoder+208
	DD	imagerel $unwind$gb2312_decoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gb2312_decoder DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gb2312_decoder
_TEXT	SEGMENT
u$ = 0
data$ = 32
gb2312_decoder PROC					; COMDAT

; 966  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 967  :     ucs4_t u;
; 968  :     TRYMAP_DEC(gb2312, u, data[0], data[1])

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0000e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00011	48 6b c0 10	 imul	 rax, 16
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gb2312_decmap
  0001c	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00021	0f 84 9f 00 00
	00		 je	 $LN2@gb2312_dec
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0002c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00035	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00038	48 6b c9 10	 imul	 rcx, 16
  0003c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR gb2312_decmap
  00043	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00048	3b c1		 cmp	 eax, ecx
  0004a	7c 7a		 jl	 SHORT $LN2@gb2312_dec
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00051	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  0005a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0005d	48 6b c9 10	 imul	 rcx, 16
  00061	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR gb2312_decmap
  00068	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  0006d	3b c1		 cmp	 eax, ecx
  0006f	7f 55		 jg	 SHORT $LN2@gb2312_dec
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00076	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00079	48 6b c0 10	 imul	 rax, 16
  0007d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00082	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00086	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0008b	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  0008e	48 6b d2 10	 imul	 rdx, 16
  00092	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR gb2312_decmap
  00099	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  0009f	2b ca		 sub	 ecx, edx
  000a1	48 63 c9	 movsxd	 rcx, ecx
  000a4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR gb2312_decmap
  000ab	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000af	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  000b3	89 04 24	 mov	 DWORD PTR u$[rsp], eax
  000b6	81 3c 24 fe ff
	00 00		 cmp	 DWORD PTR u$[rsp], 65534 ; 0000fffeH
  000bd	74 07		 je	 SHORT $LN2@gb2312_dec

; 969  :         return u;

  000bf	8b 04 24	 mov	 eax, DWORD PTR u$[rsp]
  000c2	eb 07		 jmp	 SHORT $LN3@gb2312_dec

; 970  :     else

  000c4	eb 05		 jmp	 SHORT $LN1@gb2312_dec
$LN2@gb2312_dec:

; 971  :         return MAP_UNMAPPABLE;

  000c6	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN1@gb2312_dec:
$LN3@gb2312_dec:

; 972  : }

  000cb	48 83 c4 18	 add	 rsp, 24
  000cf	c3		 ret	 0
gb2312_decoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gb2312_encoder DD imagerel gb2312_encoder
	DD	imagerel gb2312_encoder+321
	DD	imagerel $unwind$gb2312_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gb2312_encoder DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gb2312_encoder
_TEXT	SEGMENT
coded$ = 32
data$ = 64
length$ = 72
gb2312_encoder PROC					; COMDAT

; 976  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 977  :     DBCHAR coded;
; 978  :     assert(*length == 1);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR length$[rsp]
  00013	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00017	74 1c		 je	 SHORT $LN6@gb2312_enc
  00019	41 b8 d2 03 00
	00		 mov	 r8d, 978		; 000003d2H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MBLKAJOP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAc?$AAj?$AAk?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA?2?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AAs?$AA_?$AAi?$AAs?$AAo@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@KFPJGOKE@?$AA?$CK?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00033	33 c0		 xor	 eax, eax
$LN6@gb2312_enc:

; 979  :     if (*data < 0x10000) {

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0003a	81 38 00 00 01
	00		 cmp	 DWORD PTR [rax], 65536	; 00010000H
  00040	0f 83 f1 00 00
	00		 jae	 $LN3@gb2312_enc

; 980  :         TRYMAP_ENC(gbcommon, coded, *data) {

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0004b	8b 00		 mov	 eax, DWORD PTR [rax]
  0004d	c1 e8 08	 shr	 eax, 8
  00050	8b c0		 mov	 eax, eax
  00052	48 6b c0 10	 imul	 rax, 16
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gbcommon_encmap
  0005d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00062	0f 84 cf 00 00
	00		 je	 $LN2@gb2312_enc
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0006d	8b 00		 mov	 eax, DWORD PTR [rax]
  0006f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00079	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0007b	c1 e9 08	 shr	 ecx, 8
  0007e	8b c9		 mov	 ecx, ecx
  00080	48 6b c9 10	 imul	 rcx, 16
  00084	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR gbcommon_encmap
  0008b	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  00090	3b c1		 cmp	 eax, ecx
  00092	0f 82 9f 00 00
	00		 jb	 $LN2@gb2312_enc
  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0009d	8b 00		 mov	 eax, DWORD PTR [rax]
  0009f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000a9	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000ab	c1 e9 08	 shr	 ecx, 8
  000ae	8b c9		 mov	 ecx, ecx
  000b0	48 6b c9 10	 imul	 rcx, 16
  000b4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR gbcommon_encmap
  000bb	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  000c0	3b c1		 cmp	 eax, ecx
  000c2	77 73		 ja	 SHORT $LN2@gb2312_enc
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  000c9	8b 00		 mov	 eax, DWORD PTR [rax]
  000cb	c1 e8 08	 shr	 eax, 8
  000ce	8b c0		 mov	 eax, eax
  000d0	48 6b c0 10	 imul	 rax, 16
  000d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000d9	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000db	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000e1	48 8b 54 24 40	 mov	 rdx, QWORD PTR data$[rsp]
  000e6	8b 12		 mov	 edx, DWORD PTR [rdx]
  000e8	c1 ea 08	 shr	 edx, 8
  000eb	8b d2		 mov	 edx, edx
  000ed	48 6b d2 10	 imul	 rdx, 16
  000f1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR gbcommon_encmap
  000f8	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  000fe	2b ca		 sub	 ecx, edx
  00100	8b c9		 mov	 ecx, ecx
  00102	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR gbcommon_encmap
  00109	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0010d	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00111	66 89 44 24 20	 mov	 WORD PTR coded$[rsp], ax
  00116	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  0011b	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00120	74 15		 je	 SHORT $LN2@gb2312_enc

; 981  :             if (!(coded & 0x8000))

  00122	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00127	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  0012c	85 c0		 test	 eax, eax
  0012e	75 07		 jne	 SHORT $LN1@gb2312_enc

; 982  :                 return coded;

  00130	0f b7 44 24 20	 movzx	 eax, WORD PTR coded$[rsp]
  00135	eb 05		 jmp	 SHORT $LN4@gb2312_enc
$LN1@gb2312_enc:
$LN2@gb2312_enc:
$LN3@gb2312_enc:

; 983  :         }
; 984  :     }
; 985  :     return MAP_UNMAPPABLE;

  00137	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN4@gb2312_enc:

; 986  : }

  0013c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00140	c3		 ret	 0
gb2312_encoder ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT dummy_decoder
_TEXT	SEGMENT
data$ = 8
dummy_decoder PROC					; COMDAT

; 991  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 992  :     return MAP_UNMAPPABLE;

  00005	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 993  : }

  0000a	c3		 ret	 0
dummy_decoder ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT dummy_encoder
_TEXT	SEGMENT
data$ = 8
length$ = 16
dummy_encoder PROC					; COMDAT

; 997  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 998  :     return MAP_UNMAPPABLE;

  0000a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 999  : }

  0000f	c3		 ret	 0
dummy_encoder ENDP
_TEXT	ENDS
PUBLIC	PyInit__codecs_iso2022
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__codecs_iso2022 DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$PyInit__codecs_iso2022
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__codecs_iso2022 DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyInit__codecs_iso2022
_TEXT	SEGMENT
m$ = 32
PyInit__codecs_iso2022 PROC				; COMDAT

; 1131 : I_AM_A_MODULE_FOR(iso2022)

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__module
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax
  0001a	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	74 0a		 je	 SHORT $LN1@PyInit__co
  00022	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  00027	e8 00 00 00 00	 call	 register_maps
$LN1@PyInit__co:
  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	c3		 ret	 0
PyInit__codecs_iso2022 ENDP
_TEXT	ENDS
PUBLIC	??_C@_06MBDMAJKM@__map_?$AA@			; `string'
EXTRN	PyModule_AddObject:PROC
EXTRN	strcpy:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\cjkcodecs\cjkcodecs.h
pdata	SEGMENT
$pdata$register_maps DD imagerel register_maps
	DD	imagerel register_maps+206
	DD	imagerel $unwind$register_maps
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$register_maps DD 040e01H
	DD	029010eH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_06MBDMAJKM@__map_?$AA@
CONST	SEGMENT
??_C@_06MBDMAJKM@__map_?$AA@ DB '__map_', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT register_maps
_TEXT	SEGMENT
h$ = 32
mhname$20602 = 48
r$20604 = 304
module$ = 352
register_maps PROC					; COMDAT

; 306  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H

; 307  :     const struct dbcs_map *h;
; 308  : 
; 309  :     for (h = mapping_list; h->charset[0] != '\0'; h++) {

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR mapping_list
  00015	48 89 44 24 20	 mov	 QWORD PTR h$[rsp], rax
  0001a	eb 0e		 jmp	 SHORT $LN4@register_m
$LN3@register_m:
  0001c	48 8b 44 24 20	 mov	 rax, QWORD PTR h$[rsp]
  00021	48 83 c0 18	 add	 rax, 24
  00025	48 89 44 24 20	 mov	 QWORD PTR h$[rsp], rax
$LN4@register_m:
  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR h$[rsp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00035	85 c0		 test	 eax, eax
  00037	0f 84 85 00 00
	00		 je	 $LN2@register_m

; 310  :         char mhname[256] = "__map_";

  0003d	48 8d 44 24 30	 lea	 rax, QWORD PTR mhname$20602[rsp]
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06MBDMAJKM@__map_?$AA@
  00049	48 8b f8	 mov	 rdi, rax
  0004c	48 8b f1	 mov	 rsi, rcx
  0004f	b9 07 00 00 00	 mov	 ecx, 7
  00054	f3 a4		 rep movsb
  00056	48 8d 44 24 37	 lea	 rax, QWORD PTR mhname$20602[rsp+7]
  0005b	48 8b f8	 mov	 rdi, rax
  0005e	33 c0		 xor	 eax, eax
  00060	b9 f9 00 00 00	 mov	 ecx, 249		; 000000f9H
  00065	f3 aa		 rep stosb

; 311  :         int r;
; 312  :         strcpy(mhname + sizeof("__map_") - 1, h->charset);

  00067	48 8d 44 24 36	 lea	 rax, QWORD PTR mhname$20602[rsp+6]
  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR h$[rsp]
  00071	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00074	48 8b c8	 mov	 rcx, rax
  00077	e8 00 00 00 00	 call	 strcpy

; 313  :         r = PyModule_AddObject(module, mhname,
; 314  :                         PyCapsule_New((void *)h, PyMultibyteCodec_CAPSULE_NAME, NULL));

  0007c	45 33 c0	 xor	 r8d, r8d
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@
  00086	48 8b 4c 24 20	 mov	 rcx, QWORD PTR h$[rsp]
  0008b	e8 00 00 00 00	 call	 PyCapsule_New
  00090	4c 8b c0	 mov	 r8, rax
  00093	48 8d 54 24 30	 lea	 rdx, QWORD PTR mhname$20602[rsp]
  00098	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR module$[rsp]
  000a0	e8 00 00 00 00	 call	 PyModule_AddObject
  000a5	89 84 24 30 01
	00 00		 mov	 DWORD PTR r$20604[rsp], eax

; 315  :         if (r == -1)

  000ac	83 bc 24 30 01
	00 00 ff	 cmp	 DWORD PTR r$20604[rsp], -1
  000b4	75 07		 jne	 SHORT $LN1@register_m

; 316  :             return -1;

  000b6	b8 ff ff ff ff	 mov	 eax, -1
  000bb	eb 07		 jmp	 SHORT $LN5@register_m
$LN1@register_m:

; 317  :     }

  000bd	e9 5a ff ff ff	 jmp	 $LN3@register_m
$LN2@register_m:

; 318  :     return 0;

  000c2	33 c0		 xor	 eax, eax
$LN5@register_m:

; 319  : }

  000c4	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  000cb	5f		 pop	 rdi
  000cc	5e		 pop	 rsi
  000cd	c3		 ret	 0
register_maps ENDP
_TEXT	ENDS
END
