; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07IFNJGOBH@_struct?$AA@			; `string'
PUBLIC	??_C@_08BLJPPNIC@calcsize?$AA@			; `string'
PUBLIC	??_C@_0M@OEIFDDHI@_clearcache?$AA@		; `string'
PUBLIC	??_C@_06DOCMLGPG@Struct?$AA@			; `string'
PUBLIC	??_C@_0BF@LEHIHPPG@struct?5size?5in?5bytes?$AA@	; `string'
PUBLIC	??_C@_04IAGNFIBA@size?$AA@			; `string'
PUBLIC	??_C@_0BF@GKEJOILN@struct?5format?5string?$AA@	; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0M@OJKBBEFN@unpack_from?$AA@		; `string'
PUBLIC	??_C@_06FIONAGJL@unpack?$AA@			; `string'
PUBLIC	??_C@_09HFGPKAHL@pack_into?$AA@			; `string'
PUBLIC	??_C@_04IPANLPFO@pack?$AA@			; `string'
PUBLIC	??_C@_06KLHHMIGM@offset?$AA@			; `string'
PUBLIC	??_C@_06HOHPNJLC@buffer?$AA@			; `string'
PUBLIC	??_C@_06DLEPGFEF@format?$AA@			; `string'
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericSetAttr:PROC
EXTRN	PyObject_GenericGetAttr:PROC
_BSS	SEGMENT
cache	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_07IFNJGOBH@_struct?$AA@
CONST	SEGMENT
??_C@_07IFNJGOBH@_struct?$AA@ DB '_struct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BLJPPNIC@calcsize?$AA@
CONST	SEGMENT
??_C@_08BLJPPNIC@calcsize?$AA@ DB 'calcsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEIFDDHI@_clearcache?$AA@
CONST	SEGMENT
??_C@_0M@OEIFDDHI@_clearcache?$AA@ DB '_clearcache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DOCMLGPG@Struct?$AA@
CONST	SEGMENT
??_C@_06DOCMLGPG@Struct?$AA@ DB 'Struct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LEHIHPPG@struct?5size?5in?5bytes?$AA@
CONST	SEGMENT
??_C@_0BF@LEHIHPPG@struct?5size?5in?5bytes?$AA@ DB 'struct size in bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAGNFIBA@size?$AA@
CONST	SEGMENT
??_C@_04IAGNFIBA@size?$AA@ DB 'size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GKEJOILN@struct?5format?5string?$AA@
CONST	SEGMENT
??_C@_0BF@GKEJOILN@struct?5format?5string?$AA@ DB 'struct format string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OJKBBEFN@unpack_from?$AA@
CONST	SEGMENT
??_C@_0M@OJKBBEFN@unpack_from?$AA@ DB 'unpack_from', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FIONAGJL@unpack?$AA@
CONST	SEGMENT
??_C@_06FIONAGJL@unpack?$AA@ DB 'unpack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HFGPKAHL@pack_into?$AA@
CONST	SEGMENT
??_C@_09HFGPKAHL@pack_into?$AA@ DB 'pack_into', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPANLPFO@pack?$AA@
CONST	SEGMENT
??_C@_04IPANLPFO@pack?$AA@ DB 'pack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLHHMIGM@offset?$AA@
CONST	SEGMENT
??_C@_06KLHHMIGM@offset?$AA@ DB 'offset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOHPNJLC@buffer?$AA@
CONST	SEGMENT
??_C@_06HOHPNJLC@buffer?$AA@ DB 'buffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLEPGFEF@format?$AA@
CONST	SEGMENT
??_C@_06DLEPGFEF@format?$AA@ DB 'format', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
native_table DB	078H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	062H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_byte
	DQ	FLAT:np_byte
	DB	042H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_ubyte
	DQ	FLAT:np_ubyte
	DB	063H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_char
	DQ	FLAT:np_char
	DB	073H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	070H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	068H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000002H
	DQ	FLAT:nu_short
	DQ	FLAT:np_short
	DB	048H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000002H
	DQ	FLAT:nu_ushort
	DQ	FLAT:np_ushort
	DB	069H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000004H
	DQ	FLAT:nu_int
	DQ	FLAT:np_int
	DB	049H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000004H
	DQ	FLAT:nu_uint
	DQ	FLAT:np_uint
	DB	06cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000004H
	DQ	FLAT:nu_long
	DQ	FLAT:np_long
	DB	04cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000004H
	DQ	FLAT:nu_ulong
	DQ	FLAT:np_ulong
	DB	06eH
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_ssize_t
	DQ	FLAT:np_ssize_t
	DB	04eH
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_size_t
	DQ	FLAT:np_size_t
	DB	071H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_longlong
	DQ	FLAT:np_longlong
	DB	051H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_ulonglong
	DQ	FLAT:np_ulonglong
	DB	03fH
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_bool
	DQ	FLAT:np_bool
	DB	066H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000004H
	DQ	FLAT:nu_float
	DQ	FLAT:np_float
	DB	064H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_double
	DQ	FLAT:np_double
	DB	050H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_void_p
	DQ	FLAT:np_void_p
	DB	00H
	ORG $+7
	ORG $+32
?kwlist@?1??s_unpack_from@@9@9 DQ FLAT:??_C@_06HOHPNJLC@buffer?$AA@ ; `s_unpack_from'::`2'::kwlist
	DQ	FLAT:??_C@_06KLHHMIGM@offset?$AA@
	DQ	0000000000000000H
bigendian_table DB 078H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	062H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_byte
	DQ	FLAT:np_byte
	DB	042H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_ubyte
	DQ	FLAT:np_ubyte
	DB	063H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_char
	DQ	FLAT:np_char
	DB	073H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	070H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	068H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000000H
	DQ	FLAT:bu_int
	DQ	FLAT:bp_int
	DB	048H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000000H
	DQ	FLAT:bu_uint
	DQ	FLAT:bp_uint
	DB	069H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:bu_int
	DQ	FLAT:bp_int
	DB	049H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:bu_uint
	DQ	FLAT:bp_uint
	DB	06cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:bu_int
	DQ	FLAT:bp_int
	DB	04cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:bu_uint
	DQ	FLAT:bp_uint
	DB	071H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:bu_longlong
	DQ	FLAT:bp_longlong
	DB	051H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:bu_ulonglong
	DQ	FLAT:bp_ulonglong
	DB	03fH
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:bu_bool
	DQ	FLAT:bp_bool
	DB	066H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:bu_float
	DQ	FLAT:bp_float
	DB	064H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:bu_double
	DQ	FLAT:bp_double
	DB	00H
	ORG $+7
	ORG $+32
lilendian_table DB 078H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	062H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_byte
	DQ	FLAT:np_byte
	DB	042H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_ubyte
	DQ	FLAT:np_ubyte
	DB	063H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_char
	DQ	FLAT:np_char
	DB	073H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	070H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	068H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000000H
	DQ	FLAT:lu_int
	DQ	FLAT:lp_int
	DB	048H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000000H
	DQ	FLAT:lu_uint
	DQ	FLAT:lp_uint
	DB	069H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:lu_int
	DQ	FLAT:lp_int
	DB	049H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:lu_uint
	DQ	FLAT:lp_uint
	DB	06cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:lu_int
	DQ	FLAT:lp_int
	DB	04cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:lu_uint
	DQ	FLAT:lp_uint
	DB	071H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:lu_longlong
	DQ	FLAT:lp_longlong
	DB	051H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:lu_ulonglong
	DQ	FLAT:lp_ulonglong
	DB	03fH
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:bu_bool
	DQ	FLAT:bp_bool
	DB	066H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:lu_float
	DQ	FLAT:lp_float
	DB	064H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:lu_double
	DQ	FLAT:lp_double
	DB	00H
	ORG $+7
	ORG $+32
?kwlist@?1??s_init@@9@9 DQ FLAT:??_C@_06DLEPGFEF@format?$AA@ ; `s_init'::`2'::kwlist
	DQ	0000000000000000H
s_unpack__doc__ DB 'S.unpack(buffer) -> (v1, v2, ...)', 0aH, 0aH, 'Return'
	DB	' a tuple containing values unpacked according to the format', 0aH
	DB	'string S.format.  Requires len(buffer) == S.size.  See help(s'
	DB	'truct)', 0aH, 'for more on format strings.', 00H
	ORG $+11
s_unpack_from__doc__ DB 'S.unpack_from(buffer, offset=0) -> (v1, v2, ...)'
	DB	0aH, 0aH, 'Return a tuple containing values unpacked according'
	DB	' to the format', 0aH, 'string S.format.  Requires len(buffer['
	DB	'offset:]) >= S.size.  See', 0aH, 'help(struct) for more on fo'
	DB	'rmat strings.', 00H
	ORG $+3
s_pack__doc__ DB 'S.pack(v1, v2, ...) -> bytes', 0aH, 0aH, 'Return a byte'
	DB	's object containing values v1, v2, ... packed according', 0aH
	DB	'to the format string S.format.  See help(struct) for more on '
	DB	'format', 0aH, 'strings.', 00H
s_pack_into__doc__ DB 'S.pack_into(buffer, offset, v1, v2, ...)', 0aH, 0aH
	DB	'Pack the values v1, v2, ... according to the format string S.'
	DB	'format', 0aH, 'and write the packed bytes into the writable b'
	DB	'uffer buf starting at', 0aH, 'offset.  Note that the offset i'
	DB	's a required argument.  See', 0aH, 'help(struct) for more on '
	DB	'format strings.', 00H
	ORG $+2
s_sizeof__doc__ DB 'S.__sizeof__() -> size of S in memory, in bytes', 00H
	ORG $+8
s_methods DQ	FLAT:??_C@_04IPANLPFO@pack?$AA@
	DQ	FLAT:s_pack
	DD	01H
	ORG $+4
	DQ	FLAT:s_pack__doc__
	DQ	FLAT:??_C@_09HFGPKAHL@pack_into?$AA@
	DQ	FLAT:s_pack_into
	DD	01H
	ORG $+4
	DQ	FLAT:s_pack_into__doc__
	DQ	FLAT:??_C@_06FIONAGJL@unpack?$AA@
	DQ	FLAT:s_unpack
	DD	08H
	ORG $+4
	DQ	FLAT:s_unpack__doc__
	DQ	FLAT:??_C@_0M@OJKBBEFN@unpack_from?$AA@
	DQ	FLAT:s_unpack_from
	DD	03H
	ORG $+4
	DQ	FLAT:s_unpack_from__doc__
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:s_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:s_sizeof__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
s__doc__ DB	'Struct(fmt) --> compiled struct object', 0aH, 0aH, 'Retu'
	DB	'rn a new Struct object which writes and reads binary data acc'
	DB	'ording to', 0aH, 'the format string fmt.  See help(struct) fo'
	DB	'r more on format strings.', 00H
	ORG $+8
s_getsetlist DQ	FLAT:??_C@_06DLEPGFEF@format?$AA@
	DQ	FLAT:s_get_format
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BF@GKEJOILN@struct?5format?5string?$AA@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_04IAGNFIBA@size?$AA@
	DQ	FLAT:s_get_size
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BF@LEHIHPPG@struct?5size?5in?5bytes?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
PyStructType DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06DOCMLGPG@Struct?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:s_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	FLAT:PyObject_GenericSetAttr
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:s__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:s_methods
	DQ	0000000000000000H
	DQ	FLAT:s_getsetlist
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:s_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:s_new
	DQ	FLAT:_PyObject_DebugFree
	ORG $+64
clearcache_doc DB 'Clear the internal cache.', 00H
	ORG $+6
calcsize_doc DB	'calcsize(fmt) -> integer', 0aH, 0aH, 'Return size in byt'
	DB	'es of the struct described by the format string fmt.', 00H
	ORG $+15
pack_doc DB	'pack(fmt, v1, v2, ...) -> bytes', 0aH, 0aH, 'Return a by'
	DB	'tes object containing the values v1, v2, ... packed according'
	DB	0aH, 'to the format string fmt.  See help(struct) for more on '
	DB	'format strings.', 00H
	ORG $+14
pack_into_doc DB 'pack_into(fmt, buffer, offset, v1, v2, ...)', 0aH, 0aH, 'P'
	DB	'ack the values v1, v2, ... according to the format string fmt'
	DB	' and write', 0aH, 'the packed bytes into the writable buffer '
	DB	'buf starting at offset.  Note', 0aH, 'that the offset is a re'
	DB	'quired argument.  See help(struct) for more', 0aH, 'on format'
	DB	' strings.', 00H
	ORG $+12
unpack_doc DB	'unpack(fmt, buffer) -> (v1, v2, ...)', 0aH, 0aH, 'Return'
	DB	' a tuple containing values unpacked according to the format s'
	DB	'tring', 0aH, 'fmt.  Requires len(buffer) == calcsize(fmt). Se'
	DB	'e help(struct) for more', 0aH, 'on format strings.', 00H
	ORG $+7
unpack_from_doc DB 'unpack_from(fmt, buffer, offset=0) -> (v1, v2, ...)', 0aH
	DB	0aH, 'Return a tuple containing values unpacked according to t'
	DB	'he format string', 0aH, 'fmt.  Requires len(buffer[offset:]) '
	DB	'>= calcsize(fmt).  See help(struct)', 0aH, 'for more on forma'
	DB	't strings.', 00H
	ORG $+14
module_functions DQ FLAT:??_C@_0M@OEIFDDHI@_clearcache?$AA@
	DQ	FLAT:clearcache
	DD	04H
	ORG $+4
	DQ	FLAT:clearcache_doc
	DQ	FLAT:??_C@_08BLJPPNIC@calcsize?$AA@
	DQ	FLAT:calcsize
	DD	08H
	ORG $+4
	DQ	FLAT:calcsize_doc
	DQ	FLAT:??_C@_04IPANLPFO@pack?$AA@
	DQ	FLAT:pack
	DD	01H
	ORG $+4
	DQ	FLAT:pack_doc
	DQ	FLAT:??_C@_09HFGPKAHL@pack_into?$AA@
	DQ	FLAT:pack_into
	DD	01H
	ORG $+4
	DQ	FLAT:pack_into_doc
	DQ	FLAT:??_C@_06FIONAGJL@unpack?$AA@
	DQ	FLAT:unpack
	DD	01H
	ORG $+4
	DQ	FLAT:unpack_doc
	DQ	FLAT:??_C@_0M@OJKBBEFN@unpack_from?$AA@
	DQ	FLAT:unpack_from
	DD	03H
	ORG $+4
	DQ	FLAT:unpack_from_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_doc DB	'Functions to convert between Python values and C structs'
	DB	'.', 0aH, 'Python bytes objects are used to hold the data repr'
	DB	'esenting the C struct', 0aH, 'and also as format strings (exp'
	DB	'lained below) to describe the layout of data', 0aH, 'in the C'
	DB	' struct.', 0aH, 0aH, 'The optional first format char indicate'
	DB	's byte order, size and alignment:', 0aH, '  @: native order, '
	DB	'size & alignment (default)', 0aH, '  =: native order, std. si'
	DB	'ze & alignment', 0aH, '  <: little-endian, std. size & alignm'
	DB	'ent', 0aH, '  >: big-endian, std. size & alignment', 0aH, '  '
	DB	'!: same as >', 0aH, 0aH, 'The remaining chars indicate types '
	DB	'of args and must match exactly;', 0aH, 'these can be preceded'
	DB	' by a decimal repeat count:', 0aH, '  x: pad byte (no data); '
	DB	'c:char; b:signed byte; B:unsigned byte;', 0aH, '  ?: _Bool (r'
	DB	'equires C99; if not available, char is used instead)', 0aH, ' '
	DB	' h:short; H:unsigned short; i:int; I:unsigned int;', 0aH, '  '
	DB	'l:long; L:unsigned long; f:float; d:double.', 0aH, 'Special c'
	DB	'ases (preceding decimal count indicates length):', 0aH, '  s:'
	DB	'string (array of char); p: pascal string (with count byte).', 0aH
	DB	'Special cases (only available in native format):', 0aH, '  n:'
	DB	'ssize_t; N:size_t;', 0aH, '  P:an integer type that is wide e'
	DB	'nough to hold a pointer.', 0aH, 'Special case (not in native '
	DB	'mode unless ''long long'' in platform C):', 0aH, '  q:long lo'
	DB	'ng; Q:unsigned long long', 0aH, 'Whitespace between formats i'
	DB	's ignored.', 0aH, 0aH, 'The variable struct.error is an excep'
	DB	'tion raised on errors.', 0aH, 00H
	ORG $+11
_structmodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07IFNJGOBH@_struct?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:module_functions
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_struct.c
pdata	SEGMENT
$pdata$nu_char DD imagerel nu_char
	DD	imagerel nu_char+34
	DD	imagerel $unwind$nu_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_char DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_char
_TEXT	SEGMENT
p$ = 48
f$ = 56
nu_char	PROC						; COMDAT

; 348  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 349  :     return PyBytes_FromStringAndSize(p, 1);

  0000e	ba 01 00 00 00	 mov	 edx, 1
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00018	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 350  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
nu_char	ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_byte DD imagerel nu_byte
	DD	imagerel nu_byte+34
	DD	imagerel $unwind$nu_byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_byte DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_byte
_TEXT	SEGMENT
p$ = 48
f$ = 56
nu_byte	PROC						; COMDAT

; 354  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 355  :     return PyLong_FromLong((long) *(signed char *)p);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00013	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 PyLong_FromLong

; 356  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
nu_byte	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_ubyte DD imagerel nu_ubyte
	DD	imagerel nu_ubyte+34
	DD	imagerel $unwind$nu_ubyte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_ubyte DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_ubyte
_TEXT	SEGMENT
p$ = 48
f$ = 56
nu_ubyte PROC						; COMDAT

; 360  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 361  :     return PyLong_FromLong((long) *(unsigned char *)p);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00013	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 PyLong_FromLong

; 362  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
nu_ubyte ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_short DD imagerel nu_short
	DD	imagerel nu_short+52
	DD	imagerel $unwind$nu_short
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_short DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_short
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_short PROC						; COMDAT

; 366  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 367  :     short x;
; 368  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 369  :     return PyLong_FromLong((long)x);

  00023	0f bf 44 24 20	 movsx	 eax, WORD PTR x$[rsp]
  00028	8b c8		 mov	 ecx, eax
  0002a	e8 00 00 00 00	 call	 PyLong_FromLong

; 370  : }

  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
nu_short ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_ushort DD imagerel nu_ushort
	DD	imagerel nu_ushort+52
	DD	imagerel $unwind$nu_ushort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_ushort DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_ushort
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_ushort PROC						; COMDAT

; 374  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 375  :     unsigned short x;
; 376  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 377  :     return PyLong_FromLong((long)x);

  00023	0f b7 44 24 20	 movzx	 eax, WORD PTR x$[rsp]
  00028	8b c8		 mov	 ecx, eax
  0002a	e8 00 00 00 00	 call	 PyLong_FromLong

; 378  : }

  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
nu_ushort ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_int DD imagerel nu_int
	DD	imagerel nu_int+49
	DD	imagerel $unwind$nu_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_int DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_int
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_int	PROC						; COMDAT

; 382  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 383  :     int x;
; 384  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 385  :     return PyLong_FromLong((long)x);

  00023	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00027	e8 00 00 00 00	 call	 PyLong_FromLong

; 386  : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	c3		 ret	 0
nu_int	ENDP
_TEXT	ENDS
EXTRN	PyLong_FromUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_uint DD imagerel nu_uint
	DD	imagerel nu_uint+70
	DD	imagerel $unwind$nu_uint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_uint DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_uint
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_uint	PROC						; COMDAT

; 390  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 391  :     unsigned int x;
; 392  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 393  : #if (SIZEOF_LONG > SIZEOF_INT)
; 394  :     return PyLong_FromLong((long)x);
; 395  : #else
; 396  :     if (x <= ((unsigned int)LONG_MAX))

  00023	81 7c 24 20 ff
	ff ff 7f	 cmp	 DWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  0002b	77 0b		 ja	 SHORT $LN1@nu_uint

; 397  :         return PyLong_FromLong((long)x);

  0002d	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00031	e8 00 00 00 00	 call	 PyLong_FromLong
  00036	eb 09		 jmp	 SHORT $LN2@nu_uint
$LN1@nu_uint:

; 398  :     return PyLong_FromUnsignedLong((unsigned long)x);

  00038	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  0003c	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN2@nu_uint:

; 399  : #endif
; 400  : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
nu_uint	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_long DD imagerel nu_long
	DD	imagerel nu_long+49
	DD	imagerel $unwind$nu_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_long DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_long
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_long	PROC						; COMDAT

; 404  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 405  :     long x;
; 406  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 407  :     return PyLong_FromLong(x);

  00023	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00027	e8 00 00 00 00	 call	 PyLong_FromLong

; 408  : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	c3		 ret	 0
nu_long	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_ulong DD imagerel nu_ulong
	DD	imagerel nu_ulong+70
	DD	imagerel $unwind$nu_ulong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_ulong DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_ulong
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_ulong PROC						; COMDAT

; 412  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 413  :     unsigned long x;
; 414  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 415  :     if (x <= LONG_MAX)

  00023	81 7c 24 20 ff
	ff ff 7f	 cmp	 DWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  0002b	77 0b		 ja	 SHORT $LN1@nu_ulong

; 416  :         return PyLong_FromLong((long)x);

  0002d	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00031	e8 00 00 00 00	 call	 PyLong_FromLong
  00036	eb 09		 jmp	 SHORT $LN2@nu_ulong
$LN1@nu_ulong:

; 417  :     return PyLong_FromUnsignedLong(x);

  00038	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  0003c	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN2@nu_ulong:

; 418  : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
nu_ulong ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_ssize_t DD imagerel nu_ssize_t
	DD	imagerel nu_ssize_t+50
	DD	imagerel $unwind$nu_ssize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_ssize_t DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_ssize_t
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_ssize_t PROC						; COMDAT

; 422  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 423  :     Py_ssize_t x;
; 424  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 425  :     return PyLong_FromSsize_t(x);

  00023	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00028	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 426  : }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	c3		 ret	 0
nu_ssize_t ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_size_t DD imagerel nu_size_t
	DD	imagerel nu_size_t+50
	DD	imagerel $unwind$nu_size_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_size_t DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_size_t
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_size_t PROC						; COMDAT

; 430  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 431  :     size_t x;
; 432  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 433  :     return PyLong_FromSize_t(x);

  00023	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00028	e8 00 00 00 00	 call	 PyLong_FromSize_t

; 434  : }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	c3		 ret	 0
nu_size_t ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@MIJEIJKE@?$AA?$CI?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	PyLong_FromLongLong:PROC
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_longlong DD imagerel nu_longlong
	DD	imagerel nu_longlong+123
	DD	imagerel $unwind$nu_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_longlong DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1DE@MIJEIJKE@?$AA?$CI?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@MIJEIJKE@?$AA?$CI?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ DB '('
	DB	00H, '_', 00H, '_', 00H, 'i', 00H, 'n', 00H, 't', 00H, '6', 00H
	DB	'4', 00H, ')', 00H, '(', 00H, 'l', 00H, 'o', 00H, 'n', 00H, 'g'
	DB	00H, ')', 00H, '(', 00H, 'x', 00H, ')', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '(', 00H, 'x', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, '_', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT nu_longlong
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_longlong PROC					; COMDAT

; 444  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 445  :     PY_LONG_LONG x;
; 446  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 447  :     if (x >= LONG_MIN && x <= LONG_MAX)

  00023	48 81 7c 24 20
	00 00 00 80	 cmp	 QWORD PTR x$[rsp], -2147483648 ; ffffffff80000000H
  0002c	7c 3e		 jl	 SHORT $LN1@nu_longlon
  0002e	48 81 7c 24 20
	ff ff ff 7f	 cmp	 QWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  00037	7f 33		 jg	 SHORT $LN1@nu_longlon

; 448  :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, PY_LONG_LONG, long));

  00039	48 63 44 24 20	 movsxd	 rax, DWORD PTR x$[rsp]
  0003e	48 3b 44 24 20	 cmp	 rax, QWORD PTR x$[rsp]
  00043	74 1c		 je	 SHORT $LN4@nu_longlon
  00045	41 b8 c0 01 00
	00		 mov	 r8d, 448		; 000001c0H
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MIJEIJKE@?$AA?$CI?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005f	33 c0		 xor	 eax, eax
$LN4@nu_longlon:
  00061	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00065	e8 00 00 00 00	 call	 PyLong_FromLong
  0006a	eb 0a		 jmp	 SHORT $LN2@nu_longlon
$LN1@nu_longlon:

; 449  :     return PyLong_FromLongLong(x);

  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00071	e8 00 00 00 00	 call	 PyLong_FromLongLong
$LN2@nu_longlon:

; 450  : }

  00076	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007a	c3		 ret	 0
nu_longlong ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EG@GIOHOOLL@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI@ ; `string'
EXTRN	PyLong_FromUnsignedLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_ulonglong DD imagerel nu_ulonglong
	DD	imagerel nu_ulonglong+112
	DD	imagerel $unwind$nu_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_ulonglong DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1EG@GIOHOOLL@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI@
CONST	SEGMENT
??_C@_1EG@GIOHOOLL@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI@ DB '('
	DB	00H, 'u', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, '_', 00H, '_', 00H, 'i', 00H, 'n'
	DB	00H, 't', 00H, '6', 00H, '4', 00H, ')', 00H, '(', 00H, 'l', 00H
	DB	'o', 00H, 'n', 00H, 'g', 00H, ')', 00H, '(', 00H, 'x', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT nu_ulonglong
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_ulonglong PROC					; COMDAT

; 454  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 455  :     unsigned PY_LONG_LONG x;
; 456  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 457  :     if (x <= LONG_MAX)

  00023	48 81 7c 24 20
	ff ff ff 7f	 cmp	 QWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  0002c	77 33		 ja	 SHORT $LN1@nu_ulonglo

; 458  :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, unsigned PY_LONG_LONG, long));

  0002e	48 63 44 24 20	 movsxd	 rax, DWORD PTR x$[rsp]
  00033	48 3b 44 24 20	 cmp	 rax, QWORD PTR x$[rsp]
  00038	74 1c		 je	 SHORT $LN4@nu_ulonglo
  0003a	41 b8 ca 01 00
	00		 mov	 r8d, 458		; 000001caH
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@GIOHOOLL@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI@
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00054	33 c0		 xor	 eax, eax
$LN4@nu_ulonglo:
  00056	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  0005a	e8 00 00 00 00	 call	 PyLong_FromLong
  0005f	eb 0a		 jmp	 SHORT $LN2@nu_ulonglo
$LN1@nu_ulonglo:

; 459  :     return PyLong_FromUnsignedLongLong(x);

  00061	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00066	e8 00 00 00 00	 call	 PyLong_FromUnsignedLongLong
$LN2@nu_ulonglo:

; 460  : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
nu_ulonglong ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_bool DD imagerel nu_bool
	DD	imagerel nu_bool+76
	DD	imagerel $unwind$nu_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_bool DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_bool
_TEXT	SEGMENT
x$ = 32
tv70 = 36
p$ = 64
f$ = 72
nu_bool	PROC						; COMDAT

; 466  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 467  :     BOOL_TYPE x;
; 468  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 469  :     return PyBool_FromLong(x != 0);

  00023	0f be 44 24 20	 movsx	 eax, BYTE PTR x$[rsp]
  00028	85 c0		 test	 eax, eax
  0002a	74 0a		 je	 SHORT $LN3@nu_bool
  0002c	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00034	eb 08		 jmp	 SHORT $LN4@nu_bool
$LN3@nu_bool:
  00036	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN4@nu_bool:
  0003e	8b 4c 24 24	 mov	 ecx, DWORD PTR tv70[rsp]
  00042	e8 00 00 00 00	 call	 PyBool_FromLong

; 470  : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
nu_bool	ENDP
_TEXT	ENDS
EXTRN	PyFloat_FromDouble:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_float DD imagerel nu_float
	DD	imagerel nu_float+54
	DD	imagerel $unwind$nu_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_float DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_float
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_float PROC						; COMDAT

; 475  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 476  :     float x;
; 477  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 478  :     return PyFloat_FromDouble((double)x);

  00023	66 0f 6e 44 24
	20		 movd	 xmm0, DWORD PTR x$[rsp]
  00029	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002c	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 479  : }

  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	c3		 ret	 0
nu_float ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_double DD imagerel nu_double
	DD	imagerel nu_double+51
	DD	imagerel $unwind$nu_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_double DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_double
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_double PROC						; COMDAT

; 483  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 484  :     double x;
; 485  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 486  :     return PyFloat_FromDouble(x);

  00023	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00029	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 487  : }

  0002e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00032	c3		 ret	 0
nu_double ENDP
_TEXT	ENDS
EXTRN	PyLong_FromVoidPtr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$nu_void_p DD imagerel nu_void_p
	DD	imagerel nu_void_p+50
	DD	imagerel $unwind$nu_void_p
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nu_void_p DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nu_void_p
_TEXT	SEGMENT
x$ = 32
p$ = 64
f$ = 72
nu_void_p PROC						; COMDAT

; 491  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 492  :     void *x;
; 493  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 494  :     return PyLong_FromVoidPtr(x);

  00023	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00028	e8 00 00 00 00	 call	 PyLong_FromVoidPtr

; 495  : }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	c3		 ret	 0
nu_void_p ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@HPOFFIBE@byte?5format?5requires?5?9128?5?$DM?$DN?5num@ ; `string'
EXTRN	PyErr_SetString:PROC
_BSS	SEGMENT
StructError DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_byte DD imagerel np_byte
	DD	imagerel np_byte+104
	DD	imagerel $unwind$np_byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_byte DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CL@HPOFFIBE@byte?5format?5requires?5?9128?5?$DM?$DN?5num@
CONST	SEGMENT
??_C@_0CL@HPOFFIBE@byte?5format?5requires?5?9128?5?$DM?$DN?5num@ DB 'byte'
	DB	' format requires -128 <= number <= 127', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT np_byte
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_byte	PROC						; COMDAT

; 499  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 500  :     long x;
; 501  :     if (get_long(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_long
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN3@np_byte

; 502  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 36		 jmp	 SHORT $LN4@np_byte
$LN3@np_byte:

; 503  :     if (x < -128 || x > 127){

  0002d	83 7c 24 20 80	 cmp	 DWORD PTR x$[rsp], -128	; ffffffffffffff80H
  00032	7c 07		 jl	 SHORT $LN1@np_byte
  00034	83 7c 24 20 7f	 cmp	 DWORD PTR x$[rsp], 127	; 0000007fH
  00039	7e 1a		 jle	 SHORT $LN2@np_byte
$LN1@np_byte:

; 504  :         PyErr_SetString(StructError,
; 505  :                         "byte format requires -128 <= number <= 127");

  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@HPOFFIBE@byte?5format?5requires?5?9128?5?$DM?$DN?5num@
  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00049	e8 00 00 00 00	 call	 PyErr_SetString

; 506  :         return -1;

  0004e	b8 ff ff ff ff	 mov	 eax, -1
  00053	eb 0e		 jmp	 SHORT $LN4@np_byte
$LN2@np_byte:

; 507  :     }
; 508  :     *p = (char)x;

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  0005a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR x$[rsp]
  0005f	88 08		 mov	 BYTE PTR [rax], cl

; 509  :     return 0;

  00061	33 c0		 xor	 eax, eax
$LN4@np_byte:

; 510  : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
np_byte	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@ ; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_long DD imagerel get_long
	DD	imagerel get_long+200
	DD	imagerel $unwind$get_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_long DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@ DB 'argument out of rang'
	DB	'e', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'v'
	DB	00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT get_long
_TEXT	SEGMENT
x$ = 32
v$ = 64
p$ = 72
get_long PROC						; COMDAT

; 125  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 126  :     long x;
; 127  : 
; 128  :     v = get_pylong(v);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00013	e8 00 00 00 00	 call	 get_pylong
  00018	48 89 44 24 40	 mov	 QWORD PTR v$[rsp], rax

; 129  :     if (v == NULL)

  0001d	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  00023	75 0a		 jne	 SHORT $LN3@get_long

; 130  :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 94 00 00 00	 jmp	 $LN4@get_long
$LN3@get_long:

; 131  :     assert(PyLong_Check(v));

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00043	85 c0		 test	 eax, eax
  00045	75 1c		 jne	 SHORT $LN6@get_long
  00047	41 b8 83 00 00
	00		 mov	 r8d, 131		; 00000083H
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN6@get_long:

; 132  :     x = PyLong_AsLong(v);

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00068	e8 00 00 00 00	 call	 PyLong_AsLong
  0006d	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 133  :     Py_DECREF(v);

  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00076	e8 00 00 00 00	 call	 _Py_DecRef

; 134  :     if (x == (long)-1 && PyErr_Occurred()) {

  0007b	83 7c 24 20 ff	 cmp	 DWORD PTR x$[rsp], -1
  00080	75 34		 jne	 SHORT $LN2@get_long
  00082	e8 00 00 00 00	 call	 PyErr_Occurred
  00087	48 85 c0	 test	 rax, rax
  0008a	74 2a		 je	 SHORT $LN2@get_long

; 135  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  0008c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00093	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00098	85 c0		 test	 eax, eax
  0009a	74 13		 je	 SHORT $LN1@get_long

; 136  :             PyErr_SetString(StructError,
; 137  :                             "argument out of range");

  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000aa	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_long:

; 138  :         return -1;

  000af	b8 ff ff ff ff	 mov	 eax, -1
  000b4	eb 0d		 jmp	 SHORT $LN4@get_long
$LN2@get_long:

; 139  :     }
; 140  :     *p = x;

  000b6	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  000bb	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  000bf	89 08		 mov	 DWORD PTR [rax], ecx

; 141  :     return 0;

  000c1	33 c0		 xor	 eax, eax
$LN4@get_long:

; 142  : }

  000c3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c7	c3		 ret	 0
get_long ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0CE@MJBIACHN@required?5argument?5is?5not?5an?5inte@ ; `string'
PUBLIC	??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PyNumber_Index:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_struct.c
pdata	SEGMENT
$pdata$get_pylong DD imagerel get_pylong
	DD	imagerel get_pylong+240
	DD	imagerel $unwind$get_pylong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_pylong DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0CE@MJBIACHN@required?5argument?5is?5not?5an?5inte@
CONST	SEGMENT
??_C@_0CE@MJBIACHN@required?5argument?5is?5not?5an?5inte@ DB 'required ar'
	DB	'gument is not an integer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'v'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT get_pylong
_TEXT	SEGMENT
v$ = 48
get_pylong PROC						; COMDAT

; 98   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 99   :     assert(v != NULL);

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  0000f	75 1c		 jne	 SHORT $LN8@get_pylong
  00011	41 b8 63 00 00
	00		 mov	 r8d, 99			; 00000063H
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002b	33 c0		 xor	 eax, eax
$LN8@get_pylong:

; 100  :     if (!PyLong_Check(v)) {

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  00032	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00036	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003c	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00041	85 c0		 test	 eax, eax
  00043	75 63		 jne	 SHORT $LN5@get_pylong

; 101  :         /* Not an integer;  try to use __index__ to convert. */
; 102  :         if (PyIndex_Check(v)) {

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0004a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004e	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00056	74 37		 je	 SHORT $LN4@get_pylong
  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0005d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00061	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00068	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00070	74 1d		 je	 SHORT $LN4@get_pylong

; 103  :             v = PyNumber_Index(v);

  00072	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00077	e8 00 00 00 00	 call	 PyNumber_Index
  0007c	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax

; 104  :             if (v == NULL)

  00081	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  00087	75 04		 jne	 SHORT $LN3@get_pylong

; 105  :                 return NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	eb 5e		 jmp	 SHORT $LN6@get_pylong
$LN3@get_pylong:

; 106  :         }
; 107  :         else {

  0008d	eb 17		 jmp	 SHORT $LN2@get_pylong
$LN4@get_pylong:

; 108  :             PyErr_SetString(StructError,
; 109  :                             "required argument is not an integer");

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MJBIACHN@required?5argument?5is?5not?5an?5inte@
  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0009d	e8 00 00 00 00	 call	 PyErr_SetString

; 110  :             return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	eb 45		 jmp	 SHORT $LN6@get_pylong
$LN2@get_pylong:

; 111  :         }
; 112  :     }
; 113  :     else

  000a6	eb 0a		 jmp	 SHORT $LN1@get_pylong
$LN5@get_pylong:

; 114  :         Py_INCREF(v);

  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  000ad	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@get_pylong:

; 115  : 
; 116  :     assert(PyLong_Check(v));

  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  000b7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000bb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000c1	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000c6	85 c0		 test	 eax, eax
  000c8	75 1c		 jne	 SHORT $LN9@get_pylong
  000ca	41 b8 74 00 00
	00		 mov	 r8d, 116		; 00000074H
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e4	33 c0		 xor	 eax, eax
$LN9@get_pylong:

; 117  :     return v;

  000e6	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
$LN6@get_pylong:

; 118  : }

  000eb	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ef	c3		 ret	 0
get_pylong ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@GHDNPKL@ubyte?5format?5requires?50?5?$DM?$DN?5numbe@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\modules\_struct.c
pdata	SEGMENT
$pdata$np_ubyte DD imagerel np_ubyte
	DD	imagerel np_ubyte+107
	DD	imagerel $unwind$np_ubyte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_ubyte DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CJ@GHDNPKL@ubyte?5format?5requires?50?5?$DM?$DN?5numbe@
CONST	SEGMENT
??_C@_0CJ@GHDNPKL@ubyte?5format?5requires?50?5?$DM?$DN?5numbe@ DB 'ubyte '
	DB	'format requires 0 <= number <= 255', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT np_ubyte
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_ubyte PROC						; COMDAT

; 514  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 515  :     long x;
; 516  :     if (get_long(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_long
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN3@np_ubyte

; 517  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 39		 jmp	 SHORT $LN4@np_ubyte
$LN3@np_ubyte:

; 518  :     if (x < 0 || x > 255){

  0002d	83 7c 24 20 00	 cmp	 DWORD PTR x$[rsp], 0
  00032	7c 0a		 jl	 SHORT $LN1@np_ubyte
  00034	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  0003c	7e 1a		 jle	 SHORT $LN2@np_ubyte
$LN1@np_ubyte:

; 519  :         PyErr_SetString(StructError,
; 520  :                         "ubyte format requires 0 <= number <= 255");

  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@GHDNPKL@ubyte?5format?5requires?50?5?$DM?$DN?5numbe@
  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0004c	e8 00 00 00 00	 call	 PyErr_SetString

; 521  :         return -1;

  00051	b8 ff ff ff ff	 mov	 eax, -1
  00056	eb 0e		 jmp	 SHORT $LN4@np_ubyte
$LN2@np_ubyte:

; 522  :     }
; 523  :     *p = (char)x;

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  0005d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR x$[rsp]
  00062	88 08		 mov	 BYTE PTR [rax], cl

; 524  :     return 0;

  00064	33 c0		 xor	 eax, eax
$LN4@np_ubyte:

; 525  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
np_ubyte ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@FMJFJOIA@char?5format?5requires?5a?5bytes?5obj@ ; `string'
EXTRN	PyBytes_AsString:PROC
EXTRN	PyBytes_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_char DD imagerel np_char
	DD	imagerel np_char+112
	DD	imagerel $unwind$np_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_char DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_0DA@FMJFJOIA@char?5format?5requires?5a?5bytes?5obj@
CONST	SEGMENT
??_C@_0DA@FMJFJOIA@char?5format?5requires?5a?5bytes?5obj@ DB 'char format'
	DB	' requires a bytes object of length 1', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT np_char
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
np_char	PROC						; COMDAT

; 529  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 530  :     if (!PyBytes_Check(v) || PyBytes_Size(v) != 1) {

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR v$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00027	85 c0		 test	 eax, eax
  00029	74 10		 je	 SHORT $LN1@np_char
  0002b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 PyBytes_Size
  00035	48 83 f8 01	 cmp	 rax, 1
  00039	74 1a		 je	 SHORT $LN2@np_char
$LN1@np_char:

; 531  :         PyErr_SetString(StructError,
; 532  :                         "char format requires a bytes object of length 1");

  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@FMJFJOIA@char?5format?5requires?5a?5bytes?5obj@
  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00049	e8 00 00 00 00	 call	 PyErr_SetString

; 533  :         return -1;

  0004e	b8 ff ff ff ff	 mov	 eax, -1
  00053	eb 16		 jmp	 SHORT $LN3@np_char
$LN2@np_char:

; 534  :     }
; 535  :     *p = *PyBytes_AsString(v);

  00055	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  0005a	e8 00 00 00 00	 call	 PyBytes_AsString
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00064	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00067	88 01		 mov	 BYTE PTR [rcx], al

; 536  :     return 0;

  00069	33 c0		 xor	 eax, eax
$LN3@np_char:

; 537  : }

  0006b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006f	c3		 ret	 0
np_char	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@KNANBGPI@short?5format?5requires?5SHRT_MIN?5?$DM@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_short DD imagerel np_short
	DD	imagerel np_short+129
	DD	imagerel $unwind$np_short
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_short DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0DF@KNANBGPI@short?5format?5requires?5SHRT_MIN?5?$DM@
CONST	SEGMENT
??_C@_0DF@KNANBGPI@short?5format?5requires?5SHRT_MIN?5?$DM@ DB 'short for'
	DB	'mat requires SHRT_MIN <= number <= SHRT_MAX', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT np_short
_TEXT	SEGMENT
y$ = 32
x$ = 36
p$ = 64
v$ = 72
f$ = 80
np_short PROC						; COMDAT

; 541  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 542  :     long x;
; 543  :     short y;
; 544  :     if (get_long(v, &x) < 0)

  00013	48 8d 54 24 24	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_long
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN3@np_short

; 545  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 4f		 jmp	 SHORT $LN4@np_short
$LN3@np_short:

; 546  :     if (x < SHRT_MIN || x > SHRT_MAX){

  0002d	81 7c 24 24 00
	80 ff ff	 cmp	 DWORD PTR x$[rsp], -32768 ; ffffffffffff8000H
  00035	7c 0a		 jl	 SHORT $LN1@np_short
  00037	81 7c 24 24 ff
	7f 00 00	 cmp	 DWORD PTR x$[rsp], 32767 ; 00007fffH
  0003f	7e 1a		 jle	 SHORT $LN2@np_short
$LN1@np_short:

; 547  :         PyErr_SetString(StructError,
; 548  :                         "short format requires " STRINGIFY(SHRT_MIN)
; 549  :                         " <= number <= " STRINGIFY(SHRT_MAX));

  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@KNANBGPI@short?5format?5requires?5SHRT_MIN?5?$DM@
  00048	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0004f	e8 00 00 00 00	 call	 PyErr_SetString

; 550  :         return -1;

  00054	b8 ff ff ff ff	 mov	 eax, -1
  00059	eb 21		 jmp	 SHORT $LN4@np_short
$LN2@np_short:

; 551  :     }
; 552  :     y = (short)x;

  0005b	0f b7 44 24 24	 movzx	 eax, WORD PTR x$[rsp]
  00060	66 89 44 24 20	 mov	 WORD PTR y$[rsp], ax

; 553  :     memcpy(p, (char *)&y, sizeof y);

  00065	41 b8 02 00 00
	00		 mov	 r8d, 2
  0006b	48 8d 54 24 20	 lea	 rdx, QWORD PTR y$[rsp]
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  00075	e8 00 00 00 00	 call	 memcpy

; 554  :     return 0;

  0007a	33 c0		 xor	 eax, eax
$LN4@np_short:

; 555  : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
np_short ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@JHGGNNCI@ushort?5format?5requires?50?5?$DM?$DN?5numb@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_ushort DD imagerel np_ushort
	DD	imagerel np_ushort+126
	DD	imagerel $unwind$np_ushort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_ushort DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0DA@JHGGNNCI@ushort?5format?5requires?50?5?$DM?$DN?5numb@
CONST	SEGMENT
??_C@_0DA@JHGGNNCI@ushort?5format?5requires?50?5?$DM?$DN?5numb@ DB 'ushor'
	DB	't format requires 0 <= number <= USHRT_MAX', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT np_ushort
_TEXT	SEGMENT
y$ = 32
x$ = 36
p$ = 64
v$ = 72
f$ = 80
np_ushort PROC						; COMDAT

; 559  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 560  :     long x;
; 561  :     unsigned short y;
; 562  :     if (get_long(v, &x) < 0)

  00013	48 8d 54 24 24	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_long
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN3@np_ushort

; 563  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 4c		 jmp	 SHORT $LN4@np_ushort
$LN3@np_ushort:

; 564  :     if (x < 0 || x > USHRT_MAX){

  0002d	83 7c 24 24 00	 cmp	 DWORD PTR x$[rsp], 0
  00032	7c 0a		 jl	 SHORT $LN1@np_ushort
  00034	81 7c 24 24 ff
	ff 00 00	 cmp	 DWORD PTR x$[rsp], 65535 ; 0000ffffH
  0003c	7e 1a		 jle	 SHORT $LN2@np_ushort
$LN1@np_ushort:

; 565  :         PyErr_SetString(StructError,
; 566  :                         "ushort format requires 0 <= number <= " STRINGIFY(USHRT_MAX));

  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@JHGGNNCI@ushort?5format?5requires?50?5?$DM?$DN?5numb@
  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0004c	e8 00 00 00 00	 call	 PyErr_SetString

; 567  :         return -1;

  00051	b8 ff ff ff ff	 mov	 eax, -1
  00056	eb 21		 jmp	 SHORT $LN4@np_ushort
$LN2@np_ushort:

; 568  :     }
; 569  :     y = (unsigned short)x;

  00058	0f b7 44 24 24	 movzx	 eax, WORD PTR x$[rsp]
  0005d	66 89 44 24 20	 mov	 WORD PTR y$[rsp], ax

; 570  :     memcpy(p, (char *)&y, sizeof y);

  00062	41 b8 02 00 00
	00		 mov	 r8d, 2
  00068	48 8d 54 24 20	 lea	 rdx, QWORD PTR y$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  00072	e8 00 00 00 00	 call	 memcpy

; 571  :     return 0;

  00077	33 c0		 xor	 eax, eax
$LN4@np_ushort:

; 572  : }

  00079	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007d	c3		 ret	 0
np_ushort ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_int DD imagerel np_int
	DD	imagerel np_int+81
	DD	imagerel $unwind$np_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_int DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT np_int
_TEXT	SEGMENT
y$ = 32
x$ = 36
p$ = 64
v$ = 72
f$ = 80
np_int	PROC						; COMDAT

; 576  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 577  :     long x;
; 578  :     int y;
; 579  :     if (get_long(v, &x) < 0)

  00013	48 8d 54 24 24	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_long
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN1@np_int

; 580  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 1f		 jmp	 SHORT $LN2@np_int
$LN1@np_int:

; 581  : #if (SIZEOF_LONG > SIZEOF_INT)
; 582  :     if ((x < ((long)INT_MIN)) || (x > ((long)INT_MAX)))
; 583  :         RANGE_ERROR(x, f, 0, -1);
; 584  : #endif
; 585  :     y = (int)x;

  0002d	8b 44 24 24	 mov	 eax, DWORD PTR x$[rsp]
  00031	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax

; 586  :     memcpy(p, (char *)&y, sizeof y);

  00035	41 b8 04 00 00
	00		 mov	 r8d, 4
  0003b	48 8d 54 24 20	 lea	 rdx, QWORD PTR y$[rsp]
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  00045	e8 00 00 00 00	 call	 memcpy

; 587  :     return 0;

  0004a	33 c0		 xor	 eax, eax
$LN2@np_int:

; 588  : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
np_int	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_uint DD imagerel np_uint
	DD	imagerel np_uint+81
	DD	imagerel $unwind$np_uint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_uint DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT np_uint
_TEXT	SEGMENT
y$ = 32
x$ = 36
p$ = 64
v$ = 72
f$ = 80
np_uint	PROC						; COMDAT

; 592  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 593  :     unsigned long x;
; 594  :     unsigned int y;
; 595  :     if (get_ulong(v, &x) < 0)

  00013	48 8d 54 24 24	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_ulong
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN1@np_uint

; 596  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 1f		 jmp	 SHORT $LN2@np_uint
$LN1@np_uint:

; 597  :     y = (unsigned int)x;

  0002d	8b 44 24 24	 mov	 eax, DWORD PTR x$[rsp]
  00031	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax

; 598  : #if (SIZEOF_LONG > SIZEOF_INT)
; 599  :     if (x > ((unsigned long)UINT_MAX))
; 600  :         RANGE_ERROR(y, f, 1, -1);
; 601  : #endif
; 602  :     memcpy(p, (char *)&y, sizeof y);

  00035	41 b8 04 00 00
	00		 mov	 r8d, 4
  0003b	48 8d 54 24 20	 lea	 rdx, QWORD PTR y$[rsp]
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  00045	e8 00 00 00 00	 call	 memcpy

; 603  :     return 0;

  0004a	33 c0		 xor	 eax, eax
$LN2@np_uint:

; 604  : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
np_uint	ENDP
_TEXT	ENDS
EXTRN	PyLong_AsUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_ulong DD imagerel get_ulong
	DD	imagerel get_ulong+200
	DD	imagerel $unwind$get_ulong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_ulong DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_ulong
_TEXT	SEGMENT
x$ = 32
v$ = 64
p$ = 72
get_ulong PROC						; COMDAT

; 149  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 150  :     unsigned long x;
; 151  : 
; 152  :     v = get_pylong(v);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00013	e8 00 00 00 00	 call	 get_pylong
  00018	48 89 44 24 40	 mov	 QWORD PTR v$[rsp], rax

; 153  :     if (v == NULL)

  0001d	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  00023	75 0a		 jne	 SHORT $LN3@get_ulong

; 154  :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 94 00 00 00	 jmp	 $LN4@get_ulong
$LN3@get_ulong:

; 155  :     assert(PyLong_Check(v));

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00043	85 c0		 test	 eax, eax
  00045	75 1c		 jne	 SHORT $LN6@get_ulong
  00047	41 b8 9b 00 00
	00		 mov	 r8d, 155		; 0000009bH
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN6@get_ulong:

; 156  :     x = PyLong_AsUnsignedLong(v);

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00068	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  0006d	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 157  :     Py_DECREF(v);

  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00076	e8 00 00 00 00	 call	 _Py_DecRef

; 158  :     if (x == (unsigned long)-1 && PyErr_Occurred()) {

  0007b	83 7c 24 20 ff	 cmp	 DWORD PTR x$[rsp], -1	; ffffffffH
  00080	75 34		 jne	 SHORT $LN2@get_ulong
  00082	e8 00 00 00 00	 call	 PyErr_Occurred
  00087	48 85 c0	 test	 rax, rax
  0008a	74 2a		 je	 SHORT $LN2@get_ulong

; 159  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  0008c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00093	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00098	85 c0		 test	 eax, eax
  0009a	74 13		 je	 SHORT $LN1@get_ulong

; 160  :             PyErr_SetString(StructError,
; 161  :                             "argument out of range");

  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000aa	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_ulong:

; 162  :         return -1;

  000af	b8 ff ff ff ff	 mov	 eax, -1
  000b4	eb 0d		 jmp	 SHORT $LN4@get_ulong
$LN2@get_ulong:

; 163  :     }
; 164  :     *p = x;

  000b6	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  000bb	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  000bf	89 08		 mov	 DWORD PTR [rax], ecx

; 165  :     return 0;

  000c1	33 c0		 xor	 eax, eax
$LN4@get_ulong:

; 166  : }

  000c3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c7	c3		 ret	 0
get_ulong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_long DD imagerel np_long
	DD	imagerel np_long+73
	DD	imagerel $unwind$np_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_long DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT np_long
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_long	PROC						; COMDAT

; 608  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 609  :     long x;
; 610  :     if (get_long(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_long
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN1@np_long

; 611  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 17		 jmp	 SHORT $LN2@np_long
$LN1@np_long:

; 612  :     memcpy(p, (char *)&x, sizeof x);

  0002d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00033	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  0003d	e8 00 00 00 00	 call	 memcpy

; 613  :     return 0;

  00042	33 c0		 xor	 eax, eax
$LN2@np_long:

; 614  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
np_long	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_ulong DD imagerel np_ulong
	DD	imagerel np_ulong+73
	DD	imagerel $unwind$np_ulong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_ulong DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT np_ulong
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_ulong PROC						; COMDAT

; 618  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 619  :     unsigned long x;
; 620  :     if (get_ulong(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_ulong
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN1@np_ulong

; 621  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 17		 jmp	 SHORT $LN2@np_ulong
$LN1@np_ulong:

; 622  :     memcpy(p, (char *)&x, sizeof x);

  0002d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00033	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  0003d	e8 00 00 00 00	 call	 memcpy

; 623  :     return 0;

  00042	33 c0		 xor	 eax, eax
$LN2@np_ulong:

; 624  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
np_ulong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_ssize_t DD imagerel np_ssize_t
	DD	imagerel np_ssize_t+73
	DD	imagerel $unwind$np_ssize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_ssize_t DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT np_ssize_t
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_ssize_t PROC						; COMDAT

; 628  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 629  :     Py_ssize_t x;
; 630  :     if (get_ssize_t(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_ssize_t
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN1@np_ssize_t

; 631  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 17		 jmp	 SHORT $LN2@np_ssize_t
$LN1@np_ssize_t:

; 632  :     memcpy(p, (char *)&x, sizeof x);

  0002d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00033	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  0003d	e8 00 00 00 00	 call	 memcpy

; 633  :     return 0;

  00042	33 c0		 xor	 eax, eax
$LN2@np_ssize_t:

; 634  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
np_ssize_t ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_ssize_t DD imagerel get_ssize_t
	DD	imagerel get_ssize_t+204
	DD	imagerel $unwind$get_ssize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_ssize_t DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_ssize_t
_TEXT	SEGMENT
x$ = 32
v$ = 64
p$ = 72
get_ssize_t PROC					; COMDAT

; 222  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 223  :     Py_ssize_t x;
; 224  : 
; 225  :     v = get_pylong(v);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00013	e8 00 00 00 00	 call	 get_pylong
  00018	48 89 44 24 40	 mov	 QWORD PTR v$[rsp], rax

; 226  :     if (v == NULL)

  0001d	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  00023	75 0a		 jne	 SHORT $LN3@get_ssize_

; 227  :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 98 00 00 00	 jmp	 $LN4@get_ssize_
$LN3@get_ssize_:

; 228  :     assert(PyLong_Check(v));

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00043	85 c0		 test	 eax, eax
  00045	75 1c		 jne	 SHORT $LN6@get_ssize_
  00047	41 b8 e4 00 00
	00		 mov	 r8d, 228		; 000000e4H
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN6@get_ssize_:

; 229  :     x = PyLong_AsSsize_t(v);

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00068	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0006d	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 230  :     Py_DECREF(v);

  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00077	e8 00 00 00 00	 call	 _Py_DecRef

; 231  :     if (x == (Py_ssize_t)-1 && PyErr_Occurred()) {

  0007c	48 83 7c 24 20
	ff		 cmp	 QWORD PTR x$[rsp], -1
  00082	75 34		 jne	 SHORT $LN2@get_ssize_
  00084	e8 00 00 00 00	 call	 PyErr_Occurred
  00089	48 85 c0	 test	 rax, rax
  0008c	74 2a		 je	 SHORT $LN2@get_ssize_

; 232  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  0008e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00095	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0009a	85 c0		 test	 eax, eax
  0009c	74 13		 je	 SHORT $LN1@get_ssize_

; 233  :             PyErr_SetString(StructError,
; 234  :                             "argument out of range");

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000ac	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_ssize_:

; 235  :         return -1;

  000b1	b8 ff ff ff ff	 mov	 eax, -1
  000b6	eb 0f		 jmp	 SHORT $LN4@get_ssize_
$LN2@get_ssize_:

; 236  :     }
; 237  :     *p = x;

  000b8	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  000c2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 238  :     return 0;

  000c5	33 c0		 xor	 eax, eax
$LN4@get_ssize_:

; 239  : }

  000c7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cb	c3		 ret	 0
get_ssize_t ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_size_t DD imagerel np_size_t
	DD	imagerel np_size_t+73
	DD	imagerel $unwind$np_size_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_size_t DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT np_size_t
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_size_t PROC						; COMDAT

; 638  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 639  :     size_t x;
; 640  :     if (get_size_t(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_size_t
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN1@np_size_t

; 641  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 17		 jmp	 SHORT $LN2@np_size_t
$LN1@np_size_t:

; 642  :     memcpy(p, (char *)&x, sizeof x);

  0002d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00033	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  0003d	e8 00 00 00 00	 call	 memcpy

; 643  :     return 0;

  00042	33 c0		 xor	 eax, eax
$LN2@np_size_t:

; 644  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
np_size_t ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_size_t DD imagerel get_size_t
	DD	imagerel get_size_t+204
	DD	imagerel $unwind$get_size_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_size_t DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_size_t
_TEXT	SEGMENT
x$ = 32
v$ = 64
p$ = 72
get_size_t PROC						; COMDAT

; 245  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 246  :     size_t x;
; 247  : 
; 248  :     v = get_pylong(v);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00013	e8 00 00 00 00	 call	 get_pylong
  00018	48 89 44 24 40	 mov	 QWORD PTR v$[rsp], rax

; 249  :     if (v == NULL)

  0001d	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  00023	75 0a		 jne	 SHORT $LN3@get_size_t

; 250  :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 98 00 00 00	 jmp	 $LN4@get_size_t
$LN3@get_size_t:

; 251  :     assert(PyLong_Check(v));

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00043	85 c0		 test	 eax, eax
  00045	75 1c		 jne	 SHORT $LN6@get_size_t
  00047	41 b8 fb 00 00
	00		 mov	 r8d, 251		; 000000fbH
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN6@get_size_t:

; 252  :     x = PyLong_AsSize_t(v);

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00068	e8 00 00 00 00	 call	 PyLong_AsSize_t
  0006d	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 253  :     Py_DECREF(v);

  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00077	e8 00 00 00 00	 call	 _Py_DecRef

; 254  :     if (x == (size_t)-1 && PyErr_Occurred()) {

  0007c	48 83 7c 24 20
	ff		 cmp	 QWORD PTR x$[rsp], -1
  00082	75 34		 jne	 SHORT $LN2@get_size_t
  00084	e8 00 00 00 00	 call	 PyErr_Occurred
  00089	48 85 c0	 test	 rax, rax
  0008c	74 2a		 je	 SHORT $LN2@get_size_t

; 255  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  0008e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00095	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0009a	85 c0		 test	 eax, eax
  0009c	74 13		 je	 SHORT $LN1@get_size_t

; 256  :             PyErr_SetString(StructError,
; 257  :                             "argument out of range");

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000ac	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_size_t:

; 258  :         return -1;

  000b1	b8 ff ff ff ff	 mov	 eax, -1
  000b6	eb 0f		 jmp	 SHORT $LN4@get_size_t
$LN2@get_size_t:

; 259  :     }
; 260  :     *p = x;

  000b8	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  000c2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 261  :     return 0;

  000c5	33 c0		 xor	 eax, eax
$LN4@get_size_t:

; 262  : }

  000c7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cb	c3		 ret	 0
get_size_t ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_longlong DD imagerel np_longlong
	DD	imagerel np_longlong+73
	DD	imagerel $unwind$np_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_longlong DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT np_longlong
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_longlong PROC					; COMDAT

; 650  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 651  :     PY_LONG_LONG x;
; 652  :     if (get_longlong(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_longlong
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN1@np_longlon

; 653  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 17		 jmp	 SHORT $LN2@np_longlon
$LN1@np_longlon:

; 654  :     memcpy(p, (char *)&x, sizeof x);

  0002d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00033	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  0003d	e8 00 00 00 00	 call	 memcpy

; 655  :     return 0;

  00042	33 c0		 xor	 eax, eax
$LN2@np_longlon:

; 656  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
np_longlong ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_longlong DD imagerel get_longlong
	DD	imagerel get_longlong+204
	DD	imagerel $unwind$get_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_longlong DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_longlong
_TEXT	SEGMENT
x$ = 32
v$ = 64
p$ = 72
get_longlong PROC					; COMDAT

; 174  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 175  :     PY_LONG_LONG x;
; 176  : 
; 177  :     v = get_pylong(v);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00013	e8 00 00 00 00	 call	 get_pylong
  00018	48 89 44 24 40	 mov	 QWORD PTR v$[rsp], rax

; 178  :     if (v == NULL)

  0001d	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  00023	75 0a		 jne	 SHORT $LN3@get_longlo

; 179  :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 98 00 00 00	 jmp	 $LN4@get_longlo
$LN3@get_longlo:

; 180  :     assert(PyLong_Check(v));

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00043	85 c0		 test	 eax, eax
  00045	75 1c		 jne	 SHORT $LN6@get_longlo
  00047	41 b8 b4 00 00
	00		 mov	 r8d, 180		; 000000b4H
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN6@get_longlo:

; 181  :     x = PyLong_AsLongLong(v);

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00068	e8 00 00 00 00	 call	 PyLong_AsLongLong
  0006d	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 182  :     Py_DECREF(v);

  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00077	e8 00 00 00 00	 call	 _Py_DecRef

; 183  :     if (x == (PY_LONG_LONG)-1 && PyErr_Occurred()) {

  0007c	48 83 7c 24 20
	ff		 cmp	 QWORD PTR x$[rsp], -1
  00082	75 34		 jne	 SHORT $LN2@get_longlo
  00084	e8 00 00 00 00	 call	 PyErr_Occurred
  00089	48 85 c0	 test	 rax, rax
  0008c	74 2a		 je	 SHORT $LN2@get_longlo

; 184  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  0008e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00095	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0009a	85 c0		 test	 eax, eax
  0009c	74 13		 je	 SHORT $LN1@get_longlo

; 185  :             PyErr_SetString(StructError,
; 186  :                             "argument out of range");

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000ac	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_longlo:

; 187  :         return -1;

  000b1	b8 ff ff ff ff	 mov	 eax, -1
  000b6	eb 0f		 jmp	 SHORT $LN4@get_longlo
$LN2@get_longlo:

; 188  :     }
; 189  :     *p = x;

  000b8	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  000c2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 190  :     return 0;

  000c5	33 c0		 xor	 eax, eax
$LN4@get_longlo:

; 191  : }

  000c7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cb	c3		 ret	 0
get_longlong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_ulonglong DD imagerel np_ulonglong
	DD	imagerel np_ulonglong+73
	DD	imagerel $unwind$np_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_ulonglong DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT np_ulonglong
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_ulonglong PROC					; COMDAT

; 660  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 661  :     unsigned PY_LONG_LONG x;
; 662  :     if (get_ulonglong(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_ulonglong
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN1@np_ulonglo

; 663  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 17		 jmp	 SHORT $LN2@np_ulonglo
$LN1@np_ulonglo:

; 664  :     memcpy(p, (char *)&x, sizeof x);

  0002d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00033	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  0003d	e8 00 00 00 00	 call	 memcpy

; 665  :     return 0;

  00042	33 c0		 xor	 eax, eax
$LN2@np_ulonglo:

; 666  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
np_ulonglong ENDP
_TEXT	ENDS
EXTRN	PyLong_AsUnsignedLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_ulonglong DD imagerel get_ulonglong
	DD	imagerel get_ulonglong+204
	DD	imagerel $unwind$get_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_ulonglong DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_ulonglong
_TEXT	SEGMENT
x$ = 32
v$ = 64
p$ = 72
get_ulonglong PROC					; COMDAT

; 197  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 198  :     unsigned PY_LONG_LONG x;
; 199  : 
; 200  :     v = get_pylong(v);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00013	e8 00 00 00 00	 call	 get_pylong
  00018	48 89 44 24 40	 mov	 QWORD PTR v$[rsp], rax

; 201  :     if (v == NULL)

  0001d	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  00023	75 0a		 jne	 SHORT $LN3@get_ulongl

; 202  :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 98 00 00 00	 jmp	 $LN4@get_ulongl
$LN3@get_ulongl:

; 203  :     assert(PyLong_Check(v));

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00043	85 c0		 test	 eax, eax
  00045	75 1c		 jne	 SHORT $LN6@get_ulongl
  00047	41 b8 cb 00 00
	00		 mov	 r8d, 203		; 000000cbH
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN6@get_ulongl:

; 204  :     x = PyLong_AsUnsignedLongLong(v);

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00068	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongLong
  0006d	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 205  :     Py_DECREF(v);

  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00077	e8 00 00 00 00	 call	 _Py_DecRef

; 206  :     if (x == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred()) {

  0007c	48 83 7c 24 20
	ff		 cmp	 QWORD PTR x$[rsp], -1
  00082	75 34		 jne	 SHORT $LN2@get_ulongl
  00084	e8 00 00 00 00	 call	 PyErr_Occurred
  00089	48 85 c0	 test	 rax, rax
  0008c	74 2a		 je	 SHORT $LN2@get_ulongl

; 207  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  0008e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00095	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0009a	85 c0		 test	 eax, eax
  0009c	74 13		 je	 SHORT $LN1@get_ulongl

; 208  :             PyErr_SetString(StructError,
; 209  :                             "argument out of range");

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000ac	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_ulongl:

; 210  :         return -1;

  000b1	b8 ff ff ff ff	 mov	 eax, -1
  000b6	eb 0f		 jmp	 SHORT $LN4@get_ulongl
$LN2@get_ulongl:

; 211  :     }
; 212  :     *p = x;

  000b8	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  000c2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 213  :     return 0;

  000c5	33 c0		 xor	 eax, eax
$LN4@get_ulongl:

; 214  : }

  000c7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cb	c3		 ret	 0
get_ulonglong ENDP
_TEXT	ENDS
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_bool DD imagerel np_bool
	DD	imagerel np_bool+84
	DD	imagerel $unwind$np_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_bool DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT np_bool
_TEXT	SEGMENT
x$ = 32
y$ = 36
p$ = 64
v$ = 72
f$ = 80
np_bool	PROC						; COMDAT

; 672  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 673  :     int y;
; 674  :     BOOL_TYPE x;
; 675  :     y = PyObject_IsTrue(v);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 PyObject_IsTrue
  0001d	89 44 24 24	 mov	 DWORD PTR y$[rsp], eax

; 676  :     if (y < 0)

  00021	83 7c 24 24 00	 cmp	 DWORD PTR y$[rsp], 0
  00026	7d 07		 jge	 SHORT $LN1@np_bool

; 677  :         return -1;

  00028	b8 ff ff ff ff	 mov	 eax, -1
  0002d	eb 20		 jmp	 SHORT $LN2@np_bool
$LN1@np_bool:

; 678  :     x = y;

  0002f	0f b6 44 24 24	 movzx	 eax, BYTE PTR y$[rsp]
  00034	88 44 24 20	 mov	 BYTE PTR x$[rsp], al

; 679  :     memcpy(p, (char *)&x, sizeof x);

  00038	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003e	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  00048	e8 00 00 00 00	 call	 memcpy

; 680  :     return 0;

  0004d	33 c0		 xor	 eax, eax
$LN2@np_bool:

; 681  : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
np_bool	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@ ; `string'
PUBLIC	__real@bf800000
EXTRN	PyFloat_AsDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_float DD imagerel np_float
	DD	imagerel np_float+120
	DD	imagerel $unwind$np_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_float DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
CONST	SEGMENT
??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@ DB 'required ar'
	DB	'gument is not a float', 00H			; `string'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT np_float
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_float PROC						; COMDAT

; 685  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 686  :     float x = (float)PyFloat_AsDouble(v);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0001d	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00021	f3 0f 11 44 24
	20		 movss	 DWORD PTR x$[rsp], xmm0

; 687  :     if (x == -1 && PyErr_Occurred()) {

  00027	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR x$[rsp]
  0002d	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@bf800000
  00034	7a 26		 jp	 SHORT $LN1@np_float
  00036	75 24		 jne	 SHORT $LN1@np_float
  00038	e8 00 00 00 00	 call	 PyErr_Occurred
  0003d	48 85 c0	 test	 rax, rax
  00040	74 1a		 je	 SHORT $LN1@np_float

; 688  :         PyErr_SetString(StructError,
; 689  :                         "required argument is not a float");

  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  00049	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00050	e8 00 00 00 00	 call	 PyErr_SetString

; 690  :         return -1;

  00055	b8 ff ff ff ff	 mov	 eax, -1
  0005a	eb 17		 jmp	 SHORT $LN2@np_float
$LN1@np_float:

; 691  :     }
; 692  :     memcpy(p, (char *)&x, sizeof x);

  0005c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00062	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  0006c	e8 00 00 00 00	 call	 memcpy

; 693  :     return 0;

  00071	33 c0		 xor	 eax, eax
$LN2@np_float:

; 694  : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
np_float ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_double DD imagerel np_double
	DD	imagerel np_double+117
	DD	imagerel $unwind$np_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_double DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT np_double
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_double PROC						; COMDAT

; 698  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 699  :     double x = PyFloat_AsDouble(v);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0001d	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 700  :     if (x == -1 && PyErr_Occurred()) {

  00023	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00029	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00031	7a 26		 jp	 SHORT $LN1@np_double
  00033	75 24		 jne	 SHORT $LN1@np_double
  00035	e8 00 00 00 00	 call	 PyErr_Occurred
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 1a		 je	 SHORT $LN1@np_double

; 701  :         PyErr_SetString(StructError,
; 702  :                         "required argument is not a float");

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0004d	e8 00 00 00 00	 call	 PyErr_SetString

; 703  :         return -1;

  00052	b8 ff ff ff ff	 mov	 eax, -1
  00057	eb 17		 jmp	 SHORT $LN2@np_double
$LN1@np_double:

; 704  :     }
; 705  :     memcpy(p, (char *)&x, sizeof(double));

  00059	41 b8 08 00 00
	00		 mov	 r8d, 8
  0005f	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  00069	e8 00 00 00 00	 call	 memcpy

; 706  :     return 0;

  0006e	33 c0		 xor	 eax, eax
$LN2@np_double:

; 707  : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
np_double ENDP
_TEXT	ENDS
EXTRN	PyLong_AsVoidPtr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_void_p DD imagerel np_void_p
	DD	imagerel np_void_p+179
	DD	imagerel $unwind$np_void_p
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_void_p DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT np_void_p
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
np_void_p PROC						; COMDAT

; 711  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 712  :     void *x;
; 713  : 
; 714  :     v = get_pylong(v);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 get_pylong
  0001d	48 89 44 24 48	 mov	 QWORD PTR v$[rsp], rax

; 715  :     if (v == NULL)

  00022	48 83 7c 24 48
	00		 cmp	 QWORD PTR v$[rsp], 0
  00028	75 07		 jne	 SHORT $LN2@np_void_p

; 716  :         return -1;

  0002a	b8 ff ff ff ff	 mov	 eax, -1
  0002f	eb 7d		 jmp	 SHORT $LN3@np_void_p
$LN2@np_void_p:

; 717  :     assert(PyLong_Check(v));

  00031	48 8b 44 24 48	 mov	 rax, QWORD PTR v$[rsp]
  00036	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00040	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00045	85 c0		 test	 eax, eax
  00047	75 1c		 jne	 SHORT $LN5@np_void_p
  00049	41 b8 cd 02 00
	00		 mov	 r8d, 717		; 000002cdH
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00063	33 c0		 xor	 eax, eax
$LN5@np_void_p:

; 718  :     x = PyLong_AsVoidPtr(v);

  00065	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0006a	e8 00 00 00 00	 call	 PyLong_AsVoidPtr
  0006f	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 719  :     Py_DECREF(v);

  00074	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00079	e8 00 00 00 00	 call	 _Py_DecRef

; 720  :     if (x == NULL && PyErr_Occurred())

  0007e	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  00084	75 11		 jne	 SHORT $LN1@np_void_p
  00086	e8 00 00 00 00	 call	 PyErr_Occurred
  0008b	48 85 c0	 test	 rax, rax
  0008e	74 07		 je	 SHORT $LN1@np_void_p

; 721  :         return -1;

  00090	b8 ff ff ff ff	 mov	 eax, -1
  00095	eb 17		 jmp	 SHORT $LN3@np_void_p
$LN1@np_void_p:

; 722  :     memcpy(p, (char *)&x, sizeof x);

  00097	41 b8 08 00 00
	00		 mov	 r8d, 8
  0009d	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  000a7	e8 00 00 00 00	 call	 memcpy

; 723  :     return 0;

  000ac	33 c0		 xor	 eax, eax
$LN3@np_void_p:

; 724  : }

  000ae	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b2	c3		 ret	 0
np_void_p ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bu_int DD imagerel bu_int
	DD	imagerel bu_int+184
	DD	imagerel $unwind$bu_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bu_int DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bu_int
_TEXT	SEGMENT
x$ = 32
i$ = 40
bytes$ = 48
tv128 = 56
p$ = 80
f$ = 88
bu_int	PROC						; COMDAT

; 756  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 757  :     long x = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR x$[rsp], 0

; 758  :     Py_ssize_t i = f->size;

  00016	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0001b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 759  :     const unsigned char *bytes = (const unsigned char *)p;

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00029	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax
$LN4@bu_int:

; 760  :     do {
; 761  :         x = (x<<8) | *bytes++;

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00032	c1 e0 08	 shl	 eax, 8
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes$[rsp]
  0003a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0003d	0b c1		 or	 eax, ecx
  0003f	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR bytes$[rsp]
  00048	48 ff c0	 inc	 rax
  0004b	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax

; 762  :     } while (--i > 0);

  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00055	48 ff c8	 dec	 rax
  00058	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0005d	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00063	7f c9		 jg	 SHORT $LN4@bu_int

; 763  :     /* Extend the sign bit. */
; 764  :     if (SIZEOF_LONG > f->size)

  00065	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0006a	48 83 78 08 04	 cmp	 QWORD PTR [rax+8], 4
  0006f	7d 39		 jge	 SHORT $LN1@bu_int

; 765  :         x |= -(x & (1L << ((8 * f->size) - 1)));

  00071	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  00076	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007a	48 8d 04 c5 ff
	ff ff ff	 lea	 rax, QWORD PTR [rax*8-1]
  00082	b9 01 00 00 00	 mov	 ecx, 1
  00087	89 4c 24 38	 mov	 DWORD PTR tv128[rsp], ecx
  0008b	0f b6 c8	 movzx	 ecx, al
  0008e	8b 44 24 38	 mov	 eax, DWORD PTR tv128[rsp]
  00092	d3 e0		 shl	 eax, cl
  00094	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00098	23 c8		 and	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	f7 d8		 neg	 eax
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  000a2	0b c8		 or	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN1@bu_int:

; 766  :     return PyLong_FromLong(x);

  000aa	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  000ae	e8 00 00 00 00	 call	 PyLong_FromLong

; 767  : }

  000b3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b7	c3		 ret	 0
bu_int	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bu_uint DD imagerel bu_uint
	DD	imagerel bu_uint+136
	DD	imagerel $unwind$bu_uint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bu_uint DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bu_uint
_TEXT	SEGMENT
x$ = 32
i$ = 40
bytes$ = 48
p$ = 80
f$ = 88
bu_uint	PROC						; COMDAT

; 771  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 772  :     unsigned long x = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR x$[rsp], 0

; 773  :     Py_ssize_t i = f->size;

  00016	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0001b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 774  :     const unsigned char *bytes = (const unsigned char *)p;

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00029	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax
$LN4@bu_uint:

; 775  :     do {
; 776  :         x = (x<<8) | *bytes++;

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00032	c1 e0 08	 shl	 eax, 8
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes$[rsp]
  0003a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0003d	0b c1		 or	 eax, ecx
  0003f	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR bytes$[rsp]
  00048	48 ff c0	 inc	 rax
  0004b	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax

; 777  :     } while (--i > 0);

  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00055	48 ff c8	 dec	 rax
  00058	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0005d	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00063	7f c9		 jg	 SHORT $LN4@bu_uint

; 778  :     if (x <= LONG_MAX)

  00065	81 7c 24 20 ff
	ff ff 7f	 cmp	 DWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  0006d	77 0b		 ja	 SHORT $LN1@bu_uint

; 779  :         return PyLong_FromLong((long)x);

  0006f	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00073	e8 00 00 00 00	 call	 PyLong_FromLong
  00078	eb 09		 jmp	 SHORT $LN5@bu_uint
$LN1@bu_uint:

; 780  :     return PyLong_FromUnsignedLong(x);

  0007a	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  0007e	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN5@bu_uint:

; 781  : }

  00083	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00087	c3		 ret	 0
bu_uint	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bu_longlong DD imagerel bu_longlong
	DD	imagerel bu_longlong+274
	DD	imagerel $unwind$bu_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bu_longlong DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bu_longlong
_TEXT	SEGMENT
x$ = 32
i$ = 40
bytes$ = 48
tv139 = 56
p$ = 80
f$ = 88
bu_longlong PROC					; COMDAT

; 785  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 786  : #ifdef HAVE_LONG_LONG
; 787  :     PY_LONG_LONG x = 0;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 788  :     Py_ssize_t i = f->size;

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0001c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00020	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 789  :     const unsigned char *bytes = (const unsigned char *)p;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0002a	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax
$LN5@bu_longlon:

; 790  :     do {
; 791  :         x = (x<<8) | *bytes++;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  00034	48 c1 e0 08	 shl	 rax, 8
  00038	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes$[rsp]
  0003d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00040	48 0b c1	 or	 rax, rcx
  00043	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax
  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR bytes$[rsp]
  0004d	48 ff c0	 inc	 rax
  00050	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax

; 792  :     } while (--i > 0);

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0005a	48 ff c8	 dec	 rax
  0005d	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00062	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00068	7f c5		 jg	 SHORT $LN5@bu_longlon

; 793  :     /* Extend the sign bit. */
; 794  :     if (SIZEOF_LONG_LONG > f->size)

  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0006f	48 83 78 08 08	 cmp	 QWORD PTR [rax+8], 8
  00074	7d 44		 jge	 SHORT $LN2@bu_longlon

; 795  :         x |= -(x & ((PY_LONG_LONG)1 << ((8 * f->size) - 1)));

  00076	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0007b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007f	48 8d 04 c5 ff
	ff ff ff	 lea	 rax, QWORD PTR [rax*8-1]
  00087	b9 01 00 00 00	 mov	 ecx, 1
  0008c	48 89 4c 24 38	 mov	 QWORD PTR tv139[rsp], rcx
  00091	0f b6 c8	 movzx	 ecx, al
  00094	48 8b 44 24 38	 mov	 rax, QWORD PTR tv139[rsp]
  00099	48 d3 e0	 shl	 rax, cl
  0009c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  000a1	48 23 c8	 and	 rcx, rax
  000a4	48 8b c1	 mov	 rax, rcx
  000a7	48 f7 d8	 neg	 rax
  000aa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  000af	48 0b c8	 or	 rcx, rax
  000b2	48 8b c1	 mov	 rax, rcx
  000b5	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax
$LN2@bu_longlon:

; 796  :     if (x >= LONG_MIN && x <= LONG_MAX)

  000ba	48 81 7c 24 20
	00 00 00 80	 cmp	 QWORD PTR x$[rsp], -2147483648 ; ffffffff80000000H
  000c3	7c 3e		 jl	 SHORT $LN1@bu_longlon
  000c5	48 81 7c 24 20
	ff ff ff 7f	 cmp	 QWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  000ce	7f 33		 jg	 SHORT $LN1@bu_longlon

; 797  :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, PY_LONG_LONG, long));

  000d0	48 63 44 24 20	 movsxd	 rax, DWORD PTR x$[rsp]
  000d5	48 3b 44 24 20	 cmp	 rax, QWORD PTR x$[rsp]
  000da	74 1c		 je	 SHORT $LN8@bu_longlon
  000dc	41 b8 1d 03 00
	00		 mov	 r8d, 797		; 0000031dH
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MIJEIJKE@?$AA?$CI?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f6	33 c0		 xor	 eax, eax
$LN8@bu_longlon:
  000f8	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  000fc	e8 00 00 00 00	 call	 PyLong_FromLong
  00101	eb 0a		 jmp	 SHORT $LN6@bu_longlon
$LN1@bu_longlon:

; 798  :     return PyLong_FromLongLong(x);

  00103	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00108	e8 00 00 00 00	 call	 PyLong_FromLongLong
$LN6@bu_longlon:

; 799  : #else
; 800  :     return _PyLong_FromByteArray((const unsigned char *)p,
; 801  :                                   8,
; 802  :                                   0, /* little-endian */
; 803  :                       1  /* signed */);
; 804  : #endif
; 805  : }

  0010d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00111	c3		 ret	 0
bu_longlong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bu_ulonglong DD imagerel bu_ulonglong
	DD	imagerel bu_ulonglong+183
	DD	imagerel $unwind$bu_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bu_ulonglong DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bu_ulonglong
_TEXT	SEGMENT
x$ = 32
i$ = 40
bytes$ = 48
p$ = 80
f$ = 88
bu_ulonglong PROC					; COMDAT

; 809  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 810  : #ifdef HAVE_LONG_LONG
; 811  :     unsigned PY_LONG_LONG x = 0;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 812  :     Py_ssize_t i = f->size;

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0001c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00020	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 813  :     const unsigned char *bytes = (const unsigned char *)p;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0002a	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax
$LN4@bu_ulonglo:

; 814  :     do {
; 815  :         x = (x<<8) | *bytes++;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  00034	48 c1 e0 08	 shl	 rax, 8
  00038	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes$[rsp]
  0003d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00040	48 0b c1	 or	 rax, rcx
  00043	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax
  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR bytes$[rsp]
  0004d	48 ff c0	 inc	 rax
  00050	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax

; 816  :     } while (--i > 0);

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0005a	48 ff c8	 dec	 rax
  0005d	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00062	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00068	7f c5		 jg	 SHORT $LN4@bu_ulonglo

; 817  :     if (x <= LONG_MAX)

  0006a	48 81 7c 24 20
	ff ff ff 7f	 cmp	 QWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  00073	77 33		 ja	 SHORT $LN1@bu_ulonglo

; 818  :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, unsigned PY_LONG_LONG, long));

  00075	48 63 44 24 20	 movsxd	 rax, DWORD PTR x$[rsp]
  0007a	48 3b 44 24 20	 cmp	 rax, QWORD PTR x$[rsp]
  0007f	74 1c		 je	 SHORT $LN7@bu_ulonglo
  00081	41 b8 32 03 00
	00		 mov	 r8d, 818		; 00000332H
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@GIOHOOLL@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI@
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009b	33 c0		 xor	 eax, eax
$LN7@bu_ulonglo:
  0009d	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  000a1	e8 00 00 00 00	 call	 PyLong_FromLong
  000a6	eb 0a		 jmp	 SHORT $LN5@bu_ulonglo
$LN1@bu_ulonglo:

; 819  :     return PyLong_FromUnsignedLongLong(x);

  000a8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  000ad	e8 00 00 00 00	 call	 PyLong_FromUnsignedLongLong
$LN5@bu_ulonglo:

; 820  : #else
; 821  :     return _PyLong_FromByteArray((const unsigned char *)p,
; 822  :                                   8,
; 823  :                                   0, /* little-endian */
; 824  :                       0  /* signed */);
; 825  : #endif
; 826  : }

  000b2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b6	c3		 ret	 0
bu_ulonglong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bu_float DD imagerel bu_float
	DD	imagerel bu_float+31
	DD	imagerel $unwind$bu_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bu_float DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bu_float
_TEXT	SEGMENT
p$ = 48
f$ = 56
bu_float PROC						; COMDAT

; 830  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 831  :     return unpack_float(p, 0);

  0000e	33 d2		 xor	 edx, edx
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00015	e8 00 00 00 00	 call	 unpack_float

; 832  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
bu_float ENDP
_TEXT	ENDS
EXTRN	_PyFloat_Unpack4:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_float DD imagerel unpack_float
	DD	imagerel unpack_float+81
	DD	imagerel $unwind$unpack_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_float DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT unpack_float
_TEXT	SEGMENT
x$ = 32
p$ = 64
le$ = 72
unpack_float PROC					; COMDAT

; 273  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 274  :     double x;
; 275  : 
; 276  :     x = _PyFloat_Unpack4((unsigned char *)p, le);

  0000d	8b 54 24 48	 mov	 edx, DWORD PTR le$[rsp]
  00011	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  00016	e8 00 00 00 00	 call	 _PyFloat_Unpack4
  0001b	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 277  :     if (x == -1.0 && PyErr_Occurred())

  00021	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00027	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002f	7a 10		 jp	 SHORT $LN1@unpack_flo
  00031	75 0e		 jne	 SHORT $LN1@unpack_flo
  00033	e8 00 00 00 00	 call	 PyErr_Occurred
  00038	48 85 c0	 test	 rax, rax
  0003b	74 04		 je	 SHORT $LN1@unpack_flo

; 278  :         return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 0b		 jmp	 SHORT $LN2@unpack_flo
$LN1@unpack_flo:

; 279  :     return PyFloat_FromDouble(x);

  00041	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00047	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN2@unpack_flo:

; 280  : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
unpack_float ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bu_double DD imagerel bu_double
	DD	imagerel bu_double+31
	DD	imagerel $unwind$bu_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bu_double DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bu_double
_TEXT	SEGMENT
p$ = 48
f$ = 56
bu_double PROC						; COMDAT

; 836  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 837  :     return unpack_double(p, 0);

  0000e	33 d2		 xor	 edx, edx
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00015	e8 00 00 00 00	 call	 unpack_double

; 838  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
bu_double ENDP
_TEXT	ENDS
EXTRN	_PyFloat_Unpack8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_double DD imagerel unpack_double
	DD	imagerel unpack_double+81
	DD	imagerel $unwind$unpack_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_double DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT unpack_double
_TEXT	SEGMENT
x$ = 32
p$ = 64
le$ = 72
unpack_double PROC					; COMDAT

; 285  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 286  :     double x;
; 287  : 
; 288  :     x = _PyFloat_Unpack8((unsigned char *)p, le);

  0000d	8b 54 24 48	 mov	 edx, DWORD PTR le$[rsp]
  00011	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  00016	e8 00 00 00 00	 call	 _PyFloat_Unpack8
  0001b	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 289  :     if (x == -1.0 && PyErr_Occurred())

  00021	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00027	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002f	7a 10		 jp	 SHORT $LN1@unpack_dou
  00031	75 0e		 jne	 SHORT $LN1@unpack_dou
  00033	e8 00 00 00 00	 call	 PyErr_Occurred
  00038	48 85 c0	 test	 rax, rax
  0003b	74 04		 je	 SHORT $LN1@unpack_dou

; 290  :         return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 0b		 jmp	 SHORT $LN2@unpack_dou
$LN1@unpack_dou:

; 291  :     return PyFloat_FromDouble(x);

  00041	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00047	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN2@unpack_dou:

; 292  : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
unpack_double ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bu_bool DD imagerel bu_bool
	DD	imagerel bu_bool+76
	DD	imagerel $unwind$bu_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bu_bool DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bu_bool
_TEXT	SEGMENT
x$ = 32
tv70 = 36
p$ = 64
f$ = 72
bu_bool	PROC						; COMDAT

; 842  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 843  :     char x;
; 844  :     memcpy((char *)&x, p, sizeof x);

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$[rsp]
  0001e	e8 00 00 00 00	 call	 memcpy

; 845  :     return PyBool_FromLong(x != 0);

  00023	0f be 44 24 20	 movsx	 eax, BYTE PTR x$[rsp]
  00028	85 c0		 test	 eax, eax
  0002a	74 0a		 je	 SHORT $LN3@bu_bool
  0002c	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00034	eb 08		 jmp	 SHORT $LN4@bu_bool
$LN3@bu_bool:
  00036	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN4@bu_bool:
  0003e	8b 4c 24 24	 mov	 ecx, DWORD PTR tv70[rsp]
  00042	e8 00 00 00 00	 call	 PyBool_FromLong

; 846  : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
bu_bool	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_int DD imagerel bp_int
	DD	imagerel bp_int+171
	DD	imagerel $unwind$bp_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_int DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bp_int
_TEXT	SEGMENT
x$ = 32
i$ = 40
p$ = 64
v$ = 72
f$ = 80
bp_int	PROC						; COMDAT

; 850  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 851  :     long x;
; 852  :     Py_ssize_t i;
; 853  :     if (get_long(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_long
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN7@bp_int

; 854  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 79		 jmp	 SHORT $LN8@bp_int
$LN7@bp_int:

; 855  :     i = f->size;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR f$[rsp]
  00032	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00036	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 856  :     if (i != SIZEOF_LONG) {

  0003b	48 83 7c 24 28
	04		 cmp	 QWORD PTR i$[rsp], 4
  00041	74 2a		 je	 SHORT $LN6@bp_int

; 857  :         if ((i == 2) && (x < -32768 || x > 32767))

  00043	48 83 7c 24 28
	02		 cmp	 QWORD PTR i$[rsp], 2
  00049	75 22		 jne	 SHORT $LN5@bp_int
  0004b	81 7c 24 20 00
	80 ff ff	 cmp	 DWORD PTR x$[rsp], -32768 ; ffffffffffff8000H
  00053	7c 0a		 jl	 SHORT $LN4@bp_int
  00055	81 7c 24 20 ff
	7f 00 00	 cmp	 DWORD PTR x$[rsp], 32767 ; 00007fffH
  0005d	7e 0e		 jle	 SHORT $LN5@bp_int
$LN4@bp_int:

; 858  :             RANGE_ERROR(x, f, 0, 0xffffL);

  0005f	33 d2		 xor	 edx, edx
  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  00066	e8 00 00 00 00	 call	 _range_error
  0006b	eb 39		 jmp	 SHORT $LN8@bp_int
$LN5@bp_int:
$LN6@bp_int:
$LN3@bp_int:

; 859  : #if (SIZEOF_LONG != 4)
; 860  :         else if ((i == 4) && (x < -2147483648L || x > 2147483647L))
; 861  :             RANGE_ERROR(x, f, 0, 0xffffffffL);
; 862  : #endif
; 863  :     }
; 864  :     do {
; 865  :         p[--i] = (char)x;

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00072	48 ff c8	 dec	 rax
  00075	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0007a	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR x$[rsp]
  0008f	88 08		 mov	 BYTE PTR [rax], cl

; 866  :         x >>= 8;

  00091	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00095	c1 f8 08	 sar	 eax, 8
  00098	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 867  :     } while (i > 0);

  0009c	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000a2	7f c9		 jg	 SHORT $LN3@bp_int

; 868  :     return 0;

  000a4	33 c0		 xor	 eax, eax
$LN8@bp_int:

; 869  : }

  000a6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000aa	c3		 ret	 0
bp_int	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@NKGCPOGG@?8?$CFc?8?5format?5requires?5?$CFzd?5?$DM?$DN?5numb@ ; `string'
PUBLIC	??_C@_0CI@FDMMBEIJ@?8?$CFc?8?5format?5requires?50?5?$DM?$DN?5number@ ; `string'
PUBLIC	??_C@_1FC@MAKDMML@?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAI?$AAZ?$AAE?$AAO@ ; `string'
EXTRN	PyErr_Format:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_range_error DD imagerel _range_error
	DD	imagerel _range_error+232
	DD	imagerel $unwind$_range_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_range_error DD 010d01H
	DD	0a20dH
xdata	ENDS
;	COMDAT ??_C@_0CK@NKGCPOGG@?8?$CFc?8?5format?5requires?5?$CFzd?5?$DM?$DN?5numb@
CONST	SEGMENT
??_C@_0CK@NKGCPOGG@?8?$CFc?8?5format?5requires?5?$CFzd?5?$DM?$DN?5numb@ DB ''''
	DB	'%c'' format requires %zd <= number <= %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FDMMBEIJ@?8?$CFc?8?5format?5requires?50?5?$DM?$DN?5number@
CONST	SEGMENT
??_C@_0CI@FDMMBEIJ@?8?$CFc?8?5format?5requires?50?5?$DM?$DN?5number@ DB ''''
	DB	'%c'' format requires 0 <= number <= %zu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@MAKDMML@?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAI?$AAZ?$AAE?$AAO@
CONST	SEGMENT
??_C@_1FC@MAKDMML@?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAI?$AAZ?$AAE?$AAO@ DB 'f'
	DB	00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'f', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, 'O', 00H, 'F', 00H
	DB	'_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '_', 00H, 'T'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _range_error
_TEXT	SEGMENT
ulargest$ = 48
largest$20551 = 56
tv128 = 64
f$ = 96
is_unsigned$ = 104
_range_error PROC					; COMDAT

; 297  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 298  :     /* ulargest is the largest unsigned value with f->size bytes.
; 299  :      * Note that the simpler:
; 300  :      *     ((size_t)1 << (f->size * 8)) - 1
; 301  :      * doesn't work when f->size == sizeof(size_t) because C doesn't
; 302  :      * define what happens when a left shift count is >= the number of
; 303  :      * bits in the integer being shifted; e.g., on some boxes it doesn't
; 304  :      * shift at all when they're equal.
; 305  :      */
; 306  :     const size_t ulargest = (size_t)-1 >> ((SIZEOF_SIZE_T - f->size)*8);

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR f$[rsp]
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	48 2b 48 08	 sub	 rcx, QWORD PTR [rax+8]
  0001b	48 8b c1	 mov	 rax, rcx
  0001e	48 c1 e0 03	 shl	 rax, 3
  00022	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00029	48 89 4c 24 40	 mov	 QWORD PTR tv128[rsp], rcx
  0002e	0f b6 c8	 movzx	 ecx, al
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  00036	48 d3 e8	 shr	 rax, cl
  00039	48 89 44 24 30	 mov	 QWORD PTR ulargest$[rsp], rax

; 307  :     assert(f->size >= 1 && f->size <= SIZEOF_SIZE_T);

  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR f$[rsp]
  00043	48 83 78 08 01	 cmp	 QWORD PTR [rax+8], 1
  00048	7c 0c		 jl	 SHORT $LN5@range_erro
  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR f$[rsp]
  0004f	48 83 78 08 08	 cmp	 QWORD PTR [rax+8], 8
  00054	7e 1c		 jle	 SHORT $LN6@range_erro
$LN5@range_erro:
  00056	41 b8 33 01 00
	00		 mov	 r8d, 307		; 00000133H
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@MAKDMML@?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAI?$AAZ?$AAE?$AAO@
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00070	33 c0		 xor	 eax, eax
$LN6@range_erro:

; 308  :     if (is_unsigned)

  00072	83 7c 24 68 00	 cmp	 DWORD PTR is_unsigned$[rsp], 0
  00077	74 25		 je	 SHORT $LN2@range_erro

; 309  :         PyErr_Format(StructError,
; 310  :             "'%c' format requires 0 <= number <= %zu",
; 311  :             f->format,
; 312  :             ulargest);

  00079	48 8b 44 24 60	 mov	 rax, QWORD PTR f$[rsp]
  0007e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00081	4c 8b 4c 24 30	 mov	 r9, QWORD PTR ulargest$[rsp]
  00086	44 8b c0	 mov	 r8d, eax
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@FDMMBEIJ@?8?$CFc?8?5format?5requires?50?5?$DM?$DN?5number@
  00090	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00097	e8 00 00 00 00	 call	 PyErr_Format

; 313  :     else {

  0009c	eb 40		 jmp	 SHORT $LN1@range_erro
$LN2@range_erro:

; 314  :         const Py_ssize_t largest = (Py_ssize_t)(ulargest >> 1);

  0009e	48 8b 44 24 30	 mov	 rax, QWORD PTR ulargest$[rsp]
  000a3	48 d1 e8	 shr	 rax, 1
  000a6	48 89 44 24 38	 mov	 QWORD PTR largest$20551[rsp], rax

; 315  :         PyErr_Format(StructError,
; 316  :             "'%c' format requires %zd <= number <= %zd",
; 317  :             f->format,
; 318  :             ~ largest,
; 319  :             largest);

  000ab	48 8b 44 24 38	 mov	 rax, QWORD PTR largest$20551[rsp]
  000b0	48 f7 d0	 not	 rax
  000b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR f$[rsp]
  000b8	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  000bb	48 8b 54 24 38	 mov	 rdx, QWORD PTR largest$20551[rsp]
  000c0	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000c5	4c 8b c8	 mov	 r9, rax
  000c8	44 8b c1	 mov	 r8d, ecx
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NKGCPOGG@?8?$CFc?8?5format?5requires?5?$CFzd?5?$DM?$DN?5numb@
  000d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000d9	e8 00 00 00 00	 call	 PyErr_Format
$LN1@range_erro:

; 320  :     }
; 321  : 
; 322  :     return -1;

  000de	b8 ff ff ff ff	 mov	 eax, -1

; 323  : }

  000e3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e7	c3		 ret	 0
_range_error ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_uint DD imagerel bp_uint
	DD	imagerel bp_uint+189
	DD	imagerel $unwind$bp_uint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_uint DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bp_uint
_TEXT	SEGMENT
x$ = 32
i$ = 40
maxint$21095 = 48
p$ = 80
v$ = 88
f$ = 96
bp_uint	PROC						; COMDAT

; 873  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 874  :     unsigned long x;
; 875  :     Py_ssize_t i;
; 876  :     if (get_ulong(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_ulong
  00022	85 c0		 test	 eax, eax
  00024	7d 0a		 jge	 SHORT $LN6@bp_uint

; 877  :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	e9 88 00 00 00	 jmp	 $LN7@bp_uint
$LN6@bp_uint:

; 878  :     i = f->size;

  00030	48 8b 44 24 60	 mov	 rax, QWORD PTR f$[rsp]
  00035	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00039	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 879  :     if (i != SIZEOF_LONG) {

  0003e	48 83 7c 24 28
	04		 cmp	 QWORD PTR i$[rsp], 4
  00044	74 39		 je	 SHORT $LN5@bp_uint

; 880  :         unsigned long maxint = 1;

  00046	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR maxint$21095[rsp], 1

; 881  :         maxint <<= (unsigned long)(i * 8);

  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00053	48 c1 e0 03	 shl	 rax, 3
  00057	0f b6 c8	 movzx	 ecx, al
  0005a	8b 44 24 30	 mov	 eax, DWORD PTR maxint$21095[rsp]
  0005e	d3 e0		 shl	 eax, cl
  00060	89 44 24 30	 mov	 DWORD PTR maxint$21095[rsp], eax

; 882  :         if (x >= maxint)

  00064	8b 44 24 30	 mov	 eax, DWORD PTR maxint$21095[rsp]
  00068	39 44 24 20	 cmp	 DWORD PTR x$[rsp], eax
  0006c	72 11		 jb	 SHORT $LN4@bp_uint

; 883  :             RANGE_ERROR(x, f, 1, maxint - 1);

  0006e	ba 01 00 00 00	 mov	 edx, 1
  00073	48 8b 4c 24 60	 mov	 rcx, QWORD PTR f$[rsp]
  00078	e8 00 00 00 00	 call	 _range_error
  0007d	eb 39		 jmp	 SHORT $LN7@bp_uint
$LN4@bp_uint:
$LN5@bp_uint:
$LN3@bp_uint:

; 884  :     }
; 885  :     do {
; 886  :         p[--i] = (char)x;

  0007f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00084	48 ff c8	 dec	 rax
  00087	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00091	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00096	48 03 c8	 add	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR x$[rsp]
  000a1	88 08		 mov	 BYTE PTR [rax], cl

; 887  :         x >>= 8;

  000a3	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  000a7	c1 e8 08	 shr	 eax, 8
  000aa	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 888  :     } while (i > 0);

  000ae	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000b4	7f c9		 jg	 SHORT $LN3@bp_uint

; 889  :     return 0;

  000b6	33 c0		 xor	 eax, eax
$LN7@bp_uint:

; 890  : }

  000b8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bc	c3		 ret	 0
bp_uint	ENDP
_TEXT	ENDS
EXTRN	_PyLong_AsByteArray:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_longlong DD imagerel bp_longlong
	DD	imagerel bp_longlong+104
	DD	imagerel $unwind$bp_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_longlong DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bp_longlong
_TEXT	SEGMENT
res$ = 48
p$ = 80
v$ = 88
f$ = 96
bp_longlong PROC					; COMDAT

; 894  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 895  :     int res;
; 896  :     v = get_pylong(v);

  00013	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 get_pylong
  0001d	48 89 44 24 58	 mov	 QWORD PTR v$[rsp], rax

; 897  :     if (v == NULL)

  00022	48 83 7c 24 58
	00		 cmp	 QWORD PTR v$[rsp], 0
  00028	75 07		 jne	 SHORT $LN1@bp_longlon

; 898  :         return -1;

  0002a	b8 ff ff ff ff	 mov	 eax, -1
  0002f	eb 32		 jmp	 SHORT $LN2@bp_longlon
$LN1@bp_longlon:

; 899  :     res = _PyLong_AsByteArray((PyLongObject *)v,
; 900  :                               (unsigned char *)p,
; 901  :                               8,
; 902  :                               0, /* little_endian */
; 903  :                   1  /* signed */);

  00031	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00039	45 33 c9	 xor	 r9d, r9d
  0003c	41 b8 08 00 00
	00		 mov	 r8d, 8
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$[rsp]
  00047	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0004c	e8 00 00 00 00	 call	 _PyLong_AsByteArray
  00051	89 44 24 30	 mov	 DWORD PTR res$[rsp], eax

; 904  :     Py_DECREF(v);

  00055	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0005a	e8 00 00 00 00	 call	 _Py_DecRef

; 905  :     return res;

  0005f	8b 44 24 30	 mov	 eax, DWORD PTR res$[rsp]
$LN2@bp_longlon:

; 906  : }

  00063	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00067	c3		 ret	 0
bp_longlong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_ulonglong DD imagerel bp_ulonglong
	DD	imagerel bp_ulonglong+104
	DD	imagerel $unwind$bp_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_ulonglong DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bp_ulonglong
_TEXT	SEGMENT
res$ = 48
p$ = 80
v$ = 88
f$ = 96
bp_ulonglong PROC					; COMDAT

; 910  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 911  :     int res;
; 912  :     v = get_pylong(v);

  00013	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 get_pylong
  0001d	48 89 44 24 58	 mov	 QWORD PTR v$[rsp], rax

; 913  :     if (v == NULL)

  00022	48 83 7c 24 58
	00		 cmp	 QWORD PTR v$[rsp], 0
  00028	75 07		 jne	 SHORT $LN1@bp_ulonglo

; 914  :         return -1;

  0002a	b8 ff ff ff ff	 mov	 eax, -1
  0002f	eb 32		 jmp	 SHORT $LN2@bp_ulonglo
$LN1@bp_ulonglo:

; 915  :     res = _PyLong_AsByteArray((PyLongObject *)v,
; 916  :                               (unsigned char *)p,
; 917  :                               8,
; 918  :                               0, /* little_endian */
; 919  :                   0  /* signed */);

  00031	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00039	45 33 c9	 xor	 r9d, r9d
  0003c	41 b8 08 00 00
	00		 mov	 r8d, 8
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$[rsp]
  00047	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0004c	e8 00 00 00 00	 call	 _PyLong_AsByteArray
  00051	89 44 24 30	 mov	 DWORD PTR res$[rsp], eax

; 920  :     Py_DECREF(v);

  00055	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0005a	e8 00 00 00 00	 call	 _Py_DecRef

; 921  :     return res;

  0005f	8b 44 24 30	 mov	 eax, DWORD PTR res$[rsp]
$LN2@bp_ulonglo:

; 922  : }

  00063	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00067	c3		 ret	 0
bp_ulonglong ENDP
_TEXT	ENDS
EXTRN	_PyFloat_Pack4:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_float DD imagerel bp_float
	DD	imagerel bp_float+113
	DD	imagerel $unwind$bp_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_float DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bp_float
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
bp_float PROC						; COMDAT

; 926  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 927  :     double x = PyFloat_AsDouble(v);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0001d	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 928  :     if (x == -1 && PyErr_Occurred()) {

  00023	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00029	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00031	7a 26		 jp	 SHORT $LN1@bp_float
  00033	75 24		 jne	 SHORT $LN1@bp_float
  00035	e8 00 00 00 00	 call	 PyErr_Occurred
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 1a		 je	 SHORT $LN1@bp_float

; 929  :         PyErr_SetString(StructError,
; 930  :                         "required argument is not a float");

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0004d	e8 00 00 00 00	 call	 PyErr_SetString

; 931  :         return -1;

  00052	b8 ff ff ff ff	 mov	 eax, -1
  00057	eb 13		 jmp	 SHORT $LN2@bp_float
$LN1@bp_float:

; 932  :     }
; 933  :     return _PyFloat_Pack4(x, (unsigned char *)p, 0);

  00059	45 33 c0	 xor	 r8d, r8d
  0005c	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00061	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00067	e8 00 00 00 00	 call	 _PyFloat_Pack4
$LN2@bp_float:

; 934  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
bp_float ENDP
_TEXT	ENDS
EXTRN	_PyFloat_Pack8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_double DD imagerel bp_double
	DD	imagerel bp_double+113
	DD	imagerel $unwind$bp_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_double DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bp_double
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
bp_double PROC						; COMDAT

; 938  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 939  :     double x = PyFloat_AsDouble(v);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0001d	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 940  :     if (x == -1 && PyErr_Occurred()) {

  00023	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00029	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00031	7a 26		 jp	 SHORT $LN1@bp_double
  00033	75 24		 jne	 SHORT $LN1@bp_double
  00035	e8 00 00 00 00	 call	 PyErr_Occurred
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 1a		 je	 SHORT $LN1@bp_double

; 941  :         PyErr_SetString(StructError,
; 942  :                         "required argument is not a float");

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0004d	e8 00 00 00 00	 call	 PyErr_SetString

; 943  :         return -1;

  00052	b8 ff ff ff ff	 mov	 eax, -1
  00057	eb 13		 jmp	 SHORT $LN2@bp_double
$LN1@bp_double:

; 944  :     }
; 945  :     return _PyFloat_Pack8(x, (unsigned char *)p, 0);

  00059	45 33 c0	 xor	 r8d, r8d
  0005c	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00061	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00067	e8 00 00 00 00	 call	 _PyFloat_Pack8
$LN2@bp_double:

; 946  : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
bp_double ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_bool DD imagerel bp_bool
	DD	imagerel bp_bool+66
	DD	imagerel $unwind$bp_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_bool DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bp_bool
_TEXT	SEGMENT
y$ = 32
p$ = 64
v$ = 72
f$ = 80
bp_bool	PROC						; COMDAT

; 950  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 951  :     int y;
; 952  :     y = PyObject_IsTrue(v);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 PyObject_IsTrue
  0001d	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax

; 953  :     if (y < 0)

  00021	83 7c 24 20 00	 cmp	 DWORD PTR y$[rsp], 0
  00026	7d 07		 jge	 SHORT $LN1@bp_bool

; 954  :         return -1;

  00028	b8 ff ff ff ff	 mov	 eax, -1
  0002d	eb 0e		 jmp	 SHORT $LN2@bp_bool
$LN1@bp_bool:

; 955  :     *p = (char)y;

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00034	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR y$[rsp]
  00039	88 08		 mov	 BYTE PTR [rax], cl

; 956  :     return 0;

  0003b	33 c0		 xor	 eax, eax
$LN2@bp_bool:

; 957  : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
bp_bool	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lu_int DD imagerel lu_int
	DD	imagerel lu_int+184
	DD	imagerel $unwind$lu_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lu_int DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lu_int
_TEXT	SEGMENT
x$ = 32
i$ = 40
bytes$ = 48
tv128 = 56
p$ = 80
f$ = 88
lu_int	PROC						; COMDAT

; 984  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 985  :     long x = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR x$[rsp], 0

; 986  :     Py_ssize_t i = f->size;

  00016	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0001b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 987  :     const unsigned char *bytes = (const unsigned char *)p;

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00029	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax
$LN4@lu_int:

; 988  :     do {
; 989  :         x = (x<<8) | bytes[--i];

  0002e	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00033	48 ff c8	 dec	 rax
  00036	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes$[rsp]
  00045	48 03 c8	 add	 rcx, rax
  00048	48 8b c1	 mov	 rax, rcx
  0004b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004e	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00052	c1 e1 08	 shl	 ecx, 8
  00055	0b c8		 or	 ecx, eax
  00057	8b c1		 mov	 eax, ecx
  00059	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 990  :     } while (i > 0);

  0005d	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00063	7f c9		 jg	 SHORT $LN4@lu_int

; 991  :     /* Extend the sign bit. */
; 992  :     if (SIZEOF_LONG > f->size)

  00065	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0006a	48 83 78 08 04	 cmp	 QWORD PTR [rax+8], 4
  0006f	7d 39		 jge	 SHORT $LN1@lu_int

; 993  :         x |= -(x & (1L << ((8 * f->size) - 1)));

  00071	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  00076	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007a	48 8d 04 c5 ff
	ff ff ff	 lea	 rax, QWORD PTR [rax*8-1]
  00082	b9 01 00 00 00	 mov	 ecx, 1
  00087	89 4c 24 38	 mov	 DWORD PTR tv128[rsp], ecx
  0008b	0f b6 c8	 movzx	 ecx, al
  0008e	8b 44 24 38	 mov	 eax, DWORD PTR tv128[rsp]
  00092	d3 e0		 shl	 eax, cl
  00094	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00098	23 c8		 and	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	f7 d8		 neg	 eax
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  000a2	0b c8		 or	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN1@lu_int:

; 994  :     return PyLong_FromLong(x);

  000aa	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  000ae	e8 00 00 00 00	 call	 PyLong_FromLong

; 995  : }

  000b3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b7	c3		 ret	 0
lu_int	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lu_uint DD imagerel lu_uint
	DD	imagerel lu_uint+136
	DD	imagerel $unwind$lu_uint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lu_uint DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lu_uint
_TEXT	SEGMENT
x$ = 32
i$ = 40
bytes$ = 48
p$ = 80
f$ = 88
lu_uint	PROC						; COMDAT

; 999  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1000 :     unsigned long x = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR x$[rsp], 0

; 1001 :     Py_ssize_t i = f->size;

  00016	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0001b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 1002 :     const unsigned char *bytes = (const unsigned char *)p;

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00029	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax
$LN4@lu_uint:

; 1003 :     do {
; 1004 :         x = (x<<8) | bytes[--i];

  0002e	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00033	48 ff c8	 dec	 rax
  00036	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes$[rsp]
  00045	48 03 c8	 add	 rcx, rax
  00048	48 8b c1	 mov	 rax, rcx
  0004b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004e	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00052	c1 e1 08	 shl	 ecx, 8
  00055	0b c8		 or	 ecx, eax
  00057	8b c1		 mov	 eax, ecx
  00059	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 1005 :     } while (i > 0);

  0005d	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00063	7f c9		 jg	 SHORT $LN4@lu_uint

; 1006 :     if (x <= LONG_MAX)

  00065	81 7c 24 20 ff
	ff ff 7f	 cmp	 DWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  0006d	77 0b		 ja	 SHORT $LN1@lu_uint

; 1007 :         return PyLong_FromLong((long)x);

  0006f	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00073	e8 00 00 00 00	 call	 PyLong_FromLong
  00078	eb 09		 jmp	 SHORT $LN5@lu_uint
$LN1@lu_uint:

; 1008 :     return PyLong_FromUnsignedLong((long)x);

  0007a	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  0007e	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN5@lu_uint:

; 1009 : }

  00083	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00087	c3		 ret	 0
lu_uint	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lu_longlong DD imagerel lu_longlong
	DD	imagerel lu_longlong+275
	DD	imagerel $unwind$lu_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lu_longlong DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lu_longlong
_TEXT	SEGMENT
x$ = 32
i$ = 40
bytes$ = 48
tv139 = 56
p$ = 80
f$ = 88
lu_longlong PROC					; COMDAT

; 1013 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1014 : #ifdef HAVE_LONG_LONG
; 1015 :     PY_LONG_LONG x = 0;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 1016 :     Py_ssize_t i = f->size;

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0001c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00020	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 1017 :     const unsigned char *bytes = (const unsigned char *)p;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0002a	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax
$LN5@lu_longlon:

; 1018 :     do {
; 1019 :         x = (x<<8) | bytes[--i];

  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00034	48 ff c8	 dec	 rax
  00037	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00041	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes$[rsp]
  00046	48 03 c8	 add	 rcx, rax
  00049	48 8b c1	 mov	 rax, rcx
  0004c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00054	48 c1 e1 08	 shl	 rcx, 8
  00058	48 0b c8	 or	 rcx, rax
  0005b	48 8b c1	 mov	 rax, rcx
  0005e	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1020 :     } while (i > 0);

  00063	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00069	7f c4		 jg	 SHORT $LN5@lu_longlon

; 1021 :     /* Extend the sign bit. */
; 1022 :     if (SIZEOF_LONG_LONG > f->size)

  0006b	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  00070	48 83 78 08 08	 cmp	 QWORD PTR [rax+8], 8
  00075	7d 44		 jge	 SHORT $LN2@lu_longlon

; 1023 :         x |= -(x & ((PY_LONG_LONG)1 << ((8 * f->size) - 1)));

  00077	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0007c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00080	48 8d 04 c5 ff
	ff ff ff	 lea	 rax, QWORD PTR [rax*8-1]
  00088	b9 01 00 00 00	 mov	 ecx, 1
  0008d	48 89 4c 24 38	 mov	 QWORD PTR tv139[rsp], rcx
  00092	0f b6 c8	 movzx	 ecx, al
  00095	48 8b 44 24 38	 mov	 rax, QWORD PTR tv139[rsp]
  0009a	48 d3 e0	 shl	 rax, cl
  0009d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  000a2	48 23 c8	 and	 rcx, rax
  000a5	48 8b c1	 mov	 rax, rcx
  000a8	48 f7 d8	 neg	 rax
  000ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  000b0	48 0b c8	 or	 rcx, rax
  000b3	48 8b c1	 mov	 rax, rcx
  000b6	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax
$LN2@lu_longlon:

; 1024 :     if (x >= LONG_MIN && x <= LONG_MAX)

  000bb	48 81 7c 24 20
	00 00 00 80	 cmp	 QWORD PTR x$[rsp], -2147483648 ; ffffffff80000000H
  000c4	7c 3e		 jl	 SHORT $LN1@lu_longlon
  000c6	48 81 7c 24 20
	ff ff ff 7f	 cmp	 QWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  000cf	7f 33		 jg	 SHORT $LN1@lu_longlon

; 1025 :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, PY_LONG_LONG, long));

  000d1	48 63 44 24 20	 movsxd	 rax, DWORD PTR x$[rsp]
  000d6	48 3b 44 24 20	 cmp	 rax, QWORD PTR x$[rsp]
  000db	74 1c		 je	 SHORT $LN8@lu_longlon
  000dd	41 b8 01 04 00
	00		 mov	 r8d, 1025		; 00000401H
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@MIJEIJKE@?$AA?$CI?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f7	33 c0		 xor	 eax, eax
$LN8@lu_longlon:
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  000fd	e8 00 00 00 00	 call	 PyLong_FromLong
  00102	eb 0a		 jmp	 SHORT $LN6@lu_longlon
$LN1@lu_longlon:

; 1026 :     return PyLong_FromLongLong(x);

  00104	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00109	e8 00 00 00 00	 call	 PyLong_FromLongLong
$LN6@lu_longlon:

; 1027 : #else
; 1028 :     return _PyLong_FromByteArray((const unsigned char *)p,
; 1029 :                                   8,
; 1030 :                                   1, /* little-endian */
; 1031 :                       1  /* signed */);
; 1032 : #endif
; 1033 : }

  0010e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00112	c3		 ret	 0
lu_longlong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lu_ulonglong DD imagerel lu_ulonglong
	DD	imagerel lu_ulonglong+184
	DD	imagerel $unwind$lu_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lu_ulonglong DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lu_ulonglong
_TEXT	SEGMENT
x$ = 32
i$ = 40
bytes$ = 48
p$ = 80
f$ = 88
lu_ulonglong PROC					; COMDAT

; 1037 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1038 : #ifdef HAVE_LONG_LONG
; 1039 :     unsigned PY_LONG_LONG x = 0;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 1040 :     Py_ssize_t i = f->size;

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR f$[rsp]
  0001c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00020	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 1041 :     const unsigned char *bytes = (const unsigned char *)p;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0002a	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax
$LN4@lu_ulonglo:

; 1042 :     do {
; 1043 :         x = (x<<8) | bytes[--i];

  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00034	48 ff c8	 dec	 rax
  00037	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00041	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes$[rsp]
  00046	48 03 c8	 add	 rcx, rax
  00049	48 8b c1	 mov	 rax, rcx
  0004c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00054	48 c1 e1 08	 shl	 rcx, 8
  00058	48 0b c8	 or	 rcx, rax
  0005b	48 8b c1	 mov	 rax, rcx
  0005e	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1044 :     } while (i > 0);

  00063	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00069	7f c4		 jg	 SHORT $LN4@lu_ulonglo

; 1045 :     if (x <= LONG_MAX)

  0006b	48 81 7c 24 20
	ff ff ff 7f	 cmp	 QWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  00074	77 33		 ja	 SHORT $LN1@lu_ulonglo

; 1046 :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, unsigned PY_LONG_LONG, long));

  00076	48 63 44 24 20	 movsxd	 rax, DWORD PTR x$[rsp]
  0007b	48 3b 44 24 20	 cmp	 rax, QWORD PTR x$[rsp]
  00080	74 1c		 je	 SHORT $LN7@lu_ulonglo
  00082	41 b8 16 04 00
	00		 mov	 r8d, 1046		; 00000416H
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@GIOHOOLL@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI@
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009c	33 c0		 xor	 eax, eax
$LN7@lu_ulonglo:
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  000a2	e8 00 00 00 00	 call	 PyLong_FromLong
  000a7	eb 0a		 jmp	 SHORT $LN5@lu_ulonglo
$LN1@lu_ulonglo:

; 1047 :     return PyLong_FromUnsignedLongLong(x);

  000a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  000ae	e8 00 00 00 00	 call	 PyLong_FromUnsignedLongLong
$LN5@lu_ulonglo:

; 1048 : #else
; 1049 :     return _PyLong_FromByteArray((const unsigned char *)p,
; 1050 :                                   8,
; 1051 :                                   1, /* little-endian */
; 1052 :                       0  /* signed */);
; 1053 : #endif
; 1054 : }

  000b3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b7	c3		 ret	 0
lu_ulonglong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lu_float DD imagerel lu_float
	DD	imagerel lu_float+34
	DD	imagerel $unwind$lu_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lu_float DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lu_float
_TEXT	SEGMENT
p$ = 48
f$ = 56
lu_float PROC						; COMDAT

; 1058 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1059 :     return unpack_float(p, 1);

  0000e	ba 01 00 00 00	 mov	 edx, 1
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00018	e8 00 00 00 00	 call	 unpack_float

; 1060 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
lu_float ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lu_double DD imagerel lu_double
	DD	imagerel lu_double+34
	DD	imagerel $unwind$lu_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lu_double DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lu_double
_TEXT	SEGMENT
p$ = 48
f$ = 56
lu_double PROC						; COMDAT

; 1064 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1065 :     return unpack_double(p, 1);

  0000e	ba 01 00 00 00	 mov	 edx, 1
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00018	e8 00 00 00 00	 call	 unpack_double

; 1066 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
lu_double ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_int DD imagerel lp_int
	DD	imagerel lp_int+173
	DD	imagerel $unwind$lp_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_int DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lp_int
_TEXT	SEGMENT
x$ = 32
i$ = 40
p$ = 64
v$ = 72
f$ = 80
lp_int	PROC						; COMDAT

; 1070 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1071 :     long x;
; 1072 :     Py_ssize_t i;
; 1073 :     if (get_long(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_long
  00022	85 c0		 test	 eax, eax
  00024	7d 07		 jge	 SHORT $LN7@lp_int

; 1074 :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 7b		 jmp	 SHORT $LN8@lp_int
$LN7@lp_int:

; 1075 :     i = f->size;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR f$[rsp]
  00032	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00036	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 1076 :     if (i != SIZEOF_LONG) {

  0003b	48 83 7c 24 28
	04		 cmp	 QWORD PTR i$[rsp], 4
  00041	74 2a		 je	 SHORT $LN6@lp_int

; 1077 :         if ((i == 2) && (x < -32768 || x > 32767))

  00043	48 83 7c 24 28
	02		 cmp	 QWORD PTR i$[rsp], 2
  00049	75 22		 jne	 SHORT $LN5@lp_int
  0004b	81 7c 24 20 00
	80 ff ff	 cmp	 DWORD PTR x$[rsp], -32768 ; ffffffffffff8000H
  00053	7c 0a		 jl	 SHORT $LN4@lp_int
  00055	81 7c 24 20 ff
	7f 00 00	 cmp	 DWORD PTR x$[rsp], 32767 ; 00007fffH
  0005d	7e 0e		 jle	 SHORT $LN5@lp_int
$LN4@lp_int:

; 1078 :             RANGE_ERROR(x, f, 0, 0xffffL);

  0005f	33 d2		 xor	 edx, edx
  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  00066	e8 00 00 00 00	 call	 _range_error
  0006b	eb 3b		 jmp	 SHORT $LN8@lp_int
$LN5@lp_int:
$LN6@lp_int:
$LN3@lp_int:

; 1079 : #if (SIZEOF_LONG != 4)
; 1080 :         else if ((i == 4) && (x < -2147483648L || x > 2147483647L))
; 1081 :             RANGE_ERROR(x, f, 0, 0xffffffffL);
; 1082 : #endif
; 1083 :     }
; 1084 :     do {
; 1085 :         *p++ = (char)x;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00072	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR x$[rsp]
  00077	88 08		 mov	 BYTE PTR [rax], cl
  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  0007e	48 ff c0	 inc	 rax
  00081	48 89 44 24 40	 mov	 QWORD PTR p$[rsp], rax

; 1086 :         x >>= 8;

  00086	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  0008a	c1 f8 08	 sar	 eax, 8
  0008d	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 1087 :     } while (--i > 0);

  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00096	48 ff c8	 dec	 rax
  00099	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0009e	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000a4	7f c7		 jg	 SHORT $LN3@lp_int

; 1088 :     return 0;

  000a6	33 c0		 xor	 eax, eax
$LN8@lp_int:

; 1089 : }

  000a8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ac	c3		 ret	 0
lp_int	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_uint DD imagerel lp_uint
	DD	imagerel lp_uint+191
	DD	imagerel $unwind$lp_uint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_uint DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lp_uint
_TEXT	SEGMENT
x$ = 32
i$ = 40
maxint$21277 = 48
p$ = 80
v$ = 88
f$ = 96
lp_uint	PROC						; COMDAT

; 1093 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1094 :     unsigned long x;
; 1095 :     Py_ssize_t i;
; 1096 :     if (get_ulong(v, &x) < 0)

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  00018	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0001d	e8 00 00 00 00	 call	 get_ulong
  00022	85 c0		 test	 eax, eax
  00024	7d 0a		 jge	 SHORT $LN6@lp_uint

; 1097 :         return -1;

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	e9 8a 00 00 00	 jmp	 $LN7@lp_uint
$LN6@lp_uint:

; 1098 :     i = f->size;

  00030	48 8b 44 24 60	 mov	 rax, QWORD PTR f$[rsp]
  00035	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00039	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 1099 :     if (i != SIZEOF_LONG) {

  0003e	48 83 7c 24 28
	04		 cmp	 QWORD PTR i$[rsp], 4
  00044	74 39		 je	 SHORT $LN5@lp_uint

; 1100 :         unsigned long maxint = 1;

  00046	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR maxint$21277[rsp], 1

; 1101 :         maxint <<= (unsigned long)(i * 8);

  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00053	48 c1 e0 03	 shl	 rax, 3
  00057	0f b6 c8	 movzx	 ecx, al
  0005a	8b 44 24 30	 mov	 eax, DWORD PTR maxint$21277[rsp]
  0005e	d3 e0		 shl	 eax, cl
  00060	89 44 24 30	 mov	 DWORD PTR maxint$21277[rsp], eax

; 1102 :         if (x >= maxint)

  00064	8b 44 24 30	 mov	 eax, DWORD PTR maxint$21277[rsp]
  00068	39 44 24 20	 cmp	 DWORD PTR x$[rsp], eax
  0006c	72 11		 jb	 SHORT $LN4@lp_uint

; 1103 :             RANGE_ERROR(x, f, 1, maxint - 1);

  0006e	ba 01 00 00 00	 mov	 edx, 1
  00073	48 8b 4c 24 60	 mov	 rcx, QWORD PTR f$[rsp]
  00078	e8 00 00 00 00	 call	 _range_error
  0007d	eb 3b		 jmp	 SHORT $LN7@lp_uint
$LN4@lp_uint:
$LN5@lp_uint:
$LN3@lp_uint:

; 1104 :     }
; 1105 :     do {
; 1106 :         *p++ = (char)x;

  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00084	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR x$[rsp]
  00089	88 08		 mov	 BYTE PTR [rax], cl
  0008b	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 44 24 50	 mov	 QWORD PTR p$[rsp], rax

; 1107 :         x >>= 8;

  00098	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  0009c	c1 e8 08	 shr	 eax, 8
  0009f	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 1108 :     } while (--i > 0);

  000a3	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000a8	48 ff c8	 dec	 rax
  000ab	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  000b0	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000b6	7f c7		 jg	 SHORT $LN3@lp_uint

; 1109 :     return 0;

  000b8	33 c0		 xor	 eax, eax
$LN7@lp_uint:

; 1110 : }

  000ba	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000be	c3		 ret	 0
lp_uint	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_longlong DD imagerel lp_longlong
	DD	imagerel lp_longlong+107
	DD	imagerel $unwind$lp_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_longlong DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lp_longlong
_TEXT	SEGMENT
res$ = 48
p$ = 80
v$ = 88
f$ = 96
lp_longlong PROC					; COMDAT

; 1114 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1115 :     int res;
; 1116 :     v = get_pylong(v);

  00013	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 get_pylong
  0001d	48 89 44 24 58	 mov	 QWORD PTR v$[rsp], rax

; 1117 :     if (v == NULL)

  00022	48 83 7c 24 58
	00		 cmp	 QWORD PTR v$[rsp], 0
  00028	75 07		 jne	 SHORT $LN1@lp_longlon

; 1118 :         return -1;

  0002a	b8 ff ff ff ff	 mov	 eax, -1
  0002f	eb 35		 jmp	 SHORT $LN2@lp_longlon
$LN1@lp_longlon:

; 1119 :     res = _PyLong_AsByteArray((PyLongObject*)v,
; 1120 :                               (unsigned char *)p,
; 1121 :                               8,
; 1122 :                               1, /* little_endian */
; 1123 :                   1  /* signed */);

  00031	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00039	41 b9 01 00 00
	00		 mov	 r9d, 1
  0003f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00045	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$[rsp]
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0004f	e8 00 00 00 00	 call	 _PyLong_AsByteArray
  00054	89 44 24 30	 mov	 DWORD PTR res$[rsp], eax

; 1124 :     Py_DECREF(v);

  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0005d	e8 00 00 00 00	 call	 _Py_DecRef

; 1125 :     return res;

  00062	8b 44 24 30	 mov	 eax, DWORD PTR res$[rsp]
$LN2@lp_longlon:

; 1126 : }

  00066	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006a	c3		 ret	 0
lp_longlong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_ulonglong DD imagerel lp_ulonglong
	DD	imagerel lp_ulonglong+107
	DD	imagerel $unwind$lp_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_ulonglong DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lp_ulonglong
_TEXT	SEGMENT
res$ = 48
p$ = 80
v$ = 88
f$ = 96
lp_ulonglong PROC					; COMDAT

; 1130 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1131 :     int res;
; 1132 :     v = get_pylong(v);

  00013	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 get_pylong
  0001d	48 89 44 24 58	 mov	 QWORD PTR v$[rsp], rax

; 1133 :     if (v == NULL)

  00022	48 83 7c 24 58
	00		 cmp	 QWORD PTR v$[rsp], 0
  00028	75 07		 jne	 SHORT $LN1@lp_ulonglo

; 1134 :         return -1;

  0002a	b8 ff ff ff ff	 mov	 eax, -1
  0002f	eb 35		 jmp	 SHORT $LN2@lp_ulonglo
$LN1@lp_ulonglo:

; 1135 :     res = _PyLong_AsByteArray((PyLongObject*)v,
; 1136 :                               (unsigned char *)p,
; 1137 :                               8,
; 1138 :                               1, /* little_endian */
; 1139 :                   0  /* signed */);

  00031	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00039	41 b9 01 00 00
	00		 mov	 r9d, 1
  0003f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00045	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$[rsp]
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0004f	e8 00 00 00 00	 call	 _PyLong_AsByteArray
  00054	89 44 24 30	 mov	 DWORD PTR res$[rsp], eax

; 1140 :     Py_DECREF(v);

  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  0005d	e8 00 00 00 00	 call	 _Py_DecRef

; 1141 :     return res;

  00062	8b 44 24 30	 mov	 eax, DWORD PTR res$[rsp]
$LN2@lp_ulonglo:

; 1142 : }

  00066	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006a	c3		 ret	 0
lp_ulonglong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_float DD imagerel lp_float
	DD	imagerel lp_float+116
	DD	imagerel $unwind$lp_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_float DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lp_float
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
lp_float PROC						; COMDAT

; 1146 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1147 :     double x = PyFloat_AsDouble(v);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0001d	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1148 :     if (x == -1 && PyErr_Occurred()) {

  00023	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00029	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00031	7a 26		 jp	 SHORT $LN1@lp_float
  00033	75 24		 jne	 SHORT $LN1@lp_float
  00035	e8 00 00 00 00	 call	 PyErr_Occurred
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 1a		 je	 SHORT $LN1@lp_float

; 1149 :         PyErr_SetString(StructError,
; 1150 :                         "required argument is not a float");

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0004d	e8 00 00 00 00	 call	 PyErr_SetString

; 1151 :         return -1;

  00052	b8 ff ff ff ff	 mov	 eax, -1
  00057	eb 16		 jmp	 SHORT $LN2@lp_float
$LN1@lp_float:

; 1152 :     }
; 1153 :     return _PyFloat_Pack4(x, (unsigned char *)p, 1);

  00059	41 b8 01 00 00
	00		 mov	 r8d, 1
  0005f	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00064	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0006a	e8 00 00 00 00	 call	 _PyFloat_Pack4
$LN2@lp_float:

; 1154 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
lp_float ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_double DD imagerel lp_double
	DD	imagerel lp_double+116
	DD	imagerel $unwind$lp_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_double DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lp_double
_TEXT	SEGMENT
x$ = 32
p$ = 64
v$ = 72
f$ = 80
lp_double PROC						; COMDAT

; 1158 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1159 :     double x = PyFloat_AsDouble(v);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0001d	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1160 :     if (x == -1 && PyErr_Occurred()) {

  00023	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00029	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00031	7a 26		 jp	 SHORT $LN1@lp_double
  00033	75 24		 jne	 SHORT $LN1@lp_double
  00035	e8 00 00 00 00	 call	 PyErr_Occurred
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 1a		 je	 SHORT $LN1@lp_double

; 1161 :         PyErr_SetString(StructError,
; 1162 :                         "required argument is not a float");

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0004d	e8 00 00 00 00	 call	 PyErr_SetString

; 1163 :         return -1;

  00052	b8 ff ff ff ff	 mov	 eax, -1
  00057	eb 16		 jmp	 SHORT $LN2@lp_double
$LN1@lp_double:

; 1164 :     }
; 1165 :     return _PyFloat_Pack8(x, (unsigned char *)p, 1);

  00059	41 b8 01 00 00
	00		 mov	 r8d, 1
  0005f	48 8b 54 24 40	 mov	 rdx, QWORD PTR p$[rsp]
  00064	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0006a	e8 00 00 00 00	 call	 _PyFloat_Pack8
$LN2@lp_double:

; 1166 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
lp_double ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@ ; `string'
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_new DD	imagerel s_new
	DD	imagerel s_new+188
	DD	imagerel $unwind$s_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_new DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@
CONST	SEGMENT
??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@ DB 't'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'p', 00H, '_', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT s_new
_TEXT	SEGMENT
self$ = 32
s$21486 = 40
type$ = 64
args$ = 72
kwds$ = 80
s_new	PROC						; COMDAT

; 1386 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1387 :     PyObject *self;
; 1388 : 
; 1389 :     assert(type != NULL && type->tp_alloc != NULL);

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR type$[rsp], 0
  00019	74 0f		 je	 SHORT $LN4@s_new
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  00020	48 83 b8 88 01
	00 00 00	 cmp	 QWORD PTR [rax+392], 0
  00028	75 1c		 jne	 SHORT $LN5@s_new
$LN4@s_new:
  0002a	41 b8 6d 05 00
	00		 mov	 r8d, 1389		; 0000056dH
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00044	33 c0		 xor	 eax, eax
$LN5@s_new:

; 1390 : 
; 1391 :     self = type->tp_alloc(type, 0);

  00046	33 d2		 xor	 edx, edx
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  00052	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00058	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 1392 :     if (self != NULL) {

  0005d	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00063	74 4d		 je	 SHORT $LN1@s_new

; 1393 :         PyStructObject *s = (PyStructObject*)self;

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0006a	48 89 44 24 28	 mov	 QWORD PTR s$21486[rsp], rax

; 1394 :         Py_INCREF(Py_None);

  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00076	e8 00 00 00 00	 call	 _Py_IncRef

; 1395 :         s->s_format = Py_None;

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$21486[rsp]
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00087	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1396 :         s->s_codes = NULL;

  0008b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$21486[rsp]
  00090	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 1397 :         s->s_size = -1;

  00098	48 8b 44 24 28	 mov	 rax, QWORD PTR s$21486[rsp]
  0009d	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 1398 :         s->s_len = -1;

  000a5	48 8b 44 24 28	 mov	 rax, QWORD PTR s$21486[rsp]
  000aa	48 c7 40 68 ff
	ff ff ff	 mov	 QWORD PTR [rax+104], -1
$LN1@s_new:

; 1399 :     }
; 1400 :     return self;

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]

; 1401 : }

  000b7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bb	c3		 ret	 0
s_new	ENDP
_TEXT	ENDS
PUBLIC	??_C@_06BEFIJEE@s_init?$AA@			; `string'
PUBLIC	??_C@_0BF@DIOKFDPL@?4?4?2Modules?2_struct?4c?$AA@ ; `string'
PUBLIC	??_C@_0DH@JKNHLINK@Struct?$CI?$CJ?5argument?51?5must?5be?5a?5by@ ; `string'
PUBLIC	??_C@_08FAGPPOEF@O?3Struct?$AA@			; `string'
PUBLIC	??_C@_1CK@INOKNGO@?$AAP?$AAy?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyUnicode_AsASCIIString:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_init DD imagerel s_init
	DD	imagerel s_init+453
	DD	imagerel $unwind$s_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_init DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_06BEFIJEE@s_init?$AA@
CONST	SEGMENT
??_C@_06BEFIJEE@s_init?$AA@ DB 's_init', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DIOKFDPL@?4?4?2Modules?2_struct?4c?$AA@
CONST	SEGMENT
??_C@_0BF@DIOKFDPL@?4?4?2Modules?2_struct?4c?$AA@ DB '..\Modules\_struct.'
	DB	'c', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@JKNHLINK@Struct?$CI?$CJ?5argument?51?5must?5be?5a?5by@
CONST	SEGMENT
??_C@_0DH@JKNHLINK@Struct?$CI?$CJ?5argument?51?5must?5be?5a?5by@ DB 'Stru'
	DB	'ct() argument 1 must be a bytes object, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FAGPPOEF@O?3Struct?$AA@
CONST	SEGMENT
??_C@_08FAGPPOEF@O?3Struct?$AA@ DB 'O:Struct', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@INOKNGO@?$AAP?$AAy?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@INOKNGO@?$AAP?$AAy?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H
	DB	't', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k'
	DB	00H, '(', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'f', 00H, ')', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT s_init
_TEXT	SEGMENT
soself$ = 48
o_format$ = 56
ret$ = 64
_py_tmp$21529 = 72
self$ = 96
args$ = 104
kwds$ = 112
s_init	PROC						; COMDAT

; 1405 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1406 :     PyStructObject *soself = (PyStructObject *)self;

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 89 44 24 30	 mov	 QWORD PTR soself$[rsp], rax

; 1407 :     PyObject *o_format = NULL;

  0001d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR o_format$[rsp], 0

; 1408 :     int ret = 0;

  00026	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0

; 1409 :     static char *kwlist[] = {"format", 0};
; 1410 : 
; 1411 :     assert(PyStruct_Check(self));

  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyStructType
  00035	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0003a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003e	74 35		 je	 SHORT $LN12@s_init
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyStructType
  00047	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0004c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00050	e8 00 00 00 00	 call	 PyType_IsSubtype
  00055	85 c0		 test	 eax, eax
  00057	75 1c		 jne	 SHORT $LN12@s_init
  00059	41 b8 83 05 00
	00		 mov	 r8d, 1411		; 00000583H
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@INOKNGO@?$AAP?$AAy?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00073	33 c0		 xor	 eax, eax
$LN12@s_init:

; 1412 : 
; 1413 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:Struct", kwlist,
; 1414 :                                      &o_format))

  00075	48 8d 44 24 38	 lea	 rax, QWORD PTR o_format$[rsp]
  0007a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??s_init@@9@9
  00086	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08FAGPPOEF@O?3Struct?$AA@
  0008d	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwds$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00097	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0009c	85 c0		 test	 eax, eax
  0009e	75 0a		 jne	 SHORT $LN9@s_init

; 1415 :         return -1;

  000a0	b8 ff ff ff ff	 mov	 eax, -1
  000a5	e9 16 01 00 00	 jmp	 $LN10@s_init
$LN9@s_init:

; 1416 : 
; 1417 :     if (PyUnicode_Check(o_format)) {

  000aa	48 8b 44 24 38	 mov	 rax, QWORD PTR o_format$[rsp]
  000af	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000b3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000b9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000be	85 c0		 test	 eax, eax
  000c0	74 23		 je	 SHORT $LN8@s_init

; 1418 :         o_format = PyUnicode_AsASCIIString(o_format);

  000c2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR o_format$[rsp]
  000c7	e8 00 00 00 00	 call	 PyUnicode_AsASCIIString
  000cc	48 89 44 24 38	 mov	 QWORD PTR o_format$[rsp], rax

; 1419 :         if (o_format == NULL)

  000d1	48 83 7c 24 38
	00		 cmp	 QWORD PTR o_format$[rsp], 0
  000d7	75 0a		 jne	 SHORT $LN7@s_init

; 1420 :             return -1;

  000d9	b8 ff ff ff ff	 mov	 eax, -1
  000de	e9 dd 00 00 00	 jmp	 $LN10@s_init
$LN7@s_init:

; 1421 :     }
; 1422 :     /* XXX support buffer interface, too */
; 1423 :     else {

  000e3	eb 0a		 jmp	 SHORT $LN6@s_init
$LN8@s_init:

; 1424 :         Py_INCREF(o_format);

  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR o_format$[rsp]
  000ea	e8 00 00 00 00	 call	 _Py_IncRef
$LN6@s_init:

; 1425 :     }
; 1426 : 
; 1427 :     if (!PyBytes_Check(o_format)) {

  000ef	48 8b 44 24 38	 mov	 rax, QWORD PTR o_format$[rsp]
  000f4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000fe	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00103	85 c0		 test	 eax, eax
  00105	75 34		 jne	 SHORT $LN5@s_init

; 1428 :         Py_DECREF(o_format);

  00107	48 8b 4c 24 38	 mov	 rcx, QWORD PTR o_format$[rsp]
  0010c	e8 00 00 00 00	 call	 _Py_DecRef

; 1429 :         PyErr_Format(PyExc_TypeError,
; 1430 :                      "Struct() argument 1 must be a bytes object, not %.200s",
; 1431 :                      Py_TYPE(o_format)->tp_name);

  00111	48 8b 44 24 38	 mov	 rax, QWORD PTR o_format$[rsp]
  00116	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0011a	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@JKNHLINK@Struct?$CI?$CJ?5argument?51?5must?5be?5a?5by@
  00125	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0012c	e8 00 00 00 00	 call	 PyErr_Format

; 1432 :         return -1;

  00131	b8 ff ff ff ff	 mov	 eax, -1
  00136	e9 85 00 00 00	 jmp	 $LN10@s_init
$LN5@s_init:
$LN4@s_init:

; 1433 :     }
; 1434 : 
; 1435 :     Py_CLEAR(soself->s_format);

  0013b	48 8b 44 24 30	 mov	 rax, QWORD PTR soself$[rsp]
  00140	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00145	74 53		 je	 SHORT $LN1@s_init
  00147	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0014f	48 8b 44 24 30	 mov	 rax, QWORD PTR soself$[rsp]
  00154	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  00158	41 b8 9b 05 00
	00		 mov	 r8d, 1435		; 0000059bH
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@DIOKFDPL@?4?4?2Modules?2_struct?4c?$AA@
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06BEFIJEE@s_init?$AA@
  0016c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00171	85 c0		 test	 eax, eax
  00173	75 25		 jne	 SHORT $LN1@s_init
  00175	48 8b 44 24 30	 mov	 rax, QWORD PTR soself$[rsp]
  0017a	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0017e	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$21529[rsp], rax
  00183	48 8b 44 24 30	 mov	 rax, QWORD PTR soself$[rsp]
  00188	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
  00190	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$21529[rsp]
  00195	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@s_init:
  0019a	33 c0		 xor	 eax, eax
  0019c	85 c0		 test	 eax, eax
  0019e	75 9b		 jne	 SHORT $LN4@s_init

; 1436 :     soself->s_format = o_format;

  001a0	48 8b 44 24 30	 mov	 rax, QWORD PTR soself$[rsp]
  001a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR o_format$[rsp]
  001aa	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1437 : 
; 1438 :     ret = prepare_s(soself);

  001ae	48 8b 4c 24 30	 mov	 rcx, QWORD PTR soself$[rsp]
  001b3	e8 00 00 00 00	 call	 prepare_s
  001b8	89 44 24 40	 mov	 DWORD PTR ret$[rsp], eax

; 1439 :     return ret;

  001bc	8b 44 24 40	 mov	 eax, DWORD PTR ret$[rsp]
$LN10@s_init:

; 1440 : }

  001c0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c4	c3		 ret	 0
s_init	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@BKFKBDHI@total?5struct?5size?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0CM@MBFNOLLD@repeat?5count?5given?5without?5forma@ ; `string'
PUBLIC	??_C@_1DM@LMJACKPL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$prepare_s DD imagerel prepare_s
	DD	imagerel prepare_s+1531
	DD	imagerel $unwind$prepare_s
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$prepare_s DD 020c01H
	DD	013010cH
xdata	ENDS
;	COMDAT ??_C@_0BL@BKFKBDHI@total?5struct?5size?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BL@BKFKBDHI@total?5struct?5size?5too?5long?$AA@ DB 'total struct s'
	DB	'ize too long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MBFNOLLD@repeat?5count?5given?5without?5forma@
CONST	SEGMENT
??_C@_0CM@MBFNOLLD@repeat?5count?5given?5without?5forma@ DB 'repeat count'
	DB	' given without format specifier', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@LMJACKPL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@LMJACKPL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H
	DB	's', 00H, '_', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a'
	DB	00H, 't', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT prepare_s
_TEXT	SEGMENT
itemsize$ = 32
num$ = 40
s$ = 48
f$ = 56
codes$ = 64
len$ = 72
size$ = 80
fmt$ = 88
c$ = 96
e$ = 104
tv156 = 112
tv189 = 120
tv199 = 128
self$ = 160
prepare_s PROC						; COMDAT

; 1256 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1257 :     const formatdef *f;
; 1258 :     const formatdef *e;
; 1259 :     formatcode *codes;
; 1260 : 
; 1261 :     const char *s;
; 1262 :     const char *fmt;
; 1263 :     char c;
; 1264 :     Py_ssize_t size, len, num, itemsize;
; 1265 : 
; 1266 :     fmt = PyBytes_AS_STRING(self->s_format);

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00014	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00027	85 c0		 test	 eax, eax
  00029	75 1c		 jne	 SHORT $LN39@prepare_s
  0002b	41 b8 f2 04 00
	00		 mov	 r8d, 1266		; 000004f2H
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@LMJACKPL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$CJ?$AA?$AA@
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00045	33 c0		 xor	 eax, eax
$LN39@prepare_s:
  00047	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0004f	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00053	48 83 c0 78	 add	 rax, 120		; 00000078H
  00057	48 89 44 24 58	 mov	 QWORD PTR fmt$[rsp], rax

; 1267 : 
; 1268 :     f = whichtable((char **)&fmt);

  0005c	48 8d 4c 24 58	 lea	 rcx, QWORD PTR fmt$[rsp]
  00061	e8 00 00 00 00	 call	 whichtable
  00066	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax

; 1269 : 
; 1270 :     s = fmt;

  0006b	48 8b 44 24 58	 mov	 rax, QWORD PTR fmt$[rsp]
  00070	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 1271 :     size = 0;

  00075	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR size$[rsp], 0

; 1272 :     len = 0;

  0007e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0
$LN44@prepare_s:
$LN36@prepare_s:

; 1273 :     while ((c = *s++) != '\0') {

  00087	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0008c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008f	88 44 24 60	 mov	 BYTE PTR c$[rsp], al
  00093	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  00098	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0009d	48 ff c1	 inc	 rcx
  000a0	48 89 4c 24 30	 mov	 QWORD PTR s$[rsp], rcx
  000a5	85 c0		 test	 eax, eax
  000a7	0f 84 ed 01 00
	00		 je	 $LN35@prepare_s

; 1274 :         if (Py_ISSPACE(Py_CHARMASK(c)))

  000ad	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  000b2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b7	0f b6 c0	 movzx	 eax, al
  000ba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000bf	0f b6 c0	 movzx	 eax, al
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000c9	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000cc	83 e0 08	 and	 eax, 8
  000cf	85 c0		 test	 eax, eax
  000d1	74 02		 je	 SHORT $LN34@prepare_s

; 1275 :             continue;

  000d3	eb b2		 jmp	 SHORT $LN36@prepare_s
$LN34@prepare_s:

; 1276 :         if ('0' <= c && c <= '9') {

  000d5	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  000da	83 f8 30	 cmp	 eax, 48			; 00000030H
  000dd	0f 8c ca 00 00
	00		 jl	 $LN33@prepare_s
  000e3	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  000e8	83 f8 39	 cmp	 eax, 57			; 00000039H
  000eb	0f 8f bc 00 00
	00		 jg	 $LN33@prepare_s

; 1277 :             num = c - '0';

  000f1	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  000f6	83 e8 30	 sub	 eax, 48			; 00000030H
  000f9	48 98		 cdqe
  000fb	48 89 44 24 28	 mov	 QWORD PTR num$[rsp], rax
$LN32@prepare_s:

; 1278 :             while ('0' <= (c = *s++) && c <= '9') {

  00100	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00105	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00108	88 44 24 60	 mov	 BYTE PTR c$[rsp], al
  0010c	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  00111	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00116	48 ff c1	 inc	 rcx
  00119	48 89 4c 24 30	 mov	 QWORD PTR s$[rsp], rcx
  0011e	83 f8 30	 cmp	 eax, 48			; 00000030H
  00121	7c 62		 jl	 SHORT $LN31@prepare_s
  00123	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  00128	83 f8 39	 cmp	 eax, 57			; 00000039H
  0012b	7f 58		 jg	 SHORT $LN31@prepare_s

; 1279 :                 /* overflow-safe version of
; 1280 :                    if (num*10 + (c - '0') > PY_SSIZE_T_MAX) { ... } */
; 1281 :                 if (num >= PY_SSIZE_T_MAX / 10 && (
; 1282 :                         num > PY_SSIZE_T_MAX / 10 ||
; 1283 :                         (c - '0') > PY_SSIZE_T_MAX % 10))

  0012d	48 b8 cc cc cc
	cc cc cc cc 0c	 mov	 rax, 922337203685477580	; 0cccccccccccccccH
  00137	48 39 44 24 28	 cmp	 QWORD PTR num$[rsp], rax
  0013c	7c 26		 jl	 SHORT $LN30@prepare_s
  0013e	48 b8 cc cc cc
	cc cc cc cc 0c	 mov	 rax, 922337203685477580	; 0cccccccccccccccH
  00148	48 39 44 24 28	 cmp	 QWORD PTR num$[rsp], rax
  0014d	7f 10		 jg	 SHORT $LN29@prepare_s
  0014f	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  00154	83 e8 30	 sub	 eax, 48			; 00000030H
  00157	48 98		 cdqe
  00159	48 83 f8 07	 cmp	 rax, 7
  0015d	7e 05		 jle	 SHORT $LN30@prepare_s
$LN29@prepare_s:

; 1284 :                     goto overflow;

  0015f	e9 77 04 00 00	 jmp	 $overflow$21420
$LN30@prepare_s:

; 1285 :                 num = num*10 + (c - '0');

  00164	48 8b 44 24 28	 mov	 rax, QWORD PTR num$[rsp]
  00169	48 6b c0 0a	 imul	 rax, 10
  0016d	0f be 4c 24 60	 movsx	 ecx, BYTE PTR c$[rsp]
  00172	83 e9 30	 sub	 ecx, 48			; 00000030H
  00175	48 63 c9	 movsxd	 rcx, ecx
  00178	48 03 c1	 add	 rax, rcx
  0017b	48 89 44 24 28	 mov	 QWORD PTR num$[rsp], rax

; 1286 :             }

  00180	e9 7b ff ff ff	 jmp	 $LN32@prepare_s
$LN31@prepare_s:

; 1287 :             if (c == '\0') {

  00185	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  0018a	85 c0		 test	 eax, eax
  0018c	75 1d		 jne	 SHORT $LN28@prepare_s

; 1288 :                 PyErr_SetString(StructError,
; 1289 :                                 "repeat count given without format specifier");

  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@MBFNOLLD@repeat?5count?5given?5without?5forma@
  00195	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0019c	e8 00 00 00 00	 call	 PyErr_SetString

; 1290 :                 return -1;

  001a1	b8 ff ff ff ff	 mov	 eax, -1
  001a6	e9 48 04 00 00	 jmp	 $LN37@prepare_s
$LN28@prepare_s:

; 1291 :             }
; 1292 :         }
; 1293 :         else

  001ab	eb 09		 jmp	 SHORT $LN27@prepare_s
$LN33@prepare_s:

; 1294 :             num = 1;

  001ad	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR num$[rsp], 1
$LN27@prepare_s:

; 1295 : 
; 1296 :         e = getentry(c, f);

  001b6	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  001bb	48 8b 54 24 38	 mov	 rdx, QWORD PTR f$[rsp]
  001c0	8b c8		 mov	 ecx, eax
  001c2	e8 00 00 00 00	 call	 getentry
  001c7	48 89 44 24 68	 mov	 QWORD PTR e$[rsp], rax

; 1297 :         if (e == NULL)

  001cc	48 83 7c 24 68
	00		 cmp	 QWORD PTR e$[rsp], 0
  001d2	75 0a		 jne	 SHORT $LN26@prepare_s

; 1298 :             return -1;

  001d4	b8 ff ff ff ff	 mov	 eax, -1
  001d9	e9 15 04 00 00	 jmp	 $LN37@prepare_s
$LN26@prepare_s:

; 1299 : 
; 1300 :         switch (c) {

  001de	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp]
  001e3	88 44 24 70	 mov	 BYTE PTR tv156[rsp], al
  001e7	80 7c 24 70 70	 cmp	 BYTE PTR tv156[rsp], 112 ; 00000070H
  001ec	74 10		 je	 SHORT $LN23@prepare_s
  001ee	80 7c 24 70 73	 cmp	 BYTE PTR tv156[rsp], 115 ; 00000073H
  001f3	74 09		 je	 SHORT $LN23@prepare_s
  001f5	80 7c 24 70 78	 cmp	 BYTE PTR tv156[rsp], 120 ; 00000078H
  001fa	74 11		 je	 SHORT $LN22@prepare_s
  001fc	eb 11		 jmp	 SHORT $LN21@prepare_s
$LN23@prepare_s:

; 1301 :             case 's': /* fall through */
; 1302 :             case 'p': len++; break;

  001fe	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00203	48 ff c0	 inc	 rax
  00206	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax
  0020b	eb 17		 jmp	 SHORT $LN24@prepare_s
$LN22@prepare_s:

; 1303 :             case 'x': break;

  0020d	eb 15		 jmp	 SHORT $LN24@prepare_s
$LN21@prepare_s:

; 1304 :             default: len += num; break;

  0020f	48 8b 44 24 28	 mov	 rax, QWORD PTR num$[rsp]
  00214	48 8b 4c 24 48	 mov	 rcx, QWORD PTR len$[rsp]
  00219	48 03 c8	 add	 rcx, rax
  0021c	48 8b c1	 mov	 rax, rcx
  0021f	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax
$LN24@prepare_s:

; 1305 :         }
; 1306 : 
; 1307 :         itemsize = e->size;

  00224	48 8b 44 24 68	 mov	 rax, QWORD PTR e$[rsp]
  00229	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0022d	48 89 44 24 20	 mov	 QWORD PTR itemsize$[rsp], rax

; 1308 :         size = align(size, c, e);

  00232	4c 8b 44 24 68	 mov	 r8, QWORD PTR e$[rsp]
  00237	0f b6 54 24 60	 movzx	 edx, BYTE PTR c$[rsp]
  0023c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$[rsp]
  00241	e8 00 00 00 00	 call	 align
  00246	48 89 44 24 50	 mov	 QWORD PTR size$[rsp], rax

; 1309 :         if (size == -1)

  0024b	48 83 7c 24 50
	ff		 cmp	 QWORD PTR size$[rsp], -1
  00251	75 05		 jne	 SHORT $LN20@prepare_s

; 1310 :             goto overflow;

  00253	e9 83 03 00 00	 jmp	 $overflow$21420
$LN20@prepare_s:

; 1311 : 
; 1312 :         /* if (size + num * itemsize > PY_SSIZE_T_MAX) { ... } */
; 1313 :         if (num > (PY_SSIZE_T_MAX - size) / itemsize)

  00258	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00262	48 2b 44 24 50	 sub	 rax, QWORD PTR size$[rsp]
  00267	48 99		 cdq
  00269	48 f7 7c 24 20	 idiv	 QWORD PTR itemsize$[rsp]
  0026e	48 39 44 24 28	 cmp	 QWORD PTR num$[rsp], rax
  00273	7e 05		 jle	 SHORT $LN19@prepare_s

; 1314 :             goto overflow;

  00275	e9 61 03 00 00	 jmp	 $overflow$21420
$LN19@prepare_s:

; 1315 :         size += num * itemsize;

  0027a	48 8b 44 24 28	 mov	 rax, QWORD PTR num$[rsp]
  0027f	48 0f af 44 24
	20		 imul	 rax, QWORD PTR itemsize$[rsp]
  00285	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$[rsp]
  0028a	48 03 c8	 add	 rcx, rax
  0028d	48 8b c1	 mov	 rax, rcx
  00290	48 89 44 24 50	 mov	 QWORD PTR size$[rsp], rax

; 1316 :     }

  00295	e9 ed fd ff ff	 jmp	 $LN44@prepare_s
$LN35@prepare_s:

; 1317 : 
; 1318 :     /* check for overflow */
; 1319 :     if ((len + 1) > (PY_SSIZE_T_MAX / sizeof(formatcode))) {

  0029a	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  0029f	48 ff c0	 inc	 rax
  002a2	48 b9 55 55 55
	55 55 55 55 05	 mov	 rcx, 384307168202282325	; 0555555555555555H
  002ac	48 3b c1	 cmp	 rax, rcx
  002af	76 0f		 jbe	 SHORT $LN18@prepare_s

; 1320 :         PyErr_NoMemory();

  002b1	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1321 :         return -1;

  002b6	b8 ff ff ff ff	 mov	 eax, -1
  002bb	e9 33 03 00 00	 jmp	 $LN37@prepare_s
$LN18@prepare_s:

; 1322 :     }
; 1323 : 
; 1324 :     self->s_size = size;

  002c0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$[rsp]
  002cd	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1325 :     self->s_len = len;

  002d1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002d9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR len$[rsp]
  002de	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1326 :     codes = PyMem_MALLOC((len + 1) * sizeof(formatcode));

  002e2	e8 00 00 00 00	 call	 _Py_PXCTX
  002e7	85 c0		 test	 eax, eax
  002e9	74 1b		 je	 SHORT $LN40@prepare_s
  002eb	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  002f0	48 ff c0	 inc	 rax
  002f3	48 6b c0 18	 imul	 rax, 24
  002f7	48 8b c8	 mov	 rcx, rax
  002fa	e8 00 00 00 00	 call	 _PxMem_Malloc
  002ff	48 89 44 24 78	 mov	 QWORD PTR tv189[rsp], rax
  00304	eb 19		 jmp	 SHORT $LN41@prepare_s
$LN40@prepare_s:
  00306	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  0030b	48 ff c0	 inc	 rax
  0030e	48 6b c0 18	 imul	 rax, 24
  00312	48 8b c8	 mov	 rcx, rax
  00315	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0031a	48 89 44 24 78	 mov	 QWORD PTR tv189[rsp], rax
$LN41@prepare_s:
  0031f	48 8b 44 24 78	 mov	 rax, QWORD PTR tv189[rsp]
  00324	48 89 44 24 40	 mov	 QWORD PTR codes$[rsp], rax

; 1327 :     if (codes == NULL) {

  00329	48 83 7c 24 40
	00		 cmp	 QWORD PTR codes$[rsp], 0
  0032f	75 0f		 jne	 SHORT $LN17@prepare_s

; 1328 :         PyErr_NoMemory();

  00331	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1329 :         return -1;

  00336	b8 ff ff ff ff	 mov	 eax, -1
  0033b	e9 b3 02 00 00	 jmp	 $LN37@prepare_s
$LN17@prepare_s:

; 1330 :     }
; 1331 :     /* Free any s_codes value left over from a previous initialization. */
; 1332 :     if (self->s_codes != NULL)

  00340	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00348	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0034d	74 43		 je	 SHORT $LN16@prepare_s

; 1333 :         PyMem_FREE(self->s_codes);

  0034f	e8 00 00 00 00	 call	 _Py_PXCTX
  00354	85 c0		 test	 eax, eax
  00356	74 1e		 je	 SHORT $LN42@prepare_s
  00358	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00360	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00364	e8 00 00 00 00	 call	 _PxMem_Free
  00369	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv199[rsp], 0
  00374	eb 1c		 jmp	 SHORT $LN43@prepare_s
$LN42@prepare_s:
  00376	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0037e	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00382	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00387	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv199[rsp], 0
$LN43@prepare_s:
$LN16@prepare_s:

; 1334 :     self->s_codes = codes;

  00392	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0039a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR codes$[rsp]
  0039f	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 1335 : 
; 1336 :     s = fmt;

  003a3	48 8b 44 24 58	 mov	 rax, QWORD PTR fmt$[rsp]
  003a8	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 1337 :     size = 0;

  003ad	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR size$[rsp], 0
$LN45@prepare_s:
$LN15@prepare_s:

; 1338 :     while ((c = *s++) != '\0') {

  003b6	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  003bb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003be	88 44 24 60	 mov	 BYTE PTR c$[rsp], al
  003c2	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  003c7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  003cc	48 ff c1	 inc	 rcx
  003cf	48 89 4c 24 30	 mov	 QWORD PTR s$[rsp], rcx
  003d4	85 c0		 test	 eax, eax
  003d6	0f 84 d4 01 00
	00		 je	 $LN14@prepare_s

; 1339 :         if (Py_ISSPACE(Py_CHARMASK(c)))

  003dc	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  003e1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003e6	0f b6 c0	 movzx	 eax, al
  003e9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003ee	0f b6 c0	 movzx	 eax, al
  003f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  003f8	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  003fb	83 e0 08	 and	 eax, 8
  003fe	85 c0		 test	 eax, eax
  00400	74 02		 je	 SHORT $LN13@prepare_s

; 1340 :             continue;

  00402	eb b2		 jmp	 SHORT $LN15@prepare_s
$LN13@prepare_s:

; 1341 :         if ('0' <= c && c <= '9') {

  00404	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  00409	83 f8 30	 cmp	 eax, 48			; 00000030H
  0040c	7c 74		 jl	 SHORT $LN12@prepare_s
  0040e	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  00413	83 f8 39	 cmp	 eax, 57			; 00000039H
  00416	7f 6a		 jg	 SHORT $LN12@prepare_s

; 1342 :             num = c - '0';

  00418	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  0041d	83 e8 30	 sub	 eax, 48			; 00000030H
  00420	48 98		 cdqe
  00422	48 89 44 24 28	 mov	 QWORD PTR num$[rsp], rax
$LN11@prepare_s:

; 1343 :             while ('0' <= (c = *s++) && c <= '9')

  00427	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0042c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0042f	88 44 24 60	 mov	 BYTE PTR c$[rsp], al
  00433	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  00438	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0043d	48 ff c1	 inc	 rcx
  00440	48 89 4c 24 30	 mov	 QWORD PTR s$[rsp], rcx
  00445	83 f8 30	 cmp	 eax, 48			; 00000030H
  00448	7c 28		 jl	 SHORT $LN10@prepare_s
  0044a	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  0044f	83 f8 39	 cmp	 eax, 57			; 00000039H
  00452	7f 1e		 jg	 SHORT $LN10@prepare_s

; 1344 :                 num = num*10 + (c - '0');

  00454	48 8b 44 24 28	 mov	 rax, QWORD PTR num$[rsp]
  00459	48 6b c0 0a	 imul	 rax, 10
  0045d	0f be 4c 24 60	 movsx	 ecx, BYTE PTR c$[rsp]
  00462	83 e9 30	 sub	 ecx, 48			; 00000030H
  00465	48 63 c9	 movsxd	 rcx, ecx
  00468	48 03 c1	 add	 rax, rcx
  0046b	48 89 44 24 28	 mov	 QWORD PTR num$[rsp], rax
  00470	eb b5		 jmp	 SHORT $LN11@prepare_s
$LN10@prepare_s:

; 1345 :             if (c == '\0')

  00472	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  00477	85 c0		 test	 eax, eax
  00479	75 05		 jne	 SHORT $LN9@prepare_s

; 1346 :                 break;

  0047b	e9 30 01 00 00	 jmp	 $LN14@prepare_s
$LN9@prepare_s:

; 1347 :         }
; 1348 :         else

  00480	eb 09		 jmp	 SHORT $LN8@prepare_s
$LN12@prepare_s:

; 1349 :             num = 1;

  00482	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR num$[rsp], 1
$LN8@prepare_s:

; 1350 : 
; 1351 :         e = getentry(c, f);

  0048b	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  00490	48 8b 54 24 38	 mov	 rdx, QWORD PTR f$[rsp]
  00495	8b c8		 mov	 ecx, eax
  00497	e8 00 00 00 00	 call	 getentry
  0049c	48 89 44 24 68	 mov	 QWORD PTR e$[rsp], rax

; 1352 : 
; 1353 :         size = align(size, c, e);

  004a1	4c 8b 44 24 68	 mov	 r8, QWORD PTR e$[rsp]
  004a6	0f b6 54 24 60	 movzx	 edx, BYTE PTR c$[rsp]
  004ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$[rsp]
  004b0	e8 00 00 00 00	 call	 align
  004b5	48 89 44 24 50	 mov	 QWORD PTR size$[rsp], rax

; 1354 :         if (c == 's' || c == 'p') {

  004ba	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  004bf	83 f8 73	 cmp	 eax, 115		; 00000073H
  004c2	74 0a		 je	 SHORT $LN6@prepare_s
  004c4	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  004c9	83 f8 70	 cmp	 eax, 112		; 00000070H
  004cc	75 51		 jne	 SHORT $LN7@prepare_s
$LN6@prepare_s:

; 1355 :             codes->offset = size;

  004ce	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  004d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$[rsp]
  004d8	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1356 :             codes->size = num;

  004dc	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  004e1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR num$[rsp]
  004e6	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1357 :             codes->fmtdef = e;

  004ea	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  004ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR e$[rsp]
  004f4	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1358 :             codes++;

  004f7	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  004fc	48 83 c0 18	 add	 rax, 24
  00500	48 89 44 24 40	 mov	 QWORD PTR codes$[rsp], rax

; 1359 :             size += num;

  00505	48 8b 44 24 28	 mov	 rax, QWORD PTR num$[rsp]
  0050a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$[rsp]
  0050f	48 03 c8	 add	 rcx, rax
  00512	48 8b c1	 mov	 rax, rcx
  00515	48 89 44 24 50	 mov	 QWORD PTR size$[rsp], rax
  0051a	e9 8c 00 00 00	 jmp	 $LN5@prepare_s
$LN7@prepare_s:

; 1360 :         } else if (c == 'x') {

  0051f	0f be 44 24 60	 movsx	 eax, BYTE PTR c$[rsp]
  00524	83 f8 78	 cmp	 eax, 120		; 00000078H
  00527	75 17		 jne	 SHORT $LN4@prepare_s

; 1361 :             size += num;

  00529	48 8b 44 24 28	 mov	 rax, QWORD PTR num$[rsp]
  0052e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$[rsp]
  00533	48 03 c8	 add	 rcx, rax
  00536	48 8b c1	 mov	 rax, rcx
  00539	48 89 44 24 50	 mov	 QWORD PTR size$[rsp], rax

; 1362 :         } else {

  0053e	eb 6b		 jmp	 SHORT $LN3@prepare_s
$LN4@prepare_s:
$LN2@prepare_s:

; 1363 :             while (--num >= 0) {

  00540	48 8b 44 24 28	 mov	 rax, QWORD PTR num$[rsp]
  00545	48 ff c8	 dec	 rax
  00548	48 89 44 24 28	 mov	 QWORD PTR num$[rsp], rax
  0054d	48 83 7c 24 28
	00		 cmp	 QWORD PTR num$[rsp], 0
  00553	7c 56		 jl	 SHORT $LN1@prepare_s

; 1364 :                 codes->offset = size;

  00555	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  0055a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$[rsp]
  0055f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1365 :                 codes->size = e->size;

  00563	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  00568	48 8b 4c 24 68	 mov	 rcx, QWORD PTR e$[rsp]
  0056d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00571	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1366 :                 codes->fmtdef = e;

  00575	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  0057a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR e$[rsp]
  0057f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1367 :                 codes++;

  00582	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  00587	48 83 c0 18	 add	 rax, 24
  0058b	48 89 44 24 40	 mov	 QWORD PTR codes$[rsp], rax

; 1368 :                 size += e->size;

  00590	48 8b 44 24 68	 mov	 rax, QWORD PTR e$[rsp]
  00595	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00599	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$[rsp]
  0059e	48 03 c8	 add	 rcx, rax
  005a1	48 8b c1	 mov	 rax, rcx
  005a4	48 89 44 24 50	 mov	 QWORD PTR size$[rsp], rax

; 1369 :             }

  005a9	eb 95		 jmp	 SHORT $LN2@prepare_s
$LN1@prepare_s:
$LN3@prepare_s:
$LN5@prepare_s:

; 1370 :         }
; 1371 :     }

  005ab	e9 06 fe ff ff	 jmp	 $LN45@prepare_s
$LN14@prepare_s:

; 1372 :     codes->fmtdef = NULL;

  005b0	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  005b5	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1373 :     codes->offset = size;

  005bc	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  005c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR size$[rsp]
  005c6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1374 :     codes->size = 0;

  005ca	48 8b 44 24 40	 mov	 rax, QWORD PTR codes$[rsp]
  005cf	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1375 : 
; 1376 :     return 0;

  005d7	33 c0		 xor	 eax, eax
  005d9	eb 18		 jmp	 SHORT $LN37@prepare_s
$overflow$21420:

; 1377 : 
; 1378 :   overflow:
; 1379 :     PyErr_SetString(StructError,
; 1380 :                     "total struct size too long");

  005db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@BKFKBDHI@total?5struct?5size?5too?5long?$AA@
  005e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  005e9	e8 00 00 00 00	 call	 PyErr_SetString

; 1381 :     return -1;

  005ee	b8 ff ff ff ff	 mov	 eax, -1
$LN37@prepare_s:

; 1382 : }

  005f3	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  005fa	c3		 ret	 0
prepare_s ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$whichtable DD imagerel whichtable
	DD	imagerel whichtable+188
	DD	imagerel $unwind$whichtable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$whichtable DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT whichtable
_TEXT	SEGMENT
fmt$ = 0
p$21351 = 8
n$21350 = 16
tv66 = 20
pfmt$ = 48
whichtable PROC						; COMDAT

; 1193 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1194 :     const char *fmt = (*pfmt)++; /* May be backed out of later */

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR pfmt$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR fmt$[rsp], rax
  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR pfmt$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001d	48 ff c0	 inc	 rax
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00025	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1195 :     switch (*fmt) {

  00028	48 8b 04 24	 mov	 rax, QWORD PTR fmt$[rsp]
  0002c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002f	88 44 24 14	 mov	 BYTE PTR tv66[rsp], al
  00033	80 7c 24 14 21	 cmp	 BYTE PTR tv66[rsp], 33	; 00000021H
  00038	74 27		 je	 SHORT $LN6@whichtable
  0003a	80 7c 24 14 3c	 cmp	 BYTE PTR tv66[rsp], 60	; 0000003cH
  0003f	74 17		 je	 SHORT $LN7@whichtable
  00041	80 7c 24 14 3d	 cmp	 BYTE PTR tv66[rsp], 61	; 0000003dH
  00046	74 22		 je	 SHORT $LN5@whichtable
  00048	80 7c 24 14 3e	 cmp	 BYTE PTR tv66[rsp], 62	; 0000003eH
  0004d	74 12		 je	 SHORT $LN6@whichtable
  0004f	80 7c 24 14 40	 cmp	 BYTE PTR tv66[rsp], 64	; 00000040H
  00054	74 5a		 je	 SHORT $LN1@whichtable
  00056	eb 45		 jmp	 SHORT $LN2@whichtable
$LN7@whichtable:

; 1196 :     case '<':
; 1197 :         return lilendian_table;

  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lilendian_table
  0005f	eb 56		 jmp	 SHORT $LN10@whichtable
$LN6@whichtable:

; 1198 :     case '>':
; 1199 :     case '!': /* Network byte order is big-endian */
; 1200 :         return bigendian_table;

  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bigendian_table
  00068	eb 4d		 jmp	 SHORT $LN10@whichtable
$LN5@whichtable:

; 1201 :     case '=': { /* Host byte order -- different from native in alignment! */
; 1202 :         int n = 1;

  0006a	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR n$21350[rsp], 1

; 1203 :         char *p = (char *) &n;

  00072	48 8d 44 24 10	 lea	 rax, QWORD PTR n$21350[rsp]
  00077	48 89 44 24 08	 mov	 QWORD PTR p$21351[rsp], rax

; 1204 :         if (*p == 1)

  0007c	48 8b 44 24 08	 mov	 rax, QWORD PTR p$21351[rsp]
  00081	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00084	83 f8 01	 cmp	 eax, 1
  00087	75 0b		 jne	 SHORT $LN4@whichtable

; 1205 :             return lilendian_table;

  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lilendian_table
  00090	eb 25		 jmp	 SHORT $LN10@whichtable

; 1206 :         else

  00092	eb 09		 jmp	 SHORT $LN3@whichtable
$LN4@whichtable:

; 1207 :             return bigendian_table;

  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bigendian_table
  0009b	eb 1a		 jmp	 SHORT $LN10@whichtable
$LN3@whichtable:
$LN2@whichtable:

; 1208 :     }
; 1209 :     default:
; 1210 :         --*pfmt; /* Back out of pointer increment */

  0009d	48 8b 44 24 30	 mov	 rax, QWORD PTR pfmt$[rsp]
  000a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a5	48 ff c8	 dec	 rax
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000ad	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN1@whichtable:

; 1211 :         /* Fall through */
; 1212 :     case '@':
; 1213 :         return native_table;

  000b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:native_table
$LN10@whichtable:

; 1214 :     }
; 1215 : }

  000b7	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000bb	c3		 ret	 0
whichtable ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@CKDNFKKL@bad?5char?5in?5struct?5format?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$getentry DD imagerel getentry
	DD	imagerel getentry+90
	DD	imagerel $unwind$getentry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getentry DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT ??_C@_0BK@CKDNFKKL@bad?5char?5in?5struct?5format?$AA@
CONST	SEGMENT
??_C@_0BK@CKDNFKKL@bad?5char?5in?5struct?5format?$AA@ DB 'bad char in str'
	DB	'uct format', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT getentry
_TEXT	SEGMENT
c$ = 48
f$ = 56
getentry PROC						; COMDAT

; 1222 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1223 :     for (; f->format != '\0'; f++) {

  0000d	eb 0e		 jmp	 SHORT $LN4@getentry
$LN3@getentry:
  0000f	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00014	48 83 c0 28	 add	 rax, 40			; 00000028H
  00018	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax
$LN4@getentry:
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  00022	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00025	85 c0		 test	 eax, eax
  00027	74 17		 je	 SHORT $LN2@getentry

; 1224 :         if (f->format == c) {

  00029	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  0002e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00031	3b 44 24 30	 cmp	 eax, DWORD PTR c$[rsp]
  00035	75 07		 jne	 SHORT $LN1@getentry

; 1225 :             return f;

  00037	48 8b 44 24 38	 mov	 rax, QWORD PTR f$[rsp]
  0003c	eb 17		 jmp	 SHORT $LN5@getentry
$LN1@getentry:

; 1226 :         }
; 1227 :     }

  0003e	eb cf		 jmp	 SHORT $LN3@getentry
$LN2@getentry:

; 1228 :     PyErr_SetString(StructError, "bad char in struct format");

  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@CKDNFKKL@bad?5char?5in?5struct?5format?$AA@
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0004e	e8 00 00 00 00	 call	 PyErr_SetString

; 1229 :     return NULL;

  00053	33 c0		 xor	 eax, eax
$LN5@getentry:

; 1230 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
getentry ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$align DD	imagerel align
	DD	imagerel align+172
	DD	imagerel $unwind$align
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$align DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT align
_TEXT	SEGMENT
extra$ = 0
tv71 = 8
size$ = 32
c$ = 40
e$ = 48
align	PROC						; COMDAT

; 1237 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1238 :     Py_ssize_t extra;
; 1239 : 
; 1240 :     if (e->format == c) {

  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR e$[rsp]
  00017	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0001a	0f be 4c 24 28	 movsx	 ecx, BYTE PTR c$[rsp]
  0001f	3b c1		 cmp	 eax, ecx
  00021	75 7f		 jne	 SHORT $LN3@align

; 1241 :         if (e->alignment && size > 0) {

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR e$[rsp]
  00028	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002d	74 73		 je	 SHORT $LN2@align
  0002f	48 83 7c 24 20
	00		 cmp	 QWORD PTR size$[rsp], 0
  00035	7e 6b		 jle	 SHORT $LN2@align

; 1242 :             extra = (e->alignment - 1) - (size - 1) % (e->alignment);

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR e$[rsp]
  0003c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00040	48 ff c8	 dec	 rax
  00043	48 89 44 24 08	 mov	 QWORD PTR tv71[rsp], rax
  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR size$[rsp]
  0004d	48 ff c9	 dec	 rcx
  00050	48 8b c1	 mov	 rax, rcx
  00053	48 99		 cdq
  00055	48 8b 4c 24 30	 mov	 rcx, QWORD PTR e$[rsp]
  0005a	48 f7 79 10	 idiv	 QWORD PTR [rcx+16]
  0005e	48 8b c2	 mov	 rax, rdx
  00061	48 8b 4c 24 08	 mov	 rcx, QWORD PTR tv71[rsp]
  00066	48 2b c8	 sub	 rcx, rax
  00069	48 8b c1	 mov	 rax, rcx
  0006c	48 89 04 24	 mov	 QWORD PTR extra$[rsp], rax

; 1243 :             if (extra > PY_SSIZE_T_MAX - size)

  00070	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0007a	48 2b 44 24 20	 sub	 rax, QWORD PTR size$[rsp]
  0007f	48 39 04 24	 cmp	 QWORD PTR extra$[rsp], rax
  00083	7e 09		 jle	 SHORT $LN1@align

; 1244 :                 return -1;

  00085	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0008c	eb 19		 jmp	 SHORT $LN4@align
$LN1@align:

; 1245 :             size += extra;

  0008e	48 8b 04 24	 mov	 rax, QWORD PTR extra$[rsp]
  00092	48 8b 4c 24 20	 mov	 rcx, QWORD PTR size$[rsp]
  00097	48 03 c8	 add	 rcx, rax
  0009a	48 8b c1	 mov	 rax, rcx
  0009d	48 89 44 24 20	 mov	 QWORD PTR size$[rsp], rax
$LN2@align:
$LN3@align:

; 1246 :         }
; 1247 :     }
; 1248 :     return size;

  000a2	48 8b 44 24 20	 mov	 rax, QWORD PTR size$[rsp]
$LN4@align:

; 1249 : }

  000a7	48 83 c4 18	 add	 rsp, 24
  000ab	c3		 ret	 0
align	ENDP
_TEXT	ENDS
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_dealloc DD imagerel s_dealloc
	DD	imagerel s_dealloc+158
	DD	imagerel $unwind$s_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_dealloc DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT s_dealloc
_TEXT	SEGMENT
tv75 = 32
s$ = 64
s_dealloc PROC						; COMDAT

; 1444 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1445 :     if (s->weakreflist != NULL)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00016	74 0a		 je	 SHORT $LN6@s_dealloc

; 1446 :         PyObject_ClearWeakRefs((PyObject *)s);

  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001d	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN6@s_dealloc:

; 1447 :     if (s->s_codes != NULL) {

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00027	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0002c	74 37		 je	 SHORT $LN5@s_dealloc

; 1448 :         PyMem_FREE(s->s_codes);

  0002e	e8 00 00 00 00	 call	 _Py_PXCTX
  00033	85 c0		 test	 eax, eax
  00035	74 18		 je	 SHORT $LN9@s_dealloc
  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0003c	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00040	e8 00 00 00 00	 call	 _PxMem_Free
  00045	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  0004d	eb 16		 jmp	 SHORT $LN10@s_dealloc
$LN9@s_dealloc:
  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00054	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00058	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0005d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN10@s_dealloc:
$LN5@s_dealloc:
$LN4@s_dealloc:

; 1449 :     }
; 1450 :     Py_XDECREF(s->s_format);

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0006a	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0006f	74 0e		 je	 SHORT $LN1@s_dealloc
  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00076	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  0007a	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@s_dealloc:
  0007f	33 c0		 xor	 eax, eax
  00081	85 c0		 test	 eax, eax
  00083	75 e0		 jne	 SHORT $LN4@s_dealloc

; 1451 :     Py_TYPE(s)->tp_free((PyObject *)s);

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0008a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00093	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 1452 : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
s_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@POOICKIL@unpack?5requires?5a?5bytes?5object?5o@ ; `string'
PUBLIC	??_C@_1DA@POGKDLEH@?$AAs?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAc?$AAo?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PyBuffer_Release:PROC
EXTRN	PyObject_GetBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_unpack DD imagerel s_unpack
	DD	imagerel s_unpack+283
	DD	imagerel $unwind$s_unpack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_unpack DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0CN@POOICKIL@unpack?5requires?5a?5bytes?5object?5o@
CONST	SEGMENT
??_C@_0CN@POOICKIL@unpack?5requires?5a?5bytes?5object?5o@ DB 'unpack requ'
	DB	'ires a bytes object of length %zd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@POGKDLEH@?$AAs?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAc?$AAo?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@POGKDLEH@?$AAs?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAc?$AAo?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'o', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H
	DB	'>', 00H, 's', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, 's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT s_unpack
_TEXT	SEGMENT
soself$ = 32
vbuf$ = 48
result$ = 128
self$ = 160
input$ = 168
s_unpack PROC						; COMDAT

; 1497 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1498 :     Py_buffer vbuf;
; 1499 :     PyObject *result;
; 1500 :     PyStructObject *soself = (PyStructObject *)self;

  00011	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00019	48 89 44 24 20	 mov	 QWORD PTR soself$[rsp], rax

; 1501 : 
; 1502 :     assert(PyStruct_Check(self));

  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyStructType
  00025	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0002d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00031	74 38		 je	 SHORT $LN5@s_unpack
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyStructType
  0003a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00046	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004b	85 c0		 test	 eax, eax
  0004d	75 1c		 jne	 SHORT $LN5@s_unpack
  0004f	41 b8 de 05 00
	00		 mov	 r8d, 1502		; 000005deH
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@INOKNGO@?$AAP?$AAy?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00069	33 c0		 xor	 eax, eax
$LN5@s_unpack:

; 1503 :     assert(soself->s_codes != NULL);

  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR soself$[rsp]
  00070	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00075	75 1c		 jne	 SHORT $LN6@s_unpack
  00077	41 b8 df 05 00
	00		 mov	 r8d, 1503		; 000005dfH
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@POGKDLEH@?$AAs?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAc?$AAo?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00091	33 c0		 xor	 eax, eax
$LN6@s_unpack:

; 1504 :     if (PyObject_GetBuffer(input, &vbuf, PyBUF_SIMPLE) < 0)

  00093	45 33 c0	 xor	 r8d, r8d
  00096	48 8d 54 24 30	 lea	 rdx, QWORD PTR vbuf$[rsp]
  0009b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR input$[rsp]
  000a3	e8 00 00 00 00	 call	 PyObject_GetBuffer
  000a8	85 c0		 test	 eax, eax
  000aa	7d 04		 jge	 SHORT $LN2@s_unpack

; 1505 :         return NULL;

  000ac	33 c0		 xor	 eax, eax
  000ae	eb 63		 jmp	 SHORT $LN3@s_unpack
$LN2@s_unpack:

; 1506 :     if (vbuf.len != soself->s_size) {

  000b0	48 8b 44 24 20	 mov	 rax, QWORD PTR soself$[rsp]
  000b5	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b9	48 39 44 24 40	 cmp	 QWORD PTR vbuf$[rsp+16], rax
  000be	74 2a		 je	 SHORT $LN1@s_unpack

; 1507 :         PyErr_Format(StructError,
; 1508 :                      "unpack requires a bytes object of length %zd",
; 1509 :                      soself->s_size);

  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR soself$[rsp]
  000c5	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@POOICKIL@unpack?5requires?5a?5bytes?5object?5o@
  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000d7	e8 00 00 00 00	 call	 PyErr_Format

; 1510 :         PyBuffer_Release(&vbuf);

  000dc	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vbuf$[rsp]
  000e1	e8 00 00 00 00	 call	 PyBuffer_Release

; 1511 :         return NULL;

  000e6	33 c0		 xor	 eax, eax
  000e8	eb 29		 jmp	 SHORT $LN3@s_unpack
$LN1@s_unpack:

; 1512 :     }
; 1513 :     result = s_unpack_internal(soself, vbuf.buf);

  000ea	48 8b 54 24 30	 mov	 rdx, QWORD PTR vbuf$[rsp]
  000ef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR soself$[rsp]
  000f4	e8 00 00 00 00	 call	 s_unpack_internal
  000f9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR result$[rsp], rax

; 1514 :     PyBuffer_Release(&vbuf);

  00101	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vbuf$[rsp]
  00106	e8 00 00 00 00	 call	 PyBuffer_Release

; 1515 :     return result;

  0010b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN3@s_unpack:

; 1516 : }

  00113	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0011a	c3		 ret	 0
s_unpack ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_unpack_internal DD imagerel s_unpack_internal
	DD	imagerel s_unpack_internal+361
	DD	imagerel $unwind$s_unpack_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_unpack_internal DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT s_unpack_internal
_TEXT	SEGMENT
i$ = 32
code$ = 40
result$ = 48
res$21567 = 56
v$21565 = 64
e$21566 = 72
n$21571 = 80
soself$ = 112
startfrom$ = 120
s_unpack_internal PROC					; COMDAT

; 1455 : s_unpack_internal(PyStructObject *soself, char *startfrom) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1456 :     formatcode *code;
; 1457 :     Py_ssize_t i = 0;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0

; 1458 :     PyObject *result = PyTuple_New(soself->s_len);

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR soself$[rsp]
  0001c	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00020	e8 00 00 00 00	 call	 PyTuple_New
  00025	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1459 :     if (result == NULL)

  0002a	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00030	75 07		 jne	 SHORT $LN10@s_unpack_i

; 1460 :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 2b 01 00 00	 jmp	 $LN11@s_unpack_i
$LN10@s_unpack_i:

; 1461 : 
; 1462 :     for (code = soself->s_codes; code->fmtdef != NULL; code++) {

  00039	48 8b 44 24 70	 mov	 rax, QWORD PTR soself$[rsp]
  0003e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00042	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax
  00047	eb 0e		 jmp	 SHORT $LN9@s_unpack_i
$LN8@s_unpack_i:
  00049	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  0004e	48 83 c0 18	 add	 rax, 24
  00052	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax
$LN9@s_unpack_i:
  00057	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  0005c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00060	0f 84 eb 00 00
	00		 je	 $LN7@s_unpack_i

; 1463 :         PyObject *v;
; 1464 :         const formatdef *e = code->fmtdef;

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 89 44 24 48	 mov	 QWORD PTR e$21566[rsp], rax

; 1465 :         const char *res = startfrom + code->offset;

  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  00078	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR startfrom$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 38	 mov	 QWORD PTR res$21567[rsp], rax

; 1466 :         if (e->format == 's') {

  0008c	48 8b 44 24 48	 mov	 rax, QWORD PTR e$21566[rsp]
  00091	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00094	83 f8 73	 cmp	 eax, 115		; 00000073H
  00097	75 1a		 jne	 SHORT $LN6@s_unpack_i

; 1467 :             v = PyBytes_FromStringAndSize(res, code->size);

  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  0009e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR res$21567[rsp]
  000a7	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000ac	48 89 44 24 40	 mov	 QWORD PTR v$21565[rsp], rax
  000b1	eb 6e		 jmp	 SHORT $LN5@s_unpack_i
$LN6@s_unpack_i:

; 1468 :         } else if (e->format == 'p') {

  000b3	48 8b 44 24 48	 mov	 rax, QWORD PTR e$21566[rsp]
  000b8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000bb	83 f8 70	 cmp	 eax, 112		; 00000070H
  000be	75 4a		 jne	 SHORT $LN4@s_unpack_i

; 1469 :             Py_ssize_t n = *(unsigned char*)res;

  000c0	48 8b 44 24 38	 mov	 rax, QWORD PTR res$21567[rsp]
  000c5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000c8	48 89 44 24 50	 mov	 QWORD PTR n$21571[rsp], rax

; 1470 :             if (n >= code->size)

  000cd	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  000d2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d6	48 39 44 24 50	 cmp	 QWORD PTR n$21571[rsp], rax
  000db	7c 11		 jl	 SHORT $LN3@s_unpack_i

; 1471 :                 n = code->size - 1;

  000dd	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  000e2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e6	48 ff c8	 dec	 rax
  000e9	48 89 44 24 50	 mov	 QWORD PTR n$21571[rsp], rax
$LN3@s_unpack_i:

; 1472 :             v = PyBytes_FromStringAndSize(res + 1, n);

  000ee	48 8b 44 24 38	 mov	 rax, QWORD PTR res$21567[rsp]
  000f3	48 ff c0	 inc	 rax
  000f6	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$21571[rsp]
  000fb	48 8b c8	 mov	 rcx, rax
  000fe	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00103	48 89 44 24 40	 mov	 QWORD PTR v$21565[rsp], rax

; 1473 :         } else {

  00108	eb 17		 jmp	 SHORT $LN2@s_unpack_i
$LN4@s_unpack_i:

; 1474 :             v = e->unpack(res, e);

  0010a	48 8b 54 24 48	 mov	 rdx, QWORD PTR e$21566[rsp]
  0010f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR res$21567[rsp]
  00114	48 8b 44 24 48	 mov	 rax, QWORD PTR e$21566[rsp]
  00119	ff 50 18	 call	 QWORD PTR [rax+24]
  0011c	48 89 44 24 40	 mov	 QWORD PTR v$21565[rsp], rax
$LN2@s_unpack_i:
$LN5@s_unpack_i:

; 1475 :         }
; 1476 :         if (v == NULL)

  00121	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$21565[rsp], 0
  00127	75 02		 jne	 SHORT $LN1@s_unpack_i

; 1477 :             goto fail;

  00129	eb 2d		 jmp	 SHORT $fail$21577
$LN1@s_unpack_i:

; 1478 :         PyTuple_SET_ITEM(result, i++, v);

  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  00130	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00135	48 8b 54 24 40	 mov	 rdx, QWORD PTR v$21565[rsp]
  0013a	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx
  0013f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00144	48 ff c0	 inc	 rax
  00147	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 1479 :     }

  0014c	e9 f8 fe ff ff	 jmp	 $LN8@s_unpack_i
$LN7@s_unpack_i:

; 1480 : 
; 1481 :     return result;

  00151	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  00156	eb 0c		 jmp	 SHORT $LN11@s_unpack_i
$fail$21577:

; 1482 : fail:
; 1483 :     Py_DECREF(result);

  00158	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  0015d	e8 00 00 00 00	 call	 _Py_DecRef

; 1484 :     return NULL;

  00162	33 c0		 xor	 eax, eax
$LN11@s_unpack_i:

; 1485 : }

  00164	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00168	c3		 ret	 0
s_unpack_internal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@LKFPHCHB@unpack_from?5requires?5a?5buffer?5of@ ; `string'
PUBLIC	??_C@_0BA@OHJCCKEP@O?$HMn?3unpack_from?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_unpack_from DD imagerel s_unpack_from
	DD	imagerel s_unpack_from+455
	DD	imagerel $unwind$s_unpack_from
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_unpack_from DD 021601H
	DD	0170116H
xdata	ENDS
;	COMDAT ??_C@_0DE@LKFPHCHB@unpack_from?5requires?5a?5buffer?5of@
CONST	SEGMENT
??_C@_0DE@LKFPHCHB@unpack_from?5requires?5a?5buffer?5of@ DB 'unpack_from '
	DB	'requires a buffer of at least %zd bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OHJCCKEP@O?$HMn?3unpack_from?$AA@
CONST	SEGMENT
??_C@_0BA@OHJCCKEP@O?$HMn?3unpack_from?$AA@ DB 'O|n:unpack_from', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT s_unpack_from
_TEXT	SEGMENT
soself$ = 48
vbuf$ = 64
input$ = 144
offset$ = 152
result$ = 160
self$ = 192
args$ = 200
kwds$ = 208
s_unpack_from PROC					; COMDAT

; 1527 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1528 :     static char *kwlist[] = {"buffer", "offset", 0};
; 1529 : 
; 1530 :     PyObject *input;
; 1531 :     Py_ssize_t offset = 0;

  00016	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR offset$[rsp], 0

; 1532 :     Py_buffer vbuf;
; 1533 :     PyObject *result;
; 1534 :     PyStructObject *soself = (PyStructObject *)self;

  00022	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0002a	48 89 44 24 30	 mov	 QWORD PTR soself$[rsp], rax

; 1535 : 
; 1536 :     assert(PyStruct_Check(self));

  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyStructType
  00036	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0003e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00042	74 38		 je	 SHORT $LN8@s_unpack_f
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyStructType
  0004b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00053	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00057	e8 00 00 00 00	 call	 PyType_IsSubtype
  0005c	85 c0		 test	 eax, eax
  0005e	75 1c		 jne	 SHORT $LN8@s_unpack_f
  00060	41 b8 00 06 00
	00		 mov	 r8d, 1536		; 00000600H
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@INOKNGO@?$AAP?$AAy?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007a	33 c0		 xor	 eax, eax
$LN8@s_unpack_f:

; 1537 :     assert(soself->s_codes != NULL);

  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR soself$[rsp]
  00081	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00086	75 1c		 jne	 SHORT $LN9@s_unpack_f
  00088	41 b8 01 06 00
	00		 mov	 r8d, 1537		; 00000601H
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@POGKDLEH@?$AAs?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAc?$AAo?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a2	33 c0		 xor	 eax, eax
$LN9@s_unpack_f:

; 1538 : 
; 1539 :     if (!PyArg_ParseTupleAndKeywords(args, kwds,
; 1540 :                                      "O|n:unpack_from", kwlist,
; 1541 :                                      &input, &offset))

  000a4	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR offset$[rsp]
  000ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b1	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR input$[rsp]
  000b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??s_unpack_from@@9@9
  000c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@OHJCCKEP@O?$HMn?3unpack_from?$AA@
  000cc	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  000d4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000dc	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000e1	85 c0		 test	 eax, eax
  000e3	75 07		 jne	 SHORT $LN5@s_unpack_f

; 1542 :         return NULL;

  000e5	33 c0		 xor	 eax, eax
  000e7	e9 d3 00 00 00	 jmp	 $LN6@s_unpack_f
$LN5@s_unpack_f:

; 1543 :     if (PyObject_GetBuffer(input, &vbuf, PyBUF_SIMPLE) < 0)

  000ec	45 33 c0	 xor	 r8d, r8d
  000ef	48 8d 54 24 40	 lea	 rdx, QWORD PTR vbuf$[rsp]
  000f4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR input$[rsp]
  000fc	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00101	85 c0		 test	 eax, eax
  00103	7d 07		 jge	 SHORT $LN4@s_unpack_f

; 1544 :         return NULL;

  00105	33 c0		 xor	 eax, eax
  00107	e9 b3 00 00 00	 jmp	 $LN6@s_unpack_f
$LN4@s_unpack_f:

; 1545 :     if (offset < 0)

  0010c	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR offset$[rsp], 0
  00115	7d 1b		 jge	 SHORT $LN3@s_unpack_f

; 1546 :         offset += vbuf.len;

  00117	48 8b 44 24 50	 mov	 rax, QWORD PTR vbuf$[rsp+16]
  0011c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  00124	48 03 c8	 add	 rcx, rax
  00127	48 8b c1	 mov	 rax, rcx
  0012a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax
$LN3@s_unpack_f:

; 1547 :     if (offset < 0 || vbuf.len - offset < soself->s_size) {

  00132	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR offset$[rsp], 0
  0013b	7c 1e		 jl	 SHORT $LN1@s_unpack_f
  0013d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  00145	48 8b 4c 24 50	 mov	 rcx, QWORD PTR vbuf$[rsp+16]
  0014a	48 2b c8	 sub	 rcx, rax
  0014d	48 8b c1	 mov	 rax, rcx
  00150	48 8b 4c 24 30	 mov	 rcx, QWORD PTR soself$[rsp]
  00155	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  00159	7d 2a		 jge	 SHORT $LN2@s_unpack_f
$LN1@s_unpack_f:

; 1548 :         PyErr_Format(StructError,
; 1549 :             "unpack_from requires a buffer of at least %zd bytes",
; 1550 :             soself->s_size);

  0015b	48 8b 44 24 30	 mov	 rax, QWORD PTR soself$[rsp]
  00160	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00164	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@LKFPHCHB@unpack_from?5requires?5a?5buffer?5of@
  0016b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00172	e8 00 00 00 00	 call	 PyErr_Format

; 1551 :         PyBuffer_Release(&vbuf);

  00177	48 8d 4c 24 40	 lea	 rcx, QWORD PTR vbuf$[rsp]
  0017c	e8 00 00 00 00	 call	 PyBuffer_Release

; 1552 :         return NULL;

  00181	33 c0		 xor	 eax, eax
  00183	eb 3a		 jmp	 SHORT $LN6@s_unpack_f
$LN2@s_unpack_f:

; 1553 :     }
; 1554 :     result = s_unpack_internal(soself, (char*)vbuf.buf + offset);

  00185	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  0018d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vbuf$[rsp]
  00192	48 03 c8	 add	 rcx, rax
  00195	48 8b c1	 mov	 rax, rcx
  00198	48 8b d0	 mov	 rdx, rax
  0019b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR soself$[rsp]
  001a0	e8 00 00 00 00	 call	 s_unpack_internal
  001a5	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR result$[rsp], rax

; 1555 :     PyBuffer_Release(&vbuf);

  001ad	48 8d 4c 24 40	 lea	 rcx, QWORD PTR vbuf$[rsp]
  001b2	e8 00 00 00 00	 call	 PyBuffer_Release

; 1556 :     return result;

  001b7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN6@s_unpack_f:

; 1557 : }

  001bf	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  001c6	c3		 ret	 0
s_unpack_from ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CO@ODBGMAEE@pack?5expected?5?$CFzd?5items?5for?5pack@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_pack DD imagerel s_pack
	DD	imagerel s_pack+342
	DD	imagerel $unwind$s_pack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_pack DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@ODBGMAEE@pack?5expected?5?$CFzd?5items?5for?5pack@
CONST	SEGMENT
??_C@_0CO@ODBGMAEE@pack?5expected?5?$CFzd?5items?5for?5pack@ DB 'pack exp'
	DB	'ected %zd items for packing (got %zd)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT s_pack
_TEXT	SEGMENT
soself$ = 32
result$ = 40
self$ = 64
args$ = 72
s_pack	PROC						; COMDAT

; 1654 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1655 :     PyStructObject *soself;
; 1656 :     PyObject *result;
; 1657 : 
; 1658 :     /* Validate arguments. */
; 1659 :     soself = (PyStructObject *)self;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR soself$[rsp], rax

; 1660 :     assert(PyStruct_Check(self));

  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyStructType
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00024	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00028	74 35		 je	 SHORT $LN6@s_pack
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyStructType
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00036	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003f	85 c0		 test	 eax, eax
  00041	75 1c		 jne	 SHORT $LN6@s_pack
  00043	41 b8 7c 06 00
	00		 mov	 r8d, 1660		; 0000067cH
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@INOKNGO@?$AAP?$AAy?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005d	33 c0		 xor	 eax, eax
$LN6@s_pack:

; 1661 :     assert(soself->s_codes != NULL);

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR soself$[rsp]
  00064	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00069	75 1c		 jne	 SHORT $LN7@s_pack
  0006b	41 b8 7d 06 00
	00		 mov	 r8d, 1661		; 0000067dH
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@POGKDLEH@?$AAs?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAc?$AAo?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00085	33 c0		 xor	 eax, eax
$LN7@s_pack:

; 1662 :     if (PyTuple_GET_SIZE(args) != soself->s_len)

  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR args$[rsp]
  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR soself$[rsp]
  00091	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00095	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00099	74 2c		 je	 SHORT $LN3@s_pack

; 1663 :     {
; 1664 :         PyErr_Format(StructError,
; 1665 :             "pack expected %zd items for packing (got %zd)", soself->s_len, PyTuple_GET_SIZE(args));

  0009b	48 8b 44 24 48	 mov	 rax, QWORD PTR args$[rsp]
  000a0	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  000a4	48 8b 44 24 20	 mov	 rax, QWORD PTR soself$[rsp]
  000a9	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@ODBGMAEE@pack?5expected?5?$CFzd?5items?5for?5pack@
  000b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000bb	e8 00 00 00 00	 call	 PyErr_Format

; 1666 :         return NULL;

  000c0	33 c0		 xor	 eax, eax
  000c2	e9 8a 00 00 00	 jmp	 $LN4@s_pack
$LN3@s_pack:

; 1667 :     }
; 1668 : 
; 1669 :     /* Allocate a new string */
; 1670 :     result = PyBytes_FromStringAndSize((char *)NULL, soself->s_size);

  000c7	48 8b 44 24 20	 mov	 rax, QWORD PTR soself$[rsp]
  000cc	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000d0	33 c9		 xor	 ecx, ecx
  000d2	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000d7	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1671 :     if (result == NULL)

  000dc	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  000e2	75 04		 jne	 SHORT $LN2@s_pack

; 1672 :         return NULL;

  000e4	33 c0		 xor	 eax, eax
  000e6	eb 69		 jmp	 SHORT $LN4@s_pack
$LN2@s_pack:

; 1673 : 
; 1674 :     /* Call the guts */
; 1675 :     if ( s_pack_internal(soself, args, 0, PyBytes_AS_STRING(result)) != 0 ) {

  000e8	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
  000ed	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000fc	85 c0		 test	 eax, eax
  000fe	75 1c		 jne	 SHORT $LN8@s_pack
  00100	41 b8 8b 06 00
	00		 mov	 r8d, 1675		; 0000068bH
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0011a	33 c0		 xor	 eax, eax
$LN8@s_pack:
  0011c	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
  00121	48 83 c0 78	 add	 rax, 120		; 00000078H
  00125	4c 8b c8	 mov	 r9, rax
  00128	45 33 c0	 xor	 r8d, r8d
  0012b	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00130	48 8b 4c 24 20	 mov	 rcx, QWORD PTR soself$[rsp]
  00135	e8 00 00 00 00	 call	 s_pack_internal
  0013a	85 c0		 test	 eax, eax
  0013c	74 0e		 je	 SHORT $LN1@s_pack

; 1676 :         Py_DECREF(result);

  0013e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00143	e8 00 00 00 00	 call	 _Py_DecRef

; 1677 :         return NULL;

  00148	33 c0		 xor	 eax, eax
  0014a	eb 05		 jmp	 SHORT $LN4@s_pack
$LN1@s_pack:

; 1678 :     }
; 1679 : 
; 1680 :     return result;

  0014c	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN4@s_pack:

; 1681 : }

  00151	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00155	c3		 ret	 0
s_pack	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@BKNAGDBC@int?5too?5large?5to?5convert?$AA@ ; `string'
PUBLIC	??_C@_1EM@BEBINKLF@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAc?$AAh?$AAa?$AAr?$AA?$CJ?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@ ; `string'
PUBLIC	??_C@_0CI@CLNMDOAG@argument?5for?5?8p?8?5must?5be?5a?5bytes@ ; `string'
PUBLIC	??_C@_1CK@KKOANEMB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@KPAEGFOJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CI@NJILNDPO@argument?5for?5?8s?8?5must?5be?5a?5bytes@ ; `string'
EXTRN	_PyByteArray_empty_string:BYTE
EXTRN	PyByteArray_Type:BYTE
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_pack_internal DD imagerel s_pack_internal
	DD	imagerel s_pack_internal+1522
	DD	imagerel $unwind$s_pack_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_pack_internal DD 021b01H
	DD	013011bH
xdata	ENDS
;	COMDAT ??_C@_0BJ@BKNAGDBC@int?5too?5large?5to?5convert?$AA@
CONST	SEGMENT
??_C@_0BJ@BKNAGDBC@int?5too?5large?5to?5convert?$AA@ DB 'int too large to'
	DB	' convert', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@BEBINKLF@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAc?$AAh?$AAa?$AAr?$AA?$CJ?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@
CONST	SEGMENT
??_C@_1EM@BEBINKLF@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAc?$AAh?$AAa?$AAr?$AA?$CJ?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@ DB '('
	DB	00H, 'P', 00H, 'y', 00H, '_', 00H, 's', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H, 'u'
	DB	00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, ')'
	DB	00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '(', 00H, 'n', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CLNMDOAG@argument?5for?5?8p?8?5must?5be?5a?5bytes@
CONST	SEGMENT
??_C@_0CI@CLNMDOAG@argument?5for?5?8p?8?5must?5be?5a?5bytes@ DB 'argument'
	DB	' for ''p'' must be a bytes object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@KKOANEMB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@KKOANEMB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'v', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@KPAEGFOJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@KPAEGFOJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'v', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NJILNDPO@argument?5for?5?8s?8?5must?5be?5a?5bytes@
CONST	SEGMENT
??_C@_0CI@NJILNDPO@argument?5for?5?8s?8?5must?5be?5a?5bytes@ DB 'argument'
	DB	' for ''s'' must be a bytes object', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT s_pack_internal
_TEXT	SEGMENT
i$ = 32
code$ = 40
res$21658 = 48
v$21655 = 56
n$21654 = 64
e$21657 = 72
p$21661 = 80
isstring$21660 = 88
p$21691 = 96
isstring$21690 = 104
tv84 = 108
tv172 = 112
tv186 = 120
tv242 = 128
soself$ = 160
args$ = 168
offset$ = 176
buf$ = 184
s_pack_internal PROC					; COMDAT

; 1572 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1573 :     formatcode *code;
; 1574 :     /* XXX(nnorwitz): why does i need to be a local?  can we use
; 1575 :        the offset parameter or do we need the wider width? */
; 1576 :     Py_ssize_t i;
; 1577 : 
; 1578 :     memset(buf, '\0', soself->s_size);

  0001b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR soself$[rsp]
  00023	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00027	33 d2		 xor	 edx, edx
  00029	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00031	e8 00 00 00 00	 call	 memset

; 1579 :     i = offset;

  00036	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR offset$[rsp]
  0003e	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 1580 :     for (code = soself->s_codes; code->fmtdef != NULL; code++) {

  00043	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR soself$[rsp]
  0004b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0004f	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax
  00054	eb 0e		 jmp	 SHORT $LN20@s_pack_int
$LN19@s_pack_int:
  00056	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  0005b	48 83 c0 18	 add	 rax, 24
  0005f	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax
$LN20@s_pack_int:
  00064	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  00069	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006d	0f 84 75 05 00
	00		 je	 $LN18@s_pack_int

; 1581 :         Py_ssize_t n;
; 1582 :         PyObject *v = PyTuple_GET_ITEM(args, i++);

  00073	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00080	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00085	48 89 44 24 38	 mov	 QWORD PTR v$21655[rsp], rax
  0008a	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0008f	48 ff c0	 inc	 rax
  00092	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 1583 :         const formatdef *e = code->fmtdef;

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  0009c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009f	48 89 44 24 48	 mov	 QWORD PTR e$21657[rsp], rax

; 1584 :         char *res = buf + code->offset;

  000a4	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  000a9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000b5	48 03 c8	 add	 rcx, rax
  000b8	48 8b c1	 mov	 rax, rcx
  000bb	48 89 44 24 30	 mov	 QWORD PTR res$21658[rsp], rax

; 1585 :         if (e->format == 's') {

  000c0	48 8b 44 24 48	 mov	 rax, QWORD PTR e$21657[rsp]
  000c5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c8	83 f8 73	 cmp	 eax, 115		; 00000073H
  000cb	0f 85 25 02 00
	00		 jne	 $LN17@s_pack_int

; 1586 :             int isstring;
; 1587 :             void *p;
; 1588 :             isstring = PyBytes_Check(v);

  000d1	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  000d6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000da	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000e0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0a		 je	 SHORT $LN23@s_pack_int
  000e9	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  000f1	eb 08		 jmp	 SHORT $LN24@s_pack_int
$LN23@s_pack_int:
  000f3	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN24@s_pack_int:
  000fb	8b 44 24 6c	 mov	 eax, DWORD PTR tv84[rsp]
  000ff	89 44 24 58	 mov	 DWORD PTR isstring$21660[rsp], eax

; 1589 :             if (!isstring && !PyByteArray_Check(v)) {

  00103	83 7c 24 58 00	 cmp	 DWORD PTR isstring$21660[rsp], 0
  00108	75 48		 jne	 SHORT $LN16@s_pack_int
  0010a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00111	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$21655[rsp]
  00116	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0011a	74 36		 je	 SHORT $LN16@s_pack_int
  0011c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00123	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  00128	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0012c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00131	85 c0		 test	 eax, eax
  00133	75 1d		 jne	 SHORT $LN16@s_pack_int

; 1590 :                 PyErr_SetString(StructError,
; 1591 :                                 "argument for 's' must be a bytes object");

  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@NJILNDPO@argument?5for?5?8s?8?5must?5be?5a?5bytes@
  0013c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00143	e8 00 00 00 00	 call	 PyErr_SetString

; 1592 :                 return -1;

  00148	b8 ff ff ff ff	 mov	 eax, -1
  0014d	e9 98 04 00 00	 jmp	 $LN21@s_pack_int
$LN16@s_pack_int:

; 1593 :             }
; 1594 :             if (isstring) {

  00152	83 7c 24 58 00	 cmp	 DWORD PTR isstring$21660[rsp], 0
  00157	0f 84 89 00 00
	00		 je	 $LN15@s_pack_int

; 1595 :                 n = PyBytes_GET_SIZE(v);

  0015d	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  00162	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00166	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0016c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00171	85 c0		 test	 eax, eax
  00173	75 1c		 jne	 SHORT $LN25@s_pack_int
  00175	41 b8 3b 06 00
	00		 mov	 r8d, 1595		; 0000063bH
  0017b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00182	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@KPAEGFOJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0018f	33 c0		 xor	 eax, eax
$LN25@s_pack_int:
  00191	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  00196	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0019a	48 89 44 24 40	 mov	 QWORD PTR n$21654[rsp], rax

; 1596 :                 p = PyBytes_AS_STRING(v);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  001a4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001a8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001ae	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001b3	85 c0		 test	 eax, eax
  001b5	75 1c		 jne	 SHORT $LN26@s_pack_int
  001b7	41 b8 3c 06 00
	00		 mov	 r8d, 1596		; 0000063cH
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@KPAEGFOJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d1	33 c0		 xor	 eax, eax
$LN26@s_pack_int:
  001d3	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  001d8	48 83 c0 78	 add	 rax, 120		; 00000078H
  001dc	48 89 44 24 50	 mov	 QWORD PTR p$21661[rsp], rax

; 1597 :             }
; 1598 :             else {

  001e1	e9 d1 00 00 00	 jmp	 $LN14@s_pack_int
$LN15@s_pack_int:

; 1599 :                 n = PyByteArray_GET_SIZE(v);

  001e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$21655[rsp]
  001f2	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001f6	74 35		 je	 SHORT $LN27@s_pack_int
  001f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001ff	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  00204	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00208	e8 00 00 00 00	 call	 PyType_IsSubtype
  0020d	85 c0		 test	 eax, eax
  0020f	75 1c		 jne	 SHORT $LN27@s_pack_int
  00211	41 b8 3f 06 00
	00		 mov	 r8d, 1599		; 0000063fH
  00217	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@KKOANEMB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0022b	33 c0		 xor	 eax, eax
$LN27@s_pack_int:
  0022d	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  00232	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00236	48 89 44 24 40	 mov	 QWORD PTR n$21654[rsp], rax

; 1600 :                 p = PyByteArray_AS_STRING(v);

  0023b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00242	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$21655[rsp]
  00247	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0024b	74 35		 je	 SHORT $LN28@s_pack_int
  0024d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00254	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  00259	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0025d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00262	85 c0		 test	 eax, eax
  00264	75 1c		 jne	 SHORT $LN28@s_pack_int
  00266	41 b8 40 06 00
	00		 mov	 r8d, 1600		; 00000640H
  0026c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@KKOANEMB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0027a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00280	33 c0		 xor	 eax, eax
$LN28@s_pack_int:
  00282	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  00287	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0028c	74 13		 je	 SHORT $LN29@s_pack_int
  0028e	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  00293	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0029a	48 89 44 24 70	 mov	 QWORD PTR tv172[rsp], rax
  0029f	eb 0c		 jmp	 SHORT $LN30@s_pack_int
$LN29@s_pack_int:
  002a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  002a8	48 89 44 24 70	 mov	 QWORD PTR tv172[rsp], rax
$LN30@s_pack_int:
  002ad	48 8b 44 24 70	 mov	 rax, QWORD PTR tv172[rsp]
  002b2	48 89 44 24 50	 mov	 QWORD PTR p$21661[rsp], rax
$LN14@s_pack_int:

; 1601 :             }
; 1602 :             if (n > code->size)

  002b7	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  002bc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002c0	48 39 44 24 40	 cmp	 QWORD PTR n$21654[rsp], rax
  002c5	7e 0e		 jle	 SHORT $LN13@s_pack_int

; 1603 :                 n = code->size;

  002c7	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  002cc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002d0	48 89 44 24 40	 mov	 QWORD PTR n$21654[rsp], rax
$LN13@s_pack_int:

; 1604 :             if (n > 0)

  002d5	48 83 7c 24 40
	00		 cmp	 QWORD PTR n$21654[rsp], 0
  002db	7e 14		 jle	 SHORT $LN12@s_pack_int

; 1605 :                 memcpy(res, p, n);

  002dd	4c 8b 44 24 40	 mov	 r8, QWORD PTR n$21654[rsp]
  002e2	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$21661[rsp]
  002e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR res$21658[rsp]
  002ec	e8 00 00 00 00	 call	 memcpy
$LN12@s_pack_int:

; 1606 :         } else if (e->format == 'p') {

  002f1	e9 ed 02 00 00	 jmp	 $LN11@s_pack_int
$LN17@s_pack_int:
  002f6	48 8b 44 24 48	 mov	 rax, QWORD PTR e$21657[rsp]
  002fb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002fe	83 f8 70	 cmp	 eax, 112		; 00000070H
  00301	0f 85 7f 02 00
	00		 jne	 $LN10@s_pack_int

; 1607 :             int isstring;
; 1608 :             void *p;
; 1609 :             isstring = PyBytes_Check(v);

  00307	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  0030c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00310	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00316	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0031b	85 c0		 test	 eax, eax
  0031d	74 0a		 je	 SHORT $LN31@s_pack_int
  0031f	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv186[rsp], 1
  00327	eb 08		 jmp	 SHORT $LN32@s_pack_int
$LN31@s_pack_int:
  00329	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv186[rsp], 0
$LN32@s_pack_int:
  00331	8b 44 24 78	 mov	 eax, DWORD PTR tv186[rsp]
  00335	89 44 24 68	 mov	 DWORD PTR isstring$21690[rsp], eax

; 1610 :             if (!isstring && !PyByteArray_Check(v)) {

  00339	83 7c 24 68 00	 cmp	 DWORD PTR isstring$21690[rsp], 0
  0033e	75 48		 jne	 SHORT $LN9@s_pack_int
  00340	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00347	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$21655[rsp]
  0034c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00350	74 36		 je	 SHORT $LN9@s_pack_int
  00352	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00359	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  0035e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00362	e8 00 00 00 00	 call	 PyType_IsSubtype
  00367	85 c0		 test	 eax, eax
  00369	75 1d		 jne	 SHORT $LN9@s_pack_int

; 1611 :                 PyErr_SetString(StructError,
; 1612 :                                 "argument for 'p' must be a bytes object");

  0036b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@CLNMDOAG@argument?5for?5?8p?8?5must?5be?5a?5bytes@
  00372	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00379	e8 00 00 00 00	 call	 PyErr_SetString

; 1613 :                 return -1;

  0037e	b8 ff ff ff ff	 mov	 eax, -1
  00383	e9 62 02 00 00	 jmp	 $LN21@s_pack_int
$LN9@s_pack_int:

; 1614 :             }
; 1615 :             if (isstring) {

  00388	83 7c 24 68 00	 cmp	 DWORD PTR isstring$21690[rsp], 0
  0038d	0f 84 89 00 00
	00		 je	 $LN8@s_pack_int

; 1616 :                 n = PyBytes_GET_SIZE(v);

  00393	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  00398	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0039c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003a2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  003a7	85 c0		 test	 eax, eax
  003a9	75 1c		 jne	 SHORT $LN33@s_pack_int
  003ab	41 b8 50 06 00
	00		 mov	 r8d, 1616		; 00000650H
  003b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@KPAEGFOJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  003bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003c5	33 c0		 xor	 eax, eax
$LN33@s_pack_int:
  003c7	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  003cc	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  003d0	48 89 44 24 40	 mov	 QWORD PTR n$21654[rsp], rax

; 1617 :                 p = PyBytes_AS_STRING(v);

  003d5	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  003da	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003de	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003e4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  003e9	85 c0		 test	 eax, eax
  003eb	75 1c		 jne	 SHORT $LN34@s_pack_int
  003ed	41 b8 51 06 00
	00		 mov	 r8d, 1617		; 00000651H
  003f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@KPAEGFOJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00401	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00407	33 c0		 xor	 eax, eax
$LN34@s_pack_int:
  00409	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  0040e	48 83 c0 78	 add	 rax, 120		; 00000078H
  00412	48 89 44 24 60	 mov	 QWORD PTR p$21691[rsp], rax

; 1618 :             }
; 1619 :             else {

  00417	e9 da 00 00 00	 jmp	 $LN7@s_pack_int
$LN8@s_pack_int:

; 1620 :                 n = PyByteArray_GET_SIZE(v);

  0041c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00423	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$21655[rsp]
  00428	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0042c	74 35		 je	 SHORT $LN35@s_pack_int
  0042e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00435	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  0043a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0043e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00443	85 c0		 test	 eax, eax
  00445	75 1c		 jne	 SHORT $LN35@s_pack_int
  00447	41 b8 54 06 00
	00		 mov	 r8d, 1620		; 00000654H
  0044d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00454	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@KKOANEMB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0045b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00461	33 c0		 xor	 eax, eax
$LN35@s_pack_int:
  00463	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  00468	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0046c	48 89 44 24 40	 mov	 QWORD PTR n$21654[rsp], rax

; 1621 :                 p = PyByteArray_AS_STRING(v);

  00471	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00478	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$21655[rsp]
  0047d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00481	74 35		 je	 SHORT $LN36@s_pack_int
  00483	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0048a	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  0048f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00493	e8 00 00 00 00	 call	 PyType_IsSubtype
  00498	85 c0		 test	 eax, eax
  0049a	75 1c		 jne	 SHORT $LN36@s_pack_int
  0049c	41 b8 55 06 00
	00		 mov	 r8d, 1621		; 00000655H
  004a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  004a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@KKOANEMB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  004b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004b6	33 c0		 xor	 eax, eax
$LN36@s_pack_int:
  004b8	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  004bd	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  004c2	74 16		 je	 SHORT $LN37@s_pack_int
  004c4	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  004c9	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  004d0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv242[rsp], rax
  004d8	eb 0f		 jmp	 SHORT $LN38@s_pack_int
$LN37@s_pack_int:
  004da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  004e1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv242[rsp], rax
$LN38@s_pack_int:
  004e9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv242[rsp]
  004f1	48 89 44 24 60	 mov	 QWORD PTR p$21691[rsp], rax
$LN7@s_pack_int:

; 1622 :             }
; 1623 :             if (n > (code->size - 1))

  004f6	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  004fb	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  004ff	48 ff c8	 dec	 rax
  00502	48 39 44 24 40	 cmp	 QWORD PTR n$21654[rsp], rax
  00507	7e 11		 jle	 SHORT $LN6@s_pack_int

; 1624 :                 n = code->size - 1;

  00509	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  0050e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00512	48 ff c8	 dec	 rax
  00515	48 89 44 24 40	 mov	 QWORD PTR n$21654[rsp], rax
$LN6@s_pack_int:

; 1625 :             if (n > 0)

  0051a	48 83 7c 24 40
	00		 cmp	 QWORD PTR n$21654[rsp], 0
  00520	7e 1a		 jle	 SHORT $LN5@s_pack_int

; 1626 :                 memcpy(res + 1, p, n);

  00522	48 8b 44 24 30	 mov	 rax, QWORD PTR res$21658[rsp]
  00527	48 ff c0	 inc	 rax
  0052a	4c 8b 44 24 40	 mov	 r8, QWORD PTR n$21654[rsp]
  0052f	48 8b 54 24 60	 mov	 rdx, QWORD PTR p$21691[rsp]
  00534	48 8b c8	 mov	 rcx, rax
  00537	e8 00 00 00 00	 call	 memcpy
$LN5@s_pack_int:

; 1627 :             if (n > 255)

  0053c	48 81 7c 24 40
	ff 00 00 00	 cmp	 QWORD PTR n$21654[rsp], 255 ; 000000ffH
  00545	7e 09		 jle	 SHORT $LN4@s_pack_int

; 1628 :                 n = 255;

  00547	48 c7 44 24 40
	ff 00 00 00	 mov	 QWORD PTR n$21654[rsp], 255 ; 000000ffH
$LN4@s_pack_int:

; 1629 :             *res = Py_SAFE_DOWNCAST(n, Py_ssize_t, unsigned char);

  00550	0f b6 44 24 40	 movzx	 eax, BYTE PTR n$21654[rsp]
  00555	48 3b 44 24 40	 cmp	 rax, QWORD PTR n$21654[rsp]
  0055a	74 1c		 je	 SHORT $LN39@s_pack_int
  0055c	41 b8 5d 06 00
	00		 mov	 r8d, 1629		; 0000065dH
  00562	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00569	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@BEBINKLF@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAc?$AAh?$AAa?$AAr?$AA?$CJ?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@
  00570	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00576	33 c0		 xor	 eax, eax
$LN39@s_pack_int:
  00578	48 8b 44 24 30	 mov	 rax, QWORD PTR res$21658[rsp]
  0057d	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR n$21654[rsp]
  00582	88 08		 mov	 BYTE PTR [rax], cl

; 1630 :         } else {

  00584	eb 5d		 jmp	 SHORT $LN3@s_pack_int
$LN10@s_pack_int:

; 1631 :             if (e->pack(res, v, e) < 0) {

  00586	4c 8b 44 24 48	 mov	 r8, QWORD PTR e$21657[rsp]
  0058b	48 8b 54 24 38	 mov	 rdx, QWORD PTR v$21655[rsp]
  00590	48 8b 4c 24 30	 mov	 rcx, QWORD PTR res$21658[rsp]
  00595	48 8b 44 24 48	 mov	 rax, QWORD PTR e$21657[rsp]
  0059a	ff 50 20	 call	 QWORD PTR [rax+32]
  0059d	85 c0		 test	 eax, eax
  0059f	7d 42		 jge	 SHORT $LN2@s_pack_int

; 1632 :                 if (PyLong_Check(v) && PyErr_ExceptionMatches(PyExc_OverflowError))

  005a1	48 8b 44 24 38	 mov	 rax, QWORD PTR v$21655[rsp]
  005a6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005aa	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005b0	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  005b5	85 c0		 test	 eax, eax
  005b7	74 23		 je	 SHORT $LN1@s_pack_int
  005b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  005c0	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  005c5	85 c0		 test	 eax, eax
  005c7	74 13		 je	 SHORT $LN1@s_pack_int

; 1633 :                     PyErr_SetString(StructError,
; 1634 :                                     "int too large to convert");

  005c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@BKNAGDBC@int?5too?5large?5to?5convert?$AA@
  005d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  005d7	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@s_pack_int:

; 1635 :                 return -1;

  005dc	b8 ff ff ff ff	 mov	 eax, -1
  005e1	eb 07		 jmp	 SHORT $LN21@s_pack_int
$LN2@s_pack_int:
$LN3@s_pack_int:
$LN11@s_pack_int:

; 1636 :             }
; 1637 :         }
; 1638 :     }

  005e3	e9 6e fa ff ff	 jmp	 $LN19@s_pack_int
$LN18@s_pack_int:

; 1639 : 
; 1640 :     /* Success */
; 1641 :     return 0;

  005e8	33 c0		 xor	 eax, eax
$LN21@s_pack_int:

; 1642 : }

  005ea	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  005f1	c3		 ret	 0
s_pack_internal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@GDDDEOGE@pack_into?5requires?5a?5buffer?5of?5a@ ; `string'
PUBLIC	??_C@_1CA@NLIKKDJB@?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0DD@IMGMLBJO@pack_into?5expected?5?$CFzd?5items?5for@ ; `string'
PUBLIC	??_C@_0CD@EHIAMGFA@pack_into?5expected?5offset?5argume@ ; `string'
PUBLIC	??_C@_0CD@FKEIKOLF@pack_into?5expected?5buffer?5argume@ ; `string'
EXTRN	PyNumber_AsSsize_t:PROC
EXTRN	PyExc_IndexError:QWORD
EXTRN	PyObject_AsWriteBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_pack_into DD imagerel s_pack_into
	DD	imagerel s_pack_into+567
	DD	imagerel $unwind$s_pack_into
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_pack_into DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0DC@GDDDEOGE@pack_into?5requires?5a?5buffer?5of?5a@
CONST	SEGMENT
??_C@_0DC@GDDDEOGE@pack_into?5requires?5a?5buffer?5of?5a@ DB 'pack_into r'
	DB	'equires a buffer of at least %zd bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@NLIKKDJB@?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@NLIKKDJB@?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, '_', 00H
	DB	'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IMGMLBJO@pack_into?5expected?5?$CFzd?5items?5for@
CONST	SEGMENT
??_C@_0DD@IMGMLBJO@pack_into?5expected?5?$CFzd?5items?5for@ DB 'pack_into'
	DB	' expected %zd items for packing (got %zd)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EHIAMGFA@pack_into?5expected?5offset?5argume@
CONST	SEGMENT
??_C@_0CD@EHIAMGFA@pack_into?5expected?5offset?5argume@ DB 'pack_into exp'
	DB	'ected offset argument', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FKEIKOLF@pack_into?5expected?5buffer?5argume@
CONST	SEGMENT
??_C@_0CD@FKEIKOLF@pack_into?5expected?5buffer?5argume@ DB 'pack_into exp'
	DB	'ected buffer argument', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT s_pack_into
_TEXT	SEGMENT
soself$ = 32
buffer_len$ = 40
offset$ = 48
buffer$ = 56
self$ = 80
args$ = 88
s_pack_into PROC					; COMDAT

; 1693 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1694 :     PyStructObject *soself;
; 1695 :     char *buffer;
; 1696 :     Py_ssize_t buffer_len, offset;
; 1697 : 
; 1698 :     /* Validate arguments.  +1 is for the first arg as buffer. */
; 1699 :     soself = (PyStructObject *)self;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR soself$[rsp], rax

; 1700 :     assert(PyStruct_Check(self));

  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyStructType
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00024	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00028	74 35		 je	 SHORT $LN14@s_pack_int@2
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyStructType
  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00036	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003f	85 c0		 test	 eax, eax
  00041	75 1c		 jne	 SHORT $LN14@s_pack_int@2
  00043	41 b8 a4 06 00
	00		 mov	 r8d, 1700		; 000006a4H
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@INOKNGO@?$AAP?$AAy?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005d	33 c0		 xor	 eax, eax
$LN14@s_pack_int@2:

; 1701 :     assert(soself->s_codes != NULL);

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR soself$[rsp]
  00064	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00069	75 1c		 jne	 SHORT $LN15@s_pack_int@2
  0006b	41 b8 a5 06 00
	00		 mov	 r8d, 1701		; 000006a5H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@POGKDLEH@?$AAs?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AA_?$AAc?$AAo?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00085	33 c0		 xor	 eax, eax
$LN15@s_pack_int@2:

; 1702 :     if (PyTuple_GET_SIZE(args) != (soself->s_len + 2))

  00087	48 8b 44 24 20	 mov	 rax, QWORD PTR soself$[rsp]
  0008c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00090	48 83 c0 02	 add	 rax, 2
  00094	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00099	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  0009d	74 75		 je	 SHORT $LN11@s_pack_int@2

; 1703 :     {
; 1704 :         if (PyTuple_GET_SIZE(args) == 0) {

  0009f	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  000a4	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a9	75 15		 jne	 SHORT $LN10@s_pack_int@2

; 1705 :             PyErr_Format(StructError,
; 1706 :                         "pack_into expected buffer argument");

  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@FKEIKOLF@pack_into?5expected?5buffer?5argume@
  000b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000b9	e8 00 00 00 00	 call	 PyErr_Format
  000be	eb 4d		 jmp	 SHORT $LN9@s_pack_int@2
$LN10@s_pack_int@2:

; 1707 :         }
; 1708 :         else if (PyTuple_GET_SIZE(args) == 1) {

  000c0	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  000c5	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  000ca	75 15		 jne	 SHORT $LN8@s_pack_int@2

; 1709 :             PyErr_Format(StructError,
; 1710 :                         "pack_into expected offset argument");

  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@EHIAMGFA@pack_into?5expected?5offset?5argume@
  000d3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000da	e8 00 00 00 00	 call	 PyErr_Format

; 1711 :         }
; 1712 :         else {

  000df	eb 2c		 jmp	 SHORT $LN7@s_pack_int@2
$LN8@s_pack_int@2:

; 1713 :             PyErr_Format(StructError,
; 1714 :                         "pack_into expected %zd items for packing (got %zd)",
; 1715 :                         soself->s_len, (PyTuple_GET_SIZE(args) - 2));

  000e1	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  000e6	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ea	48 83 e8 02	 sub	 rax, 2
  000ee	4c 8b c8	 mov	 r9, rax
  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR soself$[rsp]
  000f6	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@IMGMLBJO@pack_into?5expected?5?$CFzd?5items?5for@
  00101	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00108	e8 00 00 00 00	 call	 PyErr_Format
$LN7@s_pack_int@2:
$LN9@s_pack_int@2:

; 1716 :         }
; 1717 :         return NULL;

  0010d	33 c0		 xor	 eax, eax
  0010f	e9 1e 01 00 00	 jmp	 $LN12@s_pack_int@2
$LN11@s_pack_int@2:

; 1718 :     }
; 1719 : 
; 1720 :     /* Extract a writable memory buffer from the first argument */
; 1721 :     if ( PyObject_AsWriteBuffer(PyTuple_GET_ITEM(args, 0),
; 1722 :                                                             (void**)&buffer, &buffer_len) == -1 ) {

  00114	4c 8d 44 24 28	 lea	 r8, QWORD PTR buffer_len$[rsp]
  00119	48 8d 54 24 38	 lea	 rdx, QWORD PTR buffer$[rsp]
  0011e	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00123	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00127	e8 00 00 00 00	 call	 PyObject_AsWriteBuffer
  0012c	83 f8 ff	 cmp	 eax, -1
  0012f	75 07		 jne	 SHORT $LN6@s_pack_int@2

; 1723 :         return NULL;

  00131	33 c0		 xor	 eax, eax
  00133	e9 fa 00 00 00	 jmp	 $LN12@s_pack_int@2
$LN6@s_pack_int@2:

; 1724 :     }
; 1725 :     assert( buffer_len >= 0 );

  00138	48 83 7c 24 28
	00		 cmp	 QWORD PTR buffer_len$[rsp], 0
  0013e	7d 1c		 jge	 SHORT $LN16@s_pack_int@2
  00140	41 b8 bd 06 00
	00		 mov	 r8d, 1725		; 000006bdH
  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@GNPPMAKD@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0014d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NLIKKDJB@?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0015a	33 c0		 xor	 eax, eax
$LN16@s_pack_int@2:

; 1726 : 
; 1727 :     /* Extract the offset from the first argument */
; 1728 :     offset = PyNumber_AsSsize_t(PyTuple_GET_ITEM(args, 1), PyExc_IndexError);

  0015c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00163	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00168	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  0016c	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00171	48 89 44 24 30	 mov	 QWORD PTR offset$[rsp], rax

; 1729 :     if (offset == -1 && PyErr_Occurred())

  00176	48 83 7c 24 30
	ff		 cmp	 QWORD PTR offset$[rsp], -1
  0017c	75 11		 jne	 SHORT $LN5@s_pack_int@2
  0017e	e8 00 00 00 00	 call	 PyErr_Occurred
  00183	48 85 c0	 test	 rax, rax
  00186	74 07		 je	 SHORT $LN5@s_pack_int@2

; 1730 :         return NULL;

  00188	33 c0		 xor	 eax, eax
  0018a	e9 a3 00 00 00	 jmp	 $LN12@s_pack_int@2
$LN5@s_pack_int@2:

; 1731 : 
; 1732 :     /* Support negative offsets. */
; 1733 :     if (offset < 0)

  0018f	48 83 7c 24 30
	00		 cmp	 QWORD PTR offset$[rsp], 0
  00195	7d 15		 jge	 SHORT $LN4@s_pack_int@2

; 1734 :         offset += buffer_len;

  00197	48 8b 44 24 28	 mov	 rax, QWORD PTR buffer_len$[rsp]
  0019c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR offset$[rsp]
  001a1	48 03 c8	 add	 rcx, rax
  001a4	48 8b c1	 mov	 rax, rcx
  001a7	48 89 44 24 30	 mov	 QWORD PTR offset$[rsp], rax
$LN4@s_pack_int@2:

; 1735 : 
; 1736 :     /* Check boundaries */
; 1737 :     if (offset < 0 || (buffer_len - offset) < soself->s_size) {

  001ac	48 83 7c 24 30
	00		 cmp	 QWORD PTR offset$[rsp], 0
  001b2	7c 1b		 jl	 SHORT $LN2@s_pack_int@2
  001b4	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  001b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buffer_len$[rsp]
  001be	48 2b c8	 sub	 rcx, rax
  001c1	48 8b c1	 mov	 rax, rcx
  001c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR soself$[rsp]
  001c9	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  001cd	7d 20		 jge	 SHORT $LN3@s_pack_int@2
$LN2@s_pack_int@2:

; 1738 :         PyErr_Format(StructError,
; 1739 :                      "pack_into requires a buffer of at least %zd bytes",
; 1740 :                      soself->s_size);

  001cf	48 8b 44 24 20	 mov	 rax, QWORD PTR soself$[rsp]
  001d4	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  001d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@GDDDEOGE@pack_into?5requires?5a?5buffer?5of?5a@
  001df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  001e6	e8 00 00 00 00	 call	 PyErr_Format

; 1741 :         return NULL;

  001eb	33 c0		 xor	 eax, eax
  001ed	eb 43		 jmp	 SHORT $LN12@s_pack_int@2
$LN3@s_pack_int@2:

; 1742 :     }
; 1743 : 
; 1744 :     /* Call the guts */
; 1745 :     if ( s_pack_internal(soself, args, 2, buffer + offset) != 0 ) {

  001ef	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  001f4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR buffer$[rsp]
  001f9	48 03 c8	 add	 rcx, rax
  001fc	48 8b c1	 mov	 rax, rcx
  001ff	4c 8b c8	 mov	 r9, rax
  00202	41 b8 02 00 00
	00		 mov	 r8d, 2
  00208	48 8b 54 24 58	 mov	 rdx, QWORD PTR args$[rsp]
  0020d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR soself$[rsp]
  00212	e8 00 00 00 00	 call	 s_pack_internal
  00217	85 c0		 test	 eax, eax
  00219	74 04		 je	 SHORT $LN1@s_pack_int@2

; 1746 :         return NULL;

  0021b	33 c0		 xor	 eax, eax
  0021d	eb 13		 jmp	 SHORT $LN12@s_pack_int@2
$LN1@s_pack_int@2:

; 1747 :     }
; 1748 : 
; 1749 :     Py_RETURN_NONE;

  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00226	e8 00 00 00 00	 call	 _Py_IncRef
  0022b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN12@s_pack_int@2:

; 1750 : }

  00232	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00236	c3		 ret	 0
s_pack_into ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_get_format DD imagerel s_get_format
	DD	imagerel s_get_format+42
	DD	imagerel $unwind$s_get_format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_get_format DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT s_get_format
_TEXT	SEGMENT
self$ = 48
unused$ = 56
s_get_format PROC					; COMDAT

; 1754 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1755 :     Py_INCREF(self->s_format);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00017	e8 00 00 00 00	 call	 _Py_IncRef

; 1756 :     return self->s_format;

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00021	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]

; 1757 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s_get_format ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_get_size DD imagerel s_get_size
	DD	imagerel s_get_size+33
	DD	imagerel $unwind$s_get_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_get_size DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT s_get_size
_TEXT	SEGMENT
self$ = 48
unused$ = 56
s_get_size PROC						; COMDAT

; 1761 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1762 :     return PyLong_FromSsize_t(self->s_size);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00017	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 1763 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s_get_size ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_sizeof DD imagerel s_sizeof
	DD	imagerel s_sizeof+56
	DD	imagerel $unwind$s_sizeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_sizeof DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT s_sizeof
_TEXT	SEGMENT
size$ = 32
self$ = 64
unused$ = 72
s_sizeof PROC						; COMDAT

; 1770 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1771 :     Py_ssize_t size;
; 1772 : 
; 1773 :     size = sizeof(PyStructObject) + sizeof(formatcode) * (self->s_len + 1);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00017	48 ff c0	 inc	 rax
  0001a	48 6b c0 18	 imul	 rax, 24
  0001e	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00024	48 89 44 24 20	 mov	 QWORD PTR size$[rsp], rax

; 1774 :     return PyLong_FromSsize_t(size);

  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR size$[rsp]
  0002e	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 1775 : }

  00033	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00037	c3		 ret	 0
s_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LKDIIBIG@clearcache?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$clearcache DD imagerel clearcache
	DD	imagerel clearcache+126
	DD	imagerel $unwind$clearcache
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$clearcache DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@LKDIIBIG@clearcache?$AA@
CONST	SEGMENT
??_C@_0L@LKDIIBIG@clearcache?$AA@ DB 'clearcache', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT clearcache
_TEXT	SEGMENT
_py_tmp$21906 = 48
self$ = 80
clearcache PROC						; COMDAT

; 1885 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@clearcache:

; 1886 :     Py_CLEAR(cache);

  00009	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR cache, 0
  00011	74 4d		 je	 SHORT $LN1@clearcache
  00013	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0001b	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR cache
  00022	41 b8 5e 07 00
	00		 mov	 r8d, 1886		; 0000075eH
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@DIOKFDPL@?4?4?2Modules?2_struct?4c?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LKDIIBIG@clearcache?$AA@
  00036	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003b	85 c0		 test	 eax, eax
  0003d	75 21		 jne	 SHORT $LN1@clearcache
  0003f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR cache
  00046	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$21906[rsp], rax
  0004b	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR cache, 0
  00056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$21906[rsp]
  0005b	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@clearcache:
  00060	33 c0		 xor	 eax, eax
  00062	85 c0		 test	 eax, eax
  00064	75 a3		 jne	 SHORT $LN4@clearcache

; 1887 :     Py_RETURN_NONE;

  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0006d	e8 00 00 00 00	 call	 _Py_IncRef
  00072	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1888 : }

  00079	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007d	c3		 ret	 0
clearcache ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$calcsize DD imagerel calcsize
	DD	imagerel calcsize+80
	DD	imagerel $unwind$calcsize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$calcsize DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT calcsize
_TEXT	SEGMENT
n$ = 32
s_object$ = 40
self$ = 64
fmt$ = 72
calcsize PROC						; COMDAT

; 1897 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1898 :     Py_ssize_t n;
; 1899 :     PyObject *s_object = cache_struct(fmt);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fmt$[rsp]
  00013	e8 00 00 00 00	 call	 cache_struct
  00018	48 89 44 24 28	 mov	 QWORD PTR s_object$[rsp], rax

; 1900 :     if (s_object == NULL)

  0001d	48 83 7c 24 28
	00		 cmp	 QWORD PTR s_object$[rsp], 0
  00023	75 04		 jne	 SHORT $LN1@calcsize

; 1901 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 22		 jmp	 SHORT $LN2@calcsize
$LN1@calcsize:

; 1902 :     n = ((PyStructObject *)s_object)->s_size;

  00029	48 8b 44 24 28	 mov	 rax, QWORD PTR s_object$[rsp]
  0002e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00032	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 1903 :     Py_DECREF(s_object);

  00037	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s_object$[rsp]
  0003c	e8 00 00 00 00	 call	 _Py_DecRef

; 1904 :     return PyLong_FromSsize_t(n);

  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  00046	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN2@calcsize:

; 1905 : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
calcsize ENDP
_TEXT	ENDS
EXTRN	PyErr_Clear:PROC
EXTRN	PyDict_SetItem:PROC
EXTRN	PyDict_Clear:PROC
EXTRN	PyDict_Size:PROC
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$cache_struct DD imagerel cache_struct
	DD	imagerel cache_struct+200
	DD	imagerel $unwind$cache_struct
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cache_struct DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cache_struct
_TEXT	SEGMENT
s_object$ = 32
fmt$ = 64
cache_struct PROC					; COMDAT

; 1854 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1855 :     PyObject * s_object;
; 1856 : 
; 1857 :     if (cache == NULL) {

  00009	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR cache, 0
  00011	75 1d		 jne	 SHORT $LN6@cache_stru

; 1858 :         cache = PyDict_New();

  00013	e8 00 00 00 00	 call	 PyDict_New
  00018	48 89 05 00 00
	00 00		 mov	 QWORD PTR cache, rax

; 1859 :         if (cache == NULL)

  0001f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR cache, 0
  00027	75 07		 jne	 SHORT $LN5@cache_stru

; 1860 :             return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	e9 93 00 00 00	 jmp	 $LN7@cache_stru
$LN5@cache_stru:
$LN6@cache_stru:

; 1861 :     }
; 1862 : 
; 1863 :     s_object = PyDict_GetItem(cache, fmt);

  00030	48 8b 54 24 40	 mov	 rdx, QWORD PTR fmt$[rsp]
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cache
  0003c	e8 00 00 00 00	 call	 PyDict_GetItem
  00041	48 89 44 24 20	 mov	 QWORD PTR s_object$[rsp], rax

; 1864 :     if (s_object != NULL) {

  00046	48 83 7c 24 20
	00		 cmp	 QWORD PTR s_object$[rsp], 0
  0004c	74 11		 je	 SHORT $LN4@cache_stru

; 1865 :         Py_INCREF(s_object);

  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s_object$[rsp]
  00053	e8 00 00 00 00	 call	 _Py_IncRef

; 1866 :         return s_object;

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR s_object$[rsp]
  0005d	eb 64		 jmp	 SHORT $LN7@cache_stru
$LN4@cache_stru:

; 1867 :     }
; 1868 : 
; 1869 :     s_object = PyObject_CallFunctionObjArgs((PyObject *)(&PyStructType), fmt, NULL);

  0005f	45 33 c0	 xor	 r8d, r8d
  00062	48 8b 54 24 40	 mov	 rdx, QWORD PTR fmt$[rsp]
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyStructType
  0006e	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00073	48 89 44 24 20	 mov	 QWORD PTR s_object$[rsp], rax

; 1870 :     if (s_object != NULL) {

  00078	48 83 7c 24 20
	00		 cmp	 QWORD PTR s_object$[rsp], 0
  0007e	74 3e		 je	 SHORT $LN3@cache_stru

; 1871 :         if (PyDict_Size(cache) >= MAXCACHE)

  00080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cache
  00087	e8 00 00 00 00	 call	 PyDict_Size
  0008c	48 83 f8 64	 cmp	 rax, 100		; 00000064H
  00090	7c 0c		 jl	 SHORT $LN2@cache_stru

; 1872 :             PyDict_Clear(cache);

  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cache
  00099	e8 00 00 00 00	 call	 PyDict_Clear
$LN2@cache_stru:

; 1873 :         /* Attempt to cache the result */
; 1874 :         if (PyDict_SetItem(cache, fmt, s_object) == -1)

  0009e	4c 8b 44 24 20	 mov	 r8, QWORD PTR s_object$[rsp]
  000a3	48 8b 54 24 40	 mov	 rdx, QWORD PTR fmt$[rsp]
  000a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cache
  000af	e8 00 00 00 00	 call	 PyDict_SetItem
  000b4	83 f8 ff	 cmp	 eax, -1
  000b7	75 05		 jne	 SHORT $LN1@cache_stru

; 1875 :             PyErr_Clear();

  000b9	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@cache_stru:
$LN3@cache_stru:

; 1876 :     }
; 1877 :     return s_object;

  000be	48 8b 44 24 20	 mov	 rax, QWORD PTR s_object$[rsp]
$LN7@cache_stru:

; 1878 : }

  000c3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c7	c3		 ret	 0
cache_struct ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@ ; `string'
EXTRN	PyTuple_GetSlice:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pack DD	imagerel pack
	DD	imagerel pack+200
	DD	imagerel $unwind$pack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pack DD	010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@
CONST	SEGMENT
??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@ DB 'missing format argu'
	DB	'ment', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT pack
_TEXT	SEGMENT
newargs$ = 32
n$ = 40
fmt$ = 48
s_object$ = 56
result$ = 64
self$ = 96
args$ = 104
pack	PROC						; COMDAT

; 1915 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1916 :     PyObject *s_object, *fmt, *newargs, *result;
; 1917 :     Py_ssize_t n = PyTuple_GET_SIZE(args);

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR args$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1918 : 
; 1919 :     if (n == 0) {

  0001c	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$[rsp], 0
  00022	75 1a		 jne	 SHORT $LN3@pack

; 1920 :         PyErr_SetString(PyExc_TypeError, "missing format argument");

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@
  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00032	e8 00 00 00 00	 call	 PyErr_SetString

; 1921 :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	e9 85 00 00 00	 jmp	 $LN4@pack
$LN3@pack:

; 1922 :     }
; 1923 :     fmt = PyTuple_GET_ITEM(args, 0);

  0003e	48 8b 44 24 68	 mov	 rax, QWORD PTR args$[rsp]
  00043	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00047	48 89 44 24 30	 mov	 QWORD PTR fmt$[rsp], rax

; 1924 :     newargs = PyTuple_GetSlice(args, 1, n);

  0004c	4c 8b 44 24 28	 mov	 r8, QWORD PTR n$[rsp]
  00051	ba 01 00 00 00	 mov	 edx, 1
  00056	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0005b	e8 00 00 00 00	 call	 PyTuple_GetSlice
  00060	48 89 44 24 20	 mov	 QWORD PTR newargs$[rsp], rax

; 1925 :     if (newargs == NULL)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR newargs$[rsp], 0
  0006b	75 04		 jne	 SHORT $LN2@pack

; 1926 :         return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	eb 52		 jmp	 SHORT $LN4@pack
$LN2@pack:

; 1927 : 
; 1928 :     s_object = cache_struct(fmt);

  00071	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fmt$[rsp]
  00076	e8 00 00 00 00	 call	 cache_struct
  0007b	48 89 44 24 38	 mov	 QWORD PTR s_object$[rsp], rax

; 1929 :     if (s_object == NULL) {

  00080	48 83 7c 24 38
	00		 cmp	 QWORD PTR s_object$[rsp], 0
  00086	75 0e		 jne	 SHORT $LN1@pack

; 1930 :         Py_DECREF(newargs);

  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newargs$[rsp]
  0008d	e8 00 00 00 00	 call	 _Py_DecRef

; 1931 :         return NULL;

  00092	33 c0		 xor	 eax, eax
  00094	eb 2d		 jmp	 SHORT $LN4@pack
$LN1@pack:

; 1932 :     }
; 1933 :     result = s_pack(s_object, newargs);

  00096	48 8b 54 24 20	 mov	 rdx, QWORD PTR newargs$[rsp]
  0009b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s_object$[rsp]
  000a0	e8 00 00 00 00	 call	 s_pack
  000a5	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1934 :     Py_DECREF(newargs);

  000aa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newargs$[rsp]
  000af	e8 00 00 00 00	 call	 _Py_DecRef

; 1935 :     Py_DECREF(s_object);

  000b4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s_object$[rsp]
  000b9	e8 00 00 00 00	 call	 _Py_DecRef

; 1936 :     return result;

  000be	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN4@pack:

; 1937 : }

  000c3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c7	c3		 ret	 0
pack	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pack_into DD imagerel pack_into
	DD	imagerel pack_into+200
	DD	imagerel $unwind$pack_into
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pack_into DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pack_into
_TEXT	SEGMENT
newargs$ = 32
n$ = 40
fmt$ = 48
s_object$ = 56
result$ = 64
self$ = 96
args$ = 104
pack_into PROC						; COMDAT

; 1949 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1950 :     PyObject *s_object, *fmt, *newargs, *result;
; 1951 :     Py_ssize_t n = PyTuple_GET_SIZE(args);

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR args$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1952 : 
; 1953 :     if (n == 0) {

  0001c	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$[rsp], 0
  00022	75 1a		 jne	 SHORT $LN3@pack_into

; 1954 :         PyErr_SetString(PyExc_TypeError, "missing format argument");

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@
  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00032	e8 00 00 00 00	 call	 PyErr_SetString

; 1955 :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	e9 85 00 00 00	 jmp	 $LN4@pack_into
$LN3@pack_into:

; 1956 :     }
; 1957 :     fmt = PyTuple_GET_ITEM(args, 0);

  0003e	48 8b 44 24 68	 mov	 rax, QWORD PTR args$[rsp]
  00043	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00047	48 89 44 24 30	 mov	 QWORD PTR fmt$[rsp], rax

; 1958 :     newargs = PyTuple_GetSlice(args, 1, n);

  0004c	4c 8b 44 24 28	 mov	 r8, QWORD PTR n$[rsp]
  00051	ba 01 00 00 00	 mov	 edx, 1
  00056	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0005b	e8 00 00 00 00	 call	 PyTuple_GetSlice
  00060	48 89 44 24 20	 mov	 QWORD PTR newargs$[rsp], rax

; 1959 :     if (newargs == NULL)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR newargs$[rsp], 0
  0006b	75 04		 jne	 SHORT $LN2@pack_into

; 1960 :         return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	eb 52		 jmp	 SHORT $LN4@pack_into
$LN2@pack_into:

; 1961 : 
; 1962 :     s_object = cache_struct(fmt);

  00071	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fmt$[rsp]
  00076	e8 00 00 00 00	 call	 cache_struct
  0007b	48 89 44 24 38	 mov	 QWORD PTR s_object$[rsp], rax

; 1963 :     if (s_object == NULL) {

  00080	48 83 7c 24 38
	00		 cmp	 QWORD PTR s_object$[rsp], 0
  00086	75 0e		 jne	 SHORT $LN1@pack_into

; 1964 :         Py_DECREF(newargs);

  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newargs$[rsp]
  0008d	e8 00 00 00 00	 call	 _Py_DecRef

; 1965 :         return NULL;

  00092	33 c0		 xor	 eax, eax
  00094	eb 2d		 jmp	 SHORT $LN4@pack_into
$LN1@pack_into:

; 1966 :     }
; 1967 :     result = s_pack_into(s_object, newargs);

  00096	48 8b 54 24 20	 mov	 rdx, QWORD PTR newargs$[rsp]
  0009b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s_object$[rsp]
  000a0	e8 00 00 00 00	 call	 s_pack_into
  000a5	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1968 :     Py_DECREF(newargs);

  000aa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newargs$[rsp]
  000af	e8 00 00 00 00	 call	 _Py_DecRef

; 1969 :     Py_DECREF(s_object);

  000b4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s_object$[rsp]
  000b9	e8 00 00 00 00	 call	 _Py_DecRef

; 1970 :     return result;

  000be	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN4@pack_into:

; 1971 : }

  000c3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c7	c3		 ret	 0
pack_into ENDP
_TEXT	ENDS
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack DD imagerel unpack
	DD	imagerel unpack+138
	DD	imagerel $unwind$unpack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT unpack
_TEXT	SEGMENT
fmt$ = 48
s_object$ = 56
inputstr$ = 64
result$ = 72
self$ = 96
args$ = 104
unpack	PROC						; COMDAT

; 1982 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1983 :     PyObject *s_object, *fmt, *inputstr, *result;
; 1984 : 
; 1985 :     if (!PyArg_UnpackTuple(args, "unpack", 2, 2, &fmt, &inputstr))

  0000e	48 8d 44 24 40	 lea	 rax, QWORD PTR inputstr$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00018	48 8d 44 24 30	 lea	 rax, QWORD PTR fmt$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	41 b9 02 00 00
	00		 mov	 r9d, 2
  00028	41 b8 02 00 00
	00		 mov	 r8d, 2
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06FIONAGJL@unpack?$AA@
  00035	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0003a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003f	85 c0		 test	 eax, eax
  00041	75 04		 jne	 SHORT $LN2@unpack

; 1986 :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	eb 3e		 jmp	 SHORT $LN3@unpack
$LN2@unpack:

; 1987 : 
; 1988 :     s_object = cache_struct(fmt);

  00047	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fmt$[rsp]
  0004c	e8 00 00 00 00	 call	 cache_struct
  00051	48 89 44 24 38	 mov	 QWORD PTR s_object$[rsp], rax

; 1989 :     if (s_object == NULL)

  00056	48 83 7c 24 38
	00		 cmp	 QWORD PTR s_object$[rsp], 0
  0005c	75 04		 jne	 SHORT $LN1@unpack

; 1990 :         return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	eb 23		 jmp	 SHORT $LN3@unpack
$LN1@unpack:

; 1991 :     result = s_unpack(s_object, inputstr);

  00062	48 8b 54 24 40	 mov	 rdx, QWORD PTR inputstr$[rsp]
  00067	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s_object$[rsp]
  0006c	e8 00 00 00 00	 call	 s_unpack
  00071	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 1992 :     Py_DECREF(s_object);

  00076	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s_object$[rsp]
  0007b	e8 00 00 00 00	 call	 _Py_DecRef

; 1993 :     return result;

  00080	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
$LN3@unpack:

; 1994 : }

  00085	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00089	c3		 ret	 0
unpack	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_from DD imagerel unpack_from
	DD	imagerel unpack_from+210
	DD	imagerel $unwind$unpack_from
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_from DD 011301H
	DD	0a213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT unpack_from
_TEXT	SEGMENT
newargs$ = 32
n$ = 40
fmt$ = 48
s_object$ = 56
result$ = 64
self$ = 96
args$ = 104
kwds$ = 112
unpack_from PROC					; COMDAT

; 2005 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2006 :     PyObject *s_object, *fmt, *newargs, *result;
; 2007 :     Py_ssize_t n = PyTuple_GET_SIZE(args);

  00013	48 8b 44 24 68	 mov	 rax, QWORD PTR args$[rsp]
  00018	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001c	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 2008 : 
; 2009 :     if (n == 0) {

  00021	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$[rsp], 0
  00027	75 1a		 jne	 SHORT $LN3@unpack_fro

; 2010 :         PyErr_SetString(PyExc_TypeError, "missing format argument");

  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@
  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00037	e8 00 00 00 00	 call	 PyErr_SetString

; 2011 :         return NULL;

  0003c	33 c0		 xor	 eax, eax
  0003e	e9 8a 00 00 00	 jmp	 $LN4@unpack_fro
$LN3@unpack_fro:

; 2012 :     }
; 2013 :     fmt = PyTuple_GET_ITEM(args, 0);

  00043	48 8b 44 24 68	 mov	 rax, QWORD PTR args$[rsp]
  00048	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0004c	48 89 44 24 30	 mov	 QWORD PTR fmt$[rsp], rax

; 2014 :     newargs = PyTuple_GetSlice(args, 1, n);

  00051	4c 8b 44 24 28	 mov	 r8, QWORD PTR n$[rsp]
  00056	ba 01 00 00 00	 mov	 edx, 1
  0005b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00060	e8 00 00 00 00	 call	 PyTuple_GetSlice
  00065	48 89 44 24 20	 mov	 QWORD PTR newargs$[rsp], rax

; 2015 :     if (newargs == NULL)

  0006a	48 83 7c 24 20
	00		 cmp	 QWORD PTR newargs$[rsp], 0
  00070	75 04		 jne	 SHORT $LN2@unpack_fro

; 2016 :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	eb 57		 jmp	 SHORT $LN4@unpack_fro
$LN2@unpack_fro:

; 2017 : 
; 2018 :     s_object = cache_struct(fmt);

  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fmt$[rsp]
  0007b	e8 00 00 00 00	 call	 cache_struct
  00080	48 89 44 24 38	 mov	 QWORD PTR s_object$[rsp], rax

; 2019 :     if (s_object == NULL) {

  00085	48 83 7c 24 38
	00		 cmp	 QWORD PTR s_object$[rsp], 0
  0008b	75 0e		 jne	 SHORT $LN1@unpack_fro

; 2020 :         Py_DECREF(newargs);

  0008d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newargs$[rsp]
  00092	e8 00 00 00 00	 call	 _Py_DecRef

; 2021 :         return NULL;

  00097	33 c0		 xor	 eax, eax
  00099	eb 32		 jmp	 SHORT $LN4@unpack_fro
$LN1@unpack_fro:

; 2022 :     }
; 2023 :     result = s_unpack_from(s_object, newargs, kwds);

  0009b	4c 8b 44 24 70	 mov	 r8, QWORD PTR kwds$[rsp]
  000a0	48 8b 54 24 20	 mov	 rdx, QWORD PTR newargs$[rsp]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s_object$[rsp]
  000aa	e8 00 00 00 00	 call	 s_unpack_from
  000af	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 2024 :     Py_DECREF(newargs);

  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newargs$[rsp]
  000b9	e8 00 00 00 00	 call	 _Py_DecRef

; 2025 :     Py_DECREF(s_object);

  000be	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s_object$[rsp]
  000c3	e8 00 00 00 00	 call	 _Py_DecRef

; 2026 :     return result;

  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN4@unpack_fro:

; 2027 : }

  000cd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d1	c3		 ret	 0
unpack_from ENDP
_TEXT	ENDS
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_0N@PADOAEKA@struct?4error?$AA@		; `string'
PUBLIC	PyInit__struct
EXTRN	PyModule_AddObject:PROC
EXTRN	PyErr_NewException:PROC
EXTRN	PyType_Ready:PROC
EXTRN	PyType_Type:BYTE
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__struct DD imagerel $LN18
	DD	imagerel $LN18+493
	DD	imagerel $unwind$PyInit__struct
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__struct DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PADOAEKA@struct?4error?$AA@
CONST	SEGMENT
??_C@_0N@PADOAEKA@struct?4error?$AA@ DB 'struct.error', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit__struct
_TEXT	SEGMENT
m$ = 32
ptr$22062 = 40
other$22061 = 48
native$22060 = 56
one$22059 = 64
PyInit__struct PROC					; COMDAT

; 2088 : {

$LN18:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2089 :     PyObject *m;
; 2090 : 
; 2091 :     m = PyModule_Create(&_structmodule);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_structmodule
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 2092 :     if (m == NULL)

  0001a	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	75 07		 jne	 SHORT $LN15@PyInit__st

; 2093 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 bf 01 00 00	 jmp	 $LN16@PyInit__st
$LN15@PyInit__st:

; 2094 : 
; 2095 :     Py_TYPE(&PyStructType) = &PyType_Type;

  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type
  00030	48 89 05 58 00
	00 00		 mov	 QWORD PTR PyStructType+88, rax

; 2096 :     if (PyType_Ready(&PyStructType) < 0)

  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyStructType
  0003e	e8 00 00 00 00	 call	 PyType_Ready
  00043	85 c0		 test	 eax, eax
  00045	7d 07		 jge	 SHORT $LN14@PyInit__st

; 2097 :         return NULL;

  00047	33 c0		 xor	 eax, eax
  00049	e9 9a 01 00 00	 jmp	 $LN16@PyInit__st
$LN14@PyInit__st:

; 2098 : 
; 2099 :     /* Check endian and swap in faster functions */
; 2100 :     {
; 2101 :         int one = 1;

  0004e	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR one$22059[rsp], 1

; 2102 :         formatdef *native = native_table;

  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:native_table
  0005d	48 89 44 24 38	 mov	 QWORD PTR native$22060[rsp], rax

; 2103 :         formatdef *other, *ptr;
; 2104 :         if ((int)*(unsigned char*)&one)

  00062	0f b6 44 24 40	 movzx	 eax, BYTE PTR one$22059[rsp]
  00067	85 c0		 test	 eax, eax
  00069	74 0e		 je	 SHORT $LN13@PyInit__st

; 2105 :             other = lilendian_table;

  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lilendian_table
  00072	48 89 44 24 30	 mov	 QWORD PTR other$22061[rsp], rax

; 2106 :         else

  00077	eb 0c		 jmp	 SHORT $LN12@PyInit__st
$LN13@PyInit__st:

; 2107 :             other = bigendian_table;

  00079	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bigendian_table
  00080	48 89 44 24 30	 mov	 QWORD PTR other$22061[rsp], rax
$LN12@PyInit__st:
$LN11@PyInit__st:

; 2108 :         /* Scan through the native table, find a matching
; 2109 :            entry in the endian table and swap in the
; 2110 :            native implementations whenever possible
; 2111 :            (64-bit platforms may not have "standard" sizes) */
; 2112 :         while (native->format != '\0' && other->format != '\0') {

  00085	48 8b 44 24 38	 mov	 rax, QWORD PTR native$22060[rsp]
  0008a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0008d	85 c0		 test	 eax, eax
  0008f	0f 84 d6 00 00
	00		 je	 $LN10@PyInit__st
  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR other$22061[rsp]
  0009a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009d	85 c0		 test	 eax, eax
  0009f	0f 84 c6 00 00
	00		 je	 $LN10@PyInit__st

; 2113 :             ptr = other;

  000a5	48 8b 44 24 30	 mov	 rax, QWORD PTR other$22061[rsp]
  000aa	48 89 44 24 28	 mov	 QWORD PTR ptr$22062[rsp], rax
$LN9@PyInit__st:

; 2114 :             while (ptr->format != '\0') {

  000af	48 8b 44 24 28	 mov	 rax, QWORD PTR ptr$22062[rsp]
  000b4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b7	85 c0		 test	 eax, eax
  000b9	0f 84 99 00 00
	00		 je	 $LN8@PyInit__st

; 2115 :                 if (ptr->format == native->format) {

  000bf	48 8b 44 24 28	 mov	 rax, QWORD PTR ptr$22062[rsp]
  000c4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR native$22060[rsp]
  000cc	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  000cf	3b c1		 cmp	 eax, ecx
  000d1	75 72		 jne	 SHORT $LN7@PyInit__st

; 2116 :                     /* Match faster when formats are
; 2117 :                        listed in the same order */
; 2118 :                     if (ptr == other)

  000d3	48 8b 44 24 30	 mov	 rax, QWORD PTR other$22061[rsp]
  000d8	48 39 44 24 28	 cmp	 QWORD PTR ptr$22062[rsp], rax
  000dd	75 0e		 jne	 SHORT $LN6@PyInit__st

; 2119 :                         other++;

  000df	48 8b 44 24 30	 mov	 rax, QWORD PTR other$22061[rsp]
  000e4	48 83 c0 28	 add	 rax, 40			; 00000028H
  000e8	48 89 44 24 30	 mov	 QWORD PTR other$22061[rsp], rax
$LN6@PyInit__st:

; 2120 :                     /* Only use the trick if the
; 2121 :                        size matches */
; 2122 :                     if (ptr->size != native->size)

  000ed	48 8b 44 24 28	 mov	 rax, QWORD PTR ptr$22062[rsp]
  000f2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR native$22060[rsp]
  000f7	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000fb	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  000ff	74 02		 je	 SHORT $LN5@PyInit__st

; 2123 :                         break;

  00101	eb 55		 jmp	 SHORT $LN8@PyInit__st
$LN5@PyInit__st:

; 2124 :                     /* Skip float and double, could be
; 2125 :                        "unknown" float format */
; 2126 :                     if (ptr->format == 'd' || ptr->format == 'f')

  00103	48 8b 44 24 28	 mov	 rax, QWORD PTR ptr$22062[rsp]
  00108	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0010b	83 f8 64	 cmp	 eax, 100		; 00000064H
  0010e	74 0d		 je	 SHORT $LN3@PyInit__st
  00110	48 8b 44 24 28	 mov	 rax, QWORD PTR ptr$22062[rsp]
  00115	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00118	83 f8 66	 cmp	 eax, 102		; 00000066H
  0011b	75 02		 jne	 SHORT $LN4@PyInit__st
$LN3@PyInit__st:

; 2127 :                         break;

  0011d	eb 39		 jmp	 SHORT $LN8@PyInit__st
$LN4@PyInit__st:

; 2128 :                     ptr->pack = native->pack;

  0011f	48 8b 44 24 28	 mov	 rax, QWORD PTR ptr$22062[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR native$22060[rsp]
  00129	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0012d	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2129 :                     ptr->unpack = native->unpack;

  00131	48 8b 44 24 28	 mov	 rax, QWORD PTR ptr$22062[rsp]
  00136	48 8b 4c 24 38	 mov	 rcx, QWORD PTR native$22060[rsp]
  0013b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0013f	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2130 :                     break;

  00143	eb 13		 jmp	 SHORT $LN8@PyInit__st
$LN7@PyInit__st:

; 2131 :                 }
; 2132 :                 ptr++;

  00145	48 8b 44 24 28	 mov	 rax, QWORD PTR ptr$22062[rsp]
  0014a	48 83 c0 28	 add	 rax, 40			; 00000028H
  0014e	48 89 44 24 28	 mov	 QWORD PTR ptr$22062[rsp], rax

; 2133 :             }

  00153	e9 57 ff ff ff	 jmp	 $LN9@PyInit__st
$LN8@PyInit__st:

; 2134 :             native++;

  00158	48 8b 44 24 38	 mov	 rax, QWORD PTR native$22060[rsp]
  0015d	48 83 c0 28	 add	 rax, 40			; 00000028H
  00161	48 89 44 24 38	 mov	 QWORD PTR native$22060[rsp], rax

; 2135 :         }

  00166	e9 1a ff ff ff	 jmp	 $LN11@PyInit__st
$LN10@PyInit__st:

; 2136 :     }
; 2137 : 
; 2138 :     /* Add some symbolic constants to the module */
; 2139 :     if (StructError == NULL) {

  0016b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR StructError, 0
  00173	75 26		 jne	 SHORT $LN2@PyInit__st

; 2140 :         StructError = PyErr_NewException("struct.error", NULL, NULL);

  00175	45 33 c0	 xor	 r8d, r8d
  00178	33 d2		 xor	 edx, edx
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@PADOAEKA@struct?4error?$AA@
  00181	e8 00 00 00 00	 call	 PyErr_NewException
  00186	48 89 05 00 00
	00 00		 mov	 QWORD PTR StructError, rax

; 2141 :         if (StructError == NULL)

  0018d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR StructError, 0
  00195	75 04		 jne	 SHORT $LN1@PyInit__st

; 2142 :             return NULL;

  00197	33 c0		 xor	 eax, eax
  00199	eb 4d		 jmp	 SHORT $LN16@PyInit__st
$LN1@PyInit__st:
$LN2@PyInit__st:

; 2143 :     }
; 2144 : 
; 2145 :     Py_INCREF(StructError);

  0019b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  001a2	e8 00 00 00 00	 call	 _Py_IncRef

; 2146 :     PyModule_AddObject(m, "error", StructError);

  001a7	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR StructError
  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  001b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  001ba	e8 00 00 00 00	 call	 PyModule_AddObject

; 2147 : 
; 2148 :     Py_INCREF((PyObject*)&PyStructType);

  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyStructType
  001c6	e8 00 00 00 00	 call	 _Py_IncRef

; 2149 :     PyModule_AddObject(m, "Struct", (PyObject*)&PyStructType);

  001cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyStructType
  001d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DOCMLGPG@Struct?$AA@
  001d9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  001de	e8 00 00 00 00	 call	 PyModule_AddObject

; 2150 : 
; 2151 :     return m;

  001e3	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
$LN16@PyInit__st:

; 2152 : }

  001e8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ec	c3		 ret	 0
PyInit__struct ENDP
_TEXT	ENDS
END
