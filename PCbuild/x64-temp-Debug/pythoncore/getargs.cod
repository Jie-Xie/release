; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	PyArg_Parse
;	COMDAT pdata
; File c:\src\pyparallel\python\getargs.c
pdata	SEGMENT
$pdata$PyArg_Parse DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$PyArg_Parse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_Parse DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyArg_Parse
_TEXT	SEGMENT
va$ = 32
retval$ = 40
args$ = 64
format$ = 72
PyArg_Parse PROC					; COMDAT

; 72   : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 73   :     int retval;
; 74   :     va_list va;
; 75   : 
; 76   :     va_start(va, format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp+8]
  0001d	48 89 44 24 20	 mov	 QWORD PTR va$[rsp], rax

; 77   :     retval = vgetargs1(args, format, &va, FLAG_COMPAT);

  00022	41 b9 01 00 00
	00		 mov	 r9d, 1
  00028	4c 8d 44 24 20	 lea	 r8, QWORD PTR va$[rsp]
  0002d	48 8b 54 24 48	 mov	 rdx, QWORD PTR format$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR args$[rsp]
  00037	e8 00 00 00 00	 call	 vgetargs1
  0003c	89 44 24 28	 mov	 DWORD PTR retval$[rsp], eax

; 78   :     va_end(va);

  00040	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 79   :     return retval;

  00049	8b 44 24 28	 mov	 eax, DWORD PTR retval$[rsp]

; 80   : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
PyArg_Parse ENDP
_TEXT	ENDS
PUBLIC	_PyArg_Parse_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_Parse_SizeT DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$_PyArg_Parse_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_Parse_SizeT DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyArg_Parse_SizeT
_TEXT	SEGMENT
va$ = 32
retval$ = 40
args$ = 64
format$ = 72
_PyArg_Parse_SizeT PROC					; COMDAT

; 84   : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 85   :     int retval;
; 86   :     va_list va;
; 87   : 
; 88   :     va_start(va, format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp+8]
  0001d	48 89 44 24 20	 mov	 QWORD PTR va$[rsp], rax

; 89   :     retval = vgetargs1(args, format, &va, FLAG_COMPAT|FLAG_SIZE_T);

  00022	41 b9 03 00 00
	00		 mov	 r9d, 3
  00028	4c 8d 44 24 20	 lea	 r8, QWORD PTR va$[rsp]
  0002d	48 8b 54 24 48	 mov	 rdx, QWORD PTR format$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR args$[rsp]
  00037	e8 00 00 00 00	 call	 vgetargs1
  0003c	89 44 24 28	 mov	 DWORD PTR retval$[rsp], eax

; 90   :     va_end(va);

  00040	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 91   :     return retval;

  00049	8b 44 24 28	 mov	 eax, DWORD PTR retval$[rsp]

; 92   : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
_PyArg_Parse_SizeT ENDP
_TEXT	ENDS
PUBLIC	PyArg_ParseTuple
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_ParseTuple DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$PyArg_ParseTuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_ParseTuple DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyArg_ParseTuple
_TEXT	SEGMENT
va$ = 32
retval$ = 40
args$ = 64
format$ = 72
PyArg_ParseTuple PROC					; COMDAT

; 97   : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 98   :     int retval;
; 99   :     va_list va;
; 100  : 
; 101  :     va_start(va, format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp+8]
  0001d	48 89 44 24 20	 mov	 QWORD PTR va$[rsp], rax

; 102  :     retval = vgetargs1(args, format, &va, 0);

  00022	45 33 c9	 xor	 r9d, r9d
  00025	4c 8d 44 24 20	 lea	 r8, QWORD PTR va$[rsp]
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR args$[rsp]
  00034	e8 00 00 00 00	 call	 vgetargs1
  00039	89 44 24 28	 mov	 DWORD PTR retval$[rsp], eax

; 103  :     va_end(va);

  0003d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 104  :     return retval;

  00046	8b 44 24 28	 mov	 eax, DWORD PTR retval$[rsp]

; 105  : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
PyArg_ParseTuple ENDP
_TEXT	ENDS
PUBLIC	_PyArg_ParseTuple_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_ParseTuple_SizeT DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$_PyArg_ParseTuple_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_ParseTuple_SizeT DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyArg_ParseTuple_SizeT
_TEXT	SEGMENT
va$ = 32
retval$ = 40
args$ = 64
format$ = 72
_PyArg_ParseTuple_SizeT PROC				; COMDAT

; 109  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 110  :     int retval;
; 111  :     va_list va;
; 112  : 
; 113  :     va_start(va, format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp+8]
  0001d	48 89 44 24 20	 mov	 QWORD PTR va$[rsp], rax

; 114  :     retval = vgetargs1(args, format, &va, FLAG_SIZE_T);

  00022	41 b9 02 00 00
	00		 mov	 r9d, 2
  00028	4c 8d 44 24 20	 lea	 r8, QWORD PTR va$[rsp]
  0002d	48 8b 54 24 48	 mov	 rdx, QWORD PTR format$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR args$[rsp]
  00037	e8 00 00 00 00	 call	 vgetargs1
  0003c	89 44 24 28	 mov	 DWORD PTR retval$[rsp], eax

; 115  :     va_end(va);

  00040	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 116  :     return retval;

  00049	8b 44 24 28	 mov	 eax, DWORD PTR retval$[rsp]

; 117  : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
_PyArg_ParseTuple_SizeT ENDP
_TEXT	ENDS
PUBLIC	PyArg_VaParse
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_VaParse DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$PyArg_VaParse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_VaParse DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyArg_VaParse
_TEXT	SEGMENT
lva$ = 32
args$ = 64
format$ = 72
va$ = 80
PyArg_VaParse PROC					; COMDAT

; 122  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 123  :     va_list lva;
; 124  : 
; 125  :         Py_VA_COPY(lva, va);

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR va$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR lva$[rsp], rax

; 126  : 
; 127  :     return vgetargs1(args, format, &lva, 0);

  0001d	45 33 c9	 xor	 r9d, r9d
  00020	4c 8d 44 24 20	 lea	 r8, QWORD PTR lva$[rsp]
  00025	48 8b 54 24 48	 mov	 rdx, QWORD PTR format$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR args$[rsp]
  0002f	e8 00 00 00 00	 call	 vgetargs1

; 128  : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
PyArg_VaParse ENDP
_TEXT	ENDS
PUBLIC	_PyArg_VaParse_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_VaParse_SizeT DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$_PyArg_VaParse_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_VaParse_SizeT DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyArg_VaParse_SizeT
_TEXT	SEGMENT
lva$ = 32
args$ = 64
format$ = 72
va$ = 80
_PyArg_VaParse_SizeT PROC				; COMDAT

; 132  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 133  :     va_list lva;
; 134  : 
; 135  :         Py_VA_COPY(lva, va);

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR va$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR lva$[rsp], rax

; 136  : 
; 137  :     return vgetargs1(args, format, &lva, FLAG_SIZE_T);

  0001d	41 b9 02 00 00
	00		 mov	 r9d, 2
  00023	4c 8d 44 24 20	 lea	 r8, QWORD PTR lva$[rsp]
  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR format$[rsp]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR args$[rsp]
  00032	e8 00 00 00 00	 call	 vgetargs1

; 138  : }

  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
_PyArg_VaParse_SizeT ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@OELPODI@bad?5format?5string?3?5?$CF?4200s?$AA@ ; `string'
PUBLIC	??_C@_0CM@DKJKMDMF@?$CF?4150s?$CFs?5takes?5?$CFs?5?$CFd?5argument?$CFs?5@ ; `string'
PUBLIC	??_C@_07IGBEEPOP@at?5most?$AA@			; `string'
PUBLIC	??_C@_08FNDBFMB@at?5least?$AA@			; `string'
PUBLIC	??_C@_07JLAGAGFH@exactly?$AA@			; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_1EC@HIPDKELL@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ@ ; `string'
PUBLIC	??_C@_0DF@JGNAFJFF@new?5style?5getargs?5format?5but?5arg@ ; `string'
PUBLIC	??_C@_0CL@DEDHDHFB@old?5style?5getargs?5format?5uses?5ne@ ; `string'
PUBLIC	??_C@_0CF@DGFDACBP@?$CF?4200s?$CFs?5takes?5at?5least?5one?5argu@ ; `string'
PUBLIC	??_C@_0BM@CMEPCPDC@?$CF?4200s?$CFs?5takes?5no?5arguments?$AA@ ; `string'
PUBLIC	??_C@_08HFFPPCHF@function?$AA@			; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BO@LCKPDGLB@missing?5?8?$CJ?8?5in?5getargs?5format?$AA@ ; `string'
PUBLIC	??_C@_0BN@FODOOFID@excess?5?8?$CJ?8?5in?5getargs?5format?$AA@ ; `string'
PUBLIC	??_C@_0DI@OGOCGHBO@too?5many?5tuple?5nesting?5levels?5in@ ; `string'
PUBLIC	??_C@_1EI@FFDFEFON@?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AAN?$AAU@ ; `string'
PUBLIC	??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_SystemError:QWORD
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_Py_PXCTX:PROC
EXTRN	_Py_ctype_table:BYTE
EXTRN	Py_FatalError:PROC
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$vgetargs1 DD imagerel vgetargs1
	DD	imagerel vgetargs1+2448
	DD	imagerel $unwind$vgetargs1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vgetargs1 DD 021b01H
	DD	055011bH
xdata	ENDS
;	COMDAT ??_C@_0BK@OELPODI@bad?5format?5string?3?5?$CF?4200s?$AA@
CONST	SEGMENT
??_C@_0BK@OELPODI@bad?5format?5string?3?5?$CF?4200s?$AA@ DB 'bad format s'
	DB	'tring: %.200s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DKJKMDMF@?$CF?4150s?$CFs?5takes?5?$CFs?5?$CFd?5argument?$CFs?5@
CONST	SEGMENT
??_C@_0CM@DKJKMDMF@?$CF?4150s?$CFs?5takes?5?$CFs?5?$CFd?5argument?$CFs?5@ DB '%'
	DB	'.150s%s takes %s %d argument%s (%ld given)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IGBEEPOP@at?5most?$AA@
CONST	SEGMENT
??_C@_07IGBEEPOP@at?5most?$AA@ DB 'at most', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FNDBFMB@at?5least?$AA@
CONST	SEGMENT
??_C@_08FNDBFMB@at?5least?$AA@ DB 'at least', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JLAGAGFH@exactly?$AA@
CONST	SEGMENT
??_C@_07JLAGAGFH@exactly?$AA@ DB 'exactly', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@HIPDKELL@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@HIPDKELL@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ@ DB '('
	DB	00H, 'P', 00H, 'y', 00H, '_', 00H, 's', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H, 'l'
	DB	00H, 'o', 00H, 'n', 00H, 'g', 00H, ')', 00H, '(', 00H, 'l', 00H
	DB	'e', 00H, 'n', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '(', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JGNAFJFF@new?5style?5getargs?5format?5but?5arg@
CONST	SEGMENT
??_C@_0DF@JGNAFJFF@new?5style?5getargs?5format?5but?5arg@ DB 'new style g'
	DB	'etargs format but argument is not a tuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DEDHDHFB@old?5style?5getargs?5format?5uses?5ne@
CONST	SEGMENT
??_C@_0CL@DEDHDHFB@old?5style?5getargs?5format?5uses?5ne@ DB 'old style g'
	DB	'etargs format uses new features', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGFDACBP@?$CF?4200s?$CFs?5takes?5at?5least?5one?5argu@
CONST	SEGMENT
??_C@_0CF@DGFDACBP@?$CF?4200s?$CFs?5takes?5at?5least?5one?5argu@ DB '%.20'
	DB	'0s%s takes at least one argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CMEPCPDC@?$CF?4200s?$CFs?5takes?5no?5arguments?$AA@
CONST	SEGMENT
??_C@_0BM@CMEPCPDC@?$CF?4200s?$CFs?5takes?5no?5arguments?$AA@ DB '%.200s%'
	DB	's takes no arguments', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HFFPPCHF@function?$AA@
CONST	SEGMENT
??_C@_08HFFPPCHF@function?$AA@ DB 'function', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LCKPDGLB@missing?5?8?$CJ?8?5in?5getargs?5format?$AA@
CONST	SEGMENT
??_C@_0BO@LCKPDGLB@missing?5?8?$CJ?8?5in?5getargs?5format?$AA@ DB 'missin'
	DB	'g '')'' in getargs format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FODOOFID@excess?5?8?$CJ?8?5in?5getargs?5format?$AA@
CONST	SEGMENT
??_C@_0BN@FODOOFID@excess?5?8?$CJ?8?5in?5getargs?5format?$AA@ DB 'excess '
	DB	''')'' in getargs format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OGOCGHBO@too?5many?5tuple?5nesting?5levels?5in@
CONST	SEGMENT
??_C@_0DI@OGOCGHBO@too?5many?5tuple?5nesting?5levels?5in@ DB 'too many tu'
	DB	'ple nesting levels in argument format string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@FFDFEFON@?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AAN?$AAU@
CONST	SEGMENT
??_C@_1EI@FFDFEFON@?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AAN?$AAU@ DB 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, '(', 00H, 'a', 00H, 'r', 00H, 'g'
	DB	00H, 's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '(', 00H
	DB	'P', 00H, 'y', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, '*', 00H, ')', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'y', 00H, 't', 00H, 'h', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'g', 00H, 'e', 00H, 't', 00H, 'a'
	DB	00H, 'r', 00H, 'g', 00H, 's', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT vgetargs1
_TEXT	SEGMENT
level$ = 64
fname$ = 72
formatsave$ = 80
compat$ = 88
i$ = 96
min$ = 104
freelist$ = 112
levels$ = 128
msg$ = 256
len$ = 264
endfmt$ = 272
message$ = 280
msgbuf$ = 288
max$ = 544
c$20519 = 548
tv75 = 552
tv153 = 560
tv152 = 568
tv160 = 576
tv163 = 584
tv174 = 592
tv177 = 600
tv235 = 608
tv237 = 616
tv241 = 624
tv247 = 632
tv246 = 640
tv250 = 648
tv253 = 656
args$ = 688
format$ = 696
p_va$ = 704
flags$ = 712
vgetargs1 PROC						; COMDAT

; 197  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 02
	00 00		 sub	 rsp, 680		; 000002a8H

; 198  :     char msgbuf[256];
; 199  :     int levels[32];
; 200  :     const char *fname = NULL;

  0001b	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR fname$[rsp], 0

; 201  :     const char *message = NULL;

  00024	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR message$[rsp], 0

; 202  :     int min = -1;

  00030	c7 44 24 68 ff
	ff ff ff	 mov	 DWORD PTR min$[rsp], -1

; 203  :     int max = 0;

  00038	c7 84 24 20 02
	00 00 00 00 00
	00		 mov	 DWORD PTR max$[rsp], 0

; 204  :     int level = 0;

  00043	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR level$[rsp], 0

; 205  :     int endfmt = 0;

  0004b	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR endfmt$[rsp], 0

; 206  :     const char *formatsave = format;

  00056	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  0005e	48 89 44 24 50	 mov	 QWORD PTR formatsave$[rsp], rax

; 207  :     Py_ssize_t i, len;
; 208  :     char *msg;
; 209  :     freelist_t freelist = {0, NULL};

  00063	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR freelist$[rsp], 0
  0006b	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR freelist$[rsp+8], 0

; 210  :     int compat = flags & FLAG_COMPAT;

  00074	8b 84 24 c8 02
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0007b	83 e0 01	 and	 eax, 1
  0007e	89 44 24 58	 mov	 DWORD PTR compat$[rsp], eax

; 211  : 
; 212  :     assert(compat || (args != (PyObject*)NULL));

  00082	83 7c 24 58 00	 cmp	 DWORD PTR compat$[rsp], 0
  00087	75 27		 jne	 SHORT $LN46@vgetargs1
  00089	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR args$[rsp], 0
  00092	75 1c		 jne	 SHORT $LN46@vgetargs1
  00094	41 b8 d4 00 00
	00		 mov	 r8d, 212		; 000000d4H
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@FFDFEFON@?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AAN?$AAU@
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ae	33 c0		 xor	 eax, eax
$LN46@vgetargs1:

; 213  :     flags = flags & ~FLAG_COMPAT;

  000b0	8b 84 24 c8 02
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  000b7	83 e0 fe	 and	 eax, -2
  000ba	89 84 24 c8 02
	00 00		 mov	 DWORD PTR flags$[rsp], eax
$LN43@vgetargs1:

; 214  : 
; 215  :     while (endfmt == 0) {

  000c1	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR endfmt$[rsp], 0
  000c9	0f 85 9e 01 00
	00		 jne	 $LN42@vgetargs1

; 216  :         int c = *format++;

  000cf	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  000d7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000da	89 84 24 24 02
	00 00		 mov	 DWORD PTR c$20519[rsp], eax
  000e1	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  000e9	48 ff c0	 inc	 rax
  000ec	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR format$[rsp], rax

; 217  :         switch (c) {

  000f4	8b 84 24 24 02
	00 00		 mov	 eax, DWORD PTR c$20519[rsp]
  000fb	89 84 24 28 02
	00 00		 mov	 DWORD PTR tv75[rsp], eax
  00102	83 bc 24 28 02
	00 00 00	 cmp	 DWORD PTR tv75[rsp], 0
  0010a	0f 84 92 00 00
	00		 je	 $LN33@vgetargs1
  00110	83 bc 24 28 02
	00 00 28	 cmp	 DWORD PTR tv75[rsp], 40	; 00000028H
  00118	74 2b		 je	 SHORT $LN39@vgetargs1
  0011a	83 bc 24 28 02
	00 00 29	 cmp	 DWORD PTR tv75[rsp], 41	; 00000029H
  00122	74 5a		 je	 SHORT $LN36@vgetargs1
  00124	83 bc 24 28 02
	00 00 3a	 cmp	 DWORD PTR tv75[rsp], 58	; 0000003aH
  0012c	0f 84 80 00 00
	00		 je	 $LN32@vgetargs1
  00132	83 bc 24 28 02
	00 00 3b	 cmp	 DWORD PTR tv75[rsp], 59	; 0000003bH
  0013a	0f 84 8f 00 00
	00		 je	 $LN31@vgetargs1
  00140	e9 a7 00 00 00	 jmp	 $LN30@vgetargs1
$LN39@vgetargs1:

; 218  :         case '(':
; 219  :             if (level == 0)

  00145	83 7c 24 40 00	 cmp	 DWORD PTR level$[rsp], 0
  0014a	75 10		 jne	 SHORT $LN38@vgetargs1

; 220  :                 max++;

  0014c	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00153	ff c0		 inc	 eax
  00155	89 84 24 20 02
	00 00		 mov	 DWORD PTR max$[rsp], eax
$LN38@vgetargs1:

; 221  :             level++;

  0015c	8b 44 24 40	 mov	 eax, DWORD PTR level$[rsp]
  00160	ff c0		 inc	 eax
  00162	89 44 24 40	 mov	 DWORD PTR level$[rsp], eax

; 222  :             if (level >= 30)

  00166	83 7c 24 40 1e	 cmp	 DWORD PTR level$[rsp], 30
  0016b	7c 0c		 jl	 SHORT $LN37@vgetargs1

; 223  :                 Py_FatalError("too many tuple nesting levels "
; 224  :                               "in argument format string");

  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@OGOCGHBO@too?5many?5tuple?5nesting?5levels?5in@
  00174	e8 00 00 00 00	 call	 Py_FatalError
$LN37@vgetargs1:

; 225  :             break;

  00179	e9 ea 00 00 00	 jmp	 $LN40@vgetargs1
$LN36@vgetargs1:

; 226  :         case ')':
; 227  :             if (level == 0)

  0017e	83 7c 24 40 00	 cmp	 DWORD PTR level$[rsp], 0
  00183	75 0e		 jne	 SHORT $LN35@vgetargs1

; 228  :                 Py_FatalError("excess ')' in getargs format");

  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@FODOOFID@excess?5?8?$CJ?8?5in?5getargs?5format?$AA@
  0018c	e8 00 00 00 00	 call	 Py_FatalError

; 229  :             else

  00191	eb 0a		 jmp	 SHORT $LN34@vgetargs1
$LN35@vgetargs1:

; 230  :                 level--;

  00193	8b 44 24 40	 mov	 eax, DWORD PTR level$[rsp]
  00197	ff c8		 dec	 eax
  00199	89 44 24 40	 mov	 DWORD PTR level$[rsp], eax
$LN34@vgetargs1:

; 231  :             break;

  0019d	e9 c6 00 00 00	 jmp	 $LN40@vgetargs1
$LN33@vgetargs1:

; 232  :         case '\0':
; 233  :             endfmt = 1;

  001a2	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR endfmt$[rsp], 1

; 234  :             break;

  001ad	e9 b6 00 00 00	 jmp	 $LN40@vgetargs1
$LN32@vgetargs1:

; 235  :         case ':':
; 236  :             fname = format;

  001b2	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  001ba	48 89 44 24 48	 mov	 QWORD PTR fname$[rsp], rax

; 237  :             endfmt = 1;

  001bf	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR endfmt$[rsp], 1

; 238  :             break;

  001ca	e9 99 00 00 00	 jmp	 $LN40@vgetargs1
$LN31@vgetargs1:

; 239  :         case ';':
; 240  :             message = format;

  001cf	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  001d7	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR message$[rsp], rax

; 241  :             endfmt = 1;

  001df	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR endfmt$[rsp], 1

; 242  :             break;

  001ea	eb 7c		 jmp	 SHORT $LN40@vgetargs1
$LN30@vgetargs1:

; 243  :         default:
; 244  :             if (level == 0) {

  001ec	83 7c 24 40 00	 cmp	 DWORD PTR level$[rsp], 0
  001f1	75 75		 jne	 SHORT $LN29@vgetargs1

; 245  :                 if (c == 'O')

  001f3	83 bc 24 24 02
	00 00 4f	 cmp	 DWORD PTR c$20519[rsp], 79 ; 0000004fH
  001fb	75 12		 jne	 SHORT $LN28@vgetargs1

; 246  :                     max++;

  001fd	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00204	ff c0		 inc	 eax
  00206	89 84 24 20 02
	00 00		 mov	 DWORD PTR max$[rsp], eax
  0020d	eb 59		 jmp	 SHORT $LN27@vgetargs1
$LN28@vgetargs1:

; 247  :                 else if (Py_ISALPHA(Py_CHARMASK(c))) {

  0020f	8b 84 24 24 02
	00 00		 mov	 eax, DWORD PTR c$20519[rsp]
  00216	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0021b	0f b6 c0	 movzx	 eax, al
  0021e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00223	0f b6 c0	 movzx	 eax, al
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0022d	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00230	83 e0 03	 and	 eax, 3
  00233	85 c0		 test	 eax, eax
  00235	74 1c		 je	 SHORT $LN26@vgetargs1

; 248  :                     if (c != 'e') /* skip encoded */

  00237	83 bc 24 24 02
	00 00 65	 cmp	 DWORD PTR c$20519[rsp], 101 ; 00000065H
  0023f	74 10		 je	 SHORT $LN25@vgetargs1

; 249  :                         max++;

  00241	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00248	ff c0		 inc	 eax
  0024a	89 84 24 20 02
	00 00		 mov	 DWORD PTR max$[rsp], eax
$LN25@vgetargs1:

; 250  :                 } else if (c == '|')

  00251	eb 15		 jmp	 SHORT $LN24@vgetargs1
$LN26@vgetargs1:
  00253	83 bc 24 24 02
	00 00 7c	 cmp	 DWORD PTR c$20519[rsp], 124 ; 0000007cH
  0025b	75 0b		 jne	 SHORT $LN23@vgetargs1

; 251  :                     min = max;

  0025d	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00264	89 44 24 68	 mov	 DWORD PTR min$[rsp], eax
$LN23@vgetargs1:
$LN24@vgetargs1:
$LN27@vgetargs1:
$LN29@vgetargs1:
$LN40@vgetargs1:

; 252  :             }
; 253  :             break;
; 254  :         }
; 255  :     }

  00268	e9 54 fe ff ff	 jmp	 $LN43@vgetargs1
$LN42@vgetargs1:

; 256  : 
; 257  :     if (level != 0)

  0026d	83 7c 24 40 00	 cmp	 DWORD PTR level$[rsp], 0
  00272	74 0c		 je	 SHORT $LN22@vgetargs1

; 258  :         Py_FatalError(/* '(' */ "missing ')' in getargs format");

  00274	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@LCKPDGLB@missing?5?8?$CJ?8?5in?5getargs?5format?$AA@
  0027b	e8 00 00 00 00	 call	 Py_FatalError
$LN22@vgetargs1:

; 259  : 
; 260  :     if (min < 0)

  00280	83 7c 24 68 00	 cmp	 DWORD PTR min$[rsp], 0
  00285	7d 0b		 jge	 SHORT $LN21@vgetargs1

; 261  :         min = max;

  00287	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  0028e	89 44 24 68	 mov	 DWORD PTR min$[rsp], eax
$LN21@vgetargs1:

; 262  : 
; 263  :     format = formatsave;

  00292	48 8b 44 24 50	 mov	 rax, QWORD PTR formatsave$[rsp]
  00297	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR format$[rsp], rax

; 264  : 
; 265  :     freelist.entries = PyMem_NEW(freelistentry_t, max);

  0029f	48 63 84 24 20
	02 00 00	 movsxd	 rax, DWORD PTR max$[rsp]
  002a7	48 b9 ff ff ff
	ff ff ff ff 07	 mov	 rcx, 576460752303423487	; 07ffffffffffffffH
  002b1	48 3b c1	 cmp	 rax, rcx
  002b4	76 0e		 jbe	 SHORT $LN49@vgetargs1
  002b6	48 c7 84 24 30
	02 00 00 00 00
	00 00		 mov	 QWORD PTR tv153[rsp], 0
  002c2	eb 53		 jmp	 SHORT $LN50@vgetargs1
$LN49@vgetargs1:
  002c4	e8 00 00 00 00	 call	 _Py_PXCTX
  002c9	85 c0		 test	 eax, eax
  002cb	74 1e		 je	 SHORT $LN47@vgetargs1
  002cd	48 63 84 24 20
	02 00 00	 movsxd	 rax, DWORD PTR max$[rsp]
  002d5	48 6b c0 10	 imul	 rax, 16
  002d9	48 8b c8	 mov	 rcx, rax
  002dc	e8 00 00 00 00	 call	 _PxMem_Malloc
  002e1	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR tv152[rsp], rax
  002e9	eb 1c		 jmp	 SHORT $LN48@vgetargs1
$LN47@vgetargs1:
  002eb	48 63 84 24 20
	02 00 00	 movsxd	 rax, DWORD PTR max$[rsp]
  002f3	48 6b c0 10	 imul	 rax, 16
  002f7	48 8b c8	 mov	 rcx, rax
  002fa	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  002ff	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR tv152[rsp], rax
$LN48@vgetargs1:
  00307	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR tv152[rsp]
  0030f	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR tv153[rsp], rax
$LN50@vgetargs1:
  00317	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR tv153[rsp]
  0031f	48 89 44 24 78	 mov	 QWORD PTR freelist$[rsp+8], rax

; 266  :     if (freelist.entries == NULL) {

  00324	48 83 7c 24 78
	00		 cmp	 QWORD PTR freelist$[rsp+8], 0
  0032a	75 0c		 jne	 SHORT $LN20@vgetargs1

; 267  :         PyErr_NoMemory();

  0032c	e8 00 00 00 00	 call	 PyErr_NoMemory

; 268  :         return 0;

  00331	33 c0		 xor	 eax, eax
  00333	e9 50 06 00 00	 jmp	 $LN44@vgetargs1
$LN20@vgetargs1:

; 269  :     }
; 270  : 
; 271  :     if (compat) {

  00338	83 7c 24 58 00	 cmp	 DWORD PTR compat$[rsp], 0
  0033d	0f 84 35 02 00
	00		 je	 $LN19@vgetargs1

; 272  :         if (max == 0) {

  00343	83 bc 24 20 02
	00 00 00	 cmp	 DWORD PTR max$[rsp], 0
  0034b	0f 85 9c 00 00
	00		 jne	 $LN18@vgetargs1

; 273  :             if (args == NULL)

  00351	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR args$[rsp], 0
  0035a	75 0a		 jne	 SHORT $LN17@vgetargs1

; 274  :                 return 1;

  0035c	b8 01 00 00 00	 mov	 eax, 1
  00361	e9 22 06 00 00	 jmp	 $LN44@vgetargs1
$LN17@vgetargs1:

; 275  :             PyErr_Format(PyExc_TypeError,
; 276  :                          "%.200s%s takes no arguments",
; 277  :                          fname==NULL ? "function" : fname,
; 278  :                          fname==NULL ? "" : "()");

  00366	48 83 7c 24 48
	00		 cmp	 QWORD PTR fname$[rsp], 0
  0036c	75 11		 jne	 SHORT $LN51@vgetargs1
  0036e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00375	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR tv160[rsp], rax
  0037d	eb 0f		 jmp	 SHORT $LN52@vgetargs1
$LN51@vgetargs1:
  0037f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00386	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR tv160[rsp], rax
$LN52@vgetargs1:
  0038e	48 83 7c 24 48
	00		 cmp	 QWORD PTR fname$[rsp], 0
  00394	75 11		 jne	 SHORT $LN53@vgetargs1
  00396	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08HFFPPCHF@function?$AA@
  0039d	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR tv163[rsp], rax
  003a5	eb 0d		 jmp	 SHORT $LN54@vgetargs1
$LN53@vgetargs1:
  003a7	48 8b 44 24 48	 mov	 rax, QWORD PTR fname$[rsp]
  003ac	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR tv163[rsp], rax
$LN54@vgetargs1:
  003b4	4c 8b 8c 24 40
	02 00 00	 mov	 r9, QWORD PTR tv160[rsp]
  003bc	4c 8b 84 24 48
	02 00 00	 mov	 r8, QWORD PTR tv163[rsp]
  003c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@CMEPCPDC@?$CF?4200s?$CFs?5takes?5no?5arguments?$AA@
  003cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  003d2	e8 00 00 00 00	 call	 PyErr_Format

; 279  :             return cleanreturn(0, &freelist);

  003d7	48 8d 54 24 70	 lea	 rdx, QWORD PTR freelist$[rsp]
  003dc	33 c9		 xor	 ecx, ecx
  003de	e8 00 00 00 00	 call	 cleanreturn
  003e3	e9 a0 05 00 00	 jmp	 $LN44@vgetargs1
  003e8	e9 8b 01 00 00	 jmp	 $LN16@vgetargs1
$LN18@vgetargs1:

; 280  :         }
; 281  :         else if (min == 1 && max == 1) {

  003ed	83 7c 24 68 01	 cmp	 DWORD PTR min$[rsp], 1
  003f2	0f 85 5c 01 00
	00		 jne	 $LN15@vgetargs1
  003f8	83 bc 24 20 02
	00 00 01	 cmp	 DWORD PTR max$[rsp], 1
  00400	0f 85 4e 01 00
	00		 jne	 $LN15@vgetargs1

; 282  :             if (args == NULL) {

  00406	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR args$[rsp], 0
  0040f	0f 85 82 00 00
	00		 jne	 $LN14@vgetargs1

; 283  :                 PyErr_Format(PyExc_TypeError,
; 284  :                              "%.200s%s takes at least one argument",
; 285  :                              fname==NULL ? "function" : fname,
; 286  :                              fname==NULL ? "" : "()");

  00415	48 83 7c 24 48
	00		 cmp	 QWORD PTR fname$[rsp], 0
  0041b	75 11		 jne	 SHORT $LN55@vgetargs1
  0041d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00424	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR tv174[rsp], rax
  0042c	eb 0f		 jmp	 SHORT $LN56@vgetargs1
$LN55@vgetargs1:
  0042e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00435	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR tv174[rsp], rax
$LN56@vgetargs1:
  0043d	48 83 7c 24 48
	00		 cmp	 QWORD PTR fname$[rsp], 0
  00443	75 11		 jne	 SHORT $LN57@vgetargs1
  00445	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08HFFPPCHF@function?$AA@
  0044c	48 89 84 24 58
	02 00 00	 mov	 QWORD PTR tv177[rsp], rax
  00454	eb 0d		 jmp	 SHORT $LN58@vgetargs1
$LN57@vgetargs1:
  00456	48 8b 44 24 48	 mov	 rax, QWORD PTR fname$[rsp]
  0045b	48 89 84 24 58
	02 00 00	 mov	 QWORD PTR tv177[rsp], rax
$LN58@vgetargs1:
  00463	4c 8b 8c 24 50
	02 00 00	 mov	 r9, QWORD PTR tv174[rsp]
  0046b	4c 8b 84 24 58
	02 00 00	 mov	 r8, QWORD PTR tv177[rsp]
  00473	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@DGFDACBP@?$CF?4200s?$CFs?5takes?5at?5least?5one?5argu@
  0047a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00481	e8 00 00 00 00	 call	 PyErr_Format

; 287  :                 return cleanreturn(0, &freelist);

  00486	48 8d 54 24 70	 lea	 rdx, QWORD PTR freelist$[rsp]
  0048b	33 c9		 xor	 ecx, ecx
  0048d	e8 00 00 00 00	 call	 cleanreturn
  00492	e9 f1 04 00 00	 jmp	 $LN44@vgetargs1
$LN14@vgetargs1:

; 288  :             }
; 289  :             msg = convertitem(args, &format, p_va, flags, levels,
; 290  :                               msgbuf, sizeof(msgbuf), &freelist);

  00497	48 8d 44 24 70	 lea	 rax, QWORD PTR freelist$[rsp]
  0049c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  004a1	48 c7 44 24 30
	00 01 00 00	 mov	 QWORD PTR [rsp+48], 256	; 00000100H
  004aa	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR msgbuf$[rsp]
  004b2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004b7	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR levels$[rsp]
  004bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c4	44 8b 8c 24 c8
	02 00 00	 mov	 r9d, DWORD PTR flags$[rsp]
  004cc	4c 8b 84 24 c0
	02 00 00	 mov	 r8, QWORD PTR p_va$[rsp]
  004d4	48 8d 94 24 b8
	02 00 00	 lea	 rdx, QWORD PTR format$[rsp]
  004dc	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  004e4	e8 00 00 00 00	 call	 convertitem
  004e9	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR msg$[rsp], rax

; 291  :             if (msg == NULL)

  004f1	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR msg$[rsp], 0
  004fa	75 14		 jne	 SHORT $LN13@vgetargs1

; 292  :                 return cleanreturn(1, &freelist);

  004fc	48 8d 54 24 70	 lea	 rdx, QWORD PTR freelist$[rsp]
  00501	b9 01 00 00 00	 mov	 ecx, 1
  00506	e8 00 00 00 00	 call	 cleanreturn
  0050b	e9 78 04 00 00	 jmp	 $LN44@vgetargs1
$LN13@vgetargs1:

; 293  :             seterror(levels[0], msg, levels+1, fname, message);

  00510	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR levels$[rsp+4]
  00518	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR message$[rsp]
  00520	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00525	4c 8b 4c 24 48	 mov	 r9, QWORD PTR fname$[rsp]
  0052a	4c 8b c0	 mov	 r8, rax
  0052d	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR msg$[rsp]
  00535	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR levels$[rsp]
  0053c	e8 00 00 00 00	 call	 seterror

; 294  :             return cleanreturn(0, &freelist);

  00541	48 8d 54 24 70	 lea	 rdx, QWORD PTR freelist$[rsp]
  00546	33 c9		 xor	 ecx, ecx
  00548	e8 00 00 00 00	 call	 cleanreturn
  0054d	e9 36 04 00 00	 jmp	 $LN44@vgetargs1

; 295  :         }
; 296  :         else {

  00552	eb 24		 jmp	 SHORT $LN12@vgetargs1
$LN15@vgetargs1:

; 297  :             PyErr_SetString(PyExc_SystemError,
; 298  :                 "old style getargs format uses new features");

  00554	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@DEDHDHFB@old?5style?5getargs?5format?5uses?5ne@
  0055b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00562	e8 00 00 00 00	 call	 PyErr_SetString

; 299  :             return cleanreturn(0, &freelist);

  00567	48 8d 54 24 70	 lea	 rdx, QWORD PTR freelist$[rsp]
  0056c	33 c9		 xor	 ecx, ecx
  0056e	e8 00 00 00 00	 call	 cleanreturn
  00573	e9 10 04 00 00	 jmp	 $LN44@vgetargs1
$LN12@vgetargs1:
$LN16@vgetargs1:
$LN19@vgetargs1:

; 300  :         }
; 301  :     }
; 302  : 
; 303  :     if (!PyTuple_Check(args)) {

  00578	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00580	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00584	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0058a	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0058f	85 c0		 test	 eax, eax
  00591	75 24		 jne	 SHORT $LN11@vgetargs1

; 304  :         PyErr_SetString(PyExc_SystemError,
; 305  :             "new style getargs format but argument is not a tuple");

  00593	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@JGNAFJFF@new?5style?5getargs?5format?5but?5arg@
  0059a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  005a1	e8 00 00 00 00	 call	 PyErr_SetString

; 306  :         return cleanreturn(0, &freelist);

  005a6	48 8d 54 24 70	 lea	 rdx, QWORD PTR freelist$[rsp]
  005ab	33 c9		 xor	 ecx, ecx
  005ad	e8 00 00 00 00	 call	 cleanreturn
  005b2	e9 d1 03 00 00	 jmp	 $LN44@vgetargs1
$LN11@vgetargs1:

; 307  :     }
; 308  : 
; 309  :     len = PyTuple_GET_SIZE(args);

  005b7	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR args$[rsp]
  005bf	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  005c3	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR len$[rsp], rax

; 310  : 
; 311  :     if (len < min || max < len) {

  005cb	48 63 44 24 68	 movsxd	 rax, DWORD PTR min$[rsp]
  005d0	48 39 84 24 08
	01 00 00	 cmp	 QWORD PTR len$[rsp], rax
  005d8	7c 16		 jl	 SHORT $LN9@vgetargs1
  005da	48 63 84 24 20
	02 00 00	 movsxd	 rax, DWORD PTR max$[rsp]
  005e2	48 3b 84 24 08
	01 00 00	 cmp	 rax, QWORD PTR len$[rsp]
  005ea	0f 8d e0 01 00
	00		 jge	 $LN10@vgetargs1
$LN9@vgetargs1:

; 312  :         if (message == NULL)

  005f0	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR message$[rsp], 0
  005f9	0f 85 ac 01 00
	00		 jne	 $LN8@vgetargs1

; 313  :             PyErr_Format(PyExc_TypeError,
; 314  :                          "%.150s%s takes %s %d argument%s (%ld given)",
; 315  :                          fname==NULL ? "function" : fname,
; 316  :                          fname==NULL ? "" : "()",
; 317  :                          min==max ? "exactly"
; 318  :                          : len < min ? "at least" : "at most",
; 319  :                          len < min ? min : max,
; 320  :                          (len < min ? min : max) == 1 ? "" : "s",
; 321  :                          Py_SAFE_DOWNCAST(len, Py_ssize_t, long));

  005ff	48 63 84 24 08
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00607	48 3b 84 24 08
	01 00 00	 cmp	 rax, QWORD PTR len$[rsp]
  0060f	74 1c		 je	 SHORT $LN59@vgetargs1
  00611	41 b8 41 01 00
	00		 mov	 r8d, 321		; 00000141H
  00617	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  0061e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@HIPDKELL@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ@
  00625	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0062b	33 c0		 xor	 eax, eax
$LN59@vgetargs1:
  0062d	48 63 44 24 68	 movsxd	 rax, DWORD PTR min$[rsp]
  00632	48 39 84 24 08
	01 00 00	 cmp	 QWORD PTR len$[rsp], rax
  0063a	7d 0d		 jge	 SHORT $LN60@vgetargs1
  0063c	8b 44 24 68	 mov	 eax, DWORD PTR min$[rsp]
  00640	89 84 24 60 02
	00 00		 mov	 DWORD PTR tv235[rsp], eax
  00647	eb 0e		 jmp	 SHORT $LN61@vgetargs1
$LN60@vgetargs1:
  00649	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00650	89 84 24 60 02
	00 00		 mov	 DWORD PTR tv235[rsp], eax
$LN61@vgetargs1:
  00657	83 bc 24 60 02
	00 00 01	 cmp	 DWORD PTR tv235[rsp], 1
  0065f	75 11		 jne	 SHORT $LN62@vgetargs1
  00661	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00668	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR tv237[rsp], rax
  00670	eb 0f		 jmp	 SHORT $LN63@vgetargs1
$LN62@vgetargs1:
  00672	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  00679	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR tv237[rsp], rax
$LN63@vgetargs1:
  00681	48 63 44 24 68	 movsxd	 rax, DWORD PTR min$[rsp]
  00686	48 39 84 24 08
	01 00 00	 cmp	 QWORD PTR len$[rsp], rax
  0068e	7d 0d		 jge	 SHORT $LN64@vgetargs1
  00690	8b 44 24 68	 mov	 eax, DWORD PTR min$[rsp]
  00694	89 84 24 70 02
	00 00		 mov	 DWORD PTR tv241[rsp], eax
  0069b	eb 0e		 jmp	 SHORT $LN65@vgetargs1
$LN64@vgetargs1:
  0069d	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  006a4	89 84 24 70 02
	00 00		 mov	 DWORD PTR tv241[rsp], eax
$LN65@vgetargs1:
  006ab	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  006b2	39 44 24 68	 cmp	 DWORD PTR min$[rsp], eax
  006b6	75 11		 jne	 SHORT $LN68@vgetargs1
  006b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07JLAGAGFH@exactly?$AA@
  006bf	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR tv247[rsp], rax
  006c7	eb 3f		 jmp	 SHORT $LN69@vgetargs1
$LN68@vgetargs1:
  006c9	48 63 44 24 68	 movsxd	 rax, DWORD PTR min$[rsp]
  006ce	48 39 84 24 08
	01 00 00	 cmp	 QWORD PTR len$[rsp], rax
  006d6	7d 11		 jge	 SHORT $LN66@vgetargs1
  006d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08FNDBFMB@at?5least?$AA@
  006df	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR tv246[rsp], rax
  006e7	eb 0f		 jmp	 SHORT $LN67@vgetargs1
$LN66@vgetargs1:
  006e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07IGBEEPOP@at?5most?$AA@
  006f0	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR tv246[rsp], rax
$LN67@vgetargs1:
  006f8	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR tv246[rsp]
  00700	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR tv247[rsp], rax
$LN69@vgetargs1:
  00708	48 83 7c 24 48
	00		 cmp	 QWORD PTR fname$[rsp], 0
  0070e	75 11		 jne	 SHORT $LN70@vgetargs1
  00710	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00717	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR tv250[rsp], rax
  0071f	eb 0f		 jmp	 SHORT $LN71@vgetargs1
$LN70@vgetargs1:
  00721	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00728	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR tv250[rsp], rax
$LN71@vgetargs1:
  00730	48 83 7c 24 48
	00		 cmp	 QWORD PTR fname$[rsp], 0
  00736	75 11		 jne	 SHORT $LN72@vgetargs1
  00738	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08HFFPPCHF@function?$AA@
  0073f	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR tv253[rsp], rax
  00747	eb 0d		 jmp	 SHORT $LN73@vgetargs1
$LN72@vgetargs1:
  00749	48 8b 44 24 48	 mov	 rax, QWORD PTR fname$[rsp]
  0074e	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR tv253[rsp], rax
$LN73@vgetargs1:
  00756	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0075d	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00761	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR tv237[rsp]
  00769	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0076e	8b 84 24 70 02
	00 00		 mov	 eax, DWORD PTR tv241[rsp]
  00775	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00779	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR tv247[rsp]
  00781	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00786	4c 8b 8c 24 88
	02 00 00	 mov	 r9, QWORD PTR tv250[rsp]
  0078e	4c 8b 84 24 90
	02 00 00	 mov	 r8, QWORD PTR tv253[rsp]
  00796	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@DKJKMDMF@?$CF?4150s?$CFs?5takes?5?$CFs?5?$CFd?5argument?$CFs?5@
  0079d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  007a4	e8 00 00 00 00	 call	 PyErr_Format

; 322  :         else

  007a9	eb 14		 jmp	 SHORT $LN7@vgetargs1
$LN8@vgetargs1:

; 323  :             PyErr_SetString(PyExc_TypeError, message);

  007ab	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR message$[rsp]
  007b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  007ba	e8 00 00 00 00	 call	 PyErr_SetString
$LN7@vgetargs1:

; 324  :         return cleanreturn(0, &freelist);

  007bf	48 8d 54 24 70	 lea	 rdx, QWORD PTR freelist$[rsp]
  007c4	33 c9		 xor	 ecx, ecx
  007c6	e8 00 00 00 00	 call	 cleanreturn
  007cb	e9 b8 01 00 00	 jmp	 $LN44@vgetargs1
$LN10@vgetargs1:

; 325  :     }
; 326  : 
; 327  :     for (i = 0; i < len; i++) {

  007d0	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  007d9	eb 0d		 jmp	 SHORT $LN6@vgetargs1
$LN5@vgetargs1:
  007db	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  007e0	48 ff c0	 inc	 rax
  007e3	48 89 44 24 60	 mov	 QWORD PTR i$[rsp], rax
$LN6@vgetargs1:
  007e8	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR len$[rsp]
  007f0	48 39 44 24 60	 cmp	 QWORD PTR i$[rsp], rax
  007f5	0f 8d d9 00 00
	00		 jge	 $LN4@vgetargs1

; 328  :         if (*format == '|')

  007fb	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00803	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00806	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00809	75 13		 jne	 SHORT $LN3@vgetargs1

; 329  :             format++;

  0080b	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00813	48 ff c0	 inc	 rax
  00816	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR format$[rsp], rax
$LN3@vgetargs1:

; 330  :         msg = convertitem(PyTuple_GET_ITEM(args, i), &format, p_va,
; 331  :                           flags, levels, msgbuf,
; 332  :                           sizeof(msgbuf), &freelist);

  0081e	48 8d 44 24 70	 lea	 rax, QWORD PTR freelist$[rsp]
  00823	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00828	48 c7 44 24 30
	00 01 00 00	 mov	 QWORD PTR [rsp+48], 256	; 00000100H
  00831	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR msgbuf$[rsp]
  00839	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0083e	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR levels$[rsp]
  00846	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0084b	44 8b 8c 24 c8
	02 00 00	 mov	 r9d, DWORD PTR flags$[rsp]
  00853	4c 8b 84 24 c0
	02 00 00	 mov	 r8, QWORD PTR p_va$[rsp]
  0085b	48 8d 94 24 b8
	02 00 00	 lea	 rdx, QWORD PTR format$[rsp]
  00863	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR args$[rsp]
  0086b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR i$[rsp]
  00870	48 8b 4c c8 70	 mov	 rcx, QWORD PTR [rax+rcx*8+112]
  00875	e8 00 00 00 00	 call	 convertitem
  0087a	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR msg$[rsp], rax

; 333  :         if (msg) {

  00882	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR msg$[rsp], 0
  0088b	74 42		 je	 SHORT $LN2@vgetargs1

; 334  :             seterror(i+1, msg, levels, fname, msg);

  0088d	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  00892	48 ff c0	 inc	 rax
  00895	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR msg$[rsp]
  0089d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  008a2	4c 8b 4c 24 48	 mov	 r9, QWORD PTR fname$[rsp]
  008a7	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR levels$[rsp]
  008af	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR msg$[rsp]
  008b7	8b c8		 mov	 ecx, eax
  008b9	e8 00 00 00 00	 call	 seterror

; 335  :             return cleanreturn(0, &freelist);

  008be	48 8d 54 24 70	 lea	 rdx, QWORD PTR freelist$[rsp]
  008c3	33 c9		 xor	 ecx, ecx
  008c5	e8 00 00 00 00	 call	 cleanreturn
  008ca	e9 b9 00 00 00	 jmp	 $LN44@vgetargs1
$LN2@vgetargs1:

; 336  :         }
; 337  :     }

  008cf	e9 07 ff ff ff	 jmp	 $LN5@vgetargs1
$LN4@vgetargs1:

; 338  : 
; 339  :     if (*format != '\0' && !Py_ISALPHA(Py_CHARMASK(*format)) &&
; 340  :         *format != '(' &&
; 341  :         *format != '|' && *format != ':' && *format != ';') {

  008d4	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  008dc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  008df	85 c0		 test	 eax, eax
  008e1	0f 84 92 00 00
	00		 je	 $LN1@vgetargs1
  008e7	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  008ef	0f be 00	 movsx	 eax, BYTE PTR [rax]
  008f2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008f7	0f b6 c0	 movzx	 eax, al
  008fa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008ff	0f b6 c0	 movzx	 eax, al
  00902	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00909	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0090c	83 e0 03	 and	 eax, 3
  0090f	85 c0		 test	 eax, eax
  00911	75 66		 jne	 SHORT $LN1@vgetargs1
  00913	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  0091b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0091e	83 f8 28	 cmp	 eax, 40			; 00000028H
  00921	74 56		 je	 SHORT $LN1@vgetargs1
  00923	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  0092b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0092e	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00931	74 46		 je	 SHORT $LN1@vgetargs1
  00933	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  0093b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0093e	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00941	74 36		 je	 SHORT $LN1@vgetargs1
  00943	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR format$[rsp]
  0094b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0094e	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00951	74 26		 je	 SHORT $LN1@vgetargs1

; 342  :         PyErr_Format(PyExc_SystemError,
; 343  :                      "bad format string: %.200s", formatsave);

  00953	4c 8b 44 24 50	 mov	 r8, QWORD PTR formatsave$[rsp]
  00958	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@OELPODI@bad?5format?5string?3?5?$CF?4200s?$AA@
  0095f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00966	e8 00 00 00 00	 call	 PyErr_Format

; 344  :         return cleanreturn(0, &freelist);

  0096b	48 8d 54 24 70	 lea	 rdx, QWORD PTR freelist$[rsp]
  00970	33 c9		 xor	 ecx, ecx
  00972	e8 00 00 00 00	 call	 cleanreturn
  00977	eb 0f		 jmp	 SHORT $LN44@vgetargs1
$LN1@vgetargs1:

; 345  :     }
; 346  : 
; 347  :     return cleanreturn(1, &freelist);

  00979	48 8d 54 24 70	 lea	 rdx, QWORD PTR freelist$[rsp]
  0097e	b9 01 00 00 00	 mov	 ecx, 1
  00983	e8 00 00 00 00	 call	 cleanreturn
$LN44@vgetargs1:

; 348  : }

  00988	48 81 c4 a8 02
	00 00		 add	 rsp, 680		; 000002a8H
  0098f	c3		 ret	 0
vgetargs1 ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$cleanreturn DD imagerel cleanreturn
	DD	imagerel cleanreturn+176
	DD	imagerel $unwind$cleanreturn
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cleanreturn DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cleanreturn
_TEXT	SEGMENT
index$ = 32
tv69 = 40
tv84 = 48
retval$ = 80
freelist$ = 88
cleanreturn PROC					; COMDAT

; 178  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 179  :     int index;
; 180  : 
; 181  :     if (retval == 0) {

  0000d	83 7c 24 50 00	 cmp	 DWORD PTR retval$[rsp], 0
  00012	75 5c		 jne	 SHORT $LN4@cleanretur

; 182  :       /* A failure occurred, therefore execute all of the cleanup
; 183  :          functions.
; 184  :       */
; 185  :       for (index = 0; index < freelist->first_available; ++index) {

  00014	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR index$[rsp], 0
  0001c	eb 0a		 jmp	 SHORT $LN3@cleanretur
$LN2@cleanretur:
  0001e	8b 44 24 20	 mov	 eax, DWORD PTR index$[rsp]
  00022	ff c0		 inc	 eax
  00024	89 44 24 20	 mov	 DWORD PTR index$[rsp], eax
$LN3@cleanretur:
  00028	48 8b 44 24 58	 mov	 rax, QWORD PTR freelist$[rsp]
  0002d	8b 00		 mov	 eax, DWORD PTR [rax]
  0002f	39 44 24 20	 cmp	 DWORD PTR index$[rsp], eax
  00033	7d 3b		 jge	 SHORT $LN1@cleanretur

; 186  :           freelist->entries[index].destructor(NULL,
; 187  :                                               freelist->entries[index].item);

  00035	48 63 44 24 20	 movsxd	 rax, DWORD PTR index$[rsp]
  0003a	48 6b c0 10	 imul	 rax, 16
  0003e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR freelist$[rsp]
  00043	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00047	48 63 54 24 20	 movsxd	 rdx, DWORD PTR index$[rsp]
  0004c	48 6b d2 10	 imul	 rdx, 16
  00050	48 89 54 24 28	 mov	 QWORD PTR tv69[rsp], rdx
  00055	4c 8b 44 24 58	 mov	 r8, QWORD PTR freelist$[rsp]
  0005a	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  0005e	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00062	33 c9		 xor	 ecx, ecx
  00064	48 8b 44 24 28	 mov	 rax, QWORD PTR tv69[rsp]
  00069	41 ff 54 00 08	 call	 QWORD PTR [r8+rax+8]

; 188  :       }

  0006e	eb ae		 jmp	 SHORT $LN2@cleanretur
$LN1@cleanretur:
$LN4@cleanretur:

; 189  :     }
; 190  :     PyMem_FREE(freelist->entries);

  00070	e8 00 00 00 00	 call	 _Py_PXCTX
  00075	85 c0		 test	 eax, eax
  00077	74 18		 je	 SHORT $LN7@cleanretur
  00079	48 8b 44 24 58	 mov	 rax, QWORD PTR freelist$[rsp]
  0007e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00082	e8 00 00 00 00	 call	 _PxMem_Free
  00087	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
  0008f	eb 16		 jmp	 SHORT $LN8@cleanretur
$LN7@cleanretur:
  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR freelist$[rsp]
  00096	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0009a	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0009f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN8@cleanretur:

; 191  :     return retval;

  000a7	8b 44 24 50	 mov	 eax, DWORD PTR retval$[rsp]

; 192  : }

  000ab	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000af	c3		 ret	 0
cleanreturn ENDP
_TEXT	ENDS
PUBLIC	??_C@_07PLGIGANP@?5?$CF?4256s?$AA@		; `string'
PUBLIC	??_C@_08MNCFOIFH@argument?$AA@			; `string'
PUBLIC	??_C@_09LKNIBBFP@?0?5item?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0M@CLHFBAMN@argument?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_09ONCPLENA@?$CF?4200s?$CI?$CJ?5?$AA@	; `string'
EXTRN	strlen:PROC
EXTRN	PyOS_snprintf:PROC
EXTRN	PyErr_Occurred:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$seterror DD imagerel seterror
	DD	imagerel seterror+578
	DD	imagerel $unwind$seterror
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$seterror DD 021a01H
	DD	047011aH
xdata	ENDS
;	COMDAT ??_C@_07PLGIGANP@?5?$CF?4256s?$AA@
CONST	SEGMENT
??_C@_07PLGIGANP@?5?$CF?4256s?$AA@ DB ' %.256s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNCFOIFH@argument?$AA@
CONST	SEGMENT
??_C@_08MNCFOIFH@argument?$AA@ DB 'argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LKNIBBFP@?0?5item?5?$CFd?$AA@
CONST	SEGMENT
??_C@_09LKNIBBFP@?0?5item?5?$CFd?$AA@ DB ', item %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CLHFBAMN@argument?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@CLHFBAMN@argument?5?$CFd?$AA@ DB 'argument %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ONCPLENA@?$CF?4200s?$CI?$CJ?5?$AA@
CONST	SEGMENT
??_C@_09ONCPLENA@?$CF?4200s?$CI?$CJ?5?$AA@ DB '%.200s() ', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT seterror
_TEXT	SEGMENT
p$ = 32
i$ = 40
buf$ = 48
iarg$ = 576
msg$ = 584
levels$ = 592
fname$ = 600
message$ = 608
seterror PROC						; COMDAT

; 355  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 81 ec 38 02
	00 00		 sub	 rsp, 568		; 00000238H

; 356  :     char buf[512];
; 357  :     int i;
; 358  :     char *p = buf;

  0001a	48 8d 44 24 30	 lea	 rax, QWORD PTR buf$[rsp]
  0001f	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 359  : 
; 360  :     if (PyErr_Occurred())

  00024	e8 00 00 00 00	 call	 PyErr_Occurred
  00029	48 85 c0	 test	 rax, rax
  0002c	74 0a		 je	 SHORT $LN8@seterror

; 361  :         return;

  0002e	e9 07 02 00 00	 jmp	 $LN9@seterror
  00033	e9 ee 01 00 00	 jmp	 $LN7@seterror
$LN8@seterror:

; 362  :     else if (message == NULL) {

  00038	48 83 bc 24 60
	02 00 00 00	 cmp	 QWORD PTR message$[rsp], 0
  00041	0f 85 df 01 00
	00		 jne	 $LN6@seterror

; 363  :         if (fname != NULL) {

  00047	48 83 bc 24 58
	02 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  00050	74 38		 je	 SHORT $LN5@seterror

; 364  :             PyOS_snprintf(p, sizeof(buf), "%.200s() ", fname);

  00052	4c 8b 8c 24 58
	02 00 00	 mov	 r9, QWORD PTR fname$[rsp]
  0005a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09ONCPLENA@?$CF?4200s?$CI?$CJ?5?$AA@
  00061	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0006b	e8 00 00 00 00	 call	 PyOS_snprintf

; 365  :             p += strlen(p);

  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00075	e8 00 00 00 00	 call	 strlen
  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0007f	48 03 c8	 add	 rcx, rax
  00082	48 8b c1	 mov	 rax, rcx
  00085	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN5@seterror:

; 366  :         }
; 367  :         if (iarg != 0) {

  0008a	83 bc 24 40 02
	00 00 00	 cmp	 DWORD PTR iarg$[rsp], 0
  00092	0f 84 01 01 00
	00		 je	 $LN4@seterror

; 368  :             PyOS_snprintf(p, sizeof(buf) - (p - buf),
; 369  :                           "argument %d", iarg);

  00098	48 8d 44 24 30	 lea	 rax, QWORD PTR buf$[rsp]
  0009d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000a2	48 2b c8	 sub	 rcx, rax
  000a5	48 8b c1	 mov	 rax, rcx
  000a8	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  000ad	48 2b c8	 sub	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	44 8b 8c 24 40
	02 00 00	 mov	 r9d, DWORD PTR iarg$[rsp]
  000bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@CLHFBAMN@argument?5?$CFd?$AA@
  000c2	48 8b d0	 mov	 rdx, rax
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000ca	e8 00 00 00 00	 call	 PyOS_snprintf

; 370  :             i = 0;

  000cf	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 371  :             p += strlen(p);

  000d7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000dc	e8 00 00 00 00	 call	 strlen
  000e1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000e6	48 03 c8	 add	 rcx, rax
  000e9	48 8b c1	 mov	 rax, rcx
  000ec	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN3@seterror:

; 372  :             while (levels[i] > 0 && i < 32 && (int)(p-buf) < 220) {

  000f1	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  000f6	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR levels$[rsp]
  000fe	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  00102	0f 8e 8f 00 00
	00		 jle	 $LN2@seterror
  00108	83 7c 24 28 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  0010d	0f 8d 84 00 00
	00		 jge	 $LN2@seterror
  00113	48 8d 44 24 30	 lea	 rax, QWORD PTR buf$[rsp]
  00118	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0011d	48 2b c8	 sub	 rcx, rax
  00120	48 8b c1	 mov	 rax, rcx
  00123	3d dc 00 00 00	 cmp	 eax, 220		; 000000dcH
  00128	7d 6d		 jge	 SHORT $LN2@seterror

; 373  :                 PyOS_snprintf(p, sizeof(buf) - (p - buf),
; 374  :                               ", item %d", levels[i]-1);

  0012a	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0012f	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR levels$[rsp]
  00137	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0013a	ff c8		 dec	 eax
  0013c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00141	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  00146	48 2b d1	 sub	 rdx, rcx
  00149	48 8b ca	 mov	 rcx, rdx
  0014c	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00151	48 2b d1	 sub	 rdx, rcx
  00154	48 8b ca	 mov	 rcx, rdx
  00157	44 8b c8	 mov	 r9d, eax
  0015a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09LKNIBBFP@?0?5item?5?$CFd?$AA@
  00161	48 8b d1	 mov	 rdx, rcx
  00164	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00169	e8 00 00 00 00	 call	 PyOS_snprintf

; 375  :                 p += strlen(p);

  0016e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00173	e8 00 00 00 00	 call	 strlen
  00178	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0017d	48 03 c8	 add	 rcx, rax
  00180	48 8b c1	 mov	 rax, rcx
  00183	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 376  :                 i++;

  00188	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0018c	ff c0		 inc	 eax
  0018e	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 377  :             }

  00192	e9 5a ff ff ff	 jmp	 $LN3@seterror
$LN2@seterror:

; 378  :         }
; 379  :         else {

  00197	eb 49		 jmp	 SHORT $LN1@seterror
$LN4@seterror:

; 380  :             PyOS_snprintf(p, sizeof(buf) - (p - buf), "argument");

  00199	48 8d 44 24 30	 lea	 rax, QWORD PTR buf$[rsp]
  0019e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001a3	48 2b c8	 sub	 rcx, rax
  001a6	48 8b c1	 mov	 rax, rcx
  001a9	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001ae	48 2b c8	 sub	 rcx, rax
  001b1	48 8b c1	 mov	 rax, rcx
  001b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08MNCFOIFH@argument?$AA@
  001bb	48 8b d0	 mov	 rdx, rax
  001be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001c3	e8 00 00 00 00	 call	 PyOS_snprintf

; 381  :             p += strlen(p);

  001c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001cd	e8 00 00 00 00	 call	 strlen
  001d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001d7	48 03 c8	 add	 rcx, rax
  001da	48 8b c1	 mov	 rax, rcx
  001dd	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN1@seterror:

; 382  :         }
; 383  :         PyOS_snprintf(p, sizeof(buf) - (p - buf), " %.256s", msg);

  001e2	48 8d 44 24 30	 lea	 rax, QWORD PTR buf$[rsp]
  001e7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001ec	48 2b c8	 sub	 rcx, rax
  001ef	48 8b c1	 mov	 rax, rcx
  001f2	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001f7	48 2b c8	 sub	 rcx, rax
  001fa	48 8b c1	 mov	 rax, rcx
  001fd	4c 8b 8c 24 48
	02 00 00	 mov	 r9, QWORD PTR msg$[rsp]
  00205	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07PLGIGANP@?5?$CF?4256s?$AA@
  0020c	48 8b d0	 mov	 rdx, rax
  0020f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00214	e8 00 00 00 00	 call	 PyOS_snprintf

; 384  :         message = buf;

  00219	48 8d 44 24 30	 lea	 rax, QWORD PTR buf$[rsp]
  0021e	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR message$[rsp], rax
$LN6@seterror:
$LN7@seterror:

; 385  :     }
; 386  :     PyErr_SetString(PyExc_TypeError, message);

  00226	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR message$[rsp]
  0022e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00235	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@seterror:

; 387  : }

  0023a	48 81 c4 38 02
	00 00		 add	 rsp, 568		; 00000238H
  00241	c3		 ret	 0
seterror ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$convertitem DD imagerel convertitem
	DD	imagerel convertitem+314
	DD	imagerel $unwind$convertitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convertitem DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT convertitem
_TEXT	SEGMENT
msg$ = 80
format$ = 88
arg$ = 112
p_format$ = 120
p_va$ = 128
flags$ = 136
levels$ = 144
msgbuf$ = 152
bufsize$ = 160
freelist$ = 168
convertitem PROC					; COMDAT

; 487  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 488  :     char *msg;
; 489  :     const char *format = *p_format;

  00018	48 8b 44 24 78	 mov	 rax, QWORD PTR p_format$[rsp]
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 89 44 24 58	 mov	 QWORD PTR format$[rsp], rax

; 490  : 
; 491  :     if (*format == '(' /* ')' */) {

  00025	48 8b 44 24 58	 mov	 rax, QWORD PTR format$[rsp]
  0002a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002d	83 f8 28	 cmp	 eax, 40			; 00000028H
  00030	0f 85 84 00 00
	00		 jne	 $LN5@convertite

; 492  :         format++;

  00036	48 8b 44 24 58	 mov	 rax, QWORD PTR format$[rsp]
  0003b	48 ff c0	 inc	 rax
  0003e	48 89 44 24 58	 mov	 QWORD PTR format$[rsp], rax

; 493  :         msg = converttuple(arg, &format, p_va, flags, levels, msgbuf,
; 494  :                            bufsize, 0, freelist);

  00043	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR freelist$[rsp]
  0004b	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00050	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR [rsp+56], 0
  00058	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bufsize$[rsp]
  00060	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00065	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  0006d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00072	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR levels$[rsp]
  0007a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007f	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR flags$[rsp]
  00087	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR p_va$[rsp]
  0008f	48 8d 54 24 58	 lea	 rdx, QWORD PTR format$[rsp]
  00094	48 8b 4c 24 70	 mov	 rcx, QWORD PTR arg$[rsp]
  00099	e8 00 00 00 00	 call	 converttuple
  0009e	48 89 44 24 50	 mov	 QWORD PTR msg$[rsp], rax

; 495  :         if (msg == NULL)

  000a3	48 83 7c 24 50
	00		 cmp	 QWORD PTR msg$[rsp], 0
  000a9	75 0d		 jne	 SHORT $LN4@convertite

; 496  :             format++;

  000ab	48 8b 44 24 58	 mov	 rax, QWORD PTR format$[rsp]
  000b0	48 ff c0	 inc	 rax
  000b3	48 89 44 24 58	 mov	 QWORD PTR format$[rsp], rax
$LN4@convertite:

; 497  :     }
; 498  :     else {

  000b8	eb 61		 jmp	 SHORT $LN3@convertite
$LN5@convertite:

; 499  :         msg = convertsimple(arg, &format, p_va, flags,
; 500  :                             msgbuf, bufsize, freelist);

  000ba	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR freelist$[rsp]
  000c2	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000c7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bufsize$[rsp]
  000cf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  000dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e1	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR flags$[rsp]
  000e9	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR p_va$[rsp]
  000f1	48 8d 54 24 58	 lea	 rdx, QWORD PTR format$[rsp]
  000f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR arg$[rsp]
  000fb	e8 00 00 00 00	 call	 convertsimple
  00100	48 89 44 24 50	 mov	 QWORD PTR msg$[rsp], rax

; 501  :         if (msg != NULL)

  00105	48 83 7c 24 50
	00		 cmp	 QWORD PTR msg$[rsp], 0
  0010b	74 0e		 je	 SHORT $LN2@convertite

; 502  :             levels[0] = 0;

  0010d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR levels$[rsp]
  00115	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN2@convertite:
$LN3@convertite:

; 503  :     }
; 504  :     if (msg == NULL)

  0011b	48 83 7c 24 50
	00		 cmp	 QWORD PTR msg$[rsp], 0
  00121	75 0d		 jne	 SHORT $LN1@convertite

; 505  :         *p_format = format;

  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR p_format$[rsp]
  00128	48 8b 4c 24 58	 mov	 rcx, QWORD PTR format$[rsp]
  0012d	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@convertite:

; 506  :     return msg;

  00130	48 8b 44 24 50	 mov	 rax, QWORD PTR msg$[rsp]

; 507  : }

  00135	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00139	c3		 ret	 0
convertitem ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0BD@LNNDNBCF@is?5not?5retrievable?$AA@	; `string'
PUBLIC	??_C@_0CG@PJDNHDOE@must?5be?5sequence?5of?5length?5?$CFd?0?5n@ ; `string'
PUBLIC	??_C@_0BO@DOGODLPL@expected?5?$CFd?5arguments?0?5not?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CE@COBEPABP@must?5be?5?$CFd?9item?5sequence?0?5not?5?$CF?4@ ; `string'
PUBLIC	??_C@_0CB@NKOGLILG@expected?5?$CFd?5arguments?0?5not?5?$CF?450s@ ; `string'
PUBLIC	??_C@_04OHJIHAFH@None?$AA@			; `string'
EXTRN	__imp_strncpy:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PySequence_GetItem:PROC
EXTRN	PySequence_Size:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PySequence_Check:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$converttuple DD imagerel converttuple
	DD	imagerel converttuple+914
	DD	imagerel $unwind$converttuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$converttuple DD 021b01H
	DD	013011bH
xdata	ENDS
;	COMDAT ??_C@_0BD@LNNDNBCF@is?5not?5retrievable?$AA@
CONST	SEGMENT
??_C@_0BD@LNNDNBCF@is?5not?5retrievable?$AA@ DB 'is not retrievable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PJDNHDOE@must?5be?5sequence?5of?5length?5?$CFd?0?5n@
CONST	SEGMENT
??_C@_0CG@PJDNHDOE@must?5be?5sequence?5of?5length?5?$CFd?0?5n@ DB 'must b'
	DB	'e sequence of length %d, not %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DOGODLPL@expected?5?$CFd?5arguments?0?5not?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@DOGODLPL@expected?5?$CFd?5arguments?0?5not?5?$CFd?$AA@ DB 'expe'
	DB	'cted %d arguments, not %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@COBEPABP@must?5be?5?$CFd?9item?5sequence?0?5not?5?$CF?4@
CONST	SEGMENT
??_C@_0CE@COBEPABP@must?5be?5?$CFd?9item?5sequence?0?5not?5?$CF?4@ DB 'mu'
	DB	'st be %d-item sequence, not %.50s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NKOGLILG@expected?5?$CFd?5arguments?0?5not?5?$CF?450s@
CONST	SEGMENT
??_C@_0CB@NKOGLILG@expected?5?$CFd?5arguments?0?5not?5?$CF?450s@ DB 'expe'
	DB	'cted %d arguments, not %.50s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None?$AA@
CONST	SEGMENT
??_C@_04OHJIHAFH@None?$AA@ DB 'None', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT converttuple
_TEXT	SEGMENT
level$ = 64
i$ = 68
n$ = 72
format$ = 80
c$20669 = 88
msg$20694 = 96
item$20695 = 104
tv131 = 112
tv135 = 120
tv146 = 128
arg$ = 160
p_format$ = 168
p_va$ = 176
flags$ = 184
levels$ = 192
msgbuf$ = 200
bufsize$ = 208
toplevel$ = 216
freelist$ = 224
converttuple PROC					; COMDAT

; 412  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 413  :     int level = 0;

  0001b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR level$[rsp], 0

; 414  :     int n = 0;

  00023	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 415  :     const char *format = *p_format;

  0002b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p_format$[rsp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 89 44 24 50	 mov	 QWORD PTR format$[rsp], rax
$LN24@converttup:

; 416  :     int i;
; 417  : 
; 418  :     for (;;) {
; 419  :         int c = *format++;

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR format$[rsp]
  00040	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00043	89 44 24 58	 mov	 DWORD PTR c$20669[rsp], eax
  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR format$[rsp]
  0004c	48 ff c0	 inc	 rax
  0004f	48 89 44 24 50	 mov	 QWORD PTR format$[rsp], rax

; 420  :         if (c == '(') {

  00054	83 7c 24 58 28	 cmp	 DWORD PTR c$20669[rsp], 40 ; 00000028H
  00059	75 1d		 jne	 SHORT $LN22@converttup

; 421  :             if (level == 0)

  0005b	83 7c 24 40 00	 cmp	 DWORD PTR level$[rsp], 0
  00060	75 0a		 jne	 SHORT $LN21@converttup

; 422  :                 n++;

  00062	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00066	ff c0		 inc	 eax
  00068	89 44 24 48	 mov	 DWORD PTR n$[rsp], eax
$LN21@converttup:

; 423  :             level++;

  0006c	8b 44 24 40	 mov	 eax, DWORD PTR level$[rsp]
  00070	ff c0		 inc	 eax
  00072	89 44 24 40	 mov	 DWORD PTR level$[rsp], eax
  00076	eb 6b		 jmp	 SHORT $LN20@converttup
$LN22@converttup:

; 424  :         }
; 425  :         else if (c == ')') {

  00078	83 7c 24 58 29	 cmp	 DWORD PTR c$20669[rsp], 41 ; 00000029H
  0007d	75 15		 jne	 SHORT $LN19@converttup

; 426  :             if (level == 0)

  0007f	83 7c 24 40 00	 cmp	 DWORD PTR level$[rsp], 0
  00084	75 02		 jne	 SHORT $LN18@converttup

; 427  :                 break;

  00086	eb 60		 jmp	 SHORT $LN23@converttup
$LN18@converttup:

; 428  :             level--;

  00088	8b 44 24 40	 mov	 eax, DWORD PTR level$[rsp]
  0008c	ff c8		 dec	 eax
  0008e	89 44 24 40	 mov	 DWORD PTR level$[rsp], eax
  00092	eb 4f		 jmp	 SHORT $LN17@converttup
$LN19@converttup:

; 429  :         }
; 430  :         else if (c == ':' || c == ';' || c == '\0')

  00094	83 7c 24 58 3a	 cmp	 DWORD PTR c$20669[rsp], 58 ; 0000003aH
  00099	74 0e		 je	 SHORT $LN15@converttup
  0009b	83 7c 24 58 3b	 cmp	 DWORD PTR c$20669[rsp], 59 ; 0000003bH
  000a0	74 07		 je	 SHORT $LN15@converttup
  000a2	83 7c 24 58 00	 cmp	 DWORD PTR c$20669[rsp], 0
  000a7	75 04		 jne	 SHORT $LN16@converttup
$LN15@converttup:

; 431  :             break;

  000a9	eb 3d		 jmp	 SHORT $LN23@converttup
  000ab	eb 36		 jmp	 SHORT $LN14@converttup
$LN16@converttup:

; 432  :         else if (level == 0 && Py_ISALPHA(Py_CHARMASK(c)))

  000ad	83 7c 24 40 00	 cmp	 DWORD PTR level$[rsp], 0
  000b2	75 2f		 jne	 SHORT $LN13@converttup
  000b4	8b 44 24 58	 mov	 eax, DWORD PTR c$20669[rsp]
  000b8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000bd	0f b6 c0	 movzx	 eax, al
  000c0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c5	0f b6 c0	 movzx	 eax, al
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000cf	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000d2	83 e0 03	 and	 eax, 3
  000d5	85 c0		 test	 eax, eax
  000d7	74 0a		 je	 SHORT $LN13@converttup

; 433  :             n++;

  000d9	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  000dd	ff c0		 inc	 eax
  000df	89 44 24 48	 mov	 DWORD PTR n$[rsp], eax
$LN13@converttup:
$LN14@converttup:
$LN17@converttup:
$LN20@converttup:

; 434  :     }

  000e3	e9 53 ff ff ff	 jmp	 $LN24@converttup
$LN23@converttup:

; 435  : 
; 436  :     if (!PySequence_Check(arg) || PyBytes_Check(arg)) {

  000e8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  000f0	e8 00 00 00 00	 call	 PySequence_Check
  000f5	85 c0		 test	 eax, eax
  000f7	74 1f		 je	 SHORT $LN11@converttup
  000f9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00101	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00105	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0010b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00110	85 c0		 test	 eax, eax
  00112	0f 84 9c 00 00
	00		 je	 $LN12@converttup
$LN11@converttup:

; 437  :         levels[0] = 0;

  00118	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR levels$[rsp]
  00120	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 438  :         PyOS_snprintf(msgbuf, bufsize,
; 439  :                       toplevel ? "expected %d arguments, not %.50s" :
; 440  :                       "must be %d-item sequence, not %.50s",
; 441  :                   n,
; 442  :                   arg == Py_None ? "None" : arg->ob_type->tp_name);

  00126	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0012d	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR arg$[rsp], rax
  00135	75 0e		 jne	 SHORT $LN27@converttup
  00137	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04OHJIHAFH@None?$AA@
  0013e	48 89 44 24 70	 mov	 QWORD PTR tv131[rsp], rax
  00143	eb 15		 jmp	 SHORT $LN28@converttup
$LN27@converttup:
  00145	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  0014d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00151	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00155	48 89 44 24 70	 mov	 QWORD PTR tv131[rsp], rax
$LN28@converttup:
  0015a	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR toplevel$[rsp], 0
  00162	74 0e		 je	 SHORT $LN29@converttup
  00164	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CB@NKOGLILG@expected?5?$CFd?5arguments?0?5not?5?$CF?450s@
  0016b	48 89 44 24 78	 mov	 QWORD PTR tv135[rsp], rax
  00170	eb 0c		 jmp	 SHORT $LN30@converttup
$LN29@converttup:
  00172	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@COBEPABP@must?5be?5?$CFd?9item?5sequence?0?5not?5?$CF?4@
  00179	48 89 44 24 78	 mov	 QWORD PTR tv135[rsp], rax
$LN30@converttup:
  0017e	48 8b 44 24 70	 mov	 rax, QWORD PTR tv131[rsp]
  00183	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00188	44 8b 4c 24 48	 mov	 r9d, DWORD PTR n$[rsp]
  0018d	4c 8b 44 24 78	 mov	 r8, QWORD PTR tv135[rsp]
  00192	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR bufsize$[rsp]
  0019a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR msgbuf$[rsp]
  001a2	e8 00 00 00 00	 call	 PyOS_snprintf

; 443  :         return msgbuf;

  001a7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  001af	e9 d6 01 00 00	 jmp	 $LN25@converttup
$LN12@converttup:

; 444  :     }
; 445  : 
; 446  :     if ((i = PySequence_Size(arg)) != n) {

  001b4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  001bc	e8 00 00 00 00	 call	 PySequence_Size
  001c1	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
  001c5	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  001c9	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  001cd	74 6f		 je	 SHORT $LN10@converttup

; 447  :         levels[0] = 0;

  001cf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR levels$[rsp]
  001d7	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 448  :         PyOS_snprintf(msgbuf, bufsize,
; 449  :                       toplevel ? "expected %d arguments, not %d" :
; 450  :                      "must be sequence of length %d, not %d",
; 451  :                   n, i);

  001dd	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR toplevel$[rsp], 0
  001e5	74 11		 je	 SHORT $LN31@converttup
  001e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@DOGODLPL@expected?5?$CFd?5arguments?0?5not?5?$CFd?$AA@
  001ee	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv146[rsp], rax
  001f6	eb 0f		 jmp	 SHORT $LN32@converttup
$LN31@converttup:
  001f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CG@PJDNHDOE@must?5be?5sequence?5of?5length?5?$CFd?0?5n@
  001ff	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv146[rsp], rax
$LN32@converttup:
  00207	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  0020b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0020f	44 8b 4c 24 48	 mov	 r9d, DWORD PTR n$[rsp]
  00214	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR tv146[rsp]
  0021c	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR bufsize$[rsp]
  00224	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR msgbuf$[rsp]
  0022c	e8 00 00 00 00	 call	 PyOS_snprintf

; 452  :         return msgbuf;

  00231	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00239	e9 4c 01 00 00	 jmp	 $LN25@converttup
$LN10@converttup:

; 453  :     }
; 454  : 
; 455  :     format = *p_format;

  0023e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p_format$[rsp]
  00246	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00249	48 89 44 24 50	 mov	 QWORD PTR format$[rsp], rax

; 456  :     for (i = 0; i < n; i++) {

  0024e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00256	eb 0a		 jmp	 SHORT $LN9@converttup
$LN8@converttup:
  00258	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  0025c	ff c0		 inc	 eax
  0025e	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN9@converttup:
  00262	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00266	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  0026a	0f 8d 08 01 00
	00		 jge	 $LN7@converttup

; 457  :         char *msg;
; 458  :         PyObject *item;
; 459  :         item = PySequence_GetItem(arg, i);

  00270	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00275	48 8b d0	 mov	 rdx, rax
  00278	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00280	e8 00 00 00 00	 call	 PySequence_GetItem
  00285	48 89 44 24 68	 mov	 QWORD PTR item$20695[rsp], rax

; 460  :         if (item == NULL) {

  0028a	48 83 7c 24 68
	00		 cmp	 QWORD PTR item$20695[rsp], 0
  00290	75 4e		 jne	 SHORT $LN6@converttup

; 461  :             PyErr_Clear();

  00292	e8 00 00 00 00	 call	 PyErr_Clear

; 462  :             levels[0] = i+1;

  00297	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  0029b	ff c0		 inc	 eax
  0029d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR levels$[rsp]
  002a5	89 01		 mov	 DWORD PTR [rcx], eax

; 463  :             levels[1] = 0;

  002a7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR levels$[rsp]
  002af	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 464  :             strncpy(msgbuf, "is not retrievable", bufsize);

  002b6	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR bufsize$[rsp]
  002be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@LNNDNBCF@is?5not?5retrievable?$AA@
  002c5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR msgbuf$[rsp]
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 465  :             return msgbuf;

  002d3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  002db	e9 aa 00 00 00	 jmp	 $LN25@converttup
$LN6@converttup:

; 466  :         }
; 467  :         msg = convertitem(item, &format, p_va, flags, levels+1,
; 468  :                           msgbuf, bufsize, freelist);

  002e0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR levels$[rsp]
  002e8	48 83 c0 04	 add	 rax, 4
  002ec	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR freelist$[rsp]
  002f4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002f9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR bufsize$[rsp]
  00301	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00306	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR msgbuf$[rsp]
  0030e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00313	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00318	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR flags$[rsp]
  00320	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR p_va$[rsp]
  00328	48 8d 54 24 50	 lea	 rdx, QWORD PTR format$[rsp]
  0032d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR item$20695[rsp]
  00332	e8 00 00 00 00	 call	 convertitem
  00337	48 89 44 24 60	 mov	 QWORD PTR msg$20694[rsp], rax
$LN5@converttup:

; 469  :         /* PySequence_GetItem calls tp->sq_item, which INCREFs */
; 470  :         Py_XDECREF(item);

  0033c	48 83 7c 24 68
	00		 cmp	 QWORD PTR item$20695[rsp], 0
  00342	74 0a		 je	 SHORT $LN2@converttup
  00344	48 8b 4c 24 68	 mov	 rcx, QWORD PTR item$20695[rsp]
  00349	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@converttup:
  0034e	33 c0		 xor	 eax, eax
  00350	85 c0		 test	 eax, eax
  00352	75 e8		 jne	 SHORT $LN5@converttup

; 471  :         if (msg != NULL) {

  00354	48 83 7c 24 60
	00		 cmp	 QWORD PTR msg$20694[rsp], 0
  0035a	74 17		 je	 SHORT $LN1@converttup

; 472  :             levels[0] = i+1;

  0035c	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00360	ff c0		 inc	 eax
  00362	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR levels$[rsp]
  0036a	89 01		 mov	 DWORD PTR [rcx], eax

; 473  :             return msg;

  0036c	48 8b 44 24 60	 mov	 rax, QWORD PTR msg$20694[rsp]
  00371	eb 17		 jmp	 SHORT $LN25@converttup
$LN1@converttup:

; 474  :         }
; 475  :     }

  00373	e9 e0 fe ff ff	 jmp	 $LN8@converttup
$LN7@converttup:

; 476  : 
; 477  :     *p_format = format;

  00378	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p_format$[rsp]
  00380	48 8b 4c 24 50	 mov	 rcx, QWORD PTR format$[rsp]
  00385	48 89 08	 mov	 QWORD PTR [rax], rcx

; 478  :     return NULL;

  00388	33 c0		 xor	 eax, eax
$LN25@converttup:

; 479  : }

  0038a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00391	c3		 ret	 0
converttuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@IMALOFOA@impossible?$DMbad?5format?5char?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BC@KHDHJHGE@contiguous?5buffer?$AA@	; `string'
PUBLIC	??_C@_0BC@NOEFPHII@read?9write?5buffer?$AA@	; `string'
PUBLIC	??_C@_0CE@FHIKGACL@invalid?5use?5of?5?8w?8?5format?5charac@ ; `string'
PUBLIC	??_C@_0O@DMBJEJOF@?$CIunspecified?$CJ?$AA@	; `string'
PUBLIC	??_C@_09FCJHKOIN@bytearray?$AA@			; `string'
PUBLIC	??_C@_05FBJAGGIG@bytes?$AA@			; `string'
PUBLIC	??_C@_0CC@PNMABHGD@encoded?5string?5without?5NULL?5byte@ ; `string'
PUBLIC	??_C@_0BC@CNIENJCI@?$CIbuffer?5overflow?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BF@FDDEBFPN@?$CIbuffer_len?5is?5NULL?$CJ?$AA@ ; `string'
PUBLIC	??_C@_1CC@PPMJPEFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CB@OMNKEOOG@?$CIencoder?5failed?5to?5return?5bytes?$CJ@ ; `string'
PUBLIC	??_C@_0BC@ECLEOFDF@?$CIencoding?5failed?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CB@CBNPKI@string?5or?5unicode?5or?5text?5buffer@ ; `string'
PUBLIC	??_C@_0BG@KEABMDON@?$CIAsCharBuffer?5failed?$CJ?$AA@ ; `string'
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0BB@MCHFDCHO@?$CIbuffer?5is?5NULL?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CE@BAFKKLBH@?$CIunknown?5parser?5marker?5combinati@ ; `string'
PUBLIC	??_C@_0BM@CLLMJED@str?5without?5null?5characters?$AA@ ; `string'
PUBLIC	??_C@_0CE@NNHOCDLF@str?5without?5null?5characters?5or?5N@ ; `string'
PUBLIC	??_C@_03OJMAPEGJ@str?$AA@			; `string'
PUBLIC	??_C@_0M@ECJNJCHF@str?5or?5None?$AA@		; `string'
PUBLIC	??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BJ@KKHLFOBF@bytes?5without?5null?5bytes?$AA@ ; `string'
PUBLIC	??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@ ; `string'
PUBLIC	??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@ ; `string'
PUBLIC	??_C@_1EI@IHJBJEGE@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@ ; `string'
PUBLIC	??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BE@GCGDJOP@a?5unicode?5character?$AA@	; `string'
PUBLIC	??_C@_0BK@GGDPHBGA@a?5byte?5string?5of?5length?51?$AA@ ; `string'
PUBLIC	??_C@_1CO@CJPJAHMC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@MCJLNGFD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	$T22551
PUBLIC	??_C@_0L@FHEGIPAD@integer?$DMK?$DO?$AA@		; `string'
PUBLIC	??_C@_0L@GPALMJOD@integer?$DMk?$DO?$AA@		; `string'
PUBLIC	??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@ ; `string'
PUBLIC	??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@ ; `string'
PUBLIC	??_C@_0CN@GGCBHAGN@signed?5short?5integer?5is?5greater?5@ ; `string'
PUBLIC	??_C@_0CK@KINDOECN@signed?5short?5integer?5is?5less?5tha@ ; `string'
PUBLIC	??_C@_0CO@JGCPDOOF@unsigned?5byte?5integer?5is?5greater@ ; `string'
PUBLIC	??_C@_0CL@KDPALKGI@unsigned?5byte?5integer?5is?5less?5th@ ; `string'
EXTRN	PyBuffer_Release:PROC
EXTRN	PyBuffer_IsContiguous:PROC
EXTRN	PyObject_GetBuffer:PROC
EXTRN	memcpy:PROC
EXTRN	PyUnicode_AsEncodedString:PROC
EXTRN	PyUnicode_FromObject:PROC
EXTRN	PyObject_AsCharBuffer:PROC
EXTRN	PyUnicode_GetDefaultEncoding:PROC
EXTRN	Py_UNICODE_strlen:PROC
EXTRN	PyUnicode_AsUnicodeAndSize:PROC
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	PyBuffer_FillInfo:PROC
EXTRN	PyObject_IsTrue:PROC
EXTRN	_PyUnicode_Ready:PROC
EXTRN	_PyByteArray_empty_string:BYTE
EXTRN	PyByteArray_Size:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyByteArray_Type:BYTE
EXTRN	PyBytes_Size:PROC
EXTRN	PyComplex_AsCComplex:PROC
EXTRN	PyFloat_AsDouble:PROC
EXTRN	PyLong_AsUnsignedLongLongMask:PROC
EXTRN	PyLong_AsLongLong:PROC
EXTRN	PyLong_AsSsize_t:PROC
EXTRN	PyNumber_Index:PROC
EXTRN	PyLong_AsUnsignedLongMask:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyLong_AsLong:PROC
EXTRN	__ImageBase:BYTE
EXTRN	_fltused:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\python\getargs.c
pdata	SEGMENT
$pdata$convertsimple DD imagerel convertsimple
	DD	imagerel convertsimple+11477
	DD	imagerel $unwind$convertsimple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convertsimple DD 041d01H
	DD	069011dH
	DD	060157016H
xdata	ENDS
;	COMDAT ??_C@_0BM@IMALOFOA@impossible?$DMbad?5format?5char?$DO?$AA@
CONST	SEGMENT
??_C@_0BM@IMALOFOA@impossible?$DMbad?5format?5char?$DO?$AA@ DB 'impossibl'
	DB	'e<bad format char>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KHDHJHGE@contiguous?5buffer?$AA@
CONST	SEGMENT
??_C@_0BC@KHDHJHGE@contiguous?5buffer?$AA@ DB 'contiguous buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NOEFPHII@read?9write?5buffer?$AA@
CONST	SEGMENT
??_C@_0BC@NOEFPHII@read?9write?5buffer?$AA@ DB 'read-write buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FHIKGACL@invalid?5use?5of?5?8w?8?5format?5charac@
CONST	SEGMENT
??_C@_0CE@FHIKGACL@invalid?5use?5of?5?8w?8?5format?5charac@ DB 'invalid u'
	DB	'se of ''w'' format character', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMBJEJOF@?$CIunspecified?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@DMBJEJOF@?$CIunspecified?$CJ?$AA@ DB '(unspecified)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCJHKOIN@bytearray?$AA@
CONST	SEGMENT
??_C@_09FCJHKOIN@bytearray?$AA@ DB 'bytearray', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FBJAGGIG@bytes?$AA@
CONST	SEGMENT
??_C@_05FBJAGGIG@bytes?$AA@ DB 'bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PNMABHGD@encoded?5string?5without?5NULL?5byte@
CONST	SEGMENT
??_C@_0CC@PNMABHGD@encoded?5string?5without?5NULL?5byte@ DB 'encoded stri'
	DB	'ng without NULL bytes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CNIENJCI@?$CIbuffer?5overflow?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@CNIENJCI@?$CIbuffer?5overflow?$CJ?$AA@ DB '(buffer overflow)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FDDEBFPN@?$CIbuffer_len?5is?5NULL?$CJ?$AA@
CONST	SEGMENT
??_C@_0BF@FDDEBFPN@?$CIbuffer_len?5is?5NULL?$CJ?$AA@ DB '(buffer_len is N'
	DB	'ULL)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@PPMJPEFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@PPMJPEFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OMNKEOOG@?$CIencoder?5failed?5to?5return?5bytes?$CJ@
CONST	SEGMENT
??_C@_0CB@OMNKEOOG@?$CIencoder?5failed?5to?5return?5bytes?$CJ@ DB '(encod'
	DB	'er failed to return bytes)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ECLEOFDF@?$CIencoding?5failed?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@ECLEOFDF@?$CIencoding?5failed?$CJ?$AA@ DB '(encoding failed)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CBNPKI@string?5or?5unicode?5or?5text?5buffer@
CONST	SEGMENT
??_C@_0CB@CBNPKI@string?5or?5unicode?5or?5text?5buffer@ DB 'string or uni'
	DB	'code or text buffer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KEABMDON@?$CIAsCharBuffer?5failed?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@KEABMDON@?$CIAsCharBuffer?5failed?$CJ?$AA@ DB '(AsCharBuffer fa'
	DB	'iled)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MCHFDCHO@?$CIbuffer?5is?5NULL?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@MCHFDCHO@?$CIbuffer?5is?5NULL?$CJ?$AA@ DB '(buffer is NULL)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BAFKKLBH@?$CIunknown?5parser?5marker?5combinati@
CONST	SEGMENT
??_C@_0CE@BAFKKLBH@?$CIunknown?5parser?5marker?5combinati@ DB '(unknown p'
	DB	'arser marker combination)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CLLMJED@str?5without?5null?5characters?$AA@
CONST	SEGMENT
??_C@_0BM@CLLMJED@str?5without?5null?5characters?$AA@ DB 'str without nul'
	DB	'l characters', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NNHOCDLF@str?5without?5null?5characters?5or?5N@
CONST	SEGMENT
??_C@_0CE@NNHOCDLF@str?5without?5null?5characters?5or?5N@ DB 'str without'
	DB	' null characters or None', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OJMAPEGJ@str?$AA@
CONST	SEGMENT
??_C@_03OJMAPEGJ@str?$AA@ DB 'str', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ECJNJCHF@str?5or?5None?$AA@
CONST	SEGMENT
??_C@_0M@ECJNJCHF@str?5or?5None?$AA@ DB 'str or None', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@ DB '(unicode c'
	DB	'onversion error)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KKHLFOBF@bytes?5without?5null?5bytes?$AA@
CONST	SEGMENT
??_C@_0BJ@KKHLFOBF@bytes?5without?5null?5bytes?$AA@ DB 'bytes without nul'
	DB	'l bytes', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@
CONST	SEGMENT
??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@ DB 'size does n'
	DB	'ot fit in an int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@ DB '(cleanup problem)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@IHJBJEGE@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
CONST	SEGMENT
??_C@_1EI@IHJBJEGE@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'a', 00H, 'r', 00H, 'g', 00H, ')', 00H, ')', 00H, '-', 00H, '>'
	DB	00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, '.', 00H, 'a', 00H
	DB	'n', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'a', 00H
	DB	'r', 00H, 'g', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'a', 00H, 'r', 00H, 'g', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GCGDJOP@a?5unicode?5character?$AA@
CONST	SEGMENT
??_C@_0BE@GCGDJOP@a?5unicode?5character?$AA@ DB 'a unicode character', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GGDPHBGA@a?5byte?5string?5of?5length?51?$AA@
CONST	SEGMENT
??_C@_0BK@GGDPHBGA@a?5byte?5string?5of?5length?51?$AA@ DB 'a byte string '
	DB	'of length 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@CJPJAHMC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@CJPJAHMC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'a', 00H, 'r', 00H
	DB	'g', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MCJLNGFD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@MCJLNGFD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'a', 00H, 'r', 00H, 'g', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FHEGIPAD@integer?$DMK?$DO?$AA@
CONST	SEGMENT
??_C@_0L@FHEGIPAD@integer?$DMK?$DO?$AA@ DB 'integer<K>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GPALMJOD@integer?$DMk?$DO?$AA@
CONST	SEGMENT
??_C@_0L@GPALMJOD@integer?$DMk?$DO?$AA@ DB 'integer<k>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@
CONST	SEGMENT
??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@ DB 'signed inte'
	DB	'ger is less than minimum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@
CONST	SEGMENT
??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@ DB 'signed integ'
	DB	'er is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GGCBHAGN@signed?5short?5integer?5is?5greater?5@
CONST	SEGMENT
??_C@_0CN@GGCBHAGN@signed?5short?5integer?5is?5greater?5@ DB 'signed shor'
	DB	't integer is greater than maximum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KINDOECN@signed?5short?5integer?5is?5less?5tha@
CONST	SEGMENT
??_C@_0CK@KINDOECN@signed?5short?5integer?5is?5less?5tha@ DB 'signed shor'
	DB	't integer is less than minimum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JGCPDOOF@unsigned?5byte?5integer?5is?5greater@
CONST	SEGMENT
??_C@_0CO@JGCPDOOF@unsigned?5byte?5integer?5is?5greater@ DB 'unsigned byt'
	DB	'e integer is greater than maximum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KDPALKGI@unsigned?5byte?5integer?5is?5less?5th@
CONST	SEGMENT
??_C@_0CL@KDPALKGI@unsigned?5byte?5integer?5is?5less?5th@ DB 'unsigned by'
	DB	'te integer is less than minimum', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT convertsimple
_TEXT	SEGMENT
sarg$ = 48
format$ = 56
c$ = 64
p$20789 = 72
ival$20800 = 80
p$20812 = 88
ival$20823 = 96
p$20829 = 104
ival$20840 = 112
p$20852 = 120
ival$20863 = 128
p$20869 = 136
ival$20880 = 144
p$20891 = 152
ival$20902 = 160
p$20910 = 168
iobj$20909 = 176
ival$20921 = 184
p$20928 = 192
ival$20939 = 200
p$20944 = 208
ival$20955 = 216
p$20961 = 224
ival$20972 = 232
p$20978 = 240
ival$20989 = 248
p$20995 = 256
dval$21006 = 264
p$21011 = 272
dval$21022 = 280
p$21026 = 288
cval$21037 = 296
p$21041 = 312
kind$21083 = 320
p$21072 = 328
data$21084 = 336
p$21127 = 344
val$21138 = 352
p$21144 = 360
count$21157 = 368
buf$21156 = 376
q2$21167 = 384
q$21165 = 392
p$21200 = 400
len$21218 = 408
buf$21223 = 416
p$21228 = 424
q2$21242 = 432
q$21240 = 440
len$21274 = 448
count$21282 = 456
buf$21281 = 464
p$21288 = 472
len$21299 = 480
p$21318 = 488
q2$21332 = 496
q$21330 = 504
len$21364 = 512
len$21377 = 520
s$21385 = 528
ptr$21388 = 536
size$21387 = 544
recode_strings$21386 = 552
encoding$21384 = 560
buffer$21383 = 568
u$21431 = 576
q2$21456 = 584
q$21454 = 592
p$21531 = 600
p$21547 = 608
p$21565 = 616
p$21586 = 624
type$21585 = 632
res$21637 = 640
convert$21615 = 648
addr$21626 = 656
p$21653 = 664
$T22506 = 672
$T22551 = 688
tv66 = 704
tv333 = 712
tv364 = 720
tv441 = 728
tv450 = 736
tv456 = 744
tv455 = 748
tv701 = 752
tv714 = 760
tv788 = 768
tv944 = 776
tv943 = 784
tv962 = 792
tv1004 = 800
tv1003 = 808
tv1068 = 816
arg$ = 864
p_format$ = 872
p_va$ = 880
flags$ = 888
msgbuf$ = 896
bufsize$ = 904
freelist$ = 912
convertsimple PROC					; COMDAT

; 552  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 48 03
	00 00		 sub	 rsp, 840		; 00000348H

; 553  :     /* For # codes */
; 554  : #define FETCH_SIZE      int *q=NULL;Py_ssize_t *q2=NULL;\
; 555  :     if (flags & FLAG_SIZE_T) q2=va_arg(*p_va, Py_ssize_t*); \
; 556  :     else q=va_arg(*p_va, int*);
; 557  : #define STORE_SIZE(s)   \
; 558  :     if (flags & FLAG_SIZE_T) \
; 559  :         *q2=s; \
; 560  :     else { \
; 561  :         if (INT_MAX < s) { \
; 562  :             PyErr_SetString(PyExc_OverflowError, \
; 563  :                 "size does not fit in an int"); \
; 564  :             return converterr("", arg, msgbuf, bufsize); \
; 565  :         } \
; 566  :         *q=s; \
; 567  :     }
; 568  : #define BUFFER_LEN      ((flags & FLAG_SIZE_T) ? *q2:*q)
; 569  : #define RETURN_ERR_OCCURRED return msgbuf
; 570  : 
; 571  :     const char *format = *p_format;

  0001d	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR p_format$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 572  :     char c = *format++;

  0002d	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  00032	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00035	88 44 24 40	 mov	 BYTE PTR c$[rsp], al
  00039	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  0003e	48 ff c0	 inc	 rax
  00041	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 573  :     char *sarg;
; 574  : 
; 575  :     switch (c) {

  00046	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  0004b	89 84 24 c0 02
	00 00		 mov	 DWORD PTR tv66[rsp], eax
  00052	8b 84 24 c0 02
	00 00		 mov	 eax, DWORD PTR tv66[rsp]
  00059	83 e8 42	 sub	 eax, 66			; 00000042H
  0005c	89 84 24 c0 02
	00 00		 mov	 DWORD PTR tv66[rsp], eax
  00063	83 bc 24 c0 02
	00 00 38	 cmp	 DWORD PTR tv66[rsp], 56	; 00000038H
  0006b	0f 87 7d 2b 00
	00		 ja	 $LN1@convertsim
  00071	48 63 84 24 c0
	02 00 00	 movsxd	 rax, DWORD PTR tv66[rsp]
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00080	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN255@convertsim[rcx+rax]
  00088	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN256@convertsim[rcx+rax*4]
  0008f	48 03 c1	 add	 rax, rcx
  00092	ff e0		 jmp	 rax
$LN206@convertsim:

; 576  : 
; 577  :     case 'b': { /* unsigned byte -- very short int */
; 578  :         char *p = va_arg(*p_va, char *);

  00094	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0009c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009f	48 83 c0 08	 add	 rax, 8
  000a3	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  000ab	48 89 01	 mov	 QWORD PTR [rcx], rax
  000ae	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  000b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b9	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  000bd	48 89 44 24 48	 mov	 QWORD PTR p$20789[rsp], rax

; 579  :         long ival;
; 580  :         if (float_argument_error(arg))

  000c2	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  000ca	e8 00 00 00 00	 call	 float_argument_error
  000cf	85 c0		 test	 eax, eax
  000d1	74 0d		 je	 SHORT $LN205@convertsim

; 581  :             RETURN_ERR_OCCURRED;

  000d3	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  000db	e9 46 2b 00 00	 jmp	 $LN209@convertsim
$LN205@convertsim:

; 582  :         ival = PyLong_AsLong(arg);

  000e0	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  000e8	e8 00 00 00 00	 call	 PyLong_AsLong
  000ed	89 44 24 50	 mov	 DWORD PTR ival$20800[rsp], eax

; 583  :         if (ival == -1 && PyErr_Occurred())

  000f1	83 7c 24 50 ff	 cmp	 DWORD PTR ival$20800[rsp], -1
  000f6	75 19		 jne	 SHORT $LN204@convertsim
  000f8	e8 00 00 00 00	 call	 PyErr_Occurred
  000fd	48 85 c0	 test	 rax, rax
  00100	74 0f		 je	 SHORT $LN204@convertsim

; 584  :             RETURN_ERR_OCCURRED;

  00102	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  0010a	e9 17 2b 00 00	 jmp	 $LN209@convertsim
  0010f	eb 61		 jmp	 SHORT $LN203@convertsim
$LN204@convertsim:

; 585  :         else if (ival < 0) {

  00111	83 7c 24 50 00	 cmp	 DWORD PTR ival$20800[rsp], 0
  00116	7d 22		 jge	 SHORT $LN202@convertsim

; 586  :             PyErr_SetString(PyExc_OverflowError,
; 587  :                             "unsigned byte integer is less than minimum");

  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@KDPALKGI@unsigned?5byte?5integer?5is?5less?5th@
  0011f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00126	e8 00 00 00 00	 call	 PyErr_SetString

; 588  :             RETURN_ERR_OCCURRED;

  0012b	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00133	e9 ee 2a 00 00	 jmp	 $LN209@convertsim
  00138	eb 38		 jmp	 SHORT $LN201@convertsim
$LN202@convertsim:

; 589  :         }
; 590  :         else if (ival > UCHAR_MAX) {

  0013a	81 7c 24 50 ff
	00 00 00	 cmp	 DWORD PTR ival$20800[rsp], 255 ; 000000ffH
  00142	7e 22		 jle	 SHORT $LN200@convertsim

; 591  :             PyErr_SetString(PyExc_OverflowError,
; 592  :                             "unsigned byte integer is greater than maximum");

  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@JGCPDOOF@unsigned?5byte?5integer?5is?5greater@
  0014b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00152	e8 00 00 00 00	 call	 PyErr_SetString

; 593  :             RETURN_ERR_OCCURRED;

  00157	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  0015f	e9 c2 2a 00 00	 jmp	 $LN209@convertsim

; 594  :         }
; 595  :         else

  00164	eb 0c		 jmp	 SHORT $LN199@convertsim
$LN200@convertsim:

; 596  :             *p = (unsigned char) ival;

  00166	48 8b 44 24 48	 mov	 rax, QWORD PTR p$20789[rsp]
  0016b	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR ival$20800[rsp]
  00170	88 08		 mov	 BYTE PTR [rax], cl
$LN199@convertsim:
$LN201@convertsim:
$LN203@convertsim:

; 597  :         break;

  00172	e9 9d 2a 00 00	 jmp	 $LN207@convertsim
$LN198@convertsim:

; 598  :     }
; 599  : 
; 600  :     case 'B': {/* byte sized bitfield - both signed and unsigned
; 601  :                   values allowed */
; 602  :         char *p = va_arg(*p_va, char *);

  00177	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0017f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00182	48 83 c0 08	 add	 rax, 8
  00186	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0018e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00191	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00199	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019c	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  001a0	48 89 44 24 58	 mov	 QWORD PTR p$20812[rsp], rax

; 603  :         long ival;
; 604  :         if (float_argument_error(arg))

  001a5	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  001ad	e8 00 00 00 00	 call	 float_argument_error
  001b2	85 c0		 test	 eax, eax
  001b4	74 0d		 je	 SHORT $LN197@convertsim

; 605  :             RETURN_ERR_OCCURRED;

  001b6	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  001be	e9 63 2a 00 00	 jmp	 $LN209@convertsim
$LN197@convertsim:

; 606  :         ival = PyLong_AsUnsignedLongMask(arg);

  001c3	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  001cb	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongMask
  001d0	89 44 24 60	 mov	 DWORD PTR ival$20823[rsp], eax

; 607  :         if (ival == -1 && PyErr_Occurred())

  001d4	83 7c 24 60 ff	 cmp	 DWORD PTR ival$20823[rsp], -1
  001d9	75 19		 jne	 SHORT $LN196@convertsim
  001db	e8 00 00 00 00	 call	 PyErr_Occurred
  001e0	48 85 c0	 test	 rax, rax
  001e3	74 0f		 je	 SHORT $LN196@convertsim

; 608  :             RETURN_ERR_OCCURRED;

  001e5	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  001ed	e9 34 2a 00 00	 jmp	 $LN209@convertsim

; 609  :         else

  001f2	eb 0c		 jmp	 SHORT $LN195@convertsim
$LN196@convertsim:

; 610  :             *p = (unsigned char) ival;

  001f4	48 8b 44 24 58	 mov	 rax, QWORD PTR p$20812[rsp]
  001f9	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR ival$20823[rsp]
  001fe	88 08		 mov	 BYTE PTR [rax], cl
$LN195@convertsim:

; 611  :         break;

  00200	e9 0f 2a 00 00	 jmp	 $LN207@convertsim
$LN194@convertsim:

; 612  :     }
; 613  : 
; 614  :     case 'h': {/* signed short int */
; 615  :         short *p = va_arg(*p_va, short *);

  00205	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0020d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00210	48 83 c0 08	 add	 rax, 8
  00214	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0021c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0021f	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00227	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0022a	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0022e	48 89 44 24 68	 mov	 QWORD PTR p$20829[rsp], rax

; 616  :         long ival;
; 617  :         if (float_argument_error(arg))

  00233	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  0023b	e8 00 00 00 00	 call	 float_argument_error
  00240	85 c0		 test	 eax, eax
  00242	74 0d		 je	 SHORT $LN193@convertsim

; 618  :             RETURN_ERR_OCCURRED;

  00244	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  0024c	e9 d5 29 00 00	 jmp	 $LN209@convertsim
$LN193@convertsim:

; 619  :         ival = PyLong_AsLong(arg);

  00251	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00259	e8 00 00 00 00	 call	 PyLong_AsLong
  0025e	89 44 24 70	 mov	 DWORD PTR ival$20840[rsp], eax

; 620  :         if (ival == -1 && PyErr_Occurred())

  00262	83 7c 24 70 ff	 cmp	 DWORD PTR ival$20840[rsp], -1
  00267	75 19		 jne	 SHORT $LN192@convertsim
  00269	e8 00 00 00 00	 call	 PyErr_Occurred
  0026e	48 85 c0	 test	 rax, rax
  00271	74 0f		 je	 SHORT $LN192@convertsim

; 621  :             RETURN_ERR_OCCURRED;

  00273	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  0027b	e9 a6 29 00 00	 jmp	 $LN209@convertsim
  00280	eb 65		 jmp	 SHORT $LN191@convertsim
$LN192@convertsim:

; 622  :         else if (ival < SHRT_MIN) {

  00282	81 7c 24 70 00
	80 ff ff	 cmp	 DWORD PTR ival$20840[rsp], -32768 ; ffffffffffff8000H
  0028a	7d 22		 jge	 SHORT $LN190@convertsim

; 623  :             PyErr_SetString(PyExc_OverflowError,
; 624  :                             "signed short integer is less than minimum");

  0028c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@KINDOECN@signed?5short?5integer?5is?5less?5tha@
  00293	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0029a	e8 00 00 00 00	 call	 PyErr_SetString

; 625  :             RETURN_ERR_OCCURRED;

  0029f	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  002a7	e9 7a 29 00 00	 jmp	 $LN209@convertsim
  002ac	eb 39		 jmp	 SHORT $LN189@convertsim
$LN190@convertsim:

; 626  :         }
; 627  :         else if (ival > SHRT_MAX) {

  002ae	81 7c 24 70 ff
	7f 00 00	 cmp	 DWORD PTR ival$20840[rsp], 32767 ; 00007fffH
  002b6	7e 22		 jle	 SHORT $LN188@convertsim

; 628  :             PyErr_SetString(PyExc_OverflowError,
; 629  :                             "signed short integer is greater than maximum");

  002b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GGCBHAGN@signed?5short?5integer?5is?5greater?5@
  002bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  002c6	e8 00 00 00 00	 call	 PyErr_SetString

; 630  :             RETURN_ERR_OCCURRED;

  002cb	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  002d3	e9 4e 29 00 00	 jmp	 $LN209@convertsim

; 631  :         }
; 632  :         else

  002d8	eb 0d		 jmp	 SHORT $LN187@convertsim
$LN188@convertsim:

; 633  :             *p = (short) ival;

  002da	48 8b 44 24 68	 mov	 rax, QWORD PTR p$20829[rsp]
  002df	0f b7 4c 24 70	 movzx	 ecx, WORD PTR ival$20840[rsp]
  002e4	66 89 08	 mov	 WORD PTR [rax], cx
$LN187@convertsim:
$LN189@convertsim:
$LN191@convertsim:

; 634  :         break;

  002e7	e9 28 29 00 00	 jmp	 $LN207@convertsim
$LN186@convertsim:

; 635  :     }
; 636  : 
; 637  :     case 'H': { /* short int sized bitfield, both signed and
; 638  :                    unsigned allowed */
; 639  :         unsigned short *p = va_arg(*p_va, unsigned short *);

  002ec	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  002f4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002f7	48 83 c0 08	 add	 rax, 8
  002fb	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  00303	48 89 01	 mov	 QWORD PTR [rcx], rax
  00306	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0030e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00311	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00315	48 89 44 24 78	 mov	 QWORD PTR p$20852[rsp], rax

; 640  :         long ival;
; 641  :         if (float_argument_error(arg))

  0031a	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00322	e8 00 00 00 00	 call	 float_argument_error
  00327	85 c0		 test	 eax, eax
  00329	74 0d		 je	 SHORT $LN185@convertsim

; 642  :             RETURN_ERR_OCCURRED;

  0032b	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00333	e9 ee 28 00 00	 jmp	 $LN209@convertsim
$LN185@convertsim:

; 643  :         ival = PyLong_AsUnsignedLongMask(arg);

  00338	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00340	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongMask
  00345	89 84 24 80 00
	00 00		 mov	 DWORD PTR ival$20863[rsp], eax

; 644  :         if (ival == -1 && PyErr_Occurred())

  0034c	83 bc 24 80 00
	00 00 ff	 cmp	 DWORD PTR ival$20863[rsp], -1
  00354	75 19		 jne	 SHORT $LN184@convertsim
  00356	e8 00 00 00 00	 call	 PyErr_Occurred
  0035b	48 85 c0	 test	 rax, rax
  0035e	74 0f		 je	 SHORT $LN184@convertsim

; 645  :             RETURN_ERR_OCCURRED;

  00360	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00368	e9 b9 28 00 00	 jmp	 $LN209@convertsim

; 646  :         else

  0036d	eb 10		 jmp	 SHORT $LN183@convertsim
$LN184@convertsim:

; 647  :             *p = (unsigned short) ival;

  0036f	48 8b 44 24 78	 mov	 rax, QWORD PTR p$20852[rsp]
  00374	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR ival$20863[rsp]
  0037c	66 89 08	 mov	 WORD PTR [rax], cx
$LN183@convertsim:

; 648  :         break;

  0037f	e9 90 28 00 00	 jmp	 $LN207@convertsim
$LN182@convertsim:

; 649  :     }
; 650  : 
; 651  :     case 'i': {/* signed int */
; 652  :         int *p = va_arg(*p_va, int *);

  00384	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0038c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0038f	48 83 c0 08	 add	 rax, 8
  00393	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0039b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0039e	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  003a6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a9	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  003ad	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR p$20869[rsp], rax

; 653  :         long ival;
; 654  :         if (float_argument_error(arg))

  003b5	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  003bd	e8 00 00 00 00	 call	 float_argument_error
  003c2	85 c0		 test	 eax, eax
  003c4	74 0d		 je	 SHORT $LN181@convertsim

; 655  :             RETURN_ERR_OCCURRED;

  003c6	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  003ce	e9 53 28 00 00	 jmp	 $LN209@convertsim
$LN181@convertsim:

; 656  :         ival = PyLong_AsLong(arg);

  003d3	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  003db	e8 00 00 00 00	 call	 PyLong_AsLong
  003e0	89 84 24 90 00
	00 00		 mov	 DWORD PTR ival$20880[rsp], eax

; 657  :         if (ival == -1 && PyErr_Occurred())

  003e7	83 bc 24 90 00
	00 00 ff	 cmp	 DWORD PTR ival$20880[rsp], -1
  003ef	75 19		 jne	 SHORT $LN180@convertsim
  003f1	e8 00 00 00 00	 call	 PyErr_Occurred
  003f6	48 85 c0	 test	 rax, rax
  003f9	74 0f		 je	 SHORT $LN180@convertsim

; 658  :             RETURN_ERR_OCCURRED;

  003fb	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00403	e9 1e 28 00 00	 jmp	 $LN209@convertsim
  00408	eb 6f		 jmp	 SHORT $LN179@convertsim
$LN180@convertsim:

; 659  :         else if (ival > INT_MAX) {

  0040a	81 bc 24 90 00
	00 00 ff ff ff
	7f		 cmp	 DWORD PTR ival$20880[rsp], 2147483647 ; 7fffffffH
  00415	7e 22		 jle	 SHORT $LN178@convertsim

; 660  :             PyErr_SetString(PyExc_OverflowError,
; 661  :                             "signed integer is greater than maximum");

  00417	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@
  0041e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00425	e8 00 00 00 00	 call	 PyErr_SetString

; 662  :             RETURN_ERR_OCCURRED;

  0042a	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00432	e9 ef 27 00 00	 jmp	 $LN209@convertsim
  00437	eb 40		 jmp	 SHORT $LN177@convertsim
$LN178@convertsim:

; 663  :         }
; 664  :         else if (ival < INT_MIN) {

  00439	81 bc 24 90 00
	00 00 00 00 00
	80		 cmp	 DWORD PTR ival$20880[rsp], -2147483648 ; ffffffff80000000H
  00444	7d 22		 jge	 SHORT $LN176@convertsim

; 665  :             PyErr_SetString(PyExc_OverflowError,
; 666  :                             "signed integer is less than minimum");

  00446	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@
  0044d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00454	e8 00 00 00 00	 call	 PyErr_SetString

; 667  :             RETURN_ERR_OCCURRED;

  00459	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00461	e9 c0 27 00 00	 jmp	 $LN209@convertsim

; 668  :         }
; 669  :         else

  00466	eb 11		 jmp	 SHORT $LN175@convertsim
$LN176@convertsim:

; 670  :             *p = ival;

  00468	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$20869[rsp]
  00470	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ival$20880[rsp]
  00477	89 08		 mov	 DWORD PTR [rax], ecx
$LN175@convertsim:
$LN177@convertsim:
$LN179@convertsim:

; 671  :         break;

  00479	e9 96 27 00 00	 jmp	 $LN207@convertsim
$LN174@convertsim:

; 672  :     }
; 673  : 
; 674  :     case 'I': { /* int sized bitfield, both signed and
; 675  :                    unsigned allowed */
; 676  :         unsigned int *p = va_arg(*p_va, unsigned int *);

  0047e	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00486	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00489	48 83 c0 08	 add	 rax, 8
  0048d	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  00495	48 89 01	 mov	 QWORD PTR [rcx], rax
  00498	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  004a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004a3	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  004a7	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$20891[rsp], rax

; 677  :         unsigned int ival;
; 678  :         if (float_argument_error(arg))

  004af	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  004b7	e8 00 00 00 00	 call	 float_argument_error
  004bc	85 c0		 test	 eax, eax
  004be	74 0d		 je	 SHORT $LN173@convertsim

; 679  :             RETURN_ERR_OCCURRED;

  004c0	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  004c8	e9 59 27 00 00	 jmp	 $LN209@convertsim
$LN173@convertsim:

; 680  :         ival = (unsigned int)PyLong_AsUnsignedLongMask(arg);

  004cd	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  004d5	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongMask
  004da	89 84 24 a0 00
	00 00		 mov	 DWORD PTR ival$20902[rsp], eax

; 681  :         if (ival == (unsigned int)-1 && PyErr_Occurred())

  004e1	83 bc 24 a0 00
	00 00 ff	 cmp	 DWORD PTR ival$20902[rsp], -1 ; ffffffffH
  004e9	75 19		 jne	 SHORT $LN172@convertsim
  004eb	e8 00 00 00 00	 call	 PyErr_Occurred
  004f0	48 85 c0	 test	 rax, rax
  004f3	74 0f		 je	 SHORT $LN172@convertsim

; 682  :             RETURN_ERR_OCCURRED;

  004f5	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  004fd	e9 24 27 00 00	 jmp	 $LN209@convertsim

; 683  :         else

  00502	eb 11		 jmp	 SHORT $LN171@convertsim
$LN172@convertsim:

; 684  :             *p = ival;

  00504	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$20891[rsp]
  0050c	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR ival$20902[rsp]
  00513	89 08		 mov	 DWORD PTR [rax], ecx
$LN171@convertsim:

; 685  :         break;

  00515	e9 fa 26 00 00	 jmp	 $LN207@convertsim
$LN170@convertsim:

; 686  :     }
; 687  : 
; 688  :     case 'n': /* Py_ssize_t */
; 689  :     {
; 690  :         PyObject *iobj;
; 691  :         Py_ssize_t *p = va_arg(*p_va, Py_ssize_t *);

  0051a	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00522	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00525	48 83 c0 08	 add	 rax, 8
  00529	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  00531	48 89 01	 mov	 QWORD PTR [rcx], rax
  00534	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0053c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0053f	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00543	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$20910[rsp], rax

; 692  :         Py_ssize_t ival = -1;

  0054b	48 c7 84 24 b8
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR ival$20921[rsp], -1

; 693  :         if (float_argument_error(arg))

  00557	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  0055f	e8 00 00 00 00	 call	 float_argument_error
  00564	85 c0		 test	 eax, eax
  00566	74 0d		 je	 SHORT $LN169@convertsim

; 694  :             RETURN_ERR_OCCURRED;

  00568	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00570	e9 b1 26 00 00	 jmp	 $LN209@convertsim
$LN169@convertsim:

; 695  :         iobj = PyNumber_Index(arg);

  00575	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  0057d	e8 00 00 00 00	 call	 PyNumber_Index
  00582	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR iobj$20909[rsp], rax

; 696  :         if (iobj != NULL) {

  0058a	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR iobj$20909[rsp], 0
  00593	74 22		 je	 SHORT $LN168@convertsim

; 697  :             ival = PyLong_AsSsize_t(iobj);

  00595	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR iobj$20909[rsp]
  0059d	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  005a2	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR ival$20921[rsp], rax

; 698  :             Py_DECREF(iobj);

  005aa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR iobj$20909[rsp]
  005b2	e8 00 00 00 00	 call	 _Py_DecRef
$LN168@convertsim:

; 699  :         }
; 700  :         if (ival == -1 && PyErr_Occurred())

  005b7	48 83 bc 24 b8
	00 00 00 ff	 cmp	 QWORD PTR ival$20921[rsp], -1
  005c0	75 17		 jne	 SHORT $LN167@convertsim
  005c2	e8 00 00 00 00	 call	 PyErr_Occurred
  005c7	48 85 c0	 test	 rax, rax
  005ca	74 0d		 je	 SHORT $LN167@convertsim

; 701  :             RETURN_ERR_OCCURRED;

  005cc	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  005d4	e9 4d 26 00 00	 jmp	 $LN209@convertsim
$LN167@convertsim:

; 702  :         *p = ival;

  005d9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$20910[rsp]
  005e1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR ival$20921[rsp]
  005e9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 703  :         break;

  005ec	e9 23 26 00 00	 jmp	 $LN207@convertsim
$LN166@convertsim:

; 704  :     }
; 705  :     case 'l': {/* long int */
; 706  :         long *p = va_arg(*p_va, long *);

  005f1	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  005f9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005fc	48 83 c0 08	 add	 rax, 8
  00600	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  00608	48 89 01	 mov	 QWORD PTR [rcx], rax
  0060b	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00613	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00616	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0061a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR p$20928[rsp], rax

; 707  :         long ival;
; 708  :         if (float_argument_error(arg))

  00622	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  0062a	e8 00 00 00 00	 call	 float_argument_error
  0062f	85 c0		 test	 eax, eax
  00631	74 0d		 je	 SHORT $LN165@convertsim

; 709  :             RETURN_ERR_OCCURRED;

  00633	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  0063b	e9 e6 25 00 00	 jmp	 $LN209@convertsim
$LN165@convertsim:

; 710  :         ival = PyLong_AsLong(arg);

  00640	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00648	e8 00 00 00 00	 call	 PyLong_AsLong
  0064d	89 84 24 c8 00
	00 00		 mov	 DWORD PTR ival$20939[rsp], eax

; 711  :         if (ival == -1 && PyErr_Occurred())

  00654	83 bc 24 c8 00
	00 00 ff	 cmp	 DWORD PTR ival$20939[rsp], -1
  0065c	75 19		 jne	 SHORT $LN164@convertsim
  0065e	e8 00 00 00 00	 call	 PyErr_Occurred
  00663	48 85 c0	 test	 rax, rax
  00666	74 0f		 je	 SHORT $LN164@convertsim

; 712  :             RETURN_ERR_OCCURRED;

  00668	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00670	e9 b1 25 00 00	 jmp	 $LN209@convertsim

; 713  :         else

  00675	eb 11		 jmp	 SHORT $LN163@convertsim
$LN164@convertsim:

; 714  :             *p = ival;

  00677	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR p$20928[rsp]
  0067f	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR ival$20939[rsp]
  00686	89 08		 mov	 DWORD PTR [rax], ecx
$LN163@convertsim:

; 715  :         break;

  00688	e9 87 25 00 00	 jmp	 $LN207@convertsim
$LN162@convertsim:

; 716  :     }
; 717  : 
; 718  :     case 'k': { /* long sized bitfield */
; 719  :         unsigned long *p = va_arg(*p_va, unsigned long *);

  0068d	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00695	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00698	48 83 c0 08	 add	 rax, 8
  0069c	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  006a4	48 89 01	 mov	 QWORD PTR [rcx], rax
  006a7	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  006af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006b2	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  006b6	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR p$20944[rsp], rax

; 720  :         unsigned long ival;
; 721  :         if (PyLong_Check(arg))

  006be	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  006c6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  006ca	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  006d0	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  006d5	85 c0		 test	 eax, eax
  006d7	74 16		 je	 SHORT $LN161@convertsim

; 722  :             ival = PyLong_AsUnsignedLongMask(arg);

  006d9	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  006e1	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongMask
  006e6	89 84 24 d8 00
	00 00		 mov	 DWORD PTR ival$20955[rsp], eax

; 723  :         else

  006ed	eb 29		 jmp	 SHORT $LN160@convertsim
$LN161@convertsim:

; 724  :             return converterr("integer<k>", arg, msgbuf, bufsize);

  006ef	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  006f7	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  006ff	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  00707	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@GPALMJOD@integer?$DMk?$DO?$AA@
  0070e	e8 00 00 00 00	 call	 converterr
  00713	e9 0e 25 00 00	 jmp	 $LN209@convertsim
$LN160@convertsim:

; 725  :         *p = ival;

  00718	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR p$20944[rsp]
  00720	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR ival$20955[rsp]
  00727	89 08		 mov	 DWORD PTR [rax], ecx

; 726  :         break;

  00729	e9 e6 24 00 00	 jmp	 $LN207@convertsim
$LN159@convertsim:

; 727  :     }
; 728  : 
; 729  : #ifdef HAVE_LONG_LONG
; 730  :     case 'L': {/* PY_LONG_LONG */
; 731  :         PY_LONG_LONG *p = va_arg( *p_va, PY_LONG_LONG * );

  0072e	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00736	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00739	48 83 c0 08	 add	 rax, 8
  0073d	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  00745	48 89 01	 mov	 QWORD PTR [rcx], rax
  00748	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00750	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00753	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00757	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR p$20961[rsp], rax

; 732  :         PY_LONG_LONG ival;
; 733  :         if (float_argument_error(arg))

  0075f	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00767	e8 00 00 00 00	 call	 float_argument_error
  0076c	85 c0		 test	 eax, eax
  0076e	74 0d		 je	 SHORT $LN158@convertsim

; 734  :             RETURN_ERR_OCCURRED;

  00770	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00778	e9 a9 24 00 00	 jmp	 $LN209@convertsim
$LN158@convertsim:

; 735  :         ival = PyLong_AsLongLong(arg);

  0077d	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00785	e8 00 00 00 00	 call	 PyLong_AsLongLong
  0078a	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR ival$20972[rsp], rax

; 736  :         if (ival == (PY_LONG_LONG)-1 && PyErr_Occurred())

  00792	48 83 bc 24 e8
	00 00 00 ff	 cmp	 QWORD PTR ival$20972[rsp], -1
  0079b	75 19		 jne	 SHORT $LN157@convertsim
  0079d	e8 00 00 00 00	 call	 PyErr_Occurred
  007a2	48 85 c0	 test	 rax, rax
  007a5	74 0f		 je	 SHORT $LN157@convertsim

; 737  :             RETURN_ERR_OCCURRED;

  007a7	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  007af	e9 72 24 00 00	 jmp	 $LN209@convertsim

; 738  :         else

  007b4	eb 13		 jmp	 SHORT $LN156@convertsim
$LN157@convertsim:

; 739  :             *p = ival;

  007b6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR p$20961[rsp]
  007be	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ival$20972[rsp]
  007c6	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN156@convertsim:

; 740  :         break;

  007c9	e9 46 24 00 00	 jmp	 $LN207@convertsim
$LN155@convertsim:

; 741  :     }
; 742  : 
; 743  :     case 'K': { /* long long sized bitfield */
; 744  :         unsigned PY_LONG_LONG *p = va_arg(*p_va, unsigned PY_LONG_LONG *);

  007ce	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  007d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007d9	48 83 c0 08	 add	 rax, 8
  007dd	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  007e5	48 89 01	 mov	 QWORD PTR [rcx], rax
  007e8	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  007f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007f3	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  007f7	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR p$20978[rsp], rax

; 745  :         unsigned PY_LONG_LONG ival;
; 746  :         if (PyLong_Check(arg))

  007ff	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00807	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0080b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00811	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00816	85 c0		 test	 eax, eax
  00818	74 17		 je	 SHORT $LN154@convertsim

; 747  :             ival = PyLong_AsUnsignedLongLongMask(arg);

  0081a	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00822	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongLongMask
  00827	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR ival$20989[rsp], rax

; 748  :         else

  0082f	eb 29		 jmp	 SHORT $LN153@convertsim
$LN154@convertsim:

; 749  :             return converterr("integer<K>", arg, msgbuf, bufsize);

  00831	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  00839	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  00841	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  00849	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@FHEGIPAD@integer?$DMK?$DO?$AA@
  00850	e8 00 00 00 00	 call	 converterr
  00855	e9 cc 23 00 00	 jmp	 $LN209@convertsim
$LN153@convertsim:

; 750  :         *p = ival;

  0085a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR p$20978[rsp]
  00862	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR ival$20989[rsp]
  0086a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 751  :         break;

  0086d	e9 a2 23 00 00	 jmp	 $LN207@convertsim
$LN152@convertsim:

; 752  :     }
; 753  : #endif
; 754  : 
; 755  :     case 'f': {/* float */
; 756  :         float *p = va_arg(*p_va, float *);

  00872	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0087a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0087d	48 83 c0 08	 add	 rax, 8
  00881	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  00889	48 89 01	 mov	 QWORD PTR [rcx], rax
  0088c	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00894	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00897	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0089b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR p$20995[rsp], rax

; 757  :         double dval = PyFloat_AsDouble(arg);

  008a3	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  008ab	e8 00 00 00 00	 call	 PyFloat_AsDouble
  008b0	f2 0f 11 84 24
	08 01 00 00	 movsdx	 QWORD PTR dval$21006[rsp], xmm0

; 758  :         if (PyErr_Occurred())

  008b9	e8 00 00 00 00	 call	 PyErr_Occurred
  008be	48 85 c0	 test	 rax, rax
  008c1	74 0f		 je	 SHORT $LN151@convertsim

; 759  :             RETURN_ERR_OCCURRED;

  008c3	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  008cb	e9 56 23 00 00	 jmp	 $LN209@convertsim

; 760  :         else

  008d0	eb 15		 jmp	 SHORT $LN150@convertsim
$LN151@convertsim:

; 761  :             *p = (float) dval;

  008d2	f2 0f 5a 84 24
	08 01 00 00	 cvtsd2ss xmm0, QWORD PTR dval$21006[rsp]
  008db	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR p$20995[rsp]
  008e3	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
$LN150@convertsim:

; 762  :         break;

  008e7	e9 28 23 00 00	 jmp	 $LN207@convertsim
$LN149@convertsim:

; 763  :     }
; 764  : 
; 765  :     case 'd': {/* double */
; 766  :         double *p = va_arg(*p_va, double *);

  008ec	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  008f4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008f7	48 83 c0 08	 add	 rax, 8
  008fb	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  00903	48 89 01	 mov	 QWORD PTR [rcx], rax
  00906	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0090e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00911	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00915	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR p$21011[rsp], rax

; 767  :         double dval = PyFloat_AsDouble(arg);

  0091d	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00925	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0092a	f2 0f 11 84 24
	18 01 00 00	 movsdx	 QWORD PTR dval$21022[rsp], xmm0

; 768  :         if (PyErr_Occurred())

  00933	e8 00 00 00 00	 call	 PyErr_Occurred
  00938	48 85 c0	 test	 rax, rax
  0093b	74 0f		 je	 SHORT $LN148@convertsim

; 769  :             RETURN_ERR_OCCURRED;

  0093d	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00945	e9 dc 22 00 00	 jmp	 $LN209@convertsim

; 770  :         else

  0094a	eb 15		 jmp	 SHORT $LN147@convertsim
$LN148@convertsim:

; 771  :             *p = dval;

  0094c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR p$21011[rsp]
  00954	f2 0f 10 84 24
	18 01 00 00	 movsdx	 xmm0, QWORD PTR dval$21022[rsp]
  0095d	f2 0f 11 00	 movsdx	 QWORD PTR [rax], xmm0
$LN147@convertsim:

; 772  :         break;

  00961	e9 ae 22 00 00	 jmp	 $LN207@convertsim
$LN146@convertsim:

; 773  :     }
; 774  : 
; 775  :     case 'D': {/* complex double */
; 776  :         Py_complex *p = va_arg(*p_va, Py_complex *);

  00966	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0096e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00971	48 83 c0 08	 add	 rax, 8
  00975	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0097d	48 89 01	 mov	 QWORD PTR [rcx], rax
  00980	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00988	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0098b	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0098f	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR p$21026[rsp], rax

; 777  :         Py_complex cval;
; 778  :         cval = PyComplex_AsCComplex(arg);

  00997	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  0099f	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR $T22506[rsp]
  009a7	e8 00 00 00 00	 call	 PyComplex_AsCComplex
  009ac	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR $T22551[rsp]
  009b4	48 8b f9	 mov	 rdi, rcx
  009b7	48 8b f0	 mov	 rsi, rax
  009ba	b9 10 00 00 00	 mov	 ecx, 16
  009bf	f3 a4		 rep movsb
  009c1	48 8d 84 24 28
	01 00 00	 lea	 rax, QWORD PTR cval$21037[rsp]
  009c9	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR $T22551[rsp]
  009d1	48 8b f8	 mov	 rdi, rax
  009d4	48 8b f1	 mov	 rsi, rcx
  009d7	b9 10 00 00 00	 mov	 ecx, 16
  009dc	f3 a4		 rep movsb

; 779  :         if (PyErr_Occurred())

  009de	e8 00 00 00 00	 call	 PyErr_Occurred
  009e3	48 85 c0	 test	 rax, rax
  009e6	74 0f		 je	 SHORT $LN145@convertsim

; 780  :             RETURN_ERR_OCCURRED;

  009e8	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  009f0	e9 31 22 00 00	 jmp	 $LN209@convertsim

; 781  :         else

  009f5	eb 1a		 jmp	 SHORT $LN144@convertsim
$LN145@convertsim:

; 782  :             *p = cval;

  009f7	48 8d 84 24 28
	01 00 00	 lea	 rax, QWORD PTR cval$21037[rsp]
  009ff	48 8b bc 24 20
	01 00 00	 mov	 rdi, QWORD PTR p$21026[rsp]
  00a07	48 8b f0	 mov	 rsi, rax
  00a0a	b9 10 00 00 00	 mov	 ecx, 16
  00a0f	f3 a4		 rep movsb
$LN144@convertsim:

; 783  :         break;

  00a11	e9 fe 21 00 00	 jmp	 $LN207@convertsim
$LN143@convertsim:

; 784  :     }
; 785  : 
; 786  :     case 'c': {/* char */
; 787  :         char *p = va_arg(*p_va, char *);

  00a16	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00a1e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a21	48 83 c0 08	 add	 rax, 8
  00a25	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  00a2d	48 89 01	 mov	 QWORD PTR [rcx], rax
  00a30	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00a38	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a3b	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00a3f	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR p$21041[rsp], rax

; 788  :         if (PyBytes_Check(arg) && PyBytes_Size(arg) == 1)

  00a47	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00a4f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00a53	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00a59	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00a5e	85 c0		 test	 eax, eax
  00a60	74 65		 je	 SHORT $LN142@convertsim
  00a62	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00a6a	e8 00 00 00 00	 call	 PyBytes_Size
  00a6f	48 83 f8 01	 cmp	 rax, 1
  00a73	75 52		 jne	 SHORT $LN142@convertsim

; 789  :             *p = PyBytes_AS_STRING(arg)[0];

  00a75	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00a7d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00a81	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00a87	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00a8c	85 c0		 test	 eax, eax
  00a8e	75 1c		 jne	 SHORT $LN211@convertsim
  00a90	41 b8 15 03 00
	00		 mov	 r8d, 789		; 00000315H
  00a96	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00a9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@MCJLNGFD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00aa4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00aaa	33 c0		 xor	 eax, eax
$LN211@convertsim:
  00aac	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR p$21041[rsp]
  00ab4	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00abc	0f b6 49 78	 movzx	 ecx, BYTE PTR [rcx+120]
  00ac0	88 08		 mov	 BYTE PTR [rax], cl
  00ac2	e9 10 01 00 00	 jmp	 $LN141@convertsim
$LN142@convertsim:

; 790  :         else if (PyByteArray_Check(arg) && PyByteArray_Size(arg) == 1)

  00ac7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00ace	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00ad6	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00ada	74 20		 je	 SHORT $LN139@convertsim
  00adc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00ae3	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00aeb	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00aef	e8 00 00 00 00	 call	 PyType_IsSubtype
  00af4	85 c0		 test	 eax, eax
  00af6	0f 84 b2 00 00
	00		 je	 $LN140@convertsim
$LN139@convertsim:
  00afc	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00b04	e8 00 00 00 00	 call	 PyByteArray_Size
  00b09	48 83 f8 01	 cmp	 rax, 1
  00b0d	0f 85 9b 00 00
	00		 jne	 $LN140@convertsim

; 791  :             *p = PyByteArray_AS_STRING(arg)[0];

  00b13	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00b1a	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00b22	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00b26	74 38		 je	 SHORT $LN212@convertsim
  00b28	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00b2f	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00b37	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00b3b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00b40	85 c0		 test	 eax, eax
  00b42	75 1c		 jne	 SHORT $LN212@convertsim
  00b44	41 b8 17 03 00
	00		 mov	 r8d, 791		; 00000317H
  00b4a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00b51	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@CJPJAHMC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00b58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00b5e	33 c0		 xor	 eax, eax
$LN212@convertsim:
  00b60	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00b68	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00b6d	74 19		 je	 SHORT $LN213@convertsim
  00b6f	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00b77	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00b7e	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR tv333[rsp], rax
  00b86	eb 0f		 jmp	 SHORT $LN214@convertsim
$LN213@convertsim:
  00b88	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00b8f	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR tv333[rsp], rax
$LN214@convertsim:
  00b97	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR p$21041[rsp]
  00b9f	48 8b 8c 24 c8
	02 00 00	 mov	 rcx, QWORD PTR tv333[rsp]
  00ba7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00baa	88 08		 mov	 BYTE PTR [rax], cl

; 792  :         else

  00bac	eb 29		 jmp	 SHORT $LN138@convertsim
$LN140@convertsim:

; 793  :             return converterr("a byte string of length 1", arg, msgbuf, bufsize);

  00bae	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  00bb6	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  00bbe	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  00bc6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@GGDPHBGA@a?5byte?5string?5of?5length?51?$AA@
  00bcd	e8 00 00 00 00	 call	 converterr
  00bd2	e9 4f 20 00 00	 jmp	 $LN209@convertsim
$LN138@convertsim:
$LN141@convertsim:

; 794  :         break;

  00bd7	e9 38 20 00 00	 jmp	 $LN207@convertsim
$LN137@convertsim:

; 795  :     }
; 796  : 
; 797  :     case 'C': {/* unicode char */
; 798  :         int *p = va_arg(*p_va, int *);

  00bdc	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00be4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00be7	48 83 c0 08	 add	 rax, 8
  00beb	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  00bf3	48 89 01	 mov	 QWORD PTR [rcx], rax
  00bf6	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00bfe	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c01	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00c05	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR p$21072[rsp], rax

; 799  :         int kind;
; 800  :         void *data;
; 801  : 
; 802  :         if (!PyUnicode_Check(arg))

  00c0d	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00c15	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00c19	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00c1f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00c24	85 c0		 test	 eax, eax
  00c26	75 29		 jne	 SHORT $LN136@convertsim

; 803  :             return converterr("a unicode character", arg, msgbuf, bufsize);

  00c28	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  00c30	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  00c38	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  00c40	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GCGDJOP@a?5unicode?5character?$AA@
  00c47	e8 00 00 00 00	 call	 converterr
  00c4c	e9 d5 1f 00 00	 jmp	 $LN209@convertsim
$LN136@convertsim:

; 804  : 
; 805  :         if (PyUnicode_READY(arg))

  00c51	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00c59	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00c5d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00c63	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00c68	85 c0		 test	 eax, eax
  00c6a	75 1c		 jne	 SHORT $LN215@convertsim
  00c6c	41 b8 25 03 00
	00		 mov	 r8d, 805		; 00000325H
  00c72	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00c79	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00c80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c86	33 c0		 xor	 eax, eax
$LN215@convertsim:
  00c88	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00c90	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00c93	c1 e8 07	 shr	 eax, 7
  00c96	83 e0 01	 and	 eax, 1
  00c99	85 c0		 test	 eax, eax
  00c9b	74 0d		 je	 SHORT $LN216@convertsim
  00c9d	c7 84 24 d0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv364[rsp], 0
  00ca8	eb 14		 jmp	 SHORT $LN217@convertsim
$LN216@convertsim:
  00caa	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00cb2	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00cb7	89 84 24 d0 02
	00 00		 mov	 DWORD PTR tv364[rsp], eax
$LN217@convertsim:
  00cbe	83 bc 24 d0 02
	00 00 00	 cmp	 DWORD PTR tv364[rsp], 0
  00cc6	74 0d		 je	 SHORT $LN135@convertsim

; 806  :             RETURN_ERR_OCCURRED;

  00cc8	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  00cd0	e9 51 1f 00 00	 jmp	 $LN209@convertsim
$LN135@convertsim:

; 807  : 
; 808  :         if (PyUnicode_GET_LENGTH(arg) != 1)

  00cd5	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00cdd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00ce1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00ce7	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00cec	85 c0		 test	 eax, eax
  00cee	75 1c		 jne	 SHORT $LN218@convertsim
  00cf0	41 b8 28 03 00
	00		 mov	 r8d, 808		; 00000328H
  00cf6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00cfd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00d04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00d0a	33 c0		 xor	 eax, eax
$LN218@convertsim:
  00d0c	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00d14	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00d17	c1 e8 07	 shr	 eax, 7
  00d1a	83 e0 01	 and	 eax, 1
  00d1d	85 c0		 test	 eax, eax
  00d1f	75 1c		 jne	 SHORT $LN219@convertsim
  00d21	41 b8 28 03 00
	00		 mov	 r8d, 808		; 00000328H
  00d27	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00d2e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00d35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00d3b	33 c0		 xor	 eax, eax
$LN219@convertsim:
  00d3d	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00d45	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  00d4a	74 29		 je	 SHORT $LN134@convertsim

; 809  :             return converterr("a unicode character", arg, msgbuf, bufsize);

  00d4c	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  00d54	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  00d5c	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  00d64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GCGDJOP@a?5unicode?5character?$AA@
  00d6b	e8 00 00 00 00	 call	 converterr
  00d70	e9 b1 1e 00 00	 jmp	 $LN209@convertsim
$LN134@convertsim:

; 810  : 
; 811  :         kind = PyUnicode_KIND(arg);

  00d75	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00d7d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00d81	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00d87	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00d8c	85 c0		 test	 eax, eax
  00d8e	75 1c		 jne	 SHORT $LN220@convertsim
  00d90	41 b8 2b 03 00
	00		 mov	 r8d, 811		; 0000032bH
  00d96	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00d9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00da4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00daa	33 c0		 xor	 eax, eax
$LN220@convertsim:
  00dac	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00db4	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00db7	c1 e8 07	 shr	 eax, 7
  00dba	83 e0 01	 and	 eax, 1
  00dbd	85 c0		 test	 eax, eax
  00dbf	75 1c		 jne	 SHORT $LN221@convertsim
  00dc1	41 b8 2b 03 00
	00		 mov	 r8d, 811		; 0000032bH
  00dc7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00dce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00dd5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00ddb	33 c0		 xor	 eax, eax
$LN221@convertsim:
  00ddd	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00de5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00de8	c1 e8 02	 shr	 eax, 2
  00deb	83 e0 07	 and	 eax, 7
  00dee	89 84 24 40 01
	00 00		 mov	 DWORD PTR kind$21083[rsp], eax

; 812  :         data = PyUnicode_DATA(arg);

  00df5	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00dfd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00e01	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00e07	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00e0c	85 c0		 test	 eax, eax
  00e0e	75 1c		 jne	 SHORT $LN222@convertsim
  00e10	41 b8 2c 03 00
	00		 mov	 r8d, 812		; 0000032cH
  00e16	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00e1d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00e24	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e2a	33 c0		 xor	 eax, eax
$LN222@convertsim:
  00e2c	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00e34	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00e37	c1 e8 05	 shr	 eax, 5
  00e3a	83 e0 01	 and	 eax, 1
  00e3d	85 c0		 test	 eax, eax
  00e3f	0f 84 bd 00 00
	00		 je	 $LN228@convertsim
  00e45	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00e4d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00e51	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00e57	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00e5c	85 c0		 test	 eax, eax
  00e5e	75 1c		 jne	 SHORT $LN223@convertsim
  00e60	41 b8 2c 03 00
	00		 mov	 r8d, 812		; 0000032cH
  00e66	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00e6d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00e74	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e7a	33 c0		 xor	 eax, eax
$LN223@convertsim:
  00e7c	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00e84	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00e87	c1 e8 07	 shr	 eax, 7
  00e8a	83 e0 01	 and	 eax, 1
  00e8d	85 c0		 test	 eax, eax
  00e8f	75 1c		 jne	 SHORT $LN224@convertsim
  00e91	41 b8 2c 03 00
	00		 mov	 r8d, 812		; 0000032cH
  00e97	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00e9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00ea5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00eab	33 c0		 xor	 eax, eax
$LN224@convertsim:
  00ead	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00eb5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00eb8	c1 e8 06	 shr	 eax, 6
  00ebb	83 e0 01	 and	 eax, 1
  00ebe	85 c0		 test	 eax, eax
  00ec0	74 18		 je	 SHORT $LN225@convertsim
  00ec2	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00eca	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00ed0	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR tv441[rsp], rax
  00ed8	eb 16		 jmp	 SHORT $LN226@convertsim
$LN225@convertsim:
  00eda	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00ee2	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00ee8	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR tv441[rsp], rax
$LN226@convertsim:
  00ef0	48 8b 84 24 d8
	02 00 00	 mov	 rax, QWORD PTR tv441[rsp]
  00ef8	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR tv450[rsp], rax
  00f00	eb 45		 jmp	 SHORT $LN229@convertsim
$LN228@convertsim:
  00f02	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00f0a	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00f12	75 1c		 jne	 SHORT $LN227@convertsim
  00f14	41 b8 2c 03 00
	00		 mov	 r8d, 812		; 0000032cH
  00f1a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00f21	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@IHJBJEGE@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
  00f28	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00f2e	33 c0		 xor	 eax, eax
$LN227@convertsim:
  00f30	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00f38	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00f3f	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR tv450[rsp], rax
$LN229@convertsim:
  00f47	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR tv450[rsp]
  00f4f	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR data$21084[rsp], rax

; 813  :         *p = PyUnicode_READ(kind, data, 0);

  00f57	83 bc 24 40 01
	00 00 01	 cmp	 DWORD PTR kind$21083[rsp], 1
  00f5f	75 14		 jne	 SHORT $LN232@convertsim
  00f61	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR data$21084[rsp]
  00f69	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00f6c	89 84 24 e8 02
	00 00		 mov	 DWORD PTR tv456[rsp], eax
  00f73	eb 3d		 jmp	 SHORT $LN233@convertsim
$LN232@convertsim:
  00f75	83 bc 24 40 01
	00 00 02	 cmp	 DWORD PTR kind$21083[rsp], 2
  00f7d	75 14		 jne	 SHORT $LN230@convertsim
  00f7f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR data$21084[rsp]
  00f87	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00f8a	89 84 24 ec 02
	00 00		 mov	 DWORD PTR tv455[rsp], eax
  00f91	eb 11		 jmp	 SHORT $LN231@convertsim
$LN230@convertsim:
  00f93	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR data$21084[rsp]
  00f9b	8b 00		 mov	 eax, DWORD PTR [rax]
  00f9d	89 84 24 ec 02
	00 00		 mov	 DWORD PTR tv455[rsp], eax
$LN231@convertsim:
  00fa4	8b 84 24 ec 02
	00 00		 mov	 eax, DWORD PTR tv455[rsp]
  00fab	89 84 24 e8 02
	00 00		 mov	 DWORD PTR tv456[rsp], eax
$LN233@convertsim:
  00fb2	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR p$21072[rsp]
  00fba	8b 8c 24 e8 02
	00 00		 mov	 ecx, DWORD PTR tv456[rsp]
  00fc1	89 08		 mov	 DWORD PTR [rax], ecx

; 814  :         break;

  00fc3	e9 4c 1c 00 00	 jmp	 $LN207@convertsim
$LN133@convertsim:

; 815  :     }
; 816  : 
; 817  :     case 'p': {/* boolean *p*redicate */
; 818  :         int *p = va_arg(*p_va, int *);

  00fc8	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00fd0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00fd3	48 83 c0 08	 add	 rax, 8
  00fd7	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  00fdf	48 89 01	 mov	 QWORD PTR [rcx], rax
  00fe2	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  00fea	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00fed	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00ff1	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR p$21127[rsp], rax

; 819  :         int val = PyObject_IsTrue(arg);

  00ff9	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  01001	e8 00 00 00 00	 call	 PyObject_IsTrue
  01006	89 84 24 60 01
	00 00		 mov	 DWORD PTR val$21138[rsp], eax

; 820  :         if (val > 0)

  0100d	83 bc 24 60 01
	00 00 00	 cmp	 DWORD PTR val$21138[rsp], 0
  01015	7e 10		 jle	 SHORT $LN132@convertsim

; 821  :             *p = 1;

  01017	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR p$21127[rsp]
  0101f	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
  01025	eb 27		 jmp	 SHORT $LN131@convertsim
$LN132@convertsim:

; 822  :         else if (val == 0)

  01027	83 bc 24 60 01
	00 00 00	 cmp	 DWORD PTR val$21138[rsp], 0
  0102f	75 10		 jne	 SHORT $LN130@convertsim

; 823  :             *p = 0;

  01031	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR p$21127[rsp]
  01039	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 824  :         else

  0103f	eb 0d		 jmp	 SHORT $LN129@convertsim
$LN130@convertsim:

; 825  :             RETURN_ERR_OCCURRED;

  01041	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  01049	e9 d8 1b 00 00	 jmp	 $LN209@convertsim
$LN129@convertsim:
$LN131@convertsim:

; 826  :         break;

  0104e	e9 c1 1b 00 00	 jmp	 $LN207@convertsim
$LN128@convertsim:

; 827  :     }
; 828  : 
; 829  :     /* XXX WAAAAH!  's', 'y', 'z', 'u', 'Z', 'e', 'w' codes all
; 830  :        need to be cleaned up! */
; 831  : 
; 832  :     case 'y': {/* any buffer-like object, but not PyUnicode */
; 833  :         void **p = (void **)va_arg(*p_va, char **);

  01053	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0105b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0105e	48 83 c0 08	 add	 rax, 8
  01062	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0106a	48 89 01	 mov	 QWORD PTR [rcx], rax
  0106d	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01078	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0107c	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR p$21144[rsp], rax

; 834  :         char *buf;
; 835  :         Py_ssize_t count;
; 836  :         if (*format == '*') {

  01084	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  01089	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0108c	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0108f	0f 85 a6 00 00
	00		 jne	 $LN127@convertsim

; 837  :             if (getbuffer(arg, (Py_buffer*)p, &buf) < 0)

  01095	4c 8d 84 24 78
	01 00 00	 lea	 r8, QWORD PTR buf$21156[rsp]
  0109d	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR p$21144[rsp]
  010a5	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  010ad	e8 00 00 00 00	 call	 getbuffer
  010b2	85 c0		 test	 eax, eax
  010b4	7d 2a		 jge	 SHORT $LN126@convertsim

; 838  :                 return converterr(buf, arg, msgbuf, bufsize);

  010b6	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  010be	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  010c6	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  010ce	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$21156[rsp]
  010d6	e8 00 00 00 00	 call	 converterr
  010db	e9 46 1b 00 00	 jmp	 $LN209@convertsim
$LN126@convertsim:

; 839  :             format++;

  010e0	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  010e5	48 ff c0	 inc	 rax
  010e8	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 840  :             if (addcleanup(p, freelist, cleanup_buffer)) {

  010ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cleanup_buffer
  010f4	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR freelist$[rsp]
  010fc	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR p$21144[rsp]
  01104	e8 00 00 00 00	 call	 addcleanup
  01109	85 c0		 test	 eax, eax
  0110b	74 29		 je	 SHORT $LN125@convertsim

; 841  :                 return converterr(
; 842  :                     "(cleanup problem)",
; 843  :                     arg, msgbuf, bufsize);

  0110d	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01115	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  0111d	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  0112c	e8 00 00 00 00	 call	 converterr
  01131	e9 f0 1a 00 00	 jmp	 $LN209@convertsim
$LN125@convertsim:

; 844  :             }
; 845  :             break;

  01136	e9 d9 1a 00 00	 jmp	 $LN207@convertsim
$LN127@convertsim:

; 846  :         }
; 847  :         count = convertbuffer(arg, p, &buf);

  0113b	4c 8d 84 24 78
	01 00 00	 lea	 r8, QWORD PTR buf$21156[rsp]
  01143	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR p$21144[rsp]
  0114b	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  01153	e8 00 00 00 00	 call	 convertbuffer
  01158	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR count$21157[rsp], rax

; 848  :         if (count < 0)

  01160	48 83 bc 24 70
	01 00 00 00	 cmp	 QWORD PTR count$21157[rsp], 0
  01169	7d 2a		 jge	 SHORT $LN124@convertsim

; 849  :             return converterr(buf, arg, msgbuf, bufsize);

  0116b	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01173	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  0117b	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01183	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$21156[rsp]
  0118b	e8 00 00 00 00	 call	 converterr
  01190	e9 91 1a 00 00	 jmp	 $LN209@convertsim
$LN124@convertsim:

; 850  :         if (*format == '#') {

  01195	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  0119a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0119d	83 f8 23	 cmp	 eax, 35			; 00000023H
  011a0	0f 85 17 01 00
	00		 jne	 $LN123@convertsim

; 851  :             FETCH_SIZE;

  011a6	48 c7 84 24 88
	01 00 00 00 00
	00 00		 mov	 QWORD PTR q$21165[rsp], 0
  011b2	48 c7 84 24 80
	01 00 00 00 00
	00 00		 mov	 QWORD PTR q2$21167[rsp], 0
  011be	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  011c5	83 e0 02	 and	 eax, 2
  011c8	85 c0		 test	 eax, eax
  011ca	74 33		 je	 SHORT $LN122@convertsim
  011cc	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  011d4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011d7	48 83 c0 08	 add	 rax, 8
  011db	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  011e3	48 89 01	 mov	 QWORD PTR [rcx], rax
  011e6	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  011ee	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011f1	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  011f5	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR q2$21167[rsp], rax
  011fd	eb 31		 jmp	 SHORT $LN121@convertsim
$LN122@convertsim:
  011ff	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01207	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0120a	48 83 c0 08	 add	 rax, 8
  0120e	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  01216	48 89 01	 mov	 QWORD PTR [rcx], rax
  01219	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01221	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01224	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01228	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR q$21165[rsp], rax
$LN121@convertsim:

; 852  :             STORE_SIZE(count);

  01230	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  01237	83 e0 02	 and	 eax, 2
  0123a	85 c0		 test	 eax, eax
  0123c	74 15		 je	 SHORT $LN120@convertsim
  0123e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR q2$21167[rsp]
  01246	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR count$21157[rsp]
  0124e	48 89 08	 mov	 QWORD PTR [rax], rcx
  01251	eb 5b		 jmp	 SHORT $LN119@convertsim
$LN120@convertsim:
  01253	48 81 bc 24 70
	01 00 00 ff ff
	ff 7f		 cmp	 QWORD PTR count$21157[rsp], 2147483647 ; 7fffffffH
  0125f	7e 3c		 jle	 SHORT $LN118@convertsim
  01261	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@
  01268	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0126f	e8 00 00 00 00	 call	 PyErr_SetString
  01274	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  0127c	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01284	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  0128c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  01293	e8 00 00 00 00	 call	 converterr
  01298	e9 89 19 00 00	 jmp	 $LN209@convertsim
$LN118@convertsim:
  0129d	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR q$21165[rsp]
  012a5	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR count$21157[rsp]
  012ac	89 08		 mov	 DWORD PTR [rax], ecx
$LN119@convertsim:

; 853  :             format++;

  012ae	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  012b3	48 ff c0	 inc	 rax
  012b6	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 854  :         } else {

  012bb	eb 43		 jmp	 SHORT $LN117@convertsim
$LN123@convertsim:

; 855  :             if (strlen(*p) != count)

  012bd	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR p$21144[rsp]
  012c5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  012c8	e8 00 00 00 00	 call	 strlen
  012cd	48 3b 84 24 70
	01 00 00	 cmp	 rax, QWORD PTR count$21157[rsp]
  012d5	74 29		 je	 SHORT $LN116@convertsim

; 856  :                 return converterr(
; 857  :                     "bytes without null bytes",
; 858  :                     arg, msgbuf, bufsize);

  012d7	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  012df	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  012e7	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  012ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@KKHLFOBF@bytes?5without?5null?5bytes?$AA@
  012f6	e8 00 00 00 00	 call	 converterr
  012fb	e9 26 19 00 00	 jmp	 $LN209@convertsim
$LN116@convertsim:
$LN117@convertsim:

; 859  :         }
; 860  :         break;

  01300	e9 0f 19 00 00	 jmp	 $LN207@convertsim
$LN115@convertsim:

; 861  :     }
; 862  : 
; 863  :     case 's': /* text string */
; 864  :     case 'z': /* text string or None */
; 865  :     {
; 866  :         if (*format == '*') {

  01305	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  0130a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0130d	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  01310	0f 85 b6 01 00
	00		 jne	 $LN114@convertsim

; 867  :             /* "s*" or "z*" */
; 868  :             Py_buffer *p = (Py_buffer *)va_arg(*p_va, Py_buffer *);

  01316	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0131e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01321	48 83 c0 08	 add	 rax, 8
  01325	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0132d	48 89 01	 mov	 QWORD PTR [rcx], rax
  01330	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01338	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0133b	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0133f	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR p$21200[rsp], rax

; 869  : 
; 870  :             if (c == 'z' && arg == Py_None)

  01347	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  0134c	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  0134f	75 3b		 jne	 SHORT $LN113@convertsim
  01351	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  01358	48 39 84 24 60
	03 00 00	 cmp	 QWORD PTR arg$[rsp], rax
  01360	75 2a		 jne	 SHORT $LN113@convertsim

; 871  :                 PyBuffer_FillInfo(p, NULL, NULL, 0, 1, 0);

  01362	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0136a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  01372	45 33 c9	 xor	 r9d, r9d
  01375	45 33 c0	 xor	 r8d, r8d
  01378	33 d2		 xor	 edx, edx
  0137a	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR p$21200[rsp]
  01382	e8 00 00 00 00	 call	 PyBuffer_FillInfo
  01387	e9 e5 00 00 00	 jmp	 $LN112@convertsim
$LN113@convertsim:

; 872  :             else if (PyUnicode_Check(arg)) {

  0138c	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  01394	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01398	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0139e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  013a3	85 c0		 test	 eax, eax
  013a5	74 7f		 je	 SHORT $LN111@convertsim

; 873  :                 Py_ssize_t len;
; 874  :                 sarg = PyUnicode_AsUTF8AndSize(arg, &len);

  013a7	48 8d 94 24 98
	01 00 00	 lea	 rdx, QWORD PTR len$21218[rsp]
  013af	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  013b7	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  013bc	48 89 44 24 30	 mov	 QWORD PTR sarg$[rsp], rax

; 875  :                 if (sarg == NULL)

  013c1	48 83 7c 24 30
	00		 cmp	 QWORD PTR sarg$[rsp], 0
  013c7	75 29		 jne	 SHORT $LN110@convertsim

; 876  :                     return converterr(CONV_UNICODE,
; 877  :                                       arg, msgbuf, bufsize);

  013c9	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  013d1	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  013d9	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  013e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@
  013e8	e8 00 00 00 00	 call	 converterr
  013ed	e9 34 18 00 00	 jmp	 $LN209@convertsim
$LN110@convertsim:

; 878  :                 PyBuffer_FillInfo(p, arg, sarg, len, 1, 0);

  013f2	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  013fa	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  01402	4c 8b 8c 24 98
	01 00 00	 mov	 r9, QWORD PTR len$21218[rsp]
  0140a	4c 8b 44 24 30	 mov	 r8, QWORD PTR sarg$[rsp]
  0140f	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01417	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR p$21200[rsp]
  0141f	e8 00 00 00 00	 call	 PyBuffer_FillInfo

; 879  :             }
; 880  :             else { /* any buffer-like object */

  01424	eb 4b		 jmp	 SHORT $LN109@convertsim
$LN111@convertsim:

; 881  :                 char *buf;
; 882  :                 if (getbuffer(arg, p, &buf) < 0)

  01426	4c 8d 84 24 a0
	01 00 00	 lea	 r8, QWORD PTR buf$21223[rsp]
  0142e	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR p$21200[rsp]
  01436	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  0143e	e8 00 00 00 00	 call	 getbuffer
  01443	85 c0		 test	 eax, eax
  01445	7d 2a		 jge	 SHORT $LN108@convertsim

; 883  :                     return converterr(buf, arg, msgbuf, bufsize);

  01447	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  0144f	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01457	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  0145f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR buf$21223[rsp]
  01467	e8 00 00 00 00	 call	 converterr
  0146c	e9 b5 17 00 00	 jmp	 $LN209@convertsim
$LN108@convertsim:
$LN109@convertsim:
$LN112@convertsim:

; 884  :             }
; 885  :             if (addcleanup(p, freelist, cleanup_buffer)) {

  01471	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cleanup_buffer
  01478	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR freelist$[rsp]
  01480	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR p$21200[rsp]
  01488	e8 00 00 00 00	 call	 addcleanup
  0148d	85 c0		 test	 eax, eax
  0148f	74 29		 je	 SHORT $LN107@convertsim

; 886  :                 return converterr(
; 887  :                     "(cleanup problem)",
; 888  :                     arg, msgbuf, bufsize);

  01491	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01499	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  014a1	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  014a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  014b0	e8 00 00 00 00	 call	 converterr
  014b5	e9 6c 17 00 00	 jmp	 $LN209@convertsim
$LN107@convertsim:

; 889  :             }
; 890  :             format++;

  014ba	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  014bf	48 ff c0	 inc	 rax
  014c2	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax
  014c7	e9 12 05 00 00	 jmp	 $LN106@convertsim
$LN114@convertsim:

; 891  :         } else if (*format == '#') { /* any buffer-like object */

  014cc	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  014d1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  014d4	83 f8 23	 cmp	 eax, 35			; 00000023H
  014d7	0f 85 48 03 00
	00		 jne	 $LN105@convertsim

; 892  :             /* "s#" or "z#" */
; 893  :             void **p = (void **)va_arg(*p_va, char **);

  014dd	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  014e5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  014e8	48 83 c0 08	 add	 rax, 8
  014ec	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  014f4	48 89 01	 mov	 QWORD PTR [rcx], rax
  014f7	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  014ff	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01502	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01506	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR p$21228[rsp], rax

; 894  :             FETCH_SIZE;

  0150e	48 c7 84 24 b8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR q$21240[rsp], 0
  0151a	48 c7 84 24 b0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR q2$21242[rsp], 0
  01526	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0152d	83 e0 02	 and	 eax, 2
  01530	85 c0		 test	 eax, eax
  01532	74 33		 je	 SHORT $LN104@convertsim
  01534	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0153c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0153f	48 83 c0 08	 add	 rax, 8
  01543	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0154b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0154e	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01556	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01559	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0155d	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR q2$21242[rsp], rax
  01565	eb 31		 jmp	 SHORT $LN103@convertsim
$LN104@convertsim:
  01567	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0156f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01572	48 83 c0 08	 add	 rax, 8
  01576	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0157e	48 89 01	 mov	 QWORD PTR [rcx], rax
  01581	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01589	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0158c	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01590	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR q$21240[rsp], rax
$LN103@convertsim:

; 895  : 
; 896  :             if (c == 'z' && arg == Py_None) {

  01598	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  0159d	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  015a0	0f 85 98 00 00
	00		 jne	 $LN102@convertsim
  015a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  015ad	48 39 84 24 60
	03 00 00	 cmp	 QWORD PTR arg$[rsp], rax
  015b5	0f 85 83 00 00
	00		 jne	 $LN102@convertsim

; 897  :                 *p = NULL;

  015bb	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR p$21228[rsp]
  015c3	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 898  :                 STORE_SIZE(0);

  015ca	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  015d1	83 e0 02	 and	 eax, 2
  015d4	85 c0		 test	 eax, eax
  015d6	74 11		 je	 SHORT $LN101@convertsim
  015d8	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR q2$21242[rsp]
  015e0	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  015e7	eb 50		 jmp	 SHORT $LN100@convertsim
$LN101@convertsim:
  015e9	33 c0		 xor	 eax, eax
  015eb	85 c0		 test	 eax, eax
  015ed	74 3c		 je	 SHORT $LN99@convertsim
  015ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@
  015f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  015fd	e8 00 00 00 00	 call	 PyErr_SetString
  01602	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  0160a	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01612	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  0161a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  01621	e8 00 00 00 00	 call	 converterr
  01626	e9 fb 15 00 00	 jmp	 $LN209@convertsim
$LN99@convertsim:
  0162b	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR q$21240[rsp]
  01633	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN100@convertsim:
  01639	e9 d5 01 00 00	 jmp	 $LN98@convertsim
$LN102@convertsim:

; 899  :             }
; 900  :             else if (PyUnicode_Check(arg)) {

  0163e	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  01646	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0164a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01650	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01655	85 c0		 test	 eax, eax
  01657	0f 84 de 00 00
	00		 je	 $LN97@convertsim

; 901  :                 Py_ssize_t len;
; 902  :                 sarg = PyUnicode_AsUTF8AndSize(arg, &len);

  0165d	48 8d 94 24 c0
	01 00 00	 lea	 rdx, QWORD PTR len$21274[rsp]
  01665	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  0166d	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  01672	48 89 44 24 30	 mov	 QWORD PTR sarg$[rsp], rax

; 903  :                 if (sarg == NULL)

  01677	48 83 7c 24 30
	00		 cmp	 QWORD PTR sarg$[rsp], 0
  0167d	75 29		 jne	 SHORT $LN96@convertsim

; 904  :                     return converterr(CONV_UNICODE,
; 905  :                                       arg, msgbuf, bufsize);

  0167f	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01687	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  0168f	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01697	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@
  0169e	e8 00 00 00 00	 call	 converterr
  016a3	e9 7e 15 00 00	 jmp	 $LN209@convertsim
$LN96@convertsim:

; 906  :                 *p = sarg;

  016a8	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR p$21228[rsp]
  016b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sarg$[rsp]
  016b5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 907  :                 STORE_SIZE(len);

  016b8	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  016bf	83 e0 02	 and	 eax, 2
  016c2	85 c0		 test	 eax, eax
  016c4	74 15		 je	 SHORT $LN95@convertsim
  016c6	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR q2$21242[rsp]
  016ce	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR len$21274[rsp]
  016d6	48 89 08	 mov	 QWORD PTR [rax], rcx
  016d9	eb 5b		 jmp	 SHORT $LN94@convertsim
$LN95@convertsim:
  016db	48 81 bc 24 c0
	01 00 00 ff ff
	ff 7f		 cmp	 QWORD PTR len$21274[rsp], 2147483647 ; 7fffffffH
  016e7	7e 3c		 jle	 SHORT $LN93@convertsim
  016e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@
  016f0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  016f7	e8 00 00 00 00	 call	 PyErr_SetString
  016fc	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01704	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  0170c	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01714	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0171b	e8 00 00 00 00	 call	 converterr
  01720	e9 01 15 00 00	 jmp	 $LN209@convertsim
$LN93@convertsim:
  01725	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR q$21240[rsp]
  0172d	8b 8c 24 c0 01
	00 00		 mov	 ecx, DWORD PTR len$21274[rsp]
  01734	89 08		 mov	 DWORD PTR [rax], ecx
$LN94@convertsim:

; 908  :             }
; 909  :             else { /* any buffer-like object */

  01736	e9 d8 00 00 00	 jmp	 $LN92@convertsim
$LN97@convertsim:

; 910  :                 /* XXX Really? */
; 911  :                 char *buf;
; 912  :                 Py_ssize_t count = convertbuffer(arg, p, &buf);

  0173b	4c 8d 84 24 d0
	01 00 00	 lea	 r8, QWORD PTR buf$21281[rsp]
  01743	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR p$21228[rsp]
  0174b	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  01753	e8 00 00 00 00	 call	 convertbuffer
  01758	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR count$21282[rsp], rax

; 913  :                 if (count < 0)

  01760	48 83 bc 24 c8
	01 00 00 00	 cmp	 QWORD PTR count$21282[rsp], 0
  01769	7d 2a		 jge	 SHORT $LN91@convertsim

; 914  :                     return converterr(buf, arg, msgbuf, bufsize);

  0176b	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01773	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  0177b	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01783	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR buf$21281[rsp]
  0178b	e8 00 00 00 00	 call	 converterr
  01790	e9 91 14 00 00	 jmp	 $LN209@convertsim
$LN91@convertsim:

; 915  :                 STORE_SIZE(count);

  01795	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0179c	83 e0 02	 and	 eax, 2
  0179f	85 c0		 test	 eax, eax
  017a1	74 15		 je	 SHORT $LN90@convertsim
  017a3	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR q2$21242[rsp]
  017ab	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR count$21282[rsp]
  017b3	48 89 08	 mov	 QWORD PTR [rax], rcx
  017b6	eb 5b		 jmp	 SHORT $LN89@convertsim
$LN90@convertsim:
  017b8	48 81 bc 24 c8
	01 00 00 ff ff
	ff 7f		 cmp	 QWORD PTR count$21282[rsp], 2147483647 ; 7fffffffH
  017c4	7e 3c		 jle	 SHORT $LN88@convertsim
  017c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@
  017cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  017d4	e8 00 00 00 00	 call	 PyErr_SetString
  017d9	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  017e1	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  017e9	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  017f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  017f8	e8 00 00 00 00	 call	 converterr
  017fd	e9 24 14 00 00	 jmp	 $LN209@convertsim
$LN88@convertsim:
  01802	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR q$21240[rsp]
  0180a	8b 8c 24 c8 01
	00 00		 mov	 ecx, DWORD PTR count$21282[rsp]
  01811	89 08		 mov	 DWORD PTR [rax], ecx
$LN89@convertsim:
$LN92@convertsim:
$LN98@convertsim:

; 916  :             }
; 917  :             format++;

  01813	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  01818	48 ff c0	 inc	 rax
  0181b	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 918  :         } else {

  01820	e9 b9 01 00 00	 jmp	 $LN87@convertsim
$LN105@convertsim:

; 919  :             /* "s" or "z" */
; 920  :             char **p = va_arg(*p_va, char **);

  01825	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0182d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01830	48 83 c0 08	 add	 rax, 8
  01834	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0183c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0183f	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01847	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0184a	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0184e	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR p$21288[rsp], rax

; 921  :             Py_ssize_t len;
; 922  :             sarg = NULL;

  01856	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR sarg$[rsp], 0

; 923  : 
; 924  :             if (c == 'z' && arg == Py_None)

  0185f	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  01864	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  01867	75 25		 jne	 SHORT $LN86@convertsim
  01869	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  01870	48 39 84 24 60
	03 00 00	 cmp	 QWORD PTR arg$[rsp], rax
  01878	75 14		 jne	 SHORT $LN86@convertsim

; 925  :                 *p = NULL;

  0187a	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$21288[rsp]
  01882	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  01889	e9 cc 00 00 00	 jmp	 $LN85@convertsim
$LN86@convertsim:

; 926  :             else if (PyUnicode_Check(arg)) {

  0188e	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  01896	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0189a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  018a0	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  018a5	85 c0		 test	 eax, eax
  018a7	74 5d		 je	 SHORT $LN84@convertsim

; 927  :                 sarg = PyUnicode_AsUTF8AndSize(arg, &len);

  018a9	48 8d 94 24 e0
	01 00 00	 lea	 rdx, QWORD PTR len$21299[rsp]
  018b1	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  018b9	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  018be	48 89 44 24 30	 mov	 QWORD PTR sarg$[rsp], rax

; 928  :                 if (sarg == NULL)

  018c3	48 83 7c 24 30
	00		 cmp	 QWORD PTR sarg$[rsp], 0
  018c9	75 29		 jne	 SHORT $LN83@convertsim

; 929  :                     return converterr(CONV_UNICODE,
; 930  :                                       arg, msgbuf, bufsize);

  018cb	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  018d3	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  018db	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  018e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@MCHPFBGL@?$CIunicode?5conversion?5error?$CJ?$AA@
  018ea	e8 00 00 00 00	 call	 converterr
  018ef	e9 32 13 00 00	 jmp	 $LN209@convertsim
$LN83@convertsim:

; 931  :                 *p = sarg;

  018f4	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$21288[rsp]
  018fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sarg$[rsp]
  01901	48 89 08	 mov	 QWORD PTR [rax], rcx

; 932  :             }
; 933  :             else

  01904	eb 54		 jmp	 SHORT $LN82@convertsim
$LN84@convertsim:

; 934  :                 return converterr(c == 'z' ? "str or None" : "str",
; 935  :                                   arg, msgbuf, bufsize);

  01906	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  0190b	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  0190e	75 11		 jne	 SHORT $LN234@convertsim
  01910	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@ECJNJCHF@str?5or?5None?$AA@
  01917	48 89 84 24 f0
	02 00 00	 mov	 QWORD PTR tv701[rsp], rax
  0191f	eb 0f		 jmp	 SHORT $LN235@convertsim
$LN234@convertsim:
  01921	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03OJMAPEGJ@str?$AA@
  01928	48 89 84 24 f0
	02 00 00	 mov	 QWORD PTR tv701[rsp], rax
$LN235@convertsim:
  01930	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01938	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01940	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01948	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR tv701[rsp]
  01950	e8 00 00 00 00	 call	 converterr
  01955	e9 cc 12 00 00	 jmp	 $LN209@convertsim
$LN82@convertsim:
$LN85@convertsim:

; 936  :             if (*p != NULL && sarg != NULL && (Py_ssize_t) strlen(*p) != len)

  0195a	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$21288[rsp]
  01962	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01966	74 76		 je	 SHORT $LN81@convertsim
  01968	48 83 7c 24 30
	00		 cmp	 QWORD PTR sarg$[rsp], 0
  0196e	74 6e		 je	 SHORT $LN81@convertsim
  01970	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$21288[rsp]
  01978	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0197b	e8 00 00 00 00	 call	 strlen
  01980	48 3b 84 24 e0
	01 00 00	 cmp	 rax, QWORD PTR len$21299[rsp]
  01988	74 54		 je	 SHORT $LN81@convertsim

; 937  :                 return converterr(
; 938  :                     c == 'z' ? "str without null characters or None"
; 939  :                              : "str without null characters",
; 940  :                     arg, msgbuf, bufsize);

  0198a	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  0198f	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  01992	75 11		 jne	 SHORT $LN236@convertsim
  01994	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@NNHOCDLF@str?5without?5null?5characters?5or?5N@
  0199b	48 89 84 24 f8
	02 00 00	 mov	 QWORD PTR tv714[rsp], rax
  019a3	eb 0f		 jmp	 SHORT $LN237@convertsim
$LN236@convertsim:
  019a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@CLLMJED@str?5without?5null?5characters?$AA@
  019ac	48 89 84 24 f8
	02 00 00	 mov	 QWORD PTR tv714[rsp], rax
$LN237@convertsim:
  019b4	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  019bc	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  019c4	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  019cc	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR tv714[rsp]
  019d4	e8 00 00 00 00	 call	 converterr
  019d9	e9 48 12 00 00	 jmp	 $LN209@convertsim
$LN81@convertsim:
$LN87@convertsim:
$LN106@convertsim:

; 941  :         }
; 942  :         break;

  019de	e9 31 12 00 00	 jmp	 $LN207@convertsim
$LN80@convertsim:

; 943  :     }
; 944  : 
; 945  :     case 'u': /* raw unicode buffer (Py_UNICODE *) */
; 946  :     case 'Z': /* raw unicode buffer or None */
; 947  :     {
; 948  :         Py_UNICODE **p = va_arg(*p_va, Py_UNICODE **);

  019e3	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  019eb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  019ee	48 83 c0 08	 add	 rax, 8
  019f2	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  019fa	48 89 01	 mov	 QWORD PTR [rcx], rax
  019fd	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01a05	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01a08	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01a0c	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR p$21318[rsp], rax

; 949  : 
; 950  :         if (*format == '#') { /* any buffer-like object */

  01a14	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  01a19	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01a1c	83 f8 23	 cmp	 eax, 35			; 00000023H
  01a1f	0f 85 45 02 00
	00		 jne	 $LN79@convertsim

; 951  :             /* "s#" or "Z#" */
; 952  :             FETCH_SIZE;

  01a25	48 c7 84 24 f8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR q$21330[rsp], 0
  01a31	48 c7 84 24 f0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR q2$21332[rsp], 0
  01a3d	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  01a44	83 e0 02	 and	 eax, 2
  01a47	85 c0		 test	 eax, eax
  01a49	74 33		 je	 SHORT $LN78@convertsim
  01a4b	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01a53	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01a56	48 83 c0 08	 add	 rax, 8
  01a5a	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  01a62	48 89 01	 mov	 QWORD PTR [rcx], rax
  01a65	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01a6d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01a70	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01a74	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR q2$21332[rsp], rax
  01a7c	eb 31		 jmp	 SHORT $LN77@convertsim
$LN78@convertsim:
  01a7e	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01a86	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01a89	48 83 c0 08	 add	 rax, 8
  01a8d	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  01a95	48 89 01	 mov	 QWORD PTR [rcx], rax
  01a98	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01aa0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01aa3	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01aa7	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR q$21330[rsp], rax
$LN77@convertsim:

; 953  : 
; 954  :             if (c == 'Z' && arg == Py_None) {

  01aaf	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  01ab4	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  01ab7	0f 85 98 00 00
	00		 jne	 $LN76@convertsim
  01abd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  01ac4	48 39 84 24 60
	03 00 00	 cmp	 QWORD PTR arg$[rsp], rax
  01acc	0f 85 83 00 00
	00		 jne	 $LN76@convertsim

; 955  :                 *p = NULL;

  01ad2	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR p$21318[rsp]
  01ada	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 956  :                 STORE_SIZE(0);

  01ae1	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  01ae8	83 e0 02	 and	 eax, 2
  01aeb	85 c0		 test	 eax, eax
  01aed	74 11		 je	 SHORT $LN75@convertsim
  01aef	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR q2$21332[rsp]
  01af7	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  01afe	eb 50		 jmp	 SHORT $LN74@convertsim
$LN75@convertsim:
  01b00	33 c0		 xor	 eax, eax
  01b02	85 c0		 test	 eax, eax
  01b04	74 3c		 je	 SHORT $LN73@convertsim
  01b06	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@
  01b0d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  01b14	e8 00 00 00 00	 call	 PyErr_SetString
  01b19	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01b21	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01b29	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01b31	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  01b38	e8 00 00 00 00	 call	 converterr
  01b3d	e9 e4 10 00 00	 jmp	 $LN209@convertsim
$LN73@convertsim:
  01b42	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR q$21330[rsp]
  01b4a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN74@convertsim:
  01b50	e9 03 01 00 00	 jmp	 $LN72@convertsim
$LN76@convertsim:

; 957  :             }
; 958  :             else if (PyUnicode_Check(arg)) {

  01b55	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  01b5d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01b61	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01b67	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01b6c	85 c0		 test	 eax, eax
  01b6e	0f 84 bb 00 00
	00		 je	 $LN71@convertsim

; 959  :                 Py_ssize_t len;
; 960  :                 *p = PyUnicode_AsUnicodeAndSize(arg, &len);

  01b74	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR len$21364[rsp]
  01b7c	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  01b84	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeAndSize
  01b89	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR p$21318[rsp]
  01b91	48 89 01	 mov	 QWORD PTR [rcx], rax

; 961  :                 if (*p == NULL)

  01b94	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR p$21318[rsp]
  01b9c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01ba0	75 0d		 jne	 SHORT $LN70@convertsim

; 962  :                     RETURN_ERR_OCCURRED;

  01ba2	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  01baa	e9 77 10 00 00	 jmp	 $LN209@convertsim
$LN70@convertsim:

; 963  :                 STORE_SIZE(len);

  01baf	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  01bb6	83 e0 02	 and	 eax, 2
  01bb9	85 c0		 test	 eax, eax
  01bbb	74 15		 je	 SHORT $LN69@convertsim
  01bbd	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR q2$21332[rsp]
  01bc5	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR len$21364[rsp]
  01bcd	48 89 08	 mov	 QWORD PTR [rax], rcx
  01bd0	eb 5b		 jmp	 SHORT $LN68@convertsim
$LN69@convertsim:
  01bd2	48 81 bc 24 00
	02 00 00 ff ff
	ff 7f		 cmp	 QWORD PTR len$21364[rsp], 2147483647 ; 7fffffffH
  01bde	7e 3c		 jle	 SHORT $LN67@convertsim
  01be0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@
  01be7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  01bee	e8 00 00 00 00	 call	 PyErr_SetString
  01bf3	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01bfb	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01c03	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01c0b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  01c12	e8 00 00 00 00	 call	 converterr
  01c17	e9 0a 10 00 00	 jmp	 $LN209@convertsim
$LN67@convertsim:
  01c1c	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR q$21330[rsp]
  01c24	8b 8c 24 00 02
	00 00		 mov	 ecx, DWORD PTR len$21364[rsp]
  01c2b	89 08		 mov	 DWORD PTR [rax], ecx
$LN68@convertsim:

; 964  :             }
; 965  :             else

  01c2d	eb 29		 jmp	 SHORT $LN66@convertsim
$LN71@convertsim:

; 966  :                 return converterr("str or None", arg, msgbuf, bufsize);

  01c2f	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01c37	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01c3f	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01c47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@ECJNJCHF@str?5or?5None?$AA@
  01c4e	e8 00 00 00 00	 call	 converterr
  01c53	e9 ce 0f 00 00	 jmp	 $LN209@convertsim
$LN66@convertsim:
$LN72@convertsim:

; 967  :             format++;

  01c58	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  01c5d	48 ff c0	 inc	 rax
  01c60	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 968  :         } else {

  01c65	e9 22 01 00 00	 jmp	 $LN65@convertsim
$LN79@convertsim:

; 969  :             /* "s" or "Z" */
; 970  :             if (c == 'Z' && arg == Py_None)

  01c6a	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  01c6f	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  01c72	75 25		 jne	 SHORT $LN64@convertsim
  01c74	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  01c7b	48 39 84 24 60
	03 00 00	 cmp	 QWORD PTR arg$[rsp], rax
  01c83	75 14		 jne	 SHORT $LN64@convertsim

; 971  :                 *p = NULL;

  01c85	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR p$21318[rsp]
  01c8d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  01c94	e9 f3 00 00 00	 jmp	 $LN63@convertsim
$LN64@convertsim:

; 972  :             else if (PyUnicode_Check(arg)) {

  01c99	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  01ca1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01ca5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01cab	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01cb0	85 c0		 test	 eax, eax
  01cb2	0f 84 80 00 00
	00		 je	 $LN62@convertsim

; 973  :                 Py_ssize_t len;
; 974  :                 *p = PyUnicode_AsUnicodeAndSize(arg, &len);

  01cb8	48 8d 94 24 08
	02 00 00	 lea	 rdx, QWORD PTR len$21377[rsp]
  01cc0	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  01cc8	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeAndSize
  01ccd	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR p$21318[rsp]
  01cd5	48 89 01	 mov	 QWORD PTR [rcx], rax

; 975  :                 if (*p == NULL)

  01cd8	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR p$21318[rsp]
  01ce0	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01ce4	75 0d		 jne	 SHORT $LN61@convertsim

; 976  :                     RETURN_ERR_OCCURRED;

  01ce6	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  01cee	e9 33 0f 00 00	 jmp	 $LN209@convertsim
$LN61@convertsim:

; 977  :                 if (Py_UNICODE_strlen(*p) != len)

  01cf3	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR p$21318[rsp]
  01cfb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  01cfe	e8 00 00 00 00	 call	 Py_UNICODE_strlen
  01d03	48 3b 84 24 08
	02 00 00	 cmp	 rax, QWORD PTR len$21377[rsp]
  01d0b	74 29		 je	 SHORT $LN60@convertsim

; 978  :                     return converterr(
; 979  :                         "str without null characters or None",
; 980  :                         arg, msgbuf, bufsize);

  01d0d	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01d15	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01d1d	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01d25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@NNHOCDLF@str?5without?5null?5characters?5or?5N@
  01d2c	e8 00 00 00 00	 call	 converterr
  01d31	e9 f0 0e 00 00	 jmp	 $LN209@convertsim
$LN60@convertsim:

; 981  :             } else

  01d36	eb 54		 jmp	 SHORT $LN59@convertsim
$LN62@convertsim:

; 982  :                 return converterr(c == 'Z' ? "str or None" : "str",
; 983  :                                   arg, msgbuf, bufsize);

  01d38	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  01d3d	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  01d40	75 11		 jne	 SHORT $LN238@convertsim
  01d42	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@ECJNJCHF@str?5or?5None?$AA@
  01d49	48 89 84 24 00
	03 00 00	 mov	 QWORD PTR tv788[rsp], rax
  01d51	eb 0f		 jmp	 SHORT $LN239@convertsim
$LN238@convertsim:
  01d53	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03OJMAPEGJ@str?$AA@
  01d5a	48 89 84 24 00
	03 00 00	 mov	 QWORD PTR tv788[rsp], rax
$LN239@convertsim:
  01d62	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01d6a	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01d72	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01d7a	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR tv788[rsp]
  01d82	e8 00 00 00 00	 call	 converterr
  01d87	e9 9a 0e 00 00	 jmp	 $LN209@convertsim
$LN59@convertsim:
$LN63@convertsim:
$LN65@convertsim:

; 984  :         }
; 985  :         break;

  01d8c	e9 83 0e 00 00	 jmp	 $LN207@convertsim
$LN58@convertsim:

; 986  :     }
; 987  : 
; 988  :     case 'e': {/* encoded string */
; 989  :         char **buffer;
; 990  :         const char *encoding;
; 991  :         PyObject *s;
; 992  :         int recode_strings;
; 993  :         Py_ssize_t size;
; 994  :         const char *ptr;
; 995  : 
; 996  :         /* Get 'e' parameter: the encoding name */
; 997  :         encoding = (const char *)va_arg(*p_va, const char *);

  01d91	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01d99	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01d9c	48 83 c0 08	 add	 rax, 8
  01da0	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  01da8	48 89 01	 mov	 QWORD PTR [rcx], rax
  01dab	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01db3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01db6	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01dba	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR encoding$21384[rsp], rax

; 998  :         if (encoding == NULL)

  01dc2	48 83 bc 24 30
	02 00 00 00	 cmp	 QWORD PTR encoding$21384[rsp], 0
  01dcb	75 0d		 jne	 SHORT $LN57@convertsim

; 999  :             encoding = PyUnicode_GetDefaultEncoding();

  01dcd	e8 00 00 00 00	 call	 PyUnicode_GetDefaultEncoding
  01dd2	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR encoding$21384[rsp], rax
$LN57@convertsim:

; 1000 : 
; 1001 :         /* Get output buffer parameter:
; 1002 :            's' (recode all objects via Unicode) or
; 1003 :            't' (only recode non-string objects)
; 1004 :         */
; 1005 :         if (*format == 's')

  01dda	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  01ddf	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01de2	83 f8 73	 cmp	 eax, 115		; 00000073H
  01de5	75 0d		 jne	 SHORT $LN56@convertsim

; 1006 :             recode_strings = 1;

  01de7	c7 84 24 28 02
	00 00 01 00 00
	00		 mov	 DWORD PTR recode_strings$21386[rsp], 1
  01df2	eb 43		 jmp	 SHORT $LN55@convertsim
$LN56@convertsim:

; 1007 :         else if (*format == 't')

  01df4	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  01df9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01dfc	83 f8 74	 cmp	 eax, 116		; 00000074H
  01dff	75 0d		 jne	 SHORT $LN54@convertsim

; 1008 :             recode_strings = 0;

  01e01	c7 84 24 28 02
	00 00 00 00 00
	00		 mov	 DWORD PTR recode_strings$21386[rsp], 0

; 1009 :         else

  01e0c	eb 29		 jmp	 SHORT $LN53@convertsim
$LN54@convertsim:

; 1010 :             return converterr(
; 1011 :                 "(unknown parser marker combination)",
; 1012 :                 arg, msgbuf, bufsize);

  01e0e	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01e16	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01e1e	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01e26	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@BAFKKLBH@?$CIunknown?5parser?5marker?5combinati@
  01e2d	e8 00 00 00 00	 call	 converterr
  01e32	e9 ef 0d 00 00	 jmp	 $LN209@convertsim
$LN53@convertsim:
$LN55@convertsim:

; 1013 :         buffer = (char **)va_arg(*p_va, char **);

  01e37	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01e3f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01e42	48 83 c0 08	 add	 rax, 8
  01e46	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  01e4e	48 89 01	 mov	 QWORD PTR [rcx], rax
  01e51	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  01e59	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01e5c	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  01e60	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR buffer$21383[rsp], rax

; 1014 :         format++;

  01e68	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  01e6d	48 ff c0	 inc	 rax
  01e70	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 1015 :         if (buffer == NULL)

  01e75	48 83 bc 24 38
	02 00 00 00	 cmp	 QWORD PTR buffer$21383[rsp], 0
  01e7e	75 29		 jne	 SHORT $LN52@convertsim

; 1016 :             return converterr("(buffer is NULL)",
; 1017 :                               arg, msgbuf, bufsize);

  01e80	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01e88	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01e90	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01e98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MCHFDCHO@?$CIbuffer?5is?5NULL?$CJ?$AA@
  01e9f	e8 00 00 00 00	 call	 converterr
  01ea4	e9 7d 0d 00 00	 jmp	 $LN209@convertsim
$LN52@convertsim:

; 1018 : 
; 1019 :         /* Encode object */
; 1020 :         if (!recode_strings &&
; 1021 :             (PyBytes_Check(arg) || PyByteArray_Check(arg))) {

  01ea9	83 bc 24 28 02
	00 00 00	 cmp	 DWORD PTR recode_strings$21386[rsp], 0
  01eb1	0f 85 b8 00 00
	00		 jne	 $LN51@convertsim
  01eb7	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  01ebf	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01ec3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01ec9	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  01ece	85 c0		 test	 eax, eax
  01ed0	75 31		 jne	 SHORT $LN50@convertsim
  01ed2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  01ed9	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  01ee1	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  01ee5	74 1c		 je	 SHORT $LN49@convertsim
  01ee7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  01eee	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  01ef6	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  01efa	e8 00 00 00 00	 call	 PyType_IsSubtype
  01eff	85 c0		 test	 eax, eax
  01f01	74 6c		 je	 SHORT $LN51@convertsim
$LN49@convertsim:
$LN50@convertsim:

; 1022 :             s = arg;

  01f03	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  01f0b	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR s$21385[rsp], rax

; 1023 :             Py_INCREF(s);

  01f13	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  01f1b	e8 00 00 00 00	 call	 _Py_IncRef

; 1024 :             if (PyObject_AsCharBuffer(s, &ptr, &size) < 0)

  01f20	4c 8d 84 24 20
	02 00 00	 lea	 r8, QWORD PTR size$21387[rsp]
  01f28	48 8d 94 24 18
	02 00 00	 lea	 rdx, QWORD PTR ptr$21388[rsp]
  01f30	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  01f38	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  01f3d	85 c0		 test	 eax, eax
  01f3f	7d 29		 jge	 SHORT $LN48@convertsim

; 1025 :                 return converterr("(AsCharBuffer failed)",
; 1026 :                                   arg, msgbuf, bufsize);

  01f41	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01f49	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01f51	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01f59	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@KEABMDON@?$CIAsCharBuffer?5failed?$CJ?$AA@
  01f60	e8 00 00 00 00	 call	 converterr
  01f65	e9 bc 0c 00 00	 jmp	 $LN209@convertsim
$LN48@convertsim:

; 1027 :         }
; 1028 :         else {

  01f6a	e9 ab 01 00 00	 jmp	 $LN47@convertsim
$LN51@convertsim:

; 1029 :             PyObject *u;
; 1030 : 
; 1031 :             /* Convert object to Unicode */
; 1032 :             u = PyUnicode_FromObject(arg);

  01f6f	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  01f77	e8 00 00 00 00	 call	 PyUnicode_FromObject
  01f7c	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR u$21431[rsp], rax

; 1033 :             if (u == NULL)

  01f84	48 83 bc 24 40
	02 00 00 00	 cmp	 QWORD PTR u$21431[rsp], 0
  01f8d	75 29		 jne	 SHORT $LN46@convertsim

; 1034 :                 return converterr(
; 1035 :                     "string or unicode or text buffer",
; 1036 :                     arg, msgbuf, bufsize);

  01f8f	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01f97	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  01f9f	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  01fa7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@CBNPKI@string?5or?5unicode?5or?5text?5buffer@
  01fae	e8 00 00 00 00	 call	 converterr
  01fb3	e9 6e 0c 00 00	 jmp	 $LN209@convertsim
$LN46@convertsim:

; 1037 : 
; 1038 :             /* Encode object; use default error handling */
; 1039 :             s = PyUnicode_AsEncodedString(u,
; 1040 :                                           encoding,
; 1041 :                                           NULL);

  01fb8	45 33 c0	 xor	 r8d, r8d
  01fbb	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR encoding$21384[rsp]
  01fc3	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR u$21431[rsp]
  01fcb	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString
  01fd0	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR s$21385[rsp], rax

; 1042 :             Py_DECREF(u);

  01fd8	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR u$21431[rsp]
  01fe0	e8 00 00 00 00	 call	 _Py_DecRef

; 1043 :             if (s == NULL)

  01fe5	48 83 bc 24 10
	02 00 00 00	 cmp	 QWORD PTR s$21385[rsp], 0
  01fee	75 29		 jne	 SHORT $LN45@convertsim

; 1044 :                 return converterr("(encoding failed)",
; 1045 :                                   arg, msgbuf, bufsize);

  01ff0	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  01ff8	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02000	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02008	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@ECLEOFDF@?$CIencoding?5failed?$CJ?$AA@
  0200f	e8 00 00 00 00	 call	 converterr
  02014	e9 0d 0c 00 00	 jmp	 $LN209@convertsim
$LN45@convertsim:

; 1046 :             if (!PyBytes_Check(s)) {

  02019	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$21385[rsp]
  02021	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02025	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0202b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  02030	85 c0		 test	 eax, eax
  02032	75 36		 jne	 SHORT $LN44@convertsim

; 1047 :                 Py_DECREF(s);

  02034	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  0203c	e8 00 00 00 00	 call	 _Py_DecRef

; 1048 :                 return converterr(
; 1049 :                     "(encoder failed to return bytes)",
; 1050 :                     arg, msgbuf, bufsize);

  02041	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02049	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02051	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@OMNKEOOG@?$CIencoder?5failed?5to?5return?5bytes?$CJ@
  02060	e8 00 00 00 00	 call	 converterr
  02065	e9 bc 0b 00 00	 jmp	 $LN209@convertsim
$LN44@convertsim:

; 1051 :             }
; 1052 :             size = PyBytes_GET_SIZE(s);

  0206a	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$21385[rsp]
  02072	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02076	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0207c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  02081	85 c0		 test	 eax, eax
  02083	75 1c		 jne	 SHORT $LN240@convertsim
  02085	41 b8 1c 04 00
	00		 mov	 r8d, 1052		; 0000041cH
  0208b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  02092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@PPMJPEFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
  02099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0209f	33 c0		 xor	 eax, eax
$LN240@convertsim:
  020a1	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$21385[rsp]
  020a9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  020ad	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR size$21387[rsp], rax

; 1053 :             ptr = PyBytes_AS_STRING(s);

  020b5	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$21385[rsp]
  020bd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  020c1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  020c7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  020cc	85 c0		 test	 eax, eax
  020ce	75 1c		 jne	 SHORT $LN241@convertsim
  020d0	41 b8 1d 04 00
	00		 mov	 r8d, 1053		; 0000041dH
  020d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  020dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@PPMJPEFK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
  020e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  020ea	33 c0		 xor	 eax, eax
$LN241@convertsim:
  020ec	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR s$21385[rsp]
  020f4	48 83 c0 78	 add	 rax, 120		; 00000078H
  020f8	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR ptr$21388[rsp], rax

; 1054 :             if (ptr == NULL)

  02100	48 83 bc 24 18
	02 00 00 00	 cmp	 QWORD PTR ptr$21388[rsp], 0
  02109	75 0f		 jne	 SHORT $LN43@convertsim

; 1055 :                 ptr = "";

  0210b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  02112	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR ptr$21388[rsp], rax
$LN43@convertsim:
$LN47@convertsim:

; 1056 :         }
; 1057 : 
; 1058 :         /* Write output; output is guaranteed to be 0-terminated */
; 1059 :         if (*format == '#') {

  0211a	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  0211f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  02122	83 f8 23	 cmp	 eax, 35			; 00000023H
  02125	0f 85 36 03 00
	00		 jne	 $LN42@convertsim

; 1060 :             /* Using buffer length parameter '#':
; 1061 : 
; 1062 :                - if *buffer is NULL, a new buffer of the
; 1063 :                needed size is allocated and the data
; 1064 :                copied into it; *buffer is updated to point
; 1065 :                to the new buffer; the caller is
; 1066 :                responsible for PyMem_Free()ing it after
; 1067 :                usage
; 1068 : 
; 1069 :                - if *buffer is not NULL, the data is
; 1070 :                copied to *buffer; *buffer_len has to be
; 1071 :                set to the size of the buffer on input;
; 1072 :                buffer overflow is signalled with an error;
; 1073 :                buffer has to provide enough room for the
; 1074 :                encoded string plus the trailing 0-byte
; 1075 : 
; 1076 :                - in both cases, *buffer_len is updated to
; 1077 :                the size of the buffer /excluding/ the
; 1078 :                trailing 0-byte
; 1079 : 
; 1080 :             */
; 1081 :             FETCH_SIZE;

  0212b	48 c7 84 24 50
	02 00 00 00 00
	00 00		 mov	 QWORD PTR q$21454[rsp], 0
  02137	48 c7 84 24 48
	02 00 00 00 00
	00 00		 mov	 QWORD PTR q2$21456[rsp], 0
  02143	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0214a	83 e0 02	 and	 eax, 2
  0214d	85 c0		 test	 eax, eax
  0214f	74 33		 je	 SHORT $LN41@convertsim
  02151	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02159	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0215c	48 83 c0 08	 add	 rax, 8
  02160	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  02168	48 89 01	 mov	 QWORD PTR [rcx], rax
  0216b	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02173	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02176	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0217a	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR q2$21456[rsp], rax
  02182	eb 31		 jmp	 SHORT $LN40@convertsim
$LN41@convertsim:
  02184	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0218c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0218f	48 83 c0 08	 add	 rax, 8
  02193	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0219b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0219e	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  021a6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  021a9	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  021ad	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR q$21454[rsp], rax
$LN40@convertsim:

; 1082 : 
; 1083 :             format++;

  021b5	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  021ba	48 ff c0	 inc	 rax
  021bd	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 1084 :             if (q == NULL && q2 == NULL) {

  021c2	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR q$21454[rsp], 0
  021cb	75 41		 jne	 SHORT $LN39@convertsim
  021cd	48 83 bc 24 48
	02 00 00 00	 cmp	 QWORD PTR q2$21456[rsp], 0
  021d6	75 36		 jne	 SHORT $LN39@convertsim

; 1085 :                 Py_DECREF(s);

  021d8	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  021e0	e8 00 00 00 00	 call	 _Py_DecRef

; 1086 :                 return converterr(
; 1087 :                     "(buffer_len is NULL)",
; 1088 :                     arg, msgbuf, bufsize);

  021e5	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  021ed	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  021f5	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  021fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@FDDEBFPN@?$CIbuffer_len?5is?5NULL?$CJ?$AA@
  02204	e8 00 00 00 00	 call	 converterr
  02209	e9 18 0a 00 00	 jmp	 $LN209@convertsim
$LN39@convertsim:

; 1089 :             }
; 1090 :             if (*buffer == NULL) {

  0220e	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR buffer$21383[rsp]
  02216	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0221a	0f 85 17 01 00
	00		 jne	 $LN38@convertsim

; 1091 :                 *buffer = PyMem_NEW(char, size + 1);

  02220	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR size$21387[rsp]
  02228	48 ff c0	 inc	 rax
  0222b	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  02235	48 3b c1	 cmp	 rax, rcx
  02238	76 0e		 jbe	 SHORT $LN244@convertsim
  0223a	48 c7 84 24 08
	03 00 00 00 00
	00 00		 mov	 QWORD PTR tv944[rsp], 0
  02246	eb 51		 jmp	 SHORT $LN245@convertsim
$LN244@convertsim:
  02248	e8 00 00 00 00	 call	 _Py_PXCTX
  0224d	85 c0		 test	 eax, eax
  0224f	74 1d		 je	 SHORT $LN242@convertsim
  02251	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR size$21387[rsp]
  02259	48 ff c0	 inc	 rax
  0225c	48 8b c8	 mov	 rcx, rax
  0225f	e8 00 00 00 00	 call	 _PxMem_Malloc
  02264	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR tv943[rsp], rax
  0226c	eb 1b		 jmp	 SHORT $LN243@convertsim
$LN242@convertsim:
  0226e	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR size$21387[rsp]
  02276	48 ff c0	 inc	 rax
  02279	48 8b c8	 mov	 rcx, rax
  0227c	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  02281	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR tv943[rsp], rax
$LN243@convertsim:
  02289	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR tv943[rsp]
  02291	48 89 84 24 08
	03 00 00	 mov	 QWORD PTR tv944[rsp], rax
$LN245@convertsim:
  02299	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR buffer$21383[rsp]
  022a1	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR tv944[rsp]
  022a9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1092 :                 if (*buffer == NULL) {

  022ac	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR buffer$21383[rsp]
  022b4	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  022b8	75 1f		 jne	 SHORT $LN37@convertsim

; 1093 :                     Py_DECREF(s);

  022ba	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  022c2	e8 00 00 00 00	 call	 _Py_DecRef

; 1094 :                     PyErr_NoMemory();

  022c7	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1095 :                     RETURN_ERR_OCCURRED;

  022cc	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  022d4	e9 4d 09 00 00	 jmp	 $LN209@convertsim
$LN37@convertsim:

; 1096 :                 }
; 1097 :                 if (addcleanup(*buffer, freelist, cleanup_ptr)) {

  022d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cleanup_ptr
  022e0	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR freelist$[rsp]
  022e8	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR buffer$21383[rsp]
  022f0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  022f3	e8 00 00 00 00	 call	 addcleanup
  022f8	85 c0		 test	 eax, eax
  022fa	74 36		 je	 SHORT $LN36@convertsim

; 1098 :                     Py_DECREF(s);

  022fc	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  02304	e8 00 00 00 00	 call	 _Py_DecRef

; 1099 :                     return converterr(
; 1100 :                         "(cleanup problem)",
; 1101 :                         arg, msgbuf, bufsize);

  02309	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02311	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02319	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02321	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  02328	e8 00 00 00 00	 call	 converterr
  0232d	e9 f4 08 00 00	 jmp	 $LN209@convertsim
$LN36@convertsim:

; 1102 :                 }
; 1103 :             } else {

  02332	e9 81 00 00 00	 jmp	 $LN35@convertsim
$LN38@convertsim:

; 1104 :                 if (size + 1 > BUFFER_LEN) {

  02337	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0233e	83 e0 02	 and	 eax, 2
  02341	85 c0		 test	 eax, eax
  02343	74 15		 je	 SHORT $LN246@convertsim
  02345	48 8b 84 24 48
	02 00 00	 mov	 rax, QWORD PTR q2$21456[rsp]
  0234d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02350	48 89 84 24 18
	03 00 00	 mov	 QWORD PTR tv962[rsp], rax
  02358	eb 13		 jmp	 SHORT $LN247@convertsim
$LN246@convertsim:
  0235a	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR q$21454[rsp]
  02362	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  02365	48 89 84 24 18
	03 00 00	 mov	 QWORD PTR tv962[rsp], rax
$LN247@convertsim:
  0236d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR size$21387[rsp]
  02375	48 ff c0	 inc	 rax
  02378	48 3b 84 24 18
	03 00 00	 cmp	 rax, QWORD PTR tv962[rsp]
  02380	7e 36		 jle	 SHORT $LN34@convertsim

; 1105 :                     Py_DECREF(s);

  02382	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  0238a	e8 00 00 00 00	 call	 _Py_DecRef

; 1106 :                     return converterr(
; 1107 :                         "(buffer overflow)",
; 1108 :                         arg, msgbuf, bufsize);

  0238f	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02397	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  0239f	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  023a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@CNIENJCI@?$CIbuffer?5overflow?$CJ?$AA@
  023ae	e8 00 00 00 00	 call	 converterr
  023b3	e9 6e 08 00 00	 jmp	 $LN209@convertsim
$LN34@convertsim:
$LN35@convertsim:

; 1109 :                 }
; 1110 :             }
; 1111 :             memcpy(*buffer, ptr, size+1);

  023b8	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR size$21387[rsp]
  023c0	48 ff c0	 inc	 rax
  023c3	4c 8b c0	 mov	 r8, rax
  023c6	48 8b 94 24 18
	02 00 00	 mov	 rdx, QWORD PTR ptr$21388[rsp]
  023ce	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR buffer$21383[rsp]
  023d6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  023d9	e8 00 00 00 00	 call	 memcpy

; 1112 :             STORE_SIZE(size);

  023de	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  023e5	83 e0 02	 and	 eax, 2
  023e8	85 c0		 test	 eax, eax
  023ea	74 15		 je	 SHORT $LN33@convertsim
  023ec	48 8b 84 24 48
	02 00 00	 mov	 rax, QWORD PTR q2$21456[rsp]
  023f4	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR size$21387[rsp]
  023fc	48 89 08	 mov	 QWORD PTR [rax], rcx
  023ff	eb 5b		 jmp	 SHORT $LN32@convertsim
$LN33@convertsim:
  02401	48 81 bc 24 20
	02 00 00 ff ff
	ff 7f		 cmp	 QWORD PTR size$21387[rsp], 2147483647 ; 7fffffffH
  0240d	7e 3c		 jle	 SHORT $LN31@convertsim
  0240f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PBNPKOPA@size?5does?5not?5fit?5in?5an?5int?$AA@
  02416	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0241d	e8 00 00 00 00	 call	 PyErr_SetString
  02422	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  0242a	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02432	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  0243a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  02441	e8 00 00 00 00	 call	 converterr
  02446	e9 db 07 00 00	 jmp	 $LN209@convertsim
$LN31@convertsim:
  0244b	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR q$21454[rsp]
  02453	8b 8c 24 20 02
	00 00		 mov	 ecx, DWORD PTR size$21387[rsp]
  0245a	89 08		 mov	 DWORD PTR [rax], ecx
$LN32@convertsim:

; 1113 :         } else {

  0245c	e9 85 01 00 00	 jmp	 $LN30@convertsim
$LN42@convertsim:

; 1114 :             /* Using a 0-terminated buffer:
; 1115 : 
; 1116 :                - the encoded string has to be 0-terminated
; 1117 :                for this variant to work; if it is not, an
; 1118 :                error raised
; 1119 : 
; 1120 :                - a new buffer of the needed size is
; 1121 :                allocated and the data copied into it;
; 1122 :                *buffer is updated to point to the new
; 1123 :                buffer; the caller is responsible for
; 1124 :                PyMem_Free()ing it after usage
; 1125 : 
; 1126 :             */
; 1127 :             if ((Py_ssize_t)strlen(ptr) != size) {

  02461	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR ptr$21388[rsp]
  02469	e8 00 00 00 00	 call	 strlen
  0246e	48 3b 84 24 20
	02 00 00	 cmp	 rax, QWORD PTR size$21387[rsp]
  02476	74 36		 je	 SHORT $LN29@convertsim

; 1128 :                 Py_DECREF(s);

  02478	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  02480	e8 00 00 00 00	 call	 _Py_DecRef

; 1129 :                 return converterr(
; 1130 :                     "encoded string without NULL bytes",
; 1131 :                     arg, msgbuf, bufsize);

  02485	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  0248d	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02495	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  0249d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@PNMABHGD@encoded?5string?5without?5NULL?5byte@
  024a4	e8 00 00 00 00	 call	 converterr
  024a9	e9 78 07 00 00	 jmp	 $LN209@convertsim
$LN29@convertsim:

; 1132 :             }
; 1133 :             *buffer = PyMem_NEW(char, size + 1);

  024ae	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR size$21387[rsp]
  024b6	48 ff c0	 inc	 rax
  024b9	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  024c3	48 3b c1	 cmp	 rax, rcx
  024c6	76 0e		 jbe	 SHORT $LN250@convertsim
  024c8	48 c7 84 24 20
	03 00 00 00 00
	00 00		 mov	 QWORD PTR tv1004[rsp], 0
  024d4	eb 51		 jmp	 SHORT $LN251@convertsim
$LN250@convertsim:
  024d6	e8 00 00 00 00	 call	 _Py_PXCTX
  024db	85 c0		 test	 eax, eax
  024dd	74 1d		 je	 SHORT $LN248@convertsim
  024df	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR size$21387[rsp]
  024e7	48 ff c0	 inc	 rax
  024ea	48 8b c8	 mov	 rcx, rax
  024ed	e8 00 00 00 00	 call	 _PxMem_Malloc
  024f2	48 89 84 24 28
	03 00 00	 mov	 QWORD PTR tv1003[rsp], rax
  024fa	eb 1b		 jmp	 SHORT $LN249@convertsim
$LN248@convertsim:
  024fc	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR size$21387[rsp]
  02504	48 ff c0	 inc	 rax
  02507	48 8b c8	 mov	 rcx, rax
  0250a	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0250f	48 89 84 24 28
	03 00 00	 mov	 QWORD PTR tv1003[rsp], rax
$LN249@convertsim:
  02517	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR tv1003[rsp]
  0251f	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR tv1004[rsp], rax
$LN251@convertsim:
  02527	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR buffer$21383[rsp]
  0252f	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR tv1004[rsp]
  02537	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1134 :             if (*buffer == NULL) {

  0253a	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR buffer$21383[rsp]
  02542	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  02546	75 1f		 jne	 SHORT $LN28@convertsim

; 1135 :                 Py_DECREF(s);

  02548	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  02550	e8 00 00 00 00	 call	 _Py_DecRef

; 1136 :                 PyErr_NoMemory();

  02555	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1137 :                 RETURN_ERR_OCCURRED;

  0255a	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  02562	e9 bf 06 00 00	 jmp	 $LN209@convertsim
$LN28@convertsim:

; 1138 :             }
; 1139 :             if (addcleanup(*buffer, freelist, cleanup_ptr)) {

  02567	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cleanup_ptr
  0256e	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR freelist$[rsp]
  02576	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR buffer$21383[rsp]
  0257e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  02581	e8 00 00 00 00	 call	 addcleanup
  02586	85 c0		 test	 eax, eax
  02588	74 36		 je	 SHORT $LN27@convertsim

; 1140 :                 Py_DECREF(s);

  0258a	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  02592	e8 00 00 00 00	 call	 _Py_DecRef

; 1141 :                 return converterr("(cleanup problem)",
; 1142 :                                 arg, msgbuf, bufsize);

  02597	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  0259f	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  025a7	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  025af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  025b6	e8 00 00 00 00	 call	 converterr
  025bb	e9 66 06 00 00	 jmp	 $LN209@convertsim
$LN27@convertsim:

; 1143 :             }
; 1144 :             memcpy(*buffer, ptr, size+1);

  025c0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR size$21387[rsp]
  025c8	48 ff c0	 inc	 rax
  025cb	4c 8b c0	 mov	 r8, rax
  025ce	48 8b 94 24 18
	02 00 00	 mov	 rdx, QWORD PTR ptr$21388[rsp]
  025d6	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR buffer$21383[rsp]
  025de	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  025e1	e8 00 00 00 00	 call	 memcpy
$LN30@convertsim:

; 1145 :         }
; 1146 :         Py_DECREF(s);

  025e6	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR s$21385[rsp]
  025ee	e8 00 00 00 00	 call	 _Py_DecRef

; 1147 :         break;

  025f3	e9 1c 06 00 00	 jmp	 $LN207@convertsim
$LN26@convertsim:

; 1148 :     }
; 1149 : 
; 1150 :     case 'S': { /* PyBytes object */
; 1151 :         PyObject **p = va_arg(*p_va, PyObject **);

  025f8	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02600	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02603	48 83 c0 08	 add	 rax, 8
  02607	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0260f	48 89 01	 mov	 QWORD PTR [rcx], rax
  02612	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0261a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0261d	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  02621	48 89 84 24 58
	02 00 00	 mov	 QWORD PTR p$21531[rsp], rax

; 1152 :         if (PyBytes_Check(arg))

  02629	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  02631	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02635	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0263b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  02640	85 c0		 test	 eax, eax
  02642	74 15		 je	 SHORT $LN25@convertsim

; 1153 :             *p = arg;

  02644	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR p$21531[rsp]
  0264c	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  02654	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1154 :         else

  02657	eb 29		 jmp	 SHORT $LN24@convertsim
$LN25@convertsim:

; 1155 :             return converterr("bytes", arg, msgbuf, bufsize);

  02659	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02661	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02669	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02671	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05FBJAGGIG@bytes?$AA@
  02678	e8 00 00 00 00	 call	 converterr
  0267d	e9 a4 05 00 00	 jmp	 $LN209@convertsim
$LN24@convertsim:

; 1156 :         break;

  02682	e9 8d 05 00 00	 jmp	 $LN207@convertsim
$LN23@convertsim:

; 1157 :     }
; 1158 : 
; 1159 :     case 'Y': { /* PyByteArray object */
; 1160 :         PyObject **p = va_arg(*p_va, PyObject **);

  02687	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0268f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02692	48 83 c0 08	 add	 rax, 8
  02696	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0269e	48 89 01	 mov	 QWORD PTR [rcx], rax
  026a1	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  026a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  026ac	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  026b0	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR p$21547[rsp], rax

; 1161 :         if (PyByteArray_Check(arg))

  026b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  026bf	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  026c7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  026cb	74 1c		 je	 SHORT $LN21@convertsim
  026cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  026d4	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  026dc	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  026e0	e8 00 00 00 00	 call	 PyType_IsSubtype
  026e5	85 c0		 test	 eax, eax
  026e7	74 15		 je	 SHORT $LN22@convertsim
$LN21@convertsim:

; 1162 :             *p = arg;

  026e9	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR p$21547[rsp]
  026f1	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  026f9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1163 :         else

  026fc	eb 29		 jmp	 SHORT $LN20@convertsim
$LN22@convertsim:

; 1164 :             return converterr("bytearray", arg, msgbuf, bufsize);

  026fe	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02706	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  0270e	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02716	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09FCJHKOIN@bytearray?$AA@
  0271d	e8 00 00 00 00	 call	 converterr
  02722	e9 ff 04 00 00	 jmp	 $LN209@convertsim
$LN20@convertsim:

; 1165 :         break;

  02727	e9 e8 04 00 00	 jmp	 $LN207@convertsim
$LN19@convertsim:

; 1166 :     }
; 1167 : 
; 1168 :     case 'U': { /* PyUnicode object */
; 1169 :         PyObject **p = va_arg(*p_va, PyObject **);

  0272c	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02734	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02737	48 83 c0 08	 add	 rax, 8
  0273b	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  02743	48 89 01	 mov	 QWORD PTR [rcx], rax
  02746	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0274e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02751	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  02755	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR p$21565[rsp], rax

; 1170 :         if (PyUnicode_Check(arg)) {

  0275d	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  02765	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02769	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0276f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  02774	85 c0		 test	 eax, eax
  02776	0f 84 99 00 00
	00		 je	 $LN18@convertsim

; 1171 :             if (PyUnicode_READY(arg) == -1)

  0277c	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  02784	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02788	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0278e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  02793	85 c0		 test	 eax, eax
  02795	75 1c		 jne	 SHORT $LN252@convertsim
  02797	41 b8 93 04 00
	00		 mov	 r8d, 1171		; 00000493H
  0279d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  027a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  027ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  027b1	33 c0		 xor	 eax, eax
$LN252@convertsim:
  027b3	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  027bb	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  027be	c1 e8 07	 shr	 eax, 7
  027c1	83 e0 01	 and	 eax, 1
  027c4	85 c0		 test	 eax, eax
  027c6	74 0d		 je	 SHORT $LN253@convertsim
  027c8	c7 84 24 30 03
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1068[rsp], 0
  027d3	eb 14		 jmp	 SHORT $LN254@convertsim
$LN253@convertsim:
  027d5	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  027dd	e8 00 00 00 00	 call	 _PyUnicode_Ready
  027e2	89 84 24 30 03
	00 00		 mov	 DWORD PTR tv1068[rsp], eax
$LN254@convertsim:
  027e9	83 bc 24 30 03
	00 00 ff	 cmp	 DWORD PTR tv1068[rsp], -1
  027f1	75 0d		 jne	 SHORT $LN17@convertsim

; 1172 :                 RETURN_ERR_OCCURRED;

  027f3	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR msgbuf$[rsp]
  027fb	e9 26 04 00 00	 jmp	 $LN209@convertsim
$LN17@convertsim:

; 1173 :             *p = arg;

  02800	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR p$21565[rsp]
  02808	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  02810	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1174 :         }
; 1175 :         else

  02813	eb 29		 jmp	 SHORT $LN16@convertsim
$LN18@convertsim:

; 1176 :             return converterr("str", arg, msgbuf, bufsize);

  02815	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  0281d	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02825	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  0282d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03OJMAPEGJ@str?$AA@
  02834	e8 00 00 00 00	 call	 converterr
  02839	e9 e8 03 00 00	 jmp	 $LN209@convertsim
$LN16@convertsim:

; 1177 :         break;

  0283e	e9 d1 03 00 00	 jmp	 $LN207@convertsim
$LN15@convertsim:

; 1178 :     }
; 1179 : 
; 1180 :     case 'O': { /* object */
; 1181 :         PyTypeObject *type;
; 1182 :         PyObject **p;
; 1183 :         if (*format == '!') {

  02843	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  02848	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0284b	83 f8 21	 cmp	 eax, 33			; 00000021H
  0284e	0f 85 d4 00 00
	00		 jne	 $LN14@convertsim

; 1184 :             type = va_arg(*p_va, PyTypeObject*);

  02854	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0285c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0285f	48 83 c0 08	 add	 rax, 8
  02863	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0286b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0286e	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02876	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02879	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0287d	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR type$21585[rsp], rax

; 1185 :             p = va_arg(*p_va, PyObject **);

  02885	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0288d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02890	48 83 c0 08	 add	 rax, 8
  02894	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  0289c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0289f	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  028a7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  028aa	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  028ae	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR p$21586[rsp], rax

; 1186 :             format++;

  028b6	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  028bb	48 ff c0	 inc	 rax
  028be	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 1187 :             if (PyType_IsSubtype(arg->ob_type, type))

  028c3	48 8b 94 24 78
	02 00 00	 mov	 rdx, QWORD PTR type$21585[rsp]
  028cb	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  028d3	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  028d7	e8 00 00 00 00	 call	 PyType_IsSubtype
  028dc	85 c0		 test	 eax, eax
  028de	74 15		 je	 SHORT $LN13@convertsim

; 1188 :                 *p = arg;

  028e0	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR p$21586[rsp]
  028e8	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  028f0	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1189 :             else

  028f3	eb 2e		 jmp	 SHORT $LN12@convertsim
$LN13@convertsim:

; 1190 :                 return converterr(type->tp_name, arg, msgbuf, bufsize);

  028f5	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  028fd	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02905	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  0290d	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR type$21585[rsp]
  02915	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  02919	e8 00 00 00 00	 call	 converterr
  0291e	e9 03 03 00 00	 jmp	 $LN209@convertsim
$LN12@convertsim:

; 1191 : 
; 1192 :         }
; 1193 :         else if (*format == '&') {

  02923	e9 6f 01 00 00	 jmp	 $LN11@convertsim
$LN14@convertsim:
  02928	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  0292d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  02930	83 f8 26	 cmp	 eax, 38			; 00000026H
  02933	0f 85 1a 01 00
	00		 jne	 $LN10@convertsim

; 1194 :             typedef int (*converter)(PyObject *, void *);
; 1195 :             converter convert = va_arg(*p_va, converter);

  02939	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02941	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02944	48 83 c0 08	 add	 rax, 8
  02948	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  02950	48 89 01	 mov	 QWORD PTR [rcx], rax
  02953	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0295b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0295e	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  02962	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR convert$21615[rsp], rax

; 1196 :             void *addr = va_arg(*p_va, void *);

  0296a	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02972	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02975	48 83 c0 08	 add	 rax, 8
  02979	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  02981	48 89 01	 mov	 QWORD PTR [rcx], rax
  02984	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  0298c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0298f	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  02993	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR addr$21626[rsp], rax

; 1197 :             int res;
; 1198 :             format++;

  0299b	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  029a0	48 ff c0	 inc	 rax
  029a3	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 1199 :             if (! (res = (*convert)(arg, addr)))

  029a8	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR addr$21626[rsp]
  029b0	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  029b8	ff 94 24 88 02
	00 00		 call	 QWORD PTR convert$21615[rsp]
  029bf	89 84 24 80 02
	00 00		 mov	 DWORD PTR res$21637[rsp], eax
  029c6	83 bc 24 80 02
	00 00 00	 cmp	 DWORD PTR res$21637[rsp], 0
  029ce	75 29		 jne	 SHORT $LN9@convertsim

; 1200 :                 return converterr("(unspecified)",
; 1201 :                                   arg, msgbuf, bufsize);

  029d0	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  029d8	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  029e0	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  029e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DMBJEJOF@?$CIunspecified?$CJ?$AA@
  029ef	e8 00 00 00 00	 call	 converterr
  029f4	e9 2d 02 00 00	 jmp	 $LN209@convertsim
$LN9@convertsim:

; 1202 :             if (res == Py_CLEANUP_SUPPORTED &&
; 1203 :                 addcleanup(addr, freelist, convert) == -1)

  029f9	81 bc 24 80 02
	00 00 00 00 02
	00		 cmp	 DWORD PTR res$21637[rsp], 131072 ; 00020000H
  02a04	75 4b		 jne	 SHORT $LN8@convertsim
  02a06	4c 8b 84 24 88
	02 00 00	 mov	 r8, QWORD PTR convert$21615[rsp]
  02a0e	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR freelist$[rsp]
  02a16	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR addr$21626[rsp]
  02a1e	e8 00 00 00 00	 call	 addcleanup
  02a23	83 f8 ff	 cmp	 eax, -1
  02a26	75 29		 jne	 SHORT $LN8@convertsim

; 1204 :                 return converterr("(cleanup problem)",
; 1205 :                                 arg, msgbuf, bufsize);

  02a28	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02a30	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02a38	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02a40	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  02a47	e8 00 00 00 00	 call	 converterr
  02a4c	e9 d5 01 00 00	 jmp	 $LN209@convertsim
$LN8@convertsim:

; 1206 :         }
; 1207 :         else {

  02a51	eb 44		 jmp	 SHORT $LN7@convertsim
$LN10@convertsim:

; 1208 :             p = va_arg(*p_va, PyObject **);

  02a53	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02a5b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02a5e	48 83 c0 08	 add	 rax, 8
  02a62	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  02a6a	48 89 01	 mov	 QWORD PTR [rcx], rax
  02a6d	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02a75	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02a78	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  02a7c	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR p$21586[rsp], rax

; 1209 :             *p = arg;

  02a84	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR p$21586[rsp]
  02a8c	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  02a94	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN7@convertsim:
$LN11@convertsim:

; 1210 :         }
; 1211 :         break;

  02a97	e9 78 01 00 00	 jmp	 $LN207@convertsim
$LN6@convertsim:

; 1212 :     }
; 1213 : 
; 1214 : 
; 1215 :     case 'w': { /* "w*": memory buffer, read-write access */
; 1216 :         void **p = va_arg(*p_va, void **);

  02a9c	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02aa4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02aa7	48 83 c0 08	 add	 rax, 8
  02aab	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR p_va$[rsp]
  02ab3	48 89 01	 mov	 QWORD PTR [rcx], rax
  02ab6	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR p_va$[rsp]
  02abe	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02ac1	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  02ac5	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR p$21653[rsp], rax

; 1217 : 
; 1218 :         if (*format != '*')

  02acd	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  02ad2	0f be 00	 movsx	 eax, BYTE PTR [rax]
  02ad5	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  02ad8	74 29		 je	 SHORT $LN5@convertsim

; 1219 :             return converterr(
; 1220 :                 "invalid use of 'w' format character",
; 1221 :                 arg, msgbuf, bufsize);

  02ada	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02ae2	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02aea	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02af2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@FHIKGACL@invalid?5use?5of?5?8w?8?5format?5charac@
  02af9	e8 00 00 00 00	 call	 converterr
  02afe	e9 23 01 00 00	 jmp	 $LN209@convertsim
$LN5@convertsim:

; 1222 :         format++;

  02b03	48 8b 44 24 38	 mov	 rax, QWORD PTR format$[rsp]
  02b08	48 ff c0	 inc	 rax
  02b0b	48 89 44 24 38	 mov	 QWORD PTR format$[rsp], rax

; 1223 : 
; 1224 :         /* Caller is interested in Py_buffer, and the object
; 1225 :            supports it directly. */
; 1226 :         if (PyObject_GetBuffer(arg, (Py_buffer*)p, PyBUF_WRITABLE) < 0) {

  02b10	41 b8 01 00 00
	00		 mov	 r8d, 1
  02b16	48 8b 94 24 98
	02 00 00	 mov	 rdx, QWORD PTR p$21653[rsp]
  02b1e	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  02b26	e8 00 00 00 00	 call	 PyObject_GetBuffer
  02b2b	85 c0		 test	 eax, eax
  02b2d	7d 2e		 jge	 SHORT $LN4@convertsim

; 1227 :             PyErr_Clear();

  02b2f	e8 00 00 00 00	 call	 PyErr_Clear

; 1228 :             return converterr("read-write buffer", arg, msgbuf, bufsize);

  02b34	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02b3c	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02b44	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02b4c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@NOEFPHII@read?9write?5buffer?$AA@
  02b53	e8 00 00 00 00	 call	 converterr
  02b58	e9 c9 00 00 00	 jmp	 $LN209@convertsim
$LN4@convertsim:

; 1229 :         }
; 1230 :         if (!PyBuffer_IsContiguous((Py_buffer*)p, 'C')) {

  02b5d	b2 43		 mov	 dl, 67			; 00000043H
  02b5f	48 8b 8c 24 98
	02 00 00	 mov	 rcx, QWORD PTR p$21653[rsp]
  02b67	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  02b6c	85 c0		 test	 eax, eax
  02b6e	75 36		 jne	 SHORT $LN3@convertsim

; 1231 :             PyBuffer_Release((Py_buffer*)p);

  02b70	48 8b 8c 24 98
	02 00 00	 mov	 rcx, QWORD PTR p$21653[rsp]
  02b78	e8 00 00 00 00	 call	 PyBuffer_Release

; 1232 :             return converterr("contiguous buffer", arg, msgbuf, bufsize);

  02b7d	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02b85	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02b8d	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02b95	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@KHDHJHGE@contiguous?5buffer?$AA@
  02b9c	e8 00 00 00 00	 call	 converterr
  02ba1	e9 80 00 00 00	 jmp	 $LN209@convertsim
$LN3@convertsim:

; 1233 :         }
; 1234 :         if (addcleanup(p, freelist, cleanup_buffer)) {

  02ba6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cleanup_buffer
  02bad	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR freelist$[rsp]
  02bb5	48 8b 8c 24 98
	02 00 00	 mov	 rcx, QWORD PTR p$21653[rsp]
  02bbd	e8 00 00 00 00	 call	 addcleanup
  02bc2	85 c0		 test	 eax, eax
  02bc4	74 26		 je	 SHORT $LN2@convertsim

; 1235 :             return converterr(
; 1236 :                 "(cleanup problem)",
; 1237 :                 arg, msgbuf, bufsize);

  02bc6	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02bce	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02bd6	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02bde	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@IHGAANNF@?$CIcleanup?5problem?$CJ?$AA@
  02be5	e8 00 00 00 00	 call	 converterr
  02bea	eb 3a		 jmp	 SHORT $LN209@convertsim
$LN2@convertsim:

; 1238 :         }
; 1239 :         break;

  02bec	eb 26		 jmp	 SHORT $LN207@convertsim
$LN1@convertsim:

; 1240 :     }
; 1241 : 
; 1242 :     default:
; 1243 :         return converterr("impossible<bad format char>", arg, msgbuf, bufsize);

  02bee	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR bufsize$[rsp]
  02bf6	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  02bfe	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR arg$[rsp]
  02c06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@IMALOFOA@impossible?$DMbad?5format?5char?$DO?$AA@
  02c0d	e8 00 00 00 00	 call	 converterr
  02c12	eb 12		 jmp	 SHORT $LN209@convertsim
$LN207@convertsim:

; 1244 : 
; 1245 :     }
; 1246 : 
; 1247 :     *p_format = format;

  02c14	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR p_format$[rsp]
  02c1c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR format$[rsp]
  02c21	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1248 :     return NULL;

  02c24	33 c0		 xor	 eax, eax
$LN209@convertsim:

; 1249 : 
; 1250 : #undef FETCH_SIZE
; 1251 : #undef STORE_SIZE
; 1252 : #undef BUFFER_LEN
; 1253 : #undef RETURN_ERR_OCCURRED
; 1254 : }

  02c26	48 81 c4 48 03
	00 00		 add	 rsp, 840		; 00000348H
  02c2d	5f		 pop	 rdi
  02c2e	5e		 pop	 rsi
  02c2f	c3		 ret	 0
$LN256@convertsim:
  02c30	00 00 00 00	 DD	 $LN198@convertsim
  02c34	00 00 00 00	 DD	 $LN137@convertsim
  02c38	00 00 00 00	 DD	 $LN146@convertsim
  02c3c	00 00 00 00	 DD	 $LN186@convertsim
  02c40	00 00 00 00	 DD	 $LN174@convertsim
  02c44	00 00 00 00	 DD	 $LN155@convertsim
  02c48	00 00 00 00	 DD	 $LN159@convertsim
  02c4c	00 00 00 00	 DD	 $LN15@convertsim
  02c50	00 00 00 00	 DD	 $LN26@convertsim
  02c54	00 00 00 00	 DD	 $LN19@convertsim
  02c58	00 00 00 00	 DD	 $LN23@convertsim
  02c5c	00 00 00 00	 DD	 $LN80@convertsim
  02c60	00 00 00 00	 DD	 $LN206@convertsim
  02c64	00 00 00 00	 DD	 $LN143@convertsim
  02c68	00 00 00 00	 DD	 $LN149@convertsim
  02c6c	00 00 00 00	 DD	 $LN58@convertsim
  02c70	00 00 00 00	 DD	 $LN152@convertsim
  02c74	00 00 00 00	 DD	 $LN194@convertsim
  02c78	00 00 00 00	 DD	 $LN182@convertsim
  02c7c	00 00 00 00	 DD	 $LN162@convertsim
  02c80	00 00 00 00	 DD	 $LN166@convertsim
  02c84	00 00 00 00	 DD	 $LN170@convertsim
  02c88	00 00 00 00	 DD	 $LN133@convertsim
  02c8c	00 00 00 00	 DD	 $LN115@convertsim
  02c90	00 00 00 00	 DD	 $LN6@convertsim
  02c94	00 00 00 00	 DD	 $LN128@convertsim
  02c98	00 00 00 00	 DD	 $LN1@convertsim
$LN255@convertsim:
  02c9c	00		 DB	 0
  02c9d	01		 DB	 1
  02c9e	02		 DB	 2
  02c9f	1a		 DB	 26
  02ca0	1a		 DB	 26
  02ca1	1a		 DB	 26
  02ca2	03		 DB	 3
  02ca3	04		 DB	 4
  02ca4	1a		 DB	 26
  02ca5	05		 DB	 5
  02ca6	06		 DB	 6
  02ca7	1a		 DB	 26
  02ca8	1a		 DB	 26
  02ca9	07		 DB	 7
  02caa	1a		 DB	 26
  02cab	1a		 DB	 26
  02cac	1a		 DB	 26
  02cad	08		 DB	 8
  02cae	1a		 DB	 26
  02caf	09		 DB	 9
  02cb0	1a		 DB	 26
  02cb1	1a		 DB	 26
  02cb2	1a		 DB	 26
  02cb3	0a		 DB	 10
  02cb4	0b		 DB	 11
  02cb5	1a		 DB	 26
  02cb6	1a		 DB	 26
  02cb7	1a		 DB	 26
  02cb8	1a		 DB	 26
  02cb9	1a		 DB	 26
  02cba	1a		 DB	 26
  02cbb	1a		 DB	 26
  02cbc	0c		 DB	 12
  02cbd	0d		 DB	 13
  02cbe	0e		 DB	 14
  02cbf	0f		 DB	 15
  02cc0	10		 DB	 16
  02cc1	1a		 DB	 26
  02cc2	11		 DB	 17
  02cc3	12		 DB	 18
  02cc4	1a		 DB	 26
  02cc5	13		 DB	 19
  02cc6	14		 DB	 20
  02cc7	1a		 DB	 26
  02cc8	15		 DB	 21
  02cc9	1a		 DB	 26
  02cca	16		 DB	 22
  02ccb	1a		 DB	 26
  02ccc	1a		 DB	 26
  02ccd	17		 DB	 23
  02cce	1a		 DB	 26
  02ccf	0b		 DB	 11
  02cd0	1a		 DB	 26
  02cd1	18		 DB	 24
  02cd2	1a		 DB	 26
  02cd3	19		 DB	 25
  02cd4	17		 DB	 23
convertsimple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\python\getargs.c
pdata	SEGMENT
$pdata$cleanup_ptr DD imagerel cleanup_ptr
	DD	imagerel cleanup_ptr+76
	DD	imagerel $unwind$cleanup_ptr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cleanup_ptr DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cleanup_ptr
_TEXT	SEGMENT
tv69 = 32
self$ = 64
ptr$ = 72
cleanup_ptr PROC					; COMDAT

; 145  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 146  :     if (ptr) {

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  00014	74 2f		 je	 SHORT $LN1@cleanup_pt

; 147  :         PyMem_FREE(ptr);

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	74 14		 je	 SHORT $LN4@cleanup_pt
  0001f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ptr$[rsp]
  00024	e8 00 00 00 00	 call	 _PxMem_Free
  00029	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  00031	eb 12		 jmp	 SHORT $LN5@cleanup_pt
$LN4@cleanup_pt:
  00033	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ptr$[rsp]
  00038	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0003d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN5@cleanup_pt:
$LN1@cleanup_pt:

; 148  :     }
; 149  :     return 0;

  00045	33 c0		 xor	 eax, eax

; 150  : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
cleanup_ptr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cleanup_buffer DD imagerel cleanup_buffer
	DD	imagerel cleanup_buffer+49
	DD	imagerel $unwind$cleanup_buffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cleanup_buffer DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cleanup_buffer
_TEXT	SEGMENT
buf$ = 32
self$ = 64
ptr$ = 72
cleanup_buffer PROC					; COMDAT

; 154  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 155  :     Py_buffer *buf = (Py_buffer *)ptr;

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR ptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR buf$[rsp], rax

; 156  :     if (buf) {

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR buf$[rsp], 0
  0001e	74 0a		 je	 SHORT $LN1@cleanup_bu

; 157  :         PyBuffer_Release(buf);

  00020	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  00025	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@cleanup_bu:

; 158  :     }
; 159  :     return 0;

  0002a	33 c0		 xor	 eax, eax

; 160  : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	c3		 ret	 0
cleanup_buffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addcleanup DD imagerel addcleanup
	DD	imagerel addcleanup+105
	DD	imagerel $unwind$addcleanup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addcleanup DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT addcleanup
_TEXT	SEGMENT
index$ = 0
ptr$ = 32
freelist$ = 40
destructor$ = 48
addcleanup PROC						; COMDAT

; 164  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 165  :     int index;
; 166  : 
; 167  :     index = freelist->first_available;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR freelist$[rsp]
  00018	8b 00		 mov	 eax, DWORD PTR [rax]
  0001a	89 04 24	 mov	 DWORD PTR index$[rsp], eax

; 168  :     freelist->first_available += 1;

  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR freelist$[rsp]
  00022	8b 00		 mov	 eax, DWORD PTR [rax]
  00024	ff c0		 inc	 eax
  00026	48 8b 4c 24 28	 mov	 rcx, QWORD PTR freelist$[rsp]
  0002b	89 01		 mov	 DWORD PTR [rcx], eax

; 169  : 
; 170  :     freelist->entries[index].item = ptr;

  0002d	48 63 04 24	 movsxd	 rax, DWORD PTR index$[rsp]
  00031	48 6b c0 10	 imul	 rax, 16
  00035	48 8b 4c 24 28	 mov	 rcx, QWORD PTR freelist$[rsp]
  0003a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003e	48 8b 54 24 20	 mov	 rdx, QWORD PTR ptr$[rsp]
  00043	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 171  :     freelist->entries[index].destructor = destructor;

  00047	48 63 04 24	 movsxd	 rax, DWORD PTR index$[rsp]
  0004b	48 6b c0 10	 imul	 rax, 16
  0004f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR freelist$[rsp]
  00054	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00058	48 8b 54 24 30	 mov	 rdx, QWORD PTR destructor$[rsp]
  0005d	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 172  : 
; 173  :     return 0;

  00062	33 c0		 xor	 eax, eax

; 174  : }

  00064	48 83 c4 18	 add	 rsp, 24
  00068	c3		 ret	 0
addcleanup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@NNKBDMMC@must?5be?5?$CF?450s?0?5not?5?$CF?450s?$AA@ ; `string'
PUBLIC	??_C@_1BI@NKMGGKJE@?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@HKBDGIFD@?$AAe?$AAx?$AAp?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$converterr DD imagerel converterr
	DD	imagerel converterr+189
	DD	imagerel $unwind$converterr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$converterr DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT ??_C@_0BJ@NNKBDMMC@must?5be?5?$CF?450s?0?5not?5?$CF?450s?$AA@
CONST	SEGMENT
??_C@_0BJ@NNKBDMMC@must?5be?5?$CF?450s?0?5not?5?$CF?450s?$AA@ DB 'must be'
	DB	' %.50s, not %.50s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@NKMGGKJE@?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@NKMGGKJE@?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'a'
	DB	00H, 'r', 00H, 'g', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@HKBDGIFD@?$AAe?$AAx?$AAp?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@HKBDGIFD@?$AAe?$AAx?$AAp?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'e'
	DB	00H, 'x', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT converterr
_TEXT	SEGMENT
tv78 = 48
expected$ = 80
arg$ = 88
msgbuf$ = 96
bufsize$ = 104
converterr PROC						; COMDAT

; 515  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 516  :     assert(expected != NULL);

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR expected$[rsp], 0
  0001e	75 1c		 jne	 SHORT $LN3@converterr
  00020	41 b8 04 02 00
	00		 mov	 r8d, 516		; 00000204H
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@HKBDGIFD@?$AAe?$AAx?$AAp?$AAe?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003a	33 c0		 xor	 eax, eax
$LN3@converterr:

; 517  :     assert(arg != NULL);

  0003c	48 83 7c 24 58
	00		 cmp	 QWORD PTR arg$[rsp], 0
  00042	75 1c		 jne	 SHORT $LN4@converterr
  00044	41 b8 05 02 00
	00		 mov	 r8d, 517		; 00000205H
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@NKMGGKJE@?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005e	33 c0		 xor	 eax, eax
$LN4@converterr:

; 518  :     PyOS_snprintf(msgbuf, bufsize,
; 519  :                   "must be %.50s, not %.50s", expected,
; 520  :                   arg == Py_None ? "None" : arg->ob_type->tp_name);

  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00067	48 39 44 24 58	 cmp	 QWORD PTR arg$[rsp], rax
  0006c	75 0e		 jne	 SHORT $LN5@converterr
  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04OHJIHAFH@None?$AA@
  00075	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
  0007a	eb 12		 jmp	 SHORT $LN6@converterr
$LN5@converterr:
  0007c	48 8b 44 24 58	 mov	 rax, QWORD PTR arg$[rsp]
  00081	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00085	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00089	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
$LN6@converterr:
  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR tv78[rsp]
  00093	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00098	4c 8b 4c 24 50	 mov	 r9, QWORD PTR expected$[rsp]
  0009d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BJ@NNKBDMMC@must?5be?5?$CF?450s?0?5not?5?$CF?450s?$AA@
  000a4	48 8b 54 24 68	 mov	 rdx, QWORD PTR bufsize$[rsp]
  000a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR msgbuf$[rsp]
  000ae	e8 00 00 00 00	 call	 PyOS_snprintf

; 521  :     return msgbuf;

  000b3	48 8b 44 24 60	 mov	 rax, QWORD PTR msgbuf$[rsp]

; 522  : }

  000b8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bc	c3		 ret	 0
converterr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@ ; `string'
EXTRN	PyFloat_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_argument_error DD imagerel float_argument_error
	DD	imagerel float_argument_error+87
	DD	imagerel $unwind$float_argument_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_argument_error DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@
CONST	SEGMENT
??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@ DB 'integer arg'
	DB	'ument expected, got float', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_argument_error
_TEXT	SEGMENT
arg$ = 48
float_argument_error PROC				; COMDAT

; 530  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 531  :     if (PyFloat_Check(arg)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR arg$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 19		 je	 SHORT $LN2@float_argu
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR arg$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	74 1c		 je	 SHORT $LN3@float_argu
$LN2@float_argu:

; 532  :         PyErr_SetString(PyExc_TypeError,
; 533  :                         "integer argument expected, got float" );

  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00042	e8 00 00 00 00	 call	 PyErr_SetString

; 534  :         return 1;

  00047	b8 01 00 00 00	 mov	 eax, 1
  0004c	eb 04		 jmp	 SHORT $LN4@float_argu

; 535  :     }
; 536  :     else

  0004e	eb 02		 jmp	 SHORT $LN1@float_argu
$LN3@float_argu:

; 537  :         return 0;

  00050	33 c0		 xor	 eax, eax
$LN1@float_argu:
$LN4@float_argu:

; 538  : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
float_argument_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PPCDLMDC@read?9only?5pinned?5buffer?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$convertbuffer DD imagerel convertbuffer
	DD	imagerel convertbuffer+220
	DD	imagerel $unwind$convertbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convertbuffer DD 021601H
	DD	0130116H
xdata	ENDS
;	COMDAT ??_C@_0BI@PPCDLMDC@read?9only?5pinned?5buffer?$AA@
CONST	SEGMENT
??_C@_0BI@PPCDLMDC@read?9only?5pinned?5buffer?$AA@ DB 'read-only pinned b'
	DB	'uffer', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT convertbuffer
_TEXT	SEGMENT
count$ = 32
view$ = 48
pb$ = 128
arg$ = 160
p$ = 168
errmsg$ = 176
convertbuffer PROC					; COMDAT

; 1258 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1259 :     PyBufferProcs *pb = Py_TYPE(arg)->tp_as_buffer;

  00016	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  0001e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00022	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00029	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pb$[rsp], rax

; 1260 :     Py_ssize_t count;
; 1261 :     Py_buffer view;
; 1262 : 
; 1263 :     *errmsg = NULL;

  00031	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR errmsg$[rsp]
  00039	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1264 :     *p = NULL;

  00040	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00048	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1265 :     if (pb != NULL && pb->bf_releasebuffer != NULL) {

  0004f	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pb$[rsp], 0
  00058	74 2a		 je	 SHORT $LN2@convertbuf
  0005a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pb$[rsp]
  00062	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00067	74 1b		 je	 SHORT $LN2@convertbuf

; 1266 :         *errmsg = "read-only pinned buffer";

  00069	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR errmsg$[rsp]
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PPCDLMDC@read?9only?5pinned?5buffer?$AA@
  00078	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1267 :         return -1;

  0007b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00082	eb 50		 jmp	 SHORT $LN3@convertbuf
$LN2@convertbuf:

; 1268 :     }
; 1269 : 
; 1270 :     if (getbuffer(arg, &view, errmsg) < 0)

  00084	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR errmsg$[rsp]
  0008c	48 8d 54 24 30	 lea	 rdx, QWORD PTR view$[rsp]
  00091	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00099	e8 00 00 00 00	 call	 getbuffer
  0009e	85 c0		 test	 eax, eax
  000a0	7d 09		 jge	 SHORT $LN1@convertbuf

; 1271 :         return -1;

  000a2	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000a9	eb 29		 jmp	 SHORT $LN3@convertbuf
$LN1@convertbuf:

; 1272 :     count = view.len;

  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp+16]
  000b0	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 1273 :     *p = view.buf;

  000b5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  000bd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp]
  000c2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1274 :     PyBuffer_Release(&view);

  000c5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR view$[rsp]
  000ca	e8 00 00 00 00	 call	 PyBuffer_Release

; 1275 :     return count;

  000cf	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
$LN3@convertbuf:

; 1276 : }

  000d4	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  000db	c3		 ret	 0
convertbuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@PDPPHHIG@bytes?5or?5buffer?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$getbuffer DD imagerel getbuffer
	DD	imagerel getbuffer+118
	DD	imagerel $unwind$getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getbuffer DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_0BA@PDPPHHIG@bytes?5or?5buffer?$AA@
CONST	SEGMENT
??_C@_0BA@PDPPHHIG@bytes?5or?5buffer?$AA@ DB 'bytes or buffer', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT getbuffer
_TEXT	SEGMENT
arg$ = 48
view$ = 56
errmsg$ = 64
getbuffer PROC						; COMDAT

; 1280 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1281 :     if (PyObject_GetBuffer(arg, view, PyBUF_SIMPLE) != 0) {

  00013	45 33 c0	 xor	 r8d, r8d
  00016	48 8b 54 24 38	 mov	 rdx, QWORD PTR view$[rsp]
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR arg$[rsp]
  00020	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00025	85 c0		 test	 eax, eax
  00027	74 16		 je	 SHORT $LN2@getbuffer

; 1282 :         *errmsg = "bytes or buffer";

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR errmsg$[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@PDPPHHIG@bytes?5or?5buffer?$AA@
  00035	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1283 :         return -1;

  00038	b8 ff ff ff ff	 mov	 eax, -1
  0003d	eb 32		 jmp	 SHORT $LN3@getbuffer
$LN2@getbuffer:

; 1284 :     }
; 1285 :     if (!PyBuffer_IsContiguous(view, 'C')) {

  0003f	b2 43		 mov	 dl, 67			; 00000043H
  00041	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00046	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  0004b	85 c0		 test	 eax, eax
  0004d	75 20		 jne	 SHORT $LN1@getbuffer

; 1286 :         PyBuffer_Release(view);

  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00054	e8 00 00 00 00	 call	 PyBuffer_Release

; 1287 :         *errmsg = "contiguous buffer";

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR errmsg$[rsp]
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@KHDHJHGE@contiguous?5buffer?$AA@
  00065	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1288 :         return -1;

  00068	b8 ff ff ff ff	 mov	 eax, -1
  0006d	eb 02		 jmp	 SHORT $LN3@getbuffer
$LN1@getbuffer:

; 1289 :     }
; 1290 :     return 0;

  0006f	33 c0		 xor	 eax, eax
$LN3@getbuffer:

; 1291 : }

  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	c3		 ret	 0
getbuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@ ; `string'
PUBLIC	PyArg_ParseTupleAndKeywords
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_ParseTupleAndKeywords DD imagerel $LN6
	DD	imagerel $LN6+200
	DD	imagerel $unwind$PyArg_ParseTupleAndKeywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_ParseTupleAndKeywords DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT ??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
CONST	SEGMENT
??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@ DB '..\Python\getargs.c', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyArg_ParseTupleAndKeywords
_TEXT	SEGMENT
va$ = 48
retval$ = 56
args$ = 80
keywords$ = 88
format$ = 96
kwlist$ = 104
PyArg_ParseTupleAndKeywords PROC			; COMDAT

; 1302 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1303 :     int retval;
; 1304 :     va_list va;
; 1305 : 
; 1306 :     if ((args == NULL || !PyTuple_Check(args)) ||
; 1307 :         (keywords != NULL && !PyDict_Check(keywords)) ||
; 1308 :         format == NULL ||
; 1309 :         kwlist == NULL)

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR args$[rsp], 0
  0001e	74 48		 je	 SHORT $LN2@PyArg_Pars
  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR args$[rsp]
  00025	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00029	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002f	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00034	85 c0		 test	 eax, eax
  00036	74 30		 je	 SHORT $LN2@PyArg_Pars
  00038	48 83 7c 24 58
	00		 cmp	 QWORD PTR keywords$[rsp], 0
  0003e	74 18		 je	 SHORT $LN1@PyArg_Pars
  00040	48 8b 44 24 58	 mov	 rax, QWORD PTR keywords$[rsp]
  00045	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00049	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00054	85 c0		 test	 eax, eax
  00056	74 10		 je	 SHORT $LN2@PyArg_Pars
$LN1@PyArg_Pars:
  00058	48 83 7c 24 60
	00		 cmp	 QWORD PTR format$[rsp], 0
  0005e	74 08		 je	 SHORT $LN2@PyArg_Pars
  00060	48 83 7c 24 68
	00		 cmp	 QWORD PTR kwlist$[rsp], 0
  00066	75 15		 jne	 SHORT $LN3@PyArg_Pars
$LN2@PyArg_Pars:

; 1310 :     {
; 1311 :         PyErr_BadInternalCall();

  00068	ba 1f 05 00 00	 mov	 edx, 1311		; 0000051fH
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  00074	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1312 :         return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	eb 46		 jmp	 SHORT $LN4@PyArg_Pars
$LN3@PyArg_Pars:

; 1313 :     }
; 1314 : 
; 1315 :     va_start(va, kwlist);

  0007d	48 8d 44 24 70	 lea	 rax, QWORD PTR kwlist$[rsp+8]
  00082	48 89 44 24 30	 mov	 QWORD PTR va$[rsp], rax

; 1316 :     retval = vgetargskeywords(args, keywords, format, kwlist, &va, 0);

  00087	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0008f	48 8d 44 24 30	 lea	 rax, QWORD PTR va$[rsp]
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8b 4c 24 68	 mov	 r9, QWORD PTR kwlist$[rsp]
  0009e	4c 8b 44 24 60	 mov	 r8, QWORD PTR format$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR keywords$[rsp]
  000a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR args$[rsp]
  000ad	e8 00 00 00 00	 call	 vgetargskeywords
  000b2	89 44 24 38	 mov	 DWORD PTR retval$[rsp], eax

; 1317 :     va_end(va);

  000b6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 1318 :     return retval;

  000bf	8b 44 24 38	 mov	 eax, DWORD PTR retval$[rsp]
$LN4@PyArg_Pars:

; 1319 : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
PyArg_ParseTupleAndKeywords ENDP
_TEXT	ENDS
PUBLIC	_PyArg_ParseTupleAndKeywords_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_ParseTupleAndKeywords_SizeT DD imagerel $LN6
	DD	imagerel $LN6+200
	DD	imagerel $unwind$_PyArg_ParseTupleAndKeywords_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_ParseTupleAndKeywords_SizeT DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyArg_ParseTupleAndKeywords_SizeT
_TEXT	SEGMENT
va$ = 48
retval$ = 56
args$ = 80
keywords$ = 88
format$ = 96
kwlist$ = 104
_PyArg_ParseTupleAndKeywords_SizeT PROC			; COMDAT

; 1326 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1327 :     int retval;
; 1328 :     va_list va;
; 1329 : 
; 1330 :     if ((args == NULL || !PyTuple_Check(args)) ||
; 1331 :         (keywords != NULL && !PyDict_Check(keywords)) ||
; 1332 :         format == NULL ||
; 1333 :         kwlist == NULL)

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR args$[rsp], 0
  0001e	74 48		 je	 SHORT $LN2@PyArg_Pars@2
  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR args$[rsp]
  00025	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00029	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002f	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00034	85 c0		 test	 eax, eax
  00036	74 30		 je	 SHORT $LN2@PyArg_Pars@2
  00038	48 83 7c 24 58
	00		 cmp	 QWORD PTR keywords$[rsp], 0
  0003e	74 18		 je	 SHORT $LN1@PyArg_Pars@2
  00040	48 8b 44 24 58	 mov	 rax, QWORD PTR keywords$[rsp]
  00045	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00049	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00054	85 c0		 test	 eax, eax
  00056	74 10		 je	 SHORT $LN2@PyArg_Pars@2
$LN1@PyArg_Pars@2:
  00058	48 83 7c 24 60
	00		 cmp	 QWORD PTR format$[rsp], 0
  0005e	74 08		 je	 SHORT $LN2@PyArg_Pars@2
  00060	48 83 7c 24 68
	00		 cmp	 QWORD PTR kwlist$[rsp], 0
  00066	75 15		 jne	 SHORT $LN3@PyArg_Pars@2
$LN2@PyArg_Pars@2:

; 1334 :     {
; 1335 :         PyErr_BadInternalCall();

  00068	ba 37 05 00 00	 mov	 edx, 1335		; 00000537H
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  00074	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1336 :         return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	eb 46		 jmp	 SHORT $LN4@PyArg_Pars@2
$LN3@PyArg_Pars@2:

; 1337 :     }
; 1338 : 
; 1339 :     va_start(va, kwlist);

  0007d	48 8d 44 24 70	 lea	 rax, QWORD PTR kwlist$[rsp+8]
  00082	48 89 44 24 30	 mov	 QWORD PTR va$[rsp], rax

; 1340 :     retval = vgetargskeywords(args, keywords, format,
; 1341 :                               kwlist, &va, FLAG_SIZE_T);

  00087	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  0008f	48 8d 44 24 30	 lea	 rax, QWORD PTR va$[rsp]
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8b 4c 24 68	 mov	 r9, QWORD PTR kwlist$[rsp]
  0009e	4c 8b 44 24 60	 mov	 r8, QWORD PTR format$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR keywords$[rsp]
  000a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR args$[rsp]
  000ad	e8 00 00 00 00	 call	 vgetargskeywords
  000b2	89 44 24 38	 mov	 DWORD PTR retval$[rsp], eax

; 1342 :     va_end(va);

  000b6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 1343 :     return retval;

  000bf	8b 44 24 38	 mov	 eax, DWORD PTR retval$[rsp]
$LN4@PyArg_Pars@2:

; 1344 : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
_PyArg_ParseTupleAndKeywords_SizeT ENDP
_TEXT	ENDS
PUBLIC	PyArg_VaParseTupleAndKeywords
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_VaParseTupleAndKeywords DD imagerel $LN6
	DD	imagerel $LN6+191
	DD	imagerel $unwind$PyArg_VaParseTupleAndKeywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_VaParseTupleAndKeywords DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyArg_VaParseTupleAndKeywords
_TEXT	SEGMENT
retval$ = 48
lva$ = 56
args$ = 80
keywords$ = 88
format$ = 96
kwlist$ = 104
va$ = 112
PyArg_VaParseTupleAndKeywords PROC			; COMDAT

; 1352 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1353 :     int retval;
; 1354 :     va_list lva;
; 1355 : 
; 1356 :     if ((args == NULL || !PyTuple_Check(args)) ||
; 1357 :         (keywords != NULL && !PyDict_Check(keywords)) ||
; 1358 :         format == NULL ||
; 1359 :         kwlist == NULL)

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR args$[rsp], 0
  0001e	74 48		 je	 SHORT $LN2@PyArg_VaPa
  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR args$[rsp]
  00025	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00029	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002f	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00034	85 c0		 test	 eax, eax
  00036	74 30		 je	 SHORT $LN2@PyArg_VaPa
  00038	48 83 7c 24 58
	00		 cmp	 QWORD PTR keywords$[rsp], 0
  0003e	74 18		 je	 SHORT $LN1@PyArg_VaPa
  00040	48 8b 44 24 58	 mov	 rax, QWORD PTR keywords$[rsp]
  00045	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00049	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00054	85 c0		 test	 eax, eax
  00056	74 10		 je	 SHORT $LN2@PyArg_VaPa
$LN1@PyArg_VaPa:
  00058	48 83 7c 24 60
	00		 cmp	 QWORD PTR format$[rsp], 0
  0005e	74 08		 je	 SHORT $LN2@PyArg_VaPa
  00060	48 83 7c 24 68
	00		 cmp	 QWORD PTR kwlist$[rsp], 0
  00066	75 15		 jne	 SHORT $LN3@PyArg_VaPa
$LN2@PyArg_VaPa:

; 1360 :     {
; 1361 :         PyErr_BadInternalCall();

  00068	ba 51 05 00 00	 mov	 edx, 1361		; 00000551H
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  00074	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1362 :         return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	eb 3d		 jmp	 SHORT $LN4@PyArg_VaPa
$LN3@PyArg_VaPa:

; 1363 :     }
; 1364 : 
; 1365 :         Py_VA_COPY(lva, va);

  0007d	48 8b 44 24 70	 mov	 rax, QWORD PTR va$[rsp]
  00082	48 89 44 24 38	 mov	 QWORD PTR lva$[rsp], rax

; 1366 : 
; 1367 :     retval = vgetargskeywords(args, keywords, format, kwlist, &lva, 0);

  00087	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0008f	48 8d 44 24 38	 lea	 rax, QWORD PTR lva$[rsp]
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8b 4c 24 68	 mov	 r9, QWORD PTR kwlist$[rsp]
  0009e	4c 8b 44 24 60	 mov	 r8, QWORD PTR format$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR keywords$[rsp]
  000a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR args$[rsp]
  000ad	e8 00 00 00 00	 call	 vgetargskeywords
  000b2	89 44 24 30	 mov	 DWORD PTR retval$[rsp], eax

; 1368 :     return retval;

  000b6	8b 44 24 30	 mov	 eax, DWORD PTR retval$[rsp]
$LN4@PyArg_VaPa:

; 1369 : }

  000ba	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000be	c3		 ret	 0
PyArg_VaParseTupleAndKeywords ENDP
_TEXT	ENDS
PUBLIC	_PyArg_VaParseTupleAndKeywords_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_VaParseTupleAndKeywords_SizeT DD imagerel $LN6
	DD	imagerel $LN6+191
	DD	imagerel $unwind$_PyArg_VaParseTupleAndKeywords_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_VaParseTupleAndKeywords_SizeT DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyArg_VaParseTupleAndKeywords_SizeT
_TEXT	SEGMENT
retval$ = 48
lva$ = 56
args$ = 80
keywords$ = 88
format$ = 96
kwlist$ = 104
va$ = 112
_PyArg_VaParseTupleAndKeywords_SizeT PROC		; COMDAT

; 1376 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     int retval;
; 1378 :     va_list lva;
; 1379 : 
; 1380 :     if ((args == NULL || !PyTuple_Check(args)) ||
; 1381 :         (keywords != NULL && !PyDict_Check(keywords)) ||
; 1382 :         format == NULL ||
; 1383 :         kwlist == NULL)

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR args$[rsp], 0
  0001e	74 48		 je	 SHORT $LN2@PyArg_VaPa@2
  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR args$[rsp]
  00025	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00029	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002f	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00034	85 c0		 test	 eax, eax
  00036	74 30		 je	 SHORT $LN2@PyArg_VaPa@2
  00038	48 83 7c 24 58
	00		 cmp	 QWORD PTR keywords$[rsp], 0
  0003e	74 18		 je	 SHORT $LN1@PyArg_VaPa@2
  00040	48 8b 44 24 58	 mov	 rax, QWORD PTR keywords$[rsp]
  00045	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00049	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00054	85 c0		 test	 eax, eax
  00056	74 10		 je	 SHORT $LN2@PyArg_VaPa@2
$LN1@PyArg_VaPa@2:
  00058	48 83 7c 24 60
	00		 cmp	 QWORD PTR format$[rsp], 0
  0005e	74 08		 je	 SHORT $LN2@PyArg_VaPa@2
  00060	48 83 7c 24 68
	00		 cmp	 QWORD PTR kwlist$[rsp], 0
  00066	75 15		 jne	 SHORT $LN3@PyArg_VaPa@2
$LN2@PyArg_VaPa@2:

; 1384 :     {
; 1385 :         PyErr_BadInternalCall();

  00068	ba 69 05 00 00	 mov	 edx, 1385		; 00000569H
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  00074	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1386 :         return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	eb 3d		 jmp	 SHORT $LN4@PyArg_VaPa@2
$LN3@PyArg_VaPa@2:

; 1387 :     }
; 1388 : 
; 1389 :         Py_VA_COPY(lva, va);

  0007d	48 8b 44 24 70	 mov	 rax, QWORD PTR va$[rsp]
  00082	48 89 44 24 38	 mov	 QWORD PTR lva$[rsp], rax

; 1390 : 
; 1391 :     retval = vgetargskeywords(args, keywords, format,
; 1392 :                               kwlist, &lva, FLAG_SIZE_T);

  00087	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  0008f	48 8d 44 24 38	 lea	 rax, QWORD PTR lva$[rsp]
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8b 4c 24 68	 mov	 r9, QWORD PTR kwlist$[rsp]
  0009e	4c 8b 44 24 60	 mov	 r8, QWORD PTR format$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR keywords$[rsp]
  000a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR args$[rsp]
  000ad	e8 00 00 00 00	 call	 vgetargskeywords
  000b2	89 44 24 30	 mov	 DWORD PTR retval$[rsp], eax

; 1393 :     return retval;

  000b6	8b 44 24 30	 mov	 eax, DWORD PTR retval$[rsp]
$LN4@PyArg_VaPa@2:

; 1394 : }

  000ba	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000be	c3		 ret	 0
_PyArg_VaParseTupleAndKeywords_SizeT ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@IHJGJBNK@keyword?5arguments?5must?5be?5string@ ; `string'
PUBLIC	PyArg_ValidateKeywordArguments
EXTRN	_PyDict_HasOnlyStringKeys:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_ValidateKeywordArguments DD imagerel $LN5
	DD	imagerel $LN5+101
	DD	imagerel $unwind$PyArg_ValidateKeywordArguments
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_ValidateKeywordArguments DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0CC@IHJGJBNK@keyword?5arguments?5must?5be?5string@
CONST	SEGMENT
??_C@_0CC@IHJGJBNK@keyword?5arguments?5must?5be?5string@ DB 'keyword argu'
	DB	'ments must be strings', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyArg_ValidateKeywordArguments
_TEXT	SEGMENT
kwargs$ = 48
PyArg_ValidateKeywordArguments PROC			; COMDAT

; 1398 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1399 :     if (!PyDict_Check(kwargs)) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR kwargs$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 15		 jne	 SHORT $LN2@PyArg_Vali

; 1400 :         PyErr_BadInternalCall();

  00021	ba 78 05 00 00	 mov	 edx, 1400		; 00000578H
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  0002d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1401 :         return 0;

  00032	33 c0		 xor	 eax, eax
  00034	eb 2a		 jmp	 SHORT $LN3@PyArg_Vali
$LN2@PyArg_Vali:

; 1402 :     }
; 1403 :     if (!_PyDict_HasOnlyStringKeys(kwargs)) {

  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR kwargs$[rsp]
  0003b	e8 00 00 00 00	 call	 _PyDict_HasOnlyStringKeys
  00040	85 c0		 test	 eax, eax
  00042	75 17		 jne	 SHORT $LN1@PyArg_Vali

; 1404 :         PyErr_SetString(PyExc_TypeError,
; 1405 :                         "keyword arguments must be strings");

  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@IHJGJBNK@keyword?5arguments?5must?5be?5string@
  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00052	e8 00 00 00 00	 call	 PyErr_SetString

; 1406 :         return 0;

  00057	33 c0		 xor	 eax, eax
  00059	eb 05		 jmp	 SHORT $LN3@PyArg_Vali
$LN1@PyArg_Vali:

; 1407 :     }
; 1408 :     return 1;

  0005b	b8 01 00 00 00	 mov	 eax, 1
$LN3@PyArg_Vali:

; 1409 : }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	c3		 ret	 0
PyArg_ValidateKeywordArguments ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@ENKIDNFE@?8?$CFU?8?5is?5an?5invalid?5keyword?5argum@ ; `string'
PUBLIC	??_C@_0BJ@LEGLBJFG@keywords?5must?5be?5strings?$AA@ ; `string'
PUBLIC	??_C@_0EL@FLEHBPOJ@more?5argument?5specifiers?5than?5ke@ ; `string'
PUBLIC	??_C@_08JAIPINJA@?$CFs?3?5?8?$CFs?8?$AA@	; `string'
PUBLIC	??_C@_0CK@HKBBODMD@Required?5argument?5?8?$CFs?8?5?$CIpos?5?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0DA@GILDFAFF@Argument?5given?5by?5name?5?$CI?8?$CFs?8?$CJ?5an@ ; `string'
PUBLIC	??_C@_0DL@LMLCHELD@More?5keyword?5list?5entries?5?$CI?$CFd?$CJ?5t@ ; `string'
PUBLIC	??_C@_0DF@BPFKLMMD@Function?5takes?5?$CFs?5?$CFd?5positional?5@ ; `string'
PUBLIC	??_C@_0CK@MOOGIOLD@Invalid?5format?5string?5?$CI$?5specifi@ ; `string'
PUBLIC	??_C@_0CD@FHABLJPP@Invalid?5format?5string?5?$CI$?5before?5@ ; `string'
PUBLIC	??_C@_0CK@JJANEEBE@Invalid?5format?5string?5?$CI?$HM?5specifi@ ; `string'
PUBLIC	??_C@_0CM@DGNOJHNI@?$CFs?$CFs?5takes?5at?5most?5?$CFd?5argument?$CFs@ ; `string'
PUBLIC	??_C@_1BK@MLJHDBA@?$AAp?$AA_?$AAv?$AAa?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@GKDDPFH@?$AAk?$AAw?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@MLMCMBKN@?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FG@FEEEBION@?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAD?$AAi?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk@ ; `string'
PUBLIC	??_C@_1EI@LAEDPDD@?$AAa?$AAr?$AAg?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr@ ; `string'
EXTRN	strcmp:PROC
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyDict_Next:PROC
EXTRN	PyDict_GetItemString:PROC
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	PyDict_Size:PROC
EXTRN	__imp_strchr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$vgetargskeywords DD imagerel vgetargskeywords
	DD	imagerel vgetargskeywords+2491
	DD	imagerel $unwind$vgetargskeywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vgetargskeywords DD 021b01H
	DD	073011bH
xdata	ENDS
;	COMDAT ??_C@_0DG@ENKIDNFE@?8?$CFU?8?5is?5an?5invalid?5keyword?5argum@
CONST	SEGMENT
??_C@_0DG@ENKIDNFE@?8?$CFU?8?5is?5an?5invalid?5keyword?5argum@ DB '''%U'''
	DB	' is an invalid keyword argument for this function', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LEGLBJFG@keywords?5must?5be?5strings?$AA@
CONST	SEGMENT
??_C@_0BJ@LEGLBJFG@keywords?5must?5be?5strings?$AA@ DB 'keywords must be '
	DB	'strings', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@FLEHBPOJ@more?5argument?5specifiers?5than?5ke@
CONST	SEGMENT
??_C@_0EL@FLEHBPOJ@more?5argument?5specifiers?5than?5ke@ DB 'more argumen'
	DB	't specifiers than keyword list entries (remaining format:''%s'
	DB	''')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08JAIPINJA@?$CFs?3?5?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_08JAIPINJA@?$CFs?3?5?8?$CFs?8?$AA@ DB '%s: ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HKBBODMD@Required?5argument?5?8?$CFs?8?5?$CIpos?5?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0CK@HKBBODMD@Required?5argument?5?8?$CFs?8?5?$CIpos?5?$CFd?$CJ?5@ DB 'R'
	DB	'equired argument ''%s'' (pos %d) not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GILDFAFF@Argument?5given?5by?5name?5?$CI?8?$CFs?8?$CJ?5an@
CONST	SEGMENT
??_C@_0DA@GILDFAFF@Argument?5given?5by?5name?5?$CI?8?$CFs?8?$CJ?5an@ DB 'A'
	DB	'rgument given by name (''%s'') and position (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@LMLCHELD@More?5keyword?5list?5entries?5?$CI?$CFd?$CJ?5t@
CONST	SEGMENT
??_C@_0DL@LMLCHELD@More?5keyword?5list?5entries?5?$CI?$CFd?$CJ?5t@ DB 'Mo'
	DB	're keyword list entries (%d) than format specifiers (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BPFKLMMD@Function?5takes?5?$CFs?5?$CFd?5positional?5@
CONST	SEGMENT
??_C@_0DF@BPFKLMMD@Function?5takes?5?$CFs?5?$CFd?5positional?5@ DB 'Funct'
	DB	'ion takes %s %d positional arguments (%d given)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MOOGIOLD@Invalid?5format?5string?5?$CI$?5specifi@
CONST	SEGMENT
??_C@_0CK@MOOGIOLD@Invalid?5format?5string?5?$CI$?5specifi@ DB 'Invalid f'
	DB	'ormat string ($ specified twice)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FHABLJPP@Invalid?5format?5string?5?$CI$?5before?5@
CONST	SEGMENT
??_C@_0CD@FHABLJPP@Invalid?5format?5string?5?$CI$?5before?5@ DB 'Invalid '
	DB	'format string ($ before |)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JJANEEBE@Invalid?5format?5string?5?$CI?$HM?5specifi@
CONST	SEGMENT
??_C@_0CK@JJANEEBE@Invalid?5format?5string?5?$CI?$HM?5specifi@ DB 'Invali'
	DB	'd format string (| specified twice)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DGNOJHNI@?$CFs?$CFs?5takes?5at?5most?5?$CFd?5argument?$CFs@
CONST	SEGMENT
??_C@_0CM@DGNOJHNI@?$CFs?$CFs?5takes?5at?5most?5?$CFd?5argument?$CFs@ DB '%'
	DB	's%s takes at most %d argument%s (%d given)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@MLJHDBA@?$AAp?$AA_?$AAv?$AAa?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@MLJHDBA@?$AAp?$AA_?$AAv?$AAa?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'p'
	DB	00H, '_', 00H, 'v', 00H, 'a', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@GKDDPFH@?$AAk?$AAw?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@GKDDPFH@?$AAk?$AAw?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'k'
	DB	00H, 'w', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MLMCMBKN@?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MLMCMBKN@?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'f'
	DB	00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@FEEEBION@?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAD?$AAi?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk@
CONST	SEGMENT
??_C@_1FG@FEEEBION@?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAD?$AAi?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk@ DB 'k'
	DB	00H, 'e', 00H, 'y', 00H, 'w', 00H, 'o', 00H, 'r', 00H, 'd', 00H
	DB	's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H
	DB	'P', 00H, 'y', 00H, 'D', 00H, 'i', 00H, 'c', 00H, 't', 00H, '_'
	DB	00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H
	DB	'k', 00H, 'e', 00H, 'y', 00H, 'w', 00H, 'o', 00H, 'r', 00H, 'd'
	DB	00H, 's', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@LAEDPDD@?$AAa?$AAr?$AAg?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr@
CONST	SEGMENT
??_C@_1EI@LAEDPDD@?$AAa?$AAr?$AAg?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr@ DB 'a'
	DB	00H, 'r', 00H, 'g', 00H, 's', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'T', 00H, 'u', 00H
	DB	'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e'
	DB	00H, 'c', 00H, 'k', 00H, '(', 00H, 'a', 00H, 'r', 00H, 'g', 00H
	DB	's', 00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT vgetargskeywords
_TEXT	SEGMENT
current_arg$ = 64
fname$ = 72
nkeywords$ = 80
i$ = 84
min$ = 88
keyword$ = 96
freelist$ = 104
levels$ = 128
len$ = 256
custom_msg$ = 264
msg$ = 272
nargs$ = 280
msgbuf$ = 288
max$ = 800
value$21909 = 808
key$21908 = 816
pos$21910 = 824
ks$21915 = 832
match$21914 = 840
tv157 = 848
tv156 = 856
tv163 = 864
tv171 = 872
tv175 = 880
tv178 = 888
tv218 = 896
args$ = 928
keywords$ = 936
format$ = 944
kwlist$ = 952
p_va$ = 960
flags$ = 968
vgetargskeywords PROC					; COMDAT

; 1416 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 03
	00 00		 sub	 rsp, 920		; 00000398H

; 1417 :     char msgbuf[512];
; 1418 :     int levels[32];
; 1419 :     const char *fname, *msg, *custom_msg, *keyword;
; 1420 :     int min = INT_MAX;

  0001b	c7 44 24 58 ff
	ff ff 7f	 mov	 DWORD PTR min$[rsp], 2147483647 ; 7fffffffH

; 1421 :     int max = INT_MAX;

  00023	c7 84 24 20 03
	00 00 ff ff ff
	7f		 mov	 DWORD PTR max$[rsp], 2147483647 ; 7fffffffH

; 1422 :     int i, len, nargs, nkeywords;
; 1423 :     PyObject *current_arg;
; 1424 :     freelist_t freelist = {0, NULL};

  0002e	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR freelist$[rsp], 0
  00036	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR freelist$[rsp+8], 0

; 1425 : 
; 1426 :     assert(args != NULL && PyTuple_Check(args));

  0003f	48 83 bc 24 a0
	03 00 00 00	 cmp	 QWORD PTR args$[rsp], 0
  00048	74 1b		 je	 SHORT $LN45@vgetargske
  0004a	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00052	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00056	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005c	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00061	85 c0		 test	 eax, eax
  00063	75 1c		 jne	 SHORT $LN46@vgetargske
$LN45@vgetargske:
  00065	41 b8 92 05 00
	00		 mov	 r8d, 1426		; 00000592H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@LAEDPDD@?$AAa?$AAr?$AAg?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr@
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007f	33 c0		 xor	 eax, eax
$LN46@vgetargske:

; 1427 :     assert(keywords == NULL || PyDict_Check(keywords));

  00081	48 83 bc 24 a8
	03 00 00 00	 cmp	 QWORD PTR keywords$[rsp], 0
  0008a	74 37		 je	 SHORT $LN47@vgetargske
  0008c	48 8b 84 24 a8
	03 00 00	 mov	 rax, QWORD PTR keywords$[rsp]
  00094	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00098	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009e	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  000a3	85 c0		 test	 eax, eax
  000a5	75 1c		 jne	 SHORT $LN47@vgetargske
  000a7	41 b8 93 05 00
	00		 mov	 r8d, 1427		; 00000593H
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FG@FEEEBION@?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAD?$AAi?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk@
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c1	33 c0		 xor	 eax, eax
$LN47@vgetargske:

; 1428 :     assert(format != NULL);

  000c3	48 83 bc 24 b0
	03 00 00 00	 cmp	 QWORD PTR format$[rsp], 0
  000cc	75 1c		 jne	 SHORT $LN48@vgetargske
  000ce	41 b8 94 05 00
	00		 mov	 r8d, 1428		; 00000594H
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@MLMCMBKN@?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e8	33 c0		 xor	 eax, eax
$LN48@vgetargske:

; 1429 :     assert(kwlist != NULL);

  000ea	48 83 bc 24 b8
	03 00 00 00	 cmp	 QWORD PTR kwlist$[rsp], 0
  000f3	75 1c		 jne	 SHORT $LN49@vgetargske
  000f5	41 b8 95 05 00
	00		 mov	 r8d, 1429		; 00000595H
  000fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@GKDDPFH@?$AAk?$AAw?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0010f	33 c0		 xor	 eax, eax
$LN49@vgetargske:

; 1430 :     assert(p_va != NULL);

  00111	48 83 bc 24 c0
	03 00 00 00	 cmp	 QWORD PTR p_va$[rsp], 0
  0011a	75 1c		 jne	 SHORT $LN50@vgetargske
  0011c	41 b8 96 05 00
	00		 mov	 r8d, 1430		; 00000596H
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@MLJHDBA@?$AAp?$AA_?$AAv?$AAa?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00136	33 c0		 xor	 eax, eax
$LN50@vgetargske:

; 1431 : 
; 1432 :     /* grab the function name or custom error msg first (mutually exclusive) */
; 1433 :     fname = strchr(format, ':');

  00138	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  0013d	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR format$[rsp]
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  0014b	48 89 44 24 48	 mov	 QWORD PTR fname$[rsp], rax

; 1434 :     if (fname) {

  00150	48 83 7c 24 48
	00		 cmp	 QWORD PTR fname$[rsp], 0
  00156	74 1b		 je	 SHORT $LN42@vgetargske

; 1435 :         fname++;

  00158	48 8b 44 24 48	 mov	 rax, QWORD PTR fname$[rsp]
  0015d	48 ff c0	 inc	 rax
  00160	48 89 44 24 48	 mov	 QWORD PTR fname$[rsp], rax

; 1436 :         custom_msg = NULL;

  00165	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR custom_msg$[rsp], 0

; 1437 :     }
; 1438 :     else {

  00171	eb 39		 jmp	 SHORT $LN41@vgetargske
$LN42@vgetargske:

; 1439 :         custom_msg = strchr(format,';');

  00173	ba 3b 00 00 00	 mov	 edx, 59			; 0000003bH
  00178	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR format$[rsp]
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00186	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR custom_msg$[rsp], rax

; 1440 :         if (custom_msg)

  0018e	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR custom_msg$[rsp], 0
  00197	74 13		 je	 SHORT $LN40@vgetargske

; 1441 :             custom_msg++;

  00199	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR custom_msg$[rsp]
  001a1	48 ff c0	 inc	 rax
  001a4	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR custom_msg$[rsp], rax
$LN40@vgetargske:
$LN41@vgetargske:

; 1442 :     }
; 1443 : 
; 1444 :     /* scan kwlist and get greatest possible nbr of args */
; 1445 :     for (len=0; kwlist[len]; len++)

  001ac	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR len$[rsp], 0
  001b7	eb 10		 jmp	 SHORT $LN39@vgetargske
$LN38@vgetargske:
  001b9	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001c0	ff c0		 inc	 eax
  001c2	89 84 24 00 01
	00 00		 mov	 DWORD PTR len$[rsp], eax
$LN39@vgetargske:
  001c9	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  001d1	48 8b 8c 24 b8
	03 00 00	 mov	 rcx, QWORD PTR kwlist$[rsp]
  001d9	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  001de	74 04		 je	 SHORT $LN37@vgetargske

; 1446 :         continue;

  001e0	eb d7		 jmp	 SHORT $LN38@vgetargske
  001e2	eb d5		 jmp	 SHORT $LN38@vgetargske
$LN37@vgetargske:

; 1447 : 
; 1448 :     freelist.entries = PyMem_NEW(freelistentry_t, len);

  001e4	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  001ec	48 b9 ff ff ff
	ff ff ff ff 07	 mov	 rcx, 576460752303423487	; 07ffffffffffffffH
  001f6	48 3b c1	 cmp	 rax, rcx
  001f9	76 0e		 jbe	 SHORT $LN53@vgetargske
  001fb	48 c7 84 24 50
	03 00 00 00 00
	00 00		 mov	 QWORD PTR tv157[rsp], 0
  00207	eb 53		 jmp	 SHORT $LN54@vgetargske
$LN53@vgetargske:
  00209	e8 00 00 00 00	 call	 _Py_PXCTX
  0020e	85 c0		 test	 eax, eax
  00210	74 1e		 je	 SHORT $LN51@vgetargske
  00212	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0021a	48 6b c0 10	 imul	 rax, 16
  0021e	48 8b c8	 mov	 rcx, rax
  00221	e8 00 00 00 00	 call	 _PxMem_Malloc
  00226	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR tv156[rsp], rax
  0022e	eb 1c		 jmp	 SHORT $LN52@vgetargske
$LN51@vgetargske:
  00230	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00238	48 6b c0 10	 imul	 rax, 16
  0023c	48 8b c8	 mov	 rcx, rax
  0023f	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00244	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR tv156[rsp], rax
$LN52@vgetargske:
  0024c	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR tv156[rsp]
  00254	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR tv157[rsp], rax
$LN54@vgetargske:
  0025c	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR tv157[rsp]
  00264	48 89 44 24 70	 mov	 QWORD PTR freelist$[rsp+8], rax

; 1449 :     if (freelist.entries == NULL) {

  00269	48 83 7c 24 70
	00		 cmp	 QWORD PTR freelist$[rsp+8], 0
  0026f	75 0c		 jne	 SHORT $LN36@vgetargske

; 1450 :         PyErr_NoMemory();

  00271	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1451 :         return 0;

  00276	33 c0		 xor	 eax, eax
  00278	e9 36 07 00 00	 jmp	 $LN43@vgetargske
$LN36@vgetargske:

; 1452 :     }
; 1453 : 
; 1454 :     nargs = PyTuple_GET_SIZE(args);

  0027d	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00285	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00288	89 84 24 18 01
	00 00		 mov	 DWORD PTR nargs$[rsp], eax

; 1455 :     nkeywords = (keywords == NULL) ? 0 : PyDict_Size(keywords);

  0028f	48 83 bc 24 a8
	03 00 00 00	 cmp	 QWORD PTR keywords$[rsp], 0
  00298	75 0e		 jne	 SHORT $LN55@vgetargske
  0029a	48 c7 84 24 60
	03 00 00 00 00
	00 00		 mov	 QWORD PTR tv163[rsp], 0
  002a6	eb 15		 jmp	 SHORT $LN56@vgetargske
$LN55@vgetargske:
  002a8	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR keywords$[rsp]
  002b0	e8 00 00 00 00	 call	 PyDict_Size
  002b5	48 89 84 24 60
	03 00 00	 mov	 QWORD PTR tv163[rsp], rax
$LN56@vgetargske:
  002bd	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR tv163[rsp]
  002c4	89 44 24 50	 mov	 DWORD PTR nkeywords$[rsp], eax

; 1456 :     if (nargs + nkeywords > len) {

  002c8	8b 44 24 50	 mov	 eax, DWORD PTR nkeywords$[rsp]
  002cc	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR nargs$[rsp]
  002d3	03 c8		 add	 ecx, eax
  002d5	8b c1		 mov	 eax, ecx
  002d7	3b 84 24 00 01
	00 00		 cmp	 eax, DWORD PTR len$[rsp]
  002de	0f 8e d7 00 00
	00		 jle	 $LN35@vgetargske

; 1457 :         PyErr_Format(PyExc_TypeError,
; 1458 :                      "%s%s takes at most %d argument%s (%d given)",
; 1459 :                      (fname == NULL) ? "function" : fname,
; 1460 :                      (fname == NULL) ? "" : "()",
; 1461 :                      len,
; 1462 :                      (len == 1) ? "" : "s",
; 1463 :                      nargs + nkeywords);

  002e4	83 bc 24 00 01
	00 00 01	 cmp	 DWORD PTR len$[rsp], 1
  002ec	75 11		 jne	 SHORT $LN57@vgetargske
  002ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  002f5	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR tv171[rsp], rax
  002fd	eb 0f		 jmp	 SHORT $LN58@vgetargske
$LN57@vgetargske:
  002ff	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  00306	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR tv171[rsp], rax
$LN58@vgetargske:
  0030e	48 83 7c 24 48
	00		 cmp	 QWORD PTR fname$[rsp], 0
  00314	75 11		 jne	 SHORT $LN59@vgetargske
  00316	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0031d	48 89 84 24 70
	03 00 00	 mov	 QWORD PTR tv175[rsp], rax
  00325	eb 0f		 jmp	 SHORT $LN60@vgetargske
$LN59@vgetargske:
  00327	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0032e	48 89 84 24 70
	03 00 00	 mov	 QWORD PTR tv175[rsp], rax
$LN60@vgetargske:
  00336	48 83 7c 24 48
	00		 cmp	 QWORD PTR fname$[rsp], 0
  0033c	75 11		 jne	 SHORT $LN61@vgetargske
  0033e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08HFFPPCHF@function?$AA@
  00345	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR tv178[rsp], rax
  0034d	eb 0d		 jmp	 SHORT $LN62@vgetargske
$LN61@vgetargske:
  0034f	48 8b 44 24 48	 mov	 rax, QWORD PTR fname$[rsp]
  00354	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR tv178[rsp], rax
$LN62@vgetargske:
  0035c	8b 44 24 50	 mov	 eax, DWORD PTR nkeywords$[rsp]
  00360	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR nargs$[rsp]
  00367	03 c8		 add	 ecx, eax
  00369	8b c1		 mov	 eax, ecx
  0036b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0036f	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR tv171[rsp]
  00377	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0037c	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00383	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00387	4c 8b 8c 24 70
	03 00 00	 mov	 r9, QWORD PTR tv175[rsp]
  0038f	4c 8b 84 24 78
	03 00 00	 mov	 r8, QWORD PTR tv178[rsp]
  00397	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@DGNOJHNI@?$CFs?$CFs?5takes?5at?5most?5?$CFd?5argument?$CFs@
  0039e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  003a5	e8 00 00 00 00	 call	 PyErr_Format

; 1464 :         return cleanreturn(0, &freelist);

  003aa	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  003af	33 c9		 xor	 ecx, ecx
  003b1	e8 00 00 00 00	 call	 cleanreturn
  003b6	e9 f8 05 00 00	 jmp	 $LN43@vgetargske
$LN35@vgetargske:

; 1465 :     }
; 1466 : 
; 1467 :     /* convert tuple args and keyword args in same loop, using kwlist to drive process */
; 1468 :     for (i = 0; i < len; i++) {

  003bb	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003c3	eb 0a		 jmp	 SHORT $LN34@vgetargske
$LN33@vgetargske:
  003c5	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  003c9	ff c0		 inc	 eax
  003cb	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN34@vgetargske:
  003cf	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  003d6	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  003da	0f 8d 11 04 00
	00		 jge	 $LN32@vgetargske

; 1469 :         keyword = kwlist[i];

  003e0	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  003e5	48 8b 8c 24 b8
	03 00 00	 mov	 rcx, QWORD PTR kwlist$[rsp]
  003ed	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  003f1	48 89 44 24 60	 mov	 QWORD PTR keyword$[rsp], rax

; 1470 :         if (*format == '|') {

  003f6	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  003fe	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00401	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00404	75 7a		 jne	 SHORT $LN31@vgetargske

; 1471 :             if (min != INT_MAX) {

  00406	81 7c 24 58 ff
	ff ff 7f	 cmp	 DWORD PTR min$[rsp], 2147483647 ; 7fffffffH
  0040e	74 24		 je	 SHORT $LN30@vgetargske

; 1472 :                 PyErr_SetString(PyExc_RuntimeError,
; 1473 :                                 "Invalid format string (| specified twice)");

  00410	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@JJANEEBE@Invalid?5format?5string?5?$CI?$HM?5specifi@
  00417	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0041e	e8 00 00 00 00	 call	 PyErr_SetString

; 1474 :                 return cleanreturn(0, &freelist);

  00423	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  00428	33 c9		 xor	 ecx, ecx
  0042a	e8 00 00 00 00	 call	 cleanreturn
  0042f	e9 7f 05 00 00	 jmp	 $LN43@vgetargske
$LN30@vgetargske:

; 1475 :             }
; 1476 : 
; 1477 :             min = i;

  00434	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00438	89 44 24 58	 mov	 DWORD PTR min$[rsp], eax

; 1478 :             format++;

  0043c	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00444	48 ff c0	 inc	 rax
  00447	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR format$[rsp], rax

; 1479 : 
; 1480 :             if (max != INT_MAX) {

  0044f	81 bc 24 20 03
	00 00 ff ff ff
	7f		 cmp	 DWORD PTR max$[rsp], 2147483647 ; 7fffffffH
  0045a	74 24		 je	 SHORT $LN29@vgetargske

; 1481 :                 PyErr_SetString(PyExc_RuntimeError,
; 1482 :                                 "Invalid format string ($ before |)");

  0045c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@FHABLJPP@Invalid?5format?5string?5?$CI$?5before?5@
  00463	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0046a	e8 00 00 00 00	 call	 PyErr_SetString

; 1483 :                 return cleanreturn(0, &freelist);

  0046f	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  00474	33 c9		 xor	 ecx, ecx
  00476	e8 00 00 00 00	 call	 cleanreturn
  0047b	e9 33 05 00 00	 jmp	 $LN43@vgetargske
$LN29@vgetargske:
$LN31@vgetargske:

; 1484 :             }
; 1485 :         }
; 1486 :         if (*format == '$') {

  00480	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00488	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0048b	83 f8 24	 cmp	 eax, 36			; 00000024H
  0048e	0f 85 c8 00 00
	00		 jne	 $LN28@vgetargske

; 1487 :             if (max != INT_MAX) {

  00494	81 bc 24 20 03
	00 00 ff ff ff
	7f		 cmp	 DWORD PTR max$[rsp], 2147483647 ; 7fffffffH
  0049f	74 24		 je	 SHORT $LN27@vgetargske

; 1488 :                 PyErr_SetString(PyExc_RuntimeError,
; 1489 :                                 "Invalid format string ($ specified twice)");

  004a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@MOOGIOLD@Invalid?5format?5string?5?$CI$?5specifi@
  004a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  004af	e8 00 00 00 00	 call	 PyErr_SetString

; 1490 :                 return cleanreturn(0, &freelist);

  004b4	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  004b9	33 c9		 xor	 ecx, ecx
  004bb	e8 00 00 00 00	 call	 cleanreturn
  004c0	e9 ee 04 00 00	 jmp	 $LN43@vgetargske
$LN27@vgetargske:

; 1491 :             }
; 1492 : 
; 1493 :             max = i;

  004c5	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  004c9	89 84 24 20 03
	00 00		 mov	 DWORD PTR max$[rsp], eax

; 1494 :             format++;

  004d0	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  004d8	48 ff c0	 inc	 rax
  004db	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR format$[rsp], rax

; 1495 : 
; 1496 :             if (max < nargs) {

  004e3	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR nargs$[rsp]
  004ea	39 84 24 20 03
	00 00		 cmp	 DWORD PTR max$[rsp], eax
  004f1	7d 69		 jge	 SHORT $LN26@vgetargske

; 1497 :                 PyErr_Format(PyExc_TypeError,
; 1498 :                              "Function takes %s %d positional arguments"
; 1499 :                              " (%d given)",
; 1500 :                              (min != INT_MAX) ? "at most" : "exactly",
; 1501 :                              max, nargs);

  004f3	81 7c 24 58 ff
	ff ff 7f	 cmp	 DWORD PTR min$[rsp], 2147483647 ; 7fffffffH
  004fb	74 11		 je	 SHORT $LN63@vgetargske
  004fd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07IGBEEPOP@at?5most?$AA@
  00504	48 89 84 24 80
	03 00 00	 mov	 QWORD PTR tv218[rsp], rax
  0050c	eb 0f		 jmp	 SHORT $LN64@vgetargske
$LN63@vgetargske:
  0050e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07JLAGAGFH@exactly?$AA@
  00515	48 89 84 24 80
	03 00 00	 mov	 QWORD PTR tv218[rsp], rax
$LN64@vgetargske:
  0051d	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR nargs$[rsp]
  00524	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00528	44 8b 8c 24 20
	03 00 00	 mov	 r9d, DWORD PTR max$[rsp]
  00530	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR tv218[rsp]
  00538	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@BPFKLMMD@Function?5takes?5?$CFs?5?$CFd?5positional?5@
  0053f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00546	e8 00 00 00 00	 call	 PyErr_Format

; 1502 :                 return cleanreturn(0, &freelist);

  0054b	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  00550	33 c9		 xor	 ecx, ecx
  00552	e8 00 00 00 00	 call	 cleanreturn
  00557	e9 57 04 00 00	 jmp	 $LN43@vgetargske
$LN26@vgetargske:
$LN28@vgetargske:

; 1503 :             }
; 1504 :         }
; 1505 :         if (IS_END_OF_FORMAT(*format)) {

  0055c	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00564	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00567	85 c0		 test	 eax, eax
  00569	74 20		 je	 SHORT $LN24@vgetargske
  0056b	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00573	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00576	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00579	74 10		 je	 SHORT $LN24@vgetargske
  0057b	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00583	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00586	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00589	75 31		 jne	 SHORT $LN25@vgetargske
$LN24@vgetargske:

; 1506 :             PyErr_Format(PyExc_RuntimeError,
; 1507 :                          "More keyword list entries (%d) than "
; 1508 :                          "format specifiers (%d)", len, i);

  0058b	44 8b 4c 24 54	 mov	 r9d, DWORD PTR i$[rsp]
  00590	44 8b 84 24 00
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00598	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@LMLCHELD@More?5keyword?5list?5entries?5?$CI?$CFd?$CJ?5t@
  0059f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  005a6	e8 00 00 00 00	 call	 PyErr_Format

; 1509 :             return cleanreturn(0, &freelist);

  005ab	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  005b0	33 c9		 xor	 ecx, ecx
  005b2	e8 00 00 00 00	 call	 cleanreturn
  005b7	e9 f7 03 00 00	 jmp	 $LN43@vgetargske
$LN25@vgetargske:

; 1510 :         }
; 1511 :         current_arg = NULL;

  005bc	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR current_arg$[rsp], 0

; 1512 :         if (nkeywords) {

  005c5	83 7c 24 50 00	 cmp	 DWORD PTR nkeywords$[rsp], 0
  005ca	74 17		 je	 SHORT $LN23@vgetargske

; 1513 :             current_arg = PyDict_GetItemString(keywords, keyword);

  005cc	48 8b 54 24 60	 mov	 rdx, QWORD PTR keyword$[rsp]
  005d1	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR keywords$[rsp]
  005d9	e8 00 00 00 00	 call	 PyDict_GetItemString
  005de	48 89 44 24 40	 mov	 QWORD PTR current_arg$[rsp], rax
$LN23@vgetargske:

; 1514 :         }
; 1515 :         if (current_arg) {

  005e3	48 83 7c 24 40
	00		 cmp	 QWORD PTR current_arg$[rsp], 0
  005e9	74 4b		 je	 SHORT $LN22@vgetargske

; 1516 :             --nkeywords;

  005eb	8b 44 24 50	 mov	 eax, DWORD PTR nkeywords$[rsp]
  005ef	ff c8		 dec	 eax
  005f1	89 44 24 50	 mov	 DWORD PTR nkeywords$[rsp], eax

; 1517 :             if (i < nargs) {

  005f5	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR nargs$[rsp]
  005fc	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00600	7d 32		 jge	 SHORT $LN21@vgetargske

; 1518 :                 /* arg present in tuple and in dict */
; 1519 :                 PyErr_Format(PyExc_TypeError,
; 1520 :                              "Argument given by name ('%s') "
; 1521 :                              "and position (%d)",
; 1522 :                              keyword, i+1);

  00602	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00606	ff c0		 inc	 eax
  00608	44 8b c8	 mov	 r9d, eax
  0060b	4c 8b 44 24 60	 mov	 r8, QWORD PTR keyword$[rsp]
  00610	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@GILDFAFF@Argument?5given?5by?5name?5?$CI?8?$CFs?8?$CJ?5an@
  00617	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0061e	e8 00 00 00 00	 call	 PyErr_Format

; 1523 :                 return cleanreturn(0, &freelist);

  00623	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  00628	33 c9		 xor	 ecx, ecx
  0062a	e8 00 00 00 00	 call	 cleanreturn
  0062f	e9 7f 03 00 00	 jmp	 $LN43@vgetargske
$LN21@vgetargske:

; 1524 :             }

  00634	eb 48		 jmp	 SHORT $LN20@vgetargske
$LN22@vgetargske:

; 1525 :         }
; 1526 :         else if (nkeywords && PyErr_Occurred())

  00636	83 7c 24 50 00	 cmp	 DWORD PTR nkeywords$[rsp], 0
  0063b	74 1d		 je	 SHORT $LN19@vgetargske
  0063d	e8 00 00 00 00	 call	 PyErr_Occurred
  00642	48 85 c0	 test	 rax, rax
  00645	74 13		 je	 SHORT $LN19@vgetargske

; 1527 :             return cleanreturn(0, &freelist);

  00647	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  0064c	33 c9		 xor	 ecx, ecx
  0064e	e8 00 00 00 00	 call	 cleanreturn
  00653	e9 5b 03 00 00	 jmp	 $LN43@vgetargske
  00658	eb 24		 jmp	 SHORT $LN18@vgetargske
$LN19@vgetargske:

; 1528 :         else if (i < nargs)

  0065a	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR nargs$[rsp]
  00661	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00665	7d 17		 jge	 SHORT $LN17@vgetargske

; 1529 :             current_arg = PyTuple_GET_ITEM(args, i);

  00667	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0066c	48 8b 8c 24 a0
	03 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00674	48 8b 44 c1 70	 mov	 rax, QWORD PTR [rcx+rax*8+112]
  00679	48 89 44 24 40	 mov	 QWORD PTR current_arg$[rsp], rax
$LN17@vgetargske:
$LN18@vgetargske:
$LN20@vgetargske:

; 1530 : 
; 1531 :         if (current_arg) {

  0067e	48 83 7c 24 40
	00		 cmp	 QWORD PTR current_arg$[rsp], 0
  00684	0f 84 a7 00 00
	00		 je	 $LN16@vgetargske

; 1532 :             msg = convertitem(current_arg, &format, p_va, flags,
; 1533 :                 levels, msgbuf, sizeof(msgbuf), &freelist);

  0068a	48 8d 44 24 68	 lea	 rax, QWORD PTR freelist$[rsp]
  0068f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00694	48 c7 44 24 30
	00 02 00 00	 mov	 QWORD PTR [rsp+48], 512	; 00000200H
  0069d	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR msgbuf$[rsp]
  006a5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006aa	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR levels$[rsp]
  006b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006b7	44 8b 8c 24 c8
	03 00 00	 mov	 r9d, DWORD PTR flags$[rsp]
  006bf	4c 8b 84 24 c0
	03 00 00	 mov	 r8, QWORD PTR p_va$[rsp]
  006c7	48 8d 94 24 b0
	03 00 00	 lea	 rdx, QWORD PTR format$[rsp]
  006cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR current_arg$[rsp]
  006d4	e8 00 00 00 00	 call	 convertitem
  006d9	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR msg$[rsp], rax

; 1534 :             if (msg) {

  006e1	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR msg$[rsp], 0
  006ea	74 40		 je	 SHORT $LN15@vgetargske

; 1535 :                 seterror(i+1, msg, levels, fname, custom_msg);

  006ec	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  006f0	ff c0		 inc	 eax
  006f2	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR custom_msg$[rsp]
  006fa	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  006ff	4c 8b 4c 24 48	 mov	 r9, QWORD PTR fname$[rsp]
  00704	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR levels$[rsp]
  0070c	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR msg$[rsp]
  00714	8b c8		 mov	 ecx, eax
  00716	e8 00 00 00 00	 call	 seterror

; 1536 :                 return cleanreturn(0, &freelist);

  0071b	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  00720	33 c9		 xor	 ecx, ecx
  00722	e8 00 00 00 00	 call	 cleanreturn
  00727	e9 87 02 00 00	 jmp	 $LN43@vgetargske
$LN15@vgetargske:

; 1537 :             }
; 1538 :             continue;

  0072c	e9 94 fc ff ff	 jmp	 $LN33@vgetargske
$LN16@vgetargske:

; 1539 :         }
; 1540 : 
; 1541 :         if (i < min) {

  00731	8b 44 24 58	 mov	 eax, DWORD PTR min$[rsp]
  00735	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00739	7d 32		 jge	 SHORT $LN14@vgetargske

; 1542 :             PyErr_Format(PyExc_TypeError, "Required argument "
; 1543 :                          "'%s' (pos %d) not found",
; 1544 :                          keyword, i+1);

  0073b	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0073f	ff c0		 inc	 eax
  00741	44 8b c8	 mov	 r9d, eax
  00744	4c 8b 44 24 60	 mov	 r8, QWORD PTR keyword$[rsp]
  00749	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@HKBBODMD@Required?5argument?5?8?$CFs?8?5?$CIpos?5?$CFd?$CJ?5@
  00750	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00757	e8 00 00 00 00	 call	 PyErr_Format

; 1545 :             return cleanreturn(0, &freelist);

  0075c	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  00761	33 c9		 xor	 ecx, ecx
  00763	e8 00 00 00 00	 call	 cleanreturn
  00768	e9 46 02 00 00	 jmp	 $LN43@vgetargske
$LN14@vgetargske:

; 1546 :         }
; 1547 :         /* current code reports success when all required args
; 1548 :          * fulfilled and no keyword args left, with no further
; 1549 :          * validation. XXX Maybe skip this in debug build ?
; 1550 :          */
; 1551 :         if (!nkeywords)

  0076d	83 7c 24 50 00	 cmp	 DWORD PTR nkeywords$[rsp], 0
  00772	75 14		 jne	 SHORT $LN13@vgetargske

; 1552 :             return cleanreturn(1, &freelist);

  00774	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  00779	b9 01 00 00 00	 mov	 ecx, 1
  0077e	e8 00 00 00 00	 call	 cleanreturn
  00783	e9 2b 02 00 00	 jmp	 $LN43@vgetargske
$LN13@vgetargske:

; 1553 : 
; 1554 :         /* We are into optional args, skip thru to any remaining
; 1555 :          * keyword args */
; 1556 :         msg = skipitem(&format, p_va, flags);

  00788	44 8b 84 24 c8
	03 00 00	 mov	 r8d, DWORD PTR flags$[rsp]
  00790	48 8b 94 24 c0
	03 00 00	 mov	 rdx, QWORD PTR p_va$[rsp]
  00798	48 8d 8c 24 b0
	03 00 00	 lea	 rcx, QWORD PTR format$[rsp]
  007a0	e8 00 00 00 00	 call	 skipitem
  007a5	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR msg$[rsp], rax

; 1557 :         if (msg) {

  007ad	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR msg$[rsp], 0
  007b6	74 34		 je	 SHORT $LN12@vgetargske

; 1558 :             PyErr_Format(PyExc_RuntimeError, "%s: '%s'", msg,
; 1559 :                          format);

  007b8	4c 8b 8c 24 b0
	03 00 00	 mov	 r9, QWORD PTR format$[rsp]
  007c0	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR msg$[rsp]
  007c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08JAIPINJA@?$CFs?3?5?8?$CFs?8?$AA@
  007cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  007d6	e8 00 00 00 00	 call	 PyErr_Format

; 1560 :             return cleanreturn(0, &freelist);

  007db	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  007e0	33 c9		 xor	 ecx, ecx
  007e2	e8 00 00 00 00	 call	 cleanreturn
  007e7	e9 c7 01 00 00	 jmp	 $LN43@vgetargske
$LN12@vgetargske:

; 1561 :         }
; 1562 :     }

  007ec	e9 d4 fb ff ff	 jmp	 $LN33@vgetargske
$LN32@vgetargske:

; 1563 : 
; 1564 :     if (!IS_END_OF_FORMAT(*format) && (*format != '|') && (*format != '$')) {

  007f1	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  007f9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  007fc	85 c0		 test	 eax, eax
  007fe	74 6c		 je	 SHORT $LN11@vgetargske
  00800	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00808	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0080b	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  0080e	74 5c		 je	 SHORT $LN11@vgetargske
  00810	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00818	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0081b	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0081e	74 4c		 je	 SHORT $LN11@vgetargske
  00820	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00828	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0082b	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  0082e	74 3c		 je	 SHORT $LN11@vgetargske
  00830	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00838	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0083b	83 f8 24	 cmp	 eax, 36			; 00000024H
  0083e	74 2c		 je	 SHORT $LN11@vgetargske

; 1565 :         PyErr_Format(PyExc_RuntimeError,
; 1566 :             "more argument specifiers than keyword list entries "
; 1567 :             "(remaining format:'%s')", format);

  00840	4c 8b 84 24 b0
	03 00 00	 mov	 r8, QWORD PTR format$[rsp]
  00848	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@FLEHBPOJ@more?5argument?5specifiers?5than?5ke@
  0084f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00856	e8 00 00 00 00	 call	 PyErr_Format

; 1568 :         return cleanreturn(0, &freelist);

  0085b	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  00860	33 c9		 xor	 ecx, ecx
  00862	e8 00 00 00 00	 call	 cleanreturn
  00867	e9 47 01 00 00	 jmp	 $LN43@vgetargske
$LN11@vgetargske:

; 1569 :     }
; 1570 : 
; 1571 :     /* make sure there are no extraneous keyword arguments */
; 1572 :     if (nkeywords > 0) {

  0086c	83 7c 24 50 00	 cmp	 DWORD PTR nkeywords$[rsp], 0
  00871	0f 8e 2d 01 00
	00		 jle	 $LN10@vgetargske

; 1573 :         PyObject *key, *value;
; 1574 :         Py_ssize_t pos = 0;

  00877	48 c7 84 24 38
	03 00 00 00 00
	00 00		 mov	 QWORD PTR pos$21910[rsp], 0
$LN9@vgetargske:

; 1575 :         while (PyDict_Next(keywords, &pos, &key, &value)) {

  00883	4c 8d 8c 24 28
	03 00 00	 lea	 r9, QWORD PTR value$21909[rsp]
  0088b	4c 8d 84 24 30
	03 00 00	 lea	 r8, QWORD PTR key$21908[rsp]
  00893	48 8d 94 24 38
	03 00 00	 lea	 rdx, QWORD PTR pos$21910[rsp]
  0089b	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR keywords$[rsp]
  008a3	e8 00 00 00 00	 call	 PyDict_Next
  008a8	85 c0		 test	 eax, eax
  008aa	0f 84 f4 00 00
	00		 je	 $LN8@vgetargske

; 1576 :             int match = 0;

  008b0	c7 84 24 48 03
	00 00 00 00 00
	00		 mov	 DWORD PTR match$21914[rsp], 0

; 1577 :             char *ks;
; 1578 :             if (!PyUnicode_Check(key)) {

  008bb	48 8b 84 24 30
	03 00 00	 mov	 rax, QWORD PTR key$21908[rsp]
  008c3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  008c7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  008cd	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  008d2	85 c0		 test	 eax, eax
  008d4	75 24		 jne	 SHORT $LN7@vgetargske

; 1579 :                 PyErr_SetString(PyExc_TypeError,
; 1580 :                                 "keywords must be strings");

  008d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@LEGLBJFG@keywords?5must?5be?5strings?$AA@
  008dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  008e4	e8 00 00 00 00	 call	 PyErr_SetString

; 1581 :                 return cleanreturn(0, &freelist);

  008e9	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  008ee	33 c9		 xor	 ecx, ecx
  008f0	e8 00 00 00 00	 call	 cleanreturn
  008f5	e9 b9 00 00 00	 jmp	 $LN43@vgetargske
$LN7@vgetargske:

; 1582 :             }
; 1583 :             /* check that _PyUnicode_AsString() result is not NULL */
; 1584 :             ks = _PyUnicode_AsString(key);

  008fa	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR key$21908[rsp]
  00902	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00907	48 89 84 24 40
	03 00 00	 mov	 QWORD PTR ks$21915[rsp], rax

; 1585 :             if (ks != NULL) {

  0090f	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR ks$21915[rsp], 0
  00918	74 52		 je	 SHORT $LN6@vgetargske

; 1586 :                 for (i = 0; i < len; i++) {

  0091a	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00922	eb 0a		 jmp	 SHORT $LN5@vgetargske
$LN4@vgetargske:
  00924	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00928	ff c0		 inc	 eax
  0092a	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN5@vgetargske:
  0092e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00935	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00939	7d 31		 jge	 SHORT $LN3@vgetargske

; 1587 :                     if (!strcmp(ks, kwlist[i])) {

  0093b	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  00940	48 8b 8c 24 b8
	03 00 00	 mov	 rcx, QWORD PTR kwlist$[rsp]
  00948	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0094c	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR ks$21915[rsp]
  00954	e8 00 00 00 00	 call	 strcmp
  00959	85 c0		 test	 eax, eax
  0095b	75 0d		 jne	 SHORT $LN2@vgetargske

; 1588 :                         match = 1;

  0095d	c7 84 24 48 03
	00 00 01 00 00
	00		 mov	 DWORD PTR match$21914[rsp], 1

; 1589 :                         break;

  00968	eb 02		 jmp	 SHORT $LN3@vgetargske
$LN2@vgetargske:

; 1590 :                     }
; 1591 :                 }

  0096a	eb b8		 jmp	 SHORT $LN4@vgetargske
$LN3@vgetargske:
$LN6@vgetargske:

; 1592 :             }
; 1593 :             if (!match) {

  0096c	83 bc 24 48 03
	00 00 00	 cmp	 DWORD PTR match$21914[rsp], 0
  00974	75 29		 jne	 SHORT $LN1@vgetargske

; 1594 :                 PyErr_Format(PyExc_TypeError,
; 1595 :                              "'%U' is an invalid keyword "
; 1596 :                              "argument for this function",
; 1597 :                              key);

  00976	4c 8b 84 24 30
	03 00 00	 mov	 r8, QWORD PTR key$21908[rsp]
  0097e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@ENKIDNFE@?8?$CFU?8?5is?5an?5invalid?5keyword?5argum@
  00985	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0098c	e8 00 00 00 00	 call	 PyErr_Format

; 1598 :                 return cleanreturn(0, &freelist);

  00991	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  00996	33 c9		 xor	 ecx, ecx
  00998	e8 00 00 00 00	 call	 cleanreturn
  0099d	eb 14		 jmp	 SHORT $LN43@vgetargske
$LN1@vgetargske:

; 1599 :             }
; 1600 :         }

  0099f	e9 df fe ff ff	 jmp	 $LN9@vgetargske
$LN8@vgetargske:
$LN10@vgetargske:

; 1601 :     }
; 1602 : 
; 1603 :     return cleanreturn(1, &freelist);

  009a4	48 8d 54 24 68	 lea	 rdx, QWORD PTR freelist$[rsp]
  009a9	b9 01 00 00 00	 mov	 ecx, 1
  009ae	e8 00 00 00 00	 call	 cleanreturn
$LN43@vgetargske:

; 1604 : }

  009b3	48 81 c4 98 03
	00 00		 add	 rsp, 920		; 00000398H
  009ba	c3		 ret	 0
vgetargskeywords ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@NJHPCPND@Unmatched?5right?5paren?5in?5format?5@ ; `string'
PUBLIC	??_C@_0CG@JJFFKGEA@Unmatched?5left?5paren?5in?5format?5s@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$skipitem DD imagerel skipitem
	DD	imagerel skipitem+803
	DD	imagerel $unwind$skipitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$skipitem DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0CH@NJHPCPND@Unmatched?5right?5paren?5in?5format?5@
CONST	SEGMENT
??_C@_0CH@NJHPCPND@Unmatched?5right?5paren?5in?5format?5@ DB 'Unmatched r'
	DB	'ight paren in format string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JJFFKGEA@Unmatched?5left?5paren?5in?5format?5s@
CONST	SEGMENT
??_C@_0CG@JJFFKGEA@Unmatched?5left?5paren?5in?5format?5s@ DB 'Unmatched l'
	DB	'eft paren in format string', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT skipitem
_TEXT	SEGMENT
format$ = 32
c$ = 40
msg$22070 = 48
tv66 = 56
p_format$ = 80
p_va$ = 88
flags$ = 96
skipitem PROC						; COMDAT

; 1609 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1610 :     const char *format = *p_format;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR p_format$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 20	 mov	 QWORD PTR format$[rsp], rax

; 1611 :     char c = *format++;

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00025	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00028	88 44 24 28	 mov	 BYTE PTR c$[rsp], al
  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00031	48 ff c0	 inc	 rax
  00034	48 89 44 24 20	 mov	 QWORD PTR format$[rsp], rax

; 1612 : 
; 1613 :     switch (c) {

  00039	0f be 44 24 28	 movsx	 eax, BYTE PTR c$[rsp]
  0003e	89 44 24 38	 mov	 DWORD PTR tv66[rsp], eax
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv66[rsp]
  00046	83 e8 28	 sub	 eax, 40			; 00000028H
  00049	89 44 24 38	 mov	 DWORD PTR tv66[rsp], eax
  0004d	83 7c 24 38 52	 cmp	 DWORD PTR tv66[rsp], 82	; 00000052H
  00052	0f 87 3c 02 00
	00		 ja	 $LN1@skipitem
  00058	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv66[rsp]
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00064	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN29@skipitem[rcx+rax]
  0006c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN30@skipitem[rcx+rax*4]
  00073	48 03 c1	 add	 rax, rcx
  00076	ff e0		 jmp	 rax
$LN24@skipitem:

; 1614 : 
; 1615 :     /*
; 1616 :      * codes that take a single data pointer as an argument
; 1617 :      * (the type of the pointer is irrelevant)
; 1618 :      */
; 1619 : 
; 1620 :     case 'b': /* byte -- very short int */
; 1621 :     case 'B': /* byte as bitfield */
; 1622 :     case 'h': /* short int */
; 1623 :     case 'H': /* short int as bitfield */
; 1624 :     case 'i': /* int */
; 1625 :     case 'I': /* int sized bitfield */
; 1626 :     case 'l': /* long int */
; 1627 :     case 'k': /* long int sized bitfield */
; 1628 : #ifdef HAVE_LONG_LONG
; 1629 :     case 'L': /* PY_LONG_LONG */
; 1630 :     case 'K': /* PY_LONG_LONG sized bitfield */
; 1631 : #endif
; 1632 :     case 'n': /* Py_ssize_t */
; 1633 :     case 'f': /* float */
; 1634 :     case 'd': /* double */
; 1635 :     case 'D': /* complex double */
; 1636 :     case 'c': /* char */
; 1637 :     case 'C': /* unicode char */
; 1638 :     case 'p': /* boolean predicate */
; 1639 :     case 'S': /* string object */
; 1640 :     case 'Y': /* string object */
; 1641 :     case 'U': /* unicode string object */
; 1642 :         {
; 1643 :             (void) va_arg(*p_va, void *);

  00078	48 8b 44 24 58	 mov	 rax, QWORD PTR p_va$[rsp]
  0007d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00080	48 83 c0 08	 add	 rax, 8
  00084	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p_va$[rsp]
  00089	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1644 :             break;

  0008c	e9 0c 02 00 00	 jmp	 $LN25@skipitem
$LN23@skipitem:

; 1645 :         }
; 1646 : 
; 1647 :     /* string codes */
; 1648 : 
; 1649 :     case 'e': /* string with encoding */
; 1650 :         {
; 1651 :             (void) va_arg(*p_va, const char *);

  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR p_va$[rsp]
  00096	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00099	48 83 c0 08	 add	 rax, 8
  0009d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p_va$[rsp]
  000a2	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1652 :             if (!(*format == 's' || *format == 't'))

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  000aa	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ad	83 f8 73	 cmp	 eax, 115		; 00000073H
  000b0	74 12		 je	 SHORT $LN22@skipitem
  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  000b7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ba	83 f8 74	 cmp	 eax, 116		; 00000074H
  000bd	74 05		 je	 SHORT $LN22@skipitem

; 1653 :                 /* after 'e', only 's' and 't' is allowed */
; 1654 :                 goto err;

  000bf	e9 d0 01 00 00	 jmp	 $err$21965
$LN22@skipitem:

; 1655 :             format++;

  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  000c9	48 ff c0	 inc	 rax
  000cc	48 89 44 24 20	 mov	 QWORD PTR format$[rsp], rax
$LN21@skipitem:

; 1656 :             /* explicit fallthrough to string cases */
; 1657 :         }
; 1658 : 
; 1659 :     case 's': /* string */
; 1660 :     case 'z': /* string or None */
; 1661 :     case 'y': /* bytes */
; 1662 :     case 'u': /* unicode string */
; 1663 :     case 'Z': /* unicode string or None */
; 1664 :     case 'w': /* buffer, read-write */
; 1665 :         {
; 1666 :             (void) va_arg(*p_va, char **);

  000d1	48 8b 44 24 58	 mov	 rax, QWORD PTR p_va$[rsp]
  000d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d9	48 83 c0 08	 add	 rax, 8
  000dd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p_va$[rsp]
  000e2	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1667 :             if (*format == '#') {

  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  000ea	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ed	83 f8 23	 cmp	 eax, 35			; 00000023H
  000f0	75 44		 jne	 SHORT $LN20@skipitem

; 1668 :                 if (flags & FLAG_SIZE_T)

  000f2	8b 44 24 60	 mov	 eax, DWORD PTR flags$[rsp]
  000f6	83 e0 02	 and	 eax, 2
  000f9	85 c0		 test	 eax, eax
  000fb	74 16		 je	 SHORT $LN19@skipitem

; 1669 :                     (void) va_arg(*p_va, Py_ssize_t *);

  000fd	48 8b 44 24 58	 mov	 rax, QWORD PTR p_va$[rsp]
  00102	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00105	48 83 c0 08	 add	 rax, 8
  00109	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p_va$[rsp]
  0010e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1670 :                 else

  00111	eb 14		 jmp	 SHORT $LN18@skipitem
$LN19@skipitem:

; 1671 :                     (void) va_arg(*p_va, int *);

  00113	48 8b 44 24 58	 mov	 rax, QWORD PTR p_va$[rsp]
  00118	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011b	48 83 c0 08	 add	 rax, 8
  0011f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p_va$[rsp]
  00124	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN18@skipitem:

; 1672 :                 format++;

  00127	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  0012c	48 ff c0	 inc	 rax
  0012f	48 89 44 24 20	 mov	 QWORD PTR format$[rsp], rax
  00134	eb 38		 jmp	 SHORT $LN17@skipitem
$LN20@skipitem:

; 1673 :             } else if ((c == 's' || c == 'z' || c == 'y') && *format == '*') {

  00136	0f be 44 24 28	 movsx	 eax, BYTE PTR c$[rsp]
  0013b	83 f8 73	 cmp	 eax, 115		; 00000073H
  0013e	74 14		 je	 SHORT $LN15@skipitem
  00140	0f be 44 24 28	 movsx	 eax, BYTE PTR c$[rsp]
  00145	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00148	74 0a		 je	 SHORT $LN15@skipitem
  0014a	0f be 44 24 28	 movsx	 eax, BYTE PTR c$[rsp]
  0014f	83 f8 79	 cmp	 eax, 121		; 00000079H
  00152	75 1a		 jne	 SHORT $LN16@skipitem
$LN15@skipitem:
  00154	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00159	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0015c	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0015f	75 0d		 jne	 SHORT $LN16@skipitem

; 1674 :                 format++;

  00161	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00166	48 ff c0	 inc	 rax
  00169	48 89 44 24 20	 mov	 QWORD PTR format$[rsp], rax
$LN16@skipitem:
$LN17@skipitem:

; 1675 :             }
; 1676 :             break;

  0016e	e9 2a 01 00 00	 jmp	 $LN25@skipitem
$LN14@skipitem:

; 1677 :         }
; 1678 : 
; 1679 :     case 'O': /* object */
; 1680 :         {
; 1681 :             if (*format == '!') {

  00173	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00178	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0017b	83 f8 21	 cmp	 eax, 33			; 00000021H
  0017e	75 37		 jne	 SHORT $LN13@skipitem

; 1682 :                 format++;

  00180	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00185	48 ff c0	 inc	 rax
  00188	48 89 44 24 20	 mov	 QWORD PTR format$[rsp], rax

; 1683 :                 (void) va_arg(*p_va, PyTypeObject*);

  0018d	48 8b 44 24 58	 mov	 rax, QWORD PTR p_va$[rsp]
  00192	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00195	48 83 c0 08	 add	 rax, 8
  00199	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p_va$[rsp]
  0019e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1684 :                 (void) va_arg(*p_va, PyObject **);

  001a1	48 8b 44 24 58	 mov	 rax, QWORD PTR p_va$[rsp]
  001a6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a9	48 83 c0 08	 add	 rax, 8
  001ad	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p_va$[rsp]
  001b2	48 89 01	 mov	 QWORD PTR [rcx], rax
  001b5	eb 58		 jmp	 SHORT $LN12@skipitem
$LN13@skipitem:

; 1685 :             }
; 1686 :             else if (*format == '&') {

  001b7	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  001bc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001bf	83 f8 26	 cmp	 eax, 38			; 00000026H
  001c2	75 37		 jne	 SHORT $LN11@skipitem

; 1687 :                 typedef int (*converter)(PyObject *, void *);
; 1688 :                 (void) va_arg(*p_va, converter);

  001c4	48 8b 44 24 58	 mov	 rax, QWORD PTR p_va$[rsp]
  001c9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cc	48 83 c0 08	 add	 rax, 8
  001d0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p_va$[rsp]
  001d5	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1689 :                 (void) va_arg(*p_va, void *);

  001d8	48 8b 44 24 58	 mov	 rax, QWORD PTR p_va$[rsp]
  001dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e0	48 83 c0 08	 add	 rax, 8
  001e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p_va$[rsp]
  001e9	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1690 :                 format++;

  001ec	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  001f1	48 ff c0	 inc	 rax
  001f4	48 89 44 24 20	 mov	 QWORD PTR format$[rsp], rax

; 1691 :             }
; 1692 :             else {

  001f9	eb 14		 jmp	 SHORT $LN10@skipitem
$LN11@skipitem:

; 1693 :                 (void) va_arg(*p_va, PyObject **);

  001fb	48 8b 44 24 58	 mov	 rax, QWORD PTR p_va$[rsp]
  00200	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00203	48 83 c0 08	 add	 rax, 8
  00207	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p_va$[rsp]
  0020c	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN10@skipitem:
$LN12@skipitem:

; 1694 :             }
; 1695 :             break;

  0020f	e9 89 00 00 00	 jmp	 $LN25@skipitem
$LN9@skipitem:
$LN8@skipitem:

; 1696 :         }
; 1697 : 
; 1698 :     case '(':           /* bypass tuple, not handled at all previously */
; 1699 :         {
; 1700 :             char *msg;
; 1701 :             for (;;) {
; 1702 :                 if (*format==')')

  00214	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00219	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0021c	83 f8 29	 cmp	 eax, 41			; 00000029H
  0021f	75 02		 jne	 SHORT $LN6@skipitem

; 1703 :                     break;

  00221	eb 59		 jmp	 SHORT $LN7@skipitem
$LN6@skipitem:

; 1704 :                 if (IS_END_OF_FORMAT(*format))

  00223	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00228	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0022b	85 c0		 test	 eax, eax
  0022d	74 1a		 je	 SHORT $LN4@skipitem
  0022f	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00234	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00237	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  0023a	74 0d		 je	 SHORT $LN4@skipitem
  0023c	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00241	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00244	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00247	75 09		 jne	 SHORT $LN5@skipitem
$LN4@skipitem:

; 1705 :                     return "Unmatched left paren in format "
; 1706 :                            "string";

  00249	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CG@JJFFKGEA@Unmatched?5left?5paren?5in?5format?5s@
  00250	eb 5a		 jmp	 SHORT $LN27@skipitem
$LN5@skipitem:

; 1707 :                 msg = skipitem(&format, p_va, flags);

  00252	44 8b 44 24 60	 mov	 r8d, DWORD PTR flags$[rsp]
  00257	48 8b 54 24 58	 mov	 rdx, QWORD PTR p_va$[rsp]
  0025c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR format$[rsp]
  00261	e8 00 00 00 00	 call	 skipitem
  00266	48 89 44 24 30	 mov	 QWORD PTR msg$22070[rsp], rax

; 1708 :                 if (msg)

  0026b	48 83 7c 24 30
	00		 cmp	 QWORD PTR msg$22070[rsp], 0
  00271	74 07		 je	 SHORT $LN3@skipitem

; 1709 :                     return msg;

  00273	48 8b 44 24 30	 mov	 rax, QWORD PTR msg$22070[rsp]
  00278	eb 32		 jmp	 SHORT $LN27@skipitem
$LN3@skipitem:

; 1710 :             }

  0027a	eb 98		 jmp	 SHORT $LN8@skipitem
$LN7@skipitem:

; 1711 :             format++;

  0027c	48 8b 44 24 20	 mov	 rax, QWORD PTR format$[rsp]
  00281	48 ff c0	 inc	 rax
  00284	48 89 44 24 20	 mov	 QWORD PTR format$[rsp], rax

; 1712 :             break;

  00289	eb 12		 jmp	 SHORT $LN25@skipitem
$LN2@skipitem:

; 1713 :         }
; 1714 : 
; 1715 :     case ')':
; 1716 :         return "Unmatched right paren in format string";

  0028b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CH@NJHPCPND@Unmatched?5right?5paren?5in?5format?5@
  00292	eb 18		 jmp	 SHORT $LN27@skipitem
$LN1@skipitem:
$err$21965:

; 1717 : 
; 1718 :     default:
; 1719 : err:
; 1720 :         return "impossible<bad format char>";

  00294	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IMALOFOA@impossible?$DMbad?5format?5char?$DO?$AA@
  0029b	eb 0f		 jmp	 SHORT $LN27@skipitem
$LN25@skipitem:

; 1721 : 
; 1722 :     }
; 1723 : 
; 1724 :     *p_format = format;

  0029d	48 8b 44 24 50	 mov	 rax, QWORD PTR p_format$[rsp]
  002a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR format$[rsp]
  002a7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1725 :     return NULL;

  002aa	33 c0		 xor	 eax, eax
$LN27@skipitem:

; 1726 : }

  002ac	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002b0	c3		 ret	 0
  002b1	0f 1f 00	 npad	 3
$LN30@skipitem:
  002b4	00 00 00 00	 DD	 $LN9@skipitem
  002b8	00 00 00 00	 DD	 $LN2@skipitem
  002bc	00 00 00 00	 DD	 $LN24@skipitem
  002c0	00 00 00 00	 DD	 $LN14@skipitem
  002c4	00 00 00 00	 DD	 $LN21@skipitem
  002c8	00 00 00 00	 DD	 $LN23@skipitem
  002cc	00 00 00 00	 DD	 $LN1@skipitem
$LN29@skipitem:
  002d0	00		 DB	 0
  002d1	01		 DB	 1
  002d2	06		 DB	 6
  002d3	06		 DB	 6
  002d4	06		 DB	 6
  002d5	06		 DB	 6
  002d6	06		 DB	 6
  002d7	06		 DB	 6
  002d8	06		 DB	 6
  002d9	06		 DB	 6
  002da	06		 DB	 6
  002db	06		 DB	 6
  002dc	06		 DB	 6
  002dd	06		 DB	 6
  002de	06		 DB	 6
  002df	06		 DB	 6
  002e0	06		 DB	 6
  002e1	06		 DB	 6
  002e2	06		 DB	 6
  002e3	06		 DB	 6
  002e4	06		 DB	 6
  002e5	06		 DB	 6
  002e6	06		 DB	 6
  002e7	06		 DB	 6
  002e8	06		 DB	 6
  002e9	06		 DB	 6
  002ea	02		 DB	 2
  002eb	02		 DB	 2
  002ec	02		 DB	 2
  002ed	06		 DB	 6
  002ee	06		 DB	 6
  002ef	06		 DB	 6
  002f0	02		 DB	 2
  002f1	02		 DB	 2
  002f2	06		 DB	 6
  002f3	02		 DB	 2
  002f4	02		 DB	 2
  002f5	06		 DB	 6
  002f6	06		 DB	 6
  002f7	03		 DB	 3
  002f8	06		 DB	 6
  002f9	06		 DB	 6
  002fa	06		 DB	 6
  002fb	02		 DB	 2
  002fc	06		 DB	 6
  002fd	02		 DB	 2
  002fe	06		 DB	 6
  002ff	06		 DB	 6
  00300	06		 DB	 6
  00301	02		 DB	 2
  00302	04		 DB	 4
  00303	06		 DB	 6
  00304	06		 DB	 6
  00305	06		 DB	 6
  00306	06		 DB	 6
  00307	06		 DB	 6
  00308	06		 DB	 6
  00309	06		 DB	 6
  0030a	02		 DB	 2
  0030b	02		 DB	 2
  0030c	02		 DB	 2
  0030d	05		 DB	 5
  0030e	02		 DB	 2
  0030f	06		 DB	 6
  00310	02		 DB	 2
  00311	02		 DB	 2
  00312	06		 DB	 6
  00313	02		 DB	 2
  00314	02		 DB	 2
  00315	06		 DB	 6
  00316	02		 DB	 2
  00317	06		 DB	 6
  00318	02		 DB	 2
  00319	06		 DB	 6
  0031a	06		 DB	 6
  0031b	04		 DB	 4
  0031c	06		 DB	 6
  0031d	04		 DB	 4
  0031e	06		 DB	 6
  0031f	04		 DB	 4
  00320	06		 DB	 6
  00321	04		 DB	 4
  00322	04		 DB	 4
skipitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_08KFLHMPAE@at?5most?5?$AA@		; `string'
PUBLIC	??_C@_0DH@OGLEKFEB@unpacked?5tuple?5should?5have?5?$CFs?$CFzd@ ; `string'
PUBLIC	??_C@_0CF@FMANCKCI@?$CFs?5expected?5?$CFs?$CFzd?5arguments?0?5got@ ; `string'
PUBLIC	??_C@_09HJOCAFJB@at?5least?5?$AA@		; `string'
PUBLIC	??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@ ; `string'
PUBLIC	??_C@_1BG@LLJJJCND@?$AAm?$AAi?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAa?$AAx?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@KILMLMLB@?$AAm?$AAi?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	PyArg_UnpackTuple
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyArg_UnpackTuple DD imagerel $LN23
	DD	imagerel $LN23+775
	DD	imagerel $unwind$PyArg_UnpackTuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyArg_UnpackTuple DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT ??_C@_08KFLHMPAE@at?5most?5?$AA@
CONST	SEGMENT
??_C@_08KFLHMPAE@at?5most?5?$AA@ DB 'at most ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@OGLEKFEB@unpacked?5tuple?5should?5have?5?$CFs?$CFzd@
CONST	SEGMENT
??_C@_0DH@OGLEKFEB@unpacked?5tuple?5should?5have?5?$CFs?$CFzd@ DB 'unpack'
	DB	'ed tuple should have %s%zd elements, but has %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FMANCKCI@?$CFs?5expected?5?$CFs?$CFzd?5arguments?0?5got@
CONST	SEGMENT
??_C@_0CF@FMANCKCI@?$CFs?5expected?5?$CFs?$CFzd?5arguments?0?5got@ DB '%s'
	DB	' expected %s%zd arguments, got %zd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJOCAFJB@at?5least?5?$AA@
CONST	SEGMENT
??_C@_09HJOCAFJB@at?5least?5?$AA@ DB 'at least ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@
CONST	SEGMENT
??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@ DB 'PyArg_Un'
	DB	'packTuple() argument list is not a tuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@LLJJJCND@?$AAm?$AAi?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAa?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@LLJJJCND@?$AAm?$AAi?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAa?$AAx?$AA?$AA@ DB 'm'
	DB	00H, 'i', 00H, 'n', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	'm', 00H, 'a', 00H, 'x', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@KILMLMLB@?$AAm?$AAi?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@KILMLMLB@?$AAm?$AAi?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'm'
	DB	00H, 'i', 00H, 'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyArg_UnpackTuple
_TEXT	SEGMENT
i$ = 48
vargs$ = 56
l$ = 64
o$ = 72
tv90 = 80
tv130 = 88
tv139 = 96
tv147 = 104
args$ = 128
name$ = 136
min$ = 144
max$ = 152
PyArg_UnpackTuple PROC					; COMDAT

; 1731 : {

$LN23:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1732 :     Py_ssize_t i, l;
; 1733 :     PyObject **o;
; 1734 :     va_list vargs;
; 1735 : 
; 1736 : #ifdef HAVE_STDARG_PROTOTYPES
; 1737 :     va_start(vargs, max);

  00018	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR max$[rsp+8]
  00020	48 89 44 24 38	 mov	 QWORD PTR vargs$[rsp], rax

; 1738 : #else
; 1739 :     va_start(vargs);
; 1740 : #endif
; 1741 : 
; 1742 :     assert(min >= 0);

  00025	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR min$[rsp], 0
  0002e	7d 1c		 jge	 SHORT $LN13@PyArg_Unpa
  00030	41 b8 ce 06 00
	00		 mov	 r8d, 1742		; 000006ceH
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KILMLMLB@?$AAm?$AAi?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004a	33 c0		 xor	 eax, eax
$LN13@PyArg_Unpa:

; 1743 :     assert(min <= max);

  0004c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR max$[rsp]
  00054	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR min$[rsp], rax
  0005c	7e 1c		 jle	 SHORT $LN14@PyArg_Unpa
  0005e	41 b8 cf 06 00
	00		 mov	 r8d, 1743		; 000006cfH
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@DALCLAAM@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAg?$AAe?$AAt?$AAa?$AAr?$AAg?$AAs?$AA?4?$AAc?$AA?$AA@
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@LLJJJCND@?$AAm?$AAi?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAa?$AAx?$AA?$AA@
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00078	33 c0		 xor	 eax, eax
$LN14@PyArg_Unpa:

; 1744 :     if (!PyTuple_Check(args)) {

  0007a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00082	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00086	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0008c	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00091	85 c0		 test	 eax, eax
  00093	75 23		 jne	 SHORT $LN10@PyArg_Unpa

; 1745 :         va_end(vargs);

  00095	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR vargs$[rsp], 0

; 1746 :         PyErr_SetString(PyExc_SystemError,
; 1747 :             "PyArg_UnpackTuple() argument list is not a tuple");

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@DAGMFCDN@PyArg_UnpackTuple?$CI?$CJ?5argument?5lis@
  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000ac	e8 00 00 00 00	 call	 PyErr_SetString

; 1748 :         return 0;

  000b1	33 c0		 xor	 eax, eax
  000b3	e9 4a 02 00 00	 jmp	 $LN11@PyArg_Unpa
$LN10@PyArg_Unpa:

; 1749 :     }
; 1750 :     l = PyTuple_GET_SIZE(args);

  000b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  000c0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000c4	48 89 44 24 40	 mov	 QWORD PTR l$[rsp], rax

; 1751 :     if (l < min) {

  000c9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR min$[rsp]
  000d1	48 39 44 24 40	 cmp	 QWORD PTR l$[rsp], rax
  000d6	0f 8d d6 00 00
	00		 jge	 $LN9@PyArg_Unpa

; 1752 :         if (name != NULL)

  000dc	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR name$[rsp], 0
  000e5	74 65		 je	 SHORT $LN8@PyArg_Unpa

; 1753 :             PyErr_Format(
; 1754 :                 PyExc_TypeError,
; 1755 :                 "%s expected %s%zd arguments, got %zd",
; 1756 :                 name, (min == max ? "" : "at least "), min, l);

  000e7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR max$[rsp]
  000ef	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR min$[rsp], rax
  000f7	75 0e		 jne	 SHORT $LN15@PyArg_Unpa
  000f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00100	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
  00105	eb 0c		 jmp	 SHORT $LN16@PyArg_Unpa
$LN15@PyArg_Unpa:
  00107	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09HJOCAFJB@at?5least?5?$AA@
  0010e	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
$LN16@PyArg_Unpa:
  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR l$[rsp]
  00118	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR min$[rsp]
  00125	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012a	4c 8b 4c 24 50	 mov	 r9, QWORD PTR tv90[rsp]
  0012f	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR name$[rsp]
  00137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@FMANCKCI@?$CFs?5expected?5?$CFs?$CFzd?5arguments?0?5got@
  0013e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00145	e8 00 00 00 00	 call	 PyErr_Format

; 1757 :         else

  0014a	eb 56		 jmp	 SHORT $LN7@PyArg_Unpa
$LN8@PyArg_Unpa:

; 1758 :             PyErr_Format(
; 1759 :                 PyExc_TypeError,
; 1760 :                 "unpacked tuple should have %s%zd elements,"
; 1761 :                 " but has %zd",
; 1762 :                 (min == max ? "" : "at least "), min, l);

  0014c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR max$[rsp]
  00154	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR min$[rsp], rax
  0015c	75 0e		 jne	 SHORT $LN17@PyArg_Unpa
  0015e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00165	48 89 44 24 58	 mov	 QWORD PTR tv130[rsp], rax
  0016a	eb 0c		 jmp	 SHORT $LN18@PyArg_Unpa
$LN17@PyArg_Unpa:
  0016c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09HJOCAFJB@at?5least?5?$AA@
  00173	48 89 44 24 58	 mov	 QWORD PTR tv130[rsp], rax
$LN18@PyArg_Unpa:
  00178	48 8b 44 24 40	 mov	 rax, QWORD PTR l$[rsp]
  0017d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00182	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR min$[rsp]
  0018a	4c 8b 44 24 58	 mov	 r8, QWORD PTR tv130[rsp]
  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@OGLEKFEB@unpacked?5tuple?5should?5have?5?$CFs?$CFzd@
  00196	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0019d	e8 00 00 00 00	 call	 PyErr_Format
$LN7@PyArg_Unpa:

; 1763 :         va_end(vargs);

  001a2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR vargs$[rsp], 0

; 1764 :         return 0;

  001ab	33 c0		 xor	 eax, eax
  001ad	e9 50 01 00 00	 jmp	 $LN11@PyArg_Unpa
$LN9@PyArg_Unpa:

; 1765 :     }
; 1766 :     if (l > max) {

  001b2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR max$[rsp]
  001ba	48 39 44 24 40	 cmp	 QWORD PTR l$[rsp], rax
  001bf	0f 8e d3 00 00
	00		 jle	 $LN6@PyArg_Unpa

; 1767 :         if (name != NULL)

  001c5	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR name$[rsp], 0
  001ce	74 65		 je	 SHORT $LN5@PyArg_Unpa

; 1768 :             PyErr_Format(
; 1769 :                 PyExc_TypeError,
; 1770 :                 "%s expected %s%zd arguments, got %zd",
; 1771 :                 name, (min == max ? "" : "at most "), max, l);

  001d0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR max$[rsp]
  001d8	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR min$[rsp], rax
  001e0	75 0e		 jne	 SHORT $LN19@PyArg_Unpa
  001e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  001e9	48 89 44 24 60	 mov	 QWORD PTR tv139[rsp], rax
  001ee	eb 0c		 jmp	 SHORT $LN20@PyArg_Unpa
$LN19@PyArg_Unpa:
  001f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08KFLHMPAE@at?5most?5?$AA@
  001f7	48 89 44 24 60	 mov	 QWORD PTR tv139[rsp], rax
$LN20@PyArg_Unpa:
  001fc	48 8b 44 24 40	 mov	 rax, QWORD PTR l$[rsp]
  00201	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00206	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR max$[rsp]
  0020e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00213	4c 8b 4c 24 60	 mov	 r9, QWORD PTR tv139[rsp]
  00218	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR name$[rsp]
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@FMANCKCI@?$CFs?5expected?5?$CFs?$CFzd?5arguments?0?5got@
  00227	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0022e	e8 00 00 00 00	 call	 PyErr_Format

; 1772 :         else

  00233	eb 56		 jmp	 SHORT $LN4@PyArg_Unpa
$LN5@PyArg_Unpa:

; 1773 :             PyErr_Format(
; 1774 :                 PyExc_TypeError,
; 1775 :                 "unpacked tuple should have %s%zd elements,"
; 1776 :                 " but has %zd",
; 1777 :                 (min == max ? "" : "at most "), max, l);

  00235	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR max$[rsp]
  0023d	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR min$[rsp], rax
  00245	75 0e		 jne	 SHORT $LN21@PyArg_Unpa
  00247	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0024e	48 89 44 24 68	 mov	 QWORD PTR tv147[rsp], rax
  00253	eb 0c		 jmp	 SHORT $LN22@PyArg_Unpa
$LN21@PyArg_Unpa:
  00255	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08KFLHMPAE@at?5most?5?$AA@
  0025c	48 89 44 24 68	 mov	 QWORD PTR tv147[rsp], rax
$LN22@PyArg_Unpa:
  00261	48 8b 44 24 40	 mov	 rax, QWORD PTR l$[rsp]
  00266	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026b	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR max$[rsp]
  00273	4c 8b 44 24 68	 mov	 r8, QWORD PTR tv147[rsp]
  00278	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@OGLEKFEB@unpacked?5tuple?5should?5have?5?$CFs?$CFzd@
  0027f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00286	e8 00 00 00 00	 call	 PyErr_Format
$LN4@PyArg_Unpa:

; 1778 :         va_end(vargs);

  0028b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR vargs$[rsp], 0

; 1779 :         return 0;

  00294	33 c0		 xor	 eax, eax
  00296	eb 6a		 jmp	 SHORT $LN11@PyArg_Unpa
$LN6@PyArg_Unpa:

; 1780 :     }
; 1781 :     for (i = 0; i < l; i++) {

  00298	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  002a1	eb 0d		 jmp	 SHORT $LN3@PyArg_Unpa
$LN2@PyArg_Unpa:
  002a3	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  002a8	48 ff c0	 inc	 rax
  002ab	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN3@PyArg_Unpa:
  002b0	48 8b 44 24 40	 mov	 rax, QWORD PTR l$[rsp]
  002b5	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  002ba	7d 38		 jge	 SHORT $LN1@PyArg_Unpa

; 1782 :         o = va_arg(vargs, PyObject **);

  002bc	48 8b 44 24 38	 mov	 rax, QWORD PTR vargs$[rsp]
  002c1	48 83 c0 08	 add	 rax, 8
  002c5	48 89 44 24 38	 mov	 QWORD PTR vargs$[rsp], rax
  002ca	48 8b 44 24 38	 mov	 rax, QWORD PTR vargs$[rsp]
  002cf	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  002d3	48 89 44 24 48	 mov	 QWORD PTR o$[rsp], rax

; 1783 :         *o = PyTuple_GET_ITEM(args, i);

  002d8	48 8b 44 24 48	 mov	 rax, QWORD PTR o$[rsp]
  002dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  002e5	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  002ea	48 8b 4c d1 70	 mov	 rcx, QWORD PTR [rcx+rdx*8+112]
  002ef	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1784 :     }

  002f2	eb af		 jmp	 SHORT $LN2@PyArg_Unpa
$LN1@PyArg_Unpa:

; 1785 :     va_end(vargs);

  002f4	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR vargs$[rsp], 0

; 1786 :     return 1;

  002fd	b8 01 00 00 00	 mov	 eax, 1
$LN11@PyArg_Unpa:

; 1787 : }

  00302	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00306	c3		 ret	 0
PyArg_UnpackTuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@MFKGCFAF@?$CFs?5does?5not?5take?5keyword?5argumen@ ; `string'
PUBLIC	_PyArg_NoKeywords
EXTRN	PyDict_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyArg_NoKeywords DD imagerel $LN6
	DD	imagerel $LN6+139
	DD	imagerel $unwind$_PyArg_NoKeywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyArg_NoKeywords DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0CD@MFKGCFAF@?$CFs?5does?5not?5take?5keyword?5argumen@
CONST	SEGMENT
??_C@_0CD@MFKGCFAF@?$CFs?5does?5not?5take?5keyword?5argumen@ DB '%s does '
	DB	'not take keyword arguments', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyArg_NoKeywords
_TEXT	SEGMENT
funcname$ = 48
kw$ = 56
_PyArg_NoKeywords PROC					; COMDAT

; 1797 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1798 :     if (kw == NULL)

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR kw$[rsp], 0
  00014	75 07		 jne	 SHORT $LN3@PyArg_NoKe

; 1799 :         return 1;

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	eb 69		 jmp	 SHORT $LN4@PyArg_NoKe
$LN3@PyArg_NoKe:

; 1800 :     if (!PyDict_CheckExact(kw)) {

  0001d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00024	48 8b 4c 24 38	 mov	 rcx, QWORD PTR kw$[rsp]
  00029	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002d	74 27		 je	 SHORT $LN2@PyArg_NoKe
  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00036	48 8b 4c 24 38	 mov	 rcx, QWORD PTR kw$[rsp]
  0003b	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  0003f	74 15		 je	 SHORT $LN2@PyArg_NoKe

; 1801 :         PyErr_BadInternalCall();

  00041	ba 09 07 00 00	 mov	 edx, 1801		; 00000709H
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GAIPICFM@?4?4?2Python?2getargs?4c?$AA@
  0004d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1802 :         return 0;

  00052	33 c0		 xor	 eax, eax
  00054	eb 30		 jmp	 SHORT $LN4@PyArg_NoKe
$LN2@PyArg_NoKe:

; 1803 :     }
; 1804 :     if (PyDict_Size(kw) == 0)

  00056	48 8b 4c 24 38	 mov	 rcx, QWORD PTR kw$[rsp]
  0005b	e8 00 00 00 00	 call	 PyDict_Size
  00060	48 85 c0	 test	 rax, rax
  00063	75 07		 jne	 SHORT $LN1@PyArg_NoKe

; 1805 :         return 1;

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	eb 1a		 jmp	 SHORT $LN4@PyArg_NoKe
$LN1@PyArg_NoKe:

; 1806 : 
; 1807 :     PyErr_Format(PyExc_TypeError, "%s does not take keyword arguments",
; 1808 :                     funcname);

  0006c	4c 8b 44 24 30	 mov	 r8, QWORD PTR funcname$[rsp]
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@MFKGCFAF@?$CFs?5does?5not?5take?5keyword?5argumen@
  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007f	e8 00 00 00 00	 call	 PyErr_Format

; 1809 :     return 0;

  00084	33 c0		 xor	 eax, eax
$LN4@PyArg_NoKe:

; 1810 : }

  00086	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008a	c3		 ret	 0
_PyArg_NoKeywords ENDP
_TEXT	ENDS
END
