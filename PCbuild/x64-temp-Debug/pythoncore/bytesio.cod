; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@KIPLDHIL@_io?4_BytesIOBuffer?$AA@	; `string'
PUBLIC	??_C@_0M@CJIKFPOJ@_io?4BytesIO?$AA@		; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0N@NAMJJHIO@__getstate__?$AA@		; `string'
PUBLIC	??_C@_08MABILMFG@truncate?$AA@			; `string'
PUBLIC	??_C@_04EDECCOGL@seek?$AA@			; `string'
PUBLIC	??_C@_08ODLBJABI@getvalue?$AA@			; `string'
PUBLIC	??_C@_09NEMCKDC@getbuffer?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_09OBGGLHMH@readlines?$AA@			; `string'
PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_08BPEKIGCI@readinto?$AA@			; `string'
PUBLIC	??_C@_05FDBMPOID@read1?$AA@			; `string'
PUBLIC	??_C@_0L@MKGKOOMC@writelines?$AA@		; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_04LBPCFPDD@tell?$AA@			; `string'
PUBLIC	??_C@_06BMABDNNN@isatty?$AA@			; `string'
PUBLIC	??_C@_05GLCAEPFP@flush?$AA@			; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	??_C@_08IBOGFJJC@writable?$AA@			; `string'
PUBLIC	??_C@_08JPFEOKJG@seekable?$AA@			; `string'
PUBLIC	??_C@_08INDGGIBD@readable?$AA@			; `string'
PUBLIC	??_C@_0BM@LKDINMGD@True?5if?5the?5file?5is?5closed?4?$AA@ ; `string'
PUBLIC	??_C@_06IKJOPBFO@closed?$AA@			; `string'
PUBLIC	PyBytesIO_Type
PUBLIC	_PyBytesIOBuffer_Type
EXTRN	PyObject_SelfIter:PROC
;	COMDAT ??_C@_0BD@KIPLDHIL@_io?4_BytesIOBuffer?$AA@
CONST	SEGMENT
??_C@_0BD@KIPLDHIL@_io?4_BytesIOBuffer?$AA@ DB '_io._BytesIOBuffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CJIKFPOJ@_io?4BytesIO?$AA@
CONST	SEGMENT
??_C@_0M@CJIKFPOJ@_io?4BytesIO?$AA@ DB '_io.BytesIO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAMJJHIO@__getstate__?$AA@
CONST	SEGMENT
??_C@_0N@NAMJJHIO@__getstate__?$AA@ DB '__getstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MABILMFG@truncate?$AA@
CONST	SEGMENT
??_C@_08MABILMFG@truncate?$AA@ DB 'truncate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDECCOGL@seek?$AA@
CONST	SEGMENT
??_C@_04EDECCOGL@seek?$AA@ DB 'seek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ODLBJABI@getvalue?$AA@
CONST	SEGMENT
??_C@_08ODLBJABI@getvalue?$AA@ DB 'getvalue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NEMCKDC@getbuffer?$AA@
CONST	SEGMENT
??_C@_09NEMCKDC@getbuffer?$AA@ DB 'getbuffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OBGGLHMH@readlines?$AA@
CONST	SEGMENT
??_C@_09OBGGLHMH@readlines?$AA@ DB 'readlines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BPEKIGCI@readinto?$AA@
CONST	SEGMENT
??_C@_08BPEKIGCI@readinto?$AA@ DB 'readinto', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FDBMPOID@read1?$AA@
CONST	SEGMENT
??_C@_05FDBMPOID@read1?$AA@ DB 'read1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MKGKOOMC@writelines?$AA@
CONST	SEGMENT
??_C@_0L@MKGKOOMC@writelines?$AA@ DB 'writelines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBPCFPDD@tell?$AA@
CONST	SEGMENT
??_C@_04LBPCFPDD@tell?$AA@ DB 'tell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMABDNNN@isatty?$AA@
CONST	SEGMENT
??_C@_06BMABDNNN@isatty?$AA@ DB 'isatty', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GLCAEPFP@flush?$AA@
CONST	SEGMENT
??_C@_05GLCAEPFP@flush?$AA@ DB 'flush', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBOGFJJC@writable?$AA@
CONST	SEGMENT
??_C@_08IBOGFJJC@writable?$AA@ DB 'writable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPFEOKJG@seekable?$AA@
CONST	SEGMENT
??_C@_08JPFEOKJG@seekable?$AA@ DB 'seekable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08INDGGIBD@readable?$AA@
CONST	SEGMENT
??_C@_08INDGGIBD@readable?$AA@ DB 'readable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LKDINMGD@True?5if?5the?5file?5is?5closed?4?$AA@
CONST	SEGMENT
??_C@_0BM@LKDINMGD@True?5if?5the?5file?5is?5closed?4?$AA@ DB 'True if the'
	DB	' file is closed.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJOPBFO@closed?$AA@
CONST	SEGMENT
??_C@_06IKJOPBFO@closed?$AA@ DB 'closed', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
readable_doc DB	'readable() -> bool. Returns True if the IO object can be'
	DB	' read.', 00H
	ORG $+1
writable_doc DB	'writable() -> bool. Returns True if the IO object can be'
	DB	' written.', 00H
	ORG $+14
seekable_doc DB	'seekable() -> bool. Returns True if the IO object can be'
	DB	' seeked.', 00H
	ORG $+7
flush_doc DB	'flush() -> None.  Does nothing.', 00H
	ORG $+8
getbuffer_doc DB 'getbuffer() -> bytes.', 0aH, 0aH, 'Get a read-write vie'
	DB	'w over the contents of the BytesIO object.', 00H
	ORG $+10
getval_doc DB	'getvalue() -> bytes.', 0aH, 0aH, 'Retrieve the entire co'
	DB	'ntents of the BytesIO object.', 00H
	ORG $+6
isatty_doc DB	'isatty() -> False.', 0aH, 0aH, 'Always returns False sin'
	DB	'ce BytesIO objects are not connected', 0aH, 'to a tty-like de'
	DB	'vice.', 00H
	ORG $+1
tell_doc DB	'tell() -> current file position, an integer', 0aH, 00H
	ORG $+11
read_doc DB	'read([size]) -> read at most size bytes, returned as a s'
	DB	'tring.', 0aH, 0aH, 'If the size argument is negative, read un'
	DB	'til EOF is reached.', 0aH, 'Return an empty string at EOF.', 00H
	ORG $+4
read1_doc DB	'read1(size) -> read at most size bytes, returned as a st'
	DB	'ring.', 0aH, 0aH, 'If the size argument is negative or omitte'
	DB	'd, read until EOF is reached.', 0aH, 'Return an empty string '
	DB	'at EOF.', 00H
	ORG $+10
readline_doc DB	'readline([size]) -> next line from the file, as a string'
	DB	'.', 0aH, 0aH, 'Retain newline.  A non-negative size argument '
	DB	'limits the maximum', 0aH, 'number of bytes to return (an inco'
	DB	'mplete line may be returned then).', 0aH, 'Return an empty st'
	DB	'ring at EOF.', 0aH, 00H
	ORG $+15
readlines_doc DB 'readlines([size]) -> list of strings, each a line from '
	DB	'the file.', 0aH, 0aH, 'Call readline() repeatedly and return '
	DB	'a list of the lines so read.', 0aH, 'The optional size argume'
	DB	'nt, if given, is an approximate bound on the', 0aH, 'total nu'
	DB	'mber of bytes in the lines returned.', 0aH, 00H
	ORG $+8
readinto_doc DB	'readinto(bytearray) -> int.  Read up to len(b) bytes int'
	DB	'o b.', 0aH, 0aH, 'Returns number of bytes read (0 for EOF), o'
	DB	'r None if the object', 0aH, 'is set not to block as has no da'
	DB	'ta to read.', 00H
	ORG $+6
truncate_doc DB	'truncate([size]) -> int.  Truncate the file to at most s'
	DB	'ize bytes.', 0aH, 0aH, 'Size defaults to the current file pos'
	DB	'ition, as returned by tell().', 0aH, 'The current file positi'
	DB	'on is unchanged.  Returns the new size.', 0aH, 00H
	ORG $+9
seek_doc DB	'seek(pos, whence=0) -> int.  Change stream position.', 0aH
	DB	0aH, 'Seek to byte offset pos relative to position indicated b'
	DB	'y whence:', 0aH, '     0  Start of stream (the default).  pos'
	DB	' should be >= 0;', 0aH, '     1  Current position - pos may b'
	DB	'e negative;', 0aH, '     2  End of stream - pos usually negat'
	DB	'ive.', 0aH, 'Returns the new absolute position.', 00H
	ORG $+11
write_doc DB	'write(bytes) -> int.  Write bytes to file.', 0aH, 0aH, 'R'
	DB	'eturn the number of bytes written.', 00H
writelines_doc DB 'writelines(sequence_of_strings) -> None.  Write string'
	DB	's to the file.', 0aH, 0aH, 'Note that newlines are not added.'
	DB	'  The sequence can be any iterable', 0aH, 'object producing s'
	DB	'trings. This is equivalent to calling write() for', 0aH, 'eac'
	DB	'h string.', 00H
	ORG $+5
close_doc DB	'close() -> None.  Disable all I/O operations.', 00H
	ORG $+2
bytesio_getsetlist DQ FLAT:??_C@_06IKJOPBFO@closed?$AA@
	DQ	FLAT:bytesio_get_closed
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BM@LKDINMGD@True?5if?5the?5file?5is?5closed?4?$AA@
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
bytesio_methods DQ FLAT:??_C@_08INDGGIBD@readable?$AA@
	DQ	FLAT:return_not_closed
	DD	04H
	ORG $+4
	DQ	FLAT:readable_doc
	DQ	FLAT:??_C@_08JPFEOKJG@seekable?$AA@
	DQ	FLAT:return_not_closed
	DD	04H
	ORG $+4
	DQ	FLAT:seekable_doc
	DQ	FLAT:??_C@_08IBOGFJJC@writable?$AA@
	DQ	FLAT:return_not_closed
	DD	04H
	ORG $+4
	DQ	FLAT:writable_doc
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	FLAT:bytesio_close
	DD	04H
	ORG $+4
	DQ	FLAT:close_doc
	DQ	FLAT:??_C@_05GLCAEPFP@flush?$AA@
	DQ	FLAT:bytesio_flush
	DD	04H
	ORG $+4
	DQ	FLAT:flush_doc
	DQ	FLAT:??_C@_06BMABDNNN@isatty?$AA@
	DQ	FLAT:bytesio_isatty
	DD	04H
	ORG $+4
	DQ	FLAT:isatty_doc
	DQ	FLAT:??_C@_04LBPCFPDD@tell?$AA@
	DQ	FLAT:bytesio_tell
	DD	04H
	ORG $+4
	DQ	FLAT:tell_doc
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	FLAT:bytesio_write
	DD	08H
	ORG $+4
	DQ	FLAT:write_doc
	DQ	FLAT:??_C@_0L@MKGKOOMC@writelines?$AA@
	DQ	FLAT:bytesio_writelines
	DD	08H
	ORG $+4
	DQ	FLAT:writelines_doc
	DQ	FLAT:??_C@_05FDBMPOID@read1?$AA@
	DQ	FLAT:bytesio_read1
	DD	08H
	ORG $+4
	DQ	FLAT:read1_doc
	DQ	FLAT:??_C@_08BPEKIGCI@readinto?$AA@
	DQ	FLAT:bytesio_readinto
	DD	08H
	ORG $+4
	DQ	FLAT:readinto_doc
	DQ	FLAT:??_C@_08KBCDPPMN@readline?$AA@
	DQ	FLAT:bytesio_readline
	DD	01H
	ORG $+4
	DQ	FLAT:readline_doc
	DQ	FLAT:??_C@_09OBGGLHMH@readlines?$AA@
	DQ	FLAT:bytesio_readlines
	DD	01H
	ORG $+4
	DQ	FLAT:readlines_doc
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	FLAT:bytesio_read
	DD	01H
	ORG $+4
	DQ	FLAT:read_doc
	DQ	FLAT:??_C@_09NEMCKDC@getbuffer?$AA@
	DQ	FLAT:bytesio_getbuffer
	DD	04H
	ORG $+4
	DQ	FLAT:getbuffer_doc
	DQ	FLAT:??_C@_08ODLBJABI@getvalue?$AA@
	DQ	FLAT:bytesio_getvalue
	DD	04H
	ORG $+4
	DQ	FLAT:getval_doc
	DQ	FLAT:??_C@_04EDECCOGL@seek?$AA@
	DQ	FLAT:bytesio_seek
	DD	01H
	ORG $+4
	DQ	FLAT:seek_doc
	DQ	FLAT:??_C@_08MABILMFG@truncate?$AA@
	DQ	FLAT:bytesio_truncate
	DD	01H
	ORG $+4
	DQ	FLAT:truncate_doc
	DQ	FLAT:??_C@_0N@NAMJJHIO@__getstate__?$AA@
	DQ	FLAT:bytesio_getstate
	DD	04H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:bytesio_setstate
	DD	08H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:bytesio_sizeof
	DD	04H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
bytesio_doc DB	'BytesIO([buffer]) -> object', 0aH, 0aH, 'Create a buffer'
	DB	'ed I/O implementation using an in-memory bytes', 0aH, 'buffer'
	DB	', ready for reading and writing.', 00H
	ORG $+14
PyBytesIO_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0M@CJIKFPOJ@_io?4BytesIO?$AA@
	DQ	00000000000000a0H
	DQ	0000000000000000H
	DQ	FLAT:bytesio_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:bytesio_doc
	DQ	FLAT:bytesio_traverse
	DQ	FLAT:bytesio_clear
	DQ	0000000000000000H
	DQ	0000000000000088H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:bytesio_iternext
	DQ	FLAT:bytesio_methods
	DQ	0000000000000000H
	DQ	FLAT:bytesio_getsetlist
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000080H
	DQ	FLAT:bytesio_init
	DQ	0000000000000000H
	DQ	FLAT:bytesio_new
	ORG $+72
bytesiobuf_as_buffer DQ FLAT:bytesiobuf_getbuffer
	DQ	FLAT:bytesiobuf_releasebuffer
_PyBytesIOBuffer_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BD@KIPLDHIL@_io?4_BytesIOBuffer?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:bytesiobuf_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytesiobuf_as_buffer
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:bytesiobuf_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+72
_DATA	ENDS
PUBLIC	_Py_IncRef
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\modules\_io\bytesio.c
pdata	SEGMENT
$pdata$bytesio_get_closed DD imagerel bytesio_get_closed
	DD	imagerel bytesio_get_closed+68
	DD	imagerel $unwind$bytesio_get_closed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_get_closed DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_get_closed
_TEXT	SEGMENT
self$ = 48
bytesio_get_closed PROC					; COMDAT

; 165  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 166  :     if (self->buf == NULL) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	75 17		 jne	 SHORT $LN2@bytesio_ge

; 167  :         Py_RETURN_TRUE;

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  0001c	e8 00 00 00 00	 call	 _Py_IncRef
  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00028	eb 15		 jmp	 SHORT $LN3@bytesio_ge

; 168  :     }
; 169  :     else {

  0002a	eb 13		 jmp	 SHORT $LN1@bytesio_ge
$LN2@bytesio_ge:

; 170  :         Py_RETURN_FALSE;

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00033	e8 00 00 00 00	 call	 _Py_IncRef
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
$LN1@bytesio_ge:
$LN3@bytesio_ge:

; 171  :     }
; 172  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
bytesio_get_closed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\_io\bytesio.c
pdata	SEGMENT
$pdata$return_not_closed DD imagerel return_not_closed
	DD	imagerel return_not_closed+68
	DD	imagerel $unwind$return_not_closed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$return_not_closed DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
CONST	SEGMENT
??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@ DB 'I/O opera'
	DB	'tion on closed file.', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT return_not_closed
_TEXT	SEGMENT
self$ = 48
return_not_closed PROC					; COMDAT

; 186  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 187  :     CHECK_CLOSED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	75 17		 jne	 SHORT $LN1@return_not
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00023	e8 00 00 00 00	 call	 PyErr_SetString
  00028	33 c0		 xor	 eax, eax
  0002a	eb 13		 jmp	 SHORT $LN2@return_not
$LN1@return_not:

; 188  :     Py_RETURN_TRUE;

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00033	e8 00 00 00 00	 call	 _Py_IncRef
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
$LN2@return_not:

; 189  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
return_not_closed ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_flush DD imagerel bytesio_flush
	DD	imagerel bytesio_flush+68
	DD	imagerel $unwind$bytesio_flush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_flush DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_flush
_TEXT	SEGMENT
self$ = 48
bytesio_flush PROC					; COMDAT

; 196  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 197  :     CHECK_CLOSED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	75 17		 jne	 SHORT $LN1@bytesio_fl
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00023	e8 00 00 00 00	 call	 PyErr_SetString
  00028	33 c0		 xor	 eax, eax
  0002a	eb 13		 jmp	 SHORT $LN2@bytesio_fl
$LN1@bytesio_fl:

; 198  :     Py_RETURN_NONE;

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00033	e8 00 00 00 00	 call	 _Py_IncRef
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@bytesio_fl:

; 199  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
bytesio_flush ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
EXTRN	PyMemoryView_FromObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_getbuffer DD imagerel bytesio_getbuffer
	DD	imagerel bytesio_getbuffer+150
	DD	imagerel $unwind$bytesio_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_getbuffer DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_getbuffer
_TEXT	SEGMENT
type$ = 32
view$ = 40
buf$ = 48
self$ = 80
bytesio_getbuffer PROC					; COMDAT

; 208  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 209  :     PyTypeObject *type = &_PyBytesIOBuffer_Type;

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyBytesIOBuffer_Type
  00010	48 89 44 24 20	 mov	 QWORD PTR type$[rsp], rax

; 210  :     bytesiobuf *buf;
; 211  :     PyObject *view;
; 212  : 
; 213  :     CHECK_CLOSED(self);

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001f	75 17		 jne	 SHORT $LN2@bytesio_ge@2
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002f	e8 00 00 00 00	 call	 PyErr_SetString
  00034	33 c0		 xor	 eax, eax
  00036	eb 59		 jmp	 SHORT $LN3@bytesio_ge@2
$LN2@bytesio_ge@2:

; 214  : 
; 215  :     buf = (bytesiobuf *) type->tp_alloc(type, 0);

  00038	33 d2		 xor	 edx, edx
  0003a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR type$[rsp]
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR type$[rsp]
  00044	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  0004a	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax

; 216  :     if (buf == NULL)

  0004f	48 83 7c 24 30
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00055	75 04		 jne	 SHORT $LN1@bytesio_ge@2

; 217  :         return NULL;

  00057	33 c0		 xor	 eax, eax
  00059	eb 36		 jmp	 SHORT $LN3@bytesio_ge@2
$LN1@bytesio_ge@2:

; 218  :     Py_INCREF(self);

  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00060	e8 00 00 00 00	 call	 _Py_IncRef

; 219  :     buf->source = self;

  00065	48 8b 44 24 30	 mov	 rax, QWORD PTR buf$[rsp]
  0006a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0006f	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 220  :     view = PyMemoryView_FromObject((PyObject *) buf);

  00073	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  00078	e8 00 00 00 00	 call	 PyMemoryView_FromObject
  0007d	48 89 44 24 28	 mov	 QWORD PTR view$[rsp], rax

; 221  :     Py_DECREF(buf);

  00082	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  00087	e8 00 00 00 00	 call	 _Py_DecRef

; 222  :     return view;

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
$LN3@bytesio_ge@2:

; 223  : }

  00091	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00095	c3		 ret	 0
bytesio_getbuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_io\bytesio.c
pdata	SEGMENT
$pdata$bytesio_getvalue DD imagerel bytesio_getvalue
	DD	imagerel bytesio_getvalue+72
	DD	imagerel $unwind$bytesio_getvalue
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_getvalue DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_getvalue
_TEXT	SEGMENT
self$ = 48
bytesio_getvalue PROC					; COMDAT

; 232  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 233  :     CHECK_CLOSED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	75 17		 jne	 SHORT $LN1@bytesio_ge@3
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00023	e8 00 00 00 00	 call	 PyErr_SetString
  00028	33 c0		 xor	 eax, eax
  0002a	eb 17		 jmp	 SHORT $LN2@bytesio_ge@3
$LN1@bytesio_ge@3:

; 234  :     return PyBytes_FromStringAndSize(self->buf, self->string_size);

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00031	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0003e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
$LN2@bytesio_ge@3:

; 235  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
bytesio_getvalue ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_isatty DD imagerel bytesio_isatty
	DD	imagerel bytesio_isatty+68
	DD	imagerel $unwind$bytesio_isatty
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_isatty DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_isatty
_TEXT	SEGMENT
self$ = 48
bytesio_isatty PROC					; COMDAT

; 245  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 246  :     CHECK_CLOSED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	75 17		 jne	 SHORT $LN1@bytesio_is
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00023	e8 00 00 00 00	 call	 PyErr_SetString
  00028	33 c0		 xor	 eax, eax
  0002a	eb 13		 jmp	 SHORT $LN2@bytesio_is
$LN1@bytesio_is:

; 247  :     Py_RETURN_FALSE;

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00033	e8 00 00 00 00	 call	 _Py_IncRef
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
$LN2@bytesio_is:

; 248  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
bytesio_isatty ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_tell DD imagerel bytesio_tell
	DD	imagerel bytesio_tell+63
	DD	imagerel $unwind$bytesio_tell
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_tell DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_tell
_TEXT	SEGMENT
self$ = 48
bytesio_tell PROC					; COMDAT

; 255  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 256  :     CHECK_CLOSED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	75 17		 jne	 SHORT $LN1@bytesio_te
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00023	e8 00 00 00 00	 call	 PyErr_SetString
  00028	33 c0		 xor	 eax, eax
  0002a	eb 0e		 jmp	 SHORT $LN2@bytesio_te
$LN1@bytesio_te:

; 257  :     return PyLong_FromSsize_t(self->pos);

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00031	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00035	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN2@bytesio_te:

; 258  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
bytesio_tell ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@FBILHFFC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@ ; `string'
PUBLIC	??_C@_07LBOODODI@?$HMO?3read?$AA@		; `string'
EXTRN	__imp__wassert:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsSsize_t:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_read DD imagerel bytesio_read
	DD	imagerel bytesio_read+406
	DD	imagerel $unwind$bytesio_read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_read DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1CE@FBILHFFC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@FBILHFFC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'b', 00H
	DB	'u', 00H, 'f', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N'
	DB	00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, '_', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'i', 00H, 'o', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@
CONST	SEGMENT
??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@ DB 'integer ar'
	DB	'gument expected, got ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBOODODI@?$HMO?3read?$AA@
CONST	SEGMENT
??_C@_07LBOODODI@?$HMO?3read?$AA@ DB '|O:read', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_read
_TEXT	SEGMENT
arg$ = 32
n$ = 40
output$ = 48
size$ = 56
self$ = 80
args$ = 88
bytesio_read PROC					; COMDAT

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 269  :     Py_ssize_t size, n;
; 270  :     char *output;
; 271  :     PyObject *arg = Py_None;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00015	48 89 44 24 20	 mov	 QWORD PTR arg$[rsp], rax

; 272  : 
; 273  :     CHECK_CLOSED(self);

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00024	75 1a		 jne	 SHORT $LN10@bytesio_re
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00034	e8 00 00 00 00	 call	 PyErr_SetString
  00039	33 c0		 xor	 eax, eax
  0003b	e9 51 01 00 00	 jmp	 $LN11@bytesio_re
$LN10@bytesio_re:

; 274  : 
; 275  :     if (!PyArg_ParseTuple(args, "|O:read", &arg))

  00040	4c 8d 44 24 20	 lea	 r8, QWORD PTR arg$[rsp]
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07LBOODODI@?$HMO?3read?$AA@
  0004c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00051	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00056	85 c0		 test	 eax, eax
  00058	75 07		 jne	 SHORT $LN9@bytesio_re

; 276  :         return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 30 01 00 00	 jmp	 $LN11@bytesio_re
$LN9@bytesio_re:

; 277  : 
; 278  :     if (PyLong_Check(arg)) {

  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR arg$[rsp]
  00066	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00075	85 c0		 test	 eax, eax
  00077	74 2a		 je	 SHORT $LN8@bytesio_re

; 279  :         size = PyLong_AsSsize_t(arg);

  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR arg$[rsp]
  0007e	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00083	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax

; 280  :         if (size == -1 && PyErr_Occurred())

  00088	48 83 7c 24 38
	ff		 cmp	 QWORD PTR size$[rsp], -1
  0008e	75 11		 jne	 SHORT $LN7@bytesio_re
  00090	e8 00 00 00 00	 call	 PyErr_Occurred
  00095	48 85 c0	 test	 rax, rax
  00098	74 07		 je	 SHORT $LN7@bytesio_re

; 281  :             return NULL;

  0009a	33 c0		 xor	 eax, eax
  0009c	e9 f0 00 00 00	 jmp	 $LN11@bytesio_re
$LN7@bytesio_re:

; 282  :     }
; 283  :     else if (arg == Py_None) {

  000a1	eb 40		 jmp	 SHORT $LN6@bytesio_re
$LN8@bytesio_re:
  000a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000aa	48 39 44 24 20	 cmp	 QWORD PTR arg$[rsp], rax
  000af	75 0b		 jne	 SHORT $LN5@bytesio_re

; 284  :         /* Read until EOF is reached, by default. */
; 285  :         size = -1;

  000b1	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR size$[rsp], -1

; 286  :     }
; 287  :     else {

  000ba	eb 27		 jmp	 SHORT $LN4@bytesio_re
$LN5@bytesio_re:

; 288  :         PyErr_Format(PyExc_TypeError, "integer argument expected, got '%s'",
; 289  :                      Py_TYPE(arg)->tp_name);

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR arg$[rsp]
  000c1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000c5	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@
  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d7	e8 00 00 00 00	 call	 PyErr_Format

; 290  :         return NULL;

  000dc	33 c0		 xor	 eax, eax
  000de	e9 ae 00 00 00	 jmp	 $LN11@bytesio_re
$LN4@bytesio_re:
$LN6@bytesio_re:

; 291  :     }
; 292  : 
; 293  :     /* adjust invalid sizes */
; 294  :     n = self->string_size - self->pos;

  000e3	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000ed	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000f1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000f5	48 2b c1	 sub	 rax, rcx
  000f8	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 295  :     if (size < 0 || size > n) {

  000fd	48 83 7c 24 38
	00		 cmp	 QWORD PTR size$[rsp], 0
  00103	7c 0c		 jl	 SHORT $LN2@bytesio_re
  00105	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0010a	48 39 44 24 38	 cmp	 QWORD PTR size$[rsp], rax
  0010f	7e 1b		 jle	 SHORT $LN3@bytesio_re
$LN2@bytesio_re:

; 296  :         size = n;

  00111	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00116	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax

; 297  :         if (size < 0)

  0011b	48 83 7c 24 38
	00		 cmp	 QWORD PTR size$[rsp], 0
  00121	7d 09		 jge	 SHORT $LN1@bytesio_re

; 298  :             size = 0;

  00123	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR size$[rsp], 0
$LN1@bytesio_re:
$LN3@bytesio_re:

; 299  :     }
; 300  : 
; 301  :     assert(self->buf != NULL);

  0012c	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00131	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00136	75 1c		 jne	 SHORT $LN13@bytesio_re
  00138	41 b8 2d 01 00
	00		 mov	 r8d, 301		; 0000012dH
  0013e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@FBILHFFC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00152	33 c0		 xor	 eax, eax
$LN13@bytesio_re:

; 302  :     output = self->buf + self->pos;

  00154	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00159	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0015d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00162	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  00166	48 89 44 24 30	 mov	 QWORD PTR output$[rsp], rax

; 303  :     self->pos += size;

  0016b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00170	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00174	48 03 44 24 38	 add	 rax, QWORD PTR size$[rsp]
  00179	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0017e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 304  : 
; 305  :     return PyBytes_FromStringAndSize(output, size);

  00182	48 8b 54 24 38	 mov	 rdx, QWORD PTR size$[rsp]
  00187	48 8b 4c 24 30	 mov	 rcx, QWORD PTR output$[rsp]
  0018c	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
$LN11@bytesio_re:

; 306  : }

  00191	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00195	c3		 ret	 0
bytesio_read ENDP
_TEXT	ENDS
EXTRN	PyTuple_Pack:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_read1 DD imagerel bytesio_read1
	DD	imagerel bytesio_read1+86
	DD	imagerel $unwind$bytesio_read1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_read1 DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_read1
_TEXT	SEGMENT
res$ = 32
arg$ = 40
self$ = 64
n$ = 72
bytesio_read1 PROC					; COMDAT

; 317  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 318  :     PyObject *arg, *res;
; 319  : 
; 320  :     arg = PyTuple_Pack(1, n);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  00013	b9 01 00 00 00	 mov	 ecx, 1
  00018	e8 00 00 00 00	 call	 PyTuple_Pack
  0001d	48 89 44 24 28	 mov	 QWORD PTR arg$[rsp], rax

; 321  :     if (arg == NULL)

  00022	48 83 7c 24 28
	00		 cmp	 QWORD PTR arg$[rsp], 0
  00028	75 04		 jne	 SHORT $LN1@bytesio_re@2

; 322  :         return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 23		 jmp	 SHORT $LN2@bytesio_re@2
$LN1@bytesio_re@2:

; 323  :     res  = bytesio_read(self, arg);

  0002e	48 8b 54 24 28	 mov	 rdx, QWORD PTR arg$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00038	e8 00 00 00 00	 call	 bytesio_read
  0003d	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 324  :     Py_DECREF(arg);

  00042	48 8b 4c 24 28	 mov	 rcx, QWORD PTR arg$[rsp]
  00047	e8 00 00 00 00	 call	 _Py_DecRef

; 325  :     return res;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
$LN2@bytesio_re@2:

; 326  : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
bytesio_read1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@CHNOBOKB@?$HMO?3readline?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_readline DD imagerel bytesio_readline
	DD	imagerel bytesio_readline+352
	DD	imagerel $unwind$bytesio_readline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_readline DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0M@CHNOBOKB@?$HMO?3readline?$AA@
CONST	SEGMENT
??_C@_0M@CHNOBOKB@?$HMO?3readline?$AA@ DB '|O:readline', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_readline
_TEXT	SEGMENT
arg$ = 32
n$ = 40
output$ = 48
size$ = 56
self$ = 80
args$ = 88
bytesio_readline PROC					; COMDAT

; 337  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 338  :     Py_ssize_t size, n;
; 339  :     char *output;
; 340  :     PyObject *arg = Py_None;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00015	48 89 44 24 20	 mov	 QWORD PTR arg$[rsp], rax

; 341  : 
; 342  :     CHECK_CLOSED(self);

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00024	75 1a		 jne	 SHORT $LN8@bytesio_re@3
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00034	e8 00 00 00 00	 call	 PyErr_SetString
  00039	33 c0		 xor	 eax, eax
  0003b	e9 1b 01 00 00	 jmp	 $LN9@bytesio_re@3
$LN8@bytesio_re@3:

; 343  : 
; 344  :     if (!PyArg_ParseTuple(args, "|O:readline", &arg))

  00040	4c 8d 44 24 20	 lea	 r8, QWORD PTR arg$[rsp]
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@CHNOBOKB@?$HMO?3readline?$AA@
  0004c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00051	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00056	85 c0		 test	 eax, eax
  00058	75 07		 jne	 SHORT $LN7@bytesio_re@3

; 345  :         return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 fa 00 00 00	 jmp	 $LN9@bytesio_re@3
$LN7@bytesio_re@3:

; 346  : 
; 347  :     if (PyLong_Check(arg)) {

  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR arg$[rsp]
  00066	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00075	85 c0		 test	 eax, eax
  00077	74 2a		 je	 SHORT $LN6@bytesio_re@3

; 348  :         size = PyLong_AsSsize_t(arg);

  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR arg$[rsp]
  0007e	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00083	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax

; 349  :         if (size == -1 && PyErr_Occurred())

  00088	48 83 7c 24 38
	ff		 cmp	 QWORD PTR size$[rsp], -1
  0008e	75 11		 jne	 SHORT $LN5@bytesio_re@3
  00090	e8 00 00 00 00	 call	 PyErr_Occurred
  00095	48 85 c0	 test	 rax, rax
  00098	74 07		 je	 SHORT $LN5@bytesio_re@3

; 350  :             return NULL;

  0009a	33 c0		 xor	 eax, eax
  0009c	e9 ba 00 00 00	 jmp	 $LN9@bytesio_re@3
$LN5@bytesio_re@3:

; 351  :     }
; 352  :     else if (arg == Py_None) {

  000a1	eb 3d		 jmp	 SHORT $LN4@bytesio_re@3
$LN6@bytesio_re@3:
  000a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000aa	48 39 44 24 20	 cmp	 QWORD PTR arg$[rsp], rax
  000af	75 0b		 jne	 SHORT $LN3@bytesio_re@3

; 353  :         /* No size limit, by default. */
; 354  :         size = -1;

  000b1	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR size$[rsp], -1

; 355  :     }
; 356  :     else {

  000ba	eb 24		 jmp	 SHORT $LN2@bytesio_re@3
$LN3@bytesio_re@3:

; 357  :         PyErr_Format(PyExc_TypeError, "integer argument expected, got '%s'",
; 358  :                      Py_TYPE(arg)->tp_name);

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR arg$[rsp]
  000c1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000c5	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@
  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d7	e8 00 00 00 00	 call	 PyErr_Format

; 359  :         return NULL;

  000dc	33 c0		 xor	 eax, eax
  000de	eb 7b		 jmp	 SHORT $LN9@bytesio_re@3
$LN2@bytesio_re@3:
$LN4@bytesio_re@3:

; 360  :     }
; 361  : 
; 362  :     n = get_line(self, &output);

  000e0	48 8d 54 24 30	 lea	 rdx, QWORD PTR output$[rsp]
  000e5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000ea	e8 00 00 00 00	 call	 get_line
  000ef	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 363  : 
; 364  :     if (size >= 0 && size < n) {

  000f4	48 83 7c 24 38
	00		 cmp	 QWORD PTR size$[rsp], 0
  000fa	7c 50		 jl	 SHORT $LN1@bytesio_re@3
  000fc	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00101	48 39 44 24 38	 cmp	 QWORD PTR size$[rsp], rax
  00106	7d 44		 jge	 SHORT $LN1@bytesio_re@3

; 365  :         size = n - size;

  00108	48 8b 44 24 38	 mov	 rax, QWORD PTR size$[rsp]
  0010d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$[rsp]
  00112	48 2b c8	 sub	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax

; 366  :         n -= size;

  0011d	48 8b 44 24 38	 mov	 rax, QWORD PTR size$[rsp]
  00122	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$[rsp]
  00127	48 2b c8	 sub	 rcx, rax
  0012a	48 8b c1	 mov	 rax, rcx
  0012d	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 367  :         self->pos -= size;

  00132	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00137	48 8b 4c 24 38	 mov	 rcx, QWORD PTR size$[rsp]
  0013c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00140	48 2b c1	 sub	 rax, rcx
  00143	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00148	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN1@bytesio_re@3:

; 368  :     }
; 369  : 
; 370  :     return PyBytes_FromStringAndSize(output, n);

  0014c	48 8b 54 24 28	 mov	 rdx, QWORD PTR n$[rsp]
  00151	48 8b 4c 24 30	 mov	 rcx, QWORD PTR output$[rsp]
  00156	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
$LN9@bytesio_re@3:

; 371  : }

  0015b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015f	c3		 ret	 0
bytesio_readline ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EC@DKAGHPD@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?9?$AA?5?$AAl?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_line DD imagerel get_line
	DD	imagerel get_line+350
	DD	imagerel $unwind$get_line
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_line DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1EC@DKAGHPD@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?9?$AA?5?$AAl?$AAe?$AAn@
CONST	SEGMENT
??_C@_1EC@DKAGHPD@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?9?$AA?5?$AAl?$AAe?$AAn@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'P', 00H, 'Y'
	DB	00H, '_', 00H, 'S', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'_', 00H, 'T', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'X', 00H, ' '
	DB	00H, '-', 00H, ' ', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'l'
	DB	00H, 'e', 00H, 'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT get_line
_TEXT	SEGMENT
str_end$ = 32
n$ = 40
len$ = 48
self$ = 80
output$ = 88
get_line PROC						; COMDAT

; 42   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 43   :     char *n;
; 44   :     const char *str_end;
; 45   :     Py_ssize_t len;
; 46   : 
; 47   :     assert(self->buf != NULL);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00018	75 1c		 jne	 SHORT $LN7@get_line
  0001a	41 b8 2f 00 00
	00		 mov	 r8d, 47			; 0000002fH
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@FBILHFFC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00034	33 c0		 xor	 eax, eax
$LN7@get_line:

; 48   : 
; 49   :     /* Move to the end of the line, up to the end of the string, s. */
; 50   :     str_end = self->buf + self->string_size;

  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0003b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00044	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  00048	48 89 44 24 20	 mov	 QWORD PTR str_end$[rsp], rax

; 51   :     for (n = self->buf + self->pos;
; 52   :          n < str_end && *n != '\n';
; 53   :          n++);

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00052	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0005b	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  0005f	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
  00064	eb 0d		 jmp	 SHORT $LN4@get_line
$LN3@get_line:
  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0006b	48 ff c0	 inc	 rax
  0006e	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
$LN4@get_line:
  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR str_end$[rsp]
  00078	48 39 44 24 28	 cmp	 QWORD PTR n$[rsp], rax
  0007d	73 0f		 jae	 SHORT $LN2@get_line
  0007f	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00084	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00087	83 f8 0a	 cmp	 eax, 10
  0008a	74 02		 je	 SHORT $LN2@get_line
  0008c	eb d8		 jmp	 SHORT $LN3@get_line
$LN2@get_line:

; 54   : 
; 55   :     /* Skip the newline character */
; 56   :     if (n < str_end)

  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR str_end$[rsp]
  00093	48 39 44 24 28	 cmp	 QWORD PTR n$[rsp], rax
  00098	73 0d		 jae	 SHORT $LN1@get_line

; 57   :         n++;

  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0009f	48 ff c0	 inc	 rax
  000a2	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
$LN1@get_line:

; 58   : 
; 59   :     /* Get the length from the current position to the end of the line. */
; 60   :     len = n - (self->buf + self->pos);

  000a7	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ac	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000b5	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$[rsp]
  000be	48 2b c8	 sub	 rcx, rax
  000c1	48 8b c1	 mov	 rax, rcx
  000c4	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 61   :     *output = self->buf + self->pos;

  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ce	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000d7	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  000db	48 8b 4c 24 58	 mov	 rcx, QWORD PTR output$[rsp]
  000e0	48 89 01	 mov	 QWORD PTR [rcx], rax

; 62   : 
; 63   :     assert(len >= 0);

  000e3	48 83 7c 24 30
	00		 cmp	 QWORD PTR len$[rsp], 0
  000e9	7d 1c		 jge	 SHORT $LN8@get_line
  000eb	41 b8 3f 00 00
	00		 mov	 r8d, 63			; 0000003fH
  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00105	33 c0		 xor	 eax, eax
$LN8@get_line:

; 64   :     assert(self->pos < PY_SSIZE_T_MAX - len);

  00107	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00111	48 2b 44 24 30	 sub	 rax, QWORD PTR len$[rsp]
  00116	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0011b	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  0011f	7c 1c		 jl	 SHORT $LN9@get_line
  00121	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@DKAGHPD@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?9?$AA?5?$AAl?$AAe?$AAn@
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0013b	33 c0		 xor	 eax, eax
$LN9@get_line:

; 65   :     self->pos += len;

  0013d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00142	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00146	48 03 44 24 30	 add	 rax, QWORD PTR len$[rsp]
  0014b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00150	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 66   : 
; 67   :     return len;

  00154	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]

; 68   : }

  00159	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015d	c3		 ret	 0
get_line ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@KFOEGHFF@?$HMO?3readlines?$AA@		; `string'
EXTRN	PyList_Append:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_readlines DD imagerel bytesio_readlines
	DD	imagerel bytesio_readlines+435
	DD	imagerel $unwind$bytesio_readlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_readlines DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0N@KFOEGHFF@?$HMO?3readlines?$AA@
CONST	SEGMENT
??_C@_0N@KFOEGHFF@?$HMO?3readlines?$AA@ DB '|O:readlines', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_readlines
_TEXT	SEGMENT
arg$ = 32
line$ = 40
n$ = 48
output$ = 56
maxsize$ = 64
size$ = 72
result$ = 80
self$ = 112
args$ = 120
bytesio_readlines PROC					; COMDAT

; 382  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 383  :     Py_ssize_t maxsize, size, n;
; 384  :     PyObject *result, *line;
; 385  :     char *output;
; 386  :     PyObject *arg = Py_None;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00015	48 89 44 24 20	 mov	 QWORD PTR arg$[rsp], rax

; 387  : 
; 388  :     CHECK_CLOSED(self);

  0001a	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0001f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00024	75 1a		 jne	 SHORT $LN13@bytesio_re@4
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00034	e8 00 00 00 00	 call	 PyErr_SetString
  00039	33 c0		 xor	 eax, eax
  0003b	e9 6e 01 00 00	 jmp	 $LN14@bytesio_re@4
$LN13@bytesio_re@4:

; 389  : 
; 390  :     if (!PyArg_ParseTuple(args, "|O:readlines", &arg))

  00040	4c 8d 44 24 20	 lea	 r8, QWORD PTR arg$[rsp]
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KFOEGHFF@?$HMO?3readlines?$AA@
  0004c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00051	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00056	85 c0		 test	 eax, eax
  00058	75 07		 jne	 SHORT $LN12@bytesio_re@4

; 391  :         return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 4d 01 00 00	 jmp	 $LN14@bytesio_re@4
$LN12@bytesio_re@4:

; 392  : 
; 393  :     if (PyLong_Check(arg)) {

  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR arg$[rsp]
  00066	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00075	85 c0		 test	 eax, eax
  00077	74 2a		 je	 SHORT $LN11@bytesio_re@4

; 394  :         maxsize = PyLong_AsSsize_t(arg);

  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR arg$[rsp]
  0007e	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00083	48 89 44 24 40	 mov	 QWORD PTR maxsize$[rsp], rax

; 395  :         if (maxsize == -1 && PyErr_Occurred())

  00088	48 83 7c 24 40
	ff		 cmp	 QWORD PTR maxsize$[rsp], -1
  0008e	75 11		 jne	 SHORT $LN10@bytesio_re@4
  00090	e8 00 00 00 00	 call	 PyErr_Occurred
  00095	48 85 c0	 test	 rax, rax
  00098	74 07		 je	 SHORT $LN10@bytesio_re@4

; 396  :             return NULL;

  0009a	33 c0		 xor	 eax, eax
  0009c	e9 0d 01 00 00	 jmp	 $LN14@bytesio_re@4
$LN10@bytesio_re@4:

; 397  :     }
; 398  :     else if (arg == Py_None) {

  000a1	eb 40		 jmp	 SHORT $LN9@bytesio_re@4
$LN11@bytesio_re@4:
  000a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000aa	48 39 44 24 20	 cmp	 QWORD PTR arg$[rsp], rax
  000af	75 0b		 jne	 SHORT $LN8@bytesio_re@4

; 399  :         /* No size limit, by default. */
; 400  :         maxsize = -1;

  000b1	48 c7 44 24 40
	ff ff ff ff	 mov	 QWORD PTR maxsize$[rsp], -1

; 401  :     }
; 402  :     else {

  000ba	eb 27		 jmp	 SHORT $LN7@bytesio_re@4
$LN8@bytesio_re@4:

; 403  :         PyErr_Format(PyExc_TypeError, "integer argument expected, got '%s'",
; 404  :                      Py_TYPE(arg)->tp_name);

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR arg$[rsp]
  000c1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000c5	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@
  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d7	e8 00 00 00 00	 call	 PyErr_Format

; 405  :         return NULL;

  000dc	33 c0		 xor	 eax, eax
  000de	e9 cb 00 00 00	 jmp	 $LN14@bytesio_re@4
$LN7@bytesio_re@4:
$LN9@bytesio_re@4:

; 406  :     }
; 407  : 
; 408  :     size = 0;

  000e3	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR size$[rsp], 0

; 409  :     result = PyList_New(0);

  000ec	33 c9		 xor	 ecx, ecx
  000ee	e8 00 00 00 00	 call	 PyList_New
  000f3	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 410  :     if (!result)

  000f8	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  000fe	75 07		 jne	 SHORT $LN6@bytesio_re@4

; 411  :         return NULL;

  00100	33 c0		 xor	 eax, eax
  00102	e9 a7 00 00 00	 jmp	 $LN14@bytesio_re@4
$LN6@bytesio_re@4:
$LN5@bytesio_re@4:

; 412  : 
; 413  :     while ((n = get_line(self, &output)) != 0) {

  00107	48 8d 54 24 38	 lea	 rdx, QWORD PTR output$[rsp]
  0010c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00111	e8 00 00 00 00	 call	 get_line
  00116	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax
  0011b	48 83 7c 24 30
	00		 cmp	 QWORD PTR n$[rsp], 0
  00121	74 78		 je	 SHORT $LN4@bytesio_re@4

; 414  :         line = PyBytes_FromStringAndSize(output, n);

  00123	48 8b 54 24 30	 mov	 rdx, QWORD PTR n$[rsp]
  00128	48 8b 4c 24 38	 mov	 rcx, QWORD PTR output$[rsp]
  0012d	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00132	48 89 44 24 28	 mov	 QWORD PTR line$[rsp], rax

; 415  :         if (!line)

  00137	48 83 7c 24 28
	00		 cmp	 QWORD PTR line$[rsp], 0
  0013d	75 02		 jne	 SHORT $LN3@bytesio_re@4

; 416  :             goto on_error;

  0013f	eb 61		 jmp	 SHORT $on_error$20718
$LN3@bytesio_re@4:

; 417  :         if (PyList_Append(result, line) == -1) {

  00141	48 8b 54 24 28	 mov	 rdx, QWORD PTR line$[rsp]
  00146	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  0014b	e8 00 00 00 00	 call	 PyList_Append
  00150	83 f8 ff	 cmp	 eax, -1
  00153	75 0c		 jne	 SHORT $LN2@bytesio_re@4

; 418  :             Py_DECREF(line);

  00155	48 8b 4c 24 28	 mov	 rcx, QWORD PTR line$[rsp]
  0015a	e8 00 00 00 00	 call	 _Py_DecRef

; 419  :             goto on_error;

  0015f	eb 41		 jmp	 SHORT $on_error$20718
$LN2@bytesio_re@4:

; 420  :         }
; 421  :         Py_DECREF(line);

  00161	48 8b 4c 24 28	 mov	 rcx, QWORD PTR line$[rsp]
  00166	e8 00 00 00 00	 call	 _Py_DecRef

; 422  :         size += n;

  0016b	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00170	48 8b 4c 24 48	 mov	 rcx, QWORD PTR size$[rsp]
  00175	48 03 c8	 add	 rcx, rax
  00178	48 8b c1	 mov	 rax, rcx
  0017b	48 89 44 24 48	 mov	 QWORD PTR size$[rsp], rax

; 423  :         if (maxsize > 0 && size >= maxsize)

  00180	48 83 7c 24 40
	00		 cmp	 QWORD PTR maxsize$[rsp], 0
  00186	7e 0e		 jle	 SHORT $LN1@bytesio_re@4
  00188	48 8b 44 24 40	 mov	 rax, QWORD PTR maxsize$[rsp]
  0018d	48 39 44 24 48	 cmp	 QWORD PTR size$[rsp], rax
  00192	7c 02		 jl	 SHORT $LN1@bytesio_re@4

; 424  :             break;

  00194	eb 05		 jmp	 SHORT $LN4@bytesio_re@4
$LN1@bytesio_re@4:

; 425  :     }

  00196	e9 6c ff ff ff	 jmp	 $LN5@bytesio_re@4
$LN4@bytesio_re@4:

; 426  :     return result;

  0019b	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  001a0	eb 0c		 jmp	 SHORT $LN14@bytesio_re@4
$on_error$20718:

; 427  : 
; 428  :   on_error:
; 429  :     Py_DECREF(result);

  001a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  001a7	e8 00 00 00 00	 call	 _Py_DecRef

; 430  :     return NULL;

  001ac	33 c0		 xor	 eax, eax
$LN14@bytesio_re@4:

; 431  : }

  001ae	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001b2	c3		 ret	 0
bytesio_readlines ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EC@KAFBBAHK@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX@ ; `string'
EXTRN	memcpy:PROC
EXTRN	PyObject_AsWriteBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_readinto DD imagerel bytesio_readinto
	DD	imagerel bytesio_readinto+316
	DD	imagerel $unwind$bytesio_readinto
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_readinto DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1EC@KAFBBAHK@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX@
CONST	SEGMENT
??_C@_1EC@KAFBBAHK@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'l', 00H, 'e'
	DB	00H, 'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'P', 00H, 'Y', 00H
	DB	'_', 00H, 'S', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '_'
	DB	00H, 'T', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'X', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_readinto
_TEXT	SEGMENT
n$ = 32
len$ = 40
raw_buffer$ = 48
self$ = 80
buffer$ = 88
bytesio_readinto PROC					; COMDAT

; 441  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 442  :     void *raw_buffer;
; 443  :     Py_ssize_t len, n;
; 444  : 
; 445  :     CHECK_CLOSED(self);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00018	75 1a		 jne	 SHORT $LN4@bytesio_re@5
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00028	e8 00 00 00 00	 call	 PyErr_SetString
  0002d	33 c0		 xor	 eax, eax
  0002f	e9 03 01 00 00	 jmp	 $LN5@bytesio_re@5
$LN4@bytesio_re@5:

; 446  : 
; 447  :     if (PyObject_AsWriteBuffer(buffer, &raw_buffer, &len) == -1)

  00034	4c 8d 44 24 28	 lea	 r8, QWORD PTR len$[rsp]
  00039	48 8d 54 24 30	 lea	 rdx, QWORD PTR raw_buffer$[rsp]
  0003e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buffer$[rsp]
  00043	e8 00 00 00 00	 call	 PyObject_AsWriteBuffer
  00048	83 f8 ff	 cmp	 eax, -1
  0004b	75 07		 jne	 SHORT $LN3@bytesio_re@5

; 448  :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	e9 e3 00 00 00	 jmp	 $LN5@bytesio_re@5
$LN3@bytesio_re@5:

; 449  : 
; 450  :     /* adjust invalid sizes */
; 451  :     n = self->string_size - self->pos;

  00054	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00059	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0005e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00062	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00066	48 2b c1	 sub	 rax, rcx
  00069	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 452  :     if (len > n) {

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00073	48 39 44 24 28	 cmp	 QWORD PTR len$[rsp], rax
  00078	7e 1b		 jle	 SHORT $LN2@bytesio_re@5

; 453  :         len = n;

  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  0007f	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 454  :         if (len < 0)

  00084	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  0008a	7d 09		 jge	 SHORT $LN1@bytesio_re@5

; 455  :             len = 0;

  0008c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0
$LN1@bytesio_re@5:
$LN2@bytesio_re@5:

; 456  :     }
; 457  : 
; 458  :     memcpy(raw_buffer, self->buf + self->pos, len);

  00095	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0009a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000a3	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  000a7	4c 8b 44 24 28	 mov	 r8, QWORD PTR len$[rsp]
  000ac	48 8b d0	 mov	 rdx, rax
  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR raw_buffer$[rsp]
  000b4	e8 00 00 00 00	 call	 memcpy

; 459  :     assert(self->pos + len < PY_SSIZE_T_MAX);

  000b9	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c2	48 03 44 24 28	 add	 rax, QWORD PTR len$[rsp]
  000c7	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  000d1	48 3b c1	 cmp	 rax, rcx
  000d4	7c 1c		 jl	 SHORT $LN7@bytesio_re@5
  000d6	41 b8 cb 01 00
	00		 mov	 r8d, 459		; 000001cbH
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@KAFBBAHK@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX@
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f0	33 c0		 xor	 eax, eax
$LN7@bytesio_re@5:

; 460  :     assert(len >= 0);

  000f2	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  000f8	7d 1c		 jge	 SHORT $LN8@bytesio_re@5
  000fa	41 b8 cc 01 00
	00		 mov	 r8d, 460		; 000001ccH
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00114	33 c0		 xor	 eax, eax
$LN8@bytesio_re@5:

; 461  :     self->pos += len;

  00116	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0011b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011f	48 03 44 24 28	 add	 rax, QWORD PTR len$[rsp]
  00124	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00129	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 462  : 
; 463  :     return PyLong_FromSsize_t(len);

  0012d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR len$[rsp]
  00132	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN5@bytesio_re@5:

; 464  : }

  00137	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013b	c3		 ret	 0
bytesio_readinto ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@JOKLPDAF@negative?5size?5value?5?$CFzd?$AA@ ; `string'
PUBLIC	??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@		; `string'
PUBLIC	??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@ ; `string'
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_truncate DD imagerel bytesio_truncate
	DD	imagerel bytesio_truncate+374
	DD	imagerel $unwind$bytesio_truncate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_truncate DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BI@JOKLPDAF@negative?5size?5value?5?$CFzd?$AA@
CONST	SEGMENT
??_C@_0BI@JOKLPDAF@negative?5size?5value?5?$CFzd?$AA@ DB 'negative size v'
	DB	'alue %zd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@
CONST	SEGMENT
??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@ DB '|O:truncate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
CONST	SEGMENT
??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@ DB 'Existing ex'
	DB	'ports of data: object cannot be re-sized', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_truncate
_TEXT	SEGMENT
arg$ = 32
size$ = 40
self$ = 64
args$ = 72
bytesio_truncate PROC					; COMDAT

; 474  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 475  :     Py_ssize_t size;
; 476  :     PyObject *arg = Py_None;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00015	48 89 44 24 20	 mov	 QWORD PTR arg$[rsp], rax

; 477  : 
; 478  :     CHECK_CLOSED(self);

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0001f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00024	75 1a		 jne	 SHORT $LN11@bytesio_tr
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00034	e8 00 00 00 00	 call	 PyErr_SetString
  00039	33 c0		 xor	 eax, eax
  0003b	e9 31 01 00 00	 jmp	 $LN12@bytesio_tr
$LN11@bytesio_tr:

; 479  :     CHECK_EXPORTS(self);

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00045	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  0004d	7e 1a		 jle	 SHORT $LN10@bytesio_tr
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0005d	e8 00 00 00 00	 call	 PyErr_SetString
  00062	33 c0		 xor	 eax, eax
  00064	e9 08 01 00 00	 jmp	 $LN12@bytesio_tr
$LN10@bytesio_tr:

; 480  : 
; 481  :     if (!PyArg_ParseTuple(args, "|O:truncate", &arg))

  00069	4c 8d 44 24 20	 lea	 r8, QWORD PTR arg$[rsp]
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@
  00075	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0007a	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0007f	85 c0		 test	 eax, eax
  00081	75 07		 jne	 SHORT $LN9@bytesio_tr

; 482  :         return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	e9 e7 00 00 00	 jmp	 $LN12@bytesio_tr
$LN9@bytesio_tr:

; 483  : 
; 484  :     if (PyLong_Check(arg)) {

  0008a	48 8b 44 24 20	 mov	 rax, QWORD PTR arg$[rsp]
  0008f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00093	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00099	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0009e	85 c0		 test	 eax, eax
  000a0	74 2a		 je	 SHORT $LN8@bytesio_tr

; 485  :         size = PyLong_AsSsize_t(arg);

  000a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR arg$[rsp]
  000a7	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000ac	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 486  :         if (size == -1 && PyErr_Occurred())

  000b1	48 83 7c 24 28
	ff		 cmp	 QWORD PTR size$[rsp], -1
  000b7	75 11		 jne	 SHORT $LN7@bytesio_tr
  000b9	e8 00 00 00 00	 call	 PyErr_Occurred
  000be	48 85 c0	 test	 rax, rax
  000c1	74 07		 je	 SHORT $LN7@bytesio_tr

; 487  :             return NULL;

  000c3	33 c0		 xor	 eax, eax
  000c5	e9 a7 00 00 00	 jmp	 $LN12@bytesio_tr
$LN7@bytesio_tr:

; 488  :     }
; 489  :     else if (arg == Py_None) {

  000ca	eb 42		 jmp	 SHORT $LN6@bytesio_tr
$LN8@bytesio_tr:
  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000d3	48 39 44 24 20	 cmp	 QWORD PTR arg$[rsp], rax
  000d8	75 10		 jne	 SHORT $LN5@bytesio_tr

; 490  :         /* Truncate to current position if no argument is passed. */
; 491  :         size = self->pos;

  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000df	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e3	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 492  :     }
; 493  :     else {

  000e8	eb 24		 jmp	 SHORT $LN4@bytesio_tr
$LN5@bytesio_tr:

; 494  :         PyErr_Format(PyExc_TypeError, "integer argument expected, got '%s'",
; 495  :                      Py_TYPE(arg)->tp_name);

  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR arg$[rsp]
  000ef	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f3	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@
  000fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00105	e8 00 00 00 00	 call	 PyErr_Format

; 496  :         return NULL;

  0010a	33 c0		 xor	 eax, eax
  0010c	eb 63		 jmp	 SHORT $LN12@bytesio_tr
$LN4@bytesio_tr:
$LN6@bytesio_tr:

; 497  :     }
; 498  : 
; 499  :     if (size < 0) {

  0010e	48 83 7c 24 28
	00		 cmp	 QWORD PTR size$[rsp], 0
  00114	7d 1c		 jge	 SHORT $LN3@bytesio_tr

; 500  :         PyErr_Format(PyExc_ValueError,
; 501  :                      "negative size value %zd", size);

  00116	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  0011b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@JOKLPDAF@negative?5size?5value?5?$CFzd?$AA@
  00122	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00129	e8 00 00 00 00	 call	 PyErr_Format

; 502  :         return NULL;

  0012e	33 c0		 xor	 eax, eax
  00130	eb 3f		 jmp	 SHORT $LN12@bytesio_tr
$LN3@bytesio_tr:

; 503  :     }
; 504  : 
; 505  :     if (size < self->string_size) {

  00132	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00137	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0013b	48 39 44 24 28	 cmp	 QWORD PTR size$[rsp], rax
  00140	7d 25		 jge	 SHORT $LN2@bytesio_tr

; 506  :         self->string_size = size;

  00142	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00147	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  0014c	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 507  :         if (resize_buffer(self, size) < 0)

  00150	48 8b 54 24 28	 mov	 rdx, QWORD PTR size$[rsp]
  00155	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0015a	e8 00 00 00 00	 call	 resize_buffer
  0015f	85 c0		 test	 eax, eax
  00161	7d 04		 jge	 SHORT $LN1@bytesio_tr

; 508  :             return NULL;

  00163	33 c0		 xor	 eax, eax
  00165	eb 0a		 jmp	 SHORT $LN12@bytesio_tr
$LN1@bytesio_tr:
$LN2@bytesio_tr:

; 509  :     }
; 510  : 
; 511  :     return PyLong_FromSsize_t(size);

  00167	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  0016c	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN12@bytesio_tr:

; 512  : }

  00171	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00175	c3		 ret	 0
bytesio_truncate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PGPOMJCD@new?5buffer?5size?5too?5large?$AA@ ; `string'
PUBLIC	__real@3ff2000000000000
PUBLIC	__real@43f0000000000000
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Realloc:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$resize_buffer DD imagerel resize_buffer
	DD	imagerel resize_buffer+420
	DD	imagerel $unwind$resize_buffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$resize_buffer DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BK@PGPOMJCD@new?5buffer?5size?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BK@PGPOMJCD@new?5buffer?5size?5too?5large?$AA@ DB 'new buffer size'
	DB	' too large', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3ff2000000000000
CONST	SEGMENT
__real@3ff2000000000000 DQ 03ff2000000000000r	; 1.125
CONST	ENDS
;	COMDAT __real@43f0000000000000
CONST	SEGMENT
__real@43f0000000000000 DQ 043f0000000000000r	; 1.84467e+019
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT resize_buffer
_TEXT	SEGMENT
new_buf$ = 32
alloc$ = 40
tv83 = 48
self$ = 80
size$ = 88
resize_buffer PROC					; COMDAT

; 75   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 76   :     /* Here, unsigned types are used to avoid dealing with signed integer
; 77   :        overflow, which is undefined in C. */
; 78   :     size_t alloc = self->buf_size;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00017	48 89 44 24 28	 mov	 QWORD PTR alloc$[rsp], rax

; 79   :     char *new_buf = NULL;

  0001c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR new_buf$[rsp], 0

; 80   : 
; 81   :     assert(self->buf != NULL);

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0002a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0002f	75 1c		 jne	 SHORT $LN12@resize_buf
  00031	41 b8 51 00 00
	00		 mov	 r8d, 81			; 00000051H
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@FBILHFFC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004b	33 c0		 xor	 eax, eax
$LN12@resize_buf:

; 82   : 
; 83   :     /* For simplicity, stay in the range of the signed type. Anyway, Python
; 84   :        doesn't allow strings to be longer than this. */
; 85   :     if (size > PY_SSIZE_T_MAX)

  0004d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00057	48 39 44 24 58	 cmp	 QWORD PTR size$[rsp], rax
  0005c	76 05		 jbe	 SHORT $LN9@resize_buf

; 86   :         goto overflow;

  0005e	e9 24 01 00 00	 jmp	 $overflow$20495
$LN9@resize_buf:

; 87   : 
; 88   :     if (size < alloc / 2) {

  00063	33 d2		 xor	 edx, edx
  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR alloc$[rsp]
  0006a	b9 02 00 00 00	 mov	 ecx, 2
  0006f	48 f7 f1	 div	 rcx
  00072	48 39 44 24 58	 cmp	 QWORD PTR size$[rsp], rax
  00077	73 12		 jae	 SHORT $LN8@resize_buf

; 89   :         /* Major downsize; resize down to exact size. */
; 90   :         alloc = size + 1;

  00079	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  0007e	48 ff c0	 inc	 rax
  00081	48 89 44 24 28	 mov	 QWORD PTR alloc$[rsp], rax
  00086	e9 a6 00 00 00	 jmp	 $LN7@resize_buf
$LN8@resize_buf:

; 91   :     }
; 92   :     else if (size < alloc) {

  0008b	48 8b 44 24 28	 mov	 rax, QWORD PTR alloc$[rsp]
  00090	48 39 44 24 58	 cmp	 QWORD PTR size$[rsp], rax
  00095	73 0c		 jae	 SHORT $LN6@resize_buf

; 93   :         /* Within allocated size; quick exit */
; 94   :         return 0;

  00097	33 c0		 xor	 eax, eax
  00099	e9 01 01 00 00	 jmp	 $LN10@resize_buf
  0009e	e9 8e 00 00 00	 jmp	 $LN5@resize_buf
$LN6@resize_buf:

; 95   :     }
; 96   :     else if (size <= alloc * 1.125) {

  000a3	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  000a8	66 0f ef c0	 pxor	 xmm0, xmm0
  000ac	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  000b1	48 85 c0	 test	 rax, rax
  000b4	7d 08		 jge	 SHORT $LN16@resize_buf
  000b6	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@43f0000000000000
$LN16@resize_buf:
  000be	48 8b 44 24 28	 mov	 rax, QWORD PTR alloc$[rsp]
  000c3	66 0f ef c9	 pxor	 xmm1, xmm1
  000c7	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  000cc	48 85 c0	 test	 rax, rax
  000cf	7d 08		 jge	 SHORT $LN15@resize_buf
  000d1	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR __real@43f0000000000000
$LN15@resize_buf:
  000d9	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3ff2000000000000
  000e1	66 0f 2f c8	 comisd	 xmm1, xmm0
  000e5	72 3d		 jb	 SHORT $LN4@resize_buf

; 97   :         /* Moderate upsize; overallocate similar to list_resize() */
; 98   :         alloc = size + (size >> 3) + (size < 9 ? 3 : 6);

  000e7	48 83 7c 24 58
	09		 cmp	 QWORD PTR size$[rsp], 9
  000ed	73 0a		 jae	 SHORT $LN13@resize_buf
  000ef	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv83[rsp], 3
  000f7	eb 08		 jmp	 SHORT $LN14@resize_buf
$LN13@resize_buf:
  000f9	c7 44 24 30 06
	00 00 00	 mov	 DWORD PTR tv83[rsp], 6
$LN14@resize_buf:
  00101	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  00106	48 c1 e8 03	 shr	 rax, 3
  0010a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  0010f	48 03 c8	 add	 rcx, rax
  00112	48 8b c1	 mov	 rax, rcx
  00115	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR tv83[rsp]
  0011a	48 03 c1	 add	 rax, rcx
  0011d	48 89 44 24 28	 mov	 QWORD PTR alloc$[rsp], rax

; 99   :     }
; 100  :     else {

  00122	eb 0d		 jmp	 SHORT $LN3@resize_buf
$LN4@resize_buf:

; 101  :         /* Major upsize; resize up to exact size */
; 102  :         alloc = size + 1;

  00124	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  00129	48 ff c0	 inc	 rax
  0012c	48 89 44 24 28	 mov	 QWORD PTR alloc$[rsp], rax
$LN3@resize_buf:
$LN5@resize_buf:
$LN7@resize_buf:

; 103  :     }
; 104  : 
; 105  :     if (alloc > ((size_t)-1) / sizeof(char))

  00131	48 83 7c 24 28
	ff		 cmp	 QWORD PTR alloc$[rsp], -1
  00137	76 02		 jbe	 SHORT $LN2@resize_buf

; 106  :         goto overflow;

  00139	eb 4c		 jmp	 SHORT $overflow$20495
$LN2@resize_buf:

; 107  :     new_buf = (char *)PyMem_Realloc(self->buf, alloc * sizeof(char));

  0013b	48 8b 54 24 28	 mov	 rdx, QWORD PTR alloc$[rsp]
  00140	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00145	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00149	e8 00 00 00 00	 call	 PyMem_Realloc
  0014e	48 89 44 24 20	 mov	 QWORD PTR new_buf$[rsp], rax

; 108  :     if (new_buf == NULL) {

  00153	48 83 7c 24 20
	00		 cmp	 QWORD PTR new_buf$[rsp], 0
  00159	75 0c		 jne	 SHORT $LN1@resize_buf

; 109  :         PyErr_NoMemory();

  0015b	e8 00 00 00 00	 call	 PyErr_NoMemory

; 110  :         return -1;

  00160	b8 ff ff ff ff	 mov	 eax, -1
  00165	eb 38		 jmp	 SHORT $LN10@resize_buf
$LN1@resize_buf:

; 111  :     }
; 112  :     self->buf_size = alloc;

  00167	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0016c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR alloc$[rsp]
  00171	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 113  :     self->buf = new_buf;

  00175	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0017a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_buf$[rsp]
  0017f	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 114  : 
; 115  :     return 0;

  00183	33 c0		 xor	 eax, eax
  00185	eb 18		 jmp	 SHORT $LN10@resize_buf
$overflow$20495:

; 116  : 
; 117  :   overflow:
; 118  :     PyErr_SetString(PyExc_OverflowError,
; 119  :                     "new buffer size too large");

  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PGPOMJCD@new?5buffer?5size?5too?5large?$AA@
  0018e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00195	e8 00 00 00 00	 call	 PyErr_SetString

; 120  :     return -1;

  0019a	b8 ff ff ff ff	 mov	 eax, -1
$LN10@resize_buf:

; 121  : }

  0019f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a3	c3		 ret	 0
resize_buffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_iternext DD imagerel bytesio_iternext
	DD	imagerel bytesio_iternext+104
	DD	imagerel $unwind$bytesio_iternext
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_iternext DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_iternext
_TEXT	SEGMENT
n$ = 32
next$ = 40
self$ = 64
bytesio_iternext PROC					; COMDAT

; 516  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 517  :     char *next;
; 518  :     Py_ssize_t n;
; 519  : 
; 520  :     CHECK_CLOSED(self);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	75 17		 jne	 SHORT $LN3@bytesio_it
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00023	e8 00 00 00 00	 call	 PyErr_SetString
  00028	33 c0		 xor	 eax, eax
  0002a	eb 37		 jmp	 SHORT $LN4@bytesio_it
$LN3@bytesio_it:

; 521  : 
; 522  :     n = get_line(self, &next);

  0002c	48 8d 54 24 28	 lea	 rdx, QWORD PTR next$[rsp]
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00036	e8 00 00 00 00	 call	 get_line
  0003b	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 523  : 
; 524  :     if (!next || n == 0)

  00040	48 83 7c 24 28
	00		 cmp	 QWORD PTR next$[rsp], 0
  00046	74 08		 je	 SHORT $LN1@bytesio_it
  00048	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  0004e	75 04		 jne	 SHORT $LN2@bytesio_it
$LN1@bytesio_it:

; 525  :         return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	eb 0f		 jmp	 SHORT $LN4@bytesio_it
$LN2@bytesio_it:

; 526  : 
; 527  :     return PyBytes_FromStringAndSize(next, n);

  00054	48 8b 54 24 20	 mov	 rdx, QWORD PTR n$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR next$[rsp]
  0005e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
$LN4@bytesio_it:

; 528  : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
bytesio_iternext ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@DDLGNKCJ@invalid?5whence?5?$CI?$CFi?0?5should?5be?50?0@ ; `string'
PUBLIC	??_C@_0BH@LKHKGFCB@new?5position?5too?5large?$AA@ ; `string'
PUBLIC	??_C@_0BI@MOBIMCNJ@negative?5seek?5value?5?$CFzd?$AA@ ; `string'
PUBLIC	??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_seek DD imagerel bytesio_seek
	DD	imagerel bytesio_seek+398
	DD	imagerel $unwind$bytesio_seek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_seek DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CJ@DDLGNKCJ@invalid?5whence?5?$CI?$CFi?0?5should?5be?50?0@
CONST	SEGMENT
??_C@_0CJ@DDLGNKCJ@invalid?5whence?5?$CI?$CFi?0?5should?5be?50?0@ DB 'inv'
	DB	'alid whence (%i, should be 0, 1 or 2)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LKHKGFCB@new?5position?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BH@LKHKGFCB@new?5position?5too?5large?$AA@ DB 'new position too la'
	DB	'rge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MOBIMCNJ@negative?5seek?5value?5?$CFzd?$AA@
CONST	SEGMENT
??_C@_0BI@MOBIMCNJ@negative?5seek?5value?5?$CFzd?$AA@ DB 'negative seek v'
	DB	'alue %zd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@
CONST	SEGMENT
??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@ DB 'n|i:seek', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_seek
_TEXT	SEGMENT
mode$ = 32
pos$ = 40
self$ = 64
args$ = 72
bytesio_seek PROC					; COMDAT

; 541  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 542  :     Py_ssize_t pos;
; 543  :     int mode = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR mode$[rsp], 0

; 544  : 
; 545  :     CHECK_CLOSED(self);

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0001b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00020	75 1a		 jne	 SHORT $LN11@bytesio_se
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00030	e8 00 00 00 00	 call	 PyErr_SetString
  00035	33 c0		 xor	 eax, eax
  00037	e9 4d 01 00 00	 jmp	 $LN12@bytesio_se
$LN11@bytesio_se:

; 546  : 
; 547  :     if (!PyArg_ParseTuple(args, "n|i:seek", &pos, &mode))

  0003c	4c 8d 4c 24 20	 lea	 r9, QWORD PTR mode$[rsp]
  00041	4c 8d 44 24 28	 lea	 r8, QWORD PTR pos$[rsp]
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@
  0004d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00052	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00057	85 c0		 test	 eax, eax
  00059	75 07		 jne	 SHORT $LN10@bytesio_se

; 548  :         return NULL;

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 27 01 00 00	 jmp	 $LN12@bytesio_se
$LN10@bytesio_se:

; 549  : 
; 550  :     if (pos < 0 && mode == 0) {

  00062	48 83 7c 24 28
	00		 cmp	 QWORD PTR pos$[rsp], 0
  00068	7d 26		 jge	 SHORT $LN9@bytesio_se
  0006a	83 7c 24 20 00	 cmp	 DWORD PTR mode$[rsp], 0
  0006f	75 1f		 jne	 SHORT $LN9@bytesio_se

; 551  :         PyErr_Format(PyExc_ValueError,
; 552  :                      "negative seek value %zd", pos);

  00071	4c 8b 44 24 28	 mov	 r8, QWORD PTR pos$[rsp]
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@MOBIMCNJ@negative?5seek?5value?5?$CFzd?$AA@
  0007d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00084	e8 00 00 00 00	 call	 PyErr_Format

; 553  :         return NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	e9 f9 00 00 00	 jmp	 $LN12@bytesio_se
$LN9@bytesio_se:

; 554  :     }
; 555  : 
; 556  :     /* mode 0: offset relative to beginning of the string.
; 557  :        mode 1: offset relative to current position.
; 558  :        mode 2: offset relative the end of the string. */
; 559  :     if (mode == 1) {

  00090	83 7c 24 20 01	 cmp	 DWORD PTR mode$[rsp], 1
  00095	75 4f		 jne	 SHORT $LN8@bytesio_se

; 560  :         if (pos > PY_SSIZE_T_MAX - self->pos) {

  00097	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000a6	48 2b 41 68	 sub	 rax, QWORD PTR [rcx+104]
  000aa	48 39 44 24 28	 cmp	 QWORD PTR pos$[rsp], rax
  000af	7e 1a		 jle	 SHORT $LN7@bytesio_se

; 561  :             PyErr_SetString(PyExc_OverflowError,
; 562  :                             "new position too large");

  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LKHKGFCB@new?5position?5too?5large?$AA@
  000b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000bf	e8 00 00 00 00	 call	 PyErr_SetString

; 563  :             return NULL;

  000c4	33 c0		 xor	 eax, eax
  000c6	e9 be 00 00 00	 jmp	 $LN12@bytesio_se
$LN7@bytesio_se:

; 564  :         }
; 565  :         pos += self->pos;

  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000d0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pos$[rsp]
  000d9	48 03 c8	 add	 rcx, rax
  000dc	48 8b c1	 mov	 rax, rcx
  000df	48 89 44 24 28	 mov	 QWORD PTR pos$[rsp], rax
  000e4	eb 76		 jmp	 SHORT $LN6@bytesio_se
$LN8@bytesio_se:

; 566  :     }
; 567  :     else if (mode == 2) {

  000e6	83 7c 24 20 02	 cmp	 DWORD PTR mode$[rsp], 2
  000eb	75 4c		 jne	 SHORT $LN5@bytesio_se

; 568  :         if (pos > PY_SSIZE_T_MAX - self->string_size) {

  000ed	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000fc	48 2b 41 70	 sub	 rax, QWORD PTR [rcx+112]
  00100	48 39 44 24 28	 cmp	 QWORD PTR pos$[rsp], rax
  00105	7e 17		 jle	 SHORT $LN4@bytesio_se

; 569  :             PyErr_SetString(PyExc_OverflowError,
; 570  :                             "new position too large");

  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LKHKGFCB@new?5position?5too?5large?$AA@
  0010e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00115	e8 00 00 00 00	 call	 PyErr_SetString

; 571  :             return NULL;

  0011a	33 c0		 xor	 eax, eax
  0011c	eb 6b		 jmp	 SHORT $LN12@bytesio_se
$LN4@bytesio_se:

; 572  :         }
; 573  :         pos += self->string_size;

  0011e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00123	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00127	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pos$[rsp]
  0012c	48 03 c8	 add	 rcx, rax
  0012f	48 8b c1	 mov	 rax, rcx
  00132	48 89 44 24 28	 mov	 QWORD PTR pos$[rsp], rax
  00137	eb 23		 jmp	 SHORT $LN3@bytesio_se
$LN5@bytesio_se:

; 574  :     }
; 575  :     else if (mode != 0) {

  00139	83 7c 24 20 00	 cmp	 DWORD PTR mode$[rsp], 0
  0013e	74 1c		 je	 SHORT $LN2@bytesio_se

; 576  :         PyErr_Format(PyExc_ValueError,
; 577  :                      "invalid whence (%i, should be 0, 1 or 2)", mode);

  00140	44 8b 44 24 20	 mov	 r8d, DWORD PTR mode$[rsp]
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@DDLGNKCJ@invalid?5whence?5?$CI?$CFi?0?5should?5be?50?0@
  0014c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00153	e8 00 00 00 00	 call	 PyErr_Format

; 578  :         return NULL;

  00158	33 c0		 xor	 eax, eax
  0015a	eb 2d		 jmp	 SHORT $LN12@bytesio_se
$LN2@bytesio_se:
$LN3@bytesio_se:
$LN6@bytesio_se:

; 579  :     }
; 580  : 
; 581  :     if (pos < 0)

  0015c	48 83 7c 24 28
	00		 cmp	 QWORD PTR pos$[rsp], 0
  00162	7d 09		 jge	 SHORT $LN1@bytesio_se

; 582  :         pos = 0;

  00164	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0
$LN1@bytesio_se:

; 583  :     self->pos = pos;

  0016d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00172	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pos$[rsp]
  00177	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 584  : 
; 585  :     return PyLong_FromSsize_t(self->pos);

  0017b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00180	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00184	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN12@bytesio_se:

; 586  : }

  00189	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0018d	c3		 ret	 0
bytesio_seek ENDP
_TEXT	ENDS
EXTRN	PyBuffer_Release:PROC
EXTRN	PyObject_GetBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_write DD imagerel bytesio_write
	DD	imagerel bytesio_write+240
	DD	imagerel $unwind$bytesio_write
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_write DD 021101H
	DD	0130111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_write
_TEXT	SEGMENT
n$ = 32
buf$ = 48
result$ = 128
self$ = 160
obj$ = 168
bytesio_write PROC					; COMDAT

; 595  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 596  :     Py_ssize_t n = 0;

  00011	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0

; 597  :     Py_buffer buf;
; 598  :     PyObject *result = NULL;

  0001a	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR result$[rsp], 0

; 599  : 
; 600  :     CHECK_CLOSED(self);

  00026	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0002e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00033	75 1a		 jne	 SHORT $LN5@bytesio_wr
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0003c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00043	e8 00 00 00 00	 call	 PyErr_SetString
  00048	33 c0		 xor	 eax, eax
  0004a	e9 99 00 00 00	 jmp	 $LN6@bytesio_wr
$LN5@bytesio_wr:

; 601  :     CHECK_EXPORTS(self);

  0004f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00057	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  0005f	7e 17		 jle	 SHORT $LN4@bytesio_wr
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
  00068	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0006f	e8 00 00 00 00	 call	 PyErr_SetString
  00074	33 c0		 xor	 eax, eax
  00076	eb 70		 jmp	 SHORT $LN6@bytesio_wr
$LN4@bytesio_wr:

; 602  : 
; 603  :     if (PyObject_GetBuffer(obj, &buf, PyBUF_CONTIG_RO) < 0)

  00078	41 b8 08 00 00
	00		 mov	 r8d, 8
  0007e	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00083	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  0008b	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00090	85 c0		 test	 eax, eax
  00092	7d 04		 jge	 SHORT $LN3@bytesio_wr

; 604  :         return NULL;

  00094	33 c0		 xor	 eax, eax
  00096	eb 50		 jmp	 SHORT $LN6@bytesio_wr
$LN3@bytesio_wr:

; 605  : 
; 606  :     if (buf.len != 0)

  00098	48 83 7c 24 40
	00		 cmp	 QWORD PTR buf$[rsp+16], 0
  0009e	74 1c		 je	 SHORT $LN2@bytesio_wr

; 607  :         n = write_bytes(self, buf.buf, buf.len);

  000a0	4c 8b 44 24 40	 mov	 r8, QWORD PTR buf$[rsp+16]
  000a5	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf$[rsp]
  000aa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000b2	e8 00 00 00 00	 call	 write_bytes
  000b7	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax
$LN2@bytesio_wr:

; 608  :     if (n >= 0)

  000bc	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  000c2	7c 12		 jl	 SHORT $LN1@bytesio_wr

; 609  :         result = PyLong_FromSsize_t(n);

  000c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  000c9	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000ce	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR result$[rsp], rax
$LN1@bytesio_wr:

; 610  : 
; 611  :     PyBuffer_Release(&buf);

  000d6	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000db	e8 00 00 00 00	 call	 PyBuffer_Release

; 612  :     return result;

  000e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN6@bytesio_wr:

; 613  : }

  000e8	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  000ef	c3		 ret	 0
bytesio_write ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BO@MEJGEIJC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_bytes DD imagerel write_bytes
	DD	imagerel write_bytes+379
	DD	imagerel $unwind$write_bytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_bytes DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_1BO@MEJGEIJC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MEJGEIJC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT write_bytes
_TEXT	SEGMENT
self$ = 48
bytes$ = 56
len$ = 64
write_bytes PROC					; COMDAT

; 127  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 128  :     assert(self->buf != NULL);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	75 1c		 jne	 SHORT $LN7@write_byte
  0001f	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@FBILHFFC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00039	33 c0		 xor	 eax, eax
$LN7@write_byte:

; 129  :     assert(self->pos >= 0);

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00040	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00045	7d 1c		 jge	 SHORT $LN8@write_byte
  00047	41 b8 81 00 00
	00		 mov	 r8d, 129		; 00000081H
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@MEJGEIJC@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN8@write_byte:

; 130  :     assert(len >= 0);

  00063	48 83 7c 24 40
	00		 cmp	 QWORD PTR len$[rsp], 0
  00069	7d 1c		 jge	 SHORT $LN9@write_byte
  0006b	41 b8 82 00 00
	00		 mov	 r8d, 130		; 00000082H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00085	33 c0		 xor	 eax, eax
$LN9@write_byte:

; 131  : 
; 132  :     if ((size_t)self->pos + len > self->buf_size) {

  00087	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0008c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00090	48 03 44 24 40	 add	 rax, QWORD PTR len$[rsp]
  00095	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0009a	48 3b 41 78	 cmp	 rax, QWORD PTR [rcx+120]
  0009e	76 2b		 jbe	 SHORT $LN4@write_byte

; 133  :         if (resize_buffer(self, (size_t)self->pos + len) < 0)

  000a0	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000a5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a9	48 03 44 24 40	 add	 rax, QWORD PTR len$[rsp]
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  000b6	e8 00 00 00 00	 call	 resize_buffer
  000bb	85 c0		 test	 eax, eax
  000bd	7d 0c		 jge	 SHORT $LN3@write_byte

; 134  :             return -1;

  000bf	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000c6	e9 ab 00 00 00	 jmp	 $LN5@write_byte
$LN3@write_byte:
$LN4@write_byte:

; 135  :     }
; 136  : 
; 137  :     if (self->pos > self->string_size) {

  000cb	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  000d5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000d9	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  000dd	7e 31		 jle	 SHORT $LN2@write_byte

; 138  :         /* In case of overseek, pad with null bytes the buffer region between
; 139  :            the end of stream and the current position.
; 140  : 
; 141  :           0   lo      string_size                           hi
; 142  :           |   |<---used--->|<----------available----------->|
; 143  :           |   |            <--to pad-->|<---to write--->    |
; 144  :           0   buf                   position
; 145  :         */
; 146  :         memset(self->buf + self->string_size, '\0',
; 147  :                (self->pos - self->string_size) * sizeof(char));

  000df	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000e4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  000e9	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000ed	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f1	48 2b c1	 sub	 rax, rcx
  000f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  000f9	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000fd	48 8b 54 24 30	 mov	 rdx, QWORD PTR self$[rsp]
  00102	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  00106	4c 8b c0	 mov	 r8, rax
  00109	33 d2		 xor	 edx, edx
  0010b	e8 00 00 00 00	 call	 memset
$LN2@write_byte:

; 148  :     }
; 149  : 
; 150  :     /* Copy the data to the internal buffer, overwriting some of the existing
; 151  :        data if self->pos < self->string_size. */
; 152  :     memcpy(self->buf + self->pos, bytes, len);

  00110	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00115	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00119	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0011e	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  00122	4c 8b 44 24 40	 mov	 r8, QWORD PTR len$[rsp]
  00127	48 8b 54 24 38	 mov	 rdx, QWORD PTR bytes$[rsp]
  0012c	48 8b c8	 mov	 rcx, rax
  0012f	e8 00 00 00 00	 call	 memcpy

; 153  :     self->pos += len;

  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00139	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0013d	48 03 44 24 40	 add	 rax, QWORD PTR len$[rsp]
  00142	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00147	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 154  : 
; 155  :     /* Set the new length of the internal string if it has changed. */
; 156  :     if (self->string_size < self->pos) {

  0014b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00150	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00155	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00159	48 39 48 70	 cmp	 QWORD PTR [rax+112], rcx
  0015d	7d 12		 jge	 SHORT $LN1@write_byte

; 157  :         self->string_size = self->pos;

  0015f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00164	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00169	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0016d	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
$LN1@write_byte:

; 158  :     }
; 159  : 
; 160  :     return len;

  00171	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
$LN5@write_byte:

; 161  : }

  00176	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0017a	c3		 ret	 0
write_bytes ENDP
_TEXT	ENDS
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_writelines DD imagerel bytesio_writelines
	DD	imagerel bytesio_writelines+217
	DD	imagerel $unwind$bytesio_writelines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_writelines DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_writelines
_TEXT	SEGMENT
it$ = 32
ret$ = 40
item$ = 48
self$ = 80
v$ = 88
bytesio_writelines PROC					; COMDAT

; 624  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 625  :     PyObject *it, *item;
; 626  :     PyObject *ret;
; 627  : 
; 628  :     CHECK_CLOSED(self);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00018	75 1a		 jne	 SHORT $LN6@bytesio_wr@2
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00028	e8 00 00 00 00	 call	 PyErr_SetString
  0002d	33 c0		 xor	 eax, eax
  0002f	e9 a0 00 00 00	 jmp	 $LN7@bytesio_wr@2
$LN6@bytesio_wr@2:

; 629  : 
; 630  :     it = PyObject_GetIter(v);

  00034	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  00039	e8 00 00 00 00	 call	 PyObject_GetIter
  0003e	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 631  :     if (it == NULL)

  00043	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00049	75 07		 jne	 SHORT $LN5@bytesio_wr@2

; 632  :         return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	e9 82 00 00 00	 jmp	 $LN7@bytesio_wr@2
$LN5@bytesio_wr@2:
$LN4@bytesio_wr@2:

; 633  : 
; 634  :     while ((item = PyIter_Next(it)) != NULL) {

  00052	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00057	e8 00 00 00 00	 call	 PyIter_Next
  0005c	48 89 44 24 30	 mov	 QWORD PTR item$[rsp], rax
  00061	48 83 7c 24 30
	00		 cmp	 QWORD PTR item$[rsp], 0
  00067	74 40		 je	 SHORT $LN3@bytesio_wr@2

; 635  :         ret = bytesio_write(self, item);

  00069	48 8b 54 24 30	 mov	 rdx, QWORD PTR item$[rsp]
  0006e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00073	e8 00 00 00 00	 call	 bytesio_write
  00078	48 89 44 24 28	 mov	 QWORD PTR ret$[rsp], rax

; 636  :         Py_DECREF(item);

  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  00082	e8 00 00 00 00	 call	 _Py_DecRef

; 637  :         if (ret == NULL) {

  00087	48 83 7c 24 28
	00		 cmp	 QWORD PTR ret$[rsp], 0
  0008d	75 0e		 jne	 SHORT $LN2@bytesio_wr@2

; 638  :             Py_DECREF(it);

  0008f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00094	e8 00 00 00 00	 call	 _Py_DecRef

; 639  :             return NULL;

  00099	33 c0		 xor	 eax, eax
  0009b	eb 37		 jmp	 SHORT $LN7@bytesio_wr@2
$LN2@bytesio_wr@2:

; 640  :         }
; 641  :         Py_DECREF(ret);

  0009d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ret$[rsp]
  000a2	e8 00 00 00 00	 call	 _Py_DecRef

; 642  :     }

  000a7	eb a9		 jmp	 SHORT $LN4@bytesio_wr@2
$LN3@bytesio_wr@2:

; 643  :     Py_DECREF(it);

  000a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000ae	e8 00 00 00 00	 call	 _Py_DecRef

; 644  : 
; 645  :     /* See if PyIter_Next failed */
; 646  :     if (PyErr_Occurred())

  000b3	e8 00 00 00 00	 call	 PyErr_Occurred
  000b8	48 85 c0	 test	 rax, rax
  000bb	74 04		 je	 SHORT $LN1@bytesio_wr@2

; 647  :         return NULL;

  000bd	33 c0		 xor	 eax, eax
  000bf	eb 13		 jmp	 SHORT $LN7@bytesio_wr@2
$LN1@bytesio_wr@2:

; 648  : 
; 649  :     Py_RETURN_NONE;

  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000c8	e8 00 00 00 00	 call	 _Py_IncRef
  000cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN7@bytesio_wr@2:

; 650  : }

  000d4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d8	c3		 ret	 0
bytesio_writelines ENDP
_TEXT	ENDS
EXTRN	PyMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_close DD imagerel bytesio_close
	DD	imagerel bytesio_close+72
	DD	imagerel $unwind$bytesio_close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_close DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_close
_TEXT	SEGMENT
self$ = 48
bytesio_close PROC					; COMDAT

; 657  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 658  :     if (self->buf != NULL) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 1b		 je	 SHORT $LN1@bytesio_cl

; 659  :         PyMem_Free(self->buf);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0001e	e8 00 00 00 00	 call	 PyMem_Free

; 660  :         self->buf = NULL;

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00028	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
$LN1@bytesio_cl:

; 661  :     }
; 662  :     Py_RETURN_NONE;

  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00037	e8 00 00 00 00	 call	 _Py_IncRef
  0003c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 663  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
bytesio_close ENDP
_TEXT	ENDS
PUBLIC	??_C@_05JKNKKJIO@?$CIOnN?$CJ?$AA@		; `string'
EXTRN	Py_BuildValue:PROC
EXTRN	PyDict_Copy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_getstate DD imagerel bytesio_getstate
	DD	imagerel bytesio_getstate+180
	DD	imagerel $unwind$bytesio_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_getstate DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_05JKNKKJIO@?$CIOnN?$CJ?$AA@
CONST	SEGMENT
??_C@_05JKNKKJIO@?$CIOnN?$CJ?$AA@ DB '(OnN)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_getstate
_TEXT	SEGMENT
dict$ = 32
initvalue$ = 40
state$ = 48
self$ = 80
bytesio_getstate PROC					; COMDAT

; 682  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 683  :     PyObject *initvalue = bytesio_getvalue(self);

  00009	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 bytesio_getvalue
  00013	48 89 44 24 28	 mov	 QWORD PTR initvalue$[rsp], rax

; 684  :     PyObject *dict;
; 685  :     PyObject *state;
; 686  : 
; 687  :     if (initvalue == NULL)

  00018	48 83 7c 24 28
	00		 cmp	 QWORD PTR initvalue$[rsp], 0
  0001e	75 07		 jne	 SHORT $LN4@bytesio_ge@4

; 688  :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	e9 88 00 00 00	 jmp	 $LN5@bytesio_ge@4
$LN4@bytesio_ge@4:

; 689  :     if (self->dict == NULL) {

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0002c	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00034	75 1a		 jne	 SHORT $LN3@bytesio_ge@4

; 690  :         Py_INCREF(Py_None);

  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0003d	e8 00 00 00 00	 call	 _Py_IncRef

; 691  :         dict = Py_None;

  00042	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00049	48 89 44 24 20	 mov	 QWORD PTR dict$[rsp], rax

; 692  :     }
; 693  :     else {

  0004e	eb 2c		 jmp	 SHORT $LN2@bytesio_ge@4
$LN3@bytesio_ge@4:

; 694  :         dict = PyDict_Copy(self->dict);

  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00055	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0005c	e8 00 00 00 00	 call	 PyDict_Copy
  00061	48 89 44 24 20	 mov	 QWORD PTR dict$[rsp], rax

; 695  :         if (dict == NULL) {

  00066	48 83 7c 24 20
	00		 cmp	 QWORD PTR dict$[rsp], 0
  0006c	75 0e		 jne	 SHORT $LN1@bytesio_ge@4

; 696  :             Py_DECREF(initvalue);

  0006e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR initvalue$[rsp]
  00073	e8 00 00 00 00	 call	 _Py_DecRef

; 697  :             return NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	eb 33		 jmp	 SHORT $LN5@bytesio_ge@4
$LN1@bytesio_ge@4:
$LN2@bytesio_ge@4:

; 698  :         }
; 699  :     }
; 700  : 
; 701  :     state = Py_BuildValue("(OnN)", initvalue, self->pos, dict);

  0007c	4c 8b 4c 24 20	 mov	 r9, QWORD PTR dict$[rsp]
  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00086	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  0008a	48 8b 54 24 28	 mov	 rdx, QWORD PTR initvalue$[rsp]
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05JKNKKJIO@?$CIOnN?$CJ?$AA@
  00096	e8 00 00 00 00	 call	 Py_BuildValue
  0009b	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 702  :     Py_DECREF(initvalue);

  000a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR initvalue$[rsp]
  000a5	e8 00 00 00 00	 call	 _Py_DecRef

; 703  :     return state;

  000aa	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
$LN5@bytesio_ge@4:

; 704  : }

  000af	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b3	c3		 ret	 0
bytesio_getstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@LLMMLCL@third?5item?5of?5state?5should?5be?5a?5@ ; `string'
PUBLIC	??_C@_0CC@PHIJAEHN@position?5value?5cannot?5be?5negativ@ ; `string'
PUBLIC	??_C@_0DE@GABJIGBE@second?5item?5of?5state?5must?5be?5an?5@ ; `string'
PUBLIC	??_C@_0DL@OPPOCNNE@?$CF?4200s?4__setstate__?5argument?5sho@ ; `string'
PUBLIC	??_C@_1BM@MIMANDHC@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PyDict_Update:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_setstate DD imagerel bytesio_setstate
	DD	imagerel bytesio_setstate+612
	DD	imagerel $unwind$bytesio_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_setstate DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0DD@LLMMLCL@third?5item?5of?5state?5should?5be?5a?5@
CONST	SEGMENT
??_C@_0DD@LLMMLCL@third?5item?5of?5state?5should?5be?5a?5@ DB 'third item'
	DB	' of state should be a dict, got a %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PHIJAEHN@position?5value?5cannot?5be?5negativ@
CONST	SEGMENT
??_C@_0CC@PHIJAEHN@position?5value?5cannot?5be?5negativ@ DB 'position val'
	DB	'ue cannot be negative', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GABJIGBE@second?5item?5of?5state?5must?5be?5an?5@
CONST	SEGMENT
??_C@_0DE@GABJIGBE@second?5item?5of?5state?5must?5be?5an?5@ DB 'second it'
	DB	'em of state must be an integer, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OPPOCNNE@?$CF?4200s?4__setstate__?5argument?5sho@
CONST	SEGMENT
??_C@_0DL@OPPOCNNE@?$CF?4200s?4__setstate__?5argument?5sho@ DB '%.200s.__'
	DB	'setstate__ argument should be 3-tuple, got %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@MIMANDHC@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@MIMANDHC@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_setstate
_TEXT	SEGMENT
position_obj$ = 32
dict$ = 40
result$ = 48
pos$ = 56
self$ = 80
state$ = 88
bytesio_setstate PROC					; COMDAT

; 708  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 709  :     PyObject *result;
; 710  :     PyObject *position_obj;
; 711  :     PyObject *dict;
; 712  :     Py_ssize_t pos;
; 713  : 
; 714  :     assert(state != NULL);

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR state$[rsp], 0
  00014	75 1c		 jne	 SHORT $LN15@bytesio_se@2
  00016	41 b8 ca 02 00
	00		 mov	 r8d, 714		; 000002caH
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@MIMANDHC@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN15@bytesio_se@2:

; 715  : 
; 716  :     /* We allow the state tuple to be longer than 3, because we may need
; 717  :        someday to extend the object's state without breaking
; 718  :        backward-compatibility. */
; 719  :     if (!PyTuple_Check(state) || Py_SIZE(state) < 3) {

  00032	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  00037	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00041	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00046	85 c0		 test	 eax, eax
  00048	74 0c		 je	 SHORT $LN11@bytesio_se@2
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  0004f	48 83 78 60 03	 cmp	 QWORD PTR [rax+96], 3
  00054	7d 34		 jge	 SHORT $LN12@bytesio_se@2
$LN11@bytesio_se@2:

; 720  :         PyErr_Format(PyExc_TypeError,
; 721  :                      "%.200s.__setstate__ argument should be 3-tuple, got %.200s",
; 722  :                      Py_TYPE(self)->tp_name, Py_TYPE(state)->tp_name);

  00056	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  0005b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00064	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00068	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  0006c	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@OPPOCNNE@?$CF?4200s?4__setstate__?5argument?5sho@
  00077	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007e	e8 00 00 00 00	 call	 PyErr_Format

; 723  :         return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	e9 d5 01 00 00	 jmp	 $LN13@bytesio_se@2
$LN12@bytesio_se@2:

; 724  :     }
; 725  :     CHECK_EXPORTS(self);

  0008a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0008f	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  00097	7e 1a		 jle	 SHORT $LN10@bytesio_se@2
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
  000a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  000a7	e8 00 00 00 00	 call	 PyErr_SetString
  000ac	33 c0		 xor	 eax, eax
  000ae	e9 ac 01 00 00	 jmp	 $LN13@bytesio_se@2
$LN10@bytesio_se@2:

; 726  :     /* Reset the object to its default state. This is only needed to handle
; 727  :        the case of repeated calls to __setstate__. */
; 728  :     self->string_size = 0;

  000b3	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000b8	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 729  :     self->pos = 0;

  000c0	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c5	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 730  : 
; 731  :     /* Set the value of the internal buffer. If state[0] does not support the
; 732  :        buffer protocol, bytesio_write will raise the appropriate TypeError. */
; 733  :     result = bytesio_write(self, PyTuple_GET_ITEM(state, 0));

  000cd	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  000d2	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  000d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000db	e8 00 00 00 00	 call	 bytesio_write
  000e0	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 734  :     if (result == NULL)

  000e5	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  000eb	75 07		 jne	 SHORT $LN9@bytesio_se@2

; 735  :         return NULL;

  000ed	33 c0		 xor	 eax, eax
  000ef	e9 6b 01 00 00	 jmp	 $LN13@bytesio_se@2
$LN9@bytesio_se@2:

; 736  :     Py_DECREF(result);

  000f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  000f9	e8 00 00 00 00	 call	 _Py_DecRef

; 737  : 
; 738  :     /* Set carefully the position value. Alternatively, we could use the seek
; 739  :        method instead of modifying self->pos directly to better protect the
; 740  :        object internal state against errneous (or malicious) inputs. */
; 741  :     position_obj = PyTuple_GET_ITEM(state, 1);

  000fe	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  00103	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00107	48 89 44 24 20	 mov	 QWORD PTR position_obj$[rsp], rax

; 742  :     if (!PyLong_Check(position_obj)) {

  0010c	48 8b 44 24 20	 mov	 rax, QWORD PTR position_obj$[rsp]
  00111	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00115	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0011b	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00120	85 c0		 test	 eax, eax
  00122	75 27		 jne	 SHORT $LN8@bytesio_se@2

; 743  :         PyErr_Format(PyExc_TypeError,
; 744  :                      "second item of state must be an integer, not %.200s",
; 745  :                      Py_TYPE(position_obj)->tp_name);

  00124	48 8b 44 24 20	 mov	 rax, QWORD PTR position_obj$[rsp]
  00129	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0012d	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00131	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@GABJIGBE@second?5item?5of?5state?5must?5be?5an?5@
  00138	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0013f	e8 00 00 00 00	 call	 PyErr_Format

; 746  :         return NULL;

  00144	33 c0		 xor	 eax, eax
  00146	e9 14 01 00 00	 jmp	 $LN13@bytesio_se@2
$LN8@bytesio_se@2:

; 747  :     }
; 748  :     pos = PyLong_AsSsize_t(position_obj);

  0014b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR position_obj$[rsp]
  00150	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00155	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 749  :     if (pos == -1 && PyErr_Occurred())

  0015a	48 83 7c 24 38
	ff		 cmp	 QWORD PTR pos$[rsp], -1
  00160	75 11		 jne	 SHORT $LN7@bytesio_se@2
  00162	e8 00 00 00 00	 call	 PyErr_Occurred
  00167	48 85 c0	 test	 rax, rax
  0016a	74 07		 je	 SHORT $LN7@bytesio_se@2

; 750  :         return NULL;

  0016c	33 c0		 xor	 eax, eax
  0016e	e9 ec 00 00 00	 jmp	 $LN13@bytesio_se@2
$LN7@bytesio_se@2:

; 751  :     if (pos < 0) {

  00173	48 83 7c 24 38
	00		 cmp	 QWORD PTR pos$[rsp], 0
  00179	7d 1a		 jge	 SHORT $LN6@bytesio_se@2

; 752  :         PyErr_SetString(PyExc_ValueError,
; 753  :                         "position value cannot be negative");

  0017b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@PHIJAEHN@position?5value?5cannot?5be?5negativ@
  00182	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00189	e8 00 00 00 00	 call	 PyErr_SetString

; 754  :         return NULL;

  0018e	33 c0		 xor	 eax, eax
  00190	e9 ca 00 00 00	 jmp	 $LN13@bytesio_se@2
$LN6@bytesio_se@2:

; 755  :     }
; 756  :     self->pos = pos;

  00195	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0019a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pos$[rsp]
  0019f	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 757  : 
; 758  :     /* Set the dictionary of the instance variables. */
; 759  :     dict = PyTuple_GET_ITEM(state, 2);

  001a3	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  001a8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  001af	48 89 44 24 28	 mov	 QWORD PTR dict$[rsp], rax

; 760  :     if (dict != Py_None) {

  001b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001bb	48 39 44 24 28	 cmp	 QWORD PTR dict$[rsp], rax
  001c0	0f 84 86 00 00
	00		 je	 $LN5@bytesio_se@2

; 761  :         if (!PyDict_Check(dict)) {

  001c6	48 8b 44 24 28	 mov	 rax, QWORD PTR dict$[rsp]
  001cb	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001cf	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001d5	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  001da	85 c0		 test	 eax, eax
  001dc	75 24		 jne	 SHORT $LN4@bytesio_se@2

; 762  :             PyErr_Format(PyExc_TypeError,
; 763  :                          "third item of state should be a dict, got a %.200s",
; 764  :                          Py_TYPE(dict)->tp_name);

  001de	48 8b 44 24 28	 mov	 rax, QWORD PTR dict$[rsp]
  001e3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001e7	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  001eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@LLMMLCL@third?5item?5of?5state?5should?5be?5a?5@
  001f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001f9	e8 00 00 00 00	 call	 PyErr_Format

; 765  :             return NULL;

  001fe	33 c0		 xor	 eax, eax
  00200	eb 5d		 jmp	 SHORT $LN13@bytesio_se@2
$LN4@bytesio_se@2:

; 766  :         }
; 767  :         if (self->dict) {

  00202	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00207	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0020f	74 20		 je	 SHORT $LN3@bytesio_se@2

; 768  :             /* Alternatively, we could replace the internal dictionary
; 769  :                completely. However, it seems more practical to just update it. */
; 770  :             if (PyDict_Update(self->dict, dict) < 0)

  00211	48 8b 54 24 28	 mov	 rdx, QWORD PTR dict$[rsp]
  00216	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0021b	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00222	e8 00 00 00 00	 call	 PyDict_Update
  00227	85 c0		 test	 eax, eax
  00229	7d 04		 jge	 SHORT $LN2@bytesio_se@2

; 771  :                 return NULL;

  0022b	33 c0		 xor	 eax, eax
  0022d	eb 30		 jmp	 SHORT $LN13@bytesio_se@2
$LN2@bytesio_se@2:

; 772  :         }
; 773  :         else {

  0022f	eb 1b		 jmp	 SHORT $LN1@bytesio_se@2
$LN3@bytesio_se@2:

; 774  :             Py_INCREF(dict);

  00231	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dict$[rsp]
  00236	e8 00 00 00 00	 call	 _Py_IncRef

; 775  :             self->dict = dict;

  0023b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00240	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dict$[rsp]
  00245	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx
$LN1@bytesio_se@2:
$LN5@bytesio_se@2:

; 776  :         }
; 777  :     }
; 778  : 
; 779  :     Py_RETURN_NONE;

  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00253	e8 00 00 00 00	 call	 _Py_IncRef
  00258	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN13@bytesio_se@2:

; 780  : }

  0025f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00263	c3		 ret	 0
bytesio_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@BICFODFJ@deallocated?5BytesIO?5object?5has?5e@ ; `string'
PUBLIC	??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ ; `string'
PUBLIC	??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@		; `string'
PUBLIC	??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@ ; `string'
EXTRN	PyObject_ClearWeakRefs:PROC
EXTRN	PyErr_Print:PROC
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_dealloc DD imagerel bytesio_dealloc
	DD	imagerel bytesio_dealloc+489
	DD	imagerel $unwind$bytesio_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_dealloc DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0DA@BICFODFJ@deallocated?5BytesIO?5object?5has?5e@
CONST	SEGMENT
??_C@_0DA@BICFODFJ@deallocated?5BytesIO?5object?5has?5e@ DB 'deallocated '
	DB	'BytesIO object has exported buffers', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
CONST	SEGMENT
??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ DB 'g'
	DB	00H, '-', 00H, '>', 00H, 'g', 00H, 'c', 00H, '.', 00H, 'g', 00H
	DB	'c', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 's', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H, 'y', 00H
	DB	'G', 00H, 'C', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'S'
	DB	00H, '_', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H
	DB	'C', 00H, 'K', 00H, 'E', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@
CONST	SEGMENT
??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@ DB 'bytesio_dealloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
CONST	SEGMENT
??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@ DB '..\Modules\_io'
	DB	'\bytesio.c', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_dealloc
_TEXT	SEGMENT
g$20968 = 48
_py_tmp$20983 = 56
tv79 = 64
self$ = 96
bytesio_dealloc PROC					; COMDAT

; 784  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 785  :     _PyObject_GC_UNTRACK(self);

  00009	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00011	4c 8b 4c 24 60	 mov	 r9, QWORD PTR self$[rsp]
  00016	41 b8 11 03 00
	00		 mov	 r8d, 785		; 00000311H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@
  0002a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0002f	85 c0		 test	 eax, eax
  00031	0f 85 c1 00 00
	00		 jne	 $LN11@bytesio_de
$LN10@bytesio_de:
  00037	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0003f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR self$[rsp]
  00044	41 b8 11 03 00
	00		 mov	 r8d, 785		; 00000311H
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@
  00058	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005d	85 c0		 test	 eax, eax
  0005f	74 0b		 je	 SHORT $LN14@bytesio_de
  00061	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  0006a	eb 0e		 jmp	 SHORT $LN15@bytesio_de
$LN14@bytesio_de:
  0006c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00071	48 83 e8 18	 sub	 rax, 24
  00075	48 89 44 24 40	 mov	 QWORD PTR tv79[rsp], rax
$LN15@bytesio_de:
  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR tv79[rsp]
  0007f	48 89 44 24 30	 mov	 QWORD PTR g$20968[rsp], rax
  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20968[rsp]
  00089	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  0008e	75 1c		 jne	 SHORT $LN16@bytesio_de
  00090	41 b8 11 03 00
	00		 mov	 r8d, 785		; 00000311H
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000aa	33 c0		 xor	 eax, eax
$LN16@bytesio_de:
  000ac	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20968[rsp]
  000b1	48 c7 40 10 fe
	ff ff ff	 mov	 QWORD PTR [rax+16], -2
  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20968[rsp]
  000be	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$20968[rsp]
  000c7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ca	48 89 08	 mov	 QWORD PTR [rax], rcx
  000cd	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20968[rsp]
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$20968[rsp]
  000da	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000de	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20968[rsp]
  000e7	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 85 3f ff ff
	ff		 jne	 $LN10@bytesio_de
$LN11@bytesio_de:

; 786  :     if (self->exports > 0) {

  000f8	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000fd	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  00105	7e 18		 jle	 SHORT $LN7@bytesio_de

; 787  :         PyErr_SetString(PyExc_SystemError,
; 788  :                         "deallocated BytesIO object has exported buffers");

  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@BICFODFJ@deallocated?5BytesIO?5object?5has?5e@
  0010e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00115	e8 00 00 00 00	 call	 PyErr_SetString

; 789  :         PyErr_Print();

  0011a	e8 00 00 00 00	 call	 PyErr_Print
$LN7@bytesio_de:

; 790  :     }
; 791  :     if (self->buf != NULL) {

  0011f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00124	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00129	74 1b		 je	 SHORT $LN6@bytesio_de

; 792  :         PyMem_Free(self->buf);

  0012b	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00130	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00134	e8 00 00 00 00	 call	 PyMem_Free

; 793  :         self->buf = NULL;

  00139	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0013e	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
$LN6@bytesio_de:
$LN5@bytesio_de:

; 794  :     }
; 795  :     Py_CLEAR(self->dict);

  00146	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0014b	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00153	74 5c		 je	 SHORT $LN2@bytesio_de
  00155	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0015d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00162	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  00169	41 b8 1b 03 00
	00		 mov	 r8d, 795		; 0000031bH
  0016f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@
  0017d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00182	85 c0		 test	 eax, eax
  00184	75 2b		 jne	 SHORT $LN2@bytesio_de
  00186	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0018b	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00192	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$20983[rsp], rax
  00197	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0019c	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
  001a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$20983[rsp]
  001ac	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@bytesio_de:
  001b1	33 c0		 xor	 eax, eax
  001b3	85 c0		 test	 eax, eax
  001b5	75 8f		 jne	 SHORT $LN5@bytesio_de

; 796  :     if (self->weakreflist != NULL)

  001b7	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001bc	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  001c4	74 0a		 je	 SHORT $LN1@bytesio_de

; 797  :         PyObject_ClearWeakRefs((PyObject *) self);

  001c6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001cb	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN1@bytesio_de:

; 798  :     Py_TYPE(self)->tp_free(self);

  001d0	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001d5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001d9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001de	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 799  : }

  001e4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e8	c3		 ret	 0
bytesio_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@ ; `string'
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_new DD imagerel bytesio_new
	DD	imagerel bytesio_new+160
	DD	imagerel $unwind$bytesio_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_new DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@
CONST	SEGMENT
??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@ DB 't'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'p', 00H, '_', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_new
_TEXT	SEGMENT
self$ = 32
type$ = 64
args$ = 72
kwds$ = 80
bytesio_new PROC					; COMDAT

; 803  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 804  :     bytesio *self;
; 805  : 
; 806  :     assert(type != NULL && type->tp_alloc != NULL);

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR type$[rsp], 0
  00019	74 0f		 je	 SHORT $LN5@bytesio_ne
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  00020	48 83 b8 88 01
	00 00 00	 cmp	 QWORD PTR [rax+392], 0
  00028	75 1c		 jne	 SHORT $LN6@bytesio_ne
$LN5@bytesio_ne:
  0002a	41 b8 26 03 00
	00		 mov	 r8d, 806		; 00000326H
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@DOOMEKFA@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00044	33 c0		 xor	 eax, eax
$LN6@bytesio_ne:

; 807  :     self = (bytesio *)type->tp_alloc(type, 0);

  00046	33 d2		 xor	 edx, edx
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  00052	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00058	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 808  :     if (self == NULL)

  0005d	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00063	75 04		 jne	 SHORT $LN2@bytesio_ne

; 809  :         return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	eb 32		 jmp	 SHORT $LN3@bytesio_ne
$LN2@bytesio_ne:

; 810  : 
; 811  :     /* tp_alloc initializes all the fields to zero. So we don't have to
; 812  :        initialize them here. */
; 813  : 
; 814  :     self->buf = (char *)PyMem_Malloc(0);

  00069	33 c9		 xor	 ecx, ecx
  0006b	e8 00 00 00 00	 call	 PyMem_Malloc
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00075	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 815  :     if (self->buf == NULL) {

  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0007e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00083	75 11		 jne	 SHORT $LN1@bytesio_ne

; 816  :         Py_DECREF(self);

  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  0008a	e8 00 00 00 00	 call	 _Py_DecRef

; 817  :         return PyErr_NoMemory();

  0008f	e8 00 00 00 00	 call	 PyErr_NoMemory
  00094	eb 05		 jmp	 SHORT $LN3@bytesio_ne
$LN1@bytesio_ne:

; 818  :     }
; 819  : 
; 820  :     return (PyObject *)self;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
$LN3@bytesio_ne:

; 821  : }

  0009b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009f	c3		 ret	 0
bytesio_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BGOHJFDD@?$HMO?3BytesIO?$AA@		; `string'
PUBLIC	??_C@_0O@CIEEPJHK@initial_bytes?$AA@		; `string'
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_init DD imagerel bytesio_init
	DD	imagerel bytesio_init+210
	DD	imagerel $unwind$bytesio_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_init DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0L@BGOHJFDD@?$HMO?3BytesIO?$AA@
CONST	SEGMENT
??_C@_0L@BGOHJFDD@?$HMO?3BytesIO?$AA@ DB '|O:BytesIO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CIEEPJHK@initial_bytes?$AA@
CONST	SEGMENT
??_C@_0O@CIEEPJHK@initial_bytes?$AA@ DB 'initial_bytes', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_init
_TEXT	SEGMENT
kwlist$ = 48
initvalue$ = 64
res$21029 = 72
self$ = 96
args$ = 104
kwds$ = 112
bytesio_init PROC					; COMDAT

; 825  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 826  :     char *kwlist[] = {"initial_bytes", NULL};

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@CIEEPJHK@initial_bytes?$AA@
  0001a	48 89 44 24 30	 mov	 QWORD PTR kwlist$[rsp], rax
  0001f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR kwlist$[rsp+8], 0

; 827  :     PyObject *initvalue = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR initvalue$[rsp], 0

; 828  : 
; 829  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O:BytesIO", kwlist,
; 830  :                                      &initvalue))

  00031	48 8d 44 24 40	 lea	 rax, QWORD PTR initvalue$[rsp]
  00036	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003b	4c 8d 4c 24 30	 lea	 r9, QWORD PTR kwlist$[rsp]
  00040	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@BGOHJFDD@?$HMO?3BytesIO?$AA@
  00047	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwds$[rsp]
  0004c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00051	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00056	85 c0		 test	 eax, eax
  00058	75 07		 jne	 SHORT $LN3@bytesio_in

; 831  :         return -1;

  0005a	b8 ff ff ff ff	 mov	 eax, -1
  0005f	eb 6c		 jmp	 SHORT $LN4@bytesio_in
$LN3@bytesio_in:

; 832  : 
; 833  :     /* In case, __init__ is called multiple times. */
; 834  :     self->string_size = 0;

  00061	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00066	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 835  :     self->pos = 0;

  0006e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00073	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 836  : 
; 837  :     if (initvalue && initvalue != Py_None) {

  0007b	48 83 7c 24 40
	00		 cmp	 QWORD PTR initvalue$[rsp], 0
  00081	74 48		 je	 SHORT $LN2@bytesio_in
  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0008a	48 39 44 24 40	 cmp	 QWORD PTR initvalue$[rsp], rax
  0008f	74 3a		 je	 SHORT $LN2@bytesio_in

; 838  :         PyObject *res;
; 839  :         res = bytesio_write(self, initvalue);

  00091	48 8b 54 24 40	 mov	 rdx, QWORD PTR initvalue$[rsp]
  00096	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0009b	e8 00 00 00 00	 call	 bytesio_write
  000a0	48 89 44 24 48	 mov	 QWORD PTR res$21029[rsp], rax

; 840  :         if (res == NULL)

  000a5	48 83 7c 24 48
	00		 cmp	 QWORD PTR res$21029[rsp], 0
  000ab	75 07		 jne	 SHORT $LN1@bytesio_in

; 841  :             return -1;

  000ad	b8 ff ff ff ff	 mov	 eax, -1
  000b2	eb 19		 jmp	 SHORT $LN4@bytesio_in
$LN1@bytesio_in:

; 842  :         Py_DECREF(res);

  000b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR res$21029[rsp]
  000b9	e8 00 00 00 00	 call	 _Py_DecRef

; 843  :         self->pos = 0;

  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000c3	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN2@bytesio_in:

; 844  :     }
; 845  : 
; 846  :     return 0;

  000cb	33 c0		 xor	 eax, eax
$LN4@bytesio_in:

; 847  : }

  000cd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d1	c3		 ret	 0
bytesio_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_sizeof DD imagerel bytesio_sizeof
	DD	imagerel bytesio_sizeof+75
	DD	imagerel $unwind$bytesio_sizeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_sizeof DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesio_sizeof
_TEXT	SEGMENT
res$ = 32
self$ = 64
unused$ = 72
bytesio_sizeof PROC					; COMDAT

; 851  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 852  :     Py_ssize_t res;
; 853  : 
; 854  :     res = sizeof(bytesio);

  0000e	48 c7 44 24 20
	a0 00 00 00	 mov	 QWORD PTR res$[rsp], 160 ; 000000a0H

; 855  :     if (self->buf)

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0001c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00021	74 19		 je	 SHORT $LN1@bytesio_si

; 856  :         res += self->buf_size;

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00028	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  00031	48 03 c8	 add	 rcx, rax
  00034	48 8b c1	 mov	 rax, rcx
  00037	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax
$LN1@bytesio_si:

; 857  :     return PyLong_FromSsize_t(res);

  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  00041	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 858  : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
bytesio_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@EDCFKHFH@bytesio_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_traverse DD imagerel bytesio_traverse
	DD	imagerel bytesio_traverse+122
	DD	imagerel $unwind$bytesio_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BB@EDCFKHFH@bytesio_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@EDCFKHFH@bytesio_traverse?$AA@ DB 'bytesio_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_traverse
_TEXT	SEGMENT
vret$21056 = 32
self$ = 64
visit$ = 72
arg$ = 80
bytesio_traverse PROC					; COMDAT

; 862  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@bytesio_tr@2:

; 863  :     Py_VISIT(self->dict);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@bytesio_tr@2
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 5f 03 00
	00		 mov	 r8d, 863		; 0000035fH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@EDCFKHFH@bytesio_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@bytesio_tr@2:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00045	74 26		 je	 SHORT $LN2@bytesio_tr@2
  00047	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00051	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00058	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  0005c	89 44 24 20	 mov	 DWORD PTR vret$21056[rsp], eax
  00060	83 7c 24 20 00	 cmp	 DWORD PTR vret$21056[rsp], 0
  00065	74 06		 je	 SHORT $LN1@bytesio_tr@2
  00067	8b 44 24 20	 mov	 eax, DWORD PTR vret$21056[rsp]
  0006b	eb 08		 jmp	 SHORT $LN7@bytesio_tr@2
$LN1@bytesio_tr@2:
$LN2@bytesio_tr@2:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 a0		 jne	 SHORT $LN6@bytesio_tr@2

; 864  :     return 0;

  00073	33 c0		 xor	 eax, eax
$LN7@bytesio_tr@2:

; 865  : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
bytesio_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@MDPHEDOG@bytesio_clear?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_clear DD imagerel bytesio_clear
	DD	imagerel bytesio_clear+129
	DD	imagerel $unwind$bytesio_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_clear DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0O@MDPHEDOG@bytesio_clear?$AA@
CONST	SEGMENT
??_C@_0O@MDPHEDOG@bytesio_clear?$AA@ DB 'bytesio_clear', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesio_clear
_TEXT	SEGMENT
_py_tmp$21068 = 48
self$ = 80
bytesio_clear PROC					; COMDAT

; 869  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@bytesio_cl@2:

; 870  :     Py_CLEAR(self->dict);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00016	74 5c		 je	 SHORT $LN1@bytesio_cl@2
  00018	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00025	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  0002c	41 b8 66 03 00
	00		 mov	 r8d, 870		; 00000366H
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MDPHEDOG@bytesio_clear?$AA@
  00040	e8 00 00 00 00	 call	 _PyParallel_Guard
  00045	85 c0		 test	 eax, eax
  00047	75 2b		 jne	 SHORT $LN1@bytesio_cl@2
  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00055	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$21068[rsp], rax
  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0005f	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
  0006a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$21068[rsp]
  0006f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@bytesio_cl@2:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 8f		 jne	 SHORT $LN4@bytesio_cl@2

; 871  :     return 0;

  0007a	33 c0		 xor	 eax, eax

; 872  : }

  0007c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00080	c3		 ret	 0
bytesio_clear ENDP
_TEXT	ENDS
EXTRN	PyBuffer_FillInfo:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesiobuf_getbuffer DD imagerel bytesiobuf_getbuffer
	DD	imagerel bytesiobuf_getbuffer+168
	DD	imagerel $unwind$bytesiobuf_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesiobuf_getbuffer DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesiobuf_getbuffer
_TEXT	SEGMENT
b$ = 48
ret$ = 56
obj$ = 80
view$ = 88
flags$ = 96
bytesiobuf_getbuffer PROC				; COMDAT

; 963  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 964  :     int ret;
; 965  :     bytesio *b = (bytesio *) obj->source;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR obj$[rsp]
  00018	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001c	48 89 44 24 30	 mov	 QWORD PTR b$[rsp], rax

; 966  :     if (view == NULL) {

  00021	48 83 7c 24 58
	00		 cmp	 QWORD PTR view$[rsp], 0
  00027	75 1f		 jne	 SHORT $LN2@bytesiobuf

; 967  :         b->exports++;

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  0002e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00035	48 ff c0	 inc	 rax
  00038	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  0003d	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 968  :         return 0;

  00044	33 c0		 xor	 eax, eax
  00046	eb 5b		 jmp	 SHORT $LN3@bytesiobuf
$LN2@bytesiobuf:

; 969  :     }
; 970  :     ret = PyBuffer_FillInfo(view, (PyObject*)obj, b->buf, b->string_size,
; 971  :                             0, flags);

  00048	8b 44 24 60	 mov	 eax, DWORD PTR flags$[rsp]
  0004c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00050	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  0005d	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00061	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  00066	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0006a	48 8b 54 24 50	 mov	 rdx, QWORD PTR obj$[rsp]
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR view$[rsp]
  00074	e8 00 00 00 00	 call	 PyBuffer_FillInfo
  00079	89 44 24 38	 mov	 DWORD PTR ret$[rsp], eax

; 972  :     if (ret >= 0) {

  0007d	83 7c 24 38 00	 cmp	 DWORD PTR ret$[rsp], 0
  00082	7c 1b		 jl	 SHORT $LN1@bytesiobuf

; 973  :         b->exports++;

  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  00089	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00090	48 ff c0	 inc	 rax
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00098	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax
$LN1@bytesiobuf:

; 974  :     }
; 975  :     return ret;

  0009f	8b 44 24 38	 mov	 eax, DWORD PTR ret$[rsp]
$LN3@bytesiobuf:

; 976  : }

  000a3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a7	c3		 ret	 0
bytesiobuf_getbuffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesiobuf_releasebuffer DD imagerel bytesiobuf_releasebuffer
	DD	imagerel bytesiobuf_releasebuffer+57
	DD	imagerel $unwind$bytesiobuf_releasebuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesiobuf_releasebuffer DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytesiobuf_releasebuffer
_TEXT	SEGMENT
b$ = 0
obj$ = 32
view$ = 40
bytesiobuf_releasebuffer PROC				; COMDAT

; 980  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 981  :     bytesio *b = (bytesio *) obj->source;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR obj$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 89 04 24	 mov	 QWORD PTR b$[rsp], rax

; 982  :     b->exports--;

  0001b	48 8b 04 24	 mov	 rax, QWORD PTR b$[rsp]
  0001f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00026	48 ff c8	 dec	 rax
  00029	48 8b 0c 24	 mov	 rcx, QWORD PTR b$[rsp]
  0002d	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 983  : }

  00034	48 83 c4 18	 add	 rsp, 24
  00038	c3		 ret	 0
bytesiobuf_releasebuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@KBCMCEEL@bytesiobuf_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesiobuf_traverse DD imagerel bytesiobuf_traverse
	DD	imagerel bytesiobuf_traverse+116
	DD	imagerel $unwind$bytesiobuf_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesiobuf_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BE@KBCMCEEL@bytesiobuf_traverse?$AA@
CONST	SEGMENT
??_C@_0BE@KBCMCEEL@bytesiobuf_traverse?$AA@ DB 'bytesiobuf_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesiobuf_traverse
_TEXT	SEGMENT
vret$21190 = 32
self$ = 64
visit$ = 72
arg$ = 80
bytesiobuf_traverse PROC				; COMDAT

; 987  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@bytesiobuf@2:

; 988  :     Py_VISIT(self->source);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@bytesiobuf@2
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 dc 03 00
	00		 mov	 r8d, 988		; 000003dcH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@KBCMCEEL@bytesiobuf_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@bytesiobuf@2:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN2@bytesiobuf@2
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$21190[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$21190[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@bytesiobuf@2
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$21190[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@bytesiobuf@2
$LN1@bytesiobuf@2:
$LN2@bytesiobuf@2:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@bytesiobuf@2

; 989  :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@bytesiobuf@2:

; 990  : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
bytesiobuf_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@BHMJNBMG@bytesiobuf_dealloc?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesiobuf_dealloc DD imagerel bytesiobuf_dealloc
	DD	imagerel bytesiobuf_dealloc+135
	DD	imagerel $unwind$bytesiobuf_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesiobuf_dealloc DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BD@BHMJNBMG@bytesiobuf_dealloc?$AA@
CONST	SEGMENT
??_C@_0BD@BHMJNBMG@bytesiobuf_dealloc?$AA@ DB 'bytesiobuf_dealloc', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytesiobuf_dealloc
_TEXT	SEGMENT
_py_tmp$21202 = 48
self$ = 80
bytesiobuf_dealloc PROC					; COMDAT

; 994  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@bytesiobuf@3:

; 995  :     Py_CLEAR(self->source);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 53		 je	 SHORT $LN1@bytesiobuf@3
  00015	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00022	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  00026	41 b8 e3 03 00
	00		 mov	 r8d, 995		; 000003e3H
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BHMJNBMG@bytesiobuf_dealloc?$AA@
  0003a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003f	85 c0		 test	 eax, eax
  00041	75 25		 jne	 SHORT $LN1@bytesiobuf@3
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00048	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004c	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$21202[rsp], rax
  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00056	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$21202[rsp]
  00063	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@bytesiobuf@3:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 9b		 jne	 SHORT $LN4@bytesiobuf@3

; 996  :     Py_TYPE(self)->tp_free(self);

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00073	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0007c	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 997  : }

  00082	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00086	c3		 ret	 0
bytesiobuf_dealloc ENDP
_TEXT	ENDS
END
