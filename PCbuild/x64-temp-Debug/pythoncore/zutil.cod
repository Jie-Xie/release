; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@	; `string'
PUBLIC	??_C@_0N@DFPGLBGC@buffer?5error?$AA@		; `string'
PUBLIC	??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@	; `string'
PUBLIC	??_C@_0L@HAHMBNLP@data?5error?$AA@		; `string'
PUBLIC	??_C@_0N@MKKNPMJD@stream?5error?$AA@		; `string'
PUBLIC	??_C@_0L@KIJFAKBJ@file?5error?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0L@FNAOCBOG@stream?5end?$AA@		; `string'
PUBLIC	??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@	; `string'
PUBLIC	z_errmsg
CONST	SEGMENT
z_errmsg DQ	FLAT:??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@
	DQ	FLAT:??_C@_0L@FNAOCBOG@stream?5end?$AA@
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	DQ	FLAT:??_C@_0L@KIJFAKBJ@file?5error?$AA@
	DQ	FLAT:??_C@_0N@MKKNPMJD@stream?5error?$AA@
	DQ	FLAT:??_C@_0L@HAHMBNLP@data?5error?$AA@
	DQ	FLAT:??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@
	DQ	FLAT:??_C@_0N@DFPGLBGC@buffer?5error?$AA@
	DQ	FLAT:??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
CONST	ENDS
;	COMDAT ??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@
CONST	SEGMENT
??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@ DB 'incompatible version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DFPGLBGC@buffer?5error?$AA@
CONST	SEGMENT
??_C@_0N@DFPGLBGC@buffer?5error?$AA@ DB 'buffer error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@
CONST	SEGMENT
??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@ DB 'insufficient memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HAHMBNLP@data?5error?$AA@
CONST	SEGMENT
??_C@_0L@HAHMBNLP@data?5error?$AA@ DB 'data error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MKKNPMJD@stream?5error?$AA@
CONST	SEGMENT
??_C@_0N@MKKNPMJD@stream?5error?$AA@ DB 'stream error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KIJFAKBJ@file?5error?$AA@
CONST	SEGMENT
??_C@_0L@KIJFAKBJ@file?5error?$AA@ DB 'file error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FNAOCBOG@stream?5end?$AA@
CONST	SEGMENT
??_C@_0L@FNAOCBOG@stream?5end?$AA@ DB 'stream end', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@
CONST	SEGMENT
??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@ DB 'need dictionary', 00H ; `string'
CONST	ENDS
PUBLIC	??_C@_05DFCKICEH@1?42?45?$AA@			; `string'
PUBLIC	zlibVersion
;	COMDAT ??_C@_05DFCKICEH@1?42?45?$AA@
; File c:\src\pyparallel\modules\zlib\zutil.c
CONST	SEGMENT
??_C@_05DFCKICEH@1?42?45?$AA@ DB '1.2.5', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT zlibVersion
_TEXT	SEGMENT
zlibVersion PROC					; COMDAT

; 29   :     return ZLIB_VERSION;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05DFCKICEH@1?42?45?$AA@

; 30   : }

  00007	c3		 ret	 0
zlibVersion ENDP
_TEXT	ENDS
PUBLIC	zlibCompileFlags
;	COMDAT pdata
pdata	SEGMENT
$pdata$zlibCompileFlags DD imagerel $LN27
	DD	imagerel $LN27+278
	DD	imagerel $unwind$zlibCompileFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zlibCompileFlags DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT zlibCompileFlags
_TEXT	SEGMENT
flags$ = 0
tv64 = 4
tv71 = 8
tv78 = 12
tv85 = 16
zlibCompileFlags PROC					; COMDAT

; 33   : {

$LN27:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 34   :     uLong flags;
; 35   : 
; 36   :     flags = 0;

  00004	c7 04 24 00 00
	00 00		 mov	 DWORD PTR flags$[rsp], 0

; 37   :     switch ((int)(sizeof(uInt))) {

  0000b	c7 44 24 04 04
	00 00 00	 mov	 DWORD PTR tv64[rsp], 4
  00013	83 7c 24 04 02	 cmp	 DWORD PTR tv64[rsp], 2
  00018	74 10		 je	 SHORT $LN22@zlibCompil
  0001a	83 7c 24 04 04	 cmp	 DWORD PTR tv64[rsp], 4
  0001f	74 0b		 je	 SHORT $LN21@zlibCompil
  00021	83 7c 24 04 08	 cmp	 DWORD PTR tv64[rsp], 8
  00026	74 0e		 je	 SHORT $LN20@zlibCompil
  00028	eb 17		 jmp	 SHORT $LN19@zlibCompil
$LN22@zlibCompil:

; 38   :     case 2:     break;

  0002a	eb 1e		 jmp	 SHORT $LN23@zlibCompil
$LN21@zlibCompil:

; 39   :     case 4:     flags += 1;     break;

  0002c	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  0002f	ff c0		 inc	 eax
  00031	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
  00034	eb 14		 jmp	 SHORT $LN23@zlibCompil
$LN20@zlibCompil:

; 40   :     case 8:     flags += 2;     break;

  00036	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  00039	83 c0 02	 add	 eax, 2
  0003c	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
  0003f	eb 09		 jmp	 SHORT $LN23@zlibCompil
$LN19@zlibCompil:

; 41   :     default:    flags += 3;

  00041	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  00044	83 c0 03	 add	 eax, 3
  00047	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
$LN23@zlibCompil:

; 42   :     }
; 43   :     switch ((int)(sizeof(uLong))) {

  0004a	c7 44 24 08 04
	00 00 00	 mov	 DWORD PTR tv71[rsp], 4
  00052	83 7c 24 08 02	 cmp	 DWORD PTR tv71[rsp], 2
  00057	74 10		 je	 SHORT $LN16@zlibCompil
  00059	83 7c 24 08 04	 cmp	 DWORD PTR tv71[rsp], 4
  0005e	74 0b		 je	 SHORT $LN15@zlibCompil
  00060	83 7c 24 08 08	 cmp	 DWORD PTR tv71[rsp], 8
  00065	74 0f		 je	 SHORT $LN14@zlibCompil
  00067	eb 18		 jmp	 SHORT $LN13@zlibCompil
$LN16@zlibCompil:

; 44   :     case 2:     break;

  00069	eb 1f		 jmp	 SHORT $LN17@zlibCompil
$LN15@zlibCompil:

; 45   :     case 4:     flags += 1 << 2;        break;

  0006b	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  0006e	83 c0 04	 add	 eax, 4
  00071	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
  00074	eb 14		 jmp	 SHORT $LN17@zlibCompil
$LN14@zlibCompil:

; 46   :     case 8:     flags += 2 << 2;        break;

  00076	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  00079	83 c0 08	 add	 eax, 8
  0007c	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
  0007f	eb 09		 jmp	 SHORT $LN17@zlibCompil
$LN13@zlibCompil:

; 47   :     default:    flags += 3 << 2;

  00081	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  00084	83 c0 0c	 add	 eax, 12
  00087	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
$LN17@zlibCompil:

; 48   :     }
; 49   :     switch ((int)(sizeof(voidpf))) {

  0008a	c7 44 24 0c 08
	00 00 00	 mov	 DWORD PTR tv78[rsp], 8
  00092	83 7c 24 0c 02	 cmp	 DWORD PTR tv78[rsp], 2
  00097	74 10		 je	 SHORT $LN10@zlibCompil
  00099	83 7c 24 0c 04	 cmp	 DWORD PTR tv78[rsp], 4
  0009e	74 0b		 je	 SHORT $LN9@zlibCompil
  000a0	83 7c 24 0c 08	 cmp	 DWORD PTR tv78[rsp], 8
  000a5	74 0f		 je	 SHORT $LN8@zlibCompil
  000a7	eb 18		 jmp	 SHORT $LN7@zlibCompil
$LN10@zlibCompil:

; 50   :     case 2:     break;

  000a9	eb 1f		 jmp	 SHORT $LN11@zlibCompil
$LN9@zlibCompil:

; 51   :     case 4:     flags += 1 << 4;        break;

  000ab	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  000ae	83 c0 10	 add	 eax, 16
  000b1	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
  000b4	eb 14		 jmp	 SHORT $LN11@zlibCompil
$LN8@zlibCompil:

; 52   :     case 8:     flags += 2 << 4;        break;

  000b6	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  000b9	83 c0 20	 add	 eax, 32			; 00000020H
  000bc	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
  000bf	eb 09		 jmp	 SHORT $LN11@zlibCompil
$LN7@zlibCompil:

; 53   :     default:    flags += 3 << 4;

  000c1	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  000c4	83 c0 30	 add	 eax, 48			; 00000030H
  000c7	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
$LN11@zlibCompil:

; 54   :     }
; 55   :     switch ((int)(sizeof(z_off_t))) {

  000ca	c7 44 24 10 04
	00 00 00	 mov	 DWORD PTR tv85[rsp], 4
  000d2	83 7c 24 10 02	 cmp	 DWORD PTR tv85[rsp], 2
  000d7	74 10		 je	 SHORT $LN4@zlibCompil
  000d9	83 7c 24 10 04	 cmp	 DWORD PTR tv85[rsp], 4
  000de	74 0b		 je	 SHORT $LN3@zlibCompil
  000e0	83 7c 24 10 08	 cmp	 DWORD PTR tv85[rsp], 8
  000e5	74 0f		 je	 SHORT $LN2@zlibCompil
  000e7	eb 1a		 jmp	 SHORT $LN1@zlibCompil
$LN4@zlibCompil:

; 56   :     case 2:     break;

  000e9	eb 23		 jmp	 SHORT $LN5@zlibCompil
$LN3@zlibCompil:

; 57   :     case 4:     flags += 1 << 6;        break;

  000eb	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  000ee	83 c0 40	 add	 eax, 64			; 00000040H
  000f1	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
  000f4	eb 18		 jmp	 SHORT $LN5@zlibCompil
$LN2@zlibCompil:

; 58   :     case 8:     flags += 2 << 6;        break;

  000f6	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  000f9	05 80 00 00 00	 add	 eax, 128		; 00000080H
  000fe	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
  00101	eb 0b		 jmp	 SHORT $LN5@zlibCompil
$LN1@zlibCompil:

; 59   :     default:    flags += 3 << 6;

  00103	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]
  00106	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  0010b	89 04 24	 mov	 DWORD PTR flags$[rsp], eax
$LN5@zlibCompil:

; 60   :     }
; 61   : #ifdef DEBUG
; 62   :     flags += 1 << 8;
; 63   : #endif
; 64   : #if defined(ASMV) || defined(ASMINF)
; 65   :     flags += 1 << 9;
; 66   : #endif
; 67   : #ifdef ZLIB_WINAPI
; 68   :     flags += 1 << 10;
; 69   : #endif
; 70   : #ifdef BUILDFIXED
; 71   :     flags += 1 << 12;
; 72   : #endif
; 73   : #ifdef DYNAMIC_CRC_TABLE
; 74   :     flags += 1 << 13;
; 75   : #endif
; 76   : #ifdef NO_GZCOMPRESS
; 77   :     flags += 1L << 16;
; 78   : #endif
; 79   : #ifdef NO_GZIP
; 80   :     flags += 1L << 17;
; 81   : #endif
; 82   : #ifdef PKZIP_BUG_WORKAROUND
; 83   :     flags += 1L << 20;
; 84   : #endif
; 85   : #ifdef FASTEST
; 86   :     flags += 1L << 21;
; 87   : #endif
; 88   : #ifdef STDC
; 89   : #  ifdef NO_vsnprintf
; 90   :         flags += 1L << 25;
; 91   : #    ifdef HAS_vsprintf_void
; 92   :         flags += 1L << 26;
; 93   : #    endif
; 94   : #  else
; 95   : #    ifdef HAS_vsnprintf_void
; 96   :         flags += 1L << 26;
; 97   : #    endif
; 98   : #  endif
; 99   : #else
; 100  :         flags += 1L << 24;
; 101  : #  ifdef NO_snprintf
; 102  :         flags += 1L << 25;
; 103  : #    ifdef HAS_sprintf_void
; 104  :         flags += 1L << 26;
; 105  : #    endif
; 106  : #  else
; 107  : #    ifdef HAS_snprintf_void
; 108  :         flags += 1L << 26;
; 109  : #    endif
; 110  : #  endif
; 111  : #endif
; 112  :     return flags;

  0010e	8b 04 24	 mov	 eax, DWORD PTR flags$[rsp]

; 113  : }

  00111	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00115	c3		 ret	 0
zlibCompileFlags ENDP
_TEXT	ENDS
PUBLIC	zError
; Function compile flags: /Odtp
;	COMDAT zError
_TEXT	SEGMENT
err$ = 8
zError	PROC						; COMDAT

; 135  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 136  :     return ERR_MSG(err);

  00004	b8 02 00 00 00	 mov	 eax, 2
  00009	2b 44 24 08	 sub	 eax, DWORD PTR err$[rsp]
  0000d	48 98		 cdqe
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z_errmsg
  00016	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 137  : }

  0001a	c3		 ret	 0
zError	ENDP
_TEXT	ENDS
PUBLIC	zcalloc
EXTRN	__imp_malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$zcalloc DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$zcalloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zcalloc DD 011201H
	DD	04212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT zcalloc
_TEXT	SEGMENT
opaque$ = 48
items$ = 56
size$ = 64
zcalloc	PROC						; COMDAT

; 304  : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 305  :     if (opaque) items += size - size; /* make compiler happy */

  00012	48 83 7c 24 30
	00		 cmp	 QWORD PTR opaque$[rsp], 0
  00018	74 18		 je	 SHORT $LN1@zcalloc
  0001a	8b 44 24 40	 mov	 eax, DWORD PTR size$[rsp]
  0001e	8b 4c 24 40	 mov	 ecx, DWORD PTR size$[rsp]
  00022	2b c8		 sub	 ecx, eax
  00024	8b c1		 mov	 eax, ecx
  00026	8b 4c 24 38	 mov	 ecx, DWORD PTR items$[rsp]
  0002a	03 c8		 add	 ecx, eax
  0002c	8b c1		 mov	 eax, ecx
  0002e	89 44 24 38	 mov	 DWORD PTR items$[rsp], eax
$LN1@zcalloc:

; 306  :     return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
; 307  :                               (voidpf)calloc(items, size);

  00032	8b 44 24 38	 mov	 eax, DWORD PTR items$[rsp]
  00036	0f af 44 24 40	 imul	 eax, DWORD PTR size$[rsp]
  0003b	8b c0		 mov	 eax, eax
  0003d	8b c8		 mov	 ecx, eax
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 308  : }

  00045	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00049	c3		 ret	 0
zcalloc	ENDP
_TEXT	ENDS
PUBLIC	zcfree
EXTRN	__imp_free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$zcfree DD imagerel $LN4
	DD	imagerel $LN4+30
	DD	imagerel $unwind$zcfree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zcfree DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT zcfree
_TEXT	SEGMENT
opaque$ = 48
ptr$ = 56
zcfree	PROC						; COMDAT

; 313  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 314  :     free(ptr);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$[rsp]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 315  :     if (opaque) return; /* make compiler happy */
; 316  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
zcfree	ENDP
_TEXT	ENDS
END
