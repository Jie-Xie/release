; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07LOLKJPHM@_pickle?$AA@			; `string'
PUBLIC	??_C@_05OCDPKIEO@loads?$AA@			; `string'
PUBLIC	??_C@_05HFMFBBBE@dumps?$AA@			; `string'
PUBLIC	??_C@_05DFJCHPDH@input?$AA@			; `string'
PUBLIC	??_C@_03GJLPFLNF@obj?$AA@			; `string'
PUBLIC	??_C@_0BC@CBEKFMIK@_pickle?4Unpickler?$AA@	; `string'
PUBLIC	??_C@_0BL@NOBPPGDL@_pickle?4UnpicklerMemoProxy?$AA@ ; `string'
PUBLIC	??_C@_0BA@NNFEJGCF@persistent_load?$AA@		; `string'
PUBLIC	??_C@_06EOMHCNPI@errors?$AA@			; `string'
PUBLIC	??_C@_08MLPGAEIK@encoding?$AA@			; `string'
PUBLIC	??_C@_04EONOHKEP@load?$AA@			; `string'
PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_06PCICMFGG@append?$AA@			; `string'
PUBLIC	??_C@_07MEBHOIG@__new__?$AA@			; `string'
PUBLIC	??_C@_0BA@NHLJJDN@__getinitargs__?$AA@		; `string'
PUBLIC	??_C@_0L@BHOLNLBJ@find_class?$AA@		; `string'
PUBLIC	??_C@_0BA@LFIFMGAB@_pickle?4Pickler?$AA@	; `string'
PUBLIC	??_C@_04PGONJDDE@memo?$AA@			; `string'
PUBLIC	??_C@_04LBNBHAJC@fast?$AA@			; `string'
PUBLIC	??_C@_03PDOMKJON@bin?$AA@			; `string'
PUBLIC	??_C@_0BJ@DIPNHLKH@_pickle?4PicklerMemoProxy?$AA@ ; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_05MEHLAELG@clear?$AA@			; `string'
PUBLIC	??_C@_0P@MAJNENGA@dispatch_table?$AA@		; `string'
PUBLIC	??_C@_0O@IGFLDCPG@persistent_id?$AA@		; `string'
PUBLIC	??_C@_0M@IDPAOKEI@fix_imports?$AA@		; `string'
PUBLIC	??_C@_08FCFPNNHF@protocol?$AA@			; `string'
PUBLIC	??_C@_04DAMGJPCA@file?$AA@			; `string'
PUBLIC	??_C@_0L@NFDPNOOM@clear_memo?$AA@		; `string'
PUBLIC	??_C@_04GGLOKIEE@dump?$AA@			; `string'
PUBLIC	??_C@_05CFHBDDLG@items?$AA@			; `string'
PUBLIC	??_C@_04EDFDKNFG@I01?6?$AA@			; `string'
PUBLIC	??_C@_04ECJBMHGB@I00?6?$AA@			; `string'
PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_04EOCFELL@peek?$AA@			; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_0O@MBIDJBCI@_pickle?4Pdata?$AA@		; `string'
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyType_GenericNew:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericSetAttr:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyObject_HashNotImplemented:PROC
_BSS	SEGMENT
PickleError DQ	01H DUP (?)
PicklingError DQ 01H DUP (?)
UnpicklingError DQ 01H DUP (?)
dispatch_table DQ 01H DUP (?)
extension_registry DQ 01H DUP (?)
inverted_registry DQ 01H DUP (?)
extension_cache DQ 01H DUP (?)
name_mapping_2to3 DQ 01H DUP (?)
import_mapping_2to3 DQ 01H DUP (?)
name_mapping_3to2 DQ 01H DUP (?)
import_mapping_3to2 DQ 01H DUP (?)
empty_tuple DQ	01H DUP (?)
two_tuple DQ	01H DUP (?)
?module_str@?1??whichmodule@@9@9 DQ 01H DUP (?)		; `whichmodule'::`2'::module_str
?main_str@?1??whichmodule@@9@9 DQ 01H DUP (?)		; `whichmodule'::`2'::main_str
?codecs_encode@?2??save_bytes@@9@9 DQ 01H DUP (?)	; `save_bytes'::`3'::codecs_encode
?latin1@?7??save_bytes@@9@9 DQ 01H DUP (?)		; `save_bytes'::`8'::latin1
?name_str@?1??save_global@@9@9 DQ 01H DUP (?)		; `save_global'::`2'::name_str
?newobj_str@?7??save_reduce@@9@9 DQ 01H DUP (?)		; `save_reduce'::`8'::newobj_str
?name_str@?7??save_reduce@@9@9 DQ 01H DUP (?)		; `save_reduce'::`8'::name_str
?reduce_str@?BL@??save@@9@9 DQ 01H DUP (?)		; `save'::`27'::reduce_str
?reduce_ex_str@?BL@??save@@9@9 DQ 01H DUP (?)		; `save'::`27'::reduce_ex_str
_BSS	ENDS
;	COMDAT ??_C@_07LOLKJPHM@_pickle?$AA@
CONST	SEGMENT
??_C@_07LOLKJPHM@_pickle?$AA@ DB '_pickle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OCDPKIEO@loads?$AA@
CONST	SEGMENT
??_C@_05OCDPKIEO@loads?$AA@ DB 'loads', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HFMFBBBE@dumps?$AA@
CONST	SEGMENT
??_C@_05HFMFBBBE@dumps?$AA@ DB 'dumps', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFJCHPDH@input?$AA@
CONST	SEGMENT
??_C@_05DFJCHPDH@input?$AA@ DB 'input', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJLPFLNF@obj?$AA@
CONST	SEGMENT
??_C@_03GJLPFLNF@obj?$AA@ DB 'obj', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CBEKFMIK@_pickle?4Unpickler?$AA@
CONST	SEGMENT
??_C@_0BC@CBEKFMIK@_pickle?4Unpickler?$AA@ DB '_pickle.Unpickler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NOBPPGDL@_pickle?4UnpicklerMemoProxy?$AA@
CONST	SEGMENT
??_C@_0BL@NOBPPGDL@_pickle?4UnpicklerMemoProxy?$AA@ DB '_pickle.Unpickler'
	DB	'MemoProxy', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNFEJGCF@persistent_load?$AA@
CONST	SEGMENT
??_C@_0BA@NNFEJGCF@persistent_load?$AA@ DB 'persistent_load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOMHCNPI@errors?$AA@
CONST	SEGMENT
??_C@_06EOMHCNPI@errors?$AA@ DB 'errors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPGAEIK@encoding?$AA@
CONST	SEGMENT
??_C@_08MLPGAEIK@encoding?$AA@ DB 'encoding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EONOHKEP@load?$AA@
CONST	SEGMENT
??_C@_04EONOHKEP@load?$AA@ DB 'load', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCICMFGG@append?$AA@
CONST	SEGMENT
??_C@_06PCICMFGG@append?$AA@ DB 'append', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEBHOIG@__new__?$AA@
CONST	SEGMENT
??_C@_07MEBHOIG@__new__?$AA@ DB '__new__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHLJJDN@__getinitargs__?$AA@
CONST	SEGMENT
??_C@_0BA@NHLJJDN@__getinitargs__?$AA@ DB '__getinitargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BHOLNLBJ@find_class?$AA@
CONST	SEGMENT
??_C@_0L@BHOLNLBJ@find_class?$AA@ DB 'find_class', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LFIFMGAB@_pickle?4Pickler?$AA@
CONST	SEGMENT
??_C@_0BA@LFIFMGAB@_pickle?4Pickler?$AA@ DB '_pickle.Pickler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGONJDDE@memo?$AA@
CONST	SEGMENT
??_C@_04PGONJDDE@memo?$AA@ DB 'memo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBNBHAJC@fast?$AA@
CONST	SEGMENT
??_C@_04LBNBHAJC@fast?$AA@ DB 'fast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PDOMKJON@bin?$AA@
CONST	SEGMENT
??_C@_03PDOMKJON@bin?$AA@ DB 'bin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DIPNHLKH@_pickle?4PicklerMemoProxy?$AA@
CONST	SEGMENT
??_C@_0BJ@DIPNHLKH@_pickle?4PicklerMemoProxy?$AA@ DB '_pickle.PicklerMemo'
	DB	'Proxy', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEHLAELG@clear?$AA@
CONST	SEGMENT
??_C@_05MEHLAELG@clear?$AA@ DB 'clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MAJNENGA@dispatch_table?$AA@
CONST	SEGMENT
??_C@_0P@MAJNENGA@dispatch_table?$AA@ DB 'dispatch_table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IGFLDCPG@persistent_id?$AA@
CONST	SEGMENT
??_C@_0O@IGFLDCPG@persistent_id?$AA@ DB 'persistent_id', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IDPAOKEI@fix_imports?$AA@
CONST	SEGMENT
??_C@_0M@IDPAOKEI@fix_imports?$AA@ DB 'fix_imports', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FCFPNNHF@protocol?$AA@
CONST	SEGMENT
??_C@_08FCFPNNHF@protocol?$AA@ DB 'protocol', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAMGJPCA@file?$AA@
CONST	SEGMENT
??_C@_04DAMGJPCA@file?$AA@ DB 'file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NFDPNOOM@clear_memo?$AA@
CONST	SEGMENT
??_C@_0L@NFDPNOOM@clear_memo?$AA@ DB 'clear_memo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGLOKIEE@dump?$AA@
CONST	SEGMENT
??_C@_04GGLOKIEE@dump?$AA@ DB 'dump', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFHBDDLG@items?$AA@
CONST	SEGMENT
??_C@_05CFHBDDLG@items?$AA@ DB 'items', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDFDKNFG@I01?6?$AA@
CONST	SEGMENT
??_C@_04EDFDKNFG@I01?6?$AA@ DB 'I01', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ECJBMHGB@I00?6?$AA@
CONST	SEGMENT
??_C@_04ECJBMHGB@I00?6?$AA@ DB 'I00', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EOCFELL@peek?$AA@
CONST	SEGMENT
??_C@_04EOCFELL@peek?$AA@ DB 'peek', 00H		; `string'
CONST	ENDS
CONST	SEGMENT
READ_WHOLE_LINE DQ ffffffffffffffffH
CONST	ENDS
_TLS	SEGMENT
?PyId_persistent_load@?1??Unpickler_init@@9@9 DQ 0000000000000000H ; `Unpickler_init'::`2'::PyId_persistent_load
	DQ	FLAT:??_C@_0BA@NNFEJGCF@persistent_load?$AA@
	DQ	0000000000000000H
?PyId___dict__@?7??load_build@@9@9 DQ 0000000000000000H	; `load_build'::`8'::PyId___dict__
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
?PyId___setstate__@?1??load_build@@9@9 DQ 0000000000000000H ; `load_build'::`2'::PyId___setstate__
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	0000000000000000H
?PyId_append@?3??do_append@@9@9 DQ 0000000000000000H	; `do_append'::`4'::PyId_append
	DQ	FLAT:??_C@_06PCICMFGG@append?$AA@
	DQ	0000000000000000H
?PyId___new__@?3??instantiate@@9@9 DQ 0000000000000000H	; `instantiate'::`4'::PyId___new__
	DQ	FLAT:??_C@_07MEBHOIG@__new__?$AA@
	DQ	0000000000000000H
?PyId___getinitargs__@?1??instantiate@@9@9 DQ 0000000000000000H ; `instantiate'::`2'::PyId___getinitargs__
	DQ	FLAT:??_C@_0BA@NHLJJDN@__getinitargs__?$AA@
	DQ	0000000000000000H
?PyId_find_class@?1??find_class@@9@9 DQ 0000000000000000H ; `find_class'::`2'::PyId_find_class
	DQ	FLAT:??_C@_0L@BHOLNLBJ@find_class?$AA@
	DQ	0000000000000000H
?PyId_dispatch_table@?1??Pickler_init@@9@9 DQ 0000000000000000H ; `Pickler_init'::`2'::PyId_dispatch_table
	DQ	FLAT:??_C@_0P@MAJNENGA@dispatch_table?$AA@
	DQ	0000000000000000H
?PyId_persistent_id@?1??Pickler_init@@9@9 DQ 0000000000000000H ; `Pickler_init'::`2'::PyId_persistent_id
	DQ	FLAT:??_C@_0O@IGFLDCPG@persistent_id?$AA@
	DQ	0000000000000000H
?PyId_items@?7??save_dict@@9@9 DQ 0000000000000000H	; `save_dict'::`8'::PyId_items
	DQ	FLAT:??_C@_05CFHBDDLG@items?$AA@
	DQ	0000000000000000H
?PyId_readline@?1??_Unpickler_SetInputStream@@9@9 DQ 0000000000000000H ; `_Unpickler_SetInputStream'::`2'::PyId_readline
	DQ	FLAT:??_C@_08KBCDPPMN@readline?$AA@
	DQ	0000000000000000H
?PyId_read@?1??_Unpickler_SetInputStream@@9@9 DQ 0000000000000000H ; `_Unpickler_SetInputStream'::`2'::PyId_read
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	0000000000000000H
?PyId_peek@?1??_Unpickler_SetInputStream@@9@9 DQ 0000000000000000H ; `_Unpickler_SetInputStream'::`2'::PyId_peek
	DQ	FLAT:??_C@_04EOCFELL@peek?$AA@
	DQ	0000000000000000H
?PyId_write@?1??_Pickler_SetOutputStream@@9@9 DQ 0000000000000000H ; `_Pickler_SetOutputStream'::`2'::PyId_write
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MBIDJBCI@_pickle?4Pdata?$AA@
CONST	SEGMENT
??_C@_0O@MBIDJBCI@_pickle?4Pdata?$AA@ DB '_pickle.Pdata', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
pickle_module_doc DB 'Optimized C implementation for the Python pickle mo'
	DB	'dule.', 00H
	ORG $+7
Pdata_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@MBIDJBCI@_pickle?4Pdata?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:Pdata_dealloc
	ORG $+336
?buf@?1??save_bool@@9@9 DQ FLAT:??_C@_04ECJBMHGB@I00?6?$AA@ ; `save_bool'::`2'::buf
	DQ	FLAT:??_C@_04EDFDKNFG@I01?6?$AA@
Pickler_clear_memo_doc DB 'clear_memo() -> None. Clears the pickler''s "m'
	DB	'emo".', 0aH, 'The memo is the data structure that remembers w'
	DB	'hich objects the', 0aH, 'pickler has already seen, so that sh'
	DB	'ared or recursive objects are', 0aH, 'pickled by reference an'
	DB	'd not by value.  This method is useful when', 0aH, 're-using '
	DB	'picklers.', 00H
	ORG $+5
Pickler_dump_doc DB 'dump(obj) -> None. Write a pickled representation of'
	DB	' obj to the open file.', 00H
	ORG $+5
Pickler_methods DQ FLAT:??_C@_04GGLOKIEE@dump?$AA@
	DQ	FLAT:Pickler_dump
	DD	01H
	ORG $+4
	DQ	FLAT:Pickler_dump_doc
	DQ	FLAT:??_C@_0L@NFDPNOOM@clear_memo?$AA@
	DQ	FLAT:Pickler_clear_memo
	DD	04H
	ORG $+4
	DQ	FLAT:Pickler_clear_memo_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
Pickler_doc DB	'Pickler(file, protocol=None)', 0aH, 'This takes a binary'
	DB	' file for writing a pickle data stream.', 0aH, 0aH, 'The opti'
	DB	'onal protocol argument tells the pickler to use the', 0aH, 'g'
	DB	'iven protocol; supported protocols are 0, 1, 2, 3.  The defau'
	DB	'lt', 0aH, 'protocol is 3; a backward-incompatible protocol de'
	DB	'signed for', 0aH, 'Python 3.0.', 0aH, 0aH, 'Specifying a nega'
	DB	'tive protocol version selects the highest', 0aH, 'protocol ve'
	DB	'rsion supported.  The higher the protocol used, the', 0aH, 'm'
	DB	'ore recent the version of Python needed to read the pickle', 0aH
	DB	'produced.', 0aH, 0aH, 'The file argument must have a write() '
	DB	'method that accepts a single', 0aH, 'bytes argument. It can t'
	DB	'hus be a file object opened for binary', 0aH, 'writing, a io.'
	DB	'BytesIO instance, or any other custom object that', 0aH, 'mee'
	DB	'ts this interface.', 0aH, 0aH, 'If fix_imports is True and pr'
	DB	'otocol is less than 3, pickle will try to', 0aH, 'map the new'
	DB	' Python 3.x names to the old module names used in Python', 0aH
	DB	'2.x, so that the pickle data stream is readable with Python 2'
	DB	'.x.', 0aH, 00H
	ORG $+1
?kwlist@?1??Pickler_init@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `Pickler_init'::`2'::kwlist
	DQ	FLAT:??_C@_08FCFPNNHF@protocol?$AA@
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	0000000000000000H
pmp_clear_doc DB 'memo.clear() -> None.  Remove all items from memo.', 00H
	ORG $+5
pmp_copy_doc DB	'memo.copy() -> new_memo.  Copy the memo to a new object.'
	DB	00H
	ORG $+7
pmp_reduce_doc DB 'memo.__reduce__(). Pickling support.', 00H
	ORG $+11
picklerproxy_methods DQ FLAT:??_C@_05MEHLAELG@clear?$AA@
	DQ	FLAT:pmp_clear
	DD	04H
	ORG $+4
	DQ	FLAT:pmp_clear_doc
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:pmp_copy
	DD	04H
	ORG $+4
	DQ	FLAT:pmp_copy_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:pmp_reduce
	DD	01H
	ORG $+4
	DQ	FLAT:pmp_reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PicklerMemoProxyType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BJ@DIPNHLKH@_pickle?4PicklerMemoProxy?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:PicklerMemoProxy_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_HashNotImplemented
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	FLAT:PyObject_GenericSetAttr
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:PicklerMemoProxy_traverse
	DQ	FLAT:PicklerMemoProxy_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:picklerproxy_methods
	ORG $+152
Pickler_members DQ FLAT:??_C@_03PDOMKJON@bin?$AA@
	DD	01H
	ORG $+4
	DQ	00000000000000a4H
	ORG $+16
	DQ	FLAT:??_C@_04LBNBHAJC@fast?$AA@
	DD	01H
	ORG $+4
	DQ	00000000000000b0H
	ORG $+16
	DQ	FLAT:??_C@_0P@MAJNENGA@dispatch_table?$AA@
	DD	010H
	ORG $+4
	DQ	0000000000000070H
	ORG $+16
	DQ	0000000000000000H
	ORG $+32
Pickler_getsets DQ FLAT:??_C@_04PGONJDDE@memo?$AA@
	DQ	FLAT:Pickler_get_memo
	DQ	FLAT:Pickler_set_memo
	ORG $+16
	DQ	FLAT:??_C@_0O@IGFLDCPG@persistent_id?$AA@
	DQ	FLAT:Pickler_get_persid
	DQ	FLAT:Pickler_set_persid
	ORG $+16
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
Pickler_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BA@LFIFMGAB@_pickle?4Pickler?$AA@
	DQ	00000000000000d0H
	DQ	0000000000000000H
	DQ	FLAT:Pickler_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:Pickler_doc
	DQ	FLAT:Pickler_traverse
	DQ	FLAT:Pickler_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:Pickler_methods
	DQ	FLAT:Pickler_members
	DQ	FLAT:Pickler_getsets
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:Pickler_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:PyType_GenericNew
	DQ	FLAT:PyObject_GC_Del
	DQ	0000000000000000H
	ORG $+56
Unpickler_load_doc DB 'load() -> object. Load a pickle.', 0aH, 'Read a pi'
	DB	'ckled object representation from the open file object given i'
	DB	'n', 0aH, 'the constructor, and return the reconstituted objec'
	DB	't hierarchy specified', 0aH, 'therein.', 0aH, 00H
	ORG $+4
Unpickler_find_class_doc DB 'find_class(module_name, global_name) -> obje'
	DB	'ct.', 0aH, 0aH, 'Return an object from a specified module, im'
	DB	'porting the module if', 0aH, 'necessary.  Subclasses may over'
	DB	'ride this method (e.g. to restrict', 0aH, 'unpickling of arbi'
	DB	'trary classes and functions).', 0aH, 0aH, 'This method is cal'
	DB	'led whenever a class or a function object is', 0aH, 'needed. '
	DB	' Both arguments passed are str objects.', 0aH, 00H
	ORG $+10
Unpickler_methods DQ FLAT:??_C@_04EONOHKEP@load?$AA@
	DQ	FLAT:Unpickler_load
	DD	04H
	ORG $+4
	DQ	FLAT:Unpickler_load_doc
	DQ	FLAT:??_C@_0L@BHOLNLBJ@find_class?$AA@
	DQ	FLAT:Unpickler_find_class
	DD	01H
	ORG $+4
	DQ	FLAT:Unpickler_find_class_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
Unpickler_doc DB 'Unpickler(file, *, encoding=''ASCII'', errors=''strict'''
	DB	')', 0aH, 'This takes a binary file for reading a pickle data '
	DB	'stream.', 0aH, 0aH, 'The protocol version of the pickle is de'
	DB	'tected automatically, so no', 0aH, 'proto argument is needed.'
	DB	0aH, 0aH, 'The file-like object must have two methods, a read('
	DB	') method', 0aH, 'that takes an integer argument, and a readli'
	DB	'ne() method that', 0aH, 'requires no arguments.  Both methods'
	DB	' should return bytes.', 0aH, 'Thus file-like object can be a '
	DB	'binary file object opened for', 0aH, 'reading, a BytesIO obje'
	DB	'ct, or any other custom object that', 0aH, 'meets this interf'
	DB	'ace.', 0aH, 0aH, 'Optional keyword arguments are *fix_imports'
	DB	'*, *encoding* and *errors*,', 0aH, 'which are used to control'
	DB	' compatiblity support for pickle stream', 0aH, 'generated by '
	DB	'Python 2.x.  If *fix_imports* is True, pickle will try to', 0aH
	DB	'map the old Python 2.x names to the new names used in Python '
	DB	'3.x.  The', 0aH, '*encoding* and *errors* tell pickle how to '
	DB	'decode 8-bit string', 0aH, 'instances pickled by Python 2.x; '
	DB	'these default to ''ASCII'' and', 0aH, '''strict'', respective'
	DB	'ly.', 0aH, 00H
	ORG $+1
?kwlist@?1??Unpickler_init@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `Unpickler_init'::`2'::kwlist
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
ump_clear_doc DB 'memo.clear() -> None.  Remove all items from memo.', 00H
	ORG $+5
ump_copy_doc DB	'memo.copy() -> new_memo.  Copy the memo to a new object.'
	DB	00H
	ORG $+7
ump_reduce_doc DB 'memo.__reduce__(). Pickling support.', 00H
	ORG $+11
unpicklerproxy_methods DQ FLAT:??_C@_05MEHLAELG@clear?$AA@
	DQ	FLAT:ump_clear
	DD	04H
	ORG $+4
	DQ	FLAT:ump_clear_doc
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:ump_copy
	DD	04H
	ORG $+4
	DQ	FLAT:ump_copy_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:ump_reduce
	DD	01H
	ORG $+4
	DQ	FLAT:ump_reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
UnpicklerMemoProxyType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BL@NOBPPGDL@_pickle?4UnpicklerMemoProxy?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:UnpicklerMemoProxy_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_HashNotImplemented
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	FLAT:PyObject_GenericSetAttr
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:UnpicklerMemoProxy_traverse
	DQ	FLAT:UnpicklerMemoProxy_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:unpicklerproxy_methods
	ORG $+152
Unpickler_getsets DQ FLAT:??_C@_04PGONJDDE@memo?$AA@
	DQ	FLAT:Unpickler_get_memo
	DQ	FLAT:Unpickler_set_memo
	ORG $+16
	DQ	FLAT:??_C@_0BA@NNFEJGCF@persistent_load?$AA@
	DQ	FLAT:Unpickler_get_persload
	DQ	FLAT:Unpickler_set_persload
	ORG $+16
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
Unpickler_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@CBEKFMIK@_pickle?4Unpickler?$AA@
	DQ	0000000000000150H
	DQ	0000000000000000H
	DQ	FLAT:Unpickler_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:Unpickler_doc
	DQ	FLAT:Unpickler_traverse
	DQ	FLAT:Unpickler_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:Unpickler_methods
	DQ	0000000000000000H
	DQ	FLAT:Unpickler_getsets
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:Unpickler_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:PyType_GenericNew
	DQ	FLAT:PyObject_GC_Del
	DQ	0000000000000000H
	ORG $+56
pickle_dump_doc DB 'dump(obj, file, protocol=None, *, fix_imports=True) -'
	DB	'> None', 0aH, 0aH, 'Write a pickled representation of obj to '
	DB	'the open file object file.  This', 0aH, 'is equivalent to ``P'
	DB	'ickler(file, protocol).dump(obj)``, but may be more', 0aH, 'e'
	DB	'fficient.', 0aH, 0aH, 'The optional protocol argument tells t'
	DB	'he pickler to use the given protocol;', 0aH, 'supported proto'
	DB	'cols are 0, 1, 2, 3.  The default protocol is 3; a', 0aH, 'ba'
	DB	'ckward-incompatible protocol designed for Python 3.0.', 0aH, 0aH
	DB	'Specifying a negative protocol version selects the highest pr'
	DB	'otocol version', 0aH, 'supported.  The higher the protocol us'
	DB	'ed, the more recent the version of', 0aH, 'Python needed to r'
	DB	'ead the pickle produced.', 0aH, 0aH, 'The file argument must '
	DB	'have a write() method that accepts a single bytes', 0aH, 'arg'
	DB	'ument.  It can thus be a file object opened for binary writin'
	DB	'g, a', 0aH, 'io.BytesIO instance, or any other custom object '
	DB	'that meets this interface.', 0aH, 0aH, 'If fix_imports is Tru'
	DB	'e and protocol is less than 3, pickle will try to', 0aH, 'map'
	DB	' the new Python 3.x names to the old module names used in Pyt'
	DB	'hon 2.x,', 0aH, 'so that the pickle data stream is readable w'
	DB	'ith Python 2.x.', 0aH, 00H
	ORG $+6
?kwlist@?1??pickle_dump@@9@9 DQ FLAT:??_C@_03GJLPFLNF@obj?$AA@ ; `pickle_dump'::`2'::kwlist
	DQ	FLAT:??_C@_04DAMGJPCA@file?$AA@
	DQ	FLAT:??_C@_08FCFPNNHF@protocol?$AA@
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	0000000000000000H
	ORG $+8
pickle_dumps_doc DB 'dumps(obj, protocol=None, *, fix_imports=True) -> by'
	DB	'tes', 0aH, 0aH, 'Return the pickled representation of the obj'
	DB	'ect as a bytes', 0aH, 'object, instead of writing it to a fil'
	DB	'e.', 0aH, 0aH, 'The optional protocol argument tells the pick'
	DB	'ler to use the given protocol;', 0aH, 'supported protocols ar'
	DB	'e 0, 1, 2, 3.  The default protocol is 3; a', 0aH, 'backward-'
	DB	'incompatible protocol designed for Python 3.0.', 0aH, 0aH, 'S'
	DB	'pecifying a negative protocol version selects the highest pro'
	DB	'tocol version', 0aH, 'supported.  The higher the protocol use'
	DB	'd, the more recent the version of', 0aH, 'Python needed to re'
	DB	'ad the pickle produced.', 0aH, 0aH, 'If fix_imports is True a'
	DB	'nd *protocol* is less than 3, pickle will try to', 0aH, 'map '
	DB	'the new Python 3.x names to the old module names used in Pyth'
	DB	'on 2.x,', 0aH, 'so that the pickle data stream is readable wi'
	DB	'th Python 2.x.', 0aH, 00H
	ORG $+3
?kwlist@?1??pickle_dumps@@9@9 DQ FLAT:??_C@_03GJLPFLNF@obj?$AA@ ; `pickle_dumps'::`2'::kwlist
	DQ	FLAT:??_C@_08FCFPNNHF@protocol?$AA@
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	0000000000000000H
	ORG $+8
pickle_load_doc DB 'load(file, *, fix_imports=True, encoding=''ASCII'', e'
	DB	'rrors=''strict'') -> object', 0aH, 0aH, 'Read a pickled objec'
	DB	't representation from the open file object file and', 0aH, 'r'
	DB	'eturn the reconstituted object hierarchy specified therein.  '
	DB	'This is', 0aH, 'equivalent to ``Unpickler(file).load()``, but'
	DB	' may be more efficient.', 0aH, 0aH, 'The protocol version of '
	DB	'the pickle is detected automatically, so no protocol', 0aH, 'a'
	DB	'rgument is needed.  Bytes past the pickled object''s represen'
	DB	'tation are', 0aH, 'ignored.', 0aH, 0aH, 'The argument file mu'
	DB	'st have two methods, a read() method that takes an', 0aH, 'in'
	DB	'teger argument, and a readline() method that requires no argu'
	DB	'ments.  Both', 0aH, 'methods should return bytes.  Thus *file'
	DB	'* can be a binary file object opened', 0aH, 'for reading, a B'
	DB	'ytesIO object, or any other custom object that meets this', 0aH
	DB	'interface.', 0aH, 0aH, 'Optional keyword arguments are fix_im'
	DB	'ports, encoding and errors,', 0aH, 'which are used to control'
	DB	' compatiblity support for pickle stream generated', 0aH, 'by '
	DB	'Python 2.x.  If fix_imports is True, pickle will try to map t'
	DB	'he old', 0aH, 'Python 2.x names to the new names used in Pyth'
	DB	'on 3.x.  The encoding and', 0aH, 'errors tell pickle how to d'
	DB	'ecode 8-bit string instances pickled by Python', 0aH, '2.x; t'
	DB	'hese default to ''ASCII'' and ''strict'', respectively.', 0aH
	DB	00H
	ORG $+1
?kwlist@?1??pickle_load@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `pickle_load'::`2'::kwlist
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
pickle_loads_doc DB 'loads(input, *, fix_imports=True, encoding=''ASCII'''
	DB	', errors=''strict'') -> object', 0aH, 0aH, 'Read a pickled ob'
	DB	'ject hierarchy from a bytes object and return the', 0aH, 'rec'
	DB	'onstituted object hierarchy specified therein', 0aH, 0aH, 'Th'
	DB	'e protocol version of the pickle is detected automatically, s'
	DB	'o no protocol', 0aH, 'argument is needed.  Bytes past the pic'
	DB	'kled object''s representation are', 0aH, 'ignored.', 0aH, 0aH
	DB	'Optional keyword arguments are fix_imports, encoding and erro'
	DB	'rs, which', 0aH, 'are used to control compatiblity support fo'
	DB	'r pickle stream generated', 0aH, 'by Python 2.x.  If fix_impo'
	DB	'rts is True, pickle will try to map the old', 0aH, 'Python 2.'
	DB	'x names to the new names used in Python 3.x.  The encoding an'
	DB	'd', 0aH, 'errors tell pickle how to decode 8-bit string insta'
	DB	'nces pickled by Python', 0aH, '2.x; these default to ''ASCII'''
	DB	' and ''strict'', respectively.', 0aH, 00H
	ORG $+4
?kwlist@?1??pickle_loads@@9@9 DQ FLAT:??_C@_05DFJCHPDH@input?$AA@ ; `pickle_loads'::`2'::kwlist
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
pickle_methods DQ FLAT:??_C@_04GGLOKIEE@dump?$AA@
	DQ	FLAT:pickle_dump
	DD	03H
	ORG $+4
	DQ	FLAT:pickle_dump_doc
	DQ	FLAT:??_C@_05HFMFBBBE@dumps?$AA@
	DQ	FLAT:pickle_dumps
	DD	03H
	ORG $+4
	DQ	FLAT:pickle_dumps_doc
	DQ	FLAT:??_C@_04EONOHKEP@load?$AA@
	DQ	FLAT:pickle_load
	DD	03H
	ORG $+4
	DQ	FLAT:pickle_load_doc
	DQ	FLAT:??_C@_05OCDPKIEO@loads?$AA@
	DQ	FLAT:pickle_loads
	DD	03H
	ORG $+4
	DQ	FLAT:pickle_loads_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
_picklemodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07LOLKJPHM@_pickle?$AA@
	DQ	FLAT:pickle_module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:pickle_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	_Py_DecRef
EXTRN	_PyObject_DebugFree:PROC
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_pickle.c
pdata	SEGMENT
$pdata$Pdata_dealloc DD imagerel Pdata_dealloc
	DD	imagerel Pdata_dealloc+139
	DD	imagerel $unwind$Pdata_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_dealloc DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Pdata_dealloc
_TEXT	SEGMENT
i$ = 32
tv77 = 40
self$ = 64
Pdata_dealloc PROC					; COMDAT

; 155  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 156  :     Py_ssize_t i = Py_SIZE(self);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN2@Pdata_deal:

; 157  :     while (--i >= 0) {

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0001c	48 ff c8	 dec	 rax
  0001f	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00024	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0002a	7c 19		 jl	 SHORT $LN1@Pdata_deal

; 158  :         Py_DECREF(self->data[i]);

  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00031	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0003a	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0003e	e8 00 00 00 00	 call	 _Py_DecRef

; 159  :     }

  00043	eb d2		 jmp	 SHORT $LN2@Pdata_deal
$LN1@Pdata_deal:

; 160  :     PyMem_FREE(self->data);

  00045	e8 00 00 00 00	 call	 _Py_PXCTX
  0004a	85 c0		 test	 eax, eax
  0004c	74 18		 je	 SHORT $LN5@Pdata_deal
  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00053	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00057	e8 00 00 00 00	 call	 _PxMem_Free
  0005c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
  00064	eb 16		 jmp	 SHORT $LN6@Pdata_deal
$LN5@Pdata_deal:
  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0006f	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00074	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN6@Pdata_deal:

; 161  :     PyObject_Del(self);

  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00081	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 162  : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
Pdata_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\modules\_pickle.c
pdata	SEGMENT
$pdata$Pickler_clear_memo DD imagerel Pickler_clear_memo
	DD	imagerel Pickler_clear_memo+59
	DD	imagerel $unwind$Pickler_clear_memo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_clear_memo DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Pickler_clear_memo
_TEXT	SEGMENT
self$ = 48
Pickler_clear_memo PROC					; COMDAT

; 3377 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3378 :     if (self->memo)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 0e		 je	 SHORT $LN1@Pickler_cl

; 3379 :         PyMemoTable_Clear(self->memo);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0001e	e8 00 00 00 00	 call	 PyMemoTable_Clear
$LN1@Pickler_cl:

; 3380 : 
; 3381 :     Py_RETURN_NONE;

  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0002a	e8 00 00 00 00	 call	 _Py_IncRef
  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3382 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
Pickler_clear_memo ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_pickle.c
pdata	SEGMENT
$pdata$PyMemoTable_Clear DD imagerel PyMemoTable_Clear
	DD	imagerel PyMemoTable_Clear+156
	DD	imagerel $unwind$PyMemoTable_Clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_Clear DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMemoTable_Clear
_TEXT	SEGMENT
i$ = 32
self$ = 64
PyMemoTable_Clear PROC					; COMDAT

; 458  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 459  :     Py_ssize_t i = self->mt_allocated;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00012	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@PyMemoTabl:

; 460  : 
; 461  :     while (--i >= 0) {

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0001c	48 ff c8	 dec	 rax
  0001f	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00024	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0002a	7c 3c		 jl	 SHORT $LN5@PyMemoTabl
$LN4@PyMemoTabl:

; 462  :         Py_XDECREF(self->mt_table[i].me_key);

  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00031	48 6b c0 10	 imul	 rax, 16
  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0003a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003e	48 83 3c 08 00	 cmp	 QWORD PTR [rax+rcx], 0
  00043	74 1b		 je	 SHORT $LN1@PyMemoTabl
  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0004a	48 6b c0 10	 imul	 rax, 16
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00053	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00057	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0005b	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyMemoTabl:
  00060	33 c0		 xor	 eax, eax
  00062	85 c0		 test	 eax, eax
  00064	75 c6		 jne	 SHORT $LN4@PyMemoTabl

; 463  :     }

  00066	eb af		 jmp	 SHORT $LN6@PyMemoTabl
$LN5@PyMemoTabl:

; 464  :     self->mt_used = 0;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006d	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 465  :     memset(self->mt_table, 0, self->mt_allocated * sizeof(PyMemoEntry));

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0007a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007e	48 6b c0 10	 imul	 rax, 16
  00082	4c 8b c0	 mov	 r8, rax
  00085	33 d2		 xor	 edx, edx
  00087	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0008c	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00090	e8 00 00 00 00	 call	 memset

; 466  :     return 0;

  00095	33 c0		 xor	 eax, eax

; 467  : }

  00097	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009b	c3		 ret	 0
PyMemoTable_Clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_06CKFCKBHM@O?3dump?$AA@			; `string'
PUBLIC	??_C@_0DD@EIOLGLN@Pickler?4__init__?$CI?$CJ?5was?5not?5calle@ ; `string'
EXTRN	PyArg_ParseTuple:PROC
EXTRN	PyErr_Format:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_dump DD imagerel Pickler_dump
	DD	imagerel Pickler_dump+178
	DD	imagerel $unwind$Pickler_dump
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_dump DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_06CKFCKBHM@O?3dump?$AA@
CONST	SEGMENT
??_C@_06CKFCKBHM@O?3dump?$AA@ DB 'O:dump', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EIOLGLN@Pickler?4__init__?$CI?$CJ?5was?5not?5calle@
CONST	SEGMENT
??_C@_0DD@EIOLGLN@Pickler?4__init__?$CI?$CJ?5was?5not?5calle@ DB 'Pickler'
	DB	'.__init__() was not called by %s.__init__()', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Pickler_dump
_TEXT	SEGMENT
obj$ = 32
self$ = 64
args$ = 72
Pickler_dump PROC					; COMDAT

; 3389 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3390 :     PyObject *obj;
; 3391 : 
; 3392 :     /* Check whether the Pickler was initialized correctly (issue3664).
; 3393 :        Developers often forget to call __init__() in their subclasses, which
; 3394 :        would trigger a segfault without this check. */
; 3395 :     if (self->write == NULL) {

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0001b	75 24		 jne	 SHORT $LN5@Pickler_du

; 3396 :         PyErr_Format(PicklingError,
; 3397 :                      "Pickler.__init__() was not called by %s.__init__()",
; 3398 :                      Py_TYPE(self)->tp_name);

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00022	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00026	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@EIOLGLN@Pickler?4__init__?$CI?$CJ?5was?5not?5calle@
  00031	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  00038	e8 00 00 00 00	 call	 PyErr_Format

; 3399 :         return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 6c		 jmp	 SHORT $LN6@Pickler_du
$LN5@Pickler_du:

; 3400 :     }
; 3401 : 
; 3402 :     if (!PyArg_ParseTuple(args, "O:dump", &obj))

  00041	4c 8d 44 24 20	 lea	 r8, QWORD PTR obj$[rsp]
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CKFCKBHM@O?3dump?$AA@
  0004d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00052	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00057	85 c0		 test	 eax, eax
  00059	75 04		 jne	 SHORT $LN4@Pickler_du

; 3403 :         return NULL;

  0005b	33 c0		 xor	 eax, eax
  0005d	eb 4e		 jmp	 SHORT $LN6@Pickler_du
$LN4@Pickler_du:

; 3404 : 
; 3405 :     if (_Pickler_ClearBuffer(self) < 0)

  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00064	e8 00 00 00 00	 call	 _Pickler_ClearBuffer
  00069	85 c0		 test	 eax, eax
  0006b	7d 04		 jge	 SHORT $LN3@Pickler_du

; 3406 :         return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	eb 3c		 jmp	 SHORT $LN6@Pickler_du
$LN3@Pickler_du:

; 3407 : 
; 3408 :     if (dump(self, obj) < 0)

  00071	48 8b 54 24 20	 mov	 rdx, QWORD PTR obj$[rsp]
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0007b	e8 00 00 00 00	 call	 dump
  00080	85 c0		 test	 eax, eax
  00082	7d 04		 jge	 SHORT $LN2@Pickler_du

; 3409 :         return NULL;

  00084	33 c0		 xor	 eax, eax
  00086	eb 25		 jmp	 SHORT $LN6@Pickler_du
$LN2@Pickler_du:

; 3410 : 
; 3411 :     if (_Pickler_FlushToFile(self) < 0)

  00088	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0008d	e8 00 00 00 00	 call	 _Pickler_FlushToFile
  00092	85 c0		 test	 eax, eax
  00094	7d 04		 jge	 SHORT $LN1@Pickler_du

; 3412 :         return NULL;

  00096	33 c0		 xor	 eax, eax
  00098	eb 13		 jmp	 SHORT $LN6@Pickler_du
$LN1@Pickler_du:

; 3413 : 
; 3414 :     Py_RETURN_NONE;

  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000a1	e8 00 00 00 00	 call	 _Py_IncRef
  000a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN6@Pickler_du:

; 3415 : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	c3		 ret	 0
Pickler_dump ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@HANIONFG@_Pickler_ClearBuffer?$AA@	; `string'
PUBLIC	??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@ ; `string'
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_ClearBuffer DD imagerel _Pickler_ClearBuffer
	DD	imagerel _Pickler_ClearBuffer+198
	DD	imagerel $unwind$_Pickler_ClearBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_ClearBuffer DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BF@HANIONFG@_Pickler_ClearBuffer?$AA@
CONST	SEGMENT
??_C@_0BF@HANIONFG@_Pickler_ClearBuffer?$AA@ DB '_Pickler_ClearBuffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
CONST	SEGMENT
??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@ DB '..\Modules\_pickle.'
	DB	'c', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Pickler_ClearBuffer
_TEXT	SEGMENT
_py_tmp$20842 = 48
self$ = 80
_Pickler_ClearBuffer PROC				; COMDAT

; 665  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN5@Pickler_Cl:

; 666  :     Py_CLEAR(self->output_buffer);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00016	74 5c		 je	 SHORT $LN2@Pickler_Cl
  00018	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00025	4c 8b 88 88 00
	00 00		 mov	 r9, QWORD PTR [rax+136]
  0002c	41 b8 9a 02 00
	00		 mov	 r8d, 666		; 0000029aH
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@HANIONFG@_Pickler_ClearBuffer?$AA@
  00040	e8 00 00 00 00	 call	 _PyParallel_Guard
  00045	85 c0		 test	 eax, eax
  00047	75 2b		 jne	 SHORT $LN2@Pickler_Cl
  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00055	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$20842[rsp], rax
  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0005f	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0
  0006a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$20842[rsp]
  0006f	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@Pickler_Cl:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 8f		 jne	 SHORT $LN5@Pickler_Cl

; 667  :     self->output_buffer =
; 668  :         PyBytes_FromStringAndSize(NULL, self->max_output_len);

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0007f	48 8b 90 98 00
	00 00		 mov	 rdx, QWORD PTR [rax+152]
  00086	33 c9		 xor	 ecx, ecx
  00088	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0008d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00092	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 669  :     if (self->output_buffer == NULL)

  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0009e	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  000a6	75 07		 jne	 SHORT $LN1@Pickler_Cl

; 670  :         return -1;

  000a8	b8 ff ff ff ff	 mov	 eax, -1
  000ad	eb 12		 jmp	 SHORT $LN6@Pickler_Cl
$LN1@Pickler_Cl:

; 671  :     self->output_len = 0;

  000af	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000b4	48 c7 80 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+144], 0

; 672  :     return 0;

  000bf	33 c0		 xor	 eax, eax
$LN6@Pickler_Cl:

; 673  : }

  000c1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c5	c3		 ret	 0
_Pickler_ClearBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CI@DBNOBFI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAw?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_FlushToFile DD imagerel _Pickler_FlushToFile
	DD	imagerel _Pickler_FlushToFile+173
	DD	imagerel $unwind$_Pickler_FlushToFile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_FlushToFile DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_1CI@DBNOBFI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAw?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@DBNOBFI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAw?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'w', 00H
	DB	'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, ' ', 00H, '!', 00H, '='
	DB	00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, '_', 00H, 'p', 00H, 'i'
	DB	00H, 'c', 00H, 'k', 00H, 'l', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Pickler_FlushToFile
_TEXT	SEGMENT
output$ = 32
result$ = 40
tv82 = 48
self$ = 80
_Pickler_FlushToFile PROC				; COMDAT

; 690  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 691  :     PyObject *output, *result;
; 692  : 
; 693  :     assert(self->write != NULL);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00016	75 1c		 jne	 SHORT $LN8@Pickler_Fl
  00018	41 b8 b5 02 00
	00		 mov	 r8d, 693		; 000002b5H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@DBNOBFI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAw?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00032	33 c0		 xor	 eax, eax
$LN8@Pickler_Fl:

; 694  : 
; 695  :     output = _Pickler_GetString(self);

  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00039	e8 00 00 00 00	 call	 _Pickler_GetString
  0003e	48 89 44 24 20	 mov	 QWORD PTR output$[rsp], rax

; 696  :     if (output == NULL)

  00043	48 83 7c 24 20
	00		 cmp	 QWORD PTR output$[rsp], 0
  00049	75 07		 jne	 SHORT $LN5@Pickler_Fl

; 697  :         return -1;

  0004b	b8 ff ff ff ff	 mov	 eax, -1
  00050	eb 56		 jmp	 SHORT $LN6@Pickler_Fl
$LN5@Pickler_Fl:

; 698  : 
; 699  :     result = _Pickler_FastCall(self, self->write, output);

  00052	4c 8b 44 24 20	 mov	 r8, QWORD PTR output$[rsp]
  00057	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0005c	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  00063	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00068	e8 00 00 00 00	 call	 _Pickler_FastCall
  0006d	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax
$LN4@Pickler_Fl:

; 700  :     Py_XDECREF(result);

  00072	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  00078	74 0a		 je	 SHORT $LN1@Pickler_Fl
  0007a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  0007f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Pickler_Fl:
  00084	33 c0		 xor	 eax, eax
  00086	85 c0		 test	 eax, eax
  00088	75 e8		 jne	 SHORT $LN4@Pickler_Fl

; 701  :     return (result == NULL) ? -1 : 0;

  0008a	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  00090	75 0a		 jne	 SHORT $LN9@Pickler_Fl
  00092	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR tv82[rsp], -1
  0009a	eb 08		 jmp	 SHORT $LN10@Pickler_Fl
$LN9@Pickler_Fl:
  0009c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN10@Pickler_Fl:
  000a4	8b 44 24 30	 mov	 eax, DWORD PTR tv82[rsp]
$LN6@Pickler_Fl:

; 702  : }

  000a8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ac	c3		 ret	 0
_Pickler_FlushToFile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@OGGBOJLP@_Pickler_FastCall?$AA@	; `string'
EXTRN	PyObject_Call:PROC
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_FastCall DD imagerel _Pickler_FastCall
	DD	imagerel _Pickler_FastCall+329
	DD	imagerel $unwind$_Pickler_FastCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_FastCall DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0BC@OGGBOJLP@_Pickler_FastCall?$AA@
CONST	SEGMENT
??_C@_0BC@OGGBOJLP@_Pickler_FastCall?$AA@ DB '_Pickler_FastCall', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Pickler_FastCall
_TEXT	SEGMENT
result$ = 48
_py_tmp$20829 = 56
tv67 = 64
self$ = 96
func$ = 104
arg$ = 112
_Pickler_FastCall PROC					; COMDAT

; 652  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 653  :     PyObject *result = NULL;

  00013	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0
$LN19@Pickler_Fa:

; 654  : 
; 655  :     ARG_TUP(self, arg);

  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00021	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00026	75 25		 jne	 SHORT $LN15@Pickler_Fa
  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	e8 00 00 00 00	 call	 PyTuple_New
  00032	48 89 44 24 40	 mov	 QWORD PTR tv67[rsp], rax
  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv67[rsp]
  00041	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx
  00045	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv67[rsp], 0
  0004b	74 3c		 je	 SHORT $LN16@Pickler_Fa
$LN15@Pickler_Fa:
$LN14@Pickler_Fa:
  0004d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00052	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00056	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0005b	74 12		 je	 SHORT $LN11@Pickler_Fa
  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00062	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00066	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0006a	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@Pickler_Fa:
  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 d8		 jne	 SHORT $LN14@Pickler_Fa
  00075	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0007a	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR arg$[rsp]
  00083	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
  00087	eb 0a		 jmp	 SHORT $LN10@Pickler_Fa
$LN16@Pickler_Fa:
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR arg$[rsp]
  0008e	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@Pickler_Fa:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 83		 jne	 SHORT $LN19@Pickler_Fa

; 656  :     if (self->arg) {

  00099	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0009e	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  000a3	0f 84 96 00 00
	00		 je	 $LN9@Pickler_Fa

; 657  :         result = PyObject_Call(func, self->arg, NULL);

  000a9	45 33 c0	 xor	 r8d, r8d
  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000b1	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  000b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR func$[rsp]
  000ba	e8 00 00 00 00	 call	 PyObject_Call
  000bf	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$LN8@Pickler_Fa:

; 658  :         FREE_ARG_TUP(self);

  000c4	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000c9	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000cd	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  000d2	7e 65		 jle	 SHORT $LN5@Pickler_Fa
$LN4@Pickler_Fa:
  000d4	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000d9	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  000de	74 53		 je	 SHORT $LN1@Pickler_Fa
  000e0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e8	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000ed	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  000f1	41 b8 92 02 00
	00		 mov	 r8d, 658		; 00000292H
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@OGGBOJLP@_Pickler_FastCall?$AA@
  00105	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010a	85 c0		 test	 eax, eax
  0010c	75 25		 jne	 SHORT $LN1@Pickler_Fa
  0010e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00113	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00117	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$20829[rsp], rax
  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00121	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
  00129	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$20829[rsp]
  0012e	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Pickler_Fa:
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 9b		 jne	 SHORT $LN4@Pickler_Fa
$LN5@Pickler_Fa:
  00139	33 c0		 xor	 eax, eax
  0013b	85 c0		 test	 eax, eax
  0013d	75 85		 jne	 SHORT $LN8@Pickler_Fa
$LN9@Pickler_Fa:

; 659  :     }
; 660  :     return result;

  0013f	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 661  : }

  00144	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00148	c3		 ret	 0
_Pickler_FastCall ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DI@OCEFHDBO@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	_PyBytes_Resize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_GetString DD imagerel _Pickler_GetString
	DD	imagerel _Pickler_GetString+125
	DD	imagerel $unwind$_Pickler_GetString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_GetString DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1DI@OCEFHDBO@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@OCEFHDBO@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, '_', 00H, 'b'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Pickler_GetString
_TEXT	SEGMENT
output_buffer$ = 32
self$ = 64
_Pickler_GetString PROC					; COMDAT

; 677  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 678  :     PyObject *output_buffer = self->output_buffer;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00015	48 89 44 24 20	 mov	 QWORD PTR output_buffer$[rsp], rax

; 679  : 
; 680  :     assert(self->output_buffer != NULL);

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0001f	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00027	75 1c		 jne	 SHORT $LN4@Pickler_Ge
  00029	41 b8 a8 02 00
	00		 mov	 r8d, 680		; 000002a8H
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@OCEFHDBO@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00043	33 c0		 xor	 eax, eax
$LN4@Pickler_Ge:

; 681  :     self->output_buffer = NULL;

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 682  :     /* Resize down to exact size */
; 683  :     if (_PyBytes_Resize(&output_buffer, self->output_len) < 0)

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0005a	48 8b 90 90 00
	00 00		 mov	 rdx, QWORD PTR [rax+144]
  00061	48 8d 4c 24 20	 lea	 rcx, QWORD PTR output_buffer$[rsp]
  00066	e8 00 00 00 00	 call	 _PyBytes_Resize
  0006b	85 c0		 test	 eax, eax
  0006d	7d 04		 jge	 SHORT $LN1@Pickler_Ge

; 684  :         return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	eb 05		 jmp	 SHORT $LN2@Pickler_Ge
$LN1@Pickler_Ge:

; 685  :     return output_buffer;

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR output_buffer$[rsp]
$LN2@Pickler_Ge:

; 686  : }

  00078	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007c	c3		 ret	 0
_Pickler_GetString ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EM@PPAIJE@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$dump DD	imagerel dump
	DD	imagerel dump+208
	DD	imagerel $unwind$dump
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dump DD	010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1EM@PPAIJE@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5@
CONST	SEGMENT
??_C@_1EM@PPAIJE@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 't', 00H, 'o', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'p'
	DB	00H, 'r', 00H, 'o', 00H, 't', 00H, 'o', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, '2', 00H, '5', 00H, '6', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT dump
_TEXT	SEGMENT
stop_op$ = 32
header$22748 = 36
self$ = 64
obj$ = 72
dump	PROC						; COMDAT

; 3347 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3348 :     const char stop_op = STOP;

  0000e	c6 44 24 20 2e	 mov	 BYTE PTR stop_op$[rsp], 46 ; 0000002eH

; 3349 : 
; 3350 :     if (self->proto >= 2) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00018	83 b8 a0 00 00
	00 02		 cmp	 DWORD PTR [rax+160], 2
  0001f	7c 71		 jl	 SHORT $LN4@dump

; 3351 :         char header[2];
; 3352 : 
; 3353 :         header[0] = PROTO;

  00021	c6 44 24 24 80	 mov	 BYTE PTR header$22748[rsp], -128 ; ffffffffffffff80H

; 3354 :         assert(self->proto >= 0 && self->proto < 256);

  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002b	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  00032	7c 11		 jl	 SHORT $LN7@dump
  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00039	81 b8 a0 00 00
	00 00 01 00 00	 cmp	 DWORD PTR [rax+160], 256 ; 00000100H
  00043	7c 1c		 jl	 SHORT $LN8@dump
$LN7@dump:
  00045	41 b8 1a 0d 00
	00		 mov	 r8d, 3354		; 00000d1aH
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@PPAIJE@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5@
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005f	33 c0		 xor	 eax, eax
$LN8@dump:

; 3355 :         header[1] = (unsigned char)self->proto;

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00066	0f b6 80 a0 00
	00 00		 movzx	 eax, BYTE PTR [rax+160]
  0006d	88 44 24 25	 mov	 BYTE PTR header$22748[rsp+1], al

; 3356 :         if (_Pickler_Write(self, header, 2) < 0)

  00071	41 b8 02 00 00
	00		 mov	 r8d, 2
  00077	48 8d 54 24 24	 lea	 rdx, QWORD PTR header$22748[rsp]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00081	e8 00 00 00 00	 call	 _Pickler_Write
  00086	48 85 c0	 test	 rax, rax
  00089	7d 07		 jge	 SHORT $LN3@dump

; 3357 :             return -1;

  0008b	b8 ff ff ff ff	 mov	 eax, -1
  00090	eb 39		 jmp	 SHORT $LN5@dump
$LN3@dump:
$LN4@dump:

; 3358 :     }
; 3359 : 
; 3360 :     if (save(self, obj, 0) < 0 ||
; 3361 :         _Pickler_Write(self, &stop_op, 1) < 0)

  00092	45 33 c0	 xor	 r8d, r8d
  00095	48 8b 54 24 48	 mov	 rdx, QWORD PTR obj$[rsp]
  0009a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0009f	e8 00 00 00 00	 call	 save
  000a4	85 c0		 test	 eax, eax
  000a6	7c 1a		 jl	 SHORT $LN1@dump
  000a8	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ae	48 8d 54 24 20	 lea	 rdx, QWORD PTR stop_op$[rsp]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000b8	e8 00 00 00 00	 call	 _Pickler_Write
  000bd	48 85 c0	 test	 rax, rax
  000c0	7d 07		 jge	 SHORT $LN2@dump
$LN1@dump:

; 3362 :         return -1;

  000c2	b8 ff ff ff ff	 mov	 eax, -1
  000c7	eb 02		 jmp	 SHORT $LN5@dump
$LN2@dump:

; 3363 : 
; 3364 :     return 0;

  000c9	33 c0		 xor	 eax, eax
$LN5@dump:

; 3365 : }

  000cb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cf	c3		 ret	 0
dump	ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EG@CCEMEJEA@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe@ ; `string'
PUBLIC	??_C@_1BE@EEKACIGI@?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	memcpy:PROC
EXTRN	PyErr_NoMemory:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_Write DD imagerel _Pickler_Write
	DD	imagerel _Pickler_Write+735
	DD	imagerel $unwind$_Pickler_Write
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_Write DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_1EG@CCEMEJEA@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe@
CONST	SEGMENT
??_C@_1EG@CCEMEJEA@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H
	DB	'o', 00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, '_'
	DB	00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@EEKACIGI@?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@EEKACIGI@?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Pickler_Write
_TEXT	SEGMENT
i$ = 32
required$ = 40
buffer$ = 48
output$20899 = 56
result$20898 = 64
tv130 = 72
self$ = 96
s$ = 104
n$ = 112
_Pickler_Write PROC					; COMDAT

; 706  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 707  :     Py_ssize_t i, required;
; 708  :     char *buffer;
; 709  : 
; 710  :     assert(s != NULL);

  00013	48 83 7c 24 68
	00		 cmp	 QWORD PTR s$[rsp], 0
  00019	75 1c		 jne	 SHORT $LN21@Pickler_Wr
  0001b	41 b8 c6 02 00
	00		 mov	 r8d, 710		; 000002c6H
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@EEKACIGI@?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00035	33 c0		 xor	 eax, eax
$LN21@Pickler_Wr:

; 711  : 
; 712  :     required = self->output_len + n;

  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0003c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00043	48 03 44 24 70	 add	 rax, QWORD PTR n$[rsp]
  00048	48 89 44 24 28	 mov	 QWORD PTR required$[rsp], rax

; 713  :     if (required > self->max_output_len) {

  0004d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00052	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00059	48 39 44 24 28	 cmp	 QWORD PTR required$[rsp], rax
  0005e	0f 8e 7f 01 00
	00		 jle	 $LN18@Pickler_Wr

; 714  :         if (self->write != NULL && required > MAX_WRITE_BUF_SIZE) {

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00069	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00071	74 3f		 je	 SHORT $LN17@Pickler_Wr
  00073	48 81 7c 24 28
	00 00 01 00	 cmp	 QWORD PTR required$[rsp], 65536 ; 00010000H
  0007c	7e 34		 jle	 SHORT $LN17@Pickler_Wr

; 715  :             /* XXX This reallocates a new buffer every time, which is a bit
; 716  :                wasteful. */
; 717  :             if (_Pickler_FlushToFile(self) < 0)

  0007e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00083	e8 00 00 00 00	 call	 _Pickler_FlushToFile
  00088	85 c0		 test	 eax, eax
  0008a	7d 0c		 jge	 SHORT $LN16@Pickler_Wr

; 718  :                 return -1;

  0008c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00093	e9 42 02 00 00	 jmp	 $LN19@Pickler_Wr
$LN16@Pickler_Wr:

; 719  :             if (_Pickler_ClearBuffer(self) < 0)

  00098	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0009d	e8 00 00 00 00	 call	 _Pickler_ClearBuffer
  000a2	85 c0		 test	 eax, eax
  000a4	7d 0c		 jge	 SHORT $LN15@Pickler_Wr

; 720  :                 return -1;

  000a6	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000ad	e9 28 02 00 00	 jmp	 $LN19@Pickler_Wr
$LN15@Pickler_Wr:
$LN17@Pickler_Wr:

; 721  :         }
; 722  :         if (self->write != NULL && n > MAX_WRITE_BUF_SIZE) {

  000b2	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000b7	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000bf	0f 84 98 00 00
	00		 je	 $LN14@Pickler_Wr
  000c5	48 81 7c 24 70
	00 00 01 00	 cmp	 QWORD PTR n$[rsp], 65536 ; 00010000H
  000ce	0f 8e 89 00 00
	00		 jle	 $LN14@Pickler_Wr

; 723  :             /* we already flushed above, so the buffer is empty */
; 724  :             PyObject *result;
; 725  :             /* XXX we could spare an intermediate copy and pass
; 726  :                a memoryview instead */
; 727  :             PyObject *output = PyBytes_FromStringAndSize(s, n);

  000d4	48 8b 54 24 70	 mov	 rdx, QWORD PTR n$[rsp]
  000d9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR s$[rsp]
  000de	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000e3	48 89 44 24 38	 mov	 QWORD PTR output$20899[rsp], rax

; 728  :             if (s == NULL)

  000e8	48 83 7c 24 68
	00		 cmp	 QWORD PTR s$[rsp], 0
  000ee	75 0c		 jne	 SHORT $LN13@Pickler_Wr

; 729  :                 return -1;

  000f0	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000f7	e9 de 01 00 00	 jmp	 $LN19@Pickler_Wr
$LN13@Pickler_Wr:

; 730  :             result = _Pickler_FastCall(self, self->write, output);

  000fc	4c 8b 44 24 38	 mov	 r8, QWORD PTR output$20899[rsp]
  00101	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00106	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  0010d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00112	e8 00 00 00 00	 call	 _Pickler_FastCall
  00117	48 89 44 24 40	 mov	 QWORD PTR result$20898[rsp], rax
$LN12@Pickler_Wr:

; 731  :             Py_XDECREF(result);

  0011c	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$20898[rsp], 0
  00122	74 0a		 je	 SHORT $LN9@Pickler_Wr
  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$20898[rsp]
  00129	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@Pickler_Wr:
  0012e	33 c0		 xor	 eax, eax
  00130	85 c0		 test	 eax, eax
  00132	75 e8		 jne	 SHORT $LN12@Pickler_Wr

; 732  :             return (result == NULL) ? -1 : 0;

  00134	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$20898[rsp], 0
  0013a	75 0a		 jne	 SHORT $LN22@Pickler_Wr
  0013c	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR tv130[rsp], -1
  00144	eb 08		 jmp	 SHORT $LN23@Pickler_Wr
$LN22@Pickler_Wr:
  00146	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN23@Pickler_Wr:
  0014e	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv130[rsp]
  00153	e9 82 01 00 00	 jmp	 $LN19@Pickler_Wr

; 733  :         }
; 734  :         else {

  00158	e9 86 00 00 00	 jmp	 $LN8@Pickler_Wr
$LN14@Pickler_Wr:

; 735  :             if (self->output_len >= PY_SSIZE_T_MAX / 2 - n) {

  0015d	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  00167	48 2b 44 24 70	 sub	 rax, QWORD PTR n$[rsp]
  0016c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00171	48 39 81 90 00
	00 00		 cmp	 QWORD PTR [rcx+144], rax
  00178	7c 11		 jl	 SHORT $LN7@Pickler_Wr

; 736  :                 PyErr_NoMemory();

  0017a	e8 00 00 00 00	 call	 PyErr_NoMemory

; 737  :                 return -1;

  0017f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00186	e9 4f 01 00 00	 jmp	 $LN19@Pickler_Wr
$LN7@Pickler_Wr:

; 738  :             }
; 739  :             self->max_output_len = (self->output_len + n) / 2 * 3;

  0018b	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00190	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00197	48 03 44 24 70	 add	 rax, QWORD PTR n$[rsp]
  0019c	48 99		 cdq
  0019e	48 2b c2	 sub	 rax, rdx
  001a1	48 d1 f8	 sar	 rax, 1
  001a4	48 6b c0 03	 imul	 rax, 3
  001a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001ad	48 89 81 98 00
	00 00		 mov	 QWORD PTR [rcx+152], rax

; 740  :             if (_PyBytes_Resize(&self->output_buffer, self->max_output_len) < 0)

  001b4	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001b9	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  001bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001c4	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  001cb	48 8b c8	 mov	 rcx, rax
  001ce	e8 00 00 00 00	 call	 _PyBytes_Resize
  001d3	85 c0		 test	 eax, eax
  001d5	7d 0c		 jge	 SHORT $LN6@Pickler_Wr

; 741  :                 return -1;

  001d7	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  001de	e9 f7 00 00 00	 jmp	 $LN19@Pickler_Wr
$LN6@Pickler_Wr:
$LN8@Pickler_Wr:
$LN18@Pickler_Wr:

; 742  :         }
; 743  :     }
; 744  :     buffer = PyBytes_AS_STRING(self->output_buffer);

  001e3	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001e8	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  001ef	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001f3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001f9	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001fe	85 c0		 test	 eax, eax
  00200	75 1c		 jne	 SHORT $LN24@Pickler_Wr
  00202	41 b8 e8 02 00
	00		 mov	 r8d, 744		; 000002e8H
  00208	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0020f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@CCEMEJEA@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe@
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0021c	33 c0		 xor	 eax, eax
$LN24@Pickler_Wr:
  0021e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00223	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  0022a	48 83 c0 78	 add	 rax, 120		; 00000078H
  0022e	48 89 44 24 30	 mov	 QWORD PTR buffer$[rsp], rax

; 745  :     if (n < 8) {

  00233	48 83 7c 24 70
	08		 cmp	 QWORD PTR n$[rsp], 8
  00239	7d 54		 jge	 SHORT $LN5@Pickler_Wr

; 746  :         /* This is faster than memcpy when the string is short. */
; 747  :         for (i = 0; i < n; i++) {

  0023b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00244	eb 0d		 jmp	 SHORT $LN4@Pickler_Wr
$LN3@Pickler_Wr:
  00246	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0024b	48 ff c0	 inc	 rax
  0024e	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@Pickler_Wr:
  00253	48 8b 44 24 70	 mov	 rax, QWORD PTR n$[rsp]
  00258	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0025d	7d 2e		 jge	 SHORT $LN2@Pickler_Wr

; 748  :             buffer[self->output_len + i] = s[i];

  0025f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00264	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0026b	48 03 44 24 20	 add	 rax, QWORD PTR i$[rsp]
  00270	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00275	48 8b 54 24 68	 mov	 rdx, QWORD PTR s$[rsp]
  0027a	48 03 d1	 add	 rdx, rcx
  0027d	48 8b ca	 mov	 rcx, rdx
  00280	48 8b 54 24 30	 mov	 rdx, QWORD PTR buffer$[rsp]
  00285	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00288	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl

; 749  :         }

  0028b	eb b9		 jmp	 SHORT $LN3@Pickler_Wr
$LN2@Pickler_Wr:

; 750  :     }
; 751  :     else {

  0028d	eb 29		 jmp	 SHORT $LN1@Pickler_Wr
$LN5@Pickler_Wr:

; 752  :         memcpy(buffer + self->output_len, s, n);

  0028f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00294	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0029b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buffer$[rsp]
  002a0	48 03 c8	 add	 rcx, rax
  002a3	48 8b c1	 mov	 rax, rcx
  002a6	4c 8b 44 24 70	 mov	 r8, QWORD PTR n$[rsp]
  002ab	48 8b 54 24 68	 mov	 rdx, QWORD PTR s$[rsp]
  002b0	48 8b c8	 mov	 rcx, rax
  002b3	e8 00 00 00 00	 call	 memcpy
$LN1@Pickler_Wr:

; 753  :     }
; 754  :     self->output_len += n;

  002b8	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  002bd	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002c4	48 03 44 24 70	 add	 rax, QWORD PTR n$[rsp]
  002c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  002ce	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 755  :     return n;

  002d5	48 8b 44 24 70	 mov	 rax, QWORD PTR n$[rsp]
$LN19@Pickler_Wr:

; 756  : }

  002da	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002de	c3		 ret	 0
_Pickler_Write ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@NPKDNCPF@__reduce__?5must?5return?5a?5string?5@ ; `string'
PUBLIC	??_C@_0CB@HIPCBBLL@can?8t?5pickle?5?8?$CF?4200s?8?5object?3?5?$CFR@ ; `string'
PUBLIC	??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@		; `string'
PUBLIC	??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_AttributeError:QWORD
EXTRN	PyLong_FromLong:PROC
EXTRN	PyObject_GetAttr:PROC
EXTRN	PyUnicode_InternFromString:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyExc_KeyError:QWORD
EXTRN	PyObject_GetItem:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyCFunction_Type:BYTE
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyFunction_Type:BYTE
EXTRN	PyType_Type:BYTE
EXTRN	PyTuple_Type:BYTE
EXTRN	PyList_Type:BYTE
EXTRN	PyDict_Type:BYTE
EXTRN	PyUnicode_Type:BYTE
EXTRN	PyBytes_Type:BYTE
EXTRN	PyFloat_Type:BYTE
EXTRN	PyLong_Type:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	_Py_EllipsisObject:BYTE
EXTRN	_Py_CheckRecursiveCall:PROC
EXTRN	_Py_CheckRecursionLimit:DWORD
EXTRN	PyThreadState_Get:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save DD	imagerel save
	DD	imagerel save+1681
	DD	imagerel $unwind$save
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save DD	011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0CJ@NPKDNCPF@__reduce__?5must?5return?5a?5string?5@
CONST	SEGMENT
??_C@_0CJ@NPKDNCPF@__reduce__?5must?5return?5a?5string?5@ DB '__reduce__ '
	DB	'must return a string or tuple', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HIPCBBLL@can?8t?5pickle?5?8?$CF?4200s?8?5object?3?5?$CFR@
CONST	SEGMENT
??_C@_0CB@HIPCBBLL@can?8t?5pickle?5?8?$CF?4200s?8?5object?3?5?$CFR@ DB 'c'
	DB	'an''t pickle ''%.200s'' object: %R', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
CONST	SEGMENT
??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@ DB '__reduce_ex__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
CONST	SEGMENT
??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@ DB ' while pickling'
	DB	' an object', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save
_TEXT	SEGMENT
type$ = 32
reduce_func$ = 40
reduce_value$ = 48
status$ = 56
proto$22707 = 64
tv66 = 72
tv279 = 80
tv273 = 88
self$ = 112
obj$ = 120
pers_save$ = 128
save	PROC						; COMDAT

; 3137 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3138 :     PyTypeObject *type;
; 3139 :     PyObject *reduce_func = NULL;

  00013	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR reduce_func$[rsp], 0

; 3140 :     PyObject *reduce_value = NULL;

  0001c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR reduce_value$[rsp], 0

; 3141 :     int status = 0;

  00025	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 3142 : 
; 3143 :     if (Py_EnterRecursiveCall(" while pickling an object"))

  0002d	e8 00 00 00 00	 call	 PyThreadState_Get
  00032	48 83 c0 18	 add	 rax, 24
  00036	48 89 44 24 48	 mov	 QWORD PTR tv66[rsp], rax
  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR tv66[rsp]
  00040	8b 00		 mov	 eax, DWORD PTR [rax]
  00042	ff c0		 inc	 eax
  00044	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv66[rsp]
  00049	89 01		 mov	 DWORD PTR [rcx], eax
  0004b	48 8b 44 24 48	 mov	 rax, QWORD PTR tv66[rsp]
  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  00056	39 08		 cmp	 DWORD PTR [rax], ecx
  00058	7e 1a		 jle	 SHORT $LN73@save
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
  00061	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00066	85 c0		 test	 eax, eax
  00068	74 0a		 je	 SHORT $LN73@save

; 3144 :         return -1;

  0006a	b8 ff ff ff ff	 mov	 eax, -1
  0006f	e9 18 06 00 00	 jmp	 $LN74@save
$LN73@save:

; 3145 : 
; 3146 :     /* The extra pers_save argument is necessary to avoid calling save_pers()
; 3147 :        on its returned object. */
; 3148 :     if (!pers_save && self->pers_func) {

  00074	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR pers_save$[rsp], 0
  0007c	75 34		 jne	 SHORT $LN72@save
  0007e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00083	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00088	74 28		 je	 SHORT $LN72@save

; 3149 :         /* save_pers() returns:
; 3150 :             -1   to signal an error;
; 3151 :              0   if it did nothing successfully;
; 3152 :              1   if a persistent id was saved.
; 3153 :          */
; 3154 :         if ((status = save_pers(self, obj, self->pers_func)) != 0)

  0008a	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0008f	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00093	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  00098	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0009d	e8 00 00 00 00	 call	 save_pers
  000a2	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax
  000a6	83 7c 24 38 00	 cmp	 DWORD PTR status$[rsp], 0
  000ab	74 05		 je	 SHORT $LN71@save

; 3155 :             goto done;

  000ad	e9 44 05 00 00	 jmp	 $done$22632
$LN71@save:
$LN72@save:

; 3156 :     }
; 3157 : 
; 3158 :     type = Py_TYPE(obj);

  000b2	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  000b7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000bb	48 89 44 24 20	 mov	 QWORD PTR type$[rsp], rax

; 3159 : 
; 3160 :     /* The old cPickle had an optimization that used switch-case statement
; 3161 :        dispatching on the first letter of the type name.  This has was removed
; 3162 :        since benchmarks shown that this optimization was actually slowing
; 3163 :        things down. */
; 3164 : 
; 3165 :     /* Atom types; these aren't memoized, so don't check the memo. */
; 3166 : 
; 3167 :     if (obj == Py_None) {

  000c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000c7	48 39 44 24 78	 cmp	 QWORD PTR obj$[rsp], rax
  000cc	75 1d		 jne	 SHORT $LN70@save

; 3168 :         status = save_none(self, obj);

  000ce	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  000d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000d8	e8 00 00 00 00	 call	 save_none
  000dd	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3169 :         goto done;

  000e1	e9 10 05 00 00	 jmp	 $done$22632
  000e6	e9 da 00 00 00	 jmp	 $LN69@save
$LN70@save:

; 3170 :     }
; 3171 :     else if (obj == Py_Ellipsis) {

  000eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_EllipsisObject
  000f2	48 39 44 24 78	 cmp	 QWORD PTR obj$[rsp], rax
  000f7	75 1d		 jne	 SHORT $LN68@save

; 3172 :         status = save_ellipsis(self, obj);

  000f9	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  000fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00103	e8 00 00 00 00	 call	 save_ellipsis
  00108	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3173 :         goto done;

  0010c	e9 e5 04 00 00	 jmp	 $done$22632
  00111	e9 af 00 00 00	 jmp	 $LN67@save
$LN68@save:

; 3174 :     }
; 3175 :     else if (obj == Py_NotImplemented) {

  00116	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0011d	48 39 44 24 78	 cmp	 QWORD PTR obj$[rsp], rax
  00122	75 1d		 jne	 SHORT $LN66@save

; 3176 :         status = save_notimplemented(self, obj);

  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  00129	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0012e	e8 00 00 00 00	 call	 save_notimplemented
  00133	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3177 :         goto done;

  00137	e9 ba 04 00 00	 jmp	 $done$22632
  0013c	e9 84 00 00 00	 jmp	 $LN65@save
$LN66@save:

; 3178 :     }
; 3179 :     else if (obj == Py_False || obj == Py_True) {

  00141	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00148	48 39 44 24 78	 cmp	 QWORD PTR obj$[rsp], rax
  0014d	74 0e		 je	 SHORT $LN63@save
  0014f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00156	48 39 44 24 78	 cmp	 QWORD PTR obj$[rsp], rax
  0015b	75 1a		 jne	 SHORT $LN64@save
$LN63@save:

; 3180 :         status = save_bool(self, obj);

  0015d	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  00162	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00167	e8 00 00 00 00	 call	 save_bool
  0016c	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3181 :         goto done;

  00170	e9 81 04 00 00	 jmp	 $done$22632
  00175	eb 4e		 jmp	 SHORT $LN62@save
$LN64@save:

; 3182 :     }
; 3183 :     else if (type == &PyLong_Type) {

  00177	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  0017e	48 39 44 24 20	 cmp	 QWORD PTR type$[rsp], rax
  00183	75 1a		 jne	 SHORT $LN61@save

; 3184 :         status = save_long(self, obj);

  00185	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  0018a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0018f	e8 00 00 00 00	 call	 save_long
  00194	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3185 :         goto done;

  00198	e9 59 04 00 00	 jmp	 $done$22632
  0019d	eb 26		 jmp	 SHORT $LN60@save
$LN61@save:

; 3186 :     }
; 3187 :     else if (type == &PyFloat_Type) {

  0019f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  001a6	48 39 44 24 20	 cmp	 QWORD PTR type$[rsp], rax
  001ab	75 18		 jne	 SHORT $LN59@save

; 3188 :         status = save_float(self, obj);

  001ad	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  001b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001b7	e8 00 00 00 00	 call	 save_float
  001bc	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3189 :         goto done;

  001c0	e9 31 04 00 00	 jmp	 $done$22632
$LN59@save:
$LN60@save:
$LN62@save:
$LN65@save:
$LN67@save:
$LN69@save:

; 3190 :     }
; 3191 : 
; 3192 :     /* Check the memo to see if it has the object. If so, generate
; 3193 :        a GET (or BINGET) opcode, instead of pickling the object
; 3194 :        once again. */
; 3195 :     if (PyMemoTable_Get(self->memo, obj)) {

  001c5	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  001ca	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001cf	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  001d3	e8 00 00 00 00	 call	 PyMemoTable_Get
  001d8	48 85 c0	 test	 rax, rax
  001db	74 1d		 je	 SHORT $LN58@save

; 3196 :         if (memo_get(self, obj) < 0)

  001dd	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  001e2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001e7	e8 00 00 00 00	 call	 memo_get
  001ec	85 c0		 test	 eax, eax
  001ee	7d 05		 jge	 SHORT $LN57@save

; 3197 :             goto error;

  001f0	e9 f9 03 00 00	 jmp	 $error$22650
$LN57@save:

; 3198 :         goto done;

  001f5	e9 fc 03 00 00	 jmp	 $done$22632
$LN58@save:

; 3199 :     }
; 3200 : 
; 3201 :     if (type == &PyBytes_Type) {

  001fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  00201	48 39 44 24 20	 cmp	 QWORD PTR type$[rsp], rax
  00206	75 1d		 jne	 SHORT $LN56@save

; 3202 :         status = save_bytes(self, obj);

  00208	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  0020d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00212	e8 00 00 00 00	 call	 save_bytes
  00217	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3203 :         goto done;

  0021b	e9 d6 03 00 00	 jmp	 $done$22632
  00220	e9 46 01 00 00	 jmp	 $LN55@save
$LN56@save:

; 3204 :     }
; 3205 :     else if (type == &PyUnicode_Type) {

  00225	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  0022c	48 39 44 24 20	 cmp	 QWORD PTR type$[rsp], rax
  00231	75 1d		 jne	 SHORT $LN54@save

; 3206 :         status = save_unicode(self, obj);

  00233	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  00238	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0023d	e8 00 00 00 00	 call	 save_unicode
  00242	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3207 :         goto done;

  00246	e9 ab 03 00 00	 jmp	 $done$22632
  0024b	e9 1b 01 00 00	 jmp	 $LN53@save
$LN54@save:

; 3208 :     }
; 3209 :     else if (type == &PyDict_Type) {

  00250	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00257	48 39 44 24 20	 cmp	 QWORD PTR type$[rsp], rax
  0025c	75 1d		 jne	 SHORT $LN52@save

; 3210 :         status = save_dict(self, obj);

  0025e	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  00263	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00268	e8 00 00 00 00	 call	 save_dict
  0026d	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3211 :         goto done;

  00271	e9 80 03 00 00	 jmp	 $done$22632
  00276	e9 f0 00 00 00	 jmp	 $LN51@save
$LN52@save:

; 3212 :     }
; 3213 :     else if (type == &PyList_Type) {

  0027b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  00282	48 39 44 24 20	 cmp	 QWORD PTR type$[rsp], rax
  00287	75 1d		 jne	 SHORT $LN50@save

; 3214 :         status = save_list(self, obj);

  00289	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  0028e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00293	e8 00 00 00 00	 call	 save_list
  00298	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3215 :         goto done;

  0029c	e9 55 03 00 00	 jmp	 $done$22632
  002a1	e9 c5 00 00 00	 jmp	 $LN49@save
$LN50@save:

; 3216 :     }
; 3217 :     else if (type == &PyTuple_Type) {

  002a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  002ad	48 39 44 24 20	 cmp	 QWORD PTR type$[rsp], rax
  002b2	75 1d		 jne	 SHORT $LN48@save

; 3218 :         status = save_tuple(self, obj);

  002b4	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  002b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  002be	e8 00 00 00 00	 call	 save_tuple
  002c3	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3219 :         goto done;

  002c7	e9 2a 03 00 00	 jmp	 $done$22632
  002cc	e9 9a 00 00 00	 jmp	 $LN47@save
$LN48@save:

; 3220 :     }
; 3221 :     else if (type == &PyType_Type) {

  002d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type
  002d8	48 39 44 24 20	 cmp	 QWORD PTR type$[rsp], rax
  002dd	75 1a		 jne	 SHORT $LN46@save

; 3222 :         status = save_type(self, obj);

  002df	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  002e4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  002e9	e8 00 00 00 00	 call	 save_type
  002ee	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3223 :         goto done;

  002f2	e9 ff 02 00 00	 jmp	 $done$22632
  002f7	eb 72		 jmp	 SHORT $LN45@save
$LN46@save:

; 3224 :     }
; 3225 :     else if (type == &PyFunction_Type) {

  002f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFunction_Type
  00300	48 39 44 24 20	 cmp	 QWORD PTR type$[rsp], rax
  00305	75 3b		 jne	 SHORT $LN44@save

; 3226 :         status = save_global(self, obj, NULL);

  00307	45 33 c0	 xor	 r8d, r8d
  0030a	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  0030f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00314	e8 00 00 00 00	 call	 save_global
  00319	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3227 :         if (status < 0 && PyErr_ExceptionMatches(PickleError)) {

  0031d	83 7c 24 38 00	 cmp	 DWORD PTR status$[rsp], 0
  00322	7d 17		 jge	 SHORT $LN43@save
  00324	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PickleError
  0032b	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00330	85 c0		 test	 eax, eax
  00332	74 07		 je	 SHORT $LN43@save

; 3228 :             /* fall back to reduce */
; 3229 :             PyErr_Clear();

  00334	e8 00 00 00 00	 call	 PyErr_Clear

; 3230 :         }
; 3231 :         else {

  00339	eb 05		 jmp	 SHORT $LN42@save
$LN43@save:

; 3232 :             goto done;

  0033b	e9 b6 02 00 00	 jmp	 $done$22632
$LN42@save:

; 3233 :         }

  00340	eb 29		 jmp	 SHORT $LN41@save
$LN44@save:

; 3234 :     }
; 3235 :     else if (type == &PyCFunction_Type) {

  00342	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyCFunction_Type
  00349	48 39 44 24 20	 cmp	 QWORD PTR type$[rsp], rax
  0034e	75 1b		 jne	 SHORT $LN40@save

; 3236 :         status = save_global(self, obj, NULL);

  00350	45 33 c0	 xor	 r8d, r8d
  00353	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  00358	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0035d	e8 00 00 00 00	 call	 save_global
  00362	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3237 :         goto done;

  00366	e9 8b 02 00 00	 jmp	 $done$22632
$LN40@save:
$LN41@save:
$LN45@save:
$LN47@save:
$LN49@save:
$LN51@save:
$LN53@save:
$LN55@save:

; 3238 :     }
; 3239 : 
; 3240 :     /* XXX: This part needs some unit tests. */
; 3241 : 
; 3242 :     /* Get a reduction callable, and call it.  This may come from
; 3243 :      * self.dispatch_table, copyreg.dispatch_table, the object's
; 3244 :      * __reduce_ex__ method, or the object's __reduce__ method.
; 3245 :      */
; 3246 :     if (self->dispatch_table == NULL) {

  0036b	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00370	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00375	75 30		 jne	 SHORT $LN39@save

; 3247 :         reduce_func = PyDict_GetItem(dispatch_table, (PyObject *)type);

  00377	48 8b 54 24 20	 mov	 rdx, QWORD PTR type$[rsp]
  0037c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dispatch_table
  00383	e8 00 00 00 00	 call	 PyDict_GetItem
  00388	48 89 44 24 28	 mov	 QWORD PTR reduce_func$[rsp], rax
$LN38@save:

; 3248 :         /* PyDict_GetItem() unlike PyObject_GetItem() and
; 3249 :            PyObject_GetAttr() returns a borrowed ref */
; 3250 :         Py_XINCREF(reduce_func);

  0038d	48 83 7c 24 28
	00		 cmp	 QWORD PTR reduce_func$[rsp], 0
  00393	74 0a		 je	 SHORT $LN35@save
  00395	48 8b 4c 24 28	 mov	 rcx, QWORD PTR reduce_func$[rsp]
  0039a	e8 00 00 00 00	 call	 _Py_IncRef
$LN35@save:
  0039f	33 c0		 xor	 eax, eax
  003a1	85 c0		 test	 eax, eax
  003a3	75 e8		 jne	 SHORT $LN38@save

; 3251 :     } else {

  003a5	eb 3c		 jmp	 SHORT $LN34@save
$LN39@save:

; 3252 :         reduce_func = PyObject_GetItem(self->dispatch_table, (PyObject *)type);

  003a7	48 8b 54 24 20	 mov	 rdx, QWORD PTR type$[rsp]
  003ac	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  003b1	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  003b5	e8 00 00 00 00	 call	 PyObject_GetItem
  003ba	48 89 44 24 28	 mov	 QWORD PTR reduce_func$[rsp], rax

; 3253 :         if (reduce_func == NULL) {

  003bf	48 83 7c 24 28
	00		 cmp	 QWORD PTR reduce_func$[rsp], 0
  003c5	75 1c		 jne	 SHORT $LN33@save

; 3254 :             if (PyErr_ExceptionMatches(PyExc_KeyError))

  003c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  003ce	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  003d3	85 c0		 test	 eax, eax
  003d5	74 07		 je	 SHORT $LN32@save

; 3255 :                 PyErr_Clear();

  003d7	e8 00 00 00 00	 call	 PyErr_Clear

; 3256 :             else

  003dc	eb 05		 jmp	 SHORT $LN31@save
$LN32@save:

; 3257 :                 goto error;

  003de	e9 0b 02 00 00	 jmp	 $error$22650
$LN31@save:
$LN33@save:
$LN34@save:

; 3258 :         }
; 3259 :     }
; 3260 :     if (reduce_func != NULL) {

  003e3	48 83 7c 24 28
	00		 cmp	 QWORD PTR reduce_func$[rsp], 0
  003e9	74 28		 je	 SHORT $LN30@save

; 3261 :         Py_INCREF(obj);

  003eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$[rsp]
  003f0	e8 00 00 00 00	 call	 _Py_IncRef

; 3262 :         reduce_value = _Pickler_FastCall(self, reduce_func, obj);

  003f5	4c 8b 44 24 78	 mov	 r8, QWORD PTR obj$[rsp]
  003fa	48 8b 54 24 28	 mov	 rdx, QWORD PTR reduce_func$[rsp]
  003ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00404	e8 00 00 00 00	 call	 _Pickler_FastCall
  00409	48 89 44 24 30	 mov	 QWORD PTR reduce_value$[rsp], rax
  0040e	e9 54 01 00 00	 jmp	 $LN29@save
$LN30@save:

; 3263 :     }
; 3264 :     else if (PyType_IsSubtype(type, &PyType_Type)) {

  00413	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyType_Type
  0041a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR type$[rsp]
  0041f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00424	85 c0		 test	 eax, eax
  00426	74 20		 je	 SHORT $LN28@save

; 3265 :         status = save_global(self, obj, NULL);

  00428	45 33 c0	 xor	 r8d, r8d
  0042b	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  00430	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00435	e8 00 00 00 00	 call	 save_global
  0043a	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3266 :         goto done;

  0043e	e9 b3 01 00 00	 jmp	 $done$22632

; 3267 :     }
; 3268 :     else {

  00443	e9 1f 01 00 00	 jmp	 $LN27@save
$LN28@save:

; 3269 :         static PyObject *reduce_str = NULL;
; 3270 :         static PyObject *reduce_ex_str = NULL;
; 3271 : 
; 3272 :         /* Cache the name of the reduce methods. */
; 3273 :         if (reduce_str == NULL) {

  00448	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?reduce_str@?BL@??save@@9@9, 0
  00450	75 44		 jne	 SHORT $LN26@save

; 3274 :             reduce_str = PyUnicode_InternFromString("__reduce__");

  00452	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
  00459	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0045e	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?reduce_str@?BL@??save@@9@9, rax

; 3275 :             if (reduce_str == NULL)

  00465	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?reduce_str@?BL@??save@@9@9, 0
  0046d	75 05		 jne	 SHORT $LN25@save

; 3276 :                 goto error;

  0046f	e9 7a 01 00 00	 jmp	 $error$22650
$LN25@save:

; 3277 :             reduce_ex_str = PyUnicode_InternFromString("__reduce_ex__");

  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
  0047b	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00480	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?reduce_ex_str@?BL@??save@@9@9, rax

; 3278 :             if (reduce_ex_str == NULL)

  00487	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?reduce_ex_str@?BL@??save@@9@9, 0
  0048f	75 05		 jne	 SHORT $LN24@save

; 3279 :                 goto error;

  00491	e9 58 01 00 00	 jmp	 $error$22650
$LN24@save:
$LN26@save:

; 3280 :         }
; 3281 : 
; 3282 :         /* XXX: If the __reduce__ method is defined, __reduce_ex__ is
; 3283 :            automatically defined as __reduce__. While this is convenient, this
; 3284 :            make it impossible to know which method was actually called. Of
; 3285 :            course, this is not a big deal. But still, it would be nice to let
; 3286 :            the user know which method was called when something go
; 3287 :            wrong. Incidentally, this means if __reduce_ex__ is not defined, we
; 3288 :            don't actually have to check for a __reduce__ method. */
; 3289 : 
; 3290 :         /* Check for a __reduce_ex__ method. */
; 3291 :         reduce_func = PyObject_GetAttr(obj, reduce_ex_str);

  00496	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?reduce_ex_str@?BL@??save@@9@9
  0049d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$[rsp]
  004a2	e8 00 00 00 00	 call	 PyObject_GetAttr
  004a7	48 89 44 24 28	 mov	 QWORD PTR reduce_func$[rsp], rax

; 3292 :         if (reduce_func != NULL) {

  004ac	48 83 7c 24 28
	00		 cmp	 QWORD PTR reduce_func$[rsp], 0
  004b2	74 38		 je	 SHORT $LN23@save

; 3293 :             PyObject *proto;
; 3294 :             proto = PyLong_FromLong(self->proto);

  004b4	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  004b9	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  004bf	e8 00 00 00 00	 call	 PyLong_FromLong
  004c4	48 89 44 24 40	 mov	 QWORD PTR proto$22707[rsp], rax

; 3295 :             if (proto != NULL) {

  004c9	48 83 7c 24 40
	00		 cmp	 QWORD PTR proto$22707[rsp], 0
  004cf	74 19		 je	 SHORT $LN22@save

; 3296 :                 reduce_value = _Pickler_FastCall(self, reduce_func, proto);

  004d1	4c 8b 44 24 40	 mov	 r8, QWORD PTR proto$22707[rsp]
  004d6	48 8b 54 24 28	 mov	 rdx, QWORD PTR reduce_func$[rsp]
  004db	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  004e0	e8 00 00 00 00	 call	 _Pickler_FastCall
  004e5	48 89 44 24 30	 mov	 QWORD PTR reduce_value$[rsp], rax
$LN22@save:

; 3297 :             }
; 3298 :         }
; 3299 :         else {

  004ea	eb 7b		 jmp	 SHORT $LN21@save
$LN23@save:

; 3300 :             if (PyErr_ExceptionMatches(PyExc_AttributeError))

  004ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  004f3	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  004f8	85 c0		 test	 eax, eax
  004fa	74 07		 je	 SHORT $LN20@save

; 3301 :                 PyErr_Clear();

  004fc	e8 00 00 00 00	 call	 PyErr_Clear

; 3302 :             else

  00501	eb 05		 jmp	 SHORT $LN19@save
$LN20@save:

; 3303 :                 goto error;

  00503	e9 e6 00 00 00	 jmp	 $error$22650
$LN19@save:

; 3304 :             /* Check for a __reduce__ method. */
; 3305 :             reduce_func = PyObject_GetAttr(obj, reduce_str);

  00508	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?reduce_str@?BL@??save@@9@9
  0050f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$[rsp]
  00514	e8 00 00 00 00	 call	 PyObject_GetAttr
  00519	48 89 44 24 28	 mov	 QWORD PTR reduce_func$[rsp], rax

; 3306 :             if (reduce_func != NULL) {

  0051e	48 83 7c 24 28
	00		 cmp	 QWORD PTR reduce_func$[rsp], 0
  00524	74 1b		 je	 SHORT $LN18@save

; 3307 :                 reduce_value = PyObject_Call(reduce_func, empty_tuple, NULL);

  00526	45 33 c0	 xor	 r8d, r8d
  00529	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR empty_tuple
  00530	48 8b 4c 24 28	 mov	 rcx, QWORD PTR reduce_func$[rsp]
  00535	e8 00 00 00 00	 call	 PyObject_Call
  0053a	48 89 44 24 30	 mov	 QWORD PTR reduce_value$[rsp], rax

; 3308 :             }
; 3309 :             else {

  0053f	eb 26		 jmp	 SHORT $LN17@save
$LN18@save:

; 3310 :                 PyErr_Format(PicklingError, "can't pickle '%.200s' object: %R",
; 3311 :                              type->tp_name, obj);

  00541	4c 8b 4c 24 78	 mov	 r9, QWORD PTR obj$[rsp]
  00546	48 8b 44 24 20	 mov	 rax, QWORD PTR type$[rsp]
  0054b	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0054f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@HIPCBBLL@can?8t?5pickle?5?8?$CF?4200s?8?5object?3?5?$CFR@
  00556	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0055d	e8 00 00 00 00	 call	 PyErr_Format

; 3312 :                 goto error;

  00562	e9 87 00 00 00	 jmp	 $error$22650
$LN17@save:
$LN21@save:
$LN27@save:
$LN29@save:

; 3313 :             }
; 3314 :         }
; 3315 :     }
; 3316 : 
; 3317 :     if (reduce_value == NULL)

  00567	48 83 7c 24 30
	00		 cmp	 QWORD PTR reduce_value$[rsp], 0
  0056d	75 02		 jne	 SHORT $LN16@save

; 3318 :         goto error;

  0056f	eb 7d		 jmp	 SHORT $error$22650
$LN16@save:

; 3319 : 
; 3320 :     if (PyUnicode_Check(reduce_value)) {

  00571	48 8b 44 24 30	 mov	 rax, QWORD PTR reduce_value$[rsp]
  00576	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0057a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00580	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00585	85 c0		 test	 eax, eax
  00587	74 1a		 je	 SHORT $LN15@save

; 3321 :         status = save_global(self, obj, reduce_value);

  00589	4c 8b 44 24 30	 mov	 r8, QWORD PTR reduce_value$[rsp]
  0058e	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  00593	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00598	e8 00 00 00 00	 call	 save_global
  0059d	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3322 :         goto done;

  005a1	eb 53		 jmp	 SHORT $done$22632
$LN15@save:

; 3323 :     }
; 3324 : 
; 3325 :     if (!PyTuple_Check(reduce_value)) {

  005a3	48 8b 44 24 30	 mov	 rax, QWORD PTR reduce_value$[rsp]
  005a8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005ac	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005b2	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  005b7	85 c0		 test	 eax, eax
  005b9	75 15		 jne	 SHORT $LN14@save

; 3326 :         PyErr_SetString(PicklingError,
; 3327 :                         "__reduce__ must return a string or tuple");

  005bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@NPKDNCPF@__reduce__?5must?5return?5a?5string?5@
  005c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  005c9	e8 00 00 00 00	 call	 PyErr_SetString

; 3328 :         goto error;

  005ce	eb 1e		 jmp	 SHORT $error$22650
$LN14@save:

; 3329 :     }
; 3330 : 
; 3331 :     status = save_reduce(self, reduce_value, obj);

  005d0	4c 8b 44 24 78	 mov	 r8, QWORD PTR obj$[rsp]
  005d5	48 8b 54 24 30	 mov	 rdx, QWORD PTR reduce_value$[rsp]
  005da	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  005df	e8 00 00 00 00	 call	 save_reduce
  005e4	89 44 24 38	 mov	 DWORD PTR status$[rsp], eax

; 3332 : 
; 3333 :     if (0) {

  005e8	33 c0		 xor	 eax, eax
  005ea	85 c0		 test	 eax, eax
  005ec	74 08		 je	 SHORT $LN13@save
$error$22650:

; 3334 :   error:
; 3335 :         status = -1;

  005ee	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1
$LN13@save:
$done$22632:
$LN12@save:

; 3336 :     }
; 3337 :   done:
; 3338 :     Py_LeaveRecursiveCall();

  005f6	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  005fd	7e 0f		 jle	 SHORT $LN76@save
  005ff	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00605	83 e8 32	 sub	 eax, 50			; 00000032H
  00608	89 44 24 50	 mov	 DWORD PTR tv279[rsp], eax
  0060c	eb 10		 jmp	 SHORT $LN77@save
$LN76@save:
  0060e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00614	c1 f8 02	 sar	 eax, 2
  00617	6b c0 03	 imul	 eax, 3
  0061a	89 44 24 50	 mov	 DWORD PTR tv279[rsp], eax
$LN77@save:
  0061e	e8 00 00 00 00	 call	 PyThreadState_Get
  00623	48 83 c0 18	 add	 rax, 24
  00627	48 89 44 24 58	 mov	 QWORD PTR tv273[rsp], rax
  0062c	48 8b 44 24 58	 mov	 rax, QWORD PTR tv273[rsp]
  00631	8b 00		 mov	 eax, DWORD PTR [rax]
  00633	ff c8		 dec	 eax
  00635	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv273[rsp]
  0063a	89 01		 mov	 DWORD PTR [rcx], eax
  0063c	48 8b 44 24 58	 mov	 rax, QWORD PTR tv273[rsp]
  00641	8b 4c 24 50	 mov	 ecx, DWORD PTR tv279[rsp]
  00645	39 08		 cmp	 DWORD PTR [rax], ecx
  00647	7d 09		 jge	 SHORT $LN9@save
  00649	e8 00 00 00 00	 call	 PyThreadState_Get
  0064e	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN9@save:
  00652	33 c0		 xor	 eax, eax
  00654	85 c0		 test	 eax, eax
  00656	75 9e		 jne	 SHORT $LN12@save
$LN8@save:

; 3339 :     Py_XDECREF(reduce_func);

  00658	48 83 7c 24 28
	00		 cmp	 QWORD PTR reduce_func$[rsp], 0
  0065e	74 0a		 je	 SHORT $LN5@save
  00660	48 8b 4c 24 28	 mov	 rcx, QWORD PTR reduce_func$[rsp]
  00665	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@save:
  0066a	33 c0		 xor	 eax, eax
  0066c	85 c0		 test	 eax, eax
  0066e	75 e8		 jne	 SHORT $LN8@save
$LN4@save:

; 3340 :     Py_XDECREF(reduce_value);

  00670	48 83 7c 24 30
	00		 cmp	 QWORD PTR reduce_value$[rsp], 0
  00676	74 0a		 je	 SHORT $LN1@save
  00678	48 8b 4c 24 30	 mov	 rcx, QWORD PTR reduce_value$[rsp]
  0067d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@save:
  00682	33 c0		 xor	 eax, eax
  00684	85 c0		 test	 eax, eax
  00686	75 e8		 jne	 SHORT $LN4@save

; 3341 : 
; 3342 :     return status;

  00688	8b 44 24 38	 mov	 eax, DWORD PTR status$[rsp]
$LN74@save:

; 3343 : }

  0068c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00690	c3		 ret	 0
save	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoTable_Get DD imagerel PyMemoTable_Get
	DD	imagerel PyMemoTable_Get+63
	DD	imagerel $unwind$PyMemoTable_Get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_Get DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMemoTable_Get
_TEXT	SEGMENT
entry$ = 32
self$ = 64
key$ = 72
PyMemoTable_Get PROC					; COMDAT

; 562  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 563  :     PyMemoEntry *entry = _PyMemoTable_Lookup(self, key);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00018	e8 00 00 00 00	 call	 _PyMemoTable_Lookup
  0001d	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 564  :     if (entry->me_key == NULL)

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00027	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0002b	75 04		 jne	 SHORT $LN1@PyMemoTabl@2

; 565  :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 09		 jmp	 SHORT $LN2@PyMemoTabl@2
$LN1@PyMemoTabl@2:

; 566  :     return &entry->me_value;

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00036	48 83 c0 08	 add	 rax, 8
$LN2@PyMemoTabl@2:

; 567  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
PyMemoTable_Get ENDP
_TEXT	ENDS
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyMemoTable_Lookup DD imagerel _PyMemoTable_Lookup
	DD	imagerel _PyMemoTable_Lookup+304
	DD	imagerel $unwind$_PyMemoTable_Lookup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyMemoTable_Lookup DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyMemoTable_Lookup
_TEXT	SEGMENT
i$ = 32
mask$ = 40
perturb$ = 48
table$ = 56
hash$ = 64
entry$ = 72
self$ = 96
key$ = 104
_PyMemoTable_Lookup PROC				; COMDAT

; 484  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 485  :     size_t i;
; 486  :     size_t perturb;
; 487  :     size_t mask = (size_t)self->mt_mask;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax

; 488  :     PyMemoEntry *table = self->mt_table;

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00024	48 89 44 24 38	 mov	 QWORD PTR table$[rsp], rax

; 489  :     PyMemoEntry *entry;
; 490  :     Py_hash_t hash = (Py_hash_t)key >> 3;

  00029	48 8b 44 24 68	 mov	 rax, QWORD PTR key$[rsp]
  0002e	48 c1 f8 03	 sar	 rax, 3
  00032	48 89 44 24 40	 mov	 QWORD PTR hash$[rsp], rax

; 491  : 
; 492  :     i = hash & mask;

  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hash$[rsp]
  00041	48 23 c8	 and	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 493  :     entry = &table[i];

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00051	48 6b c0 10	 imul	 rax, 16
  00055	48 8b 4c 24 38	 mov	 rcx, QWORD PTR table$[rsp]
  0005a	48 03 c8	 add	 rcx, rax
  0005d	48 8b c1	 mov	 rax, rcx
  00060	48 89 44 24 48	 mov	 QWORD PTR entry$[rsp], rax

; 494  :     if (entry->me_key == NULL || entry->me_key == key)

  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  0006a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006e	74 0f		 je	 SHORT $LN6@PyMemoTabl@3
  00070	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR key$[rsp]
  0007a	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0007d	75 0a		 jne	 SHORT $LN7@PyMemoTabl@3
$LN6@PyMemoTabl@3:

; 495  :         return entry;

  0007f	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  00084	e9 a2 00 00 00	 jmp	 $LN8@PyMemoTabl@3
$LN7@PyMemoTabl@3:

; 496  : 
; 497  :     for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR hash$[rsp]
  0008e	48 89 44 24 30	 mov	 QWORD PTR perturb$[rsp], rax
  00093	eb 0e		 jmp	 SHORT $LN5@PyMemoTabl@3
$LN4@PyMemoTabl@3:
  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR perturb$[rsp]
  0009a	48 c1 e8 05	 shr	 rax, 5
  0009e	48 89 44 24 30	 mov	 QWORD PTR perturb$[rsp], rax
$LN5@PyMemoTabl@3:

; 498  :         i = (i << 2) + i + perturb + 1;

  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000a8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000ad	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  000b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR perturb$[rsp]
  000b6	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  000bb	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 499  :         entry = &table[i & mask];

  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$[rsp]
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000ca	48 23 c8	 and	 rcx, rax
  000cd	48 8b c1	 mov	 rax, rcx
  000d0	48 6b c0 10	 imul	 rax, 16
  000d4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR table$[rsp]
  000d9	48 03 c8	 add	 rcx, rax
  000dc	48 8b c1	 mov	 rax, rcx
  000df	48 89 44 24 48	 mov	 QWORD PTR entry$[rsp], rax

; 500  :         if (entry->me_key == NULL || entry->me_key == key)

  000e4	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  000e9	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000ed	74 0f		 je	 SHORT $LN1@PyMemoTabl@3
  000ef	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  000f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR key$[rsp]
  000f9	48 39 08	 cmp	 QWORD PTR [rax], rcx
  000fc	75 07		 jne	 SHORT $LN2@PyMemoTabl@3
$LN1@PyMemoTabl@3:

; 501  :             return entry;

  000fe	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  00103	eb 26		 jmp	 SHORT $LN8@PyMemoTabl@3
$LN2@PyMemoTabl@3:

; 502  :     }

  00105	eb 8e		 jmp	 SHORT $LN4@PyMemoTabl@3

; 503  :     assert(0);  /* Never reached */

  00107	33 c0		 xor	 eax, eax
  00109	85 c0		 test	 eax, eax
  0010b	75 1c		 jne	 SHORT $LN10@PyMemoTabl@3
  0010d	41 b8 f7 01 00
	00		 mov	 r8d, 503		; 000001f7H
  00113	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00127	33 c0		 xor	 eax, eax
$LN10@PyMemoTabl@3:

; 504  :     return NULL;

  00129	33 c0		 xor	 eax, eax
$LN8@PyMemoTabl@3:

; 505  : }

  0012b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0012f	c3		 ret	 0
_PyMemoTable_Lookup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@JBGEENKP@memo?5id?5too?5large?5for?5LONG_BINGE@ ; `string'
PUBLIC	??_C@_04GDNBDEFH@?$CFId?6?$AA@			; `string'
EXTRN	strlen:PROC
EXTRN	PyOS_snprintf:PROC
EXTRN	PyErr_SetObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memo_get DD imagerel memo_get
	DD	imagerel memo_get+376
	DD	imagerel $unwind$memo_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memo_get DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0CC@JBGEENKP@memo?5id?5too?5large?5for?5LONG_BINGE@
CONST	SEGMENT
??_C@_0CC@JBGEENKP@memo?5id?5too?5large?5for?5LONG_BINGE@ DB 'memo id too'
	DB	' large for LONG_BINGET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GDNBDEFH@?$CFId?6?$AA@
CONST	SEGMENT
??_C@_04GDNBDEFH@?$CFId?6?$AA@ DB '%Id', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memo_get
_TEXT	SEGMENT
value$ = 32
pdata$ = 40
len$ = 72
self$ = 96
key$ = 104
memo_get PROC						; COMDAT

; 1228 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1229 :     Py_ssize_t *value;
; 1230 :     char pdata[30];
; 1231 :     Py_ssize_t len;
; 1232 : 
; 1233 :     value = PyMemoTable_Get(self->memo, key);

  0000e	48 8b 54 24 68	 mov	 rdx, QWORD PTR key$[rsp]
  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0001c	e8 00 00 00 00	 call	 PyMemoTable_Get
  00021	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 1234 :     if (value == NULL)  {

  00026	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  0002c	75 1b		 jne	 SHORT $LN8@memo_get

; 1235 :         PyErr_SetObject(PyExc_KeyError, key);

  0002e	48 8b 54 24 68	 mov	 rdx, QWORD PTR key$[rsp]
  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  0003a	e8 00 00 00 00	 call	 PyErr_SetObject

; 1236 :         return -1;

  0003f	b8 ff ff ff ff	 mov	 eax, -1
  00044	e9 2a 01 00 00	 jmp	 $LN9@memo_get
$LN8@memo_get:

; 1237 :     }
; 1238 : 
; 1239 :     if (!self->bin) {

  00049	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0004e	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [rax+164], 0
  00055	75 3a		 jne	 SHORT $LN7@memo_get

; 1240 :         pdata[0] = GET;

  00057	c6 44 24 28 67	 mov	 BYTE PTR pdata$[rsp], 103 ; 00000067H

; 1241 :         PyOS_snprintf(pdata + 1, sizeof(pdata) - 1,
; 1242 :                       "%" PY_FORMAT_SIZE_T "d\n", *value);

  0005c	48 8d 44 24 29	 lea	 rax, QWORD PTR pdata$[rsp+1]
  00061	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00066	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00069	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04GDNBDEFH@?$CFId?6?$AA@
  00070	ba 1d 00 00 00	 mov	 edx, 29
  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 PyOS_snprintf

; 1243 :         len = strlen(pdata);

  0007d	48 8d 4c 24 28	 lea	 rcx, QWORD PTR pdata$[rsp]
  00082	e8 00 00 00 00	 call	 strlen
  00087	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax

; 1244 :     }
; 1245 :     else {

  0008c	e9 c0 00 00 00	 jmp	 $LN6@memo_get
$LN7@memo_get:

; 1246 :         if (*value < 256) {

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  00096	48 81 38 00 01
	00 00		 cmp	 QWORD PTR [rax], 256	; 00000100H
  0009d	7d 25		 jge	 SHORT $LN5@memo_get

; 1247 :             pdata[0] = BINGET;

  0009f	c6 44 24 28 68	 mov	 BYTE PTR pdata$[rsp], 104 ; 00000068H

; 1248 :             pdata[1] = (unsigned char)(*value & 0xff);

  000a4	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  000a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ac	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  000b2	88 44 24 29	 mov	 BYTE PTR pdata$[rsp+1], al

; 1249 :             len = 2;

  000b6	48 c7 44 24 48
	02 00 00 00	 mov	 QWORD PTR len$[rsp], 2
  000bf	e9 8d 00 00 00	 jmp	 $LN4@memo_get
$LN5@memo_get:

; 1250 :         }
; 1251 :         else if (*value <= 0xffffffffL) {

  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  000c9	b9 ff ff ff ff	 mov	 ecx, -1
  000ce	48 39 08	 cmp	 QWORD PTR [rax], rcx
  000d1	7f 64		 jg	 SHORT $LN3@memo_get

; 1252 :             pdata[0] = LONG_BINGET;

  000d3	c6 44 24 28 6a	 mov	 BYTE PTR pdata$[rsp], 106 ; 0000006aH

; 1253 :             pdata[1] = (unsigned char)(*value & 0xff);

  000d8	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  000dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e0	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  000e6	88 44 24 29	 mov	 BYTE PTR pdata$[rsp+1], al

; 1254 :             pdata[2] = (unsigned char)((*value >> 8) & 0xff);

  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  000ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f2	48 c1 f8 08	 sar	 rax, 8
  000f6	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  000fc	88 44 24 2a	 mov	 BYTE PTR pdata$[rsp+2], al

; 1255 :             pdata[3] = (unsigned char)((*value >> 16) & 0xff);

  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  00105	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00108	48 c1 f8 10	 sar	 rax, 16
  0010c	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00112	88 44 24 2b	 mov	 BYTE PTR pdata$[rsp+3], al

; 1256 :             pdata[4] = (unsigned char)((*value >> 24) & 0xff);

  00116	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  0011b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011e	48 c1 f8 18	 sar	 rax, 24
  00122	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00128	88 44 24 2c	 mov	 BYTE PTR pdata$[rsp+4], al

; 1257 :             len = 5;

  0012c	48 c7 44 24 48
	05 00 00 00	 mov	 QWORD PTR len$[rsp], 5

; 1258 :         }
; 1259 :         else { /* unlikely */

  00135	eb 1a		 jmp	 SHORT $LN2@memo_get
$LN3@memo_get:

; 1260 :             PyErr_SetString(PicklingError,
; 1261 :                             "memo id too large for LONG_BINGET");

  00137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@JBGEENKP@memo?5id?5too?5large?5for?5LONG_BINGE@
  0013e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  00145	e8 00 00 00 00	 call	 PyErr_SetString

; 1262 :             return -1;

  0014a	b8 ff ff ff ff	 mov	 eax, -1
  0014f	eb 22		 jmp	 SHORT $LN9@memo_get
$LN2@memo_get:
$LN4@memo_get:
$LN6@memo_get:

; 1263 :         }
; 1264 :     }
; 1265 : 
; 1266 :     if (_Pickler_Write(self, pdata, len) < 0)

  00151	4c 8b 44 24 48	 mov	 r8, QWORD PTR len$[rsp]
  00156	48 8d 54 24 28	 lea	 rdx, QWORD PTR pdata$[rsp]
  0015b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00160	e8 00 00 00 00	 call	 _Pickler_Write
  00165	48 85 c0	 test	 rax, rax
  00168	7d 07		 jge	 SHORT $LN1@memo_get

; 1267 :         return -1;

  0016a	b8 ff ff ff ff	 mov	 eax, -1
  0016f	eb 02		 jmp	 SHORT $LN9@memo_get
$LN1@memo_get:

; 1268 : 
; 1269 :     return 0;

  00171	33 c0		 xor	 eax, eax
$LN9@memo_get:

; 1270 : }

  00173	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00177	c3		 ret	 0
memo_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_none DD imagerel save_none
	DD	imagerel save_none+59
	DD	imagerel $unwind$save_none
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_none DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT save_none
_TEXT	SEGMENT
none_op$ = 32
self$ = 64
obj$ = 72
save_none PROC						; COMDAT

; 1464 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1465 :     const char none_op = NONE;

  0000e	c6 44 24 20 4e	 mov	 BYTE PTR none_op$[rsp], 78 ; 0000004eH

; 1466 :     if (_Pickler_Write(self, &none_op, 1) < 0)

  00013	41 b8 01 00 00
	00		 mov	 r8d, 1
  00019	48 8d 54 24 20	 lea	 rdx, QWORD PTR none_op$[rsp]
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00023	e8 00 00 00 00	 call	 _Pickler_Write
  00028	48 85 c0	 test	 rax, rax
  0002b	7d 07		 jge	 SHORT $LN1@save_none

; 1467 :         return -1;

  0002d	b8 ff ff ff ff	 mov	 eax, -1
  00032	eb 02		 jmp	 SHORT $LN2@save_none
$LN1@save_none:

; 1468 : 
; 1469 :     return 0;

  00034	33 c0		 xor	 eax, eax
$LN2@save_none:

; 1470 : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
save_none ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_bool DD imagerel save_bool
	DD	imagerel save_bool+206
	DD	imagerel $unwind$save_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_bool DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT save_bool
_TEXT	SEGMENT
p$ = 32
len$ = 36
bool_op$21471 = 40
tv65 = 44
tv69 = 48
self$ = 80
obj$ = 88
save_bool PROC						; COMDAT

; 1474 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1475 :     static const char *buf[2] = { FALSE, TRUE };
; 1476 :     const char len[2] = {sizeof(FALSE) - 1, sizeof(TRUE) - 1};

  0000e	c6 44 24 24 04	 mov	 BYTE PTR len$[rsp], 4
  00013	c6 44 24 25 04	 mov	 BYTE PTR len$[rsp+1], 4

; 1477 :     int p = (obj == Py_True);

  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0001f	48 39 44 24 58	 cmp	 QWORD PTR obj$[rsp], rax
  00024	75 0a		 jne	 SHORT $LN7@save_bool
  00026	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0002e	eb 08		 jmp	 SHORT $LN8@save_bool
$LN7@save_bool:
  00030	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN8@save_bool:
  00038	8b 44 24 2c	 mov	 eax, DWORD PTR tv65[rsp]
  0003c	89 44 24 20	 mov	 DWORD PTR p$[rsp], eax

; 1478 : 
; 1479 :     if (self->proto >= 2) {

  00040	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00045	83 b8 a0 00 00
	00 02		 cmp	 DWORD PTR [rax+160], 2
  0004c	7c 45		 jl	 SHORT $LN4@save_bool

; 1480 :         const char bool_op = p ? NEWTRUE : NEWFALSE;

  0004e	83 7c 24 20 00	 cmp	 DWORD PTR p$[rsp], 0
  00053	74 0a		 je	 SHORT $LN9@save_bool
  00055	c7 44 24 30 88
	ff ff ff	 mov	 DWORD PTR tv69[rsp], -120 ; ffffffffffffff88H
  0005d	eb 08		 jmp	 SHORT $LN10@save_bool
$LN9@save_bool:
  0005f	c7 44 24 30 89
	ff ff ff	 mov	 DWORD PTR tv69[rsp], -119 ; ffffffffffffff89H
$LN10@save_bool:
  00067	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv69[rsp]
  0006c	88 44 24 28	 mov	 BYTE PTR bool_op$21471[rsp], al

; 1481 :         if (_Pickler_Write(self, &bool_op, 1) < 0)

  00070	41 b8 01 00 00
	00		 mov	 r8d, 1
  00076	48 8d 54 24 28	 lea	 rdx, QWORD PTR bool_op$21471[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00080	e8 00 00 00 00	 call	 _Pickler_Write
  00085	48 85 c0	 test	 rax, rax
  00088	7d 07		 jge	 SHORT $LN3@save_bool

; 1482 :             return -1;

  0008a	b8 ff ff ff ff	 mov	 eax, -1
  0008f	eb 38		 jmp	 SHORT $LN5@save_bool
$LN3@save_bool:

; 1483 :     }
; 1484 :     else if (_Pickler_Write(self, buf[p], len[p]) < 0)

  00091	eb 34		 jmp	 SHORT $LN2@save_bool
$LN4@save_bool:
  00093	48 63 44 24 20	 movsxd	 rax, DWORD PTR p$[rsp]
  00098	48 0f be 44 04
	24		 movsx	 rax, BYTE PTR len$[rsp+rax]
  0009e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR p$[rsp]
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?buf@?1??save_bool@@9@9
  000aa	4c 8b c0	 mov	 r8, rax
  000ad	48 8b 14 ca	 mov	 rdx, QWORD PTR [rdx+rcx*8]
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000b6	e8 00 00 00 00	 call	 _Pickler_Write
  000bb	48 85 c0	 test	 rax, rax
  000be	7d 07		 jge	 SHORT $LN1@save_bool

; 1485 :         return -1;

  000c0	b8 ff ff ff ff	 mov	 eax, -1
  000c5	eb 02		 jmp	 SHORT $LN5@save_bool
$LN1@save_bool:
$LN2@save_bool:

; 1486 : 
; 1487 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN5@save_bool:

; 1488 : }

  000c9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cd	c3		 ret	 0
save_bool ENDP
_TEXT	ENDS
PUBLIC	??_C@_02IDNBLKMD@L?6?$AA@			; `string'
PUBLIC	??_C@_1CI@INNPDOMC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BI@INABELJF@int?5too?5large?5to?5pickle?$AA@ ; `string'
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	PyObject_Repr:PROC
EXTRN	_PyLong_AsByteArray:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	_PyLong_NumBits:PROC
EXTRN	_PyLong_Sign:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_long DD imagerel save_long
	DD	imagerel save_long+914
	DD	imagerel $unwind$save_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_long DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_02IDNBLKMD@L?6?$AA@
CONST	SEGMENT
??_C@_02IDNBLKMD@L?6?$AA@ DB 'L', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@INNPDOMC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@INNPDOMC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'r', 00H, 'e', 00H, 'p', 00H, 'r', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@INABELJF@int?5too?5large?5to?5pickle?$AA@
CONST	SEGMENT
??_C@_0BI@INABELJF@int?5too?5large?5to?5pickle?$AA@ DB 'int too large to '
	DB	'pickle', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_long
_TEXT	SEGMENT
size$ = 48
val$ = 56
status$ = 60
repr$ = 64
long_op$ = 72
i$21515 = 76
pdata$21513 = 80
sign$21516 = 88
nbytes$21512 = 96
nbits$21511 = 104
header$21514 = 112
string$21549 = 120
self$ = 144
obj$ = 152
save_long PROC						; COMDAT

; 1540 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1541 :     PyObject *repr = NULL;

  00011	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR repr$[rsp], 0

; 1542 :     Py_ssize_t size;
; 1543 :     long val = PyLong_AsLong(obj);

  0001a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  00022	e8 00 00 00 00	 call	 PyLong_AsLong
  00027	89 44 24 38	 mov	 DWORD PTR val$[rsp], eax

; 1544 :     int status = 0;

  0002b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 1545 : 
; 1546 :     const char long_op = LONG;

  00033	c6 44 24 48 4c	 mov	 BYTE PTR long_op$[rsp], 76 ; 0000004cH

; 1547 : 
; 1548 :     if (val == -1 && PyErr_Occurred()) {

  00038	83 7c 24 38 ff	 cmp	 DWORD PTR val$[rsp], -1
  0003d	75 11		 jne	 SHORT $LN27@save_long
  0003f	e8 00 00 00 00	 call	 PyErr_Occurred
  00044	48 85 c0	 test	 rax, rax
  00047	74 07		 je	 SHORT $LN27@save_long

; 1549 :         /* out of range for int pickling */
; 1550 :         PyErr_Clear();

  00049	e8 00 00 00 00	 call	 PyErr_Clear

; 1551 :     }
; 1552 :     else

  0004e	eb 16		 jmp	 SHORT $LN26@save_long
$LN27@save_long:

; 1553 : #if SIZEOF_LONG > 4
; 1554 :         if (val <= 0x7fffffffL && val >= -0x80000000L)
; 1555 : #endif
; 1556 :             return save_int(self, val);

  00050	8b 54 24 38	 mov	 edx, DWORD PTR val$[rsp]
  00054	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	e8 00 00 00 00	 call	 save_int
  00061	e9 24 03 00 00	 jmp	 $LN28@save_long
$LN26@save_long:

; 1557 : 
; 1558 :     if (self->proto >= 2) {

  00066	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006e	83 b8 a0 00 00
	00 02		 cmp	 DWORD PTR [rax+160], 2
  00075	0f 8c 51 02 00
	00		 jl	 $LN25@save_long

; 1559 :         /* Linear-time pickling. */
; 1560 :         size_t nbits;
; 1561 :         size_t nbytes;
; 1562 :         unsigned char *pdata;
; 1563 :         char header[5];
; 1564 :         int i;
; 1565 :         int sign = _PyLong_Sign(obj);

  0007b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  00083	e8 00 00 00 00	 call	 _PyLong_Sign
  00088	89 44 24 58	 mov	 DWORD PTR sign$21516[rsp], eax

; 1566 : 
; 1567 :         if (sign == 0) {

  0008c	83 7c 24 58 00	 cmp	 DWORD PTR sign$21516[rsp], 0
  00091	75 33		 jne	 SHORT $LN24@save_long

; 1568 :             header[0] = LONG1;

  00093	c6 44 24 70 8a	 mov	 BYTE PTR header$21514[rsp], -118 ; ffffffffffffff8aH

; 1569 :             header[1] = 0;      /* It's 0 -- an empty bytestring. */

  00098	c6 44 24 71 00	 mov	 BYTE PTR header$21514[rsp+1], 0

; 1570 :             if (_Pickler_Write(self, header, 2) < 0)

  0009d	41 b8 02 00 00
	00		 mov	 r8d, 2
  000a3	48 8d 54 24 70	 lea	 rdx, QWORD PTR header$21514[rsp]
  000a8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000b0	e8 00 00 00 00	 call	 _Pickler_Write
  000b5	48 85 c0	 test	 rax, rax
  000b8	7d 05		 jge	 SHORT $LN23@save_long

; 1571 :                 goto error;

  000ba	e9 a7 02 00 00	 jmp	 $error$21519
$LN23@save_long:

; 1572 :             return 0;

  000bf	33 c0		 xor	 eax, eax
  000c1	e9 c4 02 00 00	 jmp	 $LN28@save_long
$LN24@save_long:

; 1573 :         }
; 1574 :         nbits = _PyLong_NumBits(obj);

  000c6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  000ce	e8 00 00 00 00	 call	 _PyLong_NumBits
  000d3	48 89 44 24 68	 mov	 QWORD PTR nbits$21511[rsp], rax

; 1575 :         if (nbits == (size_t)-1 && PyErr_Occurred())

  000d8	48 83 7c 24 68
	ff		 cmp	 QWORD PTR nbits$21511[rsp], -1
  000de	75 0f		 jne	 SHORT $LN22@save_long
  000e0	e8 00 00 00 00	 call	 PyErr_Occurred
  000e5	48 85 c0	 test	 rax, rax
  000e8	74 05		 je	 SHORT $LN22@save_long

; 1576 :             goto error;

  000ea	e9 77 02 00 00	 jmp	 $error$21519
$LN22@save_long:

; 1577 :         /* How many bytes do we need?  There are nbits >> 3 full
; 1578 :          * bytes of data, and nbits & 7 leftover bits.  If there
; 1579 :          * are any leftover bits, then we clearly need another
; 1580 :          * byte.  Wnat's not so obvious is that we *probably*
; 1581 :          * need another byte even if there aren't any leftovers:
; 1582 :          * the most-significant bit of the most-significant byte
; 1583 :          * acts like a sign bit, and it's usually got a sense
; 1584 :          * opposite of the one we need.  The exception is ints
; 1585 :          * of the form -(2**(8*j-1)) for j > 0.  Such an int is
; 1586 :          * its own 256's-complement, so has the right sign bit
; 1587 :          * even without the extra byte.  That's a pain to check
; 1588 :          * for in advance, though, so we always grab an extra
; 1589 :          * byte at the start, and cut it back later if possible.
; 1590 :          */
; 1591 :         nbytes = (nbits >> 3) + 1;

  000ef	48 8b 44 24 68	 mov	 rax, QWORD PTR nbits$21511[rsp]
  000f4	48 c1 e8 03	 shr	 rax, 3
  000f8	48 ff c0	 inc	 rax
  000fb	48 89 44 24 60	 mov	 QWORD PTR nbytes$21512[rsp], rax

; 1592 :         if (nbytes > 0x7fffffffL) {

  00100	48 81 7c 24 60
	ff ff ff 7f	 cmp	 QWORD PTR nbytes$21512[rsp], 2147483647 ; 7fffffffH
  00109	76 18		 jbe	 SHORT $LN21@save_long

; 1593 :             PyErr_SetString(PyExc_OverflowError,
; 1594 :                             "int too large to pickle");

  0010b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@INABELJF@int?5too?5large?5to?5pickle?$AA@
  00112	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00119	e8 00 00 00 00	 call	 PyErr_SetString

; 1595 :             goto error;

  0011e	e9 43 02 00 00	 jmp	 $error$21519
$LN21@save_long:

; 1596 :         }
; 1597 :         repr = PyBytes_FromStringAndSize(NULL, (Py_ssize_t)nbytes);

  00123	48 8b 54 24 60	 mov	 rdx, QWORD PTR nbytes$21512[rsp]
  00128	33 c9		 xor	 ecx, ecx
  0012a	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0012f	48 89 44 24 40	 mov	 QWORD PTR repr$[rsp], rax

; 1598 :         if (repr == NULL)

  00134	48 83 7c 24 40
	00		 cmp	 QWORD PTR repr$[rsp], 0
  0013a	75 05		 jne	 SHORT $LN20@save_long

; 1599 :             goto error;

  0013c	e9 25 02 00 00	 jmp	 $error$21519
$LN20@save_long:

; 1600 :         pdata = (unsigned char *)PyBytes_AS_STRING(repr);

  00141	48 8b 44 24 40	 mov	 rax, QWORD PTR repr$[rsp]
  00146	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0014a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00150	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00155	85 c0		 test	 eax, eax
  00157	75 1c		 jne	 SHORT $LN30@save_long
  00159	41 b8 40 06 00
	00		 mov	 r8d, 1600		; 00000640H
  0015f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@INNPDOMC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00173	33 c0		 xor	 eax, eax
$LN30@save_long:
  00175	48 8b 44 24 40	 mov	 rax, QWORD PTR repr$[rsp]
  0017a	48 83 c0 78	 add	 rax, 120		; 00000078H
  0017e	48 89 44 24 50	 mov	 QWORD PTR pdata$21513[rsp], rax

; 1601 :         i = _PyLong_AsByteArray((PyLongObject *)obj,
; 1602 :                                 pdata, nbytes,
; 1603 :                                 1 /* little endian */ , 1 /* signed */ );

  00183	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0018b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00191	4c 8b 44 24 60	 mov	 r8, QWORD PTR nbytes$21512[rsp]
  00196	48 8b 54 24 50	 mov	 rdx, QWORD PTR pdata$21513[rsp]
  0019b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  001a3	e8 00 00 00 00	 call	 _PyLong_AsByteArray
  001a8	89 44 24 4c	 mov	 DWORD PTR i$21515[rsp], eax

; 1604 :         if (i < 0)

  001ac	83 7c 24 4c 00	 cmp	 DWORD PTR i$21515[rsp], 0
  001b1	7d 05		 jge	 SHORT $LN19@save_long

; 1605 :             goto error;

  001b3	e9 ae 01 00 00	 jmp	 $error$21519
$LN19@save_long:

; 1606 :         /* If the int is negative, this may be a byte more than
; 1607 :          * needed.  This is so iff the MSB is all redundant sign
; 1608 :          * bits.
; 1609 :          */
; 1610 :         if (sign < 0 &&
; 1611 :             nbytes > 1 &&
; 1612 :             pdata[nbytes - 1] == 0xff &&
; 1613 :             (pdata[nbytes - 2] & 0x80) != 0) {

  001b8	83 7c 24 58 00	 cmp	 DWORD PTR sign$21516[rsp], 0
  001bd	7d 4d		 jge	 SHORT $LN18@save_long
  001bf	48 83 7c 24 60
	01		 cmp	 QWORD PTR nbytes$21512[rsp], 1
  001c5	76 45		 jbe	 SHORT $LN18@save_long
  001c7	48 8b 44 24 60	 mov	 rax, QWORD PTR nbytes$21512[rsp]
  001cc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pdata$21513[rsp]
  001d1	48 03 c8	 add	 rcx, rax
  001d4	48 8b c1	 mov	 rax, rcx
  001d7	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  001db	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001e0	75 2a		 jne	 SHORT $LN18@save_long
  001e2	48 8b 44 24 60	 mov	 rax, QWORD PTR nbytes$21512[rsp]
  001e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pdata$21513[rsp]
  001ec	48 03 c8	 add	 rcx, rax
  001ef	48 8b c1	 mov	 rax, rcx
  001f2	0f b6 40 fe	 movzx	 eax, BYTE PTR [rax-2]
  001f6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001fb	85 c0		 test	 eax, eax
  001fd	74 0d		 je	 SHORT $LN18@save_long

; 1614 :             nbytes--;

  001ff	48 8b 44 24 60	 mov	 rax, QWORD PTR nbytes$21512[rsp]
  00204	48 ff c8	 dec	 rax
  00207	48 89 44 24 60	 mov	 QWORD PTR nbytes$21512[rsp], rax
$LN18@save_long:

; 1615 :         }
; 1616 : 
; 1617 :         if (nbytes < 256) {

  0020c	48 81 7c 24 60
	00 01 00 00	 cmp	 QWORD PTR nbytes$21512[rsp], 256 ; 00000100H
  00215	73 19		 jae	 SHORT $LN17@save_long

; 1618 :             header[0] = LONG1;

  00217	c6 44 24 70 8a	 mov	 BYTE PTR header$21514[rsp], -118 ; ffffffffffffff8aH

; 1619 :             header[1] = (unsigned char)nbytes;

  0021c	0f b6 44 24 60	 movzx	 eax, BYTE PTR nbytes$21512[rsp]
  00221	88 44 24 71	 mov	 BYTE PTR header$21514[rsp+1], al

; 1620 :             size = 2;

  00225	48 c7 44 24 30
	02 00 00 00	 mov	 QWORD PTR size$[rsp], 2

; 1621 :         }
; 1622 :         else {

  0022e	eb 57		 jmp	 SHORT $LN16@save_long
$LN17@save_long:

; 1623 :             header[0] = LONG4;

  00230	c6 44 24 70 8b	 mov	 BYTE PTR header$21514[rsp], -117 ; ffffffffffffff8bH

; 1624 :             size = (Py_ssize_t) nbytes;

  00235	48 8b 44 24 60	 mov	 rax, QWORD PTR nbytes$21512[rsp]
  0023a	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 1625 :             for (i = 1; i < 5; i++) {

  0023f	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR i$21515[rsp], 1
  00247	eb 0a		 jmp	 SHORT $LN15@save_long
$LN14@save_long:
  00249	8b 44 24 4c	 mov	 eax, DWORD PTR i$21515[rsp]
  0024d	ff c0		 inc	 eax
  0024f	89 44 24 4c	 mov	 DWORD PTR i$21515[rsp], eax
$LN15@save_long:
  00253	83 7c 24 4c 05	 cmp	 DWORD PTR i$21515[rsp], 5
  00258	7d 24		 jge	 SHORT $LN13@save_long

; 1626 :                 header[i] = (unsigned char)(size & 0xff);

  0025a	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  0025f	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00265	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR i$21515[rsp]
  0026a	88 44 0c 70	 mov	 BYTE PTR header$21514[rsp+rcx], al

; 1627 :                 size >>= 8;

  0026e	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  00273	48 c1 f8 08	 sar	 rax, 8
  00277	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 1628 :             }

  0027c	eb cb		 jmp	 SHORT $LN14@save_long
$LN13@save_long:

; 1629 :             size = 5;

  0027e	48 c7 44 24 30
	05 00 00 00	 mov	 QWORD PTR size$[rsp], 5
$LN16@save_long:

; 1630 :         }
; 1631 :         if (_Pickler_Write(self, header, size) < 0 ||
; 1632 :             _Pickler_Write(self, (char *)pdata, (int)nbytes) < 0)

  00287	4c 8b 44 24 30	 mov	 r8, QWORD PTR size$[rsp]
  0028c	48 8d 54 24 70	 lea	 rdx, QWORD PTR header$21514[rsp]
  00291	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00299	e8 00 00 00 00	 call	 _Pickler_Write
  0029e	48 85 c0	 test	 rax, rax
  002a1	7c 1f		 jl	 SHORT $LN11@save_long
  002a3	48 63 44 24 60	 movsxd	 rax, DWORD PTR nbytes$21512[rsp]
  002a8	4c 8b c0	 mov	 r8, rax
  002ab	48 8b 54 24 50	 mov	 rdx, QWORD PTR pdata$21513[rsp]
  002b0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002b8	e8 00 00 00 00	 call	 _Pickler_Write
  002bd	48 85 c0	 test	 rax, rax
  002c0	7d 05		 jge	 SHORT $LN12@save_long
$LN11@save_long:

; 1633 :             goto error;

  002c2	e9 9f 00 00 00	 jmp	 $error$21519
$LN12@save_long:

; 1634 :     }
; 1635 :     else {

  002c7	e9 94 00 00 00	 jmp	 $LN10@save_long
$LN25@save_long:

; 1636 :         char *string;
; 1637 : 
; 1638 :         /* proto < 2: write the repr and newline.  This is quadratic-time (in
; 1639 :            the number of digits), in both directions.  We add a trailing 'L'
; 1640 :            to the repr, for compatibility with Python 2.x. */
; 1641 : 
; 1642 :         repr = PyObject_Repr(obj);

  002cc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  002d4	e8 00 00 00 00	 call	 PyObject_Repr
  002d9	48 89 44 24 40	 mov	 QWORD PTR repr$[rsp], rax

; 1643 :         if (repr == NULL)

  002de	48 83 7c 24 40
	00		 cmp	 QWORD PTR repr$[rsp], 0
  002e4	75 02		 jne	 SHORT $LN9@save_long

; 1644 :             goto error;

  002e6	eb 7e		 jmp	 SHORT $error$21519
$LN9@save_long:

; 1645 : 
; 1646 :         string = _PyUnicode_AsStringAndSize(repr, &size);

  002e8	48 8d 54 24 30	 lea	 rdx, QWORD PTR size$[rsp]
  002ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR repr$[rsp]
  002f2	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  002f7	48 89 44 24 78	 mov	 QWORD PTR string$21549[rsp], rax

; 1647 :         if (string == NULL)

  002fc	48 83 7c 24 78
	00		 cmp	 QWORD PTR string$21549[rsp], 0
  00302	75 02		 jne	 SHORT $LN8@save_long

; 1648 :             goto error;

  00304	eb 60		 jmp	 SHORT $error$21519
$LN8@save_long:

; 1649 : 
; 1650 :         if (_Pickler_Write(self, &long_op, 1) < 0 ||
; 1651 :             _Pickler_Write(self, string, size) < 0 ||
; 1652 :             _Pickler_Write(self, "L\n", 2) < 0)

  00306	41 b8 01 00 00
	00		 mov	 r8d, 1
  0030c	48 8d 54 24 48	 lea	 rdx, QWORD PTR long_op$[rsp]
  00311	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00319	e8 00 00 00 00	 call	 _Pickler_Write
  0031e	48 85 c0	 test	 rax, rax
  00321	7c 3b		 jl	 SHORT $LN6@save_long
  00323	4c 8b 44 24 30	 mov	 r8, QWORD PTR size$[rsp]
  00328	48 8b 54 24 78	 mov	 rdx, QWORD PTR string$21549[rsp]
  0032d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00335	e8 00 00 00 00	 call	 _Pickler_Write
  0033a	48 85 c0	 test	 rax, rax
  0033d	7c 1f		 jl	 SHORT $LN6@save_long
  0033f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00345	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02IDNBLKMD@L?6?$AA@
  0034c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00354	e8 00 00 00 00	 call	 _Pickler_Write
  00359	48 85 c0	 test	 rax, rax
  0035c	7d 02		 jge	 SHORT $LN7@save_long
$LN6@save_long:

; 1653 :             goto error;

  0035e	eb 06		 jmp	 SHORT $error$21519
$LN7@save_long:
$LN10@save_long:

; 1654 :     }
; 1655 : 
; 1656 :     if (0) {

  00360	33 c0		 xor	 eax, eax
  00362	85 c0		 test	 eax, eax
  00364	74 08		 je	 SHORT $LN5@save_long
$error$21519:

; 1657 :   error:
; 1658 :       status = -1;

  00366	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1
$LN5@save_long:
$LN4@save_long:

; 1659 :     }
; 1660 :     Py_XDECREF(repr);

  0036e	48 83 7c 24 40
	00		 cmp	 QWORD PTR repr$[rsp], 0
  00374	74 0a		 je	 SHORT $LN1@save_long
  00376	48 8b 4c 24 40	 mov	 rcx, QWORD PTR repr$[rsp]
  0037b	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@save_long:
  00380	33 c0		 xor	 eax, eax
  00382	85 c0		 test	 eax, eax
  00384	75 e8		 jne	 SHORT $LN4@save_long

; 1661 : 
; 1662 :     return status;

  00386	8b 44 24 3c	 mov	 eax, DWORD PTR status$[rsp]
$LN28@save_long:

; 1663 : }

  0038a	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00391	c3		 ret	 0
save_long ENDP
_TEXT	ENDS
PUBLIC	??_C@_05HCLFKMOP@?$CFldL?6?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_int DD imagerel save_int
	DD	imagerel save_int+292
	DD	imagerel $unwind$save_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_int DD 010d01H
	DD	0a20dH
xdata	ENDS
;	COMDAT ??_C@_05HCLFKMOP@?$CFldL?6?$AA@
CONST	SEGMENT
??_C@_05HCLFKMOP@?$CFldL?6?$AA@ DB '%ldL', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_int
_TEXT	SEGMENT
pdata$ = 32
len$ = 64
self$ = 96
x$ = 104
save_int PROC						; COMDAT

; 1492 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1493 :     char pdata[32];
; 1494 :     Py_ssize_t len = 0;

  0000d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0

; 1495 : 
; 1496 :     if (!self->bin
; 1497 : #if SIZEOF_LONG > 4
; 1498 :         || x > 0x7fffffffL || x < -0x80000000L
; 1499 : #endif
; 1500 :         ) {

  00016	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0001b	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [rax+164], 0
  00022	75 53		 jne	 SHORT $LN8@save_int

; 1501 :         /* Text-mode pickle, or long too big to fit in the 4-byte
; 1502 :          * signed BININT format:  store as a string.
; 1503 :          */
; 1504 :         pdata[0] = LONG;        /* use LONG for consistency with pickle.py */

  00024	c6 44 24 20 4c	 mov	 BYTE PTR pdata$[rsp], 76 ; 0000004cH

; 1505 :         PyOS_snprintf(pdata + 1, sizeof(pdata) - 1, "%ldL\n", x);

  00029	48 8d 44 24 21	 lea	 rax, QWORD PTR pdata$[rsp+1]
  0002e	44 8b 4c 24 68	 mov	 r9d, DWORD PTR x$[rsp]
  00033	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05HCLFKMOP@?$CFldL?6?$AA@
  0003a	ba 1f 00 00 00	 mov	 edx, 31
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 PyOS_snprintf

; 1506 :         if (_Pickler_Write(self, pdata, strlen(pdata)) < 0)

  00047	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pdata$[rsp]
  0004c	e8 00 00 00 00	 call	 strlen
  00051	4c 8b c0	 mov	 r8, rax
  00054	48 8d 54 24 20	 lea	 rdx, QWORD PTR pdata$[rsp]
  00059	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0005e	e8 00 00 00 00	 call	 _Pickler_Write
  00063	48 85 c0	 test	 rax, rax
  00066	7d 0a		 jge	 SHORT $LN7@save_int

; 1507 :             return -1;

  00068	b8 ff ff ff ff	 mov	 eax, -1
  0006d	e9 ad 00 00 00	 jmp	 $LN9@save_int
$LN7@save_int:

; 1508 :     }
; 1509 :     else {

  00072	e9 a6 00 00 00	 jmp	 $LN6@save_int
$LN8@save_int:

; 1510 :         /* Binary pickle and x fits in a signed 4-byte int. */
; 1511 :         pdata[1] = (unsigned char)(x & 0xff);

  00077	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  0007b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00080	88 44 24 21	 mov	 BYTE PTR pdata$[rsp+1], al

; 1512 :         pdata[2] = (unsigned char)((x >> 8) & 0xff);

  00084	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  00088	c1 f8 08	 sar	 eax, 8
  0008b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00090	88 44 24 22	 mov	 BYTE PTR pdata$[rsp+2], al

; 1513 :         pdata[3] = (unsigned char)((x >> 16) & 0xff);

  00094	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  00098	c1 f8 10	 sar	 eax, 16
  0009b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a0	88 44 24 23	 mov	 BYTE PTR pdata$[rsp+3], al

; 1514 :         pdata[4] = (unsigned char)((x >> 24) & 0xff);

  000a4	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  000a8	c1 f8 18	 sar	 eax, 24
  000ab	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b0	88 44 24 24	 mov	 BYTE PTR pdata$[rsp+4], al

; 1515 : 
; 1516 :         if ((pdata[4] == 0) && (pdata[3] == 0)) {

  000b4	0f be 44 24 24	 movsx	 eax, BYTE PTR pdata$[rsp+4]
  000b9	85 c0		 test	 eax, eax
  000bb	75 32		 jne	 SHORT $LN5@save_int
  000bd	0f be 44 24 23	 movsx	 eax, BYTE PTR pdata$[rsp+3]
  000c2	85 c0		 test	 eax, eax
  000c4	75 29		 jne	 SHORT $LN5@save_int

; 1517 :             if (pdata[2] == 0) {

  000c6	0f be 44 24 22	 movsx	 eax, BYTE PTR pdata$[rsp+2]
  000cb	85 c0		 test	 eax, eax
  000cd	75 10		 jne	 SHORT $LN4@save_int

; 1518 :                 pdata[0] = BININT1;

  000cf	c6 44 24 20 4b	 mov	 BYTE PTR pdata$[rsp], 75 ; 0000004bH

; 1519 :                 len = 2;

  000d4	48 c7 44 24 40
	02 00 00 00	 mov	 QWORD PTR len$[rsp], 2

; 1520 :             }
; 1521 :             else {

  000dd	eb 0e		 jmp	 SHORT $LN3@save_int
$LN4@save_int:

; 1522 :                 pdata[0] = BININT2;

  000df	c6 44 24 20 4d	 mov	 BYTE PTR pdata$[rsp], 77 ; 0000004dH

; 1523 :                 len = 3;

  000e4	48 c7 44 24 40
	03 00 00 00	 mov	 QWORD PTR len$[rsp], 3
$LN3@save_int:

; 1524 :             }
; 1525 :         }
; 1526 :         else {

  000ed	eb 0e		 jmp	 SHORT $LN2@save_int
$LN5@save_int:

; 1527 :             pdata[0] = BININT;

  000ef	c6 44 24 20 4a	 mov	 BYTE PTR pdata$[rsp], 74 ; 0000004aH

; 1528 :             len = 5;

  000f4	48 c7 44 24 40
	05 00 00 00	 mov	 QWORD PTR len$[rsp], 5
$LN2@save_int:

; 1529 :         }
; 1530 : 
; 1531 :         if (_Pickler_Write(self, pdata, len) < 0)

  000fd	4c 8b 44 24 40	 mov	 r8, QWORD PTR len$[rsp]
  00102	48 8d 54 24 20	 lea	 rdx, QWORD PTR pdata$[rsp]
  00107	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0010c	e8 00 00 00 00	 call	 _Pickler_Write
  00111	48 85 c0	 test	 rax, rax
  00114	7d 07		 jge	 SHORT $LN1@save_int

; 1532 :             return -1;

  00116	b8 ff ff ff ff	 mov	 eax, -1
  0011b	eb 02		 jmp	 SHORT $LN9@save_int
$LN1@save_int:
$LN6@save_int:

; 1533 :     }
; 1534 : 
; 1535 :     return 0;

  0011d	33 c0		 xor	 eax, eax
$LN9@save_int:

; 1536 : }

  0011f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00123	c3		 ret	 0
save_int ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
EXTRN	PyMem_Free:PROC
EXTRN	PyOS_double_to_string:PROC
EXTRN	_PyFloat_Pack8:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_float DD imagerel save_float
	DD	imagerel save_float+323
	DD	imagerel $unwind$save_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_float DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_float
_TEXT	SEGMENT
x$ = 48
pdata$21573 = 56
buf$21579 = 72
result$21578 = 80
op$21581 = 84
self$ = 112
obj$ = 120
save_float PROC						; COMDAT

; 1667 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1668 :     double x = PyFloat_AS_DOUBLE((PyFloatObject *)obj);

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  00013	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00018	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1669 : 
; 1670 :     if (self->bin) {

  0001e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00023	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [rax+164], 0
  0002a	74 52		 je	 SHORT $LN8@save_float

; 1671 :         char pdata[9];
; 1672 :         pdata[0] = BINFLOAT;

  0002c	c6 44 24 38 47	 mov	 BYTE PTR pdata$21573[rsp], 71 ; 00000047H

; 1673 :         if (_PyFloat_Pack8(x, (unsigned char *)&pdata[1], 0) < 0)

  00031	48 8d 44 24 39	 lea	 rax, QWORD PTR pdata$21573[rsp+1]
  00036	45 33 c0	 xor	 r8d, r8d
  00039	48 8b d0	 mov	 rdx, rax
  0003c	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00042	e8 00 00 00 00	 call	 _PyFloat_Pack8
  00047	85 c0		 test	 eax, eax
  00049	7d 0a		 jge	 SHORT $LN7@save_float

; 1674 :             return -1;

  0004b	b8 ff ff ff ff	 mov	 eax, -1
  00050	e9 e9 00 00 00	 jmp	 $LN9@save_float
$LN7@save_float:

; 1675 :         if (_Pickler_Write(self, pdata, 9) < 0)

  00055	41 b8 09 00 00
	00		 mov	 r8d, 9
  0005b	48 8d 54 24 38	 lea	 rdx, QWORD PTR pdata$21573[rsp]
  00060	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00065	e8 00 00 00 00	 call	 _Pickler_Write
  0006a	48 85 c0	 test	 rax, rax
  0006d	7d 0a		 jge	 SHORT $LN6@save_float

; 1676 :             return -1;

  0006f	b8 ff ff ff ff	 mov	 eax, -1
  00074	e9 c5 00 00 00	 jmp	 $LN9@save_float
$LN6@save_float:

; 1677 :    }
; 1678 :     else {

  00079	e9 be 00 00 00	 jmp	 $LN5@save_float
$LN8@save_float:

; 1679 :         int result = -1;

  0007e	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR result$21578[rsp], -1

; 1680 :         char *buf = NULL;

  00086	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR buf$21579[rsp], 0

; 1681 :         char op = FLOAT;

  0008f	c6 44 24 54 46	 mov	 BYTE PTR op$21581[rsp], 70 ; 00000046H

; 1682 : 
; 1683 :         if (_Pickler_Write(self, &op, 1) < 0)

  00094	41 b8 01 00 00
	00		 mov	 r8d, 1
  0009a	48 8d 54 24 54	 lea	 rdx, QWORD PTR op$21581[rsp]
  0009f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000a4	e8 00 00 00 00	 call	 _Pickler_Write
  000a9	48 85 c0	 test	 rax, rax
  000ac	7d 02		 jge	 SHORT $LN4@save_float

; 1684 :             goto done;

  000ae	eb 7c		 jmp	 SHORT $done$21583
$LN4@save_float:

; 1685 : 
; 1686 :         buf = PyOS_double_to_string(x, 'g', 17, 0, NULL);

  000b0	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000b9	45 33 c9	 xor	 r9d, r9d
  000bc	41 b8 11 00 00
	00		 mov	 r8d, 17
  000c2	b2 67		 mov	 dl, 103			; 00000067H
  000c4	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000ca	e8 00 00 00 00	 call	 PyOS_double_to_string
  000cf	48 89 44 24 48	 mov	 QWORD PTR buf$21579[rsp], rax

; 1687 :         if (!buf) {

  000d4	48 83 7c 24 48
	00		 cmp	 QWORD PTR buf$21579[rsp], 0
  000da	75 07		 jne	 SHORT $LN3@save_float

; 1688 :             PyErr_NoMemory();

  000dc	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1689 :             goto done;

  000e1	eb 49		 jmp	 SHORT $done$21583
$LN3@save_float:

; 1690 :         }
; 1691 : 
; 1692 :         if (_Pickler_Write(self, buf, strlen(buf)) < 0)

  000e3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$21579[rsp]
  000e8	e8 00 00 00 00	 call	 strlen
  000ed	4c 8b c0	 mov	 r8, rax
  000f0	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$21579[rsp]
  000f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000fa	e8 00 00 00 00	 call	 _Pickler_Write
  000ff	48 85 c0	 test	 rax, rax
  00102	7d 02		 jge	 SHORT $LN2@save_float

; 1693 :             goto done;

  00104	eb 26		 jmp	 SHORT $done$21583
$LN2@save_float:

; 1694 : 
; 1695 :         if (_Pickler_Write(self, "\n", 1) < 0)

  00106	41 b8 01 00 00
	00		 mov	 r8d, 1
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00113	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00118	e8 00 00 00 00	 call	 _Pickler_Write
  0011d	48 85 c0	 test	 rax, rax
  00120	7d 02		 jge	 SHORT $LN1@save_float

; 1696 :             goto done;

  00122	eb 08		 jmp	 SHORT $done$21583
$LN1@save_float:

; 1697 : 
; 1698 :         result = 0;

  00124	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR result$21578[rsp], 0
$done$21583:

; 1699 : done:
; 1700 :         PyMem_Free(buf);

  0012c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$21579[rsp]
  00131	e8 00 00 00 00	 call	 PyMem_Free

; 1701 :         return result;

  00136	8b 44 24 50	 mov	 eax, DWORD PTR result$21578[rsp]
  0013a	eb 02		 jmp	 SHORT $LN9@save_float
$LN5@save_float:

; 1702 :     }
; 1703 : 
; 1704 :     return 0;

  0013c	33 c0		 xor	 eax, eax
$LN9@save_float:

; 1705 : }

  0013e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00142	c3		 ret	 0
save_float ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@CDNPLJMA@cannot?5serialize?5a?5bytes?5object?5@ ; `string'
PUBLIC	??_C@_07IDPMLOMJ@?$CIO?$CIOO?$CJ?$CJ?$AA@	; `string'
PUBLIC	??_C@_06CDEFMFPB@latin1?$AA@			; `string'
PUBLIC	??_C@_06OLFOGHEN@strict?$AA@			; `string'
PUBLIC	??_C@_05GJDNHDMK@?$CIO?$CI?$CJ?$CJ?$AA@		; `string'
PUBLIC	??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_06GDGADLDP@encode?$AA@			; `string'
PUBLIC	??_C@_06PKGECIG@codecs?$AA@			; `string'
EXTRN	PyUnicode_DecodeLatin1:PROC
EXTRN	Py_BuildValue:PROC
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_bytes DD imagerel save_bytes
	DD	imagerel save_bytes+962
	DD	imagerel $unwind$save_bytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_bytes DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0DC@CDNPLJMA@cannot?5serialize?5a?5bytes?5object?5@
CONST	SEGMENT
??_C@_0DC@CDNPLJMA@cannot?5serialize?5a?5bytes?5object?5@ DB 'cannot seri'
	DB	'alize a bytes object larger than 4 GiB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IDPMLOMJ@?$CIO?$CIOO?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_07IDPMLOMJ@?$CIO?$CIOO?$CJ?$CJ?$AA@ DB '(O(OO))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CDEFMFPB@latin1?$AA@
CONST	SEGMENT
??_C@_06CDEFMFPB@latin1?$AA@ DB 'latin1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict?$AA@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict?$AA@ DB 'strict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GJDNHDMK@?$CIO?$CI?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_05GJDNHDMK@?$CIO?$CI?$CJ?$CJ?$AA@ DB '(O())', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GDGADLDP@encode?$AA@
CONST	SEGMENT
??_C@_06GDGADLDP@encode?$AA@ DB 'encode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PKGECIG@codecs?$AA@
CONST	SEGMENT
??_C@_06PKGECIG@codecs?$AA@ DB 'codecs', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_bytes
_TEXT	SEGMENT
reduce_value$21599 = 32
status$21601 = 40
codecs_module$21604 = 48
unicode_str$21623 = 56
len$21645 = 64
size$21643 = 72
header$21644 = 80
self$ = 112
obj$ = 120
save_bytes PROC						; COMDAT

; 1709 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1710 :     if (self->proto < 3) {

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00013	83 b8 a0 00 00
	00 03		 cmp	 DWORD PTR [rax+160], 3
  0001a	0f 8d 0a 02 00
	00		 jge	 $LN19@save_bytes

; 1711 :         /* Older pickle protocols do not have an opcode for pickling bytes
; 1712 :            objects. Therefore, we need to fake the copy protocol (i.e.,
; 1713 :            the __reduce__ method) to permit bytes object unpickling.
; 1714 : 
; 1715 :            Here we use a hack to be compatible with Python 2. Since in Python
; 1716 :            2 'bytes' is just an alias for 'str' (which has different
; 1717 :            parameters than the actual bytes object), we use codecs.encode
; 1718 :            to create the appropriate 'str' object when unpickled using
; 1719 :            Python 2 *and* the appropriate 'bytes' object when unpickled
; 1720 :            using Python 3. Again this is a hack and we don't need to do this
; 1721 :            with newer protocols. */
; 1722 :         static PyObject *codecs_encode = NULL;
; 1723 :         PyObject *reduce_value = NULL;

  00020	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR reduce_value$21599[rsp], 0

; 1724 :         int status;
; 1725 : 
; 1726 :         if (codecs_encode == NULL) {

  00029	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?codecs_encode@?2??save_bytes@@9@9, 0
  00031	75 59		 jne	 SHORT $LN18@save_bytes

; 1727 :             PyObject *codecs_module = PyImport_ImportModule("codecs");

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06PKGECIG@codecs?$AA@
  0003a	e8 00 00 00 00	 call	 PyImport_ImportModule
  0003f	48 89 44 24 30	 mov	 QWORD PTR codecs_module$21604[rsp], rax

; 1728 :             if (codecs_module == NULL) {

  00044	48 83 7c 24 30
	00		 cmp	 QWORD PTR codecs_module$21604[rsp], 0
  0004a	75 0a		 jne	 SHORT $LN17@save_bytes

; 1729 :                 return -1;

  0004c	b8 ff ff ff ff	 mov	 eax, -1
  00051	e9 67 03 00 00	 jmp	 $LN20@save_bytes
$LN17@save_bytes:

; 1730 :             }
; 1731 :             codecs_encode = PyObject_GetAttrString(codecs_module, "encode");

  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06GDGADLDP@encode?$AA@
  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR codecs_module$21604[rsp]
  00062	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00067	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?codecs_encode@?2??save_bytes@@9@9, rax

; 1732 :             Py_DECREF(codecs_module);

  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR codecs_module$21604[rsp]
  00073	e8 00 00 00 00	 call	 _Py_DecRef

; 1733 :             if (codecs_encode == NULL) {

  00078	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?codecs_encode@?2??save_bytes@@9@9, 0
  00080	75 0a		 jne	 SHORT $LN16@save_bytes

; 1734 :                 return -1;

  00082	b8 ff ff ff ff	 mov	 eax, -1
  00087	e9 31 03 00 00	 jmp	 $LN20@save_bytes
$LN16@save_bytes:
$LN18@save_bytes:

; 1735 :             }
; 1736 :         }
; 1737 : 
; 1738 :         if (PyBytes_GET_SIZE(obj) == 0) {

  0008c	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  00091	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00095	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000a0	85 c0		 test	 eax, eax
  000a2	75 1c		 jne	 SHORT $LN22@save_bytes
  000a4	41 b8 ca 06 00
	00		 mov	 r8d, 1738		; 000006caH
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000be	33 c0		 xor	 eax, eax
$LN22@save_bytes:
  000c0	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  000c5	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000ca	75 1d		 jne	 SHORT $LN15@save_bytes

; 1739 :             reduce_value = Py_BuildValue("(O())", (PyObject*)&PyBytes_Type);

  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyBytes_Type
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05GJDNHDMK@?$CIO?$CI?$CJ?$CJ?$AA@
  000da	e8 00 00 00 00	 call	 Py_BuildValue
  000df	48 89 44 24 20	 mov	 QWORD PTR reduce_value$21599[rsp], rax

; 1740 :         }
; 1741 :         else {

  000e4	e9 ff 00 00 00	 jmp	 $LN14@save_bytes
$LN15@save_bytes:

; 1742 :             static PyObject *latin1 = NULL;
; 1743 :             PyObject *unicode_str =
; 1744 :                 PyUnicode_DecodeLatin1(PyBytes_AS_STRING(obj),
; 1745 :                                        PyBytes_GET_SIZE(obj),
; 1746 :                                        "strict");

  000e9	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  000ee	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000fd	85 c0		 test	 eax, eax
  000ff	75 1c		 jne	 SHORT $LN23@save_bytes
  00101	41 b8 d1 06 00
	00		 mov	 r8d, 1745		; 000006d1H
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0011b	33 c0		 xor	 eax, eax
$LN23@save_bytes:
  0011d	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  00122	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00126	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0012c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00131	85 c0		 test	 eax, eax
  00133	75 1c		 jne	 SHORT $LN24@save_bytes
  00135	41 b8 d0 06 00
	00		 mov	 r8d, 1744		; 000006d0H
  0013b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0014f	33 c0		 xor	 eax, eax
$LN24@save_bytes:
  00151	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  00156	48 83 c0 78	 add	 rax, 120		; 00000078H
  0015a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00161	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$[rsp]
  00166	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0016a	48 8b c8	 mov	 rcx, rax
  0016d	e8 00 00 00 00	 call	 PyUnicode_DecodeLatin1
  00172	48 89 44 24 38	 mov	 QWORD PTR unicode_str$21623[rsp], rax

; 1747 :             if (unicode_str == NULL)

  00177	48 83 7c 24 38
	00		 cmp	 QWORD PTR unicode_str$21623[rsp], 0
  0017d	75 0a		 jne	 SHORT $LN13@save_bytes

; 1748 :                 return -1;

  0017f	b8 ff ff ff ff	 mov	 eax, -1
  00184	e9 34 02 00 00	 jmp	 $LN20@save_bytes
$LN13@save_bytes:

; 1749 :             if (latin1 == NULL) {

  00189	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?latin1@?7??save_bytes@@9@9, 0
  00191	75 27		 jne	 SHORT $LN12@save_bytes

; 1750 :                 latin1 = PyUnicode_InternFromString("latin1");

  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CDEFMFPB@latin1?$AA@
  0019a	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0019f	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?latin1@?7??save_bytes@@9@9, rax

; 1751 :                 if (latin1 == NULL)

  001a6	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?latin1@?7??save_bytes@@9@9, 0
  001ae	75 0a		 jne	 SHORT $LN11@save_bytes

; 1752 :                     return -1;

  001b0	b8 ff ff ff ff	 mov	 eax, -1
  001b5	e9 03 02 00 00	 jmp	 $LN20@save_bytes
$LN11@save_bytes:
$LN12@save_bytes:

; 1753 :             }
; 1754 :             reduce_value = Py_BuildValue("(O(OO))",
; 1755 :                                          codecs_encode, unicode_str, latin1);

  001ba	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?latin1@?7??save_bytes@@9@9
  001c1	4c 8b 44 24 38	 mov	 r8, QWORD PTR unicode_str$21623[rsp]
  001c6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?codecs_encode@?2??save_bytes@@9@9
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IDPMLOMJ@?$CIO?$CIOO?$CJ?$CJ?$AA@
  001d4	e8 00 00 00 00	 call	 Py_BuildValue
  001d9	48 89 44 24 20	 mov	 QWORD PTR reduce_value$21599[rsp], rax

; 1756 :             Py_DECREF(unicode_str);

  001de	48 8b 4c 24 38	 mov	 rcx, QWORD PTR unicode_str$21623[rsp]
  001e3	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@save_bytes:

; 1757 :         }
; 1758 : 
; 1759 :         if (reduce_value == NULL)

  001e8	48 83 7c 24 20
	00		 cmp	 QWORD PTR reduce_value$21599[rsp], 0
  001ee	75 0a		 jne	 SHORT $LN10@save_bytes

; 1760 :             return -1;

  001f0	b8 ff ff ff ff	 mov	 eax, -1
  001f5	e9 c3 01 00 00	 jmp	 $LN20@save_bytes
$LN10@save_bytes:

; 1761 : 
; 1762 :         /* save_reduce() will memoize the object automatically. */
; 1763 :         status = save_reduce(self, reduce_value, obj);

  001fa	4c 8b 44 24 78	 mov	 r8, QWORD PTR obj$[rsp]
  001ff	48 8b 54 24 20	 mov	 rdx, QWORD PTR reduce_value$21599[rsp]
  00204	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00209	e8 00 00 00 00	 call	 save_reduce
  0020e	89 44 24 28	 mov	 DWORD PTR status$21601[rsp], eax

; 1764 :         Py_DECREF(reduce_value);

  00212	48 8b 4c 24 20	 mov	 rcx, QWORD PTR reduce_value$21599[rsp]
  00217	e8 00 00 00 00	 call	 _Py_DecRef

; 1765 :         return status;

  0021c	8b 44 24 28	 mov	 eax, DWORD PTR status$21601[rsp]
  00220	e9 98 01 00 00	 jmp	 $LN20@save_bytes

; 1766 :     }
; 1767 :     else {

  00225	e9 93 01 00 00	 jmp	 $LN9@save_bytes
$LN19@save_bytes:

; 1768 :         Py_ssize_t size;
; 1769 :         char header[5];
; 1770 :         Py_ssize_t len;
; 1771 : 
; 1772 :         size = PyBytes_GET_SIZE(obj);

  0022a	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  0022f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00233	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00239	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0023e	85 c0		 test	 eax, eax
  00240	75 1c		 jne	 SHORT $LN25@save_bytes
  00242	41 b8 ec 06 00
	00		 mov	 r8d, 1772		; 000006ecH
  00248	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0025c	33 c0		 xor	 eax, eax
$LN25@save_bytes:
  0025e	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  00263	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00267	48 89 44 24 48	 mov	 QWORD PTR size$21643[rsp], rax

; 1773 :         if (size < 0)

  0026c	48 83 7c 24 48
	00		 cmp	 QWORD PTR size$21643[rsp], 0
  00272	7d 0a		 jge	 SHORT $LN8@save_bytes

; 1774 :             return -1;

  00274	b8 ff ff ff ff	 mov	 eax, -1
  00279	e9 3f 01 00 00	 jmp	 $LN20@save_bytes
$LN8@save_bytes:

; 1775 : 
; 1776 :         if (size < 256) {

  0027e	48 81 7c 24 48
	00 01 00 00	 cmp	 QWORD PTR size$21643[rsp], 256 ; 00000100H
  00287	7d 1c		 jge	 SHORT $LN7@save_bytes

; 1777 :             header[0] = SHORT_BINBYTES;

  00289	c6 44 24 50 43	 mov	 BYTE PTR header$21644[rsp], 67 ; 00000043H

; 1778 :             header[1] = (unsigned char)size;

  0028e	0f b6 44 24 48	 movzx	 eax, BYTE PTR size$21643[rsp]
  00293	88 44 24 51	 mov	 BYTE PTR header$21644[rsp+1], al

; 1779 :             len = 2;

  00297	48 c7 44 24 40
	02 00 00 00	 mov	 QWORD PTR len$21645[rsp], 2
  002a0	e9 81 00 00 00	 jmp	 $LN6@save_bytes
$LN7@save_bytes:

; 1780 :         }
; 1781 :         else if (size <= 0xffffffffL) {

  002a5	b8 ff ff ff ff	 mov	 eax, -1
  002aa	48 39 44 24 48	 cmp	 QWORD PTR size$21643[rsp], rax
  002af	7f 58		 jg	 SHORT $LN5@save_bytes

; 1782 :             header[0] = BINBYTES;

  002b1	c6 44 24 50 42	 mov	 BYTE PTR header$21644[rsp], 66 ; 00000042H

; 1783 :             header[1] = (unsigned char)(size & 0xff);

  002b6	48 8b 44 24 48	 mov	 rax, QWORD PTR size$21643[rsp]
  002bb	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  002c1	88 44 24 51	 mov	 BYTE PTR header$21644[rsp+1], al

; 1784 :             header[2] = (unsigned char)((size >> 8) & 0xff);

  002c5	48 8b 44 24 48	 mov	 rax, QWORD PTR size$21643[rsp]
  002ca	48 c1 f8 08	 sar	 rax, 8
  002ce	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  002d4	88 44 24 52	 mov	 BYTE PTR header$21644[rsp+2], al

; 1785 :             header[3] = (unsigned char)((size >> 16) & 0xff);

  002d8	48 8b 44 24 48	 mov	 rax, QWORD PTR size$21643[rsp]
  002dd	48 c1 f8 10	 sar	 rax, 16
  002e1	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  002e7	88 44 24 53	 mov	 BYTE PTR header$21644[rsp+3], al

; 1786 :             header[4] = (unsigned char)((size >> 24) & 0xff);

  002eb	48 8b 44 24 48	 mov	 rax, QWORD PTR size$21643[rsp]
  002f0	48 c1 f8 18	 sar	 rax, 24
  002f4	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  002fa	88 44 24 54	 mov	 BYTE PTR header$21644[rsp+4], al

; 1787 :             len = 5;

  002fe	48 c7 44 24 40
	05 00 00 00	 mov	 QWORD PTR len$21645[rsp], 5

; 1788 :         }
; 1789 :         else {

  00307	eb 1d		 jmp	 SHORT $LN4@save_bytes
$LN5@save_bytes:

; 1790 :             PyErr_SetString(PyExc_OverflowError,
; 1791 :                             "cannot serialize a bytes object larger than 4 GiB");

  00309	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@CDNPLJMA@cannot?5serialize?5a?5bytes?5object?5@
  00310	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00317	e8 00 00 00 00	 call	 PyErr_SetString

; 1792 :             return -1;          /* string too large */

  0031c	b8 ff ff ff ff	 mov	 eax, -1
  00321	e9 97 00 00 00	 jmp	 $LN20@save_bytes
$LN4@save_bytes:
$LN6@save_bytes:

; 1793 :         }
; 1794 : 
; 1795 :         if (_Pickler_Write(self, header, len) < 0)

  00326	4c 8b 44 24 40	 mov	 r8, QWORD PTR len$21645[rsp]
  0032b	48 8d 54 24 50	 lea	 rdx, QWORD PTR header$21644[rsp]
  00330	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00335	e8 00 00 00 00	 call	 _Pickler_Write
  0033a	48 85 c0	 test	 rax, rax
  0033d	7d 07		 jge	 SHORT $LN3@save_bytes

; 1796 :             return -1;

  0033f	b8 ff ff ff ff	 mov	 eax, -1
  00344	eb 77		 jmp	 SHORT $LN20@save_bytes
$LN3@save_bytes:

; 1797 : 
; 1798 :         if (_Pickler_Write(self, PyBytes_AS_STRING(obj), size) < 0)

  00346	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  0034b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0034f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00355	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0035a	85 c0		 test	 eax, eax
  0035c	75 1c		 jne	 SHORT $LN26@save_bytes
  0035e	41 b8 06 07 00
	00		 mov	 r8d, 1798		; 00000706H
  00364	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0036b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00372	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00378	33 c0		 xor	 eax, eax
$LN26@save_bytes:
  0037a	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  0037f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00383	4c 8b 44 24 48	 mov	 r8, QWORD PTR size$21643[rsp]
  00388	48 8b d0	 mov	 rdx, rax
  0038b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00390	e8 00 00 00 00	 call	 _Pickler_Write
  00395	48 85 c0	 test	 rax, rax
  00398	7d 07		 jge	 SHORT $LN2@save_bytes

; 1799 :             return -1;

  0039a	b8 ff ff ff ff	 mov	 eax, -1
  0039f	eb 1c		 jmp	 SHORT $LN20@save_bytes
$LN2@save_bytes:

; 1800 : 
; 1801 :         if (memo_put(self, obj) < 0)

  003a1	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  003a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  003ab	e8 00 00 00 00	 call	 memo_put
  003b0	85 c0		 test	 eax, eax
  003b2	7d 07		 jge	 SHORT $LN1@save_bytes

; 1802 :             return -1;

  003b4	b8 ff ff ff ff	 mov	 eax, -1
  003b9	eb 02		 jmp	 SHORT $LN20@save_bytes
$LN1@save_bytes:

; 1803 : 
; 1804 :         return 0;

  003bb	33 c0		 xor	 eax, eax
$LN9@save_bytes:
$LN20@save_bytes:

; 1805 :     }
; 1806 : }

  003bd	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003c1	c3		 ret	 0
save_bytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@EAIMIBPJ@memo?5id?5too?5large?5for?5LONG_BINPU@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memo_put DD imagerel memo_put
	DD	imagerel memo_put+376
	DD	imagerel $unwind$memo_put
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memo_put DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0CC@EAIMIBPJ@memo?5id?5too?5large?5for?5LONG_BINPU@
CONST	SEGMENT
??_C@_0CC@EAIMIBPJ@memo?5id?5too?5large?5for?5LONG_BINPU@ DB 'memo id too'
	DB	' large for LONG_BINPUT', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memo_put
_TEXT	SEGMENT
x$ = 32
pdata$ = 40
len$ = 72
status$ = 80
self$ = 112
obj$ = 120
memo_put PROC						; COMDAT

; 1276 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1277 :     Py_ssize_t x;
; 1278 :     char pdata[30];
; 1279 :     Py_ssize_t len;
; 1280 :     int status = 0;

  0000e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 1281 : 
; 1282 :     if (self->fast)

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0001b	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [rax+176], 0
  00022	74 07		 je	 SHORT $LN10@memo_put

; 1283 :         return 0;

  00024	33 c0		 xor	 eax, eax
  00026	e9 48 01 00 00	 jmp	 $LN11@memo_put
$LN10@memo_put:

; 1284 : 
; 1285 :     x = PyMemoTable_Size(self->memo);

  0002b	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00030	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00034	e8 00 00 00 00	 call	 PyMemoTable_Size
  00039	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1286 :     if (PyMemoTable_Set(self->memo, obj, x) < 0)

  0003e	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  00043	48 8b 54 24 78	 mov	 rdx, QWORD PTR obj$[rsp]
  00048	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0004d	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00051	e8 00 00 00 00	 call	 PyMemoTable_Set
  00056	85 c0		 test	 eax, eax
  00058	7d 05		 jge	 SHORT $LN9@memo_put

; 1287 :         goto error;

  0005a	e9 08 01 00 00	 jmp	 $error$21346
$LN9@memo_put:

; 1288 : 
; 1289 :     if (!self->bin) {

  0005f	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00064	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [rax+164], 0
  0006b	75 37		 jne	 SHORT $LN8@memo_put

; 1290 :         pdata[0] = PUT;

  0006d	c6 44 24 28 70	 mov	 BYTE PTR pdata$[rsp], 112 ; 00000070H

; 1291 :         PyOS_snprintf(pdata + 1, sizeof(pdata) - 1,
; 1292 :                       "%" PY_FORMAT_SIZE_T "d\n", x);

  00072	48 8d 44 24 29	 lea	 rax, QWORD PTR pdata$[rsp+1]
  00077	4c 8b 4c 24 20	 mov	 r9, QWORD PTR x$[rsp]
  0007c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04GDNBDEFH@?$CFId?6?$AA@
  00083	ba 1d 00 00 00	 mov	 edx, 29
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 PyOS_snprintf

; 1293 :         len = strlen(pdata);

  00090	48 8d 4c 24 28	 lea	 rcx, QWORD PTR pdata$[rsp]
  00095	e8 00 00 00 00	 call	 strlen
  0009a	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax

; 1294 :     }
; 1295 :     else {

  0009f	e9 a2 00 00 00	 jmp	 $LN7@memo_put
$LN8@memo_put:

; 1296 :         if (x < 256) {

  000a4	48 81 7c 24 20
	00 01 00 00	 cmp	 QWORD PTR x$[rsp], 256	; 00000100H
  000ad	7d 19		 jge	 SHORT $LN6@memo_put

; 1297 :             pdata[0] = BINPUT;

  000af	c6 44 24 28 71	 mov	 BYTE PTR pdata$[rsp], 113 ; 00000071H

; 1298 :             pdata[1] = (unsigned char)x;

  000b4	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  000b9	88 44 24 29	 mov	 BYTE PTR pdata$[rsp+1], al

; 1299 :             len = 2;

  000bd	48 c7 44 24 48
	02 00 00 00	 mov	 QWORD PTR len$[rsp], 2
  000c6	eb 7e		 jmp	 SHORT $LN5@memo_put
$LN6@memo_put:

; 1300 :         }
; 1301 :         else if (x <= 0xffffffffL) {

  000c8	b8 ff ff ff ff	 mov	 eax, -1
  000cd	48 39 44 24 20	 cmp	 QWORD PTR x$[rsp], rax
  000d2	7f 58		 jg	 SHORT $LN4@memo_put

; 1302 :             pdata[0] = LONG_BINPUT;

  000d4	c6 44 24 28 72	 mov	 BYTE PTR pdata$[rsp], 114 ; 00000072H

; 1303 :             pdata[1] = (unsigned char)(x & 0xff);

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  000de	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  000e4	88 44 24 29	 mov	 BYTE PTR pdata$[rsp+1], al

; 1304 :             pdata[2] = (unsigned char)((x >> 8) & 0xff);

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  000ed	48 c1 f8 08	 sar	 rax, 8
  000f1	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  000f7	88 44 24 2a	 mov	 BYTE PTR pdata$[rsp+2], al

; 1305 :             pdata[3] = (unsigned char)((x >> 16) & 0xff);

  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  00100	48 c1 f8 10	 sar	 rax, 16
  00104	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0010a	88 44 24 2b	 mov	 BYTE PTR pdata$[rsp+3], al

; 1306 :             pdata[4] = (unsigned char)((x >> 24) & 0xff);

  0010e	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  00113	48 c1 f8 18	 sar	 rax, 24
  00117	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0011d	88 44 24 2c	 mov	 BYTE PTR pdata$[rsp+4], al

; 1307 :             len = 5;

  00121	48 c7 44 24 48
	05 00 00 00	 mov	 QWORD PTR len$[rsp], 5

; 1308 :         }
; 1309 :         else { /* unlikely */

  0012a	eb 1a		 jmp	 SHORT $LN3@memo_put
$LN4@memo_put:

; 1310 :             PyErr_SetString(PicklingError,
; 1311 :                             "memo id too large for LONG_BINPUT");

  0012c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@EAIMIBPJ@memo?5id?5too?5large?5for?5LONG_BINPU@
  00133	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0013a	e8 00 00 00 00	 call	 PyErr_SetString

; 1312 :             return -1;

  0013f	b8 ff ff ff ff	 mov	 eax, -1
  00144	eb 2d		 jmp	 SHORT $LN11@memo_put
$LN3@memo_put:
$LN5@memo_put:
$LN7@memo_put:

; 1313 :         }
; 1314 :     }
; 1315 : 
; 1316 :     if (_Pickler_Write(self, pdata, len) < 0)

  00146	4c 8b 44 24 48	 mov	 r8, QWORD PTR len$[rsp]
  0014b	48 8d 54 24 28	 lea	 rdx, QWORD PTR pdata$[rsp]
  00150	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00155	e8 00 00 00 00	 call	 _Pickler_Write
  0015a	48 85 c0	 test	 rax, rax
  0015d	7d 02		 jge	 SHORT $LN2@memo_put

; 1317 :         goto error;

  0015f	eb 06		 jmp	 SHORT $error$21346
$LN2@memo_put:

; 1318 : 
; 1319 :     if (0) {

  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	74 08		 je	 SHORT $LN1@memo_put
$error$21346:

; 1320 :   error:
; 1321 :         status = -1;

  00167	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1
$LN1@memo_put:

; 1322 :     }
; 1323 : 
; 1324 :     return status;

  0016f	8b 44 24 50	 mov	 eax, DWORD PTR status$[rsp]
$LN11@memo_put:

; 1325 : }

  00173	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00177	c3		 ret	 0
memo_put ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT PyMemoTable_Size
_TEXT	SEGMENT
self$ = 8
PyMemoTable_Size PROC					; COMDAT

; 452  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 453  :     return self->mt_used;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  0000a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 454  : }

  0000e	c3		 ret	 0
PyMemoTable_Size ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@OEOAAOGG@?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoTable_Set DD imagerel PyMemoTable_Set
	DD	imagerel PyMemoTable_Set+266
	DD	imagerel $unwind$PyMemoTable_Set
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_Set DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1BI@OEOAAOGG@?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@OEOAAOGG@?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'k'
	DB	00H, 'e', 00H, 'y', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyMemoTable_Set
_TEXT	SEGMENT
entry$ = 32
tv88 = 40
self$ = 64
key$ = 72
value$ = 80
PyMemoTable_Set PROC					; COMDAT

; 572  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 573  :     PyMemoEntry *entry;
; 574  : 
; 575  :     assert(key != NULL);

  00013	48 83 7c 24 48
	00		 cmp	 QWORD PTR key$[rsp], 0
  00019	75 1c		 jne	 SHORT $LN5@PyMemoTabl@4
  0001b	41 b8 3f 02 00
	00		 mov	 r8d, 575		; 0000023fH
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@OEOAAOGG@?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00035	33 c0		 xor	 eax, eax
$LN5@PyMemoTabl@4:

; 576  : 
; 577  :     entry = _PyMemoTable_Lookup(self, key);

  00037	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00041	e8 00 00 00 00	 call	 _PyMemoTable_Lookup
  00046	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 578  :     if (entry->me_key != NULL) {

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00050	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00054	74 15		 je	 SHORT $LN2@PyMemoTabl@4

; 579  :         entry->me_value = value;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  00060	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 580  :         return 0;

  00064	33 c0		 xor	 eax, eax
  00066	e9 9a 00 00 00	 jmp	 $LN3@PyMemoTabl@4
$LN2@PyMemoTabl@4:

; 581  :     }
; 582  :     Py_INCREF(key);

  0006b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00070	e8 00 00 00 00	 call	 _Py_IncRef

; 583  :     entry->me_key = key;

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0007a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0007f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 584  :     entry->me_value = value;

  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00087	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0008c	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 585  :     self->mt_used++;

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00095	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00099	48 ff c0	 inc	 rax
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000a1	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 586  : 
; 587  :     /* If we added a key, we can safely resize. Otherwise just return!
; 588  :      * If used >= 2/3 size, adjust size. Normally, this quaduples the size.
; 589  :      *
; 590  :      * Quadrupling the size improves average table sparseness
; 591  :      * (reducing collisions) at the cost of some memory. It also halves
; 592  :      * the number of expensive resize operations in a growing memo table.
; 593  :      *
; 594  :      * Very large memo tables (over 50K items) use doubling instead.
; 595  :      * This may help applications with severe memory constraints.
; 596  :      */
; 597  :     if (!(self->mt_used * 3 >= (self->mt_mask + 1) * 2))

  000a5	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000aa	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ae	48 6b c0 03	 imul	 rax, 3
  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000b7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ba	48 8d 4c 09 02	 lea	 rcx, QWORD PTR [rcx+rcx+2]
  000bf	48 3b c1	 cmp	 rax, rcx
  000c2	7d 04		 jge	 SHORT $LN1@PyMemoTabl@4

; 598  :         return 0;

  000c4	33 c0		 xor	 eax, eax
  000c6	eb 3d		 jmp	 SHORT $LN3@PyMemoTabl@4
$LN1@PyMemoTabl@4:

; 599  :     return _PyMemoTable_ResizeTable(self,
; 600  :         (self->mt_used > 50000 ? 2 : 4) * self->mt_used);

  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000cd	48 81 78 08 50
	c3 00 00	 cmp	 QWORD PTR [rax+8], 50000 ; 0000c350H
  000d5	7e 0a		 jle	 SHORT $LN6@PyMemoTabl@4
  000d7	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv88[rsp], 2
  000df	eb 08		 jmp	 SHORT $LN7@PyMemoTabl@4
$LN6@PyMemoTabl@4:
  000e1	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR tv88[rsp], 4
$LN7@PyMemoTabl@4:
  000e9	48 63 44 24 28	 movsxd	 rax, DWORD PTR tv88[rsp]
  000ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000f3	48 0f af 41 08	 imul	 rax, QWORD PTR [rcx+8]
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00100	e8 00 00 00 00	 call	 _PyMemoTable_ResizeTable
$LN3@PyMemoTabl@4:

; 601  : }

  00105	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00109	c3		 ret	 0
PyMemoTable_Set ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EC@HJHONDPL@?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1BK@EPLMGHNH@?$AAm?$AAi?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyMemoTable_ResizeTable DD imagerel _PyMemoTable_ResizeTable
	DD	imagerel _PyMemoTable_ResizeTable+578
	DD	imagerel $unwind$_PyMemoTable_ResizeTable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyMemoTable_ResizeTable DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_1EC@HJHONDPL@?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1EC@HJHONDPL@?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ DB '('
	DB	00H, 'n', 00H, 'e', 00H, 'w', 00H, '_', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, ' ', 00H, '&', 00H, ' ', 00H, '(', 00H, 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '-', 00H, ' ', 00H, '1', 00H, ')', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@EPLMGHNH@?$AAm?$AAi?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@EPLMGHNH@?$AAm?$AAi?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'm'
	DB	00H, 'i', 00H, 'n', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyMemoTable_ResizeTable
_TEXT	SEGMENT
new_size$ = 32
newentry$ = 40
oldtable$ = 48
to_process$ = 56
oldentry$ = 64
tv90 = 72
tv129 = 80
tv151 = 84
self$ = 112
min_size$ = 120
_PyMemoTable_ResizeTable PROC				; COMDAT

; 510  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 511  :     PyMemoEntry *oldtable = NULL;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR oldtable$[rsp], 0

; 512  :     PyMemoEntry *oldentry, *newentry;
; 513  :     Py_ssize_t new_size = MT_MINSIZE;

  00017	48 c7 44 24 20
	08 00 00 00	 mov	 QWORD PTR new_size$[rsp], 8

; 514  :     Py_ssize_t to_process;
; 515  : 
; 516  :     assert(min_size > 0);

  00020	48 83 7c 24 78
	00		 cmp	 QWORD PTR min_size$[rsp], 0
  00026	7f 1c		 jg	 SHORT $LN11@PyMemoTabl@5
  00028	41 b8 04 02 00
	00		 mov	 r8d, 516		; 00000204H
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@EPLMGHNH@?$AAm?$AAi?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00042	33 c0		 xor	 eax, eax
$LN11@PyMemoTabl@5:
$LN8@PyMemoTabl@5:

; 517  : 
; 518  :     /* Find the smallest valid table size >= min_size. */
; 519  :     while (new_size < min_size && new_size > 0)

  00044	48 8b 44 24 78	 mov	 rax, QWORD PTR min_size$[rsp]
  00049	48 39 44 24 20	 cmp	 QWORD PTR new_size$[rsp], rax
  0004e	7d 17		 jge	 SHORT $LN7@PyMemoTabl@5
  00050	48 83 7c 24 20
	00		 cmp	 QWORD PTR new_size$[rsp], 0
  00056	7e 0f		 jle	 SHORT $LN7@PyMemoTabl@5

; 520  :         new_size <<= 1;

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR new_size$[rsp]
  0005d	48 d1 e0	 shl	 rax, 1
  00060	48 89 44 24 20	 mov	 QWORD PTR new_size$[rsp], rax
  00065	eb dd		 jmp	 SHORT $LN8@PyMemoTabl@5
$LN7@PyMemoTabl@5:

; 521  :     if (new_size <= 0) {

  00067	48 83 7c 24 20
	00		 cmp	 QWORD PTR new_size$[rsp], 0
  0006d	7f 0f		 jg	 SHORT $LN6@PyMemoTabl@5

; 522  :         PyErr_NoMemory();

  0006f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 523  :         return -1;

  00074	b8 ff ff ff ff	 mov	 eax, -1
  00079	e9 bf 01 00 00	 jmp	 $LN9@PyMemoTabl@5
$LN6@PyMemoTabl@5:

; 524  :     }
; 525  :     /* new_size needs to be a power of two. */
; 526  :     assert((new_size & (new_size - 1)) == 0);

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR new_size$[rsp]
  00083	48 ff c8	 dec	 rax
  00086	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_size$[rsp]
  0008b	48 23 c8	 and	 rcx, rax
  0008e	48 8b c1	 mov	 rax, rcx
  00091	48 85 c0	 test	 rax, rax
  00094	74 1c		 je	 SHORT $LN12@PyMemoTabl@5
  00096	41 b8 0e 02 00
	00		 mov	 r8d, 526		; 0000020eH
  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@HJHONDPL@?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b0	33 c0		 xor	 eax, eax
$LN12@PyMemoTabl@5:

; 527  : 
; 528  :     /* Allocate new table. */
; 529  :     oldtable = self->mt_table;

  000b2	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000b7	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000bb	48 89 44 24 30	 mov	 QWORD PTR oldtable$[rsp], rax

; 530  :     self->mt_table = PyMem_MALLOC(new_size * sizeof(PyMemoEntry));

  000c0	e8 00 00 00 00	 call	 _Py_PXCTX
  000c5	85 c0		 test	 eax, eax
  000c7	74 18		 je	 SHORT $LN13@PyMemoTabl@5
  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR new_size$[rsp]
  000ce	48 6b c0 10	 imul	 rax, 16
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 _PxMem_Malloc
  000da	48 89 44 24 48	 mov	 QWORD PTR tv90[rsp], rax
  000df	eb 16		 jmp	 SHORT $LN14@PyMemoTabl@5
$LN13@PyMemoTabl@5:
  000e1	48 8b 44 24 20	 mov	 rax, QWORD PTR new_size$[rsp]
  000e6	48 6b c0 10	 imul	 rax, 16
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  000f2	48 89 44 24 48	 mov	 QWORD PTR tv90[rsp], rax
$LN14@PyMemoTabl@5:
  000f7	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000fc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv90[rsp]
  00101	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 531  :     if (self->mt_table == NULL) {

  00105	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0010a	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0010f	75 3e		 jne	 SHORT $LN5@PyMemoTabl@5

; 532  :         PyMem_FREE(oldtable);

  00111	e8 00 00 00 00	 call	 _Py_PXCTX
  00116	85 c0		 test	 eax, eax
  00118	74 14		 je	 SHORT $LN15@PyMemoTabl@5
  0011a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR oldtable$[rsp]
  0011f	e8 00 00 00 00	 call	 _PxMem_Free
  00124	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
  0012c	eb 12		 jmp	 SHORT $LN16@PyMemoTabl@5
$LN15@PyMemoTabl@5:
  0012e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR oldtable$[rsp]
  00133	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00138	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN16@PyMemoTabl@5:

; 533  :         PyErr_NoMemory();

  00140	e8 00 00 00 00	 call	 PyErr_NoMemory

; 534  :         return -1;

  00145	b8 ff ff ff ff	 mov	 eax, -1
  0014a	e9 ee 00 00 00	 jmp	 $LN9@PyMemoTabl@5
$LN5@PyMemoTabl@5:

; 535  :     }
; 536  :     self->mt_allocated = new_size;

  0014f	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00154	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_size$[rsp]
  00159	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 537  :     self->mt_mask = new_size - 1;

  0015d	48 8b 44 24 20	 mov	 rax, QWORD PTR new_size$[rsp]
  00162	48 ff c8	 dec	 rax
  00165	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0016a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 538  :     memset(self->mt_table, 0, sizeof(PyMemoEntry) * new_size);

  0016d	48 8b 44 24 20	 mov	 rax, QWORD PTR new_size$[rsp]
  00172	48 6b c0 10	 imul	 rax, 16
  00176	4c 8b c0	 mov	 r8, rax
  00179	33 d2		 xor	 edx, edx
  0017b	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00180	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00184	e8 00 00 00 00	 call	 memset

; 539  : 
; 540  :     /* Copy entries from the old table. */
; 541  :     to_process = self->mt_used;

  00189	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0018e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00192	48 89 44 24 38	 mov	 QWORD PTR to_process$[rsp], rax

; 542  :     for (oldentry = oldtable; to_process > 0; oldentry++) {

  00197	48 8b 44 24 30	 mov	 rax, QWORD PTR oldtable$[rsp]
  0019c	48 89 44 24 40	 mov	 QWORD PTR oldentry$[rsp], rax
  001a1	eb 0e		 jmp	 SHORT $LN4@PyMemoTabl@5
$LN3@PyMemoTabl@5:
  001a3	48 8b 44 24 40	 mov	 rax, QWORD PTR oldentry$[rsp]
  001a8	48 83 c0 10	 add	 rax, 16
  001ac	48 89 44 24 40	 mov	 QWORD PTR oldentry$[rsp], rax
$LN4@PyMemoTabl@5:
  001b1	48 83 7c 24 38
	00		 cmp	 QWORD PTR to_process$[rsp], 0
  001b7	7e 53		 jle	 SHORT $LN2@PyMemoTabl@5

; 543  :         if (oldentry->me_key != NULL) {

  001b9	48 8b 44 24 40	 mov	 rax, QWORD PTR oldentry$[rsp]
  001be	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001c2	74 46		 je	 SHORT $LN1@PyMemoTabl@5

; 544  :             to_process--;

  001c4	48 8b 44 24 38	 mov	 rax, QWORD PTR to_process$[rsp]
  001c9	48 ff c8	 dec	 rax
  001cc	48 89 44 24 38	 mov	 QWORD PTR to_process$[rsp], rax

; 545  :             /* newentry is a pointer to a chunk of the new
; 546  :                mt_table, so we're setting the key:value pair
; 547  :                in-place. */
; 548  :             newentry = _PyMemoTable_Lookup(self, oldentry->me_key);

  001d1	48 8b 44 24 40	 mov	 rax, QWORD PTR oldentry$[rsp]
  001d6	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001d9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001de	e8 00 00 00 00	 call	 _PyMemoTable_Lookup
  001e3	48 89 44 24 28	 mov	 QWORD PTR newentry$[rsp], rax

; 549  :             newentry->me_key = oldentry->me_key;

  001e8	48 8b 44 24 28	 mov	 rax, QWORD PTR newentry$[rsp]
  001ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR oldentry$[rsp]
  001f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001f5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 550  :             newentry->me_value = oldentry->me_value;

  001f8	48 8b 44 24 28	 mov	 rax, QWORD PTR newentry$[rsp]
  001fd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR oldentry$[rsp]
  00202	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00206	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN1@PyMemoTabl@5:

; 551  :         }
; 552  :     }

  0020a	eb 97		 jmp	 SHORT $LN3@PyMemoTabl@5
$LN2@PyMemoTabl@5:

; 553  : 
; 554  :     /* Deallocate the old table. */
; 555  :     PyMem_FREE(oldtable);

  0020c	e8 00 00 00 00	 call	 _Py_PXCTX
  00211	85 c0		 test	 eax, eax
  00213	74 14		 je	 SHORT $LN17@PyMemoTabl@5
  00215	48 8b 4c 24 30	 mov	 rcx, QWORD PTR oldtable$[rsp]
  0021a	e8 00 00 00 00	 call	 _PxMem_Free
  0021f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
  00227	eb 12		 jmp	 SHORT $LN18@PyMemoTabl@5
$LN17@PyMemoTabl@5:
  00229	48 8b 4c 24 30	 mov	 rcx, QWORD PTR oldtable$[rsp]
  0022e	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00233	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN18@PyMemoTabl@5:

; 556  :     return 0;

  0023b	33 c0		 xor	 eax, eax
$LN9@PyMemoTabl@5:

; 557  : }

  0023d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00241	c3		 ret	 0
_PyMemoTable_ResizeTable ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LALEGHBC@cannot?5serialize?5a?5string?5larger@ ; `string'
PUBLIC	??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_05CAMHEFLG@utf?98?$AA@			; `string'
PUBLIC	??_C@_0O@BNPCNOJJ@surrogatepass?$AA@		; `string'
EXTRN	PyUnicode_AsEncodedString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_unicode DD imagerel save_unicode
	DD	imagerel save_unicode+702
	DD	imagerel $unwind$save_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_unicode DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0CM@LALEGHBC@cannot?5serialize?5a?5string?5larger@
CONST	SEGMENT
??_C@_0CM@LALEGHBC@cannot?5serialize?5a?5string?5larger@ DB 'cannot seria'
	DB	'lize a string larger than 4 GiB', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'd', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAMHEFLG@utf?98?$AA@
CONST	SEGMENT
??_C@_05CAMHEFLG@utf?98?$AA@ DB 'utf-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNPCNOJJ@surrogatepass?$AA@
CONST	SEGMENT
??_C@_0O@BNPCNOJJ@surrogatepass?$AA@ DB 'surrogatepass', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_unicode
_TEXT	SEGMENT
encoded$ = 32
size$ = 40
pdata$21764 = 48
unicode_op$21786 = 56
self$ = 80
obj$ = 88
save_unicode PROC					; COMDAT

; 1877 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1878 :     Py_ssize_t size;
; 1879 :     PyObject *encoded = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR encoded$[rsp], 0

; 1880 : 
; 1881 :     if (self->bin) {

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001c	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [rax+164], 0
  00023	0f 84 5a 01 00
	00		 je	 $LN15@save_unico

; 1882 :         char pdata[5];
; 1883 : 
; 1884 :         encoded = PyUnicode_AsEncodedString(obj, "utf-8", "surrogatepass");

  00029	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNPCNOJJ@surrogatepass?$AA@
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  00037	48 8b 4c 24 58	 mov	 rcx, QWORD PTR obj$[rsp]
  0003c	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString
  00041	48 89 44 24 20	 mov	 QWORD PTR encoded$[rsp], rax

; 1885 :         if (encoded == NULL)

  00046	48 83 7c 24 20
	00		 cmp	 QWORD PTR encoded$[rsp], 0
  0004c	75 05		 jne	 SHORT $LN14@save_unico

; 1886 :             goto error;

  0004e	e9 49 02 00 00	 jmp	 $error$21769
$LN14@save_unico:

; 1887 : 
; 1888 :         size = PyBytes_GET_SIZE(encoded);

  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR encoded$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00062	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00067	85 c0		 test	 eax, eax
  00069	75 1c		 jne	 SHORT $LN18@save_unico
  0006b	41 b8 60 07 00
	00		 mov	 r8d, 1888		; 00000760H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00085	33 c0		 xor	 eax, eax
$LN18@save_unico:
  00087	48 8b 44 24 20	 mov	 rax, QWORD PTR encoded$[rsp]
  0008c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00090	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 1889 :         if (size > 0xffffffffL) {

  00095	b8 ff ff ff ff	 mov	 eax, -1
  0009a	48 39 44 24 28	 cmp	 QWORD PTR size$[rsp], rax
  0009f	7e 18		 jle	 SHORT $LN13@save_unico

; 1890 :             PyErr_SetString(PyExc_OverflowError,
; 1891 :                             "cannot serialize a string larger than 4 GiB");

  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@LALEGHBC@cannot?5serialize?5a?5string?5larger@
  000a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000af	e8 00 00 00 00	 call	 PyErr_SetString

; 1892 :             goto error;          /* string too large */

  000b4	e9 e3 01 00 00	 jmp	 $error$21769
$LN13@save_unico:

; 1893 :         }
; 1894 : 
; 1895 :         pdata[0] = BINUNICODE;

  000b9	c6 44 24 30 58	 mov	 BYTE PTR pdata$21764[rsp], 88 ; 00000058H

; 1896 :         pdata[1] = (unsigned char)(size & 0xff);

  000be	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000c3	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  000c9	88 44 24 31	 mov	 BYTE PTR pdata$21764[rsp+1], al

; 1897 :         pdata[2] = (unsigned char)((size >> 8) & 0xff);

  000cd	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000d2	48 c1 f8 08	 sar	 rax, 8
  000d6	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  000dc	88 44 24 32	 mov	 BYTE PTR pdata$21764[rsp+2], al

; 1898 :         pdata[3] = (unsigned char)((size >> 16) & 0xff);

  000e0	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000e5	48 c1 f8 10	 sar	 rax, 16
  000e9	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  000ef	88 44 24 33	 mov	 BYTE PTR pdata$21764[rsp+3], al

; 1899 :         pdata[4] = (unsigned char)((size >> 24) & 0xff);

  000f3	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000f8	48 c1 f8 18	 sar	 rax, 24
  000fc	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00102	88 44 24 34	 mov	 BYTE PTR pdata$21764[rsp+4], al

; 1900 : 
; 1901 :         if (_Pickler_Write(self, pdata, 5) < 0)

  00106	41 b8 05 00 00
	00		 mov	 r8d, 5
  0010c	48 8d 54 24 30	 lea	 rdx, QWORD PTR pdata$21764[rsp]
  00111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00116	e8 00 00 00 00	 call	 _Pickler_Write
  0011b	48 85 c0	 test	 rax, rax
  0011e	7d 05		 jge	 SHORT $LN12@save_unico

; 1902 :             goto error;

  00120	e9 77 01 00 00	 jmp	 $error$21769
$LN12@save_unico:

; 1903 : 
; 1904 :         if (_Pickler_Write(self, PyBytes_AS_STRING(encoded), size) < 0)

  00125	48 8b 44 24 20	 mov	 rax, QWORD PTR encoded$[rsp]
  0012a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0012e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00134	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00139	85 c0		 test	 eax, eax
  0013b	75 1c		 jne	 SHORT $LN19@save_unico
  0013d	41 b8 70 07 00
	00		 mov	 r8d, 1904		; 00000770H
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00157	33 c0		 xor	 eax, eax
$LN19@save_unico:
  00159	48 8b 44 24 20	 mov	 rax, QWORD PTR encoded$[rsp]
  0015e	48 83 c0 78	 add	 rax, 120		; 00000078H
  00162	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  00167	48 8b d0	 mov	 rdx, rax
  0016a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0016f	e8 00 00 00 00	 call	 _Pickler_Write
  00174	48 85 c0	 test	 rax, rax
  00177	7d 05		 jge	 SHORT $LN11@save_unico

; 1905 :             goto error;

  00179	e9 1e 01 00 00	 jmp	 $error$21769
$LN11@save_unico:

; 1906 :     }
; 1907 :     else {

  0017e	e9 f6 00 00 00	 jmp	 $LN10@save_unico
$LN15@save_unico:

; 1908 :         const char unicode_op = UNICODE;

  00183	c6 44 24 38 56	 mov	 BYTE PTR unicode_op$21786[rsp], 86 ; 00000056H

; 1909 : 
; 1910 :         encoded = raw_unicode_escape(obj);

  00188	48 8b 4c 24 58	 mov	 rcx, QWORD PTR obj$[rsp]
  0018d	e8 00 00 00 00	 call	 raw_unicode_escape
  00192	48 89 44 24 20	 mov	 QWORD PTR encoded$[rsp], rax

; 1911 :         if (encoded == NULL)

  00197	48 83 7c 24 20
	00		 cmp	 QWORD PTR encoded$[rsp], 0
  0019d	75 05		 jne	 SHORT $LN9@save_unico

; 1912 :             goto error;

  0019f	e9 f8 00 00 00	 jmp	 $error$21769
$LN9@save_unico:

; 1913 : 
; 1914 :         if (_Pickler_Write(self, &unicode_op, 1) < 0)

  001a4	41 b8 01 00 00
	00		 mov	 r8d, 1
  001aa	48 8d 54 24 38	 lea	 rdx, QWORD PTR unicode_op$21786[rsp]
  001af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  001b4	e8 00 00 00 00	 call	 _Pickler_Write
  001b9	48 85 c0	 test	 rax, rax
  001bc	7d 05		 jge	 SHORT $LN8@save_unico

; 1915 :             goto error;

  001be	e9 d9 00 00 00	 jmp	 $error$21769
$LN8@save_unico:

; 1916 : 
; 1917 :         size = PyBytes_GET_SIZE(encoded);

  001c3	48 8b 44 24 20	 mov	 rax, QWORD PTR encoded$[rsp]
  001c8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001cc	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001d2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001d7	85 c0		 test	 eax, eax
  001d9	75 1c		 jne	 SHORT $LN20@save_unico
  001db	41 b8 7d 07 00
	00		 mov	 r8d, 1917		; 0000077dH
  001e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f5	33 c0		 xor	 eax, eax
$LN20@save_unico:
  001f7	48 8b 44 24 20	 mov	 rax, QWORD PTR encoded$[rsp]
  001fc	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00200	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 1918 :         if (_Pickler_Write(self, PyBytes_AS_STRING(encoded), size) < 0)

  00205	48 8b 44 24 20	 mov	 rax, QWORD PTR encoded$[rsp]
  0020a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0020e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00214	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00219	85 c0		 test	 eax, eax
  0021b	75 1c		 jne	 SHORT $LN21@save_unico
  0021d	41 b8 7e 07 00
	00		 mov	 r8d, 1918		; 0000077eH
  00223	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0022a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00237	33 c0		 xor	 eax, eax
$LN21@save_unico:
  00239	48 8b 44 24 20	 mov	 rax, QWORD PTR encoded$[rsp]
  0023e	48 83 c0 78	 add	 rax, 120		; 00000078H
  00242	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  00247	48 8b d0	 mov	 rdx, rax
  0024a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0024f	e8 00 00 00 00	 call	 _Pickler_Write
  00254	48 85 c0	 test	 rax, rax
  00257	7d 02		 jge	 SHORT $LN7@save_unico

; 1919 :             goto error;

  00259	eb 41		 jmp	 SHORT $error$21769
$LN7@save_unico:

; 1920 : 
; 1921 :         if (_Pickler_Write(self, "\n", 1) < 0)

  0025b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00261	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00268	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0026d	e8 00 00 00 00	 call	 _Pickler_Write
  00272	48 85 c0	 test	 rax, rax
  00275	7d 02		 jge	 SHORT $LN6@save_unico

; 1922 :             goto error;

  00277	eb 23		 jmp	 SHORT $error$21769
$LN6@save_unico:
$LN10@save_unico:

; 1923 :     }
; 1924 :     if (memo_put(self, obj) < 0)

  00279	48 8b 54 24 58	 mov	 rdx, QWORD PTR obj$[rsp]
  0027e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00283	e8 00 00 00 00	 call	 memo_put
  00288	85 c0		 test	 eax, eax
  0028a	7d 02		 jge	 SHORT $LN5@save_unico

; 1925 :         goto error;

  0028c	eb 0e		 jmp	 SHORT $error$21769
$LN5@save_unico:

; 1926 : 
; 1927 :     Py_DECREF(encoded);

  0028e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR encoded$[rsp]
  00293	e8 00 00 00 00	 call	 _Py_DecRef

; 1928 :     return 0;

  00298	33 c0		 xor	 eax, eax
  0029a	eb 1d		 jmp	 SHORT $LN16@save_unico
$error$21769:
$LN4@save_unico:

; 1929 : 
; 1930 :   error:
; 1931 :     Py_XDECREF(encoded);

  0029c	48 83 7c 24 20
	00		 cmp	 QWORD PTR encoded$[rsp], 0
  002a2	74 0a		 je	 SHORT $LN1@save_unico
  002a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR encoded$[rsp]
  002a9	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@save_unico:
  002ae	33 c0		 xor	 eax, eax
  002b0	85 c0		 test	 eax, eax
  002b2	75 e8		 jne	 SHORT $LN4@save_unico

; 1932 :     return -1;

  002b4	b8 ff ff ff ff	 mov	 eax, -1
$LN16@save_unico:

; 1933 : }

  002b9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002bd	c3		 ret	 0
save_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DA@BEFBIMLJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@FHOLGKIM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@ ; `string'
PUBLIC	??_C@_1DA@OCGMGMDG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@KFNFIMBM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	Py_hexdigits:QWORD
EXTRN	_PyByteArray_empty_string:BYTE
EXTRN	PyByteArray_Type:BYTE
EXTRN	PyByteArray_FromStringAndSize:PROC
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$raw_unicode_escape DD imagerel raw_unicode_escape
	DD	imagerel raw_unicode_escape+2080
	DD	imagerel $unwind$raw_unicode_escape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$raw_unicode_escape DD 020c01H
	DD	015010cH
xdata	ENDS
;	COMDAT ??_C@_1DA@BEFBIMLJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@BEFBIMLJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'r', 00H, 'e', 00H
	DB	'p', 00H, 'r', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@FHOLGKIM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
CONST	SEGMENT
??_C@_1EI@FHOLGKIM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, ')', 00H, '-', 00H, '>'
	DB	00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, '.', 00H, 'a', 00H
	DB	'n', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@OCGMGMDG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@OCGMGMDG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'o', 00H
	DB	'b', 00H, 'j', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@KFNFIMBM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@KFNFIMBM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT raw_unicode_escape
_TEXT	SEGMENT
kind$ = 32
p$ = 40
i$ = 48
size$ = 56
data$ = 64
expandsize$ = 72
repr$ = 80
result$ = 88
ch$21732 = 96
tv78 = 100
tv162 = 104
tv171 = 112
tv215 = 120
tv228 = 128
tv227 = 132
tv310 = 136
tv328 = 144
obj$ = 176
raw_unicode_escape PROC					; COMDAT

; 1812 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1813 :     PyObject *repr, *result;
; 1814 :     char *p;
; 1815 :     Py_ssize_t i, size, expandsize;
; 1816 :     void *data;
; 1817 :     unsigned int kind;
; 1818 : 
; 1819 :     if (PyUnicode_READY(obj))

  0000c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00014	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00018	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00023	85 c0		 test	 eax, eax
  00025	75 1c		 jne	 SHORT $LN17@raw_unicod
  00027	41 b8 1b 07 00
	00		 mov	 r8d, 1819		; 0000071bH
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@KFNFIMBM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00041	33 c0		 xor	 eax, eax
$LN17@raw_unicod:
  00043	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  0004b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0004e	c1 e8 07	 shr	 eax, 7
  00051	83 e0 01	 and	 eax, 1
  00054	85 c0		 test	 eax, eax
  00056	74 0a		 je	 SHORT $LN18@raw_unicod
  00058	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  00060	eb 11		 jmp	 SHORT $LN19@raw_unicod
$LN18@raw_unicod:
  00062	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  0006a	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0006f	89 44 24 64	 mov	 DWORD PTR tv78[rsp], eax
$LN19@raw_unicod:
  00073	83 7c 24 64 00	 cmp	 DWORD PTR tv78[rsp], 0
  00078	74 07		 je	 SHORT $LN14@raw_unicod

; 1820 :         return NULL;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 97 07 00 00	 jmp	 $LN15@raw_unicod
$LN14@raw_unicod:

; 1821 : 
; 1822 :     size = PyUnicode_GET_LENGTH(obj);

  00081	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00089	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00093	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00098	85 c0		 test	 eax, eax
  0009a	75 1c		 jne	 SHORT $LN20@raw_unicod
  0009c	41 b8 1e 07 00
	00		 mov	 r8d, 1822		; 0000071eH
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@KFNFIMBM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b6	33 c0		 xor	 eax, eax
$LN20@raw_unicod:
  000b8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  000c0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000c3	c1 e8 07	 shr	 eax, 7
  000c6	83 e0 01	 and	 eax, 1
  000c9	85 c0		 test	 eax, eax
  000cb	75 1c		 jne	 SHORT $LN21@raw_unicod
  000cd	41 b8 1e 07 00
	00		 mov	 r8d, 1822		; 0000071eH
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@OCGMGMDG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e7	33 c0		 xor	 eax, eax
$LN21@raw_unicod:
  000e9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  000f1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000f5	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax

; 1823 :     data = PyUnicode_DATA(obj);

  000fa	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00102	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00106	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0010c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00111	85 c0		 test	 eax, eax
  00113	75 1c		 jne	 SHORT $LN22@raw_unicod
  00115	41 b8 1f 07 00
	00		 mov	 r8d, 1823		; 0000071fH
  0011b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@KFNFIMBM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0012f	33 c0		 xor	 eax, eax
$LN22@raw_unicod:
  00131	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00139	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0013c	c1 e8 05	 shr	 eax, 5
  0013f	83 e0 01	 and	 eax, 1
  00142	85 c0		 test	 eax, eax
  00144	0f 84 b1 00 00
	00		 je	 $LN28@raw_unicod
  0014a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00152	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00156	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0015c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00161	85 c0		 test	 eax, eax
  00163	75 1c		 jne	 SHORT $LN23@raw_unicod
  00165	41 b8 1f 07 00
	00		 mov	 r8d, 1823		; 0000071fH
  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@KFNFIMBM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0017f	33 c0		 xor	 eax, eax
$LN23@raw_unicod:
  00181	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00189	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0018c	c1 e8 07	 shr	 eax, 7
  0018f	83 e0 01	 and	 eax, 1
  00192	85 c0		 test	 eax, eax
  00194	75 1c		 jne	 SHORT $LN24@raw_unicod
  00196	41 b8 1f 07 00
	00		 mov	 r8d, 1823		; 0000071fH
  0019c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@OCGMGMDG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b0	33 c0		 xor	 eax, eax
$LN24@raw_unicod:
  001b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  001ba	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001bd	c1 e8 06	 shr	 eax, 6
  001c0	83 e0 01	 and	 eax, 1
  001c3	85 c0		 test	 eax, eax
  001c5	74 15		 je	 SHORT $LN25@raw_unicod
  001c7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  001cf	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  001d5	48 89 44 24 68	 mov	 QWORD PTR tv162[rsp], rax
  001da	eb 13		 jmp	 SHORT $LN26@raw_unicod
$LN25@raw_unicod:
  001dc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  001e4	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  001ea	48 89 44 24 68	 mov	 QWORD PTR tv162[rsp], rax
$LN26@raw_unicod:
  001ef	48 8b 44 24 68	 mov	 rax, QWORD PTR tv162[rsp]
  001f4	48 89 44 24 70	 mov	 QWORD PTR tv171[rsp], rax
  001f9	eb 42		 jmp	 SHORT $LN29@raw_unicod
$LN28@raw_unicod:
  001fb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00203	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  0020b	75 1c		 jne	 SHORT $LN27@raw_unicod
  0020d	41 b8 1f 07 00
	00		 mov	 r8d, 1823		; 0000071fH
  00213	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0021a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@FHOLGKIM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
  00221	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00227	33 c0		 xor	 eax, eax
$LN27@raw_unicod:
  00229	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00231	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00238	48 89 44 24 70	 mov	 QWORD PTR tv171[rsp], rax
$LN29@raw_unicod:
  0023d	48 8b 44 24 70	 mov	 rax, QWORD PTR tv171[rsp]
  00242	48 89 44 24 40	 mov	 QWORD PTR data$[rsp], rax

; 1824 :     kind = PyUnicode_KIND(obj);

  00247	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  0024f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00253	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00259	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0025e	85 c0		 test	 eax, eax
  00260	75 1c		 jne	 SHORT $LN30@raw_unicod
  00262	41 b8 20 07 00
	00		 mov	 r8d, 1824		; 00000720H
  00268	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0026f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@KFNFIMBM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00276	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0027c	33 c0		 xor	 eax, eax
$LN30@raw_unicod:
  0027e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00286	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00289	c1 e8 07	 shr	 eax, 7
  0028c	83 e0 01	 and	 eax, 1
  0028f	85 c0		 test	 eax, eax
  00291	75 1c		 jne	 SHORT $LN31@raw_unicod
  00293	41 b8 20 07 00
	00		 mov	 r8d, 1824		; 00000720H
  00299	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@OCGMGMDG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ad	33 c0		 xor	 eax, eax
$LN31@raw_unicod:
  002af	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  002b7	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002ba	c1 e8 02	 shr	 eax, 2
  002bd	83 e0 07	 and	 eax, 7
  002c0	89 44 24 20	 mov	 DWORD PTR kind$[rsp], eax

; 1825 :     if (kind == PyUnicode_4BYTE_KIND)

  002c4	83 7c 24 20 04	 cmp	 DWORD PTR kind$[rsp], 4
  002c9	75 0b		 jne	 SHORT $LN13@raw_unicod

; 1826 :         expandsize = 10;

  002cb	48 c7 44 24 48
	0a 00 00 00	 mov	 QWORD PTR expandsize$[rsp], 10

; 1827 :     else

  002d4	eb 09		 jmp	 SHORT $LN12@raw_unicod
$LN13@raw_unicod:

; 1828 :         expandsize = 6;

  002d6	48 c7 44 24 48
	06 00 00 00	 mov	 QWORD PTR expandsize$[rsp], 6
$LN12@raw_unicod:

; 1829 : 
; 1830 :     if (size > PY_SSIZE_T_MAX / expandsize)

  002df	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  002e9	48 99		 cdq
  002eb	48 f7 7c 24 48	 idiv	 QWORD PTR expandsize$[rsp]
  002f0	48 39 44 24 38	 cmp	 QWORD PTR size$[rsp], rax
  002f5	7e 0a		 jle	 SHORT $LN11@raw_unicod

; 1831 :         return PyErr_NoMemory();

  002f7	e8 00 00 00 00	 call	 PyErr_NoMemory
  002fc	e9 17 05 00 00	 jmp	 $LN15@raw_unicod
$LN11@raw_unicod:

; 1832 :     repr = PyByteArray_FromStringAndSize(NULL, expandsize * size);

  00301	48 8b 44 24 48	 mov	 rax, QWORD PTR expandsize$[rsp]
  00306	48 0f af 44 24
	38		 imul	 rax, QWORD PTR size$[rsp]
  0030c	48 8b d0	 mov	 rdx, rax
  0030f	33 c9		 xor	 ecx, ecx
  00311	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00316	48 89 44 24 50	 mov	 QWORD PTR repr$[rsp], rax

; 1833 :     if (repr == NULL)

  0031b	48 83 7c 24 50
	00		 cmp	 QWORD PTR repr$[rsp], 0
  00321	75 07		 jne	 SHORT $LN10@raw_unicod

; 1834 :         return NULL;

  00323	33 c0		 xor	 eax, eax
  00325	e9 ee 04 00 00	 jmp	 $LN15@raw_unicod
$LN10@raw_unicod:

; 1835 :     if (size == 0)

  0032a	48 83 7c 24 38
	00		 cmp	 QWORD PTR size$[rsp], 0
  00330	75 05		 jne	 SHORT $LN9@raw_unicod

; 1836 :         goto done;

  00332	e9 43 04 00 00	 jmp	 $done$21722
$LN9@raw_unicod:

; 1837 : 
; 1838 :     p = PyByteArray_AS_STRING(repr);

  00337	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0033e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR repr$[rsp]
  00343	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00347	74 35		 je	 SHORT $LN32@raw_unicod
  00349	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00350	48 8b 44 24 50	 mov	 rax, QWORD PTR repr$[rsp]
  00355	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00359	e8 00 00 00 00	 call	 PyType_IsSubtype
  0035e	85 c0		 test	 eax, eax
  00360	75 1c		 jne	 SHORT $LN32@raw_unicod
  00362	41 b8 2e 07 00
	00		 mov	 r8d, 1838		; 0000072eH
  00368	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@BEFBIMLJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  00376	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0037c	33 c0		 xor	 eax, eax
$LN32@raw_unicod:
  0037e	48 8b 44 24 50	 mov	 rax, QWORD PTR repr$[rsp]
  00383	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00388	74 13		 je	 SHORT $LN33@raw_unicod
  0038a	48 8b 44 24 50	 mov	 rax, QWORD PTR repr$[rsp]
  0038f	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00396	48 89 44 24 78	 mov	 QWORD PTR tv215[rsp], rax
  0039b	eb 0c		 jmp	 SHORT $LN34@raw_unicod
$LN33@raw_unicod:
  0039d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  003a4	48 89 44 24 78	 mov	 QWORD PTR tv215[rsp], rax
$LN34@raw_unicod:
  003a9	48 8b 44 24 78	 mov	 rax, QWORD PTR tv215[rsp]
  003ae	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1839 :     for (i=0; i < size; i++) {

  003b3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  003bc	eb 0d		 jmp	 SHORT $LN8@raw_unicod
$LN7@raw_unicod:
  003be	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  003c3	48 ff c0	 inc	 rax
  003c6	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN8@raw_unicod:
  003cb	48 8b 44 24 38	 mov	 rax, QWORD PTR size$[rsp]
  003d0	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  003d5	0f 8d 0f 03 00
	00		 jge	 $LN6@raw_unicod

; 1840 :         Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  003db	83 7c 24 20 01	 cmp	 DWORD PTR kind$[rsp], 1
  003e0	75 1c		 jne	 SHORT $LN37@raw_unicod
  003e2	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  003e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  003ec	48 03 c8	 add	 rcx, rax
  003ef	48 8b c1	 mov	 rax, rcx
  003f2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003f5	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv228[rsp], eax
  003fc	eb 40		 jmp	 SHORT $LN38@raw_unicod
$LN37@raw_unicod:
  003fe	83 7c 24 20 02	 cmp	 DWORD PTR kind$[rsp], 2
  00403	75 17		 jne	 SHORT $LN35@raw_unicod
  00405	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  0040a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0040f	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00413	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv227[rsp], eax
  0041a	eb 14		 jmp	 SHORT $LN36@raw_unicod
$LN35@raw_unicod:
  0041c	48 8b 44 24 40	 mov	 rax, QWORD PTR data$[rsp]
  00421	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00426	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00429	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv227[rsp], eax
$LN36@raw_unicod:
  00430	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv227[rsp]
  00437	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv228[rsp], eax
$LN38@raw_unicod:
  0043e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv228[rsp]
  00445	89 44 24 60	 mov	 DWORD PTR ch$21732[rsp], eax

; 1841 :         /* Map 32-bit characters to '\Uxxxxxxxx' */
; 1842 :         if (ch >= 0x10000) {

  00449	81 7c 24 60 00
	00 01 00	 cmp	 DWORD PTR ch$21732[rsp], 65536 ; 00010000H
  00451	0f 82 84 01 00
	00		 jb	 $LN5@raw_unicod

; 1843 :             *p++ = '\\';

  00457	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0045c	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  0045f	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00464	48 ff c0	 inc	 rax
  00467	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1844 :             *p++ = 'U';

  0046c	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00471	c6 00 55	 mov	 BYTE PTR [rax], 85	; 00000055H
  00474	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00479	48 ff c0	 inc	 rax
  0047c	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1845 :             *p++ = Py_hexdigits[(ch >> 28) & 0xf];

  00481	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  00485	c1 e8 1c	 shr	 eax, 28
  00488	83 e0 0f	 and	 eax, 15
  0048b	8b c0		 mov	 eax, eax
  0048d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00492	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  00499	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0049d	88 01		 mov	 BYTE PTR [rcx], al
  0049f	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  004a4	48 ff c0	 inc	 rax
  004a7	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1846 :             *p++ = Py_hexdigits[(ch >> 24) & 0xf];

  004ac	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  004b0	c1 e8 18	 shr	 eax, 24
  004b3	83 e0 0f	 and	 eax, 15
  004b6	8b c0		 mov	 eax, eax
  004b8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  004bd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  004c4	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  004c8	88 01		 mov	 BYTE PTR [rcx], al
  004ca	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  004cf	48 ff c0	 inc	 rax
  004d2	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1847 :             *p++ = Py_hexdigits[(ch >> 20) & 0xf];

  004d7	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  004db	c1 e8 14	 shr	 eax, 20
  004de	83 e0 0f	 and	 eax, 15
  004e1	8b c0		 mov	 eax, eax
  004e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  004e8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  004ef	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  004f3	88 01		 mov	 BYTE PTR [rcx], al
  004f5	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  004fa	48 ff c0	 inc	 rax
  004fd	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1848 :             *p++ = Py_hexdigits[(ch >> 16) & 0xf];

  00502	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  00506	c1 e8 10	 shr	 eax, 16
  00509	83 e0 0f	 and	 eax, 15
  0050c	8b c0		 mov	 eax, eax
  0050e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00513	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  0051a	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0051e	88 01		 mov	 BYTE PTR [rcx], al
  00520	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00525	48 ff c0	 inc	 rax
  00528	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1849 :             *p++ = Py_hexdigits[(ch >> 12) & 0xf];

  0052d	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  00531	c1 e8 0c	 shr	 eax, 12
  00534	83 e0 0f	 and	 eax, 15
  00537	8b c0		 mov	 eax, eax
  00539	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  0053e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  00545	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00549	88 01		 mov	 BYTE PTR [rcx], al
  0054b	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00550	48 ff c0	 inc	 rax
  00553	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1850 :             *p++ = Py_hexdigits[(ch >> 8) & 0xf];

  00558	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  0055c	c1 e8 08	 shr	 eax, 8
  0055f	83 e0 0f	 and	 eax, 15
  00562	8b c0		 mov	 eax, eax
  00564	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00569	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  00570	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00574	88 01		 mov	 BYTE PTR [rcx], al
  00576	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0057b	48 ff c0	 inc	 rax
  0057e	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1851 :             *p++ = Py_hexdigits[(ch >> 4) & 0xf];

  00583	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  00587	c1 e8 04	 shr	 eax, 4
  0058a	83 e0 0f	 and	 eax, 15
  0058d	8b c0		 mov	 eax, eax
  0058f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00594	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  0059b	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0059f	88 01		 mov	 BYTE PTR [rcx], al
  005a1	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  005a6	48 ff c0	 inc	 rax
  005a9	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1852 :             *p++ = Py_hexdigits[ch & 15];

  005ae	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  005b2	83 e0 0f	 and	 eax, 15
  005b5	8b c0		 mov	 eax, eax
  005b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  005bc	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  005c3	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  005c7	88 01		 mov	 BYTE PTR [rcx], al
  005c9	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  005ce	48 ff c0	 inc	 rax
  005d1	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
  005d6	e9 0a 01 00 00	 jmp	 $LN4@raw_unicod
$LN5@raw_unicod:

; 1853 :         }
; 1854 :         /* Map 16-bit characters to '\uxxxx' */
; 1855 :         else if (ch >= 256 || ch == '\\' || ch == '\n') {

  005db	81 7c 24 60 00
	01 00 00	 cmp	 DWORD PTR ch$21732[rsp], 256 ; 00000100H
  005e3	73 12		 jae	 SHORT $LN2@raw_unicod
  005e5	83 7c 24 60 5c	 cmp	 DWORD PTR ch$21732[rsp], 92 ; 0000005cH
  005ea	74 0b		 je	 SHORT $LN2@raw_unicod
  005ec	83 7c 24 60 0a	 cmp	 DWORD PTR ch$21732[rsp], 10
  005f1	0f 85 d5 00 00
	00		 jne	 $LN3@raw_unicod
$LN2@raw_unicod:

; 1856 :             *p++ = '\\';

  005f7	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  005fc	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  005ff	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00604	48 ff c0	 inc	 rax
  00607	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1857 :             *p++ = 'u';

  0060c	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00611	c6 00 75	 mov	 BYTE PTR [rax], 117	; 00000075H
  00614	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00619	48 ff c0	 inc	 rax
  0061c	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1858 :             *p++ = Py_hexdigits[(ch >> 12) & 0xf];

  00621	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  00625	c1 e8 0c	 shr	 eax, 12
  00628	83 e0 0f	 and	 eax, 15
  0062b	8b c0		 mov	 eax, eax
  0062d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00632	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  00639	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0063d	88 01		 mov	 BYTE PTR [rcx], al
  0063f	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00644	48 ff c0	 inc	 rax
  00647	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1859 :             *p++ = Py_hexdigits[(ch >> 8) & 0xf];

  0064c	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  00650	c1 e8 08	 shr	 eax, 8
  00653	83 e0 0f	 and	 eax, 15
  00656	8b c0		 mov	 eax, eax
  00658	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  0065d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  00664	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00668	88 01		 mov	 BYTE PTR [rcx], al
  0066a	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0066f	48 ff c0	 inc	 rax
  00672	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1860 :             *p++ = Py_hexdigits[(ch >> 4) & 0xf];

  00677	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  0067b	c1 e8 04	 shr	 eax, 4
  0067e	83 e0 0f	 and	 eax, 15
  00681	8b c0		 mov	 eax, eax
  00683	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00688	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  0068f	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00693	88 01		 mov	 BYTE PTR [rcx], al
  00695	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0069a	48 ff c0	 inc	 rax
  0069d	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1861 :             *p++ = Py_hexdigits[ch & 15];

  006a2	8b 44 24 60	 mov	 eax, DWORD PTR ch$21732[rsp]
  006a6	83 e0 0f	 and	 eax, 15
  006a9	8b c0		 mov	 eax, eax
  006ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  006b0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  006b7	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  006bb	88 01		 mov	 BYTE PTR [rcx], al
  006bd	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  006c2	48 ff c0	 inc	 rax
  006c5	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1862 :         }
; 1863 :         /* Copy everything else as-is */
; 1864 :         else

  006ca	eb 19		 jmp	 SHORT $LN1@raw_unicod
$LN3@raw_unicod:

; 1865 :             *p++ = (char) ch;

  006cc	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  006d1	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR ch$21732[rsp]
  006d6	88 08		 mov	 BYTE PTR [rax], cl
  006d8	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  006dd	48 ff c0	 inc	 rax
  006e0	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
$LN1@raw_unicod:
$LN4@raw_unicod:

; 1866 :     }

  006e5	e9 d4 fc ff ff	 jmp	 $LN7@raw_unicod
$LN6@raw_unicod:

; 1867 :     size = p - PyByteArray_AS_STRING(repr);

  006ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  006f1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR repr$[rsp]
  006f6	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  006fa	74 35		 je	 SHORT $LN39@raw_unicod
  006fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00703	48 8b 44 24 50	 mov	 rax, QWORD PTR repr$[rsp]
  00708	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0070c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00711	85 c0		 test	 eax, eax
  00713	75 1c		 jne	 SHORT $LN39@raw_unicod
  00715	41 b8 4b 07 00
	00		 mov	 r8d, 1867		; 0000074bH
  0071b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00722	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@BEFBIMLJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  00729	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0072f	33 c0		 xor	 eax, eax
$LN39@raw_unicod:
  00731	48 8b 44 24 50	 mov	 rax, QWORD PTR repr$[rsp]
  00736	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0073b	74 16		 je	 SHORT $LN40@raw_unicod
  0073d	48 8b 44 24 50	 mov	 rax, QWORD PTR repr$[rsp]
  00742	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00749	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv310[rsp], rax
  00751	eb 0f		 jmp	 SHORT $LN41@raw_unicod
$LN40@raw_unicod:
  00753	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0075a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv310[rsp], rax
$LN41@raw_unicod:
  00762	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv310[rsp]
  0076a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  0076f	48 2b c8	 sub	 rcx, rax
  00772	48 8b c1	 mov	 rax, rcx
  00775	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax
$done$21722:

; 1868 : 
; 1869 : done:
; 1870 :     result = PyBytes_FromStringAndSize(PyByteArray_AS_STRING(repr), size);

  0077a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00781	48 8b 4c 24 50	 mov	 rcx, QWORD PTR repr$[rsp]
  00786	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0078a	74 35		 je	 SHORT $LN42@raw_unicod
  0078c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00793	48 8b 44 24 50	 mov	 rax, QWORD PTR repr$[rsp]
  00798	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0079c	e8 00 00 00 00	 call	 PyType_IsSubtype
  007a1	85 c0		 test	 eax, eax
  007a3	75 1c		 jne	 SHORT $LN42@raw_unicod
  007a5	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  007ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  007b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@BEFBIMLJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  007b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  007bf	33 c0		 xor	 eax, eax
$LN42@raw_unicod:
  007c1	48 8b 44 24 50	 mov	 rax, QWORD PTR repr$[rsp]
  007c6	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  007cb	74 16		 je	 SHORT $LN43@raw_unicod
  007cd	48 8b 44 24 50	 mov	 rax, QWORD PTR repr$[rsp]
  007d2	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  007d9	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv328[rsp], rax
  007e1	eb 0f		 jmp	 SHORT $LN44@raw_unicod
$LN43@raw_unicod:
  007e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  007ea	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv328[rsp], rax
$LN44@raw_unicod:
  007f2	48 8b 54 24 38	 mov	 rdx, QWORD PTR size$[rsp]
  007f7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv328[rsp]
  007ff	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00804	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 1871 :     Py_DECREF(repr);

  00809	48 8b 4c 24 50	 mov	 rcx, QWORD PTR repr$[rsp]
  0080e	e8 00 00 00 00	 call	 _Py_DecRef

; 1872 :     return result;

  00813	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
$LN15@raw_unicod:

; 1873 : }

  00818	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0081f	c3		 ret	 0
raw_unicode_escape ENDP
_TEXT	ENDS
EXTRN	PyTuple_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_tuple DD imagerel save_tuple
	DD	imagerel save_tuple+754
	DD	imagerel $unwind$save_tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_tuple DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT save_tuple
_TEXT	SEGMENT
i$ = 32
pop_mark_op$ = 40
len$ = 48
len2opcode$ = 56
tuple_op$ = 60
mark_op$ = 61
pop_op$ = 62
pdata$21839 = 64
self$ = 96
obj$ = 104
save_tuple PROC						; COMDAT

; 1963 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1964 :     Py_ssize_t len, i;
; 1965 : 
; 1966 :     const char mark_op = MARK;

  0000e	c6 44 24 3d 28	 mov	 BYTE PTR mark_op$[rsp], 40 ; 00000028H

; 1967 :     const char tuple_op = TUPLE;

  00013	c6 44 24 3c 74	 mov	 BYTE PTR tuple_op$[rsp], 116 ; 00000074H

; 1968 :     const char pop_op = POP;

  00018	c6 44 24 3e 30	 mov	 BYTE PTR pop_op$[rsp], 48 ; 00000030H

; 1969 :     const char pop_mark_op = POP_MARK;

  0001d	c6 44 24 28 31	 mov	 BYTE PTR pop_mark_op$[rsp], 49 ; 00000031H

; 1970 :     const char len2opcode[] = {EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3};

  00022	c6 44 24 38 29	 mov	 BYTE PTR len2opcode$[rsp], 41 ; 00000029H
  00027	c6 44 24 39 85	 mov	 BYTE PTR len2opcode$[rsp+1], -123 ; ffffffffffffff85H
  0002c	c6 44 24 3a 86	 mov	 BYTE PTR len2opcode$[rsp+2], -122 ; ffffffffffffff86H
  00031	c6 44 24 3b 87	 mov	 BYTE PTR len2opcode$[rsp+3], -121 ; ffffffffffffff87H

; 1971 : 
; 1972 :     if ((len = PyTuple_Size(obj)) < 0)

  00036	48 8b 4c 24 68	 mov	 rcx, QWORD PTR obj$[rsp]
  0003b	e8 00 00 00 00	 call	 PyTuple_Size
  00040	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax
  00045	48 83 7c 24 30
	00		 cmp	 QWORD PTR len$[rsp], 0
  0004b	7d 0a		 jge	 SHORT $LN29@save_tuple

; 1973 :         return -1;

  0004d	b8 ff ff ff ff	 mov	 eax, -1
  00052	e9 96 02 00 00	 jmp	 $LN30@save_tuple
$LN29@save_tuple:

; 1974 : 
; 1975 :     if (len == 0) {

  00057	48 83 7c 24 30
	00		 cmp	 QWORD PTR len$[rsp], 0
  0005d	75 5b		 jne	 SHORT $LN28@save_tuple

; 1976 :         char pdata[2];
; 1977 : 
; 1978 :         if (self->proto) {

  0005f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00064	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  0006b	74 10		 je	 SHORT $LN27@save_tuple

; 1979 :             pdata[0] = EMPTY_TUPLE;

  0006d	c6 44 24 40 29	 mov	 BYTE PTR pdata$21839[rsp], 41 ; 00000029H

; 1980 :             len = 1;

  00072	48 c7 44 24 30
	01 00 00 00	 mov	 QWORD PTR len$[rsp], 1

; 1981 :         }
; 1982 :         else {

  0007b	eb 13		 jmp	 SHORT $LN26@save_tuple
$LN27@save_tuple:

; 1983 :             pdata[0] = MARK;

  0007d	c6 44 24 40 28	 mov	 BYTE PTR pdata$21839[rsp], 40 ; 00000028H

; 1984 :             pdata[1] = TUPLE;

  00082	c6 44 24 41 74	 mov	 BYTE PTR pdata$21839[rsp+1], 116 ; 00000074H

; 1985 :             len = 2;

  00087	48 c7 44 24 30
	02 00 00 00	 mov	 QWORD PTR len$[rsp], 2
$LN26@save_tuple:

; 1986 :         }
; 1987 :         if (_Pickler_Write(self, pdata, len) < 0)

  00090	4c 8b 44 24 30	 mov	 r8, QWORD PTR len$[rsp]
  00095	48 8d 54 24 40	 lea	 rdx, QWORD PTR pdata$21839[rsp]
  0009a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0009f	e8 00 00 00 00	 call	 _Pickler_Write
  000a4	48 85 c0	 test	 rax, rax
  000a7	7d 0a		 jge	 SHORT $LN25@save_tuple

; 1988 :             return -1;

  000a9	b8 ff ff ff ff	 mov	 eax, -1
  000ae	e9 3a 02 00 00	 jmp	 $LN30@save_tuple
$LN25@save_tuple:

; 1989 :         return 0;

  000b3	33 c0		 xor	 eax, eax
  000b5	e9 33 02 00 00	 jmp	 $LN30@save_tuple
$LN28@save_tuple:

; 1990 :     }
; 1991 : 
; 1992 :     /* The tuple isn't in the memo now.  If it shows up there after
; 1993 :      * saving the tuple elements, the tuple must be recursive, in
; 1994 :      * which case we'll pop everything we put on the stack, and fetch
; 1995 :      * its value from the memo.
; 1996 :      */
; 1997 :     if (len <= 3 && self->proto >= 2) {

  000ba	48 83 7c 24 30
	03		 cmp	 QWORD PTR len$[rsp], 3
  000c0	0f 8f ed 00 00
	00		 jg	 $LN24@save_tuple
  000c6	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000cb	83 b8 a0 00 00
	00 02		 cmp	 DWORD PTR [rax+160], 2
  000d2	0f 8c db 00 00
	00		 jl	 $LN24@save_tuple

; 1998 :         /* Use TUPLE{1,2,3} opcodes. */
; 1999 :         if (store_tuple_elements(self, obj, len) < 0)

  000d8	4c 8b 44 24 30	 mov	 r8, QWORD PTR len$[rsp]
  000dd	48 8b 54 24 68	 mov	 rdx, QWORD PTR obj$[rsp]
  000e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000e7	e8 00 00 00 00	 call	 store_tuple_elements
  000ec	85 c0		 test	 eax, eax
  000ee	7d 0a		 jge	 SHORT $LN23@save_tuple

; 2000 :             return -1;

  000f0	b8 ff ff ff ff	 mov	 eax, -1
  000f5	e9 f3 01 00 00	 jmp	 $LN30@save_tuple
$LN23@save_tuple:

; 2001 : 
; 2002 :         if (PyMemoTable_Get(self->memo, obj)) {

  000fa	48 8b 54 24 68	 mov	 rdx, QWORD PTR obj$[rsp]
  000ff	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00104	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00108	e8 00 00 00 00	 call	 PyMemoTable_Get
  0010d	48 85 c0	 test	 rax, rax
  00110	74 70		 je	 SHORT $LN22@save_tuple

; 2003 :             /* pop the len elements */
; 2004 :             for (i = 0; i < len; i++)

  00112	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0011b	eb 0d		 jmp	 SHORT $LN21@save_tuple
$LN20@save_tuple:
  0011d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00122	48 ff c0	 inc	 rax
  00125	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN21@save_tuple:
  0012a	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  0012f	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00134	7d 26		 jge	 SHORT $LN19@save_tuple

; 2005 :                 if (_Pickler_Write(self, &pop_op, 1) < 0)

  00136	41 b8 01 00 00
	00		 mov	 r8d, 1
  0013c	48 8d 54 24 3e	 lea	 rdx, QWORD PTR pop_op$[rsp]
  00141	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00146	e8 00 00 00 00	 call	 _Pickler_Write
  0014b	48 85 c0	 test	 rax, rax
  0014e	7d 0a		 jge	 SHORT $LN18@save_tuple

; 2006 :                     return -1;

  00150	b8 ff ff ff ff	 mov	 eax, -1
  00155	e9 93 01 00 00	 jmp	 $LN30@save_tuple
$LN18@save_tuple:

; 2007 :             /* fetch from memo */
; 2008 :             if (memo_get(self, obj) < 0)

  0015a	eb c1		 jmp	 SHORT $LN20@save_tuple
$LN19@save_tuple:
  0015c	48 8b 54 24 68	 mov	 rdx, QWORD PTR obj$[rsp]
  00161	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00166	e8 00 00 00 00	 call	 memo_get
  0016b	85 c0		 test	 eax, eax
  0016d	7d 0a		 jge	 SHORT $LN17@save_tuple

; 2009 :                 return -1;

  0016f	b8 ff ff ff ff	 mov	 eax, -1
  00174	e9 74 01 00 00	 jmp	 $LN30@save_tuple
$LN17@save_tuple:

; 2010 : 
; 2011 :             return 0;

  00179	33 c0		 xor	 eax, eax
  0017b	e9 6d 01 00 00	 jmp	 $LN30@save_tuple

; 2012 :         }
; 2013 :         else { /* Not recursive. */

  00180	eb 2c		 jmp	 SHORT $LN16@save_tuple
$LN22@save_tuple:

; 2014 :             if (_Pickler_Write(self, len2opcode + len, 1) < 0)

  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00187	48 8d 44 04 38	 lea	 rax, QWORD PTR len2opcode$[rsp+rax]
  0018c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00192	48 8b d0	 mov	 rdx, rax
  00195	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0019a	e8 00 00 00 00	 call	 _Pickler_Write
  0019f	48 85 c0	 test	 rax, rax
  001a2	7d 0a		 jge	 SHORT $LN15@save_tuple

; 2015 :                 return -1;

  001a4	b8 ff ff ff ff	 mov	 eax, -1
  001a9	e9 3f 01 00 00	 jmp	 $LN30@save_tuple
$LN15@save_tuple:
$LN16@save_tuple:

; 2016 :         }
; 2017 :         goto memoize;

  001ae	e9 1e 01 00 00	 jmp	 $memoize$21853
$LN24@save_tuple:

; 2018 :     }
; 2019 : 
; 2020 :     /* proto < 2 and len > 0, or proto >= 2 and len > 3.
; 2021 :      * Generate MARK e1 e2 ... TUPLE
; 2022 :      */
; 2023 :     if (_Pickler_Write(self, &mark_op, 1) < 0)

  001b3	41 b8 01 00 00
	00		 mov	 r8d, 1
  001b9	48 8d 54 24 3d	 lea	 rdx, QWORD PTR mark_op$[rsp]
  001be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001c3	e8 00 00 00 00	 call	 _Pickler_Write
  001c8	48 85 c0	 test	 rax, rax
  001cb	7d 0a		 jge	 SHORT $LN14@save_tuple

; 2024 :         return -1;

  001cd	b8 ff ff ff ff	 mov	 eax, -1
  001d2	e9 16 01 00 00	 jmp	 $LN30@save_tuple
$LN14@save_tuple:

; 2025 : 
; 2026 :     if (store_tuple_elements(self, obj, len) < 0)

  001d7	4c 8b 44 24 30	 mov	 r8, QWORD PTR len$[rsp]
  001dc	48 8b 54 24 68	 mov	 rdx, QWORD PTR obj$[rsp]
  001e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001e6	e8 00 00 00 00	 call	 store_tuple_elements
  001eb	85 c0		 test	 eax, eax
  001ed	7d 0a		 jge	 SHORT $LN13@save_tuple

; 2027 :         return -1;

  001ef	b8 ff ff ff ff	 mov	 eax, -1
  001f4	e9 f4 00 00 00	 jmp	 $LN30@save_tuple
$LN13@save_tuple:

; 2028 : 
; 2029 :     if (PyMemoTable_Get(self->memo, obj)) {

  001f9	48 8b 54 24 68	 mov	 rdx, QWORD PTR obj$[rsp]
  001fe	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00203	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00207	e8 00 00 00 00	 call	 PyMemoTable_Get
  0020c	48 85 c0	 test	 rax, rax
  0020f	0f 84 9b 00 00
	00		 je	 $LN12@save_tuple

; 2030 :         /* pop the stack stuff we pushed */
; 2031 :         if (self->bin) {

  00215	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0021a	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [rax+164], 0
  00221	74 26		 je	 SHORT $LN11@save_tuple

; 2032 :             if (_Pickler_Write(self, &pop_mark_op, 1) < 0)

  00223	41 b8 01 00 00
	00		 mov	 r8d, 1
  00229	48 8d 54 24 28	 lea	 rdx, QWORD PTR pop_mark_op$[rsp]
  0022e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00233	e8 00 00 00 00	 call	 _Pickler_Write
  00238	48 85 c0	 test	 rax, rax
  0023b	7d 0a		 jge	 SHORT $LN10@save_tuple

; 2033 :                 return -1;

  0023d	b8 ff ff ff ff	 mov	 eax, -1
  00242	e9 a6 00 00 00	 jmp	 $LN30@save_tuple
$LN10@save_tuple:

; 2034 :         }
; 2035 :         else {

  00247	eb 47		 jmp	 SHORT $LN9@save_tuple
$LN11@save_tuple:

; 2036 :             /* Note that we pop one more than len, to remove
; 2037 :              * the MARK too.
; 2038 :              */
; 2039 :             for (i = 0; i <= len; i++)

  00249	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00252	eb 0d		 jmp	 SHORT $LN8@save_tuple
$LN7@save_tuple:
  00254	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00259	48 ff c0	 inc	 rax
  0025c	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN8@save_tuple:
  00261	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00266	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0026b	7f 23		 jg	 SHORT $LN6@save_tuple

; 2040 :                 if (_Pickler_Write(self, &pop_op, 1) < 0)

  0026d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00273	48 8d 54 24 3e	 lea	 rdx, QWORD PTR pop_op$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0027d	e8 00 00 00 00	 call	 _Pickler_Write
  00282	48 85 c0	 test	 rax, rax
  00285	7d 07		 jge	 SHORT $LN5@save_tuple

; 2041 :                     return -1;

  00287	b8 ff ff ff ff	 mov	 eax, -1
  0028c	eb 5f		 jmp	 SHORT $LN30@save_tuple
$LN5@save_tuple:

; 2042 :         }

  0028e	eb c4		 jmp	 SHORT $LN7@save_tuple
$LN6@save_tuple:
$LN9@save_tuple:

; 2043 :         /* fetch from memo */
; 2044 :         if (memo_get(self, obj) < 0)

  00290	48 8b 54 24 68	 mov	 rdx, QWORD PTR obj$[rsp]
  00295	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0029a	e8 00 00 00 00	 call	 memo_get
  0029f	85 c0		 test	 eax, eax
  002a1	7d 07		 jge	 SHORT $LN4@save_tuple

; 2045 :             return -1;

  002a3	b8 ff ff ff ff	 mov	 eax, -1
  002a8	eb 43		 jmp	 SHORT $LN30@save_tuple
$LN4@save_tuple:

; 2046 : 
; 2047 :         return 0;

  002aa	33 c0		 xor	 eax, eax
  002ac	eb 3f		 jmp	 SHORT $LN30@save_tuple

; 2048 :     }
; 2049 :     else { /* Not recursive. */

  002ae	eb 21		 jmp	 SHORT $LN3@save_tuple
$LN12@save_tuple:

; 2050 :         if (_Pickler_Write(self, &tuple_op, 1) < 0)

  002b0	41 b8 01 00 00
	00		 mov	 r8d, 1
  002b6	48 8d 54 24 3c	 lea	 rdx, QWORD PTR tuple_op$[rsp]
  002bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  002c0	e8 00 00 00 00	 call	 _Pickler_Write
  002c5	48 85 c0	 test	 rax, rax
  002c8	7d 07		 jge	 SHORT $LN2@save_tuple

; 2051 :             return -1;

  002ca	b8 ff ff ff ff	 mov	 eax, -1
  002cf	eb 1c		 jmp	 SHORT $LN30@save_tuple
$LN2@save_tuple:
$LN3@save_tuple:
$memoize$21853:

; 2052 :     }
; 2053 : 
; 2054 :   memoize:
; 2055 :     if (memo_put(self, obj) < 0)

  002d1	48 8b 54 24 68	 mov	 rdx, QWORD PTR obj$[rsp]
  002d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  002db	e8 00 00 00 00	 call	 memo_put
  002e0	85 c0		 test	 eax, eax
  002e2	7d 07		 jge	 SHORT $LN1@save_tuple

; 2056 :         return -1;

  002e4	b8 ff ff ff ff	 mov	 eax, -1
  002e9	eb 02		 jmp	 SHORT $LN30@save_tuple
$LN1@save_tuple:

; 2057 : 
; 2058 :     return 0;

  002eb	33 c0		 xor	 eax, eax
$LN30@save_tuple:

; 2059 : }

  002ed	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002f1	c3		 ret	 0
save_tuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CO@DOJKDPMP@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAl?$AAe?$AAn?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$store_tuple_elements DD imagerel store_tuple_elements
	DD	imagerel store_tuple_elements+173
	DD	imagerel $unwind$store_tuple_elements
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$store_tuple_elements DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1CO@DOJKDPMP@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAl?$AAe?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@DOJKDPMP@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAl?$AAe?$AAn?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'T', 00H, 'u', 00H, 'p', 00H, 'l', 00H, 'e', 00H
	DB	'_', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '(', 00H, 't'
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'l', 00H
	DB	'e', 00H, 'n', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT store_tuple_elements
_TEXT	SEGMENT
i$ = 32
element$21819 = 40
self$ = 64
t$ = 72
len$ = 80
store_tuple_elements PROC				; COMDAT

; 1938 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1939 :     Py_ssize_t i;
; 1940 : 
; 1941 :     assert(PyTuple_Size(t) == len);

  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR t$[rsp]
  00018	e8 00 00 00 00	 call	 PyTuple_Size
  0001d	48 3b 44 24 50	 cmp	 rax, QWORD PTR len$[rsp]
  00022	74 1c		 je	 SHORT $LN8@store_tupl
  00024	41 b8 95 07 00
	00		 mov	 r8d, 1941		; 00000795H
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@DOJKDPMP@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAl?$AAe?$AAn?$AA?$AA@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003e	33 c0		 xor	 eax, eax
$LN8@store_tupl:

; 1942 : 
; 1943 :     for (i = 0; i < len; i++) {

  00040	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00049	eb 0d		 jmp	 SHORT $LN5@store_tupl
$LN4@store_tupl:
  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00050	48 ff c0	 inc	 rax
  00053	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN5@store_tupl:
  00058	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  0005d	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00062	7d 42		 jge	 SHORT $LN3@store_tupl

; 1944 :         PyObject *element = PyTuple_GET_ITEM(t, i);

  00064	48 8b 44 24 48	 mov	 rax, QWORD PTR t$[rsp]
  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0006e	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00073	48 89 44 24 28	 mov	 QWORD PTR element$21819[rsp], rax

; 1945 : 
; 1946 :         if (element == NULL)

  00078	48 83 7c 24 28
	00		 cmp	 QWORD PTR element$21819[rsp], 0
  0007e	75 07		 jne	 SHORT $LN2@store_tupl

; 1947 :             return -1;

  00080	b8 ff ff ff ff	 mov	 eax, -1
  00085	eb 21		 jmp	 SHORT $LN6@store_tupl
$LN2@store_tupl:

; 1948 :         if (save(self, element, 0) < 0)

  00087	45 33 c0	 xor	 r8d, r8d
  0008a	48 8b 54 24 28	 mov	 rdx, QWORD PTR element$21819[rsp]
  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00094	e8 00 00 00 00	 call	 save
  00099	85 c0		 test	 eax, eax
  0009b	7d 07		 jge	 SHORT $LN1@store_tupl

; 1949 :             return -1;

  0009d	b8 ff ff ff ff	 mov	 eax, -1
  000a2	eb 04		 jmp	 SHORT $LN6@store_tupl
$LN1@store_tupl:

; 1950 :     }

  000a4	eb a5		 jmp	 SHORT $LN4@store_tupl
$LN3@store_tupl:

; 1951 : 
; 1952 :     return 0;

  000a6	33 c0		 xor	 eax, eax
$LN6@store_tupl:

; 1953 : }

  000a8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ac	c3		 ret	 0
store_tuple_elements ENDP
_TEXT	ENDS
EXTRN	PyObject_GetIter:PROC
EXTRN	PyList_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_list DD imagerel save_list
	DD	imagerel save_list+777
	DD	imagerel $unwind$save_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_list DD 010e01H
	DD	0e20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT save_list
_TEXT	SEGMENT
len$ = 32
status$ = 40
header$ = 44
iter$22019 = 48
tv92 = 56
tv141 = 64
tv135 = 72
tv151 = 80
tv169 = 88
tv163 = 96
self$ = 128
obj$ = 136
save_list PROC						; COMDAT

; 2230 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2231 :     char header[3];
; 2232 :     Py_ssize_t len;
; 2233 :     int status = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 2234 : 
; 2235 :     if (self->fast && !fast_save_enter(self, obj))

  00016	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001e	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [rax+176], 0
  00025	74 1e		 je	 SHORT $LN22@save_list
  00027	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR obj$[rsp]
  0002f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00037	e8 00 00 00 00	 call	 fast_save_enter
  0003c	85 c0		 test	 eax, eax
  0003e	75 05		 jne	 SHORT $LN22@save_list

; 2236 :         goto error;

  00040	e9 81 02 00 00	 jmp	 $error$22003
$LN22@save_list:

; 2237 : 
; 2238 :     /* Create an empty list. */
; 2239 :     if (self->bin) {

  00045	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0004d	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [rax+164], 0
  00054	74 10		 je	 SHORT $LN21@save_list

; 2240 :         header[0] = EMPTY_LIST;

  00056	c6 44 24 2c 5d	 mov	 BYTE PTR header$[rsp], 93 ; 0000005dH

; 2241 :         len = 1;

  0005b	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR len$[rsp], 1

; 2242 :     }
; 2243 :     else {

  00064	eb 13		 jmp	 SHORT $LN20@save_list
$LN21@save_list:

; 2244 :         header[0] = MARK;

  00066	c6 44 24 2c 28	 mov	 BYTE PTR header$[rsp], 40 ; 00000028H

; 2245 :         header[1] = LIST;

  0006b	c6 44 24 2d 6c	 mov	 BYTE PTR header$[rsp+1], 108 ; 0000006cH

; 2246 :         len = 2;

  00070	48 c7 44 24 20
	02 00 00 00	 mov	 QWORD PTR len$[rsp], 2
$LN20@save_list:

; 2247 :     }
; 2248 : 
; 2249 :     if (_Pickler_Write(self, header, len) < 0)

  00079	4c 8b 44 24 20	 mov	 r8, QWORD PTR len$[rsp]
  0007e	48 8d 54 24 2c	 lea	 rdx, QWORD PTR header$[rsp]
  00083	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0008b	e8 00 00 00 00	 call	 _Pickler_Write
  00090	48 85 c0	 test	 rax, rax
  00093	7d 05		 jge	 SHORT $LN19@save_list

; 2250 :         goto error;

  00095	e9 2c 02 00 00	 jmp	 $error$22003
$LN19@save_list:

; 2251 : 
; 2252 :     /* Get list length, and bow out early if empty. */
; 2253 :     if ((len = PyList_Size(obj)) < 0)

  0009a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  000a2	e8 00 00 00 00	 call	 PyList_Size
  000a7	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax
  000ac	48 83 7c 24 20
	00		 cmp	 QWORD PTR len$[rsp], 0
  000b2	7d 05		 jge	 SHORT $LN18@save_list

; 2254 :         goto error;

  000b4	e9 0d 02 00 00	 jmp	 $error$22003
$LN18@save_list:

; 2255 : 
; 2256 :     if (memo_put(self, obj) < 0)

  000b9	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR obj$[rsp]
  000c1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000c9	e8 00 00 00 00	 call	 memo_put
  000ce	85 c0		 test	 eax, eax
  000d0	7d 05		 jge	 SHORT $LN17@save_list

; 2257 :         goto error;

  000d2	e9 ef 01 00 00	 jmp	 $error$22003
$LN17@save_list:

; 2258 : 
; 2259 :     if (len != 0) {

  000d7	48 83 7c 24 20
	00		 cmp	 QWORD PTR len$[rsp], 0
  000dd	0f 84 dd 01 00
	00		 je	 $LN16@save_list

; 2260 :         /* Materialize the list elements. */
; 2261 :         if (PyList_CheckExact(obj) && self->proto > 0) {

  000e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  000ea	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  000f2	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f6	0f 85 d7 00 00
	00		 jne	 $LN15@save_list
  000fc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00104	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  0010b	0f 8e c2 00 00
	00		 jle	 $LN15@save_list

; 2262 :             if (Py_EnterRecursiveCall(" while pickling an object"))

  00111	e8 00 00 00 00	 call	 PyThreadState_Get
  00116	48 83 c0 18	 add	 rax, 24
  0011a	48 89 44 24 38	 mov	 QWORD PTR tv92[rsp], rax
  0011f	48 8b 44 24 38	 mov	 rax, QWORD PTR tv92[rsp]
  00124	8b 00		 mov	 eax, DWORD PTR [rax]
  00126	ff c0		 inc	 eax
  00128	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv92[rsp]
  0012d	89 01		 mov	 DWORD PTR [rcx], eax
  0012f	48 8b 44 24 38	 mov	 rax, QWORD PTR tv92[rsp]
  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  0013a	39 08		 cmp	 DWORD PTR [rax], ecx
  0013c	7e 15		 jle	 SHORT $LN14@save_list
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
  00145	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  0014a	85 c0		 test	 eax, eax
  0014c	74 05		 je	 SHORT $LN14@save_list

; 2263 :                 goto error;

  0014e	e9 73 01 00 00	 jmp	 $error$22003
$LN14@save_list:

; 2264 :             status = batch_list_exact(self, obj);

  00153	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR obj$[rsp]
  0015b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00163	e8 00 00 00 00	 call	 batch_list_exact
  00168	89 44 24 28	 mov	 DWORD PTR status$[rsp], eax
$LN13@save_list:

; 2265 :             Py_LeaveRecursiveCall();

  0016c	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  00173	7e 0f		 jle	 SHORT $LN25@save_list
  00175	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0017b	83 e8 32	 sub	 eax, 50			; 00000032H
  0017e	89 44 24 40	 mov	 DWORD PTR tv141[rsp], eax
  00182	eb 10		 jmp	 SHORT $LN26@save_list
$LN25@save_list:
  00184	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0018a	c1 f8 02	 sar	 eax, 2
  0018d	6b c0 03	 imul	 eax, 3
  00190	89 44 24 40	 mov	 DWORD PTR tv141[rsp], eax
$LN26@save_list:
  00194	e8 00 00 00 00	 call	 PyThreadState_Get
  00199	48 83 c0 18	 add	 rax, 24
  0019d	48 89 44 24 48	 mov	 QWORD PTR tv135[rsp], rax
  001a2	48 8b 44 24 48	 mov	 rax, QWORD PTR tv135[rsp]
  001a7	8b 00		 mov	 eax, DWORD PTR [rax]
  001a9	ff c8		 dec	 eax
  001ab	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv135[rsp]
  001b0	89 01		 mov	 DWORD PTR [rcx], eax
  001b2	48 8b 44 24 48	 mov	 rax, QWORD PTR tv135[rsp]
  001b7	8b 4c 24 40	 mov	 ecx, DWORD PTR tv141[rsp]
  001bb	39 08		 cmp	 DWORD PTR [rax], ecx
  001bd	7d 09		 jge	 SHORT $LN10@save_list
  001bf	e8 00 00 00 00	 call	 PyThreadState_Get
  001c4	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN10@save_list:
  001c8	33 c0		 xor	 eax, eax
  001ca	85 c0		 test	 eax, eax
  001cc	75 9e		 jne	 SHORT $LN13@save_list

; 2266 :         } else {

  001ce	e9 ed 00 00 00	 jmp	 $LN9@save_list
$LN15@save_list:

; 2267 :             PyObject *iter = PyObject_GetIter(obj);

  001d3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  001db	e8 00 00 00 00	 call	 PyObject_GetIter
  001e0	48 89 44 24 30	 mov	 QWORD PTR iter$22019[rsp], rax

; 2268 :             if (iter == NULL)

  001e5	48 83 7c 24 30
	00		 cmp	 QWORD PTR iter$22019[rsp], 0
  001eb	75 05		 jne	 SHORT $LN8@save_list

; 2269 :                 goto error;

  001ed	e9 d4 00 00 00	 jmp	 $error$22003
$LN8@save_list:

; 2270 : 
; 2271 :             if (Py_EnterRecursiveCall(" while pickling an object")) {

  001f2	e8 00 00 00 00	 call	 PyThreadState_Get
  001f7	48 83 c0 18	 add	 rax, 24
  001fb	48 89 44 24 50	 mov	 QWORD PTR tv151[rsp], rax
  00200	48 8b 44 24 50	 mov	 rax, QWORD PTR tv151[rsp]
  00205	8b 00		 mov	 eax, DWORD PTR [rax]
  00207	ff c0		 inc	 eax
  00209	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv151[rsp]
  0020e	89 01		 mov	 DWORD PTR [rcx], eax
  00210	48 8b 44 24 50	 mov	 rax, QWORD PTR tv151[rsp]
  00215	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  0021b	39 08		 cmp	 DWORD PTR [rax], ecx
  0021d	7e 1f		 jle	 SHORT $LN7@save_list
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
  00226	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  0022b	85 c0		 test	 eax, eax
  0022d	74 0f		 je	 SHORT $LN7@save_list

; 2272 :                 Py_DECREF(iter);

  0022f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iter$22019[rsp]
  00234	e8 00 00 00 00	 call	 _Py_DecRef

; 2273 :                 goto error;

  00239	e9 88 00 00 00	 jmp	 $error$22003
$LN7@save_list:

; 2274 :             }
; 2275 :             status = batch_list(self, iter);

  0023e	48 8b 54 24 30	 mov	 rdx, QWORD PTR iter$22019[rsp]
  00243	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0024b	e8 00 00 00 00	 call	 batch_list
  00250	89 44 24 28	 mov	 DWORD PTR status$[rsp], eax
$LN6@save_list:

; 2276 :             Py_LeaveRecursiveCall();

  00254	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  0025b	7e 0f		 jle	 SHORT $LN27@save_list
  0025d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00263	83 e8 32	 sub	 eax, 50			; 00000032H
  00266	89 44 24 58	 mov	 DWORD PTR tv169[rsp], eax
  0026a	eb 10		 jmp	 SHORT $LN28@save_list
$LN27@save_list:
  0026c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00272	c1 f8 02	 sar	 eax, 2
  00275	6b c0 03	 imul	 eax, 3
  00278	89 44 24 58	 mov	 DWORD PTR tv169[rsp], eax
$LN28@save_list:
  0027c	e8 00 00 00 00	 call	 PyThreadState_Get
  00281	48 83 c0 18	 add	 rax, 24
  00285	48 89 44 24 60	 mov	 QWORD PTR tv163[rsp], rax
  0028a	48 8b 44 24 60	 mov	 rax, QWORD PTR tv163[rsp]
  0028f	8b 00		 mov	 eax, DWORD PTR [rax]
  00291	ff c8		 dec	 eax
  00293	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv163[rsp]
  00298	89 01		 mov	 DWORD PTR [rcx], eax
  0029a	48 8b 44 24 60	 mov	 rax, QWORD PTR tv163[rsp]
  0029f	8b 4c 24 58	 mov	 ecx, DWORD PTR tv169[rsp]
  002a3	39 08		 cmp	 DWORD PTR [rax], ecx
  002a5	7d 09		 jge	 SHORT $LN3@save_list
  002a7	e8 00 00 00 00	 call	 PyThreadState_Get
  002ac	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN3@save_list:
  002b0	33 c0		 xor	 eax, eax
  002b2	85 c0		 test	 eax, eax
  002b4	75 9e		 jne	 SHORT $LN6@save_list

; 2277 :             Py_DECREF(iter);

  002b6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iter$22019[rsp]
  002bb	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@save_list:
$LN16@save_list:

; 2278 :         }
; 2279 :     }
; 2280 :     if (0) {

  002c0	33 c0		 xor	 eax, eax
  002c2	85 c0		 test	 eax, eax
  002c4	74 08		 je	 SHORT $LN2@save_list
$error$22003:

; 2281 :   error:
; 2282 :         status = -1;

  002c6	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1
$LN2@save_list:

; 2283 :     }
; 2284 : 
; 2285 :     if (self->fast && !fast_save_leave(self, obj))

  002ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002d6	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [rax+176], 0
  002dd	74 21		 je	 SHORT $LN1@save_list
  002df	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR obj$[rsp]
  002e7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002ef	e8 00 00 00 00	 call	 fast_save_leave
  002f4	85 c0		 test	 eax, eax
  002f6	75 08		 jne	 SHORT $LN1@save_list

; 2286 :         status = -1;

  002f8	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1
$LN1@save_list:

; 2287 : 
; 2288 :     return status;

  00300	8b 44 24 28	 mov	 eax, DWORD PTR status$[rsp]

; 2289 : }

  00304	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00308	c3		 ret	 0
save_list ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EK@PMPHMBHE@fast?5mode?3?5can?8t?5pickle?5cyclic?5o@ ; `string'
EXTRN	PyDict_SetItem:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyLong_FromVoidPtr:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fast_save_enter DD imagerel fast_save_enter
	DD	imagerel fast_save_enter+340
	DD	imagerel $unwind$fast_save_enter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fast_save_enter DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0EK@PMPHMBHE@fast?5mode?3?5can?8t?5pickle?5cyclic?5o@
CONST	SEGMENT
??_C@_0EK@PMPHMBHE@fast?5mode?3?5can?8t?5pickle?5cyclic?5o@ DB 'fast mode'
	DB	': can''t pickle cyclic objects including object type %.200s a'
	DB	't %p', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fast_save_enter
_TEXT	SEGMENT
key$21422 = 32
tv66 = 40
self$ = 64
obj$ = 72
fast_save_enter PROC					; COMDAT

; 1413 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1414 :     /* if fast_nesting < 0, we're doing an error exit. */
; 1415 :     if (++self->fast_nesting >= FAST_NESTING_LIMIT) {

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [rax+180]
  00019	ff c0		 inc	 eax
  0001b	89 44 24 28	 mov	 DWORD PTR tv66[rsp], eax
  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00024	8b 4c 24 28	 mov	 ecx, DWORD PTR tv66[rsp]
  00028	89 88 b4 00 00
	00		 mov	 DWORD PTR [rax+180], ecx
  0002e	83 7c 24 28 32	 cmp	 DWORD PTR tv66[rsp], 50	; 00000032H
  00033	0f 8c 11 01 00
	00		 jl	 $LN6@fast_save_

; 1416 :         PyObject *key = NULL;

  00039	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR key$21422[rsp], 0

; 1417 :         if (self->fast_memo == NULL) {

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00047	48 83 b8 c0 00
	00 00 00	 cmp	 QWORD PTR [rax+192], 0
  0004f	75 36		 jne	 SHORT $LN5@fast_save_

; 1418 :             self->fast_memo = PyDict_New();

  00051	e8 00 00 00 00	 call	 PyDict_New
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1419 :             if (self->fast_memo == NULL) {

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00067	48 83 b8 c0 00
	00 00 00	 cmp	 QWORD PTR [rax+192], 0
  0006f	75 16		 jne	 SHORT $LN4@fast_save_

; 1420 :                 self->fast_nesting = -1;

  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00076	c7 80 b4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+180], -1

; 1421 :                 return 0;

  00080	33 c0		 xor	 eax, eax
  00082	e9 c8 00 00 00	 jmp	 $LN7@fast_save_
$LN4@fast_save_:
$LN5@fast_save_:

; 1422 :             }
; 1423 :         }
; 1424 :         key = PyLong_FromVoidPtr(obj);

  00087	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obj$[rsp]
  0008c	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  00091	48 89 44 24 20	 mov	 QWORD PTR key$21422[rsp], rax

; 1425 :         if (key == NULL)

  00096	48 83 7c 24 20
	00		 cmp	 QWORD PTR key$21422[rsp], 0
  0009c	75 07		 jne	 SHORT $LN3@fast_save_

; 1426 :             return 0;

  0009e	33 c0		 xor	 eax, eax
  000a0	e9 aa 00 00 00	 jmp	 $LN7@fast_save_
$LN3@fast_save_:

; 1427 :         if (PyDict_GetItem(self->fast_memo, key)) {

  000a5	48 8b 54 24 20	 mov	 rdx, QWORD PTR key$21422[rsp]
  000aa	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000af	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]
  000b6	e8 00 00 00 00	 call	 PyDict_GetItem
  000bb	48 85 c0	 test	 rax, rax
  000be	74 42		 je	 SHORT $LN2@fast_save_

; 1428 :             Py_DECREF(key);

  000c0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR key$21422[rsp]
  000c5	e8 00 00 00 00	 call	 _Py_DecRef

; 1429 :             PyErr_Format(PyExc_ValueError,
; 1430 :                          "fast mode: can't pickle cyclic objects "
; 1431 :                          "including object type %.200s at %p",
; 1432 :                          obj->ob_type->tp_name, obj);

  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR obj$[rsp]
  000cf	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d3	4c 8b 4c 24 48	 mov	 r9, QWORD PTR obj$[rsp]
  000d8	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EK@PMPHMBHE@fast?5mode?3?5can?8t?5pickle?5cyclic?5o@
  000e3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ea	e8 00 00 00 00	 call	 PyErr_Format

; 1433 :             self->fast_nesting = -1;

  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000f4	c7 80 b4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+180], -1

; 1434 :             return 0;

  000fe	33 c0		 xor	 eax, eax
  00100	eb 4d		 jmp	 SHORT $LN7@fast_save_
$LN2@fast_save_:

; 1435 :         }
; 1436 :         if (PyDict_SetItem(self->fast_memo, key, Py_None) < 0) {

  00102	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00109	48 8b 54 24 20	 mov	 rdx, QWORD PTR key$21422[rsp]
  0010e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00113	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]
  0011a	e8 00 00 00 00	 call	 PyDict_SetItem
  0011f	85 c0		 test	 eax, eax
  00121	7d 1d		 jge	 SHORT $LN1@fast_save_

; 1437 :             Py_DECREF(key);

  00123	48 8b 4c 24 20	 mov	 rcx, QWORD PTR key$21422[rsp]
  00128	e8 00 00 00 00	 call	 _Py_DecRef

; 1438 :             self->fast_nesting = -1;

  0012d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00132	c7 80 b4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+180], -1

; 1439 :             return 0;

  0013c	33 c0		 xor	 eax, eax
  0013e	eb 0f		 jmp	 SHORT $LN7@fast_save_
$LN1@fast_save_:

; 1440 :         }
; 1441 :         Py_DECREF(key);

  00140	48 8b 4c 24 20	 mov	 rcx, QWORD PTR key$21422[rsp]
  00145	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@fast_save_:

; 1442 :     }
; 1443 :     return 1;

  0014a	b8 01 00 00 00	 mov	 eax, 1
$LN7@fast_save_:

; 1444 : }

  0014f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00153	c3		 ret	 0
fast_save_enter ENDP
_TEXT	ENDS
EXTRN	PyDict_DelItem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fast_save_leave DD imagerel fast_save_leave
	DD	imagerel fast_save_leave+141
	DD	imagerel $unwind$fast_save_leave
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fast_save_leave DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fast_save_leave
_TEXT	SEGMENT
key$21443 = 32
self$ = 64
obj$ = 72
fast_save_leave PROC					; COMDAT

; 1448 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1449 :     if (self->fast_nesting-- >= FAST_NESTING_LIMIT) {

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [rax+180]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	8b 89 b4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+180]
  00024	ff c9		 dec	 ecx
  00026	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  0002b	89 8a b4 00 00
	00		 mov	 DWORD PTR [rdx+180], ecx
  00031	83 f8 32	 cmp	 eax, 50			; 00000032H
  00034	7c 4d		 jl	 SHORT $LN3@fast_save_@2

; 1450 :         PyObject *key = PyLong_FromVoidPtr(obj);

  00036	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obj$[rsp]
  0003b	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  00040	48 89 44 24 20	 mov	 QWORD PTR key$21443[rsp], rax

; 1451 :         if (key == NULL)

  00045	48 83 7c 24 20
	00		 cmp	 QWORD PTR key$21443[rsp], 0
  0004b	75 04		 jne	 SHORT $LN2@fast_save_@2

; 1452 :             return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 37		 jmp	 SHORT $LN4@fast_save_@2
$LN2@fast_save_@2:

; 1453 :         if (PyDict_DelItem(self->fast_memo, key) < 0) {

  00051	48 8b 54 24 20	 mov	 rdx, QWORD PTR key$21443[rsp]
  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0005b	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]
  00062	e8 00 00 00 00	 call	 PyDict_DelItem
  00067	85 c0		 test	 eax, eax
  00069	7d 0e		 jge	 SHORT $LN1@fast_save_@2

; 1454 :             Py_DECREF(key);

  0006b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR key$21443[rsp]
  00070	e8 00 00 00 00	 call	 _Py_DecRef

; 1455 :             return 0;

  00075	33 c0		 xor	 eax, eax
  00077	eb 0f		 jmp	 SHORT $LN4@fast_save_@2
$LN1@fast_save_@2:

; 1456 :         }
; 1457 :         Py_DECREF(key);

  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR key$21443[rsp]
  0007e	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@fast_save_@2:

; 1458 :     }
; 1459 :     return 1;

  00083	b8 01 00 00 00	 mov	 eax, 1
$LN4@fast_save_@2:

; 1460 : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
fast_save_leave ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BDEHMLLL@batch_list?$AA@		; `string'
PUBLIC	??_C@_1BK@LPPKMJEB@?$AAi?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PyIter_Next:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$batch_list DD imagerel batch_list
	DD	imagerel batch_list+961
	DD	imagerel $unwind$batch_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$batch_list DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0L@BDEHMLLL@batch_list?$AA@
CONST	SEGMENT
??_C@_0L@BDEHMLLL@batch_list?$AA@ DB 'batch_list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@LPPKMJEB@?$AAi?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@LPPKMJEB@?$AAi?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'i'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT batch_list
_TEXT	SEGMENT
appends_op$ = 48
n$ = 52
i$ = 56
append_op$ = 60
firstitem$ = 64
mark_op$ = 72
obj$ = 80
_py_tmp$21913 = 88
_py_tmp$21923 = 96
_py_tmp$21935 = 104
self$ = 128
iter$ = 136
batch_list PROC						; COMDAT

; 2069 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2070 :     PyObject *obj = NULL;

  0000e	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR obj$[rsp], 0

; 2071 :     PyObject *firstitem = NULL;

  00017	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR firstitem$[rsp], 0

; 2072 :     int i, n;
; 2073 : 
; 2074 :     const char mark_op = MARK;

  00020	c6 44 24 48 28	 mov	 BYTE PTR mark_op$[rsp], 40 ; 00000028H

; 2075 :     const char append_op = APPEND;

  00025	c6 44 24 3c 61	 mov	 BYTE PTR append_op$[rsp], 97 ; 00000061H

; 2076 :     const char appends_op = APPENDS;

  0002a	c6 44 24 30 65	 mov	 BYTE PTR appends_op$[rsp], 101 ; 00000065H

; 2077 : 
; 2078 :     assert(iter != NULL);

  0002f	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR iter$[rsp], 0
  00038	75 1c		 jne	 SHORT $LN48@batch_list
  0003a	41 b8 1e 08 00
	00		 mov	 r8d, 2078		; 0000081eH
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@LPPKMJEB@?$AAi?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00054	33 c0		 xor	 eax, eax
$LN48@batch_list:

; 2079 : 
; 2080 :     /* XXX: I think this function could be made faster by avoiding the
; 2081 :        iterator interface and fetching objects directly from list using
; 2082 :        PyList_GET_ITEM.
; 2083 :     */
; 2084 : 
; 2085 :     if (self->proto == 0) {

  00056	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005e	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  00065	0f 85 97 00 00
	00		 jne	 $LN45@batch_list
$LN44@batch_list:

; 2086 :         /* APPENDS isn't available; do one at a time. */
; 2087 :         for (;;) {
; 2088 :             obj = PyIter_Next(iter);

  0006b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00073	e8 00 00 00 00	 call	 PyIter_Next
  00078	48 89 44 24 50	 mov	 QWORD PTR obj$[rsp], rax

; 2089 :             if (obj == NULL) {

  0007d	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00083	75 16		 jne	 SHORT $LN42@batch_list

; 2090 :                 if (PyErr_Occurred())

  00085	e8 00 00 00 00	 call	 PyErr_Occurred
  0008a	48 85 c0	 test	 rax, rax
  0008d	74 0a		 je	 SHORT $LN41@batch_list

; 2091 :                     return -1;

  0008f	b8 ff ff ff ff	 mov	 eax, -1
  00094	e9 23 03 00 00	 jmp	 $LN46@batch_list
$LN41@batch_list:

; 2092 :                 break;

  00099	eb 60		 jmp	 SHORT $LN43@batch_list
$LN42@batch_list:

; 2093 :             }
; 2094 :             i = save(self, obj, 0);

  0009b	45 33 c0	 xor	 r8d, r8d
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR obj$[rsp]
  000a3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000ab	e8 00 00 00 00	 call	 save
  000b0	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax

; 2095 :             Py_DECREF(obj);

  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj$[rsp]
  000b9	e8 00 00 00 00	 call	 _Py_DecRef

; 2096 :             if (i < 0)

  000be	83 7c 24 38 00	 cmp	 DWORD PTR i$[rsp], 0
  000c3	7d 0a		 jge	 SHORT $LN40@batch_list

; 2097 :                 return -1;

  000c5	b8 ff ff ff ff	 mov	 eax, -1
  000ca	e9 ed 02 00 00	 jmp	 $LN46@batch_list
$LN40@batch_list:

; 2098 :             if (_Pickler_Write(self, &append_op, 1) < 0)

  000cf	41 b8 01 00 00
	00		 mov	 r8d, 1
  000d5	48 8d 54 24 3c	 lea	 rdx, QWORD PTR append_op$[rsp]
  000da	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000e2	e8 00 00 00 00	 call	 _Pickler_Write
  000e7	48 85 c0	 test	 rax, rax
  000ea	7d 0a		 jge	 SHORT $LN39@batch_list

; 2099 :                 return -1;

  000ec	b8 ff ff ff ff	 mov	 eax, -1
  000f1	e9 c6 02 00 00	 jmp	 $LN46@batch_list
$LN39@batch_list:

; 2100 :         }

  000f6	e9 70 ff ff ff	 jmp	 $LN44@batch_list
$LN43@batch_list:

; 2101 :         return 0;

  000fb	33 c0		 xor	 eax, eax
  000fd	e9 ba 02 00 00	 jmp	 $LN46@batch_list
$LN45@batch_list:
$LN38@batch_list:

; 2102 :     }
; 2103 : 
; 2104 :     /* proto > 0:  write in batches of BATCHSIZE. */
; 2105 :     do {
; 2106 :         /* Get first item */
; 2107 :         firstitem = PyIter_Next(iter);

  00102	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  0010a	e8 00 00 00 00	 call	 PyIter_Next
  0010f	48 89 44 24 40	 mov	 QWORD PTR firstitem$[rsp], rax

; 2108 :         if (firstitem == NULL) {

  00114	48 83 7c 24 40
	00		 cmp	 QWORD PTR firstitem$[rsp], 0
  0011a	75 14		 jne	 SHORT $LN35@batch_list

; 2109 :             if (PyErr_Occurred())

  0011c	e8 00 00 00 00	 call	 PyErr_Occurred
  00121	48 85 c0	 test	 rax, rax
  00124	74 05		 je	 SHORT $LN34@batch_list

; 2110 :                 goto error;

  00126	e9 5c 02 00 00	 jmp	 $error$21902
$LN34@batch_list:

; 2111 : 
; 2112 :             /* nothing more to add */
; 2113 :             break;

  0012b	e9 53 02 00 00	 jmp	 $LN36@batch_list
$LN35@batch_list:

; 2114 :         }
; 2115 : 
; 2116 :         /* Try to get a second item */
; 2117 :         obj = PyIter_Next(iter);

  00130	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00138	e8 00 00 00 00	 call	 PyIter_Next
  0013d	48 89 44 24 50	 mov	 QWORD PTR obj$[rsp], rax

; 2118 :         if (obj == NULL) {

  00142	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00148	0f 85 a9 00 00
	00		 jne	 $LN33@batch_list

; 2119 :             if (PyErr_Occurred())

  0014e	e8 00 00 00 00	 call	 PyErr_Occurred
  00153	48 85 c0	 test	 rax, rax
  00156	74 05		 je	 SHORT $LN32@batch_list

; 2120 :                 goto error;

  00158	e9 2a 02 00 00	 jmp	 $error$21902
$LN32@batch_list:

; 2121 : 
; 2122 :             /* Only one item to write */
; 2123 :             if (save(self, firstitem, 0) < 0)

  0015d	45 33 c0	 xor	 r8d, r8d
  00160	48 8b 54 24 40	 mov	 rdx, QWORD PTR firstitem$[rsp]
  00165	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0016d	e8 00 00 00 00	 call	 save
  00172	85 c0		 test	 eax, eax
  00174	7d 05		 jge	 SHORT $LN31@batch_list

; 2124 :                 goto error;

  00176	e9 0c 02 00 00	 jmp	 $error$21902
$LN31@batch_list:

; 2125 :             if (_Pickler_Write(self, &append_op, 1) < 0)

  0017b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00181	48 8d 54 24 3c	 lea	 rdx, QWORD PTR append_op$[rsp]
  00186	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0018e	e8 00 00 00 00	 call	 _Pickler_Write
  00193	48 85 c0	 test	 rax, rax
  00196	7d 05		 jge	 SHORT $LN30@batch_list

; 2126 :                 goto error;

  00198	e9 ea 01 00 00	 jmp	 $error$21902
$LN30@batch_list:
$LN29@batch_list:

; 2127 :             Py_CLEAR(firstitem);

  0019d	48 83 7c 24 40
	00		 cmp	 QWORD PTR firstitem$[rsp], 0
  001a3	74 47		 je	 SHORT $LN26@batch_list
  001a5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001ad	4c 8b 4c 24 40	 mov	 r9, QWORD PTR firstitem$[rsp]
  001b2	41 b8 4f 08 00
	00		 mov	 r8d, 2127		; 0000084fH
  001b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@BDEHMLLL@batch_list?$AA@
  001c6	e8 00 00 00 00	 call	 _PyParallel_Guard
  001cb	85 c0		 test	 eax, eax
  001cd	75 1d		 jne	 SHORT $LN26@batch_list
  001cf	48 8b 44 24 40	 mov	 rax, QWORD PTR firstitem$[rsp]
  001d4	48 89 44 24 58	 mov	 QWORD PTR _py_tmp$21913[rsp], rax
  001d9	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR firstitem$[rsp], 0
  001e2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _py_tmp$21913[rsp]
  001e7	e8 00 00 00 00	 call	 _Py_DecRef
$LN26@batch_list:
  001ec	33 c0		 xor	 eax, eax
  001ee	85 c0		 test	 eax, eax
  001f0	75 ab		 jne	 SHORT $LN29@batch_list

; 2128 :             break;

  001f2	e9 8c 01 00 00	 jmp	 $LN36@batch_list
$LN33@batch_list:

; 2129 :         }
; 2130 : 
; 2131 :         /* More than one item to write */
; 2132 : 
; 2133 :         /* Pump out MARK, items, APPENDS. */
; 2134 :         if (_Pickler_Write(self, &mark_op, 1) < 0)

  001f7	41 b8 01 00 00
	00		 mov	 r8d, 1
  001fd	48 8d 54 24 48	 lea	 rdx, QWORD PTR mark_op$[rsp]
  00202	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0020a	e8 00 00 00 00	 call	 _Pickler_Write
  0020f	48 85 c0	 test	 rax, rax
  00212	7d 05		 jge	 SHORT $LN25@batch_list

; 2135 :             goto error;

  00214	e9 6e 01 00 00	 jmp	 $error$21902
$LN25@batch_list:

; 2136 : 
; 2137 :         if (save(self, firstitem, 0) < 0)

  00219	45 33 c0	 xor	 r8d, r8d
  0021c	48 8b 54 24 40	 mov	 rdx, QWORD PTR firstitem$[rsp]
  00221	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00229	e8 00 00 00 00	 call	 save
  0022e	85 c0		 test	 eax, eax
  00230	7d 05		 jge	 SHORT $LN24@batch_list

; 2138 :             goto error;

  00232	e9 50 01 00 00	 jmp	 $error$21902
$LN24@batch_list:
$LN23@batch_list:

; 2139 :         Py_CLEAR(firstitem);

  00237	48 83 7c 24 40
	00		 cmp	 QWORD PTR firstitem$[rsp], 0
  0023d	74 47		 je	 SHORT $LN20@batch_list
  0023f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00247	4c 8b 4c 24 40	 mov	 r9, QWORD PTR firstitem$[rsp]
  0024c	41 b8 5b 08 00
	00		 mov	 r8d, 2139		; 0000085bH
  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00259	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@BDEHMLLL@batch_list?$AA@
  00260	e8 00 00 00 00	 call	 _PyParallel_Guard
  00265	85 c0		 test	 eax, eax
  00267	75 1d		 jne	 SHORT $LN20@batch_list
  00269	48 8b 44 24 40	 mov	 rax, QWORD PTR firstitem$[rsp]
  0026e	48 89 44 24 60	 mov	 QWORD PTR _py_tmp$21923[rsp], rax
  00273	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR firstitem$[rsp], 0
  0027c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _py_tmp$21923[rsp]
  00281	e8 00 00 00 00	 call	 _Py_DecRef
$LN20@batch_list:
  00286	33 c0		 xor	 eax, eax
  00288	85 c0		 test	 eax, eax
  0028a	75 ab		 jne	 SHORT $LN23@batch_list

; 2140 :         n = 1;

  0028c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR n$[rsp], 1
$LN19@batch_list:

; 2141 : 
; 2142 :         /* Fetch and save up to BATCHSIZE items */
; 2143 :         while (obj) {

  00294	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0029a	0f 84 b6 00 00
	00		 je	 $LN18@batch_list

; 2144 :             if (save(self, obj, 0) < 0)

  002a0	45 33 c0	 xor	 r8d, r8d
  002a3	48 8b 54 24 50	 mov	 rdx, QWORD PTR obj$[rsp]
  002a8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002b0	e8 00 00 00 00	 call	 save
  002b5	85 c0		 test	 eax, eax
  002b7	7d 05		 jge	 SHORT $LN17@batch_list

; 2145 :                 goto error;

  002b9	e9 c9 00 00 00	 jmp	 $error$21902
$LN17@batch_list:
$LN16@batch_list:

; 2146 :             Py_CLEAR(obj);

  002be	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  002c4	74 47		 je	 SHORT $LN13@batch_list
  002c6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002ce	4c 8b 4c 24 50	 mov	 r9, QWORD PTR obj$[rsp]
  002d3	41 b8 62 08 00
	00		 mov	 r8d, 2146		; 00000862H
  002d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@BDEHMLLL@batch_list?$AA@
  002e7	e8 00 00 00 00	 call	 _PyParallel_Guard
  002ec	85 c0		 test	 eax, eax
  002ee	75 1d		 jne	 SHORT $LN13@batch_list
  002f0	48 8b 44 24 50	 mov	 rax, QWORD PTR obj$[rsp]
  002f5	48 89 44 24 68	 mov	 QWORD PTR _py_tmp$21935[rsp], rax
  002fa	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR obj$[rsp], 0
  00303	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _py_tmp$21935[rsp]
  00308	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@batch_list:
  0030d	33 c0		 xor	 eax, eax
  0030f	85 c0		 test	 eax, eax
  00311	75 ab		 jne	 SHORT $LN16@batch_list

; 2147 :             n += 1;

  00313	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00317	ff c0		 inc	 eax
  00319	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 2148 : 
; 2149 :             if (n == BATCHSIZE)

  0031d	81 7c 24 34 e8
	03 00 00	 cmp	 DWORD PTR n$[rsp], 1000	; 000003e8H
  00325	75 02		 jne	 SHORT $LN12@batch_list

; 2150 :                 break;

  00327	eb 2d		 jmp	 SHORT $LN18@batch_list
$LN12@batch_list:

; 2151 : 
; 2152 :             obj = PyIter_Next(iter);

  00329	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00331	e8 00 00 00 00	 call	 PyIter_Next
  00336	48 89 44 24 50	 mov	 QWORD PTR obj$[rsp], rax

; 2153 :             if (obj == NULL) {

  0033b	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00341	75 0e		 jne	 SHORT $LN11@batch_list

; 2154 :                 if (PyErr_Occurred())

  00343	e8 00 00 00 00	 call	 PyErr_Occurred
  00348	48 85 c0	 test	 rax, rax
  0034b	74 02		 je	 SHORT $LN10@batch_list

; 2155 :                     goto error;

  0034d	eb 38		 jmp	 SHORT $error$21902
$LN10@batch_list:

; 2156 :                 break;

  0034f	eb 05		 jmp	 SHORT $LN18@batch_list
$LN11@batch_list:

; 2157 :             }
; 2158 :         }

  00351	e9 3e ff ff ff	 jmp	 $LN19@batch_list
$LN18@batch_list:

; 2159 : 
; 2160 :         if (_Pickler_Write(self, &appends_op, 1) < 0)

  00356	41 b8 01 00 00
	00		 mov	 r8d, 1
  0035c	48 8d 54 24 30	 lea	 rdx, QWORD PTR appends_op$[rsp]
  00361	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00369	e8 00 00 00 00	 call	 _Pickler_Write
  0036e	48 85 c0	 test	 rax, rax
  00371	7d 02		 jge	 SHORT $LN9@batch_list

; 2161 :             goto error;

  00373	eb 12		 jmp	 SHORT $error$21902
$LN9@batch_list:

; 2162 : 
; 2163 :     } while (n == BATCHSIZE);

  00375	81 7c 24 34 e8
	03 00 00	 cmp	 DWORD PTR n$[rsp], 1000	; 000003e8H
  0037d	0f 84 7f fd ff
	ff		 je	 $LN38@batch_list
$LN36@batch_list:

; 2164 :     return 0;

  00383	33 c0		 xor	 eax, eax
  00385	eb 35		 jmp	 SHORT $LN46@batch_list
$error$21902:
$LN8@batch_list:

; 2165 : 
; 2166 :   error:
; 2167 :     Py_XDECREF(firstitem);

  00387	48 83 7c 24 40
	00		 cmp	 QWORD PTR firstitem$[rsp], 0
  0038d	74 0a		 je	 SHORT $LN5@batch_list
  0038f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR firstitem$[rsp]
  00394	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@batch_list:
  00399	33 c0		 xor	 eax, eax
  0039b	85 c0		 test	 eax, eax
  0039d	75 e8		 jne	 SHORT $LN8@batch_list
$LN4@batch_list:

; 2168 :     Py_XDECREF(obj);

  0039f	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  003a5	74 0a		 je	 SHORT $LN1@batch_list
  003a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj$[rsp]
  003ac	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@batch_list:
  003b1	33 c0		 xor	 eax, eax
  003b3	85 c0		 test	 eax, eax
  003b5	75 e8		 jne	 SHORT $LN4@batch_list

; 2169 :     return -1;

  003b7	b8 ff ff ff ff	 mov	 eax, -1
$LN46@batch_list:

; 2170 : }

  003bc	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003c0	c3		 ret	 0
batch_list ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CO@FCCBCFFE@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@HGJIBKJH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@KHFAEIJG@?$AAo?$AAb?$AAj?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$batch_list_exact DD imagerel batch_list_exact
	DD	imagerel batch_list_exact+489
	DD	imagerel $unwind$batch_list_exact
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$batch_list_exact DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1CO@FCCBCFFE@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@FCCBCFFE@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'E', 00H, 'x'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, '(', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@HGJIBKJH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@HGJIBKJH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 't', 00H, 'o', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@KHFAEIJG@?$AAo?$AAb?$AAj?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@KHFAEIJG@?$AAo?$AAb?$AAj?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'o'
	DB	00H, 'b', 00H, 'j', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT batch_list_exact
_TEXT	SEGMENT
appends_op$ = 32
append_op$ = 33
total$ = 40
this_batch$ = 48
mark_op$ = 56
item$ = 64
self$ = 96
obj$ = 104
batch_list_exact PROC					; COMDAT

; 2185 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2186 :     PyObject *item = NULL;

  0000e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR item$[rsp], 0

; 2187 :     Py_ssize_t this_batch, total;
; 2188 : 
; 2189 :     const char append_op = APPEND;

  00017	c6 44 24 21 61	 mov	 BYTE PTR append_op$[rsp], 97 ; 00000061H

; 2190 :     const char appends_op = APPENDS;

  0001c	c6 44 24 20 65	 mov	 BYTE PTR appends_op$[rsp], 101 ; 00000065H

; 2191 :     const char mark_op = MARK;

  00021	c6 44 24 38 28	 mov	 BYTE PTR mark_op$[rsp], 40 ; 00000028H

; 2192 : 
; 2193 :     assert(obj != NULL);

  00026	48 83 7c 24 68
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0002c	75 1c		 jne	 SHORT $LN15@batch_list@2
  0002e	41 b8 91 08 00
	00		 mov	 r8d, 2193		; 00000891H
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@KHFAEIJG@?$AAo?$AAb?$AAj?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00048	33 c0		 xor	 eax, eax
$LN15@batch_list@2:

; 2194 :     assert(self->proto > 0);

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0004f	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  00056	7f 1c		 jg	 SHORT $LN16@batch_list@2
  00058	41 b8 92 08 00
	00		 mov	 r8d, 2194		; 00000892H
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@HGJIBKJH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00072	33 c0		 xor	 eax, eax
$LN16@batch_list@2:

; 2195 :     assert(PyList_CheckExact(obj));

  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  0007b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR obj$[rsp]
  00080	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00084	74 1c		 je	 SHORT $LN17@batch_list@2
  00086	41 b8 93 08 00
	00		 mov	 r8d, 2195		; 00000893H
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@FCCBCFFE@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a0	33 c0		 xor	 eax, eax
$LN17@batch_list@2:

; 2196 : 
; 2197 :     if (PyList_GET_SIZE(obj) == 1) {

  000a2	48 8b 44 24 68	 mov	 rax, QWORD PTR obj$[rsp]
  000a7	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  000ac	75 5c		 jne	 SHORT $LN12@batch_list@2

; 2198 :         item = PyList_GET_ITEM(obj, 0);

  000ae	48 8b 44 24 68	 mov	 rax, QWORD PTR obj$[rsp]
  000b3	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ba	48 89 44 24 40	 mov	 QWORD PTR item$[rsp], rax

; 2199 :         if (save(self, item, 0) < 0)

  000bf	45 33 c0	 xor	 r8d, r8d
  000c2	48 8b 54 24 40	 mov	 rdx, QWORD PTR item$[rsp]
  000c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000cc	e8 00 00 00 00	 call	 save
  000d1	85 c0		 test	 eax, eax
  000d3	7d 0a		 jge	 SHORT $LN11@batch_list@2

; 2200 :             return -1;

  000d5	b8 ff ff ff ff	 mov	 eax, -1
  000da	e9 05 01 00 00	 jmp	 $LN13@batch_list@2
$LN11@batch_list@2:

; 2201 :         if (_Pickler_Write(self, &append_op, 1) < 0)

  000df	41 b8 01 00 00
	00		 mov	 r8d, 1
  000e5	48 8d 54 24 21	 lea	 rdx, QWORD PTR append_op$[rsp]
  000ea	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000ef	e8 00 00 00 00	 call	 _Pickler_Write
  000f4	48 85 c0	 test	 rax, rax
  000f7	7d 0a		 jge	 SHORT $LN10@batch_list@2

; 2202 :             return -1;

  000f9	b8 ff ff ff ff	 mov	 eax, -1
  000fe	e9 e1 00 00 00	 jmp	 $LN13@batch_list@2
$LN10@batch_list@2:

; 2203 :         return 0;

  00103	33 c0		 xor	 eax, eax
  00105	e9 da 00 00 00	 jmp	 $LN13@batch_list@2
$LN12@batch_list@2:

; 2204 :     }
; 2205 : 
; 2206 :     /* Write in batches of BATCHSIZE. */
; 2207 :     total = 0;

  0010a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR total$[rsp], 0
$LN9@batch_list@2:

; 2208 :     do {
; 2209 :         this_batch = 0;

  00113	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR this_batch$[rsp], 0

; 2210 :         if (_Pickler_Write(self, &mark_op, 1) < 0)

  0011c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00122	48 8d 54 24 38	 lea	 rdx, QWORD PTR mark_op$[rsp]
  00127	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0012c	e8 00 00 00 00	 call	 _Pickler_Write
  00131	48 85 c0	 test	 rax, rax
  00134	7d 0a		 jge	 SHORT $LN6@batch_list@2

; 2211 :             return -1;

  00136	b8 ff ff ff ff	 mov	 eax, -1
  0013b	e9 a4 00 00 00	 jmp	 $LN13@batch_list@2
$LN6@batch_list@2:
$LN5@batch_list@2:

; 2212 :         while (total < PyList_GET_SIZE(obj)) {

  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR obj$[rsp]
  00145	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00149	48 39 44 24 28	 cmp	 QWORD PTR total$[rsp], rax
  0014e	7d 5d		 jge	 SHORT $LN4@batch_list@2

; 2213 :             item = PyList_GET_ITEM(obj, total);

  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR obj$[rsp]
  00155	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00159	48 8b 4c 24 28	 mov	 rcx, QWORD PTR total$[rsp]
  0015e	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00162	48 89 44 24 40	 mov	 QWORD PTR item$[rsp], rax

; 2214 :             if (save(self, item, 0) < 0)

  00167	45 33 c0	 xor	 r8d, r8d
  0016a	48 8b 54 24 40	 mov	 rdx, QWORD PTR item$[rsp]
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00174	e8 00 00 00 00	 call	 save
  00179	85 c0		 test	 eax, eax
  0017b	7d 07		 jge	 SHORT $LN3@batch_list@2

; 2215 :                 return -1;

  0017d	b8 ff ff ff ff	 mov	 eax, -1
  00182	eb 60		 jmp	 SHORT $LN13@batch_list@2
$LN3@batch_list@2:

; 2216 :             total++;

  00184	48 8b 44 24 28	 mov	 rax, QWORD PTR total$[rsp]
  00189	48 ff c0	 inc	 rax
  0018c	48 89 44 24 28	 mov	 QWORD PTR total$[rsp], rax

; 2217 :             if (++this_batch == BATCHSIZE)

  00191	48 8b 44 24 30	 mov	 rax, QWORD PTR this_batch$[rsp]
  00196	48 ff c0	 inc	 rax
  00199	48 89 44 24 30	 mov	 QWORD PTR this_batch$[rsp], rax
  0019e	48 81 7c 24 30
	e8 03 00 00	 cmp	 QWORD PTR this_batch$[rsp], 1000 ; 000003e8H
  001a7	75 02		 jne	 SHORT $LN2@batch_list@2

; 2218 :                 break;

  001a9	eb 02		 jmp	 SHORT $LN4@batch_list@2
$LN2@batch_list@2:

; 2219 :         }

  001ab	eb 93		 jmp	 SHORT $LN5@batch_list@2
$LN4@batch_list@2:

; 2220 :         if (_Pickler_Write(self, &appends_op, 1) < 0)

  001ad	41 b8 01 00 00
	00		 mov	 r8d, 1
  001b3	48 8d 54 24 20	 lea	 rdx, QWORD PTR appends_op$[rsp]
  001b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001bd	e8 00 00 00 00	 call	 _Pickler_Write
  001c2	48 85 c0	 test	 rax, rax
  001c5	7d 07		 jge	 SHORT $LN1@batch_list@2

; 2221 :             return -1;

  001c7	b8 ff ff ff ff	 mov	 eax, -1
  001cc	eb 16		 jmp	 SHORT $LN13@batch_list@2
$LN1@batch_list@2:

; 2222 : 
; 2223 :     } while (total < PyList_GET_SIZE(obj));

  001ce	48 8b 44 24 68	 mov	 rax, QWORD PTR obj$[rsp]
  001d3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001d7	48 39 44 24 28	 cmp	 QWORD PTR total$[rsp], rax
  001dc	0f 8c 31 ff ff
	ff		 jl	 $LN9@batch_list@2

; 2224 : 
; 2225 :     return 0;

  001e2	33 c0		 xor	 eax, eax
$LN13@batch_list@2:

; 2226 : }

  001e4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e8	c3		 ret	 0
batch_list_exact ENDP
_TEXT	ENDS
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	PyDict_Size:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_dict DD imagerel save_dict
	DD	imagerel save_dict+878
	DD	imagerel $unwind$save_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_dict DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_dict
_TEXT	SEGMENT
iter$ = 32
len$ = 40
status$ = 48
items$ = 56
header$ = 64
tv94 = 72
tv143 = 80
tv137 = 88
tv165 = 96
tv183 = 104
tv177 = 112
self$ = 144
obj$ = 152
save_dict PROC						; COMDAT

; 2489 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2490 :     PyObject *items, *iter;
; 2491 :     char header[3];
; 2492 :     Py_ssize_t len;
; 2493 :     int status = 0;

  00011	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 2494 : 
; 2495 :     if (self->fast && !fast_save_enter(self, obj))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00021	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [rax+176], 0
  00028	74 1e		 je	 SHORT $LN24@save_dict
  0002a	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR obj$[rsp]
  00032	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0003a	e8 00 00 00 00	 call	 fast_save_enter
  0003f	85 c0		 test	 eax, eax
  00041	75 05		 jne	 SHORT $LN24@save_dict

; 2496 :         goto error;

  00043	e9 e0 02 00 00	 jmp	 $error$22186
$LN24@save_dict:

; 2497 : 
; 2498 :     /* Create an empty dict. */
; 2499 :     if (self->bin) {

  00048	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00050	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [rax+164], 0
  00057	74 10		 je	 SHORT $LN23@save_dict

; 2500 :         header[0] = EMPTY_DICT;

  00059	c6 44 24 40 7d	 mov	 BYTE PTR header$[rsp], 125 ; 0000007dH

; 2501 :         len = 1;

  0005e	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR len$[rsp], 1

; 2502 :     }
; 2503 :     else {

  00067	eb 13		 jmp	 SHORT $LN22@save_dict
$LN23@save_dict:

; 2504 :         header[0] = MARK;

  00069	c6 44 24 40 28	 mov	 BYTE PTR header$[rsp], 40 ; 00000028H

; 2505 :         header[1] = DICT;

  0006e	c6 44 24 41 64	 mov	 BYTE PTR header$[rsp+1], 100 ; 00000064H

; 2506 :         len = 2;

  00073	48 c7 44 24 28
	02 00 00 00	 mov	 QWORD PTR len$[rsp], 2
$LN22@save_dict:

; 2507 :     }
; 2508 : 
; 2509 :     if (_Pickler_Write(self, header, len) < 0)

  0007c	4c 8b 44 24 28	 mov	 r8, QWORD PTR len$[rsp]
  00081	48 8d 54 24 40	 lea	 rdx, QWORD PTR header$[rsp]
  00086	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0008e	e8 00 00 00 00	 call	 _Pickler_Write
  00093	48 85 c0	 test	 rax, rax
  00096	7d 05		 jge	 SHORT $LN21@save_dict

; 2510 :         goto error;

  00098	e9 8b 02 00 00	 jmp	 $error$22186
$LN21@save_dict:

; 2511 : 
; 2512 :     /* Get dict size, and bow out early if empty. */
; 2513 :     if ((len = PyDict_Size(obj)) < 0)

  0009d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  000a5	e8 00 00 00 00	 call	 PyDict_Size
  000aa	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax
  000af	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  000b5	7d 05		 jge	 SHORT $LN20@save_dict

; 2514 :         goto error;

  000b7	e9 6c 02 00 00	 jmp	 $error$22186
$LN20@save_dict:

; 2515 : 
; 2516 :     if (memo_put(self, obj) < 0)

  000bc	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR obj$[rsp]
  000c4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000cc	e8 00 00 00 00	 call	 memo_put
  000d1	85 c0		 test	 eax, eax
  000d3	7d 05		 jge	 SHORT $LN19@save_dict

; 2517 :         goto error;

  000d5	e9 4e 02 00 00	 jmp	 $error$22186
$LN19@save_dict:

; 2518 : 
; 2519 :     if (len != 0) {

  000da	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  000e0	0f 84 3c 02 00
	00		 je	 $LN18@save_dict

; 2520 :         /* Save the dict items. */
; 2521 :         if (PyDict_CheckExact(obj) && self->proto > 0) {

  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  000ed	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  000f5	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f9	74 19		 je	 SHORT $LN16@save_dict
  000fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00102	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  0010a	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  0010e	0f 85 d7 00 00
	00		 jne	 $LN17@save_dict
$LN16@save_dict:
  00114	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0011c	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  00123	0f 8e c2 00 00
	00		 jle	 $LN17@save_dict

; 2522 :             /* We can take certain shortcuts if we know this is a dict and
; 2523 :                not a dict subclass. */
; 2524 :             if (Py_EnterRecursiveCall(" while pickling an object"))

  00129	e8 00 00 00 00	 call	 PyThreadState_Get
  0012e	48 83 c0 18	 add	 rax, 24
  00132	48 89 44 24 48	 mov	 QWORD PTR tv94[rsp], rax
  00137	48 8b 44 24 48	 mov	 rax, QWORD PTR tv94[rsp]
  0013c	8b 00		 mov	 eax, DWORD PTR [rax]
  0013e	ff c0		 inc	 eax
  00140	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv94[rsp]
  00145	89 01		 mov	 DWORD PTR [rcx], eax
  00147	48 8b 44 24 48	 mov	 rax, QWORD PTR tv94[rsp]
  0014c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  00152	39 08		 cmp	 DWORD PTR [rax], ecx
  00154	7e 15		 jle	 SHORT $LN15@save_dict
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
  0015d	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00162	85 c0		 test	 eax, eax
  00164	74 05		 je	 SHORT $LN15@save_dict

; 2525 :                 goto error;

  00166	e9 bd 01 00 00	 jmp	 $error$22186
$LN15@save_dict:

; 2526 :             status = batch_dict_exact(self, obj);

  0016b	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR obj$[rsp]
  00173	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0017b	e8 00 00 00 00	 call	 batch_dict_exact
  00180	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax
$LN14@save_dict:

; 2527 :             Py_LeaveRecursiveCall();

  00184	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  0018b	7e 0f		 jle	 SHORT $LN27@save_dict
  0018d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00193	83 e8 32	 sub	 eax, 50			; 00000032H
  00196	89 44 24 50	 mov	 DWORD PTR tv143[rsp], eax
  0019a	eb 10		 jmp	 SHORT $LN28@save_dict
$LN27@save_dict:
  0019c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  001a2	c1 f8 02	 sar	 eax, 2
  001a5	6b c0 03	 imul	 eax, 3
  001a8	89 44 24 50	 mov	 DWORD PTR tv143[rsp], eax
$LN28@save_dict:
  001ac	e8 00 00 00 00	 call	 PyThreadState_Get
  001b1	48 83 c0 18	 add	 rax, 24
  001b5	48 89 44 24 58	 mov	 QWORD PTR tv137[rsp], rax
  001ba	48 8b 44 24 58	 mov	 rax, QWORD PTR tv137[rsp]
  001bf	8b 00		 mov	 eax, DWORD PTR [rax]
  001c1	ff c8		 dec	 eax
  001c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv137[rsp]
  001c8	89 01		 mov	 DWORD PTR [rcx], eax
  001ca	48 8b 44 24 58	 mov	 rax, QWORD PTR tv137[rsp]
  001cf	8b 4c 24 50	 mov	 ecx, DWORD PTR tv143[rsp]
  001d3	39 08		 cmp	 DWORD PTR [rax], ecx
  001d5	7d 09		 jge	 SHORT $LN11@save_dict
  001d7	e8 00 00 00 00	 call	 PyThreadState_Get
  001dc	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN11@save_dict:
  001e0	33 c0		 xor	 eax, eax
  001e2	85 c0		 test	 eax, eax
  001e4	75 9e		 jne	 SHORT $LN14@save_dict

; 2528 :         } else {

  001e6	e9 37 01 00 00	 jmp	 $LN10@save_dict
$LN17@save_dict:

; 2529 :             _Py_IDENTIFIER(items);
; 2530 : 
; 2531 :             items = _PyObject_CallMethodId(obj, &PyId_items, "()");

  001eb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_items@?7??save_dict@@9@9
  001f0	8b c0		 mov	 eax, eax
  001f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00201	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00205	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0020c	48 8b d0	 mov	 rdx, rax
  0020f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  00217	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  0021c	48 89 44 24 38	 mov	 QWORD PTR items$[rsp], rax

; 2532 :             if (items == NULL)

  00221	48 83 7c 24 38
	00		 cmp	 QWORD PTR items$[rsp], 0
  00227	75 05		 jne	 SHORT $LN9@save_dict

; 2533 :                 goto error;

  00229	e9 fa 00 00 00	 jmp	 $error$22186
$LN9@save_dict:

; 2534 :             iter = PyObject_GetIter(items);

  0022e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR items$[rsp]
  00233	e8 00 00 00 00	 call	 PyObject_GetIter
  00238	48 89 44 24 20	 mov	 QWORD PTR iter$[rsp], rax

; 2535 :             Py_DECREF(items);

  0023d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR items$[rsp]
  00242	e8 00 00 00 00	 call	 _Py_DecRef

; 2536 :             if (iter == NULL)

  00247	48 83 7c 24 20
	00		 cmp	 QWORD PTR iter$[rsp], 0
  0024d	75 05		 jne	 SHORT $LN8@save_dict

; 2537 :                 goto error;

  0024f	e9 d4 00 00 00	 jmp	 $error$22186
$LN8@save_dict:

; 2538 :             if (Py_EnterRecursiveCall(" while pickling an object")) {

  00254	e8 00 00 00 00	 call	 PyThreadState_Get
  00259	48 83 c0 18	 add	 rax, 24
  0025d	48 89 44 24 60	 mov	 QWORD PTR tv165[rsp], rax
  00262	48 8b 44 24 60	 mov	 rax, QWORD PTR tv165[rsp]
  00267	8b 00		 mov	 eax, DWORD PTR [rax]
  00269	ff c0		 inc	 eax
  0026b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv165[rsp]
  00270	89 01		 mov	 DWORD PTR [rcx], eax
  00272	48 8b 44 24 60	 mov	 rax, QWORD PTR tv165[rsp]
  00277	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  0027d	39 08		 cmp	 DWORD PTR [rax], ecx
  0027f	7e 1f		 jle	 SHORT $LN7@save_dict
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
  00288	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  0028d	85 c0		 test	 eax, eax
  0028f	74 0f		 je	 SHORT $LN7@save_dict

; 2539 :                 Py_DECREF(iter);

  00291	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iter$[rsp]
  00296	e8 00 00 00 00	 call	 _Py_DecRef

; 2540 :                 goto error;

  0029b	e9 88 00 00 00	 jmp	 $error$22186
$LN7@save_dict:

; 2541 :             }
; 2542 :             status = batch_dict(self, iter);

  002a0	48 8b 54 24 20	 mov	 rdx, QWORD PTR iter$[rsp]
  002a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002ad	e8 00 00 00 00	 call	 batch_dict
  002b2	89 44 24 30	 mov	 DWORD PTR status$[rsp], eax
$LN6@save_dict:

; 2543 :             Py_LeaveRecursiveCall();

  002b6	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  002bd	7e 0f		 jle	 SHORT $LN29@save_dict
  002bf	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  002c5	83 e8 32	 sub	 eax, 50			; 00000032H
  002c8	89 44 24 68	 mov	 DWORD PTR tv183[rsp], eax
  002cc	eb 10		 jmp	 SHORT $LN30@save_dict
$LN29@save_dict:
  002ce	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  002d4	c1 f8 02	 sar	 eax, 2
  002d7	6b c0 03	 imul	 eax, 3
  002da	89 44 24 68	 mov	 DWORD PTR tv183[rsp], eax
$LN30@save_dict:
  002de	e8 00 00 00 00	 call	 PyThreadState_Get
  002e3	48 83 c0 18	 add	 rax, 24
  002e7	48 89 44 24 70	 mov	 QWORD PTR tv177[rsp], rax
  002ec	48 8b 44 24 70	 mov	 rax, QWORD PTR tv177[rsp]
  002f1	8b 00		 mov	 eax, DWORD PTR [rax]
  002f3	ff c8		 dec	 eax
  002f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv177[rsp]
  002fa	89 01		 mov	 DWORD PTR [rcx], eax
  002fc	48 8b 44 24 70	 mov	 rax, QWORD PTR tv177[rsp]
  00301	8b 4c 24 68	 mov	 ecx, DWORD PTR tv183[rsp]
  00305	39 08		 cmp	 DWORD PTR [rax], ecx
  00307	7d 09		 jge	 SHORT $LN3@save_dict
  00309	e8 00 00 00 00	 call	 PyThreadState_Get
  0030e	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN3@save_dict:
  00312	33 c0		 xor	 eax, eax
  00314	85 c0		 test	 eax, eax
  00316	75 9e		 jne	 SHORT $LN6@save_dict

; 2544 :             Py_DECREF(iter);

  00318	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iter$[rsp]
  0031d	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@save_dict:
$LN18@save_dict:

; 2545 :         }
; 2546 :     }
; 2547 : 
; 2548 :     if (0) {

  00322	33 c0		 xor	 eax, eax
  00324	85 c0		 test	 eax, eax
  00326	74 08		 je	 SHORT $LN2@save_dict
$error$22186:

; 2549 :   error:
; 2550 :         status = -1;

  00328	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1
$LN2@save_dict:

; 2551 :     }
; 2552 : 
; 2553 :     if (self->fast && !fast_save_leave(self, obj))

  00330	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00338	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [rax+176], 0
  0033f	74 21		 je	 SHORT $LN1@save_dict
  00341	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR obj$[rsp]
  00349	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00351	e8 00 00 00 00	 call	 fast_save_leave
  00356	85 c0		 test	 eax, eax
  00358	75 08		 jne	 SHORT $LN1@save_dict

; 2554 :         status = -1;

  0035a	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1
$LN1@save_dict:

; 2555 : 
; 2556 :     return status;

  00362	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]

; 2557 : }

  00366	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0036d	c3		 ret	 0
save_dict ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DPBBCDAK@batch_dict?$AA@		; `string'
PUBLIC	??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@ ; `string'
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$batch_dict DD imagerel batch_dict
	DD	imagerel batch_dict+1310
	DD	imagerel $unwind$batch_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$batch_dict DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0L@DPBBCDAK@batch_dict?$AA@
CONST	SEGMENT
??_C@_0L@DPBBCDAK@batch_dict?$AA@ DB 'batch_dict', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@
CONST	SEGMENT
??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@ DB 'dict items '
	DB	'iterator must return 2-tuples', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT batch_dict
_TEXT	SEGMENT
setitems_op$ = 48
n$ = 52
i$ = 56
firstitem$ = 64
setitem_op$ = 72
mark_op$ = 73
obj$ = 80
_py_tmp$22088 = 88
_py_tmp$22101 = 96
_py_tmp$22119 = 104
self$ = 128
iter$ = 136
batch_dict PROC						; COMDAT

; 2304 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2305 :     PyObject *obj = NULL;

  0000e	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR obj$[rsp], 0

; 2306 :     PyObject *firstitem = NULL;

  00017	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR firstitem$[rsp], 0

; 2307 :     int i, n;
; 2308 : 
; 2309 :     const char mark_op = MARK;

  00020	c6 44 24 49 28	 mov	 BYTE PTR mark_op$[rsp], 40 ; 00000028H

; 2310 :     const char setitem_op = SETITEM;

  00025	c6 44 24 48 73	 mov	 BYTE PTR setitem_op$[rsp], 115 ; 00000073H

; 2311 :     const char setitems_op = SETITEMS;

  0002a	c6 44 24 30 75	 mov	 BYTE PTR setitems_op$[rsp], 117 ; 00000075H

; 2312 : 
; 2313 :     assert(iter != NULL);

  0002f	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR iter$[rsp], 0
  00038	75 1c		 jne	 SHORT $LN58@batch_dict
  0003a	41 b8 09 09 00
	00		 mov	 r8d, 2313		; 00000909H
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@LPPKMJEB@?$AAi?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00054	33 c0		 xor	 eax, eax
$LN58@batch_dict:

; 2314 : 
; 2315 :     if (self->proto == 0) {

  00056	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005e	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  00065	0f 85 07 01 00
	00		 jne	 $LN55@batch_dict
$LN54@batch_dict:

; 2316 :         /* SETITEMS isn't available; do one at a time. */
; 2317 :         for (;;) {
; 2318 :             obj = PyIter_Next(iter);

  0006b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00073	e8 00 00 00 00	 call	 PyIter_Next
  00078	48 89 44 24 50	 mov	 QWORD PTR obj$[rsp], rax

; 2319 :             if (obj == NULL) {

  0007d	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00083	75 19		 jne	 SHORT $LN52@batch_dict

; 2320 :                 if (PyErr_Occurred())

  00085	e8 00 00 00 00	 call	 PyErr_Occurred
  0008a	48 85 c0	 test	 rax, rax
  0008d	74 0a		 je	 SHORT $LN51@batch_dict

; 2321 :                     return -1;

  0008f	b8 ff ff ff ff	 mov	 eax, -1
  00094	e9 80 04 00 00	 jmp	 $LN56@batch_dict
$LN51@batch_dict:

; 2322 :                 break;

  00099	e9 cd 00 00 00	 jmp	 $LN53@batch_dict
$LN52@batch_dict:

; 2323 :             }
; 2324 :             if (!PyTuple_Check(obj) || PyTuple_Size(obj) != 2) {

  0009e	48 8b 44 24 50	 mov	 rax, QWORD PTR obj$[rsp]
  000a3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000ad	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  000b2	85 c0		 test	 eax, eax
  000b4	74 10		 je	 SHORT $LN49@batch_dict
  000b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj$[rsp]
  000bb	e8 00 00 00 00	 call	 PyTuple_Size
  000c0	48 83 f8 02	 cmp	 rax, 2
  000c4	74 1d		 je	 SHORT $LN50@batch_dict
$LN49@batch_dict:

; 2325 :                 PyErr_SetString(PyExc_TypeError, "dict items "
; 2326 :                                 "iterator must return 2-tuples");

  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@
  000cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d4	e8 00 00 00 00	 call	 PyErr_SetString

; 2327 :                 return -1;

  000d9	b8 ff ff ff ff	 mov	 eax, -1
  000de	e9 36 04 00 00	 jmp	 $LN56@batch_dict
$LN50@batch_dict:

; 2328 :             }
; 2329 :             i = save(self, PyTuple_GET_ITEM(obj, 0), 0);

  000e3	45 33 c0	 xor	 r8d, r8d
  000e6	48 8b 44 24 50	 mov	 rax, QWORD PTR obj$[rsp]
  000eb	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  000ef	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000f7	e8 00 00 00 00	 call	 save
  000fc	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax

; 2330 :             if (i >= 0)

  00100	83 7c 24 38 00	 cmp	 DWORD PTR i$[rsp], 0
  00105	7c 1d		 jl	 SHORT $LN48@batch_dict

; 2331 :                 i = save(self, PyTuple_GET_ITEM(obj, 1), 0);

  00107	45 33 c0	 xor	 r8d, r8d
  0010a	48 8b 44 24 50	 mov	 rax, QWORD PTR obj$[rsp]
  0010f	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  00113	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0011b	e8 00 00 00 00	 call	 save
  00120	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN48@batch_dict:

; 2332 :             Py_DECREF(obj);

  00124	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj$[rsp]
  00129	e8 00 00 00 00	 call	 _Py_DecRef

; 2333 :             if (i < 0)

  0012e	83 7c 24 38 00	 cmp	 DWORD PTR i$[rsp], 0
  00133	7d 0a		 jge	 SHORT $LN47@batch_dict

; 2334 :                 return -1;

  00135	b8 ff ff ff ff	 mov	 eax, -1
  0013a	e9 da 03 00 00	 jmp	 $LN56@batch_dict
$LN47@batch_dict:

; 2335 :             if (_Pickler_Write(self, &setitem_op, 1) < 0)

  0013f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00145	48 8d 54 24 48	 lea	 rdx, QWORD PTR setitem_op$[rsp]
  0014a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00152	e8 00 00 00 00	 call	 _Pickler_Write
  00157	48 85 c0	 test	 rax, rax
  0015a	7d 0a		 jge	 SHORT $LN46@batch_dict

; 2336 :                 return -1;

  0015c	b8 ff ff ff ff	 mov	 eax, -1
  00161	e9 b3 03 00 00	 jmp	 $LN56@batch_dict
$LN46@batch_dict:

; 2337 :         }

  00166	e9 00 ff ff ff	 jmp	 $LN54@batch_dict
$LN53@batch_dict:

; 2338 :         return 0;

  0016b	33 c0		 xor	 eax, eax
  0016d	e9 a7 03 00 00	 jmp	 $LN56@batch_dict
$LN55@batch_dict:
$LN45@batch_dict:

; 2339 :     }
; 2340 : 
; 2341 :     /* proto > 0:  write in batches of BATCHSIZE. */
; 2342 :     do {
; 2343 :         /* Get first item */
; 2344 :         firstitem = PyIter_Next(iter);

  00172	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  0017a	e8 00 00 00 00	 call	 PyIter_Next
  0017f	48 89 44 24 40	 mov	 QWORD PTR firstitem$[rsp], rax

; 2345 :         if (firstitem == NULL) {

  00184	48 83 7c 24 40
	00		 cmp	 QWORD PTR firstitem$[rsp], 0
  0018a	75 14		 jne	 SHORT $LN42@batch_dict

; 2346 :             if (PyErr_Occurred())

  0018c	e8 00 00 00 00	 call	 PyErr_Occurred
  00191	48 85 c0	 test	 rax, rax
  00194	74 05		 je	 SHORT $LN41@batch_dict

; 2347 :                 goto error;

  00196	e9 49 03 00 00	 jmp	 $error$22071
$LN41@batch_dict:

; 2348 : 
; 2349 :             /* nothing more to add */
; 2350 :             break;

  0019b	e9 40 03 00 00	 jmp	 $LN43@batch_dict
$LN42@batch_dict:

; 2351 :         }
; 2352 :         if (!PyTuple_Check(firstitem) || PyTuple_Size(firstitem) != 2) {

  001a0	48 8b 44 24 40	 mov	 rax, QWORD PTR firstitem$[rsp]
  001a5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001a9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001af	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  001b4	85 c0		 test	 eax, eax
  001b6	74 10		 je	 SHORT $LN39@batch_dict
  001b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR firstitem$[rsp]
  001bd	e8 00 00 00 00	 call	 PyTuple_Size
  001c2	48 83 f8 02	 cmp	 rax, 2
  001c6	74 18		 je	 SHORT $LN40@batch_dict
$LN39@batch_dict:

; 2353 :             PyErr_SetString(PyExc_TypeError, "dict items "
; 2354 :                                 "iterator must return 2-tuples");

  001c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@
  001cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001d6	e8 00 00 00 00	 call	 PyErr_SetString

; 2355 :             goto error;

  001db	e9 04 03 00 00	 jmp	 $error$22071
$LN40@batch_dict:

; 2356 :         }
; 2357 : 
; 2358 :         /* Try to get a second item */
; 2359 :         obj = PyIter_Next(iter);

  001e0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  001e8	e8 00 00 00 00	 call	 PyIter_Next
  001ed	48 89 44 24 50	 mov	 QWORD PTR obj$[rsp], rax

; 2360 :         if (obj == NULL) {

  001f2	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  001f8	0f 85 cf 00 00
	00		 jne	 $LN38@batch_dict

; 2361 :             if (PyErr_Occurred())

  001fe	e8 00 00 00 00	 call	 PyErr_Occurred
  00203	48 85 c0	 test	 rax, rax
  00206	74 05		 je	 SHORT $LN37@batch_dict

; 2362 :                 goto error;

  00208	e9 d7 02 00 00	 jmp	 $error$22071
$LN37@batch_dict:

; 2363 : 
; 2364 :             /* Only one item to write */
; 2365 :             if (save(self, PyTuple_GET_ITEM(firstitem, 0), 0) < 0)

  0020d	45 33 c0	 xor	 r8d, r8d
  00210	48 8b 44 24 40	 mov	 rax, QWORD PTR firstitem$[rsp]
  00215	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00219	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00221	e8 00 00 00 00	 call	 save
  00226	85 c0		 test	 eax, eax
  00228	7d 05		 jge	 SHORT $LN36@batch_dict

; 2366 :                 goto error;

  0022a	e9 b5 02 00 00	 jmp	 $error$22071
$LN36@batch_dict:

; 2367 :             if (save(self, PyTuple_GET_ITEM(firstitem, 1), 0) < 0)

  0022f	45 33 c0	 xor	 r8d, r8d
  00232	48 8b 44 24 40	 mov	 rax, QWORD PTR firstitem$[rsp]
  00237	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  0023b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00243	e8 00 00 00 00	 call	 save
  00248	85 c0		 test	 eax, eax
  0024a	7d 05		 jge	 SHORT $LN35@batch_dict

; 2368 :                 goto error;

  0024c	e9 93 02 00 00	 jmp	 $error$22071
$LN35@batch_dict:

; 2369 :             if (_Pickler_Write(self, &setitem_op, 1) < 0)

  00251	41 b8 01 00 00
	00		 mov	 r8d, 1
  00257	48 8d 54 24 48	 lea	 rdx, QWORD PTR setitem_op$[rsp]
  0025c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00264	e8 00 00 00 00	 call	 _Pickler_Write
  00269	48 85 c0	 test	 rax, rax
  0026c	7d 05		 jge	 SHORT $LN34@batch_dict

; 2370 :                 goto error;

  0026e	e9 71 02 00 00	 jmp	 $error$22071
$LN34@batch_dict:
$LN33@batch_dict:

; 2371 :             Py_CLEAR(firstitem);

  00273	48 83 7c 24 40
	00		 cmp	 QWORD PTR firstitem$[rsp], 0
  00279	74 47		 je	 SHORT $LN30@batch_dict
  0027b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00283	4c 8b 4c 24 40	 mov	 r9, QWORD PTR firstitem$[rsp]
  00288	41 b8 43 09 00
	00		 mov	 r8d, 2371		; 00000943H
  0028e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00295	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DPBBCDAK@batch_dict?$AA@
  0029c	e8 00 00 00 00	 call	 _PyParallel_Guard
  002a1	85 c0		 test	 eax, eax
  002a3	75 1d		 jne	 SHORT $LN30@batch_dict
  002a5	48 8b 44 24 40	 mov	 rax, QWORD PTR firstitem$[rsp]
  002aa	48 89 44 24 58	 mov	 QWORD PTR _py_tmp$22088[rsp], rax
  002af	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR firstitem$[rsp], 0
  002b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _py_tmp$22088[rsp]
  002bd	e8 00 00 00 00	 call	 _Py_DecRef
$LN30@batch_dict:
  002c2	33 c0		 xor	 eax, eax
  002c4	85 c0		 test	 eax, eax
  002c6	75 ab		 jne	 SHORT $LN33@batch_dict

; 2372 :             break;

  002c8	e9 13 02 00 00	 jmp	 $LN43@batch_dict
$LN38@batch_dict:

; 2373 :         }
; 2374 : 
; 2375 :         /* More than one item to write */
; 2376 : 
; 2377 :         /* Pump out MARK, items, SETITEMS. */
; 2378 :         if (_Pickler_Write(self, &mark_op, 1) < 0)

  002cd	41 b8 01 00 00
	00		 mov	 r8d, 1
  002d3	48 8d 54 24 49	 lea	 rdx, QWORD PTR mark_op$[rsp]
  002d8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002e0	e8 00 00 00 00	 call	 _Pickler_Write
  002e5	48 85 c0	 test	 rax, rax
  002e8	7d 05		 jge	 SHORT $LN29@batch_dict

; 2379 :             goto error;

  002ea	e9 f5 01 00 00	 jmp	 $error$22071
$LN29@batch_dict:

; 2380 : 
; 2381 :         if (save(self, PyTuple_GET_ITEM(firstitem, 0), 0) < 0)

  002ef	45 33 c0	 xor	 r8d, r8d
  002f2	48 8b 44 24 40	 mov	 rax, QWORD PTR firstitem$[rsp]
  002f7	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  002fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00303	e8 00 00 00 00	 call	 save
  00308	85 c0		 test	 eax, eax
  0030a	7d 05		 jge	 SHORT $LN28@batch_dict

; 2382 :             goto error;

  0030c	e9 d3 01 00 00	 jmp	 $error$22071
$LN28@batch_dict:

; 2383 :         if (save(self, PyTuple_GET_ITEM(firstitem, 1), 0) < 0)

  00311	45 33 c0	 xor	 r8d, r8d
  00314	48 8b 44 24 40	 mov	 rax, QWORD PTR firstitem$[rsp]
  00319	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  0031d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00325	e8 00 00 00 00	 call	 save
  0032a	85 c0		 test	 eax, eax
  0032c	7d 05		 jge	 SHORT $LN27@batch_dict

; 2384 :             goto error;

  0032e	e9 b1 01 00 00	 jmp	 $error$22071
$LN27@batch_dict:
$LN26@batch_dict:

; 2385 :         Py_CLEAR(firstitem);

  00333	48 83 7c 24 40
	00		 cmp	 QWORD PTR firstitem$[rsp], 0
  00339	74 47		 je	 SHORT $LN23@batch_dict
  0033b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00343	4c 8b 4c 24 40	 mov	 r9, QWORD PTR firstitem$[rsp]
  00348	41 b8 51 09 00
	00		 mov	 r8d, 2385		; 00000951H
  0034e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00355	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DPBBCDAK@batch_dict?$AA@
  0035c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00361	85 c0		 test	 eax, eax
  00363	75 1d		 jne	 SHORT $LN23@batch_dict
  00365	48 8b 44 24 40	 mov	 rax, QWORD PTR firstitem$[rsp]
  0036a	48 89 44 24 60	 mov	 QWORD PTR _py_tmp$22101[rsp], rax
  0036f	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR firstitem$[rsp], 0
  00378	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _py_tmp$22101[rsp]
  0037d	e8 00 00 00 00	 call	 _Py_DecRef
$LN23@batch_dict:
  00382	33 c0		 xor	 eax, eax
  00384	85 c0		 test	 eax, eax
  00386	75 ab		 jne	 SHORT $LN26@batch_dict

; 2386 :         n = 1;

  00388	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR n$[rsp], 1
$LN22@batch_dict:

; 2387 : 
; 2388 :         /* Fetch and save up to BATCHSIZE items */
; 2389 :         while (obj) {

  00390	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00396	0f 84 17 01 00
	00		 je	 $LN21@batch_dict

; 2390 :             if (!PyTuple_Check(obj) || PyTuple_Size(obj) != 2) {

  0039c	48 8b 44 24 50	 mov	 rax, QWORD PTR obj$[rsp]
  003a1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003a5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003ab	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  003b0	85 c0		 test	 eax, eax
  003b2	74 10		 je	 SHORT $LN19@batch_dict
  003b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj$[rsp]
  003b9	e8 00 00 00 00	 call	 PyTuple_Size
  003be	48 83 f8 02	 cmp	 rax, 2
  003c2	74 18		 je	 SHORT $LN20@batch_dict
$LN19@batch_dict:

; 2391 :                 PyErr_SetString(PyExc_TypeError, "dict items "
; 2392 :                     "iterator must return 2-tuples");

  003c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@
  003cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  003d2	e8 00 00 00 00	 call	 PyErr_SetString

; 2393 :                 goto error;

  003d7	e9 08 01 00 00	 jmp	 $error$22071
$LN20@batch_dict:

; 2394 :             }
; 2395 :             if (save(self, PyTuple_GET_ITEM(obj, 0), 0) < 0 ||
; 2396 :                 save(self, PyTuple_GET_ITEM(obj, 1), 0) < 0)

  003dc	45 33 c0	 xor	 r8d, r8d
  003df	48 8b 44 24 50	 mov	 rax, QWORD PTR obj$[rsp]
  003e4	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  003e8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  003f0	e8 00 00 00 00	 call	 save
  003f5	85 c0		 test	 eax, eax
  003f7	7c 1d		 jl	 SHORT $LN17@batch_dict
  003f9	45 33 c0	 xor	 r8d, r8d
  003fc	48 8b 44 24 50	 mov	 rax, QWORD PTR obj$[rsp]
  00401	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  00405	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0040d	e8 00 00 00 00	 call	 save
  00412	85 c0		 test	 eax, eax
  00414	7d 05		 jge	 SHORT $LN18@batch_dict
$LN17@batch_dict:

; 2397 :                 goto error;

  00416	e9 c9 00 00 00	 jmp	 $error$22071
$LN18@batch_dict:
$LN16@batch_dict:

; 2398 :             Py_CLEAR(obj);

  0041b	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00421	74 47		 je	 SHORT $LN13@batch_dict
  00423	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0042b	4c 8b 4c 24 50	 mov	 r9, QWORD PTR obj$[rsp]
  00430	41 b8 5e 09 00
	00		 mov	 r8d, 2398		; 0000095eH
  00436	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0043d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DPBBCDAK@batch_dict?$AA@
  00444	e8 00 00 00 00	 call	 _PyParallel_Guard
  00449	85 c0		 test	 eax, eax
  0044b	75 1d		 jne	 SHORT $LN13@batch_dict
  0044d	48 8b 44 24 50	 mov	 rax, QWORD PTR obj$[rsp]
  00452	48 89 44 24 68	 mov	 QWORD PTR _py_tmp$22119[rsp], rax
  00457	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR obj$[rsp], 0
  00460	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _py_tmp$22119[rsp]
  00465	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@batch_dict:
  0046a	33 c0		 xor	 eax, eax
  0046c	85 c0		 test	 eax, eax
  0046e	75 ab		 jne	 SHORT $LN16@batch_dict

; 2399 :             n += 1;

  00470	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00474	ff c0		 inc	 eax
  00476	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 2400 : 
; 2401 :             if (n == BATCHSIZE)

  0047a	81 7c 24 34 e8
	03 00 00	 cmp	 DWORD PTR n$[rsp], 1000	; 000003e8H
  00482	75 02		 jne	 SHORT $LN12@batch_dict

; 2402 :                 break;

  00484	eb 2d		 jmp	 SHORT $LN21@batch_dict
$LN12@batch_dict:

; 2403 : 
; 2404 :             obj = PyIter_Next(iter);

  00486	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  0048e	e8 00 00 00 00	 call	 PyIter_Next
  00493	48 89 44 24 50	 mov	 QWORD PTR obj$[rsp], rax

; 2405 :             if (obj == NULL) {

  00498	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0049e	75 0e		 jne	 SHORT $LN11@batch_dict

; 2406 :                 if (PyErr_Occurred())

  004a0	e8 00 00 00 00	 call	 PyErr_Occurred
  004a5	48 85 c0	 test	 rax, rax
  004a8	74 02		 je	 SHORT $LN10@batch_dict

; 2407 :                     goto error;

  004aa	eb 38		 jmp	 SHORT $error$22071
$LN10@batch_dict:

; 2408 :                 break;

  004ac	eb 05		 jmp	 SHORT $LN21@batch_dict
$LN11@batch_dict:

; 2409 :             }
; 2410 :         }

  004ae	e9 dd fe ff ff	 jmp	 $LN22@batch_dict
$LN21@batch_dict:

; 2411 : 
; 2412 :         if (_Pickler_Write(self, &setitems_op, 1) < 0)

  004b3	41 b8 01 00 00
	00		 mov	 r8d, 1
  004b9	48 8d 54 24 30	 lea	 rdx, QWORD PTR setitems_op$[rsp]
  004be	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  004c6	e8 00 00 00 00	 call	 _Pickler_Write
  004cb	48 85 c0	 test	 rax, rax
  004ce	7d 02		 jge	 SHORT $LN9@batch_dict

; 2413 :             goto error;

  004d0	eb 12		 jmp	 SHORT $error$22071
$LN9@batch_dict:

; 2414 : 
; 2415 :     } while (n == BATCHSIZE);

  004d2	81 7c 24 34 e8
	03 00 00	 cmp	 DWORD PTR n$[rsp], 1000	; 000003e8H
  004da	0f 84 92 fc ff
	ff		 je	 $LN45@batch_dict
$LN43@batch_dict:

; 2416 :     return 0;

  004e0	33 c0		 xor	 eax, eax
  004e2	eb 35		 jmp	 SHORT $LN56@batch_dict
$error$22071:
$LN8@batch_dict:

; 2417 : 
; 2418 :   error:
; 2419 :     Py_XDECREF(firstitem);

  004e4	48 83 7c 24 40
	00		 cmp	 QWORD PTR firstitem$[rsp], 0
  004ea	74 0a		 je	 SHORT $LN5@batch_dict
  004ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR firstitem$[rsp]
  004f1	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@batch_dict:
  004f6	33 c0		 xor	 eax, eax
  004f8	85 c0		 test	 eax, eax
  004fa	75 e8		 jne	 SHORT $LN8@batch_dict
$LN4@batch_dict:

; 2420 :     Py_XDECREF(obj);

  004fc	48 83 7c 24 50
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00502	74 0a		 je	 SHORT $LN1@batch_dict
  00504	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj$[rsp]
  00509	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@batch_dict:
  0050e	33 c0		 xor	 eax, eax
  00510	85 c0		 test	 eax, eax
  00512	75 e8		 jne	 SHORT $LN4@batch_dict

; 2421 :     return -1;

  00514	b8 ff ff ff ff	 mov	 eax, -1
$LN56@batch_dict:

; 2422 : }

  00519	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0051d	c3		 ret	 0
batch_dict ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@KOANJCHL@dictionary?5changed?5size?5during?5i@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	PyDict_Next:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$batch_dict_exact DD imagerel batch_dict_exact
	DD	imagerel batch_dict_exact+548
	DD	imagerel $unwind$batch_dict_exact
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$batch_dict_exact DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0CJ@KOANJCHL@dictionary?5changed?5size?5during?5i@
CONST	SEGMENT
??_C@_0CJ@KOANJCHL@dictionary?5changed?5size?5during?5i@ DB 'dictionary c'
	DB	'hanged size during iteration', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT batch_dict_exact
_TEXT	SEGMENT
setitems_op$ = 32
value$ = 40
dict_size$ = 48
i$ = 56
key$ = 64
setitem_op$ = 72
ppos$ = 80
mark_op$ = 88
self$ = 112
obj$ = 120
batch_dict_exact PROC					; COMDAT

; 2435 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2436 :     PyObject *key = NULL, *value = NULL;

  0000e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR key$[rsp], 0
  00017	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR value$[rsp], 0

; 2437 :     int i;
; 2438 :     Py_ssize_t dict_size, ppos = 0;

  00020	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR ppos$[rsp], 0

; 2439 : 
; 2440 :     const char mark_op = MARK;

  00029	c6 44 24 58 28	 mov	 BYTE PTR mark_op$[rsp], 40 ; 00000028H

; 2441 :     const char setitem_op = SETITEM;

  0002e	c6 44 24 48 73	 mov	 BYTE PTR setitem_op$[rsp], 115 ; 00000073H

; 2442 :     const char setitems_op = SETITEMS;

  00033	c6 44 24 20 75	 mov	 BYTE PTR setitems_op$[rsp], 117 ; 00000075H

; 2443 : 
; 2444 :     assert(obj != NULL);

  00038	48 83 7c 24 78
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0003e	75 1c		 jne	 SHORT $LN18@batch_dict@2
  00040	41 b8 8c 09 00
	00		 mov	 r8d, 2444		; 0000098cH
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@KHFAEIJG@?$AAo?$AAb?$AAj?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005a	33 c0		 xor	 eax, eax
$LN18@batch_dict@2:

; 2445 :     assert(self->proto > 0);

  0005c	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00061	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  00068	7f 1c		 jg	 SHORT $LN19@batch_dict@2
  0006a	41 b8 8d 09 00
	00		 mov	 r8d, 2445		; 0000098dH
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@HGJIBKJH@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAr?$AAo?$AAt?$AAo?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00084	33 c0		 xor	 eax, eax
$LN19@batch_dict@2:

; 2446 : 
; 2447 :     dict_size = PyDict_Size(obj);

  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$[rsp]
  0008b	e8 00 00 00 00	 call	 PyDict_Size
  00090	48 89 44 24 30	 mov	 QWORD PTR dict_size$[rsp], rax

; 2448 : 
; 2449 :     /* Special-case len(d) == 1 to save space. */
; 2450 :     if (dict_size == 1) {

  00095	48 83 7c 24 30
	01		 cmp	 QWORD PTR dict_size$[rsp], 1
  0009b	0f 85 84 00 00
	00		 jne	 $LN15@batch_dict@2

; 2451 :         PyDict_Next(obj, &ppos, &key, &value);

  000a1	4c 8d 4c 24 28	 lea	 r9, QWORD PTR value$[rsp]
  000a6	4c 8d 44 24 40	 lea	 r8, QWORD PTR key$[rsp]
  000ab	48 8d 54 24 50	 lea	 rdx, QWORD PTR ppos$[rsp]
  000b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$[rsp]
  000b5	e8 00 00 00 00	 call	 PyDict_Next

; 2452 :         if (save(self, key, 0) < 0)

  000ba	45 33 c0	 xor	 r8d, r8d
  000bd	48 8b 54 24 40	 mov	 rdx, QWORD PTR key$[rsp]
  000c2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000c7	e8 00 00 00 00	 call	 save
  000cc	85 c0		 test	 eax, eax
  000ce	7d 0a		 jge	 SHORT $LN14@batch_dict@2

; 2453 :             return -1;

  000d0	b8 ff ff ff ff	 mov	 eax, -1
  000d5	e9 45 01 00 00	 jmp	 $LN16@batch_dict@2
$LN14@batch_dict@2:

; 2454 :         if (save(self, value, 0) < 0)

  000da	45 33 c0	 xor	 r8d, r8d
  000dd	48 8b 54 24 28	 mov	 rdx, QWORD PTR value$[rsp]
  000e2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000e7	e8 00 00 00 00	 call	 save
  000ec	85 c0		 test	 eax, eax
  000ee	7d 0a		 jge	 SHORT $LN13@batch_dict@2

; 2455 :             return -1;

  000f0	b8 ff ff ff ff	 mov	 eax, -1
  000f5	e9 25 01 00 00	 jmp	 $LN16@batch_dict@2
$LN13@batch_dict@2:

; 2456 :         if (_Pickler_Write(self, &setitem_op, 1) < 0)

  000fa	41 b8 01 00 00
	00		 mov	 r8d, 1
  00100	48 8d 54 24 48	 lea	 rdx, QWORD PTR setitem_op$[rsp]
  00105	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0010a	e8 00 00 00 00	 call	 _Pickler_Write
  0010f	48 85 c0	 test	 rax, rax
  00112	7d 0a		 jge	 SHORT $LN12@batch_dict@2

; 2457 :             return -1;

  00114	b8 ff ff ff ff	 mov	 eax, -1
  00119	e9 01 01 00 00	 jmp	 $LN16@batch_dict@2
$LN12@batch_dict@2:

; 2458 :         return 0;

  0011e	33 c0		 xor	 eax, eax
  00120	e9 fa 00 00 00	 jmp	 $LN16@batch_dict@2
$LN15@batch_dict@2:
$LN11@batch_dict@2:

; 2459 :     }
; 2460 : 
; 2461 :     /* Write in batches of BATCHSIZE. */
; 2462 :     do {
; 2463 :         i = 0;

  00125	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 2464 :         if (_Pickler_Write(self, &mark_op, 1) < 0)

  0012d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00133	48 8d 54 24 58	 lea	 rdx, QWORD PTR mark_op$[rsp]
  00138	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0013d	e8 00 00 00 00	 call	 _Pickler_Write
  00142	48 85 c0	 test	 rax, rax
  00145	7d 0a		 jge	 SHORT $LN8@batch_dict@2

; 2465 :             return -1;

  00147	b8 ff ff ff ff	 mov	 eax, -1
  0014c	e9 ce 00 00 00	 jmp	 $LN16@batch_dict@2
$LN8@batch_dict@2:
$LN7@batch_dict@2:

; 2466 :         while (PyDict_Next(obj, &ppos, &key, &value)) {

  00151	4c 8d 4c 24 28	 lea	 r9, QWORD PTR value$[rsp]
  00156	4c 8d 44 24 40	 lea	 r8, QWORD PTR key$[rsp]
  0015b	48 8d 54 24 50	 lea	 rdx, QWORD PTR ppos$[rsp]
  00160	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$[rsp]
  00165	e8 00 00 00 00	 call	 PyDict_Next
  0016a	85 c0		 test	 eax, eax
  0016c	74 55		 je	 SHORT $LN6@batch_dict@2

; 2467 :             if (save(self, key, 0) < 0)

  0016e	45 33 c0	 xor	 r8d, r8d
  00171	48 8b 54 24 40	 mov	 rdx, QWORD PTR key$[rsp]
  00176	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0017b	e8 00 00 00 00	 call	 save
  00180	85 c0		 test	 eax, eax
  00182	7d 0a		 jge	 SHORT $LN5@batch_dict@2

; 2468 :                 return -1;

  00184	b8 ff ff ff ff	 mov	 eax, -1
  00189	e9 91 00 00 00	 jmp	 $LN16@batch_dict@2
$LN5@batch_dict@2:

; 2469 :             if (save(self, value, 0) < 0)

  0018e	45 33 c0	 xor	 r8d, r8d
  00191	48 8b 54 24 28	 mov	 rdx, QWORD PTR value$[rsp]
  00196	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0019b	e8 00 00 00 00	 call	 save
  001a0	85 c0		 test	 eax, eax
  001a2	7d 07		 jge	 SHORT $LN4@batch_dict@2

; 2470 :                 return -1;

  001a4	b8 ff ff ff ff	 mov	 eax, -1
  001a9	eb 74		 jmp	 SHORT $LN16@batch_dict@2
$LN4@batch_dict@2:

; 2471 :             if (++i == BATCHSIZE)

  001ab	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  001af	ff c0		 inc	 eax
  001b1	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
  001b5	81 7c 24 38 e8
	03 00 00	 cmp	 DWORD PTR i$[rsp], 1000	; 000003e8H
  001bd	75 02		 jne	 SHORT $LN3@batch_dict@2

; 2472 :                 break;

  001bf	eb 02		 jmp	 SHORT $LN6@batch_dict@2
$LN3@batch_dict@2:

; 2473 :         }

  001c1	eb 8e		 jmp	 SHORT $LN7@batch_dict@2
$LN6@batch_dict@2:

; 2474 :         if (_Pickler_Write(self, &setitems_op, 1) < 0)

  001c3	41 b8 01 00 00
	00		 mov	 r8d, 1
  001c9	48 8d 54 24 20	 lea	 rdx, QWORD PTR setitems_op$[rsp]
  001ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001d3	e8 00 00 00 00	 call	 _Pickler_Write
  001d8	48 85 c0	 test	 rax, rax
  001db	7d 07		 jge	 SHORT $LN2@batch_dict@2

; 2475 :             return -1;

  001dd	b8 ff ff ff ff	 mov	 eax, -1
  001e2	eb 3b		 jmp	 SHORT $LN16@batch_dict@2
$LN2@batch_dict@2:

; 2476 :         if (PyDict_Size(obj) != dict_size) {

  001e4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$[rsp]
  001e9	e8 00 00 00 00	 call	 PyDict_Size
  001ee	48 3b 44 24 30	 cmp	 rax, QWORD PTR dict_size$[rsp]
  001f3	74 1a		 je	 SHORT $LN1@batch_dict@2

; 2477 :             PyErr_Format(
; 2478 :                 PyExc_RuntimeError,
; 2479 :                 "dictionary changed size during iteration");

  001f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@KOANJCHL@dictionary?5changed?5size?5during?5i@
  001fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00203	e8 00 00 00 00	 call	 PyErr_Format

; 2480 :             return -1;

  00208	b8 ff ff ff ff	 mov	 eax, -1
  0020d	eb 10		 jmp	 SHORT $LN16@batch_dict@2
$LN1@batch_dict@2:

; 2481 :         }
; 2482 : 
; 2483 :     } while (i == BATCHSIZE);

  0020f	81 7c 24 38 e8
	03 00 00	 cmp	 DWORD PTR i$[rsp], 1000	; 000003e8H
  00217	0f 84 08 ff ff
	ff		 je	 $LN11@batch_dict@2

; 2484 :     return 0;

  0021d	33 c0		 xor	 eax, eax
$LN16@batch_dict@2:

; 2485 : }

  0021f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00223	c3		 ret	 0
batch_dict_exact ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@MLEIBFDL@can?8t?5pickle?5global?5identifier?5?8@ ; `string'
PUBLIC	??_C@_0DN@KMBOMFB@can?8t?5pickle?5module?5identifier?5?8@ ; `string'
PUBLIC	??_C@_0EL@NGOKECAH@_compat_pickle?4REVERSE_IMPORT_MA@ ; `string'
PUBLIC	??_C@_0FI@NLCPOHBE@_compat_pickle?4REVERSE_NAME_MAPP@ ; `string'
PUBLIC	??_C@_0M@BMDGBENA@save_global?$AA@		; `string'
PUBLIC	??_C@_0EK@CHBHKAKA@_compat_pickle?4REVERSE_NAME_MAPP@ ; `string'
PUBLIC	??_C@_0DE@DLEOMJHE@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@ ; `string'
PUBLIC	??_C@_0DE@OEDIPGIM@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@ ; `string'
PUBLIC	??_C@_0DD@GHBKBGK@Can?8t?5pickle?5?$CFR?3?5it?8s?5not?5the?5sa@ ; `string'
PUBLIC	??_C@_0CP@PKDHHGNG@Can?8t?5pickle?5?$CFR?3?5attribute?5looku@ ; `string'
PUBLIC	??_C@_0CM@FENKPBGJ@Can?8t?5pickle?5?$CFR?3?5import?5of?5modul@ ; `string'
PUBLIC	??_C@_08BHKDPDAA@__name__?$AA@			; `string'
EXTRN	PyExc_UnicodeEncodeError:QWORD
EXTRN	PyDict_GetItemWithError:PROC
EXTRN	PyTuple_Pack:PROC
EXTRN	PyUnicode_AsASCIIString:PROC
EXTRN	PyUnicode_AsUTF8String:PROC
EXTRN	PyImport_Import:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_global DD imagerel save_global
	DD	imagerel save_global+2440
	DD	imagerel $unwind$save_global
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_global DD 021601H
	DD	0170116H
xdata	ENDS
;	COMDAT ??_C@_0DN@MLEIBFDL@can?8t?5pickle?5global?5identifier?5?8@
CONST	SEGMENT
??_C@_0DN@MLEIBFDL@can?8t?5pickle?5global?5identifier?5?8@ DB 'can''t pic'
	DB	'kle global identifier ''%S'' using pickle protocol %i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@KMBOMFB@can?8t?5pickle?5module?5identifier?5?8@
CONST	SEGMENT
??_C@_0DN@KMBOMFB@can?8t?5pickle?5module?5identifier?5?8@ DB 'can''t pick'
	DB	'le module identifier ''%S'' using pickle protocol %i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NGOKECAH@_compat_pickle?4REVERSE_IMPORT_MA@
CONST	SEGMENT
??_C@_0EL@NGOKECAH@_compat_pickle?4REVERSE_IMPORT_MA@ DB '_compat_pickle.'
	DB	'REVERSE_IMPORT_MAPPING values should be strings, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@NLCPOHBE@_compat_pickle?4REVERSE_NAME_MAPP@
CONST	SEGMENT
??_C@_0FI@NLCPOHBE@_compat_pickle?4REVERSE_NAME_MAPP@ DB '_compat_pickle.'
	DB	'REVERSE_NAME_MAPPING values should be pairs of str, not (%.20'
	DB	'0s, %.200s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BMDGBENA@save_global?$AA@
CONST	SEGMENT
??_C@_0M@BMDGBENA@save_global?$AA@ DB 'save_global', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@CHBHKAKA@_compat_pickle?4REVERSE_NAME_MAPP@
CONST	SEGMENT
??_C@_0EK@CHBHKAKA@_compat_pickle?4REVERSE_NAME_MAPP@ DB '_compat_pickle.'
	DB	'REVERSE_NAME_MAPPING values should be 2-tuples, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DLEOMJHE@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@
CONST	SEGMENT
??_C@_0DE@DLEOMJHE@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@ DB 'Can''t'
	DB	' pickle %R: extension code %ld is out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OEDIPGIM@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@
CONST	SEGMENT
??_C@_0DE@OEDIPGIM@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@ DB 'Can''t'
	DB	' pickle %R: extension code %R isn''t an integer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GHBKBGK@Can?8t?5pickle?5?$CFR?3?5it?8s?5not?5the?5sa@
CONST	SEGMENT
??_C@_0DD@GHBKBGK@Can?8t?5pickle?5?$CFR?3?5it?8s?5not?5the?5sa@ DB 'Can'''
	DB	't pickle %R: it''s not the same object as %S.%S', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PKDHHGNG@Can?8t?5pickle?5?$CFR?3?5attribute?5looku@
CONST	SEGMENT
??_C@_0CP@PKDHHGNG@Can?8t?5pickle?5?$CFR?3?5attribute?5looku@ DB 'Can''t '
	DB	'pickle %R: attribute lookup %S.%S failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FENKPBGJ@Can?8t?5pickle?5?$CFR?3?5import?5of?5modul@
CONST	SEGMENT
??_C@_0CM@FENKPBGJ@Can?8t?5pickle?5?$CFR?3?5import?5of?5modul@ DB 'Can''t'
	DB	' pickle %R: import of module %R failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BHKDPDAA@__name__?$AA@
CONST	SEGMENT
??_C@_08BHKDPDAA@__name__?$AA@ DB '__name__', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_global
_TEXT	SEGMENT
cls$ = 48
module$ = 56
module_name$ = 64
status$ = 72
global_op$ = 76
global_name$ = 80
n$22268 = 88
code$22266 = 96
pdata$22267 = 100
code_obj$22265 = 112
encoded$22294 = 120
unicode_encoder$22296 = 128
key$22301 = 136
item$22302 = 144
_py_tmp$22318 = 152
_py_tmp$22326 = 160
_py_tmp$22352 = 168
self$ = 192
obj$ = 200
name$ = 208
save_global PROC					; COMDAT

; 2561 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2562 :     static PyObject *name_str = NULL;
; 2563 :     PyObject *global_name = NULL;

  00016	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR global_name$[rsp], 0

; 2564 :     PyObject *module_name = NULL;

  0001f	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR module_name$[rsp], 0

; 2565 :     PyObject *module = NULL;

  00028	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR module$[rsp], 0

; 2566 :     PyObject *cls;
; 2567 :     int status = 0;

  00031	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 2568 : 
; 2569 :     const char global_op = GLOBAL;

  00039	c6 44 24 4c 63	 mov	 BYTE PTR global_op$[rsp], 99 ; 00000063H

; 2570 : 
; 2571 :     if (name_str == NULL) {

  0003e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name_str@?1??save_global@@9@9, 0
  00046	75 22		 jne	 SHORT $LN71@save_globa

; 2572 :         name_str = PyUnicode_InternFromString("__name__");

  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08BHKDPDAA@__name__?$AA@
  0004f	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00054	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name_str@?1??save_global@@9@9, rax

; 2573 :         if (name_str == NULL)

  0005b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name_str@?1??save_global@@9@9, 0
  00063	75 05		 jne	 SHORT $LN70@save_globa

; 2574 :             goto error;

  00065	e9 c2 08 00 00	 jmp	 $error$22246
$LN70@save_globa:
$LN71@save_globa:

; 2575 :     }
; 2576 : 
; 2577 :     if (name) {

  0006a	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR name$[rsp], 0
  00073	74 19		 je	 SHORT $LN69@save_globa

; 2578 :         global_name = name;

  00075	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  0007d	48 89 44 24 50	 mov	 QWORD PTR global_name$[rsp], rax

; 2579 :         Py_INCREF(global_name);

  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR global_name$[rsp]
  00087	e8 00 00 00 00	 call	 _Py_IncRef

; 2580 :     }
; 2581 :     else {

  0008c	eb 26		 jmp	 SHORT $LN68@save_globa
$LN69@save_globa:

; 2582 :         global_name = PyObject_GetAttr(obj, name_str);

  0008e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?name_str@?1??save_global@@9@9
  00095	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  0009d	e8 00 00 00 00	 call	 PyObject_GetAttr
  000a2	48 89 44 24 50	 mov	 QWORD PTR global_name$[rsp], rax

; 2583 :         if (global_name == NULL)

  000a7	48 83 7c 24 50
	00		 cmp	 QWORD PTR global_name$[rsp], 0
  000ad	75 05		 jne	 SHORT $LN67@save_globa

; 2584 :             goto error;

  000af	e9 78 08 00 00	 jmp	 $error$22246
$LN67@save_globa:
$LN68@save_globa:

; 2585 :     }
; 2586 : 
; 2587 :     module_name = whichmodule(obj, global_name);

  000b4	48 8b 54 24 50	 mov	 rdx, QWORD PTR global_name$[rsp]
  000b9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  000c1	e8 00 00 00 00	 call	 whichmodule
  000c6	48 89 44 24 40	 mov	 QWORD PTR module_name$[rsp], rax

; 2588 :     if (module_name == NULL)

  000cb	48 83 7c 24 40
	00		 cmp	 QWORD PTR module_name$[rsp], 0
  000d1	75 05		 jne	 SHORT $LN66@save_globa

; 2589 :         goto error;

  000d3	e9 54 08 00 00	 jmp	 $error$22246
$LN66@save_globa:

; 2590 : 
; 2591 :     /* XXX: Change to use the import C API directly with level=0 to disallow
; 2592 :        relative imports.
; 2593 : 
; 2594 :        XXX: PyImport_ImportModuleLevel could be used. However, this bypasses
; 2595 :        builtins.__import__. Therefore, _pickle, unlike pickle.py, will ignore
; 2596 :        custom import functions (IMHO, this would be a nice security
; 2597 :        feature). The import C API would need to be extended to support the
; 2598 :        extra parameters of __import__ to fix that. */
; 2599 :     module = PyImport_Import(module_name);

  000d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR module_name$[rsp]
  000dd	e8 00 00 00 00	 call	 PyImport_Import
  000e2	48 89 44 24 38	 mov	 QWORD PTR module$[rsp], rax

; 2600 :     if (module == NULL) {

  000e7	48 83 7c 24 38
	00		 cmp	 QWORD PTR module$[rsp], 0
  000ed	75 25		 jne	 SHORT $LN65@save_globa

; 2601 :         PyErr_Format(PicklingError,
; 2602 :                      "Can't pickle %R: import of module %R failed",
; 2603 :                      obj, module_name);

  000ef	4c 8b 4c 24 40	 mov	 r9, QWORD PTR module_name$[rsp]
  000f4	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR obj$[rsp]
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@FENKPBGJ@Can?8t?5pickle?5?$CFR?3?5import?5of?5modul@
  00103	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0010a	e8 00 00 00 00	 call	 PyErr_Format

; 2604 :         goto error;

  0010f	e9 18 08 00 00	 jmp	 $error$22246
$LN65@save_globa:

; 2605 :     }
; 2606 :     cls = PyObject_GetAttr(module, global_name);

  00114	48 8b 54 24 50	 mov	 rdx, QWORD PTR global_name$[rsp]
  00119	48 8b 4c 24 38	 mov	 rcx, QWORD PTR module$[rsp]
  0011e	e8 00 00 00 00	 call	 PyObject_GetAttr
  00123	48 89 44 24 30	 mov	 QWORD PTR cls$[rsp], rax

; 2607 :     if (cls == NULL) {

  00128	48 83 7c 24 30
	00		 cmp	 QWORD PTR cls$[rsp], 0
  0012e	75 2f		 jne	 SHORT $LN64@save_globa

; 2608 :         PyErr_Format(PicklingError,
; 2609 :                      "Can't pickle %R: attribute lookup %S.%S failed",
; 2610 :                      obj, module_name, global_name);

  00130	48 8b 44 24 50	 mov	 rax, QWORD PTR global_name$[rsp]
  00135	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR module_name$[rsp]
  0013f	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR obj$[rsp]
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@PKDHHGNG@Can?8t?5pickle?5?$CFR?3?5attribute?5looku@
  0014e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  00155	e8 00 00 00 00	 call	 PyErr_Format

; 2611 :         goto error;

  0015a	e9 cd 07 00 00	 jmp	 $error$22246
$LN64@save_globa:

; 2612 :     }
; 2613 :     if (cls != obj) {

  0015f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00167	48 39 44 24 30	 cmp	 QWORD PTR cls$[rsp], rax
  0016c	74 39		 je	 SHORT $LN63@save_globa

; 2614 :         Py_DECREF(cls);

  0016e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cls$[rsp]
  00173	e8 00 00 00 00	 call	 _Py_DecRef

; 2615 :         PyErr_Format(PicklingError,
; 2616 :                      "Can't pickle %R: it's not the same object as %S.%S",
; 2617 :                      obj, module_name, global_name);

  00178	48 8b 44 24 50	 mov	 rax, QWORD PTR global_name$[rsp]
  0017d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00182	4c 8b 4c 24 40	 mov	 r9, QWORD PTR module_name$[rsp]
  00187	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR obj$[rsp]
  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@GHBKBGK@Can?8t?5pickle?5?$CFR?3?5it?8s?5not?5the?5sa@
  00196	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0019d	e8 00 00 00 00	 call	 PyErr_Format

; 2618 :         goto error;

  001a2	e9 85 07 00 00	 jmp	 $error$22246
$LN63@save_globa:

; 2619 :     }
; 2620 :     Py_DECREF(cls);

  001a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cls$[rsp]
  001ac	e8 00 00 00 00	 call	 _Py_DecRef

; 2621 : 
; 2622 :     if (self->proto >= 2) {

  001b1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001b9	83 b8 a0 00 00
	00 02		 cmp	 DWORD PTR [rax+160], 2
  001c0	0f 8c 9e 01 00
	00		 jl	 $LN62@save_globa

; 2623 :         /* See whether this is in the extension registry, and if
; 2624 :          * so generate an EXT opcode.
; 2625 :          */
; 2626 :         PyObject *code_obj;      /* extension code as Python object */
; 2627 :         long code;               /* extension code as C value */
; 2628 :         char pdata[5];
; 2629 :         Py_ssize_t n;
; 2630 : 
; 2631 :         PyTuple_SET_ITEM(two_tuple, 0, module_name);

  001c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR two_tuple
  001cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR module_name$[rsp]
  001d2	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2632 :         PyTuple_SET_ITEM(two_tuple, 1, global_name);

  001d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR two_tuple
  001dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR global_name$[rsp]
  001e2	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 2633 :         code_obj = PyDict_GetItem(extension_registry, two_tuple);

  001e6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR two_tuple
  001ed	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR extension_registry
  001f4	e8 00 00 00 00	 call	 PyDict_GetItem
  001f9	48 89 44 24 70	 mov	 QWORD PTR code_obj$22265[rsp], rax

; 2634 :         /* The object is not registered in the extension registry.
; 2635 :            This is the most likely code path. */
; 2636 :         if (code_obj == NULL)

  001fe	48 83 7c 24 70
	00		 cmp	 QWORD PTR code_obj$22265[rsp], 0
  00204	75 05		 jne	 SHORT $LN61@save_globa

; 2637 :             goto gen_global;

  00206	e9 59 01 00 00	 jmp	 $gen_global$22273
$LN61@save_globa:

; 2638 : 
; 2639 :         /* XXX: pickle.py doesn't check neither the type, nor the range
; 2640 :            of the value returned by the extension_registry. It should for
; 2641 :            consistency. */
; 2642 : 
; 2643 :         /* Verify code_obj has the right type and value. */
; 2644 :         if (!PyLong_Check(code_obj)) {

  0020b	48 8b 44 24 70	 mov	 rax, QWORD PTR code_obj$22265[rsp]
  00210	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00214	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0021a	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0021f	85 c0		 test	 eax, eax
  00221	75 25		 jne	 SHORT $LN60@save_globa

; 2645 :             PyErr_Format(PicklingError,
; 2646 :                          "Can't pickle %R: extension code %R isn't an integer",
; 2647 :                          obj, code_obj);

  00223	4c 8b 4c 24 70	 mov	 r9, QWORD PTR code_obj$22265[rsp]
  00228	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR obj$[rsp]
  00230	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@OEDIPGIM@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@
  00237	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0023e	e8 00 00 00 00	 call	 PyErr_Format

; 2648 :             goto error;

  00243	e9 e4 06 00 00	 jmp	 $error$22246
$LN60@save_globa:

; 2649 :         }
; 2650 :         code = PyLong_AS_LONG(code_obj);

  00248	48 8b 4c 24 70	 mov	 rcx, QWORD PTR code_obj$22265[rsp]
  0024d	e8 00 00 00 00	 call	 PyLong_AsLong
  00252	89 44 24 60	 mov	 DWORD PTR code$22266[rsp], eax

; 2651 :         if (code <= 0 || code > 0x7fffffffL) {

  00256	83 7c 24 60 00	 cmp	 DWORD PTR code$22266[rsp], 0
  0025b	7e 0a		 jle	 SHORT $LN58@save_globa
  0025d	81 7c 24 60 ff
	ff ff 7f	 cmp	 DWORD PTR code$22266[rsp], 2147483647 ; 7fffffffH
  00265	7e 2f		 jle	 SHORT $LN59@save_globa
$LN58@save_globa:

; 2652 :             if (!PyErr_Occurred())

  00267	e8 00 00 00 00	 call	 PyErr_Occurred
  0026c	48 85 c0	 test	 rax, rax
  0026f	75 20		 jne	 SHORT $LN57@save_globa

; 2653 :                 PyErr_Format(PicklingError,
; 2654 :                              "Can't pickle %R: extension code %ld is out of range",
; 2655 :                              obj, code);

  00271	44 8b 4c 24 60	 mov	 r9d, DWORD PTR code$22266[rsp]
  00276	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR obj$[rsp]
  0027e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@DLEOMJHE@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@
  00285	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0028c	e8 00 00 00 00	 call	 PyErr_Format
$LN57@save_globa:

; 2656 :             goto error;

  00291	e9 96 06 00 00	 jmp	 $error$22246
$LN59@save_globa:

; 2657 :         }
; 2658 : 
; 2659 :         /* Generate an EXT opcode. */
; 2660 :         if (code <= 0xff) {

  00296	81 7c 24 60 ff
	00 00 00	 cmp	 DWORD PTR code$22266[rsp], 255 ; 000000ffH
  0029e	7f 1c		 jg	 SHORT $LN56@save_globa

; 2661 :             pdata[0] = EXT1;

  002a0	c6 44 24 64 82	 mov	 BYTE PTR pdata$22267[rsp], -126 ; ffffffffffffff82H

; 2662 :             pdata[1] = (unsigned char)code;

  002a5	0f b6 44 24 60	 movzx	 eax, BYTE PTR code$22266[rsp]
  002aa	88 44 24 65	 mov	 BYTE PTR pdata$22267[rsp+1], al

; 2663 :             n = 2;

  002ae	48 c7 44 24 58
	02 00 00 00	 mov	 QWORD PTR n$22268[rsp], 2
  002b7	e9 82 00 00 00	 jmp	 $LN55@save_globa
$LN56@save_globa:

; 2664 :         }
; 2665 :         else if (code <= 0xffff) {

  002bc	81 7c 24 60 ff
	ff 00 00	 cmp	 DWORD PTR code$22266[rsp], 65535 ; 0000ffffH
  002c4	7f 2d		 jg	 SHORT $LN54@save_globa

; 2666 :             pdata[0] = EXT2;

  002c6	c6 44 24 64 83	 mov	 BYTE PTR pdata$22267[rsp], -125 ; ffffffffffffff83H

; 2667 :             pdata[1] = (unsigned char)(code & 0xff);

  002cb	8b 44 24 60	 mov	 eax, DWORD PTR code$22266[rsp]
  002cf	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002d4	88 44 24 65	 mov	 BYTE PTR pdata$22267[rsp+1], al

; 2668 :             pdata[2] = (unsigned char)((code >> 8) & 0xff);

  002d8	8b 44 24 60	 mov	 eax, DWORD PTR code$22266[rsp]
  002dc	c1 f8 08	 sar	 eax, 8
  002df	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002e4	88 44 24 66	 mov	 BYTE PTR pdata$22267[rsp+2], al

; 2669 :             n = 3;

  002e8	48 c7 44 24 58
	03 00 00 00	 mov	 QWORD PTR n$22268[rsp], 3

; 2670 :         }
; 2671 :         else {

  002f1	eb 4b		 jmp	 SHORT $LN53@save_globa
$LN54@save_globa:

; 2672 :             pdata[0] = EXT4;

  002f3	c6 44 24 64 84	 mov	 BYTE PTR pdata$22267[rsp], -124 ; ffffffffffffff84H

; 2673 :             pdata[1] = (unsigned char)(code & 0xff);

  002f8	8b 44 24 60	 mov	 eax, DWORD PTR code$22266[rsp]
  002fc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00301	88 44 24 65	 mov	 BYTE PTR pdata$22267[rsp+1], al

; 2674 :             pdata[2] = (unsigned char)((code >> 8) & 0xff);

  00305	8b 44 24 60	 mov	 eax, DWORD PTR code$22266[rsp]
  00309	c1 f8 08	 sar	 eax, 8
  0030c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00311	88 44 24 66	 mov	 BYTE PTR pdata$22267[rsp+2], al

; 2675 :             pdata[3] = (unsigned char)((code >> 16) & 0xff);

  00315	8b 44 24 60	 mov	 eax, DWORD PTR code$22266[rsp]
  00319	c1 f8 10	 sar	 eax, 16
  0031c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00321	88 44 24 67	 mov	 BYTE PTR pdata$22267[rsp+3], al

; 2676 :             pdata[4] = (unsigned char)((code >> 24) & 0xff);

  00325	8b 44 24 60	 mov	 eax, DWORD PTR code$22266[rsp]
  00329	c1 f8 18	 sar	 eax, 24
  0032c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00331	88 44 24 68	 mov	 BYTE PTR pdata$22267[rsp+4], al

; 2677 :             n = 5;

  00335	48 c7 44 24 58
	05 00 00 00	 mov	 QWORD PTR n$22268[rsp], 5
$LN53@save_globa:
$LN55@save_globa:

; 2678 :         }
; 2679 : 
; 2680 :         if (_Pickler_Write(self, pdata, n) < 0)

  0033e	4c 8b 44 24 58	 mov	 r8, QWORD PTR n$22268[rsp]
  00343	48 8d 54 24 64	 lea	 rdx, QWORD PTR pdata$22267[rsp]
  00348	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00350	e8 00 00 00 00	 call	 _Pickler_Write
  00355	48 85 c0	 test	 rax, rax
  00358	7d 05		 jge	 SHORT $LN52@save_globa

; 2681 :             goto error;

  0035a	e9 cd 05 00 00	 jmp	 $error$22246
$LN52@save_globa:

; 2682 :     }
; 2683 :     else {

  0035f	e9 c2 05 00 00	 jmp	 $LN51@save_globa
$LN62@save_globa:
$gen_global$22273:

; 2684 :         /* Generate a normal global opcode if we are using a pickle
; 2685 :            protocol <= 2, or if the object is not registered in the
; 2686 :            extension registry. */
; 2687 :         PyObject *encoded;
; 2688 :         PyObject *(*unicode_encoder)(PyObject *);
; 2689 : 
; 2690 :   gen_global:
; 2691 :         if (_Pickler_Write(self, &global_op, 1) < 0)

  00364	41 b8 01 00 00
	00		 mov	 r8d, 1
  0036a	48 8d 54 24 4c	 lea	 rdx, QWORD PTR global_op$[rsp]
  0036f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00377	e8 00 00 00 00	 call	 _Pickler_Write
  0037c	48 85 c0	 test	 rax, rax
  0037f	7d 05		 jge	 SHORT $LN50@save_globa

; 2692 :             goto error;

  00381	e9 a6 05 00 00	 jmp	 $error$22246
$LN50@save_globa:

; 2693 : 
; 2694 :         /* Since Python 3.0 now supports non-ASCII identifiers, we encode both
; 2695 :            the module name and the global name using UTF-8. We do so only when
; 2696 :            we are using the pickle protocol newer than version 3. This is to
; 2697 :            ensure compatibility with older Unpickler running on Python 2.x. */
; 2698 :         if (self->proto >= 3) {

  00386	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0038e	83 b8 a0 00 00
	00 03		 cmp	 DWORD PTR [rax+160], 3
  00395	7c 11		 jl	 SHORT $LN49@save_globa

; 2699 :             unicode_encoder = PyUnicode_AsUTF8String;

  00397	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_AsUTF8String
  0039e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR unicode_encoder$22296[rsp], rax

; 2700 :         }
; 2701 :         else {

  003a6	eb 0f		 jmp	 SHORT $LN48@save_globa
$LN49@save_globa:

; 2702 :             unicode_encoder = PyUnicode_AsASCIIString;

  003a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_AsASCIIString
  003af	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR unicode_encoder$22296[rsp], rax
$LN48@save_globa:

; 2703 :         }
; 2704 : 
; 2705 :         /* For protocol < 3 and if the user didn't request against doing so,
; 2706 :            we convert module names to the old 2.x module names. */
; 2707 :         if (self->fix_imports) {

  003b7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003bf	83 b8 b8 00 00
	00 00		 cmp	 DWORD PTR [rax+184], 0
  003c6	0f 84 03 03 00
	00		 je	 $LN47@save_globa

; 2708 :             PyObject *key;
; 2709 :             PyObject *item;
; 2710 : 
; 2711 :             key = PyTuple_Pack(2, module_name, global_name);

  003cc	4c 8b 44 24 50	 mov	 r8, QWORD PTR global_name$[rsp]
  003d1	48 8b 54 24 40	 mov	 rdx, QWORD PTR module_name$[rsp]
  003d6	b9 02 00 00 00	 mov	 ecx, 2
  003db	e8 00 00 00 00	 call	 PyTuple_Pack
  003e0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR key$22301[rsp], rax

; 2712 :             if (key == NULL)

  003e8	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR key$22301[rsp], 0
  003f1	75 05		 jne	 SHORT $LN46@save_globa

; 2713 :                 goto error;

  003f3	e9 34 05 00 00	 jmp	 $error$22246
$LN46@save_globa:

; 2714 :             item = PyDict_GetItemWithError(name_mapping_3to2, key);

  003f8	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR key$22301[rsp]
  00400	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR name_mapping_3to2
  00407	e8 00 00 00 00	 call	 PyDict_GetItemWithError
  0040c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR item$22302[rsp], rax

; 2715 :             Py_DECREF(key);

  00414	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR key$22301[rsp]
  0041c	e8 00 00 00 00	 call	 _Py_DecRef

; 2716 :             if (item) {

  00421	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR item$22302[rsp], 0
  0042a	0f 84 a2 01 00
	00		 je	 $LN45@save_globa

; 2717 :                 if (!PyTuple_Check(item) || PyTuple_GET_SIZE(item) != 2) {

  00430	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR item$22302[rsp]
  00438	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0043c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00442	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00447	85 c0		 test	 eax, eax
  00449	74 0f		 je	 SHORT $LN43@save_globa
  0044b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR item$22302[rsp]
  00453	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  00458	74 28		 je	 SHORT $LN44@save_globa
$LN43@save_globa:

; 2718 :                     PyErr_Format(PyExc_RuntimeError,
; 2719 :                                  "_compat_pickle.REVERSE_NAME_MAPPING values "
; 2720 :                                  "should be 2-tuples, not %.200s",
; 2721 :                                  Py_TYPE(item)->tp_name);

  0045a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR item$22302[rsp]
  00462	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00466	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0046a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EK@CHBHKAKA@_compat_pickle?4REVERSE_NAME_MAPP@
  00471	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00478	e8 00 00 00 00	 call	 PyErr_Format

; 2722 :                     goto error;

  0047d	e9 aa 04 00 00	 jmp	 $error$22246
$LN44@save_globa:
$LN42@save_globa:

; 2723 :                 }
; 2724 :                 Py_CLEAR(module_name);

  00482	48 83 7c 24 40
	00		 cmp	 QWORD PTR module_name$[rsp], 0
  00488	74 4d		 je	 SHORT $LN39@save_globa
  0048a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00492	4c 8b 4c 24 40	 mov	 r9, QWORD PTR module_name$[rsp]
  00497	41 b8 a4 0a 00
	00		 mov	 r8d, 2724		; 00000aa4H
  0049d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  004a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@BMDGBENA@save_global?$AA@
  004ab	e8 00 00 00 00	 call	 _PyParallel_Guard
  004b0	85 c0		 test	 eax, eax
  004b2	75 23		 jne	 SHORT $LN39@save_globa
  004b4	48 8b 44 24 40	 mov	 rax, QWORD PTR module_name$[rsp]
  004b9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR _py_tmp$22318[rsp], rax
  004c1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR module_name$[rsp], 0
  004ca	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$22318[rsp]
  004d2	e8 00 00 00 00	 call	 _Py_DecRef
$LN39@save_globa:
  004d7	33 c0		 xor	 eax, eax
  004d9	85 c0		 test	 eax, eax
  004db	75 a5		 jne	 SHORT $LN42@save_globa
$LN38@save_globa:

; 2725 :                 Py_CLEAR(global_name);

  004dd	48 83 7c 24 50
	00		 cmp	 QWORD PTR global_name$[rsp], 0
  004e3	74 4d		 je	 SHORT $LN35@save_globa
  004e5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004ed	4c 8b 4c 24 50	 mov	 r9, QWORD PTR global_name$[rsp]
  004f2	41 b8 a5 0a 00
	00		 mov	 r8d, 2725		; 00000aa5H
  004f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  004ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@BMDGBENA@save_global?$AA@
  00506	e8 00 00 00 00	 call	 _PyParallel_Guard
  0050b	85 c0		 test	 eax, eax
  0050d	75 23		 jne	 SHORT $LN35@save_globa
  0050f	48 8b 44 24 50	 mov	 rax, QWORD PTR global_name$[rsp]
  00514	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR _py_tmp$22326[rsp], rax
  0051c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR global_name$[rsp], 0
  00525	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$22326[rsp]
  0052d	e8 00 00 00 00	 call	 _Py_DecRef
$LN35@save_globa:
  00532	33 c0		 xor	 eax, eax
  00534	85 c0		 test	 eax, eax
  00536	75 a5		 jne	 SHORT $LN38@save_globa

; 2726 :                 module_name = PyTuple_GET_ITEM(item, 0);

  00538	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR item$22302[rsp]
  00540	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00544	48 89 44 24 40	 mov	 QWORD PTR module_name$[rsp], rax

; 2727 :                 global_name = PyTuple_GET_ITEM(item, 1);

  00549	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR item$22302[rsp]
  00551	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00555	48 89 44 24 50	 mov	 QWORD PTR global_name$[rsp], rax

; 2728 :                 if (!PyUnicode_Check(module_name) ||
; 2729 :                     !PyUnicode_Check(global_name)) {

  0055a	48 8b 44 24 40	 mov	 rax, QWORD PTR module_name$[rsp]
  0055f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00563	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00569	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0056e	85 c0		 test	 eax, eax
  00570	74 18		 je	 SHORT $LN33@save_globa
  00572	48 8b 44 24 50	 mov	 rax, QWORD PTR global_name$[rsp]
  00577	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0057b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00581	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00586	85 c0		 test	 eax, eax
  00588	75 32		 jne	 SHORT $LN34@save_globa
$LN33@save_globa:

; 2730 :                     PyErr_Format(PyExc_RuntimeError,
; 2731 :                                  "_compat_pickle.REVERSE_NAME_MAPPING values "
; 2732 :                                  "should be pairs of str, not (%.200s, %.200s)",
; 2733 :                                  Py_TYPE(module_name)->tp_name,
; 2734 :                                  Py_TYPE(global_name)->tp_name);

  0058a	48 8b 44 24 50	 mov	 rax, QWORD PTR global_name$[rsp]
  0058f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00593	48 8b 4c 24 40	 mov	 rcx, QWORD PTR module_name$[rsp]
  00598	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0059c	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  005a0	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  005a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FI@NLCPOHBE@_compat_pickle?4REVERSE_NAME_MAPP@
  005ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  005b2	e8 00 00 00 00	 call	 PyErr_Format

; 2735 :                     goto error;

  005b7	e9 70 03 00 00	 jmp	 $error$22246
$LN34@save_globa:

; 2736 :                 }
; 2737 :                 Py_INCREF(module_name);

  005bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR module_name$[rsp]
  005c1	e8 00 00 00 00	 call	 _Py_IncRef

; 2738 :                 Py_INCREF(global_name);

  005c6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR global_name$[rsp]
  005cb	e8 00 00 00 00	 call	 _Py_IncRef
  005d0	eb 0f		 jmp	 SHORT $LN32@save_globa
$LN45@save_globa:

; 2739 :             }
; 2740 :             else if (PyErr_Occurred()) {

  005d2	e8 00 00 00 00	 call	 PyErr_Occurred
  005d7	48 85 c0	 test	 rax, rax
  005da	74 05		 je	 SHORT $LN31@save_globa

; 2741 :                 goto error;

  005dc	e9 4b 03 00 00	 jmp	 $error$22246
$LN31@save_globa:
$LN32@save_globa:

; 2742 :             }
; 2743 : 
; 2744 :             item = PyDict_GetItemWithError(import_mapping_3to2, module_name);

  005e1	48 8b 54 24 40	 mov	 rdx, QWORD PTR module_name$[rsp]
  005e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR import_mapping_3to2
  005ed	e8 00 00 00 00	 call	 PyDict_GetItemWithError
  005f2	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR item$22302[rsp], rax

; 2745 :             if (item) {

  005fa	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR item$22302[rsp], 0
  00603	0f 84 b7 00 00
	00		 je	 $LN30@save_globa

; 2746 :                 if (!PyUnicode_Check(item)) {

  00609	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR item$22302[rsp]
  00611	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00615	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0061b	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00620	85 c0		 test	 eax, eax
  00622	75 28		 jne	 SHORT $LN29@save_globa

; 2747 :                     PyErr_Format(PyExc_RuntimeError,
; 2748 :                                  "_compat_pickle.REVERSE_IMPORT_MAPPING values "
; 2749 :                                  "should be strings, not %.200s",
; 2750 :                                  Py_TYPE(item)->tp_name);

  00624	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR item$22302[rsp]
  0062c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00630	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00634	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@NGOKECAH@_compat_pickle?4REVERSE_IMPORT_MA@
  0063b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00642	e8 00 00 00 00	 call	 PyErr_Format

; 2751 :                     goto error;

  00647	e9 e0 02 00 00	 jmp	 $error$22246
$LN29@save_globa:
$LN28@save_globa:

; 2752 :                 }
; 2753 :                 Py_CLEAR(module_name);

  0064c	48 83 7c 24 40
	00		 cmp	 QWORD PTR module_name$[rsp], 0
  00652	74 4d		 je	 SHORT $LN25@save_globa
  00654	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0065c	4c 8b 4c 24 40	 mov	 r9, QWORD PTR module_name$[rsp]
  00661	41 b8 c1 0a 00
	00		 mov	 r8d, 2753		; 00000ac1H
  00667	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0066e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@BMDGBENA@save_global?$AA@
  00675	e8 00 00 00 00	 call	 _PyParallel_Guard
  0067a	85 c0		 test	 eax, eax
  0067c	75 23		 jne	 SHORT $LN25@save_globa
  0067e	48 8b 44 24 40	 mov	 rax, QWORD PTR module_name$[rsp]
  00683	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR _py_tmp$22352[rsp], rax
  0068b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR module_name$[rsp], 0
  00694	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$22352[rsp]
  0069c	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@save_globa:
  006a1	33 c0		 xor	 eax, eax
  006a3	85 c0		 test	 eax, eax
  006a5	75 a5		 jne	 SHORT $LN28@save_globa

; 2754 :                 module_name = item;

  006a7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR item$22302[rsp]
  006af	48 89 44 24 40	 mov	 QWORD PTR module_name$[rsp], rax

; 2755 :                 Py_INCREF(module_name);

  006b4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR module_name$[rsp]
  006b9	e8 00 00 00 00	 call	 _Py_IncRef
  006be	eb 0f		 jmp	 SHORT $LN24@save_globa
$LN30@save_globa:

; 2756 :             }
; 2757 :             else if (PyErr_Occurred()) {

  006c0	e8 00 00 00 00	 call	 PyErr_Occurred
  006c5	48 85 c0	 test	 rax, rax
  006c8	74 05		 je	 SHORT $LN23@save_globa

; 2758 :                 goto error;

  006ca	e9 5d 02 00 00	 jmp	 $error$22246
$LN23@save_globa:
$LN24@save_globa:
$LN47@save_globa:

; 2759 :             }
; 2760 :         }
; 2761 : 
; 2762 :         /* Save the name of the module. */
; 2763 :         encoded = unicode_encoder(module_name);

  006cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR module_name$[rsp]
  006d4	ff 94 24 80 00
	00 00		 call	 QWORD PTR unicode_encoder$22296[rsp]
  006db	48 89 44 24 78	 mov	 QWORD PTR encoded$22294[rsp], rax

; 2764 :         if (encoded == NULL) {

  006e0	48 83 7c 24 78
	00		 cmp	 QWORD PTR encoded$22294[rsp], 0
  006e6	75 3c		 jne	 SHORT $LN22@save_globa

; 2765 :             if (PyErr_ExceptionMatches(PyExc_UnicodeEncodeError))

  006e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeEncodeError
  006ef	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  006f4	85 c0		 test	 eax, eax
  006f6	74 27		 je	 SHORT $LN21@save_globa

; 2766 :                 PyErr_Format(PicklingError,
; 2767 :                              "can't pickle module identifier '%S' using "
; 2768 :                              "pickle protocol %i", module_name, self->proto);

  006f8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00700	44 8b 88 a0 00
	00 00		 mov	 r9d, DWORD PTR [rax+160]
  00707	4c 8b 44 24 40	 mov	 r8, QWORD PTR module_name$[rsp]
  0070c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@KMBOMFB@can?8t?5pickle?5module?5identifier?5?8@
  00713	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0071a	e8 00 00 00 00	 call	 PyErr_Format
$LN21@save_globa:

; 2769 :             goto error;

  0071f	e9 08 02 00 00	 jmp	 $error$22246
$LN22@save_globa:

; 2770 :         }
; 2771 :         if (_Pickler_Write(self, PyBytes_AS_STRING(encoded),
; 2772 :                           PyBytes_GET_SIZE(encoded)) < 0) {

  00724	48 8b 44 24 78	 mov	 rax, QWORD PTR encoded$22294[rsp]
  00729	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0072d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00733	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00738	85 c0		 test	 eax, eax
  0073a	75 1c		 jne	 SHORT $LN74@save_globa
  0073c	41 b8 d4 0a 00
	00		 mov	 r8d, 2772		; 00000ad4H
  00742	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00749	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  00750	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00756	33 c0		 xor	 eax, eax
$LN74@save_globa:
  00758	48 8b 44 24 78	 mov	 rax, QWORD PTR encoded$22294[rsp]
  0075d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00761	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00767	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0076c	85 c0		 test	 eax, eax
  0076e	75 1c		 jne	 SHORT $LN75@save_globa
  00770	41 b8 d3 0a 00
	00		 mov	 r8d, 2771		; 00000ad3H
  00776	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0077d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  00784	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0078a	33 c0		 xor	 eax, eax
$LN75@save_globa:
  0078c	48 8b 44 24 78	 mov	 rax, QWORD PTR encoded$22294[rsp]
  00791	48 83 c0 78	 add	 rax, 120		; 00000078H
  00795	48 8b 4c 24 78	 mov	 rcx, QWORD PTR encoded$22294[rsp]
  0079a	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  0079e	48 8b d0	 mov	 rdx, rax
  007a1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  007a9	e8 00 00 00 00	 call	 _Pickler_Write
  007ae	48 85 c0	 test	 rax, rax
  007b1	7d 0f		 jge	 SHORT $LN20@save_globa

; 2773 :             Py_DECREF(encoded);

  007b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR encoded$22294[rsp]
  007b8	e8 00 00 00 00	 call	 _Py_DecRef

; 2774 :             goto error;

  007bd	e9 6a 01 00 00	 jmp	 $error$22246
$LN20@save_globa:

; 2775 :         }
; 2776 :         Py_DECREF(encoded);

  007c2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR encoded$22294[rsp]
  007c7	e8 00 00 00 00	 call	 _Py_DecRef

; 2777 :         if(_Pickler_Write(self, "\n", 1) < 0)

  007cc	41 b8 01 00 00
	00		 mov	 r8d, 1
  007d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  007d9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  007e1	e8 00 00 00 00	 call	 _Pickler_Write
  007e6	48 85 c0	 test	 rax, rax
  007e9	7d 05		 jge	 SHORT $LN19@save_globa

; 2778 :             goto error;

  007eb	e9 3c 01 00 00	 jmp	 $error$22246
$LN19@save_globa:

; 2779 : 
; 2780 :         /* Save the name of the module. */
; 2781 :         encoded = unicode_encoder(global_name);

  007f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR global_name$[rsp]
  007f5	ff 94 24 80 00
	00 00		 call	 QWORD PTR unicode_encoder$22296[rsp]
  007fc	48 89 44 24 78	 mov	 QWORD PTR encoded$22294[rsp], rax

; 2782 :         if (encoded == NULL) {

  00801	48 83 7c 24 78
	00		 cmp	 QWORD PTR encoded$22294[rsp], 0
  00807	75 3c		 jne	 SHORT $LN18@save_globa

; 2783 :             if (PyErr_ExceptionMatches(PyExc_UnicodeEncodeError))

  00809	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeEncodeError
  00810	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00815	85 c0		 test	 eax, eax
  00817	74 27		 je	 SHORT $LN17@save_globa

; 2784 :                 PyErr_Format(PicklingError,
; 2785 :                              "can't pickle global identifier '%S' using "
; 2786 :                              "pickle protocol %i", global_name, self->proto);

  00819	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00821	44 8b 88 a0 00
	00 00		 mov	 r9d, DWORD PTR [rax+160]
  00828	4c 8b 44 24 50	 mov	 r8, QWORD PTR global_name$[rsp]
  0082d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@MLEIBFDL@can?8t?5pickle?5global?5identifier?5?8@
  00834	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0083b	e8 00 00 00 00	 call	 PyErr_Format
$LN17@save_globa:

; 2787 :             goto error;

  00840	e9 e7 00 00 00	 jmp	 $error$22246
$LN18@save_globa:

; 2788 :         }
; 2789 :         if (_Pickler_Write(self, PyBytes_AS_STRING(encoded),
; 2790 :                           PyBytes_GET_SIZE(encoded)) < 0) {

  00845	48 8b 44 24 78	 mov	 rax, QWORD PTR encoded$22294[rsp]
  0084a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0084e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00854	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00859	85 c0		 test	 eax, eax
  0085b	75 1c		 jne	 SHORT $LN76@save_globa
  0085d	41 b8 e6 0a 00
	00		 mov	 r8d, 2790		; 00000ae6H
  00863	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0086a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  00871	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00877	33 c0		 xor	 eax, eax
$LN76@save_globa:
  00879	48 8b 44 24 78	 mov	 rax, QWORD PTR encoded$22294[rsp]
  0087e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00882	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00888	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0088d	85 c0		 test	 eax, eax
  0088f	75 1c		 jne	 SHORT $LN77@save_globa
  00891	41 b8 e5 0a 00
	00		 mov	 r8d, 2789		; 00000ae5H
  00897	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0089e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  008a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  008ab	33 c0		 xor	 eax, eax
$LN77@save_globa:
  008ad	48 8b 44 24 78	 mov	 rax, QWORD PTR encoded$22294[rsp]
  008b2	48 83 c0 78	 add	 rax, 120		; 00000078H
  008b6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR encoded$22294[rsp]
  008bb	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  008bf	48 8b d0	 mov	 rdx, rax
  008c2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  008ca	e8 00 00 00 00	 call	 _Pickler_Write
  008cf	48 85 c0	 test	 rax, rax
  008d2	7d 0c		 jge	 SHORT $LN16@save_globa

; 2791 :             Py_DECREF(encoded);

  008d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR encoded$22294[rsp]
  008d9	e8 00 00 00 00	 call	 _Py_DecRef

; 2792 :             goto error;

  008de	eb 4c		 jmp	 SHORT $error$22246
$LN16@save_globa:

; 2793 :         }
; 2794 :         Py_DECREF(encoded);

  008e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR encoded$22294[rsp]
  008e5	e8 00 00 00 00	 call	 _Py_DecRef

; 2795 :         if(_Pickler_Write(self, "\n", 1) < 0)

  008ea	41 b8 01 00 00
	00		 mov	 r8d, 1
  008f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  008f7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  008ff	e8 00 00 00 00	 call	 _Pickler_Write
  00904	48 85 c0	 test	 rax, rax
  00907	7d 02		 jge	 SHORT $LN15@save_globa

; 2796 :             goto error;

  00909	eb 21		 jmp	 SHORT $error$22246
$LN15@save_globa:

; 2797 : 
; 2798 :         /* Memoize the object. */
; 2799 :         if (memo_put(self, obj) < 0)

  0090b	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR obj$[rsp]
  00913	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0091b	e8 00 00 00 00	 call	 memo_put
  00920	85 c0		 test	 eax, eax
  00922	7d 02		 jge	 SHORT $LN14@save_globa

; 2800 :             goto error;

  00924	eb 06		 jmp	 SHORT $error$22246
$LN14@save_globa:
$LN51@save_globa:

; 2801 :     }
; 2802 : 
; 2803 :     if (0) {

  00926	33 c0		 xor	 eax, eax
  00928	85 c0		 test	 eax, eax
  0092a	74 08		 je	 SHORT $LN13@save_globa
$error$22246:

; 2804 :   error:
; 2805 :         status = -1;

  0092c	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1
$LN13@save_globa:
$LN12@save_globa:

; 2806 :     }
; 2807 :     Py_XDECREF(module_name);

  00934	48 83 7c 24 40
	00		 cmp	 QWORD PTR module_name$[rsp], 0
  0093a	74 0a		 je	 SHORT $LN9@save_globa
  0093c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR module_name$[rsp]
  00941	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@save_globa:
  00946	33 c0		 xor	 eax, eax
  00948	85 c0		 test	 eax, eax
  0094a	75 e8		 jne	 SHORT $LN12@save_globa
$LN8@save_globa:

; 2808 :     Py_XDECREF(global_name);

  0094c	48 83 7c 24 50
	00		 cmp	 QWORD PTR global_name$[rsp], 0
  00952	74 0a		 je	 SHORT $LN5@save_globa
  00954	48 8b 4c 24 50	 mov	 rcx, QWORD PTR global_name$[rsp]
  00959	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@save_globa:
  0095e	33 c0		 xor	 eax, eax
  00960	85 c0		 test	 eax, eax
  00962	75 e8		 jne	 SHORT $LN8@save_globa
$LN4@save_globa:

; 2809 :     Py_XDECREF(module);

  00964	48 83 7c 24 38
	00		 cmp	 QWORD PTR module$[rsp], 0
  0096a	74 0a		 je	 SHORT $LN1@save_globa
  0096c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR module$[rsp]
  00971	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@save_globa:
  00976	33 c0		 xor	 eax, eax
  00978	85 c0		 test	 eax, eax
  0097a	75 e8		 jne	 SHORT $LN4@save_globa

; 2810 : 
; 2811 :     return status;

  0097c	8b 44 24 48	 mov	 eax, DWORD PTR status$[rsp]

; 2812 : }

  00980	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00987	c3		 ret	 0
save_global ENDP
_TEXT	ENDS
PUBLIC	??_C@_07DFGEOAEG@modules?$AA@			; `string'
PUBLIC	??_C@_08EMKMIFM@__main__?$AA@			; `string'
PUBLIC	??_C@_0L@LNCJCPDP@__module__?$AA@		; `string'
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	PySys_GetObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$whichmodule DD imagerel whichmodule
	DD	imagerel whichmodule+460
	DD	imagerel $unwind$whichmodule
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$whichmodule DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_07DFGEOAEG@modules?$AA@
CONST	SEGMENT
??_C@_07DFGEOAEG@modules?$AA@ DB 'modules', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMKMIFM@__main__?$AA@
CONST	SEGMENT
??_C@_08EMKMIFM@__main__?$AA@ DB '__main__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LNCJCPDP@__module__?$AA@
CONST	SEGMENT
??_C@_0L@LNCJCPDP@__module__?$AA@ DB '__module__', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT whichmodule
_TEXT	SEGMENT
i$ = 32
module$ = 40
module_name$ = 48
modules_dict$ = 56
obj$ = 64
j$ = 72
global$ = 96
global_name$ = 104
whichmodule PROC					; COMDAT

; 1329 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1330 :     Py_ssize_t i, j;
; 1331 :     static PyObject *module_str = NULL;
; 1332 :     static PyObject *main_str = NULL;
; 1333 :     PyObject *module_name;
; 1334 :     PyObject *modules_dict;
; 1335 :     PyObject *module;
; 1336 :     PyObject *obj;
; 1337 : 
; 1338 :     if (module_str == NULL) {

  0000e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?module_str@?1??whichmodule@@9@9, 0
  00016	75 48		 jne	 SHORT $LN16@whichmodul

; 1339 :         module_str = PyUnicode_InternFromString("__module__");

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LNCJCPDP@__module__?$AA@
  0001f	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00024	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?module_str@?1??whichmodule@@9@9, rax

; 1340 :         if (module_str == NULL)

  0002b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?module_str@?1??whichmodule@@9@9, 0
  00033	75 07		 jne	 SHORT $LN15@whichmodul

; 1341 :             return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	e9 8b 01 00 00	 jmp	 $LN17@whichmodul
$LN15@whichmodul:

; 1342 :         main_str = PyUnicode_InternFromString("__main__");

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08EMKMIFM@__main__?$AA@
  00043	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00048	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?main_str@?1??whichmodule@@9@9, rax

; 1343 :         if (main_str == NULL)

  0004f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?main_str@?1??whichmodule@@9@9, 0
  00057	75 07		 jne	 SHORT $LN14@whichmodul

; 1344 :             return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 67 01 00 00	 jmp	 $LN17@whichmodul
$LN14@whichmodul:
$LN16@whichmodul:

; 1345 :     }
; 1346 : 
; 1347 :     module_name = PyObject_GetAttr(global, module_str);

  00060	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?module_str@?1??whichmodule@@9@9
  00067	48 8b 4c 24 60	 mov	 rcx, QWORD PTR global$[rsp]
  0006c	e8 00 00 00 00	 call	 PyObject_GetAttr
  00071	48 89 44 24 30	 mov	 QWORD PTR module_name$[rsp], rax

; 1348 : 
; 1349 :     /* In some rare cases (e.g., bound methods of extension types),
; 1350 :        __module__ can be None. If it is so, then search sys.modules
; 1351 :        for the module of global.  */
; 1352 :     if (module_name == Py_None) {

  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007d	48 39 44 24 30	 cmp	 QWORD PTR module_name$[rsp], rax
  00082	75 0c		 jne	 SHORT $LN13@whichmodul

; 1353 :         Py_DECREF(module_name);

  00084	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module_name$[rsp]
  00089	e8 00 00 00 00	 call	 _Py_DecRef

; 1354 :         goto search;

  0008e	eb 30		 jmp	 SHORT $search$21391
$LN13@whichmodul:

; 1355 :     }
; 1356 : 
; 1357 :     if (module_name) {

  00090	48 83 7c 24 30
	00		 cmp	 QWORD PTR module_name$[rsp], 0
  00096	74 0a		 je	 SHORT $LN12@whichmodul

; 1358 :         return module_name;

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR module_name$[rsp]
  0009d	e9 25 01 00 00	 jmp	 $LN17@whichmodul
$LN12@whichmodul:

; 1359 :     }
; 1360 :     if (PyErr_ExceptionMatches(PyExc_AttributeError))

  000a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  000a9	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000ae	85 c0		 test	 eax, eax
  000b0	74 07		 je	 SHORT $LN11@whichmodul

; 1361 :         PyErr_Clear();

  000b2	e8 00 00 00 00	 call	 PyErr_Clear

; 1362 :     else

  000b7	eb 07		 jmp	 SHORT $LN10@whichmodul
$LN11@whichmodul:

; 1363 :         return NULL;

  000b9	33 c0		 xor	 eax, eax
  000bb	e9 07 01 00 00	 jmp	 $LN17@whichmodul
$LN10@whichmodul:
$search$21391:

; 1364 : 
; 1365 :   search:
; 1366 :     modules_dict = PySys_GetObject("modules");

  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DFGEOAEG@modules?$AA@
  000c7	e8 00 00 00 00	 call	 PySys_GetObject
  000cc	48 89 44 24 38	 mov	 QWORD PTR modules_dict$[rsp], rax

; 1367 :     if (modules_dict == NULL)

  000d1	48 83 7c 24 38
	00		 cmp	 QWORD PTR modules_dict$[rsp], 0
  000d7	75 07		 jne	 SHORT $LN9@whichmodul

; 1368 :         return NULL;

  000d9	33 c0		 xor	 eax, eax
  000db	e9 e7 00 00 00	 jmp	 $LN17@whichmodul
$LN9@whichmodul:

; 1369 : 
; 1370 :     i = 0;

  000e0	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0

; 1371 :     module_name = NULL;

  000e9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR module_name$[rsp], 0
$LN20@whichmodul:
$LN19@whichmodul:
$LN8@whichmodul:

; 1372 :     while ((j = PyDict_Next(modules_dict, &i, &module_name, &module))) {

  000f2	4c 8d 4c 24 28	 lea	 r9, QWORD PTR module$[rsp]
  000f7	4c 8d 44 24 30	 lea	 r8, QWORD PTR module_name$[rsp]
  000fc	48 8d 54 24 20	 lea	 rdx, QWORD PTR i$[rsp]
  00101	48 8b 4c 24 38	 mov	 rcx, QWORD PTR modules_dict$[rsp]
  00106	e8 00 00 00 00	 call	 PyDict_Next
  0010b	48 98		 cdqe
  0010d	48 89 44 24 48	 mov	 QWORD PTR j$[rsp], rax
  00112	48 83 7c 24 48
	00		 cmp	 QWORD PTR j$[rsp], 0
  00118	0f 84 86 00 00
	00		 je	 $LN7@whichmodul

; 1373 :         if (PyObject_RichCompareBool(module_name, main_str, Py_EQ) == 1)

  0011e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00124	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?main_str@?1??whichmodule@@9@9
  0012b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module_name$[rsp]
  00130	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00135	83 f8 01	 cmp	 eax, 1
  00138	75 02		 jne	 SHORT $LN6@whichmodul

; 1374 :             continue;

  0013a	eb b6		 jmp	 SHORT $LN8@whichmodul
$LN6@whichmodul:

; 1375 : 
; 1376 :         obj = PyObject_GetAttr(module, global_name);

  0013c	48 8b 54 24 68	 mov	 rdx, QWORD PTR global_name$[rsp]
  00141	48 8b 4c 24 28	 mov	 rcx, QWORD PTR module$[rsp]
  00146	e8 00 00 00 00	 call	 PyObject_GetAttr
  0014b	48 89 44 24 40	 mov	 QWORD PTR obj$[rsp], rax

; 1377 :         if (obj == NULL) {

  00150	48 83 7c 24 40
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00156	75 20		 jne	 SHORT $LN5@whichmodul

; 1378 :             if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00158	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0015f	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00164	85 c0		 test	 eax, eax
  00166	74 07		 je	 SHORT $LN4@whichmodul

; 1379 :                 PyErr_Clear();

  00168	e8 00 00 00 00	 call	 PyErr_Clear

; 1380 :             else

  0016d	eb 04		 jmp	 SHORT $LN3@whichmodul
$LN4@whichmodul:

; 1381 :                 return NULL;

  0016f	33 c0		 xor	 eax, eax
  00171	eb 54		 jmp	 SHORT $LN17@whichmodul
$LN3@whichmodul:

; 1382 :             continue;

  00173	e9 7a ff ff ff	 jmp	 $LN19@whichmodul
$LN5@whichmodul:

; 1383 :         }
; 1384 : 
; 1385 :         if (obj != global) {

  00178	48 8b 44 24 60	 mov	 rax, QWORD PTR global$[rsp]
  0017d	48 39 44 24 40	 cmp	 QWORD PTR obj$[rsp], rax
  00182	74 0f		 je	 SHORT $LN2@whichmodul

; 1386 :             Py_DECREF(obj);

  00184	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  00189	e8 00 00 00 00	 call	 _Py_DecRef

; 1387 :             continue;

  0018e	e9 5f ff ff ff	 jmp	 $LN20@whichmodul
$LN2@whichmodul:

; 1388 :         }
; 1389 : 
; 1390 :         Py_DECREF(obj);

  00193	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  00198	e8 00 00 00 00	 call	 _Py_DecRef

; 1391 :         break;

  0019d	eb 05		 jmp	 SHORT $LN7@whichmodul

; 1392 :     }

  0019f	e9 4e ff ff ff	 jmp	 $LN8@whichmodul
$LN7@whichmodul:

; 1393 : 
; 1394 :     /* If no module is found, use __main__. */
; 1395 :     if (!j) {

  001a4	48 83 7c 24 48
	00		 cmp	 QWORD PTR j$[rsp], 0
  001aa	75 0c		 jne	 SHORT $LN1@whichmodul

; 1396 :         module_name = main_str;

  001ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?main_str@?1??whichmodule@@9@9
  001b3	48 89 44 24 30	 mov	 QWORD PTR module_name$[rsp], rax
$LN1@whichmodul:

; 1397 :     }
; 1398 : 
; 1399 :     Py_INCREF(module_name);

  001b8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module_name$[rsp]
  001bd	e8 00 00 00 00	 call	 _Py_IncRef

; 1400 :     return module_name;

  001c2	48 8b 44 24 30	 mov	 rax, QWORD PTR module_name$[rsp]
$LN17@whichmodul:

; 1401 : }

  001c7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001cb	c3		 ret	 0
whichmodule ENDP
_TEXT	ENDS
PUBLIC	??_C@_08KKBGFFMJ@Ellipsis?$AA@			; `string'
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_ellipsis DD imagerel save_ellipsis
	DD	imagerel save_ellipsis+91
	DD	imagerel $unwind$save_ellipsis
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_ellipsis DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_08KKBGFFMJ@Ellipsis?$AA@
CONST	SEGMENT
??_C@_08KKBGFFMJ@Ellipsis?$AA@ DB 'Ellipsis', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_ellipsis
_TEXT	SEGMENT
res$ = 32
str$ = 40
self$ = 64
obj$ = 72
save_ellipsis PROC					; COMDAT

; 2816 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2817 :     PyObject *str = PyUnicode_FromString("Ellipsis");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KKBGFFMJ@Ellipsis?$AA@
  00015	e8 00 00 00 00	 call	 PyUnicode_FromString
  0001a	48 89 44 24 28	 mov	 QWORD PTR str$[rsp], rax

; 2818 :     int res;
; 2819 :     if (str == NULL)

  0001f	48 83 7c 24 28
	00		 cmp	 QWORD PTR str$[rsp], 0
  00025	75 07		 jne	 SHORT $LN1@save_ellip

; 2820 :         return -1;

  00027	b8 ff ff ff ff	 mov	 eax, -1
  0002c	eb 28		 jmp	 SHORT $LN2@save_ellip
$LN1@save_ellip:

; 2821 :     res = save_global(self, Py_Ellipsis, str);

  0002e	4c 8b 44 24 28	 mov	 r8, QWORD PTR str$[rsp]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_EllipsisObject
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0003f	e8 00 00 00 00	 call	 save_global
  00044	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 2822 :     Py_DECREF(str);

  00048	48 8b 4c 24 28	 mov	 rcx, QWORD PTR str$[rsp]
  0004d	e8 00 00 00 00	 call	 _Py_DecRef

; 2823 :     return res;

  00052	8b 44 24 20	 mov	 eax, DWORD PTR res$[rsp]
$LN2@save_ellip:

; 2824 : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
save_ellipsis ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@HCLFFHDH@NotImplemented?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_notimplemented DD imagerel save_notimplemented
	DD	imagerel save_notimplemented+91
	DD	imagerel $unwind$save_notimplemented
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_notimplemented DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0P@HCLFFHDH@NotImplemented?$AA@
CONST	SEGMENT
??_C@_0P@HCLFFHDH@NotImplemented?$AA@ DB 'NotImplemented', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_notimplemented
_TEXT	SEGMENT
res$ = 32
str$ = 40
self$ = 64
obj$ = 72
save_notimplemented PROC				; COMDAT

; 2828 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2829 :     PyObject *str = PyUnicode_FromString("NotImplemented");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@HCLFFHDH@NotImplemented?$AA@
  00015	e8 00 00 00 00	 call	 PyUnicode_FromString
  0001a	48 89 44 24 28	 mov	 QWORD PTR str$[rsp], rax

; 2830 :     int res;
; 2831 :     if (str == NULL)

  0001f	48 83 7c 24 28
	00		 cmp	 QWORD PTR str$[rsp], 0
  00025	75 07		 jne	 SHORT $LN1@save_notim

; 2832 :         return -1;

  00027	b8 ff ff ff ff	 mov	 eax, -1
  0002c	eb 28		 jmp	 SHORT $LN2@save_notim
$LN1@save_notim:

; 2833 :     res = save_global(self, Py_NotImplemented, str);

  0002e	4c 8b 44 24 28	 mov	 r8, QWORD PTR str$[rsp]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NotImplementedStruct
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0003f	e8 00 00 00 00	 call	 save_global
  00044	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 2834 :     Py_DECREF(str);

  00048	48 8b 4c 24 28	 mov	 rcx, QWORD PTR str$[rsp]
  0004d	e8 00 00 00 00	 call	 _Py_DecRef

; 2835 :     return res;

  00052	8b 44 24 20	 mov	 eax, DWORD PTR res$[rsp]
$LN2@save_notim:

; 2836 : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
save_notimplemented ENDP
_TEXT	ENDS
EXTRN	_PyNotImplemented_Type:BYTE
EXTRN	PyEllipsis_Type:BYTE
EXTRN	_PyNone_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_type DD imagerel save_type
	DD	imagerel save_type+155
	DD	imagerel $unwind$save_type
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_type DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT save_type
_TEXT	SEGMENT
self$ = 48
obj$ = 56
save_type PROC						; COMDAT

; 2855 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2856 :     if (obj == (PyObject *)&_PyNone_Type) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyNone_Type
  00015	48 39 44 24 38	 cmp	 QWORD PTR obj$[rsp], rax
  0001a	75 1a		 jne	 SHORT $LN5@save_type

; 2857 :         return save_singleton_type(self, obj, Py_None);

  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00023	48 8b 54 24 38	 mov	 rdx, QWORD PTR obj$[rsp]
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0002d	e8 00 00 00 00	 call	 save_singleton_type
  00032	eb 62		 jmp	 SHORT $LN6@save_type
  00034	eb 4e		 jmp	 SHORT $LN4@save_type
$LN5@save_type:

; 2858 :     }
; 2859 :     else if (obj == (PyObject *)&PyEllipsis_Type) {

  00036	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyEllipsis_Type
  0003d	48 39 44 24 38	 cmp	 QWORD PTR obj$[rsp], rax
  00042	75 1a		 jne	 SHORT $LN3@save_type

; 2860 :         return save_singleton_type(self, obj, Py_Ellipsis);

  00044	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_EllipsisObject
  0004b	48 8b 54 24 38	 mov	 rdx, QWORD PTR obj$[rsp]
  00050	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00055	e8 00 00 00 00	 call	 save_singleton_type
  0005a	eb 3a		 jmp	 SHORT $LN6@save_type
  0005c	eb 26		 jmp	 SHORT $LN2@save_type
$LN3@save_type:

; 2861 :     }
; 2862 :     else if (obj == (PyObject *)&_PyNotImplemented_Type) {

  0005e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyNotImplemented_Type
  00065	48 39 44 24 38	 cmp	 QWORD PTR obj$[rsp], rax
  0006a	75 18		 jne	 SHORT $LN1@save_type

; 2863 :         return save_singleton_type(self, obj, Py_NotImplemented);

  0006c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NotImplementedStruct
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR obj$[rsp]
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007d	e8 00 00 00 00	 call	 save_singleton_type
  00082	eb 12		 jmp	 SHORT $LN6@save_type
$LN1@save_type:
$LN2@save_type:
$LN4@save_type:

; 2864 :     }
; 2865 :     return save_global(self, obj, NULL);

  00084	45 33 c0	 xor	 r8d, r8d
  00087	48 8b 54 24 38	 mov	 rdx, QWORD PTR obj$[rsp]
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00091	e8 00 00 00 00	 call	 save_global
$LN6@save_type:

; 2866 : }

  00096	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009a	c3		 ret	 0
save_type ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_singleton_type DD imagerel save_singleton_type
	DD	imagerel save_singleton_type+106
	DD	imagerel $unwind$save_singleton_type
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_singleton_type DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@ DB 'O(O)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_singleton_type
_TEXT	SEGMENT
reduce_value$ = 32
status$ = 40
self$ = 64
obj$ = 72
singleton$ = 80
save_singleton_type PROC				; COMDAT

; 2840 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2841 :     PyObject *reduce_value;
; 2842 :     int status;
; 2843 : 
; 2844 :     reduce_value = Py_BuildValue("O(O)", &PyType_Type, singleton);

  00013	4c 8b 44 24 50	 mov	 r8, QWORD PTR singleton$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyType_Type
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@
  00026	e8 00 00 00 00	 call	 Py_BuildValue
  0002b	48 89 44 24 20	 mov	 QWORD PTR reduce_value$[rsp], rax

; 2845 :     if (reduce_value == NULL) {

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR reduce_value$[rsp], 0
  00036	75 07		 jne	 SHORT $LN1@save_singl

; 2846 :         return -1;

  00038	b8 ff ff ff ff	 mov	 eax, -1
  0003d	eb 26		 jmp	 SHORT $LN2@save_singl
$LN1@save_singl:

; 2847 :     }
; 2848 :     status = save_reduce(self, reduce_value, obj);

  0003f	4c 8b 44 24 48	 mov	 r8, QWORD PTR obj$[rsp]
  00044	48 8b 54 24 20	 mov	 rdx, QWORD PTR reduce_value$[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0004e	e8 00 00 00 00	 call	 save_reduce
  00053	89 44 24 28	 mov	 DWORD PTR status$[rsp], eax

; 2849 :     Py_DECREF(reduce_value);

  00057	48 8b 4c 24 20	 mov	 rcx, QWORD PTR reduce_value$[rsp]
  0005c	e8 00 00 00 00	 call	 _Py_DecRef

; 2850 :     return status;

  00061	8b 44 24 28	 mov	 eax, DWORD PTR status$[rsp]
$LN2@save_singl:

; 2851 : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
save_singleton_type ENDP
_TEXT	ENDS
EXTRN	PyObject_Str:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_pers DD imagerel save_pers
	DD	imagerel save_pers+405
	DD	imagerel $unwind$save_pers
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_pers DD 011301H
	DD	0a213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT save_pers
_TEXT	SEGMENT
binpersid_op$ = 32
persid_op$ = 33
pid$ = 40
status$ = 48
pid_str$22479 = 56
size$22482 = 64
pid_ascii_bytes$22481 = 72
self$ = 96
obj$ = 104
func$ = 112
save_pers PROC						; COMDAT

; 2870 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2871 :     PyObject *pid = NULL;

  00013	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pid$[rsp], 0

; 2872 :     int status = 0;

  0001c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 2873 : 
; 2874 :     const char persid_op = PERSID;

  00024	c6 44 24 21 50	 mov	 BYTE PTR persid_op$[rsp], 80 ; 00000050H

; 2875 :     const char binpersid_op = BINPERSID;

  00029	c6 44 24 20 51	 mov	 BYTE PTR binpersid_op$[rsp], 81 ; 00000051H

; 2876 : 
; 2877 :     Py_INCREF(obj);

  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR obj$[rsp]
  00033	e8 00 00 00 00	 call	 _Py_IncRef

; 2878 :     pid = _Pickler_FastCall(self, func, obj);

  00038	4c 8b 44 24 68	 mov	 r8, QWORD PTR obj$[rsp]
  0003d	48 8b 54 24 70	 mov	 rdx, QWORD PTR func$[rsp]
  00042	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00047	e8 00 00 00 00	 call	 _Pickler_FastCall
  0004c	48 89 44 24 28	 mov	 QWORD PTR pid$[rsp], rax

; 2879 :     if (pid == NULL)

  00051	48 83 7c 24 28
	00		 cmp	 QWORD PTR pid$[rsp], 0
  00057	75 0a		 jne	 SHORT $LN15@save_pers

; 2880 :         return -1;

  00059	b8 ff ff ff ff	 mov	 eax, -1
  0005e	e9 2d 01 00 00	 jmp	 $LN16@save_pers
$LN15@save_pers:

; 2881 : 
; 2882 :     if (pid != Py_None) {

  00063	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0006a	48 39 44 24 28	 cmp	 QWORD PTR pid$[rsp], rax
  0006f	0f 84 f1 00 00
	00		 je	 $LN14@save_pers

; 2883 :         if (self->bin) {

  00075	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0007a	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [rax+164], 0
  00081	74 3d		 je	 SHORT $LN13@save_pers

; 2884 :             if (save(self, pid, 1) < 0 ||
; 2885 :                 _Pickler_Write(self, &binpersid_op, 1) < 0)

  00083	41 b8 01 00 00
	00		 mov	 r8d, 1
  00089	48 8b 54 24 28	 mov	 rdx, QWORD PTR pid$[rsp]
  0008e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00093	e8 00 00 00 00	 call	 save
  00098	85 c0		 test	 eax, eax
  0009a	7c 1a		 jl	 SHORT $LN11@save_pers
  0009c	41 b8 01 00 00
	00		 mov	 r8d, 1
  000a2	48 8d 54 24 20	 lea	 rdx, QWORD PTR binpersid_op$[rsp]
  000a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000ac	e8 00 00 00 00	 call	 _Pickler_Write
  000b1	48 85 c0	 test	 rax, rax
  000b4	7d 05		 jge	 SHORT $LN12@save_pers
$LN11@save_pers:

; 2886 :                 goto error;

  000b6	e9 b1 00 00 00	 jmp	 $error$22477
$LN12@save_pers:

; 2887 :         }
; 2888 :         else {

  000bb	e9 9e 00 00 00	 jmp	 $LN10@save_pers
$LN13@save_pers:

; 2889 :             PyObject *pid_str = NULL;

  000c0	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pid_str$22479[rsp], 0

; 2890 :             char *pid_ascii_bytes;
; 2891 :             Py_ssize_t size;
; 2892 : 
; 2893 :             pid_str = PyObject_Str(pid);

  000c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pid$[rsp]
  000ce	e8 00 00 00 00	 call	 PyObject_Str
  000d3	48 89 44 24 38	 mov	 QWORD PTR pid_str$22479[rsp], rax

; 2894 :             if (pid_str == NULL)

  000d8	48 83 7c 24 38
	00		 cmp	 QWORD PTR pid_str$22479[rsp], 0
  000de	75 05		 jne	 SHORT $LN9@save_pers

; 2895 :                 goto error;

  000e0	e9 87 00 00 00	 jmp	 $error$22477
$LN9@save_pers:

; 2896 : 
; 2897 :             /* XXX: Should it check whether the persistent id only contains
; 2898 :                ASCII characters? And what if the pid contains embedded
; 2899 :                newlines? */
; 2900 :             pid_ascii_bytes = _PyUnicode_AsStringAndSize(pid_str, &size);

  000e5	48 8d 54 24 40	 lea	 rdx, QWORD PTR size$22482[rsp]
  000ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pid_str$22479[rsp]
  000ef	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  000f4	48 89 44 24 48	 mov	 QWORD PTR pid_ascii_bytes$22481[rsp], rax

; 2901 :             Py_DECREF(pid_str);

  000f9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pid_str$22479[rsp]
  000fe	e8 00 00 00 00	 call	 _Py_DecRef

; 2902 :             if (pid_ascii_bytes == NULL)

  00103	48 83 7c 24 48
	00		 cmp	 QWORD PTR pid_ascii_bytes$22481[rsp], 0
  00109	75 02		 jne	 SHORT $LN8@save_pers

; 2903 :                 goto error;

  0010b	eb 5f		 jmp	 SHORT $error$22477
$LN8@save_pers:

; 2904 : 
; 2905 :             if (_Pickler_Write(self, &persid_op, 1) < 0 ||
; 2906 :                 _Pickler_Write(self, pid_ascii_bytes, size) < 0 ||
; 2907 :                 _Pickler_Write(self, "\n", 1) < 0)

  0010d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00113	48 8d 54 24 21	 lea	 rdx, QWORD PTR persid_op$[rsp]
  00118	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0011d	e8 00 00 00 00	 call	 _Pickler_Write
  00122	48 85 c0	 test	 rax, rax
  00125	7c 35		 jl	 SHORT $LN6@save_pers
  00127	4c 8b 44 24 40	 mov	 r8, QWORD PTR size$22482[rsp]
  0012c	48 8b 54 24 48	 mov	 rdx, QWORD PTR pid_ascii_bytes$22481[rsp]
  00131	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00136	e8 00 00 00 00	 call	 _Pickler_Write
  0013b	48 85 c0	 test	 rax, rax
  0013e	7c 1c		 jl	 SHORT $LN6@save_pers
  00140	41 b8 01 00 00
	00		 mov	 r8d, 1
  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  0014d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00152	e8 00 00 00 00	 call	 _Pickler_Write
  00157	48 85 c0	 test	 rax, rax
  0015a	7d 02		 jge	 SHORT $LN7@save_pers
$LN6@save_pers:

; 2908 :                 goto error;

  0015c	eb 0e		 jmp	 SHORT $error$22477
$LN7@save_pers:
$LN10@save_pers:

; 2909 :         }
; 2910 :         status = 1;

  0015e	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR status$[rsp], 1
$LN14@save_pers:

; 2911 :     }
; 2912 : 
; 2913 :     if (0) {

  00166	33 c0		 xor	 eax, eax
  00168	85 c0		 test	 eax, eax
  0016a	74 08		 je	 SHORT $LN5@save_pers
$error$22477:

; 2914 :   error:
; 2915 :         status = -1;

  0016c	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1
$LN5@save_pers:
$LN4@save_pers:

; 2916 :     }
; 2917 :     Py_XDECREF(pid);

  00174	48 83 7c 24 28
	00		 cmp	 QWORD PTR pid$[rsp], 0
  0017a	74 0a		 je	 SHORT $LN1@save_pers
  0017c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pid$[rsp]
  00181	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@save_pers:
  00186	33 c0		 xor	 eax, eax
  00188	85 c0		 test	 eax, eax
  0018a	75 e8		 jne	 SHORT $LN4@save_pers

; 2918 : 
; 2919 :     return status;

  0018c	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
$LN16@save_pers:

; 2920 : }

  00190	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00194	c3		 ret	 0
save_pers ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@LEGKFGN@args?$FL0?$FN?5from?5__newobj__?5args?5has@ ; `string'
PUBLIC	??_C@_0CL@MPICCEHP@args?$FL0?$FN?5from?5__newobj__?5args?5is?5@ ; `string'
PUBLIC	??_C@_0BM@LCDLENIA@__newobj__?5arglist?5is?5empty?$AA@ ; `string'
PUBLIC	??_C@_0L@GEMAGKL@__newobj__?$AA@		; `string'
PUBLIC	??_C@_0EO@IJJFOKCF@fifth?5element?5of?5the?5tuple?5retur@ ; `string'
PUBLIC	??_C@_0EP@LILNLFGN@fourth?5element?5of?5the?5tuple?5retu@ ; `string'
PUBLIC	??_C@_0EA@DFGACFMJ@second?5item?5of?5the?5tuple?5returne@ ; `string'
PUBLIC	??_C@_0EA@JJGKNCFD@first?5item?5of?5the?5tuple?5returned@ ; `string'
PUBLIC	??_C@_0M@GGIHMHGB@save_reduce?$AA@		; `string'
PUBLIC	??_C@_0DP@FFGPPFID@tuple?5returned?5by?5__reduce__?5mus@ ; `string'
EXTRN	PyTuple_GetSlice:PROC
EXTRN	PyUnicode_Compare:PROC
EXTRN	_PyObject_NextNotImplemented:PROC
EXTRN	PyCallable_Check:PROC
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_reduce DD imagerel save_reduce
	DD	imagerel save_reduce+1699
	DD	imagerel $unwind$save_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_reduce DD 021601H
	DD	01d0116H
xdata	ENDS
;	COMDAT ??_C@_0DB@LEGKFGN@args?$FL0?$FN?5from?5__newobj__?5args?5has@
CONST	SEGMENT
??_C@_0DB@LEGKFGN@args?$FL0?$FN?5from?5__newobj__?5args?5has@ DB 'args[0]'
	DB	' from __newobj__ args has the wrong class', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MPICCEHP@args?$FL0?$FN?5from?5__newobj__?5args?5is?5@
CONST	SEGMENT
??_C@_0CL@MPICCEHP@args?$FL0?$FN?5from?5__newobj__?5args?5is?5@ DB 'args['
	DB	'0] from __newobj__ args is not a type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LCDLENIA@__newobj__?5arglist?5is?5empty?$AA@
CONST	SEGMENT
??_C@_0BM@LCDLENIA@__newobj__?5arglist?5is?5empty?$AA@ DB '__newobj__ arg'
	DB	'list is empty', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GEMAGKL@__newobj__?$AA@
CONST	SEGMENT
??_C@_0L@GEMAGKL@__newobj__?$AA@ DB '__newobj__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@IJJFOKCF@fifth?5element?5of?5the?5tuple?5retur@
CONST	SEGMENT
??_C@_0EO@IJJFOKCF@fifth?5element?5of?5the?5tuple?5retur@ DB 'fifth eleme'
	DB	'nt of the tuple returned by __reduce__ must be an iterator, n'
	DB	'ot %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@LILNLFGN@fourth?5element?5of?5the?5tuple?5retu@
CONST	SEGMENT
??_C@_0EP@LILNLFGN@fourth?5element?5of?5the?5tuple?5retu@ DB 'fourth elem'
	DB	'ent of the tuple returned by __reduce__ must be an iterator, '
	DB	'not %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@DFGACFMJ@second?5item?5of?5the?5tuple?5returne@
CONST	SEGMENT
??_C@_0EA@DFGACFMJ@second?5item?5of?5the?5tuple?5returne@ DB 'second item'
	DB	' of the tuple returned by __reduce__ must be a tuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@JJGKNCFD@first?5item?5of?5the?5tuple?5returned@
CONST	SEGMENT
??_C@_0EA@JJGKNCFD@first?5item?5of?5the?5tuple?5returned@ DB 'first item '
	DB	'of the tuple returned by __reduce__ must be callable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGIHMHGB@save_reduce?$AA@
CONST	SEGMENT
??_C@_0M@GGIHMHGB@save_reduce?$AA@ DB 'save_reduce', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@FFGPPFID@tuple?5returned?5by?5__reduce__?5mus@
CONST	SEGMENT
??_C@_0DP@FFGPPFID@tuple?5returned?5by?5__reduce__?5mus@ DB 'tuple return'
	DB	'ed by __reduce__ must contain 2 through 5 elements', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT save_reduce
_TEXT	SEGMENT
listitems$ = 80
newobj_op$ = 88
argtup$ = 96
callable$ = 104
use_newobj$ = 112
size$ = 120
build_op$ = 128
dictitems$ = 136
reduce_op$ = 144
state$ = 152
name$22568 = 160
p$22587 = 168
obj_class$22586 = 176
newargtup$22585 = 184
cls$22584 = 192
tv66 = 200
tv175 = 204
tv194 = 208
self$ = 240
args$ = 248
obj$ = 256
save_reduce PROC					; COMDAT

; 2949 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 2950 :     PyObject *callable;
; 2951 :     PyObject *argtup;
; 2952 :     PyObject *state = NULL;

  00016	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR state$[rsp], 0

; 2953 :     PyObject *listitems = Py_None;

  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00029	48 89 44 24 50	 mov	 QWORD PTR listitems$[rsp], rax

; 2954 :     PyObject *dictitems = Py_None;

  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00035	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dictitems$[rsp], rax

; 2955 :     Py_ssize_t size;
; 2956 : 
; 2957 :     int use_newobj = self->proto >= 2;

  0003d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00045	83 b8 a0 00 00
	00 02		 cmp	 DWORD PTR [rax+160], 2
  0004c	7c 0d		 jl	 SHORT $LN43@save_reduc
  0004e	c7 84 24 c8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv66[rsp], 1
  00059	eb 0b		 jmp	 SHORT $LN44@save_reduc
$LN43@save_reduc:
  0005b	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv66[rsp], 0
$LN44@save_reduc:
  00066	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv66[rsp]
  0006d	89 44 24 70	 mov	 DWORD PTR use_newobj$[rsp], eax

; 2958 : 
; 2959 :     const char reduce_op = REDUCE;

  00071	c6 84 24 90 00
	00 00 52	 mov	 BYTE PTR reduce_op$[rsp], 82 ; 00000052H

; 2960 :     const char build_op = BUILD;

  00079	c6 84 24 80 00
	00 00 62	 mov	 BYTE PTR build_op$[rsp], 98 ; 00000062H

; 2961 :     const char newobj_op = NEWOBJ;

  00081	c6 44 24 58 81	 mov	 BYTE PTR newobj_op$[rsp], -127 ; ffffffffffffff81H

; 2962 : 
; 2963 :     size = PyTuple_Size(args);

  00086	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0008e	e8 00 00 00 00	 call	 PyTuple_Size
  00093	48 89 44 24 78	 mov	 QWORD PTR size$[rsp], rax

; 2964 :     if (size < 2 || size > 5) {

  00098	48 83 7c 24 78
	02		 cmp	 QWORD PTR size$[rsp], 2
  0009e	7c 08		 jl	 SHORT $LN39@save_reduc
  000a0	48 83 7c 24 78
	05		 cmp	 QWORD PTR size$[rsp], 5
  000a6	7e 1d		 jle	 SHORT $LN40@save_reduc
$LN39@save_reduc:

; 2965 :         PyErr_SetString(PicklingError, "tuple returned by "
; 2966 :                         "__reduce__ must contain 2 through 5 elements");

  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@FFGPPFID@tuple?5returned?5by?5__reduce__?5mus@
  000af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  000b6	e8 00 00 00 00	 call	 PyErr_SetString

; 2967 :         return -1;

  000bb	b8 ff ff ff ff	 mov	 eax, -1
  000c0	e9 d6 05 00 00	 jmp	 $LN41@save_reduc
$LN40@save_reduc:

; 2968 :     }
; 2969 : 
; 2970 :     if (!PyArg_UnpackTuple(args, "save_reduce", 2, 5,
; 2971 :                            &callable, &argtup, &state, &listitems, &dictitems))

  000c5	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR dictitems$[rsp]
  000cd	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000d2	48 8d 44 24 50	 lea	 rax, QWORD PTR listitems$[rsp]
  000d7	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000dc	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR state$[rsp]
  000e4	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000e9	48 8d 44 24 60	 lea	 rax, QWORD PTR argtup$[rsp]
  000ee	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f3	48 8d 44 24 68	 lea	 rax, QWORD PTR callable$[rsp]
  000f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fd	41 b9 05 00 00
	00		 mov	 r9d, 5
  00103	41 b8 02 00 00
	00		 mov	 r8d, 2
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GGIHMHGB@save_reduce?$AA@
  00110	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00118	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0011d	85 c0		 test	 eax, eax
  0011f	75 0a		 jne	 SHORT $LN38@save_reduc

; 2972 :         return -1;

  00121	b8 ff ff ff ff	 mov	 eax, -1
  00126	e9 70 05 00 00	 jmp	 $LN41@save_reduc
$LN38@save_reduc:

; 2973 : 
; 2974 :     if (!PyCallable_Check(callable)) {

  0012b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR callable$[rsp]
  00130	e8 00 00 00 00	 call	 PyCallable_Check
  00135	85 c0		 test	 eax, eax
  00137	75 1d		 jne	 SHORT $LN37@save_reduc

; 2975 :         PyErr_SetString(PicklingError, "first item of the tuple "
; 2976 :                         "returned by __reduce__ must be callable");

  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@JJGKNCFD@first?5item?5of?5the?5tuple?5returned@
  00140	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  00147	e8 00 00 00 00	 call	 PyErr_SetString

; 2977 :         return -1;

  0014c	b8 ff ff ff ff	 mov	 eax, -1
  00151	e9 45 05 00 00	 jmp	 $LN41@save_reduc
$LN37@save_reduc:

; 2978 :     }
; 2979 :     if (!PyTuple_Check(argtup)) {

  00156	48 8b 44 24 60	 mov	 rax, QWORD PTR argtup$[rsp]
  0015b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0015f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00165	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0016a	85 c0		 test	 eax, eax
  0016c	75 1d		 jne	 SHORT $LN36@save_reduc

; 2980 :         PyErr_SetString(PicklingError, "second item of the tuple "
; 2981 :                         "returned by __reduce__ must be a tuple");

  0016e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@DFGACFMJ@second?5item?5of?5the?5tuple?5returne@
  00175	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0017c	e8 00 00 00 00	 call	 PyErr_SetString

; 2982 :         return -1;

  00181	b8 ff ff ff ff	 mov	 eax, -1
  00186	e9 10 05 00 00	 jmp	 $LN41@save_reduc
$LN36@save_reduc:

; 2983 :     }
; 2984 : 
; 2985 :     if (state == Py_None)

  0018b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00192	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR state$[rsp], rax
  0019a	75 0c		 jne	 SHORT $LN35@save_reduc

; 2986 :         state = NULL;

  0019c	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR state$[rsp], 0
$LN35@save_reduc:

; 2987 : 
; 2988 :     if (listitems == Py_None)

  001a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001af	48 39 44 24 50	 cmp	 QWORD PTR listitems$[rsp], rax
  001b4	75 0b		 jne	 SHORT $LN34@save_reduc

; 2989 :         listitems = NULL;

  001b6	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR listitems$[rsp], 0
  001bf	eb 56		 jmp	 SHORT $LN33@save_reduc
$LN34@save_reduc:

; 2990 :     else if (!PyIter_Check(listitems)) {

  001c1	48 8b 44 24 50	 mov	 rax, QWORD PTR listitems$[rsp]
  001c6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001ca	48 83 b8 38 01
	00 00 00	 cmp	 QWORD PTR [rax+312], 0
  001d2	74 19		 je	 SHORT $LN31@save_reduc
  001d4	48 8b 44 24 50	 mov	 rax, QWORD PTR listitems$[rsp]
  001d9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyObject_NextNotImplemented
  001e4	48 39 88 38 01
	00 00		 cmp	 QWORD PTR [rax+312], rcx
  001eb	75 2a		 jne	 SHORT $LN32@save_reduc
$LN31@save_reduc:

; 2991 :         PyErr_Format(PicklingError, "fourth element of the tuple "
; 2992 :                      "returned by __reduce__ must be an iterator, not %s",
; 2993 :                      Py_TYPE(listitems)->tp_name);

  001ed	48 8b 44 24 50	 mov	 rax, QWORD PTR listitems$[rsp]
  001f2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001f6	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  001fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EP@LILNLFGN@fourth?5element?5of?5the?5tuple?5retu@
  00201	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  00208	e8 00 00 00 00	 call	 PyErr_Format

; 2994 :         return -1;

  0020d	b8 ff ff ff ff	 mov	 eax, -1
  00212	e9 84 04 00 00	 jmp	 $LN41@save_reduc
$LN32@save_reduc:
$LN33@save_reduc:

; 2995 :     }
; 2996 : 
; 2997 :     if (dictitems == Py_None)

  00217	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0021e	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR dictitems$[rsp], rax
  00226	75 0e		 jne	 SHORT $LN30@save_reduc

; 2998 :         dictitems = NULL;

  00228	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR dictitems$[rsp], 0
  00234	eb 5f		 jmp	 SHORT $LN29@save_reduc
$LN30@save_reduc:

; 2999 :     else if (!PyIter_Check(dictitems)) {

  00236	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dictitems$[rsp]
  0023e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00242	48 83 b8 38 01
	00 00 00	 cmp	 QWORD PTR [rax+312], 0
  0024a	74 1c		 je	 SHORT $LN27@save_reduc
  0024c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dictitems$[rsp]
  00254	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00258	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyObject_NextNotImplemented
  0025f	48 39 88 38 01
	00 00		 cmp	 QWORD PTR [rax+312], rcx
  00266	75 2d		 jne	 SHORT $LN28@save_reduc
$LN27@save_reduc:

; 3000 :         PyErr_Format(PicklingError, "fifth element of the tuple "
; 3001 :                      "returned by __reduce__ must be an iterator, not %s",
; 3002 :                      Py_TYPE(dictitems)->tp_name);

  00268	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dictitems$[rsp]
  00270	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00274	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00278	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EO@IJJFOKCF@fifth?5element?5of?5the?5tuple?5retur@
  0027f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  00286	e8 00 00 00 00	 call	 PyErr_Format

; 3003 :         return -1;

  0028b	b8 ff ff ff ff	 mov	 eax, -1
  00290	e9 06 04 00 00	 jmp	 $LN41@save_reduc
$LN28@save_reduc:
$LN29@save_reduc:

; 3004 :     }
; 3005 : 
; 3006 :     /* Protocol 2 special case: if callable's name is __newobj__, use
; 3007 :        NEWOBJ. */
; 3008 :     if (use_newobj) {

  00295	83 7c 24 70 00	 cmp	 DWORD PTR use_newobj$[rsp], 0
  0029a	0f 84 00 01 00
	00		 je	 $LN26@save_reduc

; 3009 :         static PyObject *newobj_str = NULL, *name_str = NULL;
; 3010 :         PyObject *name;
; 3011 : 
; 3012 :         if (newobj_str == NULL) {

  002a0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?newobj_str@?7??save_reduce@@9@9, 0
  002a8	75 44		 jne	 SHORT $LN25@save_reduc

; 3013 :             newobj_str = PyUnicode_InternFromString("__newobj__");

  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@GEMAGKL@__newobj__?$AA@
  002b1	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  002b6	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?newobj_str@?7??save_reduce@@9@9, rax

; 3014 :             name_str = PyUnicode_InternFromString("__name__");

  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08BHKDPDAA@__name__?$AA@
  002c4	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  002c9	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name_str@?7??save_reduce@@9@9, rax

; 3015 :             if (newobj_str == NULL || name_str == NULL)

  002d0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?newobj_str@?7??save_reduce@@9@9, 0
  002d8	74 0a		 je	 SHORT $LN23@save_reduc
  002da	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name_str@?7??save_reduce@@9@9, 0
  002e2	75 0a		 jne	 SHORT $LN24@save_reduc
$LN23@save_reduc:

; 3016 :                 return -1;

  002e4	b8 ff ff ff ff	 mov	 eax, -1
  002e9	e9 ad 03 00 00	 jmp	 $LN41@save_reduc
$LN24@save_reduc:
$LN25@save_reduc:

; 3017 :         }
; 3018 : 
; 3019 :         name = PyObject_GetAttr(callable, name_str);

  002ee	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?name_str@?7??save_reduce@@9@9
  002f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR callable$[rsp]
  002fa	e8 00 00 00 00	 call	 PyObject_GetAttr
  002ff	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR name$22568[rsp], rax

; 3020 :         if (name == NULL) {

  00307	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR name$22568[rsp], 0
  00310	75 2b		 jne	 SHORT $LN22@save_reduc

; 3021 :             if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00312	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00319	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0031e	85 c0		 test	 eax, eax
  00320	74 07		 je	 SHORT $LN21@save_reduc

; 3022 :                 PyErr_Clear();

  00322	e8 00 00 00 00	 call	 PyErr_Clear

; 3023 :             else

  00327	eb 0a		 jmp	 SHORT $LN20@save_reduc
$LN21@save_reduc:

; 3024 :                 return -1;

  00329	b8 ff ff ff ff	 mov	 eax, -1
  0032e	e9 68 03 00 00	 jmp	 $LN41@save_reduc
$LN20@save_reduc:

; 3025 :             use_newobj = 0;

  00333	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR use_newobj$[rsp], 0

; 3026 :         }
; 3027 :         else {

  0033b	eb 63		 jmp	 SHORT $LN19@save_reduc
$LN22@save_reduc:

; 3028 :             use_newobj = PyUnicode_Check(name) &&
; 3029 :                          PyUnicode_Compare(name, newobj_str) == 0;

  0033d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR name$22568[rsp]
  00345	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00349	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0034f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00354	85 c0		 test	 eax, eax
  00356	74 25		 je	 SHORT $LN45@save_reduc
  00358	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?newobj_str@?7??save_reduce@@9@9
  0035f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR name$22568[rsp]
  00367	e8 00 00 00 00	 call	 PyUnicode_Compare
  0036c	85 c0		 test	 eax, eax
  0036e	75 0d		 jne	 SHORT $LN45@save_reduc
  00370	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv175[rsp], 1
  0037b	eb 0b		 jmp	 SHORT $LN46@save_reduc
$LN45@save_reduc:
  0037d	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv175[rsp], 0
$LN46@save_reduc:
  00388	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR tv175[rsp]
  0038f	89 44 24 70	 mov	 DWORD PTR use_newobj$[rsp], eax

; 3030 :             Py_DECREF(name);

  00393	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR name$22568[rsp]
  0039b	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@save_reduc:
$LN26@save_reduc:

; 3031 :         }
; 3032 :     }
; 3033 :     if (use_newobj) {

  003a0	83 7c 24 70 00	 cmp	 DWORD PTR use_newobj$[rsp], 0
  003a5	0f 84 c6 01 00
	00		 je	 $LN18@save_reduc

; 3034 :         PyObject *cls;
; 3035 :         PyObject *newargtup;
; 3036 :         PyObject *obj_class;
; 3037 :         int p;
; 3038 : 
; 3039 :         /* Sanity checks. */
; 3040 :         if (Py_SIZE(argtup) < 1) {

  003ab	48 8b 44 24 60	 mov	 rax, QWORD PTR argtup$[rsp]
  003b0	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  003b5	7d 1d		 jge	 SHORT $LN17@save_reduc

; 3041 :             PyErr_SetString(PicklingError, "__newobj__ arglist is empty");

  003b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@LCDLENIA@__newobj__?5arglist?5is?5empty?$AA@
  003be	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  003c5	e8 00 00 00 00	 call	 PyErr_SetString

; 3042 :             return -1;

  003ca	b8 ff ff ff ff	 mov	 eax, -1
  003cf	e9 c7 02 00 00	 jmp	 $LN41@save_reduc
$LN17@save_reduc:

; 3043 :         }
; 3044 : 
; 3045 :         cls = PyTuple_GET_ITEM(argtup, 0);

  003d4	48 8b 44 24 60	 mov	 rax, QWORD PTR argtup$[rsp]
  003d9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  003dd	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR cls$22584[rsp], rax

; 3046 :         if (!PyType_Check(cls)) {

  003e5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cls$22584[rsp]
  003ed	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003f1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003f7	25 00 00 00 80	 and	 eax, -2147483648	; ffffffff80000000H
  003fc	85 c0		 test	 eax, eax
  003fe	75 1d		 jne	 SHORT $LN16@save_reduc

; 3047 :             PyErr_SetString(PicklingError, "args[0] from "
; 3048 :                             "__newobj__ args is not a type");

  00400	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@MPICCEHP@args?$FL0?$FN?5from?5__newobj__?5args?5is?5@
  00407	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0040e	e8 00 00 00 00	 call	 PyErr_SetString

; 3049 :             return -1;

  00413	b8 ff ff ff ff	 mov	 eax, -1
  00418	e9 7e 02 00 00	 jmp	 $LN41@save_reduc
$LN16@save_reduc:

; 3050 :         }
; 3051 : 
; 3052 :         if (obj != NULL) {

  0041d	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR obj$[rsp], 0
  00426	0f 84 81 00 00
	00		 je	 $LN15@save_reduc

; 3053 :             obj_class = get_class(obj);

  0042c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  00434	e8 00 00 00 00	 call	 get_class
  00439	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR obj_class$22586[rsp], rax

; 3054 :             p = obj_class != cls;    /* true iff a problem */

  00441	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cls$22584[rsp]
  00449	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR obj_class$22586[rsp], rax
  00451	74 0d		 je	 SHORT $LN47@save_reduc
  00453	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv194[rsp], 1
  0045e	eb 0b		 jmp	 SHORT $LN48@save_reduc
$LN47@save_reduc:
  00460	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv194[rsp], 0
$LN48@save_reduc:
  0046b	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv194[rsp]
  00472	89 84 24 a8 00
	00 00		 mov	 DWORD PTR p$22587[rsp], eax

; 3055 :             Py_DECREF(obj_class);

  00479	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR obj_class$22586[rsp]
  00481	e8 00 00 00 00	 call	 _Py_DecRef

; 3056 :             if (p) {

  00486	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR p$22587[rsp], 0
  0048e	74 1d		 je	 SHORT $LN14@save_reduc

; 3057 :                 PyErr_SetString(PicklingError, "args[0] from "
; 3058 :                                 "__newobj__ args has the wrong class");

  00490	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@LEGKFGN@args?$FL0?$FN?5from?5__newobj__?5args?5has@
  00497	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0049e	e8 00 00 00 00	 call	 PyErr_SetString

; 3059 :                 return -1;

  004a3	b8 ff ff ff ff	 mov	 eax, -1
  004a8	e9 ee 01 00 00	 jmp	 $LN41@save_reduc
$LN14@save_reduc:
$LN15@save_reduc:

; 3060 :             }
; 3061 :         }
; 3062 :         /* XXX: These calls save() are prone to infinite recursion. Imagine
; 3063 :            what happen if the value returned by the __reduce__() method of
; 3064 :            some extension type contains another object of the same type. Ouch!
; 3065 : 
; 3066 :            Here is a quick example, that I ran into, to illustrate what I
; 3067 :            mean:
; 3068 : 
; 3069 :              >>> import pickle, copyreg
; 3070 :              >>> copyreg.dispatch_table.pop(complex)
; 3071 :              >>> pickle.dumps(1+2j)
; 3072 :              Traceback (most recent call last):
; 3073 :                ...
; 3074 :              RuntimeError: maximum recursion depth exceeded
; 3075 : 
; 3076 :            Removing the complex class from copyreg.dispatch_table made the
; 3077 :            __reduce_ex__() method emit another complex object:
; 3078 : 
; 3079 :              >>> (1+1j).__reduce_ex__(2)
; 3080 :              (<function __newobj__ at 0xb7b71c3c>,
; 3081 :                (<class 'complex'>, (1+1j)), None, None, None)
; 3082 : 
; 3083 :            Thus when save() was called on newargstup (the 2nd item) recursion
; 3084 :            ensued. Of course, the bug was in the complex class which had a
; 3085 :            broken __getnewargs__() that emitted another complex object. But,
; 3086 :            the point, here, is it is quite easy to end up with a broken reduce
; 3087 :            function. */
; 3088 : 
; 3089 :         /* Save the class and its __new__ arguments. */
; 3090 :         if (save(self, cls, 0) < 0)

  004ad	45 33 c0	 xor	 r8d, r8d
  004b0	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR cls$22584[rsp]
  004b8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  004c0	e8 00 00 00 00	 call	 save
  004c5	85 c0		 test	 eax, eax
  004c7	7d 0a		 jge	 SHORT $LN13@save_reduc

; 3091 :             return -1;

  004c9	b8 ff ff ff ff	 mov	 eax, -1
  004ce	e9 c8 01 00 00	 jmp	 $LN41@save_reduc
$LN13@save_reduc:

; 3092 : 
; 3093 :         newargtup = PyTuple_GetSlice(argtup, 1, Py_SIZE(argtup));

  004d3	48 8b 44 24 60	 mov	 rax, QWORD PTR argtup$[rsp]
  004d8	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  004dc	ba 01 00 00 00	 mov	 edx, 1
  004e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR argtup$[rsp]
  004e6	e8 00 00 00 00	 call	 PyTuple_GetSlice
  004eb	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR newargtup$22585[rsp], rax

; 3094 :         if (newargtup == NULL)

  004f3	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR newargtup$22585[rsp], 0
  004fc	75 0a		 jne	 SHORT $LN12@save_reduc

; 3095 :             return -1;

  004fe	b8 ff ff ff ff	 mov	 eax, -1
  00503	e9 93 01 00 00	 jmp	 $LN41@save_reduc
$LN12@save_reduc:

; 3096 : 
; 3097 :         p = save(self, newargtup, 0);

  00508	45 33 c0	 xor	 r8d, r8d
  0050b	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR newargtup$22585[rsp]
  00513	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0051b	e8 00 00 00 00	 call	 save
  00520	89 84 24 a8 00
	00 00		 mov	 DWORD PTR p$22587[rsp], eax

; 3098 :         Py_DECREF(newargtup);

  00527	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR newargtup$22585[rsp]
  0052f	e8 00 00 00 00	 call	 _Py_DecRef

; 3099 :         if (p < 0)

  00534	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR p$22587[rsp], 0
  0053c	7d 0a		 jge	 SHORT $LN11@save_reduc

; 3100 :             return -1;

  0053e	b8 ff ff ff ff	 mov	 eax, -1
  00543	e9 53 01 00 00	 jmp	 $LN41@save_reduc
$LN11@save_reduc:

; 3101 : 
; 3102 :         /* Add NEWOBJ opcode. */
; 3103 :         if (_Pickler_Write(self, &newobj_op, 1) < 0)

  00548	41 b8 01 00 00
	00		 mov	 r8d, 1
  0054e	48 8d 54 24 58	 lea	 rdx, QWORD PTR newobj_op$[rsp]
  00553	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0055b	e8 00 00 00 00	 call	 _Pickler_Write
  00560	48 85 c0	 test	 rax, rax
  00563	7d 0a		 jge	 SHORT $LN10@save_reduc

; 3104 :             return -1;

  00565	b8 ff ff ff ff	 mov	 eax, -1
  0056a	e9 2c 01 00 00	 jmp	 $LN41@save_reduc
$LN10@save_reduc:

; 3105 :     }
; 3106 :     else { /* Not using NEWOBJ. */

  0056f	eb 5c		 jmp	 SHORT $LN9@save_reduc
$LN18@save_reduc:

; 3107 :         if (save(self, callable, 0) < 0 ||
; 3108 :             save(self, argtup, 0) < 0 ||
; 3109 :             _Pickler_Write(self, &reduce_op, 1) < 0)

  00571	45 33 c0	 xor	 r8d, r8d
  00574	48 8b 54 24 68	 mov	 rdx, QWORD PTR callable$[rsp]
  00579	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00581	e8 00 00 00 00	 call	 save
  00586	85 c0		 test	 eax, eax
  00588	7c 39		 jl	 SHORT $LN7@save_reduc
  0058a	45 33 c0	 xor	 r8d, r8d
  0058d	48 8b 54 24 60	 mov	 rdx, QWORD PTR argtup$[rsp]
  00592	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0059a	e8 00 00 00 00	 call	 save
  0059f	85 c0		 test	 eax, eax
  005a1	7c 20		 jl	 SHORT $LN7@save_reduc
  005a3	41 b8 01 00 00
	00		 mov	 r8d, 1
  005a9	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR reduce_op$[rsp]
  005b1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  005b9	e8 00 00 00 00	 call	 _Pickler_Write
  005be	48 85 c0	 test	 rax, rax
  005c1	7d 0a		 jge	 SHORT $LN8@save_reduc
$LN7@save_reduc:

; 3110 :             return -1;

  005c3	b8 ff ff ff ff	 mov	 eax, -1
  005c8	e9 ce 00 00 00	 jmp	 $LN41@save_reduc
$LN8@save_reduc:
$LN9@save_reduc:

; 3111 :     }
; 3112 : 
; 3113 :     /* obj can be NULL when save_reduce() is used directly. A NULL obj means
; 3114 :        the caller do not want to memoize the object. Not particularly useful,
; 3115 :        but that is to mimic the behavior save_reduce() in pickle.py when
; 3116 :        obj is None. */
; 3117 :     if (obj && memo_put(self, obj) < 0)

  005cd	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR obj$[rsp], 0
  005d6	74 23		 je	 SHORT $LN6@save_reduc
  005d8	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR obj$[rsp]
  005e0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  005e8	e8 00 00 00 00	 call	 memo_put
  005ed	85 c0		 test	 eax, eax
  005ef	7d 0a		 jge	 SHORT $LN6@save_reduc

; 3118 :         return -1;

  005f1	b8 ff ff ff ff	 mov	 eax, -1
  005f6	e9 a0 00 00 00	 jmp	 $LN41@save_reduc
$LN6@save_reduc:

; 3119 : 
; 3120 :     if (listitems && batch_list(self, listitems) < 0)

  005fb	48 83 7c 24 50
	00		 cmp	 QWORD PTR listitems$[rsp], 0
  00601	74 1d		 je	 SHORT $LN5@save_reduc
  00603	48 8b 54 24 50	 mov	 rdx, QWORD PTR listitems$[rsp]
  00608	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00610	e8 00 00 00 00	 call	 batch_list
  00615	85 c0		 test	 eax, eax
  00617	7d 07		 jge	 SHORT $LN5@save_reduc

; 3121 :         return -1;

  00619	b8 ff ff ff ff	 mov	 eax, -1
  0061e	eb 7b		 jmp	 SHORT $LN41@save_reduc
$LN5@save_reduc:

; 3122 : 
; 3123 :     if (dictitems && batch_dict(self, dictitems) < 0)

  00620	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dictitems$[rsp], 0
  00629	74 20		 je	 SHORT $LN4@save_reduc
  0062b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR dictitems$[rsp]
  00633	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0063b	e8 00 00 00 00	 call	 batch_dict
  00640	85 c0		 test	 eax, eax
  00642	7d 07		 jge	 SHORT $LN4@save_reduc

; 3124 :         return -1;

  00644	b8 ff ff ff ff	 mov	 eax, -1
  00649	eb 50		 jmp	 SHORT $LN41@save_reduc
$LN4@save_reduc:

; 3125 : 
; 3126 :     if (state) {

  0064b	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR state$[rsp], 0
  00654	74 43		 je	 SHORT $LN3@save_reduc

; 3127 :         if (save(self, state, 0) < 0 ||
; 3128 :             _Pickler_Write(self, &build_op, 1) < 0)

  00656	45 33 c0	 xor	 r8d, r8d
  00659	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  00661	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00669	e8 00 00 00 00	 call	 save
  0066e	85 c0		 test	 eax, eax
  00670	7c 20		 jl	 SHORT $LN1@save_reduc
  00672	41 b8 01 00 00
	00		 mov	 r8d, 1
  00678	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR build_op$[rsp]
  00680	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00688	e8 00 00 00 00	 call	 _Pickler_Write
  0068d	48 85 c0	 test	 rax, rax
  00690	7d 07		 jge	 SHORT $LN2@save_reduc
$LN1@save_reduc:

; 3129 :             return -1;

  00692	b8 ff ff ff ff	 mov	 eax, -1
  00697	eb 02		 jmp	 SHORT $LN41@save_reduc
$LN2@save_reduc:
$LN3@save_reduc:

; 3130 :     }
; 3131 : 
; 3132 :     return 0;

  00699	33 c0		 xor	 eax, eax
$LN41@save_reduc:

; 3133 : }

  0069b	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  006a2	c3		 ret	 0
save_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LFGACEKG@__class__?$AA@			; `string'
_BSS	SEGMENT
?str_class@?1??get_class@@9@9 DQ 01H DUP (?)		; `get_class'::`2'::str_class
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_class DD imagerel get_class
	DD	imagerel get_class+137
	DD	imagerel $unwind$get_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_class DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_09LFGACEKG@__class__?$AA@
CONST	SEGMENT
??_C@_09LFGACEKG@__class__?$AA@ DB '__class__', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT get_class
_TEXT	SEGMENT
cls$ = 32
obj$ = 64
get_class PROC						; COMDAT

; 2924 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2925 :     PyObject *cls;
; 2926 :     static PyObject *str_class;
; 2927 : 
; 2928 :     if (str_class == NULL) {

  00009	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?str_class@?1??get_class@@9@9, 0
  00011	75 21		 jne	 SHORT $LN4@get_class

; 2929 :         str_class = PyUnicode_InternFromString("__class__");

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09LFGACEKG@__class__?$AA@
  0001a	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0001f	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?str_class@?1??get_class@@9@9, rax

; 2930 :         if (str_class == NULL)

  00026	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?str_class@?1??get_class@@9@9, 0
  0002e	75 04		 jne	 SHORT $LN3@get_class

; 2931 :             return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 50		 jmp	 SHORT $LN5@get_class
$LN3@get_class:
$LN4@get_class:

; 2932 :     }
; 2933 :     cls = PyObject_GetAttr(obj, str_class);

  00034	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?str_class@?1??get_class@@9@9
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  00040	e8 00 00 00 00	 call	 PyObject_GetAttr
  00045	48 89 44 24 20	 mov	 QWORD PTR cls$[rsp], rax

; 2934 :     if (cls == NULL) {

  0004a	48 83 7c 24 20
	00		 cmp	 QWORD PTR cls$[rsp], 0
  00050	75 2d		 jne	 SHORT $LN2@get_class

; 2935 :         if (PyErr_ExceptionMatches(PyExc_AttributeError)) {

  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00059	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0005e	85 c0		 test	 eax, eax
  00060	74 1d		 je	 SHORT $LN1@get_class

; 2936 :             PyErr_Clear();

  00062	e8 00 00 00 00	 call	 PyErr_Clear

; 2937 :             cls = (PyObject *) Py_TYPE(obj);

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  0006c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00070	48 89 44 24 20	 mov	 QWORD PTR cls$[rsp], rax

; 2938 :             Py_INCREF(cls);

  00075	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cls$[rsp]
  0007a	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@get_class:
$LN2@get_class:

; 2939 :         }
; 2940 :     }
; 2941 :     return cls;

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR cls$[rsp]
$LN5@get_class:

; 2942 : }

  00084	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00088	c3		 ret	 0
get_class ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_UnTrack:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_dealloc DD imagerel Pickler_dealloc
	DD	imagerel Pickler_dealloc+268
	DD	imagerel $unwind$Pickler_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Pickler_dealloc
_TEXT	SEGMENT
self$ = 48
Pickler_dealloc PROC					; COMDAT

; 3427 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3428 :     PyObject_GC_UnTrack(self);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN24@Pickler_de:

; 3429 : 
; 3430 :     Py_XDECREF(self->output_buffer);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00020	74 11		 je	 SHORT $LN21@Pickler_de
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  0002e	e8 00 00 00 00	 call	 _Py_DecRef
$LN21@Pickler_de:
  00033	33 c0		 xor	 eax, eax
  00035	85 c0		 test	 eax, eax
  00037	75 da		 jne	 SHORT $LN24@Pickler_de
$LN20@Pickler_de:

; 3431 :     Py_XDECREF(self->write);

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00046	74 11		 je	 SHORT $LN17@Pickler_de
  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004d	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00054	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@Pickler_de:
  00059	33 c0		 xor	 eax, eax
  0005b	85 c0		 test	 eax, eax
  0005d	75 da		 jne	 SHORT $LN20@Pickler_de
$LN16@Pickler_de:

; 3432 :     Py_XDECREF(self->pers_func);

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00064	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00069	74 0e		 je	 SHORT $LN13@Pickler_de
  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00070	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00074	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@Pickler_de:
  00079	33 c0		 xor	 eax, eax
  0007b	85 c0		 test	 eax, eax
  0007d	75 e0		 jne	 SHORT $LN16@Pickler_de
$LN12@Pickler_de:

; 3433 :     Py_XDECREF(self->dispatch_table);

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00084	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00089	74 0e		 je	 SHORT $LN9@Pickler_de
  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00090	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00094	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@Pickler_de:
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e0		 jne	 SHORT $LN12@Pickler_de
$LN8@Pickler_de:

; 3434 :     Py_XDECREF(self->arg);

  0009f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000a4	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  000a9	74 0e		 je	 SHORT $LN5@Pickler_de
  000ab	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000b0	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  000b4	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@Pickler_de:
  000b9	33 c0		 xor	 eax, eax
  000bb	85 c0		 test	 eax, eax
  000bd	75 e0		 jne	 SHORT $LN8@Pickler_de
$LN4@Pickler_de:

; 3435 :     Py_XDECREF(self->fast_memo);

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000c4	48 83 b8 c0 00
	00 00 00	 cmp	 QWORD PTR [rax+192], 0
  000cc	74 11		 je	 SHORT $LN1@Pickler_de
  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000d3	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]
  000da	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Pickler_de:
  000df	33 c0		 xor	 eax, eax
  000e1	85 c0		 test	 eax, eax
  000e3	75 da		 jne	 SHORT $LN4@Pickler_de

; 3436 : 
; 3437 :     PyMemoTable_Del(self->memo);

  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000ea	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000ee	e8 00 00 00 00	 call	 PyMemoTable_Del

; 3438 : 
; 3439 :     Py_TYPE(self)->tp_free((PyObject *)self);

  000f3	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000f8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00101	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 3440 : }

  00107	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010b	c3		 ret	 0
Pickler_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoTable_Del DD imagerel PyMemoTable_Del
	DD	imagerel PyMemoTable_Del+136
	DD	imagerel $unwind$PyMemoTable_Del
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_Del DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMemoTable_Del
_TEXT	SEGMENT
tv72 = 32
tv77 = 36
self$ = 64
PyMemoTable_Del PROC					; COMDAT

; 471  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 472  :     if (self == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR self$[rsp], 0
  0000f	75 02		 jne	 SHORT $LN1@PyMemoTabl@6

; 473  :         return;

  00011	eb 70		 jmp	 SHORT $LN2@PyMemoTabl@6
$LN1@PyMemoTabl@6:

; 474  :     PyMemoTable_Clear(self);

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00018	e8 00 00 00 00	 call	 PyMemoTable_Clear

; 475  : 
; 476  :     PyMem_FREE(self->mt_table);

  0001d	e8 00 00 00 00	 call	 _Py_PXCTX
  00022	85 c0		 test	 eax, eax
  00024	74 18		 je	 SHORT $LN4@PyMemoTabl@6
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002b	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0002f	e8 00 00 00 00	 call	 _PxMem_Free
  00034	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
  0003c	eb 16		 jmp	 SHORT $LN5@PyMemoTabl@6
$LN4@PyMemoTabl@6:
  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00043	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00047	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0004c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN5@PyMemoTabl@6:

; 477  :     PyMem_FREE(self);

  00054	e8 00 00 00 00	 call	 _Py_PXCTX
  00059	85 c0		 test	 eax, eax
  0005b	74 14		 je	 SHORT $LN6@PyMemoTabl@6
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00062	e8 00 00 00 00	 call	 _PxMem_Free
  00067	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
  0006f	eb 12		 jmp	 SHORT $LN7@PyMemoTabl@6
$LN6@PyMemoTabl@6:
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00076	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0007b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN7@PyMemoTabl@6:
$LN2@PyMemoTabl@6:

; 478  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
PyMemoTable_Del ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_traverse DD imagerel Pickler_traverse
	DD	imagerel Pickler_traverse+497
	DD	imagerel $unwind$Pickler_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_traverse DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@ DB 'Pickler_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Pickler_traverse
_TEXT	SEGMENT
vret$22842 = 32
vret$22850 = 36
vret$22858 = 40
vret$22866 = 44
vret$22874 = 48
self$ = 80
visit$ = 88
arg$ = 96
Pickler_traverse PROC					; COMDAT

; 3444 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN30@Pickler_tr:

; 3445 :     Py_VISIT(self->write);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN27@Pickler_tr
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 75 0d 00
	00		 mov	 r8d, 3445		; 00000d75H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN27@Pickler_tr:
  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00045	74 29		 je	 SHORT $LN26@Pickler_tr
  00047	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  0004c	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00051	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00058	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  0005c	89 44 24 20	 mov	 DWORD PTR vret$22842[rsp], eax
  00060	83 7c 24 20 00	 cmp	 DWORD PTR vret$22842[rsp], 0
  00065	74 09		 je	 SHORT $LN25@Pickler_tr
  00067	8b 44 24 20	 mov	 eax, DWORD PTR vret$22842[rsp]
  0006b	e9 7c 01 00 00	 jmp	 $LN31@Pickler_tr
$LN25@Pickler_tr:
$LN26@Pickler_tr:
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 9d		 jne	 SHORT $LN30@Pickler_tr
$LN24@Pickler_tr:

; 3446 :     Py_VISIT(self->pers_func);

  00076	e8 00 00 00 00	 call	 _Py_PXCTX
  0007b	85 c0		 test	 eax, eax
  0007d	74 1c		 je	 SHORT $LN21@Pickler_tr
  0007f	45 33 c9	 xor	 r9d, r9d
  00082	41 b8 76 0d 00
	00		 mov	 r8d, 3446		; 00000d76H
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
  00096	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN21@Pickler_tr:
  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000a0	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000a5	74 26		 je	 SHORT $LN20@Pickler_tr
  000a7	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  000ac	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000b1	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000b5	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  000b9	89 44 24 24	 mov	 DWORD PTR vret$22850[rsp], eax
  000bd	83 7c 24 24 00	 cmp	 DWORD PTR vret$22850[rsp], 0
  000c2	74 09		 je	 SHORT $LN19@Pickler_tr
  000c4	8b 44 24 24	 mov	 eax, DWORD PTR vret$22850[rsp]
  000c8	e9 1f 01 00 00	 jmp	 $LN31@Pickler_tr
$LN19@Pickler_tr:
$LN20@Pickler_tr:
  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 a3		 jne	 SHORT $LN24@Pickler_tr
$LN18@Pickler_tr:

; 3447 :     Py_VISIT(self->dispatch_table);

  000d3	e8 00 00 00 00	 call	 _Py_PXCTX
  000d8	85 c0		 test	 eax, eax
  000da	74 1c		 je	 SHORT $LN15@Pickler_tr
  000dc	45 33 c9	 xor	 r9d, r9d
  000df	41 b8 77 0d 00
	00		 mov	 r8d, 3447		; 00000d77H
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
  000f3	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@Pickler_tr:
  000f8	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000fd	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00102	74 26		 je	 SHORT $LN14@Pickler_tr
  00104	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  00109	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0010e	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00112	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  00116	89 44 24 28	 mov	 DWORD PTR vret$22858[rsp], eax
  0011a	83 7c 24 28 00	 cmp	 DWORD PTR vret$22858[rsp], 0
  0011f	74 09		 je	 SHORT $LN13@Pickler_tr
  00121	8b 44 24 28	 mov	 eax, DWORD PTR vret$22858[rsp]
  00125	e9 c2 00 00 00	 jmp	 $LN31@Pickler_tr
$LN13@Pickler_tr:
$LN14@Pickler_tr:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 a3		 jne	 SHORT $LN18@Pickler_tr
$LN12@Pickler_tr:

; 3448 :     Py_VISIT(self->arg);

  00130	e8 00 00 00 00	 call	 _Py_PXCTX
  00135	85 c0		 test	 eax, eax
  00137	74 1c		 je	 SHORT $LN9@Pickler_tr
  00139	45 33 c9	 xor	 r9d, r9d
  0013c	41 b8 78 0d 00
	00		 mov	 r8d, 3448		; 00000d78H
  00142	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
  00150	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@Pickler_tr:
  00155	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0015a	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0015f	74 23		 je	 SHORT $LN8@Pickler_tr
  00161	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  00166	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0016b	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  0016f	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  00173	89 44 24 2c	 mov	 DWORD PTR vret$22866[rsp], eax
  00177	83 7c 24 2c 00	 cmp	 DWORD PTR vret$22866[rsp], 0
  0017c	74 06		 je	 SHORT $LN7@Pickler_tr
  0017e	8b 44 24 2c	 mov	 eax, DWORD PTR vret$22866[rsp]
  00182	eb 68		 jmp	 SHORT $LN31@Pickler_tr
$LN7@Pickler_tr:
$LN8@Pickler_tr:
  00184	33 c0		 xor	 eax, eax
  00186	85 c0		 test	 eax, eax
  00188	75 a6		 jne	 SHORT $LN12@Pickler_tr
$LN6@Pickler_tr:

; 3449 :     Py_VISIT(self->fast_memo);

  0018a	e8 00 00 00 00	 call	 _Py_PXCTX
  0018f	85 c0		 test	 eax, eax
  00191	74 1c		 je	 SHORT $LN3@Pickler_tr
  00193	45 33 c9	 xor	 r9d, r9d
  00196	41 b8 79 0d 00
	00		 mov	 r8d, 3449		; 00000d79H
  0019c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
  001aa	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@Pickler_tr:
  001af	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001b4	48 83 b8 c0 00
	00 00 00	 cmp	 QWORD PTR [rax+192], 0
  001bc	74 26		 je	 SHORT $LN2@Pickler_tr
  001be	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  001c3	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001c8	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]
  001cf	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  001d3	89 44 24 30	 mov	 DWORD PTR vret$22874[rsp], eax
  001d7	83 7c 24 30 00	 cmp	 DWORD PTR vret$22874[rsp], 0
  001dc	74 06		 je	 SHORT $LN1@Pickler_tr
  001de	8b 44 24 30	 mov	 eax, DWORD PTR vret$22874[rsp]
  001e2	eb 08		 jmp	 SHORT $LN31@Pickler_tr
$LN1@Pickler_tr:
$LN2@Pickler_tr:
  001e4	33 c0		 xor	 eax, eax
  001e6	85 c0		 test	 eax, eax
  001e8	75 a0		 jne	 SHORT $LN6@Pickler_tr

; 3450 :     return 0;

  001ea	33 c0		 xor	 eax, eax
$LN31@Pickler_tr:

; 3451 : }

  001ec	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f0	c3		 ret	 0
Pickler_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@MAJBEHNL@Pickler_clear?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_clear DD imagerel Pickler_clear
	DD	imagerel Pickler_clear+788
	DD	imagerel $unwind$Pickler_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_clear DD 010901H
	DD	0e209H
xdata	ENDS
;	COMDAT ??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
CONST	SEGMENT
??_C@_0O@MAJBEHNL@Pickler_clear?$AA@ DB 'Pickler_clear', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Pickler_clear
_TEXT	SEGMENT
_py_tmp$22886 = 48
_py_tmp$22894 = 56
_py_tmp$22902 = 64
_py_tmp$22910 = 72
_py_tmp$22918 = 80
_py_tmp$22926 = 88
memo$22932 = 96
self$ = 128
Pickler_clear PROC					; COMDAT

; 3455 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H
$LN25@Pickler_cl@2:

; 3456 :     Py_CLEAR(self->output_buffer);

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00011	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00019	74 65		 je	 SHORT $LN22@Pickler_cl@2
  0001b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00023	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0002b	4c 8b 88 88 00
	00 00		 mov	 r9, QWORD PTR [rax+136]
  00032	41 b8 80 0d 00
	00		 mov	 r8d, 3456		; 00000d80H
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  00046	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004b	85 c0		 test	 eax, eax
  0004d	75 31		 jne	 SHORT $LN22@Pickler_cl@2
  0004f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00057	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  0005e	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$22886[rsp], rax
  00063	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$22886[rsp]
  0007b	e8 00 00 00 00	 call	 _Py_DecRef
$LN22@Pickler_cl@2:
  00080	33 c0		 xor	 eax, eax
  00082	85 c0		 test	 eax, eax
  00084	75 83		 jne	 SHORT $LN25@Pickler_cl@2
$LN21@Pickler_cl@2:

; 3457 :     Py_CLEAR(self->write);

  00086	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0008e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00096	74 65		 je	 SHORT $LN18@Pickler_cl@2
  00098	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a8	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  000af	41 b8 81 0d 00
	00		 mov	 r8d, 3457		; 00000d81H
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  000c3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c8	85 c0		 test	 eax, eax
  000ca	75 31		 jne	 SHORT $LN18@Pickler_cl@2
  000cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000d4	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000db	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$22894[rsp], rax
  000e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000e8	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
  000f3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$22894[rsp]
  000f8	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@Pickler_cl@2:
  000fd	33 c0		 xor	 eax, eax
  000ff	85 c0		 test	 eax, eax
  00101	75 83		 jne	 SHORT $LN21@Pickler_cl@2
$LN17@Pickler_cl@2:

; 3458 :     Py_CLEAR(self->pers_func);

  00103	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0010b	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00110	74 5c		 je	 SHORT $LN14@Pickler_cl@2
  00112	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0011a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00122	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  00126	41 b8 82 0d 00
	00		 mov	 r8d, 3458		; 00000d82H
  0012c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  0013a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0013f	85 c0		 test	 eax, eax
  00141	75 2b		 jne	 SHORT $LN14@Pickler_cl@2
  00143	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0014b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0014f	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$22902[rsp], rax
  00154	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0015c	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
  00164	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$22902[rsp]
  00169	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@Pickler_cl@2:
  0016e	33 c0		 xor	 eax, eax
  00170	85 c0		 test	 eax, eax
  00172	75 8f		 jne	 SHORT $LN17@Pickler_cl@2
$LN13@Pickler_cl@2:

; 3459 :     Py_CLEAR(self->dispatch_table);

  00174	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0017c	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00181	74 5c		 je	 SHORT $LN10@Pickler_cl@2
  00183	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0018b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00193	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00197	41 b8 83 0d 00
	00		 mov	 r8d, 3459		; 00000d83H
  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  001ab	e8 00 00 00 00	 call	 _PyParallel_Guard
  001b0	85 c0		 test	 eax, eax
  001b2	75 2b		 jne	 SHORT $LN10@Pickler_cl@2
  001b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001bc	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001c0	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$22910[rsp], rax
  001c5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001cd	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  001d5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$22910[rsp]
  001da	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@Pickler_cl@2:
  001df	33 c0		 xor	 eax, eax
  001e1	85 c0		 test	 eax, eax
  001e3	75 8f		 jne	 SHORT $LN13@Pickler_cl@2
$LN9@Pickler_cl@2:

; 3460 :     Py_CLEAR(self->arg);

  001e5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001ed	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  001f2	74 5c		 je	 SHORT $LN6@Pickler_cl@2
  001f4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001fc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00204	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  00208	41 b8 84 0d 00
	00		 mov	 r8d, 3460		; 00000d84H
  0020e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  0021c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00221	85 c0		 test	 eax, eax
  00223	75 2b		 jne	 SHORT $LN6@Pickler_cl@2
  00225	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0022d	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00231	48 89 44 24 50	 mov	 QWORD PTR _py_tmp$22918[rsp], rax
  00236	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0023e	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
  00246	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _py_tmp$22918[rsp]
  0024b	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@Pickler_cl@2:
  00250	33 c0		 xor	 eax, eax
  00252	85 c0		 test	 eax, eax
  00254	75 8f		 jne	 SHORT $LN9@Pickler_cl@2
$LN5@Pickler_cl@2:

; 3461 :     Py_CLEAR(self->fast_memo);

  00256	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0025e	48 83 b8 c0 00
	00 00 00	 cmp	 QWORD PTR [rax+192], 0
  00266	74 65		 je	 SHORT $LN2@Pickler_cl@2
  00268	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00270	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00278	4c 8b 88 c0 00
	00 00		 mov	 r9, QWORD PTR [rax+192]
  0027f	41 b8 85 0d 00
	00		 mov	 r8d, 3461		; 00000d85H
  00285	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0028c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  00293	e8 00 00 00 00	 call	 _PyParallel_Guard
  00298	85 c0		 test	 eax, eax
  0029a	75 31		 jne	 SHORT $LN2@Pickler_cl@2
  0029c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002a4	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002ab	48 89 44 24 58	 mov	 QWORD PTR _py_tmp$22926[rsp], rax
  002b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002b8	48 c7 80 c0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+192], 0
  002c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _py_tmp$22926[rsp]
  002c8	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@Pickler_cl@2:
  002cd	33 c0		 xor	 eax, eax
  002cf	85 c0		 test	 eax, eax
  002d1	75 83		 jne	 SHORT $LN5@Pickler_cl@2

; 3462 : 
; 3463 :     if (self->memo != NULL) {

  002d3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002db	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  002e0	74 2b		 je	 SHORT $LN1@Pickler_cl@2

; 3464 :         PyMemoTable *memo = self->memo;

  002e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002ea	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002ee	48 89 44 24 60	 mov	 QWORD PTR memo$22932[rsp], rax

; 3465 :         self->memo = NULL;

  002f3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002fb	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 3466 :         PyMemoTable_Del(memo);

  00303	48 8b 4c 24 60	 mov	 rcx, QWORD PTR memo$22932[rsp]
  00308	e8 00 00 00 00	 call	 PyMemoTable_Del
$LN1@Pickler_cl@2:

; 3467 :     }
; 3468 :     return 0;

  0030d	33 c0		 xor	 eax, eax

; 3469 : }

  0030f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00313	c3		 ret	 0
Pickler_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NDEHFBIC@O?$HMOO?3Pickler?$AA@		; `string'
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_PyObject_HasAttrId:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_init DD imagerel Pickler_init
	DD	imagerel Pickler_init+667
	DD	imagerel $unwind$Pickler_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_init DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0N@NDEHFBIC@O?$HMOO?3Pickler?$AA@
CONST	SEGMENT
??_C@_0N@NDEHFBIC@O?$HMOO?3Pickler?$AA@ DB 'O|OO:Pickler', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Pickler_init
_TEXT	SEGMENT
fix_imports$ = 64
file$ = 72
proto_obj$ = 80
self$ = 112
args$ = 120
kwds$ = 128
Pickler_init PROC					; COMDAT

; 3498 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3499 :     static char *kwlist[] = {"file", "protocol", "fix_imports", 0};
; 3500 :     PyObject *file;
; 3501 :     PyObject *proto_obj = NULL;

  00013	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR proto_obj$[rsp], 0

; 3502 :     PyObject *fix_imports = Py_True;

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00023	48 89 44 24 40	 mov	 QWORD PTR fix_imports$[rsp], rax

; 3503 :     _Py_IDENTIFIER(persistent_id);
; 3504 :     _Py_IDENTIFIER(dispatch_table);
; 3505 : 
; 3506 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:Pickler",
; 3507 :                                      kwlist, &file, &proto_obj, &fix_imports))

  00028	48 8d 44 24 40	 lea	 rax, QWORD PTR fix_imports$[rsp]
  0002d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00032	48 8d 44 24 50	 lea	 rax, QWORD PTR proto_obj$[rsp]
  00037	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003c	48 8d 44 24 48	 lea	 rax, QWORD PTR file$[rsp]
  00041	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00046	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??Pickler_init@@9@9
  0004d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@NDEHFBIC@O?$HMOO?3Pickler?$AA@
  00054	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  0005c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00061	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00066	85 c0		 test	 eax, eax
  00068	75 0a		 jne	 SHORT $LN12@Pickler_in

; 3508 :         return -1;

  0006a	b8 ff ff ff ff	 mov	 eax, -1
  0006f	e9 22 02 00 00	 jmp	 $LN13@Pickler_in
$LN12@Pickler_in:

; 3509 : 
; 3510 :     /* In case of multiple __init__() calls, clear previous content. */
; 3511 :     if (self->write != NULL)

  00074	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00079	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00081	74 0a		 je	 SHORT $LN11@Pickler_in

; 3512 :         (void)Pickler_clear(self);

  00083	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00088	e8 00 00 00 00	 call	 Pickler_clear
$LN11@Pickler_in:

; 3513 : 
; 3514 :     if (_Pickler_SetProtocol(self, proto_obj, fix_imports) < 0)

  0008d	4c 8b 44 24 40	 mov	 r8, QWORD PTR fix_imports$[rsp]
  00092	48 8b 54 24 50	 mov	 rdx, QWORD PTR proto_obj$[rsp]
  00097	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0009c	e8 00 00 00 00	 call	 _Pickler_SetProtocol
  000a1	85 c0		 test	 eax, eax
  000a3	7d 0a		 jge	 SHORT $LN10@Pickler_in

; 3515 :         return -1;

  000a5	b8 ff ff ff ff	 mov	 eax, -1
  000aa	e9 e7 01 00 00	 jmp	 $LN13@Pickler_in
$LN10@Pickler_in:

; 3516 : 
; 3517 :     if (_Pickler_SetOutputStream(self, file) < 0)

  000af	48 8b 54 24 48	 mov	 rdx, QWORD PTR file$[rsp]
  000b4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000b9	e8 00 00 00 00	 call	 _Pickler_SetOutputStream
  000be	85 c0		 test	 eax, eax
  000c0	7d 0a		 jge	 SHORT $LN9@Pickler_in

; 3518 :         return -1;

  000c2	b8 ff ff ff ff	 mov	 eax, -1
  000c7	e9 ca 01 00 00	 jmp	 $LN13@Pickler_in
$LN9@Pickler_in:

; 3519 : 
; 3520 :     /* memo and output_buffer may have already been created in _Pickler_New */
; 3521 :     if (self->memo == NULL) {

  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000d1	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000d6	75 24		 jne	 SHORT $LN8@Pickler_in

; 3522 :         self->memo = PyMemoTable_New();

  000d8	e8 00 00 00 00	 call	 PyMemoTable_New
  000dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000e2	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 3523 :         if (self->memo == NULL)

  000e6	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000eb	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000f0	75 0a		 jne	 SHORT $LN7@Pickler_in

; 3524 :             return -1;

  000f2	b8 ff ff ff ff	 mov	 eax, -1
  000f7	e9 9a 01 00 00	 jmp	 $LN13@Pickler_in
$LN7@Pickler_in:
$LN8@Pickler_in:

; 3525 :     }
; 3526 :     self->output_len = 0;

  000fc	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00101	48 c7 80 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+144], 0

; 3527 :     if (self->output_buffer == NULL) {

  0010c	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00111	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00119	75 48		 jne	 SHORT $LN6@Pickler_in

; 3528 :         self->max_output_len = WRITE_BUF_SIZE;

  0011b	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00120	48 c7 80 98 00
	00 00 00 10 00
	00		 mov	 QWORD PTR [rax+152], 4096 ; 00001000H

; 3529 :         self->output_buffer = PyBytes_FromStringAndSize(NULL,
; 3530 :                                                         self->max_output_len);

  0012b	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00130	48 8b 90 98 00
	00 00		 mov	 rdx, QWORD PTR [rax+152]
  00137	33 c9		 xor	 ecx, ecx
  00139	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0013e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00143	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 3531 :         if (self->output_buffer == NULL)

  0014a	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0014f	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00157	75 0a		 jne	 SHORT $LN5@Pickler_in

; 3532 :             return -1;

  00159	b8 ff ff ff ff	 mov	 eax, -1
  0015e	e9 33 01 00 00	 jmp	 $LN13@Pickler_in
$LN5@Pickler_in:
$LN6@Pickler_in:

; 3533 :     }
; 3534 : 
; 3535 :     self->arg = NULL;

  00163	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00168	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 3536 :     self->fast = 0;

  00170	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00175	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+176], 0

; 3537 :     self->fast_nesting = 0;

  0017f	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00184	c7 80 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+180], 0

; 3538 :     self->fast_memo = NULL;

  0018e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00193	48 c7 80 c0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+192], 0

; 3539 :     self->pers_func = NULL;

  0019e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001a3	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 3540 :     if (_PyObject_HasAttrId((PyObject *)self, &PyId_persistent_id)) {

  001ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_persistent_id@?1??Pickler_init@@9@9
  001b0	8b c0		 mov	 eax, eax
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001b8	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001c1	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  001c5	48 8b d0	 mov	 rdx, rax
  001c8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001cd	e8 00 00 00 00	 call	 _PyObject_HasAttrId
  001d2	85 c0		 test	 eax, eax
  001d4	74 43		 je	 SHORT $LN4@Pickler_in

; 3541 :         self->pers_func = _PyObject_GetAttrId((PyObject *)self,
; 3542 :                                               &PyId_persistent_id);

  001d6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_persistent_id@?1??Pickler_init@@9@9
  001db	8b c0		 mov	 eax, eax
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001e3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ec	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  001f0	48 8b d0	 mov	 rdx, rax
  001f3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001f8	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  001fd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00202	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 3543 :         if (self->pers_func == NULL)

  00206	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0020b	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00210	75 07		 jne	 SHORT $LN3@Pickler_in

; 3544 :             return -1;

  00212	b8 ff ff ff ff	 mov	 eax, -1
  00217	eb 7d		 jmp	 SHORT $LN13@Pickler_in
$LN3@Pickler_in:
$LN4@Pickler_in:

; 3545 :     }
; 3546 :     self->dispatch_table = NULL;

  00219	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0021e	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 3547 :     if (_PyObject_HasAttrId((PyObject *)self, &PyId_dispatch_table)) {

  00226	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_dispatch_table@?1??Pickler_init@@9@9
  0022b	8b c0		 mov	 eax, eax
  0022d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00233	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0023c	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00240	48 8b d0	 mov	 rdx, rax
  00243	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00248	e8 00 00 00 00	 call	 _PyObject_HasAttrId
  0024d	85 c0		 test	 eax, eax
  0024f	74 43		 je	 SHORT $LN2@Pickler_in

; 3548 :         self->dispatch_table = _PyObject_GetAttrId((PyObject *)self,
; 3549 :                                                    &PyId_dispatch_table);

  00251	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_dispatch_table@?1??Pickler_init@@9@9
  00256	8b c0		 mov	 eax, eax
  00258	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0025e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00267	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0026b	48 8b d0	 mov	 rdx, rax
  0026e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00273	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00278	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0027d	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 3550 :         if (self->dispatch_table == NULL)

  00281	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00286	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0028b	75 07		 jne	 SHORT $LN1@Pickler_in

; 3551 :             return -1;

  0028d	b8 ff ff ff ff	 mov	 eax, -1
  00292	eb 02		 jmp	 SHORT $LN13@Pickler_in
$LN1@Pickler_in:
$LN2@Pickler_in:

; 3552 :     }
; 3553 :     return 0;

  00294	33 c0		 xor	 eax, eax
$LN13@Pickler_in:

; 3554 : }

  00296	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0029a	c3		 ret	 0
Pickler_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoTable_New DD imagerel PyMemoTable_New
	DD	imagerel PyMemoTable_New+268
	DD	imagerel $unwind$PyMemoTable_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_New DD 010401H
	DD	08204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMemoTable_New
_TEXT	SEGMENT
memo$ = 32
tv70 = 40
tv81 = 48
tv88 = 56
PyMemoTable_New PROC					; COMDAT

; 401  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 402  :     PyMemoTable *memo = PyMem_MALLOC(sizeof(PyMemoTable));

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 11		 je	 SHORT $LN5@PyMemoTabl@7
  0000d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00012	e8 00 00 00 00	 call	 _PxMem_Malloc
  00017	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  0001c	eb 0f		 jmp	 SHORT $LN6@PyMemoTabl@7
$LN5@PyMemoTabl@7:
  0001e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00023	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00028	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN6@PyMemoTabl@7:
  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  00032	48 89 44 24 20	 mov	 QWORD PTR memo$[rsp], rax

; 403  :     if (memo == NULL) {

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR memo$[rsp], 0
  0003d	75 0c		 jne	 SHORT $LN2@PyMemoTabl@7

; 404  :         PyErr_NoMemory();

  0003f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 405  :         return NULL;

  00044	33 c0		 xor	 eax, eax
  00046	e9 bc 00 00 00	 jmp	 $LN3@PyMemoTabl@7
$LN2@PyMemoTabl@7:

; 406  :     }
; 407  : 
; 408  :     memo->mt_used = 0;

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR memo$[rsp]
  00050	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 409  :     memo->mt_allocated = MT_MINSIZE;

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR memo$[rsp]
  0005d	48 c7 40 10 08
	00 00 00	 mov	 QWORD PTR [rax+16], 8

; 410  :     memo->mt_mask = MT_MINSIZE - 1;

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR memo$[rsp]
  0006a	48 c7 00 07 00
	00 00		 mov	 QWORD PTR [rax], 7

; 411  :     memo->mt_table = PyMem_MALLOC(MT_MINSIZE * sizeof(PyMemoEntry));

  00071	e8 00 00 00 00	 call	 _Py_PXCTX
  00076	85 c0		 test	 eax, eax
  00078	74 11		 je	 SHORT $LN7@PyMemoTabl@7
  0007a	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0007f	e8 00 00 00 00	 call	 _PxMem_Malloc
  00084	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  00089	eb 0f		 jmp	 SHORT $LN8@PyMemoTabl@7
$LN7@PyMemoTabl@7:
  0008b	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00090	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00095	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
$LN8@PyMemoTabl@7:
  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR memo$[rsp]
  0009f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  000a4	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 412  :     if (memo->mt_table == NULL) {

  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR memo$[rsp]
  000ad	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000b2	75 38		 jne	 SHORT $LN1@PyMemoTabl@7

; 413  :         PyMem_FREE(memo);

  000b4	e8 00 00 00 00	 call	 _Py_PXCTX
  000b9	85 c0		 test	 eax, eax
  000bb	74 14		 je	 SHORT $LN9@PyMemoTabl@7
  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR memo$[rsp]
  000c2	e8 00 00 00 00	 call	 _PxMem_Free
  000c7	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
  000cf	eb 12		 jmp	 SHORT $LN10@PyMemoTabl@7
$LN9@PyMemoTabl@7:
  000d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR memo$[rsp]
  000d6	e8 00 00 00 00	 call	 _PyMem_DebugFree
  000db	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN10@PyMemoTabl@7:

; 414  :         PyErr_NoMemory();

  000e3	e8 00 00 00 00	 call	 PyErr_NoMemory

; 415  :         return NULL;

  000e8	33 c0		 xor	 eax, eax
  000ea	eb 1b		 jmp	 SHORT $LN3@PyMemoTabl@7
$LN1@PyMemoTabl@7:

; 416  :     }
; 417  :     memset(memo->mt_table, 0, MT_MINSIZE * sizeof(PyMemoEntry));

  000ec	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  000f2	33 d2		 xor	 edx, edx
  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR memo$[rsp]
  000f9	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000fd	e8 00 00 00 00	 call	 memset

; 418  : 
; 419  :     return memo;

  00102	48 8b 44 24 20	 mov	 rax, QWORD PTR memo$[rsp]
$LN3@PyMemoTabl@7:

; 420  : }

  00107	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010b	c3		 ret	 0
PyMemoTable_New ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@HLBJPKP@pickle?5protocol?5must?5be?5?$DM?$DN?5?$CFd?$AA@ ; `string'
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_SetProtocol DD imagerel _Pickler_SetProtocol
	DD	imagerel _Pickler_SetProtocol+294
	DD	imagerel $unwind$_Pickler_SetProtocol
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_SetProtocol DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BO@HLBJPKP@pickle?5protocol?5must?5be?5?$DM?$DN?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@HLBJPKP@pickle?5protocol?5must?5be?5?$DM?$DN?5?$CFd?$AA@ DB 'pi'
	DB	'ckle protocol must be <= %d', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Pickler_SetProtocol
_TEXT	SEGMENT
fix_imports$ = 32
proto$ = 36
tv82 = 40
tv86 = 44
self$ = 64
proto_obj$ = 72
fix_imports_obj$ = 80
_Pickler_SetProtocol PROC				; COMDAT

; 797  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 798  :     long proto = 0;

  00013	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR proto$[rsp], 0

; 799  :     int fix_imports;
; 800  : 
; 801  :     if (proto_obj == NULL || proto_obj == Py_None)

  0001b	48 83 7c 24 48
	00		 cmp	 QWORD PTR proto_obj$[rsp], 0
  00021	74 0e		 je	 SHORT $LN6@Pickler_Se
  00023	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0002a	48 39 44 24 48	 cmp	 QWORD PTR proto_obj$[rsp], rax
  0002f	75 0a		 jne	 SHORT $LN7@Pickler_Se
$LN6@Pickler_Se:

; 802  :         proto = DEFAULT_PROTOCOL;

  00031	c7 44 24 24 03
	00 00 00	 mov	 DWORD PTR proto$[rsp], 3

; 803  :     else {

  00039	eb 29		 jmp	 SHORT $LN5@Pickler_Se
$LN7@Pickler_Se:

; 804  :         proto = PyLong_AsLong(proto_obj);

  0003b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR proto_obj$[rsp]
  00040	e8 00 00 00 00	 call	 PyLong_AsLong
  00045	89 44 24 24	 mov	 DWORD PTR proto$[rsp], eax

; 805  :         if (proto == -1 && PyErr_Occurred())

  00049	83 7c 24 24 ff	 cmp	 DWORD PTR proto$[rsp], -1
  0004e	75 14		 jne	 SHORT $LN4@Pickler_Se
  00050	e8 00 00 00 00	 call	 PyErr_Occurred
  00055	48 85 c0	 test	 rax, rax
  00058	74 0a		 je	 SHORT $LN4@Pickler_Se

; 806  :             return -1;

  0005a	b8 ff ff ff ff	 mov	 eax, -1
  0005f	e9 bd 00 00 00	 jmp	 $LN8@Pickler_Se
$LN4@Pickler_Se:
$LN5@Pickler_Se:

; 807  :     }
; 808  :     if (proto < 0)

  00064	83 7c 24 24 00	 cmp	 DWORD PTR proto$[rsp], 0
  00069	7d 08		 jge	 SHORT $LN3@Pickler_Se

; 809  :         proto = HIGHEST_PROTOCOL;

  0006b	c7 44 24 24 03
	00 00 00	 mov	 DWORD PTR proto$[rsp], 3
$LN3@Pickler_Se:

; 810  :     if (proto > HIGHEST_PROTOCOL) {

  00073	83 7c 24 24 03	 cmp	 DWORD PTR proto$[rsp], 3
  00078	7e 23		 jle	 SHORT $LN2@Pickler_Se

; 811  :         PyErr_Format(PyExc_ValueError, "pickle protocol must be <= %d",
; 812  :                      HIGHEST_PROTOCOL);

  0007a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@HLBJPKP@pickle?5protocol?5must?5be?5?$DM?$DN?5?$CFd?$AA@
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0008e	e8 00 00 00 00	 call	 PyErr_Format

; 813  :         return -1;

  00093	b8 ff ff ff ff	 mov	 eax, -1
  00098	e9 84 00 00 00	 jmp	 $LN8@Pickler_Se
$LN2@Pickler_Se:

; 814  :     }
; 815  :     fix_imports = PyObject_IsTrue(fix_imports_obj);

  0009d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fix_imports_obj$[rsp]
  000a2	e8 00 00 00 00	 call	 PyObject_IsTrue
  000a7	89 44 24 20	 mov	 DWORD PTR fix_imports$[rsp], eax

; 816  :     if (fix_imports == -1)

  000ab	83 7c 24 20 ff	 cmp	 DWORD PTR fix_imports$[rsp], -1
  000b0	75 07		 jne	 SHORT $LN1@Pickler_Se

; 817  :         return -1;

  000b2	b8 ff ff ff ff	 mov	 eax, -1
  000b7	eb 68		 jmp	 SHORT $LN8@Pickler_Se
$LN1@Pickler_Se:

; 818  : 
; 819  :     self->proto = proto;

  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000be	8b 4c 24 24	 mov	 ecx, DWORD PTR proto$[rsp]
  000c2	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 820  :     self->bin = proto > 0;

  000c8	83 7c 24 24 00	 cmp	 DWORD PTR proto$[rsp], 0
  000cd	7e 0a		 jle	 SHORT $LN10@Pickler_Se
  000cf	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  000d7	eb 08		 jmp	 SHORT $LN11@Pickler_Se
$LN10@Pickler_Se:
  000d9	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN11@Pickler_Se:
  000e1	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000e6	8b 4c 24 28	 mov	 ecx, DWORD PTR tv82[rsp]
  000ea	89 88 a4 00 00
	00		 mov	 DWORD PTR [rax+164], ecx

; 821  :     self->fix_imports = fix_imports && proto < 3;

  000f0	83 7c 24 20 00	 cmp	 DWORD PTR fix_imports$[rsp], 0
  000f5	74 11		 je	 SHORT $LN12@Pickler_Se
  000f7	83 7c 24 24 03	 cmp	 DWORD PTR proto$[rsp], 3
  000fc	7d 0a		 jge	 SHORT $LN12@Pickler_Se
  000fe	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  00106	eb 08		 jmp	 SHORT $LN13@Pickler_Se
$LN12@Pickler_Se:
  00108	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN13@Pickler_Se:
  00110	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00115	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv86[rsp]
  00119	89 88 b8 00 00
	00		 mov	 DWORD PTR [rax+184], ecx

; 822  : 
; 823  :     return 0;

  0011f	33 c0		 xor	 eax, eax
$LN8@Pickler_Se:

; 824  : }

  00121	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00125	c3		 ret	 0
_Pickler_SetProtocol ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@JBEHNELP@file?5must?5have?5a?5?8write?8?5attribu@ ; `string'
PUBLIC	??_C@_1BK@NILMGIFG@?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_SetOutputStream DD imagerel _Pickler_SetOutputStream
	DD	imagerel _Pickler_SetOutputStream+165
	DD	imagerel $unwind$_Pickler_SetOutputStream
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_SetOutputStream DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0CD@JBEHNELP@file?5must?5have?5a?5?8write?8?5attribu@
CONST	SEGMENT
??_C@_0CD@JBEHNELP@file?5must?5have?5a?5?8write?8?5attribu@ DB 'file must'
	DB	' have a ''write'' attribute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NILMGIFG@?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NILMGIFG@?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'f'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Pickler_SetOutputStream
_TEXT	SEGMENT
self$ = 48
file$ = 56
_Pickler_SetOutputStream PROC				; COMDAT

; 830  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 831  :     _Py_IDENTIFIER(write);
; 832  :     assert(file != NULL);

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR file$[rsp], 0
  00014	75 1c		 jne	 SHORT $LN5@Pickler_Se@2
  00016	41 b8 40 03 00
	00		 mov	 r8d, 832		; 00000340H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@NILMGIFG@?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN5@Pickler_Se@2:

; 833  :     self->write = _PyObject_GetAttrId(file, &PyId_write);

  00032	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_write@?1??_Pickler_SetOutputStream@@9@9
  00037	8b c0		 mov	 eax, eax
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00048	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00054	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00059	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0005e	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 834  :     if (self->write == NULL) {

  00065	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0006a	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00072	75 2a		 jne	 SHORT $LN2@Pickler_Se@2

; 835  :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00074	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0007b	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00080	85 c0		 test	 eax, eax
  00082	74 13		 je	 SHORT $LN1@Pickler_Se@2

; 836  :             PyErr_SetString(PyExc_TypeError,
; 837  :                             "file must have a 'write' attribute");

  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@JBEHNELP@file?5must?5have?5a?5?8write?8?5attribu@
  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00092	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@Pickler_Se@2:

; 838  :         return -1;

  00097	b8 ff ff ff ff	 mov	 eax, -1
  0009c	eb 02		 jmp	 SHORT $LN3@Pickler_Se@2
$LN2@Pickler_Se@2:

; 839  :     }
; 840  : 
; 841  :     return 0;

  0009e	33 c0		 xor	 eax, eax
$LN3@Pickler_Se@2:

; 842  : }

  000a0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a4	c3		 ret	 0
_Pickler_SetOutputStream ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pmp_clear DD imagerel pmp_clear
	DD	imagerel pmp_clear+67
	DD	imagerel $unwind$pmp_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pmp_clear DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pmp_clear
_TEXT	SEGMENT
self$ = 48
pmp_clear PROC						; COMDAT

; 3576 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3577 :     if (self->pickler->memo)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00017	74 12		 je	 SHORT $LN1@pmp_clear

; 3578 :         PyMemoTable_Clear(self->pickler->memo);

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00022	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00026	e8 00 00 00 00	 call	 PyMemoTable_Clear
$LN1@pmp_clear:

; 3579 :     Py_RETURN_NONE;

  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00032	e8 00 00 00 00	 call	 _Py_IncRef
  00037	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3580 : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
pmp_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DFBGJDAN@nO?$AA@			; `string'
PUBLIC	$T26671
;	COMDAT pdata
pdata	SEGMENT
$pdata$pmp_copy DD imagerel pmp_copy
	DD	imagerel pmp_copy+379
	DD	imagerel $unwind$pmp_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pmp_copy DD 030b01H
	DD	07007e20bH
	DD	06006H
xdata	ENDS
;	COMDAT ??_C@_02DFBGJDAN@nO?$AA@
CONST	SEGMENT
??_C@_02DFBGJDAN@nO?$AA@ DB 'nO', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT pmp_copy
_TEXT	SEGMENT
i$ = 32
new_memo$ = 40
memo$ = 48
entry$23014 = 56
value$23019 = 72
key$23018 = 80
status$23017 = 88
$T26671 = 96
self$ = 144
pmp_copy PROC						; COMDAT

; 3587 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3588 :     Py_ssize_t i;
; 3589 :     PyMemoTable *memo;
; 3590 :     PyObject *new_memo = PyDict_New();

  0000b	e8 00 00 00 00	 call	 PyDict_New
  00010	48 89 44 24 28	 mov	 QWORD PTR new_memo$[rsp], rax

; 3591 :     if (new_memo == NULL)

  00015	48 83 7c 24 28
	00		 cmp	 QWORD PTR new_memo$[rsp], 0
  0001b	75 07		 jne	 SHORT $LN20@pmp_copy

; 3592 :         return NULL;

  0001d	33 c0		 xor	 eax, eax
  0001f	e9 50 01 00 00	 jmp	 $LN21@pmp_copy
$LN20@pmp_copy:

; 3593 : 
; 3594 :     memo = self->pickler->memo;

  00024	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0002c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00030	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00034	48 89 44 24 30	 mov	 QWORD PTR memo$[rsp], rax

; 3595 :     for (i = 0; i < memo->mt_allocated; ++i) {

  00039	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00042	eb 0d		 jmp	 SHORT $LN19@pmp_copy
$LN18@pmp_copy:
  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00049	48 ff c0	 inc	 rax
  0004c	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN19@pmp_copy:
  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR memo$[rsp]
  00056	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005a	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0005f	0f 8d ee 00 00
	00		 jge	 $LN17@pmp_copy

; 3596 :         PyMemoEntry entry = memo->mt_table[i];

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0006a	48 6b c0 10	 imul	 rax, 16
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR memo$[rsp]
  00073	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00077	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T26671[rsp]
  0007c	48 8b fa	 mov	 rdi, rdx
  0007f	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00083	b9 10 00 00 00	 mov	 ecx, 16
  00088	f3 a4		 rep movsb
  0008a	48 8d 44 24 38	 lea	 rax, QWORD PTR entry$23014[rsp]
  0008f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T26671[rsp]
  00094	48 8b f8	 mov	 rdi, rax
  00097	48 8b f1	 mov	 rsi, rcx
  0009a	b9 10 00 00 00	 mov	 ecx, 16
  0009f	f3 a4		 rep movsb

; 3597 :         if (entry.me_key != NULL) {

  000a1	48 83 7c 24 38
	00		 cmp	 QWORD PTR entry$23014[rsp], 0
  000a7	0f 84 a1 00 00
	00		 je	 $LN16@pmp_copy

; 3598 :             int status;
; 3599 :             PyObject *key, *value;
; 3600 : 
; 3601 :             key = PyLong_FromVoidPtr(entry.me_key);

  000ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR entry$23014[rsp]
  000b2	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  000b7	48 89 44 24 50	 mov	 QWORD PTR key$23018[rsp], rax

; 3602 :             value = Py_BuildValue("nO", entry.me_value, entry.me_key);

  000bc	4c 8b 44 24 38	 mov	 r8, QWORD PTR entry$23014[rsp]
  000c1	48 8b 54 24 40	 mov	 rdx, QWORD PTR entry$23014[rsp+8]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DFBGJDAN@nO?$AA@
  000cd	e8 00 00 00 00	 call	 Py_BuildValue
  000d2	48 89 44 24 48	 mov	 QWORD PTR value$23019[rsp], rax

; 3603 : 
; 3604 :             if (key == NULL || value == NULL) {

  000d7	48 83 7c 24 50
	00		 cmp	 QWORD PTR key$23018[rsp], 0
  000dd	74 08		 je	 SHORT $LN14@pmp_copy
  000df	48 83 7c 24 48
	00		 cmp	 QWORD PTR value$23019[rsp], 0
  000e5	75 32		 jne	 SHORT $LN15@pmp_copy
$LN14@pmp_copy:
$LN13@pmp_copy:

; 3605 :                 Py_XDECREF(key);

  000e7	48 83 7c 24 50
	00		 cmp	 QWORD PTR key$23018[rsp], 0
  000ed	74 0a		 je	 SHORT $LN10@pmp_copy
  000ef	48 8b 4c 24 50	 mov	 rcx, QWORD PTR key$23018[rsp]
  000f4	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@pmp_copy:
  000f9	33 c0		 xor	 eax, eax
  000fb	85 c0		 test	 eax, eax
  000fd	75 e8		 jne	 SHORT $LN13@pmp_copy
$LN9@pmp_copy:

; 3606 :                 Py_XDECREF(value);

  000ff	48 83 7c 24 48
	00		 cmp	 QWORD PTR value$23019[rsp], 0
  00105	74 0a		 je	 SHORT $LN6@pmp_copy
  00107	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$23019[rsp]
  0010c	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@pmp_copy:
  00111	33 c0		 xor	 eax, eax
  00113	85 c0		 test	 eax, eax
  00115	75 e8		 jne	 SHORT $LN9@pmp_copy

; 3607 :                 goto error;

  00117	eb 41		 jmp	 SHORT $error$23035
$LN15@pmp_copy:

; 3608 :             }
; 3609 :             status = PyDict_SetItem(new_memo, key, value);

  00119	4c 8b 44 24 48	 mov	 r8, QWORD PTR value$23019[rsp]
  0011e	48 8b 54 24 50	 mov	 rdx, QWORD PTR key$23018[rsp]
  00123	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_memo$[rsp]
  00128	e8 00 00 00 00	 call	 PyDict_SetItem
  0012d	89 44 24 58	 mov	 DWORD PTR status$23017[rsp], eax

; 3610 :             Py_DECREF(key);

  00131	48 8b 4c 24 50	 mov	 rcx, QWORD PTR key$23018[rsp]
  00136	e8 00 00 00 00	 call	 _Py_DecRef

; 3611 :             Py_DECREF(value);

  0013b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$23019[rsp]
  00140	e8 00 00 00 00	 call	 _Py_DecRef

; 3612 :             if (status < 0)

  00145	83 7c 24 58 00	 cmp	 DWORD PTR status$23017[rsp], 0
  0014a	7d 02		 jge	 SHORT $LN5@pmp_copy

; 3613 :                 goto error;

  0014c	eb 0c		 jmp	 SHORT $error$23035
$LN5@pmp_copy:
$LN16@pmp_copy:

; 3614 :         }
; 3615 :     }

  0014e	e9 f1 fe ff ff	 jmp	 $LN18@pmp_copy
$LN17@pmp_copy:

; 3616 :     return new_memo;

  00153	48 8b 44 24 28	 mov	 rax, QWORD PTR new_memo$[rsp]
  00158	eb 1a		 jmp	 SHORT $LN21@pmp_copy
$error$23035:
$LN4@pmp_copy:

; 3617 : 
; 3618 :   error:
; 3619 :     Py_XDECREF(new_memo);

  0015a	48 83 7c 24 28
	00		 cmp	 QWORD PTR new_memo$[rsp], 0
  00160	74 0a		 je	 SHORT $LN1@pmp_copy
  00162	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_memo$[rsp]
  00167	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@pmp_copy:
  0016c	33 c0		 xor	 eax, eax
  0016e	85 c0		 test	 eax, eax
  00170	75 e8		 jne	 SHORT $LN4@pmp_copy

; 3620 :     return NULL;

  00172	33 c0		 xor	 eax, eax
$LN21@pmp_copy:

; 3621 : }

  00174	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00178	5f		 pop	 rdi
  00179	5e		 pop	 rsi
  0017a	c3		 ret	 0
pmp_copy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pmp_reduce DD imagerel pmp_reduce
	DD	imagerel pmp_reduce+194
	DD	imagerel $unwind$pmp_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pmp_reduce DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pmp_reduce
_TEXT	SEGMENT
reduce_value$ = 32
dict_args$ = 40
contents$ = 48
self$ = 80
args$ = 88
pmp_reduce PROC						; COMDAT

; 3628 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3629 :     PyObject *reduce_value, *dict_args;
; 3630 :     PyObject *contents = pmp_copy(self);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 pmp_copy
  00018	48 89 44 24 30	 mov	 QWORD PTR contents$[rsp], rax

; 3631 :     if (contents == NULL)

  0001d	48 83 7c 24 30
	00		 cmp	 QWORD PTR contents$[rsp], 0
  00023	75 07		 jne	 SHORT $LN3@pmp_reduce

; 3632 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	e9 91 00 00 00	 jmp	 $LN4@pmp_reduce
$LN3@pmp_reduce:

; 3633 : 
; 3634 :     reduce_value = PyTuple_New(2);

  0002c	b9 02 00 00 00	 mov	 ecx, 2
  00031	e8 00 00 00 00	 call	 PyTuple_New
  00036	48 89 44 24 20	 mov	 QWORD PTR reduce_value$[rsp], rax

; 3635 :     if (reduce_value == NULL) {

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR reduce_value$[rsp], 0
  00041	75 0e		 jne	 SHORT $LN2@pmp_reduce

; 3636 :         Py_DECREF(contents);

  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR contents$[rsp]
  00048	e8 00 00 00 00	 call	 _Py_DecRef

; 3637 :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 6c		 jmp	 SHORT $LN4@pmp_reduce
$LN2@pmp_reduce:

; 3638 :     }
; 3639 :     dict_args = PyTuple_New(1);

  00051	b9 01 00 00 00	 mov	 ecx, 1
  00056	e8 00 00 00 00	 call	 PyTuple_New
  0005b	48 89 44 24 28	 mov	 QWORD PTR dict_args$[rsp], rax

; 3640 :     if (dict_args == NULL) {

  00060	48 83 7c 24 28
	00		 cmp	 QWORD PTR dict_args$[rsp], 0
  00066	75 18		 jne	 SHORT $LN1@pmp_reduce

; 3641 :         Py_DECREF(contents);

  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR contents$[rsp]
  0006d	e8 00 00 00 00	 call	 _Py_DecRef

; 3642 :         Py_DECREF(reduce_value);

  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR reduce_value$[rsp]
  00077	e8 00 00 00 00	 call	 _Py_DecRef

; 3643 :         return NULL;

  0007c	33 c0		 xor	 eax, eax
  0007e	eb 3d		 jmp	 SHORT $LN4@pmp_reduce
$LN1@pmp_reduce:

; 3644 :     }
; 3645 :     PyTuple_SET_ITEM(dict_args, 0, contents);

  00080	48 8b 44 24 28	 mov	 rax, QWORD PTR dict_args$[rsp]
  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR contents$[rsp]
  0008a	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 3646 :     Py_INCREF((PyObject *)&PyDict_Type);

  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDict_Type
  00095	e8 00 00 00 00	 call	 _Py_IncRef

; 3647 :     PyTuple_SET_ITEM(reduce_value, 0, (PyObject *)&PyDict_Type);

  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR reduce_value$[rsp]
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDict_Type
  000a6	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 3648 :     PyTuple_SET_ITEM(reduce_value, 1, dict_args);

  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR reduce_value$[rsp]
  000af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dict_args$[rsp]
  000b4	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 3649 :     return reduce_value;

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR reduce_value$[rsp]
$LN4@pmp_reduce:

; 3650 : }

  000bd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c1	c3		 ret	 0
pmp_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PicklerMemoProxy_dealloc DD imagerel PicklerMemoProxy_dealloc
	DD	imagerel PicklerMemoProxy_dealloc+66
	DD	imagerel $unwind$PicklerMemoProxy_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PicklerMemoProxy_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PicklerMemoProxy_dealloc
_TEXT	SEGMENT
self$ = 48
PicklerMemoProxy_dealloc PROC				; COMDAT

; 3661 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3662 :     PyObject_GC_UnTrack(self);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN4@PicklerMem:

; 3663 :     Py_XDECREF(self->pickler);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN1@PicklerMem
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PicklerMem:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN4@PicklerMem

; 3664 :     PyObject_GC_Del((PyObject *)self);

  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00038	e8 00 00 00 00	 call	 PyObject_GC_Del

; 3665 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
PicklerMemoProxy_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@IANMMKJD@PicklerMemoProxy_traverse?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PicklerMemoProxy_traverse DD imagerel PicklerMemoProxy_traverse
	DD	imagerel PicklerMemoProxy_traverse+116
	DD	imagerel $unwind$PicklerMemoProxy_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PicklerMemoProxy_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BK@IANMMKJD@PicklerMemoProxy_traverse?$AA@
CONST	SEGMENT
??_C@_0BK@IANMMKJD@PicklerMemoProxy_traverse?$AA@ DB 'PicklerMemoProxy_tr'
	DB	'averse', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PicklerMemoProxy_traverse
_TEXT	SEGMENT
vret$23105 = 32
self$ = 64
visit$ = 72
arg$ = 80
PicklerMemoProxy_traverse PROC				; COMDAT

; 3670 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@PicklerMem@2:

; 3671 :     Py_VISIT(self->pickler);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@PicklerMem@2
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 57 0e 00
	00		 mov	 r8d, 3671		; 00000e57H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@IANMMKJD@PicklerMemoProxy_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@PicklerMem@2:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN2@PicklerMem@2
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$23105[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$23105[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@PicklerMem@2
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$23105[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@PicklerMem@2
$LN1@PicklerMem@2:
$LN2@PicklerMem@2:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@PicklerMem@2

; 3672 :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@PicklerMem@2:

; 3673 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
PicklerMemoProxy_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@BKPDCCH@PicklerMemoProxy_clear?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PicklerMemoProxy_clear DD imagerel PicklerMemoProxy_clear
	DD	imagerel PicklerMemoProxy_clear+117
	DD	imagerel $unwind$PicklerMemoProxy_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PicklerMemoProxy_clear DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BH@BKPDCCH@PicklerMemoProxy_clear?$AA@
CONST	SEGMENT
??_C@_0BH@BKPDCCH@PicklerMemoProxy_clear?$AA@ DB 'PicklerMemoProxy_clear', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PicklerMemoProxy_clear
_TEXT	SEGMENT
_py_tmp$23117 = 48
self$ = 80
PicklerMemoProxy_clear PROC				; COMDAT

; 3677 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@PicklerMem@3:

; 3678 :     Py_CLEAR(self->pickler);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 53		 je	 SHORT $LN1@PicklerMem@3
  00015	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00022	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  00026	41 b8 5e 0e 00
	00		 mov	 r8d, 3678		; 00000e5eH
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@BKPDCCH@PicklerMemoProxy_clear?$AA@
  0003a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003f	85 c0		 test	 eax, eax
  00041	75 25		 jne	 SHORT $LN1@PicklerMem@3
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00048	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004c	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$23117[rsp], rax
  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00056	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$23117[rsp]
  00063	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PicklerMem@3:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 9b		 jne	 SHORT $LN4@PicklerMem@3

; 3679 :     return 0;

  0006e	33 c0		 xor	 eax, eax

; 3680 : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
PicklerMemoProxy_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_get_memo DD imagerel Pickler_get_memo
	DD	imagerel Pickler_get_memo+24
	DD	imagerel $unwind$Pickler_get_memo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_get_memo DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Pickler_get_memo
_TEXT	SEGMENT
self$ = 48
Pickler_get_memo PROC					; COMDAT

; 3731 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3732 :     return PicklerMemoProxy_New(self);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 PicklerMemoProxy_New

; 3733 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
Pickler_get_memo ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Track:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PicklerMemoProxy_New DD imagerel PicklerMemoProxy_New
	DD	imagerel PicklerMemoProxy_New+120
	DD	imagerel $unwind$PicklerMemoProxy_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PicklerMemoProxy_New DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PicklerMemoProxy_New
_TEXT	SEGMENT
self$ = 32
tv70 = 40
pickler$ = 64
PicklerMemoProxy_New PROC				; COMDAT

; 3715 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3716 :     PicklerMemoProxyObject *self;
; 3717 : 
; 3718 :     self = PyObject_GC_New(PicklerMemoProxyObject, &PicklerMemoProxyType);

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 13		 je	 SHORT $LN4@PicklerMem@4
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PicklerMemoProxyType
  00019	e8 00 00 00 00	 call	 _PxObject_New
  0001e	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00023	eb 11		 jmp	 SHORT $LN5@PicklerMem@4
$LN4@PicklerMem@4:
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PicklerMemoProxyType
  0002c	e8 00 00 00 00	 call	 _PyObject_GC_New
  00031	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN5@PicklerMem@4:
  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  0003b	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 3719 :     if (self == NULL)

  00040	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00046	75 04		 jne	 SHORT $LN1@PicklerMem@4

; 3720 :         return NULL;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 27		 jmp	 SHORT $LN2@PicklerMem@4
$LN1@PicklerMem@4:

; 3721 :     Py_INCREF(pickler);

  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pickler$[rsp]
  00051	e8 00 00 00 00	 call	 _Py_IncRef

; 3722 :     self->pickler = pickler;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pickler$[rsp]
  00060	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3723 :     PyObject_GC_Track(self);

  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00069	e8 00 00 00 00	 call	 PyObject_GC_Track

; 3724 :     return (PyObject *)self;

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
$LN2@PicklerMem@4:

; 3725 : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
PicklerMemoProxy_New ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@DMODCLIB@?8memo?8?5attribute?5must?5be?5an?5Pick@ ; `string'
PUBLIC	??_C@_0CE@JMGPAAF@?8memo?8?5values?5must?5be?52?9item?5tup@ ; `string'
PUBLIC	??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@ ; `string'
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_set_memo DD imagerel Pickler_set_memo
	DD	imagerel Pickler_set_memo+477
	DD	imagerel $unwind$Pickler_set_memo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_set_memo DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0EH@DMODCLIB@?8memo?8?5attribute?5must?5be?5an?5Pick@
CONST	SEGMENT
??_C@_0EH@DMODCLIB@?8memo?8?5attribute?5must?5be?5an?5Pick@ DB '''memo'' '
	DB	'attribute must be an PicklerMemoProxy objector dict, not %.20'
	DB	'0s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JMGPAAF@?8memo?8?5values?5must?5be?52?9item?5tup@
CONST	SEGMENT
??_C@_0CE@JMGPAAF@?8memo?8?5values?5must?5be?52?9item?5tup@ DB '''memo'' '
	DB	'values must be 2-item tuples', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@
CONST	SEGMENT
??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@ DB 'attribute de'
	DB	'letion is not supported', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Pickler_set_memo
_TEXT	SEGMENT
new_memo$ = 32
pickler$23169 = 40
value$23178 = 48
i$23176 = 56
key$23177 = 64
memo_id$23184 = 72
memo_obj$23185 = 80
self$ = 112
obj$ = 120
Pickler_set_memo PROC					; COMDAT

; 3737 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3738 :     PyMemoTable *new_memo = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR new_memo$[rsp], 0

; 3739 : 
; 3740 :     if (obj == NULL) {

  00017	48 83 7c 24 78
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0001d	75 1d		 jne	 SHORT $LN14@Pickler_se

; 3741 :         PyErr_SetString(PyExc_TypeError,
; 3742 :                         "attribute deletion is not supported");

  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@
  00026	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0002d	e8 00 00 00 00	 call	 PyErr_SetString

; 3743 :         return -1;

  00032	b8 ff ff ff ff	 mov	 eax, -1
  00037	e9 9c 01 00 00	 jmp	 $LN15@Pickler_se
$LN14@Pickler_se:

; 3744 :     }
; 3745 : 
; 3746 :     if (Py_TYPE(obj) == &PicklerMemoProxyType) {

  0003c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PicklerMemoProxyType
  00043	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$[rsp]
  00048	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0004c	75 38		 jne	 SHORT $LN13@Pickler_se

; 3747 :         PicklerObject *pickler =
; 3748 :             ((PicklerMemoProxyObject *)obj)->pickler;

  0004e	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  00053	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00057	48 89 44 24 28	 mov	 QWORD PTR pickler$23169[rsp], rax

; 3749 : 
; 3750 :         new_memo = PyMemoTable_Copy(pickler->memo);

  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR pickler$23169[rsp]
  00061	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00065	e8 00 00 00 00	 call	 PyMemoTable_Copy
  0006a	48 89 44 24 20	 mov	 QWORD PTR new_memo$[rsp], rax

; 3751 :         if (new_memo == NULL)

  0006f	48 83 7c 24 20
	00		 cmp	 QWORD PTR new_memo$[rsp], 0
  00075	75 0a		 jne	 SHORT $LN12@Pickler_se

; 3752 :             return -1;

  00077	b8 ff ff ff ff	 mov	 eax, -1
  0007c	e9 57 01 00 00	 jmp	 $LN15@Pickler_se
$LN12@Pickler_se:

; 3753 :     }
; 3754 :     else if (PyDict_Check(obj)) {

  00081	e9 1b 01 00 00	 jmp	 $LN11@Pickler_se
$LN13@Pickler_se:
  00086	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  0008b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00095	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0009a	85 c0		 test	 eax, eax
  0009c	0f 84 d8 00 00
	00		 je	 $LN10@Pickler_se

; 3755 :         Py_ssize_t i = 0;

  000a2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$23176[rsp], 0

; 3756 :         PyObject *key, *value;
; 3757 : 
; 3758 :         new_memo = PyMemoTable_New();

  000ab	e8 00 00 00 00	 call	 PyMemoTable_New
  000b0	48 89 44 24 20	 mov	 QWORD PTR new_memo$[rsp], rax

; 3759 :         if (new_memo == NULL)

  000b5	48 83 7c 24 20
	00		 cmp	 QWORD PTR new_memo$[rsp], 0
  000bb	75 0a		 jne	 SHORT $LN9@Pickler_se

; 3760 :             return -1;

  000bd	b8 ff ff ff ff	 mov	 eax, -1
  000c2	e9 11 01 00 00	 jmp	 $LN15@Pickler_se
$LN9@Pickler_se:
$LN8@Pickler_se:

; 3761 : 
; 3762 :         while (PyDict_Next(obj, &i, &key, &value)) {

  000c7	4c 8d 4c 24 30	 lea	 r9, QWORD PTR value$23178[rsp]
  000cc	4c 8d 44 24 40	 lea	 r8, QWORD PTR key$23177[rsp]
  000d1	48 8d 54 24 38	 lea	 rdx, QWORD PTR i$23176[rsp]
  000d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$[rsp]
  000db	e8 00 00 00 00	 call	 PyDict_Next
  000e0	85 c0		 test	 eax, eax
  000e2	0f 84 90 00 00
	00		 je	 $LN7@Pickler_se

; 3763 :             Py_ssize_t memo_id;
; 3764 :             PyObject *memo_obj;
; 3765 : 
; 3766 :             if (!PyTuple_Check(value) || Py_SIZE(value) != 2) {

  000e8	48 8b 44 24 30	 mov	 rax, QWORD PTR value$23178[rsp]
  000ed	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f7	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  000fc	85 c0		 test	 eax, eax
  000fe	74 0c		 je	 SHORT $LN5@Pickler_se
  00100	48 8b 44 24 30	 mov	 rax, QWORD PTR value$23178[rsp]
  00105	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  0010a	74 18		 je	 SHORT $LN6@Pickler_se
$LN5@Pickler_se:

; 3767 :                 PyErr_SetString(PyExc_TypeError,
; 3768 :                                 "'memo' values must be 2-item tuples");

  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@JMGPAAF@?8memo?8?5values?5must?5be?52?9item?5tup@
  00113	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0011a	e8 00 00 00 00	 call	 PyErr_SetString

; 3769 :                 goto error;

  0011f	e9 9d 00 00 00	 jmp	 $error$23191
$LN6@Pickler_se:

; 3770 :             }
; 3771 :             memo_id = PyLong_AsSsize_t(PyTuple_GET_ITEM(value, 0));

  00124	48 8b 44 24 30	 mov	 rax, QWORD PTR value$23178[rsp]
  00129	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0012d	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00132	48 89 44 24 48	 mov	 QWORD PTR memo_id$23184[rsp], rax

; 3772 :             if (memo_id == -1 && PyErr_Occurred())

  00137	48 83 7c 24 48
	ff		 cmp	 QWORD PTR memo_id$23184[rsp], -1
  0013d	75 0c		 jne	 SHORT $LN4@Pickler_se
  0013f	e8 00 00 00 00	 call	 PyErr_Occurred
  00144	48 85 c0	 test	 rax, rax
  00147	74 02		 je	 SHORT $LN4@Pickler_se

; 3773 :                 goto error;

  00149	eb 76		 jmp	 SHORT $error$23191
$LN4@Pickler_se:

; 3774 :             memo_obj = PyTuple_GET_ITEM(value, 1);

  0014b	48 8b 44 24 30	 mov	 rax, QWORD PTR value$23178[rsp]
  00150	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00154	48 89 44 24 50	 mov	 QWORD PTR memo_obj$23185[rsp], rax

; 3775 :             if (PyMemoTable_Set(new_memo, memo_obj, memo_id) < 0)

  00159	4c 8b 44 24 48	 mov	 r8, QWORD PTR memo_id$23184[rsp]
  0015e	48 8b 54 24 50	 mov	 rdx, QWORD PTR memo_obj$23185[rsp]
  00163	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_memo$[rsp]
  00168	e8 00 00 00 00	 call	 PyMemoTable_Set
  0016d	85 c0		 test	 eax, eax
  0016f	7d 02		 jge	 SHORT $LN3@Pickler_se

; 3776 :                 goto error;

  00171	eb 4e		 jmp	 SHORT $error$23191
$LN3@Pickler_se:

; 3777 :         }

  00173	e9 4f ff ff ff	 jmp	 $LN8@Pickler_se
$LN7@Pickler_se:

; 3778 :     }
; 3779 :     else {

  00178	eb 27		 jmp	 SHORT $LN2@Pickler_se
$LN10@Pickler_se:

; 3780 :         PyErr_Format(PyExc_TypeError,
; 3781 :                      "'memo' attribute must be an PicklerMemoProxy object"
; 3782 :                      "or dict, not %.200s", Py_TYPE(obj)->tp_name);

  0017a	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$[rsp]
  0017f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00183	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EH@DMODCLIB@?8memo?8?5attribute?5must?5be?5an?5Pick@
  0018e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00195	e8 00 00 00 00	 call	 PyErr_Format

; 3783 :         return -1;

  0019a	b8 ff ff ff ff	 mov	 eax, -1
  0019f	eb 37		 jmp	 SHORT $LN15@Pickler_se
$LN2@Pickler_se:
$LN11@Pickler_se:

; 3784 :     }
; 3785 : 
; 3786 :     PyMemoTable_Del(self->memo);

  001a1	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001a6	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  001aa	e8 00 00 00 00	 call	 PyMemoTable_Del

; 3787 :     self->memo = new_memo;

  001af	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_memo$[rsp]
  001b9	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3788 : 
; 3789 :     return 0;

  001bd	33 c0		 xor	 eax, eax
  001bf	eb 17		 jmp	 SHORT $LN15@Pickler_se
$error$23191:

; 3790 : 
; 3791 :   error:
; 3792 :     if (new_memo)

  001c1	48 83 7c 24 20
	00		 cmp	 QWORD PTR new_memo$[rsp], 0
  001c7	74 0a		 je	 SHORT $LN1@Pickler_se

; 3793 :         PyMemoTable_Del(new_memo);

  001c9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_memo$[rsp]
  001ce	e8 00 00 00 00	 call	 PyMemoTable_Del
$LN1@Pickler_se:

; 3794 :     return -1;

  001d3	b8 ff ff ff ff	 mov	 eax, -1
$LN15@Pickler_se:

; 3795 : }

  001d8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001dc	c3		 ret	 0
Pickler_set_memo ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoTable_Copy DD imagerel PyMemoTable_Copy
	DD	imagerel PyMemoTable_Copy+433
	DD	imagerel $unwind$PyMemoTable_Copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_Copy DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMemoTable_Copy
_TEXT	SEGMENT
i$ = 32
new$ = 40
tv76 = 48
tv88 = 56
tv95 = 64
self$ = 96
PyMemoTable_Copy PROC					; COMDAT

; 424  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 425  :     Py_ssize_t i;
; 426  :     PyMemoTable *new = PyMemoTable_New();

  00009	e8 00 00 00 00	 call	 PyMemoTable_New
  0000e	48 89 44 24 28	 mov	 QWORD PTR new$[rsp], rax

; 427  :     if (new == NULL)

  00013	48 83 7c 24 28
	00		 cmp	 QWORD PTR new$[rsp], 0
  00019	75 07		 jne	 SHORT $LN9@PyMemoTabl@8

; 428  :         return NULL;

  0001b	33 c0		 xor	 eax, eax
  0001d	e9 8a 01 00 00	 jmp	 $LN10@PyMemoTabl@8
$LN9@PyMemoTabl@8:

; 429  : 
; 430  :     new->mt_used = self->mt_used;

  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0002c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00030	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 431  :     new->mt_allocated = self->mt_allocated;

  00034	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  00039	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0003e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00042	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 432  :     new->mt_mask = self->mt_mask;

  00046	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  0004b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00050	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00053	48 89 08	 mov	 QWORD PTR [rax], rcx

; 433  :     /* The table we get from _New() is probably smaller than we wanted.
; 434  :        Free it and allocate one that's the right size. */
; 435  :     PyMem_FREE(new->mt_table);

  00056	e8 00 00 00 00	 call	 _Py_PXCTX
  0005b	85 c0		 test	 eax, eax
  0005d	74 18		 je	 SHORT $LN12@PyMemoTabl@8
  0005f	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  00064	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00068	e8 00 00 00 00	 call	 _PxMem_Free
  0006d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
  00075	eb 16		 jmp	 SHORT $LN13@PyMemoTabl@8
$LN12@PyMemoTabl@8:
  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  0007c	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00080	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00085	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN13@PyMemoTabl@8:

; 436  :     new->mt_table = PyMem_MALLOC(self->mt_allocated * sizeof(PyMemoEntry));

  0008d	e8 00 00 00 00	 call	 _Py_PXCTX
  00092	85 c0		 test	 eax, eax
  00094	74 1c		 je	 SHORT $LN14@PyMemoTabl@8
  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0009b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009f	48 6b c0 10	 imul	 rax, 16
  000a3	48 8b c8	 mov	 rcx, rax
  000a6	e8 00 00 00 00	 call	 _PxMem_Malloc
  000ab	48 89 44 24 38	 mov	 QWORD PTR tv88[rsp], rax
  000b0	eb 1a		 jmp	 SHORT $LN15@PyMemoTabl@8
$LN14@PyMemoTabl@8:
  000b2	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000b7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000bb	48 6b c0 10	 imul	 rax, 16
  000bf	48 8b c8	 mov	 rcx, rax
  000c2	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  000c7	48 89 44 24 38	 mov	 QWORD PTR tv88[rsp], rax
$LN15@PyMemoTabl@8:
  000cc	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  000d1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv88[rsp]
  000d6	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 437  :     if (new->mt_table == NULL) {

  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  000df	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000e4	75 36		 jne	 SHORT $LN8@PyMemoTabl@8

; 438  :         PyMem_FREE(new);

  000e6	e8 00 00 00 00	 call	 _Py_PXCTX
  000eb	85 c0		 test	 eax, eax
  000ed	74 14		 je	 SHORT $LN16@PyMemoTabl@8
  000ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new$[rsp]
  000f4	e8 00 00 00 00	 call	 _PxMem_Free
  000f9	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
  00101	eb 12		 jmp	 SHORT $LN17@PyMemoTabl@8
$LN16@PyMemoTabl@8:
  00103	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new$[rsp]
  00108	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0010d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN17@PyMemoTabl@8:

; 439  :         return NULL;

  00115	33 c0		 xor	 eax, eax
  00117	e9 90 00 00 00	 jmp	 $LN10@PyMemoTabl@8
$LN8@PyMemoTabl@8:

; 440  :     }
; 441  :     for (i = 0; i < self->mt_allocated; i++) {

  0011c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00125	eb 0d		 jmp	 SHORT $LN7@PyMemoTabl@8
$LN6@PyMemoTabl@8:
  00127	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0012c	48 ff c0	 inc	 rax
  0012f	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN7@PyMemoTabl@8:
  00134	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00139	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0013d	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00142	7d 3c		 jge	 SHORT $LN5@PyMemoTabl@8
$LN4@PyMemoTabl@8:

; 442  :         Py_XINCREF(self->mt_table[i].me_key);

  00144	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00149	48 6b c0 10	 imul	 rax, 16
  0014d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00152	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00156	48 83 3c 08 00	 cmp	 QWORD PTR [rax+rcx], 0
  0015b	74 1b		 je	 SHORT $LN1@PyMemoTabl@8
  0015d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00162	48 6b c0 10	 imul	 rax, 16
  00166	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0016b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0016f	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00173	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@PyMemoTabl@8:
  00178	33 c0		 xor	 eax, eax
  0017a	85 c0		 test	 eax, eax
  0017c	75 c6		 jne	 SHORT $LN4@PyMemoTabl@8

; 443  :     }

  0017e	eb a7		 jmp	 SHORT $LN6@PyMemoTabl@8
$LN5@PyMemoTabl@8:

; 444  :     memcpy(new->mt_table, self->mt_table,
; 445  :            sizeof(PyMemoEntry) * self->mt_allocated);

  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00185	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00189	48 6b c0 10	 imul	 rax, 16
  0018d	4c 8b c0	 mov	 r8, rax
  00190	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00195	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00199	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  0019e	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001a2	e8 00 00 00 00	 call	 memcpy

; 446  : 
; 447  :     return new;

  001a7	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
$LN10@PyMemoTabl@8:

; 448  : }

  001ac	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b0	c3		 ret	 0
PyMemoTable_Copy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_get_persid DD imagerel Pickler_get_persid
	DD	imagerel Pickler_get_persid+70
	DD	imagerel $unwind$Pickler_get_persid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_get_persid DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Pickler_get_persid
_TEXT	SEGMENT
self$ = 48
Pickler_get_persid PROC					; COMDAT

; 3799 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3800 :     if (self->pers_func == NULL)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	75 15		 jne	 SHORT $LN2@Pickler_ge

; 3801 :         PyErr_SetString(PyExc_AttributeError, "persistent_id");

  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@IGFLDCPG@persistent_id?$AA@
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00023	e8 00 00 00 00	 call	 PyErr_SetString

; 3802 :     else

  00028	eb 0e		 jmp	 SHORT $LN1@Pickler_ge
$LN2@Pickler_ge:

; 3803 :         Py_INCREF(self->pers_func);

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0002f	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00033	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@Pickler_ge:

; 3804 :     return self->pers_func;

  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]

; 3805 : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
Pickler_get_persid ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@GNJKJGDK@persistent_id?5must?5be?5a?5callable@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_set_persid DD imagerel Pickler_set_persid
	DD	imagerel Pickler_set_persid+157
	DD	imagerel $unwind$Pickler_set_persid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_set_persid DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0DF@GNJKJGDK@persistent_id?5must?5be?5a?5callable@
CONST	SEGMENT
??_C@_0DF@GNJKJGDK@persistent_id?5must?5be?5a?5callable@ DB 'persistent_i'
	DB	'd must be a callable taking one argument', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Pickler_set_persid
_TEXT	SEGMENT
tmp$ = 32
self$ = 64
value$ = 72
Pickler_set_persid PROC					; COMDAT

; 3809 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3810 :     PyObject *tmp;
; 3811 : 
; 3812 :     if (value == NULL) {

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR value$[rsp], 0
  00014	75 1a		 jne	 SHORT $LN6@Pickler_se@2

; 3813 :         PyErr_SetString(PyExc_TypeError,
; 3814 :                         "attribute deletion is not supported");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@
  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00024	e8 00 00 00 00	 call	 PyErr_SetString

; 3815 :         return -1;

  00029	b8 ff ff ff ff	 mov	 eax, -1
  0002e	eb 68		 jmp	 SHORT $LN7@Pickler_se@2
$LN6@Pickler_se@2:

; 3816 :     }
; 3817 :     if (!PyCallable_Check(value)) {

  00030	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$[rsp]
  00035	e8 00 00 00 00	 call	 PyCallable_Check
  0003a	85 c0		 test	 eax, eax
  0003c	75 1a		 jne	 SHORT $LN5@Pickler_se@2

; 3818 :         PyErr_SetString(PyExc_TypeError,
; 3819 :                         "persistent_id must be a callable taking one argument");

  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@GNJKJGDK@persistent_id?5must?5be?5a?5callable@
  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0004c	e8 00 00 00 00	 call	 PyErr_SetString

; 3820 :         return -1;

  00051	b8 ff ff ff ff	 mov	 eax, -1
  00056	eb 40		 jmp	 SHORT $LN7@Pickler_se@2
$LN5@Pickler_se@2:

; 3821 :     }
; 3822 : 
; 3823 :     tmp = self->pers_func;

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 3824 :     Py_INCREF(value);

  00066	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$[rsp]
  0006b	e8 00 00 00 00	 call	 _Py_IncRef

; 3825 :     self->pers_func = value;

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00075	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$[rsp]
  0007a	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN4@Pickler_se@2:

; 3826 :     Py_XDECREF(tmp);      /* self->pers_func can be NULL, so be careful. */

  0007e	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00084	74 0a		 je	 SHORT $LN1@Pickler_se@2
  00086	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0008b	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Pickler_se@2:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 e8		 jne	 SHORT $LN4@Pickler_se@2

; 3827 : 
; 3828 :     return 0;

  00096	33 c0		 xor	 eax, eax
$LN7@Pickler_se@2:

; 3829 : }

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
Pickler_set_persid ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@GLAKAKP@Unpickler?4__init__?$CI?$CJ?5was?5not?5cal@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_load DD imagerel Unpickler_load
	DD	imagerel Unpickler_load+75
	DD	imagerel $unwind$Unpickler_load
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_load DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0DF@GLAKAKP@Unpickler?4__init__?$CI?$CJ?5was?5not?5cal@
CONST	SEGMENT
??_C@_0DF@GLAKAKP@Unpickler?4__init__?$CI?$CJ?5was?5not?5cal@ DB 'Unpickl'
	DB	'er.__init__() was not called by %s.__init__()', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Unpickler_load
_TEXT	SEGMENT
self$ = 48
Unpickler_load PROC					; COMDAT

; 5464 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5465 :     /* Check whether the Unpickler was initialized correctly. This prevents
; 5466 :        segfaulting if a subclass overridden __init__ with a function that does
; 5467 :        not call Unpickler.__init__(). Here, we simply ensure that self->read
; 5468 :        is not NULL. */
; 5469 :     if (self->read == NULL) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 00 01
	00 00 00	 cmp	 QWORD PTR [rax+256], 0
  00016	75 24		 jne	 SHORT $LN1@Unpickler_

; 5470 :         PyErr_Format(UnpicklingError,
; 5471 :                      "Unpickler.__init__() was not called by %s.__init__()",
; 5472 :                      Py_TYPE(self)->tp_name);

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@GLAKAKP@Unpickler?4__init__?$CI?$CJ?5was?5not?5cal@
  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00033	e8 00 00 00 00	 call	 PyErr_Format

; 5473 :         return NULL;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 0a		 jmp	 SHORT $LN2@Unpickler_
$LN1@Unpickler_:

; 5474 :     }
; 5475 : 
; 5476 :     return load(self);

  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00041	e8 00 00 00 00	 call	 load
$LN2@Unpickler_:

; 5477 : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
Unpickler_load ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@OJGEENPH@invalid?5load?5key?0?5?8?$CFc?8?4?$AA@ ; `string'
EXTRN	PyErr_SetNone:PROC
EXTRN	PyExc_EOFError:QWORD
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$load DD	imagerel load
	DD	imagerel load+2170
	DD	imagerel $unwind$load
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load DD	010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BI@OJGEENPH@invalid?5load?5key?0?5?8?$CFc?8?4?$AA@
CONST	SEGMENT
??_C@_0BI@OJGEENPH@invalid?5load?5key?0?5?8?$CFc?8?4?$AA@ DB 'invalid loa'
	DB	'd key, ''%c''.', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load
_TEXT	SEGMENT
value$ = 32
s$ = 40
err$ = 48
tv78 = 56
self$ = 80
load	PROC						; COMDAT

; 5349 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5350 :     PyObject *err;
; 5351 :     PyObject *value = NULL;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR value$[rsp], 0

; 5352 :     char *s;
; 5353 : 
; 5354 :     self->num_marks = 0;

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00017	48 c7 80 30 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+304], 0

; 5355 :     if (Py_SIZE(self->stack))

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00030	74 10		 je	 SHORT $LN124@load

; 5356 :         Pdata_clear(self->stack, 0);

  00032	33 d2		 xor	 edx, edx
  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00039	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0003d	e8 00 00 00 00	 call	 Pdata_clear
$LN124@load:
$LN179@load:
$LN178@load:
$LN177@load:
$LN176@load:
$LN175@load:
$LN174@load:
$LN173@load:
$LN172@load:
$LN171@load:
$LN170@load:
$LN169@load:
$LN168@load:
$LN167@load:
$LN166@load:
$LN165@load:
$LN164@load:
$LN163@load:
$LN162@load:
$LN161@load:
$LN160@load:
$LN159@load:
$LN158@load:
$LN157@load:
$LN156@load:
$LN155@load:
$LN154@load:
$LN153@load:
$LN152@load:
$LN151@load:
$LN150@load:
$LN149@load:
$LN148@load:
$LN147@load:
$LN146@load:
$LN145@load:
$LN144@load:
$LN143@load:
$LN142@load:
$LN141@load:
$LN140@load:
$LN139@load:
$LN138@load:
$LN137@load:
$LN136@load:
$LN135@load:
$LN134@load:
$LN133@load:
$LN132@load:
$LN131@load:
$LN130@load:
$LN129@load:
$LN128@load:
$LN127@load:
$LN123@load:

; 5357 : 
; 5358 :     /* Convenient macros for the dispatch while-switch loop just below. */
; 5359 : #define OP(opcode, load_func) \
; 5360 :     case opcode: if (load_func(self) < 0) break; continue;
; 5361 : 
; 5362 : #define OP_ARG(opcode, load_func, arg) \
; 5363 :     case opcode: if (load_func(self, (arg)) < 0) break; continue;
; 5364 : 
; 5365 :     while (1) {

  00042	33 c0		 xor	 eax, eax
  00044	83 f8 01	 cmp	 eax, 1
  00047	0f 84 ea 05 00
	00		 je	 $LN122@load

; 5366 :         if (_Unpickler_Read(self, &s, 1) < 0)

  0004d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00053	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00058	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0005d	e8 00 00 00 00	 call	 _Unpickler_Read
  00062	48 85 c0	 test	 rax, rax
  00065	7d 05		 jge	 SHORT $LN121@load

; 5367 :             break;

  00067	e9 cb 05 00 00	 jmp	 $LN122@load
$LN121@load:

; 5368 : 
; 5369 :         switch ((enum opcode)s[0]) {

  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00071	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00074	89 44 24 38	 mov	 DWORD PTR tv78[rsp], eax
  00078	8b 44 24 38	 mov	 eax, DWORD PTR tv78[rsp]
  0007c	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00081	89 44 24 38	 mov	 DWORD PTR tv78[rsp], eax
  00085	81 7c 24 38 fd
	00 00 00	 cmp	 DWORD PTR tv78[rsp], 253 ; 000000fdH
  0008d	0f 87 61 05 00
	00		 ja	 $LN9@load
  00093	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv78[rsp]
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0009f	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN180@load[rcx+rax]
  000a7	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN181@load[rcx+rax*4]
  000ae	48 03 c1	 add	 rax, rcx
  000b1	ff e0		 jmp	 rax
$LN118@load:

; 5370 :         OP(NONE, load_none)

  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000b8	e8 00 00 00 00	 call	 load_none
  000bd	85 c0		 test	 eax, eax
  000bf	7d 05		 jge	 SHORT $LN117@load
  000c1	e9 6a 05 00 00	 jmp	 $LN119@load
$LN117@load:
  000c6	e9 77 ff ff ff	 jmp	 $LN123@load
$LN116@load:

; 5371 :         OP(BININT, load_binint)

  000cb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000d0	e8 00 00 00 00	 call	 load_binint
  000d5	85 c0		 test	 eax, eax
  000d7	7d 05		 jge	 SHORT $LN115@load
  000d9	e9 52 05 00 00	 jmp	 $LN119@load
$LN115@load:
  000de	e9 5f ff ff ff	 jmp	 $LN127@load
$LN114@load:

; 5372 :         OP(BININT1, load_binint1)

  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000e8	e8 00 00 00 00	 call	 load_binint1
  000ed	85 c0		 test	 eax, eax
  000ef	7d 05		 jge	 SHORT $LN113@load
  000f1	e9 3a 05 00 00	 jmp	 $LN119@load
$LN113@load:
  000f6	e9 47 ff ff ff	 jmp	 $LN128@load
$LN112@load:

; 5373 :         OP(BININT2, load_binint2)

  000fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00100	e8 00 00 00 00	 call	 load_binint2
  00105	85 c0		 test	 eax, eax
  00107	7d 05		 jge	 SHORT $LN111@load
  00109	e9 22 05 00 00	 jmp	 $LN119@load
$LN111@load:
  0010e	e9 2f ff ff ff	 jmp	 $LN129@load
$LN110@load:

; 5374 :         OP(INT, load_int)

  00113	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00118	e8 00 00 00 00	 call	 load_int
  0011d	85 c0		 test	 eax, eax
  0011f	7d 05		 jge	 SHORT $LN109@load
  00121	e9 0a 05 00 00	 jmp	 $LN119@load
$LN109@load:
  00126	e9 17 ff ff ff	 jmp	 $LN130@load
$LN108@load:

; 5375 :         OP(LONG, load_long)

  0012b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00130	e8 00 00 00 00	 call	 load_long
  00135	85 c0		 test	 eax, eax
  00137	7d 05		 jge	 SHORT $LN107@load
  00139	e9 f2 04 00 00	 jmp	 $LN119@load
$LN107@load:
  0013e	e9 ff fe ff ff	 jmp	 $LN131@load
$LN106@load:

; 5376 :         OP_ARG(LONG1, load_counted_long, 1)

  00143	ba 01 00 00 00	 mov	 edx, 1
  00148	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0014d	e8 00 00 00 00	 call	 load_counted_long
  00152	85 c0		 test	 eax, eax
  00154	7d 05		 jge	 SHORT $LN105@load
  00156	e9 d5 04 00 00	 jmp	 $LN119@load
$LN105@load:
  0015b	e9 e2 fe ff ff	 jmp	 $LN132@load
$LN104@load:

; 5377 :         OP_ARG(LONG4, load_counted_long, 4)

  00160	ba 04 00 00 00	 mov	 edx, 4
  00165	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0016a	e8 00 00 00 00	 call	 load_counted_long
  0016f	85 c0		 test	 eax, eax
  00171	7d 05		 jge	 SHORT $LN103@load
  00173	e9 b8 04 00 00	 jmp	 $LN119@load
$LN103@load:
  00178	e9 c5 fe ff ff	 jmp	 $LN133@load
$LN102@load:

; 5378 :         OP(FLOAT, load_float)

  0017d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00182	e8 00 00 00 00	 call	 load_float
  00187	85 c0		 test	 eax, eax
  00189	7d 05		 jge	 SHORT $LN101@load
  0018b	e9 a0 04 00 00	 jmp	 $LN119@load
$LN101@load:
  00190	e9 ad fe ff ff	 jmp	 $LN134@load
$LN100@load:

; 5379 :         OP(BINFLOAT, load_binfloat)

  00195	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0019a	e8 00 00 00 00	 call	 load_binfloat
  0019f	85 c0		 test	 eax, eax
  001a1	7d 05		 jge	 SHORT $LN99@load
  001a3	e9 88 04 00 00	 jmp	 $LN119@load
$LN99@load:
  001a8	e9 95 fe ff ff	 jmp	 $LN135@load
$LN98@load:

; 5380 :         OP(BINBYTES, load_binbytes)

  001ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  001b2	e8 00 00 00 00	 call	 load_binbytes
  001b7	85 c0		 test	 eax, eax
  001b9	7d 05		 jge	 SHORT $LN97@load
  001bb	e9 70 04 00 00	 jmp	 $LN119@load
$LN97@load:
  001c0	e9 7d fe ff ff	 jmp	 $LN136@load
$LN96@load:

; 5381 :         OP(SHORT_BINBYTES, load_short_binbytes)

  001c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  001ca	e8 00 00 00 00	 call	 load_short_binbytes
  001cf	85 c0		 test	 eax, eax
  001d1	7d 05		 jge	 SHORT $LN95@load
  001d3	e9 58 04 00 00	 jmp	 $LN119@load
$LN95@load:
  001d8	e9 65 fe ff ff	 jmp	 $LN137@load
$LN94@load:

; 5382 :         OP(BINSTRING, load_binstring)

  001dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  001e2	e8 00 00 00 00	 call	 load_binstring
  001e7	85 c0		 test	 eax, eax
  001e9	7d 05		 jge	 SHORT $LN93@load
  001eb	e9 40 04 00 00	 jmp	 $LN119@load
$LN93@load:
  001f0	e9 4d fe ff ff	 jmp	 $LN138@load
$LN92@load:

; 5383 :         OP(SHORT_BINSTRING, load_short_binstring)

  001f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  001fa	e8 00 00 00 00	 call	 load_short_binstring
  001ff	85 c0		 test	 eax, eax
  00201	7d 05		 jge	 SHORT $LN91@load
  00203	e9 28 04 00 00	 jmp	 $LN119@load
$LN91@load:
  00208	e9 35 fe ff ff	 jmp	 $LN139@load
$LN90@load:

; 5384 :         OP(STRING, load_string)

  0020d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00212	e8 00 00 00 00	 call	 load_string
  00217	85 c0		 test	 eax, eax
  00219	7d 05		 jge	 SHORT $LN89@load
  0021b	e9 10 04 00 00	 jmp	 $LN119@load
$LN89@load:
  00220	e9 1d fe ff ff	 jmp	 $LN140@load
$LN88@load:

; 5385 :         OP(UNICODE, load_unicode)

  00225	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0022a	e8 00 00 00 00	 call	 load_unicode
  0022f	85 c0		 test	 eax, eax
  00231	7d 05		 jge	 SHORT $LN87@load
  00233	e9 f8 03 00 00	 jmp	 $LN119@load
$LN87@load:
  00238	e9 05 fe ff ff	 jmp	 $LN141@load
$LN86@load:

; 5386 :         OP(BINUNICODE, load_binunicode)

  0023d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00242	e8 00 00 00 00	 call	 load_binunicode
  00247	85 c0		 test	 eax, eax
  00249	7d 05		 jge	 SHORT $LN85@load
  0024b	e9 e0 03 00 00	 jmp	 $LN119@load
$LN85@load:
  00250	e9 ed fd ff ff	 jmp	 $LN142@load
$LN84@load:

; 5387 :         OP_ARG(EMPTY_TUPLE, load_counted_tuple, 0)

  00255	33 d2		 xor	 edx, edx
  00257	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0025c	e8 00 00 00 00	 call	 load_counted_tuple
  00261	85 c0		 test	 eax, eax
  00263	7d 05		 jge	 SHORT $LN83@load
  00265	e9 c6 03 00 00	 jmp	 $LN119@load
$LN83@load:
  0026a	e9 d3 fd ff ff	 jmp	 $LN143@load
$LN82@load:

; 5388 :         OP_ARG(TUPLE1, load_counted_tuple, 1)

  0026f	ba 01 00 00 00	 mov	 edx, 1
  00274	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00279	e8 00 00 00 00	 call	 load_counted_tuple
  0027e	85 c0		 test	 eax, eax
  00280	7d 05		 jge	 SHORT $LN81@load
  00282	e9 a9 03 00 00	 jmp	 $LN119@load
$LN81@load:
  00287	e9 b6 fd ff ff	 jmp	 $LN144@load
$LN80@load:

; 5389 :         OP_ARG(TUPLE2, load_counted_tuple, 2)

  0028c	ba 02 00 00 00	 mov	 edx, 2
  00291	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00296	e8 00 00 00 00	 call	 load_counted_tuple
  0029b	85 c0		 test	 eax, eax
  0029d	7d 05		 jge	 SHORT $LN79@load
  0029f	e9 8c 03 00 00	 jmp	 $LN119@load
$LN79@load:
  002a4	e9 99 fd ff ff	 jmp	 $LN145@load
$LN78@load:

; 5390 :         OP_ARG(TUPLE3, load_counted_tuple, 3)

  002a9	ba 03 00 00 00	 mov	 edx, 3
  002ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  002b3	e8 00 00 00 00	 call	 load_counted_tuple
  002b8	85 c0		 test	 eax, eax
  002ba	7d 05		 jge	 SHORT $LN77@load
  002bc	e9 6f 03 00 00	 jmp	 $LN119@load
$LN77@load:
  002c1	e9 7c fd ff ff	 jmp	 $LN146@load
$LN76@load:

; 5391 :         OP(TUPLE, load_tuple)

  002c6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  002cb	e8 00 00 00 00	 call	 load_tuple
  002d0	85 c0		 test	 eax, eax
  002d2	7d 05		 jge	 SHORT $LN75@load
  002d4	e9 57 03 00 00	 jmp	 $LN119@load
$LN75@load:
  002d9	e9 64 fd ff ff	 jmp	 $LN147@load
$LN74@load:

; 5392 :         OP(EMPTY_LIST, load_empty_list)

  002de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  002e3	e8 00 00 00 00	 call	 load_empty_list
  002e8	85 c0		 test	 eax, eax
  002ea	7d 05		 jge	 SHORT $LN73@load
  002ec	e9 3f 03 00 00	 jmp	 $LN119@load
$LN73@load:
  002f1	e9 4c fd ff ff	 jmp	 $LN148@load
$LN72@load:

; 5393 :         OP(LIST, load_list)

  002f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  002fb	e8 00 00 00 00	 call	 load_list
  00300	85 c0		 test	 eax, eax
  00302	7d 05		 jge	 SHORT $LN71@load
  00304	e9 27 03 00 00	 jmp	 $LN119@load
$LN71@load:
  00309	e9 34 fd ff ff	 jmp	 $LN149@load
$LN70@load:

; 5394 :         OP(EMPTY_DICT, load_empty_dict)

  0030e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00313	e8 00 00 00 00	 call	 load_empty_dict
  00318	85 c0		 test	 eax, eax
  0031a	7d 05		 jge	 SHORT $LN69@load
  0031c	e9 0f 03 00 00	 jmp	 $LN119@load
$LN69@load:
  00321	e9 1c fd ff ff	 jmp	 $LN150@load
$LN68@load:

; 5395 :         OP(DICT, load_dict)

  00326	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0032b	e8 00 00 00 00	 call	 load_dict
  00330	85 c0		 test	 eax, eax
  00332	7d 05		 jge	 SHORT $LN67@load
  00334	e9 f7 02 00 00	 jmp	 $LN119@load
$LN67@load:
  00339	e9 04 fd ff ff	 jmp	 $LN151@load
$LN66@load:

; 5396 :         OP(OBJ, load_obj)

  0033e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00343	e8 00 00 00 00	 call	 load_obj
  00348	85 c0		 test	 eax, eax
  0034a	7d 05		 jge	 SHORT $LN65@load
  0034c	e9 df 02 00 00	 jmp	 $LN119@load
$LN65@load:
  00351	e9 ec fc ff ff	 jmp	 $LN152@load
$LN64@load:

; 5397 :         OP(INST, load_inst)

  00356	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0035b	e8 00 00 00 00	 call	 load_inst
  00360	85 c0		 test	 eax, eax
  00362	7d 05		 jge	 SHORT $LN63@load
  00364	e9 c7 02 00 00	 jmp	 $LN119@load
$LN63@load:
  00369	e9 d4 fc ff ff	 jmp	 $LN153@load
$LN62@load:

; 5398 :         OP(NEWOBJ, load_newobj)

  0036e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00373	e8 00 00 00 00	 call	 load_newobj
  00378	85 c0		 test	 eax, eax
  0037a	7d 05		 jge	 SHORT $LN61@load
  0037c	e9 af 02 00 00	 jmp	 $LN119@load
$LN61@load:
  00381	e9 bc fc ff ff	 jmp	 $LN154@load
$LN60@load:

; 5399 :         OP(GLOBAL, load_global)

  00386	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0038b	e8 00 00 00 00	 call	 load_global
  00390	85 c0		 test	 eax, eax
  00392	7d 05		 jge	 SHORT $LN59@load
  00394	e9 97 02 00 00	 jmp	 $LN119@load
$LN59@load:
  00399	e9 a4 fc ff ff	 jmp	 $LN155@load
$LN58@load:

; 5400 :         OP(APPEND, load_append)

  0039e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  003a3	e8 00 00 00 00	 call	 load_append
  003a8	85 c0		 test	 eax, eax
  003aa	7d 05		 jge	 SHORT $LN57@load
  003ac	e9 7f 02 00 00	 jmp	 $LN119@load
$LN57@load:
  003b1	e9 8c fc ff ff	 jmp	 $LN156@load
$LN56@load:

; 5401 :         OP(APPENDS, load_appends)

  003b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  003bb	e8 00 00 00 00	 call	 load_appends
  003c0	85 c0		 test	 eax, eax
  003c2	7d 05		 jge	 SHORT $LN55@load
  003c4	e9 67 02 00 00	 jmp	 $LN119@load
$LN55@load:
  003c9	e9 74 fc ff ff	 jmp	 $LN157@load
$LN54@load:

; 5402 :         OP(BUILD, load_build)

  003ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  003d3	e8 00 00 00 00	 call	 load_build
  003d8	85 c0		 test	 eax, eax
  003da	7d 05		 jge	 SHORT $LN53@load
  003dc	e9 4f 02 00 00	 jmp	 $LN119@load
$LN53@load:
  003e1	e9 5c fc ff ff	 jmp	 $LN158@load
$LN52@load:

; 5403 :         OP(DUP, load_dup)

  003e6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  003eb	e8 00 00 00 00	 call	 load_dup
  003f0	85 c0		 test	 eax, eax
  003f2	7d 05		 jge	 SHORT $LN51@load
  003f4	e9 37 02 00 00	 jmp	 $LN119@load
$LN51@load:
  003f9	e9 44 fc ff ff	 jmp	 $LN159@load
$LN50@load:

; 5404 :         OP(BINGET, load_binget)

  003fe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00403	e8 00 00 00 00	 call	 load_binget
  00408	85 c0		 test	 eax, eax
  0040a	7d 05		 jge	 SHORT $LN49@load
  0040c	e9 1f 02 00 00	 jmp	 $LN119@load
$LN49@load:
  00411	e9 2c fc ff ff	 jmp	 $LN160@load
$LN48@load:

; 5405 :         OP(LONG_BINGET, load_long_binget)

  00416	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0041b	e8 00 00 00 00	 call	 load_long_binget
  00420	85 c0		 test	 eax, eax
  00422	7d 05		 jge	 SHORT $LN47@load
  00424	e9 07 02 00 00	 jmp	 $LN119@load
$LN47@load:
  00429	e9 14 fc ff ff	 jmp	 $LN161@load
$LN46@load:

; 5406 :         OP(GET, load_get)

  0042e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00433	e8 00 00 00 00	 call	 load_get
  00438	85 c0		 test	 eax, eax
  0043a	7d 05		 jge	 SHORT $LN45@load
  0043c	e9 ef 01 00 00	 jmp	 $LN119@load
$LN45@load:
  00441	e9 fc fb ff ff	 jmp	 $LN162@load
$LN44@load:

; 5407 :         OP(MARK, load_mark)

  00446	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0044b	e8 00 00 00 00	 call	 load_mark
  00450	85 c0		 test	 eax, eax
  00452	7d 05		 jge	 SHORT $LN43@load
  00454	e9 d7 01 00 00	 jmp	 $LN119@load
$LN43@load:
  00459	e9 e4 fb ff ff	 jmp	 $LN163@load
$LN42@load:

; 5408 :         OP(BINPUT, load_binput)

  0045e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00463	e8 00 00 00 00	 call	 load_binput
  00468	85 c0		 test	 eax, eax
  0046a	7d 05		 jge	 SHORT $LN41@load
  0046c	e9 bf 01 00 00	 jmp	 $LN119@load
$LN41@load:
  00471	e9 cc fb ff ff	 jmp	 $LN164@load
$LN40@load:

; 5409 :         OP(LONG_BINPUT, load_long_binput)

  00476	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0047b	e8 00 00 00 00	 call	 load_long_binput
  00480	85 c0		 test	 eax, eax
  00482	7d 05		 jge	 SHORT $LN39@load
  00484	e9 a7 01 00 00	 jmp	 $LN119@load
$LN39@load:
  00489	e9 b4 fb ff ff	 jmp	 $LN165@load
$LN38@load:

; 5410 :         OP(PUT, load_put)

  0048e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00493	e8 00 00 00 00	 call	 load_put
  00498	85 c0		 test	 eax, eax
  0049a	7d 05		 jge	 SHORT $LN37@load
  0049c	e9 8f 01 00 00	 jmp	 $LN119@load
$LN37@load:
  004a1	e9 9c fb ff ff	 jmp	 $LN166@load
$LN36@load:

; 5411 :         OP(POP, load_pop)

  004a6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  004ab	e8 00 00 00 00	 call	 load_pop
  004b0	85 c0		 test	 eax, eax
  004b2	7d 05		 jge	 SHORT $LN35@load
  004b4	e9 77 01 00 00	 jmp	 $LN119@load
$LN35@load:
  004b9	e9 84 fb ff ff	 jmp	 $LN167@load
$LN34@load:

; 5412 :         OP(POP_MARK, load_pop_mark)

  004be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  004c3	e8 00 00 00 00	 call	 load_pop_mark
  004c8	85 c0		 test	 eax, eax
  004ca	7d 05		 jge	 SHORT $LN33@load
  004cc	e9 5f 01 00 00	 jmp	 $LN119@load
$LN33@load:
  004d1	e9 6c fb ff ff	 jmp	 $LN168@load
$LN32@load:

; 5413 :         OP(SETITEM, load_setitem)

  004d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  004db	e8 00 00 00 00	 call	 load_setitem
  004e0	85 c0		 test	 eax, eax
  004e2	7d 05		 jge	 SHORT $LN31@load
  004e4	e9 47 01 00 00	 jmp	 $LN119@load
$LN31@load:
  004e9	e9 54 fb ff ff	 jmp	 $LN169@load
$LN30@load:

; 5414 :         OP(SETITEMS, load_setitems)

  004ee	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  004f3	e8 00 00 00 00	 call	 load_setitems
  004f8	85 c0		 test	 eax, eax
  004fa	7d 05		 jge	 SHORT $LN29@load
  004fc	e9 2f 01 00 00	 jmp	 $LN119@load
$LN29@load:
  00501	e9 3c fb ff ff	 jmp	 $LN170@load
$LN28@load:

; 5415 :         OP(PERSID, load_persid)

  00506	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0050b	e8 00 00 00 00	 call	 load_persid
  00510	85 c0		 test	 eax, eax
  00512	7d 05		 jge	 SHORT $LN27@load
  00514	e9 17 01 00 00	 jmp	 $LN119@load
$LN27@load:
  00519	e9 24 fb ff ff	 jmp	 $LN171@load
$LN26@load:

; 5416 :         OP(BINPERSID, load_binpersid)

  0051e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00523	e8 00 00 00 00	 call	 load_binpersid
  00528	85 c0		 test	 eax, eax
  0052a	7d 05		 jge	 SHORT $LN25@load
  0052c	e9 ff 00 00 00	 jmp	 $LN119@load
$LN25@load:
  00531	e9 0c fb ff ff	 jmp	 $LN172@load
$LN24@load:

; 5417 :         OP(REDUCE, load_reduce)

  00536	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0053b	e8 00 00 00 00	 call	 load_reduce
  00540	85 c0		 test	 eax, eax
  00542	7d 05		 jge	 SHORT $LN23@load
  00544	e9 e7 00 00 00	 jmp	 $LN119@load
$LN23@load:
  00549	e9 f4 fa ff ff	 jmp	 $LN173@load
$LN22@load:

; 5418 :         OP(PROTO, load_proto)

  0054e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00553	e8 00 00 00 00	 call	 load_proto
  00558	85 c0		 test	 eax, eax
  0055a	7d 05		 jge	 SHORT $LN21@load
  0055c	e9 cf 00 00 00	 jmp	 $LN119@load
$LN21@load:
  00561	e9 dc fa ff ff	 jmp	 $LN174@load
$LN20@load:

; 5419 :         OP_ARG(EXT1, load_extension, 1)

  00566	ba 01 00 00 00	 mov	 edx, 1
  0056b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00570	e8 00 00 00 00	 call	 load_extension
  00575	85 c0		 test	 eax, eax
  00577	7d 05		 jge	 SHORT $LN19@load
  00579	e9 b2 00 00 00	 jmp	 $LN119@load
$LN19@load:
  0057e	e9 bf fa ff ff	 jmp	 $LN175@load
$LN18@load:

; 5420 :         OP_ARG(EXT2, load_extension, 2)

  00583	ba 02 00 00 00	 mov	 edx, 2
  00588	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0058d	e8 00 00 00 00	 call	 load_extension
  00592	85 c0		 test	 eax, eax
  00594	7d 05		 jge	 SHORT $LN17@load
  00596	e9 95 00 00 00	 jmp	 $LN119@load
$LN17@load:
  0059b	e9 a2 fa ff ff	 jmp	 $LN176@load
$LN16@load:

; 5421 :         OP_ARG(EXT4, load_extension, 4)

  005a0	ba 04 00 00 00	 mov	 edx, 4
  005a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  005aa	e8 00 00 00 00	 call	 load_extension
  005af	85 c0		 test	 eax, eax
  005b1	7d 02		 jge	 SHORT $LN15@load
  005b3	eb 7b		 jmp	 SHORT $LN119@load
$LN15@load:
  005b5	e9 88 fa ff ff	 jmp	 $LN177@load
$LN14@load:

; 5422 :         OP_ARG(NEWTRUE, load_bool, Py_True)

  005ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_TrueStruct
  005c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  005c6	e8 00 00 00 00	 call	 load_bool
  005cb	85 c0		 test	 eax, eax
  005cd	7d 02		 jge	 SHORT $LN13@load
  005cf	eb 5f		 jmp	 SHORT $LN119@load
$LN13@load:
  005d1	e9 6c fa ff ff	 jmp	 $LN178@load
$LN12@load:

; 5423 :         OP_ARG(NEWFALSE, load_bool, Py_False)

  005d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_FalseStruct
  005dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  005e2	e8 00 00 00 00	 call	 load_bool
  005e7	85 c0		 test	 eax, eax
  005e9	7d 02		 jge	 SHORT $LN11@load
  005eb	eb 43		 jmp	 SHORT $LN119@load
$LN11@load:
  005ed	e9 50 fa ff ff	 jmp	 $LN179@load
$LN10@load:

; 5424 : 
; 5425 :         case STOP:
; 5426 :             break;

  005f2	eb 3c		 jmp	 SHORT $LN119@load
$LN9@load:

; 5427 : 
; 5428 :         default:
; 5429 :             if (s[0] == '\0')

  005f4	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  005f9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005fc	85 c0		 test	 eax, eax
  005fe	75 0e		 jne	 SHORT $LN8@load

; 5430 :                 PyErr_SetNone(PyExc_EOFError);

  00600	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_EOFError
  00607	e8 00 00 00 00	 call	 PyErr_SetNone

; 5431 :             else

  0060c	eb 1e		 jmp	 SHORT $LN7@load
$LN8@load:

; 5432 :                 PyErr_Format(UnpicklingError,
; 5433 :                              "invalid load key, '%c'.", s[0]);

  0060e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00613	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00616	44 8b c0	 mov	 r8d, eax
  00619	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@OJGEENPH@invalid?5load?5key?0?5?8?$CFc?8?4?$AA@
  00620	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00627	e8 00 00 00 00	 call	 PyErr_Format
$LN7@load:

; 5434 :             return NULL;

  0062c	33 c0		 xor	 eax, eax
  0062e	eb 67		 jmp	 SHORT $LN125@load
$LN119@load:

; 5435 :         }
; 5436 : 
; 5437 :         break;                  /* and we are done! */

  00630	eb 05		 jmp	 SHORT $LN122@load

; 5438 :     }

  00632	e9 0b fa ff ff	 jmp	 $LN123@load
$LN122@load:

; 5439 : 
; 5440 :     if (_Unpickler_SkipConsumed(self) < 0)

  00637	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0063c	e8 00 00 00 00	 call	 _Unpickler_SkipConsumed
  00641	85 c0		 test	 eax, eax
  00643	7d 04		 jge	 SHORT $LN6@load

; 5441 :         return NULL;

  00645	33 c0		 xor	 eax, eax
  00647	eb 4e		 jmp	 SHORT $LN125@load
$LN6@load:

; 5442 : 
; 5443 :     /* XXX: It is not clear what this is actually for. */
; 5444 :     if ((err = PyErr_Occurred())) {

  00649	e8 00 00 00 00	 call	 PyErr_Occurred
  0064e	48 89 44 24 30	 mov	 QWORD PTR err$[rsp], rax
  00653	48 83 7c 24 30
	00		 cmp	 QWORD PTR err$[rsp], 0
  00659	74 1e		 je	 SHORT $LN5@load

; 5445 :         if (err == PyExc_EOFError) {

  0065b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyExc_EOFError
  00662	48 39 44 24 30	 cmp	 QWORD PTR err$[rsp], rax
  00667	75 0c		 jne	 SHORT $LN4@load

; 5446 :             PyErr_SetNone(PyExc_EOFError);

  00669	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_EOFError
  00670	e8 00 00 00 00	 call	 PyErr_SetNone
$LN4@load:

; 5447 :         }
; 5448 :         return NULL;

  00675	33 c0		 xor	 eax, eax
  00677	eb 1e		 jmp	 SHORT $LN125@load
$LN5@load:
$LN3@load:

; 5449 :     }
; 5450 : 
; 5451 :     PDATA_POP(self->stack, value);

  00679	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0067e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00682	e8 00 00 00 00	 call	 Pdata_pop
  00687	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  0068c	33 c0		 xor	 eax, eax
  0068e	85 c0		 test	 eax, eax
  00690	75 e7		 jne	 SHORT $LN3@load

; 5452 :     return value;

  00692	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
$LN125@load:

; 5453 : }

  00697	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0069b	c3		 ret	 0
$LN181@load:
  0069c	00 00 00 00	 DD	 $LN22@load
  006a0	00 00 00 00	 DD	 $LN62@load
  006a4	00 00 00 00	 DD	 $LN20@load
  006a8	00 00 00 00	 DD	 $LN18@load
  006ac	00 00 00 00	 DD	 $LN16@load
  006b0	00 00 00 00	 DD	 $LN82@load
  006b4	00 00 00 00	 DD	 $LN80@load
  006b8	00 00 00 00	 DD	 $LN78@load
  006bc	00 00 00 00	 DD	 $LN14@load
  006c0	00 00 00 00	 DD	 $LN12@load
  006c4	00 00 00 00	 DD	 $LN106@load
  006c8	00 00 00 00	 DD	 $LN104@load
  006cc	00 00 00 00	 DD	 $LN44@load
  006d0	00 00 00 00	 DD	 $LN84@load
  006d4	00 00 00 00	 DD	 $LN10@load
  006d8	00 00 00 00	 DD	 $LN36@load
  006dc	00 00 00 00	 DD	 $LN34@load
  006e0	00 00 00 00	 DD	 $LN52@load
  006e4	00 00 00 00	 DD	 $LN98@load
  006e8	00 00 00 00	 DD	 $LN96@load
  006ec	00 00 00 00	 DD	 $LN102@load
  006f0	00 00 00 00	 DD	 $LN100@load
  006f4	00 00 00 00	 DD	 $LN110@load
  006f8	00 00 00 00	 DD	 $LN116@load
  006fc	00 00 00 00	 DD	 $LN114@load
  00700	00 00 00 00	 DD	 $LN108@load
  00704	00 00 00 00	 DD	 $LN112@load
  00708	00 00 00 00	 DD	 $LN118@load
  0070c	00 00 00 00	 DD	 $LN28@load
  00710	00 00 00 00	 DD	 $LN26@load
  00714	00 00 00 00	 DD	 $LN24@load
  00718	00 00 00 00	 DD	 $LN90@load
  0071c	00 00 00 00	 DD	 $LN94@load
  00720	00 00 00 00	 DD	 $LN92@load
  00724	00 00 00 00	 DD	 $LN88@load
  00728	00 00 00 00	 DD	 $LN86@load
  0072c	00 00 00 00	 DD	 $LN74@load
  00730	00 00 00 00	 DD	 $LN58@load
  00734	00 00 00 00	 DD	 $LN54@load
  00738	00 00 00 00	 DD	 $LN60@load
  0073c	00 00 00 00	 DD	 $LN68@load
  00740	00 00 00 00	 DD	 $LN56@load
  00744	00 00 00 00	 DD	 $LN46@load
  00748	00 00 00 00	 DD	 $LN50@load
  0074c	00 00 00 00	 DD	 $LN64@load
  00750	00 00 00 00	 DD	 $LN48@load
  00754	00 00 00 00	 DD	 $LN72@load
  00758	00 00 00 00	 DD	 $LN66@load
  0075c	00 00 00 00	 DD	 $LN38@load
  00760	00 00 00 00	 DD	 $LN42@load
  00764	00 00 00 00	 DD	 $LN40@load
  00768	00 00 00 00	 DD	 $LN32@load
  0076c	00 00 00 00	 DD	 $LN76@load
  00770	00 00 00 00	 DD	 $LN30@load
  00774	00 00 00 00	 DD	 $LN70@load
  00778	00 00 00 00	 DD	 $LN9@load
$LN180@load:
  0077c	00		 DB	 0
  0077d	01		 DB	 1
  0077e	02		 DB	 2
  0077f	03		 DB	 3
  00780	04		 DB	 4
  00781	05		 DB	 5
  00782	06		 DB	 6
  00783	07		 DB	 7
  00784	08		 DB	 8
  00785	09		 DB	 9
  00786	0a		 DB	 10
  00787	0b		 DB	 11
  00788	37		 DB	 55			; 00000037H
  00789	37		 DB	 55			; 00000037H
  0078a	37		 DB	 55			; 00000037H
  0078b	37		 DB	 55			; 00000037H
  0078c	37		 DB	 55			; 00000037H
  0078d	37		 DB	 55			; 00000037H
  0078e	37		 DB	 55			; 00000037H
  0078f	37		 DB	 55			; 00000037H
  00790	37		 DB	 55			; 00000037H
  00791	37		 DB	 55			; 00000037H
  00792	37		 DB	 55			; 00000037H
  00793	37		 DB	 55			; 00000037H
  00794	37		 DB	 55			; 00000037H
  00795	37		 DB	 55			; 00000037H
  00796	37		 DB	 55			; 00000037H
  00797	37		 DB	 55			; 00000037H
  00798	37		 DB	 55			; 00000037H
  00799	37		 DB	 55			; 00000037H
  0079a	37		 DB	 55			; 00000037H
  0079b	37		 DB	 55			; 00000037H
  0079c	37		 DB	 55			; 00000037H
  0079d	37		 DB	 55			; 00000037H
  0079e	37		 DB	 55			; 00000037H
  0079f	37		 DB	 55			; 00000037H
  007a0	37		 DB	 55			; 00000037H
  007a1	37		 DB	 55			; 00000037H
  007a2	37		 DB	 55			; 00000037H
  007a3	37		 DB	 55			; 00000037H
  007a4	37		 DB	 55			; 00000037H
  007a5	37		 DB	 55			; 00000037H
  007a6	37		 DB	 55			; 00000037H
  007a7	37		 DB	 55			; 00000037H
  007a8	37		 DB	 55			; 00000037H
  007a9	37		 DB	 55			; 00000037H
  007aa	37		 DB	 55			; 00000037H
  007ab	37		 DB	 55			; 00000037H
  007ac	37		 DB	 55			; 00000037H
  007ad	37		 DB	 55			; 00000037H
  007ae	37		 DB	 55			; 00000037H
  007af	37		 DB	 55			; 00000037H
  007b0	37		 DB	 55			; 00000037H
  007b1	37		 DB	 55			; 00000037H
  007b2	37		 DB	 55			; 00000037H
  007b3	37		 DB	 55			; 00000037H
  007b4	37		 DB	 55			; 00000037H
  007b5	37		 DB	 55			; 00000037H
  007b6	37		 DB	 55			; 00000037H
  007b7	37		 DB	 55			; 00000037H
  007b8	37		 DB	 55			; 00000037H
  007b9	37		 DB	 55			; 00000037H
  007ba	37		 DB	 55			; 00000037H
  007bb	37		 DB	 55			; 00000037H
  007bc	37		 DB	 55			; 00000037H
  007bd	37		 DB	 55			; 00000037H
  007be	37		 DB	 55			; 00000037H
  007bf	37		 DB	 55			; 00000037H
  007c0	37		 DB	 55			; 00000037H
  007c1	37		 DB	 55			; 00000037H
  007c2	37		 DB	 55			; 00000037H
  007c3	37		 DB	 55			; 00000037H
  007c4	37		 DB	 55			; 00000037H
  007c5	37		 DB	 55			; 00000037H
  007c6	37		 DB	 55			; 00000037H
  007c7	37		 DB	 55			; 00000037H
  007c8	37		 DB	 55			; 00000037H
  007c9	37		 DB	 55			; 00000037H
  007ca	37		 DB	 55			; 00000037H
  007cb	37		 DB	 55			; 00000037H
  007cc	37		 DB	 55			; 00000037H
  007cd	37		 DB	 55			; 00000037H
  007ce	37		 DB	 55			; 00000037H
  007cf	37		 DB	 55			; 00000037H
  007d0	37		 DB	 55			; 00000037H
  007d1	37		 DB	 55			; 00000037H
  007d2	37		 DB	 55			; 00000037H
  007d3	37		 DB	 55			; 00000037H
  007d4	37		 DB	 55			; 00000037H
  007d5	37		 DB	 55			; 00000037H
  007d6	37		 DB	 55			; 00000037H
  007d7	37		 DB	 55			; 00000037H
  007d8	37		 DB	 55			; 00000037H
  007d9	37		 DB	 55			; 00000037H
  007da	37		 DB	 55			; 00000037H
  007db	37		 DB	 55			; 00000037H
  007dc	37		 DB	 55			; 00000037H
  007dd	37		 DB	 55			; 00000037H
  007de	37		 DB	 55			; 00000037H
  007df	37		 DB	 55			; 00000037H
  007e0	37		 DB	 55			; 00000037H
  007e1	37		 DB	 55			; 00000037H
  007e2	37		 DB	 55			; 00000037H
  007e3	37		 DB	 55			; 00000037H
  007e4	37		 DB	 55			; 00000037H
  007e5	37		 DB	 55			; 00000037H
  007e6	37		 DB	 55			; 00000037H
  007e7	37		 DB	 55			; 00000037H
  007e8	37		 DB	 55			; 00000037H
  007e9	37		 DB	 55			; 00000037H
  007ea	37		 DB	 55			; 00000037H
  007eb	37		 DB	 55			; 00000037H
  007ec	37		 DB	 55			; 00000037H
  007ed	37		 DB	 55			; 00000037H
  007ee	37		 DB	 55			; 00000037H
  007ef	37		 DB	 55			; 00000037H
  007f0	37		 DB	 55			; 00000037H
  007f1	37		 DB	 55			; 00000037H
  007f2	37		 DB	 55			; 00000037H
  007f3	37		 DB	 55			; 00000037H
  007f4	37		 DB	 55			; 00000037H
  007f5	37		 DB	 55			; 00000037H
  007f6	37		 DB	 55			; 00000037H
  007f7	37		 DB	 55			; 00000037H
  007f8	37		 DB	 55			; 00000037H
  007f9	37		 DB	 55			; 00000037H
  007fa	37		 DB	 55			; 00000037H
  007fb	37		 DB	 55			; 00000037H
  007fc	37		 DB	 55			; 00000037H
  007fd	37		 DB	 55			; 00000037H
  007fe	37		 DB	 55			; 00000037H
  007ff	37		 DB	 55			; 00000037H
  00800	37		 DB	 55			; 00000037H
  00801	37		 DB	 55			; 00000037H
  00802	37		 DB	 55			; 00000037H
  00803	37		 DB	 55			; 00000037H
  00804	37		 DB	 55			; 00000037H
  00805	37		 DB	 55			; 00000037H
  00806	37		 DB	 55			; 00000037H
  00807	37		 DB	 55			; 00000037H
  00808	37		 DB	 55			; 00000037H
  00809	37		 DB	 55			; 00000037H
  0080a	37		 DB	 55			; 00000037H
  0080b	37		 DB	 55			; 00000037H
  0080c	37		 DB	 55			; 00000037H
  0080d	37		 DB	 55			; 00000037H
  0080e	37		 DB	 55			; 00000037H
  0080f	37		 DB	 55			; 00000037H
  00810	37		 DB	 55			; 00000037H
  00811	37		 DB	 55			; 00000037H
  00812	37		 DB	 55			; 00000037H
  00813	37		 DB	 55			; 00000037H
  00814	37		 DB	 55			; 00000037H
  00815	37		 DB	 55			; 00000037H
  00816	37		 DB	 55			; 00000037H
  00817	37		 DB	 55			; 00000037H
  00818	37		 DB	 55			; 00000037H
  00819	37		 DB	 55			; 00000037H
  0081a	37		 DB	 55			; 00000037H
  0081b	37		 DB	 55			; 00000037H
  0081c	37		 DB	 55			; 00000037H
  0081d	37		 DB	 55			; 00000037H
  0081e	37		 DB	 55			; 00000037H
  0081f	37		 DB	 55			; 00000037H
  00820	37		 DB	 55			; 00000037H
  00821	37		 DB	 55			; 00000037H
  00822	37		 DB	 55			; 00000037H
  00823	37		 DB	 55			; 00000037H
  00824	0c		 DB	 12
  00825	0d		 DB	 13
  00826	37		 DB	 55			; 00000037H
  00827	37		 DB	 55			; 00000037H
  00828	37		 DB	 55			; 00000037H
  00829	37		 DB	 55			; 00000037H
  0082a	0e		 DB	 14
  0082b	37		 DB	 55			; 00000037H
  0082c	0f		 DB	 15
  0082d	10		 DB	 16
  0082e	11		 DB	 17
  0082f	37		 DB	 55			; 00000037H
  00830	37		 DB	 55			; 00000037H
  00831	37		 DB	 55			; 00000037H
  00832	37		 DB	 55			; 00000037H
  00833	37		 DB	 55			; 00000037H
  00834	37		 DB	 55			; 00000037H
  00835	37		 DB	 55			; 00000037H
  00836	37		 DB	 55			; 00000037H
  00837	37		 DB	 55			; 00000037H
  00838	37		 DB	 55			; 00000037H
  00839	37		 DB	 55			; 00000037H
  0083a	37		 DB	 55			; 00000037H
  0083b	37		 DB	 55			; 00000037H
  0083c	37		 DB	 55			; 00000037H
  0083d	37		 DB	 55			; 00000037H
  0083e	12		 DB	 18
  0083f	13		 DB	 19
  00840	37		 DB	 55			; 00000037H
  00841	37		 DB	 55			; 00000037H
  00842	14		 DB	 20
  00843	15		 DB	 21
  00844	37		 DB	 55			; 00000037H
  00845	16		 DB	 22
  00846	17		 DB	 23
  00847	18		 DB	 24
  00848	19		 DB	 25
  00849	1a		 DB	 26
  0084a	1b		 DB	 27
  0084b	37		 DB	 55			; 00000037H
  0084c	1c		 DB	 28
  0084d	1d		 DB	 29
  0084e	1e		 DB	 30
  0084f	1f		 DB	 31
  00850	20		 DB	 32			; 00000020H
  00851	21		 DB	 33			; 00000021H
  00852	22		 DB	 34			; 00000022H
  00853	37		 DB	 55			; 00000037H
  00854	23		 DB	 35			; 00000023H
  00855	37		 DB	 55			; 00000037H
  00856	37		 DB	 55			; 00000037H
  00857	37		 DB	 55			; 00000037H
  00858	37		 DB	 55			; 00000037H
  00859	24		 DB	 36			; 00000024H
  0085a	37		 DB	 55			; 00000037H
  0085b	37		 DB	 55			; 00000037H
  0085c	37		 DB	 55			; 00000037H
  0085d	25		 DB	 37			; 00000025H
  0085e	26		 DB	 38			; 00000026H
  0085f	27		 DB	 39			; 00000027H
  00860	28		 DB	 40			; 00000028H
  00861	29		 DB	 41			; 00000029H
  00862	37		 DB	 55			; 00000037H
  00863	2a		 DB	 42			; 0000002aH
  00864	2b		 DB	 43			; 0000002bH
  00865	2c		 DB	 44			; 0000002cH
  00866	2d		 DB	 45			; 0000002dH
  00867	37		 DB	 55			; 00000037H
  00868	2e		 DB	 46			; 0000002eH
  00869	37		 DB	 55			; 00000037H
  0086a	37		 DB	 55			; 00000037H
  0086b	2f		 DB	 47			; 0000002fH
  0086c	30		 DB	 48			; 00000030H
  0086d	31		 DB	 49			; 00000031H
  0086e	32		 DB	 50			; 00000032H
  0086f	33		 DB	 51			; 00000033H
  00870	34		 DB	 52			; 00000034H
  00871	35		 DB	 53			; 00000035H
  00872	37		 DB	 55			; 00000037H
  00873	37		 DB	 55			; 00000037H
  00874	37		 DB	 55			; 00000037H
  00875	37		 DB	 55			; 00000037H
  00876	37		 DB	 55			; 00000037H
  00877	37		 DB	 55			; 00000037H
  00878	37		 DB	 55			; 00000037H
  00879	36		 DB	 54			; 00000036H
load	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@IIKMBICA@Pdata_clear?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_clear DD imagerel Pdata_clear
	DD	imagerel Pdata_clear+261
	DD	imagerel $unwind$Pdata_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_clear DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0M@IIKMBICA@Pdata_clear?$AA@
CONST	SEGMENT
??_C@_0M@IIKMBICA@Pdata_clear?$AA@ DB 'Pdata_clear', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Pdata_clear
_TEXT	SEGMENT
i$ = 48
_py_tmp$20491 = 56
self$ = 80
clearto$ = 88
Pdata_clear PROC					; COMDAT

; 194  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 195  :     Py_ssize_t i = Py_SIZE(self);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 196  : 
; 197  :     if (clearto < 0)

  0001c	48 83 7c 24 58
	00		 cmp	 QWORD PTR clearto$[rsp], 0
  00022	7d 0a		 jge	 SHORT $LN8@Pdata_clea

; 198  :         return stack_underflow();

  00024	e8 00 00 00 00	 call	 stack_underflow
  00029	e9 d2 00 00 00	 jmp	 $LN9@Pdata_clea
$LN8@Pdata_clea:

; 199  :     if (clearto >= i)

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00033	48 39 44 24 58	 cmp	 QWORD PTR clearto$[rsp], rax
  00038	7c 07		 jl	 SHORT $LN7@Pdata_clea

; 200  :         return 0;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 bf 00 00 00	 jmp	 $LN9@Pdata_clea
$LN7@Pdata_clea:
$LN6@Pdata_clea:

; 201  : 
; 202  :     while (--i >= clearto) {

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00046	48 ff c8	 dec	 rax
  00049	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  0004e	48 8b 44 24 58	 mov	 rax, QWORD PTR clearto$[rsp]
  00053	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00058	0f 8c 92 00 00
	00		 jl	 $LN5@Pdata_clea
$LN4@Pdata_clea:

; 203  :         Py_CLEAR(self->data[i]);

  0005e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00063	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0006c	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00071	74 6e		 je	 SHORT $LN1@Pdata_clea
  00073	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00078	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0007c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00084	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00089	4c 8b 0c c8	 mov	 r9, QWORD PTR [rax+rcx*8]
  0008d	41 b8 cb 00 00
	00		 mov	 r8d, 203		; 000000cbH
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@IIKMBICA@Pdata_clear?$AA@
  000a1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a6	85 c0		 test	 eax, eax
  000a8	75 37		 jne	 SHORT $LN1@Pdata_clea
  000aa	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000af	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  000b8	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000bc	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$20491[rsp], rax
  000c1	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c6	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  000cf	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0
  000d7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$20491[rsp]
  000dc	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Pdata_clea:
  000e1	33 c0		 xor	 eax, eax
  000e3	85 c0		 test	 eax, eax
  000e5	0f 85 73 ff ff
	ff		 jne	 $LN4@Pdata_clea

; 204  :     }

  000eb	e9 51 ff ff ff	 jmp	 $LN6@Pdata_clea
$LN5@Pdata_clea:

; 205  :     Py_SIZE(self) = clearto;

  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000f5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR clearto$[rsp]
  000fa	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 206  :     return 0;

  000fe	33 c0		 xor	 eax, eax
$LN9@Pdata_clea:

; 207  : }

  00100	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00104	c3		 ret	 0
Pdata_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@LIPPOKPL@unpickling?5stack?5underflow?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stack_underflow DD imagerel stack_underflow
	DD	imagerel stack_underflow+33
	DD	imagerel $unwind$stack_underflow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stack_underflow DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BL@LIPPOKPL@unpickling?5stack?5underflow?$AA@
CONST	SEGMENT
??_C@_0BL@LIPPOKPL@unpickling?5stack?5underflow?$AA@ DB 'unpickling stack'
	DB	' underflow', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stack_underflow
_TEXT	SEGMENT
stack_underflow PROC					; COMDAT

; 141  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 142  :     PyErr_SetString(UnpicklingError, "unpickling stack underflow");

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LIPPOKPL@unpickling?5stack?5underflow?$AA@
  0000b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 143  :     return -1;

  00017	b8 ff ff ff ff	 mov	 eax, -1

; 144  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
stack_underflow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@CAKEIMA@bad?5pickle?5data?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_pop DD imagerel Pdata_pop
	DD	imagerel Pdata_pop+98
	DD	imagerel $unwind$Pdata_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_pop DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BA@CAKEIMA@bad?5pickle?5data?$AA@
CONST	SEGMENT
??_C@_0BA@CAKEIMA@bad?5pickle?5data?$AA@ DB 'bad pickle data', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Pdata_pop
_TEXT	SEGMENT
tv71 = 32
self$ = 64
Pdata_pop PROC						; COMDAT

; 242  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 243  :     if (Py_SIZE(self) == 0) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	75 17		 jne	 SHORT $LN1@Pdata_pop

; 244  :         PyErr_SetString(UnpicklingError, "bad pickle data");

  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@CAKEIMA@bad?5pickle?5data?$AA@
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00023	e8 00 00 00 00	 call	 PyErr_SetString

; 245  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 31		 jmp	 SHORT $LN2@Pdata_pop
$LN1@Pdata_pop:

; 246  :     }
; 247  :     return self->data[--Py_SIZE(self)];

  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00031	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00035	48 ff c8	 dec	 rax
  00038	48 89 44 24 20	 mov	 QWORD PTR tv71[rsp], rax
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv71[rsp]
  00047	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00050	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv71[rsp]
  00059	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
$LN2@Pdata_pop:

; 248  : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
Pdata_pop ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EFFIKLCJ@n?$AA@				; `string'
PUBLIC	??_C@_1BG@ENDOEFBE@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAe?$AAe?$AAk?$AA?$AA@ ; `string'
EXTRN	PyObject_CallFunction:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_SkipConsumed DD imagerel _Unpickler_SkipConsumed
	DD	imagerel _Unpickler_SkipConsumed+182
	DD	imagerel $unwind$_Unpickler_SkipConsumed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_SkipConsumed DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n?$AA@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n?$AA@ DB 'n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@ENDOEFBE@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAe?$AAe?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@ENDOEFBE@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAe?$AAe?$AAk?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'p', 00H
	DB	'e', 00H, 'e', 00H, 'k', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Unpickler_SkipConsumed
_TEXT	SEGMENT
consumed$ = 32
r$21035 = 40
self$ = 64
_Unpickler_SkipConsumed PROC				; COMDAT

; 876  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 877  :     Py_ssize_t consumed = self->next_read_idx - self->prefetched_idx;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00013	48 8b 89 f8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+248]
  0001a	48 8b 80 f0 00
	00 00		 mov	 rax, QWORD PTR [rax+240]
  00021	48 2b c1	 sub	 rax, rcx
  00024	48 89 44 24 20	 mov	 QWORD PTR consumed$[rsp], rax

; 878  : 
; 879  :     if (consumed > 0) {

  00029	48 83 7c 24 20
	00		 cmp	 QWORD PTR consumed$[rsp], 0
  0002f	7e 7e		 jle	 SHORT $LN2@Unpickler_@2

; 880  :         PyObject *r;
; 881  :         assert(self->peek);  /* otherwise we did something wrong */

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00036	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  0003e	75 1c		 jne	 SHORT $LN5@Unpickler_@2
  00040	41 b8 71 03 00
	00		 mov	 r8d, 881		; 00000371H
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@ENDOEFBE@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAe?$AAe?$AAk?$AA?$AA@
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005a	33 c0		 xor	 eax, eax
$LN5@Unpickler_@2:

; 882  :         /* This makes an useless copy... */
; 883  :         r = PyObject_CallFunction(self->read, "n", consumed);

  0005c	4c 8b 44 24 20	 mov	 r8, QWORD PTR consumed$[rsp]
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EFFIKLCJ@n?$AA@
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006d	48 8b 88 00 01
	00 00		 mov	 rcx, QWORD PTR [rax+256]
  00074	e8 00 00 00 00	 call	 PyObject_CallFunction
  00079	48 89 44 24 28	 mov	 QWORD PTR r$21035[rsp], rax

; 884  :         if (r == NULL)

  0007e	48 83 7c 24 28
	00		 cmp	 QWORD PTR r$21035[rsp], 0
  00084	75 07		 jne	 SHORT $LN1@Unpickler_@2

; 885  :             return -1;

  00086	b8 ff ff ff ff	 mov	 eax, -1
  0008b	eb 24		 jmp	 SHORT $LN3@Unpickler_@2
$LN1@Unpickler_@2:

; 886  :         Py_DECREF(r);

  0008d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR r$21035[rsp]
  00092	e8 00 00 00 00	 call	 _Py_DecRef

; 887  :         self->prefetched_idx = self->next_read_idx;

  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000a1	48 8b 89 f0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+240]
  000a8	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx
$LN2@Unpickler_@2:

; 888  :     }
; 889  :     return 0;

  000af	33 c0		 xor	 eax, eax
$LN3@Unpickler_@2:

; 890  : }

  000b1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b5	c3		 ret	 0
_Unpickler_SkipConsumed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@OILLHPME@Ran?5out?5of?5input?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_Read DD imagerel _Unpickler_Read
	DD	imagerel _Unpickler_Read+288
	DD	imagerel $unwind$_Unpickler_Read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_Read DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BB@OILLHPME@Ran?5out?5of?5input?$AA@
CONST	SEGMENT
??_C@_0BB@OILLHPME@Ran?5out?5of?5input?$AA@ DB 'Ran out of input', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Unpickler_Read
_TEXT	SEGMENT
num_read$ = 32
self$ = 64
s$ = 72
n$ = 80
_Unpickler_Read PROC					; COMDAT

; 980  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 981  :     Py_ssize_t num_read;
; 982  : 
; 983  :     if (self->next_read_idx + n <= self->input_len) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 8b 80 f0 00
	00 00		 mov	 rax, QWORD PTR [rax+240]
  0001f	48 03 44 24 50	 add	 rax, QWORD PTR n$[rsp]
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00029	48 3b 81 e8 00
	00 00		 cmp	 rax, QWORD PTR [rcx+232]
  00030	7f 47		 jg	 SHORT $LN4@Unpickler_@3

; 984  :         *s = self->input_buffer + self->next_read_idx;

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00037	48 8b 80 d8 00
	00 00		 mov	 rax, QWORD PTR [rax+216]
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00043	48 03 81 f0 00
	00 00		 add	 rax, QWORD PTR [rcx+240]
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0004f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 985  :         self->next_read_idx += n;

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00057	48 8b 80 f0 00
	00 00		 mov	 rax, QWORD PTR [rax+240]
  0005e	48 03 44 24 50	 add	 rax, QWORD PTR n$[rsp]
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00068	48 89 81 f0 00
	00 00		 mov	 QWORD PTR [rcx+240], rax

; 986  :         return n;

  0006f	48 8b 44 24 50	 mov	 rax, QWORD PTR n$[rsp]
  00074	e9 a2 00 00 00	 jmp	 $LN5@Unpickler_@3
$LN4@Unpickler_@3:

; 987  :     }
; 988  :     if (!self->read) {

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0007e	48 83 b8 00 01
	00 00 00	 cmp	 QWORD PTR [rax+256], 0
  00086	75 1c		 jne	 SHORT $LN3@Unpickler_@3

; 989  :         PyErr_Format(PyExc_EOFError, "Ran out of input");

  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@OILLHPME@Ran?5out?5of?5input?$AA@
  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_EOFError
  00096	e8 00 00 00 00	 call	 PyErr_Format

; 990  :         return -1;

  0009b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000a2	eb 77		 jmp	 SHORT $LN5@Unpickler_@3
$LN3@Unpickler_@3:

; 991  :     }
; 992  :     num_read = _Unpickler_ReadFromFile(self, n);

  000a4	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$[rsp]
  000a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000ae	e8 00 00 00 00	 call	 _Unpickler_ReadFromFile
  000b3	48 89 44 24 20	 mov	 QWORD PTR num_read$[rsp], rax

; 993  :     if (num_read < 0)

  000b8	48 83 7c 24 20
	00		 cmp	 QWORD PTR num_read$[rsp], 0
  000be	7d 09		 jge	 SHORT $LN2@Unpickler_@3

; 994  :         return -1;

  000c0	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000c7	eb 52		 jmp	 SHORT $LN5@Unpickler_@3
$LN2@Unpickler_@3:

; 995  :     if (num_read < n) {

  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR n$[rsp]
  000ce	48 39 44 24 20	 cmp	 QWORD PTR num_read$[rsp], rax
  000d3	7d 1c		 jge	 SHORT $LN1@Unpickler_@3

; 996  :         PyErr_Format(PyExc_EOFError, "Ran out of input");

  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@OILLHPME@Ran?5out?5of?5input?$AA@
  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_EOFError
  000e3	e8 00 00 00 00	 call	 PyErr_Format

; 997  :         return -1;

  000e8	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000ef	eb 2a		 jmp	 SHORT $LN5@Unpickler_@3
$LN1@Unpickler_@3:

; 998  :     }
; 999  :     *s = self->input_buffer;

  000f1	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  000f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000fb	48 8b 89 d8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+216]
  00102	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1000 :     self->next_read_idx = n;

  00105	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0010a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR n$[rsp]
  0010f	48 89 88 f0 00
	00 00		 mov	 QWORD PTR [rax+240], rcx

; 1001 :     return n;

  00116	48 8b 44 24 50	 mov	 rax, QWORD PTR n$[rsp]
$LN5@Unpickler_@3:

; 1002 : }

  0011b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011f	c3		 ret	 0
_Unpickler_Read ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@DFOGLNFE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAe?$AAf?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BI@HFLJBJMA@_Unpickler_ReadFromFile?$AA@	; `string'
PUBLIC	??_C@_1CG@LABDKFKI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PyBytes_ConcatAndDel:PROC
EXTRN	PyExc_NotImplementedError:QWORD
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_ReadFromFile DD imagerel _Unpickler_ReadFromFile
	DD	imagerel _Unpickler_ReadFromFile+762
	DD	imagerel $unwind$_Unpickler_ReadFromFile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_ReadFromFile DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_1DE@DFOGLNFE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAe?$AAf?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@DFOGLNFE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAe?$AAf?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'p', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 't', 00H
	DB	'c', 00H, 'h', 00H, 'e', 00H, 'd', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HFLJBJMA@_Unpickler_ReadFromFile?$AA@
CONST	SEGMENT
??_C@_0BI@HFLJBJMA@_Unpickler_ReadFromFile?$AA@ DB '_Unpickler_ReadFromFi'
	DB	'le', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LABDKFKI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@LABDKFKI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'r', 00H
	DB	'e', 00H, 'a', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Unpickler_ReadFromFile
_TEXT	SEGMENT
prefetched_size$ = 48
data$ = 56
read_size$ = 64
len$21059 = 72
prefetched$21066 = 80
len$21065 = 88
_py_tmp$21078 = 96
self$ = 128
n$ = 136
_Unpickler_ReadFromFile PROC				; COMDAT

; 910  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 911  :     PyObject *data;
; 912  :     Py_ssize_t read_size, prefetched_size = 0;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR prefetched_size$[rsp], 0

; 913  : 
; 914  :     assert(self->read != NULL);

  00017	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001f	48 83 b8 00 01
	00 00 00	 cmp	 QWORD PTR [rax+256], 0
  00027	75 1c		 jne	 SHORT $LN19@Unpickler_@4
  00029	41 b8 92 03 00
	00		 mov	 r8d, 914		; 00000392H
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@LABDKFKI@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00043	33 c0		 xor	 eax, eax
$LN19@Unpickler_@4:

; 915  : 
; 916  :     if (_Unpickler_SkipConsumed(self) < 0)

  00045	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0004d	e8 00 00 00 00	 call	 _Unpickler_SkipConsumed
  00052	85 c0		 test	 eax, eax
  00054	7d 0c		 jge	 SHORT $LN16@Unpickler_@4

; 917  :         return -1;

  00056	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0005d	e9 93 02 00 00	 jmp	 $LN17@Unpickler_@4
$LN16@Unpickler_@4:

; 918  : 
; 919  :     if (n == READ_WHOLE_LINE)

  00062	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR READ_WHOLE_LINE
  00069	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR n$[rsp], rax
  00071	75 25		 jne	 SHORT $LN15@Unpickler_@4

; 920  :         data = PyObject_Call(self->readline, empty_tuple, NULL);

  00073	45 33 c0	 xor	 r8d, r8d
  00076	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR empty_tuple
  0007d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00085	48 8b 88 08 01
	00 00		 mov	 rcx, QWORD PTR [rax+264]
  0008c	e8 00 00 00 00	 call	 PyObject_Call
  00091	48 89 44 24 38	 mov	 QWORD PTR data$[rsp], rax

; 921  :     else {

  00096	eb 4c		 jmp	 SHORT $LN14@Unpickler_@4
$LN15@Unpickler_@4:

; 922  :         PyObject *len = PyLong_FromSsize_t(n);

  00098	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  000a0	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000a5	48 89 44 24 48	 mov	 QWORD PTR len$21059[rsp], rax

; 923  :         if (len == NULL)

  000aa	48 83 7c 24 48
	00		 cmp	 QWORD PTR len$21059[rsp], 0
  000b0	75 0c		 jne	 SHORT $LN13@Unpickler_@4

; 924  :             return -1;

  000b2	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000b9	e9 37 02 00 00	 jmp	 $LN17@Unpickler_@4
$LN13@Unpickler_@4:

; 925  :         data = _Unpickler_FastCall(self, self->read, len);

  000be	4c 8b 44 24 48	 mov	 r8, QWORD PTR len$21059[rsp]
  000c3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000cb	48 8b 90 00 01
	00 00		 mov	 rdx, QWORD PTR [rax+256]
  000d2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000da	e8 00 00 00 00	 call	 _Unpickler_FastCall
  000df	48 89 44 24 38	 mov	 QWORD PTR data$[rsp], rax
$LN14@Unpickler_@4:

; 926  :     }
; 927  :     if (data == NULL)

  000e4	48 83 7c 24 38
	00		 cmp	 QWORD PTR data$[rsp], 0
  000ea	75 0c		 jne	 SHORT $LN12@Unpickler_@4

; 928  :         return -1;

  000ec	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000f3	e9 fd 01 00 00	 jmp	 $LN17@Unpickler_@4
$LN12@Unpickler_@4:

; 929  : 
; 930  :     /* Prefetch some data without advancing the file pointer, if possible */
; 931  :     if (self->peek) {

  000f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00100	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  00108	0f 84 a8 01 00
	00		 je	 $LN11@Unpickler_@4

; 932  :         PyObject *len, *prefetched;
; 933  :         len = PyLong_FromSsize_t(PREFETCH);

  0010e	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00113	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00118	48 89 44 24 58	 mov	 QWORD PTR len$21065[rsp], rax

; 934  :         if (len == NULL) {

  0011d	48 83 7c 24 58
	00		 cmp	 QWORD PTR len$21065[rsp], 0
  00123	75 16		 jne	 SHORT $LN10@Unpickler_@4

; 935  :             Py_DECREF(data);

  00125	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  0012a	e8 00 00 00 00	 call	 _Py_DecRef

; 936  :             return -1;

  0012f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00136	e9 ba 01 00 00	 jmp	 $LN17@Unpickler_@4
$LN10@Unpickler_@4:

; 937  :         }
; 938  :         prefetched = _Unpickler_FastCall(self, self->peek, len);

  0013b	4c 8b 44 24 58	 mov	 r8, QWORD PTR len$21065[rsp]
  00140	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00148	48 8b 90 10 01
	00 00		 mov	 rdx, QWORD PTR [rax+272]
  0014f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00157	e8 00 00 00 00	 call	 _Unpickler_FastCall
  0015c	48 89 44 24 50	 mov	 QWORD PTR prefetched$21066[rsp], rax

; 939  :         if (prefetched == NULL) {

  00161	48 83 7c 24 50
	00		 cmp	 QWORD PTR prefetched$21066[rsp], 0
  00167	0f 85 b3 00 00
	00		 jne	 $LN9@Unpickler_@4

; 940  :             if (PyErr_ExceptionMatches(PyExc_NotImplementedError)) {

  0016d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00174	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00179	85 c0		 test	 eax, eax
  0017b	0f 84 84 00 00
	00		 je	 $LN8@Unpickler_@4

; 941  :                 /* peek() is probably not supported by the given file object */
; 942  :                 PyErr_Clear();

  00181	e8 00 00 00 00	 call	 PyErr_Clear
$LN7@Unpickler_@4:

; 943  :                 Py_CLEAR(self->peek);

  00186	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0018e	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  00196	74 65		 je	 SHORT $LN4@Unpickler_@4
  00198	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001a8	4c 8b 88 10 01
	00 00		 mov	 r9, QWORD PTR [rax+272]
  001af	41 b8 af 03 00
	00		 mov	 r8d, 943		; 000003afH
  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@HFLJBJMA@_Unpickler_ReadFromFile?$AA@
  001c3	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c8	85 c0		 test	 eax, eax
  001ca	75 31		 jne	 SHORT $LN4@Unpickler_@4
  001cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001d4	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  001db	48 89 44 24 60	 mov	 QWORD PTR _py_tmp$21078[rsp], rax
  001e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001e8	48 c7 80 10 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+272], 0
  001f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _py_tmp$21078[rsp]
  001f8	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@Unpickler_@4:
  001fd	33 c0		 xor	 eax, eax
  001ff	85 c0		 test	 eax, eax
  00201	75 83		 jne	 SHORT $LN7@Unpickler_@4

; 944  :             }
; 945  :             else {

  00203	eb 16		 jmp	 SHORT $LN3@Unpickler_@4
$LN8@Unpickler_@4:

; 946  :                 Py_DECREF(data);

  00205	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  0020a	e8 00 00 00 00	 call	 _Py_DecRef

; 947  :                 return -1;

  0020f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00216	e9 da 00 00 00	 jmp	 $LN17@Unpickler_@4
$LN3@Unpickler_@4:

; 948  :             }
; 949  :         }
; 950  :         else {

  0021b	e9 96 00 00 00	 jmp	 $LN2@Unpickler_@4
$LN9@Unpickler_@4:

; 951  :             assert(PyBytes_Check(prefetched));

  00220	48 8b 44 24 50	 mov	 rax, QWORD PTR prefetched$21066[rsp]
  00225	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00229	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0022f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00234	85 c0		 test	 eax, eax
  00236	75 1c		 jne	 SHORT $LN20@Unpickler_@4
  00238	41 b8 b7 03 00
	00		 mov	 r8d, 951		; 000003b7H
  0023e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00245	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@DFOGLNFE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAe?$AAf?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00252	33 c0		 xor	 eax, eax
$LN20@Unpickler_@4:

; 952  :             prefetched_size = PyBytes_GET_SIZE(prefetched);

  00254	48 8b 44 24 50	 mov	 rax, QWORD PTR prefetched$21066[rsp]
  00259	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0025d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00263	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00268	85 c0		 test	 eax, eax
  0026a	75 1c		 jne	 SHORT $LN21@Unpickler_@4
  0026c	41 b8 b8 03 00
	00		 mov	 r8d, 952		; 000003b8H
  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@DFOGLNFE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAe?$AAf?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00286	33 c0		 xor	 eax, eax
$LN21@Unpickler_@4:
  00288	48 8b 44 24 50	 mov	 rax, QWORD PTR prefetched$21066[rsp]
  0028d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00291	48 89 44 24 30	 mov	 QWORD PTR prefetched_size$[rsp], rax

; 953  :             PyBytes_ConcatAndDel(&data, prefetched);

  00296	48 8b 54 24 50	 mov	 rdx, QWORD PTR prefetched$21066[rsp]
  0029b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR data$[rsp]
  002a0	e8 00 00 00 00	 call	 PyBytes_ConcatAndDel

; 954  :             if (data == NULL)

  002a5	48 83 7c 24 38
	00		 cmp	 QWORD PTR data$[rsp], 0
  002ab	75 09		 jne	 SHORT $LN1@Unpickler_@4

; 955  :                 return -1;

  002ad	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  002b4	eb 3f		 jmp	 SHORT $LN17@Unpickler_@4
$LN1@Unpickler_@4:
$LN2@Unpickler_@4:
$LN11@Unpickler_@4:

; 956  :         }
; 957  :     }
; 958  : 
; 959  :     read_size = _Unpickler_SetStringInput(self, data) - prefetched_size;

  002b6	48 8b 54 24 38	 mov	 rdx, QWORD PTR data$[rsp]
  002bb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002c3	e8 00 00 00 00	 call	 _Unpickler_SetStringInput
  002c8	48 2b 44 24 30	 sub	 rax, QWORD PTR prefetched_size$[rsp]
  002cd	48 89 44 24 40	 mov	 QWORD PTR read_size$[rsp], rax

; 960  :     Py_DECREF(data);

  002d2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  002d7	e8 00 00 00 00	 call	 _Py_DecRef

; 961  :     self->prefetched_idx = read_size;

  002dc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR read_size$[rsp]
  002e9	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 962  :     return read_size;

  002f0	48 8b 44 24 40	 mov	 rax, QWORD PTR read_size$[rsp]
$LN17@Unpickler_@4:

; 963  : }

  002f5	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002f9	c3		 ret	 0
_Unpickler_ReadFromFile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@PFNKPMMG@_Unpickler_FastCall?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_FastCall DD imagerel _Unpickler_FastCall
	DD	imagerel _Unpickler_FastCall+329
	DD	imagerel $unwind$_Unpickler_FastCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_FastCall DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0BE@PFNKPMMG@_Unpickler_FastCall?$AA@
CONST	SEGMENT
??_C@_0BE@PFNKPMMG@_Unpickler_FastCall?$AA@ DB '_Unpickler_FastCall', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Unpickler_FastCall
_TEXT	SEGMENT
result$ = 48
_py_tmp$21016 = 56
tv67 = 64
self$ = 96
func$ = 104
arg$ = 112
_Unpickler_FastCall PROC				; COMDAT

; 847  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 848  :     PyObject *result = NULL;

  00013	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0
$LN19@Unpickler_@5:

; 849  : 
; 850  :     ARG_TUP(self, arg);

  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00021	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00026	75 25		 jne	 SHORT $LN15@Unpickler_@5
  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	e8 00 00 00 00	 call	 PyTuple_New
  00032	48 89 44 24 40	 mov	 QWORD PTR tv67[rsp], rax
  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv67[rsp]
  00041	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx
  00045	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv67[rsp], 0
  0004b	74 3c		 je	 SHORT $LN16@Unpickler_@5
$LN15@Unpickler_@5:
$LN14@Unpickler_@5:
  0004d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00052	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00056	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0005b	74 12		 je	 SHORT $LN11@Unpickler_@5
  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00062	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00066	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0006a	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@Unpickler_@5:
  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 d8		 jne	 SHORT $LN14@Unpickler_@5
  00075	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0007a	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR arg$[rsp]
  00083	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
  00087	eb 0a		 jmp	 SHORT $LN10@Unpickler_@5
$LN16@Unpickler_@5:
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR arg$[rsp]
  0008e	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@Unpickler_@5:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 83		 jne	 SHORT $LN19@Unpickler_@5

; 851  :     if (self->arg) {

  00099	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0009e	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  000a3	0f 84 96 00 00
	00		 je	 $LN9@Unpickler_@5

; 852  :         result = PyObject_Call(func, self->arg, NULL);

  000a9	45 33 c0	 xor	 r8d, r8d
  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000b1	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  000b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR func$[rsp]
  000ba	e8 00 00 00 00	 call	 PyObject_Call
  000bf	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$LN8@Unpickler_@5:

; 853  :         FREE_ARG_TUP(self);

  000c4	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000c9	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000cd	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  000d2	7e 65		 jle	 SHORT $LN5@Unpickler_@5
$LN4@Unpickler_@5:
  000d4	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000d9	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  000de	74 53		 je	 SHORT $LN1@Unpickler_@5
  000e0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e8	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000ed	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  000f1	41 b8 55 03 00
	00		 mov	 r8d, 853		; 00000355H
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@PFNKPMMG@_Unpickler_FastCall?$AA@
  00105	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010a	85 c0		 test	 eax, eax
  0010c	75 25		 jne	 SHORT $LN1@Unpickler_@5
  0010e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00113	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00117	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$21016[rsp], rax
  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00121	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
  00129	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$21016[rsp]
  0012e	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Unpickler_@5:
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 9b		 jne	 SHORT $LN4@Unpickler_@5
$LN5@Unpickler_@5:
  00139	33 c0		 xor	 eax, eax
  0013b	85 c0		 test	 eax, eax
  0013d	75 85		 jne	 SHORT $LN8@Unpickler_@5
$LN9@Unpickler_@5:

; 854  :     }
; 855  :     return result;

  0013f	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 856  : }

  00144	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00148	c3		 ret	 0
_Unpickler_FastCall ENDP
_TEXT	ENDS
EXTRN	PyObject_GetBuffer:PROC
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_SetStringInput DD imagerel _Unpickler_SetStringInput
	DD	imagerel _Unpickler_SetStringInput+196
	DD	imagerel $unwind$_Unpickler_SetStringInput
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_SetStringInput DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Unpickler_SetStringInput
_TEXT	SEGMENT
self$ = 48
input$ = 56
_Unpickler_SetStringInput PROC				; COMDAT

; 862  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 863  :     if (self->buffer.buf != NULL)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	74 13		 je	 SHORT $LN2@Unpickler_@6

; 864  :         PyBuffer_Release(&self->buffer);

  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00022	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@Unpickler_@6:

; 865  :     if (PyObject_GetBuffer(input, &self->buffer, PyBUF_CONTIG_RO) < 0)

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00035	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  0003b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00041	48 8b d0	 mov	 rdx, rax
  00044	48 8b 4c 24 38	 mov	 rcx, QWORD PTR input$[rsp]
  00049	e8 00 00 00 00	 call	 PyObject_GetBuffer
  0004e	85 c0		 test	 eax, eax
  00050	7d 09		 jge	 SHORT $LN1@Unpickler_@6

; 866  :         return -1;

  00052	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00059	eb 64		 jmp	 SHORT $LN3@Unpickler_@6
$LN1@Unpickler_@6:

; 867  :     self->input_buffer = self->buffer.buf;

  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00060	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00065	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  0006c	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 868  :     self->input_len = self->buffer.len;

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007d	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00084	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 869  :     self->next_read_idx = 0;

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00090	48 c7 80 f0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+240], 0

; 870  :     self->prefetched_idx = self->input_len;

  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  000a5	48 8b 89 e8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+232]
  000ac	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 871  :     return self->input_len;

  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000b8	48 8b 80 e8 00
	00 00		 mov	 rax, QWORD PTR [rax+232]
$LN3@Unpickler_@6:

; 872  : }

  000bf	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c3	c3		 ret	 0
_Unpickler_SetStringInput ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_none DD imagerel load_none
	DD	imagerel load_none+66
	DD	imagerel $unwind$load_none
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_none DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_none
_TEXT	SEGMENT
self$ = 48
load_none PROC						; COMDAT

; 3918 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@load_none:

; 3919 :     PDATA_APPEND(self->stack, Py_None, -1);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00010	e8 00 00 00 00	 call	 _Py_IncRef
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00021	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00025	e8 00 00 00 00	 call	 Pdata_push
  0002a	85 c0		 test	 eax, eax
  0002c	7d 07		 jge	 SHORT $LN1@load_none
  0002e	b8 ff ff ff ff	 mov	 eax, -1
  00033	eb 08		 jmp	 SHORT $LN5@load_none
$LN1@load_none:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 ce		 jne	 SHORT $LN4@load_none

; 3920 :     return 0;

  0003b	33 c0		 xor	 eax, eax
$LN5@load_none:

; 3921 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
load_none ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_push DD imagerel Pdata_push
	DD	imagerel Pdata_push+110
	DD	imagerel $unwind$Pdata_push
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_push DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Pdata_push
_TEXT	SEGMENT
self$ = 48
obj$ = 56
Pdata_push PROC						; COMDAT

; 253  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 254  :     if (Py_SIZE(self) == self->allocated && Pdata_grow(self) < 0) {

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00018	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0001c	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00020	75 15		 jne	 SHORT $LN1@Pdata_push
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00027	e8 00 00 00 00	 call	 Pdata_grow
  0002c	85 c0		 test	 eax, eax
  0002e	7d 07		 jge	 SHORT $LN1@Pdata_push

; 255  :         return -1;

  00030	b8 ff ff ff ff	 mov	 eax, -1
  00035	eb 32		 jmp	 SHORT $LN2@Pdata_push
$LN1@Pdata_push:

; 256  :     }
; 257  :     self->data[Py_SIZE(self)++] = obj;

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00045	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00049	48 8b 54 24 38	 mov	 rdx, QWORD PTR obj$[rsp]
  0004e	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00057	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0005b	48 ff c0	 inc	 rax
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00063	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 258  :     return 0;

  00067	33 c0		 xor	 eax, eax
$LN2@Pdata_push:

; 259  : }

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
Pdata_push ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugRealloc:PROC
EXTRN	_PxMem_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_grow DD imagerel Pdata_grow
	DD	imagerel Pdata_grow+254
	DD	imagerel $unwind$Pdata_grow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_grow DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Pdata_grow
_TEXT	SEGMENT
allocated$ = 32
new_allocated$ = 40
data$ = 48
tv82 = 56
self$ = 80
Pdata_grow PROC						; COMDAT

; 211  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 212  :     PyObject **data = self->data;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00012	48 89 44 24 30	 mov	 QWORD PTR data$[rsp], rax

; 213  :     Py_ssize_t allocated = self->allocated;

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001c	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00020	48 89 44 24 20	 mov	 QWORD PTR allocated$[rsp], rax

; 214  :     Py_ssize_t new_allocated;
; 215  : 
; 216  :     new_allocated = (allocated >> 3) + 6;

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR allocated$[rsp]
  0002a	48 c1 f8 03	 sar	 rax, 3
  0002e	48 83 c0 06	 add	 rax, 6
  00032	48 89 44 24 28	 mov	 QWORD PTR new_allocated$[rsp], rax

; 217  :     /* check for integer overflow */
; 218  :     if (new_allocated > PY_SSIZE_T_MAX - allocated)

  00037	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00041	48 2b 44 24 20	 sub	 rax, QWORD PTR allocated$[rsp]
  00046	48 39 44 24 28	 cmp	 QWORD PTR new_allocated$[rsp], rax
  0004b	7e 05		 jle	 SHORT $LN3@Pdata_grow

; 219  :         goto nomemory;

  0004d	e9 9d 00 00 00	 jmp	 $nomemory$20506
$LN3@Pdata_grow:

; 220  :     new_allocated += allocated;

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR allocated$[rsp]
  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_allocated$[rsp]
  0005c	48 03 c8	 add	 rcx, rax
  0005f	48 8b c1	 mov	 rax, rcx
  00062	48 89 44 24 28	 mov	 QWORD PTR new_allocated$[rsp], rax

; 221  :     if (new_allocated > (PY_SSIZE_T_MAX / sizeof(PyObject *)))

  00067	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00071	48 39 44 24 28	 cmp	 QWORD PTR new_allocated$[rsp], rax
  00076	76 02		 jbe	 SHORT $LN2@Pdata_grow

; 222  :         goto nomemory;

  00078	eb 75		 jmp	 SHORT $nomemory$20506
$LN2@Pdata_grow:

; 223  :     data = PyMem_REALLOC(data, new_allocated * sizeof(PyObject *));

  0007a	e8 00 00 00 00	 call	 _Py_PXCTX
  0007f	85 c0		 test	 eax, eax
  00081	74 1d		 je	 SHORT $LN6@Pdata_grow
  00083	48 8b 44 24 28	 mov	 rax, QWORD PTR new_allocated$[rsp]
  00088	48 c1 e0 03	 shl	 rax, 3
  0008c	48 8b d0	 mov	 rdx, rax
  0008f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00094	e8 00 00 00 00	 call	 _PxMem_Realloc
  00099	48 89 44 24 38	 mov	 QWORD PTR tv82[rsp], rax
  0009e	eb 1b		 jmp	 SHORT $LN7@Pdata_grow
$LN6@Pdata_grow:
  000a0	48 8b 44 24 28	 mov	 rax, QWORD PTR new_allocated$[rsp]
  000a5	48 c1 e0 03	 shl	 rax, 3
  000a9	48 8b d0	 mov	 rdx, rax
  000ac	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  000b1	e8 00 00 00 00	 call	 _PyMem_DebugRealloc
  000b6	48 89 44 24 38	 mov	 QWORD PTR tv82[rsp], rax
$LN7@Pdata_grow:
  000bb	48 8b 44 24 38	 mov	 rax, QWORD PTR tv82[rsp]
  000c0	48 89 44 24 30	 mov	 QWORD PTR data$[rsp], rax

; 224  :     if (data == NULL)

  000c5	48 83 7c 24 30
	00		 cmp	 QWORD PTR data$[rsp], 0
  000cb	75 02		 jne	 SHORT $LN1@Pdata_grow

; 225  :         goto nomemory;

  000cd	eb 20		 jmp	 SHORT $nomemory$20506
$LN1@Pdata_grow:

; 226  : 
; 227  :     self->data = data;

  000cf	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  000d9	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 228  :     self->allocated = new_allocated;

  000dd	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000e2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_allocated$[rsp]
  000e7	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 229  :     return 0;

  000eb	33 c0		 xor	 eax, eax
  000ed	eb 0a		 jmp	 SHORT $LN4@Pdata_grow
$nomemory$20506:

; 230  : 
; 231  :   nomemory:
; 232  :     PyErr_NoMemory();

  000ef	e8 00 00 00 00	 call	 PyErr_NoMemory

; 233  :     return -1;

  000f4	b8 ff ff ff ff	 mov	 eax, -1
$LN4@Pdata_grow:

; 234  : }

  000f9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fd	c3		 ret	 0
Pdata_grow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@BGNJIDPO@could?5not?5convert?5string?5to?5int?$AA@ ; `string'
EXTRN	PyBool_FromLong:PROC
EXTRN	PyLong_FromString:PROC
EXTRN	__imp_strtol:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_int DD imagerel load_int
	DD	imagerel load_int+329
	DD	imagerel $unwind$load_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_int DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0CA@BGNJIDPO@could?5not?5convert?5string?5to?5int?$AA@
CONST	SEGMENT
??_C@_0CA@BGNJIDPO@could?5not?5convert?5string?5to?5int?$AA@ DB 'could no'
	DB	't convert string to int', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_int
_TEXT	SEGMENT
value$ = 32
x$ = 40
endptr$ = 48
s$ = 56
len$ = 64
self$ = 96
load_int PROC						; COMDAT

; 3932 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3933 :     PyObject *value;
; 3934 :     char *endptr, *s;
; 3935 :     Py_ssize_t len;
; 3936 :     long x;
; 3937 : 
; 3938 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00009	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 _Unpickler_Readline
  00018	48 89 44 24 40	 mov	 QWORD PTR len$[rsp], rax
  0001d	48 83 7c 24 40
	00		 cmp	 QWORD PTR len$[rsp], 0
  00023	7d 0a		 jge	 SHORT $LN15@load_int

; 3939 :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 15 01 00 00	 jmp	 $LN16@load_int
$LN15@load_int:

; 3940 :     if (len < 2)

  0002f	48 83 7c 24 40
	02		 cmp	 QWORD PTR len$[rsp], 2
  00035	7d 0a		 jge	 SHORT $LN14@load_int

; 3941 :         return bad_readline();

  00037	e8 00 00 00 00	 call	 bad_readline
  0003c	e9 03 01 00 00	 jmp	 $LN16@load_int
$LN14@load_int:

; 3942 : 
; 3943 :     errno = 0;

  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00047	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3944 :     /* XXX: Should the base argument of strtol() be explicitly set to 10?
; 3945 :        XXX(avassalotti): Should this uses PyOS_strtol()? */
; 3946 :     x = strtol(s, &endptr, 0);

  0004d	45 33 c0	 xor	 r8d, r8d
  00050	48 8d 54 24 30	 lea	 rdx, QWORD PTR endptr$[rsp]
  00055	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  00060	89 44 24 28	 mov	 DWORD PTR x$[rsp], eax

; 3947 : 
; 3948 :     if (errno || (*endptr != '\n' && *endptr != '\0')) {

  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0006a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0006d	75 19		 jne	 SHORT $LN12@load_int
  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR endptr$[rsp]
  00074	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00077	83 f8 0a	 cmp	 eax, 10
  0007a	74 50		 je	 SHORT $LN13@load_int
  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR endptr$[rsp]
  00081	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00084	85 c0		 test	 eax, eax
  00086	74 44		 je	 SHORT $LN13@load_int
$LN12@load_int:

; 3949 :         /* Hm, maybe we've got something long.  Let's try reading
; 3950 :          * it as a Python int object. */
; 3951 :         errno = 0;

  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3952 :         /* XXX: Same thing about the base here. */
; 3953 :         value = PyLong_FromString(s, NULL, 0);

  00094	45 33 c0	 xor	 r8d, r8d
  00097	33 d2		 xor	 edx, edx
  00099	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0009e	e8 00 00 00 00	 call	 PyLong_FromString
  000a3	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 3954 :         if (value == NULL) {

  000a8	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  000ae	75 1a		 jne	 SHORT $LN11@load_int

; 3955 :             PyErr_SetString(PyExc_ValueError,
; 3956 :                             "could not convert string to int");

  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@BGNJIDPO@could?5not?5convert?5string?5to?5int?$AA@
  000b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000be	e8 00 00 00 00	 call	 PyErr_SetString

; 3957 :             return -1;

  000c3	b8 ff ff ff ff	 mov	 eax, -1
  000c8	eb 7a		 jmp	 SHORT $LN16@load_int
$LN11@load_int:

; 3958 :         }
; 3959 :     }
; 3960 :     else {

  000ca	eb 52		 jmp	 SHORT $LN10@load_int
$LN13@load_int:

; 3961 :         if (len == 3 && (x == 0 || x == 1)) {

  000cc	48 83 7c 24 40
	03		 cmp	 QWORD PTR len$[rsp], 3
  000d2	75 2d		 jne	 SHORT $LN9@load_int
  000d4	83 7c 24 28 00	 cmp	 DWORD PTR x$[rsp], 0
  000d9	74 07		 je	 SHORT $LN8@load_int
  000db	83 7c 24 28 01	 cmp	 DWORD PTR x$[rsp], 1
  000e0	75 1f		 jne	 SHORT $LN9@load_int
$LN8@load_int:

; 3962 :             if ((value = PyBool_FromLong(x)) == NULL)

  000e2	8b 4c 24 28	 mov	 ecx, DWORD PTR x$[rsp]
  000e6	e8 00 00 00 00	 call	 PyBool_FromLong
  000eb	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  000f0	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  000f6	75 07		 jne	 SHORT $LN7@load_int

; 3963 :                 return -1;

  000f8	b8 ff ff ff ff	 mov	 eax, -1
  000fd	eb 45		 jmp	 SHORT $LN16@load_int
$LN7@load_int:

; 3964 :         }
; 3965 :         else {

  000ff	eb 1d		 jmp	 SHORT $LN6@load_int
$LN9@load_int:

; 3966 :             if ((value = PyLong_FromLong(x)) == NULL)

  00101	8b 4c 24 28	 mov	 ecx, DWORD PTR x$[rsp]
  00105	e8 00 00 00 00	 call	 PyLong_FromLong
  0010a	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  0010f	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  00115	75 07		 jne	 SHORT $LN5@load_int

; 3967 :                 return -1;

  00117	b8 ff ff ff ff	 mov	 eax, -1
  0011c	eb 26		 jmp	 SHORT $LN16@load_int
$LN5@load_int:
$LN6@load_int:
$LN10@load_int:
$LN4@load_int:

; 3968 :         }
; 3969 :     }
; 3970 : 
; 3971 :     PDATA_PUSH(self->stack, value, -1);

  0011e	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00123	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00128	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0012c	e8 00 00 00 00	 call	 Pdata_push
  00131	85 c0		 test	 eax, eax
  00133	7d 07		 jge	 SHORT $LN1@load_int
  00135	b8 ff ff ff ff	 mov	 eax, -1
  0013a	eb 08		 jmp	 SHORT $LN16@load_int
$LN1@load_int:
  0013c	33 c0		 xor	 eax, eax
  0013e	85 c0		 test	 eax, eax
  00140	75 dc		 jne	 SHORT $LN4@load_int

; 3972 :     return 0;

  00142	33 c0		 xor	 eax, eax
$LN16@load_int:

; 3973 : }

  00144	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00148	c3		 ret	 0
load_int ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_Readline DD imagerel _Unpickler_Readline
	DD	imagerel _Unpickler_Readline+405
	DD	imagerel $unwind$_Unpickler_Readline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_Readline DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Unpickler_Readline
_TEXT	SEGMENT
i$ = 32
num_read$ = 40
line_start$21133 = 48
self$ = 80
result$ = 88
_Unpickler_Readline PROC				; COMDAT

; 1025 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1026 :     Py_ssize_t i, num_read;
; 1027 : 
; 1028 :     for (i = self->next_read_idx; i < self->input_len; i++) {

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 80 f0 00
	00 00		 mov	 rax, QWORD PTR [rax+240]
  0001a	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  0001f	eb 0d		 jmp	 SHORT $LN6@Unpickler_@7
$LN5@Unpickler_@7:
  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00026	48 ff c0	 inc	 rax
  00029	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@Unpickler_@7:
  0002e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00033	48 8b 80 e8 00
	00 00		 mov	 rax, QWORD PTR [rax+232]
  0003a	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0003f	0f 8d 8d 00 00
	00		 jge	 $LN4@Unpickler_@7

; 1029 :         if (self->input_buffer[i] == '\n') {

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 80 d8 00
	00 00		 mov	 rax, QWORD PTR [rax+216]
  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00056	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0005a	83 f8 0a	 cmp	 eax, 10
  0005d	75 6e		 jne	 SHORT $LN3@Unpickler_@7

; 1030 :             char *line_start = self->input_buffer + self->next_read_idx;

  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00064	48 8b 80 d8 00
	00 00		 mov	 rax, QWORD PTR [rax+216]
  0006b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00070	48 03 81 f0 00
	00 00		 add	 rax, QWORD PTR [rcx+240]
  00077	48 89 44 24 30	 mov	 QWORD PTR line_start$21133[rsp], rax

; 1031 :             num_read = i - self->next_read_idx + 1;

  0007c	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00081	48 8b 80 f0 00
	00 00		 mov	 rax, QWORD PTR [rax+240]
  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0008d	48 2b c8	 sub	 rcx, rax
  00090	48 8b c1	 mov	 rax, rcx
  00093	48 ff c0	 inc	 rax
  00096	48 89 44 24 28	 mov	 QWORD PTR num_read$[rsp], rax

; 1032 :             self->next_read_idx = i + 1;

  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000a0	48 ff c0	 inc	 rax
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000a8	48 89 81 f0 00
	00 00		 mov	 QWORD PTR [rcx+240], rax

; 1033 :             return _Unpickler_CopyLine(self, line_start, num_read, result);

  000af	4c 8b 4c 24 58	 mov	 r9, QWORD PTR result$[rsp]
  000b4	4c 8b 44 24 28	 mov	 r8, QWORD PTR num_read$[rsp]
  000b9	48 8b 54 24 30	 mov	 rdx, QWORD PTR line_start$21133[rsp]
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000c3	e8 00 00 00 00	 call	 _Unpickler_CopyLine
  000c8	e9 c3 00 00 00	 jmp	 $LN7@Unpickler_@7
$LN3@Unpickler_@7:

; 1034 :         }
; 1035 :     }

  000cd	e9 4f ff ff ff	 jmp	 $LN5@Unpickler_@7
$LN4@Unpickler_@7:

; 1036 :     if (self->read) {

  000d2	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d7	48 83 b8 00 01
	00 00 00	 cmp	 QWORD PTR [rax+256], 0
  000df	74 5d		 je	 SHORT $LN2@Unpickler_@7

; 1037 :         num_read = _Unpickler_ReadFromFile(self, READ_WHOLE_LINE);

  000e1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR READ_WHOLE_LINE
  000e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000ed	e8 00 00 00 00	 call	 _Unpickler_ReadFromFile
  000f2	48 89 44 24 28	 mov	 QWORD PTR num_read$[rsp], rax

; 1038 :         if (num_read < 0)

  000f7	48 83 7c 24 28
	00		 cmp	 QWORD PTR num_read$[rsp], 0
  000fd	7d 0c		 jge	 SHORT $LN1@Unpickler_@7

; 1039 :             return -1;

  000ff	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00106	e9 85 00 00 00	 jmp	 $LN7@Unpickler_@7
$LN1@Unpickler_@7:

; 1040 :         self->next_read_idx = num_read;

  0010b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00110	48 8b 4c 24 28	 mov	 rcx, QWORD PTR num_read$[rsp]
  00115	48 89 88 f0 00
	00 00		 mov	 QWORD PTR [rax+240], rcx

; 1041 :         return _Unpickler_CopyLine(self, self->input_buffer, num_read, result);

  0011c	4c 8b 4c 24 58	 mov	 r9, QWORD PTR result$[rsp]
  00121	4c 8b 44 24 28	 mov	 r8, QWORD PTR num_read$[rsp]
  00126	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0012b	48 8b 90 d8 00
	00 00		 mov	 rdx, QWORD PTR [rax+216]
  00132	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00137	e8 00 00 00 00	 call	 _Unpickler_CopyLine
  0013c	eb 52		 jmp	 SHORT $LN7@Unpickler_@7
$LN2@Unpickler_@7:

; 1042 :     }
; 1043 : 
; 1044 :     /* If we get here, we've run off the end of the input string. Return the
; 1045 :        remaining string and let the caller figure it out. */
; 1046 :     *result = self->input_buffer + self->next_read_idx;

  0013e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00143	48 8b 80 d8 00
	00 00		 mov	 rax, QWORD PTR [rax+216]
  0014a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0014f	48 03 81 f0 00
	00 00		 add	 rax, QWORD PTR [rcx+240]
  00156	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  0015b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1047 :     num_read = i - self->next_read_idx;

  0015e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00163	48 8b 80 f0 00
	00 00		 mov	 rax, QWORD PTR [rax+240]
  0016a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0016f	48 2b c8	 sub	 rcx, rax
  00172	48 8b c1	 mov	 rax, rcx
  00175	48 89 44 24 28	 mov	 QWORD PTR num_read$[rsp], rax

; 1048 :     self->next_read_idx = i;

  0017a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0017f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00184	48 89 88 f0 00
	00 00		 mov	 QWORD PTR [rax+240], rcx

; 1049 :     return num_read;

  0018b	48 8b 44 24 28	 mov	 rax, QWORD PTR num_read$[rsp]
$LN7@Unpickler_@7:

; 1050 : }

  00190	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00194	c3		 ret	 0
_Unpickler_Readline ENDP
_TEXT	ENDS
EXTRN	PyMem_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_CopyLine DD imagerel _Unpickler_CopyLine
	DD	imagerel _Unpickler_CopyLine+160
	DD	imagerel $unwind$_Unpickler_CopyLine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_CopyLine DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Unpickler_CopyLine
_TEXT	SEGMENT
input_line$ = 32
self$ = 64
line$ = 72
len$ = 80
result$ = 88
_Unpickler_CopyLine PROC				; COMDAT

; 1007 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1008 :     char *input_line = PyMem_Realloc(self->input_line, len + 1);

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  0001d	48 ff c0	 inc	 rax
  00020	48 8b d0	 mov	 rdx, rax
  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00028	48 8b 88 e0 00
	00 00		 mov	 rcx, QWORD PTR [rax+224]
  0002f	e8 00 00 00 00	 call	 PyMem_Realloc
  00034	48 89 44 24 20	 mov	 QWORD PTR input_line$[rsp], rax

; 1009 :     if (input_line == NULL)

  00039	48 83 7c 24 20
	00		 cmp	 QWORD PTR input_line$[rsp], 0
  0003f	75 09		 jne	 SHORT $LN1@Unpickler_@8

; 1010 :         return -1;

  00041	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00048	eb 51		 jmp	 SHORT $LN2@Unpickler_@8
$LN1@Unpickler_@8:

; 1011 : 
; 1012 :     memcpy(input_line, line, len);

  0004a	4c 8b 44 24 50	 mov	 r8, QWORD PTR len$[rsp]
  0004f	48 8b 54 24 48	 mov	 rdx, QWORD PTR line$[rsp]
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input_line$[rsp]
  00059	e8 00 00 00 00	 call	 memcpy

; 1013 :     input_line[len] = '\0';

  0005e	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input_line$[rsp]
  00068	48 03 c8	 add	 rcx, rax
  0006b	48 8b c1	 mov	 rax, rcx
  0006e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1014 :     self->input_line = input_line;

  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input_line$[rsp]
  0007b	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 1015 :     *result = self->input_line;

  00082	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0008c	48 8b 89 e0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+224]
  00093	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1016 :     return len;

  00096	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
$LN2@Unpickler_@8:

; 1017 : }

  0009b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009f	c3		 ret	 0
_Unpickler_CopyLine ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@FOBFDGN@pickle?5data?5was?5truncated?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bad_readline DD imagerel bad_readline
	DD	imagerel bad_readline+33
	DD	imagerel $unwind$bad_readline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bad_readline DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BK@FOBFDGN@pickle?5data?5was?5truncated?$AA@
CONST	SEGMENT
??_C@_0BK@FOBFDGN@pickle?5data?5was?5truncated?$AA@ DB 'pickle data was t'
	DB	'runcated', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bad_readline
_TEXT	SEGMENT
bad_readline PROC					; COMDAT

; 3925 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3926 :     PyErr_SetString(UnpicklingError, "pickle data was truncated");

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@FOBFDGN@pickle?5data?5was?5truncated?$AA@
  0000b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 3927 :     return -1;

  00017	b8 ff ff ff ff	 mov	 eax, -1

; 3928 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
bad_readline ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FE@FHDANNBG@?$AAb?$AAo?$AAo?$AAl?$AAe?$AAa?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAT?$AAr?$AAu?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAo?$AAo?$AAl?$AAe?$AAa?$AAn?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_bool DD imagerel load_bool
	DD	imagerel load_bool+123
	DD	imagerel $unwind$load_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_bool DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_1FE@FHDANNBG@?$AAb?$AAo?$AAo?$AAl?$AAe?$AAa?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAT?$AAr?$AAu?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAo?$AAo?$AAl?$AAe?$AAa?$AAn?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1FE@FHDANNBG@?$AAb?$AAo?$AAo?$AAl?$AAe?$AAa?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAT?$AAr?$AAu?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAo?$AAo?$AAl?$AAe?$AAa?$AAn?$AA?5?$AA?$DN?$AA?$DN@ DB 'b'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'n', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'y', 00H, '_'
	DB	00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'b', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 'e'
	DB	00H, 'a', 00H, 'n', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'P', 00H, 'y', 00H, '_', 00H, 'F', 00H, 'a', 00H, 'l', 00H, 's'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_bool
_TEXT	SEGMENT
self$ = 48
boolean$ = 56
load_bool PROC						; COMDAT

; 3977 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3978 :     assert(boolean == Py_True || boolean == Py_False);

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00015	48 39 44 24 38	 cmp	 QWORD PTR boolean$[rsp], rax
  0001a	74 2a		 je	 SHORT $LN7@load_bool
  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00023	48 39 44 24 38	 cmp	 QWORD PTR boolean$[rsp], rax
  00028	74 1c		 je	 SHORT $LN7@load_bool
  0002a	41 b8 8a 0f 00
	00		 mov	 r8d, 3978		; 00000f8aH
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@FHDANNBG@?$AAb?$AAo?$AAo?$AAl?$AAe?$AAa?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAT?$AAr?$AAu?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAo?$AAo?$AAl?$AAe?$AAa?$AAn?$AA?5?$AA?$DN?$AA?$DN@
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00044	33 c0		 xor	 eax, eax
$LN7@load_bool:
$LN4@load_bool:

; 3979 :     PDATA_APPEND(self->stack, boolean, -1);

  00046	48 8b 4c 24 38	 mov	 rcx, QWORD PTR boolean$[rsp]
  0004b	e8 00 00 00 00	 call	 _Py_IncRef
  00050	48 8b 54 24 38	 mov	 rdx, QWORD PTR boolean$[rsp]
  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0005a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0005e	e8 00 00 00 00	 call	 Pdata_push
  00063	85 c0		 test	 eax, eax
  00065	7d 07		 jge	 SHORT $LN1@load_bool
  00067	b8 ff ff ff ff	 mov	 eax, -1
  0006c	eb 08		 jmp	 SHORT $LN5@load_bool
$LN1@load_bool:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d2		 jne	 SHORT $LN4@load_bool

; 3980 :     return 0;

  00074	33 c0		 xor	 eax, eax
$LN5@load_bool:

; 3981 : }

  00076	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007a	c3		 ret	 0
load_bool ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binint DD imagerel load_binint
	DD	imagerel load_binint+68
	DD	imagerel $unwind$load_binint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binint DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_binint
_TEXT	SEGMENT
s$ = 32
self$ = 64
load_binint PROC					; COMDAT

; 4049 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4050 :     char *s;
; 4051 : 
; 4052 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00009	41 b8 04 00 00
	00		 mov	 r8d, 4
  0000f	48 8d 54 24 20	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 07		 jge	 SHORT $LN1@load_binin

; 4053 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	eb 15		 jmp	 SHORT $LN2@load_binin
$LN1@load_binin:

; 4054 : 
; 4055 :     return load_binintx(self, s, 4);

  0002a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00030	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0003a	e8 00 00 00 00	 call	 load_binintx
$LN2@load_binin:

; 4056 : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
load_binint ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binintx DD imagerel load_binintx
	DD	imagerel load_binintx+109
	DD	imagerel $unwind$load_binintx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binintx DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_binintx
_TEXT	SEGMENT
value$ = 32
x$ = 40
self$ = 64
s$ = 72
size$ = 80
load_binintx PROC					; COMDAT

; 4034 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4035 :     PyObject *value;
; 4036 :     long x;
; 4037 : 
; 4038 :     x = calc_binint(s, size);

  00013	8b 54 24 50	 mov	 edx, DWORD PTR size$[rsp]
  00017	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 calc_binint
  00021	89 44 24 28	 mov	 DWORD PTR x$[rsp], eax

; 4039 : 
; 4040 :     if ((value = PyLong_FromLong(x)) == NULL)

  00025	8b 4c 24 28	 mov	 ecx, DWORD PTR x$[rsp]
  00029	e8 00 00 00 00	 call	 PyLong_FromLong
  0002e	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00033	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  00039	75 07		 jne	 SHORT $LN5@load_binin@2

; 4041 :         return -1;

  0003b	b8 ff ff ff ff	 mov	 eax, -1
  00040	eb 26		 jmp	 SHORT $LN6@load_binin@2
$LN5@load_binin@2:
$LN4@load_binin@2:

; 4042 : 
; 4043 :     PDATA_PUSH(self->stack, value, -1);

  00042	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004c	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00050	e8 00 00 00 00	 call	 Pdata_push
  00055	85 c0		 test	 eax, eax
  00057	7d 07		 jge	 SHORT $LN1@load_binin@2
  00059	b8 ff ff ff ff	 mov	 eax, -1
  0005e	eb 08		 jmp	 SHORT $LN6@load_binin@2
$LN1@load_binin@2:
  00060	33 c0		 xor	 eax, eax
  00062	85 c0		 test	 eax, eax
  00064	75 dc		 jne	 SHORT $LN4@load_binin@2

; 4044 :     return 0;

  00066	33 c0		 xor	 eax, eax
$LN6@load_binin@2:

; 4045 : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
load_binintx ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$calc_binint DD imagerel calc_binint
	DD	imagerel calc_binint+137
	DD	imagerel $unwind$calc_binint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$calc_binint DD 010d01H
	DD	0220dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT calc_binint
_TEXT	SEGMENT
x$ = 0
i$ = 4
s$ = 8
bytes$ = 32
size$ = 40
calc_binint PROC					; COMDAT

; 4012 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 4013 :     unsigned char *s = (unsigned char *)bytes;

  0000d	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes$[rsp]
  00012	48 89 44 24 08	 mov	 QWORD PTR s$[rsp], rax

; 4014 :     int i = size;

  00017	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  0001b	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax

; 4015 :     long x = 0;

  0001f	c7 04 24 00 00
	00 00		 mov	 DWORD PTR x$[rsp], 0

; 4016 : 
; 4017 :     for (i = 0; i < size; i++) {

  00026	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002e	eb 0a		 jmp	 SHORT $LN4@calc_binin
$LN3@calc_binin:
  00030	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00034	ff c0		 inc	 eax
  00036	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@calc_binin:
  0003a	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  0003e	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  00042	7d 23		 jge	 SHORT $LN2@calc_binin

; 4018 :         x |= (long)s[i] << (i * 8);

  00044	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00049	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  0004e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00052	8b 4c 24 04	 mov	 ecx, DWORD PTR i$[rsp]
  00056	c1 e1 03	 shl	 ecx, 3
  00059	d3 e0		 shl	 eax, cl
  0005b	8b 0c 24	 mov	 ecx, DWORD PTR x$[rsp]
  0005e	0b c8		 or	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 04 24	 mov	 DWORD PTR x$[rsp], eax

; 4019 :     }

  00065	eb c9		 jmp	 SHORT $LN3@calc_binin
$LN2@calc_binin:

; 4020 : 
; 4021 :     /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
; 4022 :      * is signed, so on a box with longs bigger than 4 bytes we need
; 4023 :      * to extend a BININT's sign bit to the full width.
; 4024 :      */
; 4025 :     if (SIZEOF_LONG > 4 && size == 4) {

  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	74 14		 je	 SHORT $LN1@calc_binin

; 4026 :         x |= -(x & (1L << 31));

  0006d	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  00070	25 00 00 00 80	 and	 eax, -2147483648	; ffffffff80000000H
  00075	f7 d8		 neg	 eax
  00077	8b 0c 24	 mov	 ecx, DWORD PTR x$[rsp]
  0007a	0b c8		 or	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	89 04 24	 mov	 DWORD PTR x$[rsp], eax
$LN1@calc_binin:

; 4027 :     }
; 4028 : 
; 4029 :     return x;

  00081	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]

; 4030 : }

  00084	48 83 c4 18	 add	 rsp, 24
  00088	c3		 ret	 0
calc_binint ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binint1 DD imagerel load_binint1
	DD	imagerel load_binint1+68
	DD	imagerel $unwind$load_binint1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binint1 DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_binint1
_TEXT	SEGMENT
s$ = 32
self$ = 64
load_binint1 PROC					; COMDAT

; 4060 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4061 :     char *s;
; 4062 : 
; 4063 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	48 8d 54 24 20	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 07		 jge	 SHORT $LN1@load_binin@3

; 4064 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	eb 15		 jmp	 SHORT $LN2@load_binin@3
$LN1@load_binin@3:

; 4065 : 
; 4066 :     return load_binintx(self, s, 1);

  0002a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00030	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0003a	e8 00 00 00 00	 call	 load_binintx
$LN2@load_binin@3:

; 4067 : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
load_binint1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binint2 DD imagerel load_binint2
	DD	imagerel load_binint2+68
	DD	imagerel $unwind$load_binint2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binint2 DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_binint2
_TEXT	SEGMENT
s$ = 32
self$ = 64
load_binint2 PROC					; COMDAT

; 4071 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4072 :     char *s;
; 4073 : 
; 4074 :     if (_Unpickler_Read(self, &s, 2) < 0)

  00009	41 b8 02 00 00
	00		 mov	 r8d, 2
  0000f	48 8d 54 24 20	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 07		 jge	 SHORT $LN1@load_binin@4

; 4075 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	eb 15		 jmp	 SHORT $LN2@load_binin@4
$LN1@load_binin@4:

; 4076 : 
; 4077 :     return load_binintx(self, s, 2);

  0002a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00030	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0003a	e8 00 00 00 00	 call	 load_binintx
$LN2@load_binin@4:

; 4078 : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
load_binint2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_long DD imagerel load_long
	DD	imagerel load_long+185
	DD	imagerel $unwind$load_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_long DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_long
_TEXT	SEGMENT
value$ = 32
s$ = 40
len$ = 48
self$ = 80
load_long PROC						; COMDAT

; 4082 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4083 :     PyObject *value;
; 4084 :     char *s;
; 4085 :     Py_ssize_t len;
; 4086 : 
; 4087 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00009	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 _Unpickler_Readline
  00018	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax
  0001d	48 83 7c 24 30
	00		 cmp	 QWORD PTR len$[rsp], 0
  00023	7d 0a		 jge	 SHORT $LN8@load_long

; 4088 :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 85 00 00 00	 jmp	 $LN9@load_long
$LN8@load_long:

; 4089 :     if (len < 2)

  0002f	48 83 7c 24 30
	02		 cmp	 QWORD PTR len$[rsp], 2
  00035	7d 07		 jge	 SHORT $LN7@load_long

; 4090 :         return bad_readline();

  00037	e8 00 00 00 00	 call	 bad_readline
  0003c	eb 76		 jmp	 SHORT $LN9@load_long
$LN7@load_long:

; 4091 : 
; 4092 :     /* s[len-2] will usually be 'L' (and s[len-1] is '\n'); we need to remove
; 4093 :        the 'L' before calling PyLong_FromString.  In order to maintain
; 4094 :        compatibility with Python 3.0.0, we don't actually *require*
; 4095 :        the 'L' to be present. */
; 4096 :     if (s[len-2] == 'L')

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00043	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00048	48 03 c8	 add	 rcx, rax
  0004b	48 8b c1	 mov	 rax, rcx
  0004e	0f be 40 fe	 movsx	 eax, BYTE PTR [rax-2]
  00052	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  00055	75 14		 jne	 SHORT $LN6@load_long

; 4097 :         s[len-2] = '\0';

  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00061	48 03 c8	 add	 rcx, rax
  00064	48 8b c1	 mov	 rax, rcx
  00067	c6 40 fe 00	 mov	 BYTE PTR [rax-2], 0
$LN6@load_long:

; 4098 :     /* XXX: Should the base argument explicitly set to 10? */
; 4099 :     value = PyLong_FromString(s, NULL, 0);

  0006b	45 33 c0	 xor	 r8d, r8d
  0006e	33 d2		 xor	 edx, edx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00075	e8 00 00 00 00	 call	 PyLong_FromString
  0007a	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 4100 :     if (value == NULL)

  0007f	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  00085	75 07		 jne	 SHORT $LN5@load_long

; 4101 :         return -1;

  00087	b8 ff ff ff ff	 mov	 eax, -1
  0008c	eb 26		 jmp	 SHORT $LN9@load_long
$LN5@load_long:
$LN4@load_long:

; 4102 : 
; 4103 :     PDATA_PUSH(self->stack, value, -1);

  0008e	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00098	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0009c	e8 00 00 00 00	 call	 Pdata_push
  000a1	85 c0		 test	 eax, eax
  000a3	7d 07		 jge	 SHORT $LN1@load_long
  000a5	b8 ff ff ff ff	 mov	 eax, -1
  000aa	eb 08		 jmp	 SHORT $LN9@load_long
$LN1@load_long:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 dc		 jne	 SHORT $LN4@load_long

; 4104 :     return 0;

  000b2	33 c0		 xor	 eax, eax
$LN9@load_long:

; 4105 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
load_long ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@IHNPBLEL@LONG?5pickle?5has?5negative?5byte?5co@ ; `string'
PUBLIC	??_C@_1CO@DEBPKEIE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@ ; `string'
EXTRN	_PyLong_FromByteArray:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_counted_long DD imagerel load_counted_long
	DD	imagerel load_counted_long+296
	DD	imagerel $unwind$load_counted_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_counted_long DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT ??_C@_0CE@IHNPBLEL@LONG?5pickle?5has?5negative?5byte?5co@
CONST	SEGMENT
??_C@_0CE@IHNPBLEL@LONG?5pickle?5has?5negative?5byte?5co@ DB 'LONG pickle'
	DB	' has negative byte count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@DEBPKEIE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@DEBPKEIE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '4', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_counted_long
_TEXT	SEGMENT
value$ = 32
pdata$ = 40
nbytes$ = 48
self$ = 80
size$ = 88
load_counted_long PROC					; COMDAT

; 4112 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4113 :     PyObject *value;
; 4114 :     char *nbytes;
; 4115 :     char *pdata;
; 4116 : 
; 4117 :     assert(size == 1 || size == 4);

  0000d	83 7c 24 58 01	 cmp	 DWORD PTR size$[rsp], 1
  00012	74 23		 je	 SHORT $LN13@load_count
  00014	83 7c 24 58 04	 cmp	 DWORD PTR size$[rsp], 4
  00019	74 1c		 je	 SHORT $LN13@load_count
  0001b	41 b8 15 10 00
	00		 mov	 r8d, 4117		; 00001015H
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@DEBPKEIE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00035	33 c0		 xor	 eax, eax
$LN13@load_count:

; 4118 :     if (_Unpickler_Read(self, &nbytes, size) < 0)

  00037	48 63 44 24 58	 movsxd	 rax, DWORD PTR size$[rsp]
  0003c	4c 8b c0	 mov	 r8, rax
  0003f	48 8d 54 24 30	 lea	 rdx, QWORD PTR nbytes$[rsp]
  00044	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00049	e8 00 00 00 00	 call	 _Unpickler_Read
  0004e	48 85 c0	 test	 rax, rax
  00051	7d 0a		 jge	 SHORT $LN10@load_count

; 4119 :         return -1;

  00053	b8 ff ff ff ff	 mov	 eax, -1
  00058	e9 c6 00 00 00	 jmp	 $LN11@load_count
$LN10@load_count:

; 4120 : 
; 4121 :     size = calc_binint(nbytes, size);

  0005d	8b 54 24 58	 mov	 edx, DWORD PTR size$[rsp]
  00061	48 8b 4c 24 30	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00066	e8 00 00 00 00	 call	 calc_binint
  0006b	89 44 24 58	 mov	 DWORD PTR size$[rsp], eax

; 4122 :     if (size < 0) {

  0006f	83 7c 24 58 00	 cmp	 DWORD PTR size$[rsp], 0
  00074	7d 1d		 jge	 SHORT $LN9@load_count

; 4123 :         /* Corrupt or hostile pickle -- we never write one like this */
; 4124 :         PyErr_SetString(UnpicklingError,
; 4125 :                         "LONG pickle has negative byte count");

  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@IHNPBLEL@LONG?5pickle?5has?5negative?5byte?5co@
  0007d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00084	e8 00 00 00 00	 call	 PyErr_SetString

; 4126 :         return -1;

  00089	b8 ff ff ff ff	 mov	 eax, -1
  0008e	e9 90 00 00 00	 jmp	 $LN11@load_count
$LN9@load_count:

; 4127 :     }
; 4128 : 
; 4129 :     if (size == 0)

  00093	83 7c 24 58 00	 cmp	 DWORD PTR size$[rsp], 0
  00098	75 0e		 jne	 SHORT $LN8@load_count

; 4130 :         value = PyLong_FromLong(0L);

  0009a	33 c9		 xor	 ecx, ecx
  0009c	e8 00 00 00 00	 call	 PyLong_FromLong
  000a1	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 4131 :     else {

  000a6	eb 46		 jmp	 SHORT $LN7@load_count
$LN8@load_count:

; 4132 :         /* Read the raw little-endian bytes and convert. */
; 4133 :         if (_Unpickler_Read(self, &pdata, size) < 0)

  000a8	48 63 44 24 58	 movsxd	 rax, DWORD PTR size$[rsp]
  000ad	4c 8b c0	 mov	 r8, rax
  000b0	48 8d 54 24 28	 lea	 rdx, QWORD PTR pdata$[rsp]
  000b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000ba	e8 00 00 00 00	 call	 _Unpickler_Read
  000bf	48 85 c0	 test	 rax, rax
  000c2	7d 07		 jge	 SHORT $LN6@load_count

; 4134 :             return -1;

  000c4	b8 ff ff ff ff	 mov	 eax, -1
  000c9	eb 58		 jmp	 SHORT $LN11@load_count
$LN6@load_count:

; 4135 :         value = _PyLong_FromByteArray((unsigned char *)pdata, (size_t)size,
; 4136 :                                       1 /* little endian */ , 1 /* signed */ );

  000cb	48 63 44 24 58	 movsxd	 rax, DWORD PTR size$[rsp]
  000d0	41 b9 01 00 00
	00		 mov	 r9d, 1
  000d6	41 b8 01 00 00
	00		 mov	 r8d, 1
  000dc	48 8b d0	 mov	 rdx, rax
  000df	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pdata$[rsp]
  000e4	e8 00 00 00 00	 call	 _PyLong_FromByteArray
  000e9	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
$LN7@load_count:

; 4137 :     }
; 4138 :     if (value == NULL)

  000ee	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  000f4	75 07		 jne	 SHORT $LN5@load_count

; 4139 :         return -1;

  000f6	b8 ff ff ff ff	 mov	 eax, -1
  000fb	eb 26		 jmp	 SHORT $LN11@load_count
$LN5@load_count:
$LN4@load_count:

; 4140 :     PDATA_PUSH(self->stack, value, -1);

  000fd	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00107	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0010b	e8 00 00 00 00	 call	 Pdata_push
  00110	85 c0		 test	 eax, eax
  00112	7d 07		 jge	 SHORT $LN1@load_count
  00114	b8 ff ff ff ff	 mov	 eax, -1
  00119	eb 08		 jmp	 SHORT $LN11@load_count
$LN1@load_count:
  0011b	33 c0		 xor	 eax, eax
  0011d	85 c0		 test	 eax, eax
  0011f	75 dc		 jne	 SHORT $LN4@load_count

; 4141 :     return 0;

  00121	33 c0		 xor	 eax, eax
$LN11@load_count:

; 4142 : }

  00123	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00127	c3		 ret	 0
load_counted_long ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@PAEGCELO@could?5not?5convert?5string?5to?5floa@ ; `string'
PUBLIC	__real@bff0000000000000
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyOS_string_to_double:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_float DD imagerel load_float
	DD	imagerel load_float+265
	DD	imagerel $unwind$load_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_float DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0CC@PAEGCELO@could?5not?5convert?5string?5to?5floa@
CONST	SEGMENT
??_C@_0CC@PAEGCELO@could?5not?5convert?5string?5to?5floa@ DB 'could not c'
	DB	'onvert string to float', 00H		; `string'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_float
_TEXT	SEGMENT
value$ = 32
endptr$ = 40
s$ = 48
len$ = 56
d$ = 64
self$ = 96
load_float PROC						; COMDAT

; 4146 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4147 :     PyObject *value;
; 4148 :     char *endptr, *s;
; 4149 :     Py_ssize_t len;
; 4150 :     double d;
; 4151 : 
; 4152 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00009	48 8d 54 24 30	 lea	 rdx, QWORD PTR s$[rsp]
  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 _Unpickler_Readline
  00018	48 89 44 24 38	 mov	 QWORD PTR len$[rsp], rax
  0001d	48 83 7c 24 38
	00		 cmp	 QWORD PTR len$[rsp], 0
  00023	7d 0a		 jge	 SHORT $LN9@load_float

; 4153 :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 d5 00 00 00	 jmp	 $LN10@load_float
$LN9@load_float:

; 4154 :     if (len < 2)

  0002f	48 83 7c 24 38
	02		 cmp	 QWORD PTR len$[rsp], 2
  00035	7d 0a		 jge	 SHORT $LN8@load_float

; 4155 :         return bad_readline();

  00037	e8 00 00 00 00	 call	 bad_readline
  0003c	e9 c3 00 00 00	 jmp	 $LN10@load_float
$LN8@load_float:

; 4156 : 
; 4157 :     errno = 0;

  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00047	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 4158 :     d = PyOS_string_to_double(s, &endptr, PyExc_OverflowError);

  0004d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PyExc_OverflowError
  00054	48 8d 54 24 28	 lea	 rdx, QWORD PTR endptr$[rsp]
  00059	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0005e	e8 00 00 00 00	 call	 PyOS_string_to_double
  00063	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR d$[rsp], xmm0

; 4159 :     if (d == -1.0 && PyErr_Occurred())

  00069	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR d$[rsp]
  0006f	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00077	7a 13		 jp	 SHORT $LN7@load_float
  00079	75 11		 jne	 SHORT $LN7@load_float
  0007b	e8 00 00 00 00	 call	 PyErr_Occurred
  00080	48 85 c0	 test	 rax, rax
  00083	74 07		 je	 SHORT $LN7@load_float

; 4160 :         return -1;

  00085	b8 ff ff ff ff	 mov	 eax, -1
  0008a	eb 78		 jmp	 SHORT $LN10@load_float
$LN7@load_float:

; 4161 :     if ((endptr[0] != '\n') && (endptr[0] != '\0')) {

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR endptr$[rsp]
  00091	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00094	83 f8 0a	 cmp	 eax, 10
  00097	74 26		 je	 SHORT $LN6@load_float
  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR endptr$[rsp]
  0009e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a1	85 c0		 test	 eax, eax
  000a3	74 1a		 je	 SHORT $LN6@load_float

; 4162 :         PyErr_SetString(PyExc_ValueError, "could not convert string to float");

  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@PAEGCELO@could?5not?5convert?5string?5to?5floa@
  000ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000b3	e8 00 00 00 00	 call	 PyErr_SetString

; 4163 :         return -1;

  000b8	b8 ff ff ff ff	 mov	 eax, -1
  000bd	eb 45		 jmp	 SHORT $LN10@load_float
$LN6@load_float:

; 4164 :     }
; 4165 :     value = PyFloat_FromDouble(d);

  000bf	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR d$[rsp]
  000c5	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000ca	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 4166 :     if (value == NULL)

  000cf	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  000d5	75 07		 jne	 SHORT $LN5@load_float

; 4167 :         return -1;

  000d7	b8 ff ff ff ff	 mov	 eax, -1
  000dc	eb 26		 jmp	 SHORT $LN10@load_float
$LN5@load_float:
$LN4@load_float:

; 4168 : 
; 4169 :     PDATA_PUSH(self->stack, value, -1);

  000de	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  000e3	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000e8	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000ec	e8 00 00 00 00	 call	 Pdata_push
  000f1	85 c0		 test	 eax, eax
  000f3	7d 07		 jge	 SHORT $LN1@load_float
  000f5	b8 ff ff ff ff	 mov	 eax, -1
  000fa	eb 08		 jmp	 SHORT $LN10@load_float
$LN1@load_float:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 dc		 jne	 SHORT $LN4@load_float

; 4170 :     return 0;

  00102	33 c0		 xor	 eax, eax
$LN10@load_float:

; 4171 : }

  00104	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00108	c3		 ret	 0
load_float ENDP
_TEXT	ENDS
EXTRN	_PyFloat_Unpack8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binfloat DD imagerel load_binfloat
	DD	imagerel load_binfloat+169
	DD	imagerel $unwind$load_binfloat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binfloat DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_binfloat
_TEXT	SEGMENT
value$ = 32
x$ = 40
s$ = 48
self$ = 80
load_binfloat PROC					; COMDAT

; 4175 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4176 :     PyObject *value;
; 4177 :     double x;
; 4178 :     char *s;
; 4179 : 
; 4180 :     if (_Unpickler_Read(self, &s, 8) < 0)

  00009	41 b8 08 00 00
	00		 mov	 r8d, 8
  0000f	48 8d 54 24 30	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 07		 jge	 SHORT $LN7@load_binfl

; 4181 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	eb 7a		 jmp	 SHORT $LN8@load_binfl
$LN7@load_binfl:

; 4182 : 
; 4183 :     x = _PyFloat_Unpack8((unsigned char *)s, 0);

  0002a	33 d2		 xor	 edx, edx
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00031	e8 00 00 00 00	 call	 _PyFloat_Unpack8
  00036	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR x$[rsp], xmm0

; 4184 :     if (x == -1.0 && PyErr_Occurred())

  0003c	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00042	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0004a	7a 13		 jp	 SHORT $LN6@load_binfl
  0004c	75 11		 jne	 SHORT $LN6@load_binfl
  0004e	e8 00 00 00 00	 call	 PyErr_Occurred
  00053	48 85 c0	 test	 rax, rax
  00056	74 07		 je	 SHORT $LN6@load_binfl

; 4185 :         return -1;

  00058	b8 ff ff ff ff	 mov	 eax, -1
  0005d	eb 45		 jmp	 SHORT $LN8@load_binfl
$LN6@load_binfl:

; 4186 : 
; 4187 :     if ((value = PyFloat_FromDouble(x)) == NULL)

  0005f	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00065	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0006a	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  0006f	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  00075	75 07		 jne	 SHORT $LN5@load_binfl

; 4188 :         return -1;

  00077	b8 ff ff ff ff	 mov	 eax, -1
  0007c	eb 26		 jmp	 SHORT $LN8@load_binfl
$LN5@load_binfl:
$LN4@load_binfl:

; 4189 : 
; 4190 :     PDATA_PUSH(self->stack, value, -1);

  0007e	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00088	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0008c	e8 00 00 00 00	 call	 Pdata_push
  00091	85 c0		 test	 eax, eax
  00093	7d 07		 jge	 SHORT $LN1@load_binfl
  00095	b8 ff ff ff ff	 mov	 eax, -1
  0009a	eb 08		 jmp	 SHORT $LN8@load_binfl
$LN1@load_binfl:
  0009c	33 c0		 xor	 eax, eax
  0009e	85 c0		 test	 eax, eax
  000a0	75 dc		 jne	 SHORT $LN4@load_binfl

; 4191 :     return 0;

  000a2	33 c0		 xor	 eax, eax
$LN8@load_binfl:

; 4192 : }

  000a4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a8	c3		 ret	 0
load_binfloat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@PIAJHIOC@insecure?5string?5pickle?$AA@ ; `string'
EXTRN	PyUnicode_FromEncodedObject:PROC
EXTRN	PyBytes_DecodeEscape:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_strdup:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_string DD imagerel load_string
	DD	imagerel load_string+562
	DD	imagerel $unwind$load_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_string DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_0BH@PIAJHIOC@insecure?5string?5pickle?$AA@
CONST	SEGMENT
??_C@_0BH@PIAJHIOC@insecure?5string?5pickle?$AA@ DB 'insecure string pick'
	DB	'le', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_string
_TEXT	SEGMENT
p$ = 48
s$ = 56
len$ = 64
bytes$ = 72
str$ = 80
self$ = 112
load_string PROC					; COMDAT

; 4196 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4197 :     PyObject *bytes;
; 4198 :     PyObject *str = NULL;

  00009	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR str$[rsp], 0

; 4199 :     Py_ssize_t len;
; 4200 :     char *s, *p;
; 4201 : 
; 4202 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00012	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  00017	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0001c	e8 00 00 00 00	 call	 _Unpickler_Readline
  00021	48 89 44 24 40	 mov	 QWORD PTR len$[rsp], rax
  00026	48 83 7c 24 40
	00		 cmp	 QWORD PTR len$[rsp], 0
  0002c	7d 0a		 jge	 SHORT $LN15@load_strin

; 4203 :         return -1;

  0002e	b8 ff ff ff ff	 mov	 eax, -1
  00033	e9 f5 01 00 00	 jmp	 $LN16@load_strin
$LN15@load_strin:

; 4204 :     if (len < 2)

  00038	48 83 7c 24 40
	02		 cmp	 QWORD PTR len$[rsp], 2
  0003e	7d 0a		 jge	 SHORT $LN14@load_strin

; 4205 :         return bad_readline();

  00040	e8 00 00 00 00	 call	 bad_readline
  00045	e9 e3 01 00 00	 jmp	 $LN16@load_strin
$LN14@load_strin:

; 4206 :     if ((s = strdup(s)) == NULL) {

  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00055	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax
  0005a	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  00060	75 0f		 jne	 SHORT $LN13@load_strin

; 4207 :         PyErr_NoMemory();

  00062	e8 00 00 00 00	 call	 PyErr_NoMemory

; 4208 :         return -1;

  00067	b8 ff ff ff ff	 mov	 eax, -1
  0006c	e9 bc 01 00 00	 jmp	 $LN16@load_strin
$LN13@load_strin:
$LN12@load_strin:

; 4209 :     }
; 4210 : 
; 4211 :     /* Strip outermost quotes */
; 4212 :     while (len > 0 && s[len - 1] <= ' ')

  00071	48 83 7c 24 40
	00		 cmp	 QWORD PTR len$[rsp], 0
  00077	7e 28		 jle	 SHORT $LN11@load_strin
  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  0007e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00083	48 03 c8	 add	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  0008d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00090	7f 0f		 jg	 SHORT $LN11@load_strin

; 4213 :         len--;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  00097	48 ff c8	 dec	 rax
  0009a	48 89 44 24 40	 mov	 QWORD PTR len$[rsp], rax
  0009f	eb d0		 jmp	 SHORT $LN12@load_strin
$LN11@load_strin:

; 4214 :     if (len > 1 && s[0] == '"' && s[len - 1] == '"') {

  000a1	48 83 7c 24 40
	01		 cmp	 QWORD PTR len$[rsp], 1
  000a7	7e 5a		 jle	 SHORT $LN10@load_strin
  000a9	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000ae	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b1	83 f8 22	 cmp	 eax, 34			; 00000022H
  000b4	75 4d		 jne	 SHORT $LN10@load_strin
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  000c0	48 03 c8	 add	 rcx, rax
  000c3	48 8b c1	 mov	 rax, rcx
  000c6	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  000ca	83 f8 22	 cmp	 eax, 34			; 00000022H
  000cd	75 34		 jne	 SHORT $LN10@load_strin

; 4215 :         s[len - 1] = '\0';

  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  000d4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  000d9	48 03 c8	 add	 rcx, rax
  000dc	48 8b c1	 mov	 rax, rcx
  000df	c6 40 ff 00	 mov	 BYTE PTR [rax-1], 0

; 4216 :         p = s + 1;

  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000e8	48 ff c0	 inc	 rax
  000eb	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4217 :         len -= 2;

  000f0	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  000f5	48 83 e8 02	 sub	 rax, 2
  000f9	48 89 44 24 40	 mov	 QWORD PTR len$[rsp], rax
  000fe	e9 87 00 00 00	 jmp	 $LN9@load_strin
$LN10@load_strin:

; 4218 :     }
; 4219 :     else if (len > 1 && s[0] == '\'' && s[len - 1] == '\'') {

  00103	48 83 7c 24 40
	01		 cmp	 QWORD PTR len$[rsp], 1
  00109	7e 57		 jle	 SHORT $LN8@load_strin
  0010b	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00110	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00113	83 f8 27	 cmp	 eax, 39			; 00000027H
  00116	75 4a		 jne	 SHORT $LN8@load_strin
  00118	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  0011d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00122	48 03 c8	 add	 rcx, rax
  00125	48 8b c1	 mov	 rax, rcx
  00128	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  0012c	83 f8 27	 cmp	 eax, 39			; 00000027H
  0012f	75 31		 jne	 SHORT $LN8@load_strin

; 4220 :         s[len - 1] = '\0';

  00131	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  00136	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0013b	48 03 c8	 add	 rcx, rax
  0013e	48 8b c1	 mov	 rax, rcx
  00141	c6 40 ff 00	 mov	 BYTE PTR [rax-1], 0

; 4221 :         p = s + 1;

  00145	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0014a	48 ff c0	 inc	 rax
  0014d	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4222 :         len -= 2;

  00152	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  00157	48 83 e8 02	 sub	 rax, 2
  0015b	48 89 44 24 40	 mov	 QWORD PTR len$[rsp], rax

; 4223 :     }
; 4224 :     else {

  00160	eb 28		 jmp	 SHORT $LN7@load_strin
$LN8@load_strin:

; 4225 :         free(s);

  00162	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4226 :         PyErr_SetString(PyExc_ValueError, "insecure string pickle");

  0016d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@PIAJHIOC@insecure?5string?5pickle?$AA@
  00174	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0017b	e8 00 00 00 00	 call	 PyErr_SetString

; 4227 :         return -1;

  00180	b8 ff ff ff ff	 mov	 eax, -1
  00185	e9 a3 00 00 00	 jmp	 $LN16@load_strin
$LN7@load_strin:
$LN9@load_strin:

; 4228 :     }
; 4229 : 
; 4230 :     /* Use the PyBytes API to decode the string, since that is what is used
; 4231 :        to encode, and then coerce the result to Unicode. */
; 4232 :     bytes = PyBytes_DecodeEscape(p, len, NULL, 0, NULL);

  0018a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00193	45 33 c9	 xor	 r9d, r9d
  00196	45 33 c0	 xor	 r8d, r8d
  00199	48 8b 54 24 40	 mov	 rdx, QWORD PTR len$[rsp]
  0019e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  001a3	e8 00 00 00 00	 call	 PyBytes_DecodeEscape
  001a8	48 89 44 24 48	 mov	 QWORD PTR bytes$[rsp], rax

; 4233 :     free(s);

  001ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4234 :     if (bytes == NULL)

  001b8	48 83 7c 24 48
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  001be	75 07		 jne	 SHORT $LN6@load_strin

; 4235 :         return -1;

  001c0	b8 ff ff ff ff	 mov	 eax, -1
  001c5	eb 66		 jmp	 SHORT $LN16@load_strin
$LN6@load_strin:

; 4236 :     str = PyUnicode_FromEncodedObject(bytes, self->encoding, self->errors);

  001c7	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001cc	4c 8b 80 20 01
	00 00		 mov	 r8, QWORD PTR [rax+288]
  001d3	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001d8	48 8b 90 18 01
	00 00		 mov	 rdx, QWORD PTR [rax+280]
  001df	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytes$[rsp]
  001e4	e8 00 00 00 00	 call	 PyUnicode_FromEncodedObject
  001e9	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax

; 4237 :     Py_DECREF(bytes);

  001ee	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytes$[rsp]
  001f3	e8 00 00 00 00	 call	 _Py_DecRef

; 4238 :     if (str == NULL)

  001f8	48 83 7c 24 50
	00		 cmp	 QWORD PTR str$[rsp], 0
  001fe	75 07		 jne	 SHORT $LN5@load_strin

; 4239 :         return -1;

  00200	b8 ff ff ff ff	 mov	 eax, -1
  00205	eb 26		 jmp	 SHORT $LN16@load_strin
$LN5@load_strin:
$LN4@load_strin:

; 4240 : 
; 4241 :     PDATA_PUSH(self->stack, str, -1);

  00207	48 8b 54 24 50	 mov	 rdx, QWORD PTR str$[rsp]
  0020c	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00211	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00215	e8 00 00 00 00	 call	 Pdata_push
  0021a	85 c0		 test	 eax, eax
  0021c	7d 07		 jge	 SHORT $LN1@load_strin
  0021e	b8 ff ff ff ff	 mov	 eax, -1
  00223	eb 08		 jmp	 SHORT $LN16@load_strin
$LN1@load_strin:
  00225	33 c0		 xor	 eax, eax
  00227	85 c0		 test	 eax, eax
  00229	75 dc		 jne	 SHORT $LN4@load_strin

; 4242 :     return 0;

  0022b	33 c0		 xor	 eax, eax
$LN16@load_strin:

; 4243 : }

  0022d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00231	c3		 ret	 0
load_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@FALDIICK@BINBYTES?5exceeds?5system?8s?5maximu@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binbytes DD imagerel load_binbytes
	DD	imagerel load_binbytes+219
	DD	imagerel $unwind$load_binbytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binbytes DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0DE@FALDIICK@BINBYTES?5exceeds?5system?8s?5maximu@
CONST	SEGMENT
??_C@_0DE@FALDIICK@BINBYTES?5exceeds?5system?8s?5maximu@ DB 'BINBYTES exc'
	DB	'eeds system''s maximum size of %zd bytes', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_binbytes
_TEXT	SEGMENT
x$ = 32
s$ = 40
bytes$ = 48
self$ = 80
load_binbytes PROC					; COMDAT

; 4247 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4248 :     PyObject *bytes;
; 4249 :     Py_ssize_t x;
; 4250 :     char *s;
; 4251 : 
; 4252 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00009	41 b8 04 00 00
	00		 mov	 r8d, 4
  0000f	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 0a		 jge	 SHORT $LN8@load_binby

; 4253 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 a9 00 00 00	 jmp	 $LN9@load_binby
$LN8@load_binby:

; 4254 : 
; 4255 :     x = calc_binsize(s, 4);

  0002d	ba 04 00 00 00	 mov	 edx, 4
  00032	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00037	e8 00 00 00 00	 call	 calc_binsize
  0003c	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 4256 :     if (x < 0) {

  00041	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  00047	7d 24		 jge	 SHORT $LN7@load_binby

; 4257 :         PyErr_Format(PyExc_OverflowError,
; 4258 :                      "BINBYTES exceeds system's maximum size of %zd bytes",
; 4259 :                      PY_SSIZE_T_MAX
; 4260 :                     );

  00049	49 b8 ff ff ff
	ff ff ff ff 7f	 mov	 r8, 9223372036854775807	; 7fffffffffffffffH
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@FALDIICK@BINBYTES?5exceeds?5system?8s?5maximu@
  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00061	e8 00 00 00 00	 call	 PyErr_Format

; 4261 :         return -1;

  00066	b8 ff ff ff ff	 mov	 eax, -1
  0006b	eb 69		 jmp	 SHORT $LN9@load_binby
$LN7@load_binby:

; 4262 :     }
; 4263 : 
; 4264 :     if (_Unpickler_Read(self, &s, x) < 0)

  0006d	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  00072	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0007c	e8 00 00 00 00	 call	 _Unpickler_Read
  00081	48 85 c0	 test	 rax, rax
  00084	7d 07		 jge	 SHORT $LN6@load_binby

; 4265 :         return -1;

  00086	b8 ff ff ff ff	 mov	 eax, -1
  0008b	eb 49		 jmp	 SHORT $LN9@load_binby
$LN6@load_binby:

; 4266 :     bytes = PyBytes_FromStringAndSize(s, x);

  0008d	48 8b 54 24 20	 mov	 rdx, QWORD PTR x$[rsp]
  00092	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00097	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0009c	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax

; 4267 :     if (bytes == NULL)

  000a1	48 83 7c 24 30
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  000a7	75 07		 jne	 SHORT $LN5@load_binby

; 4268 :         return -1;

  000a9	b8 ff ff ff ff	 mov	 eax, -1
  000ae	eb 26		 jmp	 SHORT $LN9@load_binby
$LN5@load_binby:
$LN4@load_binby:

; 4269 : 
; 4270 :     PDATA_PUSH(self->stack, bytes, -1);

  000b0	48 8b 54 24 30	 mov	 rdx, QWORD PTR bytes$[rsp]
  000b5	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ba	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000be	e8 00 00 00 00	 call	 Pdata_push
  000c3	85 c0		 test	 eax, eax
  000c5	7d 07		 jge	 SHORT $LN1@load_binby
  000c7	b8 ff ff ff ff	 mov	 eax, -1
  000cc	eb 08		 jmp	 SHORT $LN9@load_binby
$LN1@load_binby:
  000ce	33 c0		 xor	 eax, eax
  000d0	85 c0		 test	 eax, eax
  000d2	75 dc		 jne	 SHORT $LN4@load_binby

; 4271 :     return 0;

  000d4	33 c0		 xor	 eax, eax
$LN9@load_binby:

; 4272 : }

  000d6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000da	c3		 ret	 0
load_binbytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@EPDDLEFA@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$calc_binsize DD imagerel calc_binsize
	DD	imagerel calc_binsize+205
	DD	imagerel $unwind$calc_binsize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$calc_binsize DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_1BE@EPDDLEFA@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@EPDDLEFA@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '4', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT calc_binsize
_TEXT	SEGMENT
x$ = 32
s$ = 40
bytes$ = 64
size$ = 72
calc_binsize PROC					; COMDAT

; 3988 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3989 :     unsigned char *s = (unsigned char *)bytes;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR bytes$[rsp]
  00012	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 3990 :     size_t x = 0;

  00017	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 3991 : 
; 3992 :     assert(size == 4);

  00020	83 7c 24 48 04	 cmp	 DWORD PTR size$[rsp], 4
  00025	74 1c		 je	 SHORT $LN5@calc_binsi
  00027	41 b8 98 0f 00
	00		 mov	 r8d, 3992		; 00000f98H
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@EPDDLEFA@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA4?$AA?$AA@
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00041	33 c0		 xor	 eax, eax
$LN5@calc_binsi:

; 3993 : 
; 3994 :     x =  (size_t) s[0];

  00043	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004b	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 3995 :     x |= (size_t) s[1] << 8;

  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00055	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00059	48 c1 e0 08	 shl	 rax, 8
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00062	48 0b c8	 or	 rcx, rax
  00065	48 8b c1	 mov	 rax, rcx
  00068	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 3996 :     x |= (size_t) s[2] << 16;

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00072	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00076	48 c1 e0 10	 shl	 rax, 16
  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  0007f	48 0b c8	 or	 rcx, rax
  00082	48 8b c1	 mov	 rax, rcx
  00085	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 3997 :     x |= (size_t) s[3] << 24;

  0008a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0008f	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00093	48 c1 e0 18	 shl	 rax, 24
  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  0009c	48 0b c8	 or	 rcx, rax
  0009f	48 8b c1	 mov	 rax, rcx
  000a2	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 3998 : 
; 3999 :     if (x > PY_SSIZE_T_MAX)

  000a7	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000b1	48 39 44 24 20	 cmp	 QWORD PTR x$[rsp], rax
  000b6	76 0b		 jbe	 SHORT $LN2@calc_binsi

; 4000 :         return -1;

  000b8	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000bf	eb 07		 jmp	 SHORT $LN3@calc_binsi

; 4001 :     else

  000c1	eb 05		 jmp	 SHORT $LN1@calc_binsi
$LN2@calc_binsi:

; 4002 :         return (Py_ssize_t) x;

  000c3	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
$LN1@calc_binsi:
$LN3@calc_binsi:

; 4003 : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
calc_binsize ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_short_binbytes DD imagerel load_short_binbytes
	DD	imagerel load_short_binbytes+165
	DD	imagerel $unwind$load_short_binbytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_short_binbytes DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_short_binbytes
_TEXT	SEGMENT
x$ = 32
s$ = 40
bytes$ = 48
self$ = 80
load_short_binbytes PROC				; COMDAT

; 4276 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4277 :     PyObject *bytes;
; 4278 :     Py_ssize_t x;
; 4279 :     char *s;
; 4280 : 
; 4281 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 07		 jge	 SHORT $LN7@load_short

; 4282 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	eb 76		 jmp	 SHORT $LN8@load_short
$LN7@load_short:

; 4283 : 
; 4284 :     x = (unsigned char)s[0];

  0002a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 4285 : 
; 4286 :     if (_Unpickler_Read(self, &s, x) < 0)

  00037	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  0003c	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00041	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00046	e8 00 00 00 00	 call	 _Unpickler_Read
  0004b	48 85 c0	 test	 rax, rax
  0004e	7d 07		 jge	 SHORT $LN6@load_short

; 4287 :         return -1;

  00050	b8 ff ff ff ff	 mov	 eax, -1
  00055	eb 49		 jmp	 SHORT $LN8@load_short
$LN6@load_short:

; 4288 : 
; 4289 :     bytes = PyBytes_FromStringAndSize(s, x);

  00057	48 8b 54 24 20	 mov	 rdx, QWORD PTR x$[rsp]
  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00061	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00066	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax

; 4290 :     if (bytes == NULL)

  0006b	48 83 7c 24 30
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  00071	75 07		 jne	 SHORT $LN5@load_short

; 4291 :         return -1;

  00073	b8 ff ff ff ff	 mov	 eax, -1
  00078	eb 26		 jmp	 SHORT $LN8@load_short
$LN5@load_short:
$LN4@load_short:

; 4292 : 
; 4293 :     PDATA_PUSH(self->stack, bytes, -1);

  0007a	48 8b 54 24 30	 mov	 rdx, QWORD PTR bytes$[rsp]
  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00084	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00088	e8 00 00 00 00	 call	 Pdata_push
  0008d	85 c0		 test	 eax, eax
  0008f	7d 07		 jge	 SHORT $LN1@load_short
  00091	b8 ff ff ff ff	 mov	 eax, -1
  00096	eb 08		 jmp	 SHORT $LN8@load_short
$LN1@load_short:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 dc		 jne	 SHORT $LN4@load_short

; 4294 :     return 0;

  0009e	33 c0		 xor	 eax, eax
$LN8@load_short:

; 4295 : }

  000a0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a4	c3		 ret	 0
load_short_binbytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@KLBLDIIH@BINSTRING?5pickle?5has?5negative?5by@ ; `string'
EXTRN	PyUnicode_Decode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binstring DD imagerel load_binstring
	DD	imagerel load_binstring+238
	DD	imagerel $unwind$load_binstring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binstring DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0CJ@KLBLDIIH@BINSTRING?5pickle?5has?5negative?5by@
CONST	SEGMENT
??_C@_0CJ@KLBLDIIH@BINSTRING?5pickle?5has?5negative?5by@ DB 'BINSTRING pi'
	DB	'ckle has negative byte count', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_binstring
_TEXT	SEGMENT
x$ = 32
s$ = 40
str$ = 48
self$ = 80
load_binstring PROC					; COMDAT

; 4299 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4300 :     PyObject *str;
; 4301 :     Py_ssize_t x;
; 4302 :     char *s;
; 4303 : 
; 4304 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00009	41 b8 04 00 00
	00		 mov	 r8d, 4
  0000f	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 0a		 jge	 SHORT $LN8@load_binst

; 4305 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 bc 00 00 00	 jmp	 $LN9@load_binst
$LN8@load_binst:

; 4306 : 
; 4307 :     x = calc_binint(s, 4);

  0002d	ba 04 00 00 00	 mov	 edx, 4
  00032	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00037	e8 00 00 00 00	 call	 calc_binint
  0003c	48 98		 cdqe
  0003e	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 4308 :     if (x < 0) {

  00043	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  00049	7d 1d		 jge	 SHORT $LN7@load_binst

; 4309 :         PyErr_SetString(UnpicklingError,
; 4310 :                         "BINSTRING pickle has negative byte count");

  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@KLBLDIIH@BINSTRING?5pickle?5has?5negative?5by@
  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00059	e8 00 00 00 00	 call	 PyErr_SetString

; 4311 :         return -1;

  0005e	b8 ff ff ff ff	 mov	 eax, -1
  00063	e9 81 00 00 00	 jmp	 $LN9@load_binst
$LN7@load_binst:

; 4312 :     }
; 4313 : 
; 4314 :     if (_Unpickler_Read(self, &s, x) < 0)

  00068	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  0006d	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00077	e8 00 00 00 00	 call	 _Unpickler_Read
  0007c	48 85 c0	 test	 rax, rax
  0007f	7d 07		 jge	 SHORT $LN6@load_binst

; 4315 :         return -1;

  00081	b8 ff ff ff ff	 mov	 eax, -1
  00086	eb 61		 jmp	 SHORT $LN9@load_binst
$LN6@load_binst:

; 4316 : 
; 4317 :     /* Convert Python 2.x strings to unicode. */
; 4318 :     str = PyUnicode_Decode(s, x, self->encoding, self->errors);

  00088	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0008d	4c 8b 88 20 01
	00 00		 mov	 r9, QWORD PTR [rax+288]
  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00099	4c 8b 80 18 01
	00 00		 mov	 r8, QWORD PTR [rax+280]
  000a0	48 8b 54 24 20	 mov	 rdx, QWORD PTR x$[rsp]
  000a5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000aa	e8 00 00 00 00	 call	 PyUnicode_Decode
  000af	48 89 44 24 30	 mov	 QWORD PTR str$[rsp], rax

; 4319 :     if (str == NULL)

  000b4	48 83 7c 24 30
	00		 cmp	 QWORD PTR str$[rsp], 0
  000ba	75 07		 jne	 SHORT $LN5@load_binst

; 4320 :         return -1;

  000bc	b8 ff ff ff ff	 mov	 eax, -1
  000c1	eb 26		 jmp	 SHORT $LN9@load_binst
$LN5@load_binst:
$LN4@load_binst:

; 4321 : 
; 4322 :     PDATA_PUSH(self->stack, str, -1);

  000c3	48 8b 54 24 30	 mov	 rdx, QWORD PTR str$[rsp]
  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000cd	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000d1	e8 00 00 00 00	 call	 Pdata_push
  000d6	85 c0		 test	 eax, eax
  000d8	7d 07		 jge	 SHORT $LN1@load_binst
  000da	b8 ff ff ff ff	 mov	 eax, -1
  000df	eb 08		 jmp	 SHORT $LN9@load_binst
$LN1@load_binst:
  000e1	33 c0		 xor	 eax, eax
  000e3	85 c0		 test	 eax, eax
  000e5	75 dc		 jne	 SHORT $LN4@load_binst

; 4323 :     return 0;

  000e7	33 c0		 xor	 eax, eax
$LN9@load_binst:

; 4324 : }

  000e9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ed	c3		 ret	 0
load_binstring ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_short_binstring DD imagerel load_short_binstring
	DD	imagerel load_short_binstring+192
	DD	imagerel $unwind$load_short_binstring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_short_binstring DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_short_binstring
_TEXT	SEGMENT
x$ = 32
s$ = 40
str$ = 48
self$ = 80
load_short_binstring PROC				; COMDAT

; 4328 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4329 :     PyObject *str;
; 4330 :     Py_ssize_t x;
; 4331 :     char *s;
; 4332 : 
; 4333 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 0a		 jge	 SHORT $LN7@load_short@2

; 4334 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 8e 00 00 00	 jmp	 $LN8@load_short@2
$LN7@load_short@2:

; 4335 : 
; 4336 :     x = (unsigned char)s[0];

  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00032	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00035	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 4337 : 
; 4338 :     if (_Unpickler_Read(self, &s, x) < 0)

  0003a	4c 8b 44 24 20	 mov	 r8, QWORD PTR x$[rsp]
  0003f	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00044	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00049	e8 00 00 00 00	 call	 _Unpickler_Read
  0004e	48 85 c0	 test	 rax, rax
  00051	7d 07		 jge	 SHORT $LN6@load_short@2

; 4339 :         return -1;

  00053	b8 ff ff ff ff	 mov	 eax, -1
  00058	eb 61		 jmp	 SHORT $LN8@load_short@2
$LN6@load_short@2:

; 4340 : 
; 4341 :     /* Convert Python 2.x strings to unicode. */
; 4342 :     str = PyUnicode_Decode(s, x, self->encoding, self->errors);

  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0005f	4c 8b 88 20 01
	00 00		 mov	 r9, QWORD PTR [rax+288]
  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0006b	4c 8b 80 18 01
	00 00		 mov	 r8, QWORD PTR [rax+280]
  00072	48 8b 54 24 20	 mov	 rdx, QWORD PTR x$[rsp]
  00077	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0007c	e8 00 00 00 00	 call	 PyUnicode_Decode
  00081	48 89 44 24 30	 mov	 QWORD PTR str$[rsp], rax

; 4343 :     if (str == NULL)

  00086	48 83 7c 24 30
	00		 cmp	 QWORD PTR str$[rsp], 0
  0008c	75 07		 jne	 SHORT $LN5@load_short@2

; 4344 :         return -1;

  0008e	b8 ff ff ff ff	 mov	 eax, -1
  00093	eb 26		 jmp	 SHORT $LN8@load_short@2
$LN5@load_short@2:
$LN4@load_short@2:

; 4345 : 
; 4346 :     PDATA_PUSH(self->stack, str, -1);

  00095	48 8b 54 24 30	 mov	 rdx, QWORD PTR str$[rsp]
  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0009f	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000a3	e8 00 00 00 00	 call	 Pdata_push
  000a8	85 c0		 test	 eax, eax
  000aa	7d 07		 jge	 SHORT $LN1@load_short@2
  000ac	b8 ff ff ff ff	 mov	 eax, -1
  000b1	eb 08		 jmp	 SHORT $LN8@load_short@2
$LN1@load_short@2:
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 dc		 jne	 SHORT $LN4@load_short@2

; 4347 :     return 0;

  000b9	33 c0		 xor	 eax, eax
$LN8@load_short@2:

; 4348 : }

  000bb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bf	c3		 ret	 0
load_short_binstring ENDP
_TEXT	ENDS
EXTRN	PyUnicode_DecodeRawUnicodeEscape:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_unicode DD imagerel load_unicode
	DD	imagerel load_unicode+146
	DD	imagerel $unwind$load_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_unicode DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_unicode
_TEXT	SEGMENT
s$ = 32
len$ = 40
str$ = 48
self$ = 80
load_unicode PROC					; COMDAT

; 4352 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4353 :     PyObject *str;
; 4354 :     Py_ssize_t len;
; 4355 :     char *s;
; 4356 : 
; 4357 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00009	48 8d 54 24 20	 lea	 rdx, QWORD PTR s$[rsp]
  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 _Unpickler_Readline
  00018	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax
  0001d	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  00023	7d 07		 jge	 SHORT $LN7@load_unico

; 4358 :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	eb 61		 jmp	 SHORT $LN8@load_unico
$LN7@load_unico:

; 4359 :     if (len < 1)

  0002c	48 83 7c 24 28
	01		 cmp	 QWORD PTR len$[rsp], 1
  00032	7d 07		 jge	 SHORT $LN6@load_unico

; 4360 :         return bad_readline();

  00034	e8 00 00 00 00	 call	 bad_readline
  00039	eb 52		 jmp	 SHORT $LN8@load_unico
$LN6@load_unico:

; 4361 : 
; 4362 :     str = PyUnicode_DecodeRawUnicodeEscape(s, len - 1, NULL);

  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00040	48 ff c8	 dec	 rax
  00043	45 33 c0	 xor	 r8d, r8d
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0004e	e8 00 00 00 00	 call	 PyUnicode_DecodeRawUnicodeEscape
  00053	48 89 44 24 30	 mov	 QWORD PTR str$[rsp], rax

; 4363 :     if (str == NULL)

  00058	48 83 7c 24 30
	00		 cmp	 QWORD PTR str$[rsp], 0
  0005e	75 07		 jne	 SHORT $LN5@load_unico

; 4364 :         return -1;

  00060	b8 ff ff ff ff	 mov	 eax, -1
  00065	eb 26		 jmp	 SHORT $LN8@load_unico
$LN5@load_unico:
$LN4@load_unico:

; 4365 : 
; 4366 :     PDATA_PUSH(self->stack, str, -1);

  00067	48 8b 54 24 30	 mov	 rdx, QWORD PTR str$[rsp]
  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00071	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00075	e8 00 00 00 00	 call	 Pdata_push
  0007a	85 c0		 test	 eax, eax
  0007c	7d 07		 jge	 SHORT $LN1@load_unico
  0007e	b8 ff ff ff ff	 mov	 eax, -1
  00083	eb 08		 jmp	 SHORT $LN8@load_unico
$LN1@load_unico:
  00085	33 c0		 xor	 eax, eax
  00087	85 c0		 test	 eax, eax
  00089	75 dc		 jne	 SHORT $LN4@load_unico

; 4367 :     return 0;

  0008b	33 c0		 xor	 eax, eax
$LN8@load_unico:

; 4368 : }

  0008d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00091	c3		 ret	 0
load_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@OMCKIKHC@BINUNICODE?5exceeds?5system?8s?5maxi@ ; `string'
EXTRN	PyUnicode_DecodeUTF8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binunicode DD imagerel load_binunicode
	DD	imagerel load_binunicode+226
	DD	imagerel $unwind$load_binunicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binunicode DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0DG@OMCKIKHC@BINUNICODE?5exceeds?5system?8s?5maxi@
CONST	SEGMENT
??_C@_0DG@OMCKIKHC@BINUNICODE?5exceeds?5system?8s?5maxi@ DB 'BINUNICODE e'
	DB	'xceeds system''s maximum size of %zd bytes', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_binunicode
_TEXT	SEGMENT
s$ = 32
size$ = 40
str$ = 48
self$ = 80
load_binunicode PROC					; COMDAT

; 4372 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4373 :     PyObject *str;
; 4374 :     Py_ssize_t size;
; 4375 :     char *s;
; 4376 : 
; 4377 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00009	41 b8 04 00 00
	00		 mov	 r8d, 4
  0000f	48 8d 54 24 20	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 0a		 jge	 SHORT $LN8@load_binun

; 4378 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 b0 00 00 00	 jmp	 $LN9@load_binun
$LN8@load_binun:

; 4379 : 
; 4380 :     size = calc_binsize(s, 4);

  0002d	ba 04 00 00 00	 mov	 edx, 4
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00037	e8 00 00 00 00	 call	 calc_binsize
  0003c	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 4381 :     if (size < 0) {

  00041	48 83 7c 24 28
	00		 cmp	 QWORD PTR size$[rsp], 0
  00047	7d 24		 jge	 SHORT $LN7@load_binun

; 4382 :         PyErr_Format(PyExc_OverflowError,
; 4383 :                      "BINUNICODE exceeds system's maximum size of %zd bytes",
; 4384 :                      PY_SSIZE_T_MAX
; 4385 :                     );

  00049	49 b8 ff ff ff
	ff ff ff ff 7f	 mov	 r8, 9223372036854775807	; 7fffffffffffffffH
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@OMCKIKHC@BINUNICODE?5exceeds?5system?8s?5maxi@
  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00061	e8 00 00 00 00	 call	 PyErr_Format

; 4386 :         return -1;

  00066	b8 ff ff ff ff	 mov	 eax, -1
  0006b	eb 70		 jmp	 SHORT $LN9@load_binun
$LN7@load_binun:

; 4387 :     }
; 4388 : 
; 4389 : 
; 4390 :     if (_Unpickler_Read(self, &s, size) < 0)

  0006d	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  00072	48 8d 54 24 20	 lea	 rdx, QWORD PTR s$[rsp]
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0007c	e8 00 00 00 00	 call	 _Unpickler_Read
  00081	48 85 c0	 test	 rax, rax
  00084	7d 07		 jge	 SHORT $LN6@load_binun

; 4391 :         return -1;

  00086	b8 ff ff ff ff	 mov	 eax, -1
  0008b	eb 50		 jmp	 SHORT $LN9@load_binun
$LN6@load_binun:

; 4392 : 
; 4393 :     str = PyUnicode_DecodeUTF8(s, size, "surrogatepass");

  0008d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNPCNOJJ@surrogatepass?$AA@
  00094	48 8b 54 24 28	 mov	 rdx, QWORD PTR size$[rsp]
  00099	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0009e	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  000a3	48 89 44 24 30	 mov	 QWORD PTR str$[rsp], rax

; 4394 :     if (str == NULL)

  000a8	48 83 7c 24 30
	00		 cmp	 QWORD PTR str$[rsp], 0
  000ae	75 07		 jne	 SHORT $LN5@load_binun

; 4395 :         return -1;

  000b0	b8 ff ff ff ff	 mov	 eax, -1
  000b5	eb 26		 jmp	 SHORT $LN9@load_binun
$LN5@load_binun:
$LN4@load_binun:

; 4396 : 
; 4397 :     PDATA_PUSH(self->stack, str, -1);

  000b7	48 8b 54 24 30	 mov	 rdx, QWORD PTR str$[rsp]
  000bc	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c1	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000c5	e8 00 00 00 00	 call	 Pdata_push
  000ca	85 c0		 test	 eax, eax
  000cc	7d 07		 jge	 SHORT $LN1@load_binun
  000ce	b8 ff ff ff ff	 mov	 eax, -1
  000d3	eb 08		 jmp	 SHORT $LN9@load_binun
$LN1@load_binun:
  000d5	33 c0		 xor	 eax, eax
  000d7	85 c0		 test	 eax, eax
  000d9	75 dc		 jne	 SHORT $LN4@load_binun

; 4398 :     return 0;

  000db	33 c0		 xor	 eax, eax
$LN9@load_binun:

; 4399 : }

  000dd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e1	c3		 ret	 0
load_binunicode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_tuple DD imagerel load_tuple
	DD	imagerel load_tuple+121
	DD	imagerel $unwind$load_tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_tuple DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_tuple
_TEXT	SEGMENT
i$ = 32
tuple$ = 40
self$ = 64
load_tuple PROC						; COMDAT

; 4403 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4404 :     PyObject *tuple;
; 4405 :     Py_ssize_t i;
; 4406 : 
; 4407 :     if ((i = marker(self)) < 0)

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 marker
  00013	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0001e	7d 07		 jge	 SHORT $LN6@load_tuple

; 4408 :         return -1;

  00020	b8 ff ff ff ff	 mov	 eax, -1
  00025	eb 4d		 jmp	 SHORT $LN7@load_tuple
$LN6@load_tuple:

; 4409 : 
; 4410 :     tuple = Pdata_poptuple(self->stack, i);

  00027	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00031	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00035	e8 00 00 00 00	 call	 Pdata_poptuple
  0003a	48 89 44 24 28	 mov	 QWORD PTR tuple$[rsp], rax

; 4411 :     if (tuple == NULL)

  0003f	48 83 7c 24 28
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  00045	75 07		 jne	 SHORT $LN5@load_tuple

; 4412 :         return -1;

  00047	b8 ff ff ff ff	 mov	 eax, -1
  0004c	eb 26		 jmp	 SHORT $LN7@load_tuple
$LN5@load_tuple:
$LN4@load_tuple:

; 4413 :     PDATA_PUSH(self->stack, tuple, -1);

  0004e	48 8b 54 24 28	 mov	 rdx, QWORD PTR tuple$[rsp]
  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00058	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0005c	e8 00 00 00 00	 call	 Pdata_push
  00061	85 c0		 test	 eax, eax
  00063	7d 07		 jge	 SHORT $LN1@load_tuple
  00065	b8 ff ff ff ff	 mov	 eax, -1
  0006a	eb 08		 jmp	 SHORT $LN7@load_tuple
$LN1@load_tuple:
  0006c	33 c0		 xor	 eax, eax
  0006e	85 c0		 test	 eax, eax
  00070	75 dc		 jne	 SHORT $LN4@load_tuple

; 4414 :     return 0;

  00072	33 c0		 xor	 eax, eax
$LN7@load_tuple:

; 4415 : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
load_tuple ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_poptuple DD imagerel Pdata_poptuple
	DD	imagerel Pdata_poptuple+181
	DD	imagerel $unwind$Pdata_poptuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_poptuple DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Pdata_poptuple
_TEXT	SEGMENT
i$ = 32
len$ = 40
tuple$ = 48
j$ = 56
self$ = 80
start$ = 88
Pdata_poptuple PROC					; COMDAT

; 272  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 273  :     PyObject *tuple;
; 274  :     Py_ssize_t len, i, j;
; 275  : 
; 276  :     len = Py_SIZE(self) - start;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 4c 24 58	 mov	 rcx, QWORD PTR start$[rsp]
  00018	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001c	48 2b c1	 sub	 rax, rcx
  0001f	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 277  :     tuple = PyTuple_New(len);

  00024	48 8b 4c 24 28	 mov	 rcx, QWORD PTR len$[rsp]
  00029	e8 00 00 00 00	 call	 PyTuple_New
  0002e	48 89 44 24 30	 mov	 QWORD PTR tuple$[rsp], rax

; 278  :     if (tuple == NULL)

  00033	48 83 7c 24 30
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  00039	75 04		 jne	 SHORT $LN4@Pdata_popt

; 279  :         return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 71		 jmp	 SHORT $LN5@Pdata_popt
$LN4@Pdata_popt:

; 280  :     for (i = start, j = 0; j < len; i++, j++)

  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR start$[rsp]
  00044	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00049	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00052	eb 1a		 jmp	 SHORT $LN3@Pdata_popt
$LN2@Pdata_popt:
  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00059	48 ff c0	 inc	 rax
  0005c	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00061	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  00066	48 ff c0	 inc	 rax
  00069	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax
$LN3@Pdata_popt:
  0006e	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00073	48 39 44 24 38	 cmp	 QWORD PTR j$[rsp], rax
  00078	7d 23		 jge	 SHORT $LN1@Pdata_popt

; 281  :         PyTuple_SET_ITEM(tuple, j, self->data[i]);

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0007f	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00083	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tuple$[rsp]
  00088	48 8b 54 24 38	 mov	 rdx, QWORD PTR j$[rsp]
  0008d	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00092	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  00096	48 89 44 d1 70	 mov	 QWORD PTR [rcx+rdx*8+112], rax
  0009b	eb b7		 jmp	 SHORT $LN2@Pdata_popt
$LN1@Pdata_popt:

; 282  : 
; 283  :     Py_SIZE(self) = start;

  0009d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR start$[rsp]
  000a7	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 284  :     return tuple;

  000ab	48 8b 44 24 30	 mov	 rax, QWORD PTR tuple$[rsp]
$LN5@Pdata_popt:

; 285  : }

  000b0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b4	c3		 ret	 0
Pdata_poptuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@FHCIFDJG@could?5not?5find?5MARK?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$marker DD imagerel marker
	DD	imagerel marker+115
	DD	imagerel $unwind$marker
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$marker DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BE@FHCIFDJG@could?5not?5find?5MARK?$AA@
CONST	SEGMENT
??_C@_0BE@FHCIFDJG@could?5not?5find?5MARK?$AA@ DB 'could not find MARK', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT marker
_TEXT	SEGMENT
tv71 = 32
self$ = 64
marker	PROC						; COMDAT

; 3907 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3908 :     if (self->num_marks < 1) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 30 01
	00 00 01	 cmp	 QWORD PTR [rax+304], 1
  00016	7d 1c		 jge	 SHORT $LN1@marker

; 3909 :         PyErr_SetString(UnpicklingError, "could not find MARK");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@FHCIFDJG@could?5not?5find?5MARK?$AA@
  0001f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00026	e8 00 00 00 00	 call	 PyErr_SetString

; 3910 :         return -1;

  0002b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00032	eb 3a		 jmp	 SHORT $LN2@marker
$LN1@marker:

; 3911 :     }
; 3912 : 
; 3913 :     return self->marks[--self->num_marks];

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00039	48 8b 80 30 01
	00 00		 mov	 rax, QWORD PTR [rax+304]
  00040	48 ff c8	 dec	 rax
  00043	48 89 44 24 20	 mov	 QWORD PTR tv71[rsp], rax
  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv71[rsp]
  00052	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx
  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0005e	48 8b 80 28 01
	00 00		 mov	 rax, QWORD PTR [rax+296]
  00065	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv71[rsp]
  0006a	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
$LN2@marker:

; 3914 : }

  0006e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00072	c3		 ret	 0
marker	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_counted_tuple DD imagerel load_counted_tuple
	DD	imagerel load_counted_tuple+168
	DD	imagerel $unwind$load_counted_tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_counted_tuple DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_counted_tuple
_TEXT	SEGMENT
tuple$ = 32
item$23648 = 40
self$ = 64
len$ = 72
load_counted_tuple PROC					; COMDAT

; 4419 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4420 :     PyObject *tuple;
; 4421 : 
; 4422 :     tuple = PyTuple_New(len);

  0000d	48 63 44 24 48	 movsxd	 rax, DWORD PTR len$[rsp]
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 PyTuple_New
  0001a	48 89 44 24 20	 mov	 QWORD PTR tuple$[rsp], rax

; 4423 :     if (tuple == NULL)

  0001f	48 83 7c 24 20
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  00025	75 07		 jne	 SHORT $LN11@load_count@2

; 4424 :         return -1;

  00027	b8 ff ff ff ff	 mov	 eax, -1
  0002c	eb 75		 jmp	 SHORT $LN12@load_count@2
$LN11@load_count@2:
$LN10@load_count@2:

; 4425 : 
; 4426 :     while (--len >= 0) {

  0002e	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  00032	ff c8		 dec	 eax
  00034	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax
  00038	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  0003d	7c 3e		 jl	 SHORT $LN9@load_count@2
$LN8@load_count@2:

; 4427 :         PyObject *item;
; 4428 : 
; 4429 :         PDATA_POP(self->stack, item);

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00044	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00048	e8 00 00 00 00	 call	 Pdata_pop
  0004d	48 89 44 24 28	 mov	 QWORD PTR item$23648[rsp], rax
  00052	33 c0		 xor	 eax, eax
  00054	85 c0		 test	 eax, eax
  00056	75 e7		 jne	 SHORT $LN8@load_count@2

; 4430 :         if (item == NULL)

  00058	48 83 7c 24 28
	00		 cmp	 QWORD PTR item$23648[rsp], 0
  0005e	75 07		 jne	 SHORT $LN5@load_count@2

; 4431 :             return -1;

  00060	b8 ff ff ff ff	 mov	 eax, -1
  00065	eb 3c		 jmp	 SHORT $LN12@load_count@2
$LN5@load_count@2:

; 4432 :         PyTuple_SET_ITEM(tuple, len, item);

  00067	48 63 44 24 48	 movsxd	 rax, DWORD PTR len$[rsp]
  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tuple$[rsp]
  00071	48 8b 54 24 28	 mov	 rdx, QWORD PTR item$23648[rsp]
  00076	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 4433 :     }

  0007b	eb b1		 jmp	 SHORT $LN10@load_count@2
$LN9@load_count@2:
$LN4@load_count@2:

; 4434 :     PDATA_PUSH(self->stack, tuple, -1);

  0007d	48 8b 54 24 20	 mov	 rdx, QWORD PTR tuple$[rsp]
  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00087	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0008b	e8 00 00 00 00	 call	 Pdata_push
  00090	85 c0		 test	 eax, eax
  00092	7d 07		 jge	 SHORT $LN1@load_count@2
  00094	b8 ff ff ff ff	 mov	 eax, -1
  00099	eb 08		 jmp	 SHORT $LN12@load_count@2
$LN1@load_count@2:
  0009b	33 c0		 xor	 eax, eax
  0009d	85 c0		 test	 eax, eax
  0009f	75 dc		 jne	 SHORT $LN4@load_count@2

; 4435 :     return 0;

  000a1	33 c0		 xor	 eax, eax
$LN12@load_count@2:

; 4436 : }

  000a3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a7	c3		 ret	 0
load_counted_tuple ENDP
_TEXT	ENDS
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_empty_list DD imagerel load_empty_list
	DD	imagerel load_empty_list+79
	DD	imagerel $unwind$load_empty_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_empty_list DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_empty_list
_TEXT	SEGMENT
list$ = 32
self$ = 64
load_empty_list PROC					; COMDAT

; 4440 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4441 :     PyObject *list;
; 4442 : 
; 4443 :     if ((list = PyList_New(0)) == NULL)

  00009	33 c9		 xor	 ecx, ecx
  0000b	e8 00 00 00 00	 call	 PyList_New
  00010	48 89 44 24 20	 mov	 QWORD PTR list$[rsp], rax
  00015	48 83 7c 24 20
	00		 cmp	 QWORD PTR list$[rsp], 0
  0001b	75 07		 jne	 SHORT $LN5@load_empty

; 4444 :         return -1;

  0001d	b8 ff ff ff ff	 mov	 eax, -1
  00022	eb 26		 jmp	 SHORT $LN6@load_empty
$LN5@load_empty:
$LN4@load_empty:

; 4445 :     PDATA_PUSH(self->stack, list, -1);

  00024	48 8b 54 24 20	 mov	 rdx, QWORD PTR list$[rsp]
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00032	e8 00 00 00 00	 call	 Pdata_push
  00037	85 c0		 test	 eax, eax
  00039	7d 07		 jge	 SHORT $LN1@load_empty
  0003b	b8 ff ff ff ff	 mov	 eax, -1
  00040	eb 08		 jmp	 SHORT $LN6@load_empty
$LN1@load_empty:
  00042	33 c0		 xor	 eax, eax
  00044	85 c0		 test	 eax, eax
  00046	75 dc		 jne	 SHORT $LN4@load_empty

; 4446 :     return 0;

  00048	33 c0		 xor	 eax, eax
$LN6@load_empty:

; 4447 : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
load_empty_list ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_empty_dict DD imagerel load_empty_dict
	DD	imagerel load_empty_dict+77
	DD	imagerel $unwind$load_empty_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_empty_dict DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_empty_dict
_TEXT	SEGMENT
dict$ = 32
self$ = 64
load_empty_dict PROC					; COMDAT

; 4451 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4452 :     PyObject *dict;
; 4453 : 
; 4454 :     if ((dict = PyDict_New()) == NULL)

  00009	e8 00 00 00 00	 call	 PyDict_New
  0000e	48 89 44 24 20	 mov	 QWORD PTR dict$[rsp], rax
  00013	48 83 7c 24 20
	00		 cmp	 QWORD PTR dict$[rsp], 0
  00019	75 07		 jne	 SHORT $LN5@load_empty@2

; 4455 :         return -1;

  0001b	b8 ff ff ff ff	 mov	 eax, -1
  00020	eb 26		 jmp	 SHORT $LN6@load_empty@2
$LN5@load_empty@2:
$LN4@load_empty@2:

; 4456 :     PDATA_PUSH(self->stack, dict, -1);

  00022	48 8b 54 24 20	 mov	 rdx, QWORD PTR dict$[rsp]
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002c	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00030	e8 00 00 00 00	 call	 Pdata_push
  00035	85 c0		 test	 eax, eax
  00037	7d 07		 jge	 SHORT $LN1@load_empty@2
  00039	b8 ff ff ff ff	 mov	 eax, -1
  0003e	eb 08		 jmp	 SHORT $LN6@load_empty@2
$LN1@load_empty@2:
  00040	33 c0		 xor	 eax, eax
  00042	85 c0		 test	 eax, eax
  00044	75 dc		 jne	 SHORT $LN4@load_empty@2

; 4457 :     return 0;

  00046	33 c0		 xor	 eax, eax
$LN6@load_empty@2:

; 4458 : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
load_empty_dict ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_list DD imagerel load_list
	DD	imagerel load_list+121
	DD	imagerel $unwind$load_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_list DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_list
_TEXT	SEGMENT
i$ = 32
list$ = 40
self$ = 64
load_list PROC						; COMDAT

; 4462 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4463 :     PyObject *list;
; 4464 :     Py_ssize_t i;
; 4465 : 
; 4466 :     if ((i = marker(self)) < 0)

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 marker
  00013	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0001e	7d 07		 jge	 SHORT $LN6@load_list

; 4467 :         return -1;

  00020	b8 ff ff ff ff	 mov	 eax, -1
  00025	eb 4d		 jmp	 SHORT $LN7@load_list
$LN6@load_list:

; 4468 : 
; 4469 :     list = Pdata_poplist(self->stack, i);

  00027	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00031	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00035	e8 00 00 00 00	 call	 Pdata_poplist
  0003a	48 89 44 24 28	 mov	 QWORD PTR list$[rsp], rax

; 4470 :     if (list == NULL)

  0003f	48 83 7c 24 28
	00		 cmp	 QWORD PTR list$[rsp], 0
  00045	75 07		 jne	 SHORT $LN5@load_list

; 4471 :         return -1;

  00047	b8 ff ff ff ff	 mov	 eax, -1
  0004c	eb 26		 jmp	 SHORT $LN7@load_list
$LN5@load_list:
$LN4@load_list:

; 4472 :     PDATA_PUSH(self->stack, list, -1);

  0004e	48 8b 54 24 28	 mov	 rdx, QWORD PTR list$[rsp]
  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00058	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0005c	e8 00 00 00 00	 call	 Pdata_push
  00061	85 c0		 test	 eax, eax
  00063	7d 07		 jge	 SHORT $LN1@load_list
  00065	b8 ff ff ff ff	 mov	 eax, -1
  0006a	eb 08		 jmp	 SHORT $LN7@load_list
$LN1@load_list:
  0006c	33 c0		 xor	 eax, eax
  0006e	85 c0		 test	 eax, eax
  00070	75 dc		 jne	 SHORT $LN4@load_list

; 4473 :     return 0;

  00072	33 c0		 xor	 eax, eax
$LN7@load_list:

; 4474 : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
load_list ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_poplist DD imagerel Pdata_poplist
	DD	imagerel Pdata_poplist+184
	DD	imagerel $unwind$Pdata_poplist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_poplist DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Pdata_poplist
_TEXT	SEGMENT
i$ = 32
len$ = 40
list$ = 48
j$ = 56
self$ = 80
start$ = 88
Pdata_poplist PROC					; COMDAT

; 289  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 290  :     PyObject *list;
; 291  :     Py_ssize_t len, i, j;
; 292  : 
; 293  :     len = Py_SIZE(self) - start;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 4c 24 58	 mov	 rcx, QWORD PTR start$[rsp]
  00018	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001c	48 2b c1	 sub	 rax, rcx
  0001f	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 294  :     list = PyList_New(len);

  00024	48 8b 4c 24 28	 mov	 rcx, QWORD PTR len$[rsp]
  00029	e8 00 00 00 00	 call	 PyList_New
  0002e	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 295  :     if (list == NULL)

  00033	48 83 7c 24 30
	00		 cmp	 QWORD PTR list$[rsp], 0
  00039	75 04		 jne	 SHORT $LN4@Pdata_popl

; 296  :         return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 74		 jmp	 SHORT $LN5@Pdata_popl
$LN4@Pdata_popl:

; 297  :     for (i = start, j = 0; j < len; i++, j++)

  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR start$[rsp]
  00044	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00049	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00052	eb 1a		 jmp	 SHORT $LN3@Pdata_popl
$LN2@Pdata_popl:
  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00059	48 ff c0	 inc	 rax
  0005c	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00061	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  00066	48 ff c0	 inc	 rax
  00069	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax
$LN3@Pdata_popl:
  0006e	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00073	48 39 44 24 38	 cmp	 QWORD PTR j$[rsp], rax
  00078	7d 26		 jge	 SHORT $LN1@Pdata_popl

; 298  :         PyList_SET_ITEM(list, j, self->data[i]);

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0007f	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00083	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00088	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0008c	48 8b 54 24 38	 mov	 rdx, QWORD PTR j$[rsp]
  00091	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00096	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  0009a	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0009e	eb b4		 jmp	 SHORT $LN2@Pdata_popl
$LN1@Pdata_popl:

; 299  : 
; 300  :     Py_SIZE(self) = start;

  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000a5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR start$[rsp]
  000aa	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 301  :     return list;

  000ae	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
$LN5@Pdata_popl:

; 302  : }

  000b3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b7	c3		 ret	 0
Pdata_poplist ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_dict DD imagerel load_dict
	DD	imagerel load_dict+289
	DD	imagerel $unwind$load_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_dict DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_dict
_TEXT	SEGMENT
value$ = 32
i$ = 40
dict$ = 48
key$ = 56
k$ = 64
j$ = 72
self$ = 96
load_dict PROC						; COMDAT

; 4478 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4479 :     PyObject *dict, *key, *value;
; 4480 :     Py_ssize_t i, j, k;
; 4481 : 
; 4482 :     if ((i = marker(self)) < 0)

  00009	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 marker
  00013	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00018	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  0001e	7d 0a		 jge	 SHORT $LN10@load_dict

; 4483 :         return -1;

  00020	b8 ff ff ff ff	 mov	 eax, -1
  00025	e9 f2 00 00 00	 jmp	 $LN11@load_dict
$LN10@load_dict:

; 4484 :     j = Py_SIZE(self->stack);

  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0002f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00033	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00037	48 89 44 24 48	 mov	 QWORD PTR j$[rsp], rax

; 4485 : 
; 4486 :     if ((dict = PyDict_New()) == NULL)

  0003c	e8 00 00 00 00	 call	 PyDict_New
  00041	48 89 44 24 30	 mov	 QWORD PTR dict$[rsp], rax
  00046	48 83 7c 24 30
	00		 cmp	 QWORD PTR dict$[rsp], 0
  0004c	75 0a		 jne	 SHORT $LN9@load_dict

; 4487 :         return -1;

  0004e	b8 ff ff ff ff	 mov	 eax, -1
  00053	e9 c4 00 00 00	 jmp	 $LN11@load_dict
$LN9@load_dict:

; 4488 : 
; 4489 :     for (k = i + 1; k < j; k += 2) {

  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0005d	48 ff c0	 inc	 rax
  00060	48 89 44 24 40	 mov	 QWORD PTR k$[rsp], rax
  00065	eb 0e		 jmp	 SHORT $LN8@load_dict
$LN7@load_dict:
  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR k$[rsp]
  0006c	48 83 c0 02	 add	 rax, 2
  00070	48 89 44 24 40	 mov	 QWORD PTR k$[rsp], rax
$LN8@load_dict:
  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR j$[rsp]
  0007a	48 39 44 24 40	 cmp	 QWORD PTR k$[rsp], rax
  0007f	7d 62		 jge	 SHORT $LN6@load_dict

; 4490 :         key = self->stack->data[k - 1];

  00081	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00086	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR k$[rsp]
  00093	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  00098	48 89 44 24 38	 mov	 QWORD PTR key$[rsp], rax

; 4491 :         value = self->stack->data[k];

  0009d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000a2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a6	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR k$[rsp]
  000af	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000b3	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 4492 :         if (PyDict_SetItem(dict, key, value) < 0) {

  000b8	4c 8b 44 24 20	 mov	 r8, QWORD PTR value$[rsp]
  000bd	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dict$[rsp]
  000c7	e8 00 00 00 00	 call	 PyDict_SetItem
  000cc	85 c0		 test	 eax, eax
  000ce	7d 11		 jge	 SHORT $LN5@load_dict

; 4493 :             Py_DECREF(dict);

  000d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dict$[rsp]
  000d5	e8 00 00 00 00	 call	 _Py_DecRef

; 4494 :             return -1;

  000da	b8 ff ff ff ff	 mov	 eax, -1
  000df	eb 3b		 jmp	 SHORT $LN11@load_dict
$LN5@load_dict:

; 4495 :         }
; 4496 :     }

  000e1	eb 84		 jmp	 SHORT $LN7@load_dict
$LN6@load_dict:

; 4497 :     Pdata_clear(self->stack, i);

  000e3	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  000e8	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000ed	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000f1	e8 00 00 00 00	 call	 Pdata_clear
$LN4@load_dict:

; 4498 :     PDATA_PUSH(self->stack, dict, -1);

  000f6	48 8b 54 24 30	 mov	 rdx, QWORD PTR dict$[rsp]
  000fb	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00100	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00104	e8 00 00 00 00	 call	 Pdata_push
  00109	85 c0		 test	 eax, eax
  0010b	7d 07		 jge	 SHORT $LN1@load_dict
  0010d	b8 ff ff ff ff	 mov	 eax, -1
  00112	eb 08		 jmp	 SHORT $LN11@load_dict
$LN1@load_dict:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 dc		 jne	 SHORT $LN4@load_dict

; 4499 :     return 0;

  0011a	33 c0		 xor	 eax, eax
$LN11@load_dict:

; 4500 : }

  0011c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00120	c3		 ret	 0
load_dict ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_obj DD imagerel load_obj
	DD	imagerel load_obj+227
	DD	imagerel $unwind$load_obj
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_obj DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_obj
_TEXT	SEGMENT
args$ = 32
i$ = 40
cls$ = 48
obj$ = 56
self$ = 80
load_obj PROC						; COMDAT

; 4525 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4526 :     PyObject *cls, *args, *obj = NULL;

  00009	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR obj$[rsp], 0

; 4527 :     Py_ssize_t i;
; 4528 : 
; 4529 :     if ((i = marker(self)) < 0)

  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00017	e8 00 00 00 00	 call	 marker
  0001c	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00021	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00027	7d 0a		 jge	 SHORT $LN11@load_obj

; 4530 :         return -1;

  00029	b8 ff ff ff ff	 mov	 eax, -1
  0002e	e9 ab 00 00 00	 jmp	 $LN12@load_obj
$LN11@load_obj:

; 4531 : 
; 4532 :     args = Pdata_poptuple(self->stack, i + 1);

  00033	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00038	48 ff c0	 inc	 rax
  0003b	48 8b d0	 mov	 rdx, rax
  0003e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00043	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00047	e8 00 00 00 00	 call	 Pdata_poptuple
  0004c	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 4533 :     if (args == NULL)

  00051	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  00057	75 07		 jne	 SHORT $LN10@load_obj

; 4534 :         return -1;

  00059	b8 ff ff ff ff	 mov	 eax, -1
  0005e	eb 7e		 jmp	 SHORT $LN12@load_obj
$LN10@load_obj:
$LN9@load_obj:

; 4535 : 
; 4536 :     PDATA_POP(self->stack, cls);

  00060	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00065	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00069	e8 00 00 00 00	 call	 Pdata_pop
  0006e	48 89 44 24 30	 mov	 QWORD PTR cls$[rsp], rax
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 e7		 jne	 SHORT $LN9@load_obj

; 4537 :     if (cls) {

  00079	48 83 7c 24 30
	00		 cmp	 QWORD PTR cls$[rsp], 0
  0007f	74 1e		 je	 SHORT $LN6@load_obj

; 4538 :         obj = instantiate(cls, args);

  00081	48 8b 54 24 20	 mov	 rdx, QWORD PTR args$[rsp]
  00086	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cls$[rsp]
  0008b	e8 00 00 00 00	 call	 instantiate
  00090	48 89 44 24 38	 mov	 QWORD PTR obj$[rsp], rax

; 4539 :         Py_DECREF(cls);

  00095	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cls$[rsp]
  0009a	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@load_obj:

; 4540 :     }
; 4541 :     Py_DECREF(args);

  0009f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  000a4	e8 00 00 00 00	 call	 _Py_DecRef

; 4542 :     if (obj == NULL)

  000a9	48 83 7c 24 38
	00		 cmp	 QWORD PTR obj$[rsp], 0
  000af	75 07		 jne	 SHORT $LN5@load_obj

; 4543 :         return -1;

  000b1	b8 ff ff ff ff	 mov	 eax, -1
  000b6	eb 26		 jmp	 SHORT $LN12@load_obj
$LN5@load_obj:
$LN4@load_obj:

; 4544 : 
; 4545 :     PDATA_PUSH(self->stack, obj, -1);

  000b8	48 8b 54 24 38	 mov	 rdx, QWORD PTR obj$[rsp]
  000bd	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c2	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000c6	e8 00 00 00 00	 call	 Pdata_push
  000cb	85 c0		 test	 eax, eax
  000cd	7d 07		 jge	 SHORT $LN1@load_obj
  000cf	b8 ff ff ff ff	 mov	 eax, -1
  000d4	eb 08		 jmp	 SHORT $LN12@load_obj
$LN1@load_obj:
  000d6	33 c0		 xor	 eax, eax
  000d8	85 c0		 test	 eax, eax
  000da	75 dc		 jne	 SHORT $LN4@load_obj

; 4546 :     return 0;

  000dc	33 c0		 xor	 eax, eax
$LN12@load_obj:

; 4547 : }

  000de	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e2	c3		 ret	 0
load_obj ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
PUBLIC	??_C@_1CI@KAJNBGPM@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyObject_CallObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$instantiate DD imagerel instantiate
	DD	imagerel instantiate+242
	DD	imagerel $unwind$instantiate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$instantiate DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@KAJNBGPM@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@KAJNBGPM@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'T', 00H, 'u', 00H, 'p', 00H, 'l', 00H, 'e', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'a', 00H, 'r', 00H, 'g', 00H, 's', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT instantiate
_TEXT	SEGMENT
result$ = 32
cls$ = 64
args$ = 72
instantiate PROC					; COMDAT

; 4504 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4505 :     PyObject *result = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 4506 :     _Py_IDENTIFIER(__getinitargs__);
; 4507 :     /* Caller must assure args are a tuple.  Normally, args come from
; 4508 :        Pdata_poptuple which packs objects from the top of the stack
; 4509 :        into a newly created tuple. */
; 4510 :     assert(PyTuple_Check(args));

  00017	48 8b 44 24 48	 mov	 rax, QWORD PTR args$[rsp]
  0001c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00020	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00026	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0002b	85 c0		 test	 eax, eax
  0002d	75 1c		 jne	 SHORT $LN6@instantiat
  0002f	41 b8 9e 11 00
	00		 mov	 r8d, 4510		; 0000119eH
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KAJNBGPM@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?$AA@
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00049	33 c0		 xor	 eax, eax
$LN6@instantiat:

; 4511 :     if (Py_SIZE(args) > 0 || !PyType_Check(cls) ||
; 4512 :         _PyObject_HasAttrId(cls, &PyId___getinitargs__)) {

  0004b	48 8b 44 24 48	 mov	 rax, QWORD PTR args$[rsp]
  00050	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00055	7f 43		 jg	 SHORT $LN2@instantiat
  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR cls$[rsp]
  0005c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00060	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00066	25 00 00 00 80	 and	 eax, -2147483648	; ffffffff80000000H
  0006b	85 c0		 test	 eax, eax
  0006d	74 2b		 je	 SHORT $LN2@instantiat
  0006f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___getinitargs__@?1??instantiate@@9@9
  00074	8b c0		 mov	 eax, eax
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0007c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00085	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00089	48 8b d0	 mov	 rdx, rax
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$[rsp]
  00091	e8 00 00 00 00	 call	 _PyObject_HasAttrId
  00096	85 c0		 test	 eax, eax
  00098	74 16		 je	 SHORT $LN3@instantiat
$LN2@instantiat:

; 4513 :         result = PyObject_CallObject(cls, args);

  0009a	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$[rsp]
  000a4	e8 00 00 00 00	 call	 PyObject_CallObject
  000a9	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 4514 :     }
; 4515 :     else {

  000ae	eb 38		 jmp	 SHORT $LN1@instantiat
$LN3@instantiat:

; 4516 :         _Py_IDENTIFIER(__new__);
; 4517 : 
; 4518 :         result = _PyObject_CallMethodId(cls, &PyId___new__, "O", cls);

  000b0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___new__@?3??instantiate@@9@9
  000b5	8b c0		 mov	 eax, eax
  000b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000bd	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000c6	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000ca	4c 8b 4c 24 40	 mov	 r9, QWORD PTR cls$[rsp]
  000cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000d6	48 8b d0	 mov	 rdx, rax
  000d9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$[rsp]
  000de	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  000e3	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN1@instantiat:

; 4519 :     }
; 4520 :     return result;

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 4521 : }

  000ed	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f1	c3		 ret	 0
instantiate ENDP
_TEXT	ENDS
EXTRN	PyUnicode_DecodeASCII:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_inst DD imagerel load_inst
	DD	imagerel load_inst+453
	DD	imagerel $unwind$load_inst
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_inst DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_inst
_TEXT	SEGMENT
args$ = 32
i$ = 40
s$ = 48
len$ = 56
cls$ = 64
module_name$ = 72
class_name$ = 80
obj$ = 88
self$ = 112
load_inst PROC						; COMDAT

; 4551 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4552 :     PyObject *cls = NULL;

  00009	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR cls$[rsp], 0

; 4553 :     PyObject *args = NULL;

  00012	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 4554 :     PyObject *obj = NULL;

  0001b	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR obj$[rsp], 0

; 4555 :     PyObject *module_name;
; 4556 :     PyObject *class_name;
; 4557 :     Py_ssize_t len;
; 4558 :     Py_ssize_t i;
; 4559 :     char *s;
; 4560 : 
; 4561 :     if ((i = marker(self)) < 0)

  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00029	e8 00 00 00 00	 call	 marker
  0002e	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00033	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00039	7d 0a		 jge	 SHORT $LN14@load_inst

; 4562 :         return -1;

  0003b	b8 ff ff ff ff	 mov	 eax, -1
  00040	e9 7b 01 00 00	 jmp	 $LN15@load_inst
$LN14@load_inst:

; 4563 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00045	48 8d 54 24 30	 lea	 rdx, QWORD PTR s$[rsp]
  0004a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0004f	e8 00 00 00 00	 call	 _Unpickler_Readline
  00054	48 89 44 24 38	 mov	 QWORD PTR len$[rsp], rax
  00059	48 83 7c 24 38
	00		 cmp	 QWORD PTR len$[rsp], 0
  0005f	7d 0a		 jge	 SHORT $LN13@load_inst

; 4564 :         return -1;

  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	e9 55 01 00 00	 jmp	 $LN15@load_inst
$LN13@load_inst:

; 4565 :     if (len < 2)

  0006b	48 83 7c 24 38
	02		 cmp	 QWORD PTR len$[rsp], 2
  00071	7d 0a		 jge	 SHORT $LN12@load_inst

; 4566 :         return bad_readline();

  00073	e8 00 00 00 00	 call	 bad_readline
  00078	e9 43 01 00 00	 jmp	 $LN15@load_inst
$LN12@load_inst:

; 4567 : 
; 4568 :     /* Here it is safe to use PyUnicode_DecodeASCII(), even though non-ASCII
; 4569 :        identifiers are permitted in Python 3.0, since the INST opcode is only
; 4570 :        supported by older protocols on Python 2.x. */
; 4571 :     module_name = PyUnicode_DecodeASCII(s, len - 1, "strict");

  0007d	48 8b 44 24 38	 mov	 rax, QWORD PTR len$[rsp]
  00082	48 ff c8	 dec	 rax
  00085	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  0008c	48 8b d0	 mov	 rdx, rax
  0008f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00094	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  00099	48 89 44 24 48	 mov	 QWORD PTR module_name$[rsp], rax

; 4572 :     if (module_name == NULL)

  0009e	48 83 7c 24 48
	00		 cmp	 QWORD PTR module_name$[rsp], 0
  000a4	75 0a		 jne	 SHORT $LN11@load_inst

; 4573 :         return -1;

  000a6	b8 ff ff ff ff	 mov	 eax, -1
  000ab	e9 10 01 00 00	 jmp	 $LN15@load_inst
$LN11@load_inst:

; 4574 : 
; 4575 :     if ((len = _Unpickler_Readline(self, &s)) >= 0) {

  000b0	48 8d 54 24 30	 lea	 rdx, QWORD PTR s$[rsp]
  000b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000ba	e8 00 00 00 00	 call	 _Unpickler_Readline
  000bf	48 89 44 24 38	 mov	 QWORD PTR len$[rsp], rax
  000c4	48 83 7c 24 38
	00		 cmp	 QWORD PTR len$[rsp], 0
  000ca	7c 5e		 jl	 SHORT $LN10@load_inst

; 4576 :         if (len < 2)

  000cc	48 83 7c 24 38
	02		 cmp	 QWORD PTR len$[rsp], 2
  000d2	7d 0a		 jge	 SHORT $LN9@load_inst

; 4577 :             return bad_readline();

  000d4	e8 00 00 00 00	 call	 bad_readline
  000d9	e9 e2 00 00 00	 jmp	 $LN15@load_inst
$LN9@load_inst:

; 4578 :         class_name = PyUnicode_DecodeASCII(s, len - 1, "strict");

  000de	48 8b 44 24 38	 mov	 rax, QWORD PTR len$[rsp]
  000e3	48 ff c8	 dec	 rax
  000e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  000ed	48 8b d0	 mov	 rdx, rax
  000f0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000f5	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  000fa	48 89 44 24 50	 mov	 QWORD PTR class_name$[rsp], rax

; 4579 :         if (class_name != NULL) {

  000ff	48 83 7c 24 50
	00		 cmp	 QWORD PTR class_name$[rsp], 0
  00105	74 23		 je	 SHORT $LN8@load_inst

; 4580 :             cls = find_class(self, module_name, class_name);

  00107	4c 8b 44 24 50	 mov	 r8, QWORD PTR class_name$[rsp]
  0010c	48 8b 54 24 48	 mov	 rdx, QWORD PTR module_name$[rsp]
  00111	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00116	e8 00 00 00 00	 call	 find_class
  0011b	48 89 44 24 40	 mov	 QWORD PTR cls$[rsp], rax

; 4581 :             Py_DECREF(class_name);

  00120	48 8b 4c 24 50	 mov	 rcx, QWORD PTR class_name$[rsp]
  00125	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@load_inst:
$LN10@load_inst:

; 4582 :         }
; 4583 :     }
; 4584 :     Py_DECREF(module_name);

  0012a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR module_name$[rsp]
  0012f	e8 00 00 00 00	 call	 _Py_DecRef

; 4585 : 
; 4586 :     if (cls == NULL)

  00134	48 83 7c 24 40
	00		 cmp	 QWORD PTR cls$[rsp], 0
  0013a	75 07		 jne	 SHORT $LN7@load_inst

; 4587 :         return -1;

  0013c	b8 ff ff ff ff	 mov	 eax, -1
  00141	eb 7d		 jmp	 SHORT $LN15@load_inst
$LN7@load_inst:

; 4588 : 
; 4589 :     if ((args = Pdata_poptuple(self->stack, i)) != NULL) {

  00143	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00148	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0014d	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00151	e8 00 00 00 00	 call	 Pdata_poptuple
  00156	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax
  0015b	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  00161	74 1e		 je	 SHORT $LN6@load_inst

; 4590 :         obj = instantiate(cls, args);

  00163	48 8b 54 24 20	 mov	 rdx, QWORD PTR args$[rsp]
  00168	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$[rsp]
  0016d	e8 00 00 00 00	 call	 instantiate
  00172	48 89 44 24 58	 mov	 QWORD PTR obj$[rsp], rax

; 4591 :         Py_DECREF(args);

  00177	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  0017c	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@load_inst:

; 4592 :     }
; 4593 :     Py_DECREF(cls);

  00181	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$[rsp]
  00186	e8 00 00 00 00	 call	 _Py_DecRef

; 4594 : 
; 4595 :     if (obj == NULL)

  0018b	48 83 7c 24 58
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00191	75 07		 jne	 SHORT $LN5@load_inst

; 4596 :         return -1;

  00193	b8 ff ff ff ff	 mov	 eax, -1
  00198	eb 26		 jmp	 SHORT $LN15@load_inst
$LN5@load_inst:
$LN4@load_inst:

; 4597 : 
; 4598 :     PDATA_PUSH(self->stack, obj, -1);

  0019a	48 8b 54 24 58	 mov	 rdx, QWORD PTR obj$[rsp]
  0019f	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001a4	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  001a8	e8 00 00 00 00	 call	 Pdata_push
  001ad	85 c0		 test	 eax, eax
  001af	7d 07		 jge	 SHORT $LN1@load_inst
  001b1	b8 ff ff ff ff	 mov	 eax, -1
  001b6	eb 08		 jmp	 SHORT $LN15@load_inst
$LN1@load_inst:
  001b8	33 c0		 xor	 eax, eax
  001ba	85 c0		 test	 eax, eax
  001bc	75 dc		 jne	 SHORT $LN4@load_inst

; 4599 :     return 0;

  001be	33 c0		 xor	 eax, eax
$LN15@load_inst:

; 4600 : }

  001c0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001c4	c3		 ret	 0
load_inst ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MJJLPNK@OO?$AA@				; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$find_class DD imagerel find_class
	DD	imagerel find_class+85
	DD	imagerel $unwind$find_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$find_class DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_02MJJLPNK@OO?$AA@
CONST	SEGMENT
??_C@_02MJJLPNK@OO?$AA@ DB 'OO', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT find_class
_TEXT	SEGMENT
self$ = 64
module_name$ = 72
global_name$ = 80
find_class PROC						; COMDAT

; 3898 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3899 :     _Py_IDENTIFIER(find_class);
; 3900 : 
; 3901 :     return _PyObject_CallMethodId((PyObject *)self, &PyId_find_class, "OO",
; 3902 :                                   module_name, global_name);

  00013	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_find_class@?1??find_class@@9@9
  00018	8b c0		 mov	 eax, eax
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00020	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00029	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR global_name$[rsp]
  00032	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00037	4c 8b 4c 24 48	 mov	 r9, QWORD PTR module_name$[rsp]
  0003c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02MJJLPNK@OO?$AA@
  00043	48 8b d0	 mov	 rdx, rax
  00046	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0004b	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 3903 : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
find_class ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@INAOHFPP@NEWOBJ?5class?5argument?5has?5NULL?5t@ ; `string'
PUBLIC	??_C@_0CK@PKCLLMEF@NEWOBJ?5class?5argument?5isn?8t?5a?5ty@ ; `string'
PUBLIC	??_C@_0BO@CHFKLHLD@NEWOBJ?5expected?5an?5arg?5tuple?4?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_newobj DD imagerel load_newobj
	DD	imagerel load_newobj+402
	DD	imagerel $unwind$load_newobj
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_newobj DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0CG@INAOHFPP@NEWOBJ?5class?5argument?5has?5NULL?5t@
CONST	SEGMENT
??_C@_0CG@INAOHFPP@NEWOBJ?5class?5argument?5has?5NULL?5t@ DB 'NEWOBJ clas'
	DB	's argument has NULL tp_new', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PKCLLMEF@NEWOBJ?5class?5argument?5isn?8t?5a?5ty@
CONST	SEGMENT
??_C@_0CK@PKCLLMEF@NEWOBJ?5class?5argument?5isn?8t?5a?5ty@ DB 'NEWOBJ cla'
	DB	'ss argument isn''t a type object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CHFKLHLD@NEWOBJ?5expected?5an?5arg?5tuple?4?$AA@
CONST	SEGMENT
??_C@_0BO@CHFKLHLD@NEWOBJ?5expected?5an?5arg?5tuple?4?$AA@ DB 'NEWOBJ exp'
	DB	'ected an arg tuple.', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_newobj
_TEXT	SEGMENT
args$ = 32
clsraw$ = 40
cls$ = 48
obj$ = 56
self$ = 80
load_newobj PROC					; COMDAT

; 4604 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4605 :     PyObject *args = NULL;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 4606 :     PyObject *clsraw = NULL;

  00012	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR clsraw$[rsp], 0
$LN24@load_newob:

; 4607 :     PyTypeObject *cls;          /* clsraw cast to its true type */
; 4608 :     PyObject *obj;
; 4609 : 
; 4610 :     /* Stack is ... cls argtuple, and we want to call
; 4611 :      * cls.__new__(cls, *argtuple).
; 4612 :      */
; 4613 :     PDATA_POP(self->stack, args);

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00024	e8 00 00 00 00	 call	 Pdata_pop
  00029	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax
  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 e7		 jne	 SHORT $LN24@load_newob

; 4614 :     if (args == NULL)

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  0003a	75 05		 jne	 SHORT $LN21@load_newob

; 4615 :         goto error;

  0003c	e9 17 01 00 00	 jmp	 $error$23817
$LN21@load_newob:

; 4616 :     if (!PyTuple_Check(args)) {

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR args$[rsp]
  00046	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00050	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00055	85 c0		 test	 eax, eax
  00057	75 18		 jne	 SHORT $LN20@load_newob

; 4617 :         PyErr_SetString(UnpicklingError, "NEWOBJ expected an arg " "tuple.");

  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@CHFKLHLD@NEWOBJ?5expected?5an?5arg?5tuple?4?$AA@
  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00067	e8 00 00 00 00	 call	 PyErr_SetString

; 4618 :         goto error;

  0006c	e9 e7 00 00 00	 jmp	 $error$23817
$LN20@load_newob:
$LN19@load_newob:

; 4619 :     }
; 4620 : 
; 4621 :     PDATA_POP(self->stack, clsraw);

  00071	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00076	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0007a	e8 00 00 00 00	 call	 Pdata_pop
  0007f	48 89 44 24 28	 mov	 QWORD PTR clsraw$[rsp], rax
  00084	33 c0		 xor	 eax, eax
  00086	85 c0		 test	 eax, eax
  00088	75 e7		 jne	 SHORT $LN19@load_newob

; 4622 :     cls = (PyTypeObject *)clsraw;

  0008a	48 8b 44 24 28	 mov	 rax, QWORD PTR clsraw$[rsp]
  0008f	48 89 44 24 30	 mov	 QWORD PTR cls$[rsp], rax

; 4623 :     if (cls == NULL)

  00094	48 83 7c 24 30
	00		 cmp	 QWORD PTR cls$[rsp], 0
  0009a	75 05		 jne	 SHORT $LN16@load_newob

; 4624 :         goto error;

  0009c	e9 b7 00 00 00	 jmp	 $error$23817
$LN16@load_newob:

; 4625 :     if (!PyType_Check(cls)) {

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR cls$[rsp]
  000a6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000aa	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000b0	25 00 00 00 80	 and	 eax, -2147483648	; ffffffff80000000H
  000b5	85 c0		 test	 eax, eax
  000b7	75 18		 jne	 SHORT $LN15@load_newob

; 4626 :         PyErr_SetString(UnpicklingError, "NEWOBJ class argument "
; 4627 :                         "isn't a type object");

  000b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@PKCLLMEF@NEWOBJ?5class?5argument?5isn?8t?5a?5ty@
  000c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  000c7	e8 00 00 00 00	 call	 PyErr_SetString

; 4628 :         goto error;

  000cc	e9 87 00 00 00	 jmp	 $error$23817
$LN15@load_newob:

; 4629 :     }
; 4630 :     if (cls->tp_new == NULL) {

  000d1	48 8b 44 24 30	 mov	 rax, QWORD PTR cls$[rsp]
  000d6	48 83 b8 90 01
	00 00 00	 cmp	 QWORD PTR [rax+400], 0
  000de	75 15		 jne	 SHORT $LN14@load_newob

; 4631 :         PyErr_SetString(UnpicklingError, "NEWOBJ class argument "
; 4632 :                         "has NULL tp_new");

  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@INAOHFPP@NEWOBJ?5class?5argument?5has?5NULL?5t@
  000e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  000ee	e8 00 00 00 00	 call	 PyErr_SetString

; 4633 :         goto error;

  000f3	eb 63		 jmp	 SHORT $error$23817
$LN14@load_newob:

; 4634 :     }
; 4635 : 
; 4636 :     /* Call __new__. */
; 4637 :     obj = cls->tp_new(cls, args, NULL);

  000f5	45 33 c0	 xor	 r8d, r8d
  000f8	48 8b 54 24 20	 mov	 rdx, QWORD PTR args$[rsp]
  000fd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cls$[rsp]
  00102	48 8b 44 24 30	 mov	 rax, QWORD PTR cls$[rsp]
  00107	ff 90 90 01 00
	00		 call	 QWORD PTR [rax+400]
  0010d	48 89 44 24 38	 mov	 QWORD PTR obj$[rsp], rax

; 4638 :     if (obj == NULL)

  00112	48 83 7c 24 38
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00118	75 02		 jne	 SHORT $LN13@load_newob

; 4639 :         goto error;

  0011a	eb 3c		 jmp	 SHORT $error$23817
$LN13@load_newob:

; 4640 : 
; 4641 :     Py_DECREF(args);

  0011c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  00121	e8 00 00 00 00	 call	 _Py_DecRef

; 4642 :     Py_DECREF(clsraw);

  00126	48 8b 4c 24 28	 mov	 rcx, QWORD PTR clsraw$[rsp]
  0012b	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@load_newob:

; 4643 :     PDATA_PUSH(self->stack, obj, -1);

  00130	48 8b 54 24 38	 mov	 rdx, QWORD PTR obj$[rsp]
  00135	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0013a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0013e	e8 00 00 00 00	 call	 Pdata_push
  00143	85 c0		 test	 eax, eax
  00145	7d 07		 jge	 SHORT $LN9@load_newob
  00147	b8 ff ff ff ff	 mov	 eax, -1
  0014c	eb 3f		 jmp	 SHORT $LN25@load_newob
$LN9@load_newob:
  0014e	33 c0		 xor	 eax, eax
  00150	85 c0		 test	 eax, eax
  00152	75 dc		 jne	 SHORT $LN12@load_newob

; 4644 :     return 0;

  00154	33 c0		 xor	 eax, eax
  00156	eb 35		 jmp	 SHORT $LN25@load_newob
$error$23817:
$LN8@load_newob:

; 4645 : 
; 4646 :   error:
; 4647 :     Py_XDECREF(args);

  00158	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  0015e	74 0a		 je	 SHORT $LN5@load_newob
  00160	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  00165	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@load_newob:
  0016a	33 c0		 xor	 eax, eax
  0016c	85 c0		 test	 eax, eax
  0016e	75 e8		 jne	 SHORT $LN8@load_newob
$LN4@load_newob:

; 4648 :     Py_XDECREF(clsraw);

  00170	48 83 7c 24 28
	00		 cmp	 QWORD PTR clsraw$[rsp], 0
  00176	74 0a		 je	 SHORT $LN1@load_newob
  00178	48 8b 4c 24 28	 mov	 rcx, QWORD PTR clsraw$[rsp]
  0017d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@load_newob:
  00182	33 c0		 xor	 eax, eax
  00184	85 c0		 test	 eax, eax
  00186	75 e8		 jne	 SHORT $LN4@load_newob

; 4649 :     return -1;

  00188	b8 ff ff ff ff	 mov	 eax, -1
$LN25@load_newob:

; 4650 : }

  0018d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00191	c3		 ret	 0
load_newobj ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_global DD imagerel load_global
	DD	imagerel load_global+325
	DD	imagerel $unwind$load_global
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_global DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_global
_TEXT	SEGMENT
s$ = 32
len$ = 40
module_name$ = 48
global_name$ = 56
global$ = 64
self$ = 96
load_global PROC					; COMDAT

; 4654 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4655 :     PyObject *global = NULL;

  00009	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR global$[rsp], 0

; 4656 :     PyObject *module_name;
; 4657 :     PyObject *global_name;
; 4658 :     Py_ssize_t len;
; 4659 :     char *s;
; 4660 : 
; 4661 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00012	48 8d 54 24 20	 lea	 rdx, QWORD PTR s$[rsp]
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0001c	e8 00 00 00 00	 call	 _Unpickler_Readline
  00021	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax
  00026	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  0002c	7d 0a		 jge	 SHORT $LN11@load_globa

; 4662 :         return -1;

  0002e	b8 ff ff ff ff	 mov	 eax, -1
  00033	e9 08 01 00 00	 jmp	 $LN12@load_globa
$LN11@load_globa:

; 4663 :     if (len < 2)

  00038	48 83 7c 24 28
	02		 cmp	 QWORD PTR len$[rsp], 2
  0003e	7d 0a		 jge	 SHORT $LN10@load_globa

; 4664 :         return bad_readline();

  00040	e8 00 00 00 00	 call	 bad_readline
  00045	e9 f6 00 00 00	 jmp	 $LN12@load_globa
$LN10@load_globa:

; 4665 :     module_name = PyUnicode_DecodeUTF8(s, len - 1, "strict");

  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0004f	48 ff c8	 dec	 rax
  00052	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00059	48 8b d0	 mov	 rdx, rax
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00061	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  00066	48 89 44 24 30	 mov	 QWORD PTR module_name$[rsp], rax

; 4666 :     if (!module_name)

  0006b	48 83 7c 24 30
	00		 cmp	 QWORD PTR module_name$[rsp], 0
  00071	75 0a		 jne	 SHORT $LN9@load_globa

; 4667 :         return -1;

  00073	b8 ff ff ff ff	 mov	 eax, -1
  00078	e9 c3 00 00 00	 jmp	 $LN12@load_globa
$LN9@load_globa:

; 4668 : 
; 4669 :     if ((len = _Unpickler_Readline(self, &s)) >= 0) {

  0007d	48 8d 54 24 20	 lea	 rdx, QWORD PTR s$[rsp]
  00082	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00087	e8 00 00 00 00	 call	 _Unpickler_Readline
  0008c	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax
  00091	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  00097	7c 68		 jl	 SHORT $LN8@load_globa

; 4670 :         if (len < 2) {

  00099	48 83 7c 24 28
	02		 cmp	 QWORD PTR len$[rsp], 2
  0009f	7d 14		 jge	 SHORT $LN7@load_globa

; 4671 :             Py_DECREF(module_name);

  000a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module_name$[rsp]
  000a6	e8 00 00 00 00	 call	 _Py_DecRef

; 4672 :             return bad_readline();

  000ab	e8 00 00 00 00	 call	 bad_readline
  000b0	e9 8b 00 00 00	 jmp	 $LN12@load_globa
$LN7@load_globa:

; 4673 :         }
; 4674 :         global_name = PyUnicode_DecodeUTF8(s, len - 1, "strict");

  000b5	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  000ba	48 ff c8	 dec	 rax
  000bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  000c4	48 8b d0	 mov	 rdx, rax
  000c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000cc	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  000d1	48 89 44 24 38	 mov	 QWORD PTR global_name$[rsp], rax

; 4675 :         if (global_name) {

  000d6	48 83 7c 24 38
	00		 cmp	 QWORD PTR global_name$[rsp], 0
  000dc	74 23		 je	 SHORT $LN6@load_globa

; 4676 :             global = find_class(self, module_name, global_name);

  000de	4c 8b 44 24 38	 mov	 r8, QWORD PTR global_name$[rsp]
  000e3	48 8b 54 24 30	 mov	 rdx, QWORD PTR module_name$[rsp]
  000e8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000ed	e8 00 00 00 00	 call	 find_class
  000f2	48 89 44 24 40	 mov	 QWORD PTR global$[rsp], rax

; 4677 :             Py_DECREF(global_name);

  000f7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR global_name$[rsp]
  000fc	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@load_globa:
$LN8@load_globa:

; 4678 :         }
; 4679 :     }
; 4680 :     Py_DECREF(module_name);

  00101	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module_name$[rsp]
  00106	e8 00 00 00 00	 call	 _Py_DecRef

; 4681 : 
; 4682 :     if (global == NULL)

  0010b	48 83 7c 24 40
	00		 cmp	 QWORD PTR global$[rsp], 0
  00111	75 07		 jne	 SHORT $LN5@load_globa

; 4683 :         return -1;

  00113	b8 ff ff ff ff	 mov	 eax, -1
  00118	eb 26		 jmp	 SHORT $LN12@load_globa
$LN5@load_globa:
$LN4@load_globa:

; 4684 :     PDATA_PUSH(self->stack, global, -1);

  0011a	48 8b 54 24 40	 mov	 rdx, QWORD PTR global$[rsp]
  0011f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00124	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00128	e8 00 00 00 00	 call	 Pdata_push
  0012d	85 c0		 test	 eax, eax
  0012f	7d 07		 jge	 SHORT $LN1@load_globa
  00131	b8 ff ff ff ff	 mov	 eax, -1
  00136	eb 08		 jmp	 SHORT $LN12@load_globa
$LN1@load_globa:
  00138	33 c0		 xor	 eax, eax
  0013a	85 c0		 test	 eax, eax
  0013c	75 dc		 jne	 SHORT $LN4@load_globa

; 4685 :     return 0;

  0013e	33 c0		 xor	 eax, eax
$LN12@load_globa:

; 4686 : }

  00140	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00144	c3		 ret	 0
load_global ENDP
_TEXT	ENDS
PUBLIC	??_C@_0GB@HJMGCJMN@A?5load?5persistent?5id?5instruction@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_persid DD imagerel load_persid
	DD	imagerel load_persid+243
	DD	imagerel $unwind$load_persid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_persid DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0GB@HJMGCJMN@A?5load?5persistent?5id?5instruction@
CONST	SEGMENT
??_C@_0GB@HJMGCJMN@A?5load?5persistent?5id?5instruction@ DB 'A load persi'
	DB	'stent id instruction was encountered,', 0aH, 'but no persiste'
	DB	'nt_load function was specified.', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_persid
_TEXT	SEGMENT
s$ = 32
len$ = 40
pid$ = 48
self$ = 80
load_persid PROC					; COMDAT

; 4690 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4691 :     PyObject *pid;
; 4692 :     Py_ssize_t len;
; 4693 :     char *s;
; 4694 : 
; 4695 :     if (self->pers_func) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00016	0f 84 ba 00 00
	00		 je	 $LN10@load_persi

; 4696 :         if ((len = _Unpickler_Readline(self, &s)) < 0)

  0001c	48 8d 54 24 20	 lea	 rdx, QWORD PTR s$[rsp]
  00021	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00026	e8 00 00 00 00	 call	 _Unpickler_Readline
  0002b	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax
  00030	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  00036	7d 0a		 jge	 SHORT $LN9@load_persi

; 4697 :             return -1;

  00038	b8 ff ff ff ff	 mov	 eax, -1
  0003d	e9 ac 00 00 00	 jmp	 $LN11@load_persi
$LN9@load_persi:

; 4698 :         if (len < 1)

  00042	48 83 7c 24 28
	01		 cmp	 QWORD PTR len$[rsp], 1
  00048	7d 0a		 jge	 SHORT $LN8@load_persi

; 4699 :             return bad_readline();

  0004a	e8 00 00 00 00	 call	 bad_readline
  0004f	e9 9a 00 00 00	 jmp	 $LN11@load_persi
$LN8@load_persi:

; 4700 : 
; 4701 :         pid = PyBytes_FromStringAndSize(s, len - 1);

  00054	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00059	48 ff c8	 dec	 rax
  0005c	48 8b d0	 mov	 rdx, rax
  0005f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00064	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00069	48 89 44 24 30	 mov	 QWORD PTR pid$[rsp], rax

; 4702 :         if (pid == NULL)

  0006e	48 83 7c 24 30
	00		 cmp	 QWORD PTR pid$[rsp], 0
  00074	75 07		 jne	 SHORT $LN7@load_persi

; 4703 :             return -1;

  00076	b8 ff ff ff ff	 mov	 eax, -1
  0007b	eb 71		 jmp	 SHORT $LN11@load_persi
$LN7@load_persi:

; 4704 : 
; 4705 :         /* Ugh... this does not leak since _Unpickler_FastCall() steals the
; 4706 :            reference to pid first. */
; 4707 :         pid = _Unpickler_FastCall(self, self->pers_func, pid);

  0007d	4c 8b 44 24 30	 mov	 r8, QWORD PTR pid$[rsp]
  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00087	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00093	e8 00 00 00 00	 call	 _Unpickler_FastCall
  00098	48 89 44 24 30	 mov	 QWORD PTR pid$[rsp], rax

; 4708 :         if (pid == NULL)

  0009d	48 83 7c 24 30
	00		 cmp	 QWORD PTR pid$[rsp], 0
  000a3	75 07		 jne	 SHORT $LN6@load_persi

; 4709 :             return -1;

  000a5	b8 ff ff ff ff	 mov	 eax, -1
  000aa	eb 42		 jmp	 SHORT $LN11@load_persi
$LN6@load_persi:
$LN5@load_persi:

; 4710 : 
; 4711 :         PDATA_PUSH(self->stack, pid, -1);

  000ac	48 8b 54 24 30	 mov	 rdx, QWORD PTR pid$[rsp]
  000b1	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000b6	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000ba	e8 00 00 00 00	 call	 Pdata_push
  000bf	85 c0		 test	 eax, eax
  000c1	7d 07		 jge	 SHORT $LN2@load_persi
  000c3	b8 ff ff ff ff	 mov	 eax, -1
  000c8	eb 24		 jmp	 SHORT $LN11@load_persi
$LN2@load_persi:
  000ca	33 c0		 xor	 eax, eax
  000cc	85 c0		 test	 eax, eax
  000ce	75 dc		 jne	 SHORT $LN5@load_persi

; 4712 :         return 0;

  000d0	33 c0		 xor	 eax, eax
  000d2	eb 1a		 jmp	 SHORT $LN11@load_persi

; 4713 :     }
; 4714 :     else {

  000d4	eb 18		 jmp	 SHORT $LN1@load_persi
$LN10@load_persi:

; 4715 :         PyErr_SetString(UnpicklingError,
; 4716 :                         "A load persistent id instruction was encountered,\n"
; 4717 :                         "but no persistent_load function was specified.");

  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GB@HJMGCJMN@A?5load?5persistent?5id?5instruction@
  000dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  000e4	e8 00 00 00 00	 call	 PyErr_SetString

; 4718 :         return -1;

  000e9	b8 ff ff ff ff	 mov	 eax, -1
$LN1@load_persi:
$LN11@load_persi:

; 4719 :     }
; 4720 : }

  000ee	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f2	c3		 ret	 0
load_persid ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binpersid DD imagerel load_binpersid
	DD	imagerel load_binpersid+186
	DD	imagerel $unwind$load_binpersid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binpersid DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_binpersid
_TEXT	SEGMENT
pid$ = 32
self$ = 64
load_binpersid PROC					; COMDAT

; 4724 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4725 :     PyObject *pid;
; 4726 : 
; 4727 :     if (self->pers_func) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00016	0f 84 81 00 00
	00		 je	 $LN11@load_binpe
$LN10@load_binpe:

; 4728 :         PDATA_POP(self->stack, pid);

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00021	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00025	e8 00 00 00 00	 call	 Pdata_pop
  0002a	48 89 44 24 20	 mov	 QWORD PTR pid$[rsp], rax
  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 e7		 jne	 SHORT $LN10@load_binpe

; 4729 :         if (pid == NULL)

  00035	48 83 7c 24 20
	00		 cmp	 QWORD PTR pid$[rsp], 0
  0003b	75 07		 jne	 SHORT $LN7@load_binpe

; 4730 :             return -1;

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	eb 71		 jmp	 SHORT $LN12@load_binpe
$LN7@load_binpe:

; 4731 : 
; 4732 :         /* Ugh... this does not leak since _Unpickler_FastCall() steals the
; 4733 :            reference to pid first. */
; 4734 :         pid = _Unpickler_FastCall(self, self->pers_func, pid);

  00044	4c 8b 44 24 20	 mov	 r8, QWORD PTR pid$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005a	e8 00 00 00 00	 call	 _Unpickler_FastCall
  0005f	48 89 44 24 20	 mov	 QWORD PTR pid$[rsp], rax

; 4735 :         if (pid == NULL)

  00064	48 83 7c 24 20
	00		 cmp	 QWORD PTR pid$[rsp], 0
  0006a	75 07		 jne	 SHORT $LN6@load_binpe

; 4736 :             return -1;

  0006c	b8 ff ff ff ff	 mov	 eax, -1
  00071	eb 42		 jmp	 SHORT $LN12@load_binpe
$LN6@load_binpe:
$LN5@load_binpe:

; 4737 : 
; 4738 :         PDATA_PUSH(self->stack, pid, -1);

  00073	48 8b 54 24 20	 mov	 rdx, QWORD PTR pid$[rsp]
  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0007d	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00081	e8 00 00 00 00	 call	 Pdata_push
  00086	85 c0		 test	 eax, eax
  00088	7d 07		 jge	 SHORT $LN2@load_binpe
  0008a	b8 ff ff ff ff	 mov	 eax, -1
  0008f	eb 24		 jmp	 SHORT $LN12@load_binpe
$LN2@load_binpe:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 dc		 jne	 SHORT $LN5@load_binpe

; 4739 :         return 0;

  00097	33 c0		 xor	 eax, eax
  00099	eb 1a		 jmp	 SHORT $LN12@load_binpe

; 4740 :     }
; 4741 :     else {

  0009b	eb 18		 jmp	 SHORT $LN1@load_binpe
$LN11@load_binpe:

; 4742 :         PyErr_SetString(UnpicklingError,
; 4743 :                         "A load persistent id instruction was encountered,\n"
; 4744 :                         "but no persistent_load function was specified.");

  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GB@HJMGCJMN@A?5load?5persistent?5id?5instruction@
  000a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  000ab	e8 00 00 00 00	 call	 PyErr_SetString

; 4745 :         return -1;

  000b0	b8 ff ff ff ff	 mov	 eax, -1
$LN1@load_binpe:
$LN12@load_binpe:

; 4746 :     }
; 4747 : }

  000b5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b9	c3		 ret	 0
load_binpersid ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_pop DD imagerel load_pop
	DD	imagerel load_pop+189
	DD	imagerel $unwind$load_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_pop DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_pop
_TEXT	SEGMENT
len$ = 32
self$ = 64
load_pop PROC						; COMDAT

; 4751 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4752 :     Py_ssize_t len = Py_SIZE(self->stack);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00016	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 4753 : 
; 4754 :     /* Note that we split the (pickle.py) stack into two stacks,
; 4755 :      * an object stack and a mark stack. We have to be clever and
; 4756 :      * pop the right one. We do this by looking at the top of the
; 4757 :      * mark stack first, and only signalling a stack underflow if
; 4758 :      * the object stack is empty and the mark stack doesn't match
; 4759 :      * our expectations.
; 4760 :      */
; 4761 :     if (self->num_marks > 0 && self->marks[self->num_marks - 1] == len) {

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 83 b8 30 01
	00 00 00	 cmp	 QWORD PTR [rax+304], 0
  00028	7e 41		 jle	 SHORT $LN4@load_pop
  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002f	48 8b 80 30 01
	00 00		 mov	 rax, QWORD PTR [rax+304]
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0003b	48 8b 89 28 01
	00 00		 mov	 rcx, QWORD PTR [rcx+296]
  00042	48 8b 54 24 20	 mov	 rdx, QWORD PTR len$[rsp]
  00047	48 39 54 c1 f8	 cmp	 QWORD PTR [rcx+rax*8-8], rdx
  0004c	75 1d		 jne	 SHORT $LN4@load_pop

; 4762 :         self->num_marks--;

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00053	48 8b 80 30 01
	00 00		 mov	 rax, QWORD PTR [rax+304]
  0005a	48 ff c8	 dec	 rax
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00062	48 89 81 30 01
	00 00		 mov	 QWORD PTR [rcx+304], rax
  00069	eb 4b		 jmp	 SHORT $LN3@load_pop
$LN4@load_pop:

; 4763 :     } else if (len > 0) {

  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR len$[rsp], 0
  00071	7e 3c		 jle	 SHORT $LN2@load_pop

; 4764 :         len--;

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR len$[rsp]
  00078	48 ff c8	 dec	 rax
  0007b	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 4765 :         Py_DECREF(self->stack->data[len]);

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00085	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00089	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0008d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  00092	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00096	e8 00 00 00 00	 call	 _Py_DecRef

; 4766 :         Py_SIZE(self->stack) = len;

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  000a9	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 4767 :     } else {

  000ad	eb 07		 jmp	 SHORT $LN1@load_pop
$LN2@load_pop:

; 4768 :         return stack_underflow();

  000af	e8 00 00 00 00	 call	 stack_underflow
  000b4	eb 02		 jmp	 SHORT $LN5@load_pop
$LN1@load_pop:
$LN3@load_pop:

; 4769 :     }
; 4770 :     return 0;

  000b6	33 c0		 xor	 eax, eax
$LN5@load_pop:

; 4771 : }

  000b8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bc	c3		 ret	 0
load_pop ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_pop_mark DD imagerel load_pop_mark
	DD	imagerel load_pop_mark+65
	DD	imagerel $unwind$load_pop_mark
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_pop_mark DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_pop_mark
_TEXT	SEGMENT
i$ = 32
self$ = 64
load_pop_mark PROC					; COMDAT

; 4775 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4776 :     Py_ssize_t i;
; 4777 : 
; 4778 :     if ((i = marker(self)) < 0)

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 marker
  00013	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0001e	7d 07		 jge	 SHORT $LN1@load_pop_m

; 4779 :         return -1;

  00020	b8 ff ff ff ff	 mov	 eax, -1
  00025	eb 15		 jmp	 SHORT $LN2@load_pop_m
$LN1@load_pop_m:

; 4780 : 
; 4781 :     Pdata_clear(self->stack, i);

  00027	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00031	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00035	e8 00 00 00 00	 call	 Pdata_clear

; 4782 : 
; 4783 :     return 0;

  0003a	33 c0		 xor	 eax, eax
$LN2@load_pop_m:

; 4784 : }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
load_pop_mark ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_dup DD imagerel load_dup
	DD	imagerel load_dup+123
	DD	imagerel $unwind$load_dup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_dup DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_dup
_TEXT	SEGMENT
last$ = 32
len$ = 40
self$ = 64
load_dup PROC						; COMDAT

; 4788 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4789 :     PyObject *last;
; 4790 :     Py_ssize_t len;
; 4791 : 
; 4792 :     if ((len = Py_SIZE(self->stack)) <= 0)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00016	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax
  0001b	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  00021	7f 07		 jg	 SHORT $LN5@load_dup

; 4793 :         return stack_underflow();

  00023	e8 00 00 00 00	 call	 stack_underflow
  00028	eb 4c		 jmp	 SHORT $LN6@load_dup
$LN5@load_dup:

; 4794 :     last = self->stack->data[len - 1];

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00033	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00037	48 8b 4c 24 28	 mov	 rcx, QWORD PTR len$[rsp]
  0003c	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  00041	48 89 44 24 20	 mov	 QWORD PTR last$[rsp], rax
$LN4@load_dup:

; 4795 :     PDATA_APPEND(self->stack, last, -1);

  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR last$[rsp]
  0004b	e8 00 00 00 00	 call	 _Py_IncRef
  00050	48 8b 54 24 20	 mov	 rdx, QWORD PTR last$[rsp]
  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0005a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0005e	e8 00 00 00 00	 call	 Pdata_push
  00063	85 c0		 test	 eax, eax
  00065	7d 07		 jge	 SHORT $LN1@load_dup
  00067	b8 ff ff ff ff	 mov	 eax, -1
  0006c	eb 08		 jmp	 SHORT $LN6@load_dup
$LN1@load_dup:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 d2		 jne	 SHORT $LN4@load_dup

; 4796 :     return 0;

  00074	33 c0		 xor	 eax, eax
$LN6@load_dup:

; 4797 : }

  00076	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007a	c3		 ret	 0
load_dup ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_get DD imagerel load_get
	DD	imagerel load_get+294
	DD	imagerel $unwind$load_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_get DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_get
_TEXT	SEGMENT
value$ = 32
s$ = 40
idx$ = 48
key$ = 56
len$ = 64
self$ = 96
load_get PROC						; COMDAT

; 4801 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4802 :     PyObject *key, *value;
; 4803 :     Py_ssize_t idx;
; 4804 :     Py_ssize_t len;
; 4805 :     char *s;
; 4806 : 
; 4807 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00009	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 _Unpickler_Readline
  00018	48 89 44 24 40	 mov	 QWORD PTR len$[rsp], rax
  0001d	48 83 7c 24 40
	00		 cmp	 QWORD PTR len$[rsp], 0
  00023	7d 0a		 jge	 SHORT $LN10@load_get

; 4808 :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 f2 00 00 00	 jmp	 $LN11@load_get
$LN10@load_get:

; 4809 :     if (len < 2)

  0002f	48 83 7c 24 40
	02		 cmp	 QWORD PTR len$[rsp], 2
  00035	7d 0a		 jge	 SHORT $LN9@load_get

; 4810 :         return bad_readline();

  00037	e8 00 00 00 00	 call	 bad_readline
  0003c	e9 e0 00 00 00	 jmp	 $LN11@load_get
$LN9@load_get:

; 4811 : 
; 4812 :     key = PyLong_FromString(s, NULL, 10);

  00041	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00047	33 d2		 xor	 edx, edx
  00049	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0004e	e8 00 00 00 00	 call	 PyLong_FromString
  00053	48 89 44 24 38	 mov	 QWORD PTR key$[rsp], rax

; 4813 :     if (key == NULL)

  00058	48 83 7c 24 38
	00		 cmp	 QWORD PTR key$[rsp], 0
  0005e	75 0a		 jne	 SHORT $LN8@load_get

; 4814 :         return -1;

  00060	b8 ff ff ff ff	 mov	 eax, -1
  00065	e9 b7 00 00 00	 jmp	 $LN11@load_get
$LN8@load_get:

; 4815 :     idx = PyLong_AsSsize_t(key);

  0006a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  0006f	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00074	48 89 44 24 30	 mov	 QWORD PTR idx$[rsp], rax

; 4816 :     if (idx == -1 && PyErr_Occurred()) {

  00079	48 83 7c 24 30
	ff		 cmp	 QWORD PTR idx$[rsp], -1
  0007f	75 1e		 jne	 SHORT $LN7@load_get
  00081	e8 00 00 00 00	 call	 PyErr_Occurred
  00086	48 85 c0	 test	 rax, rax
  00089	74 14		 je	 SHORT $LN7@load_get

; 4817 :         Py_DECREF(key);

  0008b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  00090	e8 00 00 00 00	 call	 _Py_DecRef

; 4818 :         return -1;

  00095	b8 ff ff ff ff	 mov	 eax, -1
  0009a	e9 82 00 00 00	 jmp	 $LN11@load_get
$LN7@load_get:

; 4819 :     }
; 4820 : 
; 4821 :     value = _Unpickler_MemoGet(self, idx);

  0009f	48 8b 54 24 30	 mov	 rdx, QWORD PTR idx$[rsp]
  000a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000a9	e8 00 00 00 00	 call	 _Unpickler_MemoGet
  000ae	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 4822 :     if (value == NULL) {

  000b3	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  000b9	75 2c		 jne	 SHORT $LN6@load_get

; 4823 :         if (!PyErr_Occurred())

  000bb	e8 00 00 00 00	 call	 PyErr_Occurred
  000c0	48 85 c0	 test	 rax, rax
  000c3	75 11		 jne	 SHORT $LN5@load_get

; 4824 :             PyErr_SetObject(PyExc_KeyError, key);

  000c5	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  000ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  000d1	e8 00 00 00 00	 call	 PyErr_SetObject
$LN5@load_get:

; 4825 :         Py_DECREF(key);

  000d6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  000db	e8 00 00 00 00	 call	 _Py_DecRef

; 4826 :         return -1;

  000e0	b8 ff ff ff ff	 mov	 eax, -1
  000e5	eb 3a		 jmp	 SHORT $LN11@load_get
$LN6@load_get:

; 4827 :     }
; 4828 :     Py_DECREF(key);

  000e7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  000ec	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@load_get:

; 4829 : 
; 4830 :     PDATA_APPEND(self->stack, value, -1);

  000f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  000f6	e8 00 00 00 00	 call	 _Py_IncRef
  000fb	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00100	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00105	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00109	e8 00 00 00 00	 call	 Pdata_push
  0010e	85 c0		 test	 eax, eax
  00110	7d 07		 jge	 SHORT $LN1@load_get
  00112	b8 ff ff ff ff	 mov	 eax, -1
  00117	eb 08		 jmp	 SHORT $LN11@load_get
$LN1@load_get:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	75 d2		 jne	 SHORT $LN4@load_get

; 4831 :     return 0;

  0011f	33 c0		 xor	 eax, eax
$LN11@load_get:

; 4832 : }

  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	c3		 ret	 0
load_get ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _Unpickler_MemoGet
_TEXT	SEGMENT
self$ = 8
idx$ = 16
_Unpickler_MemoGet PROC					; COMDAT

; 1077 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1078 :     if (idx < 0 || idx >= self->memo_size)

  0000a	48 83 7c 24 10
	00		 cmp	 QWORD PTR idx$[rsp], 0
  00010	7c 10		 jl	 SHORT $LN1@Unpickler_@9
  00012	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  00017	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0001b	48 39 44 24 10	 cmp	 QWORD PTR idx$[rsp], rax
  00020	7c 04		 jl	 SHORT $LN2@Unpickler_@9
$LN1@Unpickler_@9:

; 1079 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	eb 12		 jmp	 SHORT $LN3@Unpickler_@9
$LN2@Unpickler_@9:

; 1080 : 
; 1081 :     return self->memo[idx];

  00026	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  0002b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0002f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR idx$[rsp]
  00034	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
$LN3@Unpickler_@9:

; 1082 : }

  00038	f3 c3		 fatret	 0
_Unpickler_MemoGet ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binget DD imagerel load_binget
	DD	imagerel load_binget+204
	DD	imagerel $unwind$load_binget
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binget DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_binget
_TEXT	SEGMENT
value$ = 32
s$ = 40
idx$ = 48
key$23983 = 56
self$ = 80
load_binget PROC					; COMDAT

; 4836 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4837 :     PyObject *value;
; 4838 :     Py_ssize_t idx;
; 4839 :     char *s;
; 4840 : 
; 4841 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 0a		 jge	 SHORT $LN7@load_binge

; 4842 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 9a 00 00 00	 jmp	 $LN8@load_binge
$LN7@load_binge:

; 4843 : 
; 4844 :     idx = Py_CHARMASK(s[0]);

  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00032	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00035	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	48 89 44 24 30	 mov	 QWORD PTR idx$[rsp], rax

; 4845 : 
; 4846 :     value = _Unpickler_MemoGet(self, idx);

  00042	48 8b 54 24 30	 mov	 rdx, QWORD PTR idx$[rsp]
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0004c	e8 00 00 00 00	 call	 _Unpickler_MemoGet
  00051	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 4847 :     if (value == NULL) {

  00056	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  0005c	75 39		 jne	 SHORT $LN6@load_binge

; 4848 :         PyObject *key = PyLong_FromSsize_t(idx);

  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idx$[rsp]
  00063	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00068	48 89 44 24 38	 mov	 QWORD PTR key$23983[rsp], rax

; 4849 :         if (key != NULL) {

  0006d	48 83 7c 24 38
	00		 cmp	 QWORD PTR key$23983[rsp], 0
  00073	74 1b		 je	 SHORT $LN5@load_binge

; 4850 :             PyErr_SetObject(PyExc_KeyError, key);

  00075	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$23983[rsp]
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  00081	e8 00 00 00 00	 call	 PyErr_SetObject

; 4851 :             Py_DECREF(key);

  00086	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$23983[rsp]
  0008b	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@load_binge:

; 4852 :         }
; 4853 :         return -1;

  00090	b8 ff ff ff ff	 mov	 eax, -1
  00095	eb 30		 jmp	 SHORT $LN8@load_binge
$LN6@load_binge:
$LN4@load_binge:

; 4854 :     }
; 4855 : 
; 4856 :     PDATA_APPEND(self->stack, value, -1);

  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  0009c	e8 00 00 00 00	 call	 _Py_IncRef
  000a1	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  000a6	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ab	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000af	e8 00 00 00 00	 call	 Pdata_push
  000b4	85 c0		 test	 eax, eax
  000b6	7d 07		 jge	 SHORT $LN1@load_binge
  000b8	b8 ff ff ff ff	 mov	 eax, -1
  000bd	eb 08		 jmp	 SHORT $LN8@load_binge
$LN1@load_binge:
  000bf	33 c0		 xor	 eax, eax
  000c1	85 c0		 test	 eax, eax
  000c3	75 d2		 jne	 SHORT $LN4@load_binge

; 4857 :     return 0;

  000c5	33 c0		 xor	 eax, eax
$LN8@load_binge:

; 4858 : }

  000c7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cb	c3		 ret	 0
load_binget ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_long_binget DD imagerel load_long_binget
	DD	imagerel load_long_binget+203
	DD	imagerel $unwind$load_long_binget
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_long_binget DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_long_binget
_TEXT	SEGMENT
value$ = 32
s$ = 40
idx$ = 48
key$24002 = 56
self$ = 80
load_long_binget PROC					; COMDAT

; 4862 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4863 :     PyObject *value;
; 4864 :     Py_ssize_t idx;
; 4865 :     char *s;
; 4866 : 
; 4867 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00009	41 b8 04 00 00
	00		 mov	 r8d, 4
  0000f	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 0a		 jge	 SHORT $LN7@load_long_@2

; 4868 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 99 00 00 00	 jmp	 $LN8@load_long_@2
$LN7@load_long_@2:

; 4869 : 
; 4870 :     idx = calc_binsize(s, 4);

  0002d	ba 04 00 00 00	 mov	 edx, 4
  00032	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00037	e8 00 00 00 00	 call	 calc_binsize
  0003c	48 89 44 24 30	 mov	 QWORD PTR idx$[rsp], rax

; 4871 : 
; 4872 :     value = _Unpickler_MemoGet(self, idx);

  00041	48 8b 54 24 30	 mov	 rdx, QWORD PTR idx$[rsp]
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0004b	e8 00 00 00 00	 call	 _Unpickler_MemoGet
  00050	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 4873 :     if (value == NULL) {

  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  0005b	75 39		 jne	 SHORT $LN6@load_long_@2

; 4874 :         PyObject *key = PyLong_FromSsize_t(idx);

  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idx$[rsp]
  00062	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00067	48 89 44 24 38	 mov	 QWORD PTR key$24002[rsp], rax

; 4875 :         if (key != NULL) {

  0006c	48 83 7c 24 38
	00		 cmp	 QWORD PTR key$24002[rsp], 0
  00072	74 1b		 je	 SHORT $LN5@load_long_@2

; 4876 :             PyErr_SetObject(PyExc_KeyError, key);

  00074	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$24002[rsp]
  00079	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  00080	e8 00 00 00 00	 call	 PyErr_SetObject

; 4877 :             Py_DECREF(key);

  00085	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$24002[rsp]
  0008a	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@load_long_@2:

; 4878 :         }
; 4879 :         return -1;

  0008f	b8 ff ff ff ff	 mov	 eax, -1
  00094	eb 30		 jmp	 SHORT $LN8@load_long_@2
$LN6@load_long_@2:
$LN4@load_long_@2:

; 4880 :     }
; 4881 : 
; 4882 :     PDATA_APPEND(self->stack, value, -1);

  00096	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  0009b	e8 00 00 00 00	 call	 _Py_IncRef
  000a0	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  000a5	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000aa	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000ae	e8 00 00 00 00	 call	 Pdata_push
  000b3	85 c0		 test	 eax, eax
  000b5	7d 07		 jge	 SHORT $LN1@load_long_@2
  000b7	b8 ff ff ff ff	 mov	 eax, -1
  000bc	eb 08		 jmp	 SHORT $LN8@load_long_@2
$LN1@load_long_@2:
  000be	33 c0		 xor	 eax, eax
  000c0	85 c0		 test	 eax, eax
  000c2	75 d2		 jne	 SHORT $LN4@load_long_@2

; 4883 :     return 0;

  000c4	33 c0		 xor	 eax, eax
$LN8@load_long_@2:

; 4884 : }

  000c6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ca	c3		 ret	 0
load_long_binget ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@FKFPALO@_inverted_registry?$FL?$CFld?$FN?5isn?8t?5a?5@ ; `string'
PUBLIC	??_C@_0CA@MCHHKMHE@unregistered?5extension?5code?5?$CFld?$AA@ ; `string'
PUBLIC	??_C@_0BI@NHAIMOIL@EXT?5specifies?5code?5?$DM?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_1FE@MBHHDGFK@?$AAn?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAb@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_extension DD imagerel load_extension
	DD	imagerel load_extension+669
	DD	imagerel $unwind$load_extension
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_extension DD 010d01H
	DD	0c20dH
xdata	ENDS
;	COMDAT ??_C@_0DD@FKFPALO@_inverted_registry?$FL?$CFld?$FN?5isn?8t?5a?5@
CONST	SEGMENT
??_C@_0DD@FKFPALO@_inverted_registry?$FL?$CFld?$FN?5isn?8t?5a?5@ DB '_inv'
	DB	'erted_registry[%ld] isn''t a 2-tuple of strings', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MCHHKMHE@unregistered?5extension?5code?5?$CFld?$AA@
CONST	SEGMENT
??_C@_0CA@MCHHKMHE@unregistered?5extension?5code?5?$CFld?$AA@ DB 'unregis'
	DB	'tered extension code %ld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NHAIMOIL@EXT?5specifies?5code?5?$DM?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BI@NHAIMOIL@EXT?5specifies?5code?5?$DM?$DN?50?$AA@ DB 'EXT specifi'
	DB	'es code <= 0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FE@MBHHDGFK@?$AAn?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAb@
CONST	SEGMENT
??_C@_1FE@MBHHDGFK@?$AAn?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAb@ DB 'n'
	DB	00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '1', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'n', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H
	DB	's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '2', 00H, ' '
	DB	00H, '|', 00H, '|', 00H, ' ', 00H, 'n', 00H, 'b', 00H, 'y', 00H
	DB	't', 00H, 'e', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '4', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_extension
_TEXT	SEGMENT
pair$ = 32
code$ = 40
module_name$ = 48
py_code$ = 56
class_name$ = 64
obj$ = 72
codebytes$ = 80
self$ = 112
nbytes$ = 120
load_extension PROC					; COMDAT

; 4891 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4892 :     char *codebytes;            /* the nbytes bytes after the opcode */
; 4893 :     long code;                  /* calc_binint returns long */
; 4894 :     PyObject *py_code;          /* code as a Python int */
; 4895 :     PyObject *obj;              /* the object to push */
; 4896 :     PyObject *pair;             /* (module_name, class_name) */
; 4897 :     PyObject *module_name, *class_name;
; 4898 : 
; 4899 :     assert(nbytes == 1 || nbytes == 2 || nbytes == 4);

  0000d	83 7c 24 78 01	 cmp	 DWORD PTR nbytes$[rsp], 1
  00012	74 2a		 je	 SHORT $LN20@load_exten
  00014	83 7c 24 78 02	 cmp	 DWORD PTR nbytes$[rsp], 2
  00019	74 23		 je	 SHORT $LN20@load_exten
  0001b	83 7c 24 78 04	 cmp	 DWORD PTR nbytes$[rsp], 4
  00020	74 1c		 je	 SHORT $LN20@load_exten
  00022	41 b8 23 13 00
	00		 mov	 r8d, 4899		; 00001323H
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@MBHHDGFK@?$AAn?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAb@
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003c	33 c0		 xor	 eax, eax
$LN20@load_exten:

; 4900 :     if (_Unpickler_Read(self, &codebytes, nbytes) < 0)

  0003e	48 63 44 24 78	 movsxd	 rax, DWORD PTR nbytes$[rsp]
  00043	4c 8b c0	 mov	 r8, rax
  00046	48 8d 54 24 50	 lea	 rdx, QWORD PTR codebytes$[rsp]
  0004b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00050	e8 00 00 00 00	 call	 _Unpickler_Read
  00055	48 85 c0	 test	 rax, rax
  00058	7d 0a		 jge	 SHORT $LN17@load_exten

; 4901 :         return -1;

  0005a	b8 ff ff ff ff	 mov	 eax, -1
  0005f	e9 34 02 00 00	 jmp	 $LN18@load_exten
$LN17@load_exten:

; 4902 :     code = calc_binint(codebytes, nbytes);

  00064	8b 54 24 78	 mov	 edx, DWORD PTR nbytes$[rsp]
  00068	48 8b 4c 24 50	 mov	 rcx, QWORD PTR codebytes$[rsp]
  0006d	e8 00 00 00 00	 call	 calc_binint
  00072	89 44 24 28	 mov	 DWORD PTR code$[rsp], eax

; 4903 :     if (code <= 0) {            /* note that 0 is forbidden */

  00076	83 7c 24 28 00	 cmp	 DWORD PTR code$[rsp], 0
  0007b	7f 1d		 jg	 SHORT $LN16@load_exten

; 4904 :         /* Corrupt or hostile pickle. */
; 4905 :         PyErr_SetString(UnpicklingError, "EXT specifies code <= 0");

  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@NHAIMOIL@EXT?5specifies?5code?5?$DM?$DN?50?$AA@
  00084	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  0008b	e8 00 00 00 00	 call	 PyErr_SetString

; 4906 :         return -1;

  00090	b8 ff ff ff ff	 mov	 eax, -1
  00095	e9 fe 01 00 00	 jmp	 $LN18@load_exten
$LN16@load_exten:

; 4907 :     }
; 4908 : 
; 4909 :     /* Look for the code in the cache. */
; 4910 :     py_code = PyLong_FromLong(code);

  0009a	8b 4c 24 28	 mov	 ecx, DWORD PTR code$[rsp]
  0009e	e8 00 00 00 00	 call	 PyLong_FromLong
  000a3	48 89 44 24 38	 mov	 QWORD PTR py_code$[rsp], rax

; 4911 :     if (py_code == NULL)

  000a8	48 83 7c 24 38
	00		 cmp	 QWORD PTR py_code$[rsp], 0
  000ae	75 0a		 jne	 SHORT $LN15@load_exten

; 4912 :         return -1;

  000b0	b8 ff ff ff ff	 mov	 eax, -1
  000b5	e9 de 01 00 00	 jmp	 $LN18@load_exten
$LN15@load_exten:

; 4913 :     obj = PyDict_GetItem(extension_cache, py_code);

  000ba	48 8b 54 24 38	 mov	 rdx, QWORD PTR py_code$[rsp]
  000bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR extension_cache
  000c6	e8 00 00 00 00	 call	 PyDict_GetItem
  000cb	48 89 44 24 48	 mov	 QWORD PTR obj$[rsp], rax

; 4914 :     if (obj != NULL) {

  000d0	48 83 7c 24 48
	00		 cmp	 QWORD PTR obj$[rsp], 0
  000d6	74 42		 je	 SHORT $LN14@load_exten

; 4915 :         /* Bingo. */
; 4916 :         Py_DECREF(py_code);

  000d8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR py_code$[rsp]
  000dd	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@load_exten:

; 4917 :         PDATA_APPEND(self->stack, obj, -1);

  000e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obj$[rsp]
  000e7	e8 00 00 00 00	 call	 _Py_IncRef
  000ec	48 8b 54 24 48	 mov	 rdx, QWORD PTR obj$[rsp]
  000f1	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000f6	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000fa	e8 00 00 00 00	 call	 Pdata_push
  000ff	85 c0		 test	 eax, eax
  00101	7d 0a		 jge	 SHORT $LN10@load_exten
  00103	b8 ff ff ff ff	 mov	 eax, -1
  00108	e9 8b 01 00 00	 jmp	 $LN18@load_exten
$LN10@load_exten:
  0010d	33 c0		 xor	 eax, eax
  0010f	85 c0		 test	 eax, eax
  00111	75 cf		 jne	 SHORT $LN13@load_exten

; 4918 :         return 0;

  00113	33 c0		 xor	 eax, eax
  00115	e9 7e 01 00 00	 jmp	 $LN18@load_exten
$LN14@load_exten:

; 4919 :     }
; 4920 : 
; 4921 :     /* Look up the (module_name, class_name) pair. */
; 4922 :     pair = PyDict_GetItem(inverted_registry, py_code);

  0011a	48 8b 54 24 38	 mov	 rdx, QWORD PTR py_code$[rsp]
  0011f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR inverted_registry
  00126	e8 00 00 00 00	 call	 PyDict_GetItem
  0012b	48 89 44 24 20	 mov	 QWORD PTR pair$[rsp], rax

; 4923 :     if (pair == NULL) {

  00130	48 83 7c 24 20
	00		 cmp	 QWORD PTR pair$[rsp], 0
  00136	75 2c		 jne	 SHORT $LN9@load_exten

; 4924 :         Py_DECREF(py_code);

  00138	48 8b 4c 24 38	 mov	 rcx, QWORD PTR py_code$[rsp]
  0013d	e8 00 00 00 00	 call	 _Py_DecRef

; 4925 :         PyErr_Format(PyExc_ValueError, "unregistered extension "
; 4926 :                      "code %ld", code);

  00142	44 8b 44 24 28	 mov	 r8d, DWORD PTR code$[rsp]
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@MCHHKMHE@unregistered?5extension?5code?5?$CFld?$AA@
  0014e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00155	e8 00 00 00 00	 call	 PyErr_Format

; 4927 :         return -1;

  0015a	b8 ff ff ff ff	 mov	 eax, -1
  0015f	e9 34 01 00 00	 jmp	 $LN18@load_exten
$LN9@load_exten:

; 4928 :     }
; 4929 :     /* Since the extension registry is manipulable via Python code,
; 4930 :      * confirm that pair is really a 2-tuple of strings.
; 4931 :      */
; 4932 :     if (!PyTuple_Check(pair) || PyTuple_Size(pair) != 2 ||
; 4933 :         !PyUnicode_Check(module_name = PyTuple_GET_ITEM(pair, 0)) ||
; 4934 :         !PyUnicode_Check(class_name = PyTuple_GET_ITEM(pair, 1))) {

  00164	48 8b 44 24 20	 mov	 rax, QWORD PTR pair$[rsp]
  00169	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0016d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00173	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00178	85 c0		 test	 eax, eax
  0017a	74 5c		 je	 SHORT $LN7@load_exten
  0017c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pair$[rsp]
  00181	e8 00 00 00 00	 call	 PyTuple_Size
  00186	48 83 f8 02	 cmp	 rax, 2
  0018a	75 4c		 jne	 SHORT $LN7@load_exten
  0018c	48 8b 44 24 20	 mov	 rax, QWORD PTR pair$[rsp]
  00191	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00195	48 89 44 24 30	 mov	 QWORD PTR module_name$[rsp], rax
  0019a	48 8b 44 24 30	 mov	 rax, QWORD PTR module_name$[rsp]
  0019f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001a3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001a9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  001ae	85 c0		 test	 eax, eax
  001b0	74 26		 je	 SHORT $LN7@load_exten
  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR pair$[rsp]
  001b7	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  001bb	48 89 44 24 40	 mov	 QWORD PTR class_name$[rsp], rax
  001c0	48 8b 44 24 40	 mov	 rax, QWORD PTR class_name$[rsp]
  001c5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001c9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001cf	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  001d4	85 c0		 test	 eax, eax
  001d6	75 2c		 jne	 SHORT $LN8@load_exten
$LN7@load_exten:

; 4935 :         Py_DECREF(py_code);

  001d8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR py_code$[rsp]
  001dd	e8 00 00 00 00	 call	 _Py_DecRef

; 4936 :         PyErr_Format(PyExc_ValueError, "_inverted_registry[%ld] "
; 4937 :                      "isn't a 2-tuple of strings", code);

  001e2	44 8b 44 24 28	 mov	 r8d, DWORD PTR code$[rsp]
  001e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@FKFPALO@_inverted_registry?$FL?$CFld?$FN?5isn?8t?5a?5@
  001ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001f5	e8 00 00 00 00	 call	 PyErr_Format

; 4938 :         return -1;

  001fa	b8 ff ff ff ff	 mov	 eax, -1
  001ff	e9 94 00 00 00	 jmp	 $LN18@load_exten
$LN8@load_exten:

; 4939 :     }
; 4940 :     /* Load the object. */
; 4941 :     obj = find_class(self, module_name, class_name);

  00204	4c 8b 44 24 40	 mov	 r8, QWORD PTR class_name$[rsp]
  00209	48 8b 54 24 30	 mov	 rdx, QWORD PTR module_name$[rsp]
  0020e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00213	e8 00 00 00 00	 call	 find_class
  00218	48 89 44 24 48	 mov	 QWORD PTR obj$[rsp], rax

; 4942 :     if (obj == NULL) {

  0021d	48 83 7c 24 48
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00223	75 11		 jne	 SHORT $LN6@load_exten

; 4943 :         Py_DECREF(py_code);

  00225	48 8b 4c 24 38	 mov	 rcx, QWORD PTR py_code$[rsp]
  0022a	e8 00 00 00 00	 call	 _Py_DecRef

; 4944 :         return -1;

  0022f	b8 ff ff ff ff	 mov	 eax, -1
  00234	eb 62		 jmp	 SHORT $LN18@load_exten
$LN6@load_exten:

; 4945 :     }
; 4946 :     /* Cache code -> obj. */
; 4947 :     code = PyDict_SetItem(extension_cache, py_code, obj);

  00236	4c 8b 44 24 48	 mov	 r8, QWORD PTR obj$[rsp]
  0023b	48 8b 54 24 38	 mov	 rdx, QWORD PTR py_code$[rsp]
  00240	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR extension_cache
  00247	e8 00 00 00 00	 call	 PyDict_SetItem
  0024c	89 44 24 28	 mov	 DWORD PTR code$[rsp], eax

; 4948 :     Py_DECREF(py_code);

  00250	48 8b 4c 24 38	 mov	 rcx, QWORD PTR py_code$[rsp]
  00255	e8 00 00 00 00	 call	 _Py_DecRef

; 4949 :     if (code < 0) {

  0025a	83 7c 24 28 00	 cmp	 DWORD PTR code$[rsp], 0
  0025f	7d 11		 jge	 SHORT $LN5@load_exten

; 4950 :         Py_DECREF(obj);

  00261	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obj$[rsp]
  00266	e8 00 00 00 00	 call	 _Py_DecRef

; 4951 :         return -1;

  0026b	b8 ff ff ff ff	 mov	 eax, -1
  00270	eb 26		 jmp	 SHORT $LN18@load_exten
$LN5@load_exten:
$LN4@load_exten:

; 4952 :     }
; 4953 :     PDATA_PUSH(self->stack, obj, -1);

  00272	48 8b 54 24 48	 mov	 rdx, QWORD PTR obj$[rsp]
  00277	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0027c	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00280	e8 00 00 00 00	 call	 Pdata_push
  00285	85 c0		 test	 eax, eax
  00287	7d 07		 jge	 SHORT $LN1@load_exten
  00289	b8 ff ff ff ff	 mov	 eax, -1
  0028e	eb 08		 jmp	 SHORT $LN18@load_exten
$LN1@load_exten:
  00290	33 c0		 xor	 eax, eax
  00292	85 c0		 test	 eax, eax
  00294	75 dc		 jne	 SHORT $LN4@load_exten

; 4954 :     return 0;

  00296	33 c0		 xor	 eax, eax
$LN18@load_exten:

; 4955 : }

  00298	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0029c	c3		 ret	 0
load_extension ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@FMJDFNLA@negative?5PUT?5argument?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_put DD imagerel load_put
	DD	imagerel load_put+259
	DD	imagerel $unwind$load_put
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_put DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0BG@FMJDFNLA@negative?5PUT?5argument?$AA@
CONST	SEGMENT
??_C@_0BG@FMJDFNLA@negative?5PUT?5argument?$AA@ DB 'negative PUT argument'
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_put
_TEXT	SEGMENT
value$ = 32
s$ = 40
idx$ = 48
key$ = 56
len$ = 64
self$ = 96
load_put PROC						; COMDAT

; 4959 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4960 :     PyObject *key, *value;
; 4961 :     Py_ssize_t idx;
; 4962 :     Py_ssize_t len;
; 4963 :     char *s;
; 4964 : 
; 4965 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00009	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 _Unpickler_Readline
  00018	48 89 44 24 40	 mov	 QWORD PTR len$[rsp], rax
  0001d	48 83 7c 24 40
	00		 cmp	 QWORD PTR len$[rsp], 0
  00023	7d 0a		 jge	 SHORT $LN6@load_put

; 4966 :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 cf 00 00 00	 jmp	 $LN7@load_put
$LN6@load_put:

; 4967 :     if (len < 2)

  0002f	48 83 7c 24 40
	02		 cmp	 QWORD PTR len$[rsp], 2
  00035	7d 0a		 jge	 SHORT $LN5@load_put

; 4968 :         return bad_readline();

  00037	e8 00 00 00 00	 call	 bad_readline
  0003c	e9 bd 00 00 00	 jmp	 $LN7@load_put
$LN5@load_put:

; 4969 :     if (Py_SIZE(self->stack) <= 0)

  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00046	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0004f	7f 0a		 jg	 SHORT $LN4@load_put

; 4970 :         return stack_underflow();

  00051	e8 00 00 00 00	 call	 stack_underflow
  00056	e9 a3 00 00 00	 jmp	 $LN7@load_put
$LN4@load_put:

; 4971 :     value = self->stack->data[Py_SIZE(self->stack) - 1];

  0005b	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00060	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00064	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00069	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0006d	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00071	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00075	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  0007a	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 4972 : 
; 4973 :     key = PyLong_FromString(s, NULL, 10);

  0007f	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00085	33 d2		 xor	 edx, edx
  00087	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0008c	e8 00 00 00 00	 call	 PyLong_FromString
  00091	48 89 44 24 38	 mov	 QWORD PTR key$[rsp], rax

; 4974 :     if (key == NULL)

  00096	48 83 7c 24 38
	00		 cmp	 QWORD PTR key$[rsp], 0
  0009c	75 07		 jne	 SHORT $LN3@load_put

; 4975 :         return -1;

  0009e	b8 ff ff ff ff	 mov	 eax, -1
  000a3	eb 59		 jmp	 SHORT $LN7@load_put
$LN3@load_put:

; 4976 :     idx = PyLong_AsSsize_t(key);

  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  000aa	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000af	48 89 44 24 30	 mov	 QWORD PTR idx$[rsp], rax

; 4977 :     Py_DECREF(key);

  000b4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  000b9	e8 00 00 00 00	 call	 _Py_DecRef

; 4978 :     if (idx < 0) {

  000be	48 83 7c 24 30
	00		 cmp	 QWORD PTR idx$[rsp], 0
  000c4	7d 24		 jge	 SHORT $LN2@load_put

; 4979 :         if (!PyErr_Occurred())

  000c6	e8 00 00 00 00	 call	 PyErr_Occurred
  000cb	48 85 c0	 test	 rax, rax
  000ce	75 13		 jne	 SHORT $LN1@load_put

; 4980 :             PyErr_SetString(PyExc_ValueError,
; 4981 :                             "negative PUT argument");

  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@FMJDFNLA@negative?5PUT?5argument?$AA@
  000d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000de	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@load_put:

; 4982 :         return -1;

  000e3	b8 ff ff ff ff	 mov	 eax, -1
  000e8	eb 14		 jmp	 SHORT $LN7@load_put
$LN2@load_put:

; 4983 :     }
; 4984 : 
; 4985 :     return _Unpickler_MemoPut(self, idx, value);

  000ea	4c 8b 44 24 20	 mov	 r8, QWORD PTR value$[rsp]
  000ef	48 8b 54 24 30	 mov	 rdx, QWORD PTR idx$[rsp]
  000f4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000f9	e8 00 00 00 00	 call	 _Unpickler_MemoPut
$LN7@load_put:

; 4986 : }

  000fe	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00102	c3		 ret	 0
load_put ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@ONOOHMAD@?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAe?$AAm?$AAo?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_MemoPut DD imagerel _Unpickler_MemoPut
	DD	imagerel _Unpickler_MemoPut+198
	DD	imagerel $unwind$_Unpickler_MemoPut
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_MemoPut DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1CM@ONOOHMAD@?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAe?$AAm?$AAo?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@ONOOHMAD@?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAe?$AAm?$AAo?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 'd', 00H, 'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, 's', 00H
	DB	'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'm', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Unpickler_MemoPut
_TEXT	SEGMENT
old_item$ = 32
self$ = 64
idx$ = 72
value$ = 80
_Unpickler_MemoPut PROC					; COMDAT

; 1088 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1089 :     PyObject *old_item;
; 1090 : 
; 1091 :     if (idx >= self->memo_size) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0001c	48 39 44 24 48	 cmp	 QWORD PTR idx$[rsp], rax
  00021	7c 4c		 jl	 SHORT $LN6@Unpickler_@10

; 1092 :         if (_Unpickler_ResizeMemoList(self, idx * 2) < 0)

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR idx$[rsp]
  00028	48 03 c0	 add	 rax, rax
  0002b	48 8b d0	 mov	 rdx, rax
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00033	e8 00 00 00 00	 call	 _Unpickler_ResizeMemoList
  00038	85 c0		 test	 eax, eax
  0003a	7d 07		 jge	 SHORT $LN5@Unpickler_@10

; 1093 :             return -1;

  0003c	b8 ff ff ff ff	 mov	 eax, -1
  00041	eb 7e		 jmp	 SHORT $LN7@Unpickler_@10
$LN5@Unpickler_@10:

; 1094 :         assert(idx < self->memo_size);

  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00048	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0004c	48 39 44 24 48	 cmp	 QWORD PTR idx$[rsp], rax
  00051	7c 1c		 jl	 SHORT $LN9@Unpickler_@10
  00053	41 b8 46 04 00
	00		 mov	 r8d, 1094		; 00000446H
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@ONOOHMAD@?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAe?$AAm?$AAo?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006d	33 c0		 xor	 eax, eax
$LN9@Unpickler_@10:
$LN6@Unpickler_@10:

; 1095 :     }
; 1096 :     Py_INCREF(value);

  0006f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  00074	e8 00 00 00 00	 call	 _Py_IncRef

; 1097 :     old_item = self->memo[idx];

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	48 8b 4c 24 48	 mov	 rcx, QWORD PTR idx$[rsp]
  00087	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0008b	48 89 44 24 20	 mov	 QWORD PTR old_item$[rsp], rax

; 1098 :     self->memo[idx] = value;

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00095	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00099	48 8b 4c 24 48	 mov	 rcx, QWORD PTR idx$[rsp]
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR value$[rsp]
  000a3	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
$LN4@Unpickler_@10:

; 1099 :     Py_XDECREF(old_item);

  000a7	48 83 7c 24 20
	00		 cmp	 QWORD PTR old_item$[rsp], 0
  000ad	74 0a		 je	 SHORT $LN1@Unpickler_@10
  000af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR old_item$[rsp]
  000b4	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Unpickler_@10:
  000b9	33 c0		 xor	 eax, eax
  000bb	85 c0		 test	 eax, eax
  000bd	75 e8		 jne	 SHORT $LN4@Unpickler_@10

; 1100 :     return 0;

  000bf	33 c0		 xor	 eax, eax
$LN7@Unpickler_@10:

; 1101 : }

  000c1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c5	c3		 ret	 0
_Unpickler_MemoPut ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DG@CLMCFCKO@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAe?$AAm?$AAo?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_ResizeMemoList DD imagerel _Unpickler_ResizeMemoList
	DD	imagerel _Unpickler_ResizeMemoList+261
	DD	imagerel $unwind$_Unpickler_ResizeMemoList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_ResizeMemoList DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1DG@CLMCFCKO@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAe?$AAm?$AAo?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@CLMCFCKO@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAe?$AAm?$AAo?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'l'
	DB	00H, 'f', 00H, '-', 00H, '>', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Unpickler_ResizeMemoList
_TEXT	SEGMENT
i$ = 32
memo$ = 40
tv82 = 48
self$ = 80
new_size$ = 88
_Unpickler_ResizeMemoList PROC				; COMDAT

; 1056 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1057 :     Py_ssize_t i;
; 1058 :     PyObject **memo;
; 1059 : 
; 1060 :     assert(new_size > self->memo_size);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 39 44 24 58	 cmp	 QWORD PTR new_size$[rsp], rax
  0001c	7f 1c		 jg	 SHORT $LN7@Unpickler_@11
  0001e	41 b8 24 04 00
	00		 mov	 r8d, 1060		; 00000424H
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@DHJKOIMG@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAp?$AAi?$AAc?$AAk?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CLMCFCKO@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAe?$AAm?$AAo?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00038	33 c0		 xor	 eax, eax
$LN7@Unpickler_@11:

; 1061 : 
; 1062 :     memo = PyMem_REALLOC(self->memo, new_size * sizeof(PyObject *));

  0003a	e8 00 00 00 00	 call	 _Py_PXCTX
  0003f	85 c0		 test	 eax, eax
  00041	74 21		 je	 SHORT $LN8@Unpickler_@11
  00043	48 8b 44 24 58	 mov	 rax, QWORD PTR new_size$[rsp]
  00048	48 c1 e0 03	 shl	 rax, 3
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00054	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00058	e8 00 00 00 00	 call	 _PxMem_Realloc
  0005d	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
  00062	eb 1f		 jmp	 SHORT $LN9@Unpickler_@11
$LN8@Unpickler_@11:
  00064	48 8b 44 24 58	 mov	 rax, QWORD PTR new_size$[rsp]
  00069	48 c1 e0 03	 shl	 rax, 3
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00075	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00079	e8 00 00 00 00	 call	 _PyMem_DebugRealloc
  0007e	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
$LN9@Unpickler_@11:
  00083	48 8b 44 24 30	 mov	 rax, QWORD PTR tv82[rsp]
  00088	48 89 44 24 28	 mov	 QWORD PTR memo$[rsp], rax

; 1063 :     if (memo == NULL) {

  0008d	48 83 7c 24 28
	00		 cmp	 QWORD PTR memo$[rsp], 0
  00093	75 0c		 jne	 SHORT $LN4@Unpickler_@11

; 1064 :         PyErr_NoMemory();

  00095	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1065 :         return -1;

  0009a	b8 ff ff ff ff	 mov	 eax, -1
  0009f	eb 5f		 jmp	 SHORT $LN5@Unpickler_@11
$LN4@Unpickler_@11:

; 1066 :     }
; 1067 :     self->memo = memo;

  000a1	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR memo$[rsp]
  000ab	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1068 :     for (i = self->memo_size; i < new_size; i++)

  000af	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000b4	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b8	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  000bd	eb 0d		 jmp	 SHORT $LN3@Unpickler_@11
$LN2@Unpickler_@11:
  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000c4	48 ff c0	 inc	 rax
  000c7	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@Unpickler_@11:
  000cc	48 8b 44 24 58	 mov	 rax, QWORD PTR new_size$[rsp]
  000d1	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000d6	7d 18		 jge	 SHORT $LN1@Unpickler_@11

; 1069 :         self->memo[i] = NULL;

  000d8	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000dd	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000e6	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0
  000ee	eb cf		 jmp	 SHORT $LN2@Unpickler_@11
$LN1@Unpickler_@11:

; 1070 :     self->memo_size = new_size;

  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000f5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR new_size$[rsp]
  000fa	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 1071 :     return 0;

  000fe	33 c0		 xor	 eax, eax
$LN5@Unpickler_@11:

; 1072 : }

  00100	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00104	c3		 ret	 0
_Unpickler_ResizeMemoList ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binput DD imagerel load_binput
	DD	imagerel load_binput+147
	DD	imagerel $unwind$load_binput
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binput DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_binput
_TEXT	SEGMENT
value$ = 32
s$ = 40
idx$ = 48
self$ = 80
load_binput PROC					; COMDAT

; 4990 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4991 :     PyObject *value;
; 4992 :     Py_ssize_t idx;
; 4993 :     char *s;
; 4994 : 
; 4995 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 07		 jge	 SHORT $LN2@load_binpu

; 4996 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	eb 64		 jmp	 SHORT $LN3@load_binpu
$LN2@load_binpu:

; 4997 : 
; 4998 :     if (Py_SIZE(self->stack) <= 0)

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0002f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00033	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00038	7f 07		 jg	 SHORT $LN1@load_binpu

; 4999 :         return stack_underflow();

  0003a	e8 00 00 00 00	 call	 stack_underflow
  0003f	eb 4d		 jmp	 SHORT $LN3@load_binpu
$LN1@load_binpu:

; 5000 :     value = self->stack->data[Py_SIZE(self->stack) - 1];

  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00046	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0004f	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00053	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00057	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0005b	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  00060	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 5001 : 
; 5002 :     idx = Py_CHARMASK(s[0]);

  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0006a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0006d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00072	0f b6 c0	 movzx	 eax, al
  00075	48 89 44 24 30	 mov	 QWORD PTR idx$[rsp], rax

; 5003 : 
; 5004 :     return _Unpickler_MemoPut(self, idx, value);

  0007a	4c 8b 44 24 20	 mov	 r8, QWORD PTR value$[rsp]
  0007f	48 8b 54 24 30	 mov	 rdx, QWORD PTR idx$[rsp]
  00084	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00089	e8 00 00 00 00	 call	 _Unpickler_MemoPut
$LN3@load_binpu:

; 5005 : }

  0008e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00092	c3		 ret	 0
load_binput ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@KDGICMDO@negative?5LONG_BINPUT?5argument?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_long_binput DD imagerel load_long_binput
	DD	imagerel load_long_binput+183
	DD	imagerel $unwind$load_long_binput
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_long_binput DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BO@KDGICMDO@negative?5LONG_BINPUT?5argument?$AA@
CONST	SEGMENT
??_C@_0BO@KDGICMDO@negative?5LONG_BINPUT?5argument?$AA@ DB 'negative LONG'
	DB	'_BINPUT argument', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_long_binput
_TEXT	SEGMENT
value$ = 32
s$ = 40
idx$ = 48
self$ = 80
load_long_binput PROC					; COMDAT

; 5009 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5010 :     PyObject *value;
; 5011 :     Py_ssize_t idx;
; 5012 :     char *s;
; 5013 : 
; 5014 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00009	41 b8 04 00 00
	00		 mov	 r8d, 4
  0000f	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 0a		 jge	 SHORT $LN3@load_long_@3

; 5015 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 85 00 00 00	 jmp	 $LN4@load_long_@3
$LN3@load_long_@3:

; 5016 : 
; 5017 :     if (Py_SIZE(self->stack) <= 0)

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00032	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00036	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0003b	7f 07		 jg	 SHORT $LN2@load_long_@3

; 5018 :         return stack_underflow();

  0003d	e8 00 00 00 00	 call	 stack_underflow
  00042	eb 6e		 jmp	 SHORT $LN4@load_long_@3
$LN2@load_long_@3:

; 5019 :     value = self->stack->data[Py_SIZE(self->stack) - 1];

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00049	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00052	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00056	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0005a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0005e	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  00063	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 5020 : 
; 5021 :     idx = calc_binsize(s, 4);

  00068	ba 04 00 00 00	 mov	 edx, 4
  0006d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00072	e8 00 00 00 00	 call	 calc_binsize
  00077	48 89 44 24 30	 mov	 QWORD PTR idx$[rsp], rax

; 5022 :     if (idx < 0) {

  0007c	48 83 7c 24 30
	00		 cmp	 QWORD PTR idx$[rsp], 0
  00082	7d 1a		 jge	 SHORT $LN1@load_long_@3

; 5023 :         PyErr_SetString(PyExc_ValueError,
; 5024 :                         "negative LONG_BINPUT argument");

  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@KDGICMDO@negative?5LONG_BINPUT?5argument?$AA@
  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00092	e8 00 00 00 00	 call	 PyErr_SetString

; 5025 :         return -1;

  00097	b8 ff ff ff ff	 mov	 eax, -1
  0009c	eb 14		 jmp	 SHORT $LN4@load_long_@3
$LN1@load_long_@3:

; 5026 :     }
; 5027 : 
; 5028 :     return _Unpickler_MemoPut(self, idx, value);

  0009e	4c 8b 44 24 20	 mov	 r8, QWORD PTR value$[rsp]
  000a3	48 8b 54 24 30	 mov	 rdx, QWORD PTR idx$[rsp]
  000a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000ad	e8 00 00 00 00	 call	 _Unpickler_MemoPut
$LN4@load_long_@3:

; 5029 : }

  000b2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b6	c3		 ret	 0
load_long_binput ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_append DD imagerel load_append
	DD	imagerel load_append+43
	DD	imagerel $unwind$load_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_append DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_append
_TEXT	SEGMENT
self$ = 48
load_append PROC					; COMDAT

; 5088 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5089 :     return do_append(self, Py_SIZE(self->stack) - 1);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00016	48 ff c8	 dec	 rax
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00021	e8 00 00 00 00	 call	 do_append

; 5090 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
load_append ENDP
_TEXT	ENDS
EXTRN	PyList_SetSlice:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_append DD imagerel do_append
	DD	imagerel do_append+563
	DD	imagerel $unwind$do_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_append DD 010e01H
	DD	0e20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT do_append
_TEXT	SEGMENT
value$ = 32
i$ = 40
len$ = 48
list$ = 56
slice$24124 = 64
list_len$24125 = 72
ret$24126 = 80
append_func$24131 = 88
result$24140 = 96
self$ = 128
x$ = 136
do_append PROC						; COMDAT

; 5033 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 5034 :     PyObject *value;
; 5035 :     PyObject *list;
; 5036 :     Py_ssize_t len, i;
; 5037 : 
; 5038 :     len = Py_SIZE(self->stack);

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00016	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001e	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 5039 :     if (x > len || x <= 0)

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00028	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR x$[rsp], rax
  00030	7f 0b		 jg	 SHORT $LN10@do_append
  00032	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR x$[rsp], 0
  0003b	7f 0a		 jg	 SHORT $LN11@do_append
$LN10@do_append:

; 5040 :         return stack_underflow();

  0003d	e8 00 00 00 00	 call	 stack_underflow
  00042	e9 e7 01 00 00	 jmp	 $LN12@do_append
$LN11@do_append:

; 5041 :     if (len == x)  /* nothing to do */

  00047	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0004f	48 39 44 24 30	 cmp	 QWORD PTR len$[rsp], rax
  00054	75 07		 jne	 SHORT $LN9@do_append

; 5042 :         return 0;

  00056	33 c0		 xor	 eax, eax
  00058	e9 d1 01 00 00	 jmp	 $LN12@do_append
$LN9@do_append:

; 5043 : 
; 5044 :     list = self->stack->data[x - 1];

  0005d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00065	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00069	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0006d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  00075	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  0007a	48 89 44 24 38	 mov	 QWORD PTR list$[rsp], rax

; 5045 : 
; 5046 :     if (PyList_Check(list)) {

  0007f	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  00084	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00088	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0008e	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00093	85 c0		 test	 eax, eax
  00095	74 73		 je	 SHORT $LN8@do_append

; 5047 :         PyObject *slice;
; 5048 :         Py_ssize_t list_len;
; 5049 :         int ret;
; 5050 : 
; 5051 :         slice = Pdata_poplist(self->stack, x);

  00097	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0009f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a7	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000ab	e8 00 00 00 00	 call	 Pdata_poplist
  000b0	48 89 44 24 40	 mov	 QWORD PTR slice$24124[rsp], rax

; 5052 :         if (!slice)

  000b5	48 83 7c 24 40
	00		 cmp	 QWORD PTR slice$24124[rsp], 0
  000bb	75 0a		 jne	 SHORT $LN7@do_append

; 5053 :             return -1;

  000bd	b8 ff ff ff ff	 mov	 eax, -1
  000c2	e9 67 01 00 00	 jmp	 $LN12@do_append
$LN7@do_append:

; 5054 :         list_len = PyList_GET_SIZE(list);

  000c7	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  000cc	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d0	48 89 44 24 48	 mov	 QWORD PTR list_len$24125[rsp], rax

; 5055 :         ret = PyList_SetSlice(list, list_len, list_len, slice);

  000d5	4c 8b 4c 24 40	 mov	 r9, QWORD PTR slice$24124[rsp]
  000da	4c 8b 44 24 48	 mov	 r8, QWORD PTR list_len$24125[rsp]
  000df	48 8b 54 24 48	 mov	 rdx, QWORD PTR list_len$24125[rsp]
  000e4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$[rsp]
  000e9	e8 00 00 00 00	 call	 PyList_SetSlice
  000ee	89 44 24 50	 mov	 DWORD PTR ret$24126[rsp], eax

; 5056 :         Py_DECREF(slice);

  000f2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR slice$24124[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_DecRef

; 5057 :         return ret;

  000fc	8b 44 24 50	 mov	 eax, DWORD PTR ret$24126[rsp]
  00100	e9 29 01 00 00	 jmp	 $LN12@do_append

; 5058 :     }
; 5059 :     else {

  00105	e9 22 01 00 00	 jmp	 $LN6@do_append
$LN8@do_append:

; 5060 :         PyObject *append_func;
; 5061 :         _Py_IDENTIFIER(append);
; 5062 : 
; 5063 :         append_func = _PyObject_GetAttrId(list, &PyId_append);

  0010a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_append@?3??do_append@@9@9
  0010f	8b c0		 mov	 eax, eax
  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00117	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00120	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00124	48 8b d0	 mov	 rdx, rax
  00127	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$[rsp]
  0012c	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00131	48 89 44 24 58	 mov	 QWORD PTR append_func$24131[rsp], rax

; 5064 :         if (append_func == NULL)

  00136	48 83 7c 24 58
	00		 cmp	 QWORD PTR append_func$24131[rsp], 0
  0013c	75 0a		 jne	 SHORT $LN5@do_append

; 5065 :             return -1;

  0013e	b8 ff ff ff ff	 mov	 eax, -1
  00143	e9 e6 00 00 00	 jmp	 $LN12@do_append
$LN5@do_append:

; 5066 :         for (i = x; i < len; i++) {

  00148	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00150	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00155	eb 0d		 jmp	 SHORT $LN4@do_append
$LN3@do_append:
  00157	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0015c	48 ff c0	 inc	 rax
  0015f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN4@do_append:
  00164	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00169	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0016e	0f 8d 96 00 00
	00		 jge	 $LN2@do_append

; 5067 :             PyObject *result;
; 5068 : 
; 5069 :             value = self->stack->data[i];

  00174	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0017c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00180	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00184	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00189	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0018d	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 5070 :             result = _Unpickler_FastCall(self, append_func, value);

  00192	4c 8b 44 24 20	 mov	 r8, QWORD PTR value$[rsp]
  00197	48 8b 54 24 58	 mov	 rdx, QWORD PTR append_func$24131[rsp]
  0019c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001a4	e8 00 00 00 00	 call	 _Unpickler_FastCall
  001a9	48 89 44 24 60	 mov	 QWORD PTR result$24140[rsp], rax

; 5071 :             if (result == NULL) {

  001ae	48 83 7c 24 60
	00		 cmp	 QWORD PTR result$24140[rsp], 0
  001b4	75 45		 jne	 SHORT $LN1@do_append

; 5072 :                 Pdata_clear(self->stack, i + 1);

  001b6	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  001bb	48 ff c0	 inc	 rax
  001be	48 8b d0	 mov	 rdx, rax
  001c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001c9	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  001cd	e8 00 00 00 00	 call	 Pdata_clear

; 5073 :                 Py_SIZE(self->stack) = x;

  001d2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001da	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001de	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  001e6	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 5074 :                 Py_DECREF(append_func);

  001ea	48 8b 4c 24 58	 mov	 rcx, QWORD PTR append_func$24131[rsp]
  001ef	e8 00 00 00 00	 call	 _Py_DecRef

; 5075 :                 return -1;

  001f4	b8 ff ff ff ff	 mov	 eax, -1
  001f9	eb 33		 jmp	 SHORT $LN12@do_append
$LN1@do_append:

; 5076 :             }
; 5077 :             Py_DECREF(result);

  001fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$24140[rsp]
  00200	e8 00 00 00 00	 call	 _Py_DecRef

; 5078 :         }

  00205	e9 4d ff ff ff	 jmp	 $LN3@do_append
$LN2@do_append:

; 5079 :         Py_SIZE(self->stack) = x;

  0020a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00212	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00216	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  0021e	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 5080 :         Py_DECREF(append_func);

  00222	48 8b 4c 24 58	 mov	 rcx, QWORD PTR append_func$24131[rsp]
  00227	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@do_append:

; 5081 :     }
; 5082 : 
; 5083 :     return 0;

  0022c	33 c0		 xor	 eax, eax
$LN12@do_append:

; 5084 : }

  0022e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00232	c3		 ret	 0
do_append ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_appends DD imagerel load_appends
	DD	imagerel load_appends+37
	DD	imagerel $unwind$load_appends
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_appends DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_appends
_TEXT	SEGMENT
self$ = 48
load_appends PROC					; COMDAT

; 5094 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5095 :     return do_append(self, marker(self));

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 marker
  00013	48 8b d0	 mov	 rdx, rax
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0001b	e8 00 00 00 00	 call	 do_append

; 5096 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
load_appends ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_setitem DD imagerel load_setitem
	DD	imagerel load_setitem+44
	DD	imagerel $unwind$load_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_setitem DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_setitem
_TEXT	SEGMENT
self$ = 48
load_setitem PROC					; COMDAT

; 5136 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5137 :     return do_setitems(self, Py_SIZE(self->stack) - 2);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00016	48 83 e8 02	 sub	 rax, 2
  0001a	48 8b d0	 mov	 rdx, rax
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00022	e8 00 00 00 00	 call	 do_setitems

; 5138 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
load_setitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@LEPMKFJ@odd?5number?5of?5items?5for?5SETITEMS@ ; `string'
EXTRN	PyObject_SetItem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_setitems DD imagerel do_setitems
	DD	imagerel do_setitems+339
	DD	imagerel $unwind$do_setitems
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_setitems DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0CB@LEPMKFJ@odd?5number?5of?5items?5for?5SETITEMS@
CONST	SEGMENT
??_C@_0CB@LEPMKFJ@odd?5number?5of?5items?5for?5SETITEMS@ DB 'odd number o'
	DB	'f items for SETITEMS', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT do_setitems
_TEXT	SEGMENT
value$ = 32
i$ = 40
dict$ = 48
key$ = 56
len$ = 64
status$ = 72
self$ = 96
x$ = 104
do_setitems PROC					; COMDAT

; 5100 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5101 :     PyObject *value, *key;
; 5102 :     PyObject *dict;
; 5103 :     Py_ssize_t len, i;
; 5104 :     int status = 0;

  0000e	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 5105 : 
; 5106 :     len = Py_SIZE(self->stack);

  00016	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0001b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00023	48 89 44 24 40	 mov	 QWORD PTR len$[rsp], rax

; 5107 :     if (x > len || x <= 0)

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  0002d	48 39 44 24 68	 cmp	 QWORD PTR x$[rsp], rax
  00032	7f 08		 jg	 SHORT $LN7@do_setitem
  00034	48 83 7c 24 68
	00		 cmp	 QWORD PTR x$[rsp], 0
  0003a	7f 0a		 jg	 SHORT $LN8@do_setitem
$LN7@do_setitem:

; 5108 :         return stack_underflow();

  0003c	e8 00 00 00 00	 call	 stack_underflow
  00041	e9 08 01 00 00	 jmp	 $LN9@do_setitem
$LN8@do_setitem:

; 5109 :     if (len == x)  /* nothing to do */

  00046	48 8b 44 24 68	 mov	 rax, QWORD PTR x$[rsp]
  0004b	48 39 44 24 40	 cmp	 QWORD PTR len$[rsp], rax
  00050	75 07		 jne	 SHORT $LN6@do_setitem

; 5110 :         return 0;

  00052	33 c0		 xor	 eax, eax
  00054	e9 f5 00 00 00	 jmp	 $LN9@do_setitem
$LN6@do_setitem:

; 5111 :     if ((len - x) % 2 != 0) {

  00059	48 8b 44 24 68	 mov	 rax, QWORD PTR x$[rsp]
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR len$[rsp]
  00063	48 2b c8	 sub	 rcx, rax
  00066	48 8b c1	 mov	 rax, rcx
  00069	48 99		 cdq
  0006b	48 83 e0 01	 and	 rax, 1
  0006f	48 33 c2	 xor	 rax, rdx
  00072	48 2b c2	 sub	 rax, rdx
  00075	48 85 c0	 test	 rax, rax
  00078	74 1d		 je	 SHORT $LN5@do_setitem

; 5112 :         /* Currupt or hostile pickle -- we never write one like this. */
; 5113 :         PyErr_SetString(UnpicklingError, "odd number of items for SETITEMS");

  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@LEPMKFJ@odd?5number?5of?5items?5for?5SETITEMS@
  00081	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00088	e8 00 00 00 00	 call	 PyErr_SetString

; 5114 :         return -1;

  0008d	b8 ff ff ff ff	 mov	 eax, -1
  00092	e9 b7 00 00 00	 jmp	 $LN9@do_setitem
$LN5@do_setitem:

; 5115 :     }
; 5116 : 
; 5117 :     /* Here, dict does not actually need to be a PyDict; it could be anything
; 5118 :        that supports the __setitem__ attribute. */
; 5119 :     dict = self->stack->data[x - 1];

  00097	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a0	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR x$[rsp]
  000a9	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  000ae	48 89 44 24 30	 mov	 QWORD PTR dict$[rsp], rax

; 5120 : 
; 5121 :     for (i = x + 1; i < len; i += 2) {

  000b3	48 8b 44 24 68	 mov	 rax, QWORD PTR x$[rsp]
  000b8	48 ff c0	 inc	 rax
  000bb	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  000c0	eb 0e		 jmp	 SHORT $LN4@do_setitem
$LN3@do_setitem:
  000c2	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000c7	48 83 c0 02	 add	 rax, 2
  000cb	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN4@do_setitem:
  000d0	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  000d5	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000da	7d 5b		 jge	 SHORT $LN2@do_setitem

; 5122 :         key = self->stack->data[i - 1];

  000dc	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000e1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000e5	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000e9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000ee	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  000f3	48 89 44 24 38	 mov	 QWORD PTR key$[rsp], rax

; 5123 :         value = self->stack->data[i];

  000f8	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000fd	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00101	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00105	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0010a	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0010e	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 5124 :         if (PyObject_SetItem(dict, key, value) < 0) {

  00113	4c 8b 44 24 20	 mov	 r8, QWORD PTR value$[rsp]
  00118	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  0011d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dict$[rsp]
  00122	e8 00 00 00 00	 call	 PyObject_SetItem
  00127	85 c0		 test	 eax, eax
  00129	7d 0a		 jge	 SHORT $LN1@do_setitem

; 5125 :             status = -1;

  0012b	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1

; 5126 :             break;

  00133	eb 02		 jmp	 SHORT $LN2@do_setitem
$LN1@do_setitem:

; 5127 :         }
; 5128 :     }

  00135	eb 8b		 jmp	 SHORT $LN3@do_setitem
$LN2@do_setitem:

; 5129 : 
; 5130 :     Pdata_clear(self->stack, x);

  00137	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  0013c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00141	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00145	e8 00 00 00 00	 call	 Pdata_clear

; 5131 :     return status;

  0014a	8b 44 24 48	 mov	 eax, DWORD PTR status$[rsp]
$LN9@do_setitem:

; 5132 : }

  0014e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00152	c3		 ret	 0
do_setitems ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_setitems DD imagerel load_setitems
	DD	imagerel load_setitems+37
	DD	imagerel $unwind$load_setitems
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_setitems DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_setitems
_TEXT	SEGMENT
self$ = 48
load_setitems PROC					; COMDAT

; 5142 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5143 :     return do_setitems(self, marker(self));

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 marker
  00013	48 8b d0	 mov	 rdx, rax
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0001b	e8 00 00 00 00	 call	 do_setitems

; 5144 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
load_setitems ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@BKAEOMIB@slot?5state?5is?5not?5a?5dictionary?$AA@ ; `string'
PUBLIC	??_C@_0BK@BPIFALMC@state?5is?5not?5a?5dictionary?$AA@ ; `string'
EXTRN	PyObject_SetAttr:PROC
EXTRN	PyUnicode_InternInPlace:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_build DD imagerel load_build
	DD	imagerel load_build+873
	DD	imagerel $unwind$load_build
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_build DD 020c01H
	DD	013010cH
xdata	ENDS
;	COMDAT ??_C@_0BP@BKAEOMIB@slot?5state?5is?5not?5a?5dictionary?$AA@
CONST	SEGMENT
??_C@_0BP@BKAEOMIB@slot?5state?5is?5not?5a?5dictionary?$AA@ DB 'slot stat'
	DB	'e is not a dictionary', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BPIFALMC@state?5is?5not?5a?5dictionary?$AA@
CONST	SEGMENT
??_C@_0BK@BPIFALMC@state?5is?5not?5a?5dictionary?$AA@ DB 'state is not a '
	DB	'dictionary', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_build
_TEXT	SEGMENT
slotstate$ = 32
inst$ = 40
status$ = 48
setstate$ = 56
state$ = 64
result$24214 = 72
tmp$24222 = 80
i$24234 = 88
dict$24231 = 96
d_key$24232 = 104
d_value$24233 = 112
i$24258 = 120
d_key$24256 = 128
d_value$24257 = 136
self$ = 160
load_build PROC						; COMDAT

; 5148 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 5149 :     PyObject *state, *inst, *slotstate;
; 5150 :     PyObject *setstate;
; 5151 :     int status = 0;

  0000c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 5152 :     _Py_IDENTIFIER(__setstate__);
; 5153 : 
; 5154 :     /* Stack is ... instance, state.  We want to leave instance at
; 5155 :      * the stack top, possibly mutated via instance.__setstate__(state).
; 5156 :      */
; 5157 :     if (Py_SIZE(self->stack) < 2)

  00014	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00020	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  00025	7d 0a		 jge	 SHORT $LN29@load_build

; 5158 :         return stack_underflow();

  00027	e8 00 00 00 00	 call	 stack_underflow
  0002c	e9 30 03 00 00	 jmp	 $LN30@load_build
$LN29@load_build:
$LN28@load_build:

; 5159 : 
; 5160 :     PDATA_POP(self->stack, state);

  00031	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00039	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0003d	e8 00 00 00 00	 call	 Pdata_pop
  00042	48 89 44 24 40	 mov	 QWORD PTR state$[rsp], rax
  00047	33 c0		 xor	 eax, eax
  00049	85 c0		 test	 eax, eax
  0004b	75 e4		 jne	 SHORT $LN28@load_build

; 5161 :     if (state == NULL)

  0004d	48 83 7c 24 40
	00		 cmp	 QWORD PTR state$[rsp], 0
  00053	75 0a		 jne	 SHORT $LN25@load_build

; 5162 :         return -1;

  00055	b8 ff ff ff ff	 mov	 eax, -1
  0005a	e9 02 03 00 00	 jmp	 $LN30@load_build
$LN25@load_build:

; 5163 : 
; 5164 :     inst = self->stack->data[Py_SIZE(self->stack) - 1];

  0005f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00067	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00073	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00077	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0007b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0007f	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  00084	48 89 44 24 28	 mov	 QWORD PTR inst$[rsp], rax

; 5165 : 
; 5166 :     setstate = _PyObject_GetAttrId(inst, &PyId___setstate__);

  00089	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___setstate__@?1??load_build@@9@9
  0008e	8b c0		 mov	 eax, eax
  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00096	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0009f	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000a3	48 8b d0	 mov	 rdx, rax
  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR inst$[rsp]
  000ab	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  000b0	48 89 44 24 38	 mov	 QWORD PTR setstate$[rsp], rax

; 5167 :     if (setstate == NULL) {

  000b5	48 83 7c 24 38
	00		 cmp	 QWORD PTR setstate$[rsp], 0
  000bb	75 2d		 jne	 SHORT $LN24@load_build

; 5168 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  000bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  000c4	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000c9	85 c0		 test	 eax, eax
  000cb	74 07		 je	 SHORT $LN23@load_build

; 5169 :             PyErr_Clear();

  000cd	e8 00 00 00 00	 call	 PyErr_Clear

; 5170 :         else {

  000d2	eb 14		 jmp	 SHORT $LN22@load_build
$LN23@load_build:

; 5171 :             Py_DECREF(state);

  000d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000d9	e8 00 00 00 00	 call	 _Py_DecRef

; 5172 :             return -1;

  000de	b8 ff ff ff ff	 mov	 eax, -1
  000e3	e9 79 02 00 00	 jmp	 $LN30@load_build
$LN22@load_build:

; 5173 :         }
; 5174 :     }
; 5175 :     else {

  000e8	eb 49		 jmp	 SHORT $LN21@load_build
$LN24@load_build:

; 5176 :         PyObject *result;
; 5177 : 
; 5178 :         /* The explicit __setstate__ is responsible for everything. */
; 5179 :         /* Ugh... this does not leak since _Unpickler_FastCall() steals the
; 5180 :            reference to state first. */
; 5181 :         result = _Unpickler_FastCall(self, setstate, state);

  000ea	4c 8b 44 24 40	 mov	 r8, QWORD PTR state$[rsp]
  000ef	48 8b 54 24 38	 mov	 rdx, QWORD PTR setstate$[rsp]
  000f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000fc	e8 00 00 00 00	 call	 _Unpickler_FastCall
  00101	48 89 44 24 48	 mov	 QWORD PTR result$24214[rsp], rax

; 5182 :         Py_DECREF(setstate);

  00106	48 8b 4c 24 38	 mov	 rcx, QWORD PTR setstate$[rsp]
  0010b	e8 00 00 00 00	 call	 _Py_DecRef

; 5183 :         if (result == NULL)

  00110	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$24214[rsp], 0
  00116	75 0a		 jne	 SHORT $LN20@load_build

; 5184 :             return -1;

  00118	b8 ff ff ff ff	 mov	 eax, -1
  0011d	e9 3f 02 00 00	 jmp	 $LN30@load_build
$LN20@load_build:

; 5185 :         Py_DECREF(result);

  00122	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$24214[rsp]
  00127	e8 00 00 00 00	 call	 _Py_DecRef

; 5186 :         return 0;

  0012c	33 c0		 xor	 eax, eax
  0012e	e9 2e 02 00 00	 jmp	 $LN30@load_build
$LN21@load_build:

; 5187 :     }
; 5188 : 
; 5189 :     /* A default __setstate__.  First see whether state embeds a
; 5190 :      * slot state dict too (a proto 2 addition).
; 5191 :      */
; 5192 :     if (PyTuple_Check(state) && Py_SIZE(state) == 2) {

  00133	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00138	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0013c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00142	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00147	85 c0		 test	 eax, eax
  00149	74 52		 je	 SHORT $LN19@load_build
  0014b	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00150	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  00155	75 46		 jne	 SHORT $LN19@load_build

; 5193 :         PyObject *tmp = state;

  00157	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0015c	48 89 44 24 50	 mov	 QWORD PTR tmp$24222[rsp], rax

; 5194 : 
; 5195 :         state = PyTuple_GET_ITEM(tmp, 0);

  00161	48 8b 44 24 50	 mov	 rax, QWORD PTR tmp$24222[rsp]
  00166	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0016a	48 89 44 24 40	 mov	 QWORD PTR state$[rsp], rax

; 5196 :         slotstate = PyTuple_GET_ITEM(tmp, 1);

  0016f	48 8b 44 24 50	 mov	 rax, QWORD PTR tmp$24222[rsp]
  00174	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00178	48 89 44 24 20	 mov	 QWORD PTR slotstate$[rsp], rax

; 5197 :         Py_INCREF(state);

  0017d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00182	e8 00 00 00 00	 call	 _Py_IncRef

; 5198 :         Py_INCREF(slotstate);

  00187	48 8b 4c 24 20	 mov	 rcx, QWORD PTR slotstate$[rsp]
  0018c	e8 00 00 00 00	 call	 _Py_IncRef

; 5199 :         Py_DECREF(tmp);

  00191	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tmp$24222[rsp]
  00196	e8 00 00 00 00	 call	 _Py_DecRef

; 5200 :     }
; 5201 :     else

  0019b	eb 09		 jmp	 SHORT $LN18@load_build
$LN19@load_build:

; 5202 :         slotstate = NULL;

  0019d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR slotstate$[rsp], 0
$LN18@load_build:

; 5203 : 
; 5204 :     /* Set inst.__dict__ from the state dict (if any). */
; 5205 :     if (state != Py_None) {

  001a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001ad	48 39 44 24 40	 cmp	 QWORD PTR state$[rsp], rax
  001b2	0f 84 f2 00 00
	00		 je	 $LN17@load_build

; 5206 :         PyObject *dict;
; 5207 :         PyObject *d_key, *d_value;
; 5208 :         Py_ssize_t i;
; 5209 :         _Py_IDENTIFIER(__dict__);
; 5210 : 
; 5211 :         if (!PyDict_Check(state)) {

  001b8	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  001bd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001c1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001c7	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  001cc	85 c0		 test	 eax, eax
  001ce	75 18		 jne	 SHORT $LN16@load_build

; 5212 :             PyErr_SetString(UnpicklingError, "state is not a dictionary");

  001d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@BPIFALMC@state?5is?5not?5a?5dictionary?$AA@
  001d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  001de	e8 00 00 00 00	 call	 PyErr_SetString

; 5213 :             goto error;

  001e3	e9 4b 01 00 00	 jmp	 $error$24241
$LN16@load_build:

; 5214 :         }
; 5215 :         dict = _PyObject_GetAttrId(inst, &PyId___dict__);

  001e8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___dict__@?7??load_build@@9@9
  001ed	8b c0		 mov	 eax, eax
  001ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001f5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001fe	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00202	48 8b d0	 mov	 rdx, rax
  00205	48 8b 4c 24 28	 mov	 rcx, QWORD PTR inst$[rsp]
  0020a	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0020f	48 89 44 24 60	 mov	 QWORD PTR dict$24231[rsp], rax

; 5216 :         if (dict == NULL)

  00214	48 83 7c 24 60
	00		 cmp	 QWORD PTR dict$24231[rsp], 0
  0021a	75 05		 jne	 SHORT $LN15@load_build

; 5217 :             goto error;

  0021c	e9 12 01 00 00	 jmp	 $error$24241
$LN15@load_build:

; 5218 : 
; 5219 :         i = 0;

  00221	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR i$24234[rsp], 0
$LN14@load_build:

; 5220 :         while (PyDict_Next(state, &i, &d_key, &d_value)) {

  0022a	4c 8d 4c 24 70	 lea	 r9, QWORD PTR d_value$24233[rsp]
  0022f	4c 8d 44 24 68	 lea	 r8, QWORD PTR d_key$24232[rsp]
  00234	48 8d 54 24 58	 lea	 rdx, QWORD PTR i$24234[rsp]
  00239	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0023e	e8 00 00 00 00	 call	 PyDict_Next
  00243	85 c0		 test	 eax, eax
  00245	74 59		 je	 SHORT $LN13@load_build

; 5221 :             /* normally the keys for instance attributes are
; 5222 :                interned.  we should try to do that here. */
; 5223 :             Py_INCREF(d_key);

  00247	48 8b 4c 24 68	 mov	 rcx, QWORD PTR d_key$24232[rsp]
  0024c	e8 00 00 00 00	 call	 _Py_IncRef

; 5224 :             if (PyUnicode_CheckExact(d_key))

  00251	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00258	48 8b 4c 24 68	 mov	 rcx, QWORD PTR d_key$24232[rsp]
  0025d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00261	75 0a		 jne	 SHORT $LN12@load_build

; 5225 :                 PyUnicode_InternInPlace(&d_key);

  00263	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d_key$24232[rsp]
  00268	e8 00 00 00 00	 call	 PyUnicode_InternInPlace
$LN12@load_build:

; 5226 :             if (PyObject_SetItem(dict, d_key, d_value) < 0) {

  0026d	4c 8b 44 24 70	 mov	 r8, QWORD PTR d_value$24233[rsp]
  00272	48 8b 54 24 68	 mov	 rdx, QWORD PTR d_key$24232[rsp]
  00277	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dict$24231[rsp]
  0027c	e8 00 00 00 00	 call	 PyObject_SetItem
  00281	85 c0		 test	 eax, eax
  00283	7d 0f		 jge	 SHORT $LN11@load_build

; 5227 :                 Py_DECREF(d_key);

  00285	48 8b 4c 24 68	 mov	 rcx, QWORD PTR d_key$24232[rsp]
  0028a	e8 00 00 00 00	 call	 _Py_DecRef

; 5228 :                 goto error;

  0028f	e9 9f 00 00 00	 jmp	 $error$24241
$LN11@load_build:

; 5229 :             }
; 5230 :             Py_DECREF(d_key);

  00294	48 8b 4c 24 68	 mov	 rcx, QWORD PTR d_key$24232[rsp]
  00299	e8 00 00 00 00	 call	 _Py_DecRef

; 5231 :         }

  0029e	eb 8a		 jmp	 SHORT $LN14@load_build
$LN13@load_build:

; 5232 :         Py_DECREF(dict);

  002a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dict$24231[rsp]
  002a5	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@load_build:

; 5233 :     }
; 5234 : 
; 5235 :     /* Also set instance attributes from the slotstate dict (if any). */
; 5236 :     if (slotstate != NULL) {

  002aa	48 83 7c 24 20
	00		 cmp	 QWORD PTR slotstate$[rsp], 0
  002b0	74 7b		 je	 SHORT $LN10@load_build

; 5237 :         PyObject *d_key, *d_value;
; 5238 :         Py_ssize_t i;
; 5239 : 
; 5240 :         if (!PyDict_Check(slotstate)) {

  002b2	48 8b 44 24 20	 mov	 rax, QWORD PTR slotstate$[rsp]
  002b7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002bb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002c1	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002c6	85 c0		 test	 eax, eax
  002c8	75 15		 jne	 SHORT $LN9@load_build

; 5241 :             PyErr_SetString(UnpicklingError,
; 5242 :                             "slot state is not a dictionary");

  002ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@BKAEOMIB@slot?5state?5is?5not?5a?5dictionary?$AA@
  002d1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  002d8	e8 00 00 00 00	 call	 PyErr_SetString

; 5243 :             goto error;

  002dd	eb 54		 jmp	 SHORT $error$24241
$LN9@load_build:

; 5244 :         }
; 5245 :         i = 0;

  002df	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i$24258[rsp], 0
$LN8@load_build:

; 5246 :         while (PyDict_Next(slotstate, &i, &d_key, &d_value)) {

  002e8	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR d_value$24257[rsp]
  002f0	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR d_key$24256[rsp]
  002f8	48 8d 54 24 78	 lea	 rdx, QWORD PTR i$24258[rsp]
  002fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR slotstate$[rsp]
  00302	e8 00 00 00 00	 call	 PyDict_Next
  00307	85 c0		 test	 eax, eax
  00309	74 22		 je	 SHORT $LN7@load_build

; 5247 :             if (PyObject_SetAttr(inst, d_key, d_value) < 0)

  0030b	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR d_value$24257[rsp]
  00313	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR d_key$24256[rsp]
  0031b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR inst$[rsp]
  00320	e8 00 00 00 00	 call	 PyObject_SetAttr
  00325	85 c0		 test	 eax, eax
  00327	7d 02		 jge	 SHORT $LN6@load_build

; 5248 :                 goto error;

  00329	eb 08		 jmp	 SHORT $error$24241
$LN6@load_build:

; 5249 :         }

  0032b	eb bb		 jmp	 SHORT $LN8@load_build
$LN7@load_build:
$LN10@load_build:

; 5250 :     }
; 5251 : 
; 5252 :     if (0) {

  0032d	33 c0		 xor	 eax, eax
  0032f	85 c0		 test	 eax, eax
  00331	74 08		 je	 SHORT $LN5@load_build
$error$24241:

; 5253 :   error:
; 5254 :         status = -1;

  00333	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR status$[rsp], -1
$LN5@load_build:

; 5255 :     }
; 5256 : 
; 5257 :     Py_DECREF(state);

  0033b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00340	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@load_build:

; 5258 :     Py_XDECREF(slotstate);

  00345	48 83 7c 24 20
	00		 cmp	 QWORD PTR slotstate$[rsp], 0
  0034b	74 0a		 je	 SHORT $LN1@load_build
  0034d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR slotstate$[rsp]
  00352	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@load_build:
  00357	33 c0		 xor	 eax, eax
  00359	85 c0		 test	 eax, eax
  0035b	75 e8		 jne	 SHORT $LN4@load_build

; 5259 :     return status;

  0035d	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
$LN30@load_build:

; 5260 : }

  00361	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00368	c3		 ret	 0
load_build ENDP
_TEXT	ENDS
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_mark DD imagerel load_mark
	DD	imagerel load_mark+320
	DD	imagerel $unwind$load_mark
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_mark DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_mark
_TEXT	SEGMENT
marks$24279 = 32
alloc$24278 = 40
self$ = 64
load_mark PROC						; COMDAT

; 5264 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5265 : 
; 5266 :     /* Note that we split the (pickle.py) stack into two stacks, an
; 5267 :      * object stack and a mark stack. Here we push a mark onto the
; 5268 :      * mark stack.
; 5269 :      */
; 5270 : 
; 5271 :     if ((self->num_marks + 1) >= self->marks_size) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 80 30 01
	00 00		 mov	 rax, QWORD PTR [rax+304]
  00015	48 ff c0	 inc	 rax
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001d	48 3b 81 38 01
	00 00		 cmp	 rax, QWORD PTR [rcx+312]
  00024	0f 8c cb 00 00
	00		 jl	 $LN6@load_mark

; 5272 :         size_t alloc;
; 5273 :         Py_ssize_t *marks;
; 5274 : 
; 5275 :         /* Use the size_t type to check for overflow. */
; 5276 :         alloc = ((size_t)self->num_marks << 1) + 20;

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002f	48 8b 80 30 01
	00 00		 mov	 rax, QWORD PTR [rax+304]
  00036	48 8d 44 00 14	 lea	 rax, QWORD PTR [rax+rax+20]
  0003b	48 89 44 24 28	 mov	 QWORD PTR alloc$24278[rsp], rax

; 5277 :         if (alloc > (PY_SSIZE_T_MAX / sizeof(Py_ssize_t)) ||
; 5278 :             alloc <= ((size_t)self->num_marks + 1)) {

  00040	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  0004a	48 39 44 24 28	 cmp	 QWORD PTR alloc$24278[rsp], rax
  0004f	77 16		 ja	 SHORT $LN4@load_mark
  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00056	48 8b 80 30 01
	00 00		 mov	 rax, QWORD PTR [rax+304]
  0005d	48 ff c0	 inc	 rax
  00060	48 39 44 24 28	 cmp	 QWORD PTR alloc$24278[rsp], rax
  00065	77 0f		 ja	 SHORT $LN5@load_mark
$LN4@load_mark:

; 5279 :             PyErr_NoMemory();

  00067	e8 00 00 00 00	 call	 PyErr_NoMemory

; 5280 :             return -1;

  0006c	b8 ff ff ff ff	 mov	 eax, -1
  00071	e9 c5 00 00 00	 jmp	 $LN7@load_mark
$LN5@load_mark:

; 5281 :         }
; 5282 : 
; 5283 :         if (self->marks == NULL)

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0007b	48 83 b8 28 01
	00 00 00	 cmp	 QWORD PTR [rax+296], 0
  00083	75 18		 jne	 SHORT $LN3@load_mark

; 5284 :             marks = (Py_ssize_t *) PyMem_Malloc(alloc * sizeof(Py_ssize_t));

  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR alloc$24278[rsp]
  0008a	48 c1 e0 03	 shl	 rax, 3
  0008e	48 8b c8	 mov	 rcx, rax
  00091	e8 00 00 00 00	 call	 PyMem_Malloc
  00096	48 89 44 24 20	 mov	 QWORD PTR marks$24279[rsp], rax

; 5285 :         else

  0009b	eb 22		 jmp	 SHORT $LN2@load_mark
$LN3@load_mark:

; 5286 :             marks = (Py_ssize_t *) PyMem_Realloc(self->marks,
; 5287 :                                                  alloc * sizeof(Py_ssize_t));

  0009d	48 8b 44 24 28	 mov	 rax, QWORD PTR alloc$24278[rsp]
  000a2	48 c1 e0 03	 shl	 rax, 3
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000ae	48 8b 88 28 01
	00 00		 mov	 rcx, QWORD PTR [rax+296]
  000b5	e8 00 00 00 00	 call	 PyMem_Realloc
  000ba	48 89 44 24 20	 mov	 QWORD PTR marks$24279[rsp], rax
$LN2@load_mark:

; 5288 :         if (marks == NULL) {

  000bf	48 83 7c 24 20
	00		 cmp	 QWORD PTR marks$24279[rsp], 0
  000c5	75 0c		 jne	 SHORT $LN1@load_mark

; 5289 :             PyErr_NoMemory();

  000c7	e8 00 00 00 00	 call	 PyErr_NoMemory

; 5290 :             return -1;

  000cc	b8 ff ff ff ff	 mov	 eax, -1
  000d1	eb 68		 jmp	 SHORT $LN7@load_mark
$LN1@load_mark:

; 5291 :         }
; 5292 :         self->marks = marks;

  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR marks$24279[rsp]
  000dd	48 89 88 28 01
	00 00		 mov	 QWORD PTR [rax+296], rcx

; 5293 :         self->marks_size = (Py_ssize_t)alloc;

  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000e9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR alloc$24278[rsp]
  000ee	48 89 88 38 01
	00 00		 mov	 QWORD PTR [rax+312], rcx
$LN6@load_mark:

; 5294 :     }
; 5295 : 
; 5296 :     self->marks[self->num_marks++] = Py_SIZE(self->stack);

  000f5	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000fa	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00103	48 8b 89 30 01
	00 00		 mov	 rcx, QWORD PTR [rcx+304]
  0010a	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  0010f	48 8b 92 28 01
	00 00		 mov	 rdx, QWORD PTR [rdx+296]
  00116	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0011a	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  0011e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00123	48 8b 80 30 01
	00 00		 mov	 rax, QWORD PTR [rax+304]
  0012a	48 ff c0	 inc	 rax
  0012d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00132	48 89 81 30 01
	00 00		 mov	 QWORD PTR [rcx+304], rax

; 5297 : 
; 5298 :     return 0;

  00139	33 c0		 xor	 eax, eax
$LN7@load_mark:

; 5299 : }

  0013b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0013f	c3		 ret	 0
load_mark ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_reduce DD imagerel load_reduce
	DD	imagerel load_reduce+207
	DD	imagerel $unwind$load_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_reduce DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT load_reduce
_TEXT	SEGMENT
argtup$ = 32
callable$ = 40
obj$ = 48
self$ = 80
load_reduce PROC					; COMDAT

; 5303 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5304 :     PyObject *callable = NULL;

  00009	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR callable$[rsp], 0

; 5305 :     PyObject *argtup = NULL;

  00012	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR argtup$[rsp], 0

; 5306 :     PyObject *obj = NULL;

  0001b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR obj$[rsp], 0
$LN13@load_reduc:

; 5307 : 
; 5308 :     PDATA_POP(self->stack, argtup);

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00029	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0002d	e8 00 00 00 00	 call	 Pdata_pop
  00032	48 89 44 24 20	 mov	 QWORD PTR argtup$[rsp], rax
  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 e7		 jne	 SHORT $LN13@load_reduc

; 5309 :     if (argtup == NULL)

  0003d	48 83 7c 24 20
	00		 cmp	 QWORD PTR argtup$[rsp], 0
  00043	75 07		 jne	 SHORT $LN10@load_reduc

; 5310 :         return -1;

  00045	b8 ff ff ff ff	 mov	 eax, -1
  0004a	eb 7e		 jmp	 SHORT $LN14@load_reduc
$LN10@load_reduc:
$LN9@load_reduc:

; 5311 :     PDATA_POP(self->stack, callable);

  0004c	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00051	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00055	e8 00 00 00 00	 call	 Pdata_pop
  0005a	48 89 44 24 28	 mov	 QWORD PTR callable$[rsp], rax
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 e7		 jne	 SHORT $LN9@load_reduc

; 5312 :     if (callable) {

  00065	48 83 7c 24 28
	00		 cmp	 QWORD PTR callable$[rsp], 0
  0006b	74 1e		 je	 SHORT $LN6@load_reduc

; 5313 :         obj = PyObject_CallObject(callable, argtup);

  0006d	48 8b 54 24 20	 mov	 rdx, QWORD PTR argtup$[rsp]
  00072	48 8b 4c 24 28	 mov	 rcx, QWORD PTR callable$[rsp]
  00077	e8 00 00 00 00	 call	 PyObject_CallObject
  0007c	48 89 44 24 30	 mov	 QWORD PTR obj$[rsp], rax

; 5314 :         Py_DECREF(callable);

  00081	48 8b 4c 24 28	 mov	 rcx, QWORD PTR callable$[rsp]
  00086	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@load_reduc:

; 5315 :     }
; 5316 :     Py_DECREF(argtup);

  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR argtup$[rsp]
  00090	e8 00 00 00 00	 call	 _Py_DecRef

; 5317 : 
; 5318 :     if (obj == NULL)

  00095	48 83 7c 24 30
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0009b	75 07		 jne	 SHORT $LN5@load_reduc

; 5319 :         return -1;

  0009d	b8 ff ff ff ff	 mov	 eax, -1
  000a2	eb 26		 jmp	 SHORT $LN14@load_reduc
$LN5@load_reduc:
$LN4@load_reduc:

; 5320 : 
; 5321 :     PDATA_PUSH(self->stack, obj, -1);

  000a4	48 8b 54 24 30	 mov	 rdx, QWORD PTR obj$[rsp]
  000a9	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ae	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000b2	e8 00 00 00 00	 call	 Pdata_push
  000b7	85 c0		 test	 eax, eax
  000b9	7d 07		 jge	 SHORT $LN1@load_reduc
  000bb	b8 ff ff ff ff	 mov	 eax, -1
  000c0	eb 08		 jmp	 SHORT $LN14@load_reduc
$LN1@load_reduc:
  000c2	33 c0		 xor	 eax, eax
  000c4	85 c0		 test	 eax, eax
  000c6	75 dc		 jne	 SHORT $LN4@load_reduc

; 5322 :     return 0;

  000c8	33 c0		 xor	 eax, eax
$LN14@load_reduc:

; 5323 : }

  000ca	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ce	c3		 ret	 0
load_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@BKMFGIKD@unsupported?5pickle?5protocol?3?5?$CFd?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_proto DD imagerel load_proto
	DD	imagerel load_proto+114
	DD	imagerel $unwind$load_proto
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_proto DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CA@BKMFGIKD@unsupported?5pickle?5protocol?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0CA@BKMFGIKD@unsupported?5pickle?5protocol?3?5?$CFd?$AA@ DB 'unsupp'
	DB	'orted pickle protocol: %d', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT load_proto
_TEXT	SEGMENT
i$ = 32
s$ = 40
self$ = 64
load_proto PROC						; COMDAT

; 5330 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5331 :     char *s;
; 5332 :     int i;
; 5333 : 
; 5334 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	48 8d 54 24 28	 lea	 rdx, QWORD PTR s$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00019	e8 00 00 00 00	 call	 _Unpickler_Read
  0001e	48 85 c0	 test	 rax, rax
  00021	7d 07		 jge	 SHORT $LN2@load_proto

; 5335 :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	eb 43		 jmp	 SHORT $LN3@load_proto
$LN2@load_proto:

; 5336 : 
; 5337 :     i = (unsigned char)s[0];

  0002a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 5338 :     if (i <= HIGHEST_PROTOCOL) {

  00036	83 7c 24 20 03	 cmp	 DWORD PTR i$[rsp], 3
  0003b	7f 13		 jg	 SHORT $LN1@load_proto

; 5339 :         self->proto = i;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00042	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00046	89 88 40 01 00
	00		 mov	 DWORD PTR [rax+320], ecx

; 5340 :         return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 1d		 jmp	 SHORT $LN3@load_proto
$LN1@load_proto:

; 5341 :     }
; 5342 : 
; 5343 :     PyErr_Format(PyExc_ValueError, "unsupported pickle protocol: %d", i);

  00050	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$[rsp]
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@BKMFGIKD@unsupported?5pickle?5protocol?3?5?$CFd?$AA@
  0005c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00063	e8 00 00 00 00	 call	 PyErr_Format

; 5344 :     return -1;

  00068	b8 ff ff ff ff	 mov	 eax, -1
$LN3@load_proto:

; 5345 : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
load_proto ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@DGNEEHFG@_compat_pickle?4IMPORT_MAPPING?5va@ ; `string'
PUBLIC	??_C@_0FA@NKGOBDJL@_compat_pickle?4NAME_MAPPING?5valu@ ; `string'
PUBLIC	??_C@_0EC@MMPLOPKK@_compat_pickle?4NAME_MAPPING?5valu@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_find_class DD imagerel Unpickler_find_class
	DD	imagerel Unpickler_find_class+707
	DD	imagerel $unwind$Unpickler_find_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_find_class DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0ED@DGNEEHFG@_compat_pickle?4IMPORT_MAPPING?5va@
CONST	SEGMENT
??_C@_0ED@DGNEEHFG@_compat_pickle?4IMPORT_MAPPING?5va@ DB '_compat_pickle'
	DB	'.IMPORT_MAPPING values should be strings, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NKGOBDJL@_compat_pickle?4NAME_MAPPING?5valu@
CONST	SEGMENT
??_C@_0FA@NKGOBDJL@_compat_pickle?4NAME_MAPPING?5valu@ DB '_compat_pickle'
	DB	'.NAME_MAPPING values should be pairs of str, not (%.200s, %.2'
	DB	'00s)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MMPLOPKK@_compat_pickle?4NAME_MAPPING?5valu@
CONST	SEGMENT
??_C@_0EC@MMPLOPKK@_compat_pickle?4NAME_MAPPING?5valu@ DB '_compat_pickle'
	DB	'.NAME_MAPPING values should be 2-tuples, not %.200s', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Unpickler_find_class
_TEXT	SEGMENT
module$ = 48
module_name$ = 56
modules_dict$ = 64
global_name$ = 72
global$ = 80
key$24505 = 88
item$24506 = 96
self$ = 128
args$ = 136
Unpickler_find_class PROC				; COMDAT

; 5495 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 5496 :     PyObject *global;
; 5497 :     PyObject *modules_dict;
; 5498 :     PyObject *module;
; 5499 :     PyObject *module_name, *global_name;
; 5500 : 
; 5501 :     if (!PyArg_UnpackTuple(args, "find_class", 2, 2,
; 5502 :                            &module_name, &global_name))

  0000e	48 8d 44 24 48	 lea	 rax, QWORD PTR global_name$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00018	48 8d 44 24 38	 lea	 rax, QWORD PTR module_name$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	41 b9 02 00 00
	00		 mov	 r9d, 2
  00028	41 b8 02 00 00
	00		 mov	 r8d, 2
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@BHOLNLBJ@find_class?$AA@
  00035	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0003d	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00042	85 c0		 test	 eax, eax
  00044	75 07		 jne	 SHORT $LN19@Unpickler_@12

; 5503 :         return NULL;

  00046	33 c0		 xor	 eax, eax
  00048	e9 71 02 00 00	 jmp	 $LN20@Unpickler_@12
$LN19@Unpickler_@12:

; 5504 : 
; 5505 :     /* Try to map the old names used in Python 2.x to the new ones used in
; 5506 :        Python 3.x.  We do this only with old pickle protocols and when the
; 5507 :        user has not disabled the feature. */
; 5508 :     if (self->proto < 3 && self->fix_imports) {

  0004d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00055	83 b8 40 01 00
	00 03		 cmp	 DWORD PTR [rax+320], 3
  0005c	0f 8d c1 01 00
	00		 jge	 $LN18@Unpickler_@12
  00062	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006a	83 b8 44 01 00
	00 00		 cmp	 DWORD PTR [rax+324], 0
  00071	0f 84 ac 01 00
	00		 je	 $LN18@Unpickler_@12

; 5509 :         PyObject *key;
; 5510 :         PyObject *item;
; 5511 : 
; 5512 :         /* Check if the global (i.e., a function or a class) was renamed
; 5513 :            or moved to another module. */
; 5514 :         key = PyTuple_Pack(2, module_name, global_name);

  00077	4c 8b 44 24 48	 mov	 r8, QWORD PTR global_name$[rsp]
  0007c	48 8b 54 24 38	 mov	 rdx, QWORD PTR module_name$[rsp]
  00081	b9 02 00 00 00	 mov	 ecx, 2
  00086	e8 00 00 00 00	 call	 PyTuple_Pack
  0008b	48 89 44 24 58	 mov	 QWORD PTR key$24505[rsp], rax

; 5515 :         if (key == NULL)

  00090	48 83 7c 24 58
	00		 cmp	 QWORD PTR key$24505[rsp], 0
  00096	75 07		 jne	 SHORT $LN17@Unpickler_@12

; 5516 :             return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	e9 1f 02 00 00	 jmp	 $LN20@Unpickler_@12
$LN17@Unpickler_@12:

; 5517 :         item = PyDict_GetItemWithError(name_mapping_2to3, key);

  0009f	48 8b 54 24 58	 mov	 rdx, QWORD PTR key$24505[rsp]
  000a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR name_mapping_2to3
  000ab	e8 00 00 00 00	 call	 PyDict_GetItemWithError
  000b0	48 89 44 24 60	 mov	 QWORD PTR item$24506[rsp], rax

; 5518 :         Py_DECREF(key);

  000b5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$24505[rsp]
  000ba	e8 00 00 00 00	 call	 _Py_DecRef

; 5519 :         if (item) {

  000bf	48 83 7c 24 60
	00		 cmp	 QWORD PTR item$24506[rsp], 0
  000c5	0f 84 cd 00 00
	00		 je	 $LN16@Unpickler_@12

; 5520 :             if (!PyTuple_Check(item) || PyTuple_GET_SIZE(item) != 2) {

  000cb	48 8b 44 24 60	 mov	 rax, QWORD PTR item$24506[rsp]
  000d0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000da	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  000df	85 c0		 test	 eax, eax
  000e1	74 0c		 je	 SHORT $LN14@Unpickler_@12
  000e3	48 8b 44 24 60	 mov	 rax, QWORD PTR item$24506[rsp]
  000e8	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  000ed	74 27		 je	 SHORT $LN15@Unpickler_@12
$LN14@Unpickler_@12:

; 5521 :                 PyErr_Format(PyExc_RuntimeError,
; 5522 :                              "_compat_pickle.NAME_MAPPING values should be "
; 5523 :                              "2-tuples, not %.200s", Py_TYPE(item)->tp_name);

  000ef	48 8b 44 24 60	 mov	 rax, QWORD PTR item$24506[rsp]
  000f4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f8	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@MMPLOPKK@_compat_pickle?4NAME_MAPPING?5valu@
  00103	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0010a	e8 00 00 00 00	 call	 PyErr_Format

; 5524 :                 return NULL;

  0010f	33 c0		 xor	 eax, eax
  00111	e9 a8 01 00 00	 jmp	 $LN20@Unpickler_@12
$LN15@Unpickler_@12:

; 5525 :             }
; 5526 :             module_name = PyTuple_GET_ITEM(item, 0);

  00116	48 8b 44 24 60	 mov	 rax, QWORD PTR item$24506[rsp]
  0011b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0011f	48 89 44 24 38	 mov	 QWORD PTR module_name$[rsp], rax

; 5527 :             global_name = PyTuple_GET_ITEM(item, 1);

  00124	48 8b 44 24 60	 mov	 rax, QWORD PTR item$24506[rsp]
  00129	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0012d	48 89 44 24 48	 mov	 QWORD PTR global_name$[rsp], rax

; 5528 :             if (!PyUnicode_Check(module_name) ||
; 5529 :                 !PyUnicode_Check(global_name)) {

  00132	48 8b 44 24 38	 mov	 rax, QWORD PTR module_name$[rsp]
  00137	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0013b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00141	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00146	85 c0		 test	 eax, eax
  00148	74 18		 je	 SHORT $LN12@Unpickler_@12
  0014a	48 8b 44 24 48	 mov	 rax, QWORD PTR global_name$[rsp]
  0014f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00153	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00159	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0015e	85 c0		 test	 eax, eax
  00160	75 34		 jne	 SHORT $LN13@Unpickler_@12
$LN12@Unpickler_@12:

; 5530 :                 PyErr_Format(PyExc_RuntimeError,
; 5531 :                              "_compat_pickle.NAME_MAPPING values should be "
; 5532 :                              "pairs of str, not (%.200s, %.200s)",
; 5533 :                              Py_TYPE(module_name)->tp_name,
; 5534 :                              Py_TYPE(global_name)->tp_name);

  00162	48 8b 44 24 48	 mov	 rax, QWORD PTR global_name$[rsp]
  00167	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0016b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR module_name$[rsp]
  00170	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00174	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00178	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FA@NKGOBDJL@_compat_pickle?4NAME_MAPPING?5valu@
  00183	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0018a	e8 00 00 00 00	 call	 PyErr_Format

; 5535 :                 return NULL;

  0018f	33 c0		 xor	 eax, eax
  00191	e9 28 01 00 00	 jmp	 $LN20@Unpickler_@12
$LN13@Unpickler_@12:

; 5536 :             }

  00196	eb 11		 jmp	 SHORT $LN11@Unpickler_@12
$LN16@Unpickler_@12:

; 5537 :         }
; 5538 :         else if (PyErr_Occurred()) {

  00198	e8 00 00 00 00	 call	 PyErr_Occurred
  0019d	48 85 c0	 test	 rax, rax
  001a0	74 07		 je	 SHORT $LN10@Unpickler_@12

; 5539 :             return NULL;

  001a2	33 c0		 xor	 eax, eax
  001a4	e9 15 01 00 00	 jmp	 $LN20@Unpickler_@12
$LN10@Unpickler_@12:
$LN11@Unpickler_@12:

; 5540 :         }
; 5541 : 
; 5542 :         /* Check if the module was renamed. */
; 5543 :         item = PyDict_GetItemWithError(import_mapping_2to3, module_name);

  001a9	48 8b 54 24 38	 mov	 rdx, QWORD PTR module_name$[rsp]
  001ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR import_mapping_2to3
  001b5	e8 00 00 00 00	 call	 PyDict_GetItemWithError
  001ba	48 89 44 24 60	 mov	 QWORD PTR item$24506[rsp], rax

; 5544 :         if (item) {

  001bf	48 83 7c 24 60
	00		 cmp	 QWORD PTR item$24506[rsp], 0
  001c5	74 4b		 je	 SHORT $LN9@Unpickler_@12

; 5545 :             if (!PyUnicode_Check(item)) {

  001c7	48 8b 44 24 60	 mov	 rax, QWORD PTR item$24506[rsp]
  001cc	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001d0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001d6	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  001db	85 c0		 test	 eax, eax
  001dd	75 27		 jne	 SHORT $LN8@Unpickler_@12

; 5546 :                 PyErr_Format(PyExc_RuntimeError,
; 5547 :                              "_compat_pickle.IMPORT_MAPPING values should be "
; 5548 :                              "strings, not %.200s", Py_TYPE(item)->tp_name);

  001df	48 8b 44 24 60	 mov	 rax, QWORD PTR item$24506[rsp]
  001e4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001e8	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  001ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@DGNEEHFG@_compat_pickle?4IMPORT_MAPPING?5va@
  001f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  001fa	e8 00 00 00 00	 call	 PyErr_Format

; 5549 :                 return NULL;

  001ff	33 c0		 xor	 eax, eax
  00201	e9 b8 00 00 00	 jmp	 $LN20@Unpickler_@12
$LN8@Unpickler_@12:

; 5550 :             }
; 5551 :             module_name = item;

  00206	48 8b 44 24 60	 mov	 rax, QWORD PTR item$24506[rsp]
  0020b	48 89 44 24 38	 mov	 QWORD PTR module_name$[rsp], rax
  00210	eb 11		 jmp	 SHORT $LN7@Unpickler_@12
$LN9@Unpickler_@12:

; 5552 :         }
; 5553 :         else if (PyErr_Occurred()) {

  00212	e8 00 00 00 00	 call	 PyErr_Occurred
  00217	48 85 c0	 test	 rax, rax
  0021a	74 07		 je	 SHORT $LN6@Unpickler_@12

; 5554 :             return NULL;

  0021c	33 c0		 xor	 eax, eax
  0021e	e9 9b 00 00 00	 jmp	 $LN20@Unpickler_@12
$LN6@Unpickler_@12:
$LN7@Unpickler_@12:
$LN18@Unpickler_@12:

; 5555 :         }
; 5556 :     }
; 5557 : 
; 5558 :     modules_dict = PySys_GetObject("modules");

  00223	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DFGEOAEG@modules?$AA@
  0022a	e8 00 00 00 00	 call	 PySys_GetObject
  0022f	48 89 44 24 40	 mov	 QWORD PTR modules_dict$[rsp], rax

; 5559 :     if (modules_dict == NULL)

  00234	48 83 7c 24 40
	00		 cmp	 QWORD PTR modules_dict$[rsp], 0
  0023a	75 04		 jne	 SHORT $LN5@Unpickler_@12

; 5560 :         return NULL;

  0023c	33 c0		 xor	 eax, eax
  0023e	eb 7e		 jmp	 SHORT $LN20@Unpickler_@12
$LN5@Unpickler_@12:

; 5561 : 
; 5562 :     module = PyDict_GetItemWithError(modules_dict, module_name);

  00240	48 8b 54 24 38	 mov	 rdx, QWORD PTR module_name$[rsp]
  00245	48 8b 4c 24 40	 mov	 rcx, QWORD PTR modules_dict$[rsp]
  0024a	e8 00 00 00 00	 call	 PyDict_GetItemWithError
  0024f	48 89 44 24 30	 mov	 QWORD PTR module$[rsp], rax

; 5563 :     if (module == NULL) {

  00254	48 83 7c 24 30
	00		 cmp	 QWORD PTR module$[rsp], 0
  0025a	75 49		 jne	 SHORT $LN4@Unpickler_@12

; 5564 :         if (PyErr_Occurred())

  0025c	e8 00 00 00 00	 call	 PyErr_Occurred
  00261	48 85 c0	 test	 rax, rax
  00264	74 04		 je	 SHORT $LN3@Unpickler_@12

; 5565 :             return NULL;

  00266	33 c0		 xor	 eax, eax
  00268	eb 54		 jmp	 SHORT $LN20@Unpickler_@12
$LN3@Unpickler_@12:

; 5566 :         module = PyImport_Import(module_name);

  0026a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR module_name$[rsp]
  0026f	e8 00 00 00 00	 call	 PyImport_Import
  00274	48 89 44 24 30	 mov	 QWORD PTR module$[rsp], rax

; 5567 :         if (module == NULL)

  00279	48 83 7c 24 30
	00		 cmp	 QWORD PTR module$[rsp], 0
  0027f	75 04		 jne	 SHORT $LN2@Unpickler_@12

; 5568 :             return NULL;

  00281	33 c0		 xor	 eax, eax
  00283	eb 39		 jmp	 SHORT $LN20@Unpickler_@12
$LN2@Unpickler_@12:

; 5569 :         global = PyObject_GetAttr(module, global_name);

  00285	48 8b 54 24 48	 mov	 rdx, QWORD PTR global_name$[rsp]
  0028a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module$[rsp]
  0028f	e8 00 00 00 00	 call	 PyObject_GetAttr
  00294	48 89 44 24 50	 mov	 QWORD PTR global$[rsp], rax

; 5570 :         Py_DECREF(module);

  00299	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module$[rsp]
  0029e	e8 00 00 00 00	 call	 _Py_DecRef

; 5571 :     }
; 5572 :     else {

  002a3	eb 14		 jmp	 SHORT $LN1@Unpickler_@12
$LN4@Unpickler_@12:

; 5573 :         global = PyObject_GetAttr(module, global_name);

  002a5	48 8b 54 24 48	 mov	 rdx, QWORD PTR global_name$[rsp]
  002aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module$[rsp]
  002af	e8 00 00 00 00	 call	 PyObject_GetAttr
  002b4	48 89 44 24 50	 mov	 QWORD PTR global$[rsp], rax
$LN1@Unpickler_@12:

; 5574 :     }
; 5575 :     return global;

  002b9	48 8b 44 24 50	 mov	 rax, QWORD PTR global$[rsp]
$LN20@Unpickler_@12:

; 5576 : }

  002be	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002c2	c3		 ret	 0
Unpickler_find_class ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_dealloc DD imagerel Unpickler_dealloc
	DD	imagerel Unpickler_dealloc+390
	DD	imagerel $unwind$Unpickler_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Unpickler_dealloc
_TEXT	SEGMENT
self$ = 48
Unpickler_dealloc PROC					; COMDAT

; 5588 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5589 :     PyObject_GC_UnTrack((PyObject *)self);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN25@Unpickler_@13:

; 5590 :     Py_XDECREF(self->readline);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00020	74 11		 je	 SHORT $LN22@Unpickler_@13
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 88 08 01
	00 00		 mov	 rcx, QWORD PTR [rax+264]
  0002e	e8 00 00 00 00	 call	 _Py_DecRef
$LN22@Unpickler_@13:
  00033	33 c0		 xor	 eax, eax
  00035	85 c0		 test	 eax, eax
  00037	75 da		 jne	 SHORT $LN25@Unpickler_@13
$LN21@Unpickler_@13:

; 5591 :     Py_XDECREF(self->read);

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003e	48 83 b8 00 01
	00 00 00	 cmp	 QWORD PTR [rax+256], 0
  00046	74 11		 je	 SHORT $LN18@Unpickler_@13
  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004d	48 8b 88 00 01
	00 00		 mov	 rcx, QWORD PTR [rax+256]
  00054	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@Unpickler_@13:
  00059	33 c0		 xor	 eax, eax
  0005b	85 c0		 test	 eax, eax
  0005d	75 da		 jne	 SHORT $LN21@Unpickler_@13
$LN17@Unpickler_@13:

; 5592 :     Py_XDECREF(self->peek);

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00064	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  0006c	74 11		 je	 SHORT $LN14@Unpickler_@13
  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00073	48 8b 88 10 01
	00 00		 mov	 rcx, QWORD PTR [rax+272]
  0007a	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@Unpickler_@13:
  0007f	33 c0		 xor	 eax, eax
  00081	85 c0		 test	 eax, eax
  00083	75 da		 jne	 SHORT $LN17@Unpickler_@13
$LN13@Unpickler_@13:

; 5593 :     Py_XDECREF(self->stack);

  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0008a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0008f	74 0e		 je	 SHORT $LN10@Unpickler_@13
  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00096	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0009a	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@Unpickler_@13:
  0009f	33 c0		 xor	 eax, eax
  000a1	85 c0		 test	 eax, eax
  000a3	75 e0		 jne	 SHORT $LN13@Unpickler_@13
$LN9@Unpickler_@13:

; 5594 :     Py_XDECREF(self->pers_func);

  000a5	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000aa	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000b2	74 11		 je	 SHORT $LN6@Unpickler_@13
  000b4	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000b9	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000c0	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@Unpickler_@13:
  000c5	33 c0		 xor	 eax, eax
  000c7	85 c0		 test	 eax, eax
  000c9	75 da		 jne	 SHORT $LN9@Unpickler_@13
$LN5@Unpickler_@13:

; 5595 :     Py_XDECREF(self->arg);

  000cb	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000d0	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  000d5	74 0e		 je	 SHORT $LN2@Unpickler_@13
  000d7	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000dc	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  000e0	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@Unpickler_@13:
  000e5	33 c0		 xor	 eax, eax
  000e7	85 c0		 test	 eax, eax
  000e9	75 e0		 jne	 SHORT $LN5@Unpickler_@13

; 5596 :     if (self->buffer.buf != NULL) {

  000eb	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000f0	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  000f8	74 23		 je	 SHORT $LN1@Unpickler_@13

; 5597 :         PyBuffer_Release(&self->buffer);

  000fa	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000ff	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00105	48 8b c8	 mov	 rcx, rax
  00108	e8 00 00 00 00	 call	 PyBuffer_Release

; 5598 :         self->buffer.buf = NULL;

  0010d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00112	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0
$LN1@Unpickler_@13:

; 5599 :     }
; 5600 : 
; 5601 :     _Unpickler_MemoCleanup(self);

  0011d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00122	e8 00 00 00 00	 call	 _Unpickler_MemoCleanup

; 5602 :     PyMem_Free(self->marks);

  00127	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0012c	48 8b 88 28 01
	00 00		 mov	 rcx, QWORD PTR [rax+296]
  00133	e8 00 00 00 00	 call	 PyMem_Free

; 5603 :     PyMem_Free(self->input_line);

  00138	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0013d	48 8b 88 e0 00
	00 00		 mov	 rcx, QWORD PTR [rax+224]
  00144	e8 00 00 00 00	 call	 PyMem_Free

; 5604 :     free(self->encoding);

  00149	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0014e	48 8b 88 18 01
	00 00		 mov	 rcx, QWORD PTR [rax+280]
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5605 :     free(self->errors);

  0015b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00160	48 8b 88 20 01
	00 00		 mov	 rcx, QWORD PTR [rax+288]
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5606 : 
; 5607 :     Py_TYPE(self)->tp_free((PyObject *)self);

  0016d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00172	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00176	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0017b	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 5608 : }

  00181	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00185	c3		 ret	 0
Unpickler_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_MemoCleanup DD imagerel _Unpickler_MemoCleanup
	DD	imagerel _Unpickler_MemoCleanup+184
	DD	imagerel $unwind$_Unpickler_MemoCleanup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_MemoCleanup DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Unpickler_MemoCleanup
_TEXT	SEGMENT
i$ = 32
memo$ = 40
tv82 = 48
self$ = 80
_Unpickler_MemoCleanup PROC				; COMDAT

; 1116 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1117 :     Py_ssize_t i;
; 1118 :     PyObject **memo = self->memo;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00012	48 89 44 24 28	 mov	 QWORD PTR memo$[rsp], rax

; 1119 : 
; 1120 :     if (self->memo == NULL)

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001c	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00021	75 05		 jne	 SHORT $LN7@Unpickler_@14

; 1121 :         return;

  00023	e9 8b 00 00 00	 jmp	 $LN8@Unpickler_@14
$LN7@Unpickler_@14:

; 1122 :     self->memo = NULL;

  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0002d	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 1123 :     i = self->memo_size;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0003a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0003e	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@Unpickler_@14:

; 1124 :     while (--i >= 0) {

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00048	48 ff c8	 dec	 rax
  0004b	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00050	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  00056	7c 2c		 jl	 SHORT $LN5@Unpickler_@14
$LN4@Unpickler_@14:

; 1125 :         Py_XDECREF(memo[i]);

  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR memo$[rsp]
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00062	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00067	74 13		 je	 SHORT $LN1@Unpickler_@14
  00069	48 8b 44 24 28	 mov	 rax, QWORD PTR memo$[rsp]
  0006e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00073	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00077	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Unpickler_@14:
  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 d6		 jne	 SHORT $LN4@Unpickler_@14

; 1126 :     }

  00082	eb bf		 jmp	 SHORT $LN6@Unpickler_@14
$LN5@Unpickler_@14:

; 1127 :     PyMem_FREE(memo);

  00084	e8 00 00 00 00	 call	 _Py_PXCTX
  00089	85 c0		 test	 eax, eax
  0008b	74 14		 je	 SHORT $LN10@Unpickler_@14
  0008d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR memo$[rsp]
  00092	e8 00 00 00 00	 call	 _PxMem_Free
  00097	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
  0009f	eb 12		 jmp	 SHORT $LN11@Unpickler_@14
$LN10@Unpickler_@14:
  000a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR memo$[rsp]
  000a6	e8 00 00 00 00	 call	 _PyMem_DebugFree
  000ab	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN11@Unpickler_@14:
$LN8@Unpickler_@14:

; 1128 : }

  000b3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b7	c3		 ret	 0
_Unpickler_MemoCleanup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_traverse DD imagerel Unpickler_traverse
	DD	imagerel Unpickler_traverse+602
	DD	imagerel $unwind$Unpickler_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_traverse DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
CONST	SEGMENT
??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@ DB 'Unpickler_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Unpickler_traverse
_TEXT	SEGMENT
vret$24613 = 32
vret$24621 = 36
vret$24629 = 40
vret$24637 = 44
vret$24645 = 48
vret$24653 = 52
self$ = 80
visit$ = 88
arg$ = 96
Unpickler_traverse PROC					; COMDAT

; 5612 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN36@Unpickler_@15:

; 5613 :     Py_VISIT(self->readline);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN33@Unpickler_@15
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 ed 15 00
	00		 mov	 r8d, 5613		; 000015edH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN33@Unpickler_@15:
  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00045	74 29		 je	 SHORT $LN32@Unpickler_@15
  00047	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  0004c	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00051	48 8b 88 08 01
	00 00		 mov	 rcx, QWORD PTR [rax+264]
  00058	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  0005c	89 44 24 20	 mov	 DWORD PTR vret$24613[rsp], eax
  00060	83 7c 24 20 00	 cmp	 DWORD PTR vret$24613[rsp], 0
  00065	74 09		 je	 SHORT $LN31@Unpickler_@15
  00067	8b 44 24 20	 mov	 eax, DWORD PTR vret$24613[rsp]
  0006b	e9 e5 01 00 00	 jmp	 $LN37@Unpickler_@15
$LN31@Unpickler_@15:
$LN32@Unpickler_@15:
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 9d		 jne	 SHORT $LN36@Unpickler_@15
$LN30@Unpickler_@15:

; 5614 :     Py_VISIT(self->read);

  00076	e8 00 00 00 00	 call	 _Py_PXCTX
  0007b	85 c0		 test	 eax, eax
  0007d	74 1c		 je	 SHORT $LN27@Unpickler_@15
  0007f	45 33 c9	 xor	 r9d, r9d
  00082	41 b8 ee 15 00
	00		 mov	 r8d, 5614		; 000015eeH
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  00096	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN27@Unpickler_@15:
  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000a0	48 83 b8 00 01
	00 00 00	 cmp	 QWORD PTR [rax+256], 0
  000a8	74 29		 je	 SHORT $LN26@Unpickler_@15
  000aa	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  000af	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000b4	48 8b 88 00 01
	00 00		 mov	 rcx, QWORD PTR [rax+256]
  000bb	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  000bf	89 44 24 24	 mov	 DWORD PTR vret$24621[rsp], eax
  000c3	83 7c 24 24 00	 cmp	 DWORD PTR vret$24621[rsp], 0
  000c8	74 09		 je	 SHORT $LN25@Unpickler_@15
  000ca	8b 44 24 24	 mov	 eax, DWORD PTR vret$24621[rsp]
  000ce	e9 82 01 00 00	 jmp	 $LN37@Unpickler_@15
$LN25@Unpickler_@15:
$LN26@Unpickler_@15:
  000d3	33 c0		 xor	 eax, eax
  000d5	85 c0		 test	 eax, eax
  000d7	75 9d		 jne	 SHORT $LN30@Unpickler_@15
$LN24@Unpickler_@15:

; 5615 :     Py_VISIT(self->peek);

  000d9	e8 00 00 00 00	 call	 _Py_PXCTX
  000de	85 c0		 test	 eax, eax
  000e0	74 1c		 je	 SHORT $LN21@Unpickler_@15
  000e2	45 33 c9	 xor	 r9d, r9d
  000e5	41 b8 ef 15 00
	00		 mov	 r8d, 5615		; 000015efH
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  000f9	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN21@Unpickler_@15:
  000fe	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00103	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  0010b	74 29		 je	 SHORT $LN20@Unpickler_@15
  0010d	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  00112	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00117	48 8b 88 10 01
	00 00		 mov	 rcx, QWORD PTR [rax+272]
  0011e	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  00122	89 44 24 28	 mov	 DWORD PTR vret$24629[rsp], eax
  00126	83 7c 24 28 00	 cmp	 DWORD PTR vret$24629[rsp], 0
  0012b	74 09		 je	 SHORT $LN19@Unpickler_@15
  0012d	8b 44 24 28	 mov	 eax, DWORD PTR vret$24629[rsp]
  00131	e9 1f 01 00 00	 jmp	 $LN37@Unpickler_@15
$LN19@Unpickler_@15:
$LN20@Unpickler_@15:
  00136	33 c0		 xor	 eax, eax
  00138	85 c0		 test	 eax, eax
  0013a	75 9d		 jne	 SHORT $LN24@Unpickler_@15
$LN18@Unpickler_@15:

; 5616 :     Py_VISIT(self->stack);

  0013c	e8 00 00 00 00	 call	 _Py_PXCTX
  00141	85 c0		 test	 eax, eax
  00143	74 1c		 je	 SHORT $LN15@Unpickler_@15
  00145	45 33 c9	 xor	 r9d, r9d
  00148	41 b8 f0 15 00
	00		 mov	 r8d, 5616		; 000015f0H
  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  0015c	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@Unpickler_@15:
  00161	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00166	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0016b	74 26		 je	 SHORT $LN14@Unpickler_@15
  0016d	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  00172	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00177	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0017b	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  0017f	89 44 24 2c	 mov	 DWORD PTR vret$24637[rsp], eax
  00183	83 7c 24 2c 00	 cmp	 DWORD PTR vret$24637[rsp], 0
  00188	74 09		 je	 SHORT $LN13@Unpickler_@15
  0018a	8b 44 24 2c	 mov	 eax, DWORD PTR vret$24637[rsp]
  0018e	e9 c2 00 00 00	 jmp	 $LN37@Unpickler_@15
$LN13@Unpickler_@15:
$LN14@Unpickler_@15:
  00193	33 c0		 xor	 eax, eax
  00195	85 c0		 test	 eax, eax
  00197	75 a3		 jne	 SHORT $LN18@Unpickler_@15
$LN12@Unpickler_@15:

; 5617 :     Py_VISIT(self->pers_func);

  00199	e8 00 00 00 00	 call	 _Py_PXCTX
  0019e	85 c0		 test	 eax, eax
  001a0	74 1c		 je	 SHORT $LN9@Unpickler_@15
  001a2	45 33 c9	 xor	 r9d, r9d
  001a5	41 b8 f1 15 00
	00		 mov	 r8d, 5617		; 000015f1H
  001ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  001b9	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@Unpickler_@15:
  001be	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001c3	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  001cb	74 26		 je	 SHORT $LN8@Unpickler_@15
  001cd	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  001d2	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001d7	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  001de	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  001e2	89 44 24 30	 mov	 DWORD PTR vret$24645[rsp], eax
  001e6	83 7c 24 30 00	 cmp	 DWORD PTR vret$24645[rsp], 0
  001eb	74 06		 je	 SHORT $LN7@Unpickler_@15
  001ed	8b 44 24 30	 mov	 eax, DWORD PTR vret$24645[rsp]
  001f1	eb 62		 jmp	 SHORT $LN37@Unpickler_@15
$LN7@Unpickler_@15:
$LN8@Unpickler_@15:
  001f3	33 c0		 xor	 eax, eax
  001f5	85 c0		 test	 eax, eax
  001f7	75 a0		 jne	 SHORT $LN12@Unpickler_@15
$LN6@Unpickler_@15:

; 5618 :     Py_VISIT(self->arg);

  001f9	e8 00 00 00 00	 call	 _Py_PXCTX
  001fe	85 c0		 test	 eax, eax
  00200	74 1c		 je	 SHORT $LN3@Unpickler_@15
  00202	45 33 c9	 xor	 r9d, r9d
  00205	41 b8 f2 15 00
	00		 mov	 r8d, 5618		; 000015f2H
  0020b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  00219	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@Unpickler_@15:
  0021e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00223	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00228	74 23		 je	 SHORT $LN2@Unpickler_@15
  0022a	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  0022f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00234	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00238	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  0023c	89 44 24 34	 mov	 DWORD PTR vret$24653[rsp], eax
  00240	83 7c 24 34 00	 cmp	 DWORD PTR vret$24653[rsp], 0
  00245	74 06		 je	 SHORT $LN1@Unpickler_@15
  00247	8b 44 24 34	 mov	 eax, DWORD PTR vret$24653[rsp]
  0024b	eb 08		 jmp	 SHORT $LN37@Unpickler_@15
$LN1@Unpickler_@15:
$LN2@Unpickler_@15:
  0024d	33 c0		 xor	 eax, eax
  0024f	85 c0		 test	 eax, eax
  00251	75 a6		 jne	 SHORT $LN6@Unpickler_@15

; 5619 :     return 0;

  00253	33 c0		 xor	 eax, eax
$LN37@Unpickler_@15:

; 5620 : }

  00255	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00259	c3		 ret	 0
Unpickler_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_clear DD imagerel Unpickler_clear
	DD	imagerel Unpickler_clear+864
	DD	imagerel $unwind$Unpickler_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_clear DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
CONST	SEGMENT
??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@ DB 'Unpickler_clear', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Unpickler_clear
_TEXT	SEGMENT
_py_tmp$24665 = 48
_py_tmp$24673 = 56
_py_tmp$24681 = 64
_py_tmp$24689 = 72
_py_tmp$24697 = 80
_py_tmp$24705 = 88
self$ = 112
Unpickler_clear PROC					; COMDAT

; 5624 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN25@Unpickler_@16:

; 5625 :     Py_CLEAR(self->readline);

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00016	74 5c		 je	 SHORT $LN22@Unpickler_@16
  00018	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00020	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00025	4c 8b 88 08 01
	00 00		 mov	 r9, QWORD PTR [rax+264]
  0002c	41 b8 f9 15 00
	00		 mov	 r8d, 5625		; 000015f9H
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  00040	e8 00 00 00 00	 call	 _PyParallel_Guard
  00045	85 c0		 test	 eax, eax
  00047	75 2b		 jne	 SHORT $LN22@Unpickler_@16
  00049	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 80 08 01
	00 00		 mov	 rax, QWORD PTR [rax+264]
  00055	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$24665[rsp], rax
  0005a	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0005f	48 c7 80 08 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+264], 0
  0006a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$24665[rsp]
  0006f	e8 00 00 00 00	 call	 _Py_DecRef
$LN22@Unpickler_@16:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 8f		 jne	 SHORT $LN25@Unpickler_@16
$LN21@Unpickler_@16:

; 5626 :     Py_CLEAR(self->read);

  0007a	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0007f	48 83 b8 00 01
	00 00 00	 cmp	 QWORD PTR [rax+256], 0
  00087	74 5c		 je	 SHORT $LN18@Unpickler_@16
  00089	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00091	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00096	4c 8b 88 00 01
	00 00		 mov	 r9, QWORD PTR [rax+256]
  0009d	41 b8 fa 15 00
	00		 mov	 r8d, 5626		; 000015faH
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  000b1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b6	85 c0		 test	 eax, eax
  000b8	75 2b		 jne	 SHORT $LN18@Unpickler_@16
  000ba	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000bf	48 8b 80 00 01
	00 00		 mov	 rax, QWORD PTR [rax+256]
  000c6	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$24673[rsp], rax
  000cb	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000d0	48 c7 80 00 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+256], 0
  000db	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$24673[rsp]
  000e0	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@Unpickler_@16:
  000e5	33 c0		 xor	 eax, eax
  000e7	85 c0		 test	 eax, eax
  000e9	75 8f		 jne	 SHORT $LN21@Unpickler_@16
$LN17@Unpickler_@16:

; 5627 :     Py_CLEAR(self->peek);

  000eb	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000f0	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  000f8	74 5c		 je	 SHORT $LN14@Unpickler_@16
  000fa	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00102	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00107	4c 8b 88 10 01
	00 00		 mov	 r9, QWORD PTR [rax+272]
  0010e	41 b8 fb 15 00
	00		 mov	 r8d, 5627		; 000015fbH
  00114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  00122	e8 00 00 00 00	 call	 _PyParallel_Guard
  00127	85 c0		 test	 eax, eax
  00129	75 2b		 jne	 SHORT $LN14@Unpickler_@16
  0012b	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00130	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  00137	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$24681[rsp], rax
  0013c	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00141	48 c7 80 10 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+272], 0
  0014c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$24681[rsp]
  00151	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@Unpickler_@16:
  00156	33 c0		 xor	 eax, eax
  00158	85 c0		 test	 eax, eax
  0015a	75 8f		 jne	 SHORT $LN17@Unpickler_@16
$LN13@Unpickler_@16:

; 5628 :     Py_CLEAR(self->stack);

  0015c	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00161	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00166	74 53		 je	 SHORT $LN10@Unpickler_@16
  00168	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00170	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00175	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  00179	41 b8 fc 15 00
	00		 mov	 r8d, 5628		; 000015fcH
  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  0018d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00192	85 c0		 test	 eax, eax
  00194	75 25		 jne	 SHORT $LN10@Unpickler_@16
  00196	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0019b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0019f	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$24689[rsp], rax
  001a4	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001a9	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  001b1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$24689[rsp]
  001b6	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@Unpickler_@16:
  001bb	33 c0		 xor	 eax, eax
  001bd	85 c0		 test	 eax, eax
  001bf	75 9b		 jne	 SHORT $LN13@Unpickler_@16
$LN9@Unpickler_@16:

; 5629 :     Py_CLEAR(self->pers_func);

  001c1	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001c6	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  001ce	74 5c		 je	 SHORT $LN6@Unpickler_@16
  001d0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d8	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001dd	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  001e4	41 b8 fd 15 00
	00		 mov	 r8d, 5629		; 000015fdH
  001ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  001f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  001f8	e8 00 00 00 00	 call	 _PyParallel_Guard
  001fd	85 c0		 test	 eax, eax
  001ff	75 2b		 jne	 SHORT $LN6@Unpickler_@16
  00201	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00206	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0020d	48 89 44 24 50	 mov	 QWORD PTR _py_tmp$24697[rsp], rax
  00212	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00217	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
  00222	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _py_tmp$24697[rsp]
  00227	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@Unpickler_@16:
  0022c	33 c0		 xor	 eax, eax
  0022e	85 c0		 test	 eax, eax
  00230	75 8f		 jne	 SHORT $LN9@Unpickler_@16
$LN5@Unpickler_@16:

; 5630 :     Py_CLEAR(self->arg);

  00232	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00237	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0023c	74 53		 je	 SHORT $LN2@Unpickler_@16
  0023e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00246	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0024b	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  0024f	41 b8 fe 15 00
	00		 mov	 r8d, 5630		; 000015feH
  00255	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  00263	e8 00 00 00 00	 call	 _PyParallel_Guard
  00268	85 c0		 test	 eax, eax
  0026a	75 25		 jne	 SHORT $LN2@Unpickler_@16
  0026c	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00271	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00275	48 89 44 24 58	 mov	 QWORD PTR _py_tmp$24705[rsp], rax
  0027a	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0027f	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
  00287	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _py_tmp$24705[rsp]
  0028c	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@Unpickler_@16:
  00291	33 c0		 xor	 eax, eax
  00293	85 c0		 test	 eax, eax
  00295	75 9b		 jne	 SHORT $LN5@Unpickler_@16

; 5631 :     if (self->buffer.buf != NULL) {

  00297	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0029c	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  002a4	74 23		 je	 SHORT $LN1@Unpickler_@16

; 5632 :         PyBuffer_Release(&self->buffer);

  002a6	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  002ab	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  002b1	48 8b c8	 mov	 rcx, rax
  002b4	e8 00 00 00 00	 call	 PyBuffer_Release

; 5633 :         self->buffer.buf = NULL;

  002b9	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  002be	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0
$LN1@Unpickler_@16:

; 5634 :     }
; 5635 : 
; 5636 :     _Unpickler_MemoCleanup(self);

  002c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  002ce	e8 00 00 00 00	 call	 _Unpickler_MemoCleanup

; 5637 :     PyMem_Free(self->marks);

  002d3	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  002d8	48 8b 88 28 01
	00 00		 mov	 rcx, QWORD PTR [rax+296]
  002df	e8 00 00 00 00	 call	 PyMem_Free

; 5638 :     self->marks = NULL;

  002e4	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  002e9	48 c7 80 28 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+296], 0

; 5639 :     PyMem_Free(self->input_line);

  002f4	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  002f9	48 8b 88 e0 00
	00 00		 mov	 rcx, QWORD PTR [rax+224]
  00300	e8 00 00 00 00	 call	 PyMem_Free

; 5640 :     self->input_line = NULL;

  00305	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0030a	48 c7 80 e0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+224], 0

; 5641 :     free(self->encoding);

  00315	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0031a	48 8b 88 18 01
	00 00		 mov	 rcx, QWORD PTR [rax+280]
  00321	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5642 :     self->encoding = NULL;

  00327	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0032c	48 c7 80 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+280], 0

; 5643 :     free(self->errors);

  00337	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0033c	48 8b 88 20 01
	00 00		 mov	 rcx, QWORD PTR [rax+288]
  00343	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5644 :     self->errors = NULL;

  00349	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0034e	48 c7 80 20 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+288], 0

; 5645 : 
; 5646 :     return 0;

  00359	33 c0		 xor	 eax, eax

; 5647 : }

  0035b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0035f	c3		 ret	 0
Unpickler_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@ECPOKLMD@O?$HMOss?3Unpickler?$AA@	; `string'
PUBLIC	??_C@_0DF@EKMCJKEL@?$CFs?5takes?5exactly?5one?5positional?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_init DD imagerel Unpickler_init
	DD	imagerel Unpickler_init+591
	DD	imagerel $unwind$Unpickler_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_init DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0BA@ECPOKLMD@O?$HMOss?3Unpickler?$AA@
CONST	SEGMENT
??_C@_0BA@ECPOKLMD@O?$HMOss?3Unpickler?$AA@ DB 'O|Oss:Unpickler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EKMCJKEL@?$CFs?5takes?5exactly?5one?5positional?5@
CONST	SEGMENT
??_C@_0DF@EKMCJKEL@?$CFs?5takes?5exactly?5one?5positional?5@ DB '%s takes'
	DB	' exactly one positional argument (%zd given)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Unpickler_init
_TEXT	SEGMENT
fix_imports$ = 64
errors$ = 72
file$ = 80
encoding$ = 88
self$ = 112
args$ = 120
kwds$ = 128
Unpickler_init PROC					; COMDAT

; 5674 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 5675 :     static char *kwlist[] = {"file", "fix_imports", "encoding", "errors", 0};
; 5676 :     PyObject *file;
; 5677 :     PyObject *fix_imports = Py_True;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0001a	48 89 44 24 40	 mov	 QWORD PTR fix_imports$[rsp], rax

; 5678 :     char *encoding = NULL;

  0001f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR encoding$[rsp], 0

; 5679 :     char *errors = NULL;

  00028	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR errors$[rsp], 0

; 5680 :     _Py_IDENTIFIER(persistent_load);
; 5681 : 
; 5682 :     /* XXX: That is an horrible error message. But, I don't know how to do
; 5683 :        better... */
; 5684 :     if (Py_SIZE(args) != 1) {

  00031	48 8b 44 24 78	 mov	 rax, QWORD PTR args$[rsp]
  00036	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  0003b	74 33		 je	 SHORT $LN11@Unpickler_@17

; 5685 :         PyErr_Format(PyExc_TypeError,
; 5686 :                      "%s takes exactly one positional argument (%zd given)",
; 5687 :                      Py_TYPE(self)->tp_name, Py_SIZE(args));

  0003d	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00046	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  0004b	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  0004f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@EKMCJKEL@?$CFs?5takes?5exactly?5one?5positional?5@
  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00061	e8 00 00 00 00	 call	 PyErr_Format

; 5688 :         return -1;

  00066	b8 ff ff ff ff	 mov	 eax, -1
  0006b	e9 da 01 00 00	 jmp	 $LN12@Unpickler_@17
$LN11@Unpickler_@17:

; 5689 :     }
; 5690 : 
; 5691 :     /* Arguments parsing needs to be done in the __init__() method to allow
; 5692 :        subclasses to define their own __init__() method, which may (or may
; 5693 :        not) support Unpickler arguments. However, this means we need to be
; 5694 :        extra careful in the other Unpickler methods, since a subclass could
; 5695 :        forget to call Unpickler.__init__() thus breaking our internal
; 5696 :        invariants. */
; 5697 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|Oss:Unpickler", kwlist,
; 5698 :                                      &file, &fix_imports, &encoding, &errors))

  00070	48 8d 44 24 48	 lea	 rax, QWORD PTR errors$[rsp]
  00075	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0007a	48 8d 44 24 58	 lea	 rax, QWORD PTR encoding$[rsp]
  0007f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00084	48 8d 44 24 40	 lea	 rax, QWORD PTR fix_imports$[rsp]
  00089	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008e	48 8d 44 24 50	 lea	 rax, QWORD PTR file$[rsp]
  00093	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00098	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??Unpickler_init@@9@9
  0009f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@ECPOKLMD@O?$HMOss?3Unpickler?$AA@
  000a6	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  000ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  000b3	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000b8	85 c0		 test	 eax, eax
  000ba	75 0a		 jne	 SHORT $LN10@Unpickler_@17

; 5699 :         return -1;

  000bc	b8 ff ff ff ff	 mov	 eax, -1
  000c1	e9 84 01 00 00	 jmp	 $LN12@Unpickler_@17
$LN10@Unpickler_@17:

; 5700 : 
; 5701 :     /* In case of multiple __init__() calls, clear previous content. */
; 5702 :     if (self->read != NULL)

  000c6	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000cb	48 83 b8 00 01
	00 00 00	 cmp	 QWORD PTR [rax+256], 0
  000d3	74 0a		 je	 SHORT $LN9@Unpickler_@17

; 5703 :         (void)Unpickler_clear(self);

  000d5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000da	e8 00 00 00 00	 call	 Unpickler_clear
$LN9@Unpickler_@17:

; 5704 : 
; 5705 :     if (_Unpickler_SetInputStream(self, file) < 0)

  000df	48 8b 54 24 50	 mov	 rdx, QWORD PTR file$[rsp]
  000e4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000e9	e8 00 00 00 00	 call	 _Unpickler_SetInputStream
  000ee	85 c0		 test	 eax, eax
  000f0	7d 0a		 jge	 SHORT $LN8@Unpickler_@17

; 5706 :         return -1;

  000f2	b8 ff ff ff ff	 mov	 eax, -1
  000f7	e9 4e 01 00 00	 jmp	 $LN12@Unpickler_@17
$LN8@Unpickler_@17:

; 5707 : 
; 5708 :     if (_Unpickler_SetInputEncoding(self, encoding, errors) < 0)

  000fc	4c 8b 44 24 48	 mov	 r8, QWORD PTR errors$[rsp]
  00101	48 8b 54 24 58	 mov	 rdx, QWORD PTR encoding$[rsp]
  00106	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0010b	e8 00 00 00 00	 call	 _Unpickler_SetInputEncoding
  00110	85 c0		 test	 eax, eax
  00112	7d 0a		 jge	 SHORT $LN7@Unpickler_@17

; 5709 :         return -1;

  00114	b8 ff ff ff ff	 mov	 eax, -1
  00119	e9 2c 01 00 00	 jmp	 $LN12@Unpickler_@17
$LN7@Unpickler_@17:

; 5710 : 
; 5711 :     self->fix_imports = PyObject_IsTrue(fix_imports);

  0011e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fix_imports$[rsp]
  00123	e8 00 00 00 00	 call	 PyObject_IsTrue
  00128	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0012d	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax

; 5712 :     if (self->fix_imports == -1)

  00133	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00138	83 b8 44 01 00
	00 ff		 cmp	 DWORD PTR [rax+324], -1
  0013f	75 0a		 jne	 SHORT $LN6@Unpickler_@17

; 5713 :         return -1;

  00141	b8 ff ff ff ff	 mov	 eax, -1
  00146	e9 ff 00 00 00	 jmp	 $LN12@Unpickler_@17
$LN6@Unpickler_@17:

; 5714 : 
; 5715 :     if (_PyObject_HasAttrId((PyObject *)self, &PyId_persistent_load)) {

  0014b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_persistent_load@?1??Unpickler_init@@9@9
  00150	8b c0		 mov	 eax, eax
  00152	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00158	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00161	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00165	48 8b d0	 mov	 rdx, rax
  00168	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0016d	e8 00 00 00 00	 call	 _PyObject_HasAttrId
  00172	85 c0		 test	 eax, eax
  00174	74 4e		 je	 SHORT $LN5@Unpickler_@17

; 5716 :         self->pers_func = _PyObject_GetAttrId((PyObject *)self,
; 5717 :                                               &PyId_persistent_load);

  00176	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_persistent_load@?1??Unpickler_init@@9@9
  0017b	8b c0		 mov	 eax, eax
  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00183	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018c	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00190	48 8b d0	 mov	 rdx, rax
  00193	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00198	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0019d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001a2	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 5718 :         if (self->pers_func == NULL)

  001a9	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001ae	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  001b6	75 0a		 jne	 SHORT $LN4@Unpickler_@17

; 5719 :             return -1;

  001b8	b8 ff ff ff ff	 mov	 eax, -1
  001bd	e9 88 00 00 00	 jmp	 $LN12@Unpickler_@17
$LN4@Unpickler_@17:

; 5720 :     }
; 5721 :     else {

  001c2	eb 10		 jmp	 SHORT $LN3@Unpickler_@17
$LN5@Unpickler_@17:

; 5722 :         self->pers_func = NULL;

  001c4	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001c9	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
$LN3@Unpickler_@17:

; 5723 :     }
; 5724 : 
; 5725 :     self->stack = (Pdata *)Pdata_New();

  001d4	e8 00 00 00 00	 call	 Pdata_New
  001d9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001de	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 5726 :     if (self->stack == NULL)

  001e2	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001e7	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001ec	75 07		 jne	 SHORT $LN2@Unpickler_@17

; 5727 :         return -1;

  001ee	b8 ff ff ff ff	 mov	 eax, -1
  001f3	eb 55		 jmp	 SHORT $LN12@Unpickler_@17
$LN2@Unpickler_@17:

; 5728 : 
; 5729 :     self->memo_size = 32;

  001f5	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001fa	48 c7 40 70 20
	00 00 00	 mov	 QWORD PTR [rax+112], 32	; 00000020H

; 5730 :     self->memo = _Unpickler_NewMemo(self->memo_size);

  00202	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00207	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0020b	e8 00 00 00 00	 call	 _Unpickler_NewMemo
  00210	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00215	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 5731 :     if (self->memo == NULL)

  00219	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0021e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00223	75 07		 jne	 SHORT $LN1@Unpickler_@17

; 5732 :         return -1;

  00225	b8 ff ff ff ff	 mov	 eax, -1
  0022a	eb 1e		 jmp	 SHORT $LN12@Unpickler_@17
$LN1@Unpickler_@17:

; 5733 : 
; 5734 :     self->arg = NULL;

  0022c	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00231	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 5735 :     self->proto = 0;

  00239	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0023e	c7 80 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+320], 0

; 5736 : 
; 5737 :     return 0;

  00248	33 c0		 xor	 eax, eax
$LN12@Unpickler_@17:

; 5738 : }

  0024a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0024e	c3		 ret	 0
Unpickler_init ENDP
_TEXT	ENDS
EXTRN	_PyObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_New DD imagerel Pdata_New
	DD	imagerel Pdata_New+216
	DD	imagerel $unwind$Pdata_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_New DD 010401H
	DD	08204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Pdata_New
_TEXT	SEGMENT
self$ = 32
tv70 = 40
tv85 = 48
Pdata_New PROC						; COMDAT

; 174  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 175  :     Pdata *self;
; 176  : 
; 177  :     if (!(self = PyObject_New(Pdata, &Pdata_Type)))

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 13		 je	 SHORT $LN5@Pdata_New
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pdata_Type
  00014	e8 00 00 00 00	 call	 _PxObject_New
  00019	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  0001e	eb 11		 jmp	 SHORT $LN6@Pdata_New
$LN5@Pdata_New:
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pdata_Type
  00027	e8 00 00 00 00	 call	 _PyObject_New
  0002c	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN6@Pdata_New:
  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  00036	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax
  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00041	75 07		 jne	 SHORT $LN2@Pdata_New

; 178  :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 89 00 00 00	 jmp	 $LN3@Pdata_New
$LN2@Pdata_New:

; 179  :     Py_SIZE(self) = 0;

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0004f	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 180  :     self->allocated = 8;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0005c	48 c7 40 78 08
	00 00 00	 mov	 QWORD PTR [rax+120], 8

; 181  :     self->data = PyMem_MALLOC(self->allocated * sizeof(PyObject *));

  00064	e8 00 00 00 00	 call	 _Py_PXCTX
  00069	85 c0		 test	 eax, eax
  0006b	74 1c		 je	 SHORT $LN7@Pdata_New
  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00072	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00076	48 c1 e0 03	 shl	 rax, 3
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 _PxMem_Malloc
  00082	48 89 44 24 30	 mov	 QWORD PTR tv85[rsp], rax
  00087	eb 1a		 jmp	 SHORT $LN8@Pdata_New
$LN7@Pdata_New:
  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0008e	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00092	48 c1 e0 03	 shl	 rax, 3
  00096	48 8b c8	 mov	 rcx, rax
  00099	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0009e	48 89 44 24 30	 mov	 QWORD PTR tv85[rsp], rax
$LN8@Pdata_New:
  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv85[rsp]
  000ad	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 182  :     if (self->data)

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000b6	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  000bb	74 07		 je	 SHORT $LN1@Pdata_New

; 183  :         return (PyObject *)self;

  000bd	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000c2	eb 0f		 jmp	 SHORT $LN3@Pdata_New
$LN1@Pdata_New:

; 184  :     Py_DECREF(self);

  000c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  000c9	e8 00 00 00 00	 call	 _Py_DecRef

; 185  :     return PyErr_NoMemory();

  000ce	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN3@Pdata_New:

; 186  : }

  000d3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d7	c3		 ret	 0
Pdata_New ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_NewMemo DD imagerel _Unpickler_NewMemo
	DD	imagerel _Unpickler_NewMemo+120
	DD	imagerel $unwind$_Unpickler_NewMemo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_NewMemo DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Unpickler_NewMemo
_TEXT	SEGMENT
memo$ = 32
tv72 = 40
new_size$ = 64
_Unpickler_NewMemo PROC					; COMDAT

; 1105 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1106 :     PyObject **memo = PyMem_MALLOC(new_size * sizeof(PyObject *));

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 18		 je	 SHORT $LN4@Unpickler_@18
  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR new_size$[rsp]
  00017	48 c1 e0 03	 shl	 rax, 3
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	e8 00 00 00 00	 call	 _PxMem_Malloc
  00023	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
  00028	eb 16		 jmp	 SHORT $LN5@Unpickler_@18
$LN4@Unpickler_@18:
  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR new_size$[rsp]
  0002f	48 c1 e0 03	 shl	 rax, 3
  00033	48 8b c8	 mov	 rcx, rax
  00036	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0003b	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
$LN5@Unpickler_@18:
  00040	48 8b 44 24 28	 mov	 rax, QWORD PTR tv72[rsp]
  00045	48 89 44 24 20	 mov	 QWORD PTR memo$[rsp], rax

; 1107 :     if (memo == NULL)

  0004a	48 83 7c 24 20
	00		 cmp	 QWORD PTR memo$[rsp], 0
  00050	75 04		 jne	 SHORT $LN1@Unpickler_@18

; 1108 :         return NULL;

  00052	33 c0		 xor	 eax, eax
  00054	eb 1d		 jmp	 SHORT $LN2@Unpickler_@18
$LN1@Unpickler_@18:

; 1109 :     memset(memo, 0, new_size * sizeof(PyObject *));

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR new_size$[rsp]
  0005b	48 c1 e0 03	 shl	 rax, 3
  0005f	4c 8b c0	 mov	 r8, rax
  00062	33 d2		 xor	 edx, edx
  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR memo$[rsp]
  00069	e8 00 00 00 00	 call	 memset

; 1110 :     return memo;

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR memo$[rsp]
$LN2@Unpickler_@18:

; 1111 : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
_Unpickler_NewMemo ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@ ; `string'
PUBLIC	??_C@_0DA@COIFLMFN@file?5must?5have?5?8read?8?5and?5?8readl@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_SetInputStream DD imagerel _Unpickler_SetInputStream
	DD	imagerel _Unpickler_SetInputStream+637
	DD	imagerel $unwind$_Unpickler_SetInputStream
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_SetInputStream DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@
CONST	SEGMENT
??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@ DB '_Unpickler_SetInput'
	DB	'Stream', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@COIFLMFN@file?5must?5have?5?8read?8?5and?5?8readl@
CONST	SEGMENT
??_C@_0DA@COIFLMFN@file?5must?5have?5?8read?8?5and?5?8readl@ DB 'file mus'
	DB	't have ''read'' and ''readline'' attributes', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Unpickler_SetInputStream
_TEXT	SEGMENT
_py_tmp$21271 = 48
_py_tmp$21279 = 56
_py_tmp$21287 = 64
self$ = 96
file$ = 104
_Unpickler_SetInputStream PROC				; COMDAT

; 1178 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1179 :     _Py_IDENTIFIER(peek);
; 1180 :     _Py_IDENTIFIER(read);
; 1181 :     _Py_IDENTIFIER(readline);
; 1182 : 
; 1183 :     self->peek = _PyObject_GetAttrId(file, &PyId_peek);

  0000e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_peek@?1??_Unpickler_SetInputStream@@9@9
  00013	8b c0		 mov	 eax, eax
  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0001b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00024	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00028	48 8b d0	 mov	 rdx, rax
  0002b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00030	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00035	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0003a	48 89 81 10 01
	00 00		 mov	 QWORD PTR [rcx+272], rax

; 1184 :     if (self->peek == NULL) {

  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00046	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  0004e	75 21		 jne	 SHORT $LN18@Unpickler_@19

; 1185 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00057	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN17@Unpickler_@19

; 1186 :             PyErr_Clear();

  00060	e8 00 00 00 00	 call	 PyErr_Clear

; 1187 :         else

  00065	eb 0a		 jmp	 SHORT $LN16@Unpickler_@19
$LN17@Unpickler_@19:

; 1188 :             return -1;

  00067	b8 ff ff ff ff	 mov	 eax, -1
  0006c	e9 07 02 00 00	 jmp	 $LN19@Unpickler_@19
$LN16@Unpickler_@19:
$LN18@Unpickler_@19:

; 1189 :     }
; 1190 :     self->read = _PyObject_GetAttrId(file, &PyId_read);

  00071	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_read@?1??_Unpickler_SetInputStream@@9@9
  00076	8b c0		 mov	 eax, eax
  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0007e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00087	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0008b	48 8b d0	 mov	 rdx, rax
  0008e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00093	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00098	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0009d	48 89 81 00 01
	00 00		 mov	 QWORD PTR [rcx+256], rax

; 1191 :     self->readline = _PyObject_GetAttrId(file, &PyId_readline);

  000a4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_readline@?1??_Unpickler_SetInputStream@@9@9
  000a9	8b c0		 mov	 eax, eax
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000b1	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000ba	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000be	48 8b d0	 mov	 rdx, rax
  000c1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  000c6	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  000cb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000d0	48 89 81 08 01
	00 00		 mov	 QWORD PTR [rcx+264], rax

; 1192 :     if (self->readline == NULL || self->read == NULL) {

  000d7	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000dc	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  000e4	74 13		 je	 SHORT $LN14@Unpickler_@19
  000e6	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000eb	48 83 b8 00 01
	00 00 00	 cmp	 QWORD PTR [rax+256], 0
  000f3	0f 85 7d 01 00
	00		 jne	 $LN15@Unpickler_@19
$LN14@Unpickler_@19:

; 1193 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  000f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00100	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00105	85 c0		 test	 eax, eax
  00107	74 13		 je	 SHORT $LN13@Unpickler_@19

; 1194 :             PyErr_SetString(PyExc_TypeError,
; 1195 :                             "file must have 'read' and 'readline' attributes");

  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@COIFLMFN@file?5must?5have?5?8read?8?5and?5?8readl@
  00110	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00117	e8 00 00 00 00	 call	 PyErr_SetString
$LN13@Unpickler_@19:
$LN12@Unpickler_@19:

; 1196 :         Py_CLEAR(self->read);

  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00121	48 83 b8 00 01
	00 00 00	 cmp	 QWORD PTR [rax+256], 0
  00129	74 5c		 je	 SHORT $LN9@Unpickler_@19
  0012b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00133	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00138	4c 8b 88 00 01
	00 00		 mov	 r9, QWORD PTR [rax+256]
  0013f	41 b8 ac 04 00
	00		 mov	 r8d, 1196		; 000004acH
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@
  00153	e8 00 00 00 00	 call	 _PyParallel_Guard
  00158	85 c0		 test	 eax, eax
  0015a	75 2b		 jne	 SHORT $LN9@Unpickler_@19
  0015c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00161	48 8b 80 00 01
	00 00		 mov	 rax, QWORD PTR [rax+256]
  00168	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$21271[rsp], rax
  0016d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00172	48 c7 80 00 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+256], 0
  0017d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$21271[rsp]
  00182	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@Unpickler_@19:
  00187	33 c0		 xor	 eax, eax
  00189	85 c0		 test	 eax, eax
  0018b	75 8f		 jne	 SHORT $LN12@Unpickler_@19
$LN8@Unpickler_@19:

; 1197 :         Py_CLEAR(self->readline);

  0018d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00192	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  0019a	74 5c		 je	 SHORT $LN5@Unpickler_@19
  0019c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a4	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001a9	4c 8b 88 08 01
	00 00		 mov	 r9, QWORD PTR [rax+264]
  001b0	41 b8 ad 04 00
	00		 mov	 r8d, 1197		; 000004adH
  001b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@
  001c4	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c9	85 c0		 test	 eax, eax
  001cb	75 2b		 jne	 SHORT $LN5@Unpickler_@19
  001cd	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001d2	48 8b 80 08 01
	00 00		 mov	 rax, QWORD PTR [rax+264]
  001d9	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$21279[rsp], rax
  001de	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001e3	48 c7 80 08 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+264], 0
  001ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$21279[rsp]
  001f3	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@Unpickler_@19:
  001f8	33 c0		 xor	 eax, eax
  001fa	85 c0		 test	 eax, eax
  001fc	75 8f		 jne	 SHORT $LN8@Unpickler_@19
$LN4@Unpickler_@19:

; 1198 :         Py_CLEAR(self->peek);

  001fe	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00203	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  0020b	74 5c		 je	 SHORT $LN1@Unpickler_@19
  0020d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00215	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0021a	4c 8b 88 10 01
	00 00		 mov	 r9, QWORD PTR [rax+272]
  00221	41 b8 ae 04 00
	00		 mov	 r8d, 1198		; 000004aeH
  00227	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0022e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@
  00235	e8 00 00 00 00	 call	 _PyParallel_Guard
  0023a	85 c0		 test	 eax, eax
  0023c	75 2b		 jne	 SHORT $LN1@Unpickler_@19
  0023e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00243	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  0024a	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$21287[rsp], rax
  0024f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00254	48 c7 80 10 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+272], 0
  0025f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$21287[rsp]
  00264	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Unpickler_@19:
  00269	33 c0		 xor	 eax, eax
  0026b	85 c0		 test	 eax, eax
  0026d	75 8f		 jne	 SHORT $LN4@Unpickler_@19

; 1199 :         return -1;

  0026f	b8 ff ff ff ff	 mov	 eax, -1
  00274	eb 02		 jmp	 SHORT $LN19@Unpickler_@19
$LN15@Unpickler_@19:

; 1200 :     }
; 1201 :     return 0;

  00276	33 c0		 xor	 eax, eax
$LN19@Unpickler_@19:

; 1202 : }

  00278	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0027c	c3		 ret	 0
_Unpickler_SetInputStream ENDP
_TEXT	ENDS
PUBLIC	??_C@_05CCNLIHFO@ASCII?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_SetInputEncoding DD imagerel _Unpickler_SetInputEncoding
	DD	imagerel _Unpickler_SetInputEncoding+154
	DD	imagerel $unwind$_Unpickler_SetInputEncoding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_SetInputEncoding DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_05CCNLIHFO@ASCII?$AA@
CONST	SEGMENT
??_C@_05CCNLIHFO@ASCII?$AA@ DB 'ASCII', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Unpickler_SetInputEncoding
_TEXT	SEGMENT
self$ = 48
encoding$ = 56
errors$ = 64
_Unpickler_SetInputEncoding PROC			; COMDAT

; 1210 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1211 :     if (encoding == NULL)

  00013	48 83 7c 24 38
	00		 cmp	 QWORD PTR encoding$[rsp], 0
  00019	75 0c		 jne	 SHORT $LN4@Unpickler_@20

; 1212 :         encoding = "ASCII";

  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05CCNLIHFO@ASCII?$AA@
  00022	48 89 44 24 38	 mov	 QWORD PTR encoding$[rsp], rax
$LN4@Unpickler_@20:

; 1213 :     if (errors == NULL)

  00027	48 83 7c 24 40
	00		 cmp	 QWORD PTR errors$[rsp], 0
  0002d	75 0c		 jne	 SHORT $LN3@Unpickler_@20

; 1214 :         errors = "strict";

  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00036	48 89 44 24 40	 mov	 QWORD PTR errors$[rsp], rax
$LN3@Unpickler_@20:

; 1215 : 
; 1216 :     self->encoding = strdup(encoding);

  0003b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR encoding$[rsp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0004b	48 89 81 18 01
	00 00		 mov	 QWORD PTR [rcx+280], rax

; 1217 :     self->errors = strdup(errors);

  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR errors$[rsp]
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00062	48 89 81 20 01
	00 00		 mov	 QWORD PTR [rcx+288], rax

; 1218 :     if (self->encoding == NULL || self->errors == NULL) {

  00069	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 83 b8 18 01
	00 00 00	 cmp	 QWORD PTR [rax+280], 0
  00076	74 0f		 je	 SHORT $LN1@Unpickler_@20
  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0007d	48 83 b8 20 01
	00 00 00	 cmp	 QWORD PTR [rax+288], 0
  00085	75 0c		 jne	 SHORT $LN2@Unpickler_@20
$LN1@Unpickler_@20:

; 1219 :         PyErr_NoMemory();

  00087	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1220 :         return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	eb 02		 jmp	 SHORT $LN5@Unpickler_@20
$LN2@Unpickler_@20:

; 1221 :     }
; 1222 :     return 0;

  00093	33 c0		 xor	 eax, eax
$LN5@Unpickler_@20:

; 1223 : }

  00095	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00099	c3		 ret	 0
_Unpickler_SetInputEncoding ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ump_clear DD imagerel ump_clear
	DD	imagerel ump_clear+98
	DD	imagerel $unwind$ump_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ump_clear DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ump_clear
_TEXT	SEGMENT
self$ = 48
ump_clear PROC						; COMDAT

; 5763 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5764 :     _Unpickler_MemoCleanup(self->unpickler);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00012	e8 00 00 00 00	 call	 _Unpickler_MemoCleanup

; 5765 :     self->unpickler->memo = _Unpickler_NewMemo(self->unpickler->memo_size);

  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00020	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00024	e8 00 00 00 00	 call	 _Unpickler_NewMemo
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0002e	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00032	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 5766 :     if (self->unpickler->memo == NULL)

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003f	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00044	75 04		 jne	 SHORT $LN1@ump_clear

; 5767 :         return NULL;

  00046	33 c0		 xor	 eax, eax
  00048	eb 13		 jmp	 SHORT $LN2@ump_clear
$LN1@ump_clear:

; 5768 :     Py_RETURN_NONE;

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00051	e8 00 00 00 00	 call	 _Py_IncRef
  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@ump_clear:

; 5769 : }

  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00061	c3		 ret	 0
ump_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ump_copy DD imagerel ump_copy
	DD	imagerel ump_copy+212
	DD	imagerel $unwind$ump_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ump_copy DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ump_copy
_TEXT	SEGMENT
i$ = 32
new_memo$ = 40
value$24793 = 48
key$24792 = 56
status$24791 = 64
self$ = 96
ump_copy PROC						; COMDAT

; 5776 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5777 :     Py_ssize_t i;
; 5778 :     PyObject *new_memo = PyDict_New();

  00009	e8 00 00 00 00	 call	 PyDict_New
  0000e	48 89 44 24 28	 mov	 QWORD PTR new_memo$[rsp], rax

; 5779 :     if (new_memo == NULL)

  00013	48 83 7c 24 28
	00		 cmp	 QWORD PTR new_memo$[rsp], 0
  00019	75 07		 jne	 SHORT $LN7@ump_copy

; 5780 :         return NULL;

  0001b	33 c0		 xor	 eax, eax
  0001d	e9 ad 00 00 00	 jmp	 $LN8@ump_copy
$LN7@ump_copy:

; 5781 : 
; 5782 :     for (i = 0; i < self->unpickler->memo_size; i++) {

  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0002b	eb 0d		 jmp	 SHORT $LN6@ump_copy
$LN5@ump_copy:
  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00032	48 ff c0	 inc	 rax
  00035	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@ump_copy:
  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0003f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00043	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00047	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0004c	7d 6e		 jge	 SHORT $LN4@ump_copy

; 5783 :         int status;
; 5784 :         PyObject *key, *value;
; 5785 : 
; 5786 :         value = self->unpickler->memo[i];

  0004e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00053	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00057	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00060	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00064	48 89 44 24 30	 mov	 QWORD PTR value$24793[rsp], rax

; 5787 :         if (value == NULL)

  00069	48 83 7c 24 30
	00		 cmp	 QWORD PTR value$24793[rsp], 0
  0006f	75 02		 jne	 SHORT $LN3@ump_copy

; 5788 :             continue;

  00071	eb ba		 jmp	 SHORT $LN5@ump_copy
$LN3@ump_copy:

; 5789 : 
; 5790 :         key = PyLong_FromSsize_t(i);

  00073	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00078	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0007d	48 89 44 24 38	 mov	 QWORD PTR key$24792[rsp], rax

; 5791 :         if (key == NULL)

  00082	48 83 7c 24 38
	00		 cmp	 QWORD PTR key$24792[rsp], 0
  00088	75 02		 jne	 SHORT $LN2@ump_copy

; 5792 :             goto error;

  0008a	eb 37		 jmp	 SHORT $error$24798
$LN2@ump_copy:

; 5793 :         status = PyDict_SetItem(new_memo, key, value);

  0008c	4c 8b 44 24 30	 mov	 r8, QWORD PTR value$24793[rsp]
  00091	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$24792[rsp]
  00096	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_memo$[rsp]
  0009b	e8 00 00 00 00	 call	 PyDict_SetItem
  000a0	89 44 24 40	 mov	 DWORD PTR status$24791[rsp], eax

; 5794 :         Py_DECREF(key);

  000a4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$24792[rsp]
  000a9	e8 00 00 00 00	 call	 _Py_DecRef

; 5795 :         if (status < 0)

  000ae	83 7c 24 40 00	 cmp	 DWORD PTR status$24791[rsp], 0
  000b3	7d 02		 jge	 SHORT $LN1@ump_copy

; 5796 :             goto error;

  000b5	eb 0c		 jmp	 SHORT $error$24798
$LN1@ump_copy:

; 5797 :     }

  000b7	e9 71 ff ff ff	 jmp	 $LN5@ump_copy
$LN4@ump_copy:

; 5798 :     return new_memo;

  000bc	48 8b 44 24 28	 mov	 rax, QWORD PTR new_memo$[rsp]
  000c1	eb 0c		 jmp	 SHORT $LN8@ump_copy
$error$24798:

; 5799 : 
; 5800 : error:
; 5801 :     Py_DECREF(new_memo);

  000c3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_memo$[rsp]
  000c8	e8 00 00 00 00	 call	 _Py_DecRef

; 5802 :     return NULL;

  000cd	33 c0		 xor	 eax, eax
$LN8@ump_copy:

; 5803 : }

  000cf	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d3	c3		 ret	 0
ump_copy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ump_reduce DD imagerel ump_reduce
	DD	imagerel ump_reduce+194
	DD	imagerel $unwind$ump_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ump_reduce DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ump_reduce
_TEXT	SEGMENT
constructor_args$ = 32
reduce_value$ = 40
contents$ = 48
self$ = 80
args$ = 88
ump_reduce PROC						; COMDAT

; 5810 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5811 :     PyObject *reduce_value;
; 5812 :     PyObject *constructor_args;
; 5813 :     PyObject *contents = ump_copy(self);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 ump_copy
  00018	48 89 44 24 30	 mov	 QWORD PTR contents$[rsp], rax

; 5814 :     if (contents == NULL)

  0001d	48 83 7c 24 30
	00		 cmp	 QWORD PTR contents$[rsp], 0
  00023	75 07		 jne	 SHORT $LN3@ump_reduce

; 5815 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	e9 91 00 00 00	 jmp	 $LN4@ump_reduce
$LN3@ump_reduce:

; 5816 : 
; 5817 :     reduce_value = PyTuple_New(2);

  0002c	b9 02 00 00 00	 mov	 ecx, 2
  00031	e8 00 00 00 00	 call	 PyTuple_New
  00036	48 89 44 24 28	 mov	 QWORD PTR reduce_value$[rsp], rax

; 5818 :     if (reduce_value == NULL) {

  0003b	48 83 7c 24 28
	00		 cmp	 QWORD PTR reduce_value$[rsp], 0
  00041	75 0e		 jne	 SHORT $LN2@ump_reduce

; 5819 :         Py_DECREF(contents);

  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR contents$[rsp]
  00048	e8 00 00 00 00	 call	 _Py_DecRef

; 5820 :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 6c		 jmp	 SHORT $LN4@ump_reduce
$LN2@ump_reduce:

; 5821 :     }
; 5822 :     constructor_args = PyTuple_New(1);

  00051	b9 01 00 00 00	 mov	 ecx, 1
  00056	e8 00 00 00 00	 call	 PyTuple_New
  0005b	48 89 44 24 20	 mov	 QWORD PTR constructor_args$[rsp], rax

; 5823 :     if (constructor_args == NULL) {

  00060	48 83 7c 24 20
	00		 cmp	 QWORD PTR constructor_args$[rsp], 0
  00066	75 18		 jne	 SHORT $LN1@ump_reduce

; 5824 :         Py_DECREF(contents);

  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR contents$[rsp]
  0006d	e8 00 00 00 00	 call	 _Py_DecRef

; 5825 :         Py_DECREF(reduce_value);

  00072	48 8b 4c 24 28	 mov	 rcx, QWORD PTR reduce_value$[rsp]
  00077	e8 00 00 00 00	 call	 _Py_DecRef

; 5826 :         return NULL;

  0007c	33 c0		 xor	 eax, eax
  0007e	eb 3d		 jmp	 SHORT $LN4@ump_reduce
$LN1@ump_reduce:

; 5827 :     }
; 5828 :     PyTuple_SET_ITEM(constructor_args, 0, contents);

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR constructor_args$[rsp]
  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR contents$[rsp]
  0008a	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 5829 :     Py_INCREF((PyObject *)&PyDict_Type);

  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDict_Type
  00095	e8 00 00 00 00	 call	 _Py_IncRef

; 5830 :     PyTuple_SET_ITEM(reduce_value, 0, (PyObject *)&PyDict_Type);

  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR reduce_value$[rsp]
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDict_Type
  000a6	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 5831 :     PyTuple_SET_ITEM(reduce_value, 1, constructor_args);

  000aa	48 8b 44 24 28	 mov	 rax, QWORD PTR reduce_value$[rsp]
  000af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR constructor_args$[rsp]
  000b4	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 5832 :     return reduce_value;

  000b8	48 8b 44 24 28	 mov	 rax, QWORD PTR reduce_value$[rsp]
$LN4@ump_reduce:

; 5833 : }

  000bd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c1	c3		 ret	 0
ump_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnpicklerMemoProxy_dealloc DD imagerel UnpicklerMemoProxy_dealloc
	DD	imagerel UnpicklerMemoProxy_dealloc+66
	DD	imagerel $unwind$UnpicklerMemoProxy_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnpicklerMemoProxy_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT UnpicklerMemoProxy_dealloc
_TEXT	SEGMENT
self$ = 48
UnpicklerMemoProxy_dealloc PROC				; COMDAT

; 5844 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5845 :     PyObject_GC_UnTrack(self);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN4@UnpicklerM:

; 5846 :     Py_XDECREF(self->unpickler);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN1@UnpicklerM
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@UnpicklerM:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN4@UnpicklerM

; 5847 :     PyObject_GC_Del((PyObject *)self);

  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00038	e8 00 00 00 00	 call	 PyObject_GC_Del

; 5848 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
UnpicklerMemoProxy_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@DBEGFKPC@UnpicklerMemoProxy_traverse?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnpicklerMemoProxy_traverse DD imagerel UnpicklerMemoProxy_traverse
	DD	imagerel UnpicklerMemoProxy_traverse+116
	DD	imagerel $unwind$UnpicklerMemoProxy_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnpicklerMemoProxy_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BM@DBEGFKPC@UnpicklerMemoProxy_traverse?$AA@
CONST	SEGMENT
??_C@_0BM@DBEGFKPC@UnpicklerMemoProxy_traverse?$AA@ DB 'UnpicklerMemoProx'
	DB	'y_traverse', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT UnpicklerMemoProxy_traverse
_TEXT	SEGMENT
vret$24861 = 32
self$ = 64
visit$ = 72
arg$ = 80
UnpicklerMemoProxy_traverse PROC			; COMDAT

; 5853 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@UnpicklerM@2:

; 5854 :     Py_VISIT(self->unpickler);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@UnpicklerM@2
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 de 16 00
	00		 mov	 r8d, 5854		; 000016deH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@DBEGFKPC@UnpicklerMemoProxy_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@UnpicklerM@2:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN2@UnpicklerM@2
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$24861[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$24861[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@UnpicklerM@2
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$24861[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@UnpicklerM@2
$LN1@UnpicklerM@2:
$LN2@UnpicklerM@2:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@UnpicklerM@2

; 5855 :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@UnpicklerM@2:

; 5856 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
UnpicklerMemoProxy_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@JPBDBIDH@UnpicklerMemoProxy_clear?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnpicklerMemoProxy_clear DD imagerel UnpicklerMemoProxy_clear
	DD	imagerel UnpicklerMemoProxy_clear+117
	DD	imagerel $unwind$UnpicklerMemoProxy_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnpicklerMemoProxy_clear DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BJ@JPBDBIDH@UnpicklerMemoProxy_clear?$AA@
CONST	SEGMENT
??_C@_0BJ@JPBDBIDH@UnpicklerMemoProxy_clear?$AA@ DB 'UnpicklerMemoProxy_c'
	DB	'lear', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT UnpicklerMemoProxy_clear
_TEXT	SEGMENT
_py_tmp$24873 = 48
self$ = 80
UnpicklerMemoProxy_clear PROC				; COMDAT

; 5860 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@UnpicklerM@3:

; 5861 :     Py_CLEAR(self->unpickler);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 53		 je	 SHORT $LN1@UnpicklerM@3
  00015	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00022	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  00026	41 b8 e5 16 00
	00		 mov	 r8d, 5861		; 000016e5H
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@JPBDBIDH@UnpicklerMemoProxy_clear?$AA@
  0003a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003f	85 c0		 test	 eax, eax
  00041	75 25		 jne	 SHORT $LN1@UnpicklerM@3
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00048	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004c	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$24873[rsp], rax
  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00056	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$24873[rsp]
  00063	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@UnpicklerM@3:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 9b		 jne	 SHORT $LN4@UnpicklerM@3

; 5862 :     return 0;

  0006e	33 c0		 xor	 eax, eax

; 5863 : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
UnpicklerMemoProxy_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_get_memo DD imagerel Unpickler_get_memo
	DD	imagerel Unpickler_get_memo+24
	DD	imagerel $unwind$Unpickler_get_memo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_get_memo DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Unpickler_get_memo
_TEXT	SEGMENT
self$ = 48
Unpickler_get_memo PROC					; COMDAT

; 5916 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5917 :     return UnpicklerMemoProxy_New(self);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 UnpicklerMemoProxy_New

; 5918 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
Unpickler_get_memo ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnpicklerMemoProxy_New DD imagerel UnpicklerMemoProxy_New
	DD	imagerel UnpicklerMemoProxy_New+120
	DD	imagerel $unwind$UnpicklerMemoProxy_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnpicklerMemoProxy_New DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT UnpicklerMemoProxy_New
_TEXT	SEGMENT
self$ = 32
tv70 = 40
unpickler$ = 64
UnpicklerMemoProxy_New PROC				; COMDAT

; 5898 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5899 :     UnpicklerMemoProxyObject *self;
; 5900 : 
; 5901 :     self = PyObject_GC_New(UnpicklerMemoProxyObject,
; 5902 :                            &UnpicklerMemoProxyType);

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 13		 je	 SHORT $LN4@UnpicklerM@4
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UnpicklerMemoProxyType
  00019	e8 00 00 00 00	 call	 _PxObject_New
  0001e	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00023	eb 11		 jmp	 SHORT $LN5@UnpicklerM@4
$LN4@UnpicklerM@4:
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UnpicklerMemoProxyType
  0002c	e8 00 00 00 00	 call	 _PyObject_GC_New
  00031	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN5@UnpicklerM@4:
  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  0003b	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 5903 :     if (self == NULL)

  00040	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00046	75 04		 jne	 SHORT $LN1@UnpicklerM@4

; 5904 :         return NULL;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 27		 jmp	 SHORT $LN2@UnpicklerM@4
$LN1@UnpicklerM@4:

; 5905 :     Py_INCREF(unpickler);

  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR unpickler$[rsp]
  00051	e8 00 00 00 00	 call	 _Py_IncRef

; 5906 :     self->unpickler = unpickler;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR unpickler$[rsp]
  00060	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 5907 :     PyObject_GC_Track(self);

  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00069	e8 00 00 00 00	 call	 PyObject_GC_Track

; 5908 :     return (PyObject *)self;

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
$LN2@UnpicklerM@4:

; 5909 : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
UnpicklerMemoProxy_New ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EJ@JNONLCFC@?8memo?8?5attribute?5must?5be?5an?5Unpi@ ; `string'
PUBLIC	??_C@_0CE@EFMIHDJD@memo?5key?5must?5be?5positive?5intege@ ; `string'
PUBLIC	??_C@_0BK@DHOABPGF@memo?5key?5must?5be?5integers?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_set_memo DD imagerel Unpickler_set_memo
	DD	imagerel Unpickler_set_memo+797
	DD	imagerel $unwind$Unpickler_set_memo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_set_memo DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0EJ@JNONLCFC@?8memo?8?5attribute?5must?5be?5an?5Unpi@
CONST	SEGMENT
??_C@_0EJ@JNONLCFC@?8memo?8?5attribute?5must?5be?5an?5Unpi@ DB '''memo'' '
	DB	'attribute must be an UnpicklerMemoProxy objector dict, not %.'
	DB	'200s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EFMIHDJD@memo?5key?5must?5be?5positive?5intege@
CONST	SEGMENT
??_C@_0CE@EFMIHDJD@memo?5key?5must?5be?5positive?5intege@ DB 'memo key mu'
	DB	'st be positive integers.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DHOABPGF@memo?5key?5must?5be?5integers?$AA@
CONST	SEGMENT
??_C@_0BK@DHOABPGF@memo?5key?5must?5be?5integers?$AA@ DB 'memo key must b'
	DB	'e integers', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Unpickler_set_memo
_TEXT	SEGMENT
i$ = 32
new_memo_size$ = 40
new_memo$ = 48
unpickler$24925 = 56
value$24942 = 64
i$24940 = 72
key$24941 = 80
idx$24948 = 88
tv178 = 96
self$ = 128
obj$ = 136
Unpickler_set_memo PROC					; COMDAT

; 5922 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 5923 :     PyObject **new_memo;
; 5924 :     Py_ssize_t new_memo_size = 0;

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR new_memo_size$[rsp], 0

; 5925 :     Py_ssize_t i;
; 5926 : 
; 5927 :     if (obj == NULL) {

  00017	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR obj$[rsp], 0
  00020	75 1d		 jne	 SHORT $LN27@Unpickler_@21

; 5928 :         PyErr_SetString(PyExc_TypeError,
; 5929 :                         "attribute deletion is not supported");

  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00030	e8 00 00 00 00	 call	 PyErr_SetString

; 5930 :         return -1;

  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	e9 d9 02 00 00	 jmp	 $LN28@Unpickler_@21
$LN27@Unpickler_@21:

; 5931 :     }
; 5932 : 
; 5933 :     if (Py_TYPE(obj) == &UnpicklerMemoProxyType) {

  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:UnpicklerMemoProxyType
  00046	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  0004e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00052	0f 85 bd 00 00
	00		 jne	 $LN26@Unpickler_@21

; 5934 :         UnpicklerObject *unpickler =
; 5935 :             ((UnpicklerMemoProxyObject *)obj)->unpickler;

  00058	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00060	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00064	48 89 44 24 38	 mov	 QWORD PTR unpickler$24925[rsp], rax

; 5936 : 
; 5937 :         new_memo_size = unpickler->memo_size;

  00069	48 8b 44 24 38	 mov	 rax, QWORD PTR unpickler$24925[rsp]
  0006e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00072	48 89 44 24 28	 mov	 QWORD PTR new_memo_size$[rsp], rax

; 5938 :         new_memo = _Unpickler_NewMemo(new_memo_size);

  00077	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_memo_size$[rsp]
  0007c	e8 00 00 00 00	 call	 _Unpickler_NewMemo
  00081	48 89 44 24 30	 mov	 QWORD PTR new_memo$[rsp], rax

; 5939 :         if (new_memo == NULL)

  00086	48 83 7c 24 30
	00		 cmp	 QWORD PTR new_memo$[rsp], 0
  0008c	75 0a		 jne	 SHORT $LN25@Unpickler_@21

; 5940 :             return -1;

  0008e	b8 ff ff ff ff	 mov	 eax, -1
  00093	e9 80 02 00 00	 jmp	 $LN28@Unpickler_@21
$LN25@Unpickler_@21:

; 5941 : 
; 5942 :         for (i = 0; i < new_memo_size; i++) {

  00098	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000a1	eb 0d		 jmp	 SHORT $LN24@Unpickler_@21
$LN23@Unpickler_@21:
  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000a8	48 ff c0	 inc	 rax
  000ab	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN24@Unpickler_@21:
  000b0	48 8b 44 24 28	 mov	 rax, QWORD PTR new_memo_size$[rsp]
  000b5	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000ba	7d 54		 jge	 SHORT $LN22@Unpickler_@21
$LN21@Unpickler_@21:

; 5943 :             Py_XINCREF(unpickler->memo[i]);

  000bc	48 8b 44 24 38	 mov	 rax, QWORD PTR unpickler$24925[rsp]
  000c1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000ca	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  000cf	74 17		 je	 SHORT $LN18@Unpickler_@21
  000d1	48 8b 44 24 38	 mov	 rax, QWORD PTR unpickler$24925[rsp]
  000d6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000df	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  000e3	e8 00 00 00 00	 call	 _Py_IncRef
$LN18@Unpickler_@21:
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	75 ce		 jne	 SHORT $LN21@Unpickler_@21

; 5944 :             new_memo[i] = unpickler->memo[i];

  000ee	48 8b 44 24 38	 mov	 rax, QWORD PTR unpickler$24925[rsp]
  000f3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR new_memo$[rsp]
  000fc	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00101	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00106	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  0010a	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 5945 :         }

  0010e	eb 93		 jmp	 SHORT $LN23@Unpickler_@21
$LN22@Unpickler_@21:

; 5946 :     }
; 5947 :     else if (PyDict_Check(obj)) {

  00110	e9 46 01 00 00	 jmp	 $LN17@Unpickler_@21
$LN26@Unpickler_@21:
  00115	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  0011d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00121	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00127	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0012c	85 c0		 test	 eax, eax
  0012e	0f 84 fa 00 00
	00		 je	 $LN16@Unpickler_@21

; 5948 :         Py_ssize_t i = 0;

  00134	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR i$24940[rsp], 0

; 5949 :         PyObject *key, *value;
; 5950 : 
; 5951 :         new_memo_size = PyDict_Size(obj);

  0013d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  00145	e8 00 00 00 00	 call	 PyDict_Size
  0014a	48 89 44 24 28	 mov	 QWORD PTR new_memo_size$[rsp], rax

; 5952 :         new_memo = _Unpickler_NewMemo(new_memo_size);

  0014f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_memo_size$[rsp]
  00154	e8 00 00 00 00	 call	 _Unpickler_NewMemo
  00159	48 89 44 24 30	 mov	 QWORD PTR new_memo$[rsp], rax

; 5953 :         if (new_memo == NULL)

  0015e	48 83 7c 24 30
	00		 cmp	 QWORD PTR new_memo$[rsp], 0
  00164	75 0a		 jne	 SHORT $LN15@Unpickler_@21

; 5954 :             return -1;

  00166	b8 ff ff ff ff	 mov	 eax, -1
  0016b	e9 a8 01 00 00	 jmp	 $LN28@Unpickler_@21
$LN15@Unpickler_@21:
$LN14@Unpickler_@21:

; 5955 : 
; 5956 :         while (PyDict_Next(obj, &i, &key, &value)) {

  00170	4c 8d 4c 24 40	 lea	 r9, QWORD PTR value$24942[rsp]
  00175	4c 8d 44 24 50	 lea	 r8, QWORD PTR key$24941[rsp]
  0017a	48 8d 54 24 48	 lea	 rdx, QWORD PTR i$24940[rsp]
  0017f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  00187	e8 00 00 00 00	 call	 PyDict_Next
  0018c	85 c0		 test	 eax, eax
  0018e	0f 84 98 00 00
	00		 je	 $LN13@Unpickler_@21

; 5957 :             Py_ssize_t idx;
; 5958 :             if (!PyLong_Check(key)) {

  00194	48 8b 44 24 50	 mov	 rax, QWORD PTR key$24941[rsp]
  00199	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0019d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001a3	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  001a8	85 c0		 test	 eax, eax
  001aa	75 18		 jne	 SHORT $LN12@Unpickler_@21

; 5959 :                 PyErr_SetString(PyExc_TypeError,
; 5960 :                                 "memo key must be integers");

  001ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DHOABPGF@memo?5key?5must?5be?5integers?$AA@
  001b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001ba	e8 00 00 00 00	 call	 PyErr_SetString

; 5961 :                 goto error;

  001bf	e9 cd 00 00 00	 jmp	 $error$24952
$LN12@Unpickler_@21:

; 5962 :             }
; 5963 :             idx = PyLong_AsSsize_t(key);

  001c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR key$24941[rsp]
  001c9	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  001ce	48 89 44 24 58	 mov	 QWORD PTR idx$24948[rsp], rax

; 5964 :             if (idx == -1 && PyErr_Occurred())

  001d3	48 83 7c 24 58
	ff		 cmp	 QWORD PTR idx$24948[rsp], -1
  001d9	75 0f		 jne	 SHORT $LN11@Unpickler_@21
  001db	e8 00 00 00 00	 call	 PyErr_Occurred
  001e0	48 85 c0	 test	 rax, rax
  001e3	74 05		 je	 SHORT $LN11@Unpickler_@21

; 5965 :                 goto error;

  001e5	e9 a7 00 00 00	 jmp	 $error$24952
$LN11@Unpickler_@21:

; 5966 :             if (idx < 0) {

  001ea	48 83 7c 24 58
	00		 cmp	 QWORD PTR idx$24948[rsp], 0
  001f0	7d 18		 jge	 SHORT $LN10@Unpickler_@21

; 5967 :                 PyErr_SetString(PyExc_ValueError,
; 5968 :                                 "memo key must be positive integers.");

  001f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@EFMIHDJD@memo?5key?5must?5be?5positive?5intege@
  001f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00200	e8 00 00 00 00	 call	 PyErr_SetString

; 5969 :                 goto error;

  00205	e9 87 00 00 00	 jmp	 $error$24952
$LN10@Unpickler_@21:

; 5970 :             }
; 5971 :             if (_Unpickler_MemoPut(self, idx, value) < 0)

  0020a	4c 8b 44 24 40	 mov	 r8, QWORD PTR value$24942[rsp]
  0020f	48 8b 54 24 58	 mov	 rdx, QWORD PTR idx$24948[rsp]
  00214	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0021c	e8 00 00 00 00	 call	 _Unpickler_MemoPut
  00221	85 c0		 test	 eax, eax
  00223	7d 02		 jge	 SHORT $LN9@Unpickler_@21

; 5972 :                 goto error;

  00225	eb 6a		 jmp	 SHORT $error$24952
$LN9@Unpickler_@21:

; 5973 :         }

  00227	e9 44 ff ff ff	 jmp	 $LN14@Unpickler_@21
$LN13@Unpickler_@21:

; 5974 :     }
; 5975 :     else {

  0022c	eb 2d		 jmp	 SHORT $LN8@Unpickler_@21
$LN16@Unpickler_@21:

; 5976 :         PyErr_Format(PyExc_TypeError,
; 5977 :                      "'memo' attribute must be an UnpicklerMemoProxy object"
; 5978 :                      "or dict, not %.200s", Py_TYPE(obj)->tp_name);

  0022e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00236	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0023a	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0023e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EJ@JNONLCFC@?8memo?8?5attribute?5must?5be?5an?5Unpi@
  00245	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0024c	e8 00 00 00 00	 call	 PyErr_Format

; 5979 :         return -1;

  00251	b8 ff ff ff ff	 mov	 eax, -1
  00256	e9 bd 00 00 00	 jmp	 $LN28@Unpickler_@21
$LN8@Unpickler_@21:
$LN17@Unpickler_@21:

; 5980 :     }
; 5981 : 
; 5982 :     _Unpickler_MemoCleanup(self);

  0025b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00263	e8 00 00 00 00	 call	 _Unpickler_MemoCleanup

; 5983 :     self->memo_size = new_memo_size;

  00268	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00270	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_memo_size$[rsp]
  00275	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 5984 :     self->memo = new_memo;

  00279	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00281	48 8b 4c 24 30	 mov	 rcx, QWORD PTR new_memo$[rsp]
  00286	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 5985 : 
; 5986 :     return 0;

  0028a	33 c0		 xor	 eax, eax
  0028c	e9 87 00 00 00	 jmp	 $LN28@Unpickler_@21
$error$24952:

; 5987 : 
; 5988 :   error:
; 5989 :     if (new_memo_size) {

  00291	48 83 7c 24 28
	00		 cmp	 QWORD PTR new_memo_size$[rsp], 0
  00297	74 7a		 je	 SHORT $LN7@Unpickler_@21

; 5990 :         i = new_memo_size;

  00299	48 8b 44 24 28	 mov	 rax, QWORD PTR new_memo_size$[rsp]
  0029e	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@Unpickler_@21:

; 5991 :         while (--i >= 0) {

  002a3	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  002a8	48 ff c8	 dec	 rax
  002ab	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  002b0	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  002b6	7c 2c		 jl	 SHORT $LN5@Unpickler_@21
$LN4@Unpickler_@21:

; 5992 :             Py_XDECREF(new_memo[i]);

  002b8	48 8b 44 24 30	 mov	 rax, QWORD PTR new_memo$[rsp]
  002bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  002c2	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  002c7	74 13		 je	 SHORT $LN1@Unpickler_@21
  002c9	48 8b 44 24 30	 mov	 rax, QWORD PTR new_memo$[rsp]
  002ce	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  002d3	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  002d7	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Unpickler_@21:
  002dc	33 c0		 xor	 eax, eax
  002de	85 c0		 test	 eax, eax
  002e0	75 d6		 jne	 SHORT $LN4@Unpickler_@21

; 5993 :         }

  002e2	eb bf		 jmp	 SHORT $LN6@Unpickler_@21
$LN5@Unpickler_@21:

; 5994 :         PyMem_FREE(new_memo);

  002e4	e8 00 00 00 00	 call	 _Py_PXCTX
  002e9	85 c0		 test	 eax, eax
  002eb	74 14		 je	 SHORT $LN30@Unpickler_@21
  002ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR new_memo$[rsp]
  002f2	e8 00 00 00 00	 call	 _PxMem_Free
  002f7	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
  002ff	eb 12		 jmp	 SHORT $LN31@Unpickler_@21
$LN30@Unpickler_@21:
  00301	48 8b 4c 24 30	 mov	 rcx, QWORD PTR new_memo$[rsp]
  00306	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0030b	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN31@Unpickler_@21:
$LN7@Unpickler_@21:

; 5995 :     }
; 5996 :     return -1;

  00313	b8 ff ff ff ff	 mov	 eax, -1
$LN28@Unpickler_@21:

; 5997 : }

  00318	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0031c	c3		 ret	 0
Unpickler_set_memo ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_get_persload DD imagerel Unpickler_get_persload
	DD	imagerel Unpickler_get_persload+79
	DD	imagerel $unwind$Unpickler_get_persload
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_get_persload DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Unpickler_get_persload
_TEXT	SEGMENT
self$ = 48
Unpickler_get_persload PROC				; COMDAT

; 6001 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6002 :     if (self->pers_func == NULL)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00016	75 15		 jne	 SHORT $LN2@Unpickler_@22

; 6003 :         PyErr_SetString(PyExc_AttributeError, "persistent_load");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@NNFEJGCF@persistent_load?$AA@
  0001f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00026	e8 00 00 00 00	 call	 PyErr_SetString

; 6004 :     else

  0002b	eb 11		 jmp	 SHORT $LN1@Unpickler_@22
$LN2@Unpickler_@22:

; 6005 :         Py_INCREF(self->pers_func);

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00032	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00039	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@Unpickler_@22:

; 6006 :     return self->pers_func;

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00043	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]

; 6007 : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
Unpickler_get_persload ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@GNLPJLNO@persistent_load?5must?5be?5a?5callab@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_set_persload DD imagerel Unpickler_set_persload
	DD	imagerel Unpickler_set_persload+163
	DD	imagerel $unwind$Unpickler_set_persload
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_set_persload DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0DH@GNLPJLNO@persistent_load?5must?5be?5a?5callab@
CONST	SEGMENT
??_C@_0DH@GNLPJLNO@persistent_load?5must?5be?5a?5callab@ DB 'persistent_l'
	DB	'oad must be a callable taking one argument', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Unpickler_set_persload
_TEXT	SEGMENT
tmp$ = 32
self$ = 64
value$ = 72
Unpickler_set_persload PROC				; COMDAT

; 6011 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6012 :     PyObject *tmp;
; 6013 : 
; 6014 :     if (value == NULL) {

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR value$[rsp], 0
  00014	75 1a		 jne	 SHORT $LN6@Unpickler_@23

; 6015 :         PyErr_SetString(PyExc_TypeError,
; 6016 :                         "attribute deletion is not supported");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@
  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00024	e8 00 00 00 00	 call	 PyErr_SetString

; 6017 :         return -1;

  00029	b8 ff ff ff ff	 mov	 eax, -1
  0002e	eb 6e		 jmp	 SHORT $LN7@Unpickler_@23
$LN6@Unpickler_@23:

; 6018 :     }
; 6019 :     if (!PyCallable_Check(value)) {

  00030	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$[rsp]
  00035	e8 00 00 00 00	 call	 PyCallable_Check
  0003a	85 c0		 test	 eax, eax
  0003c	75 1a		 jne	 SHORT $LN5@Unpickler_@23

; 6020 :         PyErr_SetString(PyExc_TypeError,
; 6021 :                         "persistent_load must be a callable taking "
; 6022 :                         "one argument");

  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@GNLPJLNO@persistent_load?5must?5be?5a?5callab@
  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0004c	e8 00 00 00 00	 call	 PyErr_SetString

; 6023 :         return -1;

  00051	b8 ff ff ff ff	 mov	 eax, -1
  00056	eb 46		 jmp	 SHORT $LN7@Unpickler_@23
$LN5@Unpickler_@23:

; 6024 :     }
; 6025 : 
; 6026 :     tmp = self->pers_func;

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0005d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00064	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 6027 :     Py_INCREF(value);

  00069	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$[rsp]
  0006e	e8 00 00 00 00	 call	 _Py_IncRef

; 6028 :     self->pers_func = value;

  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00078	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$[rsp]
  0007d	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx
$LN4@Unpickler_@23:

; 6029 :     Py_XDECREF(tmp);      /* self->pers_func can be NULL, so be careful. */

  00084	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0008a	74 0a		 je	 SHORT $LN1@Unpickler_@23
  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  00091	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@Unpickler_@23:
  00096	33 c0		 xor	 eax, eax
  00098	85 c0		 test	 eax, eax
  0009a	75 e8		 jne	 SHORT $LN4@Unpickler_@23

; 6030 : 
; 6031 :     return 0;

  0009c	33 c0		 xor	 eax, eax
$LN7@Unpickler_@23:

; 6032 : }

  0009e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a2	c3		 ret	 0
Unpickler_set_persload ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BAJCJOGK@OO?$HMOO?3dump?$AA@		; `string'
PUBLIC	??_C@_0DO@NPFJLKNJ@pickle?4dump?$CI?$CJ?5takes?5at?5most?53?5po@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pickle_dump DD imagerel pickle_dump
	DD	imagerel pickle_dump+350
	DD	imagerel $unwind$pickle_dump
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pickle_dump DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0L@BAJCJOGK@OO?$HMOO?3dump?$AA@
CONST	SEGMENT
??_C@_0L@BAJCJOGK@OO?$HMOO?3dump?$AA@ DB 'OO|OO:dump', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@NPFJLKNJ@pickle?4dump?$CI?$CJ?5takes?5at?5most?53?5po@
CONST	SEGMENT
??_C@_0DO@NPFJLKNJ@pickle?4dump?$CI?$CJ?5takes?5at?5most?53?5po@ DB 'pick'
	DB	'le.dump() takes at most 3 positional argument (%zd given)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT pickle_dump
_TEXT	SEGMENT
fix_imports$ = 64
proto$ = 72
file$ = 80
obj$ = 88
pickler$ = 96
self$ = 128
args$ = 136
kwds$ = 144
pickle_dump PROC					; COMDAT

; 6109 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 6110 :     static char *kwlist[] = {"obj", "file", "protocol", "fix_imports", 0};
; 6111 :     PyObject *obj;
; 6112 :     PyObject *file;
; 6113 :     PyObject *proto = NULL;

  00013	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR proto$[rsp], 0

; 6114 :     PyObject *fix_imports = Py_True;

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00023	48 89 44 24 40	 mov	 QWORD PTR fix_imports$[rsp], rax

; 6115 :     PicklerObject *pickler;
; 6116 : 
; 6117 :     /* fix_imports is a keyword-only argument.  */
; 6118 :     if (Py_SIZE(args) > 3) {

  00028	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00030	48 83 78 60 03	 cmp	 QWORD PTR [rax+96], 3
  00035	7e 26		 jle	 SHORT $LN11@pickle_dum

; 6119 :         PyErr_Format(PyExc_TypeError,
; 6120 :                      "pickle.dump() takes at most 3 positional "
; 6121 :                      "argument (%zd given)", Py_SIZE(args));

  00037	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  0003f	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DO@NPFJLKNJ@pickle?4dump?$CI?$CJ?5takes?5at?5most?53?5po@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00051	e8 00 00 00 00	 call	 PyErr_Format

; 6122 :         return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	e9 fc 00 00 00	 jmp	 $LN12@pickle_dum
$LN11@pickle_dum:

; 6123 :     }
; 6124 : 
; 6125 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO|OO:dump", kwlist,
; 6126 :                                      &obj, &file, &proto, &fix_imports))

  0005d	48 8d 44 24 40	 lea	 rax, QWORD PTR fix_imports$[rsp]
  00062	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00067	48 8d 44 24 48	 lea	 rax, QWORD PTR proto$[rsp]
  0006c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00071	48 8d 44 24 50	 lea	 rax, QWORD PTR file$[rsp]
  00076	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007b	48 8d 44 24 58	 lea	 rax, QWORD PTR obj$[rsp]
  00080	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00085	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pickle_dump@@9@9
  0008c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@BAJCJOGK@OO?$HMOO?3dump?$AA@
  00093	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  0009b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000a3	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000a8	85 c0		 test	 eax, eax
  000aa	75 07		 jne	 SHORT $LN10@pickle_dum

; 6127 :         return NULL;

  000ac	33 c0		 xor	 eax, eax
  000ae	e9 a6 00 00 00	 jmp	 $LN12@pickle_dum
$LN10@pickle_dum:

; 6128 : 
; 6129 :     pickler = _Pickler_New();

  000b3	e8 00 00 00 00	 call	 _Pickler_New
  000b8	48 89 44 24 60	 mov	 QWORD PTR pickler$[rsp], rax

; 6130 :     if (pickler == NULL)

  000bd	48 83 7c 24 60
	00		 cmp	 QWORD PTR pickler$[rsp], 0
  000c3	75 07		 jne	 SHORT $LN9@pickle_dum

; 6131 :         return NULL;

  000c5	33 c0		 xor	 eax, eax
  000c7	e9 8d 00 00 00	 jmp	 $LN12@pickle_dum
$LN9@pickle_dum:

; 6132 : 
; 6133 :     if (_Pickler_SetProtocol(pickler, proto, fix_imports) < 0)

  000cc	4c 8b 44 24 40	 mov	 r8, QWORD PTR fix_imports$[rsp]
  000d1	48 8b 54 24 48	 mov	 rdx, QWORD PTR proto$[rsp]
  000d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  000db	e8 00 00 00 00	 call	 _Pickler_SetProtocol
  000e0	85 c0		 test	 eax, eax
  000e2	7d 02		 jge	 SHORT $LN8@pickle_dum

; 6134 :         goto error;

  000e4	eb 59		 jmp	 SHORT $error$25050
$LN8@pickle_dum:

; 6135 : 
; 6136 :     if (_Pickler_SetOutputStream(pickler, file) < 0)

  000e6	48 8b 54 24 50	 mov	 rdx, QWORD PTR file$[rsp]
  000eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  000f0	e8 00 00 00 00	 call	 _Pickler_SetOutputStream
  000f5	85 c0		 test	 eax, eax
  000f7	7d 02		 jge	 SHORT $LN7@pickle_dum

; 6137 :         goto error;

  000f9	eb 44		 jmp	 SHORT $error$25050
$LN7@pickle_dum:

; 6138 : 
; 6139 :     if (dump(pickler, obj) < 0)

  000fb	48 8b 54 24 58	 mov	 rdx, QWORD PTR obj$[rsp]
  00100	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  00105	e8 00 00 00 00	 call	 dump
  0010a	85 c0		 test	 eax, eax
  0010c	7d 02		 jge	 SHORT $LN6@pickle_dum

; 6140 :         goto error;

  0010e	eb 2f		 jmp	 SHORT $error$25050
$LN6@pickle_dum:

; 6141 : 
; 6142 :     if (_Pickler_FlushToFile(pickler) < 0)

  00110	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  00115	e8 00 00 00 00	 call	 _Pickler_FlushToFile
  0011a	85 c0		 test	 eax, eax
  0011c	7d 02		 jge	 SHORT $LN5@pickle_dum

; 6143 :         goto error;

  0011e	eb 1f		 jmp	 SHORT $error$25050
$LN5@pickle_dum:

; 6144 : 
; 6145 :     Py_DECREF(pickler);

  00120	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  00125	e8 00 00 00 00	 call	 _Py_DecRef

; 6146 :     Py_RETURN_NONE;

  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00131	e8 00 00 00 00	 call	 _Py_IncRef
  00136	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0013d	eb 1a		 jmp	 SHORT $LN12@pickle_dum
$error$25050:
$LN4@pickle_dum:

; 6147 : 
; 6148 :   error:
; 6149 :     Py_XDECREF(pickler);

  0013f	48 83 7c 24 60
	00		 cmp	 QWORD PTR pickler$[rsp], 0
  00145	74 0a		 je	 SHORT $LN1@pickle_dum
  00147	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  0014c	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@pickle_dum:
  00151	33 c0		 xor	 eax, eax
  00153	85 c0		 test	 eax, eax
  00155	75 e8		 jne	 SHORT $LN4@pickle_dum

; 6150 :     return NULL;

  00157	33 c0		 xor	 eax, eax
$LN12@pickle_dum:

; 6151 : }

  00159	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0015d	c3		 ret	 0
pickle_dump ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_New DD imagerel _Pickler_New
	DD	imagerel _Pickler_New+362
	DD	imagerel $unwind$_Pickler_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_New DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Pickler_New
_TEXT	SEGMENT
self$ = 32
tv70 = 40
_Pickler_New PROC					; COMDAT

; 760  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 761  :     PicklerObject *self;
; 762  : 
; 763  :     self = PyObject_GC_New(PicklerObject, &Pickler_Type);

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 13		 je	 SHORT $LN6@Pickler_Ne
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pickler_Type
  00014	e8 00 00 00 00	 call	 _PxObject_New
  00019	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  0001e	eb 11		 jmp	 SHORT $LN7@Pickler_Ne
$LN6@Pickler_Ne:
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pickler_Type
  00027	e8 00 00 00 00	 call	 _PyObject_GC_New
  0002c	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN7@Pickler_Ne:
  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  00036	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 764  :     if (self == NULL)

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00041	75 07		 jne	 SHORT $LN3@Pickler_Ne

; 765  :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 1b 01 00 00	 jmp	 $LN4@Pickler_Ne
$LN3@Pickler_Ne:

; 766  : 
; 767  :     self->pers_func = NULL;

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0004f	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 768  :     self->dispatch_table = NULL;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0005c	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 769  :     self->arg = NULL;

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00069	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 770  :     self->write = NULL;

  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00076	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 771  :     self->proto = 0;

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00086	c7 80 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+160], 0

; 772  :     self->bin = 0;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00095	c7 80 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+164], 0

; 773  :     self->fast = 0;

  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000a4	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+176], 0

; 774  :     self->fast_nesting = 0;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000b3	c7 80 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+180], 0

; 775  :     self->fix_imports = 0;

  000bd	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000c2	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+184], 0

; 776  :     self->fast_memo = NULL;

  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000d1	48 c7 80 c0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+192], 0

; 777  : 
; 778  :     self->memo = PyMemoTable_New();

  000dc	e8 00 00 00 00	 call	 PyMemoTable_New
  000e1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  000e6	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 779  :     if (self->memo == NULL) {

  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000ef	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000f4	75 0e		 jne	 SHORT $LN2@Pickler_Ne

; 780  :         Py_DECREF(self);

  000f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  000fb	e8 00 00 00 00	 call	 _Py_DecRef

; 781  :         return NULL;

  00100	33 c0		 xor	 eax, eax
  00102	eb 61		 jmp	 SHORT $LN4@Pickler_Ne
$LN2@Pickler_Ne:

; 782  :     }
; 783  :     self->max_output_len = WRITE_BUF_SIZE;

  00104	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00109	48 c7 80 98 00
	00 00 00 10 00
	00		 mov	 QWORD PTR [rax+152], 4096 ; 00001000H

; 784  :     self->output_len = 0;

  00114	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00119	48 c7 80 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+144], 0

; 785  :     self->output_buffer = PyBytes_FromStringAndSize(NULL,
; 786  :                                                     self->max_output_len);

  00124	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00129	48 8b 90 98 00
	00 00		 mov	 rdx, QWORD PTR [rax+152]
  00130	33 c9		 xor	 ecx, ecx
  00132	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00137	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  0013c	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 787  :     if (self->output_buffer == NULL) {

  00143	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00148	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00150	75 0e		 jne	 SHORT $LN1@Pickler_Ne

; 788  :         Py_DECREF(self);

  00152	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00157	e8 00 00 00 00	 call	 _Py_DecRef

; 789  :         return NULL;

  0015c	33 c0		 xor	 eax, eax
  0015e	eb 05		 jmp	 SHORT $LN4@Pickler_Ne
$LN1@Pickler_Ne:

; 790  :     }
; 791  :     return self;

  00160	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
$LN4@Pickler_Ne:

; 792  : }

  00165	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00169	c3		 ret	 0
_Pickler_New ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@PLMAGPOP@O?$HMOO?3dumps?$AA@		; `string'
PUBLIC	??_C@_0DP@IGIBAAHF@pickle?4dumps?$CI?$CJ?5takes?5at?5most?52?5p@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pickle_dumps DD imagerel pickle_dumps
	DD	imagerel pickle_dumps+298
	DD	imagerel $unwind$pickle_dumps
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pickle_dumps DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0L@PLMAGPOP@O?$HMOO?3dumps?$AA@
CONST	SEGMENT
??_C@_0L@PLMAGPOP@O?$HMOO?3dumps?$AA@ DB 'O|OO:dumps', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@IGIBAAHF@pickle?4dumps?$CI?$CJ?5takes?5at?5most?52?5p@
CONST	SEGMENT
??_C@_0DP@IGIBAAHF@pickle?4dumps?$CI?$CJ?5takes?5at?5most?52?5p@ DB 'pick'
	DB	'le.dumps() takes at most 2 positional argument (%zd given)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT pickle_dumps
_TEXT	SEGMENT
fix_imports$ = 64
proto$ = 72
result$ = 80
obj$ = 88
pickler$ = 96
self$ = 128
args$ = 136
kwds$ = 144
pickle_dumps PROC					; COMDAT

; 6173 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 6174 :     static char *kwlist[] = {"obj", "protocol", "fix_imports", 0};
; 6175 :     PyObject *obj;
; 6176 :     PyObject *proto = NULL;

  00013	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR proto$[rsp], 0

; 6177 :     PyObject *result;
; 6178 :     PyObject *fix_imports = Py_True;

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00023	48 89 44 24 40	 mov	 QWORD PTR fix_imports$[rsp], rax

; 6179 :     PicklerObject *pickler;
; 6180 : 
; 6181 :     /* fix_imports is a keyword-only argument.  */
; 6182 :     if (Py_SIZE(args) > 2) {

  00028	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00030	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  00035	7e 26		 jle	 SHORT $LN9@pickle_dum@2

; 6183 :         PyErr_Format(PyExc_TypeError,
; 6184 :                      "pickle.dumps() takes at most 2 positional "
; 6185 :                      "argument (%zd given)", Py_SIZE(args));

  00037	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  0003f	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@IGIBAAHF@pickle?4dumps?$CI?$CJ?5takes?5at?5most?52?5p@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00051	e8 00 00 00 00	 call	 PyErr_Format

; 6186 :         return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	e9 c8 00 00 00	 jmp	 $LN10@pickle_dum@2
$LN9@pickle_dum@2:

; 6187 :     }
; 6188 : 
; 6189 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:dumps", kwlist,
; 6190 :                                      &obj, &proto, &fix_imports))

  0005d	48 8d 44 24 40	 lea	 rax, QWORD PTR fix_imports$[rsp]
  00062	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00067	48 8d 44 24 48	 lea	 rax, QWORD PTR proto$[rsp]
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	48 8d 44 24 58	 lea	 rax, QWORD PTR obj$[rsp]
  00076	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pickle_dumps@@9@9
  00082	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@PLMAGPOP@O?$HMOO?3dumps?$AA@
  00089	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00091	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00099	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0009e	85 c0		 test	 eax, eax
  000a0	75 04		 jne	 SHORT $LN8@pickle_dum@2

; 6191 :         return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	eb 7f		 jmp	 SHORT $LN10@pickle_dum@2
$LN8@pickle_dum@2:

; 6192 : 
; 6193 :     pickler = _Pickler_New();

  000a6	e8 00 00 00 00	 call	 _Pickler_New
  000ab	48 89 44 24 60	 mov	 QWORD PTR pickler$[rsp], rax

; 6194 :     if (pickler == NULL)

  000b0	48 83 7c 24 60
	00		 cmp	 QWORD PTR pickler$[rsp], 0
  000b6	75 04		 jne	 SHORT $LN7@pickle_dum@2

; 6195 :         return NULL;

  000b8	33 c0		 xor	 eax, eax
  000ba	eb 69		 jmp	 SHORT $LN10@pickle_dum@2
$LN7@pickle_dum@2:

; 6196 : 
; 6197 :     if (_Pickler_SetProtocol(pickler, proto, fix_imports) < 0)

  000bc	4c 8b 44 24 40	 mov	 r8, QWORD PTR fix_imports$[rsp]
  000c1	48 8b 54 24 48	 mov	 rdx, QWORD PTR proto$[rsp]
  000c6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  000cb	e8 00 00 00 00	 call	 _Pickler_SetProtocol
  000d0	85 c0		 test	 eax, eax
  000d2	7d 02		 jge	 SHORT $LN6@pickle_dum@2

; 6198 :         goto error;

  000d4	eb 35		 jmp	 SHORT $error$25092
$LN6@pickle_dum@2:

; 6199 : 
; 6200 :     if (dump(pickler, obj) < 0)

  000d6	48 8b 54 24 58	 mov	 rdx, QWORD PTR obj$[rsp]
  000db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  000e0	e8 00 00 00 00	 call	 dump
  000e5	85 c0		 test	 eax, eax
  000e7	7d 02		 jge	 SHORT $LN5@pickle_dum@2

; 6201 :         goto error;

  000e9	eb 20		 jmp	 SHORT $error$25092
$LN5@pickle_dum@2:

; 6202 : 
; 6203 :     result = _Pickler_GetString(pickler);

  000eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  000f0	e8 00 00 00 00	 call	 _Pickler_GetString
  000f5	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 6204 :     Py_DECREF(pickler);

  000fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  000ff	e8 00 00 00 00	 call	 _Py_DecRef

; 6205 :     return result;

  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  00109	eb 1a		 jmp	 SHORT $LN10@pickle_dum@2
$error$25092:
$LN4@pickle_dum@2:

; 6206 : 
; 6207 :   error:
; 6208 :     Py_XDECREF(pickler);

  0010b	48 83 7c 24 60
	00		 cmp	 QWORD PTR pickler$[rsp], 0
  00111	74 0a		 je	 SHORT $LN1@pickle_dum@2
  00113	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pickler$[rsp]
  00118	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@pickle_dum@2:
  0011d	33 c0		 xor	 eax, eax
  0011f	85 c0		 test	 eax, eax
  00121	75 e8		 jne	 SHORT $LN4@pickle_dum@2

; 6209 :     return NULL;

  00123	33 c0		 xor	 eax, eax
$LN10@pickle_dum@2:

; 6210 : }

  00125	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00129	c3		 ret	 0
pickle_dumps ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BBCLAAFJ@O?$HMOss?3load?$AA@		; `string'
PUBLIC	??_C@_0EA@PAKCFPIA@pickle?4load?$CI?$CJ?5takes?5exactly?5one?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pickle_load DD imagerel pickle_load
	DD	imagerel pickle_load+360
	DD	imagerel $unwind$pickle_load
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pickle_load DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0L@BBCLAAFJ@O?$HMOss?3load?$AA@
CONST	SEGMENT
??_C@_0L@BBCLAAFJ@O?$HMOss?3load?$AA@ DB 'O|Oss:load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@PAKCFPIA@pickle?4load?$CI?$CJ?5takes?5exactly?5one?5@
CONST	SEGMENT
??_C@_0EA@PAKCFPIA@pickle?4load?$CI?$CJ?5takes?5exactly?5one?5@ DB 'pickl'
	DB	'e.load() takes exactly one positional argument (%zd given)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT pickle_load
_TEXT	SEGMENT
fix_imports$ = 64
errors$ = 72
file$ = 80
encoding$ = 88
result$ = 96
unpickler$ = 104
self$ = 128
args$ = 136
kwds$ = 144
pickle_load PROC					; COMDAT

; 6238 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 6239 :     static char *kwlist[] = {"file", "fix_imports", "encoding", "errors", 0};
; 6240 :     PyObject *file;
; 6241 :     PyObject *fix_imports = Py_True;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0001a	48 89 44 24 40	 mov	 QWORD PTR fix_imports$[rsp], rax

; 6242 :     PyObject *result;
; 6243 :     char *encoding = NULL;

  0001f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR encoding$[rsp], 0

; 6244 :     char *errors = NULL;

  00028	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR errors$[rsp], 0

; 6245 :     UnpicklerObject *unpickler;
; 6246 : 
; 6247 :     /* fix_imports, encoding and errors are a keyword-only argument.  */
; 6248 :     if (Py_SIZE(args) != 1) {

  00031	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00039	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  0003e	74 26		 je	 SHORT $LN10@pickle_loa

; 6249 :         PyErr_Format(PyExc_TypeError,
; 6250 :                      "pickle.load() takes exactly one positional "
; 6251 :                      "argument (%zd given)", Py_SIZE(args));

  00040	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00048	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@PAKCFPIA@pickle?4load?$CI?$CJ?5takes?5exactly?5one?5@
  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0005a	e8 00 00 00 00	 call	 PyErr_Format

; 6252 :         return NULL;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 fd 00 00 00	 jmp	 $LN11@pickle_loa
$LN10@pickle_loa:

; 6253 :     }
; 6254 : 
; 6255 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|Oss:load", kwlist,
; 6256 :                                      &file, &fix_imports, &encoding, &errors))

  00066	48 8d 44 24 48	 lea	 rax, QWORD PTR errors$[rsp]
  0006b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00070	48 8d 44 24 58	 lea	 rax, QWORD PTR encoding$[rsp]
  00075	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0007a	48 8d 44 24 40	 lea	 rax, QWORD PTR fix_imports$[rsp]
  0007f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00084	48 8d 44 24 50	 lea	 rax, QWORD PTR file$[rsp]
  00089	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pickle_load@@9@9
  00095	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@BBCLAAFJ@O?$HMOss?3load?$AA@
  0009c	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  000a4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000ac	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000b1	85 c0		 test	 eax, eax
  000b3	75 07		 jne	 SHORT $LN9@pickle_loa

; 6257 :         return NULL;

  000b5	33 c0		 xor	 eax, eax
  000b7	e9 a7 00 00 00	 jmp	 $LN11@pickle_loa
$LN9@pickle_loa:

; 6258 : 
; 6259 :     unpickler = _Unpickler_New();

  000bc	e8 00 00 00 00	 call	 _Unpickler_New
  000c1	48 89 44 24 68	 mov	 QWORD PTR unpickler$[rsp], rax

; 6260 :     if (unpickler == NULL)

  000c6	48 83 7c 24 68
	00		 cmp	 QWORD PTR unpickler$[rsp], 0
  000cc	75 07		 jne	 SHORT $LN8@pickle_loa

; 6261 :         return NULL;

  000ce	33 c0		 xor	 eax, eax
  000d0	e9 8e 00 00 00	 jmp	 $LN11@pickle_loa
$LN8@pickle_loa:

; 6262 : 
; 6263 :     if (_Unpickler_SetInputStream(unpickler, file) < 0)

  000d5	48 8b 54 24 50	 mov	 rdx, QWORD PTR file$[rsp]
  000da	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  000df	e8 00 00 00 00	 call	 _Unpickler_SetInputStream
  000e4	85 c0		 test	 eax, eax
  000e6	7d 02		 jge	 SHORT $LN7@pickle_loa

; 6264 :         goto error;

  000e8	eb 5f		 jmp	 SHORT $error$25133
$LN7@pickle_loa:

; 6265 : 
; 6266 :     if (_Unpickler_SetInputEncoding(unpickler, encoding, errors) < 0)

  000ea	4c 8b 44 24 48	 mov	 r8, QWORD PTR errors$[rsp]
  000ef	48 8b 54 24 58	 mov	 rdx, QWORD PTR encoding$[rsp]
  000f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  000f9	e8 00 00 00 00	 call	 _Unpickler_SetInputEncoding
  000fe	85 c0		 test	 eax, eax
  00100	7d 02		 jge	 SHORT $LN6@pickle_loa

; 6267 :         goto error;

  00102	eb 45		 jmp	 SHORT $error$25133
$LN6@pickle_loa:

; 6268 : 
; 6269 :     unpickler->fix_imports = PyObject_IsTrue(fix_imports);

  00104	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fix_imports$[rsp]
  00109	e8 00 00 00 00	 call	 PyObject_IsTrue
  0010e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  00113	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax

; 6270 :     if (unpickler->fix_imports == -1)

  00119	48 8b 44 24 68	 mov	 rax, QWORD PTR unpickler$[rsp]
  0011e	83 b8 44 01 00
	00 ff		 cmp	 DWORD PTR [rax+324], -1
  00125	75 02		 jne	 SHORT $LN5@pickle_loa

; 6271 :         goto error;

  00127	eb 20		 jmp	 SHORT $error$25133
$LN5@pickle_loa:

; 6272 : 
; 6273 :     result = load(unpickler);

  00129	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  0012e	e8 00 00 00 00	 call	 load
  00133	48 89 44 24 60	 mov	 QWORD PTR result$[rsp], rax

; 6274 :     Py_DECREF(unpickler);

  00138	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  0013d	e8 00 00 00 00	 call	 _Py_DecRef

; 6275 :     return result;

  00142	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
  00147	eb 1a		 jmp	 SHORT $LN11@pickle_loa
$error$25133:
$LN4@pickle_loa:

; 6276 : 
; 6277 :   error:
; 6278 :     Py_XDECREF(unpickler);

  00149	48 83 7c 24 68
	00		 cmp	 QWORD PTR unpickler$[rsp], 0
  0014f	74 0a		 je	 SHORT $LN1@pickle_loa
  00151	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  00156	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@pickle_loa:
  0015b	33 c0		 xor	 eax, eax
  0015d	85 c0		 test	 eax, eax
  0015f	75 e8		 jne	 SHORT $LN4@pickle_loa

; 6279 :     return NULL;

  00161	33 c0		 xor	 eax, eax
$LN11@pickle_loa:

; 6280 : }

  00163	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00167	c3		 ret	 0
pickle_load ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_New DD imagerel _Unpickler_New
	DD	imagerel _Unpickler_New+486
	DD	imagerel $unwind$_Unpickler_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_New DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Unpickler_New
_TEXT	SEGMENT
self$ = 32
tv70 = 40
_Unpickler_New PROC					; COMDAT

; 1132 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1133 :     UnpicklerObject *self;
; 1134 : 
; 1135 :     self = PyObject_GC_New(UnpicklerObject, &Unpickler_Type);

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 13		 je	 SHORT $LN6@Unpickler_@24
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Unpickler_Type
  00014	e8 00 00 00 00	 call	 _PxObject_New
  00019	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  0001e	eb 11		 jmp	 SHORT $LN7@Unpickler_@24
$LN6@Unpickler_@24:
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Unpickler_Type
  00027	e8 00 00 00 00	 call	 _PyObject_GC_New
  0002c	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN7@Unpickler_@24:
  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  00036	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 1136 :     if (self == NULL)

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00041	75 07		 jne	 SHORT $LN3@Unpickler_@24

; 1137 :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 97 01 00 00	 jmp	 $LN4@Unpickler_@24
$LN3@Unpickler_@24:

; 1138 : 
; 1139 :     self->stack = (Pdata *)Pdata_New();

  0004a	e8 00 00 00 00	 call	 Pdata_New
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00054	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1140 :     if (self->stack == NULL) {

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0005d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00062	75 11		 jne	 SHORT $LN2@Unpickler_@24

; 1141 :         Py_DECREF(self);

  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00069	e8 00 00 00 00	 call	 _Py_DecRef

; 1142 :         return NULL;

  0006e	33 c0		 xor	 eax, eax
  00070	e9 6c 01 00 00	 jmp	 $LN4@Unpickler_@24
$LN2@Unpickler_@24:

; 1143 :     }
; 1144 :     memset(&self->buffer, 0, sizeof(Py_buffer));

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0007a	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00080	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00086	33 d2		 xor	 edx, edx
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 memset

; 1145 : 
; 1146 :     self->memo_size = 32;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00095	48 c7 40 70 20
	00 00 00	 mov	 QWORD PTR [rax+112], 32	; 00000020H

; 1147 :     self->memo = _Unpickler_NewMemo(self->memo_size);

  0009d	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000a2	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000a6	e8 00 00 00 00	 call	 _Unpickler_NewMemo
  000ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  000b0	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 1148 :     if (self->memo == NULL) {

  000b4	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000b9	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000be	75 11		 jne	 SHORT $LN1@Unpickler_@24

; 1149 :         Py_DECREF(self);

  000c0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  000c5	e8 00 00 00 00	 call	 _Py_DecRef

; 1150 :         return NULL;

  000ca	33 c0		 xor	 eax, eax
  000cc	e9 10 01 00 00	 jmp	 $LN4@Unpickler_@24
$LN1@Unpickler_@24:

; 1151 :     }
; 1152 : 
; 1153 :     self->arg = NULL;

  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000d6	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 1154 :     self->pers_func = NULL;

  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000e3	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 1155 :     self->input_buffer = NULL;

  000ee	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000f3	48 c7 80 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+216], 0

; 1156 :     self->input_line = NULL;

  000fe	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00103	48 c7 80 e0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+224], 0

; 1157 :     self->input_len = 0;

  0010e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00113	48 c7 80 e8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+232], 0

; 1158 :     self->next_read_idx = 0;

  0011e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00123	48 c7 80 f0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+240], 0

; 1159 :     self->prefetched_idx = 0;

  0012e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00133	48 c7 80 f8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+248], 0

; 1160 :     self->read = NULL;

  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00143	48 c7 80 00 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+256], 0

; 1161 :     self->readline = NULL;

  0014e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00153	48 c7 80 08 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+264], 0

; 1162 :     self->peek = NULL;

  0015e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00163	48 c7 80 10 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+272], 0

; 1163 :     self->encoding = NULL;

  0016e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00173	48 c7 80 18 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+280], 0

; 1164 :     self->errors = NULL;

  0017e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00183	48 c7 80 20 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+288], 0

; 1165 :     self->marks = NULL;

  0018e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00193	48 c7 80 28 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+296], 0

; 1166 :     self->num_marks = 0;

  0019e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  001a3	48 c7 80 30 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+304], 0

; 1167 :     self->marks_size = 0;

  001ae	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  001b3	48 c7 80 38 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+312], 0

; 1168 :     self->proto = 0;

  001be	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  001c3	c7 80 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+320], 0

; 1169 :     self->fix_imports = 0;

  001cd	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  001d2	c7 80 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+324], 0

; 1170 : 
; 1171 :     return self;

  001dc	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
$LN4@Unpickler_@24:

; 1172 : }

  001e1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001e5	c3		 ret	 0
_Unpickler_New ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@BGLEOIGF@O?$HMOss?3loads?$AA@		; `string'
PUBLIC	??_C@_0EB@MCKAECFB@pickle?4loads?$CI?$CJ?5takes?5exactly?5one@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pickle_loads DD imagerel pickle_loads
	DD	imagerel pickle_loads+361
	DD	imagerel $unwind$pickle_loads
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pickle_loads DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0M@BGLEOIGF@O?$HMOss?3loads?$AA@
CONST	SEGMENT
??_C@_0M@BGLEOIGF@O?$HMOss?3loads?$AA@ DB 'O|Oss:loads', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@MCKAECFB@pickle?4loads?$CI?$CJ?5takes?5exactly?5one@
CONST	SEGMENT
??_C@_0EB@MCKAECFB@pickle?4loads?$CI?$CJ?5takes?5exactly?5one@ DB 'pickle'
	DB	'.loads() takes exactly one positional argument (%zd given)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT pickle_loads
_TEXT	SEGMENT
fix_imports$ = 64
errors$ = 72
input$ = 80
encoding$ = 88
result$ = 96
unpickler$ = 104
self$ = 128
args$ = 136
kwds$ = 144
pickle_loads PROC					; COMDAT

; 6301 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 6302 :     static char *kwlist[] = {"input", "fix_imports", "encoding", "errors", 0};
; 6303 :     PyObject *input;
; 6304 :     PyObject *fix_imports = Py_True;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0001a	48 89 44 24 40	 mov	 QWORD PTR fix_imports$[rsp], rax

; 6305 :     PyObject *result;
; 6306 :     char *encoding = NULL;

  0001f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR encoding$[rsp], 0

; 6307 :     char *errors = NULL;

  00028	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR errors$[rsp], 0

; 6308 :     UnpicklerObject *unpickler;
; 6309 : 
; 6310 :     /* fix_imports, encoding and errors are a keyword-only argument.  */
; 6311 :     if (Py_SIZE(args) != 1) {

  00031	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00039	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  0003e	74 26		 je	 SHORT $LN10@pickle_loa@2

; 6312 :         PyErr_Format(PyExc_TypeError,
; 6313 :                      "pickle.loads() takes exactly one positional "
; 6314 :                      "argument (%zd given)", Py_SIZE(args));

  00040	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00048	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@MCKAECFB@pickle?4loads?$CI?$CJ?5takes?5exactly?5one@
  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0005a	e8 00 00 00 00	 call	 PyErr_Format

; 6315 :         return NULL;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 fe 00 00 00	 jmp	 $LN11@pickle_loa@2
$LN10@pickle_loa@2:

; 6316 :     }
; 6317 : 
; 6318 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|Oss:loads", kwlist,
; 6319 :                                      &input, &fix_imports, &encoding, &errors))

  00066	48 8d 44 24 48	 lea	 rax, QWORD PTR errors$[rsp]
  0006b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00070	48 8d 44 24 58	 lea	 rax, QWORD PTR encoding$[rsp]
  00075	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0007a	48 8d 44 24 40	 lea	 rax, QWORD PTR fix_imports$[rsp]
  0007f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00084	48 8d 44 24 50	 lea	 rax, QWORD PTR input$[rsp]
  00089	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pickle_loads@@9@9
  00095	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@BGLEOIGF@O?$HMOss?3loads?$AA@
  0009c	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  000a4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000ac	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000b1	85 c0		 test	 eax, eax
  000b3	75 07		 jne	 SHORT $LN9@pickle_loa@2

; 6320 :         return NULL;

  000b5	33 c0		 xor	 eax, eax
  000b7	e9 a8 00 00 00	 jmp	 $LN11@pickle_loa@2
$LN9@pickle_loa@2:

; 6321 : 
; 6322 :     unpickler = _Unpickler_New();

  000bc	e8 00 00 00 00	 call	 _Unpickler_New
  000c1	48 89 44 24 68	 mov	 QWORD PTR unpickler$[rsp], rax

; 6323 :     if (unpickler == NULL)

  000c6	48 83 7c 24 68
	00		 cmp	 QWORD PTR unpickler$[rsp], 0
  000cc	75 07		 jne	 SHORT $LN8@pickle_loa@2

; 6324 :         return NULL;

  000ce	33 c0		 xor	 eax, eax
  000d0	e9 8f 00 00 00	 jmp	 $LN11@pickle_loa@2
$LN8@pickle_loa@2:

; 6325 : 
; 6326 :     if (_Unpickler_SetStringInput(unpickler, input) < 0)

  000d5	48 8b 54 24 50	 mov	 rdx, QWORD PTR input$[rsp]
  000da	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  000df	e8 00 00 00 00	 call	 _Unpickler_SetStringInput
  000e4	48 85 c0	 test	 rax, rax
  000e7	7d 02		 jge	 SHORT $LN7@pickle_loa@2

; 6327 :         goto error;

  000e9	eb 5f		 jmp	 SHORT $error$25176
$LN7@pickle_loa@2:

; 6328 : 
; 6329 :     if (_Unpickler_SetInputEncoding(unpickler, encoding, errors) < 0)

  000eb	4c 8b 44 24 48	 mov	 r8, QWORD PTR errors$[rsp]
  000f0	48 8b 54 24 58	 mov	 rdx, QWORD PTR encoding$[rsp]
  000f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  000fa	e8 00 00 00 00	 call	 _Unpickler_SetInputEncoding
  000ff	85 c0		 test	 eax, eax
  00101	7d 02		 jge	 SHORT $LN6@pickle_loa@2

; 6330 :         goto error;

  00103	eb 45		 jmp	 SHORT $error$25176
$LN6@pickle_loa@2:

; 6331 : 
; 6332 :     unpickler->fix_imports = PyObject_IsTrue(fix_imports);

  00105	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fix_imports$[rsp]
  0010a	e8 00 00 00 00	 call	 PyObject_IsTrue
  0010f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  00114	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax

; 6333 :     if (unpickler->fix_imports == -1)

  0011a	48 8b 44 24 68	 mov	 rax, QWORD PTR unpickler$[rsp]
  0011f	83 b8 44 01 00
	00 ff		 cmp	 DWORD PTR [rax+324], -1
  00126	75 02		 jne	 SHORT $LN5@pickle_loa@2

; 6334 :         goto error;

  00128	eb 20		 jmp	 SHORT $error$25176
$LN5@pickle_loa@2:

; 6335 : 
; 6336 :     result = load(unpickler);

  0012a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  0012f	e8 00 00 00 00	 call	 load
  00134	48 89 44 24 60	 mov	 QWORD PTR result$[rsp], rax

; 6337 :     Py_DECREF(unpickler);

  00139	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  0013e	e8 00 00 00 00	 call	 _Py_DecRef

; 6338 :     return result;

  00143	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
  00148	eb 1a		 jmp	 SHORT $LN11@pickle_loa@2
$error$25176:
$LN4@pickle_loa@2:

; 6339 : 
; 6340 :   error:
; 6341 :     Py_XDECREF(unpickler);

  0014a	48 83 7c 24 68
	00		 cmp	 QWORD PTR unpickler$[rsp], 0
  00150	74 0a		 je	 SHORT $LN1@pickle_loa@2
  00152	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unpickler$[rsp]
  00157	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@pickle_loa@2:
  0015c	33 c0		 xor	 eax, eax
  0015e	85 c0		 test	 eax, eax
  00160	75 e8		 jne	 SHORT $LN4@pickle_loa@2

; 6342 :     return NULL;

  00162	33 c0		 xor	 eax, eax
$LN11@pickle_loa@2:

; 6343 : }

  00164	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00168	c3		 ret	 0
pickle_loads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@LCGBPENE@UnpicklingError?$AA@		; `string'
PUBLIC	??_C@_0O@FPEIPGHK@PicklingError?$AA@		; `string'
PUBLIC	??_C@_0M@GKNHGKJD@PickleError?$AA@		; `string'
PUBLIC	??_C@_0BI@EPOMPDOP@_pickle?4UnpicklingError?$AA@ ; `string'
PUBLIC	??_C@_0BG@HEBJMGDJ@_pickle?4PicklingError?$AA@	; `string'
PUBLIC	??_C@_0BE@NFLINNFO@_pickle?4PickleError?$AA@	; `string'
PUBLIC	??_C@_09CHPAHJLJ@Unpickler?$AA@			; `string'
PUBLIC	??_C@_07JDLCLLMK@Pickler?$AA@			; `string'
PUBLIC	PyInit__pickle
EXTRN	PyErr_NewException:PROC
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__pickle DD imagerel $LN18
	DD	imagerel $LN18+499
	DD	imagerel $unwind$PyInit__pickle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__pickle DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BA@LCGBPENE@UnpicklingError?$AA@
CONST	SEGMENT
??_C@_0BA@LCGBPENE@UnpicklingError?$AA@ DB 'UnpicklingError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPEIPGHK@PicklingError?$AA@
CONST	SEGMENT
??_C@_0O@FPEIPGHK@PicklingError?$AA@ DB 'PicklingError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GKNHGKJD@PickleError?$AA@
CONST	SEGMENT
??_C@_0M@GKNHGKJD@PickleError?$AA@ DB 'PickleError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EPOMPDOP@_pickle?4UnpicklingError?$AA@
CONST	SEGMENT
??_C@_0BI@EPOMPDOP@_pickle?4UnpicklingError?$AA@ DB '_pickle.UnpicklingEr'
	DB	'ror', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HEBJMGDJ@_pickle?4PicklingError?$AA@
CONST	SEGMENT
??_C@_0BG@HEBJMGDJ@_pickle?4PicklingError?$AA@ DB '_pickle.PicklingError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NFLINNFO@_pickle?4PickleError?$AA@
CONST	SEGMENT
??_C@_0BE@NFLINNFO@_pickle?4PickleError?$AA@ DB '_pickle.PickleError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CHPAHJLJ@Unpickler?$AA@
CONST	SEGMENT
??_C@_09CHPAHJLJ@Unpickler?$AA@ DB 'Unpickler', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JDLCLLMK@Pickler?$AA@
CONST	SEGMENT
??_C@_07JDLCLLMK@Pickler?$AA@ DB 'Pickler', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit__pickle
_TEXT	SEGMENT
m$ = 32
PyInit__pickle PROC					; COMDAT

; 6476 : {

$LN18:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6477 :     PyObject *m;
; 6478 : 
; 6479 :     if (PyType_Ready(&Unpickler_Type) < 0)

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Unpickler_Type
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	7d 07		 jge	 SHORT $LN15@PyInit__pi

; 6480 :         return NULL;

  00014	33 c0		 xor	 eax, eax
  00016	e9 d3 01 00 00	 jmp	 $LN16@PyInit__pi
$LN15@PyInit__pi:

; 6481 :     if (PyType_Ready(&Pickler_Type) < 0)

  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pickler_Type
  00022	e8 00 00 00 00	 call	 PyType_Ready
  00027	85 c0		 test	 eax, eax
  00029	7d 07		 jge	 SHORT $LN14@PyInit__pi

; 6482 :         return NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 bc 01 00 00	 jmp	 $LN16@PyInit__pi
$LN14@PyInit__pi:

; 6483 :     if (PyType_Ready(&Pdata_Type) < 0)

  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pdata_Type
  00039	e8 00 00 00 00	 call	 PyType_Ready
  0003e	85 c0		 test	 eax, eax
  00040	7d 07		 jge	 SHORT $LN13@PyInit__pi

; 6484 :         return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	e9 a5 01 00 00	 jmp	 $LN16@PyInit__pi
$LN13@PyInit__pi:

; 6485 :     if (PyType_Ready(&PicklerMemoProxyType) < 0)

  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PicklerMemoProxyType
  00050	e8 00 00 00 00	 call	 PyType_Ready
  00055	85 c0		 test	 eax, eax
  00057	7d 07		 jge	 SHORT $LN12@PyInit__pi

; 6486 :         return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 8e 01 00 00	 jmp	 $LN16@PyInit__pi
$LN12@PyInit__pi:

; 6487 :     if (PyType_Ready(&UnpicklerMemoProxyType) < 0)

  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UnpicklerMemoProxyType
  00067	e8 00 00 00 00	 call	 PyType_Ready
  0006c	85 c0		 test	 eax, eax
  0006e	7d 07		 jge	 SHORT $LN11@PyInit__pi

; 6488 :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	e9 77 01 00 00	 jmp	 $LN16@PyInit__pi
$LN11@PyInit__pi:

; 6489 : 
; 6490 :     /* Create the module and add the functions. */
; 6491 :     m = PyModule_Create(&_picklemodule);

  00077	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_picklemodule
  00083	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00088	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 6492 :     if (m == NULL)

  0008d	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00093	75 07		 jne	 SHORT $LN10@PyInit__pi

; 6493 :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	e9 52 01 00 00	 jmp	 $LN16@PyInit__pi
$LN10@PyInit__pi:

; 6494 : 
; 6495 :     Py_INCREF(&Pickler_Type);

  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pickler_Type
  000a3	e8 00 00 00 00	 call	 _Py_IncRef

; 6496 :     if (PyModule_AddObject(m, "Pickler", (PyObject *)&Pickler_Type) < 0)

  000a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Pickler_Type
  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07JDLCLLMK@Pickler?$AA@
  000b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  000bb	e8 00 00 00 00	 call	 PyModule_AddObject
  000c0	85 c0		 test	 eax, eax
  000c2	7d 07		 jge	 SHORT $LN9@PyInit__pi

; 6497 :         return NULL;

  000c4	33 c0		 xor	 eax, eax
  000c6	e9 23 01 00 00	 jmp	 $LN16@PyInit__pi
$LN9@PyInit__pi:

; 6498 :     Py_INCREF(&Unpickler_Type);

  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Unpickler_Type
  000d2	e8 00 00 00 00	 call	 _Py_IncRef

; 6499 :     if (PyModule_AddObject(m, "Unpickler", (PyObject *)&Unpickler_Type) < 0)

  000d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Unpickler_Type
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09CHPAHJLJ@Unpickler?$AA@
  000e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  000ea	e8 00 00 00 00	 call	 PyModule_AddObject
  000ef	85 c0		 test	 eax, eax
  000f1	7d 07		 jge	 SHORT $LN8@PyInit__pi

; 6500 :         return NULL;

  000f3	33 c0		 xor	 eax, eax
  000f5	e9 f4 00 00 00	 jmp	 $LN16@PyInit__pi
$LN8@PyInit__pi:

; 6501 : 
; 6502 :     /* Initialize the exceptions. */
; 6503 :     PickleError = PyErr_NewException("_pickle.PickleError", NULL, NULL);

  000fa	45 33 c0	 xor	 r8d, r8d
  000fd	33 d2		 xor	 edx, edx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@NFLINNFO@_pickle?4PickleError?$AA@
  00106	e8 00 00 00 00	 call	 PyErr_NewException
  0010b	48 89 05 00 00
	00 00		 mov	 QWORD PTR PickleError, rax

; 6504 :     if (PickleError == NULL)

  00112	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR PickleError, 0
  0011a	75 07		 jne	 SHORT $LN7@PyInit__pi

; 6505 :         return NULL;

  0011c	33 c0		 xor	 eax, eax
  0011e	e9 cb 00 00 00	 jmp	 $LN16@PyInit__pi
$LN7@PyInit__pi:

; 6506 :     PicklingError = \
; 6507 :         PyErr_NewException("_pickle.PicklingError", PickleError, NULL);

  00123	45 33 c0	 xor	 r8d, r8d
  00126	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PickleError
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@HEBJMGDJ@_pickle?4PicklingError?$AA@
  00134	e8 00 00 00 00	 call	 PyErr_NewException
  00139	48 89 05 00 00
	00 00		 mov	 QWORD PTR PicklingError, rax

; 6508 :     if (PicklingError == NULL)

  00140	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR PicklingError, 0
  00148	75 07		 jne	 SHORT $LN6@PyInit__pi

; 6509 :         return NULL;

  0014a	33 c0		 xor	 eax, eax
  0014c	e9 9d 00 00 00	 jmp	 $LN16@PyInit__pi
$LN6@PyInit__pi:

; 6510 :     UnpicklingError = \
; 6511 :         PyErr_NewException("_pickle.UnpicklingError", PickleError, NULL);

  00151	45 33 c0	 xor	 r8d, r8d
  00154	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PickleError
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EPOMPDOP@_pickle?4UnpicklingError?$AA@
  00162	e8 00 00 00 00	 call	 PyErr_NewException
  00167	48 89 05 00 00
	00 00		 mov	 QWORD PTR UnpicklingError, rax

; 6512 :     if (UnpicklingError == NULL)

  0016e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR UnpicklingError, 0
  00176	75 04		 jne	 SHORT $LN5@PyInit__pi

; 6513 :         return NULL;

  00178	33 c0		 xor	 eax, eax
  0017a	eb 72		 jmp	 SHORT $LN16@PyInit__pi
$LN5@PyInit__pi:

; 6514 : 
; 6515 :     if (PyModule_AddObject(m, "PickleError", PickleError) < 0)

  0017c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PickleError
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GKNHGKJD@PickleError?$AA@
  0018a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  0018f	e8 00 00 00 00	 call	 PyModule_AddObject
  00194	85 c0		 test	 eax, eax
  00196	7d 04		 jge	 SHORT $LN4@PyInit__pi

; 6516 :         return NULL;

  00198	33 c0		 xor	 eax, eax
  0019a	eb 52		 jmp	 SHORT $LN16@PyInit__pi
$LN4@PyInit__pi:

; 6517 :     if (PyModule_AddObject(m, "PicklingError", PicklingError) < 0)

  0019c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PicklingError
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@FPEIPGHK@PicklingError?$AA@
  001aa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  001af	e8 00 00 00 00	 call	 PyModule_AddObject
  001b4	85 c0		 test	 eax, eax
  001b6	7d 04		 jge	 SHORT $LN3@PyInit__pi

; 6518 :         return NULL;

  001b8	33 c0		 xor	 eax, eax
  001ba	eb 32		 jmp	 SHORT $LN16@PyInit__pi
$LN3@PyInit__pi:

; 6519 :     if (PyModule_AddObject(m, "UnpicklingError", UnpicklingError) < 0)

  001bc	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR UnpicklingError
  001c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@LCGBPENE@UnpicklingError?$AA@
  001ca	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  001cf	e8 00 00 00 00	 call	 PyModule_AddObject
  001d4	85 c0		 test	 eax, eax
  001d6	7d 04		 jge	 SHORT $LN2@PyInit__pi

; 6520 :         return NULL;

  001d8	33 c0		 xor	 eax, eax
  001da	eb 12		 jmp	 SHORT $LN16@PyInit__pi
$LN2@PyInit__pi:

; 6521 : 
; 6522 :     if (initmodule() < 0)

  001dc	e8 00 00 00 00	 call	 initmodule
  001e1	85 c0		 test	 eax, eax
  001e3	7d 04		 jge	 SHORT $LN1@PyInit__pi

; 6523 :         return NULL;

  001e5	33 c0		 xor	 eax, eax
  001e7	eb 05		 jmp	 SHORT $LN16@PyInit__pi
$LN1@PyInit__pi:

; 6524 : 
; 6525 :     return m;

  001e9	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
$LN16@PyInit__pi:

; 6526 : }

  001ee	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001f2	c3		 ret	 0
PyInit__pickle ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@DMHCPNOG@_compat_pickle?4REVERSE_IMPORT_MA@ ; `string'
PUBLIC	??_C@_0BH@HCNJFHFO@REVERSE_IMPORT_MAPPING?$AA@	; `string'
PUBLIC	??_C@_0EB@EGJAAION@_compat_pickle?4REVERSE_NAME_MAPP@ ; `string'
PUBLIC	??_C@_0BF@PCKAADLD@REVERSE_NAME_MAPPING?$AA@	; `string'
PUBLIC	??_C@_0DL@IBPPHGMJ@_compat_pickle?4IMPORT_MAPPING?5sh@ ; `string'
PUBLIC	??_C@_0P@FDAEMEFC@IMPORT_MAPPING?$AA@		; `string'
PUBLIC	??_C@_0DJ@IKFMBBAC@_compat_pickle?4NAME_MAPPING?5shou@ ; `string'
PUBLIC	??_C@_0N@JDNLMJCA@NAME_MAPPING?$AA@		; `string'
PUBLIC	??_C@_0P@NENAADEG@_compat_pickle?$AA@		; `string'
PUBLIC	??_C@_0L@NCMCMGNH@initmodule?$AA@		; `string'
PUBLIC	??_C@_0BB@JFMPGNNF@_extension_cache?$AA@	; `string'
PUBLIC	??_C@_0BD@FFNJNBHB@_inverted_registry?$AA@	; `string'
PUBLIC	??_C@_0BE@PCFNLJJD@_extension_registry?$AA@	; `string'
PUBLIC	??_C@_07ODDBKIAB@copyreg?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$initmodule DD imagerel initmodule
	DD	imagerel initmodule+2106
	DD	imagerel $unwind$initmodule
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$initmodule DD 020701H
	DD	0170107H
xdata	ENDS
;	COMDAT ??_C@_0ED@DMHCPNOG@_compat_pickle?4REVERSE_IMPORT_MA@
CONST	SEGMENT
??_C@_0ED@DMHCPNOG@_compat_pickle?4REVERSE_IMPORT_MA@ DB '_compat_pickle.'
	DB	'REVERSE_IMPORT_MAPPING should be a dict, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HCNJFHFO@REVERSE_IMPORT_MAPPING?$AA@
CONST	SEGMENT
??_C@_0BH@HCNJFHFO@REVERSE_IMPORT_MAPPING?$AA@ DB 'REVERSE_IMPORT_MAPPING'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@EGJAAION@_compat_pickle?4REVERSE_NAME_MAPP@
CONST	SEGMENT
??_C@_0EB@EGJAAION@_compat_pickle?4REVERSE_NAME_MAPP@ DB '_compat_pickle.'
	DB	'REVERSE_NAME_MAPPING should be a dict, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PCKAADLD@REVERSE_NAME_MAPPING?$AA@
CONST	SEGMENT
??_C@_0BF@PCKAADLD@REVERSE_NAME_MAPPING?$AA@ DB 'REVERSE_NAME_MAPPING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@IBPPHGMJ@_compat_pickle?4IMPORT_MAPPING?5sh@
CONST	SEGMENT
??_C@_0DL@IBPPHGMJ@_compat_pickle?4IMPORT_MAPPING?5sh@ DB '_compat_pickle'
	DB	'.IMPORT_MAPPING should be a dict, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FDAEMEFC@IMPORT_MAPPING?$AA@
CONST	SEGMENT
??_C@_0P@FDAEMEFC@IMPORT_MAPPING?$AA@ DB 'IMPORT_MAPPING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@IKFMBBAC@_compat_pickle?4NAME_MAPPING?5shou@
CONST	SEGMENT
??_C@_0DJ@IKFMBBAC@_compat_pickle?4NAME_MAPPING?5shou@ DB '_compat_pickle'
	DB	'.NAME_MAPPING should be a dict, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JDNLMJCA@NAME_MAPPING?$AA@
CONST	SEGMENT
??_C@_0N@JDNLMJCA@NAME_MAPPING?$AA@ DB 'NAME_MAPPING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NENAADEG@_compat_pickle?$AA@
CONST	SEGMENT
??_C@_0P@NENAADEG@_compat_pickle?$AA@ DB '_compat_pickle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NCMCMGNH@initmodule?$AA@
CONST	SEGMENT
??_C@_0L@NCMCMGNH@initmodule?$AA@ DB 'initmodule', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JFMPGNNF@_extension_cache?$AA@
CONST	SEGMENT
??_C@_0BB@JFMPGNNF@_extension_cache?$AA@ DB '_extension_cache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFNJNBHB@_inverted_registry?$AA@
CONST	SEGMENT
??_C@_0BD@FFNJNBHB@_inverted_registry?$AA@ DB '_inverted_registry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PCFNLJJD@_extension_registry?$AA@
CONST	SEGMENT
??_C@_0BE@PCFNLJJD@_extension_registry?$AA@ DB '_extension_registry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ODDBKIAB@copyreg?$AA@
CONST	SEGMENT
??_C@_07ODDBKIAB@copyreg?$AA@ DB 'copyreg', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT initmodule
_TEXT	SEGMENT
copyreg$ = 48
compat_pickle$ = 56
_py_tmp$25217 = 64
_py_tmp$25255 = 72
_py_tmp$25267 = 80
_py_tmp$25275 = 88
_py_tmp$25283 = 96
_py_tmp$25291 = 104
_py_tmp$25299 = 112
_py_tmp$25307 = 120
_py_tmp$25315 = 128
_py_tmp$25323 = 136
_py_tmp$25331 = 144
_py_tmp$25339 = 152
_py_tmp$25347 = 160
_py_tmp$25355 = 168
initmodule PROC						; COMDAT

; 6360 : {

  00000	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 6361 :     PyObject *copyreg = NULL;

  00007	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR copyreg$[rsp], 0

; 6362 :     PyObject *compat_pickle = NULL;

  00010	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR compat_pickle$[rsp], 0

; 6363 : 
; 6364 :     /* XXX: We should ensure that the types of the dictionaries imported are
; 6365 :        exactly PyDict objects. Otherwise, it is possible to crash the pickle
; 6366 :        since we use the PyDict API directly to access these dictionaries. */
; 6367 : 
; 6368 :     copyreg = PyImport_ImportModule("copyreg");

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07ODDBKIAB@copyreg?$AA@
  00020	e8 00 00 00 00	 call	 PyImport_ImportModule
  00025	48 89 44 24 30	 mov	 QWORD PTR copyreg$[rsp], rax

; 6369 :     if (!copyreg)

  0002a	48 83 7c 24 30
	00		 cmp	 QWORD PTR copyreg$[rsp], 0
  00030	75 05		 jne	 SHORT $LN72@initmodule

; 6370 :         goto error;

  00032	e9 86 03 00 00	 jmp	 $error$25204
$LN72@initmodule:

; 6371 :     dispatch_table = PyObject_GetAttrString(copyreg, "dispatch_table");

  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@MAJNENGA@dispatch_table?$AA@
  0003e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copyreg$[rsp]
  00043	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00048	48 89 05 00 00
	00 00		 mov	 QWORD PTR dispatch_table, rax

; 6372 :     if (!dispatch_table)

  0004f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR dispatch_table, 0
  00057	75 05		 jne	 SHORT $LN71@initmodule

; 6373 :         goto error;

  00059	e9 5f 03 00 00	 jmp	 $error$25204
$LN71@initmodule:

; 6374 :     extension_registry = \
; 6375 :         PyObject_GetAttrString(copyreg, "_extension_registry");

  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@PCFNLJJD@_extension_registry?$AA@
  00065	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copyreg$[rsp]
  0006a	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0006f	48 89 05 00 00
	00 00		 mov	 QWORD PTR extension_registry, rax

; 6376 :     if (!extension_registry)

  00076	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR extension_registry, 0
  0007e	75 05		 jne	 SHORT $LN70@initmodule

; 6377 :         goto error;

  00080	e9 38 03 00 00	 jmp	 $error$25204
$LN70@initmodule:

; 6378 :     inverted_registry = PyObject_GetAttrString(copyreg, "_inverted_registry");

  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@FFNJNBHB@_inverted_registry?$AA@
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copyreg$[rsp]
  00091	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00096	48 89 05 00 00
	00 00		 mov	 QWORD PTR inverted_registry, rax

; 6379 :     if (!inverted_registry)

  0009d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR inverted_registry, 0
  000a5	75 05		 jne	 SHORT $LN69@initmodule

; 6380 :         goto error;

  000a7	e9 11 03 00 00	 jmp	 $error$25204
$LN69@initmodule:

; 6381 :     extension_cache = PyObject_GetAttrString(copyreg, "_extension_cache");

  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@JFMPGNNF@_extension_cache?$AA@
  000b3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copyreg$[rsp]
  000b8	e8 00 00 00 00	 call	 PyObject_GetAttrString
  000bd	48 89 05 00 00
	00 00		 mov	 QWORD PTR extension_cache, rax

; 6382 :     if (!extension_cache)

  000c4	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR extension_cache, 0
  000cc	75 05		 jne	 SHORT $LN68@initmodule

; 6383 :         goto error;

  000ce	e9 ea 02 00 00	 jmp	 $error$25204
$LN68@initmodule:
$LN67@initmodule:

; 6384 :     Py_CLEAR(copyreg);

  000d3	48 83 7c 24 30
	00		 cmp	 QWORD PTR copyreg$[rsp], 0
  000d9	74 47		 je	 SHORT $LN64@initmodule
  000db	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e3	4c 8b 4c 24 30	 mov	 r9, QWORD PTR copyreg$[rsp]
  000e8	41 b8 f0 18 00
	00		 mov	 r8d, 6384		; 000018f0H
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  000fc	e8 00 00 00 00	 call	 _PyParallel_Guard
  00101	85 c0		 test	 eax, eax
  00103	75 1d		 jne	 SHORT $LN64@initmodule
  00105	48 8b 44 24 30	 mov	 rax, QWORD PTR copyreg$[rsp]
  0010a	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$25217[rsp], rax
  0010f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR copyreg$[rsp], 0
  00118	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$25217[rsp]
  0011d	e8 00 00 00 00	 call	 _Py_DecRef
$LN64@initmodule:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 ab		 jne	 SHORT $LN67@initmodule

; 6385 : 
; 6386 :     /* Load the 2.x -> 3.x stdlib module mapping tables */
; 6387 :     compat_pickle = PyImport_ImportModule("_compat_pickle");

  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@NENAADEG@_compat_pickle?$AA@
  0012f	e8 00 00 00 00	 call	 PyImport_ImportModule
  00134	48 89 44 24 38	 mov	 QWORD PTR compat_pickle$[rsp], rax

; 6388 :     if (!compat_pickle)

  00139	48 83 7c 24 38
	00		 cmp	 QWORD PTR compat_pickle$[rsp], 0
  0013f	75 05		 jne	 SHORT $LN63@initmodule

; 6389 :         goto error;

  00141	e9 77 02 00 00	 jmp	 $error$25204
$LN63@initmodule:

; 6390 :     name_mapping_2to3 = PyObject_GetAttrString(compat_pickle, "NAME_MAPPING");

  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JDNLMJCA@NAME_MAPPING?$AA@
  0014d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR compat_pickle$[rsp]
  00152	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00157	48 89 05 00 00
	00 00		 mov	 QWORD PTR name_mapping_2to3, rax

; 6391 :     if (!name_mapping_2to3)

  0015e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR name_mapping_2to3, 0
  00166	75 05		 jne	 SHORT $LN62@initmodule

; 6392 :         goto error;

  00168	e9 50 02 00 00	 jmp	 $error$25204
$LN62@initmodule:

; 6393 :     if (!PyDict_CheckExact(name_mapping_2to3)) {

  0016d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00174	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR name_mapping_2to3
  0017b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0017f	74 3b		 je	 SHORT $LN61@initmodule
  00181	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00188	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR name_mapping_2to3
  0018f	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  00193	74 27		 je	 SHORT $LN61@initmodule

; 6394 :         PyErr_Format(PyExc_RuntimeError,
; 6395 :                      "_compat_pickle.NAME_MAPPING should be a dict, not %.200s",
; 6396 :                      Py_TYPE(name_mapping_2to3)->tp_name);

  00195	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR name_mapping_2to3
  0019c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001a0	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  001a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@IKFMBBAC@_compat_pickle?4NAME_MAPPING?5shou@
  001ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  001b2	e8 00 00 00 00	 call	 PyErr_Format

; 6397 :         goto error;

  001b7	e9 01 02 00 00	 jmp	 $error$25204
$LN61@initmodule:

; 6398 :     }
; 6399 :     import_mapping_2to3 = PyObject_GetAttrString(compat_pickle,
; 6400 :                                                  "IMPORT_MAPPING");

  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FDAEMEFC@IMPORT_MAPPING?$AA@
  001c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR compat_pickle$[rsp]
  001c8	e8 00 00 00 00	 call	 PyObject_GetAttrString
  001cd	48 89 05 00 00
	00 00		 mov	 QWORD PTR import_mapping_2to3, rax

; 6401 :     if (!import_mapping_2to3)

  001d4	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR import_mapping_2to3, 0
  001dc	75 05		 jne	 SHORT $LN60@initmodule

; 6402 :         goto error;

  001de	e9 da 01 00 00	 jmp	 $error$25204
$LN60@initmodule:

; 6403 :     if (!PyDict_CheckExact(import_mapping_2to3)) {

  001e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  001ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR import_mapping_2to3
  001f1	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001f5	74 3b		 je	 SHORT $LN59@initmodule
  001f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  001fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR import_mapping_2to3
  00205	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  00209	74 27		 je	 SHORT $LN59@initmodule

; 6404 :         PyErr_Format(PyExc_RuntimeError,
; 6405 :                      "_compat_pickle.IMPORT_MAPPING should be a dict, "
; 6406 :                      "not %.200s", Py_TYPE(import_mapping_2to3)->tp_name);

  0020b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR import_mapping_2to3
  00212	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00216	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0021a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@IBPPHGMJ@_compat_pickle?4IMPORT_MAPPING?5sh@
  00221	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00228	e8 00 00 00 00	 call	 PyErr_Format

; 6407 :         goto error;

  0022d	e9 8b 01 00 00	 jmp	 $error$25204
$LN59@initmodule:

; 6408 :     }
; 6409 :     /* ... and the 3.x -> 2.x mapping tables */
; 6410 :     name_mapping_3to2 = PyObject_GetAttrString(compat_pickle,
; 6411 :                                                "REVERSE_NAME_MAPPING");

  00232	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@PCKAADLD@REVERSE_NAME_MAPPING?$AA@
  00239	48 8b 4c 24 38	 mov	 rcx, QWORD PTR compat_pickle$[rsp]
  0023e	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00243	48 89 05 00 00
	00 00		 mov	 QWORD PTR name_mapping_3to2, rax

; 6412 :     if (!name_mapping_3to2)

  0024a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR name_mapping_3to2, 0
  00252	75 05		 jne	 SHORT $LN58@initmodule

; 6413 :         goto error;

  00254	e9 64 01 00 00	 jmp	 $error$25204
$LN58@initmodule:

; 6414 :     if (!PyDict_CheckExact(name_mapping_3to2)) {

  00259	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00260	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR name_mapping_3to2
  00267	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0026b	74 3b		 je	 SHORT $LN57@initmodule
  0026d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00274	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR name_mapping_3to2
  0027b	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  0027f	74 27		 je	 SHORT $LN57@initmodule

; 6415 :         PyErr_Format(PyExc_RuntimeError,
; 6416 :                      "_compat_pickle.REVERSE_NAME_MAPPING should be a dict, "
; 6417 :                      "not %.200s", Py_TYPE(name_mapping_3to2)->tp_name);

  00281	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR name_mapping_3to2
  00288	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0028c	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00290	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@EGJAAION@_compat_pickle?4REVERSE_NAME_MAPP@
  00297	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0029e	e8 00 00 00 00	 call	 PyErr_Format

; 6418 :         goto error;

  002a3	e9 15 01 00 00	 jmp	 $error$25204
$LN57@initmodule:

; 6419 :     }
; 6420 :     import_mapping_3to2 = PyObject_GetAttrString(compat_pickle,
; 6421 :                                                  "REVERSE_IMPORT_MAPPING");

  002a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@HCNJFHFO@REVERSE_IMPORT_MAPPING?$AA@
  002af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR compat_pickle$[rsp]
  002b4	e8 00 00 00 00	 call	 PyObject_GetAttrString
  002b9	48 89 05 00 00
	00 00		 mov	 QWORD PTR import_mapping_3to2, rax

; 6422 :     if (!import_mapping_3to2)

  002c0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR import_mapping_3to2, 0
  002c8	75 05		 jne	 SHORT $LN56@initmodule

; 6423 :         goto error;

  002ca	e9 ee 00 00 00	 jmp	 $error$25204
$LN56@initmodule:

; 6424 :     if (!PyDict_CheckExact(import_mapping_3to2)) {

  002cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  002d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR import_mapping_3to2
  002dd	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  002e1	74 3b		 je	 SHORT $LN55@initmodule
  002e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  002ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR import_mapping_3to2
  002f1	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  002f5	74 27		 je	 SHORT $LN55@initmodule

; 6425 :         PyErr_Format(PyExc_RuntimeError,
; 6426 :                      "_compat_pickle.REVERSE_IMPORT_MAPPING should be a dict, "
; 6427 :                      "not %.200s", Py_TYPE(import_mapping_3to2)->tp_name);

  002f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR import_mapping_3to2
  002fe	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00302	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00306	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@DMHCPNOG@_compat_pickle?4REVERSE_IMPORT_MA@
  0030d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00314	e8 00 00 00 00	 call	 PyErr_Format

; 6428 :         goto error;

  00319	e9 9f 00 00 00	 jmp	 $error$25204
$LN55@initmodule:
$LN54@initmodule:

; 6429 :     }
; 6430 :     Py_CLEAR(compat_pickle);

  0031e	48 83 7c 24 38
	00		 cmp	 QWORD PTR compat_pickle$[rsp], 0
  00324	74 47		 je	 SHORT $LN51@initmodule
  00326	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0032e	4c 8b 4c 24 38	 mov	 r9, QWORD PTR compat_pickle$[rsp]
  00333	41 b8 1e 19 00
	00		 mov	 r8d, 6430		; 0000191eH
  00339	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00340	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00347	e8 00 00 00 00	 call	 _PyParallel_Guard
  0034c	85 c0		 test	 eax, eax
  0034e	75 1d		 jne	 SHORT $LN51@initmodule
  00350	48 8b 44 24 38	 mov	 rax, QWORD PTR compat_pickle$[rsp]
  00355	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$25255[rsp], rax
  0035a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR compat_pickle$[rsp], 0
  00363	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$25255[rsp]
  00368	e8 00 00 00 00	 call	 _Py_DecRef
$LN51@initmodule:
  0036d	33 c0		 xor	 eax, eax
  0036f	85 c0		 test	 eax, eax
  00371	75 ab		 jne	 SHORT $LN54@initmodule

; 6431 : 
; 6432 :     empty_tuple = PyTuple_New(0);

  00373	33 c9		 xor	 ecx, ecx
  00375	e8 00 00 00 00	 call	 PyTuple_New
  0037a	48 89 05 00 00
	00 00		 mov	 QWORD PTR empty_tuple, rax

; 6433 :     if (empty_tuple == NULL)

  00381	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR empty_tuple, 0
  00389	75 02		 jne	 SHORT $LN50@initmodule

; 6434 :         goto error;

  0038b	eb 30		 jmp	 SHORT $error$25204
$LN50@initmodule:

; 6435 :     two_tuple = PyTuple_New(2);

  0038d	b9 02 00 00 00	 mov	 ecx, 2
  00392	e8 00 00 00 00	 call	 PyTuple_New
  00397	48 89 05 00 00
	00 00		 mov	 QWORD PTR two_tuple, rax

; 6436 :     if (two_tuple == NULL)

  0039e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR two_tuple, 0
  003a6	75 02		 jne	 SHORT $LN49@initmodule

; 6437 :         goto error;

  003a8	eb 13		 jmp	 SHORT $error$25204
$LN49@initmodule:

; 6438 :     /* We use this temp container with no regard to refcounts, or to
; 6439 :      * keeping containees alive.  Exempt from GC, because we don't
; 6440 :      * want anything looking at two_tuple() by magic.
; 6441 :      */
; 6442 :     PyObject_GC_UnTrack(two_tuple);

  003aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR two_tuple
  003b1	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 6443 : 
; 6444 :     return 0;

  003b6	33 c0		 xor	 eax, eax
  003b8	e9 75 04 00 00	 jmp	 $LN73@initmodule
$error$25204:
$LN48@initmodule:

; 6445 : 
; 6446 :   error:
; 6447 :     Py_CLEAR(copyreg);

  003bd	48 83 7c 24 30
	00		 cmp	 QWORD PTR copyreg$[rsp], 0
  003c3	74 47		 je	 SHORT $LN45@initmodule
  003c5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003cd	4c 8b 4c 24 30	 mov	 r9, QWORD PTR copyreg$[rsp]
  003d2	41 b8 2f 19 00
	00		 mov	 r8d, 6447		; 0000192fH
  003d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  003df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  003e6	e8 00 00 00 00	 call	 _PyParallel_Guard
  003eb	85 c0		 test	 eax, eax
  003ed	75 1d		 jne	 SHORT $LN45@initmodule
  003ef	48 8b 44 24 30	 mov	 rax, QWORD PTR copyreg$[rsp]
  003f4	48 89 44 24 50	 mov	 QWORD PTR _py_tmp$25267[rsp], rax
  003f9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR copyreg$[rsp], 0
  00402	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _py_tmp$25267[rsp]
  00407	e8 00 00 00 00	 call	 _Py_DecRef
$LN45@initmodule:
  0040c	33 c0		 xor	 eax, eax
  0040e	85 c0		 test	 eax, eax
  00410	75 ab		 jne	 SHORT $LN48@initmodule
$LN44@initmodule:

; 6448 :     Py_CLEAR(dispatch_table);

  00412	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR dispatch_table, 0
  0041a	74 4d		 je	 SHORT $LN41@initmodule
  0041c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00424	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR dispatch_table
  0042b	41 b8 30 19 00
	00		 mov	 r8d, 6448		; 00001930H
  00431	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00438	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  0043f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00444	85 c0		 test	 eax, eax
  00446	75 21		 jne	 SHORT $LN41@initmodule
  00448	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dispatch_table
  0044f	48 89 44 24 58	 mov	 QWORD PTR _py_tmp$25275[rsp], rax
  00454	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR dispatch_table, 0
  0045f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _py_tmp$25275[rsp]
  00464	e8 00 00 00 00	 call	 _Py_DecRef
$LN41@initmodule:
  00469	33 c0		 xor	 eax, eax
  0046b	85 c0		 test	 eax, eax
  0046d	75 a3		 jne	 SHORT $LN44@initmodule
$LN40@initmodule:

; 6449 :     Py_CLEAR(extension_registry);

  0046f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR extension_registry, 0
  00477	74 4d		 je	 SHORT $LN37@initmodule
  00479	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00481	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR extension_registry
  00488	41 b8 31 19 00
	00		 mov	 r8d, 6449		; 00001931H
  0048e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00495	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  0049c	e8 00 00 00 00	 call	 _PyParallel_Guard
  004a1	85 c0		 test	 eax, eax
  004a3	75 21		 jne	 SHORT $LN37@initmodule
  004a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR extension_registry
  004ac	48 89 44 24 60	 mov	 QWORD PTR _py_tmp$25283[rsp], rax
  004b1	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR extension_registry, 0
  004bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _py_tmp$25283[rsp]
  004c1	e8 00 00 00 00	 call	 _Py_DecRef
$LN37@initmodule:
  004c6	33 c0		 xor	 eax, eax
  004c8	85 c0		 test	 eax, eax
  004ca	75 a3		 jne	 SHORT $LN40@initmodule
$LN36@initmodule:

; 6450 :     Py_CLEAR(inverted_registry);

  004cc	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR inverted_registry, 0
  004d4	74 4d		 je	 SHORT $LN33@initmodule
  004d6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004de	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR inverted_registry
  004e5	41 b8 32 19 00
	00		 mov	 r8d, 6450		; 00001932H
  004eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  004f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  004f9	e8 00 00 00 00	 call	 _PyParallel_Guard
  004fe	85 c0		 test	 eax, eax
  00500	75 21		 jne	 SHORT $LN33@initmodule
  00502	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR inverted_registry
  00509	48 89 44 24 68	 mov	 QWORD PTR _py_tmp$25291[rsp], rax
  0050e	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR inverted_registry, 0
  00519	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _py_tmp$25291[rsp]
  0051e	e8 00 00 00 00	 call	 _Py_DecRef
$LN33@initmodule:
  00523	33 c0		 xor	 eax, eax
  00525	85 c0		 test	 eax, eax
  00527	75 a3		 jne	 SHORT $LN36@initmodule
$LN32@initmodule:

; 6451 :     Py_CLEAR(extension_cache);

  00529	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR extension_cache, 0
  00531	74 4d		 je	 SHORT $LN29@initmodule
  00533	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0053b	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR extension_cache
  00542	41 b8 33 19 00
	00		 mov	 r8d, 6451		; 00001933H
  00548	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0054f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00556	e8 00 00 00 00	 call	 _PyParallel_Guard
  0055b	85 c0		 test	 eax, eax
  0055d	75 21		 jne	 SHORT $LN29@initmodule
  0055f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR extension_cache
  00566	48 89 44 24 70	 mov	 QWORD PTR _py_tmp$25299[rsp], rax
  0056b	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR extension_cache, 0
  00576	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _py_tmp$25299[rsp]
  0057b	e8 00 00 00 00	 call	 _Py_DecRef
$LN29@initmodule:
  00580	33 c0		 xor	 eax, eax
  00582	85 c0		 test	 eax, eax
  00584	75 a3		 jne	 SHORT $LN32@initmodule
$LN28@initmodule:

; 6452 :     Py_CLEAR(compat_pickle);

  00586	48 83 7c 24 38
	00		 cmp	 QWORD PTR compat_pickle$[rsp], 0
  0058c	74 47		 je	 SHORT $LN25@initmodule
  0058e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00596	4c 8b 4c 24 38	 mov	 r9, QWORD PTR compat_pickle$[rsp]
  0059b	41 b8 34 19 00
	00		 mov	 r8d, 6452		; 00001934H
  005a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  005a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  005af	e8 00 00 00 00	 call	 _PyParallel_Guard
  005b4	85 c0		 test	 eax, eax
  005b6	75 1d		 jne	 SHORT $LN25@initmodule
  005b8	48 8b 44 24 38	 mov	 rax, QWORD PTR compat_pickle$[rsp]
  005bd	48 89 44 24 78	 mov	 QWORD PTR _py_tmp$25307[rsp], rax
  005c2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR compat_pickle$[rsp], 0
  005cb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _py_tmp$25307[rsp]
  005d0	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@initmodule:
  005d5	33 c0		 xor	 eax, eax
  005d7	85 c0		 test	 eax, eax
  005d9	75 ab		 jne	 SHORT $LN28@initmodule
$LN24@initmodule:

; 6453 :     Py_CLEAR(name_mapping_2to3);

  005db	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR name_mapping_2to3, 0
  005e3	74 53		 je	 SHORT $LN21@initmodule
  005e5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  005ed	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR name_mapping_2to3
  005f4	41 b8 35 19 00
	00		 mov	 r8d, 6453		; 00001935H
  005fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00601	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00608	e8 00 00 00 00	 call	 _PyParallel_Guard
  0060d	85 c0		 test	 eax, eax
  0060f	75 27		 jne	 SHORT $LN21@initmodule
  00611	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR name_mapping_2to3
  00618	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR _py_tmp$25315[rsp], rax
  00620	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR name_mapping_2to3, 0
  0062b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$25315[rsp]
  00633	e8 00 00 00 00	 call	 _Py_DecRef
$LN21@initmodule:
  00638	33 c0		 xor	 eax, eax
  0063a	85 c0		 test	 eax, eax
  0063c	75 9d		 jne	 SHORT $LN24@initmodule
$LN20@initmodule:

; 6454 :     Py_CLEAR(import_mapping_2to3);

  0063e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR import_mapping_2to3, 0
  00646	74 53		 je	 SHORT $LN17@initmodule
  00648	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00650	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR import_mapping_2to3
  00657	41 b8 36 19 00
	00		 mov	 r8d, 6454		; 00001936H
  0065d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00664	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  0066b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00670	85 c0		 test	 eax, eax
  00672	75 27		 jne	 SHORT $LN17@initmodule
  00674	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR import_mapping_2to3
  0067b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR _py_tmp$25323[rsp], rax
  00683	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR import_mapping_2to3, 0
  0068e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$25323[rsp]
  00696	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@initmodule:
  0069b	33 c0		 xor	 eax, eax
  0069d	85 c0		 test	 eax, eax
  0069f	75 9d		 jne	 SHORT $LN20@initmodule
$LN16@initmodule:

; 6455 :     Py_CLEAR(name_mapping_3to2);

  006a1	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR name_mapping_3to2, 0
  006a9	74 53		 je	 SHORT $LN13@initmodule
  006ab	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  006b3	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR name_mapping_3to2
  006ba	41 b8 37 19 00
	00		 mov	 r8d, 6455		; 00001937H
  006c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  006c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  006ce	e8 00 00 00 00	 call	 _PyParallel_Guard
  006d3	85 c0		 test	 eax, eax
  006d5	75 27		 jne	 SHORT $LN13@initmodule
  006d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR name_mapping_3to2
  006de	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR _py_tmp$25331[rsp], rax
  006e6	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR name_mapping_3to2, 0
  006f1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$25331[rsp]
  006f9	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@initmodule:
  006fe	33 c0		 xor	 eax, eax
  00700	85 c0		 test	 eax, eax
  00702	75 9d		 jne	 SHORT $LN16@initmodule
$LN12@initmodule:

; 6456 :     Py_CLEAR(import_mapping_3to2);

  00704	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR import_mapping_3to2, 0
  0070c	74 53		 je	 SHORT $LN9@initmodule
  0070e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00716	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR import_mapping_3to2
  0071d	41 b8 38 19 00
	00		 mov	 r8d, 6456		; 00001938H
  00723	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0072a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00731	e8 00 00 00 00	 call	 _PyParallel_Guard
  00736	85 c0		 test	 eax, eax
  00738	75 27		 jne	 SHORT $LN9@initmodule
  0073a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR import_mapping_3to2
  00741	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR _py_tmp$25339[rsp], rax
  00749	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR import_mapping_3to2, 0
  00754	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$25339[rsp]
  0075c	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@initmodule:
  00761	33 c0		 xor	 eax, eax
  00763	85 c0		 test	 eax, eax
  00765	75 9d		 jne	 SHORT $LN12@initmodule
$LN8@initmodule:

; 6457 :     Py_CLEAR(empty_tuple);

  00767	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR empty_tuple, 0
  0076f	74 53		 je	 SHORT $LN5@initmodule
  00771	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00779	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR empty_tuple
  00780	41 b8 39 19 00
	00		 mov	 r8d, 6457		; 00001939H
  00786	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0078d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00794	e8 00 00 00 00	 call	 _PyParallel_Guard
  00799	85 c0		 test	 eax, eax
  0079b	75 27		 jne	 SHORT $LN5@initmodule
  0079d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR empty_tuple
  007a4	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR _py_tmp$25347[rsp], rax
  007ac	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR empty_tuple, 0
  007b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$25347[rsp]
  007bf	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@initmodule:
  007c4	33 c0		 xor	 eax, eax
  007c6	85 c0		 test	 eax, eax
  007c8	75 9d		 jne	 SHORT $LN8@initmodule
$LN4@initmodule:

; 6458 :     Py_CLEAR(two_tuple);

  007ca	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR two_tuple, 0
  007d2	74 53		 je	 SHORT $LN1@initmodule
  007d4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  007dc	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR two_tuple
  007e3	41 b8 3a 19 00
	00		 mov	 r8d, 6458		; 0000193aH
  007e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  007f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  007f7	e8 00 00 00 00	 call	 _PyParallel_Guard
  007fc	85 c0		 test	 eax, eax
  007fe	75 27		 jne	 SHORT $LN1@initmodule
  00800	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR two_tuple
  00807	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR _py_tmp$25355[rsp], rax
  0080f	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR two_tuple, 0
  0081a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$25355[rsp]
  00822	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@initmodule:
  00827	33 c0		 xor	 eax, eax
  00829	85 c0		 test	 eax, eax
  0082b	75 9d		 jne	 SHORT $LN4@initmodule

; 6459 :     return -1;

  0082d	b8 ff ff ff ff	 mov	 eax, -1
$LN73@initmodule:

; 6460 : }

  00832	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00839	c3		 ret	 0
initmodule ENDP
_TEXT	ENDS
END
