; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
CONST	ENDS
PUBLIC	??_C@_05DFCKICEH@1?42?45?$AA@			; `string'
PUBLIC	inflateBackInit_
EXTRN	zcfree:PROC
EXTRN	zcalloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\zlib\infback.c
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN10
	DD	imagerel $LN10+350
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT ??_C@_05DFCKICEH@1?42?45?$AA@
CONST	SEGMENT
??_C@_05DFCKICEH@1?42?45?$AA@ DB '1.2.5', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
state$ = 32
tv147 = 40
strm$ = 64
windowBits$ = 72
window$ = 80
version$ = 88
stream_size$ = 96
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00017	48 83 7c 24 58
	00		 cmp	 QWORD PTR version$[rsp], 0
  0001d	74 1a		 je	 SHORT $LN6@inflateBac
  0001f	48 8b 44 24 58	 mov	 rax, QWORD PTR version$[rsp]
  00024	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00027	0f be 0d 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_05DFCKICEH@1?42?45?$AA@
  0002e	3b c1		 cmp	 eax, ecx
  00030	75 07		 jne	 SHORT $LN6@inflateBac
  00032	83 7c 24 60 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  00037	74 0a		 je	 SHORT $LN7@inflateBac
$LN6@inflateBac:

; 39   :         return Z_VERSION_ERROR;

  00039	b8 fa ff ff ff	 mov	 eax, -6
  0003e	e9 16 01 00 00	 jmp	 $LN8@inflateBac
$LN7@inflateBac:

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00049	74 16		 je	 SHORT $LN4@inflateBac
  0004b	48 83 7c 24 50
	00		 cmp	 QWORD PTR window$[rsp], 0
  00051	74 0e		 je	 SHORT $LN4@inflateBac
  00053	83 7c 24 48 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  00058	7c 07		 jl	 SHORT $LN4@inflateBac
  0005a	83 7c 24 48 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  0005f	7e 0a		 jle	 SHORT $LN5@inflateBac
$LN4@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  00061	b8 fe ff ff ff	 mov	 eax, -2
  00066	e9 ee 00 00 00	 jmp	 $LN8@inflateBac
$LN5@inflateBac:

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00070	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007d	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00082	75 1d		 jne	 SHORT $LN3@inflateBac

; 45   :         strm->zalloc = zcalloc;

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcalloc
  00090	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 46   :         strm->opaque = (voidpf)0;

  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00099	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN3@inflateBac:

; 47   :     }
; 48   :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a6	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000ab	75 10		 jne	 SHORT $LN2@inflateBac
  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree
  000b9	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN2@inflateBac:

; 49   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 50   :                                                sizeof(struct inflate_state));

  000bd	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  000c3	ba 01 00 00 00	 mov	 edx, 1
  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000cd	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d6	ff 50 30	 call	 QWORD PTR [rax+48]
  000d9	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 51   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000de	48 83 7c 24 20
	00		 cmp	 QWORD PTR state$[rsp], 0
  000e4	75 07		 jne	 SHORT $LN1@inflateBac
  000e6	b8 fc ff ff ff	 mov	 eax, -4
  000eb	eb 6c		 jmp	 SHORT $LN8@inflateBac
$LN1@inflateBac:

; 52   :     Tracev((stderr, "inflate: allocated\n"));
; 53   :     strm->state = (struct internal_state FAR *)state;

  000ed	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000f2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000f7	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 54   :     state->dmax = 32768U;

  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00100	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [rax+20], 32768 ; 00008000H

; 55   :     state->wbits = windowBits;

  00107	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0010c	8b 4c 24 48	 mov	 ecx, DWORD PTR windowBits$[rsp]
  00110	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 56   :     state->wsize = 1U << windowBits;

  00113	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  00117	b9 01 00 00 00	 mov	 ecx, 1
  0011c	89 4c 24 28	 mov	 DWORD PTR tv147[rsp], ecx
  00120	0f b6 c8	 movzx	 ecx, al
  00123	8b 44 24 28	 mov	 eax, DWORD PTR tv147[rsp]
  00127	d3 e0		 shl	 eax, cl
  00129	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0012e	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 57   :     state->window = window;

  00131	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00136	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  0013b	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 58   :     state->wnext = 0;

  0013f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00144	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 59   :     state->whave = 0;

  0014b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00150	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 60   :     return Z_OK;

  00157	33 c0		 xor	 eax, eax
$LN8@inflateBac:

; 61   : }

  00159	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015d	c3		 ret	 0
inflateBackInit_ ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	inflateBack
EXTRN	inflate_fast:PROC
EXTRN	inflate_table:PROC
EXTRN	memcpy:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN355
	DD	imagerel $LN355+7316
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 021b01H
	DD	01b011bH
xdata	ENDS
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT inflateBack
_TEXT	SEGMENT
put$ = 48
last$ = 56
here$ = 60
have$ = 64
len$ = 68
bits$ = 72
left$ = 76
next$ = 80
ret$ = 88
hold$ = 92
copy$ = 96
from$ = 104
state$ = 112
tv73 = 120
tv76 = 124
tv137 = 128
tv308 = 136
tv1173 = 144
tv506 = 152
tv527 = 160
tv1358 = 168
tv591 = 172
tv1439 = 176
tv1455 = 180
tv717 = 184
tv1521 = 188
tv796 = 192
strm$ = 224
in$ = 232
in_desc$ = 240
out$ = 248
out_desc$ = 256
inflateBack PROC					; COMDAT

; 247  : {

$LN355:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 248  :     struct inflate_state FAR *state;
; 249  :     unsigned char FAR *next;    /* next input */
; 250  :     unsigned char FAR *put;     /* next output */
; 251  :     unsigned have, left;        /* available input and output */
; 252  :     unsigned long hold;         /* bit buffer */
; 253  :     unsigned bits;              /* bits in bit buffer */
; 254  :     unsigned copy;              /* number of stored or match bytes to copy */
; 255  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 256  :     code here;                  /* current decoding table entry */
; 257  :     code last;                  /* parent table entry */
; 258  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 259  :     int ret;                    /* return code */
; 260  :     static const unsigned short order[19] = /* permutation of code lengths */
; 261  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 262  : 
; 263  :     /* Check that the strm exists and that the state was initialized */
; 264  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0001b	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR strm$[rsp], 0
  00024	74 0f		 je	 SHORT $LN346@inflateBac@2
  00026	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0002e	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00033	75 0a		 jne	 SHORT $LN347@inflateBac@2
$LN346@inflateBac@2:

; 265  :         return Z_STREAM_ERROR;

  00035	b8 fe ff ff ff	 mov	 eax, -2
  0003a	e9 ff 1b 00 00	 jmp	 $LN348@inflateBac@2
$LN347@inflateBac@2:

; 266  :     state = (struct inflate_state FAR *)strm->state;

  0003f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00047	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004b	48 89 44 24 70	 mov	 QWORD PTR state$[rsp], rax

; 267  : 
; 268  :     /* Reset the state */
; 269  :     strm->msg = Z_NULL;

  00050	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00058	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 270  :     state->mode = TYPE;

  00060	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00065	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 271  :     state->last = 0;

  0006b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00070	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 272  :     state->whave = 0;

  00077	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0007c	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 273  :     next = strm->next_in;

  00083	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 274  :     have = next != Z_NULL ? strm->avail_in : 0;

  00093	48 83 7c 24 50
	00		 cmp	 QWORD PTR next$[rsp], 0
  00099	74 11		 je	 SHORT $LN350@inflateBac@2
  0009b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000a3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000a6	89 44 24 78	 mov	 DWORD PTR tv73[rsp], eax
  000aa	eb 08		 jmp	 SHORT $LN351@inflateBac@2
$LN350@inflateBac@2:
  000ac	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN351@inflateBac@2:
  000b4	8b 44 24 78	 mov	 eax, DWORD PTR tv73[rsp]
  000b8	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 275  :     hold = 0;

  000bc	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0

; 276  :     bits = 0;

  000c4	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0

; 277  :     put = state->window;

  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000d1	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000d5	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 278  :     left = state->wsize;

  000da	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000df	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000e2	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
$LN345@inflateBac@2:

; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  000e6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000eb	8b 00		 mov	 eax, DWORD PTR [rax]
  000ed	89 44 24 7c	 mov	 DWORD PTR tv76[rsp], eax
  000f1	8b 44 24 7c	 mov	 eax, DWORD PTR tv76[rsp]
  000f5	83 e8 0b	 sub	 eax, 11
  000f8	89 44 24 7c	 mov	 DWORD PTR tv76[rsp], eax
  000fc	83 7c 24 7c 12	 cmp	 DWORD PTR tv76[rsp], 18
  00101	0f 87 05 1b 00
	00		 ja	 $LN1@inflateBac@2
  00107	48 63 44 24 7c	 movsxd	 rax, DWORD PTR tv76[rsp]
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00113	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN354@inflateBac@2[rcx+rax*4]
  0011a	48 03 c1	 add	 rax, rcx
  0011d	ff e0		 jmp	 rax
$LN341@inflateBac@2:

; 283  :         case TYPE:
; 284  :             /* determine and dispatch block type */
; 285  :             if (state->last) {

  0011f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00124	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00128	74 3d		 je	 SHORT $LN340@inflateBac@2
$LN339@inflateBac@2:

; 286  :                 BYTEBITS();

  0012a	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0012e	83 e0 07	 and	 eax, 7
  00131	0f b6 c8	 movzx	 ecx, al
  00134	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00138	d3 e8		 shr	 eax, cl
  0013a	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0013e	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00142	83 e0 07	 and	 eax, 7
  00145	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00149	2b c8		 sub	 ecx, eax
  0014b	8b c1		 mov	 eax, ecx
  0014d	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00151	33 c0		 xor	 eax, eax
  00153	85 c0		 test	 eax, eax
  00155	75 d3		 jne	 SHORT $LN339@inflateBac@2

; 287  :                 state->mode = DONE;

  00157	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0015c	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 288  :                 break;

  00162	e9 af 1a 00 00	 jmp	 $LN342@inflateBac@2
$LN340@inflateBac@2:
$LN336@inflateBac@2:
$LN333@inflateBac@2:

; 289  :             }
; 290  :             NEEDBITS(3);

  00167	83 7c 24 48 03	 cmp	 DWORD PTR bits$[rsp], 3
  0016c	0f 83 8d 00 00
	00		 jae	 $LN332@inflateBac@2
$LN331@inflateBac@2:
$LN328@inflateBac@2:
  00172	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00177	75 35		 jne	 SHORT $LN325@inflateBac@2
  00179	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0017e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00186	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0018d	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00191	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00196	75 16		 jne	 SHORT $LN324@inflateBac@2
  00198	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  001a1	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  001a9	e9 6d 1a 00 00	 jmp	 $inf_leave$4912
$LN324@inflateBac@2:
$LN325@inflateBac@2:
  001ae	33 c0		 xor	 eax, eax
  001b0	85 c0		 test	 eax, eax
  001b2	75 be		 jne	 SHORT $LN328@inflateBac@2
  001b4	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  001b8	ff c8		 dec	 eax
  001ba	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  001be	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  001c3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001c6	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  001ca	d3 e0		 shl	 eax, cl
  001cc	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  001d0	03 c8		 add	 ecx, eax
  001d2	8b c1		 mov	 eax, ecx
  001d4	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  001d8	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  001dd	48 ff c0	 inc	 rax
  001e0	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  001e5	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  001e9	83 c0 08	 add	 eax, 8
  001ec	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  001f0	33 c0		 xor	 eax, eax
  001f2	85 c0		 test	 eax, eax
  001f4	0f 85 78 ff ff
	ff		 jne	 $LN331@inflateBac@2
  001fa	e9 68 ff ff ff	 jmp	 $LN333@inflateBac@2
$LN332@inflateBac@2:
  001ff	33 c0		 xor	 eax, eax
  00201	85 c0		 test	 eax, eax
  00203	0f 85 5e ff ff
	ff		 jne	 $LN336@inflateBac@2

; 291  :             state->last = BITS(1);

  00209	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0020d	83 e0 01	 and	 eax, 1
  00210	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00215	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN323@inflateBac@2:

; 292  :             DROPBITS(1);

  00218	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0021c	d1 e8		 shr	 eax, 1
  0021e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00222	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00226	ff c8		 dec	 eax
  00228	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0022c	33 c0		 xor	 eax, eax
  0022e	85 c0		 test	 eax, eax
  00230	75 e6		 jne	 SHORT $LN323@inflateBac@2

; 293  :             switch (BITS(2)) {

  00232	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00236	83 e0 03	 and	 eax, 3
  00239	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv137[rsp], eax
  00240	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv137[rsp], 0
  00248	74 20		 je	 SHORT $LN318@inflateBac@2
  0024a	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR tv137[rsp], 1
  00252	74 23		 je	 SHORT $LN317@inflateBac@2
  00254	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR tv137[rsp], 2
  0025c	74 30		 je	 SHORT $LN316@inflateBac@2
  0025e	83 bc 24 80 00
	00 00 03	 cmp	 DWORD PTR tv137[rsp], 3
  00266	74 33		 je	 SHORT $LN315@inflateBac@2
  00268	eb 4f		 jmp	 SHORT $LN319@inflateBac@2
$LN318@inflateBac@2:

; 294  :             case 0:                             /* stored block */
; 295  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 296  :                         state->last ? " (last)" : ""));
; 297  :                 state->mode = STORED;

  0026a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0026f	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13

; 298  :                 break;

  00275	eb 42		 jmp	 SHORT $LN319@inflateBac@2
$LN317@inflateBac@2:

; 299  :             case 1:                             /* fixed block */
; 300  :                 fixedtables(state);

  00277	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0027c	e8 00 00 00 00	 call	 fixedtables

; 301  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 302  :                         state->last ? " (last)" : ""));
; 303  :                 state->mode = LEN;              /* decode codes */

  00281	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00286	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20

; 304  :                 break;

  0028c	eb 2b		 jmp	 SHORT $LN319@inflateBac@2
$LN316@inflateBac@2:

; 305  :             case 2:                             /* dynamic block */
; 306  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 307  :                         state->last ? " (last)" : ""));
; 308  :                 state->mode = TABLE;

  0028e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00293	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 309  :                 break;

  00299	eb 1e		 jmp	 SHORT $LN319@inflateBac@2
$LN315@inflateBac@2:

; 310  :             case 3:
; 311  :                 strm->msg = (char *)"invalid block type";

  0029b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  002a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
  002aa	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 312  :                 state->mode = BAD;

  002ae	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  002b3	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29
$LN319@inflateBac@2:
$LN314@inflateBac@2:

; 313  :             }
; 314  :             DROPBITS(2);

  002b9	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  002bd	c1 e8 02	 shr	 eax, 2
  002c0	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  002c4	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  002c8	83 e8 02	 sub	 eax, 2
  002cb	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  002cf	33 c0		 xor	 eax, eax
  002d1	85 c0		 test	 eax, eax
  002d3	75 e4		 jne	 SHORT $LN314@inflateBac@2

; 315  :             break;

  002d5	e9 3c 19 00 00	 jmp	 $LN342@inflateBac@2
$LN311@inflateBac@2:
$LN310@inflateBac@2:

; 316  : 
; 317  :         case STORED:
; 318  :             /* get and verify stored block length */
; 319  :             BYTEBITS();                         /* go to byte boundary */

  002da	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  002de	83 e0 07	 and	 eax, 7
  002e1	0f b6 c8	 movzx	 ecx, al
  002e4	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  002e8	d3 e8		 shr	 eax, cl
  002ea	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  002ee	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  002f2	83 e0 07	 and	 eax, 7
  002f5	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  002f9	2b c8		 sub	 ecx, eax
  002fb	8b c1		 mov	 eax, ecx
  002fd	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00301	33 c0		 xor	 eax, eax
  00303	85 c0		 test	 eax, eax
  00305	75 d3		 jne	 SHORT $LN310@inflateBac@2
$LN307@inflateBac@2:
$LN304@inflateBac@2:

; 320  :             NEEDBITS(32);

  00307	83 7c 24 48 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  0030c	0f 83 8d 00 00
	00		 jae	 $LN303@inflateBac@2
$LN302@inflateBac@2:
$LN299@inflateBac@2:
  00312	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00317	75 35		 jne	 SHORT $LN296@inflateBac@2
  00319	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0031e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00326	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0032d	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00331	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00336	75 16		 jne	 SHORT $LN295@inflateBac@2
  00338	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00341	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00349	e9 cd 18 00 00	 jmp	 $inf_leave$4912
$LN295@inflateBac@2:
$LN296@inflateBac@2:
  0034e	33 c0		 xor	 eax, eax
  00350	85 c0		 test	 eax, eax
  00352	75 be		 jne	 SHORT $LN299@inflateBac@2
  00354	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00358	ff c8		 dec	 eax
  0035a	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0035e	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00363	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00366	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  0036a	d3 e0		 shl	 eax, cl
  0036c	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00370	03 c8		 add	 ecx, eax
  00372	8b c1		 mov	 eax, ecx
  00374	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00378	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0037d	48 ff c0	 inc	 rax
  00380	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00385	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00389	83 c0 08	 add	 eax, 8
  0038c	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00390	33 c0		 xor	 eax, eax
  00392	85 c0		 test	 eax, eax
  00394	0f 85 78 ff ff
	ff		 jne	 $LN302@inflateBac@2
  0039a	e9 68 ff ff ff	 jmp	 $LN304@inflateBac@2
$LN303@inflateBac@2:
  0039f	33 c0		 xor	 eax, eax
  003a1	85 c0		 test	 eax, eax
  003a3	0f 85 5e ff ff
	ff		 jne	 $LN307@inflateBac@2

; 321  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  003a9	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  003ad	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  003b2	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  003b6	c1 e9 10	 shr	 ecx, 16
  003b9	81 f1 ff ff 00
	00		 xor	 ecx, 65535		; 0000ffffH
  003bf	3b c1		 cmp	 eax, ecx
  003c1	74 23		 je	 SHORT $LN294@inflateBac@2

; 322  :                 strm->msg = (char *)"invalid stored block lengths";

  003c3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  003cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  003d2	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 323  :                 state->mode = BAD;

  003d6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  003db	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 324  :                 break;

  003e1	e9 30 18 00 00	 jmp	 $LN342@inflateBac@2
$LN294@inflateBac@2:

; 325  :             }
; 326  :             state->length = (unsigned)hold & 0xffff;

  003e6	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  003ea	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  003ef	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  003f4	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN293@inflateBac@2:

; 327  :             Tracev((stderr, "inflate:       stored length %u\n",
; 328  :                     state->length));
; 329  :             INITBITS();

  003f7	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  003ff	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00407	33 c0		 xor	 eax, eax
  00409	85 c0		 test	 eax, eax
  0040b	75 ea		 jne	 SHORT $LN293@inflateBac@2
$LN290@inflateBac@2:

; 330  : 
; 331  :             /* copy stored block from input to output */
; 332  :             while (state->length != 0) {

  0040d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00412	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  00416	0f 84 48 01 00
	00		 je	 $LN289@inflateBac@2

; 333  :                 copy = state->length;

  0041c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00421	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00424	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN288@inflateBac@2:

; 334  :                 PULL();

  00428	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0042d	75 35		 jne	 SHORT $LN285@inflateBac@2
  0042f	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00434	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0043c	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00443	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00447	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0044c	75 16		 jne	 SHORT $LN284@inflateBac@2
  0044e	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00457	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0045f	e9 b7 17 00 00	 jmp	 $inf_leave$4912
$LN284@inflateBac@2:
$LN285@inflateBac@2:
  00464	33 c0		 xor	 eax, eax
  00466	85 c0		 test	 eax, eax
  00468	75 be		 jne	 SHORT $LN288@inflateBac@2
$LN283@inflateBac@2:

; 335  :                 ROOM();

  0046a	83 7c 24 4c 00	 cmp	 DWORD PTR left$[rsp], 0
  0046f	75 50		 jne	 SHORT $LN280@inflateBac@2
  00471	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00476	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0047a	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  0047f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00484	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00487	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  0048b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00490	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  00494	89 48 30	 mov	 DWORD PTR [rax+48], ecx
  00497	44 8b 44 24 4c	 mov	 r8d, DWORD PTR left$[rsp]
  0049c	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  004a1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  004a9	ff 94 24 f8 00
	00 00		 call	 QWORD PTR out$[rsp]
  004b0	85 c0		 test	 eax, eax
  004b2	74 0d		 je	 SHORT $LN279@inflateBac@2
  004b4	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  004bc	e9 5a 17 00 00	 jmp	 $inf_leave$4912
$LN279@inflateBac@2:
$LN280@inflateBac@2:
  004c1	33 c0		 xor	 eax, eax
  004c3	85 c0		 test	 eax, eax
  004c5	75 a3		 jne	 SHORT $LN283@inflateBac@2

; 336  :                 if (copy > have) copy = have;

  004c7	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  004cb	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  004cf	76 08		 jbe	 SHORT $LN278@inflateBac@2
  004d1	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  004d5	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN278@inflateBac@2:

; 337  :                 if (copy > left) copy = left;

  004d9	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  004dd	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  004e1	76 08		 jbe	 SHORT $LN277@inflateBac@2
  004e3	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  004e7	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN277@inflateBac@2:

; 338  :                 zmemcpy(put, next, copy);

  004eb	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  004ef	44 8b c0	 mov	 r8d, eax
  004f2	48 8b 54 24 50	 mov	 rdx, QWORD PTR next$[rsp]
  004f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  004fc	e8 00 00 00 00	 call	 memcpy

; 339  :                 have -= copy;

  00501	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00505	8b 4c 24 40	 mov	 ecx, DWORD PTR have$[rsp]
  00509	2b c8		 sub	 ecx, eax
  0050b	8b c1		 mov	 eax, ecx
  0050d	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 340  :                 next += copy;

  00511	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00515	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  0051a	48 03 c8	 add	 rcx, rax
  0051d	48 8b c1	 mov	 rax, rcx
  00520	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 341  :                 left -= copy;

  00525	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00529	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  0052d	2b c8		 sub	 ecx, eax
  0052f	8b c1		 mov	 eax, ecx
  00531	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax

; 342  :                 put += copy;

  00535	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00539	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  0053e	48 03 c8	 add	 rcx, rax
  00541	48 8b c1	 mov	 rax, rcx
  00544	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 343  :                 state->length -= copy;

  00549	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0054e	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  00552	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00555	2b c1		 sub	 eax, ecx
  00557	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0055c	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 344  :             }

  0055f	e9 a9 fe ff ff	 jmp	 $LN290@inflateBac@2
$LN289@inflateBac@2:

; 345  :             Tracev((stderr, "inflate:       stored end\n"));
; 346  :             state->mode = TYPE;

  00564	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00569	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 347  :             break;

  0056f	e9 a2 16 00 00	 jmp	 $LN342@inflateBac@2
$LN276@inflateBac@2:
$LN275@inflateBac@2:
$LN272@inflateBac@2:

; 348  : 
; 349  :         case TABLE:
; 350  :             /* get dynamic table entries descriptor */
; 351  :             NEEDBITS(14);

  00574	83 7c 24 48 0e	 cmp	 DWORD PTR bits$[rsp], 14
  00579	0f 83 8d 00 00
	00		 jae	 $LN271@inflateBac@2
$LN270@inflateBac@2:
$LN267@inflateBac@2:
  0057f	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00584	75 35		 jne	 SHORT $LN264@inflateBac@2
  00586	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0058b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00593	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0059a	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0059e	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  005a3	75 16		 jne	 SHORT $LN263@inflateBac@2
  005a5	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  005ae	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  005b6	e9 60 16 00 00	 jmp	 $inf_leave$4912
$LN263@inflateBac@2:
$LN264@inflateBac@2:
  005bb	33 c0		 xor	 eax, eax
  005bd	85 c0		 test	 eax, eax
  005bf	75 be		 jne	 SHORT $LN267@inflateBac@2
  005c1	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  005c5	ff c8		 dec	 eax
  005c7	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  005cb	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  005d0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005d3	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  005d7	d3 e0		 shl	 eax, cl
  005d9	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  005dd	03 c8		 add	 ecx, eax
  005df	8b c1		 mov	 eax, ecx
  005e1	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  005e5	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  005ea	48 ff c0	 inc	 rax
  005ed	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  005f2	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  005f6	83 c0 08	 add	 eax, 8
  005f9	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  005fd	33 c0		 xor	 eax, eax
  005ff	85 c0		 test	 eax, eax
  00601	0f 85 78 ff ff
	ff		 jne	 $LN270@inflateBac@2
  00607	e9 68 ff ff ff	 jmp	 $LN272@inflateBac@2
$LN271@inflateBac@2:
  0060c	33 c0		 xor	 eax, eax
  0060e	85 c0		 test	 eax, eax
  00610	0f 85 5e ff ff
	ff		 jne	 $LN275@inflateBac@2

; 352  :             state->nlen = BITS(5) + 257;

  00616	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0061a	83 e0 1f	 and	 eax, 31
  0061d	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00622	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00627	89 41 74	 mov	 DWORD PTR [rcx+116], eax
$LN262@inflateBac@2:

; 353  :             DROPBITS(5);

  0062a	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0062e	c1 e8 05	 shr	 eax, 5
  00631	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00635	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00639	83 e8 05	 sub	 eax, 5
  0063c	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00640	33 c0		 xor	 eax, eax
  00642	85 c0		 test	 eax, eax
  00644	75 e4		 jne	 SHORT $LN262@inflateBac@2

; 354  :             state->ndist = BITS(5) + 1;

  00646	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0064a	83 e0 1f	 and	 eax, 31
  0064d	ff c0		 inc	 eax
  0064f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00654	89 41 78	 mov	 DWORD PTR [rcx+120], eax
$LN259@inflateBac@2:

; 355  :             DROPBITS(5);

  00657	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0065b	c1 e8 05	 shr	 eax, 5
  0065e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00662	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00666	83 e8 05	 sub	 eax, 5
  00669	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0066d	33 c0		 xor	 eax, eax
  0066f	85 c0		 test	 eax, eax
  00671	75 e4		 jne	 SHORT $LN259@inflateBac@2

; 356  :             state->ncode = BITS(4) + 4;

  00673	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00677	83 e0 0f	 and	 eax, 15
  0067a	83 c0 04	 add	 eax, 4
  0067d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00682	89 41 70	 mov	 DWORD PTR [rcx+112], eax
$LN256@inflateBac@2:

; 357  :             DROPBITS(4);

  00685	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00689	c1 e8 04	 shr	 eax, 4
  0068c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00690	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00694	83 e8 04	 sub	 eax, 4
  00697	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0069b	33 c0		 xor	 eax, eax
  0069d	85 c0		 test	 eax, eax
  0069f	75 e4		 jne	 SHORT $LN256@inflateBac@2

; 358  : #ifndef PKZIP_BUG_WORKAROUND
; 359  :             if (state->nlen > 286 || state->ndist > 30) {

  006a1	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006a6	81 78 74 1e 01
	00 00		 cmp	 DWORD PTR [rax+116], 286 ; 0000011eH
  006ad	77 0b		 ja	 SHORT $LN252@inflateBac@2
  006af	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006b4	83 78 78 1e	 cmp	 DWORD PTR [rax+120], 30
  006b8	76 23		 jbe	 SHORT $LN253@inflateBac@2
$LN252@inflateBac@2:

; 360  :                 strm->msg = (char *)"too many length or distance symbols";

  006ba	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  006c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  006c9	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 361  :                 state->mode = BAD;

  006cd	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006d2	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 362  :                 break;

  006d8	e9 39 15 00 00	 jmp	 $LN342@inflateBac@2
$LN253@inflateBac@2:

; 363  :             }
; 364  : #endif
; 365  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 366  : 
; 367  :             /* get code length code lengths (not a typo) */
; 368  :             state->have = 0;

  006dd	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006e2	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0
$LN251@inflateBac@2:

; 369  :             while (state->have < state->ncode) {

  006e9	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  006f3	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  006f6	39 48 7c	 cmp	 DWORD PTR [rax+124], ecx
  006f9	0f 83 fc 00 00
	00		 jae	 $LN250@inflateBac@2
$LN249@inflateBac@2:
$LN246@inflateBac@2:

; 370  :                 NEEDBITS(3);

  006ff	83 7c 24 48 03	 cmp	 DWORD PTR bits$[rsp], 3
  00704	0f 83 8d 00 00
	00		 jae	 $LN245@inflateBac@2
$LN244@inflateBac@2:
$LN241@inflateBac@2:
  0070a	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0070f	75 35		 jne	 SHORT $LN238@inflateBac@2
  00711	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00716	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0071e	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00725	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00729	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0072e	75 16		 jne	 SHORT $LN237@inflateBac@2
  00730	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00739	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00741	e9 d5 14 00 00	 jmp	 $inf_leave$4912
$LN237@inflateBac@2:
$LN238@inflateBac@2:
  00746	33 c0		 xor	 eax, eax
  00748	85 c0		 test	 eax, eax
  0074a	75 be		 jne	 SHORT $LN241@inflateBac@2
  0074c	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00750	ff c8		 dec	 eax
  00752	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00756	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0075b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0075e	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00762	d3 e0		 shl	 eax, cl
  00764	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00768	03 c8		 add	 ecx, eax
  0076a	8b c1		 mov	 eax, ecx
  0076c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00770	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00775	48 ff c0	 inc	 rax
  00778	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  0077d	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00781	83 c0 08	 add	 eax, 8
  00784	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00788	33 c0		 xor	 eax, eax
  0078a	85 c0		 test	 eax, eax
  0078c	0f 85 78 ff ff
	ff		 jne	 $LN244@inflateBac@2
  00792	e9 68 ff ff ff	 jmp	 $LN246@inflateBac@2
$LN245@inflateBac@2:
  00797	33 c0		 xor	 eax, eax
  00799	85 c0		 test	 eax, eax
  0079b	0f 85 5e ff ff
	ff		 jne	 $LN249@inflateBac@2

; 371  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  007a1	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  007a5	83 e0 07	 and	 eax, 7
  007a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  007ad	8b 49 7c	 mov	 ecx, DWORD PTR [rcx+124]
  007b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?order@?1??inflateBack@@9@9
  007b7	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  007bb	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  007c0	66 89 84 4a 88
	00 00 00	 mov	 WORD PTR [rdx+rcx*2+136], ax
  007c8	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007cd	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  007d0	ff c0		 inc	 eax
  007d2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  007d7	89 41 7c	 mov	 DWORD PTR [rcx+124], eax
$LN236@inflateBac@2:

; 372  :                 DROPBITS(3);

  007da	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  007de	c1 e8 03	 shr	 eax, 3
  007e1	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  007e5	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  007e9	83 e8 03	 sub	 eax, 3
  007ec	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  007f0	33 c0		 xor	 eax, eax
  007f2	85 c0		 test	 eax, eax
  007f4	75 e4		 jne	 SHORT $LN236@inflateBac@2

; 373  :             }

  007f6	e9 ee fe ff ff	 jmp	 $LN251@inflateBac@2
$LN250@inflateBac@2:
$LN233@inflateBac@2:

; 374  :             while (state->have < 19)

  007fb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00800	83 78 7c 13	 cmp	 DWORD PTR [rax+124], 19
  00804	73 36		 jae	 SHORT $LN232@inflateBac@2

; 375  :                 state->lens[order[state->have++]] = 0;

  00806	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0080b	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  0080e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?order@?1??inflateBack@@9@9
  00815	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00819	33 c9		 xor	 ecx, ecx
  0081b	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  00820	66 89 8c 42 88
	00 00 00	 mov	 WORD PTR [rdx+rax*2+136], cx
  00828	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0082d	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00830	ff c0		 inc	 eax
  00832	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00837	89 41 7c	 mov	 DWORD PTR [rcx+124], eax
  0083a	eb bf		 jmp	 SHORT $LN233@inflateBac@2
$LN232@inflateBac@2:

; 376  :             state->next = state->codes;

  0083c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00841	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  00847	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0084c	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 377  :             state->lencode = (code const FAR *)(state->next);

  00853	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00858	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0085d	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00864	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 378  :             state->lenbits = 7;

  00868	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0086d	c7 40 68 07 00
	00 00		 mov	 DWORD PTR [rax+104], 7

; 379  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 380  :                                 &(state->lenbits), state->work);

  00874	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00879	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  0087f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00884	48 83 c1 68	 add	 rcx, 104		; 00000068H
  00888	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  0088d	48 81 c2 80 00
	00 00		 add	 rdx, 128		; 00000080H
  00894	4c 8b 44 24 70	 mov	 r8, QWORD PTR state$[rsp]
  00899	49 81 c0 88 00
	00 00		 add	 r8, 136			; 00000088H
  008a0	4c 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv308[rsp], r8
  008a8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008ad	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  008b2	4c 8b ca	 mov	 r9, rdx
  008b5	41 b8 13 00 00
	00		 mov	 r8d, 19
  008bb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv308[rsp]
  008c3	48 8b d0	 mov	 rdx, rax
  008c6	33 c9		 xor	 ecx, ecx
  008c8	e8 00 00 00 00	 call	 inflate_table
  008cd	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 381  :             if (ret) {

  008d1	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  008d6	74 23		 je	 SHORT $LN231@inflateBac@2

; 382  :                 strm->msg = (char *)"invalid code lengths set";

  008d8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  008e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  008e7	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 383  :                 state->mode = BAD;

  008eb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  008f0	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 384  :                 break;

  008f6	e9 1b 13 00 00	 jmp	 $LN342@inflateBac@2
$LN231@inflateBac@2:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;

  008fb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00900	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0
$LN230@inflateBac@2:

; 390  :             while (state->have < state->nlen + state->ndist) {

  00907	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0090c	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0090f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00914	03 41 78	 add	 eax, DWORD PTR [rcx+120]
  00917	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0091c	39 41 7c	 cmp	 DWORD PTR [rcx+124], eax
  0091f	0f 83 e1 05 00
	00		 jae	 $LN229@inflateBac@2
$LN228@inflateBac@2:

; 391  :                 for (;;) {
; 392  :                     here = state->lencode[BITS(state->lenbits)];

  00925	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0092a	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0092d	b9 01 00 00 00	 mov	 ecx, 1
  00932	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv1173[rsp], ecx
  00939	0f b6 c8	 movzx	 ecx, al
  0093c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv1173[rsp]
  00943	d3 e0		 shl	 eax, cl
  00945	ff c8		 dec	 eax
  00947	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0094b	23 c8		 and	 ecx, eax
  0094d	8b c1		 mov	 eax, ecx
  0094f	8b c0		 mov	 eax, eax
  00951	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00956	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0095a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0095d	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 393  :                     if ((unsigned)(here.bits) <= bits) break;

  00961	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00966	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  0096a	77 05		 ja	 SHORT $LN226@inflateBac@2
  0096c	e9 8d 00 00 00	 jmp	 $LN227@inflateBac@2
$LN226@inflateBac@2:
$LN225@inflateBac@2:
$LN222@inflateBac@2:

; 394  :                     PULLBYTE();

  00971	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00976	75 35		 jne	 SHORT $LN219@inflateBac@2
  00978	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0097d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00985	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0098c	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00990	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00995	75 16		 jne	 SHORT $LN218@inflateBac@2
  00997	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  009a0	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  009a8	e9 6e 12 00 00	 jmp	 $inf_leave$4912
$LN218@inflateBac@2:
$LN219@inflateBac@2:
  009ad	33 c0		 xor	 eax, eax
  009af	85 c0		 test	 eax, eax
  009b1	75 be		 jne	 SHORT $LN222@inflateBac@2
  009b3	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  009b7	ff c8		 dec	 eax
  009b9	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  009bd	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  009c2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  009c5	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  009c9	d3 e0		 shl	 eax, cl
  009cb	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  009cf	03 c8		 add	 ecx, eax
  009d1	8b c1		 mov	 eax, ecx
  009d3	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  009d7	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  009dc	48 ff c0	 inc	 rax
  009df	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  009e4	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  009e8	83 c0 08	 add	 eax, 8
  009eb	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  009ef	33 c0		 xor	 eax, eax
  009f1	85 c0		 test	 eax, eax
  009f3	0f 85 78 ff ff
	ff		 jne	 $LN225@inflateBac@2

; 395  :                 }

  009f9	e9 27 ff ff ff	 jmp	 $LN228@inflateBac@2
$LN227@inflateBac@2:

; 396  :                 if (here.val < 16) {

  009fe	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  00a03	83 f8 10	 cmp	 eax, 16
  00a06	0f 8d 00 01 00
	00		 jge	 $LN217@inflateBac@2
$LN216@inflateBac@2:
$LN213@inflateBac@2:

; 397  :                     NEEDBITS(here.bits);

  00a0c	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00a11	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  00a15	0f 83 8d 00 00
	00		 jae	 $LN212@inflateBac@2
$LN211@inflateBac@2:
$LN208@inflateBac@2:
  00a1b	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00a20	75 35		 jne	 SHORT $LN205@inflateBac@2
  00a22	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00a27	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00a2f	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00a36	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00a3a	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00a3f	75 16		 jne	 SHORT $LN204@inflateBac@2
  00a41	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00a4a	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00a52	e9 c4 11 00 00	 jmp	 $inf_leave$4912
$LN204@inflateBac@2:
$LN205@inflateBac@2:
  00a57	33 c0		 xor	 eax, eax
  00a59	85 c0		 test	 eax, eax
  00a5b	75 be		 jne	 SHORT $LN208@inflateBac@2
  00a5d	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00a61	ff c8		 dec	 eax
  00a63	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00a67	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00a6c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a6f	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00a73	d3 e0		 shl	 eax, cl
  00a75	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00a79	03 c8		 add	 ecx, eax
  00a7b	8b c1		 mov	 eax, ecx
  00a7d	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00a81	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00a86	48 ff c0	 inc	 rax
  00a89	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00a8e	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00a92	83 c0 08	 add	 eax, 8
  00a95	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00a99	33 c0		 xor	 eax, eax
  00a9b	85 c0		 test	 eax, eax
  00a9d	0f 85 78 ff ff
	ff		 jne	 $LN211@inflateBac@2
  00aa3	e9 64 ff ff ff	 jmp	 $LN213@inflateBac@2
$LN212@inflateBac@2:
  00aa8	33 c0		 xor	 eax, eax
  00aaa	85 c0		 test	 eax, eax
  00aac	0f 85 5a ff ff
	ff		 jne	 $LN216@inflateBac@2
$LN203@inflateBac@2:

; 398  :                     DROPBITS(here.bits);

  00ab2	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00ab7	0f b6 c8	 movzx	 ecx, al
  00aba	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00abe	d3 e8		 shr	 eax, cl
  00ac0	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00ac4	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00ac9	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00acd	2b c8		 sub	 ecx, eax
  00acf	8b c1		 mov	 eax, ecx
  00ad1	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00ad5	33 c0		 xor	 eax, eax
  00ad7	85 c0		 test	 eax, eax
  00ad9	75 d7		 jne	 SHORT $LN203@inflateBac@2

; 399  :                     state->lens[state->have++] = here.val;

  00adb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ae0	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00ae3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00ae8	0f b7 54 24 3e	 movzx	 edx, WORD PTR here$[rsp+2]
  00aed	66 89 94 41 88
	00 00 00	 mov	 WORD PTR [rcx+rax*2+136], dx
  00af5	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00afa	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00afd	ff c0		 inc	 eax
  00aff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00b04	89 41 7c	 mov	 DWORD PTR [rcx+124], eax

; 400  :                 }
; 401  :                 else {

  00b07	e9 f5 03 00 00	 jmp	 $LN200@inflateBac@2
$LN217@inflateBac@2:

; 402  :                     if (here.val == 16) {

  00b0c	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  00b11	83 f8 10	 cmp	 eax, 16
  00b14	0f 85 4c 01 00
	00		 jne	 $LN199@inflateBac@2
$LN198@inflateBac@2:
$LN195@inflateBac@2:

; 403  :                         NEEDBITS(here.bits + 2);

  00b1a	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00b1f	83 c0 02	 add	 eax, 2
  00b22	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  00b26	0f 83 8d 00 00
	00		 jae	 $LN194@inflateBac@2
$LN193@inflateBac@2:
$LN190@inflateBac@2:
  00b2c	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00b31	75 35		 jne	 SHORT $LN187@inflateBac@2
  00b33	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00b38	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00b40	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00b47	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00b4b	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00b50	75 16		 jne	 SHORT $LN186@inflateBac@2
  00b52	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00b5b	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00b63	e9 b3 10 00 00	 jmp	 $inf_leave$4912
$LN186@inflateBac@2:
$LN187@inflateBac@2:
  00b68	33 c0		 xor	 eax, eax
  00b6a	85 c0		 test	 eax, eax
  00b6c	75 be		 jne	 SHORT $LN190@inflateBac@2
  00b6e	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00b72	ff c8		 dec	 eax
  00b74	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00b78	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00b7d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b80	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00b84	d3 e0		 shl	 eax, cl
  00b86	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00b8a	03 c8		 add	 ecx, eax
  00b8c	8b c1		 mov	 eax, ecx
  00b8e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00b92	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00b97	48 ff c0	 inc	 rax
  00b9a	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00b9f	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00ba3	83 c0 08	 add	 eax, 8
  00ba6	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00baa	33 c0		 xor	 eax, eax
  00bac	85 c0		 test	 eax, eax
  00bae	0f 85 78 ff ff
	ff		 jne	 $LN193@inflateBac@2
  00bb4	e9 61 ff ff ff	 jmp	 $LN195@inflateBac@2
$LN194@inflateBac@2:
  00bb9	33 c0		 xor	 eax, eax
  00bbb	85 c0		 test	 eax, eax
  00bbd	0f 85 57 ff ff
	ff		 jne	 $LN198@inflateBac@2
$LN185@inflateBac@2:

; 404  :                         DROPBITS(here.bits);

  00bc3	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00bc8	0f b6 c8	 movzx	 ecx, al
  00bcb	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00bcf	d3 e8		 shr	 eax, cl
  00bd1	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00bd5	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00bda	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00bde	2b c8		 sub	 ecx, eax
  00be0	8b c1		 mov	 eax, ecx
  00be2	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00be6	33 c0		 xor	 eax, eax
  00be8	85 c0		 test	 eax, eax
  00bea	75 d7		 jne	 SHORT $LN185@inflateBac@2

; 405  :                         if (state->have == 0) {

  00bec	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00bf1	83 78 7c 00	 cmp	 DWORD PTR [rax+124], 0
  00bf5	75 23		 jne	 SHORT $LN182@inflateBac@2

; 406  :                             strm->msg = (char *)"invalid bit length repeat";

  00bf7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00bff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00c06	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 407  :                             state->mode = BAD;

  00c0a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00c0f	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 408  :                             break;

  00c15	e9 ec 02 00 00	 jmp	 $LN229@inflateBac@2
$LN182@inflateBac@2:

; 409  :                         }
; 410  :                         len = (unsigned)(state->lens[state->have - 1]);

  00c1a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00c1f	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00c22	ff c8		 dec	 eax
  00c24	8b c0		 mov	 eax, eax
  00c26	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00c2b	0f b7 84 41 88
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+136]
  00c33	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 411  :                         copy = 3 + BITS(2);

  00c37	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00c3b	83 e0 03	 and	 eax, 3
  00c3e	83 c0 03	 add	 eax, 3
  00c41	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN181@inflateBac@2:

; 412  :                         DROPBITS(2);

  00c45	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00c49	c1 e8 02	 shr	 eax, 2
  00c4c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00c50	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00c54	83 e8 02	 sub	 eax, 2
  00c57	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00c5b	33 c0		 xor	 eax, eax
  00c5d	85 c0		 test	 eax, eax
  00c5f	75 e4		 jne	 SHORT $LN181@inflateBac@2

; 413  :                     }
; 414  :                     else if (here.val == 17) {

  00c61	e9 1b 02 00 00	 jmp	 $LN178@inflateBac@2
$LN199@inflateBac@2:
  00c66	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  00c6b	83 f8 11	 cmp	 eax, 17
  00c6e	0f 85 09 01 00
	00		 jne	 $LN177@inflateBac@2
$LN176@inflateBac@2:
$LN173@inflateBac@2:

; 415  :                         NEEDBITS(here.bits + 3);

  00c74	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00c79	83 c0 03	 add	 eax, 3
  00c7c	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  00c80	0f 83 8d 00 00
	00		 jae	 $LN172@inflateBac@2
$LN171@inflateBac@2:
$LN168@inflateBac@2:
  00c86	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00c8b	75 35		 jne	 SHORT $LN165@inflateBac@2
  00c8d	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00c92	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00c9a	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00ca1	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00ca5	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00caa	75 16		 jne	 SHORT $LN164@inflateBac@2
  00cac	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00cb5	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00cbd	e9 59 0f 00 00	 jmp	 $inf_leave$4912
$LN164@inflateBac@2:
$LN165@inflateBac@2:
  00cc2	33 c0		 xor	 eax, eax
  00cc4	85 c0		 test	 eax, eax
  00cc6	75 be		 jne	 SHORT $LN168@inflateBac@2
  00cc8	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00ccc	ff c8		 dec	 eax
  00cce	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00cd2	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00cd7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00cda	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00cde	d3 e0		 shl	 eax, cl
  00ce0	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00ce4	03 c8		 add	 ecx, eax
  00ce6	8b c1		 mov	 eax, ecx
  00ce8	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00cec	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00cf1	48 ff c0	 inc	 rax
  00cf4	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00cf9	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00cfd	83 c0 08	 add	 eax, 8
  00d00	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00d04	33 c0		 xor	 eax, eax
  00d06	85 c0		 test	 eax, eax
  00d08	0f 85 78 ff ff
	ff		 jne	 $LN171@inflateBac@2
  00d0e	e9 61 ff ff ff	 jmp	 $LN173@inflateBac@2
$LN172@inflateBac@2:
  00d13	33 c0		 xor	 eax, eax
  00d15	85 c0		 test	 eax, eax
  00d17	0f 85 57 ff ff
	ff		 jne	 $LN176@inflateBac@2
$LN163@inflateBac@2:

; 416  :                         DROPBITS(here.bits);

  00d1d	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00d22	0f b6 c8	 movzx	 ecx, al
  00d25	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00d29	d3 e8		 shr	 eax, cl
  00d2b	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00d2f	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00d34	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00d38	2b c8		 sub	 ecx, eax
  00d3a	8b c1		 mov	 eax, ecx
  00d3c	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00d40	33 c0		 xor	 eax, eax
  00d42	85 c0		 test	 eax, eax
  00d44	75 d7		 jne	 SHORT $LN163@inflateBac@2

; 417  :                         len = 0;

  00d46	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 418  :                         copy = 3 + BITS(3);

  00d4e	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00d52	83 e0 07	 and	 eax, 7
  00d55	83 c0 03	 add	 eax, 3
  00d58	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN160@inflateBac@2:

; 419  :                         DROPBITS(3);

  00d5c	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00d60	c1 e8 03	 shr	 eax, 3
  00d63	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00d67	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00d6b	83 e8 03	 sub	 eax, 3
  00d6e	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00d72	33 c0		 xor	 eax, eax
  00d74	85 c0		 test	 eax, eax
  00d76	75 e4		 jne	 SHORT $LN160@inflateBac@2

; 420  :                     }
; 421  :                     else {

  00d78	e9 04 01 00 00	 jmp	 $LN157@inflateBac@2
$LN177@inflateBac@2:
$LN156@inflateBac@2:
$LN153@inflateBac@2:

; 422  :                         NEEDBITS(here.bits + 7);

  00d7d	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00d82	83 c0 07	 add	 eax, 7
  00d85	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  00d89	0f 83 8d 00 00
	00		 jae	 $LN152@inflateBac@2
$LN151@inflateBac@2:
$LN148@inflateBac@2:
  00d8f	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00d94	75 35		 jne	 SHORT $LN145@inflateBac@2
  00d96	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00d9b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00da3	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00daa	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00dae	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00db3	75 16		 jne	 SHORT $LN144@inflateBac@2
  00db5	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00dbe	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00dc6	e9 50 0e 00 00	 jmp	 $inf_leave$4912
$LN144@inflateBac@2:
$LN145@inflateBac@2:
  00dcb	33 c0		 xor	 eax, eax
  00dcd	85 c0		 test	 eax, eax
  00dcf	75 be		 jne	 SHORT $LN148@inflateBac@2
  00dd1	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00dd5	ff c8		 dec	 eax
  00dd7	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00ddb	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00de0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00de3	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00de7	d3 e0		 shl	 eax, cl
  00de9	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00ded	03 c8		 add	 ecx, eax
  00def	8b c1		 mov	 eax, ecx
  00df1	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00df5	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00dfa	48 ff c0	 inc	 rax
  00dfd	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00e02	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00e06	83 c0 08	 add	 eax, 8
  00e09	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00e0d	33 c0		 xor	 eax, eax
  00e0f	85 c0		 test	 eax, eax
  00e11	0f 85 78 ff ff
	ff		 jne	 $LN151@inflateBac@2
  00e17	e9 61 ff ff ff	 jmp	 $LN153@inflateBac@2
$LN152@inflateBac@2:
  00e1c	33 c0		 xor	 eax, eax
  00e1e	85 c0		 test	 eax, eax
  00e20	0f 85 57 ff ff
	ff		 jne	 $LN156@inflateBac@2
$LN143@inflateBac@2:

; 423  :                         DROPBITS(here.bits);

  00e26	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00e2b	0f b6 c8	 movzx	 ecx, al
  00e2e	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00e32	d3 e8		 shr	 eax, cl
  00e34	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00e38	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00e3d	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00e41	2b c8		 sub	 ecx, eax
  00e43	8b c1		 mov	 eax, ecx
  00e45	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00e49	33 c0		 xor	 eax, eax
  00e4b	85 c0		 test	 eax, eax
  00e4d	75 d7		 jne	 SHORT $LN143@inflateBac@2

; 424  :                         len = 0;

  00e4f	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 425  :                         copy = 11 + BITS(7);

  00e57	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00e5b	83 e0 7f	 and	 eax, 127		; 0000007fH
  00e5e	83 c0 0b	 add	 eax, 11
  00e61	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN140@inflateBac@2:

; 426  :                         DROPBITS(7);

  00e65	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00e69	c1 e8 07	 shr	 eax, 7
  00e6c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00e70	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00e74	83 e8 07	 sub	 eax, 7
  00e77	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00e7b	33 c0		 xor	 eax, eax
  00e7d	85 c0		 test	 eax, eax
  00e7f	75 e4		 jne	 SHORT $LN140@inflateBac@2
$LN157@inflateBac@2:
$LN178@inflateBac@2:

; 427  :                     }
; 428  :                     if (state->have + copy > state->nlen + state->ndist) {

  00e81	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00e86	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00e89	03 44 24 60	 add	 eax, DWORD PTR copy$[rsp]
  00e8d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00e92	8b 49 74	 mov	 ecx, DWORD PTR [rcx+116]
  00e95	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  00e9a	03 4a 78	 add	 ecx, DWORD PTR [rdx+120]
  00e9d	3b c1		 cmp	 eax, ecx
  00e9f	76 20		 jbe	 SHORT $LN137@inflateBac@2

; 429  :                         strm->msg = (char *)"invalid bit length repeat";

  00ea1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00ea9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00eb0	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 430  :                         state->mode = BAD;

  00eb4	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00eb9	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 431  :                         break;

  00ebf	eb 45		 jmp	 SHORT $LN229@inflateBac@2
$LN137@inflateBac@2:
$LN136@inflateBac@2:

; 432  :                     }
; 433  :                     while (copy--)

  00ec1	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00ec5	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  00ec9	ff c9		 dec	 ecx
  00ecb	89 4c 24 60	 mov	 DWORD PTR copy$[rsp], ecx
  00ecf	85 c0		 test	 eax, eax
  00ed1	74 2e		 je	 SHORT $LN135@inflateBac@2

; 434  :                         state->lens[state->have++] = (unsigned short)len;

  00ed3	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ed8	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00edb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00ee0	0f b7 54 24 44	 movzx	 edx, WORD PTR len$[rsp]
  00ee5	66 89 94 41 88
	00 00 00	 mov	 WORD PTR [rcx+rax*2+136], dx
  00eed	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ef2	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00ef5	ff c0		 inc	 eax
  00ef7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00efc	89 41 7c	 mov	 DWORD PTR [rcx+124], eax
  00eff	eb c0		 jmp	 SHORT $LN136@inflateBac@2
$LN135@inflateBac@2:
$LN200@inflateBac@2:

; 435  :                 }
; 436  :             }

  00f01	e9 01 fa ff ff	 jmp	 $LN230@inflateBac@2
$LN229@inflateBac@2:

; 437  : 
; 438  :             /* handle error breaks in while */
; 439  :             if (state->mode == BAD) break;

  00f06	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f0b	83 38 1d	 cmp	 DWORD PTR [rax], 29
  00f0e	75 05		 jne	 SHORT $LN134@inflateBac@2
  00f10	e9 01 0d 00 00	 jmp	 $LN342@inflateBac@2
$LN134@inflateBac@2:

; 440  : 
; 441  :             /* check for end-of-block code (better have one) */
; 442  :             if (state->lens[256] == 0) {

  00f15	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f1a	0f b7 80 88 02
	00 00		 movzx	 eax, WORD PTR [rax+648]
  00f21	85 c0		 test	 eax, eax
  00f23	75 23		 jne	 SHORT $LN133@inflateBac@2

; 443  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00f25	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00f2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
  00f34	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 444  :                 state->mode = BAD;

  00f38	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f3d	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 445  :                 break;

  00f43	e9 ce 0c 00 00	 jmp	 $LN342@inflateBac@2
$LN133@inflateBac@2:

; 446  :             }
; 447  : 
; 448  :             /* build code tables -- note: do not change the lenbits or distbits
; 449  :                values here (9 and 6) without reading the comments in inftrees.h
; 450  :                concerning the ENOUGH constants, which depend on those values */
; 451  :             state->next = state->codes;

  00f48	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f4d	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  00f53	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00f58	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 452  :             state->lencode = (code const FAR *)(state->next);

  00f5f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f64	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00f69	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00f70	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 453  :             state->lenbits = 9;

  00f74	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f79	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 454  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 455  :                                 &(state->lenbits), state->work);

  00f80	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f85	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  00f8b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00f90	48 83 c1 68	 add	 rcx, 104		; 00000068H
  00f94	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  00f99	48 81 c2 80 00
	00 00		 add	 rdx, 128		; 00000080H
  00fa0	4c 8b 44 24 70	 mov	 r8, QWORD PTR state$[rsp]
  00fa5	49 81 c0 88 00
	00 00		 add	 r8, 136			; 00000088H
  00fac	4c 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv506[rsp], r8
  00fb4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00fb9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00fbe	4c 8b ca	 mov	 r9, rdx
  00fc1	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00fc6	44 8b 40 74	 mov	 r8d, DWORD PTR [rax+116]
  00fca	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv506[rsp]
  00fd2	48 8b d0	 mov	 rdx, rax
  00fd5	b9 01 00 00 00	 mov	 ecx, 1
  00fda	e8 00 00 00 00	 call	 inflate_table
  00fdf	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 456  :             if (ret) {

  00fe3	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  00fe8	74 23		 je	 SHORT $LN132@inflateBac@2

; 457  :                 strm->msg = (char *)"invalid literal/lengths set";

  00fea	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00ff2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00ff9	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 458  :                 state->mode = BAD;

  00ffd	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01002	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 459  :                 break;

  01008	e9 09 0c 00 00	 jmp	 $LN342@inflateBac@2
$LN132@inflateBac@2:

; 460  :             }
; 461  :             state->distcode = (code const FAR *)(state->next);

  0100d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01012	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01017	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0101e	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 462  :             state->distbits = 6;

  01022	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01027	c7 40 6c 06 00
	00 00		 mov	 DWORD PTR [rax+108], 6

; 463  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 464  :                             &(state->next), &(state->distbits), state->work);

  0102e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01033	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  01039	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0103e	48 83 c1 6c	 add	 rcx, 108		; 0000006cH
  01042	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  01047	48 81 c2 80 00
	00 00		 add	 rdx, 128		; 00000080H
  0104e	4c 8b 44 24 70	 mov	 r8, QWORD PTR state$[rsp]
  01053	45 8b 40 74	 mov	 r8d, DWORD PTR [r8+116]
  01057	4c 8b 4c 24 70	 mov	 r9, QWORD PTR state$[rsp]
  0105c	4f 8d 84 41 88
	00 00 00	 lea	 r8, QWORD PTR [r9+r8*2+136]
  01064	4c 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv527[rsp], r8
  0106c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01071	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01076	4c 8b ca	 mov	 r9, rdx
  01079	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0107e	44 8b 40 78	 mov	 r8d, DWORD PTR [rax+120]
  01082	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv527[rsp]
  0108a	48 8b d0	 mov	 rdx, rax
  0108d	b9 02 00 00 00	 mov	 ecx, 2
  01092	e8 00 00 00 00	 call	 inflate_table
  01097	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 465  :             if (ret) {

  0109b	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  010a0	74 23		 je	 SHORT $LN131@inflateBac@2

; 466  :                 strm->msg = (char *)"invalid distances set";

  010a2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  010aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  010b1	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 467  :                 state->mode = BAD;

  010b5	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  010ba	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 468  :                 break;

  010c0	e9 51 0b 00 00	 jmp	 $LN342@inflateBac@2
$LN131@inflateBac@2:

; 469  :             }
; 470  :             Tracev((stderr, "inflate:       codes ok\n"));
; 471  :             state->mode = LEN;

  010c5	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  010ca	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20
$LN130@inflateBac@2:

; 472  : 
; 473  :         case LEN:
; 474  :             /* use inflate_fast() if we have enough input and output */
; 475  :             if (have >= 6 && left >= 258) {

  010d0	83 7c 24 40 06	 cmp	 DWORD PTR have$[rsp], 6
  010d5	0f 82 0a 01 00
	00		 jb	 $LN129@inflateBac@2
  010db	81 7c 24 4c 02
	01 00 00	 cmp	 DWORD PTR left$[rsp], 258 ; 00000102H
  010e3	0f 82 fc 00 00
	00		 jb	 $LN129@inflateBac@2
$LN128@inflateBac@2:

; 476  :                 RESTORE();

  010e9	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  010f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  010f6	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  010fa	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01102	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  01106	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  01109	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  01116	48 89 08	 mov	 QWORD PTR [rax], rcx
  01119	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01121	8b 4c 24 40	 mov	 ecx, DWORD PTR have$[rsp]
  01125	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  01128	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0112d	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  01131	89 48 40	 mov	 DWORD PTR [rax+64], ecx
  01134	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01139	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  0113d	89 48 44	 mov	 DWORD PTR [rax+68], ecx
  01140	33 c0		 xor	 eax, eax
  01142	85 c0		 test	 eax, eax
  01144	75 a3		 jne	 SHORT $LN128@inflateBac@2

; 477  :                 if (state->whave < state->wsize)

  01146	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0114b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01150	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  01153	39 48 30	 cmp	 DWORD PTR [rax+48], ecx
  01156	73 16		 jae	 SHORT $LN125@inflateBac@2

; 478  :                     state->whave = state->wsize - left;

  01158	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0115d	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  01161	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01164	2b c1		 sub	 eax, ecx
  01166	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0116b	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN125@inflateBac@2:

; 479  :                 inflate_fast(strm, state->wsize);

  0116e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01173	8b 50 2c	 mov	 edx, DWORD PTR [rax+44]
  01176	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0117e	e8 00 00 00 00	 call	 inflate_fast
$LN124@inflateBac@2:

; 480  :                 LOAD();

  01183	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0118b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0118f	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01194	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0119c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0119f	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  011a3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  011ab	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011ae	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  011b3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  011bb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  011be	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  011c2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  011c7	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  011ca	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  011ce	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  011d3	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  011d6	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  011da	33 c0		 xor	 eax, eax
  011dc	85 c0		 test	 eax, eax
  011de	75 a3		 jne	 SHORT $LN124@inflateBac@2

; 481  :                 break;

  011e0	e9 31 0a 00 00	 jmp	 $LN342@inflateBac@2
$LN129@inflateBac@2:
$LN121@inflateBac@2:

; 482  :             }
; 483  : 
; 484  :             /* get a literal, length, or end-of-block code */
; 485  :             for (;;) {
; 486  :                 here = state->lencode[BITS(state->lenbits)];

  011e5	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  011ea	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  011ed	b9 01 00 00 00	 mov	 ecx, 1
  011f2	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv1358[rsp], ecx
  011f9	0f b6 c8	 movzx	 ecx, al
  011fc	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv1358[rsp]
  01203	d3 e0		 shl	 eax, cl
  01205	ff c8		 dec	 eax
  01207	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0120b	23 c8		 and	 ecx, eax
  0120d	8b c1		 mov	 eax, ecx
  0120f	8b c0		 mov	 eax, eax
  01211	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01216	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0121a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0121d	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 487  :                 if ((unsigned)(here.bits) <= bits) break;

  01221	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01226	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  0122a	77 05		 ja	 SHORT $LN119@inflateBac@2
  0122c	e9 8d 00 00 00	 jmp	 $LN120@inflateBac@2
$LN119@inflateBac@2:
$LN118@inflateBac@2:
$LN115@inflateBac@2:

; 488  :                 PULLBYTE();

  01231	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01236	75 35		 jne	 SHORT $LN112@inflateBac@2
  01238	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0123d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01245	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0124c	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01250	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01255	75 16		 jne	 SHORT $LN111@inflateBac@2
  01257	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  01260	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01268	e9 ae 09 00 00	 jmp	 $inf_leave$4912
$LN111@inflateBac@2:
$LN112@inflateBac@2:
  0126d	33 c0		 xor	 eax, eax
  0126f	85 c0		 test	 eax, eax
  01271	75 be		 jne	 SHORT $LN115@inflateBac@2
  01273	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01277	ff c8		 dec	 eax
  01279	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0127d	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01282	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01285	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  01289	d3 e0		 shl	 eax, cl
  0128b	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0128f	03 c8		 add	 ecx, eax
  01291	8b c1		 mov	 eax, ecx
  01293	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01297	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0129c	48 ff c0	 inc	 rax
  0129f	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  012a4	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  012a8	83 c0 08	 add	 eax, 8
  012ab	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  012af	33 c0		 xor	 eax, eax
  012b1	85 c0		 test	 eax, eax
  012b3	0f 85 78 ff ff
	ff		 jne	 $LN118@inflateBac@2

; 489  :             }

  012b9	e9 27 ff ff ff	 jmp	 $LN121@inflateBac@2
$LN120@inflateBac@2:

; 490  :             if (here.op && (here.op & 0xf0) == 0) {

  012be	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  012c3	85 c0		 test	 eax, eax
  012c5	0f 84 39 01 00
	00		 je	 $LN110@inflateBac@2
  012cb	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  012d0	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  012d5	85 c0		 test	 eax, eax
  012d7	0f 85 27 01 00
	00		 jne	 $LN110@inflateBac@2

; 491  :                 last = here;

  012dd	8b 44 24 3c	 mov	 eax, DWORD PTR here$[rsp]
  012e1	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN109@inflateBac@2:

; 492  :                 for (;;) {
; 493  :                     here = state->lencode[last.val +
; 494  :                             (BITS(last.bits + last.op) >> last.bits)];

  012e5	0f b7 44 24 3a	 movzx	 eax, WORD PTR last$[rsp+2]
  012ea	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  012ef	0f b6 54 24 38	 movzx	 edx, BYTE PTR last$[rsp]
  012f4	03 ca		 add	 ecx, edx
  012f6	ba 01 00 00 00	 mov	 edx, 1
  012fb	d3 e2		 shl	 edx, cl
  012fd	8b ca		 mov	 ecx, edx
  012ff	ff c9		 dec	 ecx
  01301	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  01305	23 d1		 and	 edx, ecx
  01307	8b ca		 mov	 ecx, edx
  01309	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv591[rsp], ecx
  01310	0f b6 54 24 39	 movzx	 edx, BYTE PTR last$[rsp+1]
  01315	0f b6 ca	 movzx	 ecx, dl
  01318	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR tv591[rsp]
  0131f	d3 ea		 shr	 edx, cl
  01321	8b ca		 mov	 ecx, edx
  01323	03 c1		 add	 eax, ecx
  01325	8b c0		 mov	 eax, eax
  01327	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0132c	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  01330	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  01333	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 495  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01337	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  0133c	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  01341	03 c1		 add	 eax, ecx
  01343	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  01347	77 05		 ja	 SHORT $LN107@inflateBac@2
  01349	e9 8d 00 00 00	 jmp	 $LN108@inflateBac@2
$LN107@inflateBac@2:
$LN106@inflateBac@2:
$LN103@inflateBac@2:

; 496  :                     PULLBYTE();

  0134e	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01353	75 35		 jne	 SHORT $LN100@inflateBac@2
  01355	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0135a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01362	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  01369	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0136d	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01372	75 16		 jne	 SHORT $LN99@inflateBac@2
  01374	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0137d	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01385	e9 91 08 00 00	 jmp	 $inf_leave$4912
$LN99@inflateBac@2:
$LN100@inflateBac@2:
  0138a	33 c0		 xor	 eax, eax
  0138c	85 c0		 test	 eax, eax
  0138e	75 be		 jne	 SHORT $LN103@inflateBac@2
  01390	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01394	ff c8		 dec	 eax
  01396	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0139a	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0139f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  013a2	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  013a6	d3 e0		 shl	 eax, cl
  013a8	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  013ac	03 c8		 add	 ecx, eax
  013ae	8b c1		 mov	 eax, ecx
  013b0	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  013b4	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  013b9	48 ff c0	 inc	 rax
  013bc	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  013c1	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  013c5	83 c0 08	 add	 eax, 8
  013c8	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  013cc	33 c0		 xor	 eax, eax
  013ce	85 c0		 test	 eax, eax
  013d0	0f 85 78 ff ff
	ff		 jne	 $LN106@inflateBac@2

; 497  :                 }

  013d6	e9 0a ff ff ff	 jmp	 $LN109@inflateBac@2
$LN108@inflateBac@2:
$LN98@inflateBac@2:

; 498  :                 DROPBITS(last.bits);

  013db	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  013e0	0f b6 c8	 movzx	 ecx, al
  013e3	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  013e7	d3 e8		 shr	 eax, cl
  013e9	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  013ed	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  013f2	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  013f6	2b c8		 sub	 ecx, eax
  013f8	8b c1		 mov	 eax, ecx
  013fa	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  013fe	33 c0		 xor	 eax, eax
  01400	85 c0		 test	 eax, eax
  01402	75 d7		 jne	 SHORT $LN98@inflateBac@2
$LN110@inflateBac@2:
$LN95@inflateBac@2:

; 499  :             }
; 500  :             DROPBITS(here.bits);

  01404	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01409	0f b6 c8	 movzx	 ecx, al
  0140c	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01410	d3 e8		 shr	 eax, cl
  01412	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01416	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  0141b	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  0141f	2b c8		 sub	 ecx, eax
  01421	8b c1		 mov	 eax, ecx
  01423	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01427	33 c0		 xor	 eax, eax
  01429	85 c0		 test	 eax, eax
  0142b	75 d7		 jne	 SHORT $LN95@inflateBac@2

; 501  :             state->length = (unsigned)here.val;

  0142d	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  01432	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01437	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 502  : 
; 503  :             /* process literal */
; 504  :             if (here.op == 0) {

  0143a	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  0143f	85 c0		 test	 eax, eax
  01441	0f 85 94 00 00
	00		 jne	 $LN92@inflateBac@2
$LN91@inflateBac@2:

; 505  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 506  :                         "inflate:         literal '%c'\n" :
; 507  :                         "inflate:         literal 0x%02x\n", here.val));
; 508  :                 ROOM();

  01447	83 7c 24 4c 00	 cmp	 DWORD PTR left$[rsp], 0
  0144c	75 50		 jne	 SHORT $LN88@inflateBac@2
  0144e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01453	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  01457	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  0145c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01461	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01464	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  01468	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0146d	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  01471	89 48 30	 mov	 DWORD PTR [rax+48], ecx
  01474	44 8b 44 24 4c	 mov	 r8d, DWORD PTR left$[rsp]
  01479	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  0147e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  01486	ff 94 24 f8 00
	00 00		 call	 QWORD PTR out$[rsp]
  0148d	85 c0		 test	 eax, eax
  0148f	74 0d		 je	 SHORT $LN87@inflateBac@2
  01491	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01499	e9 7d 07 00 00	 jmp	 $inf_leave$4912
$LN87@inflateBac@2:
$LN88@inflateBac@2:
  0149e	33 c0		 xor	 eax, eax
  014a0	85 c0		 test	 eax, eax
  014a2	75 a3		 jne	 SHORT $LN91@inflateBac@2

; 509  :                 *put++ = (unsigned char)(state->length);

  014a4	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  014a9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  014ae	0f b6 49 48	 movzx	 ecx, BYTE PTR [rcx+72]
  014b2	88 08		 mov	 BYTE PTR [rax], cl
  014b4	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  014b9	48 ff c0	 inc	 rax
  014bc	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 510  :                 left--;

  014c1	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  014c5	ff c8		 dec	 eax
  014c7	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax

; 511  :                 state->mode = LEN;

  014cb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  014d0	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20

; 512  :                 break;

  014d6	e9 3b 07 00 00	 jmp	 $LN342@inflateBac@2
$LN92@inflateBac@2:

; 513  :             }
; 514  : 
; 515  :             /* process end of block */
; 516  :             if (here.op & 32) {

  014db	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  014e0	83 e0 20	 and	 eax, 32			; 00000020H
  014e3	85 c0		 test	 eax, eax
  014e5	74 10		 je	 SHORT $LN86@inflateBac@2

; 517  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 518  :                 state->mode = TYPE;

  014e7	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  014ec	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 519  :                 break;

  014f2	e9 1f 07 00 00	 jmp	 $LN342@inflateBac@2
$LN86@inflateBac@2:

; 520  :             }
; 521  : 
; 522  :             /* invalid code */
; 523  :             if (here.op & 64) {

  014f7	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  014fc	83 e0 40	 and	 eax, 64			; 00000040H
  014ff	85 c0		 test	 eax, eax
  01501	74 23		 je	 SHORT $LN85@inflateBac@2

; 524  :                 strm->msg = (char *)"invalid literal/length code";

  01503	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0150b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  01512	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 525  :                 state->mode = BAD;

  01516	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0151b	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 526  :                 break;

  01521	e9 f0 06 00 00	 jmp	 $LN342@inflateBac@2
$LN85@inflateBac@2:

; 527  :             }
; 528  : 
; 529  :             /* length code -- get extra bits, if any */
; 530  :             state->extra = (unsigned)(here.op) & 15;

  01526	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  0152b	83 e0 0f	 and	 eax, 15
  0152e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01533	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 531  :             if (state->extra != 0) {

  01536	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0153b	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  0153f	0f 84 12 01 00
	00		 je	 $LN84@inflateBac@2
$LN83@inflateBac@2:
$LN80@inflateBac@2:

; 532  :                 NEEDBITS(state->extra);

  01545	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0154a	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0154d	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  01551	0f 83 8d 00 00
	00		 jae	 $LN79@inflateBac@2
$LN78@inflateBac@2:
$LN75@inflateBac@2:
  01557	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0155c	75 35		 jne	 SHORT $LN72@inflateBac@2
  0155e	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  01563	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0156b	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  01572	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01576	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0157b	75 16		 jne	 SHORT $LN71@inflateBac@2
  0157d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  01586	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0158e	e9 88 06 00 00	 jmp	 $inf_leave$4912
$LN71@inflateBac@2:
$LN72@inflateBac@2:
  01593	33 c0		 xor	 eax, eax
  01595	85 c0		 test	 eax, eax
  01597	75 be		 jne	 SHORT $LN75@inflateBac@2
  01599	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0159d	ff c8		 dec	 eax
  0159f	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  015a3	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  015a8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  015ab	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  015af	d3 e0		 shl	 eax, cl
  015b1	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  015b5	03 c8		 add	 ecx, eax
  015b7	8b c1		 mov	 eax, ecx
  015b9	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  015bd	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  015c2	48 ff c0	 inc	 rax
  015c5	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  015ca	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  015ce	83 c0 08	 add	 eax, 8
  015d1	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  015d5	33 c0		 xor	 eax, eax
  015d7	85 c0		 test	 eax, eax
  015d9	0f 85 78 ff ff
	ff		 jne	 $LN78@inflateBac@2
  015df	e9 61 ff ff ff	 jmp	 $LN80@inflateBac@2
$LN79@inflateBac@2:
  015e4	33 c0		 xor	 eax, eax
  015e6	85 c0		 test	 eax, eax
  015e8	0f 85 57 ff ff
	ff		 jne	 $LN83@inflateBac@2

; 533  :                 state->length += BITS(state->extra);

  015ee	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  015f3	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  015f6	b9 01 00 00 00	 mov	 ecx, 1
  015fb	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv1439[rsp], ecx
  01602	0f b6 c8	 movzx	 ecx, al
  01605	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv1439[rsp]
  0160c	d3 e0		 shl	 eax, cl
  0160e	ff c8		 dec	 eax
  01610	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  01614	23 c8		 and	 ecx, eax
  01616	8b c1		 mov	 eax, ecx
  01618	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0161d	03 41 48	 add	 eax, DWORD PTR [rcx+72]
  01620	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01625	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN70@inflateBac@2:

; 534  :                 DROPBITS(state->extra);

  01628	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0162d	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  01630	0f b6 c8	 movzx	 ecx, al
  01633	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01637	d3 e8		 shr	 eax, cl
  01639	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0163d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01642	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  01645	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  01649	2b c8		 sub	 ecx, eax
  0164b	8b c1		 mov	 eax, ecx
  0164d	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01651	33 c0		 xor	 eax, eax
  01653	85 c0		 test	 eax, eax
  01655	75 d1		 jne	 SHORT $LN70@inflateBac@2
$LN84@inflateBac@2:
$LN67@inflateBac@2:

; 535  :             }
; 536  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 537  : 
; 538  :             /* get distance code */
; 539  :             for (;;) {
; 540  :                 here = state->distcode[BITS(state->distbits)];

  01657	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0165c	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0165f	b9 01 00 00 00	 mov	 ecx, 1
  01664	89 8c 24 b4 00
	00 00		 mov	 DWORD PTR tv1455[rsp], ecx
  0166b	0f b6 c8	 movzx	 ecx, al
  0166e	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv1455[rsp]
  01675	d3 e0		 shl	 eax, cl
  01677	ff c8		 dec	 eax
  01679	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0167d	23 c8		 and	 ecx, eax
  0167f	8b c1		 mov	 eax, ecx
  01681	8b c0		 mov	 eax, eax
  01683	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01688	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0168c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0168f	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 541  :                 if ((unsigned)(here.bits) <= bits) break;

  01693	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01698	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  0169c	77 05		 ja	 SHORT $LN65@inflateBac@2
  0169e	e9 8d 00 00 00	 jmp	 $LN66@inflateBac@2
$LN65@inflateBac@2:
$LN64@inflateBac@2:
$LN61@inflateBac@2:

; 542  :                 PULLBYTE();

  016a3	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  016a8	75 35		 jne	 SHORT $LN58@inflateBac@2
  016aa	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  016af	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  016b7	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  016be	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  016c2	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  016c7	75 16		 jne	 SHORT $LN57@inflateBac@2
  016c9	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  016d2	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  016da	e9 3c 05 00 00	 jmp	 $inf_leave$4912
$LN57@inflateBac@2:
$LN58@inflateBac@2:
  016df	33 c0		 xor	 eax, eax
  016e1	85 c0		 test	 eax, eax
  016e3	75 be		 jne	 SHORT $LN61@inflateBac@2
  016e5	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  016e9	ff c8		 dec	 eax
  016eb	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  016ef	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  016f4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  016f7	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  016fb	d3 e0		 shl	 eax, cl
  016fd	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  01701	03 c8		 add	 ecx, eax
  01703	8b c1		 mov	 eax, ecx
  01705	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01709	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0170e	48 ff c0	 inc	 rax
  01711	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01716	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0171a	83 c0 08	 add	 eax, 8
  0171d	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01721	33 c0		 xor	 eax, eax
  01723	85 c0		 test	 eax, eax
  01725	0f 85 78 ff ff
	ff		 jne	 $LN64@inflateBac@2

; 543  :             }

  0172b	e9 27 ff ff ff	 jmp	 $LN67@inflateBac@2
$LN66@inflateBac@2:

; 544  :             if ((here.op & 0xf0) == 0) {

  01730	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  01735	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0173a	85 c0		 test	 eax, eax
  0173c	0f 85 27 01 00
	00		 jne	 $LN56@inflateBac@2

; 545  :                 last = here;

  01742	8b 44 24 3c	 mov	 eax, DWORD PTR here$[rsp]
  01746	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN55@inflateBac@2:

; 546  :                 for (;;) {
; 547  :                     here = state->distcode[last.val +
; 548  :                             (BITS(last.bits + last.op) >> last.bits)];

  0174a	0f b7 44 24 3a	 movzx	 eax, WORD PTR last$[rsp+2]
  0174f	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  01754	0f b6 54 24 38	 movzx	 edx, BYTE PTR last$[rsp]
  01759	03 ca		 add	 ecx, edx
  0175b	ba 01 00 00 00	 mov	 edx, 1
  01760	d3 e2		 shl	 edx, cl
  01762	8b ca		 mov	 ecx, edx
  01764	ff c9		 dec	 ecx
  01766	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  0176a	23 d1		 and	 edx, ecx
  0176c	8b ca		 mov	 ecx, edx
  0176e	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv717[rsp], ecx
  01775	0f b6 54 24 39	 movzx	 edx, BYTE PTR last$[rsp+1]
  0177a	0f b6 ca	 movzx	 ecx, dl
  0177d	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR tv717[rsp]
  01784	d3 ea		 shr	 edx, cl
  01786	8b ca		 mov	 ecx, edx
  01788	03 c1		 add	 eax, ecx
  0178a	8b c0		 mov	 eax, eax
  0178c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01791	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  01795	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  01798	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 549  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0179c	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  017a1	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  017a6	03 c1		 add	 eax, ecx
  017a8	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  017ac	77 05		 ja	 SHORT $LN53@inflateBac@2
  017ae	e9 8d 00 00 00	 jmp	 $LN54@inflateBac@2
$LN53@inflateBac@2:
$LN52@inflateBac@2:
$LN49@inflateBac@2:

; 550  :                     PULLBYTE();

  017b3	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  017b8	75 35		 jne	 SHORT $LN46@inflateBac@2
  017ba	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  017bf	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  017c7	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  017ce	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  017d2	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  017d7	75 16		 jne	 SHORT $LN45@inflateBac@2
  017d9	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  017e2	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  017ea	e9 2c 04 00 00	 jmp	 $inf_leave$4912
$LN45@inflateBac@2:
$LN46@inflateBac@2:
  017ef	33 c0		 xor	 eax, eax
  017f1	85 c0		 test	 eax, eax
  017f3	75 be		 jne	 SHORT $LN49@inflateBac@2
  017f5	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  017f9	ff c8		 dec	 eax
  017fb	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  017ff	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01804	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01807	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  0180b	d3 e0		 shl	 eax, cl
  0180d	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  01811	03 c8		 add	 ecx, eax
  01813	8b c1		 mov	 eax, ecx
  01815	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01819	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0181e	48 ff c0	 inc	 rax
  01821	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01826	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0182a	83 c0 08	 add	 eax, 8
  0182d	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01831	33 c0		 xor	 eax, eax
  01833	85 c0		 test	 eax, eax
  01835	0f 85 78 ff ff
	ff		 jne	 $LN52@inflateBac@2

; 551  :                 }

  0183b	e9 0a ff ff ff	 jmp	 $LN55@inflateBac@2
$LN54@inflateBac@2:
$LN44@inflateBac@2:

; 552  :                 DROPBITS(last.bits);

  01840	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  01845	0f b6 c8	 movzx	 ecx, al
  01848	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0184c	d3 e8		 shr	 eax, cl
  0184e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01852	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  01857	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  0185b	2b c8		 sub	 ecx, eax
  0185d	8b c1		 mov	 eax, ecx
  0185f	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01863	33 c0		 xor	 eax, eax
  01865	85 c0		 test	 eax, eax
  01867	75 d7		 jne	 SHORT $LN44@inflateBac@2
$LN56@inflateBac@2:
$LN41@inflateBac@2:

; 553  :             }
; 554  :             DROPBITS(here.bits);

  01869	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  0186e	0f b6 c8	 movzx	 ecx, al
  01871	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01875	d3 e8		 shr	 eax, cl
  01877	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0187b	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01880	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  01884	2b c8		 sub	 ecx, eax
  01886	8b c1		 mov	 eax, ecx
  01888	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0188c	33 c0		 xor	 eax, eax
  0188e	85 c0		 test	 eax, eax
  01890	75 d7		 jne	 SHORT $LN41@inflateBac@2

; 555  :             if (here.op & 64) {

  01892	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  01897	83 e0 40	 and	 eax, 64			; 00000040H
  0189a	85 c0		 test	 eax, eax
  0189c	74 23		 je	 SHORT $LN38@inflateBac@2

; 556  :                 strm->msg = (char *)"invalid distance code";

  0189e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  018a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  018ad	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 557  :                 state->mode = BAD;

  018b1	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  018b6	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 558  :                 break;

  018bc	e9 55 03 00 00	 jmp	 $LN342@inflateBac@2
$LN38@inflateBac@2:

; 559  :             }
; 560  :             state->offset = (unsigned)here.val;

  018c1	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  018c6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  018cb	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 561  : 
; 562  :             /* get distance extra bits, if any */
; 563  :             state->extra = (unsigned)(here.op) & 15;

  018ce	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  018d3	83 e0 0f	 and	 eax, 15
  018d6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  018db	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 564  :             if (state->extra != 0) {

  018de	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  018e3	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  018e7	0f 84 12 01 00
	00		 je	 $LN37@inflateBac@2
$LN36@inflateBac@2:
$LN33@inflateBac@2:

; 565  :                 NEEDBITS(state->extra);

  018ed	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  018f2	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  018f5	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  018f9	0f 83 8d 00 00
	00		 jae	 $LN32@inflateBac@2
$LN31@inflateBac@2:
$LN28@inflateBac@2:
  018ff	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01904	75 35		 jne	 SHORT $LN25@inflateBac@2
  01906	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0190b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01913	ff 94 24 e8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0191a	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0191e	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01923	75 16		 jne	 SHORT $LN24@inflateBac@2
  01925	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0192e	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01936	e9 e0 02 00 00	 jmp	 $inf_leave$4912
$LN24@inflateBac@2:
$LN25@inflateBac@2:
  0193b	33 c0		 xor	 eax, eax
  0193d	85 c0		 test	 eax, eax
  0193f	75 be		 jne	 SHORT $LN28@inflateBac@2
  01941	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01945	ff c8		 dec	 eax
  01947	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0194b	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01950	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01953	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  01957	d3 e0		 shl	 eax, cl
  01959	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0195d	03 c8		 add	 ecx, eax
  0195f	8b c1		 mov	 eax, ecx
  01961	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01965	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0196a	48 ff c0	 inc	 rax
  0196d	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01972	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01976	83 c0 08	 add	 eax, 8
  01979	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0197d	33 c0		 xor	 eax, eax
  0197f	85 c0		 test	 eax, eax
  01981	0f 85 78 ff ff
	ff		 jne	 $LN31@inflateBac@2
  01987	e9 61 ff ff ff	 jmp	 $LN33@inflateBac@2
$LN32@inflateBac@2:
  0198c	33 c0		 xor	 eax, eax
  0198e	85 c0		 test	 eax, eax
  01990	0f 85 57 ff ff
	ff		 jne	 $LN36@inflateBac@2

; 566  :                 state->offset += BITS(state->extra);

  01996	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0199b	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0199e	b9 01 00 00 00	 mov	 ecx, 1
  019a3	89 8c 24 bc 00
	00 00		 mov	 DWORD PTR tv1521[rsp], ecx
  019aa	0f b6 c8	 movzx	 ecx, al
  019ad	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv1521[rsp]
  019b4	d3 e0		 shl	 eax, cl
  019b6	ff c8		 dec	 eax
  019b8	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  019bc	23 c8		 and	 ecx, eax
  019be	8b c1		 mov	 eax, ecx
  019c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  019c5	03 41 4c	 add	 eax, DWORD PTR [rcx+76]
  019c8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  019cd	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN23@inflateBac@2:

; 567  :                 DROPBITS(state->extra);

  019d0	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  019d5	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  019d8	0f b6 c8	 movzx	 ecx, al
  019db	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  019df	d3 e8		 shr	 eax, cl
  019e1	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  019e5	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  019ea	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  019ed	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  019f1	2b c8		 sub	 ecx, eax
  019f3	8b c1		 mov	 eax, ecx
  019f5	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  019f9	33 c0		 xor	 eax, eax
  019fb	85 c0		 test	 eax, eax
  019fd	75 d1		 jne	 SHORT $LN23@inflateBac@2
$LN37@inflateBac@2:

; 568  :             }
; 569  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 570  :                                                 left : 0)) {

  019ff	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a04	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01a09	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  01a0c	39 48 30	 cmp	 DWORD PTR [rax+48], ecx
  01a0f	73 0d		 jae	 SHORT $LN352@inflateBac@2
  01a11	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01a15	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv796[rsp], eax
  01a1c	eb 0b		 jmp	 SHORT $LN353@inflateBac@2
$LN352@inflateBac@2:
  01a1e	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv796[rsp], 0
$LN353@inflateBac@2:
  01a29	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a2e	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv796[rsp]
  01a35	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01a38	2b c1		 sub	 eax, ecx
  01a3a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01a3f	39 41 4c	 cmp	 DWORD PTR [rcx+76], eax
  01a42	76 23		 jbe	 SHORT $LN20@inflateBac@2

; 571  :                 strm->msg = (char *)"invalid distance too far back";

  01a44	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01a4c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  01a53	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 572  :                 state->mode = BAD;

  01a57	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a5c	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 573  :                 break;

  01a62	e9 af 01 00 00	 jmp	 $LN342@inflateBac@2
$LN20@inflateBac@2:
$LN19@inflateBac@2:
$LN16@inflateBac@2:

; 574  :             }
; 575  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 576  : 
; 577  :             /* copy match from window to output */
; 578  :             do {
; 579  :                 ROOM();

  01a67	83 7c 24 4c 00	 cmp	 DWORD PTR left$[rsp], 0
  01a6c	75 50		 jne	 SHORT $LN13@inflateBac@2
  01a6e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a73	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  01a77	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01a7c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a81	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01a84	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  01a88	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a8d	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  01a91	89 48 30	 mov	 DWORD PTR [rax+48], ecx
  01a94	44 8b 44 24 4c	 mov	 r8d, DWORD PTR left$[rsp]
  01a99	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  01a9e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  01aa6	ff 94 24 f8 00
	00 00		 call	 QWORD PTR out$[rsp]
  01aad	85 c0		 test	 eax, eax
  01aaf	74 0d		 je	 SHORT $LN12@inflateBac@2
  01ab1	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01ab9	e9 5d 01 00 00	 jmp	 $inf_leave$4912
$LN12@inflateBac@2:
$LN13@inflateBac@2:
  01abe	33 c0		 xor	 eax, eax
  01ac0	85 c0		 test	 eax, eax
  01ac2	75 a3		 jne	 SHORT $LN16@inflateBac@2

; 580  :                 copy = state->wsize - state->offset;

  01ac4	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01ac9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01ace	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01ad1	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01ad4	2b c1		 sub	 eax, ecx
  01ad6	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 581  :                 if (copy < left) {

  01ada	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01ade	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  01ae2	73 26		 jae	 SHORT $LN11@inflateBac@2

; 582  :                     from = put + copy;

  01ae4	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01ae8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  01aed	48 03 c8	 add	 rcx, rax
  01af0	48 8b c1	 mov	 rax, rcx
  01af3	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 583  :                     copy = left - copy;

  01af8	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01afc	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  01b00	2b c8		 sub	 ecx, eax
  01b02	8b c1		 mov	 eax, ecx
  01b04	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 584  :                 }
; 585  :                 else {

  01b08	eb 20		 jmp	 SHORT $LN10@inflateBac@2
$LN11@inflateBac@2:

; 586  :                     from = put - state->offset;

  01b0a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01b0f	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01b12	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  01b17	48 2b c8	 sub	 rcx, rax
  01b1a	48 8b c1	 mov	 rax, rcx
  01b1d	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 587  :                     copy = left;

  01b22	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01b26	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN10@inflateBac@2:

; 588  :                 }
; 589  :                 if (copy > state->length) copy = state->length;

  01b2a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01b2f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01b32	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  01b36	76 0c		 jbe	 SHORT $LN9@inflateBac@2
  01b38	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01b3d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01b40	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN9@inflateBac@2:

; 590  :                 state->length -= copy;

  01b44	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01b49	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  01b4d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01b50	2b c1		 sub	 eax, ecx
  01b52	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01b57	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 591  :                 left -= copy;

  01b5a	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01b5e	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  01b62	2b c8		 sub	 ecx, eax
  01b64	8b c1		 mov	 eax, ecx
  01b66	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
$LN8@inflateBac@2:

; 592  :                 do {
; 593  :                     *put++ = *from++;

  01b6a	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01b6f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR from$[rsp]
  01b74	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01b77	88 08		 mov	 BYTE PTR [rax], cl
  01b79	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01b7e	48 ff c0	 inc	 rax
  01b81	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01b86	48 8b 44 24 68	 mov	 rax, QWORD PTR from$[rsp]
  01b8b	48 ff c0	 inc	 rax
  01b8e	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 594  :                 } while (--copy);

  01b93	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01b97	ff c8		 dec	 eax
  01b99	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
  01b9d	83 7c 24 60 00	 cmp	 DWORD PTR copy$[rsp], 0
  01ba2	75 c6		 jne	 SHORT $LN8@inflateBac@2

; 595  :             } while (state->length != 0);

  01ba4	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01ba9	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  01bad	0f 85 b4 fe ff
	ff		 jne	 $LN19@inflateBac@2

; 596  :             break;

  01bb3	eb 61		 jmp	 SHORT $LN342@inflateBac@2
$LN5@inflateBac@2:

; 597  : 
; 598  :         case DONE:
; 599  :             /* inflate stream terminated properly -- write leftover output */
; 600  :             ret = Z_STREAM_END;

  01bb5	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR ret$[rsp], 1

; 601  :             if (left < state->wsize) {

  01bbd	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01bc2	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01bc5	39 44 24 4c	 cmp	 DWORD PTR left$[rsp], eax
  01bc9	73 35		 jae	 SHORT $LN4@inflateBac@2

; 602  :                 if (out(out_desc, state->window, state->wsize - left))

  01bcb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01bd0	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  01bd4	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01bd7	2b c1		 sub	 eax, ecx
  01bd9	44 8b c0	 mov	 r8d, eax
  01bdc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01be1	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  01be5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  01bed	ff 94 24 f8 00
	00 00		 call	 QWORD PTR out$[rsp]
  01bf4	85 c0		 test	 eax, eax
  01bf6	74 08		 je	 SHORT $LN3@inflateBac@2

; 603  :                     ret = Z_BUF_ERROR;

  01bf8	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
$LN3@inflateBac@2:
$LN4@inflateBac@2:

; 604  :             }
; 605  :             goto inf_leave;

  01c00	eb 19		 jmp	 SHORT $inf_leave$4912
$LN2@inflateBac@2:

; 606  : 
; 607  :         case BAD:
; 608  :             ret = Z_DATA_ERROR;

  01c02	c7 44 24 58 fd
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -3

; 609  :             goto inf_leave;

  01c0a	eb 0f		 jmp	 SHORT $inf_leave$4912
$LN1@inflateBac@2:

; 610  : 
; 611  :         default:                /* can't happen, but makes compilers happy */
; 612  :             ret = Z_STREAM_ERROR;

  01c0c	c7 44 24 58 fe
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -2

; 613  :             goto inf_leave;

  01c14	eb 05		 jmp	 SHORT $inf_leave$4912
$LN342@inflateBac@2:

; 614  :         }

  01c16	e9 cb e4 ff ff	 jmp	 $LN345@inflateBac@2
$inf_leave$4912:

; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  01c1b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01c23	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  01c28	48 89 08	 mov	 QWORD PTR [rax], rcx

; 619  :     strm->avail_in = have;

  01c2b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01c33	8b 4c 24 40	 mov	 ecx, DWORD PTR have$[rsp]
  01c37	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 620  :     return ret;

  01c3a	8b 44 24 58	 mov	 eax, DWORD PTR ret$[rsp]
$LN348@inflateBac@2:

; 621  : }

  01c3e	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  01c45	c3		 ret	 0
  01c46	66 90		 npad	 2
$LN354@inflateBac@2:
  01c48	00 00 00 00	 DD	 $LN341@inflateBac@2
  01c4c	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c50	00 00 00 00	 DD	 $LN311@inflateBac@2
  01c54	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c58	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c5c	00 00 00 00	 DD	 $LN276@inflateBac@2
  01c60	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c64	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c68	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c6c	00 00 00 00	 DD	 $LN130@inflateBac@2
  01c70	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c74	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c78	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c7c	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c80	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c84	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c88	00 00 00 00	 DD	 $LN1@inflateBac@2
  01c8c	00 00 00 00	 DD	 $LN5@inflateBac@2
  01c90	00 00 00 00	 DD	 $LN2@inflateBac@2
inflateBack ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 75   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 76   : #ifdef BUILDFIXED
; 77   :     static int virgin = 1;
; 78   :     static code *lenfix, *distfix;
; 79   :     static code fixed[544];
; 80   : 
; 81   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 82   :     if (virgin) {
; 83   :         unsigned sym, bits;
; 84   :         static code *next;
; 85   : 
; 86   :         /* literal/length table */
; 87   :         sym = 0;
; 88   :         while (sym < 144) state->lens[sym++] = 8;
; 89   :         while (sym < 256) state->lens[sym++] = 9;
; 90   :         while (sym < 280) state->lens[sym++] = 7;
; 91   :         while (sym < 288) state->lens[sym++] = 8;
; 92   :         next = fixed;
; 93   :         lenfix = next;
; 94   :         bits = 9;
; 95   :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 96   : 
; 97   :         /* distance table */
; 98   :         sym = 0;
; 99   :         while (sym < 32) state->lens[sym++] = 5;
; 100  :         distfix = next;
; 101  :         bits = 5;
; 102  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 103  : 
; 104  :         /* do this just once */
; 105  :         virgin = 0;
; 106  :     }
; 107  : #else /* !BUILDFIXED */
; 108  : #   include "inffixed.h"
; 109  : #endif /* BUILDFIXED */
; 110  :     state->lencode = lenfix;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9
  00011	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 111  :     state->lenbits = 9;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0001a	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 112  :     state->distcode = distfix;

  00021	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  0002d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 113  :     state->distbits = 5;

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00036	c7 40 6c 05 00
	00 00		 mov	 DWORD PTR [rax+108], 5

; 114  : }

  0003d	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
PUBLIC	inflateBackEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 625  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 626  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 18		 je	 SHORT $LN1@inflateBac@3
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	74 0c		 je	 SHORT $LN1@inflateBac@3
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00022	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00027	75 07		 jne	 SHORT $LN2@inflateBac@3
$LN1@inflateBac@3:

; 627  :         return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2
  0002e	eb 29		 jmp	 SHORT $LN3@inflateBac@3
$LN2@inflateBac@3:

; 628  :     ZFREE(strm, strm->state);

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00035	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  0003e	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00047	ff 50 38	 call	 QWORD PTR [rax+56]

; 629  :     strm->state = Z_NULL;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  0004f	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 630  :     Tracev((stderr, "inflate: end\n"));
; 631  :     return Z_OK;

  00057	33 c0		 xor	 eax, eax
$LN3@inflateBac@3:

; 632  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
END
