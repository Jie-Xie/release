; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07KPBKOMIO@_random?$AA@			; `string'
PUBLIC	??_C@_0P@BMHHKIKM@_random?4Random?$AA@		; `string'
PUBLIC	??_C@_0DL@OGGNEOFD@getrandbits?$CIk?$CJ?5?9?$DO?5x?4?5?5Generates?5@ ; `string'
PUBLIC	??_C@_0M@HOAPOEBA@getrandbits?$AA@		; `string'
PUBLIC	??_C@_0DE@PFEOEBCD@setstate?$CIstate?$CJ?5?9?$DO?5None?4?5?5Restor@ ; `string'
PUBLIC	??_C@_08BJPILIMO@setstate?$AA@			; `string'
PUBLIC	??_C@_0DC@DEMJLMBG@getstate?$CI?$CJ?5?9?$DO?5tuple?5containing?5t@ ; `string'
PUBLIC	??_C@_08OINEKLLD@getstate?$AA@			; `string'
PUBLIC	??_C@_0CO@HHDJAPIE@seed?$CI?$FLn?$FN?$CJ?5?9?$DO?5None?4?5?5Defaults?5to?5@ ; `string'
PUBLIC	??_C@_04MENKDCKE@seed?$AA@			; `string'
PUBLIC	??_C@_0CG@FGCGGJHI@random?$CI?$CJ?5?9?$DO?5x?5in?5the?5interval?5?$FL0@ ; `string'
PUBLIC	??_C@_06NLFCANPD@random?$AA@			; `string'
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PyObject_GenericGetAttr:PROC
;	COMDAT ??_C@_07KPBKOMIO@_random?$AA@
CONST	SEGMENT
??_C@_07KPBKOMIO@_random?$AA@ DB '_random', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BMHHKIKM@_random?4Random?$AA@
CONST	SEGMENT
??_C@_0P@BMHHKIKM@_random?4Random?$AA@ DB '_random.Random', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OGGNEOFD@getrandbits?$CIk?$CJ?5?9?$DO?5x?4?5?5Generates?5@
CONST	SEGMENT
??_C@_0DL@OGGNEOFD@getrandbits?$CIk?$CJ?5?9?$DO?5x?4?5?5Generates?5@ DB 'g'
	DB	'etrandbits(k) -> x.  Generates an int with k random bits.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HOAPOEBA@getrandbits?$AA@
CONST	SEGMENT
??_C@_0M@HOAPOEBA@getrandbits?$AA@ DB 'getrandbits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PFEOEBCD@setstate?$CIstate?$CJ?5?9?$DO?5None?4?5?5Restor@
CONST	SEGMENT
??_C@_0DE@PFEOEBCD@setstate?$CIstate?$CJ?5?9?$DO?5None?4?5?5Restor@ DB 's'
	DB	'etstate(state) -> None.  Restores generator state.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BJPILIMO@setstate?$AA@
CONST	SEGMENT
??_C@_08BJPILIMO@setstate?$AA@ DB 'setstate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DEMJLMBG@getstate?$CI?$CJ?5?9?$DO?5tuple?5containing?5t@
CONST	SEGMENT
??_C@_0DC@DEMJLMBG@getstate?$CI?$CJ?5?9?$DO?5tuple?5containing?5t@ DB 'ge'
	DB	'tstate() -> tuple containing the current state.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OINEKLLD@getstate?$AA@
CONST	SEGMENT
??_C@_08OINEKLLD@getstate?$AA@ DB 'getstate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HHDJAPIE@seed?$CI?$FLn?$FN?$CJ?5?9?$DO?5None?4?5?5Defaults?5to?5@
CONST	SEGMENT
??_C@_0CO@HHDJAPIE@seed?$CI?$FLn?$FN?$CJ?5?9?$DO?5None?4?5?5Defaults?5to?5@ DB 's'
	DB	'eed([n]) -> None.  Defaults to current time.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MENKDCKE@seed?$AA@
CONST	SEGMENT
??_C@_04MENKDCKE@seed?$AA@ DB 'seed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FGCGGJHI@random?$CI?$CJ?5?9?$DO?5x?5in?5the?5interval?5?$FL0@
CONST	SEGMENT
??_C@_0CG@FGCGGJHI@random?$CI?$CJ?5?9?$DO?5x?5in?5the?5interval?5?$FL0@ DB 'r'
	DB	'andom() -> x in the interval [0, 1).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NLFCANPD@random?$AA@
CONST	SEGMENT
??_C@_06NLFCANPD@random?$AA@ DB 'random', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?mag01@?1??genrand_int32@@9@9 DD 00H			; `genrand_int32'::`2'::mag01
	DD	09908b0dfH
	ORG $+8
random_methods DQ FLAT:??_C@_06NLFCANPD@random?$AA@
	DQ	FLAT:random_random
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CG@FGCGGJHI@random?$CI?$CJ?5?9?$DO?5x?5in?5the?5interval?5?$FL0@
	DQ	FLAT:??_C@_04MENKDCKE@seed?$AA@
	DQ	FLAT:random_seed
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CO@HHDJAPIE@seed?$CI?$FLn?$FN?$CJ?5?9?$DO?5None?4?5?5Defaults?5to?5@
	DQ	FLAT:??_C@_08OINEKLLD@getstate?$AA@
	DQ	FLAT:random_getstate
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DC@DEMJLMBG@getstate?$CI?$CJ?5?9?$DO?5tuple?5containing?5t@
	DQ	FLAT:??_C@_08BJPILIMO@setstate?$AA@
	DQ	FLAT:random_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0DE@PFEOEBCD@setstate?$CIstate?$CJ?5?9?$DO?5None?4?5?5Restor@
	DQ	FLAT:??_C@_0M@HOAPOEBA@getrandbits?$AA@
	DQ	FLAT:random_getrandbits
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0DL@OGGNEOFD@getrandbits?$CIk?$CJ?5?9?$DO?5x?4?5?5Generates?5@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
random_doc DB	'Random() -> create a random number generator with its ow'
	DB	'n internal state.', 00H
	ORG $+6
Random_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0P@BMHHKIKM@_random?4Random?$AA@
	DQ	0000000000000a30H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:random_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:random_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:random_new
	DQ	FLAT:_PyObject_DebugFree
	DQ	0000000000000000H
	ORG $+56
module_doc DB	'Module implements the Mersenne Twister random number gen'
	DB	'erator.', 00H
_randommodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07KPBKOMIO@_random?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	__real@3ca0000000000000
PUBLIC	__real@4190000000000000
EXTRN	PyFloat_FromDouble:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\_randommodule.c
pdata	SEGMENT
$pdata$random_random DD imagerel random_random
	DD	imagerel random_random+99
	DD	imagerel $unwind$random_random
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_random DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT __real@3ca0000000000000
CONST	SEGMENT
__real@3ca0000000000000 DQ 03ca0000000000000r	; 1.11022e-016
CONST	ENDS
;	COMDAT __real@4190000000000000
CONST	SEGMENT
__real@4190000000000000 DQ 04190000000000000r	; 6.71089e+007
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT random_random
_TEXT	SEGMENT
a$ = 32
b$ = 36
self$ = 64
random_random PROC					; COMDAT

; 139  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 140  :     unsigned long a=genrand_int32(self)>>5, b=genrand_int32(self)>>6;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 genrand_int32
  00013	c1 e8 05	 shr	 eax, 5
  00016	89 44 24 20	 mov	 DWORD PTR a$[rsp], eax
  0001a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001f	e8 00 00 00 00	 call	 genrand_int32
  00024	c1 e8 06	 shr	 eax, 6
  00027	89 44 24 24	 mov	 DWORD PTR b$[rsp], eax

; 141  :     return PyFloat_FromDouble((a*67108864.0+b)*(1.0/9007199254740992.0));

  0002b	8b 44 24 20	 mov	 eax, DWORD PTR a$[rsp]
  0002f	66 0f ef c0	 pxor	 xmm0, xmm0
  00033	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00038	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4190000000000000
  00040	8b 44 24 24	 mov	 eax, DWORD PTR b$[rsp]
  00044	66 0f ef c9	 pxor	 xmm1, xmm1
  00048	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  0004d	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00051	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ca0000000000000
  00059	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 142  : }

  0005e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00062	c3		 ret	 0
random_random ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$genrand_int32 DD imagerel genrand_int32
	DD	imagerel genrand_int32+536
	DD	imagerel $unwind$genrand_int32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$genrand_int32 DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT genrand_int32
_TEXT	SEGMENT
mt$ = 0
y$ = 8
kk$20308 = 12
self$ = 32
genrand_int32 PROC					; COMDAT

; 96   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 97   :     unsigned long y;
; 98   :     static unsigned long mag01[2]={0x0UL, MATRIX_A};
; 99   :     /* mag01[x] = x * MATRIX_A  for x=0,1 */
; 100  :     unsigned long *mt;
; 101  : 
; 102  :     mt = self->state;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 c0 60	 add	 rax, 96			; 00000060H
  00012	48 89 04 24	 mov	 QWORD PTR mt$[rsp], rax

; 103  :     if (self->index >= N) { /* generate N words at one time */

  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0001b	81 b8 20 0a 00
	00 70 02 00 00	 cmp	 DWORD PTR [rax+2592], 624 ; 00000270H
  00025	0f 8c 5f 01 00
	00		 jl	 $LN7@genrand_in

; 104  :         int kk;
; 105  : 
; 106  :         for (kk=0;kk<N-M;kk++) {

  0002b	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR kk$20308[rsp], 0
  00033	eb 0a		 jmp	 SHORT $LN6@genrand_in
$LN5@genrand_in:
  00035	8b 44 24 0c	 mov	 eax, DWORD PTR kk$20308[rsp]
  00039	ff c0		 inc	 eax
  0003b	89 44 24 0c	 mov	 DWORD PTR kk$20308[rsp], eax
$LN6@genrand_in:
  0003f	81 7c 24 0c e3
	00 00 00	 cmp	 DWORD PTR kk$20308[rsp], 227 ; 000000e3H
  00047	7d 66		 jge	 SHORT $LN4@genrand_in

; 107  :             y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);

  00049	48 63 44 24 0c	 movsxd	 rax, DWORD PTR kk$20308[rsp]
  0004e	48 8b 0c 24	 mov	 rcx, QWORD PTR mt$[rsp]
  00052	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00055	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0005a	8b 4c 24 0c	 mov	 ecx, DWORD PTR kk$20308[rsp]
  0005e	ff c1		 inc	 ecx
  00060	48 63 c9	 movsxd	 rcx, ecx
  00063	48 8b 14 24	 mov	 rdx, QWORD PTR mt$[rsp]
  00067	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  0006a	0f ba f1 1f	 btr	 ecx, 31
  0006e	0b c1		 or	 eax, ecx
  00070	89 44 24 08	 mov	 DWORD PTR y$[rsp], eax

; 108  :             mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];

  00074	8b 44 24 0c	 mov	 eax, DWORD PTR kk$20308[rsp]
  00078	05 8d 01 00 00	 add	 eax, 397		; 0000018dH
  0007d	48 98		 cdqe
  0007f	8b 4c 24 08	 mov	 ecx, DWORD PTR y$[rsp]
  00083	d1 e9		 shr	 ecx, 1
  00085	48 8b 14 24	 mov	 rdx, QWORD PTR mt$[rsp]
  00089	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  0008c	33 c1		 xor	 eax, ecx
  0008e	8b 4c 24 08	 mov	 ecx, DWORD PTR y$[rsp]
  00092	83 e1 01	 and	 ecx, 1
  00095	8b c9		 mov	 ecx, ecx
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?mag01@?1??genrand_int32@@9@9
  0009e	33 04 8a	 xor	 eax, DWORD PTR [rdx+rcx*4]
  000a1	48 63 4c 24 0c	 movsxd	 rcx, DWORD PTR kk$20308[rsp]
  000a6	48 8b 14 24	 mov	 rdx, QWORD PTR mt$[rsp]
  000aa	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 109  :         }

  000ad	eb 86		 jmp	 SHORT $LN5@genrand_in
$LN4@genrand_in:

; 110  :         for (;kk<N-1;kk++) {

  000af	eb 0a		 jmp	 SHORT $LN3@genrand_in
$LN2@genrand_in:
  000b1	8b 44 24 0c	 mov	 eax, DWORD PTR kk$20308[rsp]
  000b5	ff c0		 inc	 eax
  000b7	89 44 24 0c	 mov	 DWORD PTR kk$20308[rsp], eax
$LN3@genrand_in:
  000bb	81 7c 24 0c 6f
	02 00 00	 cmp	 DWORD PTR kk$20308[rsp], 623 ; 0000026fH
  000c3	7d 66		 jge	 SHORT $LN1@genrand_in

; 111  :             y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);

  000c5	48 63 44 24 0c	 movsxd	 rax, DWORD PTR kk$20308[rsp]
  000ca	48 8b 0c 24	 mov	 rcx, QWORD PTR mt$[rsp]
  000ce	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000d1	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000d6	8b 4c 24 0c	 mov	 ecx, DWORD PTR kk$20308[rsp]
  000da	ff c1		 inc	 ecx
  000dc	48 63 c9	 movsxd	 rcx, ecx
  000df	48 8b 14 24	 mov	 rdx, QWORD PTR mt$[rsp]
  000e3	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  000e6	0f ba f1 1f	 btr	 ecx, 31
  000ea	0b c1		 or	 eax, ecx
  000ec	89 44 24 08	 mov	 DWORD PTR y$[rsp], eax

; 112  :             mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];

  000f0	8b 44 24 0c	 mov	 eax, DWORD PTR kk$20308[rsp]
  000f4	2d e3 00 00 00	 sub	 eax, 227		; 000000e3H
  000f9	48 98		 cdqe
  000fb	8b 4c 24 08	 mov	 ecx, DWORD PTR y$[rsp]
  000ff	d1 e9		 shr	 ecx, 1
  00101	48 8b 14 24	 mov	 rdx, QWORD PTR mt$[rsp]
  00105	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00108	33 c1		 xor	 eax, ecx
  0010a	8b 4c 24 08	 mov	 ecx, DWORD PTR y$[rsp]
  0010e	83 e1 01	 and	 ecx, 1
  00111	8b c9		 mov	 ecx, ecx
  00113	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?mag01@?1??genrand_int32@@9@9
  0011a	33 04 8a	 xor	 eax, DWORD PTR [rdx+rcx*4]
  0011d	48 63 4c 24 0c	 movsxd	 rcx, DWORD PTR kk$20308[rsp]
  00122	48 8b 14 24	 mov	 rdx, QWORD PTR mt$[rsp]
  00126	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 113  :         }

  00129	eb 86		 jmp	 SHORT $LN2@genrand_in
$LN1@genrand_in:

; 114  :         y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);

  0012b	48 8b 04 24	 mov	 rax, QWORD PTR mt$[rsp]
  0012f	8b 80 bc 09 00
	00		 mov	 eax, DWORD PTR [rax+2492]
  00135	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0013a	48 8b 0c 24	 mov	 rcx, QWORD PTR mt$[rsp]
  0013e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00140	0f ba f1 1f	 btr	 ecx, 31
  00144	0b c1		 or	 eax, ecx
  00146	89 44 24 08	 mov	 DWORD PTR y$[rsp], eax

; 115  :         mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

  0014a	8b 44 24 08	 mov	 eax, DWORD PTR y$[rsp]
  0014e	d1 e8		 shr	 eax, 1
  00150	48 8b 0c 24	 mov	 rcx, QWORD PTR mt$[rsp]
  00154	8b 89 30 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1584]
  0015a	33 c8		 xor	 ecx, eax
  0015c	8b c1		 mov	 eax, ecx
  0015e	8b 4c 24 08	 mov	 ecx, DWORD PTR y$[rsp]
  00162	83 e1 01	 and	 ecx, 1
  00165	8b c9		 mov	 ecx, ecx
  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?mag01@?1??genrand_int32@@9@9
  0016e	33 04 8a	 xor	 eax, DWORD PTR [rdx+rcx*4]
  00171	48 8b 0c 24	 mov	 rcx, QWORD PTR mt$[rsp]
  00175	89 81 bc 09 00
	00		 mov	 DWORD PTR [rcx+2492], eax

; 116  : 
; 117  :         self->index = 0;

  0017b	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00180	c7 80 20 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2592], 0
$LN7@genrand_in:

; 118  :     }
; 119  : 
; 120  :     y = mt[self->index++];

  0018a	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0018f	48 63 80 20 0a
	00 00		 movsxd	 rax, DWORD PTR [rax+2592]
  00196	48 8b 0c 24	 mov	 rcx, QWORD PTR mt$[rsp]
  0019a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0019d	89 44 24 08	 mov	 DWORD PTR y$[rsp], eax
  001a1	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  001a6	8b 80 20 0a 00
	00		 mov	 eax, DWORD PTR [rax+2592]
  001ac	ff c0		 inc	 eax
  001ae	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  001b3	89 81 20 0a 00
	00		 mov	 DWORD PTR [rcx+2592], eax

; 121  :     y ^= (y >> 11);

  001b9	8b 44 24 08	 mov	 eax, DWORD PTR y$[rsp]
  001bd	c1 e8 0b	 shr	 eax, 11
  001c0	8b 4c 24 08	 mov	 ecx, DWORD PTR y$[rsp]
  001c4	33 c8		 xor	 ecx, eax
  001c6	8b c1		 mov	 eax, ecx
  001c8	89 44 24 08	 mov	 DWORD PTR y$[rsp], eax

; 122  :     y ^= (y << 7) & 0x9d2c5680UL;

  001cc	8b 44 24 08	 mov	 eax, DWORD PTR y$[rsp]
  001d0	c1 e0 07	 shl	 eax, 7
  001d3	25 80 56 2c 9d	 and	 eax, -1658038656	; 9d2c5680H
  001d8	8b 4c 24 08	 mov	 ecx, DWORD PTR y$[rsp]
  001dc	33 c8		 xor	 ecx, eax
  001de	8b c1		 mov	 eax, ecx
  001e0	89 44 24 08	 mov	 DWORD PTR y$[rsp], eax

; 123  :     y ^= (y << 15) & 0xefc60000UL;

  001e4	8b 44 24 08	 mov	 eax, DWORD PTR y$[rsp]
  001e8	c1 e0 0f	 shl	 eax, 15
  001eb	25 00 00 c6 ef	 and	 eax, -272236544		; efc60000H
  001f0	8b 4c 24 08	 mov	 ecx, DWORD PTR y$[rsp]
  001f4	33 c8		 xor	 ecx, eax
  001f6	8b c1		 mov	 eax, ecx
  001f8	89 44 24 08	 mov	 DWORD PTR y$[rsp], eax

; 124  :     y ^= (y >> 18);

  001fc	8b 44 24 08	 mov	 eax, DWORD PTR y$[rsp]
  00200	c1 e8 12	 shr	 eax, 18
  00203	8b 4c 24 08	 mov	 ecx, DWORD PTR y$[rsp]
  00207	33 c8		 xor	 ecx, eax
  00209	8b c1		 mov	 eax, ecx
  0020b	89 44 24 08	 mov	 DWORD PTR y$[rsp], eax

; 125  :     return y;

  0020f	8b 44 24 08	 mov	 eax, DWORD PTR y$[rsp]

; 126  : }

  00213	48 83 c4 18	 add	 rsp, 24
  00217	c3		 ret	 0
genrand_int32 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@PEEPFKMA@?$AAk?$AAe?$AAy?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DM?$AA?5?$AAk?$AAe?$AAy?$AAm?$AAa?$AAx?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@INJKDHIJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAr?$AAa?$AAn?$AAd?$AAo?$AAm?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	_Py_DecRef
PUBLIC	_Py_IncRef
EXTRN	PyMem_Free:PROC
EXTRN	__imp__wassert:PROC
EXTRN	PyMem_Realloc:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyNumber_Rshift:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsUnsignedLong:PROC
EXTRN	PyNumber_And:PROC
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	PyLong_FromSize_t:PROC
EXTRN	PyObject_Hash:PROC
EXTRN	PyNumber_Absolute:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$random_seed DD imagerel random_seed
	DD	imagerel random_seed+963
	DD	imagerel $unwind$random_seed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_seed DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_1CC@PEEPFKMA@?$AAk?$AAe?$AAy?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DM?$AA?5?$AAk?$AAe?$AAy?$AAm?$AAa?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@PEEPFKMA@?$AAk?$AAe?$AAy?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DM?$AA?5?$AAk?$AAe?$AAy?$AAm?$AAa?$AAx?$AA?$AA@ DB 'k'
	DB	00H, 'e', 00H, 'y', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 'm'
	DB	00H, 'a', 00H, 'x', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@INJKDHIJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAr?$AAa?$AAn?$AAd?$AAo?$AAm?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@INJKDHIJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAr?$AAa?$AAn?$AAd?$AAo?$AAm?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, '_', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'o', 00H
	DB	'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT random_seed
_TEXT	SEGMENT
masklower$ = 48
arg$ = 56
n$ = 64
key$ = 72
new_key$ = 80
keymax$ = 88
err$ = 92
result$ = 96
keyused$ = 104
thirtytwo$ = 112
now$20382 = 120
hash$20388 = 128
chunk$20406 = 136
newn$20404 = 144
pychunk$20405 = 152
bigger$20417 = 160
self$ = 192
args$ = 200
random_seed PROC					; COMDAT

; 208  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 209  :     PyObject *result = NULL;            /* guilty until proved innocent */

  00011	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 210  :     PyObject *masklower = NULL;

  0001a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR masklower$[rsp], 0

; 211  :     PyObject *thirtytwo = NULL;

  00023	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR thirtytwo$[rsp], 0

; 212  :     PyObject *n = NULL;

  0002c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0

; 213  :     unsigned long *new_key, *key = NULL;

  00035	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR key$[rsp], 0

; 214  :     unsigned long keymax;               /* # of allocated slots in key */
; 215  :     unsigned long keyused;              /* # of used slots in key */
; 216  :     int err;
; 217  : 
; 218  :     PyObject *arg = NULL;

  0003e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR arg$[rsp], 0

; 219  : 
; 220  :     if (!PyArg_UnpackTuple(args, "seed", 0, 1, &arg))

  00047	48 8d 44 24 38	 lea	 rax, QWORD PTR arg$[rsp]
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	41 b9 01 00 00
	00		 mov	 r9d, 1
  00057	45 33 c0	 xor	 r8d, r8d
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MENKDCKE@seed?$AA@
  00061	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00069	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0006e	85 c0		 test	 eax, eax
  00070	75 07		 jne	 SHORT $LN33@random_see

; 221  :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	e9 42 03 00 00	 jmp	 $LN34@random_see
$LN33@random_see:

; 222  : 
; 223  :     if (arg == NULL || arg == Py_None) {

  00079	48 83 7c 24 38
	00		 cmp	 QWORD PTR arg$[rsp], 0
  0007f	74 0e		 je	 SHORT $LN31@random_see
  00081	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00088	48 39 44 24 38	 cmp	 QWORD PTR arg$[rsp], rax
  0008d	75 33		 jne	 SHORT $LN32@random_see
$LN31@random_see:

; 224  :         time_t now;
; 225  : 
; 226  :         time(&now);

  0008f	48 8d 4c 24 78	 lea	 rcx, QWORD PTR now$20382[rsp]
  00094	e8 00 00 00 00	 call	 time

; 227  :         init_genrand(self, (unsigned long)now);

  00099	8b 54 24 78	 mov	 edx, DWORD PTR now$20382[rsp]
  0009d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000a5	e8 00 00 00 00	 call	 init_genrand

; 228  :         Py_INCREF(Py_None);

  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000b1	e8 00 00 00 00	 call	 _Py_IncRef

; 229  :         return Py_None;

  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000bd	e9 f9 02 00 00	 jmp	 $LN34@random_see
$LN32@random_see:

; 230  :     }
; 231  :     /* This algorithm relies on the number being unsigned.
; 232  :      * So: if the arg is a PyLong, use its absolute value.
; 233  :      * Otherwise use its hash value, cast to unsigned.
; 234  :      */
; 235  :     if (PyLong_Check(arg))

  000c2	48 8b 44 24 38	 mov	 rax, QWORD PTR arg$[rsp]
  000c7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000cb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d1	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000d6	85 c0		 test	 eax, eax
  000d8	74 11		 je	 SHORT $LN30@random_see

; 236  :         n = PyNumber_Absolute(arg);

  000da	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arg$[rsp]
  000df	e8 00 00 00 00	 call	 PyNumber_Absolute
  000e4	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax

; 237  :     else {

  000e9	eb 34		 jmp	 SHORT $LN29@random_see
$LN30@random_see:

; 238  :         Py_hash_t hash = PyObject_Hash(arg);

  000eb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arg$[rsp]
  000f0	e8 00 00 00 00	 call	 PyObject_Hash
  000f5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR hash$20388[rsp], rax

; 239  :         if (hash == -1)

  000fd	48 83 bc 24 80
	00 00 00 ff	 cmp	 QWORD PTR hash$20388[rsp], -1
  00106	75 05		 jne	 SHORT $LN28@random_see

; 240  :             goto Done;

  00108	e9 57 02 00 00	 jmp	 $Done$20390
$LN28@random_see:

; 241  :         n = PyLong_FromSize_t((size_t)hash);

  0010d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hash$20388[rsp]
  00115	e8 00 00 00 00	 call	 PyLong_FromSize_t
  0011a	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax
$LN29@random_see:

; 242  :     }
; 243  :     if (n == NULL)

  0011f	48 83 7c 24 40
	00		 cmp	 QWORD PTR n$[rsp], 0
  00125	75 05		 jne	 SHORT $LN27@random_see

; 244  :         goto Done;

  00127	e9 38 02 00 00	 jmp	 $Done$20390
$LN27@random_see:

; 245  : 
; 246  :     /* Now split n into 32-bit chunks, from the right.  Each piece is
; 247  :      * stored into key, which has a capacity of keymax chunks, of which
; 248  :      * keyused are filled.  Alas, the repeated shifting makes this a
; 249  :      * quadratic-time algorithm; we'd really like to use
; 250  :      * _PyLong_AsByteArray here, but then we'd have to break into the
; 251  :      * long representation to figure out how big an array was needed
; 252  :      * in advance.
; 253  :      */
; 254  :     keymax = 8;         /* arbitrary; grows later if needed */

  0012c	c7 44 24 58 08
	00 00 00	 mov	 DWORD PTR keymax$[rsp], 8

; 255  :     keyused = 0;

  00134	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR keyused$[rsp], 0

; 256  :     key = (unsigned long *)PyMem_Malloc(keymax * sizeof(*key));

  0013c	8b 44 24 58	 mov	 eax, DWORD PTR keymax$[rsp]
  00140	48 c1 e0 02	 shl	 rax, 2
  00144	48 8b c8	 mov	 rcx, rax
  00147	e8 00 00 00 00	 call	 PyMem_Malloc
  0014c	48 89 44 24 48	 mov	 QWORD PTR key$[rsp], rax

; 257  :     if (key == NULL)

  00151	48 83 7c 24 48
	00		 cmp	 QWORD PTR key$[rsp], 0
  00157	75 05		 jne	 SHORT $LN26@random_see

; 258  :         goto Done;

  00159	e9 06 02 00 00	 jmp	 $Done$20390
$LN26@random_see:

; 259  : 
; 260  :     masklower = PyLong_FromUnsignedLong(0xffffffffU);

  0015e	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00163	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  00168	48 89 44 24 30	 mov	 QWORD PTR masklower$[rsp], rax

; 261  :     if (masklower == NULL)

  0016d	48 83 7c 24 30
	00		 cmp	 QWORD PTR masklower$[rsp], 0
  00173	75 05		 jne	 SHORT $LN25@random_see

; 262  :         goto Done;

  00175	e9 ea 01 00 00	 jmp	 $Done$20390
$LN25@random_see:

; 263  :     thirtytwo = PyLong_FromLong(32L);

  0017a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0017f	e8 00 00 00 00	 call	 PyLong_FromLong
  00184	48 89 44 24 70	 mov	 QWORD PTR thirtytwo$[rsp], rax

; 264  :     if (thirtytwo == NULL)

  00189	48 83 7c 24 70
	00		 cmp	 QWORD PTR thirtytwo$[rsp], 0
  0018f	75 05		 jne	 SHORT $LN24@random_see

; 265  :         goto Done;

  00191	e9 ce 01 00 00	 jmp	 $Done$20390
$LN24@random_see:
$LN23@random_see:

; 266  :     while ((err=PyObject_IsTrue(n))) {

  00196	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  0019b	e8 00 00 00 00	 call	 PyObject_IsTrue
  001a0	89 44 24 5c	 mov	 DWORD PTR err$[rsp], eax
  001a4	83 7c 24 5c 00	 cmp	 DWORD PTR err$[rsp], 0
  001a9	0f 84 78 01 00
	00		 je	 $LN22@random_see

; 267  :         PyObject *newn;
; 268  :         PyObject *pychunk;
; 269  :         unsigned long chunk;
; 270  : 
; 271  :         if (err == -1)

  001af	83 7c 24 5c ff	 cmp	 DWORD PTR err$[rsp], -1
  001b4	75 05		 jne	 SHORT $LN21@random_see

; 272  :             goto Done;

  001b6	e9 a9 01 00 00	 jmp	 $Done$20390
$LN21@random_see:

; 273  :         pychunk = PyNumber_And(n, masklower);

  001bb	48 8b 54 24 30	 mov	 rdx, QWORD PTR masklower$[rsp]
  001c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  001c5	e8 00 00 00 00	 call	 PyNumber_And
  001ca	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pychunk$20405[rsp], rax

; 274  :         if (pychunk == NULL)

  001d2	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR pychunk$20405[rsp], 0
  001db	75 05		 jne	 SHORT $LN20@random_see

; 275  :             goto Done;

  001dd	e9 82 01 00 00	 jmp	 $Done$20390
$LN20@random_see:

; 276  :         chunk = PyLong_AsUnsignedLong(pychunk);

  001e2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pychunk$20405[rsp]
  001ea	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  001ef	89 84 24 88 00
	00 00		 mov	 DWORD PTR chunk$20406[rsp], eax

; 277  :         Py_DECREF(pychunk);

  001f6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pychunk$20405[rsp]
  001fe	e8 00 00 00 00	 call	 _Py_DecRef

; 278  :         if (chunk == (unsigned long)-1 && PyErr_Occurred())

  00203	83 bc 24 88 00
	00 00 ff	 cmp	 DWORD PTR chunk$20406[rsp], -1 ; ffffffffH
  0020b	75 0f		 jne	 SHORT $LN19@random_see
  0020d	e8 00 00 00 00	 call	 PyErr_Occurred
  00212	48 85 c0	 test	 rax, rax
  00215	74 05		 je	 SHORT $LN19@random_see

; 279  :             goto Done;

  00217	e9 48 01 00 00	 jmp	 $Done$20390
$LN19@random_see:

; 280  :         newn = PyNumber_Rshift(n, thirtytwo);

  0021c	48 8b 54 24 70	 mov	 rdx, QWORD PTR thirtytwo$[rsp]
  00221	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  00226	e8 00 00 00 00	 call	 PyNumber_Rshift
  0022b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR newn$20404[rsp], rax

; 281  :         if (newn == NULL)

  00233	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR newn$20404[rsp], 0
  0023c	75 05		 jne	 SHORT $LN18@random_see

; 282  :             goto Done;

  0023e	e9 21 01 00 00	 jmp	 $Done$20390
$LN18@random_see:

; 283  :         Py_DECREF(n);

  00243	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  00248	e8 00 00 00 00	 call	 _Py_DecRef

; 284  :         n = newn;

  0024d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR newn$20404[rsp]
  00255	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax

; 285  :         if (keyused >= keymax) {

  0025a	8b 44 24 58	 mov	 eax, DWORD PTR keymax$[rsp]
  0025e	39 44 24 68	 cmp	 DWORD PTR keyused$[rsp], eax
  00262	72 7b		 jb	 SHORT $LN17@random_see

; 286  :             unsigned long bigger = keymax << 1;

  00264	8b 44 24 58	 mov	 eax, DWORD PTR keymax$[rsp]
  00268	d1 e0		 shl	 eax, 1
  0026a	89 84 24 a0 00
	00 00		 mov	 DWORD PTR bigger$20417[rsp], eax

; 287  :             if ((bigger >> 1) != keymax ||
; 288  :                 bigger > PY_SSIZE_T_MAX / sizeof(*key)) {

  00271	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR bigger$20417[rsp]
  00278	d1 e8		 shr	 eax, 1
  0027a	3b 44 24 58	 cmp	 eax, DWORD PTR keymax$[rsp]
  0027e	75 16		 jne	 SHORT $LN15@random_see
  00280	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR bigger$20417[rsp]
  00287	48 b9 ff ff ff
	ff ff ff ff 1f	 mov	 rcx, 2305843009213693951 ; 1fffffffffffffffH
  00291	48 3b c1	 cmp	 rax, rcx
  00294	76 0a		 jbe	 SHORT $LN16@random_see
$LN15@random_see:

; 289  :                 PyErr_NoMemory();

  00296	e8 00 00 00 00	 call	 PyErr_NoMemory

; 290  :                 goto Done;

  0029b	e9 c4 00 00 00	 jmp	 $Done$20390
$LN16@random_see:

; 291  :             }
; 292  :             new_key = (unsigned long *)PyMem_Realloc(key,
; 293  :                                     bigger * sizeof(*key));

  002a0	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR bigger$20417[rsp]
  002a7	48 c1 e0 02	 shl	 rax, 2
  002ab	48 8b d0	 mov	 rdx, rax
  002ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  002b3	e8 00 00 00 00	 call	 PyMem_Realloc
  002b8	48 89 44 24 50	 mov	 QWORD PTR new_key$[rsp], rax

; 294  :             if (new_key == NULL)

  002bd	48 83 7c 24 50
	00		 cmp	 QWORD PTR new_key$[rsp], 0
  002c3	75 05		 jne	 SHORT $LN14@random_see

; 295  :                 goto Done;

  002c5	e9 9a 00 00 00	 jmp	 $Done$20390
$LN14@random_see:

; 296  :             key = new_key;

  002ca	48 8b 44 24 50	 mov	 rax, QWORD PTR new_key$[rsp]
  002cf	48 89 44 24 48	 mov	 QWORD PTR key$[rsp], rax

; 297  :             keymax = bigger;

  002d4	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR bigger$20417[rsp]
  002db	89 44 24 58	 mov	 DWORD PTR keymax$[rsp], eax
$LN17@random_see:

; 298  :         }
; 299  :         assert(keyused < keymax);

  002df	8b 44 24 58	 mov	 eax, DWORD PTR keymax$[rsp]
  002e3	39 44 24 68	 cmp	 DWORD PTR keyused$[rsp], eax
  002e7	72 1c		 jb	 SHORT $LN36@random_see
  002e9	41 b8 2b 01 00
	00		 mov	 r8d, 299		; 0000012bH
  002ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DG@INJKDHIJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAr?$AAa?$AAn?$AAd?$AAo?$AAm?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@PEEPFKMA@?$AAk?$AAe?$AAy?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DM?$AA?5?$AAk?$AAe?$AAy?$AAm?$AAa?$AAx?$AA?$AA@
  002fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00303	33 c0		 xor	 eax, eax
$LN36@random_see:

; 300  :         key[keyused++] = chunk;

  00305	8b 44 24 68	 mov	 eax, DWORD PTR keyused$[rsp]
  00309	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0030e	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR chunk$20406[rsp]
  00315	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  00318	8b 44 24 68	 mov	 eax, DWORD PTR keyused$[rsp]
  0031c	ff c0		 inc	 eax
  0031e	89 44 24 68	 mov	 DWORD PTR keyused$[rsp], eax

; 301  :     }

  00322	e9 6f fe ff ff	 jmp	 $LN23@random_see
$LN22@random_see:

; 302  : 
; 303  :     if (keyused == 0)

  00327	83 7c 24 68 00	 cmp	 DWORD PTR keyused$[rsp], 0
  0032c	75 1a		 jne	 SHORT $LN13@random_see

; 304  :         key[keyused++] = 0UL;

  0032e	8b 44 24 68	 mov	 eax, DWORD PTR keyused$[rsp]
  00332	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00337	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0
  0033e	8b 44 24 68	 mov	 eax, DWORD PTR keyused$[rsp]
  00342	ff c0		 inc	 eax
  00344	89 44 24 68	 mov	 DWORD PTR keyused$[rsp], eax
$LN13@random_see:

; 305  :     result = init_by_array(self, key, keyused);

  00348	44 8b 44 24 68	 mov	 r8d, DWORD PTR keyused$[rsp]
  0034d	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00352	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0035a	e8 00 00 00 00	 call	 init_by_array
  0035f	48 89 44 24 60	 mov	 QWORD PTR result$[rsp], rax
$Done$20390:
$LN12@random_see:

; 306  : Done:
; 307  :     Py_XDECREF(masklower);

  00364	48 83 7c 24 30
	00		 cmp	 QWORD PTR masklower$[rsp], 0
  0036a	74 0a		 je	 SHORT $LN9@random_see
  0036c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR masklower$[rsp]
  00371	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@random_see:
  00376	33 c0		 xor	 eax, eax
  00378	85 c0		 test	 eax, eax
  0037a	75 e8		 jne	 SHORT $LN12@random_see
$LN8@random_see:

; 308  :     Py_XDECREF(thirtytwo);

  0037c	48 83 7c 24 70
	00		 cmp	 QWORD PTR thirtytwo$[rsp], 0
  00382	74 0a		 je	 SHORT $LN5@random_see
  00384	48 8b 4c 24 70	 mov	 rcx, QWORD PTR thirtytwo$[rsp]
  00389	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@random_see:
  0038e	33 c0		 xor	 eax, eax
  00390	85 c0		 test	 eax, eax
  00392	75 e8		 jne	 SHORT $LN8@random_see
$LN4@random_see:

; 309  :     Py_XDECREF(n);

  00394	48 83 7c 24 40
	00		 cmp	 QWORD PTR n$[rsp], 0
  0039a	74 0a		 je	 SHORT $LN1@random_see
  0039c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  003a1	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@random_see:
  003a6	33 c0		 xor	 eax, eax
  003a8	85 c0		 test	 eax, eax
  003aa	75 e8		 jne	 SHORT $LN4@random_see

; 310  :     PyMem_Free(key);

  003ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  003b1	e8 00 00 00 00	 call	 PyMem_Free

; 311  :     return result;

  003b6	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
$LN34@random_see:

; 312  : }

  003bb	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003c2	c3		 ret	 0
random_seed ENDP
_TEXT	ENDS
EXTRN	__imp__time64:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time DD	010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 48
time	PROC						; COMDAT

; 132  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 133  :     return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 134  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\_randommodule.c
pdata	SEGMENT
$pdata$init_genrand DD imagerel init_genrand
	DD	imagerel init_genrand+171
	DD	imagerel $unwind$init_genrand
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_genrand DD 010d01H
	DD	0220dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT init_genrand
_TEXT	SEGMENT
mt$ = 0
mti$ = 8
self$ = 32
s$ = 40
init_genrand PROC					; COMDAT

; 147  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 148  :     int mti;
; 149  :     unsigned long *mt;
; 150  : 
; 151  :     mt = self->state;

  0000d	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00012	48 83 c0 60	 add	 rax, 96			; 00000060H
  00016	48 89 04 24	 mov	 QWORD PTR mt$[rsp], rax

; 152  :     mt[0]= s & 0xffffffffUL;

  0001a	48 8b 04 24	 mov	 rax, QWORD PTR mt$[rsp]
  0001e	8b 4c 24 28	 mov	 ecx, DWORD PTR s$[rsp]
  00022	89 08		 mov	 DWORD PTR [rax], ecx

; 153  :     for (mti=1; mti<N; mti++) {

  00024	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR mti$[rsp], 1
  0002c	eb 0a		 jmp	 SHORT $LN3@init_genra
$LN2@init_genra:
  0002e	8b 44 24 08	 mov	 eax, DWORD PTR mti$[rsp]
  00032	ff c0		 inc	 eax
  00034	89 44 24 08	 mov	 DWORD PTR mti$[rsp], eax
$LN3@init_genra:
  00038	81 7c 24 08 70
	02 00 00	 cmp	 DWORD PTR mti$[rsp], 624 ; 00000270H
  00040	7d 55		 jge	 SHORT $LN1@init_genra

; 154  :         mt[mti] =
; 155  :         (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);

  00042	8b 44 24 08	 mov	 eax, DWORD PTR mti$[rsp]
  00046	ff c8		 dec	 eax
  00048	48 98		 cdqe
  0004a	8b 4c 24 08	 mov	 ecx, DWORD PTR mti$[rsp]
  0004e	ff c9		 dec	 ecx
  00050	48 63 c9	 movsxd	 rcx, ecx
  00053	48 8b 14 24	 mov	 rdx, QWORD PTR mt$[rsp]
  00057	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  0005a	c1 e9 1e	 shr	 ecx, 30
  0005d	48 8b 14 24	 mov	 rdx, QWORD PTR mt$[rsp]
  00061	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00064	33 c1		 xor	 eax, ecx
  00066	69 c0 65 89 07
	6c		 imul	 eax, 1812433253		; 6c078965H
  0006c	03 44 24 08	 add	 eax, DWORD PTR mti$[rsp]
  00070	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR mti$[rsp]
  00075	48 8b 14 24	 mov	 rdx, QWORD PTR mt$[rsp]
  00079	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 156  :         /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
; 157  :         /* In the previous versions, MSBs of the seed affect   */
; 158  :         /* only MSBs of the array mt[].                                */
; 159  :         /* 2002/01/09 modified by Makoto Matsumoto                     */
; 160  :         mt[mti] &= 0xffffffffUL;

  0007c	48 63 44 24 08	 movsxd	 rax, DWORD PTR mti$[rsp]
  00081	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR mti$[rsp]
  00086	48 8b 14 24	 mov	 rdx, QWORD PTR mt$[rsp]
  0008a	4c 8b 04 24	 mov	 r8, QWORD PTR mt$[rsp]
  0008e	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  00092	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 161  :         /* for >32 bit machines */
; 162  :     }

  00095	eb 97		 jmp	 SHORT $LN2@init_genra
$LN1@init_genra:

; 163  :     self->index = mti;

  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0009c	8b 4c 24 08	 mov	 ecx, DWORD PTR mti$[rsp]
  000a0	89 88 20 0a 00
	00		 mov	 DWORD PTR [rax+2592], ecx

; 164  :     return;
; 165  : }

  000a6	48 83 c4 18	 add	 rsp, 24
  000aa	c3		 ret	 0
init_genrand ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_by_array DD imagerel init_by_array
	DD	imagerel init_by_array+531
	DD	imagerel $unwind$init_by_array
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_by_array DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT init_by_array
_TEXT	SEGMENT
mt$ = 32
i$ = 40
k$ = 44
j$ = 48
tv68 = 52
self$ = 80
init_key$ = 88
key_length$ = 96
init_by_array PROC					; COMDAT

; 172  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 173  :     unsigned int i, j, k;       /* was signed in the original code. RDH 12/16/2002 */
; 174  :     unsigned long *mt;
; 175  : 
; 176  :     mt = self->state;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 83 c0 60	 add	 rax, 96			; 00000060H
  0001c	48 89 44 24 20	 mov	 QWORD PTR mt$[rsp], rax

; 177  :     init_genrand(self, 19650218UL);

  00021	ba aa d6 2b 01	 mov	 edx, 19650218		; 012bd6aaH
  00026	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0002b	e8 00 00 00 00	 call	 init_genrand

; 178  :     i=1; j=0;

  00030	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00038	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0

; 179  :     k = (N>key_length ? N : key_length);

  00040	81 7c 24 60 70
	02 00 00	 cmp	 DWORD PTR key_length$[rsp], 624 ; 00000270H
  00048	73 0a		 jae	 SHORT $LN12@init_by_ar
  0004a	c7 44 24 34 70
	02 00 00	 mov	 DWORD PTR tv68[rsp], 624 ; 00000270H
  00052	eb 08		 jmp	 SHORT $LN13@init_by_ar
$LN12@init_by_ar:
  00054	8b 44 24 60	 mov	 eax, DWORD PTR key_length$[rsp]
  00058	89 44 24 34	 mov	 DWORD PTR tv68[rsp], eax
$LN13@init_by_ar:
  0005c	8b 44 24 34	 mov	 eax, DWORD PTR tv68[rsp]
  00060	89 44 24 2c	 mov	 DWORD PTR k$[rsp], eax

; 180  :     for (; k; k--) {

  00064	eb 0a		 jmp	 SHORT $LN9@init_by_ar
$LN8@init_by_ar:
  00066	8b 44 24 2c	 mov	 eax, DWORD PTR k$[rsp]
  0006a	ff c8		 dec	 eax
  0006c	89 44 24 2c	 mov	 DWORD PTR k$[rsp], eax
$LN9@init_by_ar:
  00070	83 7c 24 2c 00	 cmp	 DWORD PTR k$[rsp], 0
  00075	0f 84 bf 00 00
	00		 je	 $LN7@init_by_ar

; 181  :         mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
; 182  :                  + init_key[j] + j; /* non linear */

  0007b	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0007f	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  00083	ff c9		 dec	 ecx
  00085	8b c9		 mov	 ecx, ecx
  00087	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  0008b	ff ca		 dec	 edx
  0008d	8b d2		 mov	 edx, edx
  0008f	4c 8b 44 24 20	 mov	 r8, QWORD PTR mt$[rsp]
  00094	41 8b 14 90	 mov	 edx, DWORD PTR [r8+rdx*4]
  00098	c1 ea 1e	 shr	 edx, 30
  0009b	4c 8b 44 24 20	 mov	 r8, QWORD PTR mt$[rsp]
  000a0	41 8b 0c 88	 mov	 ecx, DWORD PTR [r8+rcx*4]
  000a4	33 ca		 xor	 ecx, edx
  000a6	69 c9 0d 66 19
	00		 imul	 ecx, 1664525		; 0019660dH
  000ac	48 8b 54 24 20	 mov	 rdx, QWORD PTR mt$[rsp]
  000b1	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  000b4	33 c1		 xor	 eax, ecx
  000b6	8b 4c 24 30	 mov	 ecx, DWORD PTR j$[rsp]
  000ba	48 8b 54 24 58	 mov	 rdx, QWORD PTR init_key$[rsp]
  000bf	03 04 8a	 add	 eax, DWORD PTR [rdx+rcx*4]
  000c2	03 44 24 30	 add	 eax, DWORD PTR j$[rsp]
  000c6	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  000ca	48 8b 54 24 20	 mov	 rdx, QWORD PTR mt$[rsp]
  000cf	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 183  :         mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */

  000d2	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000d6	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  000da	48 8b 54 24 20	 mov	 rdx, QWORD PTR mt$[rsp]
  000df	4c 8b 44 24 20	 mov	 r8, QWORD PTR mt$[rsp]
  000e4	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  000e8	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 184  :         i++; j++;

  000eb	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000ef	ff c0		 inc	 eax
  000f1	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  000f5	8b 44 24 30	 mov	 eax, DWORD PTR j$[rsp]
  000f9	ff c0		 inc	 eax
  000fb	89 44 24 30	 mov	 DWORD PTR j$[rsp], eax

; 185  :         if (i>=N) { mt[0] = mt[N-1]; i=1; }

  000ff	81 7c 24 28 70
	02 00 00	 cmp	 DWORD PTR i$[rsp], 624	; 00000270H
  00107	72 1a		 jb	 SHORT $LN6@init_by_ar
  00109	48 8b 44 24 20	 mov	 rax, QWORD PTR mt$[rsp]
  0010e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mt$[rsp]
  00113	8b 89 bc 09 00
	00		 mov	 ecx, DWORD PTR [rcx+2492]
  00119	89 08		 mov	 DWORD PTR [rax], ecx
  0011b	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
$LN6@init_by_ar:

; 186  :         if (j>=key_length) j=0;

  00123	8b 44 24 60	 mov	 eax, DWORD PTR key_length$[rsp]
  00127	39 44 24 30	 cmp	 DWORD PTR j$[rsp], eax
  0012b	72 08		 jb	 SHORT $LN5@init_by_ar
  0012d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
$LN5@init_by_ar:

; 187  :     }

  00135	e9 2c ff ff ff	 jmp	 $LN8@init_by_ar
$LN7@init_by_ar:

; 188  :     for (k=N-1; k; k--) {

  0013a	c7 44 24 2c 6f
	02 00 00	 mov	 DWORD PTR k$[rsp], 623	; 0000026fH
  00142	eb 0a		 jmp	 SHORT $LN4@init_by_ar
$LN3@init_by_ar:
  00144	8b 44 24 2c	 mov	 eax, DWORD PTR k$[rsp]
  00148	ff c8		 dec	 eax
  0014a	89 44 24 2c	 mov	 DWORD PTR k$[rsp], eax
$LN4@init_by_ar:
  0014e	83 7c 24 2c 00	 cmp	 DWORD PTR k$[rsp], 0
  00153	0f 84 97 00 00
	00		 je	 $LN2@init_by_ar

; 189  :         mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
; 190  :                  - i; /* non linear */

  00159	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0015d	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  00161	ff c9		 dec	 ecx
  00163	8b c9		 mov	 ecx, ecx
  00165	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  00169	ff ca		 dec	 edx
  0016b	8b d2		 mov	 edx, edx
  0016d	4c 8b 44 24 20	 mov	 r8, QWORD PTR mt$[rsp]
  00172	41 8b 14 90	 mov	 edx, DWORD PTR [r8+rdx*4]
  00176	c1 ea 1e	 shr	 edx, 30
  00179	4c 8b 44 24 20	 mov	 r8, QWORD PTR mt$[rsp]
  0017e	41 8b 0c 88	 mov	 ecx, DWORD PTR [r8+rcx*4]
  00182	33 ca		 xor	 ecx, edx
  00184	69 c9 65 8b 58
	5d		 imul	 ecx, 1566083941		; 5d588b65H
  0018a	48 8b 54 24 20	 mov	 rdx, QWORD PTR mt$[rsp]
  0018f	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00192	33 c1		 xor	 eax, ecx
  00194	2b 44 24 28	 sub	 eax, DWORD PTR i$[rsp]
  00198	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  0019c	48 8b 54 24 20	 mov	 rdx, QWORD PTR mt$[rsp]
  001a1	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 191  :         mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */

  001a4	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001a8	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  001ac	48 8b 54 24 20	 mov	 rdx, QWORD PTR mt$[rsp]
  001b1	4c 8b 44 24 20	 mov	 r8, QWORD PTR mt$[rsp]
  001b6	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  001ba	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 192  :         i++;

  001bd	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001c1	ff c0		 inc	 eax
  001c3	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 193  :         if (i>=N) { mt[0] = mt[N-1]; i=1; }

  001c7	81 7c 24 28 70
	02 00 00	 cmp	 DWORD PTR i$[rsp], 624	; 00000270H
  001cf	72 1a		 jb	 SHORT $LN1@init_by_ar
  001d1	48 8b 44 24 20	 mov	 rax, QWORD PTR mt$[rsp]
  001d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mt$[rsp]
  001db	8b 89 bc 09 00
	00		 mov	 ecx, DWORD PTR [rcx+2492]
  001e1	89 08		 mov	 DWORD PTR [rax], ecx
  001e3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
$LN1@init_by_ar:

; 194  :     }

  001eb	e9 54 ff ff ff	 jmp	 $LN3@init_by_ar
$LN2@init_by_ar:

; 195  : 
; 196  :     mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */

  001f0	48 8b 44 24 20	 mov	 rax, QWORD PTR mt$[rsp]
  001f5	c7 00 00 00 00
	80		 mov	 DWORD PTR [rax], -2147483648 ; 80000000H

; 197  :     Py_INCREF(Py_None);

  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00202	e8 00 00 00 00	 call	 _Py_IncRef

; 198  :     return Py_None;

  00207	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 199  : }

  0020e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00212	c3		 ret	 0
init_by_array ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$random_getstate DD imagerel random_getstate
	DD	imagerel random_getstate+200
	DD	imagerel $unwind$random_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_getstate DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT random_getstate
_TEXT	SEGMENT
element$ = 32
i$ = 40
state$ = 48
self$ = 80
random_getstate PROC					; COMDAT

; 316  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 317  :     PyObject *state;
; 318  :     PyObject *element;
; 319  :     int i;
; 320  : 
; 321  :     state = PyTuple_New(N+1);

  00009	b9 71 02 00 00	 mov	 ecx, 625		; 00000271H
  0000e	e8 00 00 00 00	 call	 PyTuple_New
  00013	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 322  :     if (state == NULL)

  00018	48 83 7c 24 30
	00		 cmp	 QWORD PTR state$[rsp], 0
  0001e	75 07		 jne	 SHORT $LN6@random_get

; 323  :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	e9 9c 00 00 00	 jmp	 $LN7@random_get
$LN6@random_get:

; 324  :     for (i=0; i<N ; i++) {

  00027	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002f	eb 0a		 jmp	 SHORT $LN5@random_get
$LN4@random_get:
  00031	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00035	ff c0		 inc	 eax
  00037	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN5@random_get:
  0003b	81 7c 24 28 70
	02 00 00	 cmp	 DWORD PTR i$[rsp], 624	; 00000270H
  00043	7d 38		 jge	 SHORT $LN3@random_get

; 325  :         element = PyLong_FromUnsignedLong(self->state[i]);

  00045	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0004a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0004f	8b 4c 81 60	 mov	 ecx, DWORD PTR [rcx+rax*4+96]
  00053	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  00058	48 89 44 24 20	 mov	 QWORD PTR element$[rsp], rax

; 326  :         if (element == NULL)

  0005d	48 83 7c 24 20
	00		 cmp	 QWORD PTR element$[rsp], 0
  00063	75 02		 jne	 SHORT $LN2@random_get

; 327  :             goto Fail;

  00065	eb 50		 jmp	 SHORT $Fail$20459
$LN2@random_get:

; 328  :         PyTuple_SET_ITEM(state, i, element);

  00067	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0006c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00071	48 8b 54 24 20	 mov	 rdx, QWORD PTR element$[rsp]
  00076	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 329  :     }

  0007b	eb b4		 jmp	 SHORT $LN4@random_get
$LN3@random_get:

; 330  :     element = PyLong_FromLong((long)(self->index));

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00082	8b 88 20 0a 00
	00		 mov	 ecx, DWORD PTR [rax+2592]
  00088	e8 00 00 00 00	 call	 PyLong_FromLong
  0008d	48 89 44 24 20	 mov	 QWORD PTR element$[rsp], rax

; 331  :     if (element == NULL)

  00092	48 83 7c 24 20
	00		 cmp	 QWORD PTR element$[rsp], 0
  00098	75 02		 jne	 SHORT $LN1@random_get

; 332  :         goto Fail;

  0009a	eb 1b		 jmp	 SHORT $Fail$20459
$LN1@random_get:

; 333  :     PyTuple_SET_ITEM(state, i, element);

  0009c	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  000a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000a6	48 8b 54 24 20	 mov	 rdx, QWORD PTR element$[rsp]
  000ab	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 334  :     return state;

  000b0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000b5	eb 0c		 jmp	 SHORT $LN7@random_get
$Fail$20459:

; 335  : 
; 336  : Fail:
; 337  :     Py_DECREF(state);

  000b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000bc	e8 00 00 00 00	 call	 _Py_DecRef

; 338  :     return NULL;

  000c1	33 c0		 xor	 eax, eax
$LN7@random_get:

; 339  : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
random_getstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@FGJCAIOP@state?5vector?5is?5the?5wrong?5size?$AA@ ; `string'
PUBLIC	??_C@_0BN@JMGFCIDC@state?5vector?5must?5be?5a?5tuple?$AA@ ; `string'
EXTRN	PyLong_AsLong:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyTuple_Size:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$random_setstate DD imagerel random_setstate
	DD	imagerel random_setstate+287
	DD	imagerel $unwind$random_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_setstate DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BP@FGJCAIOP@state?5vector?5is?5the?5wrong?5size?$AA@
CONST	SEGMENT
??_C@_0BP@FGJCAIOP@state?5vector?5is?5the?5wrong?5size?$AA@ DB 'state vec'
	DB	'tor is the wrong size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMGFCIDC@state?5vector?5must?5be?5a?5tuple?$AA@
CONST	SEGMENT
??_C@_0BN@JMGFCIDC@state?5vector?5must?5be?5a?5tuple?$AA@ DB 'state vecto'
	DB	'r must be a tuple', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT random_setstate
_TEXT	SEGMENT
element$ = 32
i$ = 36
index$ = 40
self$ = 64
state$ = 72
random_setstate PROC					; COMDAT

; 343  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 344  :     int i;
; 345  :     unsigned long element;
; 346  :     long index;
; 347  : 
; 348  :     if (!PyTuple_Check(state)) {

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00022	85 c0		 test	 eax, eax
  00024	75 1a		 jne	 SHORT $LN7@random_set

; 349  :         PyErr_SetString(PyExc_TypeError,
; 350  :             "state vector must be a tuple");

  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JMGFCIDC@state?5vector?5must?5be?5a?5tuple?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00034	e8 00 00 00 00	 call	 PyErr_SetString

; 351  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 da 00 00 00	 jmp	 $LN8@random_set
$LN7@random_set:

; 352  :     }
; 353  :     if (PyTuple_Size(state) != N+1) {

  00040	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00045	e8 00 00 00 00	 call	 PyTuple_Size
  0004a	48 3d 71 02 00
	00		 cmp	 rax, 625		; 00000271H
  00050	74 1a		 je	 SHORT $LN6@random_set

; 354  :         PyErr_SetString(PyExc_ValueError,
; 355  :             "state vector is the wrong size");

  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@FGJCAIOP@state?5vector?5is?5the?5wrong?5size?$AA@
  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00060	e8 00 00 00 00	 call	 PyErr_SetString

; 356  :         return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	e9 ae 00 00 00	 jmp	 $LN8@random_set
$LN6@random_set:

; 357  :     }
; 358  : 
; 359  :     for (i=0; i<N ; i++) {

  0006c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00074	eb 0a		 jmp	 SHORT $LN5@random_set
$LN4@random_set:
  00076	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0007a	ff c0		 inc	 eax
  0007c	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN5@random_set:
  00080	81 7c 24 24 70
	02 00 00	 cmp	 DWORD PTR i$[rsp], 624	; 00000270H
  00088	7d 41		 jge	 SHORT $LN3@random_set

; 360  :         element = PyLong_AsUnsignedLong(PyTuple_GET_ITEM(state, i));

  0008a	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0008f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00094	48 8b 4c c1 70	 mov	 rcx, QWORD PTR [rcx+rax*8+112]
  00099	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  0009e	89 44 24 20	 mov	 DWORD PTR element$[rsp], eax

; 361  :         if (element == (unsigned long)-1 && PyErr_Occurred())

  000a2	83 7c 24 20 ff	 cmp	 DWORD PTR element$[rsp], -1 ; ffffffffH
  000a7	75 0e		 jne	 SHORT $LN2@random_set
  000a9	e8 00 00 00 00	 call	 PyErr_Occurred
  000ae	48 85 c0	 test	 rax, rax
  000b1	74 04		 je	 SHORT $LN2@random_set

; 362  :             return NULL;

  000b3	33 c0		 xor	 eax, eax
  000b5	eb 63		 jmp	 SHORT $LN8@random_set
$LN2@random_set:

; 363  :         self->state[i] = element & 0xffffffffUL; /* Make sure we get sane state */

  000b7	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000c1	8b 54 24 20	 mov	 edx, DWORD PTR element$[rsp]
  000c5	89 54 81 60	 mov	 DWORD PTR [rcx+rax*4+96], edx

; 364  :     }

  000c9	eb ab		 jmp	 SHORT $LN4@random_set
$LN3@random_set:

; 365  : 
; 366  :     index = PyLong_AsLong(PyTuple_GET_ITEM(state, i));

  000cb	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000d0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  000d5	48 8b 4c c1 70	 mov	 rcx, QWORD PTR [rcx+rax*8+112]
  000da	e8 00 00 00 00	 call	 PyLong_AsLong
  000df	89 44 24 28	 mov	 DWORD PTR index$[rsp], eax

; 367  :     if (index == -1 && PyErr_Occurred())

  000e3	83 7c 24 28 ff	 cmp	 DWORD PTR index$[rsp], -1
  000e8	75 0e		 jne	 SHORT $LN1@random_set
  000ea	e8 00 00 00 00	 call	 PyErr_Occurred
  000ef	48 85 c0	 test	 rax, rax
  000f2	74 04		 je	 SHORT $LN1@random_set

; 368  :         return NULL;

  000f4	33 c0		 xor	 eax, eax
  000f6	eb 22		 jmp	 SHORT $LN8@random_set
$LN1@random_set:

; 369  :     self->index = (int)index;

  000f8	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000fd	8b 4c 24 28	 mov	 ecx, DWORD PTR index$[rsp]
  00101	89 88 20 0a 00
	00		 mov	 DWORD PTR [rax+2592], ecx

; 370  : 
; 371  :     Py_INCREF(Py_None);

  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0010e	e8 00 00 00 00	 call	 _Py_IncRef

; 372  :     return Py_None;

  00113	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@random_set:

; 373  : }

  0011a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011e	c3		 ret	 0
random_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@IHHDGINB@number?5of?5bits?5must?5be?5greater?5t@ ; `string'
PUBLIC	??_C@_0O@MLMMKANI@i?3getrandbits?$AA@		; `string'
EXTRN	_PyLong_FromByteArray:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$random_getrandbits DD imagerel random_getrandbits
	DD	imagerel random_getrandbits+382
	DD	imagerel $unwind$random_getrandbits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_getrandbits DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0CJ@IHHDGINB@number?5of?5bits?5must?5be?5greater?5t@
CONST	SEGMENT
??_C@_0CJ@IHHDGINB@number?5of?5bits?5must?5be?5greater?5t@ DB 'number of '
	DB	'bits must be greater than zero', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLMMKANI@i?3getrandbits?$AA@
CONST	SEGMENT
??_C@_0O@MLMMKANI@i?3getrandbits?$AA@ DB 'i:getrandbits', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT random_getrandbits
_TEXT	SEGMENT
i$ = 32
bytes$ = 36
k$ = 40
result$ = 48
r$ = 56
bytearray$ = 64
self$ = 96
args$ = 104
random_getrandbits PROC					; COMDAT

; 377  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 378  :     int k, i, bytes;
; 379  :     unsigned long r;
; 380  :     unsigned char *bytearray;
; 381  :     PyObject *result;
; 382  : 
; 383  :     if (!PyArg_ParseTuple(args, "i:getrandbits", &k))

  0000e	4c 8d 44 24 28	 lea	 r8, QWORD PTR k$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@MLMMKANI@i?3getrandbits?$AA@
  0001a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 07		 jne	 SHORT $LN7@random_get@2

; 384  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 4a 01 00 00	 jmp	 $LN8@random_get@2
$LN7@random_get@2:

; 385  : 
; 386  :     if (k <= 0) {

  0002f	83 7c 24 28 00	 cmp	 DWORD PTR k$[rsp], 0
  00034	7f 1a		 jg	 SHORT $LN6@random_get@2

; 387  :         PyErr_SetString(PyExc_ValueError,
; 388  :                         "number of bits must be greater than zero");

  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@IHHDGINB@number?5of?5bits?5must?5be?5greater?5t@
  0003d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00044	e8 00 00 00 00	 call	 PyErr_SetString

; 389  :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 29 01 00 00	 jmp	 $LN8@random_get@2
$LN6@random_get@2:

; 390  :     }
; 391  : 
; 392  :     bytes = ((k - 1) / 32 + 1) * 4;

  00050	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  00054	ff c8		 dec	 eax
  00056	99		 cdq
  00057	83 e2 1f	 and	 edx, 31
  0005a	03 c2		 add	 eax, edx
  0005c	c1 f8 05	 sar	 eax, 5
  0005f	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [rax*4+4]
  00066	89 44 24 24	 mov	 DWORD PTR bytes$[rsp], eax

; 393  :     bytearray = (unsigned char *)PyMem_Malloc(bytes);

  0006a	48 63 44 24 24	 movsxd	 rax, DWORD PTR bytes$[rsp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 PyMem_Malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR bytearray$[rsp], rax

; 394  :     if (bytearray == NULL) {

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR bytearray$[rsp], 0
  00082	75 0c		 jne	 SHORT $LN5@random_get@2

; 395  :         PyErr_NoMemory();

  00084	e8 00 00 00 00	 call	 PyErr_NoMemory

; 396  :         return NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	e9 e9 00 00 00	 jmp	 $LN8@random_get@2
$LN5@random_get@2:

; 397  :     }
; 398  : 
; 399  :     /* Fill-out whole words, byte-by-byte to avoid endianness issues */
; 400  :     for (i=0 ; i<bytes ; i+=4, k-=32) {

  00090	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00098	eb 16		 jmp	 SHORT $LN4@random_get@2
$LN3@random_get@2:
  0009a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0009e	83 c0 04	 add	 eax, 4
  000a1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000a5	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  000a9	83 e8 20	 sub	 eax, 32			; 00000020H
  000ac	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax
$LN4@random_get@2:
  000b0	8b 44 24 24	 mov	 eax, DWORD PTR bytes$[rsp]
  000b4	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000b8	0f 8d 8c 00 00
	00		 jge	 $LN2@random_get@2

; 401  :         r = genrand_int32(self);

  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000c3	e8 00 00 00 00	 call	 genrand_int32
  000c8	89 44 24 38	 mov	 DWORD PTR r$[rsp], eax

; 402  :         if (k < 32)

  000cc	83 7c 24 28 20	 cmp	 DWORD PTR k$[rsp], 32	; 00000020H
  000d1	7d 16		 jge	 SHORT $LN1@random_get@2

; 403  :             r >>= (32 - k);

  000d3	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000d8	2b 44 24 28	 sub	 eax, DWORD PTR k$[rsp]
  000dc	0f b6 c8	 movzx	 ecx, al
  000df	8b 44 24 38	 mov	 eax, DWORD PTR r$[rsp]
  000e3	d3 e8		 shr	 eax, cl
  000e5	89 44 24 38	 mov	 DWORD PTR r$[rsp], eax
$LN1@random_get@2:

; 404  :         bytearray[i+0] = (unsigned char)r;

  000e9	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytearray$[rsp]
  000f3	0f b6 54 24 38	 movzx	 edx, BYTE PTR r$[rsp]
  000f8	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 405  :         bytearray[i+1] = (unsigned char)(r >> 8);

  000fb	8b 44 24 38	 mov	 eax, DWORD PTR r$[rsp]
  000ff	c1 e8 08	 shr	 eax, 8
  00102	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00106	ff c1		 inc	 ecx
  00108	48 63 c9	 movsxd	 rcx, ecx
  0010b	48 8b 54 24 40	 mov	 rdx, QWORD PTR bytearray$[rsp]
  00110	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 406  :         bytearray[i+2] = (unsigned char)(r >> 16);

  00113	8b 44 24 38	 mov	 eax, DWORD PTR r$[rsp]
  00117	c1 e8 10	 shr	 eax, 16
  0011a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0011e	83 c1 02	 add	 ecx, 2
  00121	48 63 c9	 movsxd	 rcx, ecx
  00124	48 8b 54 24 40	 mov	 rdx, QWORD PTR bytearray$[rsp]
  00129	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 407  :         bytearray[i+3] = (unsigned char)(r >> 24);

  0012c	8b 44 24 38	 mov	 eax, DWORD PTR r$[rsp]
  00130	c1 e8 18	 shr	 eax, 24
  00133	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00137	83 c1 03	 add	 ecx, 3
  0013a	48 63 c9	 movsxd	 rcx, ecx
  0013d	48 8b 54 24 40	 mov	 rdx, QWORD PTR bytearray$[rsp]
  00142	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 408  :     }

  00145	e9 50 ff ff ff	 jmp	 $LN3@random_get@2
$LN2@random_get@2:

; 409  : 
; 410  :     /* little endian order to match bytearray assignment order */
; 411  :     result = _PyLong_FromByteArray(bytearray, bytes, 1, 0);

  0014a	48 63 44 24 24	 movsxd	 rax, DWORD PTR bytes$[rsp]
  0014f	45 33 c9	 xor	 r9d, r9d
  00152	41 b8 01 00 00
	00		 mov	 r8d, 1
  00158	48 8b d0	 mov	 rdx, rax
  0015b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytearray$[rsp]
  00160	e8 00 00 00 00	 call	 _PyLong_FromByteArray
  00165	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 412  :     PyMem_Free(bytearray);

  0016a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytearray$[rsp]
  0016f	e8 00 00 00 00	 call	 PyMem_Free

; 413  :     return result;

  00174	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN8@random_get@2:

; 414  : }

  00179	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0017d	c3		 ret	 0
random_getrandbits ENDP
_TEXT	ENDS
PUBLIC	??_C@_08LBMJBPIB@Random?$CI?$CJ?$AA@		; `string'
EXTRN	_PyArg_NoKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$random_new DD imagerel random_new
	DD	imagerel random_new+155
	DD	imagerel $unwind$random_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_new DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_08LBMJBPIB@Random?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_08LBMJBPIB@Random?$CI?$CJ?$AA@ DB 'Random()', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT random_new
_TEXT	SEGMENT
tmp$ = 32
self$ = 40
type$ = 64
args$ = 72
kwds$ = 80
random_new PROC						; COMDAT

; 418  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 419  :     RandomObject *self;
; 420  :     PyObject *tmp;
; 421  : 
; 422  :     if (type == &Random_Type && !_PyArg_NoKeywords("Random()", kwds))

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Random_Type
  0001a	48 39 44 24 40	 cmp	 QWORD PTR type$[rsp], rax
  0001f	75 19		 jne	 SHORT $LN3@random_new
  00021	48 8b 54 24 50	 mov	 rdx, QWORD PTR kwds$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08LBMJBPIB@Random?$CI?$CJ?$AA@
  0002d	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00032	85 c0		 test	 eax, eax
  00034	75 04		 jne	 SHORT $LN3@random_new

; 423  :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 5c		 jmp	 SHORT $LN4@random_new
$LN3@random_new:

; 424  : 
; 425  :     self = (RandomObject *)type->tp_alloc(type, 0);

  0003a	33 d2		 xor	 edx, edx
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  00046	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  0004c	48 89 44 24 28	 mov	 QWORD PTR self$[rsp], rax

; 426  :     if (self == NULL)

  00051	48 83 7c 24 28
	00		 cmp	 QWORD PTR self$[rsp], 0
  00057	75 04		 jne	 SHORT $LN2@random_new

; 427  :         return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	eb 39		 jmp	 SHORT $LN4@random_new
$LN2@random_new:

; 428  :     tmp = random_seed(self, args);

  0005d	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00062	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  00067	e8 00 00 00 00	 call	 random_seed
  0006c	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 429  :     if (tmp == NULL) {

  00071	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00077	75 0e		 jne	 SHORT $LN1@random_new

; 430  :         Py_DECREF(self);

  00079	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  0007e	e8 00 00 00 00	 call	 _Py_DecRef

; 431  :         return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	eb 0f		 jmp	 SHORT $LN4@random_new
$LN1@random_new:

; 432  :     }
; 433  :     Py_DECREF(tmp);

  00087	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0008c	e8 00 00 00 00	 call	 _Py_DecRef

; 434  :     return (PyObject *)self;

  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
$LN4@random_new:

; 435  : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
random_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_06BEOPDEGP@Random?$AA@			; `string'
PUBLIC	PyInit__random
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__random DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$PyInit__random
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__random DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_06BEOPDEGP@Random?$AA@
CONST	SEGMENT
??_C@_06BEOPDEGP@Random?$AA@ DB 'Random', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit__random
_TEXT	SEGMENT
m$ = 32
PyInit__random PROC					; COMDAT

; 517  : {

$LN5:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 518  :     PyObject *m;
; 519  : 
; 520  :     if (PyType_Ready(&Random_Type) < 0)

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Random_Type
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	7d 04		 jge	 SHORT $LN2@PyInit__ra

; 521  :         return NULL;

  00014	33 c0		 xor	 eax, eax
  00016	eb 4b		 jmp	 SHORT $LN3@PyInit__ra
$LN2@PyInit__ra:

; 522  :     m = PyModule_Create(&_randommodule);

  00018	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_randommodule
  00024	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00029	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 523  :     if (m == NULL)

  0002e	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00034	75 04		 jne	 SHORT $LN1@PyInit__ra

; 524  :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 29		 jmp	 SHORT $LN3@PyInit__ra
$LN1@PyInit__ra:

; 525  :     Py_INCREF(&Random_Type);

  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Random_Type
  00041	e8 00 00 00 00	 call	 _Py_IncRef

; 526  :     PyModule_AddObject(m, "Random", (PyObject *)&Random_Type);

  00046	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Random_Type
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06BEOPDEGP@Random?$AA@
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  00059	e8 00 00 00 00	 call	 PyModule_AddObject

; 527  :     return m;

  0005e	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
$LN3@PyInit__ra:

; 528  : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
PyInit__random ENDP
_TEXT	ENDS
END
