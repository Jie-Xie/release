; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LEAOPCJE@no?5mem?5for?5new?5grammar?$AA@ ; `string'
PUBLIC	_Py_newgrammar
EXTRN	Py_FatalError:PROC
EXTRN	_PyObject_DebugMalloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\parser\grammar.c
pdata	SEGMENT
$pdata$_Py_newgrammar DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$_Py_newgrammar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_newgrammar DD 010801H
	DD	06208H
xdata	ENDS
;	COMDAT ??_C@_0BH@LEAOPCJE@no?5mem?5for?5new?5grammar?$AA@
CONST	SEGMENT
??_C@_0BH@LEAOPCJE@no?5mem?5for?5new?5grammar?$AA@ DB 'no mem for new gra'
	DB	'mmar', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_newgrammar
_TEXT	SEGMENT
g$ = 32
start$ = 64
_Py_newgrammar PROC					; COMDAT

; 16   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 17   :     grammar *g;
; 18   : 
; 19   :     g = (grammar *)PyObject_MALLOC(sizeof(grammar));

  00008	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0000d	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00012	48 89 44 24 20	 mov	 QWORD PTR g$[rsp], rax

; 20   :     if (g == NULL)

  00017	48 83 7c 24 20
	00		 cmp	 QWORD PTR g$[rsp], 0
  0001d	75 0c		 jne	 SHORT $LN1@Py_newgram

; 21   :         Py_FatalError("no mem for new grammar");

  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LEAOPCJE@no?5mem?5for?5new?5grammar?$AA@
  00026	e8 00 00 00 00	 call	 Py_FatalError
$LN1@Py_newgram:

; 22   :     g->g_ndfas = 0;

  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR g$[rsp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 23   :     g->g_dfa = NULL;

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR g$[rsp]
  0003b	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 24   :     g->g_start = start;

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR g$[rsp]
  00048	8b 4c 24 40	 mov	 ecx, DWORD PTR start$[rsp]
  0004c	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 25   :     g->g_ll.ll_nlabels = 0;

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR g$[rsp]
  00054	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 26   :     g->g_ll.ll_label = NULL;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR g$[rsp]
  00060	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 27   :     g->g_accel = 0;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR g$[rsp]
  0006d	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 28   :     return g;

  00074	48 8b 44 24 20	 mov	 rax, QWORD PTR g$[rsp]

; 29   : }

  00079	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007d	c3		 ret	 0
_Py_newgrammar ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@PACJOLEE@no?5mem?5to?5resize?5dfa?5in?5adddfa?$AA@ ; `string'
PUBLIC	_Py_adddfa
EXTRN	__imp_strdup:PROC
EXTRN	_PyObject_DebugRealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_adddfa DD imagerel $LN4
	DD	imagerel $LN4+216
	DD	imagerel $unwind$_Py_adddfa
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_adddfa DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT ??_C@_0BP@PACJOLEE@no?5mem?5to?5resize?5dfa?5in?5adddfa?$AA@
CONST	SEGMENT
??_C@_0BP@PACJOLEE@no?5mem?5to?5resize?5dfa?5in?5adddfa?$AA@ DB 'no mem t'
	DB	'o resize dfa in adddfa', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_adddfa
_TEXT	SEGMENT
d$ = 32
g$ = 64
type$ = 72
name$ = 80
_Py_adddfa PROC						; COMDAT

; 33   : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 34   :     dfa *d;
; 35   : 
; 36   :     g->g_dfa = (dfa *)PyObject_REALLOC(g->g_dfa,
; 37   :                                         sizeof(dfa) * (g->g_ndfas + 1));

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00017	8b 00		 mov	 eax, DWORD PTR [rax]
  00019	ff c0		 inc	 eax
  0001b	48 98		 cdqe
  0001d	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00021	48 8b d0	 mov	 rdx, rax
  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00029	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002d	e8 00 00 00 00	 call	 _PyObject_DebugRealloc
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$[rsp]
  00037	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 38   :     if (g->g_dfa == NULL)

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00040	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00045	75 0c		 jne	 SHORT $LN1@Py_adddfa

; 39   :         Py_FatalError("no mem to resize dfa in adddfa");

  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@PACJOLEE@no?5mem?5to?5resize?5dfa?5in?5adddfa?$AA@
  0004e	e8 00 00 00 00	 call	 Py_FatalError
$LN1@Py_adddfa:

; 40   :     d = &g->g_dfa[g->g_ndfas++];

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00058	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0005b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$[rsp]
  00064	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00068	48 89 44 24 20	 mov	 QWORD PTR d$[rsp], rax
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00072	8b 00		 mov	 eax, DWORD PTR [rax]
  00074	ff c0		 inc	 eax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$[rsp]
  0007b	89 01		 mov	 DWORD PTR [rcx], eax

; 41   :     d->d_type = type;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR d$[rsp]
  00082	8b 4c 24 48	 mov	 ecx, DWORD PTR type$[rsp]
  00086	89 08		 mov	 DWORD PTR [rax], ecx

; 42   :     d->d_name = strdup(name);

  00088	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$[rsp]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00098	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 43   :     d->d_nstates = 0;

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR d$[rsp]
  000a1	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 44   :     d->d_state = NULL;

  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR d$[rsp]
  000ad	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 45   :     d->d_initial = -1;

  000b5	48 8b 44 24 20	 mov	 rax, QWORD PTR d$[rsp]
  000ba	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [rax+16], -1

; 46   :     d->d_first = NULL;

  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR d$[rsp]
  000c6	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 47   :     return d; /* Only use while fresh! */

  000ce	48 8b 44 24 20	 mov	 rax, QWORD PTR d$[rsp]

; 48   : }

  000d3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d7	c3		 ret	 0
_Py_adddfa ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@NDGOOPPB@no?5mem?5to?5resize?5state?5in?5addsta@ ; `string'
PUBLIC	_Py_addstate
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_addstate DD imagerel $LN4
	DD	imagerel $LN4+228
	DD	imagerel $unwind$_Py_addstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_addstate DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CD@NDGOOPPB@no?5mem?5to?5resize?5state?5in?5addsta@
CONST	SEGMENT
??_C@_0CD@NDGOOPPB@no?5mem?5to?5resize?5state?5in?5addsta@ DB 'no mem to '
	DB	'resize state in addstate', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_addstate
_TEXT	SEGMENT
s$ = 32
d$ = 64
_Py_addstate PROC					; COMDAT

; 52   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 53   :     state *s;
; 54   : 
; 55   :     d->d_state = (state *)PyObject_REALLOC(d->d_state,
; 56   :                                   sizeof(state) * (d->d_nstates + 1));

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  0000e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00011	ff c0		 inc	 eax
  00013	48 98		 cdqe
  00015	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  00021	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00025	e8 00 00 00 00	 call	 _PyObject_DebugRealloc
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  0002f	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 57   :     if (d->d_state == NULL)

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  00038	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0003d	75 0c		 jne	 SHORT $LN1@Py_addstat

; 58   :         Py_FatalError("no mem to resize state in addstate");

  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@NDGOOPPB@no?5mem?5to?5resize?5state?5in?5addsta@
  00046	e8 00 00 00 00	 call	 Py_FatalError
$LN1@Py_addstat:

; 59   :     s = &d->d_state[d->d_nstates++];

  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  00050	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  00054	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  0005d	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00061	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  0006b	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0006e	ff c0		 inc	 eax
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00075	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 60   :     s->s_narcs = 0;

  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0007d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 61   :     s->s_arc = NULL;

  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00088	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 62   :     s->s_lower = 0;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00095	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 63   :     s->s_upper = 0;

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000a1	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 64   :     s->s_accel = NULL;

  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ad	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 65   :     s->s_accept = 0;

  000b5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ba	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 66   :     return s - d->d_state;

  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  000c6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ca	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	48 2b c8	 sub	 rcx, rax
  000d2	48 8b c1	 mov	 rax, rcx
  000d5	48 99		 cdq
  000d7	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000dc	48 f7 f9	 idiv	 rcx

; 67   : }

  000df	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e3	c3		 ret	 0
_Py_addstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@LKHKMPMN@no?5mem?5to?5resize?5arc?5list?5in?5add@ ; `string'
PUBLIC	??_C@_1DK@DCNLMLOE@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAo?$AA?5?$AA?$DM?$AA?5?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAn?$AAs?$AAt?$AAa?$AAt?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EC@IAIJOMPE@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AA?$DM?$AA?5?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAn?$AAs?$AAt?$AAa?$AAt?$AAe?$AAs@ ; `string'
PUBLIC	??_C@_1CI@BBKOADBM@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAg?$AAr?$AAa?$AAm?$AAm?$AAa?$AAr?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	_Py_addarc
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_addarc DD imagerel $LN8
	DD	imagerel $LN8+283
	DD	imagerel $unwind$_Py_addarc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_addarc DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT ??_C@_0CE@LKHKMPMN@no?5mem?5to?5resize?5arc?5list?5in?5add@
CONST	SEGMENT
??_C@_0CE@LKHKMPMN@no?5mem?5to?5resize?5arc?5list?5in?5add@ DB 'no mem to'
	DB	' resize arc list in addarc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@DCNLMLOE@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAo?$AA?5?$AA?$DM?$AA?5?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAn?$AAs?$AAt?$AAa?$AAt?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@DCNLMLOE@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAo?$AA?5?$AA?$DM?$AA?5?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAn?$AAs?$AAt?$AAa?$AAt?$AAe?$AAs?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 't', 00H, 'o', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'd', 00H, '-', 00H, '>', 00H, 'd', 00H
	DB	'_', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@IAIJOMPE@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AA?$DM?$AA?5?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAn?$AAs?$AAt?$AAa?$AAt?$AAe?$AAs@
CONST	SEGMENT
??_C@_1EC@IAIJOMPE@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AA?$DM?$AA?5?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAn?$AAs?$AAt?$AAa?$AAt?$AAe?$AAs@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'f', 00H, 'r', 00H
	DB	'o', 00H, 'm', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'f'
	DB	00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'd', 00H, '-', 00H, '>', 00H, 'd', 00H, '_', 00H, 'n', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@BBKOADBM@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAg?$AAr?$AAa?$AAm?$AAm?$AAa?$AAr?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@BBKOADBM@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAg?$AAr?$AAa?$AAm?$AAm?$AAa?$AAr?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 's', 00H
	DB	'e', 00H, 'r', 00H, '\', 00H, 'g', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, 'm', 00H, 'a', 00H, 'r', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_addarc
_TEXT	SEGMENT
a$ = 32
s$ = 40
d$ = 64
from$ = 72
to$ = 80
lbl$ = 88
_Py_addarc PROC						; COMDAT

; 71   : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 72   :     state *s;
; 73   :     arc *a;
; 74   : 
; 75   :     assert(0 <= from && from < d->d_nstates);

  00017	83 7c 24 48 00	 cmp	 DWORD PTR from$[rsp], 0
  0001c	7c 0e		 jl	 SHORT $LN4@Py_addarc
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  00023	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00026	39 44 24 48	 cmp	 DWORD PTR from$[rsp], eax
  0002a	7c 1c		 jl	 SHORT $LN5@Py_addarc
$LN4@Py_addarc:
  0002c	41 b8 4b 00 00
	00		 mov	 r8d, 75			; 0000004bH
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@BBKOADBM@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAg?$AAr?$AAa?$AAm?$AAm?$AAa?$AAr?$AA?4?$AAc?$AA?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@IAIJOMPE@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAr?$AAo?$AAm?$AA?5?$AA?$DM?$AA?5?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAn?$AAs?$AAt?$AAa?$AAt?$AAe?$AAs@
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00046	33 c0		 xor	 eax, eax
$LN5@Py_addarc:

; 76   :     assert(0 <= to && to < d->d_nstates);

  00048	83 7c 24 50 00	 cmp	 DWORD PTR to$[rsp], 0
  0004d	7c 0e		 jl	 SHORT $LN6@Py_addarc
  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  00054	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00057	39 44 24 50	 cmp	 DWORD PTR to$[rsp], eax
  0005b	7c 1c		 jl	 SHORT $LN7@Py_addarc
$LN6@Py_addarc:
  0005d	41 b8 4c 00 00
	00		 mov	 r8d, 76			; 0000004cH
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@BBKOADBM@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAg?$AAr?$AAa?$AAm?$AAm?$AAa?$AAr?$AA?4?$AAc?$AA?$AA@
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@DCNLMLOE@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAo?$AA?5?$AA?$DM?$AA?5?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAn?$AAs?$AAt?$AAa?$AAt?$AAe?$AAs?$AA?$AA@
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00077	33 c0		 xor	 eax, eax
$LN7@Py_addarc:

; 77   : 
; 78   :     s = &d->d_state[from];

  00079	48 63 44 24 48	 movsxd	 rax, DWORD PTR from$[rsp]
  0007e	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00087	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  0008b	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 79   :     s->s_arc = (arc *)PyObject_REALLOC(s->s_arc, sizeof(arc) * (s->s_narcs + 1));

  00090	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00095	8b 00		 mov	 eax, DWORD PTR [rax]
  00097	ff c0		 inc	 eax
  00099	48 98		 cdqe
  0009b	48 c1 e0 02	 shl	 rax, 2
  0009f	48 8b d0	 mov	 rdx, rax
  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000a7	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000ab	e8 00 00 00 00	 call	 _PyObject_DebugRealloc
  000b0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000b5	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 80   :     if (s->s_arc == NULL)

  000b9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000be	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000c3	75 0c		 jne	 SHORT $LN1@Py_addarc

; 81   :         Py_FatalError("no mem to resize arc list in addarc");

  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@LKHKMPMN@no?5mem?5to?5resize?5arc?5list?5in?5add@
  000cc	e8 00 00 00 00	 call	 Py_FatalError
$LN1@Py_addarc:

; 82   :     a = &s->s_arc[s->s_narcs++];

  000d1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000d6	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  000d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000de	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000e2	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000e6	48 89 44 24 20	 mov	 QWORD PTR a$[rsp], rax
  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000f0	8b 00		 mov	 eax, DWORD PTR [rax]
  000f2	ff c0		 inc	 eax
  000f4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000f9	89 01		 mov	 DWORD PTR [rcx], eax

; 83   :     a->a_lbl = lbl;

  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00100	0f b7 4c 24 58	 movzx	 ecx, WORD PTR lbl$[rsp]
  00105	66 89 08	 mov	 WORD PTR [rax], cx

; 84   :     a->a_arrow = to;

  00108	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0010d	0f b7 4c 24 50	 movzx	 ecx, WORD PTR to$[rsp]
  00112	66 89 48 02	 mov	 WORD PTR [rax+2], cx

; 85   : }

  00116	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011a	c3		 ret	 0
_Py_addarc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NJBLCGHI@Label?5?$EA?5?$CF8p?0?5?$CFd?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@EICAKID@no?5mem?5to?5resize?5labellist?5in?5ad@ ; `string'
PUBLIC	_Py_addlabel
EXTRN	__imp_printf:PROC
EXTRN	PyGrammar_LabelRepr:PROC
EXTRN	Py_DebugFlag:DWORD
EXTRN	strcmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_addlabel DD imagerel $LN9
	DD	imagerel $LN9+341
	DD	imagerel $unwind$_Py_addlabel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_addlabel DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT ??_C@_0BF@NJBLCGHI@Label?5?$EA?5?$CF8p?0?5?$CFd?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BF@NJBLCGHI@Label?5?$EA?5?$CF8p?0?5?$CFd?3?5?$CFs?6?$AA@ DB 'Label'
	DB	' @ %8p, %d: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EICAKID@no?5mem?5to?5resize?5labellist?5in?5ad@
CONST	SEGMENT
??_C@_0CH@EICAKID@no?5mem?5to?5resize?5labellist?5in?5ad@ DB 'no mem to r'
	DB	'esize labellist in addlabel', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_addlabel
_TEXT	SEGMENT
i$ = 32
lb$ = 40
ll$ = 64
type$ = 72
str$ = 80
_Py_addlabel PROC					; COMDAT

; 89   : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 90   :     int i;
; 91   :     label *lb;
; 92   : 
; 93   :     for (i = 0; i < ll->ll_nlabels; i++) {

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 0a		 jmp	 SHORT $LN6@Py_addlabe
$LN5@Py_addlabe:
  0001c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN6@Py_addlabe:
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR ll$[rsp]
  0002b	8b 00		 mov	 eax, DWORD PTR [rax]
  0002d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00031	7d 4b		 jge	 SHORT $LN4@Py_addlabe

; 94   :         if (ll->ll_label[i].lb_type == type &&
; 95   :             strcmp(ll->ll_label[i].lb_str, str) == 0)

  00033	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00038	48 6b c0 10	 imul	 rax, 16
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ll$[rsp]
  00041	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00045	8b 54 24 48	 mov	 edx, DWORD PTR type$[rsp]
  00049	39 14 08	 cmp	 DWORD PTR [rax+rcx], edx
  0004c	75 2e		 jne	 SHORT $LN3@Py_addlabe
  0004e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00053	48 6b c0 10	 imul	 rax, 16
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ll$[rsp]
  0005c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00060	48 8b 54 24 50	 mov	 rdx, QWORD PTR str$[rsp]
  00065	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  0006a	e8 00 00 00 00	 call	 strcmp
  0006f	85 c0		 test	 eax, eax
  00071	75 09		 jne	 SHORT $LN3@Py_addlabe

; 96   :             return i;

  00073	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00077	e9 d4 00 00 00	 jmp	 $LN7@Py_addlabe
$LN3@Py_addlabe:

; 97   :     }

  0007c	eb 9e		 jmp	 SHORT $LN5@Py_addlabe
$LN4@Py_addlabe:

; 98   :     ll->ll_label = (label *)PyObject_REALLOC(ll->ll_label,
; 99   :                                     sizeof(label) * (ll->ll_nlabels + 1));

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR ll$[rsp]
  00083	8b 00		 mov	 eax, DWORD PTR [rax]
  00085	ff c0		 inc	 eax
  00087	48 98		 cdqe
  00089	48 6b c0 10	 imul	 rax, 16
  0008d	48 8b d0	 mov	 rdx, rax
  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR ll$[rsp]
  00095	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00099	e8 00 00 00 00	 call	 _PyObject_DebugRealloc
  0009e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ll$[rsp]
  000a3	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 100  :     if (ll->ll_label == NULL)

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR ll$[rsp]
  000ac	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000b1	75 0c		 jne	 SHORT $LN2@Py_addlabe

; 101  :         Py_FatalError("no mem to resize labellist in addlabel");

  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@EICAKID@no?5mem?5to?5resize?5labellist?5in?5ad@
  000ba	e8 00 00 00 00	 call	 Py_FatalError
$LN2@Py_addlabe:

; 102  :     lb = &ll->ll_label[ll->ll_nlabels++];

  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR ll$[rsp]
  000c4	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  000c7	48 6b c0 10	 imul	 rax, 16
  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ll$[rsp]
  000d0	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  000d4	48 89 44 24 28	 mov	 QWORD PTR lb$[rsp], rax
  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR ll$[rsp]
  000de	8b 00		 mov	 eax, DWORD PTR [rax]
  000e0	ff c0		 inc	 eax
  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ll$[rsp]
  000e7	89 01		 mov	 DWORD PTR [rcx], eax

; 103  :     lb->lb_type = type;

  000e9	48 8b 44 24 28	 mov	 rax, QWORD PTR lb$[rsp]
  000ee	8b 4c 24 48	 mov	 ecx, DWORD PTR type$[rsp]
  000f2	89 08		 mov	 DWORD PTR [rax], ecx

; 104  :     lb->lb_str = strdup(str);

  000f4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lb$[rsp]
  00104	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 105  :     if (Py_DebugFlag)

  00108	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  0010f	74 27		 je	 SHORT $LN1@Py_addlabe

; 106  :         printf("Label @ %8p, %d: %s\n", ll, ll->ll_nlabels,
; 107  :                PyGrammar_LabelRepr(lb));

  00111	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lb$[rsp]
  00116	e8 00 00 00 00	 call	 PyGrammar_LabelRepr
  0011b	4c 8b c8	 mov	 r9, rax
  0011e	48 8b 44 24 40	 mov	 rax, QWORD PTR ll$[rsp]
  00123	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00126	48 8b 54 24 40	 mov	 rdx, QWORD PTR ll$[rsp]
  0012b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@NJBLCGHI@Label?5?$EA?5?$CF8p?0?5?$CFd?3?5?$CFs?6?$AA@
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN1@Py_addlabe:

; 108  :     return lb - ll->ll_label;

  00138	48 8b 44 24 40	 mov	 rax, QWORD PTR ll$[rsp]
  0013d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00141	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lb$[rsp]
  00146	48 2b c8	 sub	 rcx, rax
  00149	48 8b c1	 mov	 rax, rcx
  0014c	48 c1 f8 04	 sar	 rax, 4
$LN7@Py_addlabe:

; 109  : }

  00150	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00154	c3		 ret	 0
_Py_addlabel ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@CFAOJANI@grammar?4c?3findlabel?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BJ@LLAIDDKD@Label?5?$CFd?1?8?$CFs?8?5not?5found?6?$AA@ ; `string'
PUBLIC	_Py_findlabel
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_findlabel DD imagerel $LN7
	DD	imagerel $LN7+141
	DD	imagerel $unwind$_Py_findlabel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_findlabel DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT ??_C@_0BG@CFAOJANI@grammar?4c?3findlabel?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@CFAOJANI@grammar?4c?3findlabel?$CI?$CJ?$AA@ DB 'grammar.c:findl'
	DB	'abel()', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LLAIDDKD@Label?5?$CFd?1?8?$CFs?8?5not?5found?6?$AA@
CONST	SEGMENT
??_C@_0BJ@LLAIDDKD@Label?5?$CFd?1?8?$CFs?8?5not?5found?6?$AA@ DB 'Label %'
	DB	'd/''%s'' not found', 0aH, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_findlabel
_TEXT	SEGMENT
i$ = 32
ll$ = 64
type$ = 72
str$ = 80
_Py_findlabel PROC					; COMDAT

; 115  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 116  :     int i;
; 117  : 
; 118  :     for (i = 0; i < ll->ll_nlabels; i++) {

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 0a		 jmp	 SHORT $LN4@Py_findlab
$LN3@Py_findlab:
  0001c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@Py_findlab:
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR ll$[rsp]
  0002b	8b 00		 mov	 eax, DWORD PTR [rax]
  0002d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00031	7d 23		 jge	 SHORT $LN2@Py_findlab

; 119  :         if (ll->ll_label[i].lb_type == type /*&&
; 120  :             strcmp(ll->ll_label[i].lb_str, str) == 0*/)

  00033	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00038	48 6b c0 10	 imul	 rax, 16
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ll$[rsp]
  00041	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00045	8b 54 24 48	 mov	 edx, DWORD PTR type$[rsp]
  00049	39 14 08	 cmp	 DWORD PTR [rax+rcx], edx
  0004c	75 06		 jne	 SHORT $LN1@Py_findlab

; 121  :             return i;

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00052	eb 34		 jmp	 SHORT $LN5@Py_findlab
$LN1@Py_findlab:

; 122  :     }

  00054	eb c6		 jmp	 SHORT $LN3@Py_findlab
$LN2@Py_findlab:

; 123  :     fprintf(stderr, "Label %d/'%s' not found\n", type, str);

  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0005c	48 83 c0 60	 add	 rax, 96			; 00000060H
  00060	4c 8b 4c 24 50	 mov	 r9, QWORD PTR str$[rsp]
  00065	44 8b 44 24 48	 mov	 r8d, DWORD PTR type$[rsp]
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@LLAIDDKD@Label?5?$CFd?1?8?$CFs?8?5not?5found?6?$AA@
  00071	48 8b c8	 mov	 rcx, rax
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 124  :     Py_FatalError("grammar.c:findlabel()");

  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@CFAOJANI@grammar?4c?3findlabel?$CI?$CJ?$AA@
  00081	e8 00 00 00 00	 call	 Py_FatalError

; 125  :     return 0; /* Make gcc -Wall happy */

  00086	33 c0		 xor	 eax, eax
$LN5@Py_findlab:

; 126  : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
_Py_findlabel ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@FDOFKMIE@Translating?5labels?5?4?4?4?6?$AA@ ; `string'
PUBLIC	_Py_translatelabels
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_translatelabels DD imagerel $LN6
	DD	imagerel $LN6+94
	DD	imagerel $unwind$_Py_translatelabels
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_translatelabels DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BI@FDOFKMIE@Translating?5labels?5?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@FDOFKMIE@Translating?5labels?5?4?4?4?6?$AA@ DB 'Translating lab'
	DB	'els ...', 0aH, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_translatelabels
_TEXT	SEGMENT
i$ = 32
g$ = 64
_Py_translatelabels PROC				; COMDAT

; 133  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 134  :     int i;
; 135  : 
; 136  : #ifdef Py_DEBUG
; 137  :     printf("Translating labels ...\n");

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@FDOFKMIE@Translating?5labels?5?4?4?4?6?$AA@
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 138  : #endif
; 139  :     /* Don't translate EMPTY */
; 140  :     for (i = EMPTY+1; i < g->g_ll.ll_nlabels; i++)

  00016	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0001e	eb 0a		 jmp	 SHORT $LN3@Py_transla
$LN2@Py_transla:
  00020	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00024	ff c0		 inc	 eax
  00026	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN3@Py_transla:
  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  0002f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00032	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00036	7d 21		 jge	 SHORT $LN1@Py_transla

; 141  :         translabel(g, &g->g_ll.ll_label[i]);

  00038	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0003d	48 6b c0 10	 imul	 rax, 16
  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$[rsp]
  00046	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  0004a	48 8b d0	 mov	 rdx, rax
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$[rsp]
  00052	e8 00 00 00 00	 call	 translabel
  00057	eb c7		 jmp	 SHORT $LN2@Py_transla
$LN1@Py_transla:

; 142  : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
_Py_translatelabels ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@MCBIKPJI@Can?8t?5translate?5label?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@JPAKDDAN@Can?8t?5translate?5STRING?5label?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@BOLHCNHE@Unknown?5OP?5label?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@GEDIIBCK@Can?8t?5alloc?5dest?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@IJIDICON@Label?5?$CFs?5is?5a?5keyword?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@NOMEMCLM@Can?8t?5translate?5NAME?5label?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BK@BLHJLOEA@Label?5?$CFs?5is?5terminal?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@FPEDPNFN@Label?5?$CFs?5is?5non?9terminal?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMNEMALA@Translating?5label?5?$CFs?5?4?4?4?6?$AA@ ; `string'
EXTRN	PyToken_ThreeChars:PROC
EXTRN	PyToken_TwoChars:PROC
EXTRN	PyToken_OneChar:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp_malloc:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strchr:PROC
EXTRN	__imp_isalpha:PROC
EXTRN	_PyParser_TokenNames:BYTE
EXTRN	__imp_free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$translabel DD imagerel translabel
	DD	imagerel translabel+1310
	DD	imagerel $unwind$translabel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$translabel DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0BM@MCBIKPJI@Can?8t?5translate?5label?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BM@MCBIKPJI@Can?8t?5translate?5label?5?8?$CFs?8?6?$AA@ DB 'Can''t '
	DB	'translate label ''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JPAKDDAN@Can?8t?5translate?5STRING?5label?5?$CFs?6@
CONST	SEGMENT
??_C@_0CB@JPAKDDAN@Can?8t?5translate?5STRING?5label?5?$CFs?6@ DB 'Can''t '
	DB	'translate STRING label %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BOLHCNHE@Unknown?5OP?5label?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BF@BOLHCNHE@Unknown?5OP?5label?5?$CFs?6?$AA@ DB 'Unknown OP label '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GEDIIBCK@Can?8t?5alloc?5dest?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BH@GEDIIBCK@Can?8t?5alloc?5dest?5?8?$CFs?8?6?$AA@ DB 'Can''t alloc'
	DB	' dest ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IJIDICON@Label?5?$CFs?5is?5a?5keyword?6?$AA@
CONST	SEGMENT
??_C@_0BH@IJIDICON@Label?5?$CFs?5is?5a?5keyword?6?$AA@ DB 'Label %s is a '
	DB	'keyword', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NOMEMCLM@Can?8t?5translate?5NAME?5label?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0CB@NOMEMCLM@Can?8t?5translate?5NAME?5label?5?8?$CFs?8?6@ DB 'Can'''
	DB	't translate NAME label ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BLHJLOEA@Label?5?$CFs?5is?5terminal?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@BLHJLOEA@Label?5?$CFs?5is?5terminal?5?$CFd?4?6?$AA@ DB 'Label %'
	DB	's is terminal %d.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FPEDPNFN@Label?5?$CFs?5is?5non?9terminal?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@FPEDPNFN@Label?5?$CFs?5is?5non?9terminal?5?$CFd?4?6?$AA@ DB 'La'
	DB	'bel %s is non-terminal %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMNEMALA@Translating?5label?5?$CFs?5?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@BMNEMALA@Translating?5label?5?$CFs?5?4?4?4?6?$AA@ DB 'Translati'
	DB	'ng label %s ...', 0aH, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT translabel
_TEXT	SEGMENT
i$ = 32
p$20656 = 40
dest$20658 = 48
name_len$20659 = 56
src$20657 = 64
type$20669 = 72
type$20677 = 76
type$20684 = 80
tv263 = 84
g$ = 112
lb$ = 120
translabel PROC						; COMDAT

; 146  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 147  :     int i;
; 148  : 
; 149  :     if (Py_DebugFlag)

  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  00015	74 1a		 je	 SHORT $LN33@translabel

; 150  :         printf("Translating label %s ...\n", PyGrammar_LabelRepr(lb));

  00017	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lb$[rsp]
  0001c	e8 00 00 00 00	 call	 PyGrammar_LabelRepr
  00021	48 8b d0	 mov	 rdx, rax
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BMNEMALA@Translating?5label?5?$CFs?5?4?4?4?6?$AA@
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN33@translabel:

; 151  : 
; 152  :     if (lb->lb_type == NAME) {

  00031	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00036	83 38 01	 cmp	 DWORD PTR [rax], 1
  00039	0f 85 72 01 00
	00		 jne	 $LN32@translabel

; 153  :         for (i = 0; i < g->g_ndfas; i++) {

  0003f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00047	eb 0a		 jmp	 SHORT $LN31@translabel
$LN30@translabel:
  00049	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0004d	ff c0		 inc	 eax
  0004f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN31@translabel:
  00053	48 8b 44 24 70	 mov	 rax, QWORD PTR g$[rsp]
  00058	8b 00		 mov	 eax, DWORD PTR [rax]
  0005a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0005e	0f 8d a0 00 00
	00		 jge	 $LN29@translabel

; 154  :             if (strcmp(lb->lb_str, g->g_dfa[i].d_name) == 0) {

  00064	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00069	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0006d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR g$[rsp]
  00072	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00076	48 8b 54 01 08	 mov	 rdx, QWORD PTR [rcx+rax+8]
  0007b	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00080	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00084	e8 00 00 00 00	 call	 strcmp
  00089	85 c0		 test	 eax, eax
  0008b	75 72		 jne	 SHORT $LN28@translabel

; 155  :                 if (Py_DebugFlag)

  0008d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  00094	74 2c		 je	 SHORT $LN27@translabel

; 156  :                     printf(
; 157  :                         "Label %s is non-terminal %d.\n",
; 158  :                         lb->lb_str,
; 159  :                         g->g_dfa[i].d_type);

  00096	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0009b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0009f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR g$[rsp]
  000a4	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a8	44 8b 04 01	 mov	 r8d, DWORD PTR [rcx+rax]
  000ac	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  000b1	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@FPEDPNFN@Label?5?$CFs?5is?5non?9terminal?5?$CFd?4?6?$AA@
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN27@translabel:

; 160  :                 lb->lb_type = g->g_dfa[i].d_type;

  000c2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000c7	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000cb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR g$[rsp]
  000d0	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000d4	48 8b 54 24 78	 mov	 rdx, QWORD PTR lb$[rsp]
  000d9	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  000dc	89 02		 mov	 DWORD PTR [rdx], eax

; 161  :                 free(lb->lb_str);

  000de	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  000e3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 162  :                 lb->lb_str = NULL;

  000ed	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  000f2	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 163  :                 return;

  000fa	e9 1a 04 00 00	 jmp	 $LN34@translabel
$LN28@translabel:

; 164  :             }
; 165  :         }

  000ff	e9 45 ff ff ff	 jmp	 $LN30@translabel
$LN29@translabel:

; 166  :         for (i = 0; i < (int)N_TOKENS; i++) {

  00104	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0010c	eb 0a		 jmp	 SHORT $LN26@translabel
$LN25@translabel:
  0010e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00112	ff c0		 inc	 eax
  00114	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN26@translabel:
  00118	83 7c 24 20 36	 cmp	 DWORD PTR i$[rsp], 54	; 00000036H
  0011d	7d 77		 jge	 SHORT $LN24@translabel

; 167  :             if (strcmp(lb->lb_str, _PyParser_TokenNames[i]) == 0) {

  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyParser_TokenNames
  0012b	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0012f	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00134	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00138	e8 00 00 00 00	 call	 strcmp
  0013d	85 c0		 test	 eax, eax
  0013f	75 50		 jne	 SHORT $LN23@translabel

; 168  :                 if (Py_DebugFlag)

  00141	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  00148	74 1b		 je	 SHORT $LN22@translabel

; 169  :                     printf("Label %s is terminal %d.\n",
; 170  :                         lb->lb_str, i);

  0014a	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$[rsp]
  0014f	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00154	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BLHJLOEA@Label?5?$CFs?5is?5terminal?5?$CFd?4?6?$AA@
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN22@translabel:

; 171  :                 lb->lb_type = i;

  00165	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  0016a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0016e	89 08		 mov	 DWORD PTR [rax], ecx

; 172  :                 free(lb->lb_str);

  00170	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00175	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 173  :                 lb->lb_str = NULL;

  0017f	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00184	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 174  :                 return;

  0018c	e9 88 03 00 00	 jmp	 $LN34@translabel
$LN23@translabel:

; 175  :             }
; 176  :         }

  00191	e9 78 ff ff ff	 jmp	 $LN25@translabel
$LN24@translabel:

; 177  :         printf("Can't translate NAME label '%s'\n", lb->lb_str);

  00196	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  0019b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@NOMEMCLM@Can?8t?5translate?5NAME?5label?5?8?$CFs?8?6@
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 178  :         return;

  001ac	e9 68 03 00 00	 jmp	 $LN34@translabel
$LN32@translabel:

; 179  :     }
; 180  : 
; 181  :     if (lb->lb_type == STRING) {

  001b1	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  001b6	83 38 03	 cmp	 DWORD PTR [rax], 3
  001b9	0f 85 40 03 00
	00		 jne	 $LN21@translabel

; 182  :         if (isalpha(Py_CHARMASK(lb->lb_str[1])) ||
; 183  :             lb->lb_str[1] == '_') {

  001bf	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  001c4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001c8	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  001cc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001d1	0f b6 c0	 movzx	 eax, al
  001d4	8b c8		 mov	 ecx, eax
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalpha
  001dc	85 c0		 test	 eax, eax
  001de	75 16		 jne	 SHORT $LN19@translabel
  001e0	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  001e5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001e9	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  001ed	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  001f0	0f 85 fd 00 00
	00		 jne	 $LN20@translabel
$LN19@translabel:

; 184  :             char *p;
; 185  :             char *src;
; 186  :             char *dest;
; 187  :             size_t name_len;
; 188  :             if (Py_DebugFlag)

  001f6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  001fd	74 16		 je	 SHORT $LN18@translabel

; 189  :                 printf("Label %s is a keyword\n", lb->lb_str);

  001ff	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00204	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@IJIDICON@Label?5?$CFs?5is?5a?5keyword?6?$AA@
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN18@translabel:

; 190  :             lb->lb_type = NAME;

  00215	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  0021a	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 191  :             src = lb->lb_str + 1;

  00220	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00225	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00229	48 ff c0	 inc	 rax
  0022c	48 89 44 24 40	 mov	 QWORD PTR src$20657[rsp], rax

; 192  :             p = strchr(src, '\'');

  00231	ba 27 00 00 00	 mov	 edx, 39			; 00000027H
  00236	48 8b 4c 24 40	 mov	 rcx, QWORD PTR src$20657[rsp]
  0023b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00241	48 89 44 24 28	 mov	 QWORD PTR p$20656[rsp], rax

; 193  :             if (p)

  00246	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$20656[rsp], 0
  0024c	74 17		 je	 SHORT $LN17@translabel

; 194  :                 name_len = p - src;

  0024e	48 8b 44 24 40	 mov	 rax, QWORD PTR src$20657[rsp]
  00253	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$20656[rsp]
  00258	48 2b c8	 sub	 rcx, rax
  0025b	48 8b c1	 mov	 rax, rcx
  0025e	48 89 44 24 38	 mov	 QWORD PTR name_len$20659[rsp], rax

; 195  :             else

  00263	eb 0f		 jmp	 SHORT $LN16@translabel
$LN17@translabel:

; 196  :                 name_len = strlen(src);

  00265	48 8b 4c 24 40	 mov	 rcx, QWORD PTR src$20657[rsp]
  0026a	e8 00 00 00 00	 call	 strlen
  0026f	48 89 44 24 38	 mov	 QWORD PTR name_len$20659[rsp], rax
$LN16@translabel:

; 197  :             dest = (char *)malloc(name_len + 1);

  00274	48 8b 44 24 38	 mov	 rax, QWORD PTR name_len$20659[rsp]
  00279	48 ff c0	 inc	 rax
  0027c	48 8b c8	 mov	 rcx, rax
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00285	48 89 44 24 30	 mov	 QWORD PTR dest$20658[rsp], rax

; 198  :             if (!dest) {

  0028a	48 83 7c 24 30
	00		 cmp	 QWORD PTR dest$20658[rsp], 0
  00290	75 17		 jne	 SHORT $LN15@translabel

; 199  :                 printf("Can't alloc dest '%s'\n", src);

  00292	48 8b 54 24 40	 mov	 rdx, QWORD PTR src$20657[rsp]
  00297	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@GEDIIBCK@Can?8t?5alloc?5dest?5?8?$CFs?8?6?$AA@
  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 200  :                 return;

  002a4	e9 70 02 00 00	 jmp	 $LN34@translabel
$LN15@translabel:

; 201  :             }
; 202  :             strncpy(dest, src, name_len);

  002a9	4c 8b 44 24 38	 mov	 r8, QWORD PTR name_len$20659[rsp]
  002ae	48 8b 54 24 40	 mov	 rdx, QWORD PTR src$20657[rsp]
  002b3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dest$20658[rsp]
  002b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 203  :             dest[name_len] = '\0';

  002be	48 8b 44 24 38	 mov	 rax, QWORD PTR name_len$20659[rsp]
  002c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dest$20658[rsp]
  002c8	48 03 c8	 add	 rcx, rax
  002cb	48 8b c1	 mov	 rax, rcx
  002ce	c6 00 00	 mov	 BYTE PTR [rax], 0

; 204  :             free(lb->lb_str);

  002d1	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  002d6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 205  :             lb->lb_str = dest;

  002e0	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  002e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dest$20658[rsp]
  002ea	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  002ee	e9 0a 02 00 00	 jmp	 $LN14@translabel
$LN20@translabel:

; 206  :         }
; 207  :         else if (lb->lb_str[2] == lb->lb_str[0]) {

  002f3	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  002f8	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002fc	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  00300	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lb$[rsp]
  00305	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00309	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  0030c	3b c1		 cmp	 eax, ecx
  0030e	75 63		 jne	 SHORT $LN13@translabel

; 208  :             int type = (int) PyToken_OneChar(lb->lb_str[1]);

  00310	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00315	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00319	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0031d	8b c8		 mov	 ecx, eax
  0031f	e8 00 00 00 00	 call	 PyToken_OneChar
  00324	89 44 24 48	 mov	 DWORD PTR type$20669[rsp], eax

; 209  :             if (type != OP) {

  00328	83 7c 24 48 34	 cmp	 DWORD PTR type$20669[rsp], 52 ; 00000034H
  0032d	74 29		 je	 SHORT $LN12@translabel

; 210  :                 lb->lb_type = type;

  0032f	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00334	8b 4c 24 48	 mov	 ecx, DWORD PTR type$20669[rsp]
  00338	89 08		 mov	 DWORD PTR [rax], ecx

; 211  :                 free(lb->lb_str);

  0033a	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  0033f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00343	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 212  :                 lb->lb_str = NULL;

  00349	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  0034e	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 213  :             }
; 214  :             else

  00356	eb 16		 jmp	 SHORT $LN11@translabel
$LN12@translabel:

; 215  :                 printf("Unknown OP label %s\n",
; 216  :                     lb->lb_str);

  00358	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  0035d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00361	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@BOLHCNHE@Unknown?5OP?5label?5?$CFs?6?$AA@
  00368	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN11@translabel:

; 217  :         }
; 218  :         else if (lb->lb_str[2] && lb->lb_str[3] == lb->lb_str[0]) {

  0036e	e9 8a 01 00 00	 jmp	 $LN10@translabel
$LN13@translabel:
  00373	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00378	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0037c	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  00380	85 c0		 test	 eax, eax
  00382	0f 84 8d 00 00
	00		 je	 $LN9@translabel
  00388	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  0038d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00391	0f be 40 03	 movsx	 eax, BYTE PTR [rax+3]
  00395	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lb$[rsp]
  0039a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0039e	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  003a1	3b c1		 cmp	 eax, ecx
  003a3	75 70		 jne	 SHORT $LN9@translabel

; 219  :             int type = (int) PyToken_TwoChars(lb->lb_str[1],
; 220  :                                        lb->lb_str[2]);

  003a5	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  003aa	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003ae	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  003b2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lb$[rsp]
  003b7	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  003bb	0f be 49 01	 movsx	 ecx, BYTE PTR [rcx+1]
  003bf	8b d0		 mov	 edx, eax
  003c1	e8 00 00 00 00	 call	 PyToken_TwoChars
  003c6	89 44 24 4c	 mov	 DWORD PTR type$20677[rsp], eax

; 221  :             if (type != OP) {

  003ca	83 7c 24 4c 34	 cmp	 DWORD PTR type$20677[rsp], 52 ; 00000034H
  003cf	74 29		 je	 SHORT $LN8@translabel

; 222  :                 lb->lb_type = type;

  003d1	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  003d6	8b 4c 24 4c	 mov	 ecx, DWORD PTR type$20677[rsp]
  003da	89 08		 mov	 DWORD PTR [rax], ecx

; 223  :                 free(lb->lb_str);

  003dc	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  003e1	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  003e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 224  :                 lb->lb_str = NULL;

  003eb	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  003f0	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 225  :             }
; 226  :             else

  003f8	eb 16		 jmp	 SHORT $LN7@translabel
$LN8@translabel:

; 227  :                 printf("Unknown OP label %s\n",
; 228  :                     lb->lb_str);

  003fa	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  003ff	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00403	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@BOLHCNHE@Unknown?5OP?5label?5?$CFs?6?$AA@
  0040a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN7@translabel:

; 229  :         }
; 230  :         else if (lb->lb_str[2] && lb->lb_str[3] && lb->lb_str[4] == lb->lb_str[0]) {

  00410	e9 e8 00 00 00	 jmp	 $LN6@translabel
$LN9@translabel:
  00415	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  0041a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0041e	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  00422	85 c0		 test	 eax, eax
  00424	0f 84 bd 00 00
	00		 je	 $LN5@translabel
  0042a	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  0042f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00433	0f be 40 03	 movsx	 eax, BYTE PTR [rax+3]
  00437	85 c0		 test	 eax, eax
  00439	0f 84 a8 00 00
	00		 je	 $LN5@translabel
  0043f	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00444	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00448	0f be 40 04	 movsx	 eax, BYTE PTR [rax+4]
  0044c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lb$[rsp]
  00451	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00455	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00458	3b c1		 cmp	 eax, ecx
  0045a	0f 85 87 00 00
	00		 jne	 $LN5@translabel

; 231  :             int type = (int) PyToken_ThreeChars(lb->lb_str[1],
; 232  :                                                 lb->lb_str[2],
; 233  :                                                 lb->lb_str[3]);

  00460	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  00465	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00469	0f be 40 03	 movsx	 eax, BYTE PTR [rax+3]
  0046d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lb$[rsp]
  00472	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00476	0f be 49 02	 movsx	 ecx, BYTE PTR [rcx+2]
  0047a	48 8b 54 24 78	 mov	 rdx, QWORD PTR lb$[rsp]
  0047f	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00483	0f be 52 01	 movsx	 edx, BYTE PTR [rdx+1]
  00487	89 54 24 54	 mov	 DWORD PTR tv263[rsp], edx
  0048b	44 8b c0	 mov	 r8d, eax
  0048e	8b d1		 mov	 edx, ecx
  00490	8b 44 24 54	 mov	 eax, DWORD PTR tv263[rsp]
  00494	8b c8		 mov	 ecx, eax
  00496	e8 00 00 00 00	 call	 PyToken_ThreeChars
  0049b	89 44 24 50	 mov	 DWORD PTR type$20684[rsp], eax

; 234  :             if (type != OP) {

  0049f	83 7c 24 50 34	 cmp	 DWORD PTR type$20684[rsp], 52 ; 00000034H
  004a4	74 29		 je	 SHORT $LN4@translabel

; 235  :                 lb->lb_type = type;

  004a6	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  004ab	8b 4c 24 50	 mov	 ecx, DWORD PTR type$20684[rsp]
  004af	89 08		 mov	 DWORD PTR [rax], ecx

; 236  :                 free(lb->lb_str);

  004b1	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  004b6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  004ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 237  :                 lb->lb_str = NULL;

  004c0	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  004c5	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 238  :             }
; 239  :             else

  004cd	eb 16		 jmp	 SHORT $LN3@translabel
$LN4@translabel:

; 240  :                 printf("Unknown OP label %s\n",
; 241  :                     lb->lb_str);

  004cf	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  004d4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  004d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@BOLHCNHE@Unknown?5OP?5label?5?$CFs?6?$AA@
  004df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN3@translabel:

; 242  :         }
; 243  :         else

  004e5	eb 16		 jmp	 SHORT $LN2@translabel
$LN5@translabel:

; 244  :             printf("Can't translate STRING label %s\n",
; 245  :                 lb->lb_str);

  004e7	48 8b 44 24 78	 mov	 rax, QWORD PTR lb$[rsp]
  004ec	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  004f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@JPAKDDAN@Can?8t?5translate?5STRING?5label?5?$CFs?6@
  004f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN2@translabel:
$LN6@translabel:
$LN10@translabel:
$LN14@translabel:

; 246  :     }
; 247  :     else

  004fd	eb 1a		 jmp	 SHORT $LN1@translabel
$LN21@translabel:

; 248  :         printf("Can't translate label '%s'\n",
; 249  :                PyGrammar_LabelRepr(lb));

  004ff	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lb$[rsp]
  00504	e8 00 00 00 00	 call	 PyGrammar_LabelRepr
  00509	48 8b d0	 mov	 rdx, rax
  0050c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@MCBIKPJI@Can?8t?5translate?5label?5?8?$CFs?8?6?$AA@
  00513	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN1@translabel:
$LN34@translabel:

; 250  : }

  00519	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0051d	c3		 ret	 0
translabel ENDP
_TEXT	ENDS
END
