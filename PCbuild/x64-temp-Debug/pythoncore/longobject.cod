; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@EJLIILFJ@sys?4int_info?$AA@		; `string'
PUBLIC	??_C@_0DG@LNJMIEPA@size?5in?5bytes?5of?5the?5C?5type?5used@ ; `string'
PUBLIC	??_C@_0N@IECNJPGN@sizeof_digit?$AA@		; `string'
PUBLIC	??_C@_0BI@LACMDNDE@size?5of?5a?5digit?5in?5bits?$AA@ ; `string'
PUBLIC	??_C@_0P@FEHGIBKA@bits_per_digit?$AA@		; `string'
PUBLIC	??_C@_03JBIPMCLC@int?$AA@			; `string'
PUBLIC	??_C@_0DF@LGNICKCI@the?5denominator?5of?5a?5rational?5nu@ ; `string'
PUBLIC	??_C@_0M@LLLKACAC@denominator?$AA@		; `string'
PUBLIC	??_C@_0DD@BMEDFGDO@the?5numerator?5of?5a?5rational?5numb@ ; `string'
PUBLIC	??_C@_09KDGIKBGN@numerator?$AA@			; `string'
PUBLIC	??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@ ; `string'
PUBLIC	??_C@_04HBKGOHH@imag?$AA@			; `string'
PUBLIC	??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@ ; `string'
PUBLIC	??_C@_04DGGKDJMA@real?$AA@			; `string'
PUBLIC	??_C@_0CB@JHJAIPOI@Returns?5size?5in?5memory?0?5in?5bytes@ ; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0P@BCBHENLA@__getnewargs__?$AA@		; `string'
PUBLIC	??_C@_0GA@KJCBPGNO@Rounding?5an?5Integral?5returns?5its@ ; `string'
PUBLIC	??_C@_09PJGAHDBG@__round__?$AA@			; `string'
PUBLIC	??_C@_0CH@CCENPBPG@Ceiling?5of?5an?5Integral?5returns?5i@ ; `string'
PUBLIC	??_C@_08GFGNDJJM@__ceil__?$AA@			; `string'
PUBLIC	??_C@_0CF@ODDNPKME@Flooring?5an?5Integral?5returns?5its@ ; `string'
PUBLIC	??_C@_09NKCGFGFE@__floor__?$AA@			; `string'
PUBLIC	??_C@_0CH@PIJCOPCL@Truncating?5an?5Integral?5returns?5i@ ; `string'
PUBLIC	??_C@_09KENBLPCG@__trunc__?$AA@			; `string'
PUBLIC	??_C@_0L@NMKBBNFG@from_bytes?$AA@		; `string'
PUBLIC	??_C@_08HHECGKBL@to_bytes?$AA@			; `string'
PUBLIC	??_C@_0L@PKHLKCCO@bit_length?$AA@		; `string'
PUBLIC	??_C@_0DA@INOKAKKF@Returns?5self?0?5the?5complex?5conjug@ ; `string'
PUBLIC	??_C@_09PHMNDPIK@conjugate?$AA@			; `string'
PUBLIC	??_C@_05FBJAGGIG@bytes?$AA@			; `string'
PUBLIC	??_C@_06CPIODIKA@signed?$AA@			; `string'
PUBLIC	??_C@_09PJBCLGKJ@byteorder?$AA@			; `string'
PUBLIC	??_C@_06IJDLPEM@length?$AA@			; `string'
PUBLIC	??_C@_04BHIIPFEC@base?$AA@			; `string'
PUBLIC	??_C@_01FJMABOPO@x?$AA@				; `string'
PUBLIC	_PyLong_DigitValue
PUBLIC	PyLong_Type
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
_BSS	SEGMENT
?log_base_BASE@?6??PyLong_FromString@@9@9 DQ 025H DUP (?) ; `PyLong_FromString'::`7'::log_base_BASE
?convwidth_base@?6??PyLong_FromString@@9@9 DD 025H DUP (?) ; `PyLong_FromString'::`7'::convwidth_base
	ALIGN	8

?convmultmax_base@?6??PyLong_FromString@@9@9 DQ 025H DUP (?) ; `PyLong_FromString'::`7'::convmultmax_base
_BSS	ENDS
;	COMDAT ??_C@_0N@EJLIILFJ@sys?4int_info?$AA@
CONST	SEGMENT
??_C@_0N@EJLIILFJ@sys?4int_info?$AA@ DB 'sys.int_info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@LNJMIEPA@size?5in?5bytes?5of?5the?5C?5type?5used@
CONST	SEGMENT
??_C@_0DG@LNJMIEPA@size?5in?5bytes?5of?5the?5C?5type?5used@ DB 'size in b'
	DB	'ytes of the C type used to represent a digit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IECNJPGN@sizeof_digit?$AA@
CONST	SEGMENT
??_C@_0N@IECNJPGN@sizeof_digit?$AA@ DB 'sizeof_digit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LACMDNDE@size?5of?5a?5digit?5in?5bits?$AA@
CONST	SEGMENT
??_C@_0BI@LACMDNDE@size?5of?5a?5digit?5in?5bits?$AA@ DB 'size of a digit '
	DB	'in bits', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FEHGIBKA@bits_per_digit?$AA@
CONST	SEGMENT
??_C@_0P@FEHGIBKA@bits_per_digit?$AA@ DB 'bits_per_digit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBIPMCLC@int?$AA@
CONST	SEGMENT
??_C@_03JBIPMCLC@int?$AA@ DB 'int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LGNICKCI@the?5denominator?5of?5a?5rational?5nu@
CONST	SEGMENT
??_C@_0DF@LGNICKCI@the?5denominator?5of?5a?5rational?5nu@ DB 'the denomin'
	DB	'ator of a rational number in lowest terms', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LLLKACAC@denominator?$AA@
CONST	SEGMENT
??_C@_0M@LLLKACAC@denominator?$AA@ DB 'denominator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BMEDFGDO@the?5numerator?5of?5a?5rational?5numb@
CONST	SEGMENT
??_C@_0DD@BMEDFGDO@the?5numerator?5of?5a?5rational?5numb@ DB 'the numerat'
	DB	'or of a rational number in lowest terms', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KDGIKBGN@numerator?$AA@
CONST	SEGMENT
??_C@_09KDGIKBGN@numerator?$AA@ DB 'numerator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@
CONST	SEGMENT
??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@ DB 'the imagin'
	DB	'ary part of a complex number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HBKGOHH@imag?$AA@
CONST	SEGMENT
??_C@_04HBKGOHH@imag?$AA@ DB 'imag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@
CONST	SEGMENT
??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@ DB 'the real pa'
	DB	'rt of a complex number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DGGKDJMA@real?$AA@
CONST	SEGMENT
??_C@_04DGGKDJMA@real?$AA@ DB 'real', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JHJAIPOI@Returns?5size?5in?5memory?0?5in?5bytes@
CONST	SEGMENT
??_C@_0CB@JHJAIPOI@Returns?5size?5in?5memory?0?5in?5bytes@ DB 'Returns si'
	DB	'ze in memory, in bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BCBHENLA@__getnewargs__?$AA@
CONST	SEGMENT
??_C@_0P@BCBHENLA@__getnewargs__?$AA@ DB '__getnewargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@KJCBPGNO@Rounding?5an?5Integral?5returns?5its@
CONST	SEGMENT
??_C@_0GA@KJCBPGNO@Rounding?5an?5Integral?5returns?5its@ DB 'Rounding an '
	DB	'Integral returns itself.', 0aH, 'Rounding with an ndigits arg'
	DB	'ument also returns an integer.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJGAHDBG@__round__?$AA@
CONST	SEGMENT
??_C@_09PJGAHDBG@__round__?$AA@ DB '__round__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CCENPBPG@Ceiling?5of?5an?5Integral?5returns?5i@
CONST	SEGMENT
??_C@_0CH@CCENPBPG@Ceiling?5of?5an?5Integral?5returns?5i@ DB 'Ceiling of '
	DB	'an Integral returns itself.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GFGNDJJM@__ceil__?$AA@
CONST	SEGMENT
??_C@_08GFGNDJJM@__ceil__?$AA@ DB '__ceil__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@ODDNPKME@Flooring?5an?5Integral?5returns?5its@
CONST	SEGMENT
??_C@_0CF@ODDNPKME@Flooring?5an?5Integral?5returns?5its@ DB 'Flooring an '
	DB	'Integral returns itself.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NKCGFGFE@__floor__?$AA@
CONST	SEGMENT
??_C@_09NKCGFGFE@__floor__?$AA@ DB '__floor__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PIJCOPCL@Truncating?5an?5Integral?5returns?5i@
CONST	SEGMENT
??_C@_0CH@PIJCOPCL@Truncating?5an?5Integral?5returns?5i@ DB 'Truncating a'
	DB	'n Integral returns itself.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KENBLPCG@__trunc__?$AA@
CONST	SEGMENT
??_C@_09KENBLPCG@__trunc__?$AA@ DB '__trunc__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMKBBNFG@from_bytes?$AA@
CONST	SEGMENT
??_C@_0L@NMKBBNFG@from_bytes?$AA@ DB 'from_bytes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HHECGKBL@to_bytes?$AA@
CONST	SEGMENT
??_C@_08HHECGKBL@to_bytes?$AA@ DB 'to_bytes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PKHLKCCO@bit_length?$AA@
CONST	SEGMENT
??_C@_0L@PKHLKCCO@bit_length?$AA@ DB 'bit_length', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@INOKAKKF@Returns?5self?0?5the?5complex?5conjug@
CONST	SEGMENT
??_C@_0DA@INOKAKKF@Returns?5self?0?5the?5complex?5conjug@ DB 'Returns sel'
	DB	'f, the complex conjugate of any int.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PHMNDPIK@conjugate?$AA@
CONST	SEGMENT
??_C@_09PHMNDPIK@conjugate?$AA@ DB 'conjugate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FBJAGGIG@bytes?$AA@
CONST	SEGMENT
??_C@_05FBJAGGIG@bytes?$AA@ DB 'bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CPIODIKA@signed?$AA@
CONST	SEGMENT
??_C@_06CPIODIKA@signed?$AA@ DB 'signed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJBCLGKJ@byteorder?$AA@
CONST	SEGMENT
??_C@_09PJBCLGKJ@byteorder?$AA@ DB 'byteorder', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJDLPEM@length?$AA@
CONST	SEGMENT
??_C@_06IJDLPEM@length?$AA@ DB 'length', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base?$AA@
CONST	SEGMENT
??_C@_04BHIIPFEC@base?$AA@ DB 'base', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01FJMABOPO@x?$AA@
CONST	SEGMENT
??_C@_01FJMABOPO@x?$AA@ DB 'x', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_PyLong_DigitValue DB 025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
?kwlist@?1??long_new@@9@9 DQ FLAT:??_C@_01FJMABOPO@x?$AA@ ; `long_new'::`2'::kwlist
	DQ	FLAT:??_C@_04BHIIPFEC@base?$AA@
	DQ	0000000000000000H
	ORG $+8
long_bit_length_doc DB 'int.bit_length() -> int', 0aH, 0aH, 'Number of bi'
	DB	'ts necessary to represent self in binary.', 0aH, '>>> bin(37)'
	DB	0aH, '''0b100101''', 0aH, '>>> (37).bit_length()', 0aH, '6', 00H
	ORG $+2
?kwlist@?1??long_to_bytes@@9@9 DQ FLAT:??_C@_06IJDLPEM@length?$AA@ ; `long_to_bytes'::`2'::kwlist
	DQ	FLAT:??_C@_09PJBCLGKJ@byteorder?$AA@
	DQ	FLAT:??_C@_06CPIODIKA@signed?$AA@
	DQ	0000000000000000H
long_to_bytes_doc DB 'int.to_bytes(length, byteorder, *, signed=False) ->'
	DB	' bytes', 0aH, 0aH, 'Return an array of bytes representing an '
	DB	'integer.', 0aH, 0aH, 'The integer is represented using length'
	DB	' bytes.  An OverflowError is', 0aH, 'raised if the integer is'
	DB	' not representable with the given number of', 0aH, 'bytes.', 0aH
	DB	0aH, 'The byteorder argument determines the byte order used to'
	DB	' represent the', 0aH, 'integer.  If byteorder is ''big'', the'
	DB	' most significant byte is at the', 0aH, 'beginning of the byt'
	DB	'e array.  If byteorder is ''little'', the most', 0aH, 'signif'
	DB	'icant byte is at the end of the byte array.  To request the n'
	DB	'ative', 0aH, 'byte order of the host system, use `sys.byteord'
	DB	'er'' as the byte order value.', 0aH, 0aH, 'The signed keyword'
	DB	'-only argument determines whether two''s complement is', 0aH, 'u'
	DB	'sed to represent the integer.  If signed is False and a negat'
	DB	'ive integer', 0aH, 'is given, an OverflowError is raised.', 00H
	ORG $+7
?kwlist@?1??long_from_bytes@@9@9 DQ FLAT:??_C@_05FBJAGGIG@bytes?$AA@ ; `long_from_bytes'::`2'::kwlist
	DQ	FLAT:??_C@_09PJBCLGKJ@byteorder?$AA@
	DQ	FLAT:??_C@_06CPIODIKA@signed?$AA@
	DQ	0000000000000000H
long_from_bytes_doc DB 'int.from_bytes(bytes, byteorder, *, signed=False)'
	DB	' -> int', 0aH, 0aH, 'Return the integer represented by the gi'
	DB	'ven array of bytes.', 0aH, 0aH, 'The bytes argument must eith'
	DB	'er support the buffer protocol or be an', 0aH, 'iterable obje'
	DB	'ct producing bytes.  Bytes and bytearray are examples of', 0aH
	DB	'built-in objects that support the buffer protocol.', 0aH, 0aH
	DB	'The byteorder argument determines the byte order used to repr'
	DB	'esent the', 0aH, 'integer.  If byteorder is ''big'', the most'
	DB	' significant byte is at the', 0aH, 'beginning of the byte arr'
	DB	'ay.  If byteorder is ''little'', the most', 0aH, 'significant'
	DB	' byte is at the end of the byte array.  To request the native'
	DB	0aH, 'byte order of the host system, use `sys.byteorder'' as t'
	DB	'he byte order value.', 0aH, 0aH, 'The signed keyword-only arg'
	DB	'ument indicates whether two''s complement is', 0aH, 'used to '
	DB	'represent the integer.', 00H
	ORG $+2
long_methods DQ	FLAT:??_C@_09PHMNDPIK@conjugate?$AA@
	DQ	FLAT:long_long
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DA@INOKAKKF@Returns?5self?0?5the?5complex?5conjug@
	DQ	FLAT:??_C@_0L@PKHLKCCO@bit_length?$AA@
	DQ	FLAT:long_bit_length
	DD	04H
	ORG $+4
	DQ	FLAT:long_bit_length_doc
	DQ	FLAT:??_C@_08HHECGKBL@to_bytes?$AA@
	DQ	FLAT:long_to_bytes
	DD	03H
	ORG $+4
	DQ	FLAT:long_to_bytes_doc
	DQ	FLAT:??_C@_0L@NMKBBNFG@from_bytes?$AA@
	DQ	FLAT:long_from_bytes
	DD	013H
	ORG $+4
	DQ	FLAT:long_from_bytes_doc
	DQ	FLAT:??_C@_09KENBLPCG@__trunc__?$AA@
	DQ	FLAT:long_long
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CH@PIJCOPCL@Truncating?5an?5Integral?5returns?5i@
	DQ	FLAT:??_C@_09NKCGFGFE@__floor__?$AA@
	DQ	FLAT:long_long
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CF@ODDNPKME@Flooring?5an?5Integral?5returns?5its@
	DQ	FLAT:??_C@_08GFGNDJJM@__ceil__?$AA@
	DQ	FLAT:long_long
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CH@CCENPBPG@Ceiling?5of?5an?5Integral?5returns?5i@
	DQ	FLAT:??_C@_09PJGAHDBG@__round__?$AA@
	DQ	FLAT:long_round
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0GA@KJCBPGNO@Rounding?5an?5Integral?5returns?5its@
	DQ	FLAT:??_C@_0P@BCBHENLA@__getnewargs__?$AA@
	DQ	FLAT:long_getnewargs
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:long__format__
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:long_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@JHJAIPOI@Returns?5size?5in?5memory?0?5in?5bytes@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
long_getset DQ	FLAT:??_C@_04DGGKDJMA@real?$AA@
	DQ	FLAT:long_long
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_04HBKGOHH@imag?$AA@
	DQ	FLAT:long_get0
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_09KDGIKBGN@numerator?$AA@
	DQ	FLAT:long_long
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0DD@BMEDFGDO@the?5numerator?5of?5a?5rational?5numb@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0M@LLLKACAC@denominator?$AA@
	DQ	FLAT:long_get1
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0DF@LGNICKCI@the?5denominator?5of?5a?5rational?5nu@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
long_doc DB	'int(x=0) -> integer', 0aH, 'int(x, base=10) -> integer', 0aH
	DB	0aH, 'Convert a number or string to an integer, or return 0 if'
	DB	' no arguments', 0aH, 'are given.  If x is a number, return x.'
	DB	'__int__().  For floating point', 0aH, 'numbers, this truncate'
	DB	's towards zero.', 0aH, 0aH, 'If x is not a number or if base '
	DB	'is given, then x must be a string,', 0aH, 'bytes, or bytearra'
	DB	'y instance representing an integer literal in the', 0aH, 'giv'
	DB	'en base.  The literal can be preceded by ''+'' or ''-'' and b'
	DB	'e surrounded', 0aH, 'by whitespace.  The base defaults to 10.'
	DB	'  Valid bases are 0 and 2-36.', 0aH, 'Base 0 means to interpr'
	DB	'et the base from the string as an integer literal.', 0aH, '>>'
	DB	'> int(''0b100'', base=0)', 0aH, '4', 00H
	ORG $+2
long_as_number DQ FLAT:long_add
	DQ	FLAT:long_sub
	DQ	FLAT:long_mul
	DQ	FLAT:long_mod
	DQ	FLAT:long_divmod
	DQ	FLAT:long_pow
	DQ	FLAT:long_neg
	DQ	FLAT:long_long
	DQ	FLAT:long_abs
	DQ	FLAT:long_bool
	DQ	FLAT:long_invert
	DQ	FLAT:long_lshift
	DQ	FLAT:long_rshift
	DQ	FLAT:long_and
	DQ	FLAT:long_xor
	DQ	FLAT:long_or
	DQ	FLAT:long_long
	DQ	0000000000000000H
	DQ	FLAT:long_float
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_div
	DQ	FLAT:long_true_divide
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_long
PyLong_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_03JBIPMCLC@int?$AA@
	DQ	0000000000000070H
	DQ	0000000000000004H
	DQ	FLAT:long_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_to_decimal_string
	DQ	FLAT:long_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_hash
	DQ	0000000000000000H
	DQ	FLAT:long_to_decimal_string
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	01040400H
	ORG $+4
	DQ	FLAT:long_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_methods
	DQ	0000000000000000H
	DQ	FLAT:long_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_new
	DQ	FLAT:_PyObject_DebugFree
	ORG $+64
int_info__doc__ DB 'sys.int_info', 0aH, 0aH, 'A struct sequence that hold'
	DB	's information about Python''s', 0aH, 'internal representation'
	DB	' of integers.  The attributes are read only.', 00H
	ORG $+6
int_info_fields DQ FLAT:??_C@_0P@FEHGIBKA@bits_per_digit?$AA@
	DQ	FLAT:??_C@_0BI@LACMDNDE@size?5of?5a?5digit?5in?5bits?$AA@
	DQ	FLAT:??_C@_0N@IECNJPGN@sizeof_digit?$AA@
	DQ	FLAT:??_C@_0DG@LNJMIEPA@size?5in?5bytes?5of?5the?5C?5type?5used@
	DQ	0000000000000000H
	DQ	0000000000000000H
int_info_desc DQ FLAT:??_C@_0N@EJLIILFJ@sys?4int_info?$AA@
	DQ	FLAT:int_info__doc__
	DQ	FLAT:int_info_fields
	DD	02H
	ORG $+4
_DATA	ENDS
CONST	SEGMENT
BitLengthTable DB 00H
	DB	01H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
?half_even_correction@?1??_PyLong_Frexp@@9@9 DD 00H	; `_PyLong_Frexp'::`2'::half_even_correction
	DD	0ffffffffH
	DD	0fffffffeH
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	02H
	DD	01H
CONST	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0CH@FBOPHEGH@__int__?5returned?5non?9int?5?$CItype?5?$CF@ ; `string'
PUBLIC	??_C@_0CJ@CAOECIFE@an?5integer?5is?5required?5?$CIgot?5type@ ; `string'
PUBLIC	_Py_IncRef
PUBLIC	_PyLong_FromNbInt
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\objects\longobject.c
pdata	SEGMENT
$pdata$_PyLong_FromNbInt DD imagerel $LN9
	DD	imagerel $LN9+264
	DD	imagerel $unwind$_PyLong_FromNbInt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_FromNbInt DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CH@FBOPHEGH@__int__?5returned?5non?9int?5?$CItype?5?$CF@
CONST	SEGMENT
??_C@_0CH@FBOPHEGH@__int__?5returned?5non?9int?5?$CItype?5?$CF@ DB '__int'
	DB	'__ returned non-int (type %.200s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CAOECIFE@an?5integer?5is?5required?5?$CIgot?5type@
CONST	SEGMENT
??_C@_0CJ@CAOECIFE@an?5integer?5is?5required?5?$CIgot?5type@ DB 'an integ'
	DB	'er is required (got type %.200s)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_FromNbInt
_TEXT	SEGMENT
result$ = 32
nb$ = 40
integral$ = 64
_PyLong_FromNbInt PROC					; COMDAT

; 126  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 127  :     PyNumberMethods *nb;
; 128  :     PyObject *result;
; 129  : 
; 130  :     /* Fast path for the case that we already have an int. */
; 131  :     if (PyLong_CheckExact(integral)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR integral$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	75 14		 jne	 SHORT $LN6@PyLong_Fro

; 132  :         Py_INCREF(integral);

  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR integral$[rsp]
  00020	e8 00 00 00 00	 call	 _Py_IncRef

; 133  :         return (PyLongObject *)integral;

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR integral$[rsp]
  0002a	e9 d4 00 00 00	 jmp	 $LN7@PyLong_Fro
$LN6@PyLong_Fro:

; 134  :     }
; 135  : 
; 136  :     nb = Py_TYPE(integral)->tp_as_number;

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR integral$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0003f	48 89 44 24 28	 mov	 QWORD PTR nb$[rsp], rax

; 137  :     if (nb == NULL || nb->nb_int == NULL) {

  00044	48 83 7c 24 28
	00		 cmp	 QWORD PTR nb$[rsp], 0
  0004a	74 0f		 je	 SHORT $LN4@PyLong_Fro
  0004c	48 8b 44 24 28	 mov	 rax, QWORD PTR nb$[rsp]
  00051	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00059	75 27		 jne	 SHORT $LN5@PyLong_Fro
$LN4@PyLong_Fro:

; 138  :         PyErr_Format(PyExc_TypeError,
; 139  :                      "an integer is required (got type %.200s)",
; 140  :                      Py_TYPE(integral)->tp_name);

  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR integral$[rsp]
  00060	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00064	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@CAOECIFE@an?5integer?5is?5required?5?$CIgot?5type@
  0006f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00076	e8 00 00 00 00	 call	 PyErr_Format

; 141  :         return NULL;

  0007b	33 c0		 xor	 eax, eax
  0007d	e9 81 00 00 00	 jmp	 $LN7@PyLong_Fro
$LN5@PyLong_Fro:

; 142  :     }
; 143  : 
; 144  :     /* Convert using the nb_int slot, which should return something
; 145  :        of exact type int. */
; 146  :     result = nb->nb_int(integral);

  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR integral$[rsp]
  00087	48 8b 44 24 28	 mov	 rax, QWORD PTR nb$[rsp]
  0008c	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00092	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 147  :     if (!result || PyLong_CheckExact(result))

  00097	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  0009d	74 12		 je	 SHORT $LN2@PyLong_Fro
  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  000a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  000ab	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000af	75 07		 jne	 SHORT $LN3@PyLong_Fro
$LN2@PyLong_Fro:

; 148  :         return (PyLongObject *)result;

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000b6	eb 4b		 jmp	 SHORT $LN7@PyLong_Fro
$LN3@PyLong_Fro:

; 149  :     if (!PyLong_Check(result)) {

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000bd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000c1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000c7	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000cc	85 c0		 test	 eax, eax
  000ce	75 2e		 jne	 SHORT $LN1@PyLong_Fro

; 150  :         PyErr_Format(PyExc_TypeError,
; 151  :                      "__int__ returned non-int (type %.200s)",
; 152  :                      result->ob_type->tp_name);

  000d0	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000d5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d9	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@FBOPHEGH@__int__?5returned?5non?9int?5?$CItype?5?$CF@
  000e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000eb	e8 00 00 00 00	 call	 PyErr_Format

; 153  :         Py_DECREF(result);

  000f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  000f5	e8 00 00 00 00	 call	 _Py_DecRef

; 154  :         return NULL;

  000fa	33 c0		 xor	 eax, eax
  000fc	eb 05		 jmp	 SHORT $LN7@PyLong_Fro
$LN1@PyLong_Fro:

; 155  :     }
; 156  :     return (PyLongObject *)result;

  000fe	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN7@PyLong_Fro:

; 157  : }

  00103	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00107	c3		 ret	 0
_PyLong_FromNbInt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@NJCLNNOK@too?5many?5digits?5in?5integer?$AA@ ; `string'
PUBLIC	_PyLong_New
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyObject_DebugMalloc:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\objects\longobject.c
pdata	SEGMENT
$pdata$_PyLong_New DD imagerel $LN5
	DD	imagerel $LN5+119
	DD	imagerel $unwind$_PyLong_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_New DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BL@NJCLNNOK@too?5many?5digits?5in?5integer?$AA@
CONST	SEGMENT
??_C@_0BL@NJCLNNOK@too?5many?5digits?5in?5integer?$AA@ DB 'too many digit'
	DB	's in integer', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_New
_TEXT	SEGMENT
result$ = 32
size$ = 64
_PyLong_New PROC					; COMDAT

; 168  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 169  :     PyLongObject *result;
; 170  :     /* Number of bytes needed is: offsetof(PyLongObject, ob_digit) +
; 171  :        sizeof(digit)*size.  Previous incarnations of this code used
; 172  :        sizeof(PyVarObject) instead of the offsetof, but this risks being
; 173  :        incorrect in the presence of padding between the PyVarObject header
; 174  :        and the digits. */
; 175  :     if (size > (Py_ssize_t)MAX_LONG_DIGITS) {

  00009	48 b8 e3 ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693923 ; 1fffffffffffffe3H
  00013	48 39 44 24 40	 cmp	 QWORD PTR size$[rsp], rax
  00018	7e 17		 jle	 SHORT $LN2@PyLong_New

; 176  :         PyErr_SetString(PyExc_OverflowError,
; 177  :                         "too many digits in integer");

  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@NJCLNNOK@too?5many?5digits?5in?5integer?$AA@
  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00028	e8 00 00 00 00	 call	 PyErr_SetString

; 178  :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 41		 jmp	 SHORT $LN3@PyLong_New
$LN2@PyLong_New:

; 179  :     }
; 180  :     result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) +
; 181  :                              size*sizeof(digit));

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR size$[rsp]
  00036	48 8d 04 85 70
	00 00 00	 lea	 rax, QWORD PTR [rax*4+112]
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00046	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 182  :     if (!result) {

  0004b	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00051	75 09		 jne	 SHORT $LN1@PyLong_New

; 183  :         PyErr_NoMemory();

  00053	e8 00 00 00 00	 call	 PyErr_NoMemory

; 184  :         return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	eb 16		 jmp	 SHORT $LN3@PyLong_New
$LN1@PyLong_New:

; 185  :     }
; 186  :     return (PyLongObject*)PyObject_INIT_VAR((PyVarObject *)result, &PyLong_Type, size);

  0005c	4c 8b 44 24 40	 mov	 r8, QWORD PTR size$[rsp]
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyLong_Type
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0006d	e8 00 00 00 00	 call	 PyObject_INIT_VAR
$LN3@PyLong_New:

; 187  : }

  00072	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00076	c3		 ret	 0
_PyLong_New ENDP
_TEXT	ENDS
EXTRN	_Py_NewReference:PROC
EXTRN	_PxObject_InitVar:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$PyObject_INIT_VAR DD imagerel PyObject_INIT_VAR
	DD	imagerel PyObject_INIT_VAR+108
	DD	imagerel $unwind$PyObject_INIT_VAR
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT_VAR DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_INIT_VAR
_TEXT	SEGMENT
op$ = 48
tp$ = 56
n$ = 64
PyObject_INIT_VAR PROC					; COMDAT

; 247  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 248  :     Px_RETURN(_PxObject_InitVar(op, tp, n))

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 16		 je	 SHORT $LN1@PyObject_I
  0001c	4c 8b 44 24 40	 mov	 r8, QWORD PTR n$[rsp]
  00021	48 8b 54 24 38	 mov	 rdx, QWORD PTR tp$[rsp]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0002b	e8 00 00 00 00	 call	 _PxObject_InitVar
  00030	eb 35		 jmp	 SHORT $LN2@PyObject_I
$LN1@PyObject_I:

; 249  :     Py_SIZE(op) = n;

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  0003c	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 250  :     Py_TYPE(op) = tp;

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00045	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tp$[rsp]
  0004a	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 251  :     _PyObject_InitHead((PyObject *)op);

  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00053	e8 00 00 00 00	 call	 _PyObject_InitHead

; 252  :     _Py_NewReference((PyObject *)op);

  00058	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0005d	e8 00 00 00 00	 call	 _Py_NewReference

; 253  :     return op;

  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
$LN2@PyObject_I:

; 254  : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
PyObject_INIT_VAR ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_InitHead DD imagerel _PyObject_InitHead
	DD	imagerel _PyObject_InitHead+182
	DD	imagerel $unwind$_PyObject_InitHead
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_InitHead DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H
	DB	'(', 00H, 'o', 00H, 'p', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@
CONST	SEGMENT
??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 48
_PyObject_InitHead PROC					; COMDAT

; 215  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 216  :     assert(Py_TYPE(op));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0000e	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  00013	75 1c		 jne	 SHORT $LN3@PyObject_I@2
  00015	41 b8 d8 00 00
	00		 mov	 r8d, 216		; 000000d8H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	33 c0		 xor	 eax, eax
$LN3@PyObject_I@2:

; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00036	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx

; 218  :     op->px    = _Py_NOT_PARALLEL;

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00048	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00052	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 219  :     op->slist_entry.Next = NULL;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0005b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00068	48 c7 40 20 01
	00 00 00	 mov	 QWORD PTR [rax+32], 1

; 221  :     op->srw_lock  = NULL;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00075	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 222  :     op->event     = NULL;

  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 223  :     op->orig_type = NULL;

  0008a	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0008f	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;

  00097	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0009c	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 226  :     op->_ob_prev = NULL;

  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  000a9	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;
; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;
; 230  : #endif
; 231  : }

  000b1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b5	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@DCHLDCPP@?$AAs?$AAr?$AAc?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	_PyLong_Copy
;	COMDAT pdata
; File c:\src\pyparallel\objects\longobject.c
pdata	SEGMENT
$pdata$_PyLong_Copy DD imagerel $LN17
	DD	imagerel $LN17+303
	DD	imagerel $unwind$_PyLong_Copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_Copy DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_1BI@DCHLDCPP@?$AAs?$AAr?$AAc?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@DCHLDCPP@?$AAs?$AAr?$AAc?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, 'c', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'l', 00H, 'o', 00H, 'n'
	DB	00H, 'g', 00H, 'o', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, '.', 00H, 'c', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_Copy
_TEXT	SEGMENT
i$ = 32
result$ = 40
ival$20401 = 48
tv83 = 52
tv82 = 56
src$ = 80
_PyLong_Copy PROC					; COMDAT

; 191  : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 192  :     PyLongObject *result;
; 193  :     Py_ssize_t i;
; 194  : 
; 195  :     assert(src != NULL);

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR src$[rsp], 0
  0000f	75 1c		 jne	 SHORT $LN12@PyLong_Cop
  00011	41 b8 c3 00 00
	00		 mov	 r8d, 195		; 000000c3H
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@DCHLDCPP@?$AAs?$AAr?$AAc?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002b	33 c0		 xor	 eax, eax
$LN12@PyLong_Cop:

; 196  :     i = Py_SIZE(src);

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR src$[rsp]
  00032	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00036	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 197  :     if (i < 0)

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  00041	7d 0d		 jge	 SHORT $LN9@PyLong_Cop

; 198  :         i = -(i);

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00048	48 f7 d8	 neg	 rax
  0004b	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN9@PyLong_Cop:

; 199  :     if (i < 2) {

  00050	48 83 7c 24 20
	02		 cmp	 QWORD PTR i$[rsp], 2
  00056	7d 70		 jge	 SHORT $LN8@PyLong_Cop

; 200  :         sdigit ival = MEDIUM_VALUE(src);

  00058	48 8b 44 24 50	 mov	 rax, QWORD PTR src$[rsp]
  0005d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00062	7d 10		 jge	 SHORT $LN15@PyLong_Cop
  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR src$[rsp]
  00069	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0006c	f7 d8		 neg	 eax
  0006e	89 44 24 34	 mov	 DWORD PTR tv83[rsp], eax
  00072	eb 2a		 jmp	 SHORT $LN16@PyLong_Cop
$LN15@PyLong_Cop:
  00074	48 8b 44 24 50	 mov	 rax, QWORD PTR src$[rsp]
  00079	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0007e	75 0a		 jne	 SHORT $LN13@PyLong_Cop
  00080	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
  00088	eb 0c		 jmp	 SHORT $LN14@PyLong_Cop
$LN13@PyLong_Cop:
  0008a	48 8b 44 24 50	 mov	 rax, QWORD PTR src$[rsp]
  0008f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00092	89 44 24 38	 mov	 DWORD PTR tv82[rsp], eax
$LN14@PyLong_Cop:
  00096	8b 44 24 38	 mov	 eax, DWORD PTR tv82[rsp]
  0009a	89 44 24 34	 mov	 DWORD PTR tv83[rsp], eax
$LN16@PyLong_Cop:
  0009e	8b 44 24 34	 mov	 eax, DWORD PTR tv83[rsp]
  000a2	89 44 24 30	 mov	 DWORD PTR ival$20401[rsp], eax
$LN7@PyLong_Cop:

; 201  :         CHECK_SMALL_INT(ival);

  000a6	83 7c 24 30 fb	 cmp	 DWORD PTR ival$20401[rsp], -5
  000ab	7c 15		 jl	 SHORT $LN4@PyLong_Cop
  000ad	81 7c 24 30 01
	01 00 00	 cmp	 DWORD PTR ival$20401[rsp], 257 ; 00000101H
  000b5	7d 0b		 jge	 SHORT $LN4@PyLong_Cop
  000b7	8b 4c 24 30	 mov	 ecx, DWORD PTR ival$20401[rsp]
  000bb	e8 00 00 00 00	 call	 get_small_int
  000c0	eb 68		 jmp	 SHORT $LN10@PyLong_Cop
$LN4@PyLong_Cop:
  000c2	33 c0		 xor	 eax, eax
  000c4	85 c0		 test	 eax, eax
  000c6	75 de		 jne	 SHORT $LN7@PyLong_Cop
$LN8@PyLong_Cop:

; 202  :     }
; 203  :     result = _PyLong_New(i);

  000c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000cd	e8 00 00 00 00	 call	 _PyLong_New
  000d2	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 204  :     if (result != NULL) {

  000d7	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  000dd	74 46		 je	 SHORT $LN3@PyLong_Cop

; 205  :         Py_SIZE(result) = Py_SIZE(src);

  000df	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
  000e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR src$[rsp]
  000e9	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000ed	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
$LN2@PyLong_Cop:

; 206  :         while (--i >= 0)

  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000f6	48 ff c8	 dec	 rax
  000f9	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  000fe	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  00104	7c 1f		 jl	 SHORT $LN1@PyLong_Cop

; 207  :             result->ob_digit[i] = src->ob_digit[i];

  00106	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
  0010b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00110	48 8b 54 24 50	 mov	 rdx, QWORD PTR src$[rsp]
  00115	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  0011a	42 8b 54 82 70	 mov	 edx, DWORD PTR [rdx+r8*4+112]
  0011f	89 54 88 70	 mov	 DWORD PTR [rax+rcx*4+112], edx
  00123	eb cc		 jmp	 SHORT $LN2@PyLong_Cop
$LN1@PyLong_Cop:
$LN3@PyLong_Cop:

; 208  :     }
; 209  :     return (PyObject *)result;

  00125	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN10@PyLong_Cop:

; 210  : }

  0012a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012e	c3		 ret	 0
_PyLong_Copy ENDP
_TEXT	ENDS
_BSS	SEGMENT
small_ints DB	08300H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_small_int DD imagerel get_small_int
	DD	imagerel get_small_int+60
	DD	imagerel $unwind$get_small_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_small_int DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_small_int
_TEXT	SEGMENT
v$ = 32
ival$ = 64
get_small_int PROC					; COMDAT

; 38   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 39   :     PyObject *v = (PyObject*)(small_ints + ival + NSMALLNEGINTS);

  00008	48 63 44 24 40	 movsxd	 rax, DWORD PTR ival$[rsp]
  0000d	48 69 c0 80 00
	00 00		 imul	 rax, 128		; 00000080H
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:small_ints
  0001b	48 8d 84 01 80
	02 00 00	 lea	 rax, QWORD PTR [rcx+rax+640]
  00023	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 40   :     Py_INCREF(v);

  00028	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0002d	e8 00 00 00 00	 call	 _Py_IncRef

; 41   : #ifdef COUNT_ALLOCS
; 42   :     if (ival >= 0)
; 43   :         quick_int_allocs++;
; 44   :     else
; 45   :         quick_neg_int_allocs++;
; 46   : #endif
; 47   :     return v;

  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]

; 48   : }

  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
get_small_int ENDP
_TEXT	ENDS
PUBLIC	??_C@_1MK@KLKBDGLE@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AA?$CI?$AAt?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA?$CI?$AAd?$AAi?$AAg@ ; `string'
PUBLIC	??_C@_1FO@DCJIMMDP@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AA?$CI?$AAa?$AAb?$AAs?$AA_?$AAi?$AAv?$AAa?$AAl?$AA?$CJ@ ; `string'
PUBLIC	PyLong_FromLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromLong DD imagerel $LN18
	DD	imagerel $LN18+425
	DD	imagerel $unwind$PyLong_FromLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromLong DD 010801H
	DD	08208H
xdata	ENDS
;	COMDAT ??_C@_1MK@KLKBDGLE@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AA?$CI?$AAt?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA?$CI?$AAd?$AAi?$AAg@
CONST	SEGMENT
??_C@_1MK@KLKBDGLE@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AA?$CI?$AAt?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA?$CI?$AAd?$AAi?$AAg@ DB '('
	DB	00H, 'u', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'n', 00H, 'g'
	DB	00H, ')', 00H, '(', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H
	DB	't', 00H, ')', 00H, '(', 00H, 't', 00H, ' ', 00H, '&', 00H, ' '
	DB	00H, '(', 00H, '(', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H
	DB	't', 00H, ')', 00H, '(', 00H, '(', 00H, '(', 00H, 'd', 00H, 'i'
	DB	00H, 'g', 00H, 'i', 00H, 't', 00H, ')', 00H, '1', 00H, ' ', 00H
	DB	'<', 00H, '<', 00H, ' ', 00H, '3', 00H, '0', 00H, ')', 00H, ' '
	DB	00H, '-', 00H, ' ', 00H, '1', 00H, ')', 00H, ')', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 't', 00H, ' '
	DB	00H, '&', 00H, ' ', 00H, '(', 00H, '(', 00H, 'd', 00H, 'i', 00H
	DB	'g', 00H, 'i', 00H, 't', 00H, ')', 00H, '(', 00H, '(', 00H, '('
	DB	00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, ')', 00H
	DB	'1', 00H, ' ', 00H, '<', 00H, '<', 00H, ' ', 00H, '3', 00H, '0'
	DB	00H, ')', 00H, ' ', 00H, '-', 00H, ' ', 00H, '1', 00H, ')', 00H
	DB	')', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@DCJIMMDP@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AA?$CI?$AAa?$AAb?$AAs?$AA_?$AAi?$AAv?$AAa?$AAl?$AA?$CJ@
CONST	SEGMENT
??_C@_1FO@DCJIMMDP@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AA?$CI?$AAa?$AAb?$AAs?$AA_?$AAi?$AAv?$AAa?$AAl?$AA?$CJ@ DB '('
	DB	00H, 'u', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'n', 00H, 'g'
	DB	00H, ')', 00H, '(', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H
	DB	't', 00H, ')', 00H, '(', 00H, 'a', 00H, 'b', 00H, 's', 00H, '_'
	DB	00H, 'i', 00H, 'v', 00H, 'a', 00H, 'l', 00H, ')', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '(', 00H, 'a', 00H, 'b', 00H, 's'
	DB	00H, '_', 00H, 'i', 00H, 'v', 00H, 'a', 00H, 'l', 00H, ')', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLong_FromLong
_TEXT	SEGMENT
v$ = 32
abs_ival$ = 40
sign$ = 44
ndigits$ = 48
t$ = 52
p$20451 = 56
ival$ = 80
PyLong_FromLong PROC					; COMDAT

; 216  : {

$LN18:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 217  :     PyLongObject *v;
; 218  :     unsigned long abs_ival;
; 219  :     unsigned long t;  /* unsigned so >> doesn't propagate sign bit */
; 220  :     int ndigits = 0;

  00008	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ndigits$[rsp], 0

; 221  :     int sign = 1;

  00010	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1
$LN13@PyLong_Fro@2:

; 222  : 
; 223  :     CHECK_SMALL_INT(ival);

  00018	83 7c 24 50 fb	 cmp	 DWORD PTR ival$[rsp], -5
  0001d	7c 18		 jl	 SHORT $LN10@PyLong_Fro@2
  0001f	81 7c 24 50 01
	01 00 00	 cmp	 DWORD PTR ival$[rsp], 257 ; 00000101H
  00027	7d 0e		 jge	 SHORT $LN10@PyLong_Fro@2
  00029	8b 4c 24 50	 mov	 ecx, DWORD PTR ival$[rsp]
  0002d	e8 00 00 00 00	 call	 get_small_int
  00032	e9 6d 01 00 00	 jmp	 $LN14@PyLong_Fro@2
$LN10@PyLong_Fro@2:
  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 db		 jne	 SHORT $LN13@PyLong_Fro@2

; 224  : 
; 225  :     if (ival < 0) {

  0003d	83 7c 24 50 00	 cmp	 DWORD PTR ival$[rsp], 0
  00042	7d 14		 jge	 SHORT $LN9@PyLong_Fro@2

; 226  :         /* negate: can't write this as abs_ival = -ival since that
; 227  :            invokes undefined behaviour when ival is LONG_MIN */
; 228  :         abs_ival = 0U-(unsigned long)ival;

  00044	33 c0		 xor	 eax, eax
  00046	2b 44 24 50	 sub	 eax, DWORD PTR ival$[rsp]
  0004a	89 44 24 28	 mov	 DWORD PTR abs_ival$[rsp], eax

; 229  :         sign = -1;

  0004e	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR sign$[rsp], -1

; 230  :     }
; 231  :     else {

  00056	eb 08		 jmp	 SHORT $LN8@PyLong_Fro@2
$LN9@PyLong_Fro@2:

; 232  :         abs_ival = (unsigned long)ival;

  00058	8b 44 24 50	 mov	 eax, DWORD PTR ival$[rsp]
  0005c	89 44 24 28	 mov	 DWORD PTR abs_ival$[rsp], eax
$LN8@PyLong_Fro@2:

; 233  :     }
; 234  : 
; 235  :     /* Fast path for single-digit ints */
; 236  :     if (!(abs_ival >> PyLong_SHIFT)) {

  00060	8b 44 24 28	 mov	 eax, DWORD PTR abs_ival$[rsp]
  00064	c1 e8 1e	 shr	 eax, 30
  00067	85 c0		 test	 eax, eax
  00069	75 61		 jne	 SHORT $LN7@PyLong_Fro@2

; 237  :         v = _PyLong_New(1);

  0006b	b9 01 00 00 00	 mov	 ecx, 1
  00070	e8 00 00 00 00	 call	 _PyLong_New
  00075	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 238  :         if (v) {

  0007a	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00080	74 40		 je	 SHORT $LN6@PyLong_Fro@2

; 239  :             Py_SIZE(v) = sign;

  00082	48 63 44 24 2c	 movsxd	 rax, DWORD PTR sign$[rsp]
  00087	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0008c	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 240  :             v->ob_digit[0] = Py_SAFE_DOWNCAST(
; 241  :                 abs_ival, unsigned long, digit);

  00090	8b 44 24 28	 mov	 eax, DWORD PTR abs_ival$[rsp]
  00094	39 44 24 28	 cmp	 DWORD PTR abs_ival$[rsp], eax
  00098	74 1c		 je	 SHORT $LN16@PyLong_Fro@2
  0009a	41 b8 f1 00 00
	00		 mov	 r8d, 241		; 000000f1H
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@DCJIMMDP@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AA?$CI?$AAa?$AAb?$AAs?$AA_?$AAi?$AAv?$AAa?$AAl?$AA?$CJ@
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b4	33 c0		 xor	 eax, eax
$LN16@PyLong_Fro@2:
  000b6	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  000bb	8b 4c 24 28	 mov	 ecx, DWORD PTR abs_ival$[rsp]
  000bf	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN6@PyLong_Fro@2:

; 242  :         }
; 243  :         return (PyObject*)v;

  000c2	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  000c7	e9 d8 00 00 00	 jmp	 $LN14@PyLong_Fro@2
$LN7@PyLong_Fro@2:

; 244  :     }
; 245  : 
; 246  : #if PyLong_SHIFT==15
; 247  :     /* 2 digits */
; 248  :     if (!(abs_ival >> 2*PyLong_SHIFT)) {
; 249  :         v = _PyLong_New(2);
; 250  :         if (v) {
; 251  :             Py_SIZE(v) = 2*sign;
; 252  :             v->ob_digit[0] = Py_SAFE_DOWNCAST(
; 253  :                 abs_ival & PyLong_MASK, unsigned long, digit);
; 254  :             v->ob_digit[1] = Py_SAFE_DOWNCAST(
; 255  :                   abs_ival >> PyLong_SHIFT, unsigned long, digit);
; 256  :         }
; 257  :         return (PyObject*)v;
; 258  :     }
; 259  : #endif
; 260  : 
; 261  :     /* Larger numbers: loop to determine number of digits */
; 262  :     t = abs_ival;

  000cc	8b 44 24 28	 mov	 eax, DWORD PTR abs_ival$[rsp]
  000d0	89 44 24 34	 mov	 DWORD PTR t$[rsp], eax
$LN5@PyLong_Fro@2:

; 263  :     while (t) {

  000d4	83 7c 24 34 00	 cmp	 DWORD PTR t$[rsp], 0
  000d9	74 17		 je	 SHORT $LN4@PyLong_Fro@2

; 264  :         ++ndigits;

  000db	8b 44 24 30	 mov	 eax, DWORD PTR ndigits$[rsp]
  000df	ff c0		 inc	 eax
  000e1	89 44 24 30	 mov	 DWORD PTR ndigits$[rsp], eax

; 265  :         t >>= PyLong_SHIFT;

  000e5	8b 44 24 34	 mov	 eax, DWORD PTR t$[rsp]
  000e9	c1 e8 1e	 shr	 eax, 30
  000ec	89 44 24 34	 mov	 DWORD PTR t$[rsp], eax

; 266  :     }

  000f0	eb e2		 jmp	 SHORT $LN5@PyLong_Fro@2
$LN4@PyLong_Fro@2:

; 267  :     v = _PyLong_New(ndigits);

  000f2	48 63 44 24 30	 movsxd	 rax, DWORD PTR ndigits$[rsp]
  000f7	48 8b c8	 mov	 rcx, rax
  000fa	e8 00 00 00 00	 call	 _PyLong_New
  000ff	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 268  :     if (v != NULL) {

  00104	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  0010a	0f 84 8f 00 00
	00		 je	 $LN3@PyLong_Fro@2

; 269  :         digit *p = v->ob_digit;

  00110	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00115	48 83 c0 70	 add	 rax, 112		; 00000070H
  00119	48 89 44 24 38	 mov	 QWORD PTR p$20451[rsp], rax

; 270  :         Py_SIZE(v) = ndigits*sign;

  0011e	8b 44 24 30	 mov	 eax, DWORD PTR ndigits$[rsp]
  00122	0f af 44 24 2c	 imul	 eax, DWORD PTR sign$[rsp]
  00127	48 98		 cdqe
  00129	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0012e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 271  :         t = abs_ival;

  00132	8b 44 24 28	 mov	 eax, DWORD PTR abs_ival$[rsp]
  00136	89 44 24 34	 mov	 DWORD PTR t$[rsp], eax
$LN2@PyLong_Fro@2:

; 272  :         while (t) {

  0013a	83 7c 24 34 00	 cmp	 DWORD PTR t$[rsp], 0
  0013f	74 5e		 je	 SHORT $LN1@PyLong_Fro@2

; 273  :             *p++ = Py_SAFE_DOWNCAST(
; 274  :                 t & PyLong_MASK, unsigned long, digit);

  00141	8b 44 24 34	 mov	 eax, DWORD PTR t$[rsp]
  00145	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0014a	8b 4c 24 34	 mov	 ecx, DWORD PTR t$[rsp]
  0014e	81 e1 ff ff ff
	3f		 and	 ecx, 1073741823		; 3fffffffH
  00154	3b c1		 cmp	 eax, ecx
  00156	74 1c		 je	 SHORT $LN17@PyLong_Fro@2
  00158	41 b8 12 01 00
	00		 mov	 r8d, 274		; 00000112H
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1MK@KLKBDGLE@?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA?$CJ?$AA?$CI?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AA?$CI?$AAt?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA?$CI?$AAd?$AAi?$AAg@
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00172	33 c0		 xor	 eax, eax
$LN17@PyLong_Fro@2:
  00174	8b 44 24 34	 mov	 eax, DWORD PTR t$[rsp]
  00178	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0017d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$20451[rsp]
  00182	89 01		 mov	 DWORD PTR [rcx], eax
  00184	48 8b 44 24 38	 mov	 rax, QWORD PTR p$20451[rsp]
  00189	48 83 c0 04	 add	 rax, 4
  0018d	48 89 44 24 38	 mov	 QWORD PTR p$20451[rsp], rax

; 275  :             t >>= PyLong_SHIFT;

  00192	8b 44 24 34	 mov	 eax, DWORD PTR t$[rsp]
  00196	c1 e8 1e	 shr	 eax, 30
  00199	89 44 24 34	 mov	 DWORD PTR t$[rsp], eax

; 276  :         }

  0019d	eb 9b		 jmp	 SHORT $LN2@PyLong_Fro@2
$LN1@PyLong_Fro@2:
$LN3@PyLong_Fro@2:

; 277  :     }
; 278  :     return (PyObject *)v;

  0019f	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN14@PyLong_Fro@2:

; 279  : }

  001a4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a8	c3		 ret	 0
PyLong_FromLong ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromUnsignedLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromUnsignedLong DD imagerel $LN9
	DD	imagerel $LN9+192
	DD	imagerel $unwind$PyLong_FromUnsignedLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromUnsignedLong DD 010801H
	DD	08208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_FromUnsignedLong
_TEXT	SEGMENT
v$ = 32
ndigits$ = 40
t$ = 44
p$20482 = 48
ival$ = 80
PyLong_FromUnsignedLong PROC				; COMDAT

; 285  : {

$LN9:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 286  :     PyLongObject *v;
; 287  :     unsigned long t;
; 288  :     int ndigits = 0;

  00008	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ndigits$[rsp], 0

; 289  : 
; 290  :     if (ival < PyLong_BASE)

  00010	81 7c 24 50 00
	00 00 40	 cmp	 DWORD PTR ival$[rsp], 1073741824 ; 40000000H
  00018	73 0e		 jae	 SHORT $LN6@PyLong_Fro@3

; 291  :         return PyLong_FromLong(ival);

  0001a	8b 4c 24 50	 mov	 ecx, DWORD PTR ival$[rsp]
  0001e	e8 00 00 00 00	 call	 PyLong_FromLong
  00023	e9 93 00 00 00	 jmp	 $LN7@PyLong_Fro@3
$LN6@PyLong_Fro@3:

; 292  :     /* Count the number of Python digits. */
; 293  :     t = (unsigned long)ival;

  00028	8b 44 24 50	 mov	 eax, DWORD PTR ival$[rsp]
  0002c	89 44 24 2c	 mov	 DWORD PTR t$[rsp], eax
$LN5@PyLong_Fro@3:

; 294  :     while (t) {

  00030	83 7c 24 2c 00	 cmp	 DWORD PTR t$[rsp], 0
  00035	74 17		 je	 SHORT $LN4@PyLong_Fro@3

; 295  :         ++ndigits;

  00037	8b 44 24 28	 mov	 eax, DWORD PTR ndigits$[rsp]
  0003b	ff c0		 inc	 eax
  0003d	89 44 24 28	 mov	 DWORD PTR ndigits$[rsp], eax

; 296  :         t >>= PyLong_SHIFT;

  00041	8b 44 24 2c	 mov	 eax, DWORD PTR t$[rsp]
  00045	c1 e8 1e	 shr	 eax, 30
  00048	89 44 24 2c	 mov	 DWORD PTR t$[rsp], eax

; 297  :     }

  0004c	eb e2		 jmp	 SHORT $LN5@PyLong_Fro@3
$LN4@PyLong_Fro@3:

; 298  :     v = _PyLong_New(ndigits);

  0004e	48 63 44 24 28	 movsxd	 rax, DWORD PTR ndigits$[rsp]
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 _PyLong_New
  0005b	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 299  :     if (v != NULL) {

  00060	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00066	74 4e		 je	 SHORT $LN3@PyLong_Fro@3

; 300  :         digit *p = v->ob_digit;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  0006d	48 83 c0 70	 add	 rax, 112		; 00000070H
  00071	48 89 44 24 30	 mov	 QWORD PTR p$20482[rsp], rax

; 301  :         Py_SIZE(v) = ndigits;

  00076	48 63 44 24 28	 movsxd	 rax, DWORD PTR ndigits$[rsp]
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00080	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN2@PyLong_Fro@3:

; 302  :         while (ival) {

  00084	83 7c 24 50 00	 cmp	 DWORD PTR ival$[rsp], 0
  00089	74 2b		 je	 SHORT $LN1@PyLong_Fro@3

; 303  :             *p++ = (digit)(ival & PyLong_MASK);

  0008b	8b 44 24 50	 mov	 eax, DWORD PTR ival$[rsp]
  0008f	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00094	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$20482[rsp]
  00099	89 01		 mov	 DWORD PTR [rcx], eax
  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR p$20482[rsp]
  000a0	48 83 c0 04	 add	 rax, 4
  000a4	48 89 44 24 30	 mov	 QWORD PTR p$20482[rsp], rax

; 304  :             ival >>= PyLong_SHIFT;

  000a9	8b 44 24 50	 mov	 eax, DWORD PTR ival$[rsp]
  000ad	c1 e8 1e	 shr	 eax, 30
  000b0	89 44 24 50	 mov	 DWORD PTR ival$[rsp], eax

; 305  :         }

  000b4	eb ce		 jmp	 SHORT $LN2@PyLong_Fro@3
$LN1@PyLong_Fro@3:
$LN3@PyLong_Fro@3:

; 306  :     }
; 307  :     return (PyObject *)v;

  000b6	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN7@PyLong_Fro@3:

; 308  : }

  000bb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bf	c3		 ret	 0
PyLong_FromUnsignedLong ENDP
_TEXT	ENDS
PUBLIC	__mask@@NegDouble@
PUBLIC	??_C@_0CE@HNDAIPOH@cannot?5convert?5float?5NaN?5to?5inte@ ; `string'
PUBLIC	??_C@_0CJ@FCONGJCF@cannot?5convert?5float?5infinity?5to@ ; `string'
PUBLIC	PyLong_FromDouble
EXTRN	__imp_ldexp:PROC
EXTRN	__imp_frexp:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	__imp__isnan:PROC
EXTRN	__imp__finite:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromDouble DD imagerel $LN11
	DD	imagerel $LN11+441
	DD	imagerel $unwind$PyLong_FromDouble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromDouble DD 010a01H
	DD	0a20aH
xdata	ENDS
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT ??_C@_0CE@HNDAIPOH@cannot?5convert?5float?5NaN?5to?5inte@
CONST	SEGMENT
??_C@_0CE@HNDAIPOH@cannot?5convert?5float?5NaN?5to?5inte@ DB 'cannot conv'
	DB	'ert float NaN to integer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FCONGJCF@cannot?5convert?5float?5infinity?5to@
CONST	SEGMENT
??_C@_0CJ@FCONGJCF@cannot?5convert?5float?5infinity?5to@ DB 'cannot conve'
	DB	'rt float infinity to integer', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLong_FromDouble
_TEXT	SEGMENT
v$ = 32
i$ = 40
expo$ = 44
neg$ = 48
frac$ = 56
ndig$ = 64
bits$20514 = 68
dval$ = 96
PyLong_FromDouble PROC					; COMDAT

; 314  : {

$LN11:
  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 315  :     PyLongObject *v;
; 316  :     double frac;
; 317  :     int i, ndig, expo, neg;
; 318  :     neg = 0;

  0000a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR neg$[rsp], 0

; 319  :     if (Py_IS_INFINITY(dval)) {

  00012	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR dval$[rsp]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0001e	85 c0		 test	 eax, eax
  00020	75 2a		 jne	 SHORT $LN8@PyLong_Fro@4
  00022	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR dval$[rsp]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0002e	85 c0		 test	 eax, eax
  00030	75 1a		 jne	 SHORT $LN8@PyLong_Fro@4

; 320  :         PyErr_SetString(PyExc_OverflowError,
; 321  :                         "cannot convert float infinity to integer");

  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@FCONGJCF@cannot?5convert?5float?5infinity?5to@
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00040	e8 00 00 00 00	 call	 PyErr_SetString

; 322  :         return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	e9 68 01 00 00	 jmp	 $LN9@PyLong_Fro@4
$LN8@PyLong_Fro@4:

; 323  :     }
; 324  :     if (Py_IS_NAN(dval)) {

  0004c	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR dval$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00058	85 c0		 test	 eax, eax
  0005a	74 1a		 je	 SHORT $LN7@PyLong_Fro@4

; 325  :         PyErr_SetString(PyExc_ValueError,
; 326  :                         "cannot convert float NaN to integer");

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@HNDAIPOH@cannot?5convert?5float?5NaN?5to?5inte@
  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0006a	e8 00 00 00 00	 call	 PyErr_SetString

; 327  :         return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	e9 3e 01 00 00	 jmp	 $LN9@PyLong_Fro@4
$LN7@PyLong_Fro@4:

; 328  :     }
; 329  :     if (dval < 0.0) {

  00076	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0007a	66 0f 2f 44 24
	60		 comisd	 xmm0, QWORD PTR dval$[rsp]
  00080	76 1c		 jbe	 SHORT $LN6@PyLong_Fro@4

; 330  :         neg = 1;

  00082	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR neg$[rsp], 1

; 331  :         dval = -dval;

  0008a	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR dval$[rsp]
  00090	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00098	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR dval$[rsp], xmm0
$LN6@PyLong_Fro@4:

; 332  :     }
; 333  :     frac = frexp(dval, &expo); /* dval = frac*2**expo; 0.0 <= frac < 1.0 */

  0009e	48 8d 54 24 2c	 lea	 rdx, QWORD PTR expo$[rsp]
  000a3	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR dval$[rsp]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp
  000af	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR frac$[rsp], xmm0

; 334  :     if (expo <= 0)

  000b5	83 7c 24 2c 00	 cmp	 DWORD PTR expo$[rsp], 0
  000ba	7f 0c		 jg	 SHORT $LN5@PyLong_Fro@4

; 335  :         return PyLong_FromLong(0L);

  000bc	33 c9		 xor	 ecx, ecx
  000be	e8 00 00 00 00	 call	 PyLong_FromLong
  000c3	e9 ec 00 00 00	 jmp	 $LN9@PyLong_Fro@4
$LN5@PyLong_Fro@4:

; 336  :     ndig = (expo-1) / PyLong_SHIFT + 1; /* Number of 'digits' in result */

  000c8	8b 44 24 2c	 mov	 eax, DWORD PTR expo$[rsp]
  000cc	ff c8		 dec	 eax
  000ce	99		 cdq
  000cf	b9 1e 00 00 00	 mov	 ecx, 30
  000d4	f7 f9		 idiv	 ecx
  000d6	ff c0		 inc	 eax
  000d8	89 44 24 40	 mov	 DWORD PTR ndig$[rsp], eax

; 337  :     v = _PyLong_New(ndig);

  000dc	48 63 44 24 40	 movsxd	 rax, DWORD PTR ndig$[rsp]
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	e8 00 00 00 00	 call	 _PyLong_New
  000e9	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 338  :     if (v == NULL)

  000ee	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  000f4	75 07		 jne	 SHORT $LN4@PyLong_Fro@4

; 339  :         return NULL;

  000f6	33 c0		 xor	 eax, eax
  000f8	e9 b7 00 00 00	 jmp	 $LN9@PyLong_Fro@4
$LN4@PyLong_Fro@4:

; 340  :     frac = ldexp(frac, (expo-1) % PyLong_SHIFT + 1);

  000fd	8b 44 24 2c	 mov	 eax, DWORD PTR expo$[rsp]
  00101	ff c8		 dec	 eax
  00103	99		 cdq
  00104	b9 1e 00 00 00	 mov	 ecx, 30
  00109	f7 f9		 idiv	 ecx
  0010b	8b c2		 mov	 eax, edx
  0010d	ff c0		 inc	 eax
  0010f	8b d0		 mov	 edx, eax
  00111	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR frac$[rsp]
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  0011d	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR frac$[rsp], xmm0

; 341  :     for (i = ndig; --i >= 0; ) {

  00123	8b 44 24 40	 mov	 eax, DWORD PTR ndig$[rsp]
  00127	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN3@PyLong_Fro@4:
  0012b	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0012f	ff c8		 dec	 eax
  00131	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00135	83 7c 24 28 00	 cmp	 DWORD PTR i$[rsp], 0
  0013a	7c 57		 jl	 SHORT $LN2@PyLong_Fro@4

; 342  :         digit bits = (digit)frac;

  0013c	f2 48 0f 2c 44
	24 38		 cvttsd2si rax, QWORD PTR frac$[rsp]
  00143	89 44 24 44	 mov	 DWORD PTR bits$20514[rsp], eax

; 343  :         v->ob_digit[i] = bits;

  00147	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0014c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00151	8b 54 24 44	 mov	 edx, DWORD PTR bits$20514[rsp]
  00155	89 54 81 70	 mov	 DWORD PTR [rcx+rax*4+112], edx

; 344  :         frac = frac - (double)bits;

  00159	8b 44 24 44	 mov	 eax, DWORD PTR bits$20514[rsp]
  0015d	66 0f ef c0	 pxor	 xmm0, xmm0
  00161	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00166	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR frac$[rsp]
  0016c	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00170	66 0f 28 c1	 movapd	 xmm0, xmm1
  00174	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR frac$[rsp], xmm0

; 345  :         frac = ldexp(frac, PyLong_SHIFT);

  0017a	ba 1e 00 00 00	 mov	 edx, 30
  0017f	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR frac$[rsp]
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  0018b	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR frac$[rsp], xmm0

; 346  :     }

  00191	eb 98		 jmp	 SHORT $LN3@PyLong_Fro@4
$LN2@PyLong_Fro@4:

; 347  :     if (neg)

  00193	83 7c 24 30 00	 cmp	 DWORD PTR neg$[rsp], 0
  00198	74 15		 je	 SHORT $LN1@PyLong_Fro@4

; 348  :         Py_SIZE(v) = -(Py_SIZE(v));

  0019a	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  0019f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001a3	48 f7 d8	 neg	 rax
  001a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  001ab	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN1@PyLong_Fro@4:

; 349  :     return (PyObject *)v;

  001af	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN9@PyLong_Fro@4:

; 350  : }

  001b4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b8	c3		 ret	 0
PyLong_FromDouble ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@ ; `string'
PUBLIC	PyLong_AsLongAndOverflow
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsLongAndOverflow DD imagerel $LN22
	DD	imagerel $LN22+468
	DD	imagerel $unwind$PyLong_AsLongAndOverflow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsLongAndOverflow DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
CONST	SEGMENT
??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@ DB '..\Objects\longob'
	DB	'ject.c', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLong_AsLongAndOverflow
_TEXT	SEGMENT
res$ = 32
v$ = 40
do_decref$ = 48
x$ = 52
i$ = 56
prev$ = 64
sign$ = 68
tv75 = 72
vv$ = 96
overflow$ = 104
PyLong_AsLongAndOverflow PROC				; COMDAT

; 376  : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 377  :     /* This version by Tim Peters */
; 378  :     register PyLongObject *v;
; 379  :     unsigned long x, prev;
; 380  :     long res;
; 381  :     Py_ssize_t i;
; 382  :     int sign;
; 383  :     int do_decref = 0; /* if nb_int was called */

  0000e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR do_decref$[rsp], 0

; 384  : 
; 385  :     *overflow = 0;

  00016	48 8b 44 24 68	 mov	 rax, QWORD PTR overflow$[rsp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 386  :     if (vv == NULL) {

  00021	48 83 7c 24 60
	00		 cmp	 QWORD PTR vv$[rsp], 0
  00027	75 1b		 jne	 SHORT $LN19@PyLong_AsL

; 387  :         PyErr_BadInternalCall();

  00029	ba 83 01 00 00	 mov	 edx, 387		; 00000183H
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00035	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 388  :         return -1;

  0003a	b8 ff ff ff ff	 mov	 eax, -1
  0003f	e9 8b 01 00 00	 jmp	 $LN20@PyLong_AsL
$LN19@PyLong_AsL:

; 389  :     }
; 390  : 
; 391  :     if (PyLong_Check(vv)) {

  00044	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  00049	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00053	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00058	85 c0		 test	 eax, eax
  0005a	74 0c		 je	 SHORT $LN18@PyLong_AsL

; 392  :         v = (PyLongObject *)vv;

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  00061	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 393  :     }
; 394  :     else {

  00066	eb 29		 jmp	 SHORT $LN17@PyLong_AsL
$LN18@PyLong_AsL:

; 395  :         v = _PyLong_FromNbInt(vv);

  00068	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vv$[rsp]
  0006d	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00072	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 396  :         if (v == NULL)

  00077	48 83 7c 24 28
	00		 cmp	 QWORD PTR v$[rsp], 0
  0007d	75 0a		 jne	 SHORT $LN16@PyLong_AsL

; 397  :             return -1;

  0007f	b8 ff ff ff ff	 mov	 eax, -1
  00084	e9 46 01 00 00	 jmp	 $LN20@PyLong_AsL
$LN16@PyLong_AsL:

; 398  :         do_decref = 1;

  00089	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR do_decref$[rsp], 1
$LN17@PyLong_AsL:

; 399  :     }
; 400  : 
; 401  :     res = -1;

  00091	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR res$[rsp], -1

; 402  :     i = Py_SIZE(v);

  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  0009e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a2	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax

; 403  : 
; 404  :     switch (i) {

  000a7	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000ac	48 89 44 24 48	 mov	 QWORD PTR tv75[rsp], rax
  000b1	48 83 7c 24 48
	ff		 cmp	 QWORD PTR tv75[rsp], -1
  000b7	74 12		 je	 SHORT $LN13@PyLong_AsL
  000b9	48 83 7c 24 48
	00		 cmp	 QWORD PTR tv75[rsp], 0
  000bf	74 1d		 je	 SHORT $LN12@PyLong_AsL
  000c1	48 83 7c 24 48
	01		 cmp	 QWORD PTR tv75[rsp], 1
  000c7	74 22		 je	 SHORT $LN11@PyLong_AsL
  000c9	eb 31		 jmp	 SHORT $LN10@PyLong_AsL
$LN13@PyLong_AsL:

; 405  :     case -1:
; 406  :         res = -(sdigit)v->ob_digit[0];

  000cb	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  000d0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000d3	f7 d8		 neg	 eax
  000d5	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 407  :         break;

  000d9	e9 dc 00 00 00	 jmp	 $LN14@PyLong_AsL
$LN12@PyLong_AsL:

; 408  :     case 0:
; 409  :         res = 0;

  000de	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR res$[rsp], 0

; 410  :         break;

  000e6	e9 cf 00 00 00	 jmp	 $LN14@PyLong_AsL
$LN11@PyLong_AsL:

; 411  :     case 1:
; 412  :         res = v->ob_digit[0];

  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  000f0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000f3	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 413  :         break;

  000f7	e9 be 00 00 00	 jmp	 $LN14@PyLong_AsL
$LN10@PyLong_AsL:

; 414  :     default:
; 415  :         sign = 1;

  000fc	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1

; 416  :         x = 0;

  00104	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR x$[rsp], 0

; 417  :         if (i < 0) {

  0010c	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  00112	7d 15		 jge	 SHORT $LN9@PyLong_AsL

; 418  :             sign = -1;

  00114	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR sign$[rsp], -1

; 419  :             i = -(i);

  0011c	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00121	48 f7 d8	 neg	 rax
  00124	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN9@PyLong_AsL:
$LN8@PyLong_AsL:

; 420  :         }
; 421  :         while (--i >= 0) {

  00129	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0012e	48 ff c8	 dec	 rax
  00131	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
  00136	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  0013c	7c 3d		 jl	 SHORT $LN7@PyLong_AsL

; 422  :             prev = x;

  0013e	8b 44 24 34	 mov	 eax, DWORD PTR x$[rsp]
  00142	89 44 24 40	 mov	 DWORD PTR prev$[rsp], eax

; 423  :             x = (x << PyLong_SHIFT) | v->ob_digit[i];

  00146	8b 44 24 34	 mov	 eax, DWORD PTR x$[rsp]
  0014a	c1 e0 1e	 shl	 eax, 30
  0014d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  00152	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  00157	0b 44 91 70	 or	 eax, DWORD PTR [rcx+rdx*4+112]
  0015b	89 44 24 34	 mov	 DWORD PTR x$[rsp], eax

; 424  :             if ((x >> PyLong_SHIFT) != prev) {

  0015f	8b 44 24 34	 mov	 eax, DWORD PTR x$[rsp]
  00163	c1 e8 1e	 shr	 eax, 30
  00166	3b 44 24 40	 cmp	 eax, DWORD PTR prev$[rsp]
  0016a	74 0d		 je	 SHORT $LN6@PyLong_AsL

; 425  :                 *overflow = sign;

  0016c	48 8b 44 24 68	 mov	 rax, QWORD PTR overflow$[rsp]
  00171	8b 4c 24 44	 mov	 ecx, DWORD PTR sign$[rsp]
  00175	89 08		 mov	 DWORD PTR [rax], ecx

; 426  :                 goto exit;

  00177	eb 41		 jmp	 SHORT $exit$20559
$LN6@PyLong_AsL:

; 427  :             }
; 428  :         }

  00179	eb ae		 jmp	 SHORT $LN8@PyLong_AsL
$LN7@PyLong_AsL:

; 429  :         /* Haven't lost any bits, but casting to long requires extra
; 430  :          * care (see comment above).
; 431  :          */
; 432  :         if (x <= (unsigned long)LONG_MAX) {

  0017b	81 7c 24 34 ff
	ff ff 7f	 cmp	 DWORD PTR x$[rsp], 2147483647 ; 7fffffffH
  00183	77 0f		 ja	 SHORT $LN5@PyLong_AsL

; 433  :             res = (long)x * sign;

  00185	8b 44 24 34	 mov	 eax, DWORD PTR x$[rsp]
  00189	0f af 44 24 44	 imul	 eax, DWORD PTR sign$[rsp]
  0018e	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax
  00192	eb 26		 jmp	 SHORT $LN4@PyLong_AsL
$LN5@PyLong_AsL:

; 434  :         }
; 435  :         else if (sign < 0 && x == PY_ABS_LONG_MIN) {

  00194	83 7c 24 44 00	 cmp	 DWORD PTR sign$[rsp], 0
  00199	7d 14		 jge	 SHORT $LN3@PyLong_AsL
  0019b	81 7c 24 34 00
	00 00 80	 cmp	 DWORD PTR x$[rsp], -2147483648 ; 80000000H
  001a3	75 0a		 jne	 SHORT $LN3@PyLong_AsL

; 436  :             res = LONG_MIN;

  001a5	c7 44 24 20 00
	00 00 80	 mov	 DWORD PTR res$[rsp], -2147483648 ; ffffffff80000000H

; 437  :         }
; 438  :         else {

  001ad	eb 0b		 jmp	 SHORT $LN2@PyLong_AsL
$LN3@PyLong_AsL:

; 439  :             *overflow = sign;

  001af	48 8b 44 24 68	 mov	 rax, QWORD PTR overflow$[rsp]
  001b4	8b 4c 24 44	 mov	 ecx, DWORD PTR sign$[rsp]
  001b8	89 08		 mov	 DWORD PTR [rax], ecx
$LN2@PyLong_AsL:
$LN4@PyLong_AsL:
$LN14@PyLong_AsL:
$exit$20559:

; 440  :             /* res is already set to -1 */
; 441  :         }
; 442  :     }
; 443  :   exit:
; 444  :     if (do_decref) {

  001ba	83 7c 24 30 00	 cmp	 DWORD PTR do_decref$[rsp], 0
  001bf	74 0a		 je	 SHORT $LN1@PyLong_AsL

; 445  :         Py_DECREF(v);

  001c1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  001c6	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyLong_AsL:

; 446  :     }
; 447  :     return res;

  001cb	8b 44 24 20	 mov	 eax, DWORD PTR res$[rsp]
$LN20@PyLong_AsL:

; 448  : }

  001cf	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d3	c3		 ret	 0
PyLong_AsLongAndOverflow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CMJMJMG@Python?5int?5too?5large?5to?5convert?5@ ; `string'
PUBLIC	PyLong_AsLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsLong DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$PyLong_AsLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsLong DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CK@CMJMJMG@Python?5int?5too?5large?5to?5convert?5@
CONST	SEGMENT
??_C@_0CK@CMJMJMG@Python?5int?5too?5large?5to?5convert?5@ DB 'Python int '
	DB	'too large to convert to C long', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLong_AsLong
_TEXT	SEGMENT
overflow$ = 32
result$ = 36
obj$ = 64
PyLong_AsLong PROC					; COMDAT

; 455  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 456  :     int overflow;
; 457  :     long result = PyLong_AsLongAndOverflow(obj, &overflow);

  00009	48 8d 54 24 20	 lea	 rdx, QWORD PTR overflow$[rsp]
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  00013	e8 00 00 00 00	 call	 PyLong_AsLongAndOverflow
  00018	89 44 24 24	 mov	 DWORD PTR result$[rsp], eax

; 458  :     if (overflow) {

  0001c	83 7c 24 20 00	 cmp	 DWORD PTR overflow$[rsp], 0
  00021	74 13		 je	 SHORT $LN1@PyLong_AsL@2

; 459  :         /* XXX: could be cute and give a different
; 460  :            message for overflow == -1 */
; 461  :         PyErr_SetString(PyExc_OverflowError,
; 462  :                         "Python int too large to convert to C long");

  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@CMJMJMG@Python?5int?5too?5large?5to?5convert?5@
  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00031	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@PyLong_AsL@2:

; 463  :     }
; 464  :     return result;

  00036	8b 44 24 24	 mov	 eax, DWORD PTR result$[rsp]

; 465  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
PyLong_AsLong ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@PBLNFIOG@Python?5int?5too?5large?5to?5convert?5@ ; `string'
PUBLIC	_PyLong_AsInt
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_AsInt DD imagerel $LN5
	DD	imagerel $LN5+90
	DD	imagerel $unwind$_PyLong_AsInt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_AsInt DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CJ@PBLNFIOG@Python?5int?5too?5large?5to?5convert?5@
CONST	SEGMENT
??_C@_0CJ@PBLNFIOG@Python?5int?5too?5large?5to?5convert?5@ DB 'Python int'
	DB	' too large to convert to C int', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_AsInt
_TEXT	SEGMENT
overflow$ = 32
result$ = 36
obj$ = 64
_PyLong_AsInt PROC					; COMDAT

; 472  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 473  :     int overflow;
; 474  :     long result = PyLong_AsLongAndOverflow(obj, &overflow);

  00009	48 8d 54 24 20	 lea	 rdx, QWORD PTR overflow$[rsp]
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  00013	e8 00 00 00 00	 call	 PyLong_AsLongAndOverflow
  00018	89 44 24 24	 mov	 DWORD PTR result$[rsp], eax

; 475  :     if (overflow || result > INT_MAX || result < INT_MIN) {

  0001c	83 7c 24 20 00	 cmp	 DWORD PTR overflow$[rsp], 0
  00021	75 14		 jne	 SHORT $LN1@PyLong_AsI
  00023	81 7c 24 24 ff
	ff ff 7f	 cmp	 DWORD PTR result$[rsp], 2147483647 ; 7fffffffH
  0002b	7f 0a		 jg	 SHORT $LN1@PyLong_AsI
  0002d	81 7c 24 24 00
	00 00 80	 cmp	 DWORD PTR result$[rsp], -2147483648 ; ffffffff80000000H
  00035	7d 1a		 jge	 SHORT $LN2@PyLong_AsI
$LN1@PyLong_AsI:

; 476  :         /* XXX: could be cute and give a different
; 477  :            message for overflow == -1 */
; 478  :         PyErr_SetString(PyExc_OverflowError,
; 479  :                         "Python int too large to convert to C int");

  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@PBLNFIOG@Python?5int?5too?5large?5to?5convert?5@
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00045	e8 00 00 00 00	 call	 PyErr_SetString

; 480  :         return -1;

  0004a	b8 ff ff ff ff	 mov	 eax, -1
  0004f	eb 04		 jmp	 SHORT $LN3@PyLong_AsI
$LN2@PyLong_AsI:

; 481  :     }
; 482  :     return (int)result;

  00051	8b 44 24 24	 mov	 eax, DWORD PTR result$[rsp]
$LN3@PyLong_AsI:

; 483  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
_PyLong_AsInt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@MNHJJIBL@Python?5int?5too?5large?5to?5convert?5@ ; `string'
PUBLIC	??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ ; `string'
PUBLIC	PyLong_AsSsize_t
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsSsize_t DD imagerel $LN17
	DD	imagerel $LN17+431
	DD	imagerel $unwind$PyLong_AsSsize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsSsize_t DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0CN@MNHJJIBL@Python?5int?5too?5large?5to?5convert?5@
CONST	SEGMENT
??_C@_0CN@MNHJJIBL@Python?5int?5too?5large?5to?5convert?5@ DB 'Python int'
	DB	' too large to convert to C ssize_t', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
CONST	SEGMENT
??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ DB 'an integer is requi'
	DB	'red', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLong_AsSsize_t
_TEXT	SEGMENT
v$ = 32
x$ = 40
i$ = 48
prev$ = 56
sign$ = 64
tv74 = 72
vv$ = 96
PyLong_AsSsize_t PROC					; COMDAT

; 489  : PyLong_AsSsize_t(PyObject *vv) {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 490  :     register PyLongObject *v;
; 491  :     size_t x, prev;
; 492  :     Py_ssize_t i;
; 493  :     int sign;
; 494  : 
; 495  :     if (vv == NULL) {

  00009	48 83 7c 24 60
	00		 cmp	 QWORD PTR vv$[rsp], 0
  0000f	75 1d		 jne	 SHORT $LN14@PyLong_AsS

; 496  :         PyErr_BadInternalCall();

  00011	ba f0 01 00 00	 mov	 edx, 496		; 000001f0H
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0001d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 497  :         return -1;

  00022	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00029	e9 7c 01 00 00	 jmp	 $LN15@PyLong_AsS
$LN14@PyLong_AsS:

; 498  :     }
; 499  :     if (!PyLong_Check(vv)) {

  0002e	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  00033	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00037	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00042	85 c0		 test	 eax, eax
  00044	75 1f		 jne	 SHORT $LN13@PyLong_AsS

; 500  :         PyErr_SetString(PyExc_TypeError, "an integer is required");

  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00054	e8 00 00 00 00	 call	 PyErr_SetString

; 501  :         return -1;

  00059	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00060	e9 45 01 00 00	 jmp	 $LN15@PyLong_AsS
$LN13@PyLong_AsS:

; 502  :     }
; 503  : 
; 504  :     v = (PyLongObject *)vv;

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  0006a	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 505  :     i = Py_SIZE(v);

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00074	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00078	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 506  :     switch (i) {

  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00082	48 89 44 24 48	 mov	 QWORD PTR tv74[rsp], rax
  00087	48 83 7c 24 48
	ff		 cmp	 QWORD PTR tv74[rsp], -1
  0008d	74 12		 je	 SHORT $LN10@PyLong_AsS
  0008f	48 83 7c 24 48
	00		 cmp	 QWORD PTR tv74[rsp], 0
  00095	74 1b		 je	 SHORT $LN9@PyLong_AsS
  00097	48 83 7c 24 48
	01		 cmp	 QWORD PTR tv74[rsp], 1
  0009d	74 1a		 je	 SHORT $LN8@PyLong_AsS
  0009f	eb 25		 jmp	 SHORT $LN11@PyLong_AsS
$LN10@PyLong_AsS:

; 507  :     case -1: return -(sdigit)v->ob_digit[0];

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  000a6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000a9	f7 d8		 neg	 eax
  000ab	48 98		 cdqe
  000ad	e9 f8 00 00 00	 jmp	 $LN15@PyLong_AsS
$LN9@PyLong_AsS:

; 508  :     case 0: return 0;

  000b2	33 c0		 xor	 eax, eax
  000b4	e9 f1 00 00 00	 jmp	 $LN15@PyLong_AsS
$LN8@PyLong_AsS:

; 509  :     case 1: return v->ob_digit[0];

  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  000be	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000c1	e9 e4 00 00 00	 jmp	 $LN15@PyLong_AsS
$LN11@PyLong_AsS:

; 510  :     }
; 511  :     sign = 1;

  000c6	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1

; 512  :     x = 0;

  000ce	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 513  :     if (i < 0) {

  000d7	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  000dd	7d 15		 jge	 SHORT $LN7@PyLong_AsS

; 514  :         sign = -1;

  000df	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR sign$[rsp], -1

; 515  :         i = -(i);

  000e7	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000ec	48 f7 d8	 neg	 rax
  000ef	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN7@PyLong_AsS:
$LN6@PyLong_AsS:

; 516  :     }
; 517  :     while (--i >= 0) {

  000f4	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000f9	48 ff c8	 dec	 rax
  000fc	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  00101	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  00107	7c 3d		 jl	 SHORT $LN5@PyLong_AsS

; 518  :         prev = x;

  00109	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  0010e	48 89 44 24 38	 mov	 QWORD PTR prev$[rsp], rax

; 519  :         x = (x << PyLong_SHIFT) | v->ob_digit[i];

  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  00118	48 c1 e0 1e	 shl	 rax, 30
  0011c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00121	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  00126	8b 4c 91 70	 mov	 ecx, DWORD PTR [rcx+rdx*4+112]
  0012a	48 0b c1	 or	 rax, rcx
  0012d	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax

; 520  :         if ((x >> PyLong_SHIFT) != prev)

  00132	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  00137	48 c1 e8 1e	 shr	 rax, 30
  0013b	48 3b 44 24 38	 cmp	 rax, QWORD PTR prev$[rsp]
  00140	74 02		 je	 SHORT $LN4@PyLong_AsS

; 521  :             goto overflow;

  00142	eb 4c		 jmp	 SHORT $overflow$20613
$LN4@PyLong_AsS:

; 522  :     }

  00144	eb ae		 jmp	 SHORT $LN6@PyLong_AsS
$LN5@PyLong_AsS:

; 523  :     /* Haven't lost any bits, but casting to a signed type requires
; 524  :      * extra care (see comment above).
; 525  :      */
; 526  :     if (x <= (size_t)PY_SSIZE_T_MAX) {

  00146	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00150	48 39 44 24 28	 cmp	 QWORD PTR x$[rsp], rax
  00155	77 15		 ja	 SHORT $LN3@PyLong_AsS

; 527  :         return (Py_ssize_t)x * sign;

  00157	48 63 44 24 40	 movsxd	 rax, DWORD PTR sign$[rsp]
  0015c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  00161	48 0f af c8	 imul	 rcx, rax
  00165	48 8b c1	 mov	 rax, rcx
  00168	eb 40		 jmp	 SHORT $LN15@PyLong_AsS
  0016a	eb 24		 jmp	 SHORT $LN2@PyLong_AsS
$LN3@PyLong_AsS:

; 528  :     }
; 529  :     else if (sign < 0 && x == PY_ABS_SSIZE_T_MIN) {

  0016c	83 7c 24 40 00	 cmp	 DWORD PTR sign$[rsp], 0
  00171	7d 1d		 jge	 SHORT $LN1@PyLong_AsS
  00173	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0017d	48 39 44 24 28	 cmp	 QWORD PTR x$[rsp], rax
  00182	75 0c		 jne	 SHORT $LN1@PyLong_AsS

; 530  :         return PY_SSIZE_T_MIN;

  00184	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0018e	eb 1a		 jmp	 SHORT $LN15@PyLong_AsS
$LN1@PyLong_AsS:
$LN2@PyLong_AsS:
$overflow$20613:

; 531  :     }
; 532  :     /* else overflow */
; 533  : 
; 534  :   overflow:
; 535  :     PyErr_SetString(PyExc_OverflowError,
; 536  :                     "Python int too large to convert to C ssize_t");

  00190	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@MNHJJIBL@Python?5int?5too?5large?5to?5convert?5@
  00197	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0019e	e8 00 00 00 00	 call	 PyErr_SetString

; 537  :     return -1;

  001a3	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN15@PyLong_AsS:

; 538  : }

  001aa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ae	c3		 ret	 0
PyLong_AsSsize_t ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@FEJEGDLF@python?5int?5too?5large?5to?5convert?5@ ; `string'
PUBLIC	??_C@_0CN@MPCGIGO@can?8t?5convert?5negative?5value?5to?5@ ; `string'
PUBLIC	PyLong_AsUnsignedLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsUnsignedLong DD imagerel $LN13
	DD	imagerel $LN13+312
	DD	imagerel $unwind$PyLong_AsUnsignedLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsUnsignedLong DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0DD@FEJEGDLF@python?5int?5too?5large?5to?5convert?5@
CONST	SEGMENT
??_C@_0DD@FEJEGDLF@python?5int?5too?5large?5to?5convert?5@ DB 'python int'
	DB	' too large to convert to C unsigned long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MPCGIGO@can?8t?5convert?5negative?5value?5to?5@
CONST	SEGMENT
??_C@_0CN@MPCGIGO@can?8t?5convert?5negative?5value?5to?5@ DB 'can''t conv'
	DB	'ert negative value to unsigned int', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLong_AsUnsignedLong
_TEXT	SEGMENT
v$ = 32
x$ = 40
i$ = 48
prev$ = 56
tv77 = 64
vv$ = 96
PyLong_AsUnsignedLong PROC				; COMDAT

; 545  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 546  :     register PyLongObject *v;
; 547  :     unsigned long x, prev;
; 548  :     Py_ssize_t i;
; 549  : 
; 550  :     if (vv == NULL) {

  00009	48 83 7c 24 60
	00		 cmp	 QWORD PTR vv$[rsp], 0
  0000f	75 1b		 jne	 SHORT $LN10@PyLong_AsU

; 551  :         PyErr_BadInternalCall();

  00011	ba 27 02 00 00	 mov	 edx, 551		; 00000227H
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0001d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 552  :         return (unsigned long)-1;

  00022	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00027	e9 07 01 00 00	 jmp	 $LN11@PyLong_AsU
$LN10@PyLong_AsU:

; 553  :     }
; 554  :     if (!PyLong_Check(vv)) {

  0002c	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  00031	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00035	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003b	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00040	85 c0		 test	 eax, eax
  00042	75 1d		 jne	 SHORT $LN9@PyLong_AsU

; 555  :         PyErr_SetString(PyExc_TypeError, "an integer is required");

  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00052	e8 00 00 00 00	 call	 PyErr_SetString

; 556  :         return (unsigned long)-1;

  00057	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0005c	e9 d2 00 00 00	 jmp	 $LN11@PyLong_AsU
$LN9@PyLong_AsU:

; 557  :     }
; 558  : 
; 559  :     v = (PyLongObject *)vv;

  00061	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  00066	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 560  :     i = Py_SIZE(v);

  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00070	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00074	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 561  :     x = 0;

  00079	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR x$[rsp], 0

; 562  :     if (i < 0) {

  00081	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  00087	7d 1d		 jge	 SHORT $LN8@PyLong_AsU

; 563  :         PyErr_SetString(PyExc_OverflowError,
; 564  :                         "can't convert negative value to unsigned int");

  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@MPCGIGO@can?8t?5convert?5negative?5value?5to?5@
  00090	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00097	e8 00 00 00 00	 call	 PyErr_SetString

; 565  :         return (unsigned long) -1;

  0009c	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  000a1	e9 8d 00 00 00	 jmp	 $LN11@PyLong_AsU
$LN8@PyLong_AsU:

; 566  :     }
; 567  :     switch (i) {

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000ab	48 89 44 24 40	 mov	 QWORD PTR tv77[rsp], rax
  000b0	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv77[rsp], 0
  000b6	74 0a		 je	 SHORT $LN5@PyLong_AsU
  000b8	48 83 7c 24 40
	01		 cmp	 QWORD PTR tv77[rsp], 1
  000be	74 06		 je	 SHORT $LN4@PyLong_AsU
  000c0	eb 0e		 jmp	 SHORT $LN6@PyLong_AsU
$LN5@PyLong_AsU:

; 568  :     case 0: return 0;

  000c2	33 c0		 xor	 eax, eax
  000c4	eb 6d		 jmp	 SHORT $LN11@PyLong_AsU
$LN4@PyLong_AsU:

; 569  :     case 1: return v->ob_digit[0];

  000c6	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  000cb	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000ce	eb 63		 jmp	 SHORT $LN11@PyLong_AsU
$LN6@PyLong_AsU:
$LN3@PyLong_AsU:

; 570  :     }
; 571  :     while (--i >= 0) {

  000d0	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000d5	48 ff c8	 dec	 rax
  000d8	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  000dd	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  000e3	7c 4a		 jl	 SHORT $LN2@PyLong_AsU

; 572  :         prev = x;

  000e5	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
  000e9	89 44 24 38	 mov	 DWORD PTR prev$[rsp], eax

; 573  :         x = (x << PyLong_SHIFT) | v->ob_digit[i];

  000ed	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
  000f1	c1 e0 1e	 shl	 eax, 30
  000f4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  000f9	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  000fe	0b 44 91 70	 or	 eax, DWORD PTR [rcx+rdx*4+112]
  00102	89 44 24 28	 mov	 DWORD PTR x$[rsp], eax

; 574  :         if ((x >> PyLong_SHIFT) != prev) {

  00106	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
  0010a	c1 e8 1e	 shr	 eax, 30
  0010d	3b 44 24 38	 cmp	 eax, DWORD PTR prev$[rsp]
  00111	74 1a		 je	 SHORT $LN1@PyLong_AsU

; 575  :             PyErr_SetString(PyExc_OverflowError,
; 576  :                             "python int too large to convert "
; 577  :                             "to C unsigned long");

  00113	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@FEJEGDLF@python?5int?5too?5large?5to?5convert?5@
  0011a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00121	e8 00 00 00 00	 call	 PyErr_SetString

; 578  :             return (unsigned long) -1;

  00126	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0012b	eb 06		 jmp	 SHORT $LN11@PyLong_AsU
$LN1@PyLong_AsU:

; 579  :         }
; 580  :     }

  0012d	eb a1		 jmp	 SHORT $LN3@PyLong_AsU
$LN2@PyLong_AsU:

; 581  :     return x;

  0012f	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
$LN11@PyLong_AsU:

; 582  : }

  00133	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00137	c3		 ret	 0
PyLong_AsUnsignedLong ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@CLANCLJJ@Python?5int?5too?5large?5to?5convert?5@ ; `string'
PUBLIC	??_C@_0CH@MBHBMDDI@can?8t?5convert?5negative?5value?5to?5@ ; `string'
PUBLIC	PyLong_AsSize_t
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsSize_t DD imagerel $LN13
	DD	imagerel $LN13+333
	DD	imagerel $unwind$PyLong_AsSize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsSize_t DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0CM@CLANCLJJ@Python?5int?5too?5large?5to?5convert?5@
CONST	SEGMENT
??_C@_0CM@CLANCLJJ@Python?5int?5too?5large?5to?5convert?5@ DB 'Python int'
	DB	' too large to convert to C size_t', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MBHBMDDI@can?8t?5convert?5negative?5value?5to?5@
CONST	SEGMENT
??_C@_0CH@MBHBMDDI@can?8t?5convert?5negative?5value?5to?5@ DB 'can''t con'
	DB	'vert negative value to size_t', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLong_AsSize_t
_TEXT	SEGMENT
v$ = 32
x$ = 40
i$ = 48
prev$ = 56
tv77 = 64
vv$ = 96
PyLong_AsSize_t PROC					; COMDAT

; 589  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 590  :     register PyLongObject *v;
; 591  :     size_t x, prev;
; 592  :     Py_ssize_t i;
; 593  : 
; 594  :     if (vv == NULL) {

  00009	48 83 7c 24 60
	00		 cmp	 QWORD PTR vv$[rsp], 0
  0000f	75 1d		 jne	 SHORT $LN10@PyLong_AsS@2

; 595  :         PyErr_BadInternalCall();

  00011	ba 53 02 00 00	 mov	 edx, 595		; 00000253H
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0001d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 596  :         return (size_t) -1;

  00022	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00029	e9 1a 01 00 00	 jmp	 $LN11@PyLong_AsS@2
$LN10@PyLong_AsS@2:

; 597  :     }
; 598  :     if (!PyLong_Check(vv)) {

  0002e	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  00033	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00037	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00042	85 c0		 test	 eax, eax
  00044	75 1f		 jne	 SHORT $LN9@PyLong_AsS@2

; 599  :         PyErr_SetString(PyExc_TypeError, "an integer is required");

  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00054	e8 00 00 00 00	 call	 PyErr_SetString

; 600  :         return (size_t)-1;

  00059	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00060	e9 e3 00 00 00	 jmp	 $LN11@PyLong_AsS@2
$LN9@PyLong_AsS@2:

; 601  :     }
; 602  : 
; 603  :     v = (PyLongObject *)vv;

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  0006a	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 604  :     i = Py_SIZE(v);

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00074	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00078	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 605  :     x = 0;

  0007d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 606  :     if (i < 0) {

  00086	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  0008c	7d 1f		 jge	 SHORT $LN8@PyLong_AsS@2

; 607  :         PyErr_SetString(PyExc_OverflowError,
; 608  :                    "can't convert negative value to size_t");

  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@MBHBMDDI@can?8t?5convert?5negative?5value?5to?5@
  00095	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0009c	e8 00 00 00 00	 call	 PyErr_SetString

; 609  :         return (size_t) -1;

  000a1	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000a8	e9 9b 00 00 00	 jmp	 $LN11@PyLong_AsS@2
$LN8@PyLong_AsS@2:

; 610  :     }
; 611  :     switch (i) {

  000ad	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000b2	48 89 44 24 40	 mov	 QWORD PTR tv77[rsp], rax
  000b7	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv77[rsp], 0
  000bd	74 0a		 je	 SHORT $LN5@PyLong_AsS@2
  000bf	48 83 7c 24 40
	01		 cmp	 QWORD PTR tv77[rsp], 1
  000c5	74 06		 je	 SHORT $LN4@PyLong_AsS@2
  000c7	eb 0e		 jmp	 SHORT $LN6@PyLong_AsS@2
$LN5@PyLong_AsS@2:

; 612  :     case 0: return 0;

  000c9	33 c0		 xor	 eax, eax
  000cb	eb 7b		 jmp	 SHORT $LN11@PyLong_AsS@2
$LN4@PyLong_AsS@2:

; 613  :     case 1: return v->ob_digit[0];

  000cd	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  000d2	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000d5	eb 71		 jmp	 SHORT $LN11@PyLong_AsS@2
$LN6@PyLong_AsS@2:
$LN3@PyLong_AsS@2:

; 614  :     }
; 615  :     while (--i >= 0) {

  000d7	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000dc	48 ff c8	 dec	 rax
  000df	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  000e4	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  000ea	7c 57		 jl	 SHORT $LN2@PyLong_AsS@2

; 616  :         prev = x;

  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  000f1	48 89 44 24 38	 mov	 QWORD PTR prev$[rsp], rax

; 617  :         x = (x << PyLong_SHIFT) | v->ob_digit[i];

  000f6	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  000fb	48 c1 e0 1e	 shl	 rax, 30
  000ff	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00104	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  00109	8b 4c 91 70	 mov	 ecx, DWORD PTR [rcx+rdx*4+112]
  0010d	48 0b c1	 or	 rax, rcx
  00110	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax

; 618  :         if ((x >> PyLong_SHIFT) != prev) {

  00115	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  0011a	48 c1 e8 1e	 shr	 rax, 30
  0011e	48 3b 44 24 38	 cmp	 rax, QWORD PTR prev$[rsp]
  00123	74 1c		 je	 SHORT $LN1@PyLong_AsS@2

; 619  :             PyErr_SetString(PyExc_OverflowError,
; 620  :                 "Python int too large to convert to C size_t");

  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@CLANCLJJ@Python?5int?5too?5large?5to?5convert?5@
  0012c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00133	e8 00 00 00 00	 call	 PyErr_SetString

; 621  :             return (size_t) -1;

  00138	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0013f	eb 07		 jmp	 SHORT $LN11@PyLong_AsS@2
$LN1@PyLong_AsS@2:

; 622  :         }
; 623  :     }

  00141	eb 94		 jmp	 SHORT $LN3@PyLong_AsS@2
$LN2@PyLong_AsS@2:

; 624  :     return x;

  00143	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
$LN11@PyLong_AsS@2:

; 625  : }

  00148	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0014c	c3		 ret	 0
PyLong_AsSize_t ENDP
_TEXT	ENDS
PUBLIC	PyLong_AsUnsignedLongMask
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsUnsignedLongMask DD imagerel $LN6
	DD	imagerel $LN6+140
	DD	imagerel $unwind$PyLong_AsUnsignedLongMask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsUnsignedLongMask DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_AsUnsignedLongMask
_TEXT	SEGMENT
lo$ = 32
val$ = 40
op$ = 64
PyLong_AsUnsignedLongMask PROC				; COMDAT

; 662  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 663  :     PyLongObject *lo;
; 664  :     unsigned long val;
; 665  : 
; 666  :     if (op == NULL) {

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR op$[rsp], 0
  0000f	75 18		 jne	 SHORT $LN3@PyLong_AsU@2

; 667  :         PyErr_BadInternalCall();

  00011	ba 9b 02 00 00	 mov	 edx, 667		; 0000029bH
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0001d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 668  :         return (unsigned long)-1;

  00022	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00027	eb 5e		 jmp	 SHORT $LN4@PyLong_AsU@2
$LN3@PyLong_AsU@2:

; 669  :     }
; 670  : 
; 671  :     if (PyLong_Check(op)) {

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0002e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00032	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00038	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003d	85 c0		 test	 eax, eax
  0003f	74 0c		 je	 SHORT $LN2@PyLong_AsU@2

; 672  :         return _PyLong_AsUnsignedLongMask(op);

  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00046	e8 00 00 00 00	 call	 _PyLong_AsUnsignedLongMask
  0004b	eb 3a		 jmp	 SHORT $LN4@PyLong_AsU@2
$LN2@PyLong_AsU@2:

; 673  :     }
; 674  : 
; 675  :     lo = _PyLong_FromNbInt(op);

  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00052	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00057	48 89 44 24 20	 mov	 QWORD PTR lo$[rsp], rax

; 676  :     if (lo == NULL)

  0005c	48 83 7c 24 20
	00		 cmp	 QWORD PTR lo$[rsp], 0
  00062	75 07		 jne	 SHORT $LN1@PyLong_AsU@2

; 677  :         return (unsigned long)-1;

  00064	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00069	eb 1c		 jmp	 SHORT $LN4@PyLong_AsU@2
$LN1@PyLong_AsU@2:

; 678  : 
; 679  :     val = _PyLong_AsUnsignedLongMask((PyObject *)lo);

  0006b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lo$[rsp]
  00070	e8 00 00 00 00	 call	 _PyLong_AsUnsignedLongMask
  00075	89 44 24 28	 mov	 DWORD PTR val$[rsp], eax

; 680  :     Py_DECREF(lo);

  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lo$[rsp]
  0007e	e8 00 00 00 00	 call	 _Py_DecRef

; 681  :     return val;

  00083	8b 44 24 28	 mov	 eax, DWORD PTR val$[rsp]
$LN4@PyLong_AsU@2:

; 682  : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
PyLong_AsUnsignedLongMask ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_AsUnsignedLongMask DD imagerel _PyLong_AsUnsignedLongMask
	DD	imagerel _PyLong_AsUnsignedLongMask+241
	DD	imagerel $unwind$_PyLong_AsUnsignedLongMask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_AsUnsignedLongMask DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyLong_AsUnsignedLongMask
_TEXT	SEGMENT
v$ = 32
x$ = 40
i$ = 48
sign$ = 56
tv72 = 64
vv$ = 96
_PyLong_AsUnsignedLongMask PROC				; COMDAT

; 632  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 633  :     register PyLongObject *v;
; 634  :     unsigned long x;
; 635  :     Py_ssize_t i;
; 636  :     int sign;
; 637  : 
; 638  :     if (vv == NULL || !PyLong_Check(vv)) {

  00009	48 83 7c 24 60
	00		 cmp	 QWORD PTR vv$[rsp], 0
  0000f	74 18		 je	 SHORT $LN8@PyLong_AsU@3
  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  00016	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00020	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00025	85 c0		 test	 eax, eax
  00027	75 1b		 jne	 SHORT $LN9@PyLong_AsU@3
$LN8@PyLong_AsU@3:

; 639  :         PyErr_BadInternalCall();

  00029	ba 7f 02 00 00	 mov	 edx, 639		; 0000027fH
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00035	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 640  :         return (unsigned long) -1;

  0003a	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0003f	e9 a8 00 00 00	 jmp	 $LN10@PyLong_AsU@3
$LN9@PyLong_AsU@3:

; 641  :     }
; 642  :     v = (PyLongObject *)vv;

  00044	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  00049	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 643  :     i = Py_SIZE(v);

  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00053	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00057	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 644  :     switch (i) {

  0005c	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00061	48 89 44 24 40	 mov	 QWORD PTR tv72[rsp], rax
  00066	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv72[rsp], 0
  0006c	74 0a		 je	 SHORT $LN5@PyLong_AsU@3
  0006e	48 83 7c 24 40
	01		 cmp	 QWORD PTR tv72[rsp], 1
  00074	74 06		 je	 SHORT $LN4@PyLong_AsU@3
  00076	eb 0e		 jmp	 SHORT $LN6@PyLong_AsU@3
$LN5@PyLong_AsU@3:

; 645  :     case 0: return 0;

  00078	33 c0		 xor	 eax, eax
  0007a	eb 70		 jmp	 SHORT $LN10@PyLong_AsU@3
$LN4@PyLong_AsU@3:

; 646  :     case 1: return v->ob_digit[0];

  0007c	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00081	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00084	eb 66		 jmp	 SHORT $LN10@PyLong_AsU@3
$LN6@PyLong_AsU@3:

; 647  :     }
; 648  :     sign = 1;

  00086	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1

; 649  :     x = 0;

  0008e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR x$[rsp], 0

; 650  :     if (i < 0) {

  00096	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  0009c	7d 15		 jge	 SHORT $LN3@PyLong_AsU@3

; 651  :         sign = -1;

  0009e	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR sign$[rsp], -1

; 652  :         i = -i;

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000ab	48 f7 d8	 neg	 rax
  000ae	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN3@PyLong_AsU@3:
$LN2@PyLong_AsU@3:

; 653  :     }
; 654  :     while (--i >= 0) {

  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000b8	48 ff c8	 dec	 rax
  000bb	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  000c0	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  000c6	7c 1b		 jl	 SHORT $LN1@PyLong_AsU@3

; 655  :         x = (x << PyLong_SHIFT) | v->ob_digit[i];

  000c8	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
  000cc	c1 e0 1e	 shl	 eax, 30
  000cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  000d4	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  000d9	0b 44 91 70	 or	 eax, DWORD PTR [rcx+rdx*4+112]
  000dd	89 44 24 28	 mov	 DWORD PTR x$[rsp], eax

; 656  :     }

  000e1	eb d0		 jmp	 SHORT $LN2@PyLong_AsU@3
$LN1@PyLong_AsU@3:

; 657  :     return x * sign;

  000e3	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
  000e7	0f af 44 24 38	 imul	 eax, DWORD PTR sign$[rsp]
$LN10@PyLong_AsU@3:

; 658  : }

  000ec	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f0	c3		 ret	 0
_PyLong_AsUnsignedLongMask ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	_PyLong_Sign
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_Sign DD imagerel $LN9
	DD	imagerel $LN9+176
	DD	imagerel $unwind$_PyLong_Sign
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_Sign DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'v'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'v'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_Sign
_TEXT	SEGMENT
v$ = 32
tv82 = 40
tv81 = 44
vv$ = 64
_PyLong_Sign PROC					; COMDAT

; 686  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 687  :     PyLongObject *v = (PyLongObject *)vv;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR vv$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 688  : 
; 689  :     assert(v != NULL);

  00013	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00019	75 1c		 jne	 SHORT $LN3@PyLong_Sig
  0001b	41 b8 b1 02 00
	00		 mov	 r8d, 689		; 000002b1H
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00035	33 c0		 xor	 eax, eax
$LN3@PyLong_Sig:

; 690  :     assert(PyLong_Check(v));

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  0003c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00040	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00046	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0004b	85 c0		 test	 eax, eax
  0004d	75 1c		 jne	 SHORT $LN4@PyLong_Sig
  0004f	41 b8 b2 02 00
	00		 mov	 r8d, 690		; 000002b2H
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00069	33 c0		 xor	 eax, eax
$LN4@PyLong_Sig:

; 691  : 
; 692  :     return Py_SIZE(v) == 0 ? 0 : (Py_SIZE(v) < 0 ? -1 : 1);

  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00070	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00075	75 0a		 jne	 SHORT $LN7@PyLong_Sig
  00077	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
  0007f	eb 26		 jmp	 SHORT $LN8@PyLong_Sig
$LN7@PyLong_Sig:
  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00086	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0008b	7d 0a		 jge	 SHORT $LN5@PyLong_Sig
  0008d	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR tv81[rsp], -1
  00095	eb 08		 jmp	 SHORT $LN6@PyLong_Sig
$LN5@PyLong_Sig:
  00097	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
$LN6@PyLong_Sig:
  0009f	8b 44 24 2c	 mov	 eax, DWORD PTR tv81[rsp]
  000a3	89 44 24 28	 mov	 DWORD PTR tv82[rsp], eax
$LN8@PyLong_Sig:
  000a7	8b 44 24 28	 mov	 eax, DWORD PTR tv82[rsp]

; 693  : }

  000ab	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000af	c3		 ret	 0
_PyLong_Sign ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@ICDEHKHP@int?5has?5too?5many?5bits?5to?5express@ ; `string'
PUBLIC	??_C@_1FM@BMOIEENO@?$AAn?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$FL?$AAn?$AAd?$AAi?$AAg@ ; `string'
PUBLIC	_PyLong_NumBits
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_NumBits DD imagerel $LN14
	DD	imagerel $LN14+370
	DD	imagerel $unwind$_PyLong_NumBits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_NumBits DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0DG@ICDEHKHP@int?5has?5too?5many?5bits?5to?5express@
CONST	SEGMENT
??_C@_0DG@ICDEHKHP@int?5has?5too?5many?5bits?5to?5express@ DB 'int has to'
	DB	'o many bits to express in a platform size_t', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FM@BMOIEENO@?$AAn?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$FL?$AAn?$AAd?$AAi?$AAg@
CONST	SEGMENT
??_C@_1FM@BMOIEENO@?$AAn?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$FL?$AAn?$AAd?$AAi?$AAg@ DB 'n'
	DB	00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, 'v', 00H, '-', 00H, '>', 00H, 'o', 00H
	DB	'b', 00H, '_', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't'
	DB	00H, '[', 00H, 'n', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, ' ', 00H, '-', 00H, ' ', 00H, '1', 00H, ']'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_NumBits
_TEXT	SEGMENT
v$ = 32
ndigits$ = 40
result$ = 48
msd$20757 = 56
tv82 = 64
vv$ = 96
_PyLong_NumBits PROC					; COMDAT

; 697  : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 698  :     PyLongObject *v = (PyLongObject *)vv;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 699  :     size_t result = 0;

  00013	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 700  :     Py_ssize_t ndigits;
; 701  : 
; 702  :     assert(v != NULL);

  0001c	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00022	75 1c		 jne	 SHORT $LN9@PyLong_Num
  00024	41 b8 be 02 00
	00		 mov	 r8d, 702		; 000002beH
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003e	33 c0		 xor	 eax, eax
$LN9@PyLong_Num:

; 703  :     assert(PyLong_Check(v));

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00045	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00049	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004f	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00054	85 c0		 test	 eax, eax
  00056	75 1c		 jne	 SHORT $LN10@PyLong_Num
  00058	41 b8 bf 02 00
	00		 mov	 r8d, 703		; 000002bfH
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00072	33 c0		 xor	 eax, eax
$LN10@PyLong_Num:

; 704  :     ndigits = ABS(Py_SIZE(v));

  00074	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00079	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0007e	7d 13		 jge	 SHORT $LN11@PyLong_Num
  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00085	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00089	48 f7 d8	 neg	 rax
  0008c	48 89 44 24 40	 mov	 QWORD PTR tv82[rsp], rax
  00091	eb 0e		 jmp	 SHORT $LN12@PyLong_Num
$LN11@PyLong_Num:
  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00098	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0009c	48 89 44 24 40	 mov	 QWORD PTR tv82[rsp], rax
$LN12@PyLong_Num:
  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR tv82[rsp]
  000a6	48 89 44 24 28	 mov	 QWORD PTR ndigits$[rsp], rax

; 705  :     assert(ndigits == 0 || v->ob_digit[ndigits - 1] != 0);

  000ab	48 83 7c 24 28
	00		 cmp	 QWORD PTR ndigits$[rsp], 0
  000b1	74 2d		 je	 SHORT $LN13@PyLong_Num
  000b3	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  000b8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ndigits$[rsp]
  000bd	83 7c 88 6c 00	 cmp	 DWORD PTR [rax+rcx*4+108], 0
  000c2	75 1c		 jne	 SHORT $LN13@PyLong_Num
  000c4	41 b8 c1 02 00
	00		 mov	 r8d, 705		; 000002c1H
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@BMOIEENO@?$AAn?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$FL?$AAn?$AAd?$AAi?$AAg@
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000de	33 c0		 xor	 eax, eax
$LN13@PyLong_Num:

; 706  :     if (ndigits > 0) {

  000e0	48 83 7c 24 28
	00		 cmp	 QWORD PTR ndigits$[rsp], 0
  000e6	7e 64		 jle	 SHORT $LN6@PyLong_Num

; 707  :         digit msd = v->ob_digit[ndigits - 1];

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  000ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ndigits$[rsp]
  000f2	8b 44 88 6c	 mov	 eax, DWORD PTR [rax+rcx*4+108]
  000f6	89 44 24 38	 mov	 DWORD PTR msd$20757[rsp], eax

; 708  :         if ((size_t)(ndigits - 1) > PY_SIZE_MAX / (size_t)PyLong_SHIFT)

  000fa	48 8b 44 24 28	 mov	 rax, QWORD PTR ndigits$[rsp]
  000ff	48 ff c8	 dec	 rax
  00102	48 b9 88 88 88
	88 88 88 88 08	 mov	 rcx, 614891469123651720	; 0888888888888888H
  0010c	48 3b c1	 cmp	 rax, rcx
  0010f	76 02		 jbe	 SHORT $LN5@PyLong_Num

; 709  :             goto Overflow;

  00111	eb 40		 jmp	 SHORT $Overflow$20761
$LN5@PyLong_Num:

; 710  :         result = (size_t)(ndigits - 1) * (size_t)PyLong_SHIFT;

  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR ndigits$[rsp]
  00118	48 ff c8	 dec	 rax
  0011b	48 6b c0 1e	 imul	 rax, 30
  0011f	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$LN4@PyLong_Num:

; 711  :         do {
; 712  :             ++result;

  00124	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  00129	48 ff c0	 inc	 rax
  0012c	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 713  :             if (result == 0)

  00131	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00137	75 02		 jne	 SHORT $LN1@PyLong_Num

; 714  :                 goto Overflow;

  00139	eb 18		 jmp	 SHORT $Overflow$20761
$LN1@PyLong_Num:

; 715  :             msd >>= 1;

  0013b	8b 44 24 38	 mov	 eax, DWORD PTR msd$20757[rsp]
  0013f	d1 e8		 shr	 eax, 1
  00141	89 44 24 38	 mov	 DWORD PTR msd$20757[rsp], eax

; 716  :         } while (msd);

  00145	83 7c 24 38 00	 cmp	 DWORD PTR msd$20757[rsp], 0
  0014a	75 d8		 jne	 SHORT $LN4@PyLong_Num
$LN6@PyLong_Num:

; 717  :     }
; 718  :     return result;

  0014c	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  00151	eb 1a		 jmp	 SHORT $LN7@PyLong_Num
$Overflow$20761:

; 719  : 
; 720  :   Overflow:
; 721  :     PyErr_SetString(PyExc_OverflowError, "int has too many bits "
; 722  :                     "to express in a platform size_t");

  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@ICDEHKHP@int?5has?5too?5many?5bits?5to?5express@
  0015a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00161	e8 00 00 00 00	 call	 PyErr_SetString

; 723  :     return (size_t)-1;

  00166	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN7@PyLong_Num:

; 724  : }

  0016d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00171	c3		 ret	 0
_PyLong_NumBits ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DC@JIKGJNGJ@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@MDCGJMOK@?$AAi?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?$DM?$AA?5?$AAn?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CG@IILJNAIE@byte?5array?5too?5long?5to?5convert?5t@ ; `string'
PUBLIC	_PyLong_FromByteArray
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_FromByteArray DD imagerel $LN30
	DD	imagerel $LN30+1187
	DD	imagerel $unwind$_PyLong_FromByteArray
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_FromByteArray DD 021b01H
	DD	019011bH
xdata	ENDS
;	COMDAT ??_C@_1DC@JIKGJNGJ@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@JIKGJNGJ@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@ DB 'a'
	DB	00H, 'c', 00H, 'c', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'P', 00H, 'y'
	DB	00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'S', 00H
	DB	'H', 00H, 'I', 00H, 'F', 00H, 'T', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@MDCGJMOK@?$AAi?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?$DM?$AA?5?$AAn?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MDCGJMOK@?$AAi?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?$DM?$AA?5?$AAn?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@ DB 'i'
	DB	00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 'n', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i'
	DB	00H, 't', 00H, 's', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IILJNAIE@byte?5array?5too?5long?5to?5convert?5t@
CONST	SEGMENT
??_C@_0CG@IILJNAIE@byte?5array?5too?5long?5to?5convert?5t@ DB 'byte array'
	DB	' too long to convert to int', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_FromByteArray
_TEXT	SEGMENT
v$ = 32
pstartbyte$ = 40
idigit$ = 48
pendbyte$ = 56
incr$ = 64
ndigits$ = 72
numsignificantbytes$ = 80
p$20791 = 88
insignficant$20793 = 96
i$20790 = 104
pincr$20792 = 112
p$20811 = 120
i$20807 = 128
accumbits$20810 = 136
accum$20809 = 144
carry$20808 = 152
thisbyte$20815 = 160
tv75 = 168
tv78 = 172
tv183 = 176
bytes$ = 208
n$ = 216
little_endian$ = 224
is_signed$ = 232
_PyLong_FromByteArray PROC				; COMDAT

; 729  : {

$LN30:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 730  :     const unsigned char* pstartbyte;    /* LSB of bytes */
; 731  :     int incr;                           /* direction to move pstartbyte */
; 732  :     const unsigned char* pendbyte;      /* MSB of bytes */
; 733  :     size_t numsignificantbytes;         /* number of bytes that matter */
; 734  :     Py_ssize_t ndigits;                 /* number of Python int digits */
; 735  :     PyLongObject* v;                    /* result */
; 736  :     Py_ssize_t idigit = 0;              /* next free index in v->ob_digit */

  0001b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR idigit$[rsp], 0

; 737  : 
; 738  :     if (n == 0)

  00024	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  0002d	75 0c		 jne	 SHORT $LN17@PyLong_Fro@5

; 739  :         return PyLong_FromLong(0L);

  0002f	33 c9		 xor	 ecx, ecx
  00031	e8 00 00 00 00	 call	 PyLong_FromLong
  00036	e9 60 04 00 00	 jmp	 $LN18@PyLong_Fro@5
$LN17@PyLong_Fro@5:

; 740  : 
; 741  :     if (little_endian) {

  0003b	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR little_endian$[rsp], 0
  00043	74 31		 je	 SHORT $LN16@PyLong_Fro@5

; 742  :         pstartbyte = bytes;

  00045	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR bytes$[rsp]
  0004d	48 89 44 24 28	 mov	 QWORD PTR pstartbyte$[rsp], rax

; 743  :         pendbyte = bytes + n - 1;

  00052	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR bytes$[rsp]
  0005a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00062	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00067	48 89 44 24 38	 mov	 QWORD PTR pendbyte$[rsp], rax

; 744  :         incr = 1;

  0006c	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR incr$[rsp], 1

; 745  :     }
; 746  :     else {

  00074	eb 2f		 jmp	 SHORT $LN15@PyLong_Fro@5
$LN16@PyLong_Fro@5:

; 747  :         pstartbyte = bytes + n - 1;

  00076	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR bytes$[rsp]
  0007e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00086	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  0008b	48 89 44 24 28	 mov	 QWORD PTR pstartbyte$[rsp], rax

; 748  :         pendbyte = bytes;

  00090	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR bytes$[rsp]
  00098	48 89 44 24 38	 mov	 QWORD PTR pendbyte$[rsp], rax

; 749  :         incr = -1;

  0009d	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR incr$[rsp], -1
$LN15@PyLong_Fro@5:

; 750  :     }
; 751  : 
; 752  :     if (is_signed)

  000a5	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR is_signed$[rsp], 0
  000ad	74 35		 je	 SHORT $LN14@PyLong_Fro@5

; 753  :         is_signed = *pendbyte >= 0x80;

  000af	48 8b 44 24 38	 mov	 rax, QWORD PTR pendbyte$[rsp]
  000b4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b7	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000bc	7c 0d		 jl	 SHORT $LN20@PyLong_Fro@5
  000be	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv75[rsp], 1
  000c9	eb 0b		 jmp	 SHORT $LN21@PyLong_Fro@5
$LN20@PyLong_Fro@5:
  000cb	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv75[rsp], 0
$LN21@PyLong_Fro@5:
  000d6	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv75[rsp]
  000dd	89 84 24 e8 00
	00 00		 mov	 DWORD PTR is_signed$[rsp], eax
$LN14@PyLong_Fro@5:

; 754  : 
; 755  :     /* Compute numsignificantbytes.  This consists of finding the most
; 756  :        significant byte.  Leading 0 bytes are insignificant if the number
; 757  :        is positive, and leading 0xff bytes if negative. */
; 758  :     {
; 759  :         size_t i;
; 760  :         const unsigned char* p = pendbyte;

  000e4	48 8b 44 24 38	 mov	 rax, QWORD PTR pendbyte$[rsp]
  000e9	48 89 44 24 58	 mov	 QWORD PTR p$20791[rsp], rax

; 761  :         const int pincr = -incr;  /* search MSB to LSB */

  000ee	8b 44 24 40	 mov	 eax, DWORD PTR incr$[rsp]
  000f2	f7 d8		 neg	 eax
  000f4	89 44 24 70	 mov	 DWORD PTR pincr$20792[rsp], eax

; 762  :         const unsigned char insignficant = is_signed ? 0xff : 0x00;

  000f8	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR is_signed$[rsp], 0
  00100	74 0d		 je	 SHORT $LN22@PyLong_Fro@5
  00102	c7 84 24 ac 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv78[rsp], 255 ; 000000ffH
  0010d	eb 0b		 jmp	 SHORT $LN23@PyLong_Fro@5
$LN22@PyLong_Fro@5:
  0010f	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv78[rsp], 0
$LN23@PyLong_Fro@5:
  0011a	0f b6 84 24 ac
	00 00 00	 movzx	 eax, BYTE PTR tv78[rsp]
  00122	88 44 24 60	 mov	 BYTE PTR insignficant$20793[rsp], al

; 763  : 
; 764  :         for (i = 0; i < n; ++i, p += pincr) {

  00126	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR i$20790[rsp], 0
  0012f	eb 22		 jmp	 SHORT $LN13@PyLong_Fro@5
$LN12@PyLong_Fro@5:
  00131	48 8b 44 24 68	 mov	 rax, QWORD PTR i$20790[rsp]
  00136	48 ff c0	 inc	 rax
  00139	48 89 44 24 68	 mov	 QWORD PTR i$20790[rsp], rax
  0013e	48 63 44 24 70	 movsxd	 rax, DWORD PTR pincr$20792[rsp]
  00143	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$20791[rsp]
  00148	48 03 c8	 add	 rcx, rax
  0014b	48 8b c1	 mov	 rax, rcx
  0014e	48 89 44 24 58	 mov	 QWORD PTR p$20791[rsp], rax
$LN13@PyLong_Fro@5:
  00153	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0015b	48 39 44 24 68	 cmp	 QWORD PTR i$20790[rsp], rax
  00160	73 15		 jae	 SHORT $LN11@PyLong_Fro@5

; 765  :             if (*p != insignficant)

  00162	48 8b 44 24 58	 mov	 rax, QWORD PTR p$20791[rsp]
  00167	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0016a	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR insignficant$20793[rsp]
  0016f	3b c1		 cmp	 eax, ecx
  00171	74 02		 je	 SHORT $LN10@PyLong_Fro@5

; 766  :                 break;

  00173	eb 02		 jmp	 SHORT $LN11@PyLong_Fro@5
$LN10@PyLong_Fro@5:

; 767  :         }

  00175	eb ba		 jmp	 SHORT $LN12@PyLong_Fro@5
$LN11@PyLong_Fro@5:

; 768  :         numsignificantbytes = n - i;

  00177	48 8b 44 24 68	 mov	 rax, QWORD PTR i$20790[rsp]
  0017c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00184	48 2b c8	 sub	 rcx, rax
  00187	48 8b c1	 mov	 rax, rcx
  0018a	48 89 44 24 50	 mov	 QWORD PTR numsignificantbytes$[rsp], rax

; 769  :         /* 2's-comp is a bit tricky here, e.g. 0xff00 == -0x0100, so
; 770  :            actually has 2 significant bytes.  OTOH, 0xff0001 ==
; 771  :            -0x00ffff, so we wouldn't *need* to bump it there; but we
; 772  :            do for 0xffff = -0x0001.  To be safe without bothering to
; 773  :            check every case, bump it regardless. */
; 774  :         if (is_signed && numsignificantbytes < n)

  0018f	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR is_signed$[rsp], 0
  00197	74 1c		 je	 SHORT $LN9@PyLong_Fro@5
  00199	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001a1	48 39 44 24 50	 cmp	 QWORD PTR numsignificantbytes$[rsp], rax
  001a6	73 0d		 jae	 SHORT $LN9@PyLong_Fro@5

; 775  :             ++numsignificantbytes;

  001a8	48 8b 44 24 50	 mov	 rax, QWORD PTR numsignificantbytes$[rsp]
  001ad	48 ff c0	 inc	 rax
  001b0	48 89 44 24 50	 mov	 QWORD PTR numsignificantbytes$[rsp], rax
$LN9@PyLong_Fro@5:

; 776  :     }
; 777  : 
; 778  :     /* How many Python int digits do we need?  We have
; 779  :        8*numsignificantbytes bits, and each Python int digit has
; 780  :        PyLong_SHIFT bits, so it's the ceiling of the quotient. */
; 781  :     /* catch overflow before it happens */
; 782  :     if (numsignificantbytes > (PY_SSIZE_T_MAX - PyLong_SHIFT) / 8) {

  001b5	48 b8 fc ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846972 ; 0ffffffffffffffcH
  001bf	48 39 44 24 50	 cmp	 QWORD PTR numsignificantbytes$[rsp], rax
  001c4	76 1a		 jbe	 SHORT $LN8@PyLong_Fro@5

; 783  :         PyErr_SetString(PyExc_OverflowError,
; 784  :                         "byte array too long to convert to int");

  001c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@IILJNAIE@byte?5array?5too?5long?5to?5convert?5t@
  001cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001d4	e8 00 00 00 00	 call	 PyErr_SetString

; 785  :         return NULL;

  001d9	33 c0		 xor	 eax, eax
  001db	e9 bb 02 00 00	 jmp	 $LN18@PyLong_Fro@5
$LN8@PyLong_Fro@5:

; 786  :     }
; 787  :     ndigits = (numsignificantbytes * 8 + PyLong_SHIFT - 1) / PyLong_SHIFT;

  001e0	48 8b 44 24 50	 mov	 rax, QWORD PTR numsignificantbytes$[rsp]
  001e5	48 8d 04 c5 1d
	00 00 00	 lea	 rax, QWORD PTR [rax*8+29]
  001ed	33 d2		 xor	 edx, edx
  001ef	b9 1e 00 00 00	 mov	 ecx, 30
  001f4	48 f7 f1	 div	 rcx
  001f7	48 89 44 24 48	 mov	 QWORD PTR ndigits$[rsp], rax

; 788  :     v = _PyLong_New(ndigits);

  001fc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ndigits$[rsp]
  00201	e8 00 00 00 00	 call	 _PyLong_New
  00206	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 789  :     if (v == NULL)

  0020b	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00211	75 07		 jne	 SHORT $LN7@PyLong_Fro@5

; 790  :         return NULL;

  00213	33 c0		 xor	 eax, eax
  00215	e9 81 02 00 00	 jmp	 $LN18@PyLong_Fro@5
$LN7@PyLong_Fro@5:

; 791  : 
; 792  :     /* Copy the bits over.  The tricky parts are computing 2's-comp on
; 793  :        the fly for signed numbers, and dealing with the mismatch between
; 794  :        8-bit bytes and (probably) 15-bit Python digits.*/
; 795  :     {
; 796  :         size_t i;
; 797  :         twodigits carry = 1;                    /* for 2's-comp calculation */

  0021a	48 c7 84 24 98
	00 00 00 01 00
	00 00		 mov	 QWORD PTR carry$20808[rsp], 1

; 798  :         twodigits accum = 0;                    /* sliding register */

  00226	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR accum$20809[rsp], 0

; 799  :         unsigned int accumbits = 0;             /* number of bits in accum */

  00232	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR accumbits$20810[rsp], 0

; 800  :         const unsigned char* p = pstartbyte;

  0023d	48 8b 44 24 28	 mov	 rax, QWORD PTR pstartbyte$[rsp]
  00242	48 89 44 24 78	 mov	 QWORD PTR p$20811[rsp], rax

; 801  : 
; 802  :         for (i = 0; i < numsignificantbytes; ++i, p += incr) {

  00247	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$20807[rsp], 0
  00253	eb 28		 jmp	 SHORT $LN6@PyLong_Fro@5
$LN5@PyLong_Fro@5:
  00255	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR i$20807[rsp]
  0025d	48 ff c0	 inc	 rax
  00260	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR i$20807[rsp], rax
  00268	48 63 44 24 40	 movsxd	 rax, DWORD PTR incr$[rsp]
  0026d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$20811[rsp]
  00272	48 03 c8	 add	 rcx, rax
  00275	48 8b c1	 mov	 rax, rcx
  00278	48 89 44 24 78	 mov	 QWORD PTR p$20811[rsp], rax
$LN6@PyLong_Fro@5:
  0027d	48 8b 44 24 50	 mov	 rax, QWORD PTR numsignificantbytes$[rsp]
  00282	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR i$20807[rsp], rax
  0028a	0f 83 4d 01 00
	00		 jae	 $LN4@PyLong_Fro@5

; 803  :             twodigits thisbyte = *p;

  00290	48 8b 44 24 78	 mov	 rax, QWORD PTR p$20811[rsp]
  00295	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00298	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR thisbyte$20815[rsp], rax

; 804  :             /* Compute correction for 2's comp, if needed. */
; 805  :             if (is_signed) {

  002a0	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR is_signed$[rsp], 0
  002a8	74 48		 je	 SHORT $LN3@PyLong_Fro@5

; 806  :                 thisbyte = (0xff ^ thisbyte) + carry;

  002aa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR thisbyte$20815[rsp]
  002b2	48 35 ff 00 00
	00		 xor	 rax, 255		; 000000ffH
  002b8	48 03 84 24 98
	00 00 00	 add	 rax, QWORD PTR carry$20808[rsp]
  002c0	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR thisbyte$20815[rsp], rax

; 807  :                 carry = thisbyte >> 8;

  002c8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR thisbyte$20815[rsp]
  002d0	48 c1 e8 08	 shr	 rax, 8
  002d4	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR carry$20808[rsp], rax

; 808  :                 thisbyte &= 0xff;

  002dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR thisbyte$20815[rsp]
  002e4	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  002ea	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR thisbyte$20815[rsp], rax
$LN3@PyLong_Fro@5:

; 809  :             }
; 810  :             /* Because we're going LSB to MSB, thisbyte is
; 811  :                more significant than what's already in accum,
; 812  :                so needs to be prepended to accum. */
; 813  :             accum |= (twodigits)thisbyte << accumbits;

  002f2	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR accumbits$20810[rsp]
  002f9	0f b6 c8	 movzx	 ecx, al
  002fc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR thisbyte$20815[rsp]
  00304	48 d3 e0	 shl	 rax, cl
  00307	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR accum$20809[rsp]
  0030f	48 0b c8	 or	 rcx, rax
  00312	48 8b c1	 mov	 rax, rcx
  00315	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR accum$20809[rsp], rax

; 814  :             accumbits += 8;

  0031d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR accumbits$20810[rsp]
  00324	83 c0 08	 add	 eax, 8
  00327	89 84 24 88 00
	00 00		 mov	 DWORD PTR accumbits$20810[rsp], eax

; 815  :             if (accumbits >= PyLong_SHIFT) {

  0032e	83 bc 24 88 00
	00 00 1e	 cmp	 DWORD PTR accumbits$20810[rsp], 30
  00336	0f 82 9c 00 00
	00		 jb	 $LN2@PyLong_Fro@5

; 816  :                 /* There's enough to fill a Python digit. */
; 817  :                 assert(idigit < ndigits);

  0033c	48 8b 44 24 48	 mov	 rax, QWORD PTR ndigits$[rsp]
  00341	48 39 44 24 30	 cmp	 QWORD PTR idigit$[rsp], rax
  00346	7c 1c		 jl	 SHORT $LN24@PyLong_Fro@5
  00348	41 b8 31 03 00
	00		 mov	 r8d, 817		; 00000331H
  0034e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00355	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MDCGJMOK@?$AAi?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?$DM?$AA?5?$AAn?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@
  0035c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00362	33 c0		 xor	 eax, eax
$LN24@PyLong_Fro@5:

; 818  :                 v->ob_digit[idigit] = (digit)(accum & PyLong_MASK);

  00364	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR accum$20809[rsp]
  0036c	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  00372	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00377	48 8b 54 24 30	 mov	 rdx, QWORD PTR idigit$[rsp]
  0037c	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax

; 819  :                 ++idigit;

  00380	48 8b 44 24 30	 mov	 rax, QWORD PTR idigit$[rsp]
  00385	48 ff c0	 inc	 rax
  00388	48 89 44 24 30	 mov	 QWORD PTR idigit$[rsp], rax

; 820  :                 accum >>= PyLong_SHIFT;

  0038d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR accum$20809[rsp]
  00395	48 c1 e8 1e	 shr	 rax, 30
  00399	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR accum$20809[rsp], rax

; 821  :                 accumbits -= PyLong_SHIFT;

  003a1	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR accumbits$20810[rsp]
  003a8	83 e8 1e	 sub	 eax, 30
  003ab	89 84 24 88 00
	00 00		 mov	 DWORD PTR accumbits$20810[rsp], eax

; 822  :                 assert(accumbits < PyLong_SHIFT);

  003b2	83 bc 24 88 00
	00 00 1e	 cmp	 DWORD PTR accumbits$20810[rsp], 30
  003ba	72 1c		 jb	 SHORT $LN25@PyLong_Fro@5
  003bc	41 b8 36 03 00
	00		 mov	 r8d, 822		; 00000336H
  003c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@JIKGJNGJ@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@
  003d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003d6	33 c0		 xor	 eax, eax
$LN25@PyLong_Fro@5:
$LN2@PyLong_Fro@5:

; 823  :             }
; 824  :         }

  003d8	e9 78 fe ff ff	 jmp	 $LN5@PyLong_Fro@5
$LN4@PyLong_Fro@5:

; 825  :         assert(accumbits < PyLong_SHIFT);

  003dd	83 bc 24 88 00
	00 00 1e	 cmp	 DWORD PTR accumbits$20810[rsp], 30
  003e5	72 1c		 jb	 SHORT $LN26@PyLong_Fro@5
  003e7	41 b8 39 03 00
	00		 mov	 r8d, 825		; 00000339H
  003ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@JIKGJNGJ@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00401	33 c0		 xor	 eax, eax
$LN26@PyLong_Fro@5:

; 826  :         if (accumbits) {

  00403	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR accumbits$20810[rsp], 0
  0040b	74 4a		 je	 SHORT $LN1@PyLong_Fro@5

; 827  :             assert(idigit < ndigits);

  0040d	48 8b 44 24 48	 mov	 rax, QWORD PTR ndigits$[rsp]
  00412	48 39 44 24 30	 cmp	 QWORD PTR idigit$[rsp], rax
  00417	7c 1c		 jl	 SHORT $LN27@PyLong_Fro@5
  00419	41 b8 3b 03 00
	00		 mov	 r8d, 827		; 0000033bH
  0041f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00426	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MDCGJMOK@?$AAi?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?$DM?$AA?5?$AAn?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@
  0042d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00433	33 c0		 xor	 eax, eax
$LN27@PyLong_Fro@5:

; 828  :             v->ob_digit[idigit] = (digit)accum;

  00435	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  0043a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idigit$[rsp]
  0043f	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR accum$20809[rsp]
  00446	89 54 88 70	 mov	 DWORD PTR [rax+rcx*4+112], edx

; 829  :             ++idigit;

  0044a	48 8b 44 24 30	 mov	 rax, QWORD PTR idigit$[rsp]
  0044f	48 ff c0	 inc	 rax
  00452	48 89 44 24 30	 mov	 QWORD PTR idigit$[rsp], rax
$LN1@PyLong_Fro@5:

; 830  :         }
; 831  :     }
; 832  : 
; 833  :     Py_SIZE(v) = is_signed ? -idigit : idigit;

  00457	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR is_signed$[rsp], 0
  0045f	74 12		 je	 SHORT $LN28@PyLong_Fro@5
  00461	48 8b 44 24 30	 mov	 rax, QWORD PTR idigit$[rsp]
  00466	48 f7 d8	 neg	 rax
  00469	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv183[rsp], rax
  00471	eb 0d		 jmp	 SHORT $LN29@PyLong_Fro@5
$LN28@PyLong_Fro@5:
  00473	48 8b 44 24 30	 mov	 rax, QWORD PTR idigit$[rsp]
  00478	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv183[rsp], rax
$LN29@PyLong_Fro@5:
  00480	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00485	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv183[rsp]
  0048d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 834  :     return (PyObject *)long_normalize(v);

  00491	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00496	e8 00 00 00 00	 call	 long_normalize
$LN18@PyLong_Fro@5:

; 835  : }

  0049b	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  004a2	c3		 ret	 0
_PyLong_FromByteArray ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_normalize DD imagerel long_normalize
	DD	imagerel long_normalize+179
	DD	imagerel $unwind$long_normalize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_normalize DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_normalize
_TEXT	SEGMENT
i$ = 0
j$ = 8
tv69 = 16
tv82 = 24
v$ = 48
long_normalize PROC					; COMDAT

; 108  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 109  :     Py_ssize_t j = ABS(Py_SIZE(v));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	7d 13		 jge	 SHORT $LN6@long_norma
  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0001a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001e	48 f7 d8	 neg	 rax
  00021	48 89 44 24 10	 mov	 QWORD PTR tv69[rsp], rax
  00026	eb 0e		 jmp	 SHORT $LN7@long_norma
$LN6@long_norma:
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0002d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00031	48 89 44 24 10	 mov	 QWORD PTR tv69[rsp], rax
$LN7@long_norma:
  00036	48 8b 44 24 10	 mov	 rax, QWORD PTR tv69[rsp]
  0003b	48 89 44 24 08	 mov	 QWORD PTR j$[rsp], rax

; 110  :     Py_ssize_t i = j;

  00040	48 8b 44 24 08	 mov	 rax, QWORD PTR j$[rsp]
  00045	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN3@long_norma:

; 111  : 
; 112  :     while (i > 0 && v->ob_digit[i-1] == 0)

  00049	48 83 3c 24 00	 cmp	 QWORD PTR i$[rsp], 0
  0004e	7e 1d		 jle	 SHORT $LN2@long_norma
  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  00055	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00059	83 7c 88 6c 00	 cmp	 DWORD PTR [rax+rcx*4+108], 0
  0005e	75 0d		 jne	 SHORT $LN2@long_norma

; 113  :         --i;

  00060	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00064	48 ff c8	 dec	 rax
  00067	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
  0006b	eb dc		 jmp	 SHORT $LN3@long_norma
$LN2@long_norma:

; 114  :     if (i != j)

  0006d	48 8b 44 24 08	 mov	 rax, QWORD PTR j$[rsp]
  00072	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  00076	74 31		 je	 SHORT $LN1@long_norma

; 115  :         Py_SIZE(v) = (Py_SIZE(v) < 0) ? -(i) : i;

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0007d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00082	7d 0e		 jge	 SHORT $LN8@long_norma
  00084	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00088	48 f7 d8	 neg	 rax
  0008b	48 89 44 24 18	 mov	 QWORD PTR tv82[rsp], rax
  00090	eb 09		 jmp	 SHORT $LN9@long_norma
$LN8@long_norma:
  00092	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00096	48 89 44 24 18	 mov	 QWORD PTR tv82[rsp], rax
$LN9@long_norma:
  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  000a0	48 8b 4c 24 18	 mov	 rcx, QWORD PTR tv82[rsp]
  000a5	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
$LN1@long_norma:

; 116  :     return v;

  000a9	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]

; 117  : }

  000ae	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b2	c3		 ret	 0
long_normalize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@KCBHMDHM@int?5too?5big?5to?5convert?$AA@ ; `string'
PUBLIC	??_C@_1BO@COLFMDIL@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@NKCMNFPP@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@CMHCCDBJ@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?5?$AA8?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CH@PHDOCLKE@can?8t?5convert?5negative?5int?5to?5un@ ; `string'
PUBLIC	??_C@_1DK@LBNDCCEL@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	_PyLong_AsByteArray
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_AsByteArray DD imagerel $LN43
	DD	imagerel $LN43+1254
	DD	imagerel $unwind$_PyLong_AsByteArray
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_AsByteArray DD 021b01H
	DD	013011bH
xdata	ENDS
;	COMDAT ??_C@_0BH@KCBHMDHM@int?5too?5big?5to?5convert?$AA@
CONST	SEGMENT
??_C@_0BH@KCBHMDHM@int?5too?5big?5to?5convert?$AA@ DB 'int too big to con'
	DB	'vert', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@COLFMDIL@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@COLFMDIL@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'a'
	DB	00H, 'c', 00H, 'c', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@NKCMNFPP@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@NKCMNFPP@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'c'
	DB	00H, 'a', 00H, 'r', 00H, 'r', 00H, 'y', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@CMHCCDBJ@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?5?$AA8?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@CMHCCDBJ@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?5?$AA8?$AA?$AA@ DB 'a'
	DB	00H, 'c', 00H, 'c', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, ' ', 00H, '<', 00H, ' ', 00H, '8', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PHDOCLKE@can?8t?5convert?5negative?5int?5to?5un@
CONST	SEGMENT
??_C@_0CH@PHDOCLKE@can?8t?5convert?5negative?5int?5to?5un@ DB 'can''t con'
	DB	'vert negative int to unsigned', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@LBNDCCEL@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@LBNDCCEL@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'v'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'v'
	DB	00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_AsByteArray
_TEXT	SEGMENT
p$ = 32
do_twos_comp$ = 40
i$ = 48
pincr$ = 56
accumbits$ = 60
carry$ = 64
accum$ = 72
ndigits$ = 80
j$ = 88
thisdigit$20869 = 96
s$20877 = 100
msb$20901 = 104
sign_bit_set$20902 = 108
signbyte$20907 = 112
tv95 = 116
tv145 = 120
tv252 = 128
tv186 = 136
tv194 = 140
v$ = 160
bytes$ = 168
n$ = 176
little_endian$ = 184
is_signed$ = 192
_PyLong_AsByteArray PROC				; COMDAT

; 841  : {

$LN43:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 842  :     Py_ssize_t i;               /* index into v->ob_digit */
; 843  :     Py_ssize_t ndigits;         /* |v->ob_size| */
; 844  :     twodigits accum;            /* sliding register */
; 845  :     unsigned int accumbits;     /* # bits in accum */
; 846  :     int do_twos_comp;           /* store 2's-comp?  is_signed and v < 0 */
; 847  :     digit carry;                /* for computing 2's-comp */
; 848  :     size_t j;                   /* # bytes filled */
; 849  :     unsigned char* p;           /* pointer to next byte in bytes */
; 850  :     int pincr;                  /* direction to move p */
; 851  : 
; 852  :     assert(v != NULL && PyLong_Check(v));

  0001b	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR v$[rsp], 0
  00024	74 1b		 je	 SHORT $LN29@PyLong_AsB
  00026	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0002e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00032	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00038	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003d	85 c0		 test	 eax, eax
  0003f	75 1c		 jne	 SHORT $LN30@PyLong_AsB
$LN29@PyLong_AsB:
  00041	41 b8 54 03 00
	00		 mov	 r8d, 852		; 00000354H
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@LBNDCCEL@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005b	33 c0		 xor	 eax, eax
$LN30@PyLong_AsB:

; 853  : 
; 854  :     if (Py_SIZE(v) < 0) {

  0005d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00065	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0006a	7d 45		 jge	 SHORT $LN26@PyLong_AsB

; 855  :         ndigits = -(Py_SIZE(v));

  0006c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00074	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00078	48 f7 d8	 neg	 rax
  0007b	48 89 44 24 50	 mov	 QWORD PTR ndigits$[rsp], rax

; 856  :         if (!is_signed) {

  00080	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR is_signed$[rsp], 0
  00088	75 1d		 jne	 SHORT $LN25@PyLong_AsB

; 857  :             PyErr_SetString(PyExc_OverflowError,
; 858  :                             "can't convert negative int to unsigned");

  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@PHDOCLKE@can?8t?5convert?5negative?5int?5to?5un@
  00091	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00098	e8 00 00 00 00	 call	 PyErr_SetString

; 859  :             return -1;

  0009d	b8 ff ff ff ff	 mov	 eax, -1
  000a2	e9 37 04 00 00	 jmp	 $LN27@PyLong_AsB
$LN25@PyLong_AsB:

; 860  :         }
; 861  :         do_twos_comp = 1;

  000a7	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR do_twos_comp$[rsp], 1

; 862  :     }
; 863  :     else {

  000af	eb 19		 jmp	 SHORT $LN24@PyLong_AsB
$LN26@PyLong_AsB:

; 864  :         ndigits = Py_SIZE(v);

  000b1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  000b9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000bd	48 89 44 24 50	 mov	 QWORD PTR ndigits$[rsp], rax

; 865  :         do_twos_comp = 0;

  000c2	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR do_twos_comp$[rsp], 0
$LN24@PyLong_AsB:

; 866  :     }
; 867  : 
; 868  :     if (little_endian) {

  000ca	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR little_endian$[rsp], 0
  000d2	74 17		 je	 SHORT $LN23@PyLong_AsB

; 869  :         p = bytes;

  000d4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR bytes$[rsp]
  000dc	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 870  :         pincr = 1;

  000e1	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR pincr$[rsp], 1

; 871  :     }
; 872  :     else {

  000e9	eb 22		 jmp	 SHORT $LN22@PyLong_AsB
$LN23@PyLong_AsB:

; 873  :         p = bytes + n - 1;

  000eb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR bytes$[rsp]
  000f3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  000fb	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00100	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 874  :         pincr = -1;

  00105	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR pincr$[rsp], -1
$LN22@PyLong_AsB:

; 875  :     }
; 876  : 
; 877  :     /* Copy over all the Python digits.
; 878  :        It's crucial that every Python digit except for the MSD contribute
; 879  :        exactly PyLong_SHIFT bits to the total, so first assert that the int is
; 880  :        normalized. */
; 881  :     assert(ndigits == 0 || v->ob_digit[ndigits - 1] != 0);

  0010d	48 83 7c 24 50
	00		 cmp	 QWORD PTR ndigits$[rsp], 0
  00113	74 30		 je	 SHORT $LN31@PyLong_AsB
  00115	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0011d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ndigits$[rsp]
  00122	83 7c 88 6c 00	 cmp	 DWORD PTR [rax+rcx*4+108], 0
  00127	75 1c		 jne	 SHORT $LN31@PyLong_AsB
  00129	41 b8 71 03 00
	00		 mov	 r8d, 881		; 00000371H
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@BMOIEENO@?$AAn?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$FL?$AAn?$AAd?$AAi?$AAg@
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00143	33 c0		 xor	 eax, eax
$LN31@PyLong_AsB:

; 882  :     j = 0;

  00145	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0

; 883  :     accum = 0;

  0014e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR accum$[rsp], 0

; 884  :     accumbits = 0;

  00157	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR accumbits$[rsp], 0

; 885  :     carry = do_twos_comp ? 1 : 0;

  0015f	83 7c 24 28 00	 cmp	 DWORD PTR do_twos_comp$[rsp], 0
  00164	74 0a		 je	 SHORT $LN32@PyLong_AsB
  00166	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv95[rsp], 1
  0016e	eb 08		 jmp	 SHORT $LN33@PyLong_AsB
$LN32@PyLong_AsB:
  00170	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN33@PyLong_AsB:
  00178	8b 44 24 74	 mov	 eax, DWORD PTR tv95[rsp]
  0017c	89 44 24 40	 mov	 DWORD PTR carry$[rsp], eax

; 886  :     for (i = 0; i < ndigits; ++i) {

  00180	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00189	eb 0d		 jmp	 SHORT $LN21@PyLong_AsB
$LN20@PyLong_AsB:
  0018b	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00190	48 ff c0	 inc	 rax
  00193	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN21@PyLong_AsB:
  00198	48 8b 44 24 50	 mov	 rax, QWORD PTR ndigits$[rsp]
  0019d	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  001a2	0f 8d 2e 01 00
	00		 jge	 $LN19@PyLong_AsB

; 887  :         digit thisdigit = v->ob_digit[i];

  001a8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  001b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  001b5	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  001b9	89 44 24 60	 mov	 DWORD PTR thisdigit$20869[rsp], eax

; 888  :         if (do_twos_comp) {

  001bd	83 7c 24 28 00	 cmp	 DWORD PTR do_twos_comp$[rsp], 0
  001c2	74 29		 je	 SHORT $LN18@PyLong_AsB

; 889  :             thisdigit = (thisdigit ^ PyLong_MASK) + carry;

  001c4	8b 44 24 60	 mov	 eax, DWORD PTR thisdigit$20869[rsp]
  001c8	35 ff ff ff 3f	 xor	 eax, 1073741823		; 3fffffffH
  001cd	03 44 24 40	 add	 eax, DWORD PTR carry$[rsp]
  001d1	89 44 24 60	 mov	 DWORD PTR thisdigit$20869[rsp], eax

; 890  :             carry = thisdigit >> PyLong_SHIFT;

  001d5	8b 44 24 60	 mov	 eax, DWORD PTR thisdigit$20869[rsp]
  001d9	c1 e8 1e	 shr	 eax, 30
  001dc	89 44 24 40	 mov	 DWORD PTR carry$[rsp], eax

; 891  :             thisdigit &= PyLong_MASK;

  001e0	8b 44 24 60	 mov	 eax, DWORD PTR thisdigit$20869[rsp]
  001e4	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  001e9	89 44 24 60	 mov	 DWORD PTR thisdigit$20869[rsp], eax
$LN18@PyLong_AsB:

; 892  :         }
; 893  :         /* Because we're going LSB to MSB, thisdigit is more
; 894  :            significant than what's already in accum, so needs to be
; 895  :            prepended to accum. */
; 896  :         accum |= (twodigits)thisdigit << accumbits;

  001ed	8b 44 24 60	 mov	 eax, DWORD PTR thisdigit$20869[rsp]
  001f1	8b 4c 24 3c	 mov	 ecx, DWORD PTR accumbits$[rsp]
  001f5	48 d3 e0	 shl	 rax, cl
  001f8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR accum$[rsp]
  001fd	48 0b c8	 or	 rcx, rax
  00200	48 8b c1	 mov	 rax, rcx
  00203	48 89 44 24 48	 mov	 QWORD PTR accum$[rsp], rax

; 897  : 
; 898  :         /* The most-significant digit may be (probably is) at least
; 899  :            partly empty. */
; 900  :         if (i == ndigits - 1) {

  00208	48 8b 44 24 50	 mov	 rax, QWORD PTR ndigits$[rsp]
  0020d	48 ff c8	 dec	 rax
  00210	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00215	75 45		 jne	 SHORT $LN17@PyLong_AsB

; 901  :             /* Count # of sign bits -- they needn't be stored,
; 902  :              * although for signed conversion we need later to
; 903  :              * make sure at least one sign bit gets stored. */
; 904  :             digit s = do_twos_comp ? thisdigit ^ PyLong_MASK : thisdigit;

  00217	83 7c 24 28 00	 cmp	 DWORD PTR do_twos_comp$[rsp], 0
  0021c	74 0f		 je	 SHORT $LN34@PyLong_AsB
  0021e	8b 44 24 60	 mov	 eax, DWORD PTR thisdigit$20869[rsp]
  00222	35 ff ff ff 3f	 xor	 eax, 1073741823		; 3fffffffH
  00227	89 44 24 78	 mov	 DWORD PTR tv145[rsp], eax
  0022b	eb 08		 jmp	 SHORT $LN35@PyLong_AsB
$LN34@PyLong_AsB:
  0022d	8b 44 24 60	 mov	 eax, DWORD PTR thisdigit$20869[rsp]
  00231	89 44 24 78	 mov	 DWORD PTR tv145[rsp], eax
$LN35@PyLong_AsB:
  00235	8b 44 24 78	 mov	 eax, DWORD PTR tv145[rsp]
  00239	89 44 24 64	 mov	 DWORD PTR s$20877[rsp], eax
$LN16@PyLong_AsB:

; 905  :             while (s != 0) {

  0023d	83 7c 24 64 00	 cmp	 DWORD PTR s$20877[rsp], 0
  00242	74 16		 je	 SHORT $LN15@PyLong_AsB

; 906  :                 s >>= 1;

  00244	8b 44 24 64	 mov	 eax, DWORD PTR s$20877[rsp]
  00248	d1 e8		 shr	 eax, 1
  0024a	89 44 24 64	 mov	 DWORD PTR s$20877[rsp], eax

; 907  :                 accumbits++;

  0024e	8b 44 24 3c	 mov	 eax, DWORD PTR accumbits$[rsp]
  00252	ff c0		 inc	 eax
  00254	89 44 24 3c	 mov	 DWORD PTR accumbits$[rsp], eax

; 908  :             }

  00258	eb e3		 jmp	 SHORT $LN16@PyLong_AsB
$LN15@PyLong_AsB:

; 909  :         }
; 910  :         else

  0025a	eb 0b		 jmp	 SHORT $LN14@PyLong_AsB
$LN17@PyLong_AsB:

; 911  :             accumbits += PyLong_SHIFT;

  0025c	8b 44 24 3c	 mov	 eax, DWORD PTR accumbits$[rsp]
  00260	83 c0 1e	 add	 eax, 30
  00263	89 44 24 3c	 mov	 DWORD PTR accumbits$[rsp], eax
$LN14@PyLong_AsB:
$LN13@PyLong_AsB:

; 912  : 
; 913  :         /* Store as many bytes as possible. */
; 914  :         while (accumbits >= 8) {

  00267	83 7c 24 3c 08	 cmp	 DWORD PTR accumbits$[rsp], 8
  0026c	72 63		 jb	 SHORT $LN12@PyLong_AsB

; 915  :             if (j >= n)

  0026e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00276	48 39 44 24 58	 cmp	 QWORD PTR j$[rsp], rax
  0027b	72 05		 jb	 SHORT $LN11@PyLong_AsB

; 916  :                 goto Overflow;

  0027d	e9 44 02 00 00	 jmp	 $Overflow$20888
$LN11@PyLong_AsB:

; 917  :             ++j;

  00282	48 8b 44 24 58	 mov	 rax, QWORD PTR j$[rsp]
  00287	48 ff c0	 inc	 rax
  0028a	48 89 44 24 58	 mov	 QWORD PTR j$[rsp], rax

; 918  :             *p = (unsigned char)(accum & 0xff);

  0028f	48 8b 44 24 48	 mov	 rax, QWORD PTR accum$[rsp]
  00294	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0029a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0029f	88 01		 mov	 BYTE PTR [rcx], al

; 919  :             p += pincr;

  002a1	48 63 44 24 38	 movsxd	 rax, DWORD PTR pincr$[rsp]
  002a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  002ab	48 03 c8	 add	 rcx, rax
  002ae	48 8b c1	 mov	 rax, rcx
  002b1	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 920  :             accumbits -= 8;

  002b6	8b 44 24 3c	 mov	 eax, DWORD PTR accumbits$[rsp]
  002ba	83 e8 08	 sub	 eax, 8
  002bd	89 44 24 3c	 mov	 DWORD PTR accumbits$[rsp], eax

; 921  :             accum >>= 8;

  002c1	48 8b 44 24 48	 mov	 rax, QWORD PTR accum$[rsp]
  002c6	48 c1 e8 08	 shr	 rax, 8
  002ca	48 89 44 24 48	 mov	 QWORD PTR accum$[rsp], rax

; 922  :         }

  002cf	eb 96		 jmp	 SHORT $LN13@PyLong_AsB
$LN12@PyLong_AsB:

; 923  :     }

  002d1	e9 b5 fe ff ff	 jmp	 $LN20@PyLong_AsB
$LN19@PyLong_AsB:

; 924  : 
; 925  :     /* Store the straggler (if any). */
; 926  :     assert(accumbits < 8);

  002d6	83 7c 24 3c 08	 cmp	 DWORD PTR accumbits$[rsp], 8
  002db	72 1c		 jb	 SHORT $LN36@PyLong_AsB
  002dd	41 b8 9e 03 00
	00		 mov	 r8d, 926		; 0000039eH
  002e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@CMHCCDBJ@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?5?$AA8?$AA?$AA@
  002f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002f7	33 c0		 xor	 eax, eax
$LN36@PyLong_AsB:

; 927  :     assert(carry == 0);  /* else do_twos_comp and *every* digit was 0 */

  002f9	83 7c 24 40 00	 cmp	 DWORD PTR carry$[rsp], 0
  002fe	74 1c		 je	 SHORT $LN37@PyLong_AsB
  00300	41 b8 9f 03 00
	00		 mov	 r8d, 927		; 0000039fH
  00306	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@NKCMNFPP@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0031a	33 c0		 xor	 eax, eax
$LN37@PyLong_AsB:

; 928  :     if (accumbits > 0) {

  0031c	83 7c 24 3c 00	 cmp	 DWORD PTR accumbits$[rsp], 0
  00321	0f 86 85 00 00
	00		 jbe	 $LN10@PyLong_AsB

; 929  :         if (j >= n)

  00327	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0032f	48 39 44 24 58	 cmp	 QWORD PTR j$[rsp], rax
  00334	72 05		 jb	 SHORT $LN9@PyLong_AsB

; 930  :             goto Overflow;

  00336	e9 8b 01 00 00	 jmp	 $Overflow$20888
$LN9@PyLong_AsB:

; 931  :         ++j;

  0033b	48 8b 44 24 58	 mov	 rax, QWORD PTR j$[rsp]
  00340	48 ff c0	 inc	 rax
  00343	48 89 44 24 58	 mov	 QWORD PTR j$[rsp], rax

; 932  :         if (do_twos_comp) {

  00348	83 7c 24 28 00	 cmp	 DWORD PTR do_twos_comp$[rsp], 0
  0034d	74 31		 je	 SHORT $LN8@PyLong_AsB

; 933  :             /* Fill leading bits of the byte with sign bits
; 934  :                (appropriately pretending that the int had an
; 935  :                infinite supply of sign bits). */
; 936  :             accum |= (~(twodigits)0) << accumbits;

  0034f	8b 44 24 3c	 mov	 eax, DWORD PTR accumbits$[rsp]
  00353	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0035a	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv252[rsp], rcx
  00362	0f b6 c8	 movzx	 ecx, al
  00365	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv252[rsp]
  0036d	48 d3 e0	 shl	 rax, cl
  00370	48 8b 4c 24 48	 mov	 rcx, QWORD PTR accum$[rsp]
  00375	48 0b c8	 or	 rcx, rax
  00378	48 8b c1	 mov	 rax, rcx
  0037b	48 89 44 24 48	 mov	 QWORD PTR accum$[rsp], rax
$LN8@PyLong_AsB:

; 937  :         }
; 938  :         *p = (unsigned char)(accum & 0xff);

  00380	48 8b 44 24 48	 mov	 rax, QWORD PTR accum$[rsp]
  00385	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0038b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00390	88 01		 mov	 BYTE PTR [rcx], al

; 939  :         p += pincr;

  00392	48 63 44 24 38	 movsxd	 rax, DWORD PTR pincr$[rsp]
  00397	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0039c	48 03 c8	 add	 rcx, rax
  0039f	48 8b c1	 mov	 rax, rcx
  003a2	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  003a7	e9 aa 00 00 00	 jmp	 $LN7@PyLong_AsB
$LN10@PyLong_AsB:

; 940  :     }
; 941  :     else if (j == n && n > 0 && is_signed) {

  003ac	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003b4	48 39 44 24 58	 cmp	 QWORD PTR j$[rsp], rax
  003b9	0f 85 97 00 00
	00		 jne	 $LN6@PyLong_AsB
  003bf	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  003c8	0f 86 88 00 00
	00		 jbe	 $LN6@PyLong_AsB
  003ce	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR is_signed$[rsp], 0
  003d6	74 7e		 je	 SHORT $LN6@PyLong_AsB

; 942  :         /* The main loop filled the byte array exactly, so the code
; 943  :            just above didn't get to ensure there's a sign bit, and the
; 944  :            loop below wouldn't add one either.  Make sure a sign bit
; 945  :            exists. */
; 946  :         unsigned char msb = *(p - pincr);

  003d8	48 63 44 24 38	 movsxd	 rax, DWORD PTR pincr$[rsp]
  003dd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  003e2	48 2b c8	 sub	 rcx, rax
  003e5	48 8b c1	 mov	 rax, rcx
  003e8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003eb	88 44 24 68	 mov	 BYTE PTR msb$20901[rsp], al

; 947  :         int sign_bit_set = msb >= 0x80;

  003ef	0f b6 44 24 68	 movzx	 eax, BYTE PTR msb$20901[rsp]
  003f4	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  003f9	7c 0d		 jl	 SHORT $LN38@PyLong_AsB
  003fb	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv186[rsp], 1
  00406	eb 0b		 jmp	 SHORT $LN39@PyLong_AsB
$LN38@PyLong_AsB:
  00408	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv186[rsp], 0
$LN39@PyLong_AsB:
  00413	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv186[rsp]
  0041a	89 44 24 6c	 mov	 DWORD PTR sign_bit_set$20902[rsp], eax

; 948  :         assert(accumbits == 0);

  0041e	83 7c 24 3c 00	 cmp	 DWORD PTR accumbits$[rsp], 0
  00423	74 1c		 je	 SHORT $LN40@PyLong_AsB
  00425	41 b8 b4 03 00
	00		 mov	 r8d, 948		; 000003b4H
  0042b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00432	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@COLFMDIL@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00439	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0043f	33 c0		 xor	 eax, eax
$LN40@PyLong_AsB:

; 949  :         if (sign_bit_set == do_twos_comp)

  00441	8b 44 24 28	 mov	 eax, DWORD PTR do_twos_comp$[rsp]
  00445	39 44 24 6c	 cmp	 DWORD PTR sign_bit_set$20902[rsp], eax
  00449	75 09		 jne	 SHORT $LN5@PyLong_AsB

; 950  :             return 0;

  0044b	33 c0		 xor	 eax, eax
  0044d	e9 8c 00 00 00	 jmp	 $LN27@PyLong_AsB

; 951  :         else

  00452	eb 02		 jmp	 SHORT $LN4@PyLong_AsB
$LN5@PyLong_AsB:

; 952  :             goto Overflow;

  00454	eb 70		 jmp	 SHORT $Overflow$20888
$LN4@PyLong_AsB:
$LN6@PyLong_AsB:
$LN7@PyLong_AsB:

; 953  :     }
; 954  : 
; 955  :     /* Fill remaining bytes with copies of the sign bit. */
; 956  :     {
; 957  :         unsigned char signbyte = do_twos_comp ? 0xffU : 0U;

  00456	83 7c 24 28 00	 cmp	 DWORD PTR do_twos_comp$[rsp], 0
  0045b	74 0d		 je	 SHORT $LN41@PyLong_AsB
  0045d	c7 84 24 8c 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv194[rsp], 255 ; 000000ffH
  00468	eb 0b		 jmp	 SHORT $LN42@PyLong_AsB
$LN41@PyLong_AsB:
  0046a	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv194[rsp], 0
$LN42@PyLong_AsB:
  00475	0f b6 84 24 8c
	00 00 00	 movzx	 eax, BYTE PTR tv194[rsp]
  0047d	88 44 24 70	 mov	 BYTE PTR signbyte$20907[rsp], al

; 958  :         for ( ; j < n; ++j, p += pincr)

  00481	eb 22		 jmp	 SHORT $LN3@PyLong_AsB
$LN2@PyLong_AsB:
  00483	48 8b 44 24 58	 mov	 rax, QWORD PTR j$[rsp]
  00488	48 ff c0	 inc	 rax
  0048b	48 89 44 24 58	 mov	 QWORD PTR j$[rsp], rax
  00490	48 63 44 24 38	 movsxd	 rax, DWORD PTR pincr$[rsp]
  00495	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0049a	48 03 c8	 add	 rcx, rax
  0049d	48 8b c1	 mov	 rax, rcx
  004a0	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN3@PyLong_AsB:
  004a5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  004ad	48 39 44 24 58	 cmp	 QWORD PTR j$[rsp], rax
  004b2	73 0e		 jae	 SHORT $LN1@PyLong_AsB

; 959  :             *p = signbyte;

  004b4	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004b9	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR signbyte$20907[rsp]
  004be	88 08		 mov	 BYTE PTR [rax], cl
  004c0	eb c1		 jmp	 SHORT $LN2@PyLong_AsB
$LN1@PyLong_AsB:

; 960  :     }
; 961  : 
; 962  :     return 0;

  004c2	33 c0		 xor	 eax, eax
  004c4	eb 18		 jmp	 SHORT $LN27@PyLong_AsB
$Overflow$20888:

; 963  : 
; 964  :   Overflow:
; 965  :     PyErr_SetString(PyExc_OverflowError, "int too big to convert");

  004c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@KCBHMDHM@int?5too?5big?5to?5convert?$AA@
  004cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  004d4	e8 00 00 00 00	 call	 PyErr_SetString

; 966  :     return -1;

  004d9	b8 ff ff ff ff	 mov	 eax, -1
$LN27@PyLong_AsB:

; 967  : 
; 968  : }

  004de	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  004e5	c3		 ret	 0
_PyLong_AsByteArray ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromUnsignedLongLong
PUBLIC	PyLong_FromVoidPtr
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromVoidPtr DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$PyLong_FromVoidPtr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromVoidPtr DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_FromVoidPtr
_TEXT	SEGMENT
p$ = 48
PyLong_FromVoidPtr PROC					; COMDAT

; 974  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 975  : #if SIZEOF_VOID_P <= SIZEOF_LONG
; 976  :     /* special-case null pointer */
; 977  :     if (!p)
; 978  :         return PyLong_FromLong(0);
; 979  :     return PyLong_FromUnsignedLong((unsigned long)(Py_uintptr_t)p);
; 980  : #else
; 981  : 
; 982  : #ifndef HAVE_LONG_LONG
; 983  : #   error "PyLong_FromVoidPtr: sizeof(void*) > sizeof(long), but no long long"
; 984  : #endif
; 985  : #if SIZEOF_LONG_LONG < SIZEOF_VOID_P
; 986  : #   error "PyLong_FromVoidPtr: sizeof(PY_LONG_LONG) < sizeof(void*)"
; 987  : #endif
; 988  :     /* special-case null pointer */
; 989  :     if (!p)

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  0000f	75 09		 jne	 SHORT $LN1@PyLong_Fro@6

; 990  :         return PyLong_FromLong(0);

  00011	33 c9		 xor	 ecx, ecx
  00013	e8 00 00 00 00	 call	 PyLong_FromLong
  00018	eb 0a		 jmp	 SHORT $LN2@PyLong_Fro@6
$LN1@PyLong_Fro@6:

; 991  :     return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)(Py_uintptr_t)p);

  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  0001f	e8 00 00 00 00	 call	 PyLong_FromUnsignedLongLong
$LN2@PyLong_Fro@6:

; 992  : #endif /* SIZEOF_VOID_P <= SIZEOF_LONG */
; 993  : 
; 994  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
PyLong_FromVoidPtr ENDP
_TEXT	ENDS
PUBLIC	PyLong_AsUnsignedLongLong
PUBLIC	PyLong_AsLongLong
PUBLIC	PyLong_AsVoidPtr
EXTRN	PyErr_Occurred:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsVoidPtr DD imagerel $LN6
	DD	imagerel $LN6+111
	DD	imagerel $unwind$PyLong_AsVoidPtr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsVoidPtr DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_AsVoidPtr
_TEXT	SEGMENT
x$ = 32
vv$ = 64
PyLong_AsVoidPtr PROC					; COMDAT

; 1000 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1001 : #if SIZEOF_VOID_P <= SIZEOF_LONG
; 1002 :     long x;
; 1003 : 
; 1004 :     if (PyLong_Check(vv) && _PyLong_Sign(vv) < 0)
; 1005 :         x = PyLong_AsLong(vv);
; 1006 :     else
; 1007 :         x = PyLong_AsUnsignedLong(vv);
; 1008 : #else
; 1009 : 
; 1010 : #ifndef HAVE_LONG_LONG
; 1011 : #   error "PyLong_AsVoidPtr: sizeof(void*) > sizeof(long), but no long long"
; 1012 : #endif
; 1013 : #if SIZEOF_LONG_LONG < SIZEOF_VOID_P
; 1014 : #   error "PyLong_AsVoidPtr: sizeof(PY_LONG_LONG) < sizeof(void*)"
; 1015 : #endif
; 1016 :     PY_LONG_LONG x;
; 1017 : 
; 1018 :     if (PyLong_Check(vv) && _PyLong_Sign(vv) < 0)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR vv$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0001d	85 c0		 test	 eax, eax
  0001f	74 1f		 je	 SHORT $LN3@PyLong_AsV
  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vv$[rsp]
  00026	e8 00 00 00 00	 call	 _PyLong_Sign
  0002b	85 c0		 test	 eax, eax
  0002d	7d 11		 jge	 SHORT $LN3@PyLong_AsV

; 1019 :         x = PyLong_AsLongLong(vv);

  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vv$[rsp]
  00034	e8 00 00 00 00	 call	 PyLong_AsLongLong
  00039	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1020 :     else

  0003e	eb 0f		 jmp	 SHORT $LN2@PyLong_AsV
$LN3@PyLong_AsV:

; 1021 :         x = PyLong_AsUnsignedLongLong(vv);

  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vv$[rsp]
  00045	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongLong
  0004a	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax
$LN2@PyLong_AsV:

; 1022 : 
; 1023 : #endif /* SIZEOF_VOID_P <= SIZEOF_LONG */
; 1024 : 
; 1025 :     if (x == -1 && PyErr_Occurred())

  0004f	48 83 7c 24 20
	ff		 cmp	 QWORD PTR x$[rsp], -1
  00055	75 0e		 jne	 SHORT $LN1@PyLong_AsV
  00057	e8 00 00 00 00	 call	 PyErr_Occurred
  0005c	48 85 c0	 test	 rax, rax
  0005f	74 04		 je	 SHORT $LN1@PyLong_AsV

; 1026 :         return NULL;

  00061	33 c0		 xor	 eax, eax
  00063	eb 05		 jmp	 SHORT $LN4@PyLong_AsV
$LN1@PyLong_AsV:

; 1027 :     return (void *)x;

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
$LN4@PyLong_AsV:

; 1028 : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
PyLong_AsVoidPtr ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromLongLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromLongLong DD imagerel $LN16
	DD	imagerel $LN16+313
	DD	imagerel $unwind$PyLong_FromLongLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromLongLong DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_FromLongLong
_TEXT	SEGMENT
negative$ = 32
v$ = 40
abs_ival$ = 48
ndigits$ = 56
t$ = 64
p$20952 = 72
tv83 = 80
ival$ = 112
PyLong_FromLongLong PROC				; COMDAT

; 1043 : {

$LN16:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1044 :     PyLongObject *v;
; 1045 :     unsigned PY_LONG_LONG abs_ival;
; 1046 :     unsigned PY_LONG_LONG t;  /* unsigned so >> doesn't propagate sign bit */
; 1047 :     int ndigits = 0;

  00009	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ndigits$[rsp], 0

; 1048 :     int negative = 0;

  00011	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR negative$[rsp], 0
$LN11@PyLong_Fro@7:

; 1049 : 
; 1050 :     CHECK_SMALL_INT(ival);

  00019	48 83 7c 24 70
	fb		 cmp	 QWORD PTR ival$[rsp], -5
  0001f	7c 19		 jl	 SHORT $LN8@PyLong_Fro@7
  00021	48 81 7c 24 70
	01 01 00 00	 cmp	 QWORD PTR ival$[rsp], 257 ; 00000101H
  0002a	7d 0e		 jge	 SHORT $LN8@PyLong_Fro@7
  0002c	8b 4c 24 70	 mov	 ecx, DWORD PTR ival$[rsp]
  00030	e8 00 00 00 00	 call	 get_small_int
  00035	e9 fa 00 00 00	 jmp	 $LN12@PyLong_Fro@7
$LN8@PyLong_Fro@7:
  0003a	33 c0		 xor	 eax, eax
  0003c	85 c0		 test	 eax, eax
  0003e	75 d9		 jne	 SHORT $LN11@PyLong_Fro@7

; 1051 :     if (ival < 0) {

  00040	48 83 7c 24 70
	00		 cmp	 QWORD PTR ival$[rsp], 0
  00046	7d 1e		 jge	 SHORT $LN7@PyLong_Fro@7

; 1052 :         /* avoid signed overflow on negation;  see comments
; 1053 :            in PyLong_FromLong above. */
; 1054 :         abs_ival = (unsigned PY_LONG_LONG)(-1-ival) + 1;

  00048	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0004f	48 2b 44 24 70	 sub	 rax, QWORD PTR ival$[rsp]
  00054	48 ff c0	 inc	 rax
  00057	48 89 44 24 30	 mov	 QWORD PTR abs_ival$[rsp], rax

; 1055 :         negative = 1;

  0005c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR negative$[rsp], 1

; 1056 :     }
; 1057 :     else {

  00064	eb 0a		 jmp	 SHORT $LN6@PyLong_Fro@7
$LN7@PyLong_Fro@7:

; 1058 :         abs_ival = (unsigned PY_LONG_LONG)ival;

  00066	48 8b 44 24 70	 mov	 rax, QWORD PTR ival$[rsp]
  0006b	48 89 44 24 30	 mov	 QWORD PTR abs_ival$[rsp], rax
$LN6@PyLong_Fro@7:

; 1059 :     }
; 1060 : 
; 1061 :     /* Count the number of Python digits.
; 1062 :        We used to pick 5 ("big enough for anything"), but that's a
; 1063 :        waste of time and space given that 5*15 = 75 bits are rarely
; 1064 :        needed. */
; 1065 :     t = abs_ival;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR abs_ival$[rsp]
  00075	48 89 44 24 40	 mov	 QWORD PTR t$[rsp], rax
$LN5@PyLong_Fro@7:

; 1066 :     while (t) {

  0007a	48 83 7c 24 40
	00		 cmp	 QWORD PTR t$[rsp], 0
  00080	74 1a		 je	 SHORT $LN4@PyLong_Fro@7

; 1067 :         ++ndigits;

  00082	8b 44 24 38	 mov	 eax, DWORD PTR ndigits$[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 38	 mov	 DWORD PTR ndigits$[rsp], eax

; 1068 :         t >>= PyLong_SHIFT;

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR t$[rsp]
  00091	48 c1 e8 1e	 shr	 rax, 30
  00095	48 89 44 24 40	 mov	 QWORD PTR t$[rsp], rax

; 1069 :     }

  0009a	eb de		 jmp	 SHORT $LN5@PyLong_Fro@7
$LN4@PyLong_Fro@7:

; 1070 :     v = _PyLong_New(ndigits);

  0009c	48 63 44 24 38	 movsxd	 rax, DWORD PTR ndigits$[rsp]
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	e8 00 00 00 00	 call	 _PyLong_New
  000a9	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 1071 :     if (v != NULL) {

  000ae	48 83 7c 24 28
	00		 cmp	 QWORD PTR v$[rsp], 0
  000b4	74 79		 je	 SHORT $LN3@PyLong_Fro@7

; 1072 :         digit *p = v->ob_digit;

  000b6	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  000bb	48 83 c0 70	 add	 rax, 112		; 00000070H
  000bf	48 89 44 24 48	 mov	 QWORD PTR p$20952[rsp], rax

; 1073 :         Py_SIZE(v) = negative ? -ndigits : ndigits;

  000c4	83 7c 24 20 00	 cmp	 DWORD PTR negative$[rsp], 0
  000c9	74 0c		 je	 SHORT $LN14@PyLong_Fro@7
  000cb	8b 44 24 38	 mov	 eax, DWORD PTR ndigits$[rsp]
  000cf	f7 d8		 neg	 eax
  000d1	89 44 24 50	 mov	 DWORD PTR tv83[rsp], eax
  000d5	eb 08		 jmp	 SHORT $LN15@PyLong_Fro@7
$LN14@PyLong_Fro@7:
  000d7	8b 44 24 38	 mov	 eax, DWORD PTR ndigits$[rsp]
  000db	89 44 24 50	 mov	 DWORD PTR tv83[rsp], eax
$LN15@PyLong_Fro@7:
  000df	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv83[rsp]
  000e4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  000e9	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1074 :         t = abs_ival;

  000ed	48 8b 44 24 30	 mov	 rax, QWORD PTR abs_ival$[rsp]
  000f2	48 89 44 24 40	 mov	 QWORD PTR t$[rsp], rax
$LN2@PyLong_Fro@7:

; 1075 :         while (t) {

  000f7	48 83 7c 24 40
	00		 cmp	 QWORD PTR t$[rsp], 0
  000fd	74 30		 je	 SHORT $LN1@PyLong_Fro@7

; 1076 :             *p++ = (digit)(t & PyLong_MASK);

  000ff	48 8b 44 24 40	 mov	 rax, QWORD PTR t$[rsp]
  00104	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  0010a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$20952[rsp]
  0010f	89 01		 mov	 DWORD PTR [rcx], eax
  00111	48 8b 44 24 48	 mov	 rax, QWORD PTR p$20952[rsp]
  00116	48 83 c0 04	 add	 rax, 4
  0011a	48 89 44 24 48	 mov	 QWORD PTR p$20952[rsp], rax

; 1077 :             t >>= PyLong_SHIFT;

  0011f	48 8b 44 24 40	 mov	 rax, QWORD PTR t$[rsp]
  00124	48 c1 e8 1e	 shr	 rax, 30
  00128	48 89 44 24 40	 mov	 QWORD PTR t$[rsp], rax

; 1078 :         }

  0012d	eb c8		 jmp	 SHORT $LN2@PyLong_Fro@7
$LN1@PyLong_Fro@7:
$LN3@PyLong_Fro@7:

; 1079 :     }
; 1080 :     return (PyObject *)v;

  0012f	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
$LN12@PyLong_Fro@7:

; 1081 : }

  00134	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00138	c3		 ret	 0
PyLong_FromLongLong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromUnsignedLongLong DD imagerel $LN9
	DD	imagerel $LN9+206
	DD	imagerel $unwind$PyLong_FromUnsignedLongLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromUnsignedLongLong DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_FromUnsignedLongLong
_TEXT	SEGMENT
v$ = 32
ndigits$ = 40
t$ = 48
p$20976 = 56
ival$ = 80
PyLong_FromUnsignedLongLong PROC			; COMDAT

; 1087 : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1088 :     PyLongObject *v;
; 1089 :     unsigned PY_LONG_LONG t;
; 1090 :     int ndigits = 0;

  00009	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ndigits$[rsp], 0

; 1091 : 
; 1092 :     if (ival < PyLong_BASE)

  00011	48 81 7c 24 50
	00 00 00 40	 cmp	 QWORD PTR ival$[rsp], 1073741824 ; 40000000H
  0001a	73 0e		 jae	 SHORT $LN6@PyLong_Fro@8

; 1093 :         return PyLong_FromLong((long)ival);

  0001c	8b 4c 24 50	 mov	 ecx, DWORD PTR ival$[rsp]
  00020	e8 00 00 00 00	 call	 PyLong_FromLong
  00025	e9 9f 00 00 00	 jmp	 $LN7@PyLong_Fro@8
$LN6@PyLong_Fro@8:

; 1094 :     /* Count the number of Python digits. */
; 1095 :     t = (unsigned PY_LONG_LONG)ival;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR ival$[rsp]
  0002f	48 89 44 24 30	 mov	 QWORD PTR t$[rsp], rax
$LN5@PyLong_Fro@8:

; 1096 :     while (t) {

  00034	48 83 7c 24 30
	00		 cmp	 QWORD PTR t$[rsp], 0
  0003a	74 1a		 je	 SHORT $LN4@PyLong_Fro@8

; 1097 :         ++ndigits;

  0003c	8b 44 24 28	 mov	 eax, DWORD PTR ndigits$[rsp]
  00040	ff c0		 inc	 eax
  00042	89 44 24 28	 mov	 DWORD PTR ndigits$[rsp], eax

; 1098 :         t >>= PyLong_SHIFT;

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR t$[rsp]
  0004b	48 c1 e8 1e	 shr	 rax, 30
  0004f	48 89 44 24 30	 mov	 QWORD PTR t$[rsp], rax

; 1099 :     }

  00054	eb de		 jmp	 SHORT $LN5@PyLong_Fro@8
$LN4@PyLong_Fro@8:

; 1100 :     v = _PyLong_New(ndigits);

  00056	48 63 44 24 28	 movsxd	 rax, DWORD PTR ndigits$[rsp]
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	e8 00 00 00 00	 call	 _PyLong_New
  00063	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1101 :     if (v != NULL) {

  00068	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  0006e	74 54		 je	 SHORT $LN3@PyLong_Fro@8

; 1102 :         digit *p = v->ob_digit;

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00075	48 83 c0 70	 add	 rax, 112		; 00000070H
  00079	48 89 44 24 38	 mov	 QWORD PTR p$20976[rsp], rax

; 1103 :         Py_SIZE(v) = ndigits;

  0007e	48 63 44 24 28	 movsxd	 rax, DWORD PTR ndigits$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00088	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN2@PyLong_Fro@8:

; 1104 :         while (ival) {

  0008c	48 83 7c 24 50
	00		 cmp	 QWORD PTR ival$[rsp], 0
  00092	74 30		 je	 SHORT $LN1@PyLong_Fro@8

; 1105 :             *p++ = (digit)(ival & PyLong_MASK);

  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR ival$[rsp]
  00099	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  0009f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$20976[rsp]
  000a4	89 01		 mov	 DWORD PTR [rcx], eax
  000a6	48 8b 44 24 38	 mov	 rax, QWORD PTR p$20976[rsp]
  000ab	48 83 c0 04	 add	 rax, 4
  000af	48 89 44 24 38	 mov	 QWORD PTR p$20976[rsp], rax

; 1106 :             ival >>= PyLong_SHIFT;

  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR ival$[rsp]
  000b9	48 c1 e8 1e	 shr	 rax, 30
  000bd	48 89 44 24 50	 mov	 QWORD PTR ival$[rsp], rax

; 1107 :         }

  000c2	eb c8		 jmp	 SHORT $LN2@PyLong_Fro@8
$LN1@PyLong_Fro@8:
$LN3@PyLong_Fro@8:

; 1108 :     }
; 1109 :     return (PyObject *)v;

  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN7@PyLong_Fro@8:

; 1110 : }

  000c9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cd	c3		 ret	 0
PyLong_FromUnsignedLongLong ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromSsize_t
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromSsize_t DD imagerel $LN16
	DD	imagerel $LN16+313
	DD	imagerel $unwind$PyLong_FromSsize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromSsize_t DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_FromSsize_t
_TEXT	SEGMENT
negative$ = 32
v$ = 40
abs_ival$ = 48
ndigits$ = 56
t$ = 64
p$21007 = 72
tv83 = 80
ival$ = 112
PyLong_FromSsize_t PROC					; COMDAT

; 1116 : {

$LN16:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1117 :     PyLongObject *v;
; 1118 :     size_t abs_ival;
; 1119 :     size_t t;  /* unsigned so >> doesn't propagate sign bit */
; 1120 :     int ndigits = 0;

  00009	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ndigits$[rsp], 0

; 1121 :     int negative = 0;

  00011	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR negative$[rsp], 0
$LN11@PyLong_Fro@9:

; 1122 : 
; 1123 :     CHECK_SMALL_INT(ival);

  00019	48 83 7c 24 70
	fb		 cmp	 QWORD PTR ival$[rsp], -5
  0001f	7c 19		 jl	 SHORT $LN8@PyLong_Fro@9
  00021	48 81 7c 24 70
	01 01 00 00	 cmp	 QWORD PTR ival$[rsp], 257 ; 00000101H
  0002a	7d 0e		 jge	 SHORT $LN8@PyLong_Fro@9
  0002c	8b 4c 24 70	 mov	 ecx, DWORD PTR ival$[rsp]
  00030	e8 00 00 00 00	 call	 get_small_int
  00035	e9 fa 00 00 00	 jmp	 $LN12@PyLong_Fro@9
$LN8@PyLong_Fro@9:
  0003a	33 c0		 xor	 eax, eax
  0003c	85 c0		 test	 eax, eax
  0003e	75 d9		 jne	 SHORT $LN11@PyLong_Fro@9

; 1124 :     if (ival < 0) {

  00040	48 83 7c 24 70
	00		 cmp	 QWORD PTR ival$[rsp], 0
  00046	7d 1e		 jge	 SHORT $LN7@PyLong_Fro@9

; 1125 :         /* avoid signed overflow when ival = SIZE_T_MIN */
; 1126 :         abs_ival = (size_t)(-1-ival)+1;

  00048	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0004f	48 2b 44 24 70	 sub	 rax, QWORD PTR ival$[rsp]
  00054	48 ff c0	 inc	 rax
  00057	48 89 44 24 30	 mov	 QWORD PTR abs_ival$[rsp], rax

; 1127 :         negative = 1;

  0005c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR negative$[rsp], 1

; 1128 :     }
; 1129 :     else {

  00064	eb 0a		 jmp	 SHORT $LN6@PyLong_Fro@9
$LN7@PyLong_Fro@9:

; 1130 :         abs_ival = (size_t)ival;

  00066	48 8b 44 24 70	 mov	 rax, QWORD PTR ival$[rsp]
  0006b	48 89 44 24 30	 mov	 QWORD PTR abs_ival$[rsp], rax
$LN6@PyLong_Fro@9:

; 1131 :     }
; 1132 : 
; 1133 :     /* Count the number of Python digits. */
; 1134 :     t = abs_ival;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR abs_ival$[rsp]
  00075	48 89 44 24 40	 mov	 QWORD PTR t$[rsp], rax
$LN5@PyLong_Fro@9:

; 1135 :     while (t) {

  0007a	48 83 7c 24 40
	00		 cmp	 QWORD PTR t$[rsp], 0
  00080	74 1a		 je	 SHORT $LN4@PyLong_Fro@9

; 1136 :         ++ndigits;

  00082	8b 44 24 38	 mov	 eax, DWORD PTR ndigits$[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 38	 mov	 DWORD PTR ndigits$[rsp], eax

; 1137 :         t >>= PyLong_SHIFT;

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR t$[rsp]
  00091	48 c1 e8 1e	 shr	 rax, 30
  00095	48 89 44 24 40	 mov	 QWORD PTR t$[rsp], rax

; 1138 :     }

  0009a	eb de		 jmp	 SHORT $LN5@PyLong_Fro@9
$LN4@PyLong_Fro@9:

; 1139 :     v = _PyLong_New(ndigits);

  0009c	48 63 44 24 38	 movsxd	 rax, DWORD PTR ndigits$[rsp]
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	e8 00 00 00 00	 call	 _PyLong_New
  000a9	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 1140 :     if (v != NULL) {

  000ae	48 83 7c 24 28
	00		 cmp	 QWORD PTR v$[rsp], 0
  000b4	74 79		 je	 SHORT $LN3@PyLong_Fro@9

; 1141 :         digit *p = v->ob_digit;

  000b6	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  000bb	48 83 c0 70	 add	 rax, 112		; 00000070H
  000bf	48 89 44 24 48	 mov	 QWORD PTR p$21007[rsp], rax

; 1142 :         Py_SIZE(v) = negative ? -ndigits : ndigits;

  000c4	83 7c 24 20 00	 cmp	 DWORD PTR negative$[rsp], 0
  000c9	74 0c		 je	 SHORT $LN14@PyLong_Fro@9
  000cb	8b 44 24 38	 mov	 eax, DWORD PTR ndigits$[rsp]
  000cf	f7 d8		 neg	 eax
  000d1	89 44 24 50	 mov	 DWORD PTR tv83[rsp], eax
  000d5	eb 08		 jmp	 SHORT $LN15@PyLong_Fro@9
$LN14@PyLong_Fro@9:
  000d7	8b 44 24 38	 mov	 eax, DWORD PTR ndigits$[rsp]
  000db	89 44 24 50	 mov	 DWORD PTR tv83[rsp], eax
$LN15@PyLong_Fro@9:
  000df	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv83[rsp]
  000e4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  000e9	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1143 :         t = abs_ival;

  000ed	48 8b 44 24 30	 mov	 rax, QWORD PTR abs_ival$[rsp]
  000f2	48 89 44 24 40	 mov	 QWORD PTR t$[rsp], rax
$LN2@PyLong_Fro@9:

; 1144 :         while (t) {

  000f7	48 83 7c 24 40
	00		 cmp	 QWORD PTR t$[rsp], 0
  000fd	74 30		 je	 SHORT $LN1@PyLong_Fro@9

; 1145 :             *p++ = (digit)(t & PyLong_MASK);

  000ff	48 8b 44 24 40	 mov	 rax, QWORD PTR t$[rsp]
  00104	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  0010a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$21007[rsp]
  0010f	89 01		 mov	 DWORD PTR [rcx], eax
  00111	48 8b 44 24 48	 mov	 rax, QWORD PTR p$21007[rsp]
  00116	48 83 c0 04	 add	 rax, 4
  0011a	48 89 44 24 48	 mov	 QWORD PTR p$21007[rsp], rax

; 1146 :             t >>= PyLong_SHIFT;

  0011f	48 8b 44 24 40	 mov	 rax, QWORD PTR t$[rsp]
  00124	48 c1 e8 1e	 shr	 rax, 30
  00128	48 89 44 24 40	 mov	 QWORD PTR t$[rsp], rax

; 1147 :         }

  0012d	eb c8		 jmp	 SHORT $LN2@PyLong_Fro@9
$LN1@PyLong_Fro@9:
$LN3@PyLong_Fro@9:

; 1148 :     }
; 1149 :     return (PyObject *)v;

  0012f	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
$LN12@PyLong_Fro@9:

; 1150 : }

  00134	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00138	c3		 ret	 0
PyLong_FromSsize_t ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromSize_t
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromSize_t DD imagerel $LN9
	DD	imagerel $LN9+206
	DD	imagerel $unwind$PyLong_FromSize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromSize_t DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_FromSize_t
_TEXT	SEGMENT
v$ = 32
ndigits$ = 40
t$ = 48
p$21030 = 56
ival$ = 80
PyLong_FromSize_t PROC					; COMDAT

; 1156 : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1157 :     PyLongObject *v;
; 1158 :     size_t t;
; 1159 :     int ndigits = 0;

  00009	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR ndigits$[rsp], 0

; 1160 : 
; 1161 :     if (ival < PyLong_BASE)

  00011	48 81 7c 24 50
	00 00 00 40	 cmp	 QWORD PTR ival$[rsp], 1073741824 ; 40000000H
  0001a	73 0e		 jae	 SHORT $LN6@PyLong_Fro@10

; 1162 :         return PyLong_FromLong((long)ival);

  0001c	8b 4c 24 50	 mov	 ecx, DWORD PTR ival$[rsp]
  00020	e8 00 00 00 00	 call	 PyLong_FromLong
  00025	e9 9f 00 00 00	 jmp	 $LN7@PyLong_Fro@10
$LN6@PyLong_Fro@10:

; 1163 :     /* Count the number of Python digits. */
; 1164 :     t = ival;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR ival$[rsp]
  0002f	48 89 44 24 30	 mov	 QWORD PTR t$[rsp], rax
$LN5@PyLong_Fro@10:

; 1165 :     while (t) {

  00034	48 83 7c 24 30
	00		 cmp	 QWORD PTR t$[rsp], 0
  0003a	74 1a		 je	 SHORT $LN4@PyLong_Fro@10

; 1166 :         ++ndigits;

  0003c	8b 44 24 28	 mov	 eax, DWORD PTR ndigits$[rsp]
  00040	ff c0		 inc	 eax
  00042	89 44 24 28	 mov	 DWORD PTR ndigits$[rsp], eax

; 1167 :         t >>= PyLong_SHIFT;

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR t$[rsp]
  0004b	48 c1 e8 1e	 shr	 rax, 30
  0004f	48 89 44 24 30	 mov	 QWORD PTR t$[rsp], rax

; 1168 :     }

  00054	eb de		 jmp	 SHORT $LN5@PyLong_Fro@10
$LN4@PyLong_Fro@10:

; 1169 :     v = _PyLong_New(ndigits);

  00056	48 63 44 24 28	 movsxd	 rax, DWORD PTR ndigits$[rsp]
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	e8 00 00 00 00	 call	 _PyLong_New
  00063	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1170 :     if (v != NULL) {

  00068	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  0006e	74 54		 je	 SHORT $LN3@PyLong_Fro@10

; 1171 :         digit *p = v->ob_digit;

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00075	48 83 c0 70	 add	 rax, 112		; 00000070H
  00079	48 89 44 24 38	 mov	 QWORD PTR p$21030[rsp], rax

; 1172 :         Py_SIZE(v) = ndigits;

  0007e	48 63 44 24 28	 movsxd	 rax, DWORD PTR ndigits$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00088	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN2@PyLong_Fro@10:

; 1173 :         while (ival) {

  0008c	48 83 7c 24 50
	00		 cmp	 QWORD PTR ival$[rsp], 0
  00092	74 30		 je	 SHORT $LN1@PyLong_Fro@10

; 1174 :             *p++ = (digit)(ival & PyLong_MASK);

  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR ival$[rsp]
  00099	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  0009f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$21030[rsp]
  000a4	89 01		 mov	 DWORD PTR [rcx], eax
  000a6	48 8b 44 24 38	 mov	 rax, QWORD PTR p$21030[rsp]
  000ab	48 83 c0 04	 add	 rax, 4
  000af	48 89 44 24 38	 mov	 QWORD PTR p$21030[rsp], rax

; 1175 :             ival >>= PyLong_SHIFT;

  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR ival$[rsp]
  000b9	48 c1 e8 1e	 shr	 rax, 30
  000bd	48 89 44 24 50	 mov	 QWORD PTR ival$[rsp], rax

; 1176 :         }

  000c2	eb c8		 jmp	 SHORT $LN2@PyLong_Fro@10
$LN1@PyLong_Fro@10:
$LN3@PyLong_Fro@10:

; 1177 :     }
; 1178 :     return (PyObject *)v;

  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN7@PyLong_Fro@10:

; 1179 : }

  000c9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cd	c3		 ret	 0
PyLong_FromSize_t ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsLongLong DD imagerel $LN16
	DD	imagerel $LN16+320
	DD	imagerel $unwind$PyLong_AsLongLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsLongLong DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_AsLongLong
_TEXT	SEGMENT
res$ = 48
v$ = 56
do_decref$ = 64
bytes$ = 72
one$ = 80
tv75 = 88
vv$ = 112
PyLong_AsLongLong PROC					; COMDAT

; 1186 : {

$LN16:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1187 :     PyLongObject *v;
; 1188 :     PY_LONG_LONG bytes;
; 1189 :     int one = 1;

  00009	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR one$[rsp], 1

; 1190 :     int res;
; 1191 :     int do_decref = 0; /* if nb_int was called */

  00011	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR do_decref$[rsp], 0

; 1192 : 
; 1193 :     if (vv == NULL) {

  00019	48 83 7c 24 70
	00		 cmp	 QWORD PTR vv$[rsp], 0
  0001f	75 1d		 jne	 SHORT $LN13@PyLong_AsL@3

; 1194 :         PyErr_BadInternalCall();

  00021	ba aa 04 00 00	 mov	 edx, 1194		; 000004aaH
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0002d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1195 :         return -1;

  00032	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00039	e9 fd 00 00 00	 jmp	 $LN14@PyLong_AsL@3
$LN13@PyLong_AsL@3:

; 1196 :     }
; 1197 : 
; 1198 :     if (PyLong_Check(vv)) {

  0003e	48 8b 44 24 70	 mov	 rax, QWORD PTR vv$[rsp]
  00043	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00047	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00052	85 c0		 test	 eax, eax
  00054	74 0c		 je	 SHORT $LN12@PyLong_AsL@3

; 1199 :         v = (PyLongObject *)vv;

  00056	48 8b 44 24 70	 mov	 rax, QWORD PTR vv$[rsp]
  0005b	48 89 44 24 38	 mov	 QWORD PTR v$[rsp], rax

; 1200 :     }
; 1201 :     else {

  00060	eb 2b		 jmp	 SHORT $LN11@PyLong_AsL@3
$LN12@PyLong_AsL@3:

; 1202 :         v = _PyLong_FromNbInt(vv);

  00062	48 8b 4c 24 70	 mov	 rcx, QWORD PTR vv$[rsp]
  00067	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  0006c	48 89 44 24 38	 mov	 QWORD PTR v$[rsp], rax

; 1203 :         if (v == NULL)

  00071	48 83 7c 24 38
	00		 cmp	 QWORD PTR v$[rsp], 0
  00077	75 0c		 jne	 SHORT $LN10@PyLong_AsL@3

; 1204 :             return -1;

  00079	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00080	e9 b6 00 00 00	 jmp	 $LN14@PyLong_AsL@3
$LN10@PyLong_AsL@3:

; 1205 :         do_decref = 1;

  00085	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR do_decref$[rsp], 1
$LN11@PyLong_AsL@3:

; 1206 :     }
; 1207 : 
; 1208 :     res = 0;

  0008d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR res$[rsp], 0

; 1209 :     switch(Py_SIZE(v)) {

  00095	48 8b 44 24 38	 mov	 rax, QWORD PTR v$[rsp]
  0009a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0009e	48 89 44 24 58	 mov	 QWORD PTR tv75[rsp], rax
  000a3	48 83 7c 24 58
	ff		 cmp	 QWORD PTR tv75[rsp], -1
  000a9	74 12		 je	 SHORT $LN7@PyLong_AsL@3
  000ab	48 83 7c 24 58
	00		 cmp	 QWORD PTR tv75[rsp], 0
  000b1	74 1d		 je	 SHORT $LN6@PyLong_AsL@3
  000b3	48 83 7c 24 58
	01		 cmp	 QWORD PTR tv75[rsp], 1
  000b9	74 20		 je	 SHORT $LN5@PyLong_AsL@3
  000bb	eb 2d		 jmp	 SHORT $LN4@PyLong_AsL@3
$LN7@PyLong_AsL@3:

; 1210 :     case -1:
; 1211 :         bytes = -(sdigit)v->ob_digit[0];

  000bd	48 8b 44 24 38	 mov	 rax, QWORD PTR v$[rsp]
  000c2	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000c5	f7 d8		 neg	 eax
  000c7	48 98		 cdqe
  000c9	48 89 44 24 48	 mov	 QWORD PTR bytes$[rsp], rax

; 1212 :         break;

  000ce	eb 43		 jmp	 SHORT $LN8@PyLong_AsL@3
$LN6@PyLong_AsL@3:

; 1213 :     case 0:
; 1214 :         bytes = 0;

  000d0	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR bytes$[rsp], 0

; 1215 :         break;

  000d9	eb 38		 jmp	 SHORT $LN8@PyLong_AsL@3
$LN5@PyLong_AsL@3:

; 1216 :     case 1:
; 1217 :         bytes = v->ob_digit[0];

  000db	48 8b 44 24 38	 mov	 rax, QWORD PTR v$[rsp]
  000e0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000e3	48 89 44 24 48	 mov	 QWORD PTR bytes$[rsp], rax

; 1218 :         break;

  000e8	eb 29		 jmp	 SHORT $LN8@PyLong_AsL@3
$LN4@PyLong_AsL@3:

; 1219 :     default:
; 1220 :         res = _PyLong_AsByteArray((PyLongObject *)v, (unsigned char *)&bytes,
; 1221 :                                   SIZEOF_LONG_LONG, IS_LITTLE_ENDIAN, 1);

  000ea	0f b6 44 24 50	 movzx	 eax, BYTE PTR one$[rsp]
  000ef	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f7	44 8b c8	 mov	 r9d, eax
  000fa	41 b8 08 00 00
	00		 mov	 r8d, 8
  00100	48 8d 54 24 48	 lea	 rdx, QWORD PTR bytes$[rsp]
  00105	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  0010a	e8 00 00 00 00	 call	 _PyLong_AsByteArray
  0010f	89 44 24 30	 mov	 DWORD PTR res$[rsp], eax
$LN8@PyLong_AsL@3:

; 1222 :     }
; 1223 :     if (do_decref) {

  00113	83 7c 24 40 00	 cmp	 DWORD PTR do_decref$[rsp], 0
  00118	74 0a		 je	 SHORT $LN3@PyLong_AsL@3

; 1224 :         Py_DECREF(v);

  0011a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  0011f	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyLong_AsL@3:

; 1225 :     }
; 1226 : 
; 1227 :     /* Plan 9 can't handle PY_LONG_LONG in ? : expressions */
; 1228 :     if (res < 0)

  00124	83 7c 24 30 00	 cmp	 DWORD PTR res$[rsp], 0
  00129	7d 0b		 jge	 SHORT $LN2@PyLong_AsL@3

; 1229 :         return (PY_LONG_LONG)-1;

  0012b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00132	eb 07		 jmp	 SHORT $LN14@PyLong_AsL@3

; 1230 :     else

  00134	eb 05		 jmp	 SHORT $LN1@PyLong_AsL@3
$LN2@PyLong_AsL@3:

; 1231 :         return bytes;

  00136	48 8b 44 24 48	 mov	 rax, QWORD PTR bytes$[rsp]
$LN1@PyLong_AsL@3:
$LN14@PyLong_AsL@3:

; 1232 : }

  0013b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0013f	c3		 ret	 0
PyLong_AsLongLong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsUnsignedLongLong DD imagerel $LN11
	DD	imagerel $LN11+229
	DD	imagerel $unwind$PyLong_AsUnsignedLongLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsUnsignedLongLong DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_AsUnsignedLongLong
_TEXT	SEGMENT
res$ = 48
v$ = 56
bytes$ = 64
one$ = 72
tv74 = 80
vv$ = 112
PyLong_AsUnsignedLongLong PROC				; COMDAT

; 1239 : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1240 :     PyLongObject *v;
; 1241 :     unsigned PY_LONG_LONG bytes;
; 1242 :     int one = 1;

  00009	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR one$[rsp], 1

; 1243 :     int res;
; 1244 : 
; 1245 :     if (vv == NULL) {

  00011	48 83 7c 24 70
	00		 cmp	 QWORD PTR vv$[rsp], 0
  00017	75 1d		 jne	 SHORT $LN8@PyLong_AsU@4

; 1246 :         PyErr_BadInternalCall();

  00019	ba de 04 00 00	 mov	 edx, 1246		; 000004deH
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00025	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1247 :         return (unsigned PY_LONG_LONG)-1;

  0002a	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00031	e9 aa 00 00 00	 jmp	 $LN9@PyLong_AsU@4
$LN8@PyLong_AsU@4:

; 1248 :     }
; 1249 :     if (!PyLong_Check(vv)) {

  00036	48 8b 44 24 70	 mov	 rax, QWORD PTR vv$[rsp]
  0003b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00045	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0004a	85 c0		 test	 eax, eax
  0004c	75 1c		 jne	 SHORT $LN7@PyLong_AsU@4

; 1250 :         PyErr_SetString(PyExc_TypeError, "an integer is required");

  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0005c	e8 00 00 00 00	 call	 PyErr_SetString

; 1251 :         return (unsigned PY_LONG_LONG)-1;

  00061	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00068	eb 76		 jmp	 SHORT $LN9@PyLong_AsU@4
$LN7@PyLong_AsU@4:

; 1252 :     }
; 1253 : 
; 1254 :     v = (PyLongObject*)vv;

  0006a	48 8b 44 24 70	 mov	 rax, QWORD PTR vv$[rsp]
  0006f	48 89 44 24 38	 mov	 QWORD PTR v$[rsp], rax

; 1255 :     switch(Py_SIZE(v)) {

  00074	48 8b 44 24 38	 mov	 rax, QWORD PTR v$[rsp]
  00079	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0007d	48 89 44 24 50	 mov	 QWORD PTR tv74[rsp], rax
  00082	48 83 7c 24 50
	00		 cmp	 QWORD PTR tv74[rsp], 0
  00088	74 0a		 je	 SHORT $LN4@PyLong_AsU@4
  0008a	48 83 7c 24 50
	01		 cmp	 QWORD PTR tv74[rsp], 1
  00090	74 06		 je	 SHORT $LN3@PyLong_AsU@4
  00092	eb 0e		 jmp	 SHORT $LN5@PyLong_AsU@4
$LN4@PyLong_AsU@4:

; 1256 :     case 0: return 0;

  00094	33 c0		 xor	 eax, eax
  00096	eb 48		 jmp	 SHORT $LN9@PyLong_AsU@4
$LN3@PyLong_AsU@4:

; 1257 :     case 1: return v->ob_digit[0];

  00098	48 8b 44 24 38	 mov	 rax, QWORD PTR v$[rsp]
  0009d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000a0	eb 3e		 jmp	 SHORT $LN9@PyLong_AsU@4
$LN5@PyLong_AsU@4:

; 1258 :     }
; 1259 : 
; 1260 :     res = _PyLong_AsByteArray((PyLongObject *)vv, (unsigned char *)&bytes,
; 1261 :                               SIZEOF_LONG_LONG, IS_LITTLE_ENDIAN, 0);

  000a2	0f b6 44 24 48	 movzx	 eax, BYTE PTR one$[rsp]
  000a7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  000af	44 8b c8	 mov	 r9d, eax
  000b2	41 b8 08 00 00
	00		 mov	 r8d, 8
  000b8	48 8d 54 24 40	 lea	 rdx, QWORD PTR bytes$[rsp]
  000bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR vv$[rsp]
  000c2	e8 00 00 00 00	 call	 _PyLong_AsByteArray
  000c7	89 44 24 30	 mov	 DWORD PTR res$[rsp], eax

; 1262 : 
; 1263 :     /* Plan 9 can't handle PY_LONG_LONG in ? : expressions */
; 1264 :     if (res < 0)

  000cb	83 7c 24 30 00	 cmp	 DWORD PTR res$[rsp], 0
  000d0	7d 09		 jge	 SHORT $LN2@PyLong_AsU@4

; 1265 :         return (unsigned PY_LONG_LONG)res;

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR res$[rsp]
  000d7	eb 07		 jmp	 SHORT $LN9@PyLong_AsU@4

; 1266 :     else

  000d9	eb 05		 jmp	 SHORT $LN1@PyLong_AsU@4
$LN2@PyLong_AsU@4:

; 1267 :         return bytes;

  000db	48 8b 44 24 40	 mov	 rax, QWORD PTR bytes$[rsp]
$LN1@PyLong_AsU@4:
$LN9@PyLong_AsU@4:

; 1268 : }

  000e0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e4	c3		 ret	 0
PyLong_AsUnsignedLongLong ENDP
_TEXT	ENDS
PUBLIC	PyLong_AsUnsignedLongLongMask
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsUnsignedLongLongMask DD imagerel $LN6
	DD	imagerel $LN6+144
	DD	imagerel $unwind$PyLong_AsUnsignedLongLongMask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsUnsignedLongLongMask DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_AsUnsignedLongLongMask
_TEXT	SEGMENT
lo$ = 32
val$ = 40
op$ = 64
PyLong_AsUnsignedLongLongMask PROC			; COMDAT

; 1305 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1306 :     PyLongObject *lo;
; 1307 :     unsigned PY_LONG_LONG val;
; 1308 : 
; 1309 :     if (op == NULL) {

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR op$[rsp], 0
  0000f	75 18		 jne	 SHORT $LN3@PyLong_AsU@5

; 1310 :         PyErr_BadInternalCall();

  00011	ba 1e 05 00 00	 mov	 edx, 1310		; 0000051eH
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0001d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1311 :         return (unsigned long)-1;

  00022	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00027	eb 62		 jmp	 SHORT $LN4@PyLong_AsU@5
$LN3@PyLong_AsU@5:

; 1312 :     }
; 1313 : 
; 1314 :     if (PyLong_Check(op)) {

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0002e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00032	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00038	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003d	85 c0		 test	 eax, eax
  0003f	74 0c		 je	 SHORT $LN2@PyLong_AsU@5

; 1315 :         return _PyLong_AsUnsignedLongLongMask(op);

  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00046	e8 00 00 00 00	 call	 _PyLong_AsUnsignedLongLongMask
  0004b	eb 3e		 jmp	 SHORT $LN4@PyLong_AsU@5
$LN2@PyLong_AsU@5:

; 1316 :     }
; 1317 : 
; 1318 :     lo = _PyLong_FromNbInt(op);

  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00052	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00057	48 89 44 24 20	 mov	 QWORD PTR lo$[rsp], rax

; 1319 :     if (lo == NULL)

  0005c	48 83 7c 24 20
	00		 cmp	 QWORD PTR lo$[rsp], 0
  00062	75 09		 jne	 SHORT $LN1@PyLong_AsU@5

; 1320 :         return (unsigned PY_LONG_LONG)-1;

  00064	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0006b	eb 1e		 jmp	 SHORT $LN4@PyLong_AsU@5
$LN1@PyLong_AsU@5:

; 1321 : 
; 1322 :     val = _PyLong_AsUnsignedLongLongMask((PyObject *)lo);

  0006d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lo$[rsp]
  00072	e8 00 00 00 00	 call	 _PyLong_AsUnsignedLongLongMask
  00077	48 89 44 24 28	 mov	 QWORD PTR val$[rsp], rax

; 1323 :     Py_DECREF(lo);

  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lo$[rsp]
  00081	e8 00 00 00 00	 call	 _Py_DecRef

; 1324 :     return val;

  00086	48 8b 44 24 28	 mov	 rax, QWORD PTR val$[rsp]
$LN4@PyLong_AsU@5:

; 1325 : }

  0008b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008f	c3		 ret	 0
PyLong_AsUnsignedLongLongMask ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_AsUnsignedLongLongMask DD imagerel _PyLong_AsUnsignedLongLongMask
	DD	imagerel _PyLong_AsUnsignedLongLongMask+266
	DD	imagerel $unwind$_PyLong_AsUnsignedLongLongMask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_AsUnsignedLongLongMask DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyLong_AsUnsignedLongLongMask
_TEXT	SEGMENT
v$ = 32
x$ = 40
i$ = 48
sign$ = 56
tv72 = 64
vv$ = 96
_PyLong_AsUnsignedLongLongMask PROC			; COMDAT

; 1275 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1276 :     register PyLongObject *v;
; 1277 :     unsigned PY_LONG_LONG x;
; 1278 :     Py_ssize_t i;
; 1279 :     int sign;
; 1280 : 
; 1281 :     if (vv == NULL || !PyLong_Check(vv)) {

  00009	48 83 7c 24 60
	00		 cmp	 QWORD PTR vv$[rsp], 0
  0000f	74 18		 je	 SHORT $LN8@PyLong_AsU@6
  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  00016	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00020	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00025	85 c0		 test	 eax, eax
  00027	75 1b		 jne	 SHORT $LN9@PyLong_AsU@6
$LN8@PyLong_AsU@6:

; 1282 :         PyErr_BadInternalCall();

  00029	ba 02 05 00 00	 mov	 edx, 1282		; 00000502H
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00035	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1283 :         return (unsigned long) -1;

  0003a	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0003f	e9 c1 00 00 00	 jmp	 $LN10@PyLong_AsU@6
$LN9@PyLong_AsU@6:

; 1284 :     }
; 1285 :     v = (PyLongObject *)vv;

  00044	48 8b 44 24 60	 mov	 rax, QWORD PTR vv$[rsp]
  00049	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1286 :     switch(Py_SIZE(v)) {

  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00053	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00057	48 89 44 24 40	 mov	 QWORD PTR tv72[rsp], rax
  0005c	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv72[rsp], 0
  00062	74 0a		 je	 SHORT $LN5@PyLong_AsU@6
  00064	48 83 7c 24 40
	01		 cmp	 QWORD PTR tv72[rsp], 1
  0006a	74 09		 je	 SHORT $LN4@PyLong_AsU@6
  0006c	eb 14		 jmp	 SHORT $LN6@PyLong_AsU@6
$LN5@PyLong_AsU@6:

; 1287 :     case 0: return 0;

  0006e	33 c0		 xor	 eax, eax
  00070	e9 90 00 00 00	 jmp	 $LN10@PyLong_AsU@6
$LN4@PyLong_AsU@6:

; 1288 :     case 1: return v->ob_digit[0];

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  0007a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0007d	e9 83 00 00 00	 jmp	 $LN10@PyLong_AsU@6
$LN6@PyLong_AsU@6:

; 1289 :     }
; 1290 :     i = Py_SIZE(v);

  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00087	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008b	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 1291 :     sign = 1;

  00090	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1

; 1292 :     x = 0;

  00098	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 1293 :     if (i < 0) {

  000a1	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  000a7	7d 15		 jge	 SHORT $LN3@PyLong_AsU@6

; 1294 :         sign = -1;

  000a9	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR sign$[rsp], -1

; 1295 :         i = -i;

  000b1	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000b6	48 f7 d8	 neg	 rax
  000b9	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN3@PyLong_AsU@6:
$LN2@PyLong_AsU@6:

; 1296 :     }
; 1297 :     while (--i >= 0) {

  000be	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000c3	48 ff c8	 dec	 rax
  000c6	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  000cb	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  000d1	7c 21		 jl	 SHORT $LN1@PyLong_AsU@6

; 1298 :         x = (x << PyLong_SHIFT) | v->ob_digit[i];

  000d3	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  000d8	48 c1 e0 1e	 shl	 rax, 30
  000dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  000e1	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  000e6	8b 4c 91 70	 mov	 ecx, DWORD PTR [rcx+rdx*4+112]
  000ea	48 0b c1	 or	 rax, rcx
  000ed	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax

; 1299 :     }

  000f2	eb ca		 jmp	 SHORT $LN2@PyLong_AsU@6
$LN1@PyLong_AsU@6:

; 1300 :     return x * sign;

  000f4	48 63 44 24 38	 movsxd	 rax, DWORD PTR sign$[rsp]
  000f9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  000fe	48 0f af c8	 imul	 rcx, rax
  00102	48 8b c1	 mov	 rax, rcx
$LN10@PyLong_AsU@6:

; 1301 : }

  00105	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00109	c3		 ret	 0
_PyLong_AsUnsignedLongLongMask ENDP
_TEXT	ENDS
PUBLIC	PyLong_AsLongLongAndOverflow
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsLongLongAndOverflow DD imagerel $LN22
	DD	imagerel $LN22+521
	DD	imagerel $unwind$PyLong_AsLongLongAndOverflow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsLongLongAndOverflow DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_AsLongLongAndOverflow
_TEXT	SEGMENT
res$ = 32
v$ = 40
do_decref$ = 48
x$ = 56
i$ = 64
prev$ = 72
sign$ = 80
tv75 = 88
vv$ = 112
overflow$ = 120
PyLong_AsLongLongAndOverflow PROC			; COMDAT

; 1340 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1341 :     /* This version by Tim Peters */
; 1342 :     register PyLongObject *v;
; 1343 :     unsigned PY_LONG_LONG x, prev;
; 1344 :     PY_LONG_LONG res;
; 1345 :     Py_ssize_t i;
; 1346 :     int sign;
; 1347 :     int do_decref = 0; /* if nb_int was called */

  0000e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR do_decref$[rsp], 0

; 1348 : 
; 1349 :     *overflow = 0;

  00016	48 8b 44 24 78	 mov	 rax, QWORD PTR overflow$[rsp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1350 :     if (vv == NULL) {

  00021	48 83 7c 24 70
	00		 cmp	 QWORD PTR vv$[rsp], 0
  00027	75 1d		 jne	 SHORT $LN19@PyLong_AsL@4

; 1351 :         PyErr_BadInternalCall();

  00029	ba 47 05 00 00	 mov	 edx, 1351		; 00000547H
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00035	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1352 :         return -1;

  0003a	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00041	e9 be 01 00 00	 jmp	 $LN20@PyLong_AsL@4
$LN19@PyLong_AsL@4:

; 1353 :     }
; 1354 : 
; 1355 :     if (PyLong_Check(vv)) {

  00046	48 8b 44 24 70	 mov	 rax, QWORD PTR vv$[rsp]
  0004b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00055	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0005a	85 c0		 test	 eax, eax
  0005c	74 0c		 je	 SHORT $LN18@PyLong_AsL@4

; 1356 :         v = (PyLongObject *)vv;

  0005e	48 8b 44 24 70	 mov	 rax, QWORD PTR vv$[rsp]
  00063	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 1357 :     }
; 1358 :     else {

  00068	eb 2b		 jmp	 SHORT $LN17@PyLong_AsL@4
$LN18@PyLong_AsL@4:

; 1359 :         v = _PyLong_FromNbInt(vv);

  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR vv$[rsp]
  0006f	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00074	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 1360 :         if (v == NULL)

  00079	48 83 7c 24 28
	00		 cmp	 QWORD PTR v$[rsp], 0
  0007f	75 0c		 jne	 SHORT $LN16@PyLong_AsL@4

; 1361 :             return -1;

  00081	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00088	e9 77 01 00 00	 jmp	 $LN20@PyLong_AsL@4
$LN16@PyLong_AsL@4:

; 1362 :         do_decref = 1;

  0008d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR do_decref$[rsp], 1
$LN17@PyLong_AsL@4:

; 1363 :     }
; 1364 : 
; 1365 :     res = -1;

  00095	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR res$[rsp], -1

; 1366 :     i = Py_SIZE(v);

  0009e	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  000a3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a7	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax

; 1367 : 
; 1368 :     switch (i) {

  000ac	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  000b1	48 89 44 24 58	 mov	 QWORD PTR tv75[rsp], rax
  000b6	48 83 7c 24 58
	ff		 cmp	 QWORD PTR tv75[rsp], -1
  000bc	74 12		 je	 SHORT $LN13@PyLong_AsL@4
  000be	48 83 7c 24 58
	00		 cmp	 QWORD PTR tv75[rsp], 0
  000c4	74 20		 je	 SHORT $LN12@PyLong_AsL@4
  000c6	48 83 7c 24 58
	01		 cmp	 QWORD PTR tv75[rsp], 1
  000cc	74 26		 je	 SHORT $LN11@PyLong_AsL@4
  000ce	eb 36		 jmp	 SHORT $LN10@PyLong_AsL@4
$LN13@PyLong_AsL@4:

; 1369 :     case -1:
; 1370 :         res = -(sdigit)v->ob_digit[0];

  000d0	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  000d5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000d8	f7 d8		 neg	 eax
  000da	48 98		 cdqe
  000dc	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 1371 :         break;

  000e1	e9 08 01 00 00	 jmp	 $LN14@PyLong_AsL@4
$LN12@PyLong_AsL@4:

; 1372 :     case 0:
; 1373 :         res = 0;

  000e6	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR res$[rsp], 0

; 1374 :         break;

  000ef	e9 fa 00 00 00	 jmp	 $LN14@PyLong_AsL@4
$LN11@PyLong_AsL@4:

; 1375 :     case 1:
; 1376 :         res = v->ob_digit[0];

  000f4	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  000f9	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000fc	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 1377 :         break;

  00101	e9 e8 00 00 00	 jmp	 $LN14@PyLong_AsL@4
$LN10@PyLong_AsL@4:

; 1378 :     default:
; 1379 :         sign = 1;

  00106	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1

; 1380 :         x = 0;

  0010e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 1381 :         if (i < 0) {

  00117	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  0011d	7d 15		 jge	 SHORT $LN9@PyLong_AsL@4

; 1382 :             sign = -1;

  0011f	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR sign$[rsp], -1

; 1383 :             i = -(i);

  00127	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0012c	48 f7 d8	 neg	 rax
  0012f	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN9@PyLong_AsL@4:
$LN8@PyLong_AsL@4:

; 1384 :         }
; 1385 :         while (--i >= 0) {

  00134	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00139	48 ff c8	 dec	 rax
  0013c	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00141	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  00147	7c 48		 jl	 SHORT $LN7@PyLong_AsL@4

; 1386 :             prev = x;

  00149	48 8b 44 24 38	 mov	 rax, QWORD PTR x$[rsp]
  0014e	48 89 44 24 48	 mov	 QWORD PTR prev$[rsp], rax

; 1387 :             x = (x << PyLong_SHIFT) + v->ob_digit[i];

  00153	48 8b 44 24 38	 mov	 rax, QWORD PTR x$[rsp]
  00158	48 c1 e0 1e	 shl	 rax, 30
  0015c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  00161	48 8b 54 24 40	 mov	 rdx, QWORD PTR i$[rsp]
  00166	8b 4c 91 70	 mov	 ecx, DWORD PTR [rcx+rdx*4+112]
  0016a	48 03 c1	 add	 rax, rcx
  0016d	48 89 44 24 38	 mov	 QWORD PTR x$[rsp], rax

; 1388 :             if ((x >> PyLong_SHIFT) != prev) {

  00172	48 8b 44 24 38	 mov	 rax, QWORD PTR x$[rsp]
  00177	48 c1 e8 1e	 shr	 rax, 30
  0017b	48 3b 44 24 48	 cmp	 rax, QWORD PTR prev$[rsp]
  00180	74 0d		 je	 SHORT $LN6@PyLong_AsL@4

; 1389 :                 *overflow = sign;

  00182	48 8b 44 24 78	 mov	 rax, QWORD PTR overflow$[rsp]
  00187	8b 4c 24 50	 mov	 ecx, DWORD PTR sign$[rsp]
  0018b	89 08		 mov	 DWORD PTR [rax], ecx

; 1390 :                 goto exit;

  0018d	eb 5f		 jmp	 SHORT $exit$21178
$LN6@PyLong_AsL@4:

; 1391 :             }
; 1392 :         }

  0018f	eb a3		 jmp	 SHORT $LN8@PyLong_AsL@4
$LN7@PyLong_AsL@4:

; 1393 :         /* Haven't lost any bits, but casting to long requires extra
; 1394 :          * care (see comment above).
; 1395 :          */
; 1396 :         if (x <= (unsigned PY_LONG_LONG)PY_LLONG_MAX) {

  00191	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0019b	48 39 44 24 38	 cmp	 QWORD PTR x$[rsp], rax
  001a0	77 18		 ja	 SHORT $LN5@PyLong_AsL@4

; 1397 :             res = (PY_LONG_LONG)x * sign;

  001a2	48 63 44 24 50	 movsxd	 rax, DWORD PTR sign$[rsp]
  001a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x$[rsp]
  001ac	48 0f af c8	 imul	 rcx, rax
  001b0	48 8b c1	 mov	 rax, rcx
  001b3	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax
  001b8	eb 34		 jmp	 SHORT $LN4@PyLong_AsL@4
$LN5@PyLong_AsL@4:

; 1398 :         }
; 1399 :         else if (sign < 0 && x == PY_ABS_LLONG_MIN) {

  001ba	83 7c 24 50 00	 cmp	 DWORD PTR sign$[rsp], 0
  001bf	7d 22		 jge	 SHORT $LN3@PyLong_AsL@4
  001c1	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001cb	48 39 44 24 38	 cmp	 QWORD PTR x$[rsp], rax
  001d0	75 11		 jne	 SHORT $LN3@PyLong_AsL@4

; 1400 :             res = PY_LLONG_MIN;

  001d2	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  001dc	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 1401 :         }
; 1402 :         else {

  001e1	eb 0b		 jmp	 SHORT $LN2@PyLong_AsL@4
$LN3@PyLong_AsL@4:

; 1403 :             *overflow = sign;

  001e3	48 8b 44 24 78	 mov	 rax, QWORD PTR overflow$[rsp]
  001e8	8b 4c 24 50	 mov	 ecx, DWORD PTR sign$[rsp]
  001ec	89 08		 mov	 DWORD PTR [rax], ecx
$LN2@PyLong_AsL@4:
$LN4@PyLong_AsL@4:
$LN14@PyLong_AsL@4:
$exit$21178:

; 1404 :             /* res is already set to -1 */
; 1405 :         }
; 1406 :     }
; 1407 :   exit:
; 1408 :     if (do_decref) {

  001ee	83 7c 24 30 00	 cmp	 DWORD PTR do_decref$[rsp], 0
  001f3	74 0a		 je	 SHORT $LN1@PyLong_AsL@4

; 1409 :         Py_DECREF(v);

  001f5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  001fa	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyLong_AsL@4:

; 1410 :     }
; 1411 :     return res;

  001ff	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
$LN20@PyLong_AsL@4:

; 1412 : }

  00204	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00208	c3		 ret	 0
PyLong_AsLongLongAndOverflow ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_to_decimal_string DD imagerel long_to_decimal_string
	DD	imagerel long_to_decimal_string+46
	DD	imagerel $unwind$long_to_decimal_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_to_decimal_string DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_to_decimal_string
_TEXT	SEGMENT
v$ = 32
aa$ = 64
long_to_decimal_string PROC				; COMDAT

; 1734 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1735 :     PyObject *v;
; 1736 :     if (long_to_decimal_string_internal(aa, &v, NULL) == -1)

  00009	45 33 c0	 xor	 r8d, r8d
  0000c	48 8d 54 24 20	 lea	 rdx, QWORD PTR v$[rsp]
  00011	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aa$[rsp]
  00016	e8 00 00 00 00	 call	 long_to_decimal_string_internal
  0001b	83 f8 ff	 cmp	 eax, -1
  0001e	75 04		 jne	 SHORT $LN1@long_to_de

; 1737 :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	eb 05		 jmp	 SHORT $LN2@long_to_de
$LN1@long_to_de:

; 1738 :     return v;

  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN2@long_to_de:

; 1739 : }

  00029	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002d	c3		 ret	 0
long_to_decimal_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EI@DMGNHGGF@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAs?$AAt?$AAr?$AA?0@ ; `string'
PUBLIC	??_C@_1EG@GNEEJBAF@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@ ; `string'
PUBLIC	??_C@_1HM@HLIFOHHE@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@ ; `string'
PUBLIC	??_C@_1DK@MKLBCJPK@?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AA4?$AAB?$AAY?$AAT?$AAE?$AA_?$AAK?$AAI?$AAN?$AAD?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@LGIAMOCO@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@ ; `string'
PUBLIC	??_C@_1HM@NOGJJOMH@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@ ; `string'
PUBLIC	??_C@_1EG@DGNKGCJL@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@ ; `string'
PUBLIC	??_C@_1HM@GBCHCBDO@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@ ; `string'
PUBLIC	??_C@_1EI@DHHCGFBB@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@ ; `string'
PUBLIC	??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@ ; `string'
PUBLIC	??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@ ; `string'
PUBLIC	??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@IKKPLFAK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BM@IDJHHDAH@long?5is?5too?5large?5to?5format?$AA@ ; `string'
EXTRN	_PyUnicode_CheckConsistency:PROC
EXTRN	PyUnicode_New:PROC
EXTRN	_PyUnicodeWriter_PrepareInternal:PROC
EXTRN	PyErr_CheckSignals:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_to_decimal_string_internal DD imagerel long_to_decimal_string_internal
	DD	imagerel long_to_decimal_string_internal+7168
	DD	imagerel $unwind$long_to_decimal_string_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_to_decimal_string_internal DD 021601H
	DD	0330116H
xdata	ENDS
;	COMDAT ??_C@_1EI@DMGNHGGF@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAs?$AAt?$AAr?$AA?0@
CONST	SEGMENT
??_C@_1EI@DMGNHGGF@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAs?$AAt?$AAr?$AA?0@ DB '_'
	DB	00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e'
	DB	00H, 'c', 00H, 'k', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 's', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'y'
	DB	00H, '(', 00H, 's', 00H, 't', 00H, 'r', 00H, ',', 00H, ' ', 00H
	DB	'1', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@GNEEJBAF@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@
CONST	SEGMENT
??_C@_1EG@GNEEJBAF@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@ DB 'p'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 'P', 00H
	DB	'y', 00H, '_', 00H, 'U', 00H, 'C', 00H, 'S', 00H, '4', 00H, '*'
	DB	00H, ')', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'D', 00H, 'A'
	DB	00H, 'T', 00H, 'A', 00H, '(', 00H, 's', 00H, 't', 00H, 'r', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HM@HLIFOHHE@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@
CONST	SEGMENT
??_C@_1HM@HLIFOHHE@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@ DB 'p'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '(', 00H
	DB	'P', 00H, 'y', 00H, '_', 00H, 'U', 00H, 'C', 00H, 'S', 00H, '4'
	DB	00H, '*', 00H, ')', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H
	DB	'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'D'
	DB	00H, 'A', 00H, 'T', 00H, 'A', 00H, '(', 00H, 'w', 00H, 'r', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, '-', 00H, '>', 00H, 'b'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ')', 00H
	DB	' ', 00H, '+', 00H, ' ', 00H, 'w', 00H, 'r', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, '-', 00H, '>', 00H, 'p', 00H, 'o', 00H
	DB	's', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@MKLBCJPK@?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AA4?$AAB?$AAY?$AAT?$AAE?$AA_?$AAK?$AAI?$AAN?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@MKLBCJPK@?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AA4?$AAB?$AAY?$AAT?$AAE?$AA_?$AAK?$AAI?$AAN?$AAD?$AA?$AA@ DB 'k'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, '4', 00H, 'B', 00H
	DB	'Y', 00H, 'T', 00H, 'E', 00H, '_', 00H, 'K', 00H, 'I', 00H, 'N'
	DB	00H, 'D', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@LGIAMOCO@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@
CONST	SEGMENT
??_C@_1EG@LGIAMOCO@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@ DB 'p'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 'P', 00H
	DB	'y', 00H, '_', 00H, 'U', 00H, 'C', 00H, 'S', 00H, '2', 00H, '*'
	DB	00H, ')', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'D', 00H, 'A'
	DB	00H, 'T', 00H, 'A', 00H, '(', 00H, 's', 00H, 't', 00H, 'r', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HM@NOGJJOMH@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@
CONST	SEGMENT
??_C@_1HM@NOGJJOMH@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@ DB 'p'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '(', 00H
	DB	'P', 00H, 'y', 00H, '_', 00H, 'U', 00H, 'C', 00H, 'S', 00H, '2'
	DB	00H, '*', 00H, ')', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H
	DB	'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'D'
	DB	00H, 'A', 00H, 'T', 00H, 'A', 00H, '(', 00H, 'w', 00H, 'r', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, '-', 00H, '>', 00H, 'b'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ')', 00H
	DB	' ', 00H, '+', 00H, ' ', 00H, 'w', 00H, 'r', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, '-', 00H, '>', 00H, 'p', 00H, 'o', 00H
	DB	's', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@DGNKGCJL@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@
CONST	SEGMENT
??_C@_1EG@DGNKGCJL@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@ DB 'p'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 'P', 00H
	DB	'y', 00H, '_', 00H, 'U', 00H, 'C', 00H, 'S', 00H, '1', 00H, '*'
	DB	00H, ')', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'D', 00H, 'A'
	DB	00H, 'T', 00H, 'A', 00H, '(', 00H, 's', 00H, 't', 00H, 'r', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HM@GBCHCBDO@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@
CONST	SEGMENT
??_C@_1HM@GBCHCBDO@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@ DB 'p'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '(', 00H
	DB	'P', 00H, 'y', 00H, '_', 00H, 'U', 00H, 'C', 00H, 'S', 00H, '1'
	DB	00H, '*', 00H, ')', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H
	DB	'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'D'
	DB	00H, 'A', 00H, 'T', 00H, 'A', 00H, '(', 00H, 'w', 00H, 'r', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, '-', 00H, '>', 00H, 'b'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ')', 00H
	DB	' ', 00H, '+', 00H, ' ', 00H, 'w', 00H, 'r', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, '-', 00H, '>', 00H, 'p', 00H, 'o', 00H
	DB	's', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@DHHCGFBB@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
CONST	SEGMENT
??_C@_1EI@DHHCGFBB@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, ')', 00H, ')', 00H, '-', 00H, '>'
	DB	00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, '.', 00H, 'a', 00H
	DB	'n', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
CONST	SEGMENT
??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'w', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, '-'
	DB	00H, '>', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, ')', 00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
CONST	SEGMENT
??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'w', 00H
	DB	'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, '-', 00H, '>'
	DB	00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'w', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, '-', 00H, '>', 00H, 'b', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@IKKPLFAK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@IKKPLFAK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 's', 00H, 't', 00H, 'r', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IDJHHDAH@long?5is?5too?5large?5to?5format?$AA@
CONST	SEGMENT
??_C@_0BM@IDJHHDAH@long?5is?5too?5large?5to?5format?$AA@ DB 'long is too '
	DB	'large to format', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_to_decimal_string_internal
_TEXT	SEGMENT
kind$ = 32
negative$ = 36
pout$ = 40
a$ = 48
tenpow$ = 56
i$ = 64
rem$ = 72
scratch$ = 80
size$ = 88
strlen$ = 96
pin$ = 104
size_a$ = 112
j$ = 120
str$ = 128
hi$21375 = 136
z$21379 = 144
p$21417 = 152
p$21509 = 160
p$21596 = 168
tv76 = 176
tv79 = 184
tv181 = 188
tv180 = 192
tv244 = 200
tv253 = 208
tv290 = 216
tv299 = 224
tv357 = 232
tv366 = 240
tv407 = 248
tv416 = 256
tv458 = 264
tv467 = 272
tv506 = 280
tv515 = 288
tv574 = 296
tv583 = 304
tv625 = 312
tv634 = 320
tv680 = 328
tv689 = 336
tv728 = 344
tv737 = 352
tv794 = 360
tv803 = 368
tv845 = 376
tv854 = 384
aa$ = 416
p_output$ = 424
writer$ = 432
long_to_decimal_string_internal PROC			; COMDAT

; 1580 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H

; 1581 :     PyLongObject *scratch, *a;
; 1582 :     PyObject *str;
; 1583 :     Py_ssize_t size, strlen, size_a, i, j;
; 1584 :     digit *pout, *pin, rem, tenpow;
; 1585 :     int negative;
; 1586 :     enum PyUnicode_Kind kind;
; 1587 : 
; 1588 :     a = (PyLongObject *)aa;

  00016	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR aa$[rsp]
  0001e	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 1589 :     if (a == NULL || !PyLong_Check(a)) {

  00023	48 83 7c 24 30
	00		 cmp	 QWORD PTR a$[rsp], 0
  00029	74 18		 je	 SHORT $LN78@long_to_de@2
  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00030	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00034	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003a	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003f	85 c0		 test	 eax, eax
  00041	75 1b		 jne	 SHORT $LN79@long_to_de@2
$LN78@long_to_de@2:

; 1590 :         PyErr_BadInternalCall();

  00043	ba 36 06 00 00	 mov	 edx, 1590		; 00000636H
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0004f	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1591 :         return -1;

  00054	b8 ff ff ff ff	 mov	 eax, -1
  00059	e9 9a 1b 00 00	 jmp	 $LN80@long_to_de@2
$LN79@long_to_de@2:

; 1592 :     }
; 1593 :     size_a = ABS(Py_SIZE(a));

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00063	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00068	7d 16		 jge	 SHORT $LN82@long_to_de@2
  0006a	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0006f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00073	48 f7 d8	 neg	 rax
  00076	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv76[rsp], rax
  0007e	eb 11		 jmp	 SHORT $LN83@long_to_de@2
$LN82@long_to_de@2:
  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00085	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00089	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv76[rsp], rax
$LN83@long_to_de@2:
  00091	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv76[rsp]
  00099	48 89 44 24 70	 mov	 QWORD PTR size_a$[rsp], rax

; 1594 :     negative = Py_SIZE(a) < 0;

  0009e	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000a3	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a8	7d 0d		 jge	 SHORT $LN84@long_to_de@2
  000aa	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv79[rsp], 1
  000b5	eb 0b		 jmp	 SHORT $LN85@long_to_de@2
$LN84@long_to_de@2:
  000b7	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv79[rsp], 0
$LN85@long_to_de@2:
  000c2	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv79[rsp]
  000c9	89 44 24 24	 mov	 DWORD PTR negative$[rsp], eax

; 1595 : 
; 1596 :     /* quick and dirty upper bound for the number of digits
; 1597 :        required to express a in base _PyLong_DECIMAL_BASE:
; 1598 : 
; 1599 :          #digits = 1 + floor(log2(a) / log2(_PyLong_DECIMAL_BASE))
; 1600 : 
; 1601 :        But log2(a) < size_a * PyLong_SHIFT, and
; 1602 :        log2(_PyLong_DECIMAL_BASE) = log2(10) * _PyLong_DECIMAL_SHIFT
; 1603 :                                   > 3 * _PyLong_DECIMAL_SHIFT
; 1604 :     */
; 1605 :     if (size_a > PY_SSIZE_T_MAX / PyLong_SHIFT) {

  000cd	48 b8 44 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825860	; 0444444444444444H
  000d7	48 39 44 24 70	 cmp	 QWORD PTR size_a$[rsp], rax
  000dc	7e 1d		 jle	 SHORT $LN77@long_to_de@2

; 1606 :         PyErr_SetString(PyExc_OverflowError,
; 1607 :                         "long is too large to format");

  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@IDJHHDAH@long?5is?5too?5large?5to?5format?$AA@
  000e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000ec	e8 00 00 00 00	 call	 PyErr_SetString

; 1608 :         return -1;

  000f1	b8 ff ff ff ff	 mov	 eax, -1
  000f6	e9 fd 1a 00 00	 jmp	 $LN80@long_to_de@2
$LN77@long_to_de@2:

; 1609 :     }
; 1610 :     /* the expression size_a * PyLong_SHIFT is now safe from overflow */
; 1611 :     size = 1 + size_a * PyLong_SHIFT / (3 * _PyLong_DECIMAL_SHIFT);

  000fb	48 8b 44 24 70	 mov	 rax, QWORD PTR size_a$[rsp]
  00100	48 6b c0 1e	 imul	 rax, 30
  00104	48 99		 cdq
  00106	b9 1b 00 00 00	 mov	 ecx, 27
  0010b	48 f7 f9	 idiv	 rcx
  0010e	48 ff c0	 inc	 rax
  00111	48 89 44 24 58	 mov	 QWORD PTR size$[rsp], rax

; 1612 :     scratch = _PyLong_New(size);

  00116	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  0011b	e8 00 00 00 00	 call	 _PyLong_New
  00120	48 89 44 24 50	 mov	 QWORD PTR scratch$[rsp], rax

; 1613 :     if (scratch == NULL)

  00125	48 83 7c 24 50
	00		 cmp	 QWORD PTR scratch$[rsp], 0
  0012b	75 0a		 jne	 SHORT $LN76@long_to_de@2

; 1614 :         return -1;

  0012d	b8 ff ff ff ff	 mov	 eax, -1
  00132	e9 c1 1a 00 00	 jmp	 $LN80@long_to_de@2
$LN76@long_to_de@2:

; 1615 : 
; 1616 :     /* convert array of base _PyLong_BASE digits in pin to an array of
; 1617 :        base _PyLong_DECIMAL_BASE digits in pout, following Knuth (TAOCP,
; 1618 :        Volume 2 (3rd edn), section 4.4, Method 1b). */
; 1619 :     pin = a->ob_digit;

  00137	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0013c	48 83 c0 70	 add	 rax, 112		; 00000070H
  00140	48 89 44 24 68	 mov	 QWORD PTR pin$[rsp], rax

; 1620 :     pout = scratch->ob_digit;

  00145	48 8b 44 24 50	 mov	 rax, QWORD PTR scratch$[rsp]
  0014a	48 83 c0 70	 add	 rax, 112		; 00000070H
  0014e	48 89 44 24 28	 mov	 QWORD PTR pout$[rsp], rax

; 1621 :     size = 0;

  00153	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR size$[rsp], 0

; 1622 :     for (i = size_a; --i >= 0; ) {

  0015c	48 8b 44 24 70	 mov	 rax, QWORD PTR size_a$[rsp]
  00161	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN75@long_to_de@2:
  00166	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0016b	48 ff c8	 dec	 rax
  0016e	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00173	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  00179	0f 8c 16 01 00
	00		 jl	 $LN74@long_to_de@2

; 1623 :         digit hi = pin[i];

  0017f	48 8b 44 24 68	 mov	 rax, QWORD PTR pin$[rsp]
  00184	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00189	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0018c	89 84 24 88 00
	00 00		 mov	 DWORD PTR hi$21375[rsp], eax

; 1624 :         for (j = 0; j < size; j++) {

  00193	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  0019c	eb 0d		 jmp	 SHORT $LN73@long_to_de@2
$LN72@long_to_de@2:
  0019e	48 8b 44 24 78	 mov	 rax, QWORD PTR j$[rsp]
  001a3	48 ff c0	 inc	 rax
  001a6	48 89 44 24 78	 mov	 QWORD PTR j$[rsp], rax
$LN73@long_to_de@2:
  001ab	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  001b0	48 39 44 24 78	 cmp	 QWORD PTR j$[rsp], rax
  001b5	7d 67		 jge	 SHORT $LN71@long_to_de@2

; 1625 :             twodigits z = (twodigits)pout[j] << PyLong_SHIFT | hi;

  001b7	48 8b 44 24 28	 mov	 rax, QWORD PTR pout$[rsp]
  001bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR j$[rsp]
  001c1	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  001c4	48 c1 e0 1e	 shl	 rax, 30
  001c8	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR hi$21375[rsp]
  001cf	48 0b c1	 or	 rax, rcx
  001d2	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR z$21379[rsp], rax

; 1626 :             hi = (digit)(z / _PyLong_DECIMAL_BASE);

  001da	33 d2		 xor	 edx, edx
  001dc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$21379[rsp]
  001e4	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  001e9	48 f7 f1	 div	 rcx
  001ec	89 84 24 88 00
	00 00		 mov	 DWORD PTR hi$21375[rsp], eax

; 1627 :             pout[j] = (digit)(z - (twodigits)hi *
; 1628 :                               _PyLong_DECIMAL_BASE);

  001f3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR hi$21375[rsp]
  001fa	48 69 c0 00 ca
	9a 3b		 imul	 rax, 1000000000		; 3b9aca00H
  00201	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$21379[rsp]
  00209	48 2b c8	 sub	 rcx, rax
  0020c	48 8b c1	 mov	 rax, rcx
  0020f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pout$[rsp]
  00214	48 8b 54 24 78	 mov	 rdx, QWORD PTR j$[rsp]
  00219	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 1629 :         }

  0021c	eb 80		 jmp	 SHORT $LN72@long_to_de@2
$LN71@long_to_de@2:
$LN70@long_to_de@2:

; 1630 :         while (hi) {

  0021e	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR hi$21375[rsp], 0
  00226	74 45		 je	 SHORT $LN69@long_to_de@2

; 1631 :             pout[size++] = hi % _PyLong_DECIMAL_BASE;

  00228	33 d2		 xor	 edx, edx
  0022a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR hi$21375[rsp]
  00231	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00236	f7 f1		 div	 ecx
  00238	8b c2		 mov	 eax, edx
  0023a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pout$[rsp]
  0023f	48 8b 54 24 58	 mov	 rdx, QWORD PTR size$[rsp]
  00244	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  00247	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  0024c	48 ff c0	 inc	 rax
  0024f	48 89 44 24 58	 mov	 QWORD PTR size$[rsp], rax

; 1632 :             hi /= _PyLong_DECIMAL_BASE;

  00254	33 d2		 xor	 edx, edx
  00256	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR hi$21375[rsp]
  0025d	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00262	f7 f1		 div	 ecx
  00264	89 84 24 88 00
	00 00		 mov	 DWORD PTR hi$21375[rsp], eax

; 1633 :         }

  0026b	eb b1		 jmp	 SHORT $LN70@long_to_de@2
$LN69@long_to_de@2:
$LN68@long_to_de@2:

; 1634 :         /* check for keyboard interrupt */
; 1635 :         SIGCHECK({
; 1636 :                 Py_DECREF(scratch);
; 1637 :                 return -1;
; 1638 :             });

  0026d	e8 00 00 00 00	 call	 PyErr_CheckSignals
  00272	85 c0		 test	 eax, eax
  00274	74 14		 je	 SHORT $LN65@long_to_de@2
  00276	48 8b 4c 24 50	 mov	 rcx, QWORD PTR scratch$[rsp]
  0027b	e8 00 00 00 00	 call	 _Py_DecRef
  00280	b8 ff ff ff ff	 mov	 eax, -1
  00285	e9 6e 19 00 00	 jmp	 $LN80@long_to_de@2
$LN65@long_to_de@2:
  0028a	33 c0		 xor	 eax, eax
  0028c	85 c0		 test	 eax, eax
  0028e	75 dd		 jne	 SHORT $LN68@long_to_de@2

; 1639 :     }

  00290	e9 d1 fe ff ff	 jmp	 $LN75@long_to_de@2
$LN74@long_to_de@2:

; 1640 :     /* pout should have at least one digit, so that the case when a = 0
; 1641 :        works correctly */
; 1642 :     if (size == 0)

  00295	48 83 7c 24 58
	00		 cmp	 QWORD PTR size$[rsp], 0
  0029b	75 1e		 jne	 SHORT $LN64@long_to_de@2

; 1643 :         pout[size++] = 0;

  0029d	48 8b 44 24 28	 mov	 rax, QWORD PTR pout$[rsp]
  002a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  002a7	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [rax+rcx*4], 0
  002ae	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  002b3	48 ff c0	 inc	 rax
  002b6	48 89 44 24 58	 mov	 QWORD PTR size$[rsp], rax
$LN64@long_to_de@2:

; 1644 : 
; 1645 :     /* calculate exact length of output string, and allocate */
; 1646 :     strlen = negative + 1 + (size - 1) * _PyLong_DECIMAL_SHIFT;

  002bb	8b 44 24 24	 mov	 eax, DWORD PTR negative$[rsp]
  002bf	ff c0		 inc	 eax
  002c1	48 98		 cdqe
  002c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  002c8	48 ff c9	 dec	 rcx
  002cb	48 6b c9 09	 imul	 rcx, 9
  002cf	48 03 c1	 add	 rax, rcx
  002d2	48 89 44 24 60	 mov	 QWORD PTR strlen$[rsp], rax

; 1647 :     tenpow = 10;

  002d7	c7 44 24 38 0a
	00 00 00	 mov	 DWORD PTR tenpow$[rsp], 10

; 1648 :     rem = pout[size-1];

  002df	48 8b 44 24 28	 mov	 rax, QWORD PTR pout$[rsp]
  002e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  002e9	8b 44 88 fc	 mov	 eax, DWORD PTR [rax+rcx*4-4]
  002ed	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
$LN63@long_to_de@2:

; 1649 :     while (rem >= tenpow) {

  002f1	8b 44 24 38	 mov	 eax, DWORD PTR tenpow$[rsp]
  002f5	39 44 24 48	 cmp	 DWORD PTR rem$[rsp], eax
  002f9	72 1a		 jb	 SHORT $LN62@long_to_de@2

; 1650 :         tenpow *= 10;

  002fb	8b 44 24 38	 mov	 eax, DWORD PTR tenpow$[rsp]
  002ff	6b c0 0a	 imul	 eax, 10
  00302	89 44 24 38	 mov	 DWORD PTR tenpow$[rsp], eax

; 1651 :         strlen++;

  00306	48 8b 44 24 60	 mov	 rax, QWORD PTR strlen$[rsp]
  0030b	48 ff c0	 inc	 rax
  0030e	48 89 44 24 60	 mov	 QWORD PTR strlen$[rsp], rax

; 1652 :     }

  00313	eb dc		 jmp	 SHORT $LN63@long_to_de@2
$LN62@long_to_de@2:

; 1653 :     if (writer) {

  00315	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  0031e	0f 84 bd 00 00
	00		 je	 $LN61@long_to_de@2

; 1654 :         if (_PyUnicodeWriter_Prepare(writer, strlen, '9') == -1) {

  00324	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0032c	83 78 14 39	 cmp	 DWORD PTR [rax+20], 57	; 00000039H
  00330	72 2f		 jb	 SHORT $LN86@long_to_de@2
  00332	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0033a	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR writer$[rsp]
  00342	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00346	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0034a	48 2b c1	 sub	 rax, rcx
  0034d	48 39 44 24 60	 cmp	 QWORD PTR strlen$[rsp], rax
  00352	7f 0d		 jg	 SHORT $LN86@long_to_de@2
  00354	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv181[rsp], 0
  0035f	eb 42		 jmp	 SHORT $LN89@long_to_de@2
$LN86@long_to_de@2:
  00361	48 83 7c 24 60
	00		 cmp	 QWORD PTR strlen$[rsp], 0
  00367	75 0d		 jne	 SHORT $LN87@long_to_de@2
  00369	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv180[rsp], 0
  00374	eb 1f		 jmp	 SHORT $LN88@long_to_de@2
$LN87@long_to_de@2:
  00376	41 b8 39 00 00
	00		 mov	 r8d, 57			; 00000039H
  0037c	48 8b 54 24 60	 mov	 rdx, QWORD PTR strlen$[rsp]
  00381	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR writer$[rsp]
  00389	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  0038e	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv180[rsp], eax
$LN88@long_to_de@2:
  00395	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv180[rsp]
  0039c	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv181[rsp], eax
$LN89@long_to_de@2:
  003a3	83 bc 24 bc 00
	00 00 ff	 cmp	 DWORD PTR tv181[rsp], -1
  003ab	75 14		 jne	 SHORT $LN60@long_to_de@2

; 1655 :             Py_DECREF(scratch);

  003ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR scratch$[rsp]
  003b2	e8 00 00 00 00	 call	 _Py_DecRef

; 1656 :             return -1;

  003b7	b8 ff ff ff ff	 mov	 eax, -1
  003bc	e9 37 18 00 00	 jmp	 $LN80@long_to_de@2
$LN60@long_to_de@2:

; 1657 :         }
; 1658 :         kind = writer->kind;

  003c1	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  003c9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  003cc	89 44 24 20	 mov	 DWORD PTR kind$[rsp], eax

; 1659 :         str = NULL;

  003d0	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR str$[rsp], 0

; 1660 :     }
; 1661 :     else {

  003dc	e9 b3 00 00 00	 jmp	 $LN59@long_to_de@2
$LN61@long_to_de@2:

; 1662 :         str = PyUnicode_New(strlen, '9');

  003e1	ba 39 00 00 00	 mov	 edx, 57			; 00000039H
  003e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strlen$[rsp]
  003eb	e8 00 00 00 00	 call	 PyUnicode_New
  003f0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR str$[rsp], rax

; 1663 :         if (str == NULL) {

  003f8	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR str$[rsp], 0
  00401	75 14		 jne	 SHORT $LN58@long_to_de@2

; 1664 :             Py_DECREF(scratch);

  00403	48 8b 4c 24 50	 mov	 rcx, QWORD PTR scratch$[rsp]
  00408	e8 00 00 00 00	 call	 _Py_DecRef

; 1665 :             return -1;

  0040d	b8 ff ff ff ff	 mov	 eax, -1
  00412	e9 e1 17 00 00	 jmp	 $LN80@long_to_de@2
$LN58@long_to_de@2:

; 1666 :         }
; 1667 :         kind = PyUnicode_KIND(str);

  00417	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0041f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00423	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00429	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0042e	85 c0		 test	 eax, eax
  00430	75 1c		 jne	 SHORT $LN90@long_to_de@2
  00432	41 b8 83 06 00
	00		 mov	 r8d, 1667		; 00000683H
  00438	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0043f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00446	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0044c	33 c0		 xor	 eax, eax
$LN90@long_to_de@2:
  0044e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00456	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00459	c1 e8 07	 shr	 eax, 7
  0045c	83 e0 01	 and	 eax, 1
  0045f	85 c0		 test	 eax, eax
  00461	75 1c		 jne	 SHORT $LN91@long_to_de@2
  00463	41 b8 83 06 00
	00		 mov	 r8d, 1667		; 00000683H
  00469	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00470	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IKKPLFAK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00477	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0047d	33 c0		 xor	 eax, eax
$LN91@long_to_de@2:
  0047f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00487	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0048a	c1 e8 02	 shr	 eax, 2
  0048d	83 e0 07	 and	 eax, 7
  00490	89 44 24 20	 mov	 DWORD PTR kind$[rsp], eax
$LN59@long_to_de@2:

; 1668 :     }
; 1669 : 
; 1670 : #define WRITE_DIGITS(TYPE)                                            \
; 1671 :     do {                                                              \
; 1672 :         if (writer)                                                   \
; 1673 :             p = (TYPE*)PyUnicode_DATA(writer->buffer) + writer->pos + strlen; \
; 1674 :         else                                                          \
; 1675 :             p = (TYPE*)PyUnicode_DATA(str) + strlen;                  \
; 1676 :                                                                       \
; 1677 :         *p = '\0';                                                    \
; 1678 :         /* pout[0] through pout[size-2] contribute exactly            \
; 1679 :            _PyLong_DECIMAL_SHIFT digits each */                       \
; 1680 :         for (i=0; i < size - 1; i++) {                                \
; 1681 :             rem = pout[i];                                            \
; 1682 :             for (j = 0; j < _PyLong_DECIMAL_SHIFT; j++) {             \
; 1683 :                 *--p = '0' + rem % 10;                                \
; 1684 :                 rem /= 10;                                            \
; 1685 :             }                                                         \
; 1686 :         }                                                             \
; 1687 :         /* pout[size-1]: always produce at least one decimal digit */ \
; 1688 :         rem = pout[i];                                                \
; 1689 :         do {                                                          \
; 1690 :             *--p = '0' + rem % 10;                                    \
; 1691 :             rem /= 10;                                                \
; 1692 :         } while (rem != 0);                                           \
; 1693 :                                                                       \
; 1694 :         /* and sign */                                                \
; 1695 :         if (negative)                                                 \
; 1696 :             *--p = '-';                                               \
; 1697 :                                                                       \
; 1698 :         /* check we've counted correctly */                           \
; 1699 :         if (writer)                                                   \
; 1700 :             assert(p == ((TYPE*)PyUnicode_DATA(writer->buffer) + writer->pos)); \
; 1701 :         else                                                          \
; 1702 :             assert(p == (TYPE*)PyUnicode_DATA(str));                  \
; 1703 :     } while (0)
; 1704 : 
; 1705 :     /* fill the string right-to-left */
; 1706 :     if (kind == PyUnicode_1BYTE_KIND) {

  00494	83 7c 24 20 01	 cmp	 DWORD PTR kind$[rsp], 1
  00499	0f 85 8c 07 00
	00		 jne	 $LN57@long_to_de@2
$LN56@long_to_de@2:

; 1707 :         Py_UCS1 *p;
; 1708 :         WRITE_DIGITS(Py_UCS1);

  0049f	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  004a8	0f 84 99 01 00
	00		 je	 $LN53@long_to_de@2
  004ae	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  004b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004b9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  004bd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  004c3	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  004c8	85 c0		 test	 eax, eax
  004ca	75 1c		 jne	 SHORT $LN92@long_to_de@2
  004cc	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  004d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  004d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  004e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004e6	33 c0		 xor	 eax, eax
$LN92@long_to_de@2:
  004e8	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  004f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f3	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004f6	c1 e8 05	 shr	 eax, 5
  004f9	83 e0 01	 and	 eax, 1
  004fc	85 c0		 test	 eax, eax
  004fe	0f 84 cc 00 00
	00		 je	 $LN98@long_to_de@2
  00504	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0050c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0050f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00513	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00519	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0051e	85 c0		 test	 eax, eax
  00520	75 1c		 jne	 SHORT $LN93@long_to_de@2
  00522	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00528	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0052f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  00536	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0053c	33 c0		 xor	 eax, eax
$LN93@long_to_de@2:
  0053e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00546	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00549	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0054c	c1 e8 07	 shr	 eax, 7
  0054f	83 e0 01	 and	 eax, 1
  00552	85 c0		 test	 eax, eax
  00554	75 1c		 jne	 SHORT $LN94@long_to_de@2
  00556	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  0055c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00563	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  0056a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00570	33 c0		 xor	 eax, eax
$LN94@long_to_de@2:
  00572	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0057a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0057d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00580	c1 e8 06	 shr	 eax, 6
  00583	83 e0 01	 and	 eax, 1
  00586	85 c0		 test	 eax, eax
  00588	74 1b		 je	 SHORT $LN95@long_to_de@2
  0058a	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00592	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00595	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0059b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv244[rsp], rax
  005a3	eb 19		 jmp	 SHORT $LN96@long_to_de@2
$LN95@long_to_de@2:
  005a5	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  005ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005b0	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  005b6	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv244[rsp], rax
$LN96@long_to_de@2:
  005be	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv244[rsp]
  005c6	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv253[rsp], rax
  005ce	eb 4b		 jmp	 SHORT $LN99@long_to_de@2
$LN98@long_to_de@2:
  005d0	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  005d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005db	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  005e3	75 1c		 jne	 SHORT $LN97@long_to_de@2
  005e5	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  005eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  005f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  005f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005ff	33 c0		 xor	 eax, eax
$LN97@long_to_de@2:
  00601	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00609	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0060c	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00613	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv253[rsp], rax
$LN99@long_to_de@2:
  0061b	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00623	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00627	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv253[rsp]
  0062f	48 03 c8	 add	 rcx, rax
  00632	48 8b c1	 mov	 rax, rcx
  00635	48 03 44 24 60	 add	 rax, QWORD PTR strlen$[rsp]
  0063a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$21417[rsp], rax
  00642	e9 6d 01 00 00	 jmp	 $LN52@long_to_de@2
$LN53@long_to_de@2:
  00647	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0064f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00653	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00659	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0065e	85 c0		 test	 eax, eax
  00660	75 1c		 jne	 SHORT $LN100@long_to_de@2
  00662	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00668	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0066f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00676	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0067c	33 c0		 xor	 eax, eax
$LN100@long_to_de@2:
  0067e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00686	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00689	c1 e8 05	 shr	 eax, 5
  0068c	83 e0 01	 and	 eax, 1
  0068f	85 c0		 test	 eax, eax
  00691	0f 84 bd 00 00
	00		 je	 $LN106@long_to_de@2
  00697	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0069f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  006a3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  006a9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  006ae	85 c0		 test	 eax, eax
  006b0	75 1c		 jne	 SHORT $LN101@long_to_de@2
  006b2	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  006b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  006bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  006c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006cc	33 c0		 xor	 eax, eax
$LN101@long_to_de@2:
  006ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  006d6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  006d9	c1 e8 07	 shr	 eax, 7
  006dc	83 e0 01	 and	 eax, 1
  006df	85 c0		 test	 eax, eax
  006e1	75 1c		 jne	 SHORT $LN102@long_to_de@2
  006e3	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  006e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  006f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IKKPLFAK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  006f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006fd	33 c0		 xor	 eax, eax
$LN102@long_to_de@2:
  006ff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00707	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0070a	c1 e8 06	 shr	 eax, 6
  0070d	83 e0 01	 and	 eax, 1
  00710	85 c0		 test	 eax, eax
  00712	74 18		 je	 SHORT $LN103@long_to_de@2
  00714	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0071c	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00722	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv290[rsp], rax
  0072a	eb 16		 jmp	 SHORT $LN104@long_to_de@2
$LN103@long_to_de@2:
  0072c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00734	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0073a	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv290[rsp], rax
$LN104@long_to_de@2:
  00742	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv290[rsp]
  0074a	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv299[rsp], rax
  00752	eb 45		 jmp	 SHORT $LN107@long_to_de@2
$LN106@long_to_de@2:
  00754	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0075c	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00764	75 1c		 jne	 SHORT $LN105@long_to_de@2
  00766	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  0076c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00773	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@DHHCGFBB@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
  0077a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00780	33 c0		 xor	 eax, eax
$LN105@long_to_de@2:
  00782	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0078a	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00791	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv299[rsp], rax
$LN107@long_to_de@2:
  00799	48 8b 44 24 60	 mov	 rax, QWORD PTR strlen$[rsp]
  0079e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv299[rsp]
  007a6	48 03 c8	 add	 rcx, rax
  007a9	48 8b c1	 mov	 rax, rcx
  007ac	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$21417[rsp], rax
$LN52@long_to_de@2:
  007b4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$21417[rsp]
  007bc	c6 00 00	 mov	 BYTE PTR [rax], 0
  007bf	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  007c8	eb 0d		 jmp	 SHORT $LN51@long_to_de@2
$LN50@long_to_de@2:
  007ca	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  007cf	48 ff c0	 inc	 rax
  007d2	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN51@long_to_de@2:
  007d7	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  007dc	48 ff c8	 dec	 rax
  007df	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  007e4	7d 78		 jge	 SHORT $LN49@long_to_de@2
  007e6	48 8b 44 24 28	 mov	 rax, QWORD PTR pout$[rsp]
  007eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  007f0	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  007f3	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
  007f7	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00800	eb 0d		 jmp	 SHORT $LN48@long_to_de@2
$LN47@long_to_de@2:
  00802	48 8b 44 24 78	 mov	 rax, QWORD PTR j$[rsp]
  00807	48 ff c0	 inc	 rax
  0080a	48 89 44 24 78	 mov	 QWORD PTR j$[rsp], rax
$LN48@long_to_de@2:
  0080f	48 83 7c 24 78
	09		 cmp	 QWORD PTR j$[rsp], 9
  00815	7d 42		 jge	 SHORT $LN46@long_to_de@2
  00817	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$21417[rsp]
  0081f	48 ff c8	 dec	 rax
  00822	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$21417[rsp], rax
  0082a	33 d2		 xor	 edx, edx
  0082c	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  00830	b9 0a 00 00 00	 mov	 ecx, 10
  00835	f7 f1		 div	 ecx
  00837	8b c2		 mov	 eax, edx
  00839	83 c0 30	 add	 eax, 48			; 00000030H
  0083c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR p$21417[rsp]
  00844	88 01		 mov	 BYTE PTR [rcx], al
  00846	33 d2		 xor	 edx, edx
  00848	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  0084c	b9 0a 00 00 00	 mov	 ecx, 10
  00851	f7 f1		 div	 ecx
  00853	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
  00857	eb a9		 jmp	 SHORT $LN47@long_to_de@2
$LN46@long_to_de@2:
  00859	e9 6c ff ff ff	 jmp	 $LN50@long_to_de@2
$LN49@long_to_de@2:
  0085e	48 8b 44 24 28	 mov	 rax, QWORD PTR pout$[rsp]
  00863	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00868	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0086b	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
$LN45@long_to_de@2:
  0086f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$21417[rsp]
  00877	48 ff c8	 dec	 rax
  0087a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$21417[rsp], rax
  00882	33 d2		 xor	 edx, edx
  00884	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  00888	b9 0a 00 00 00	 mov	 ecx, 10
  0088d	f7 f1		 div	 ecx
  0088f	8b c2		 mov	 eax, edx
  00891	83 c0 30	 add	 eax, 48			; 00000030H
  00894	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR p$21417[rsp]
  0089c	88 01		 mov	 BYTE PTR [rcx], al
  0089e	33 d2		 xor	 edx, edx
  008a0	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  008a4	b9 0a 00 00 00	 mov	 ecx, 10
  008a9	f7 f1		 div	 ecx
  008ab	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
  008af	83 7c 24 48 00	 cmp	 DWORD PTR rem$[rsp], 0
  008b4	75 b9		 jne	 SHORT $LN45@long_to_de@2
  008b6	83 7c 24 24 00	 cmp	 DWORD PTR negative$[rsp], 0
  008bb	74 1e		 je	 SHORT $LN42@long_to_de@2
  008bd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$21417[rsp]
  008c5	48 ff c8	 dec	 rax
  008c8	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$21417[rsp], rax
  008d0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$21417[rsp]
  008d8	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH
$LN42@long_to_de@2:
  008db	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  008e4	0f 84 b2 01 00
	00		 je	 $LN41@long_to_de@2
  008ea	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  008f2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008f5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  008f9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  008ff	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00904	85 c0		 test	 eax, eax
  00906	75 1c		 jne	 SHORT $LN108@long_to_de@2
  00908	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  0090e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00915	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  0091c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00922	33 c0		 xor	 eax, eax
$LN108@long_to_de@2:
  00924	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0092c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0092f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00932	c1 e8 05	 shr	 eax, 5
  00935	83 e0 01	 and	 eax, 1
  00938	85 c0		 test	 eax, eax
  0093a	0f 84 cc 00 00
	00		 je	 $LN114@long_to_de@2
  00940	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00948	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0094b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0094f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00955	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0095a	85 c0		 test	 eax, eax
  0095c	75 1c		 jne	 SHORT $LN109@long_to_de@2
  0095e	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00964	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0096b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  00972	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00978	33 c0		 xor	 eax, eax
$LN109@long_to_de@2:
  0097a	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00982	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00985	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00988	c1 e8 07	 shr	 eax, 7
  0098b	83 e0 01	 and	 eax, 1
  0098e	85 c0		 test	 eax, eax
  00990	75 1c		 jne	 SHORT $LN110@long_to_de@2
  00992	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00998	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0099f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  009a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009ac	33 c0		 xor	 eax, eax
$LN110@long_to_de@2:
  009ae	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  009b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009b9	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  009bc	c1 e8 06	 shr	 eax, 6
  009bf	83 e0 01	 and	 eax, 1
  009c2	85 c0		 test	 eax, eax
  009c4	74 1b		 je	 SHORT $LN111@long_to_de@2
  009c6	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  009ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009d1	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  009d7	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv357[rsp], rax
  009df	eb 19		 jmp	 SHORT $LN112@long_to_de@2
$LN111@long_to_de@2:
  009e1	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  009e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009ec	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  009f2	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv357[rsp], rax
$LN112@long_to_de@2:
  009fa	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv357[rsp]
  00a02	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv366[rsp], rax
  00a0a	eb 4b		 jmp	 SHORT $LN115@long_to_de@2
$LN114@long_to_de@2:
  00a0c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00a14	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a17	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00a1f	75 1c		 jne	 SHORT $LN113@long_to_de@2
  00a21	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00a27	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00a2e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  00a35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a3b	33 c0		 xor	 eax, eax
$LN113@long_to_de@2:
  00a3d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00a45	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a48	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00a4f	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv366[rsp], rax
$LN115@long_to_de@2:
  00a57	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00a5f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00a63	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv366[rsp]
  00a6b	48 03 c8	 add	 rcx, rax
  00a6e	48 8b c1	 mov	 rax, rcx
  00a71	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR p$21417[rsp], rax
  00a79	74 1c		 je	 SHORT $LN116@long_to_de@2
  00a7b	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00a81	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00a88	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HM@GBCHCBDO@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@
  00a8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a95	33 c0		 xor	 eax, eax
$LN116@long_to_de@2:
  00a97	e9 80 01 00 00	 jmp	 $LN40@long_to_de@2
$LN41@long_to_de@2:
  00a9c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00aa4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00aa8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00aae	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00ab3	85 c0		 test	 eax, eax
  00ab5	75 1c		 jne	 SHORT $LN117@long_to_de@2
  00ab7	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00abd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00ac4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00acb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00ad1	33 c0		 xor	 eax, eax
$LN117@long_to_de@2:
  00ad3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00adb	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00ade	c1 e8 05	 shr	 eax, 5
  00ae1	83 e0 01	 and	 eax, 1
  00ae4	85 c0		 test	 eax, eax
  00ae6	0f 84 bd 00 00
	00		 je	 $LN123@long_to_de@2
  00aec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00af4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00af8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00afe	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00b03	85 c0		 test	 eax, eax
  00b05	75 1c		 jne	 SHORT $LN118@long_to_de@2
  00b07	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00b0d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00b14	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00b1b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00b21	33 c0		 xor	 eax, eax
$LN118@long_to_de@2:
  00b23	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00b2b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00b2e	c1 e8 07	 shr	 eax, 7
  00b31	83 e0 01	 and	 eax, 1
  00b34	85 c0		 test	 eax, eax
  00b36	75 1c		 jne	 SHORT $LN119@long_to_de@2
  00b38	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00b3e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00b45	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IKKPLFAK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00b4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00b52	33 c0		 xor	 eax, eax
$LN119@long_to_de@2:
  00b54	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00b5c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00b5f	c1 e8 06	 shr	 eax, 6
  00b62	83 e0 01	 and	 eax, 1
  00b65	85 c0		 test	 eax, eax
  00b67	74 18		 je	 SHORT $LN120@long_to_de@2
  00b69	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00b71	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00b77	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv407[rsp], rax
  00b7f	eb 16		 jmp	 SHORT $LN121@long_to_de@2
$LN120@long_to_de@2:
  00b81	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00b89	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00b8f	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv407[rsp], rax
$LN121@long_to_de@2:
  00b97	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv407[rsp]
  00b9f	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv416[rsp], rax
  00ba7	eb 45		 jmp	 SHORT $LN124@long_to_de@2
$LN123@long_to_de@2:
  00ba9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00bb1	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00bb9	75 1c		 jne	 SHORT $LN122@long_to_de@2
  00bbb	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00bc1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00bc8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@DHHCGFBB@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
  00bcf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00bd5	33 c0		 xor	 eax, eax
$LN122@long_to_de@2:
  00bd7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00bdf	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00be6	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv416[rsp], rax
$LN124@long_to_de@2:
  00bee	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv416[rsp]
  00bf6	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR p$21417[rsp], rax
  00bfe	74 1c		 je	 SHORT $LN125@long_to_de@2
  00c00	41 b8 ac 06 00
	00		 mov	 r8d, 1708		; 000006acH
  00c06	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00c0d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@DGNKGCJL@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@
  00c14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c1a	33 c0		 xor	 eax, eax
$LN125@long_to_de@2:
$LN40@long_to_de@2:
  00c1c	33 c0		 xor	 eax, eax
  00c1e	85 c0		 test	 eax, eax
  00c20	0f 85 79 f8 ff
	ff		 jne	 $LN56@long_to_de@2

; 1709 :     }
; 1710 :     else if (kind == PyUnicode_2BYTE_KIND) {

  00c26	e9 52 0f 00 00	 jmp	 $LN39@long_to_de@2
$LN57@long_to_de@2:
  00c2b	83 7c 24 20 02	 cmp	 DWORD PTR kind$[rsp], 2
  00c30	0f 85 96 07 00
	00		 jne	 $LN38@long_to_de@2
$LN37@long_to_de@2:

; 1711 :         Py_UCS2 *p;
; 1712 :         WRITE_DIGITS(Py_UCS2);

  00c36	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  00c3f	0f 84 9b 01 00
	00		 je	 $LN34@long_to_de@2
  00c45	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00c4d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c50	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00c54	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00c5a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00c5f	85 c0		 test	 eax, eax
  00c61	75 1c		 jne	 SHORT $LN126@long_to_de@2
  00c63	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  00c69	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00c70	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  00c77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c7d	33 c0		 xor	 eax, eax
$LN126@long_to_de@2:
  00c7f	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00c87	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c8a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00c8d	c1 e8 05	 shr	 eax, 5
  00c90	83 e0 01	 and	 eax, 1
  00c93	85 c0		 test	 eax, eax
  00c95	0f 84 cc 00 00
	00		 je	 $LN132@long_to_de@2
  00c9b	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00ca3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ca6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00caa	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00cb0	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00cb5	85 c0		 test	 eax, eax
  00cb7	75 1c		 jne	 SHORT $LN127@long_to_de@2
  00cb9	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  00cbf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00cc6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  00ccd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00cd3	33 c0		 xor	 eax, eax
$LN127@long_to_de@2:
  00cd5	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00cdd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ce0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00ce3	c1 e8 07	 shr	 eax, 7
  00ce6	83 e0 01	 and	 eax, 1
  00ce9	85 c0		 test	 eax, eax
  00ceb	75 1c		 jne	 SHORT $LN128@long_to_de@2
  00ced	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  00cf3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00cfa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  00d01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00d07	33 c0		 xor	 eax, eax
$LN128@long_to_de@2:
  00d09	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00d11	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d14	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00d17	c1 e8 06	 shr	 eax, 6
  00d1a	83 e0 01	 and	 eax, 1
  00d1d	85 c0		 test	 eax, eax
  00d1f	74 1b		 je	 SHORT $LN129@long_to_de@2
  00d21	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00d29	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d2c	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00d32	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv458[rsp], rax
  00d3a	eb 19		 jmp	 SHORT $LN130@long_to_de@2
$LN129@long_to_de@2:
  00d3c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00d44	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d47	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00d4d	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv458[rsp], rax
$LN130@long_to_de@2:
  00d55	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv458[rsp]
  00d5d	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv467[rsp], rax
  00d65	eb 4b		 jmp	 SHORT $LN133@long_to_de@2
$LN132@long_to_de@2:
  00d67	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00d6f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d72	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00d7a	75 1c		 jne	 SHORT $LN131@long_to_de@2
  00d7c	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  00d82	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00d89	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  00d90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00d96	33 c0		 xor	 eax, eax
$LN131@long_to_de@2:
  00d98	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00da0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00da3	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00daa	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv467[rsp], rax
$LN133@long_to_de@2:
  00db2	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00dba	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00dbe	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv467[rsp]
  00dc6	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00dca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strlen$[rsp]
  00dcf	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00dd3	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR p$21509[rsp], rax
  00ddb	e9 6b 01 00 00	 jmp	 $LN33@long_to_de@2
$LN34@long_to_de@2:
  00de0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00de8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00dec	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00df2	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00df7	85 c0		 test	 eax, eax
  00df9	75 1c		 jne	 SHORT $LN134@long_to_de@2
  00dfb	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  00e01	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00e08	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00e0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e15	33 c0		 xor	 eax, eax
$LN134@long_to_de@2:
  00e17	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00e1f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00e22	c1 e8 05	 shr	 eax, 5
  00e25	83 e0 01	 and	 eax, 1
  00e28	85 c0		 test	 eax, eax
  00e2a	0f 84 bd 00 00
	00		 je	 $LN140@long_to_de@2
  00e30	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00e38	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00e3c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00e42	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00e47	85 c0		 test	 eax, eax
  00e49	75 1c		 jne	 SHORT $LN135@long_to_de@2
  00e4b	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  00e51	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00e58	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00e5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e65	33 c0		 xor	 eax, eax
$LN135@long_to_de@2:
  00e67	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00e6f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00e72	c1 e8 07	 shr	 eax, 7
  00e75	83 e0 01	 and	 eax, 1
  00e78	85 c0		 test	 eax, eax
  00e7a	75 1c		 jne	 SHORT $LN136@long_to_de@2
  00e7c	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  00e82	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00e89	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IKKPLFAK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00e90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e96	33 c0		 xor	 eax, eax
$LN136@long_to_de@2:
  00e98	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00ea0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00ea3	c1 e8 06	 shr	 eax, 6
  00ea6	83 e0 01	 and	 eax, 1
  00ea9	85 c0		 test	 eax, eax
  00eab	74 18		 je	 SHORT $LN137@long_to_de@2
  00ead	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00eb5	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00ebb	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv506[rsp], rax
  00ec3	eb 16		 jmp	 SHORT $LN138@long_to_de@2
$LN137@long_to_de@2:
  00ec5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00ecd	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00ed3	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv506[rsp], rax
$LN138@long_to_de@2:
  00edb	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv506[rsp]
  00ee3	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv515[rsp], rax
  00eeb	eb 45		 jmp	 SHORT $LN141@long_to_de@2
$LN140@long_to_de@2:
  00eed	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00ef5	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00efd	75 1c		 jne	 SHORT $LN139@long_to_de@2
  00eff	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  00f05	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00f0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@DHHCGFBB@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
  00f13	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00f19	33 c0		 xor	 eax, eax
$LN139@long_to_de@2:
  00f1b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00f23	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00f2a	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv515[rsp], rax
$LN141@long_to_de@2:
  00f32	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR tv515[rsp]
  00f3a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strlen$[rsp]
  00f3f	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00f43	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR p$21509[rsp], rax
$LN33@long_to_de@2:
  00f4b	33 c0		 xor	 eax, eax
  00f4d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR p$21509[rsp]
  00f55	66 89 01	 mov	 WORD PTR [rcx], ax
  00f58	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00f61	eb 0d		 jmp	 SHORT $LN32@long_to_de@2
$LN31@long_to_de@2:
  00f63	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00f68	48 ff c0	 inc	 rax
  00f6b	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN32@long_to_de@2:
  00f70	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  00f75	48 ff c8	 dec	 rax
  00f78	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  00f7d	7d 7a		 jge	 SHORT $LN30@long_to_de@2
  00f7f	48 8b 44 24 28	 mov	 rax, QWORD PTR pout$[rsp]
  00f84	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00f89	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00f8c	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
  00f90	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00f99	eb 0d		 jmp	 SHORT $LN29@long_to_de@2
$LN28@long_to_de@2:
  00f9b	48 8b 44 24 78	 mov	 rax, QWORD PTR j$[rsp]
  00fa0	48 ff c0	 inc	 rax
  00fa3	48 89 44 24 78	 mov	 QWORD PTR j$[rsp], rax
$LN29@long_to_de@2:
  00fa8	48 83 7c 24 78
	09		 cmp	 QWORD PTR j$[rsp], 9
  00fae	7d 44		 jge	 SHORT $LN27@long_to_de@2
  00fb0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR p$21509[rsp]
  00fb8	48 83 e8 02	 sub	 rax, 2
  00fbc	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR p$21509[rsp], rax
  00fc4	33 d2		 xor	 edx, edx
  00fc6	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  00fca	b9 0a 00 00 00	 mov	 ecx, 10
  00fcf	f7 f1		 div	 ecx
  00fd1	8b c2		 mov	 eax, edx
  00fd3	83 c0 30	 add	 eax, 48			; 00000030H
  00fd6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR p$21509[rsp]
  00fde	66 89 01	 mov	 WORD PTR [rcx], ax
  00fe1	33 d2		 xor	 edx, edx
  00fe3	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  00fe7	b9 0a 00 00 00	 mov	 ecx, 10
  00fec	f7 f1		 div	 ecx
  00fee	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
  00ff2	eb a7		 jmp	 SHORT $LN28@long_to_de@2
$LN27@long_to_de@2:
  00ff4	e9 6a ff ff ff	 jmp	 $LN31@long_to_de@2
$LN30@long_to_de@2:
  00ff9	48 8b 44 24 28	 mov	 rax, QWORD PTR pout$[rsp]
  00ffe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  01003	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01006	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
$LN26@long_to_de@2:
  0100a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR p$21509[rsp]
  01012	48 83 e8 02	 sub	 rax, 2
  01016	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR p$21509[rsp], rax
  0101e	33 d2		 xor	 edx, edx
  01020	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  01024	b9 0a 00 00 00	 mov	 ecx, 10
  01029	f7 f1		 div	 ecx
  0102b	8b c2		 mov	 eax, edx
  0102d	83 c0 30	 add	 eax, 48			; 00000030H
  01030	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR p$21509[rsp]
  01038	66 89 01	 mov	 WORD PTR [rcx], ax
  0103b	33 d2		 xor	 edx, edx
  0103d	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  01041	b9 0a 00 00 00	 mov	 ecx, 10
  01046	f7 f1		 div	 ecx
  01048	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
  0104c	83 7c 24 48 00	 cmp	 DWORD PTR rem$[rsp], 0
  01051	75 b7		 jne	 SHORT $LN26@long_to_de@2
  01053	83 7c 24 24 00	 cmp	 DWORD PTR negative$[rsp], 0
  01058	74 24		 je	 SHORT $LN23@long_to_de@2
  0105a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR p$21509[rsp]
  01062	48 83 e8 02	 sub	 rax, 2
  01066	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR p$21509[rsp], rax
  0106e	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  01073	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR p$21509[rsp]
  0107b	66 89 01	 mov	 WORD PTR [rcx], ax
$LN23@long_to_de@2:
  0107e	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  01087	0f 84 b0 01 00
	00		 je	 $LN22@long_to_de@2
  0108d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01098	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0109c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  010a2	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  010a7	85 c0		 test	 eax, eax
  010a9	75 1c		 jne	 SHORT $LN142@long_to_de@2
  010ab	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  010b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  010b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  010bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  010c5	33 c0		 xor	 eax, eax
$LN142@long_to_de@2:
  010c7	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  010cf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  010d2	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  010d5	c1 e8 05	 shr	 eax, 5
  010d8	83 e0 01	 and	 eax, 1
  010db	85 c0		 test	 eax, eax
  010dd	0f 84 cc 00 00
	00		 je	 $LN148@long_to_de@2
  010e3	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  010eb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  010ee	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  010f2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  010f8	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  010fd	85 c0		 test	 eax, eax
  010ff	75 1c		 jne	 SHORT $LN143@long_to_de@2
  01101	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  01107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0110e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  01115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0111b	33 c0		 xor	 eax, eax
$LN143@long_to_de@2:
  0111d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01125	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01128	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0112b	c1 e8 07	 shr	 eax, 7
  0112e	83 e0 01	 and	 eax, 1
  01131	85 c0		 test	 eax, eax
  01133	75 1c		 jne	 SHORT $LN144@long_to_de@2
  01135	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  0113b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  01149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0114f	33 c0		 xor	 eax, eax
$LN144@long_to_de@2:
  01151	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01159	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0115c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0115f	c1 e8 06	 shr	 eax, 6
  01162	83 e0 01	 and	 eax, 1
  01165	85 c0		 test	 eax, eax
  01167	74 1b		 je	 SHORT $LN145@long_to_de@2
  01169	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01171	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01174	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0117a	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv574[rsp], rax
  01182	eb 19		 jmp	 SHORT $LN146@long_to_de@2
$LN145@long_to_de@2:
  01184	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0118c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0118f	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01195	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv574[rsp], rax
$LN146@long_to_de@2:
  0119d	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv574[rsp]
  011a5	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv583[rsp], rax
  011ad	eb 4b		 jmp	 SHORT $LN149@long_to_de@2
$LN148@long_to_de@2:
  011af	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  011b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011ba	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  011c2	75 1c		 jne	 SHORT $LN147@long_to_de@2
  011c4	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  011ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  011d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  011d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  011de	33 c0		 xor	 eax, eax
$LN147@long_to_de@2:
  011e0	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  011e8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011eb	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  011f2	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv583[rsp], rax
$LN149@long_to_de@2:
  011fa	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01202	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  01206	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv583[rsp]
  0120e	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  01212	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR p$21509[rsp], rax
  0121a	74 1c		 je	 SHORT $LN150@long_to_de@2
  0121c	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  01222	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HM@NOGJJOMH@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@
  01230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01236	33 c0		 xor	 eax, eax
$LN150@long_to_de@2:
  01238	e9 80 01 00 00	 jmp	 $LN21@long_to_de@2
$LN22@long_to_de@2:
  0123d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01245	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01249	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0124f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01254	85 c0		 test	 eax, eax
  01256	75 1c		 jne	 SHORT $LN151@long_to_de@2
  01258	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  0125e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01265	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  0126c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01272	33 c0		 xor	 eax, eax
$LN151@long_to_de@2:
  01274	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0127c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0127f	c1 e8 05	 shr	 eax, 5
  01282	83 e0 01	 and	 eax, 1
  01285	85 c0		 test	 eax, eax
  01287	0f 84 bd 00 00
	00		 je	 $LN157@long_to_de@2
  0128d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01295	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01299	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0129f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  012a4	85 c0		 test	 eax, eax
  012a6	75 1c		 jne	 SHORT $LN152@long_to_de@2
  012a8	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  012ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  012b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  012bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  012c2	33 c0		 xor	 eax, eax
$LN152@long_to_de@2:
  012c4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  012cc	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  012cf	c1 e8 07	 shr	 eax, 7
  012d2	83 e0 01	 and	 eax, 1
  012d5	85 c0		 test	 eax, eax
  012d7	75 1c		 jne	 SHORT $LN153@long_to_de@2
  012d9	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  012df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  012e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IKKPLFAK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  012ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  012f3	33 c0		 xor	 eax, eax
$LN153@long_to_de@2:
  012f5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  012fd	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01300	c1 e8 06	 shr	 eax, 6
  01303	83 e0 01	 and	 eax, 1
  01306	85 c0		 test	 eax, eax
  01308	74 18		 je	 SHORT $LN154@long_to_de@2
  0130a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01312	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01318	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv625[rsp], rax
  01320	eb 16		 jmp	 SHORT $LN155@long_to_de@2
$LN154@long_to_de@2:
  01322	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0132a	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01330	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv625[rsp], rax
$LN155@long_to_de@2:
  01338	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR tv625[rsp]
  01340	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv634[rsp], rax
  01348	eb 45		 jmp	 SHORT $LN158@long_to_de@2
$LN157@long_to_de@2:
  0134a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01352	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  0135a	75 1c		 jne	 SHORT $LN156@long_to_de@2
  0135c	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  01362	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01369	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@DHHCGFBB@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
  01370	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01376	33 c0		 xor	 eax, eax
$LN156@long_to_de@2:
  01378	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01380	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01387	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv634[rsp], rax
$LN158@long_to_de@2:
  0138f	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR tv634[rsp]
  01397	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR p$21509[rsp], rax
  0139f	74 1c		 je	 SHORT $LN159@long_to_de@2
  013a1	41 b8 b0 06 00
	00		 mov	 r8d, 1712		; 000006b0H
  013a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  013ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@LGIAMOCO@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@
  013b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  013bb	33 c0		 xor	 eax, eax
$LN159@long_to_de@2:
$LN21@long_to_de@2:
  013bd	33 c0		 xor	 eax, eax
  013bf	85 c0		 test	 eax, eax
  013c1	0f 85 6f f8 ff
	ff		 jne	 $LN37@long_to_de@2

; 1713 :     }
; 1714 :     else {

  013c7	e9 b1 07 00 00	 jmp	 $LN20@long_to_de@2
$LN38@long_to_de@2:

; 1715 :         Py_UCS4 *p;
; 1716 :         assert (kind == PyUnicode_4BYTE_KIND);

  013cc	83 7c 24 20 04	 cmp	 DWORD PTR kind$[rsp], 4
  013d1	74 1c		 je	 SHORT $LN160@long_to_de@2
  013d3	41 b8 b4 06 00
	00		 mov	 r8d, 1716		; 000006b4H
  013d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  013e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@MKLBCJPK@?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AA4?$AAB?$AAY?$AAT?$AAE?$AA_?$AAK?$AAI?$AAN?$AAD?$AA?$AA@
  013e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  013ed	33 c0		 xor	 eax, eax
$LN160@long_to_de@2:
$LN19@long_to_de@2:

; 1717 :         WRITE_DIGITS(Py_UCS4);

  013ef	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  013f8	0f 84 9b 01 00
	00		 je	 $LN16@long_to_de@2
  013fe	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01406	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01409	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0140d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01413	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01418	85 c0		 test	 eax, eax
  0141a	75 1c		 jne	 SHORT $LN161@long_to_de@2
  0141c	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  01422	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01429	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  01430	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01436	33 c0		 xor	 eax, eax
$LN161@long_to_de@2:
  01438	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01440	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01443	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01446	c1 e8 05	 shr	 eax, 5
  01449	83 e0 01	 and	 eax, 1
  0144c	85 c0		 test	 eax, eax
  0144e	0f 84 cc 00 00
	00		 je	 $LN167@long_to_de@2
  01454	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0145c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0145f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01463	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01469	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0146e	85 c0		 test	 eax, eax
  01470	75 1c		 jne	 SHORT $LN162@long_to_de@2
  01472	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  01478	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0147f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  01486	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0148c	33 c0		 xor	 eax, eax
$LN162@long_to_de@2:
  0148e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01496	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01499	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0149c	c1 e8 07	 shr	 eax, 7
  0149f	83 e0 01	 and	 eax, 1
  014a2	85 c0		 test	 eax, eax
  014a4	75 1c		 jne	 SHORT $LN163@long_to_de@2
  014a6	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  014ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  014b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  014ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  014c0	33 c0		 xor	 eax, eax
$LN163@long_to_de@2:
  014c2	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  014ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  014cd	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  014d0	c1 e8 06	 shr	 eax, 6
  014d3	83 e0 01	 and	 eax, 1
  014d6	85 c0		 test	 eax, eax
  014d8	74 1b		 je	 SHORT $LN164@long_to_de@2
  014da	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  014e2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  014e5	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  014eb	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv680[rsp], rax
  014f3	eb 19		 jmp	 SHORT $LN165@long_to_de@2
$LN164@long_to_de@2:
  014f5	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  014fd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01500	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01506	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv680[rsp], rax
$LN165@long_to_de@2:
  0150e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR tv680[rsp]
  01516	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv689[rsp], rax
  0151e	eb 4b		 jmp	 SHORT $LN168@long_to_de@2
$LN167@long_to_de@2:
  01520	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01528	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0152b	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01533	75 1c		 jne	 SHORT $LN166@long_to_de@2
  01535	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  0153b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01542	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  01549	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0154f	33 c0		 xor	 eax, eax
$LN166@long_to_de@2:
  01551	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01559	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0155c	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01563	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv689[rsp], rax
$LN168@long_to_de@2:
  0156b	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01573	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  01577	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv689[rsp]
  0157f	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  01583	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strlen$[rsp]
  01588	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0158c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21596[rsp], rax
  01594	e9 6b 01 00 00	 jmp	 $LN15@long_to_de@2
$LN16@long_to_de@2:
  01599	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  015a1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  015a5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  015ab	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  015b0	85 c0		 test	 eax, eax
  015b2	75 1c		 jne	 SHORT $LN169@long_to_de@2
  015b4	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  015ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  015c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  015c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  015ce	33 c0		 xor	 eax, eax
$LN169@long_to_de@2:
  015d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  015d8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  015db	c1 e8 05	 shr	 eax, 5
  015de	83 e0 01	 and	 eax, 1
  015e1	85 c0		 test	 eax, eax
  015e3	0f 84 bd 00 00
	00		 je	 $LN175@long_to_de@2
  015e9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  015f1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  015f5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  015fb	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01600	85 c0		 test	 eax, eax
  01602	75 1c		 jne	 SHORT $LN170@long_to_de@2
  01604	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  0160a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01611	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  01618	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0161e	33 c0		 xor	 eax, eax
$LN170@long_to_de@2:
  01620	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01628	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0162b	c1 e8 07	 shr	 eax, 7
  0162e	83 e0 01	 and	 eax, 1
  01631	85 c0		 test	 eax, eax
  01633	75 1c		 jne	 SHORT $LN171@long_to_de@2
  01635	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  0163b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01642	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IKKPLFAK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  01649	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0164f	33 c0		 xor	 eax, eax
$LN171@long_to_de@2:
  01651	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01659	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0165c	c1 e8 06	 shr	 eax, 6
  0165f	83 e0 01	 and	 eax, 1
  01662	85 c0		 test	 eax, eax
  01664	74 18		 je	 SHORT $LN172@long_to_de@2
  01666	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0166e	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01674	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv728[rsp], rax
  0167c	eb 16		 jmp	 SHORT $LN173@long_to_de@2
$LN172@long_to_de@2:
  0167e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01686	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0168c	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv728[rsp], rax
$LN173@long_to_de@2:
  01694	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR tv728[rsp]
  0169c	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv737[rsp], rax
  016a4	eb 45		 jmp	 SHORT $LN176@long_to_de@2
$LN175@long_to_de@2:
  016a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  016ae	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  016b6	75 1c		 jne	 SHORT $LN174@long_to_de@2
  016b8	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  016be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  016c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@DHHCGFBB@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
  016cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  016d2	33 c0		 xor	 eax, eax
$LN174@long_to_de@2:
  016d4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  016dc	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  016e3	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv737[rsp], rax
$LN176@long_to_de@2:
  016eb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR tv737[rsp]
  016f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strlen$[rsp]
  016f8	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  016fc	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21596[rsp], rax
$LN15@long_to_de@2:
  01704	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21596[rsp]
  0170c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  01712	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0171b	eb 0d		 jmp	 SHORT $LN14@long_to_de@2
$LN13@long_to_de@2:
  0171d	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  01722	48 ff c0	 inc	 rax
  01725	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN14@long_to_de@2:
  0172a	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  0172f	48 ff c8	 dec	 rax
  01732	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  01737	7d 79		 jge	 SHORT $LN12@long_to_de@2
  01739	48 8b 44 24 28	 mov	 rax, QWORD PTR pout$[rsp]
  0173e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  01743	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01746	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
  0174a	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  01753	eb 0d		 jmp	 SHORT $LN11@long_to_de@2
$LN10@long_to_de@2:
  01755	48 8b 44 24 78	 mov	 rax, QWORD PTR j$[rsp]
  0175a	48 ff c0	 inc	 rax
  0175d	48 89 44 24 78	 mov	 QWORD PTR j$[rsp], rax
$LN11@long_to_de@2:
  01762	48 83 7c 24 78
	09		 cmp	 QWORD PTR j$[rsp], 9
  01768	7d 43		 jge	 SHORT $LN9@long_to_de@2
  0176a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21596[rsp]
  01772	48 83 e8 04	 sub	 rax, 4
  01776	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21596[rsp], rax
  0177e	33 d2		 xor	 edx, edx
  01780	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  01784	b9 0a 00 00 00	 mov	 ecx, 10
  01789	f7 f1		 div	 ecx
  0178b	8b c2		 mov	 eax, edx
  0178d	83 c0 30	 add	 eax, 48			; 00000030H
  01790	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR p$21596[rsp]
  01798	89 01		 mov	 DWORD PTR [rcx], eax
  0179a	33 d2		 xor	 edx, edx
  0179c	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  017a0	b9 0a 00 00 00	 mov	 ecx, 10
  017a5	f7 f1		 div	 ecx
  017a7	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
  017ab	eb a8		 jmp	 SHORT $LN10@long_to_de@2
$LN9@long_to_de@2:
  017ad	e9 6b ff ff ff	 jmp	 $LN13@long_to_de@2
$LN12@long_to_de@2:
  017b2	48 8b 44 24 28	 mov	 rax, QWORD PTR pout$[rsp]
  017b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  017bc	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  017bf	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
$LN8@long_to_de@2:
  017c3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21596[rsp]
  017cb	48 83 e8 04	 sub	 rax, 4
  017cf	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21596[rsp], rax
  017d7	33 d2		 xor	 edx, edx
  017d9	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  017dd	b9 0a 00 00 00	 mov	 ecx, 10
  017e2	f7 f1		 div	 ecx
  017e4	8b c2		 mov	 eax, edx
  017e6	83 c0 30	 add	 eax, 48			; 00000030H
  017e9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR p$21596[rsp]
  017f1	89 01		 mov	 DWORD PTR [rcx], eax
  017f3	33 d2		 xor	 edx, edx
  017f5	8b 44 24 48	 mov	 eax, DWORD PTR rem$[rsp]
  017f9	b9 0a 00 00 00	 mov	 ecx, 10
  017fe	f7 f1		 div	 ecx
  01800	89 44 24 48	 mov	 DWORD PTR rem$[rsp], eax
  01804	83 7c 24 48 00	 cmp	 DWORD PTR rem$[rsp], 0
  01809	75 b8		 jne	 SHORT $LN8@long_to_de@2
  0180b	83 7c 24 24 00	 cmp	 DWORD PTR negative$[rsp], 0
  01810	74 22		 je	 SHORT $LN5@long_to_de@2
  01812	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21596[rsp]
  0181a	48 83 e8 04	 sub	 rax, 4
  0181e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21596[rsp], rax
  01826	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21596[rsp]
  0182e	c7 00 2d 00 00
	00		 mov	 DWORD PTR [rax], 45	; 0000002dH
$LN5@long_to_de@2:
  01834	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  0183d	0f 84 b0 01 00
	00		 je	 $LN4@long_to_de@2
  01843	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0184b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0184e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01852	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01858	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0185d	85 c0		 test	 eax, eax
  0185f	75 1c		 jne	 SHORT $LN177@long_to_de@2
  01861	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  01867	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0186e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  01875	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0187b	33 c0		 xor	 eax, eax
$LN177@long_to_de@2:
  0187d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01885	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01888	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0188b	c1 e8 05	 shr	 eax, 5
  0188e	83 e0 01	 and	 eax, 1
  01891	85 c0		 test	 eax, eax
  01893	0f 84 cc 00 00
	00		 je	 $LN183@long_to_de@2
  01899	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  018a1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  018a4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  018a8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  018ae	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  018b3	85 c0		 test	 eax, eax
  018b5	75 1c		 jne	 SHORT $LN178@long_to_de@2
  018b7	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  018bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  018c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  018cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  018d1	33 c0		 xor	 eax, eax
$LN178@long_to_de@2:
  018d3	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  018db	48 8b 00	 mov	 rax, QWORD PTR [rax]
  018de	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  018e1	c1 e8 07	 shr	 eax, 7
  018e4	83 e0 01	 and	 eax, 1
  018e7	85 c0		 test	 eax, eax
  018e9	75 1c		 jne	 SHORT $LN179@long_to_de@2
  018eb	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  018f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  018f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  018ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01905	33 c0		 xor	 eax, eax
$LN179@long_to_de@2:
  01907	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0190f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01912	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01915	c1 e8 06	 shr	 eax, 6
  01918	83 e0 01	 and	 eax, 1
  0191b	85 c0		 test	 eax, eax
  0191d	74 1b		 je	 SHORT $LN180@long_to_de@2
  0191f	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01927	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0192a	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01930	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv794[rsp], rax
  01938	eb 19		 jmp	 SHORT $LN181@long_to_de@2
$LN180@long_to_de@2:
  0193a	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01942	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01945	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0194b	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv794[rsp], rax
$LN181@long_to_de@2:
  01953	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR tv794[rsp]
  0195b	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv803[rsp], rax
  01963	eb 4b		 jmp	 SHORT $LN184@long_to_de@2
$LN183@long_to_de@2:
  01965	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0196d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01970	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01978	75 1c		 jne	 SHORT $LN182@long_to_de@2
  0197a	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  01980	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01987	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  0198e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01994	33 c0		 xor	 eax, eax
$LN182@long_to_de@2:
  01996	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0199e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  019a1	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  019a8	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv803[rsp], rax
$LN184@long_to_de@2:
  019b0	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  019b8	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  019bc	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv803[rsp]
  019c4	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  019c8	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR p$21596[rsp], rax
  019d0	74 1c		 je	 SHORT $LN185@long_to_de@2
  019d2	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  019d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  019df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HM@HLIFOHHE@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@
  019e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  019ec	33 c0		 xor	 eax, eax
$LN185@long_to_de@2:
  019ee	e9 80 01 00 00	 jmp	 $LN3@long_to_de@2
$LN4@long_to_de@2:
  019f3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  019fb	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  019ff	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01a05	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01a0a	85 c0		 test	 eax, eax
  01a0c	75 1c		 jne	 SHORT $LN186@long_to_de@2
  01a0e	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  01a14	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01a1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  01a22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01a28	33 c0		 xor	 eax, eax
$LN186@long_to_de@2:
  01a2a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01a32	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01a35	c1 e8 05	 shr	 eax, 5
  01a38	83 e0 01	 and	 eax, 1
  01a3b	85 c0		 test	 eax, eax
  01a3d	0f 84 bd 00 00
	00		 je	 $LN192@long_to_de@2
  01a43	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01a4b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01a4f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01a55	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01a5a	85 c0		 test	 eax, eax
  01a5c	75 1c		 jne	 SHORT $LN187@long_to_de@2
  01a5e	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  01a64	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01a6b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNBGFFCA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  01a72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01a78	33 c0		 xor	 eax, eax
$LN187@long_to_de@2:
  01a7a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01a82	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01a85	c1 e8 07	 shr	 eax, 7
  01a88	83 e0 01	 and	 eax, 1
  01a8b	85 c0		 test	 eax, eax
  01a8d	75 1c		 jne	 SHORT $LN188@long_to_de@2
  01a8f	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  01a95	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01a9c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IKKPLFAK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  01aa3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01aa9	33 c0		 xor	 eax, eax
$LN188@long_to_de@2:
  01aab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01ab3	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01ab6	c1 e8 06	 shr	 eax, 6
  01ab9	83 e0 01	 and	 eax, 1
  01abc	85 c0		 test	 eax, eax
  01abe	74 18		 je	 SHORT $LN189@long_to_de@2
  01ac0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01ac8	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01ace	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv845[rsp], rax
  01ad6	eb 16		 jmp	 SHORT $LN190@long_to_de@2
$LN189@long_to_de@2:
  01ad8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01ae0	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01ae6	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv845[rsp], rax
$LN190@long_to_de@2:
  01aee	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR tv845[rsp]
  01af6	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv854[rsp], rax
  01afe	eb 45		 jmp	 SHORT $LN193@long_to_de@2
$LN192@long_to_de@2:
  01b00	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01b08	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01b10	75 1c		 jne	 SHORT $LN191@long_to_de@2
  01b12	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  01b18	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01b1f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@DHHCGFBB@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
  01b26	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01b2c	33 c0		 xor	 eax, eax
$LN191@long_to_de@2:
  01b2e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  01b36	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01b3d	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv854[rsp], rax
$LN193@long_to_de@2:
  01b45	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR tv854[rsp]
  01b4d	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR p$21596[rsp], rax
  01b55	74 1c		 je	 SHORT $LN194@long_to_de@2
  01b57	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  01b5d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01b64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@GNEEJBAF@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAs?$AAt@
  01b6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01b71	33 c0		 xor	 eax, eax
$LN194@long_to_de@2:
$LN3@long_to_de@2:
  01b73	33 c0		 xor	 eax, eax
  01b75	85 c0		 test	 eax, eax
  01b77	0f 85 72 f8 ff
	ff		 jne	 $LN19@long_to_de@2
$LN20@long_to_de@2:
$LN39@long_to_de@2:

; 1718 :     }
; 1719 : #undef WRITE_DIGITS
; 1720 : 
; 1721 :     Py_DECREF(scratch);

  01b7d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR scratch$[rsp]
  01b82	e8 00 00 00 00	 call	 _Py_DecRef

; 1722 :     if (writer) {

  01b87	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  01b90	74 1f		 je	 SHORT $LN2@long_to_de@2

; 1723 :         writer->pos += strlen;

  01b92	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01b9a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  01b9e	48 03 44 24 60	 add	 rax, QWORD PTR strlen$[rsp]
  01ba3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR writer$[rsp]
  01bab	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1724 :     }
; 1725 :     else {

  01baf	eb 45		 jmp	 SHORT $LN1@long_to_de@2
$LN2@long_to_de@2:

; 1726 :         assert(_PyUnicode_CheckConsistency(str, 1));

  01bb1	ba 01 00 00 00	 mov	 edx, 1
  01bb6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  01bbe	e8 00 00 00 00	 call	 _PyUnicode_CheckConsistency
  01bc3	85 c0		 test	 eax, eax
  01bc5	75 1c		 jne	 SHORT $LN195@long_to_de@2
  01bc7	41 b8 be 06 00
	00		 mov	 r8d, 1726		; 000006beH
  01bcd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01bd4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@DMGNHGGF@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAs?$AAt?$AAr?$AA?0@
  01bdb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01be1	33 c0		 xor	 eax, eax
$LN195@long_to_de@2:

; 1727 :         *p_output = (PyObject *)str;

  01be3	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR p_output$[rsp]
  01beb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  01bf3	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@long_to_de@2:

; 1728 :     }
; 1729 :     return 0;

  01bf6	33 c0		 xor	 eax, eax
$LN80@long_to_de@2:

; 1730 : }

  01bf8	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  01bff	c3		 ret	 0
long_to_decimal_string_internal ENDP
_TEXT	ENDS
PUBLIC	_PyLong_Format
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_Format DD imagerel $LN6
	DD	imagerel $LN6+103
	DD	imagerel $unwind$_PyLong_Format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_Format DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyLong_Format
_TEXT	SEGMENT
err$ = 48
str$ = 56
obj$ = 80
base$ = 88
_PyLong_Format PROC					; COMDAT

; 1891 : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1892 :     PyObject *str;
; 1893 :     int err;
; 1894 :     if (base == 10)

  0000d	83 7c 24 58 0a	 cmp	 DWORD PTR base$[rsp], 10
  00012	75 18		 jne	 SHORT $LN3@PyLong_For

; 1895 :         err = long_to_decimal_string_internal(obj, &str, NULL);

  00014	45 33 c0	 xor	 r8d, r8d
  00017	48 8d 54 24 38	 lea	 rdx, QWORD PTR str$[rsp]
  0001c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj$[rsp]
  00021	e8 00 00 00 00	 call	 long_to_decimal_string_internal
  00026	89 44 24 30	 mov	 DWORD PTR err$[rsp], eax

; 1896 :     else

  0002a	eb 26		 jmp	 SHORT $LN2@PyLong_For
$LN3@PyLong_For:

; 1897 :         err = long_format_binary(obj, base, 1, &str, NULL);

  0002c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00035	4c 8d 4c 24 38	 lea	 r9, QWORD PTR str$[rsp]
  0003a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00040	8b 54 24 58	 mov	 edx, DWORD PTR base$[rsp]
  00044	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj$[rsp]
  00049	e8 00 00 00 00	 call	 long_format_binary
  0004e	89 44 24 30	 mov	 DWORD PTR err$[rsp], eax
$LN2@PyLong_For:

; 1898 :     if (err == -1)

  00052	83 7c 24 30 ff	 cmp	 DWORD PTR err$[rsp], -1
  00057	75 04		 jne	 SHORT $LN1@PyLong_For

; 1899 :         return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	eb 05		 jmp	 SHORT $LN4@PyLong_For
$LN1@PyLong_For:

; 1900 :     return str;

  0005d	48 8b 44 24 38	 mov	 rax, QWORD PTR str$[rsp]
$LN4@PyLong_For:

; 1901 : }

  00062	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00066	c3		 ret	 0
_PyLong_Format ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EE@OGFJKBIM@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAv?$AA?0?$AA?5?$AA1@ ; `string'
PUBLIC	??_C@_1EC@DCHLEKIM@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1EC@ECAMFMGK@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1EC@HKDHNHBJ@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1CE@HAAJLKOA@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAi?$AAt?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@ ; `string'
PUBLIC	??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BL@JIIGGCNL@int?5is?5too?5large?5to?5format?$AA@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_1EK@CMLFNKHE@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_format_binary DD imagerel long_format_binary
	DD	imagerel long_format_binary+7990
	DD	imagerel $unwind$long_format_binary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_format_binary DD 021a01H
	DD	03f011aH
xdata	ENDS
;	COMDAT ??_C@_1EE@OGFJKBIM@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAv?$AA?0?$AA?5?$AA1@
CONST	SEGMENT
??_C@_1EE@OGFJKBIM@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAv?$AA?0?$AA?5?$AA1@ DB '_'
	DB	00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e'
	DB	00H, 'c', 00H, 'k', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 's', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'y'
	DB	00H, '(', 00H, 'v', 00H, ',', 00H, ' ', 00H, '1', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@DCHLEKIM@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@DCHLEKIM@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@ DB 'p'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 'P', 00H
	DB	'y', 00H, '_', 00H, 'U', 00H, 'C', 00H, 'S', 00H, '4', 00H, '*'
	DB	00H, ')', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'D', 00H, 'A'
	DB	00H, 'T', 00H, 'A', 00H, '(', 00H, 'v', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@ECAMFMGK@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@ECAMFMGK@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@ DB 'p'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 'P', 00H
	DB	'y', 00H, '_', 00H, 'U', 00H, 'C', 00H, 'S', 00H, '2', 00H, '*'
	DB	00H, ')', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'D', 00H, 'A'
	DB	00H, 'T', 00H, 'A', 00H, '(', 00H, 'v', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@HKDHNHBJ@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@HKDHNHBJ@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@ DB 'p'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 'P', 00H
	DB	'y', 00H, '_', 00H, 'U', 00H, 'C', 00H, 'S', 00H, '1', 00H, '*'
	DB	00H, ')', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'D', 00H, 'A'
	DB	00H, 'T', 00H, 'A', 00H, '(', 00H, 'v', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@HAAJLKOA@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAi?$AAt?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@HAAJLKOA@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAi?$AAt?$AAs?$AA?$AA@ DB 'a'
	DB	00H, 'c', 00H, 'c', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
CONST	SEGMENT
??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'v', 00H, ')', 00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'v', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'v', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JIIGGCNL@int?5is?5too?5large?5to?5format?$AA@
CONST	SEGMENT
??_C@_0BL@JIIGGCNL@int?5is?5too?5large?5to?5format?$AA@ DB 'int is too la'
	DB	'rge to format', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@CMLFNKHE@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN@
CONST	SEGMENT
??_C@_1EK@CMLFNKHE@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN@ DB 'b'
	DB	00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '2', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'b'
	DB	00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '8', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'b'
	DB	00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, '6', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_format_binary
_TEXT	SEGMENT
negative$ = 32
kind$ = 36
v$ = 40
a$ = 48
bits$ = 56
size_a$ = 64
sz$ = 72
size_a_in_bits$21740 = 80
p$21761 = 88
i$21804 = 96
accumbits$21803 = 104
accum$21802 = 112
cdigit$21814 = 120
p$21861 = 128
i$21903 = 136
accumbits$21902 = 144
accum$21901 = 152
cdigit$21912 = 160
p$21958 = 168
i$22001 = 176
accumbits$22000 = 184
accum$21999 = 192
cdigit$22010 = 200
tv83 = 208
tv86 = 216
tv87 = 220
tv133 = 224
tv142 = 232
tv146 = 240
tv164 = 248
tv163 = 252
tv225 = 256
tv234 = 264
tv271 = 272
tv280 = 280
tv304 = 288
tv317 = 292
tv318 = 296
tv316 = 300
tv363 = 304
tv372 = 312
tv413 = 320
tv422 = 328
tv464 = 336
tv473 = 344
tv512 = 352
tv521 = 360
tv546 = 368
tv560 = 372
tv561 = 376
tv559 = 380
tv606 = 384
tv615 = 392
tv657 = 400
tv666 = 408
tv712 = 416
tv721 = 424
tv760 = 432
tv769 = 440
tv794 = 448
tv808 = 452
tv809 = 456
tv807 = 460
tv854 = 464
tv863 = 472
tv905 = 480
tv914 = 488
aa$ = 512
base$ = 520
alternate$ = 528
p_output$ = 536
writer$ = 544
long_format_binary PROC					; COMDAT

; 1749 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H

; 1750 :     register PyLongObject *a = (PyLongObject *)aa;

  0001a	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR aa$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 1751 :     PyObject *v;
; 1752 :     Py_ssize_t sz;
; 1753 :     Py_ssize_t size_a;
; 1754 :     enum PyUnicode_Kind kind;
; 1755 :     int negative;
; 1756 :     int bits;
; 1757 : 
; 1758 :     assert(base == 2 || base == 8 || base == 16);

  00027	83 bc 24 08 02
	00 00 02	 cmp	 DWORD PTR base$[rsp], 2
  0002f	74 30		 je	 SHORT $LN88@long_forma
  00031	83 bc 24 08 02
	00 00 08	 cmp	 DWORD PTR base$[rsp], 8
  00039	74 26		 je	 SHORT $LN88@long_forma
  0003b	83 bc 24 08 02
	00 00 10	 cmp	 DWORD PTR base$[rsp], 16
  00043	74 1c		 je	 SHORT $LN88@long_forma
  00045	41 b8 de 06 00
	00		 mov	 r8d, 1758		; 000006deH
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@CMLFNKHE@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DN@
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005f	33 c0		 xor	 eax, eax
$LN88@long_forma:

; 1759 :     if (a == NULL || !PyLong_Check(a)) {

  00061	48 83 7c 24 30
	00		 cmp	 QWORD PTR a$[rsp], 0
  00067	74 18		 je	 SHORT $LN84@long_forma
  00069	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0006e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00072	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00078	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0007d	85 c0		 test	 eax, eax
  0007f	75 1b		 jne	 SHORT $LN85@long_forma
$LN84@long_forma:

; 1760 :         PyErr_BadInternalCall();

  00081	ba e0 06 00 00	 mov	 edx, 1760		; 000006e0H
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0008d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1761 :         return -1;

  00092	b8 ff ff ff ff	 mov	 eax, -1
  00097	e9 92 1e 00 00	 jmp	 $LN86@long_forma
$LN85@long_forma:

; 1762 :     }
; 1763 :     size_a = ABS(Py_SIZE(a));

  0009c	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000a1	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a6	7d 16		 jge	 SHORT $LN89@long_forma
  000a8	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000ad	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b1	48 f7 d8	 neg	 rax
  000b4	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv83[rsp], rax
  000bc	eb 11		 jmp	 SHORT $LN90@long_forma
$LN89@long_forma:
  000be	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000c3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000c7	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv83[rsp], rax
$LN90@long_forma:
  000cf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv83[rsp]
  000d7	48 89 44 24 40	 mov	 QWORD PTR size_a$[rsp], rax

; 1764 :     negative = Py_SIZE(a) < 0;

  000dc	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000e1	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000e6	7d 0d		 jge	 SHORT $LN91@long_forma
  000e8	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv86[rsp], 1
  000f3	eb 0b		 jmp	 SHORT $LN92@long_forma
$LN91@long_forma:
  000f5	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv86[rsp], 0
$LN92@long_forma:
  00100	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv86[rsp]
  00107	89 44 24 20	 mov	 DWORD PTR negative$[rsp], eax

; 1765 : 
; 1766 :     /* Compute a rough upper bound for the length of the string */
; 1767 :     switch (base) {

  0010b	8b 84 24 08 02
	00 00		 mov	 eax, DWORD PTR base$[rsp]
  00112	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv87[rsp], eax
  00119	83 bc 24 dc 00
	00 00 02	 cmp	 DWORD PTR tv87[rsp], 2
  00121	74 2a		 je	 SHORT $LN79@long_forma
  00123	83 bc 24 dc 00
	00 00 08	 cmp	 DWORD PTR tv87[rsp], 8
  0012b	74 16		 je	 SHORT $LN80@long_forma
  0012d	83 bc 24 dc 00
	00 00 10	 cmp	 DWORD PTR tv87[rsp], 16
  00135	74 02		 je	 SHORT $LN81@long_forma
  00137	eb 1e		 jmp	 SHORT $LN78@long_forma
$LN81@long_forma:

; 1768 :     case 16:
; 1769 :         bits = 4;

  00139	c7 44 24 38 04
	00 00 00	 mov	 DWORD PTR bits$[rsp], 4

; 1770 :         break;

  00141	eb 3e		 jmp	 SHORT $LN82@long_forma
$LN80@long_forma:

; 1771 :     case 8:
; 1772 :         bits = 3;

  00143	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR bits$[rsp], 3

; 1773 :         break;

  0014b	eb 34		 jmp	 SHORT $LN82@long_forma
$LN79@long_forma:

; 1774 :     case 2:
; 1775 :         bits = 1;

  0014d	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR bits$[rsp], 1

; 1776 :         break;

  00155	eb 2a		 jmp	 SHORT $LN82@long_forma
$LN78@long_forma:

; 1777 :     default:
; 1778 :         assert(0); /* shouldn't ever get here */

  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 1c		 jne	 SHORT $LN93@long_forma
  0015d	41 b8 f2 06 00
	00		 mov	 r8d, 1778		; 000006f2H
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00177	33 c0		 xor	 eax, eax
$LN93@long_forma:

; 1779 :         bits = 0; /* to silence gcc warning */

  00179	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
$LN82@long_forma:

; 1780 :     }
; 1781 : 
; 1782 :     /* Compute exact length 'sz' of output string. */
; 1783 :     if (size_a == 0) {

  00181	48 83 7c 24 40
	00		 cmp	 QWORD PTR size_a$[rsp], 0
  00187	75 0e		 jne	 SHORT $LN77@long_forma

; 1784 :         sz = 1;

  00189	48 c7 44 24 48
	01 00 00 00	 mov	 QWORD PTR sz$[rsp], 1

; 1785 :     }
; 1786 :     else {

  00192	e9 bb 00 00 00	 jmp	 $LN76@long_forma
$LN77@long_forma:

; 1787 :         Py_ssize_t size_a_in_bits;
; 1788 :         /* Ensure overflow doesn't occur during computation of sz. */
; 1789 :         if (size_a > (PY_SSIZE_T_MAX - 3) / PyLong_SHIFT) {

  00197	48 b8 44 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825860	; 0444444444444444H
  001a1	48 39 44 24 40	 cmp	 QWORD PTR size_a$[rsp], rax
  001a6	7e 1d		 jle	 SHORT $LN75@long_forma

; 1790 :             PyErr_SetString(PyExc_OverflowError,
; 1791 :                             "int is too large to format");

  001a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@JIIGGCNL@int?5is?5too?5large?5to?5format?$AA@
  001af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001b6	e8 00 00 00 00	 call	 PyErr_SetString

; 1792 :             return -1;

  001bb	b8 ff ff ff ff	 mov	 eax, -1
  001c0	e9 69 1d 00 00	 jmp	 $LN86@long_forma
$LN75@long_forma:

; 1793 :         }
; 1794 :         size_a_in_bits = (size_a - 1) * PyLong_SHIFT +
; 1795 :                          bits_in_digit(a->ob_digit[size_a - 1]);

  001c5	48 8b 44 24 40	 mov	 rax, QWORD PTR size_a$[rsp]
  001ca	48 ff c8	 dec	 rax
  001cd	48 6b c0 1e	 imul	 rax, 30
  001d1	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  001d9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  001de	48 8b 54 24 40	 mov	 rdx, QWORD PTR size_a$[rsp]
  001e3	8b 4c 91 6c	 mov	 ecx, DWORD PTR [rcx+rdx*4+108]
  001e7	e8 00 00 00 00	 call	 bits_in_digit
  001ec	48 98		 cdqe
  001ee	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  001f6	48 03 c8	 add	 rcx, rax
  001f9	48 8b c1	 mov	 rax, rcx
  001fc	48 89 44 24 50	 mov	 QWORD PTR size_a_in_bits$21740[rsp], rax

; 1796 :         /* Allow 1 character for a '-' sign. */
; 1797 :         sz = negative + (size_a_in_bits + (bits - 1)) / bits;

  00201	48 63 44 24 20	 movsxd	 rax, DWORD PTR negative$[rsp]
  00206	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv142[rsp], rax
  0020e	8b 4c 24 38	 mov	 ecx, DWORD PTR bits$[rsp]
  00212	ff c9		 dec	 ecx
  00214	48 63 c9	 movsxd	 rcx, ecx
  00217	48 8b 54 24 50	 mov	 rdx, QWORD PTR size_a_in_bits$21740[rsp]
  0021c	48 03 d1	 add	 rdx, rcx
  0021f	48 8b ca	 mov	 rcx, rdx
  00222	48 63 54 24 38	 movsxd	 rdx, DWORD PTR bits$[rsp]
  00227	48 89 94 24 f0
	00 00 00	 mov	 QWORD PTR tv146[rsp], rdx
  0022f	48 8b c1	 mov	 rax, rcx
  00232	48 99		 cdq
  00234	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv146[rsp]
  0023c	48 f7 f9	 idiv	 rcx
  0023f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv142[rsp]
  00247	48 03 c8	 add	 rcx, rax
  0024a	48 8b c1	 mov	 rax, rcx
  0024d	48 89 44 24 48	 mov	 QWORD PTR sz$[rsp], rax
$LN76@long_forma:

; 1798 :     }
; 1799 :     if (alternate) {

  00252	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR alternate$[rsp], 0
  0025a	74 0e		 je	 SHORT $LN74@long_forma

; 1800 :         /* 2 characters for prefix  */
; 1801 :         sz += 2;

  0025c	48 8b 44 24 48	 mov	 rax, QWORD PTR sz$[rsp]
  00261	48 83 c0 02	 add	 rax, 2
  00265	48 89 44 24 48	 mov	 QWORD PTR sz$[rsp], rax
$LN74@long_forma:

; 1802 :     }
; 1803 : 
; 1804 :     if (writer) {

  0026a	48 83 bc 24 20
	02 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  00273	0f 84 b0 00 00
	00		 je	 $LN73@long_forma

; 1805 :         if (_PyUnicodeWriter_Prepare(writer, sz, 'x') == -1)

  00279	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00281	83 78 14 78	 cmp	 DWORD PTR [rax+20], 120	; 00000078H
  00285	72 2f		 jb	 SHORT $LN94@long_forma
  00287	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0028f	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR writer$[rsp]
  00297	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0029b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0029f	48 2b c1	 sub	 rax, rcx
  002a2	48 39 44 24 48	 cmp	 QWORD PTR sz$[rsp], rax
  002a7	7f 0d		 jg	 SHORT $LN94@long_forma
  002a9	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv164[rsp], 0
  002b4	eb 42		 jmp	 SHORT $LN97@long_forma
$LN94@long_forma:
  002b6	48 83 7c 24 48
	00		 cmp	 QWORD PTR sz$[rsp], 0
  002bc	75 0d		 jne	 SHORT $LN95@long_forma
  002be	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv163[rsp], 0
  002c9	eb 1f		 jmp	 SHORT $LN96@long_forma
$LN95@long_forma:
  002cb	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  002d1	48 8b 54 24 48	 mov	 rdx, QWORD PTR sz$[rsp]
  002d6	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR writer$[rsp]
  002de	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  002e3	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv163[rsp], eax
$LN96@long_forma:
  002ea	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR tv163[rsp]
  002f1	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv164[rsp], eax
$LN97@long_forma:
  002f8	83 bc 24 f8 00
	00 00 ff	 cmp	 DWORD PTR tv164[rsp], -1
  00300	75 0a		 jne	 SHORT $LN72@long_forma

; 1806 :             return -1;

  00302	b8 ff ff ff ff	 mov	 eax, -1
  00307	e9 22 1c 00 00	 jmp	 $LN86@long_forma
$LN72@long_forma:

; 1807 :         kind = writer->kind;

  0030c	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00314	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00317	89 44 24 24	 mov	 DWORD PTR kind$[rsp], eax

; 1808 :         v = NULL;

  0031b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR v$[rsp], 0

; 1809 :     }
; 1810 :     else {

  00324	e9 9a 00 00 00	 jmp	 $LN71@long_forma
$LN73@long_forma:

; 1811 :         v = PyUnicode_New(sz, 'x');

  00329	ba 78 00 00 00	 mov	 edx, 120		; 00000078H
  0032e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sz$[rsp]
  00333	e8 00 00 00 00	 call	 PyUnicode_New
  00338	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 1812 :         if (v == NULL)

  0033d	48 83 7c 24 28
	00		 cmp	 QWORD PTR v$[rsp], 0
  00343	75 0a		 jne	 SHORT $LN70@long_forma

; 1813 :             return -1;

  00345	b8 ff ff ff ff	 mov	 eax, -1
  0034a	e9 df 1b 00 00	 jmp	 $LN86@long_forma
$LN70@long_forma:

; 1814 :         kind = PyUnicode_KIND(v);

  0034f	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00354	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00358	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0035e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00363	85 c0		 test	 eax, eax
  00365	75 1c		 jne	 SHORT $LN98@long_forma
  00367	41 b8 16 07 00
	00		 mov	 r8d, 1814		; 00000716H
  0036d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0037b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00381	33 c0		 xor	 eax, eax
$LN98@long_forma:
  00383	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00388	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0038b	c1 e8 07	 shr	 eax, 7
  0038e	83 e0 01	 and	 eax, 1
  00391	85 c0		 test	 eax, eax
  00393	75 1c		 jne	 SHORT $LN99@long_forma
  00395	41 b8 16 07 00
	00		 mov	 r8d, 1814		; 00000716H
  0039b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  003a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003af	33 c0		 xor	 eax, eax
$LN99@long_forma:
  003b1	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  003b6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003b9	c1 e8 02	 shr	 eax, 2
  003bc	83 e0 07	 and	 eax, 7
  003bf	89 44 24 24	 mov	 DWORD PTR kind$[rsp], eax
$LN71@long_forma:

; 1815 :     }
; 1816 : 
; 1817 : #define WRITE_DIGITS(TYPE)                                              \
; 1818 :     do {                                                                \
; 1819 :         if (writer)                                                     \
; 1820 :             p = (TYPE*)PyUnicode_DATA(writer->buffer) + writer->pos + sz; \
; 1821 :         else                                                            \
; 1822 :             p = (TYPE*)PyUnicode_DATA(v) + sz;                          \
; 1823 :                                                                         \
; 1824 :         if (size_a == 0) {                                              \
; 1825 :             *--p = '0';                                                 \
; 1826 :         }                                                               \
; 1827 :         else {                                                          \
; 1828 :             /* JRH: special case for power-of-2 bases */                \
; 1829 :             twodigits accum = 0;                                        \
; 1830 :             int accumbits = 0;   /* # of bits in accum */               \
; 1831 :             Py_ssize_t i;                                               \
; 1832 :             for (i = 0; i < size_a; ++i) {                              \
; 1833 :                 accum |= (twodigits)a->ob_digit[i] << accumbits;        \
; 1834 :                 accumbits += PyLong_SHIFT;                              \
; 1835 :                 assert(accumbits >= bits);                              \
; 1836 :                 do {                                                    \
; 1837 :                     char cdigit;                                        \
; 1838 :                     cdigit = (char)(accum & (base - 1));                \
; 1839 :                     cdigit += (cdigit < 10) ? '0' : 'a'-10;             \
; 1840 :                     *--p = cdigit;                                      \
; 1841 :                     accumbits -= bits;                                  \
; 1842 :                     accum >>= bits;                                     \
; 1843 :                 } while (i < size_a-1 ? accumbits >= bits : accum > 0); \
; 1844 :             }                                                           \
; 1845 :         }                                                               \
; 1846 :                                                                         \
; 1847 :         if (alternate) {                                                \
; 1848 :             if (base == 16)                                             \
; 1849 :                 *--p = 'x';                                             \
; 1850 :             else if (base == 8)                                         \
; 1851 :                 *--p = 'o';                                             \
; 1852 :             else /* (base == 2) */                                      \
; 1853 :                 *--p = 'b';                                             \
; 1854 :             *--p = '0';                                                 \
; 1855 :         }                                                               \
; 1856 :         if (negative)                                                   \
; 1857 :             *--p = '-';                                                 \
; 1858 :         if (writer)                                                     \
; 1859 :             assert(p == ((TYPE*)PyUnicode_DATA(writer->buffer) + writer->pos)); \
; 1860 :         else                                                            \
; 1861 :             assert(p == (TYPE*)PyUnicode_DATA(v));                      \
; 1862 :     } while (0)
; 1863 : 
; 1864 :     if (kind == PyUnicode_1BYTE_KIND) {

  003c3	83 7c 24 24 01	 cmp	 DWORD PTR kind$[rsp], 1
  003c8	0f 85 72 08 00
	00		 jne	 $LN69@long_forma
$LN68@long_forma:

; 1865 :         Py_UCS1 *p;
; 1866 :         WRITE_DIGITS(Py_UCS1);

  003ce	48 83 bc 24 20
	02 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  003d7	0f 84 96 01 00
	00		 je	 $LN65@long_forma
  003dd	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  003e5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003e8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003ec	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003f2	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  003f7	85 c0		 test	 eax, eax
  003f9	75 1c		 jne	 SHORT $LN100@long_forma
  003fb	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00401	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00408	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  0040f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00415	33 c0		 xor	 eax, eax
$LN100@long_forma:
  00417	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0041f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00422	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00425	c1 e8 05	 shr	 eax, 5
  00428	83 e0 01	 and	 eax, 1
  0042b	85 c0		 test	 eax, eax
  0042d	0f 84 cc 00 00
	00		 je	 $LN106@long_forma
  00433	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0043b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0043e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00442	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00448	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0044d	85 c0		 test	 eax, eax
  0044f	75 1c		 jne	 SHORT $LN101@long_forma
  00451	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00457	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0045e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0046b	33 c0		 xor	 eax, eax
$LN101@long_forma:
  0046d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00475	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00478	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0047b	c1 e8 07	 shr	 eax, 7
  0047e	83 e0 01	 and	 eax, 1
  00481	85 c0		 test	 eax, eax
  00483	75 1c		 jne	 SHORT $LN102@long_forma
  00485	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  0048b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00492	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  00499	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0049f	33 c0		 xor	 eax, eax
$LN102@long_forma:
  004a1	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  004a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004ac	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004af	c1 e8 06	 shr	 eax, 6
  004b2	83 e0 01	 and	 eax, 1
  004b5	85 c0		 test	 eax, eax
  004b7	74 1b		 je	 SHORT $LN103@long_forma
  004b9	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  004c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004c4	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  004ca	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv225[rsp], rax
  004d2	eb 19		 jmp	 SHORT $LN104@long_forma
$LN103@long_forma:
  004d4	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  004dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004df	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  004e5	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv225[rsp], rax
$LN104@long_forma:
  004ed	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv225[rsp]
  004f5	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv234[rsp], rax
  004fd	eb 4b		 jmp	 SHORT $LN107@long_forma
$LN106@long_forma:
  004ff	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00507	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0050a	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00512	75 1c		 jne	 SHORT $LN105@long_forma
  00514	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  0051a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00521	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  00528	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0052e	33 c0		 xor	 eax, eax
$LN105@long_forma:
  00530	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00538	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0053b	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00542	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv234[rsp], rax
$LN107@long_forma:
  0054a	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00552	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00556	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv234[rsp]
  0055e	48 03 c8	 add	 rcx, rax
  00561	48 8b c1	 mov	 rax, rcx
  00564	48 03 44 24 48	 add	 rax, QWORD PTR sz$[rsp]
  00569	48 89 44 24 58	 mov	 QWORD PTR p$21761[rsp], rax
  0056e	e9 4f 01 00 00	 jmp	 $LN64@long_forma
$LN65@long_forma:
  00573	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00578	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0057c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00582	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00587	85 c0		 test	 eax, eax
  00589	75 1c		 jne	 SHORT $LN108@long_forma
  0058b	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00591	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00598	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  0059f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005a5	33 c0		 xor	 eax, eax
$LN108@long_forma:
  005a7	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  005ac	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  005af	c1 e8 05	 shr	 eax, 5
  005b2	83 e0 01	 and	 eax, 1
  005b5	85 c0		 test	 eax, eax
  005b7	0f 84 ae 00 00
	00		 je	 $LN114@long_forma
  005bd	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  005c2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005c6	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005cc	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  005d1	85 c0		 test	 eax, eax
  005d3	75 1c		 jne	 SHORT $LN109@long_forma
  005d5	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  005db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  005e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  005e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005ef	33 c0		 xor	 eax, eax
$LN109@long_forma:
  005f1	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  005f6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  005f9	c1 e8 07	 shr	 eax, 7
  005fc	83 e0 01	 and	 eax, 1
  005ff	85 c0		 test	 eax, eax
  00601	75 1c		 jne	 SHORT $LN110@long_forma
  00603	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00609	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00610	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00617	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0061d	33 c0		 xor	 eax, eax
$LN110@long_forma:
  0061f	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00624	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00627	c1 e8 06	 shr	 eax, 6
  0062a	83 e0 01	 and	 eax, 1
  0062d	85 c0		 test	 eax, eax
  0062f	74 15		 je	 SHORT $LN111@long_forma
  00631	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00636	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0063c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv271[rsp], rax
  00644	eb 13		 jmp	 SHORT $LN112@long_forma
$LN111@long_forma:
  00646	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  0064b	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00651	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv271[rsp], rax
$LN112@long_forma:
  00659	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv271[rsp]
  00661	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv280[rsp], rax
  00669	eb 3f		 jmp	 SHORT $LN115@long_forma
$LN114@long_forma:
  0066b	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00670	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00678	75 1c		 jne	 SHORT $LN113@long_forma
  0067a	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00680	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00687	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
  0068e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00694	33 c0		 xor	 eax, eax
$LN113@long_forma:
  00696	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  0069b	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  006a2	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv280[rsp], rax
$LN115@long_forma:
  006aa	48 8b 44 24 48	 mov	 rax, QWORD PTR sz$[rsp]
  006af	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv280[rsp]
  006b7	48 03 c8	 add	 rcx, rax
  006ba	48 8b c1	 mov	 rax, rcx
  006bd	48 89 44 24 58	 mov	 QWORD PTR p$21761[rsp], rax
$LN64@long_forma:
  006c2	48 83 7c 24 40
	00		 cmp	 QWORD PTR size_a$[rsp], 0
  006c8	75 1a		 jne	 SHORT $LN63@long_forma
  006ca	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  006cf	48 ff c8	 dec	 rax
  006d2	48 89 44 24 58	 mov	 QWORD PTR p$21761[rsp], rax
  006d7	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  006dc	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
  006df	e9 9b 01 00 00	 jmp	 $LN62@long_forma
$LN63@long_forma:
  006e4	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR accum$21802[rsp], 0
  006ed	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR accumbits$21803[rsp], 0
  006f5	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR i$21804[rsp], 0
  006fe	eb 0d		 jmp	 SHORT $LN61@long_forma
$LN60@long_forma:
  00700	48 8b 44 24 60	 mov	 rax, QWORD PTR i$21804[rsp]
  00705	48 ff c0	 inc	 rax
  00708	48 89 44 24 60	 mov	 QWORD PTR i$21804[rsp], rax
$LN61@long_forma:
  0070d	48 8b 44 24 40	 mov	 rax, QWORD PTR size_a$[rsp]
  00712	48 39 44 24 60	 cmp	 QWORD PTR i$21804[rsp], rax
  00717	0f 8d 62 01 00
	00		 jge	 $LN59@long_forma
  0071d	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00722	48 8b 4c 24 60	 mov	 rcx, QWORD PTR i$21804[rsp]
  00727	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  0072b	8b 4c 24 68	 mov	 ecx, DWORD PTR accumbits$21803[rsp]
  0072f	48 d3 e0	 shl	 rax, cl
  00732	48 8b 4c 24 70	 mov	 rcx, QWORD PTR accum$21802[rsp]
  00737	48 0b c8	 or	 rcx, rax
  0073a	48 8b c1	 mov	 rax, rcx
  0073d	48 89 44 24 70	 mov	 QWORD PTR accum$21802[rsp], rax
  00742	8b 44 24 68	 mov	 eax, DWORD PTR accumbits$21803[rsp]
  00746	83 c0 1e	 add	 eax, 30
  00749	89 44 24 68	 mov	 DWORD PTR accumbits$21803[rsp], eax
  0074d	8b 44 24 38	 mov	 eax, DWORD PTR bits$[rsp]
  00751	39 44 24 68	 cmp	 DWORD PTR accumbits$21803[rsp], eax
  00755	7d 1c		 jge	 SHORT $LN116@long_forma
  00757	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  0075d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00764	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@HAAJLKOA@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAi?$AAt?$AAs?$AA?$AA@
  0076b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00771	33 c0		 xor	 eax, eax
$LN116@long_forma:
$LN58@long_forma:
  00773	8b 84 24 08 02
	00 00		 mov	 eax, DWORD PTR base$[rsp]
  0077a	ff c8		 dec	 eax
  0077c	48 98		 cdqe
  0077e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR accum$21802[rsp]
  00783	48 23 c8	 and	 rcx, rax
  00786	48 8b c1	 mov	 rax, rcx
  00789	88 44 24 78	 mov	 BYTE PTR cdigit$21814[rsp], al
  0078d	0f be 44 24 78	 movsx	 eax, BYTE PTR cdigit$21814[rsp]
  00792	83 f8 0a	 cmp	 eax, 10
  00795	7d 0d		 jge	 SHORT $LN117@long_forma
  00797	c7 84 24 20 01
	00 00 30 00 00
	00		 mov	 DWORD PTR tv304[rsp], 48 ; 00000030H
  007a2	eb 0b		 jmp	 SHORT $LN118@long_forma
$LN117@long_forma:
  007a4	c7 84 24 20 01
	00 00 57 00 00
	00		 mov	 DWORD PTR tv304[rsp], 87 ; 00000057H
$LN118@long_forma:
  007af	0f be 44 24 78	 movsx	 eax, BYTE PTR cdigit$21814[rsp]
  007b4	03 84 24 20 01
	00 00		 add	 eax, DWORD PTR tv304[rsp]
  007bb	88 44 24 78	 mov	 BYTE PTR cdigit$21814[rsp], al
  007bf	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  007c4	48 ff c8	 dec	 rax
  007c7	48 89 44 24 58	 mov	 QWORD PTR p$21761[rsp], rax
  007cc	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  007d1	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR cdigit$21814[rsp]
  007d6	88 08		 mov	 BYTE PTR [rax], cl
  007d8	8b 44 24 38	 mov	 eax, DWORD PTR bits$[rsp]
  007dc	8b 4c 24 68	 mov	 ecx, DWORD PTR accumbits$21803[rsp]
  007e0	2b c8		 sub	 ecx, eax
  007e2	8b c1		 mov	 eax, ecx
  007e4	89 44 24 68	 mov	 DWORD PTR accumbits$21803[rsp], eax
  007e8	48 63 44 24 38	 movsxd	 rax, DWORD PTR bits$[rsp]
  007ed	0f b6 c8	 movzx	 ecx, al
  007f0	48 8b 44 24 70	 mov	 rax, QWORD PTR accum$21802[rsp]
  007f5	48 d3 e8	 shr	 rax, cl
  007f8	48 89 44 24 70	 mov	 QWORD PTR accum$21802[rsp], rax
  007fd	48 8b 44 24 40	 mov	 rax, QWORD PTR size_a$[rsp]
  00802	48 ff c8	 dec	 rax
  00805	48 39 44 24 60	 cmp	 QWORD PTR i$21804[rsp], rax
  0080a	7d 32		 jge	 SHORT $LN123@long_forma
  0080c	8b 44 24 38	 mov	 eax, DWORD PTR bits$[rsp]
  00810	39 44 24 68	 cmp	 DWORD PTR accumbits$21803[rsp], eax
  00814	7c 0d		 jl	 SHORT $LN121@long_forma
  00816	c7 84 24 24 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv317[rsp], 1
  00821	eb 0b		 jmp	 SHORT $LN122@long_forma
$LN121@long_forma:
  00823	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv317[rsp], 0
$LN122@long_forma:
  0082e	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR tv317[rsp]
  00835	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv318[rsp], eax
  0083c	eb 2e		 jmp	 SHORT $LN124@long_forma
$LN123@long_forma:
  0083e	48 83 7c 24 70
	00		 cmp	 QWORD PTR accum$21802[rsp], 0
  00844	76 0d		 jbe	 SHORT $LN119@long_forma
  00846	c7 84 24 2c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv316[rsp], 1
  00851	eb 0b		 jmp	 SHORT $LN120@long_forma
$LN119@long_forma:
  00853	c7 84 24 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv316[rsp], 0
$LN120@long_forma:
  0085e	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR tv316[rsp]
  00865	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv318[rsp], eax
$LN124@long_forma:
  0086c	83 bc 24 28 01
	00 00 00	 cmp	 DWORD PTR tv318[rsp], 0
  00874	0f 85 f9 fe ff
	ff		 jne	 $LN58@long_forma
  0087a	e9 81 fe ff ff	 jmp	 $LN60@long_forma
$LN59@long_forma:
$LN62@long_forma:
  0087f	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR alternate$[rsp], 0
  00887	74 6c		 je	 SHORT $LN55@long_forma
  00889	83 bc 24 08 02
	00 00 10	 cmp	 DWORD PTR base$[rsp], 16
  00891	75 17		 jne	 SHORT $LN54@long_forma
  00893	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  00898	48 ff c8	 dec	 rax
  0089b	48 89 44 24 58	 mov	 QWORD PTR p$21761[rsp], rax
  008a0	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  008a5	c6 00 78	 mov	 BYTE PTR [rax], 120	; 00000078H
  008a8	eb 36		 jmp	 SHORT $LN53@long_forma
$LN54@long_forma:
  008aa	83 bc 24 08 02
	00 00 08	 cmp	 DWORD PTR base$[rsp], 8
  008b2	75 17		 jne	 SHORT $LN52@long_forma
  008b4	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  008b9	48 ff c8	 dec	 rax
  008bc	48 89 44 24 58	 mov	 QWORD PTR p$21761[rsp], rax
  008c1	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  008c6	c6 00 6f	 mov	 BYTE PTR [rax], 111	; 0000006fH
  008c9	eb 15		 jmp	 SHORT $LN51@long_forma
$LN52@long_forma:
  008cb	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  008d0	48 ff c8	 dec	 rax
  008d3	48 89 44 24 58	 mov	 QWORD PTR p$21761[rsp], rax
  008d8	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  008dd	c6 00 62	 mov	 BYTE PTR [rax], 98	; 00000062H
$LN51@long_forma:
$LN53@long_forma:
  008e0	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  008e5	48 ff c8	 dec	 rax
  008e8	48 89 44 24 58	 mov	 QWORD PTR p$21761[rsp], rax
  008ed	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  008f2	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
$LN55@long_forma:
  008f5	83 7c 24 20 00	 cmp	 DWORD PTR negative$[rsp], 0
  008fa	74 15		 je	 SHORT $LN50@long_forma
  008fc	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  00901	48 ff c8	 dec	 rax
  00904	48 89 44 24 58	 mov	 QWORD PTR p$21761[rsp], rax
  00909	48 8b 44 24 58	 mov	 rax, QWORD PTR p$21761[rsp]
  0090e	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH
$LN50@long_forma:
  00911	48 83 bc 24 20
	02 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  0091a	0f 84 af 01 00
	00		 je	 $LN49@long_forma
  00920	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00928	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0092b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0092f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00935	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0093a	85 c0		 test	 eax, eax
  0093c	75 1c		 jne	 SHORT $LN125@long_forma
  0093e	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00944	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0094b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  00952	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00958	33 c0		 xor	 eax, eax
$LN125@long_forma:
  0095a	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00962	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00965	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00968	c1 e8 05	 shr	 eax, 5
  0096b	83 e0 01	 and	 eax, 1
  0096e	85 c0		 test	 eax, eax
  00970	0f 84 cc 00 00
	00		 je	 $LN131@long_forma
  00976	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0097e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00981	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00985	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0098b	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00990	85 c0		 test	 eax, eax
  00992	75 1c		 jne	 SHORT $LN126@long_forma
  00994	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  0099a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  009a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  009a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009ae	33 c0		 xor	 eax, eax
$LN126@long_forma:
  009b0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  009b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009bb	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  009be	c1 e8 07	 shr	 eax, 7
  009c1	83 e0 01	 and	 eax, 1
  009c4	85 c0		 test	 eax, eax
  009c6	75 1c		 jne	 SHORT $LN127@long_forma
  009c8	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  009ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  009d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  009dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009e2	33 c0		 xor	 eax, eax
$LN127@long_forma:
  009e4	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  009ec	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009ef	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  009f2	c1 e8 06	 shr	 eax, 6
  009f5	83 e0 01	 and	 eax, 1
  009f8	85 c0		 test	 eax, eax
  009fa	74 1b		 je	 SHORT $LN128@long_forma
  009fc	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00a04	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a07	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00a0d	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv363[rsp], rax
  00a15	eb 19		 jmp	 SHORT $LN129@long_forma
$LN128@long_forma:
  00a17	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00a1f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a22	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00a28	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv363[rsp], rax
$LN129@long_forma:
  00a30	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv363[rsp]
  00a38	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv372[rsp], rax
  00a40	eb 4b		 jmp	 SHORT $LN132@long_forma
$LN131@long_forma:
  00a42	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00a4a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a4d	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00a55	75 1c		 jne	 SHORT $LN130@long_forma
  00a57	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00a5d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00a64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  00a6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a71	33 c0		 xor	 eax, eax
$LN130@long_forma:
  00a73	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00a7b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a7e	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00a85	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv372[rsp], rax
$LN132@long_forma:
  00a8d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00a95	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00a99	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv372[rsp]
  00aa1	48 03 c8	 add	 rcx, rax
  00aa4	48 8b c1	 mov	 rax, rcx
  00aa7	48 39 44 24 58	 cmp	 QWORD PTR p$21761[rsp], rax
  00aac	74 1c		 je	 SHORT $LN133@long_forma
  00aae	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00ab4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00abb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HM@GBCHCBDO@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@
  00ac2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00ac8	33 c0		 xor	 eax, eax
$LN133@long_forma:
  00aca	e9 62 01 00 00	 jmp	 $LN48@long_forma
$LN49@long_forma:
  00acf	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00ad4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00ad8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00ade	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00ae3	85 c0		 test	 eax, eax
  00ae5	75 1c		 jne	 SHORT $LN134@long_forma
  00ae7	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00aed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00af4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00afb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00b01	33 c0		 xor	 eax, eax
$LN134@long_forma:
  00b03	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00b08	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00b0b	c1 e8 05	 shr	 eax, 5
  00b0e	83 e0 01	 and	 eax, 1
  00b11	85 c0		 test	 eax, eax
  00b13	0f 84 ae 00 00
	00		 je	 $LN140@long_forma
  00b19	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00b1e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00b22	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00b28	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00b2d	85 c0		 test	 eax, eax
  00b2f	75 1c		 jne	 SHORT $LN135@long_forma
  00b31	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00b37	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00b3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00b45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00b4b	33 c0		 xor	 eax, eax
$LN135@long_forma:
  00b4d	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00b52	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00b55	c1 e8 07	 shr	 eax, 7
  00b58	83 e0 01	 and	 eax, 1
  00b5b	85 c0		 test	 eax, eax
  00b5d	75 1c		 jne	 SHORT $LN136@long_forma
  00b5f	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00b65	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00b6c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00b73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00b79	33 c0		 xor	 eax, eax
$LN136@long_forma:
  00b7b	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00b80	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00b83	c1 e8 06	 shr	 eax, 6
  00b86	83 e0 01	 and	 eax, 1
  00b89	85 c0		 test	 eax, eax
  00b8b	74 15		 je	 SHORT $LN137@long_forma
  00b8d	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00b92	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00b98	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv413[rsp], rax
  00ba0	eb 13		 jmp	 SHORT $LN138@long_forma
$LN137@long_forma:
  00ba2	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00ba7	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00bad	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv413[rsp], rax
$LN138@long_forma:
  00bb5	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR tv413[rsp]
  00bbd	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv422[rsp], rax
  00bc5	eb 3f		 jmp	 SHORT $LN141@long_forma
$LN140@long_forma:
  00bc7	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00bcc	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00bd4	75 1c		 jne	 SHORT $LN139@long_forma
  00bd6	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00bdc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00be3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
  00bea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00bf0	33 c0		 xor	 eax, eax
$LN139@long_forma:
  00bf2	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00bf7	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00bfe	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv422[rsp], rax
$LN141@long_forma:
  00c06	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR tv422[rsp]
  00c0e	48 39 44 24 58	 cmp	 QWORD PTR p$21761[rsp], rax
  00c13	74 1c		 je	 SHORT $LN142@long_forma
  00c15	41 b8 4a 07 00
	00		 mov	 r8d, 1866		; 0000074aH
  00c1b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00c22	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@HKDHNHBJ@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA1?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@
  00c29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c2f	33 c0		 xor	 eax, eax
$LN142@long_forma:
$LN48@long_forma:
  00c31	33 c0		 xor	 eax, eax
  00c33	85 c0		 test	 eax, eax
  00c35	0f 85 93 f7 ff
	ff		 jne	 $LN68@long_forma

; 1867 :     }
; 1868 :     else if (kind == PyUnicode_2BYTE_KIND) {

  00c3b	e9 83 12 00 00	 jmp	 $LN47@long_forma
$LN69@long_forma:
  00c40	83 7c 24 24 02	 cmp	 DWORD PTR kind$[rsp], 2
  00c45	0f 85 34 09 00
	00		 jne	 $LN46@long_forma
$LN45@long_forma:

; 1869 :         Py_UCS2 *p;
; 1870 :         WRITE_DIGITS(Py_UCS2);

  00c4b	48 83 bc 24 20
	02 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  00c54	0f 84 9b 01 00
	00		 je	 $LN42@long_forma
  00c5a	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00c62	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c65	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00c69	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00c6f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00c74	85 c0		 test	 eax, eax
  00c76	75 1c		 jne	 SHORT $LN143@long_forma
  00c78	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  00c7e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00c85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  00c8c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c92	33 c0		 xor	 eax, eax
$LN143@long_forma:
  00c94	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00c9c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c9f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00ca2	c1 e8 05	 shr	 eax, 5
  00ca5	83 e0 01	 and	 eax, 1
  00ca8	85 c0		 test	 eax, eax
  00caa	0f 84 cc 00 00
	00		 je	 $LN149@long_forma
  00cb0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00cb8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00cbb	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00cbf	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00cc5	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00cca	85 c0		 test	 eax, eax
  00ccc	75 1c		 jne	 SHORT $LN144@long_forma
  00cce	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  00cd4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00cdb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  00ce2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00ce8	33 c0		 xor	 eax, eax
$LN144@long_forma:
  00cea	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00cf2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00cf5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00cf8	c1 e8 07	 shr	 eax, 7
  00cfb	83 e0 01	 and	 eax, 1
  00cfe	85 c0		 test	 eax, eax
  00d00	75 1c		 jne	 SHORT $LN145@long_forma
  00d02	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  00d08	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00d0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  00d16	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00d1c	33 c0		 xor	 eax, eax
$LN145@long_forma:
  00d1e	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00d26	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d29	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00d2c	c1 e8 06	 shr	 eax, 6
  00d2f	83 e0 01	 and	 eax, 1
  00d32	85 c0		 test	 eax, eax
  00d34	74 1b		 je	 SHORT $LN146@long_forma
  00d36	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00d3e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d41	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00d47	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv464[rsp], rax
  00d4f	eb 19		 jmp	 SHORT $LN147@long_forma
$LN146@long_forma:
  00d51	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00d59	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d5c	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00d62	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv464[rsp], rax
$LN147@long_forma:
  00d6a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR tv464[rsp]
  00d72	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv473[rsp], rax
  00d7a	eb 4b		 jmp	 SHORT $LN150@long_forma
$LN149@long_forma:
  00d7c	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00d84	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d87	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00d8f	75 1c		 jne	 SHORT $LN148@long_forma
  00d91	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  00d97	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00d9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  00da5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00dab	33 c0		 xor	 eax, eax
$LN148@long_forma:
  00dad	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00db5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00db8	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00dbf	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv473[rsp], rax
$LN150@long_forma:
  00dc7	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  00dcf	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00dd3	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv473[rsp]
  00ddb	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00ddf	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sz$[rsp]
  00de4	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00de8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$21861[rsp], rax
  00df0	e9 50 01 00 00	 jmp	 $LN41@long_forma
$LN42@long_forma:
  00df5	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00dfa	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00dfe	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00e04	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00e09	85 c0		 test	 eax, eax
  00e0b	75 1c		 jne	 SHORT $LN151@long_forma
  00e0d	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  00e13	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00e1a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00e21	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e27	33 c0		 xor	 eax, eax
$LN151@long_forma:
  00e29	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00e2e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00e31	c1 e8 05	 shr	 eax, 5
  00e34	83 e0 01	 and	 eax, 1
  00e37	85 c0		 test	 eax, eax
  00e39	0f 84 ae 00 00
	00		 je	 $LN157@long_forma
  00e3f	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00e44	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00e48	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00e4e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00e53	85 c0		 test	 eax, eax
  00e55	75 1c		 jne	 SHORT $LN152@long_forma
  00e57	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  00e5d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00e64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00e6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e71	33 c0		 xor	 eax, eax
$LN152@long_forma:
  00e73	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00e78	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00e7b	c1 e8 07	 shr	 eax, 7
  00e7e	83 e0 01	 and	 eax, 1
  00e81	85 c0		 test	 eax, eax
  00e83	75 1c		 jne	 SHORT $LN153@long_forma
  00e85	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  00e8b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00e92	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00e99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e9f	33 c0		 xor	 eax, eax
$LN153@long_forma:
  00ea1	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00ea6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00ea9	c1 e8 06	 shr	 eax, 6
  00eac	83 e0 01	 and	 eax, 1
  00eaf	85 c0		 test	 eax, eax
  00eb1	74 15		 je	 SHORT $LN154@long_forma
  00eb3	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00eb8	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00ebe	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv512[rsp], rax
  00ec6	eb 13		 jmp	 SHORT $LN155@long_forma
$LN154@long_forma:
  00ec8	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00ecd	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00ed3	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv512[rsp], rax
$LN155@long_forma:
  00edb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR tv512[rsp]
  00ee3	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv521[rsp], rax
  00eeb	eb 3f		 jmp	 SHORT $LN158@long_forma
$LN157@long_forma:
  00eed	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00ef2	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00efa	75 1c		 jne	 SHORT $LN156@long_forma
  00efc	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  00f02	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00f09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
  00f10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00f16	33 c0		 xor	 eax, eax
$LN156@long_forma:
  00f18	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  00f1d	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00f24	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv521[rsp], rax
$LN158@long_forma:
  00f2c	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR tv521[rsp]
  00f34	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sz$[rsp]
  00f39	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00f3d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$21861[rsp], rax
$LN41@long_forma:
  00f45	48 83 7c 24 40
	00		 cmp	 QWORD PTR size_a$[rsp], 0
  00f4b	75 29		 jne	 SHORT $LN40@long_forma
  00f4d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$21861[rsp]
  00f55	48 83 e8 02	 sub	 rax, 2
  00f59	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$21861[rsp], rax
  00f61	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00f66	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$21861[rsp]
  00f6e	66 89 01	 mov	 WORD PTR [rcx], ax
  00f71	e9 f5 01 00 00	 jmp	 $LN39@long_forma
$LN40@long_forma:
  00f76	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR accum$21901[rsp], 0
  00f82	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR accumbits$21902[rsp], 0
  00f8d	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$21903[rsp], 0
  00f99	eb 13		 jmp	 SHORT $LN38@long_forma
$LN37@long_forma:
  00f9b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR i$21903[rsp]
  00fa3	48 ff c0	 inc	 rax
  00fa6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR i$21903[rsp], rax
$LN38@long_forma:
  00fae	48 8b 44 24 40	 mov	 rax, QWORD PTR size_a$[rsp]
  00fb3	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR i$21903[rsp], rax
  00fbb	0f 8d aa 01 00
	00		 jge	 $LN36@long_forma
  00fc1	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00fc6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR i$21903[rsp]
  00fce	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  00fd2	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR accumbits$21902[rsp]
  00fd9	48 d3 e0	 shl	 rax, cl
  00fdc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR accum$21901[rsp]
  00fe4	48 0b c8	 or	 rcx, rax
  00fe7	48 8b c1	 mov	 rax, rcx
  00fea	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR accum$21901[rsp], rax
  00ff2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR accumbits$21902[rsp]
  00ff9	83 c0 1e	 add	 eax, 30
  00ffc	89 84 24 90 00
	00 00		 mov	 DWORD PTR accumbits$21902[rsp], eax
  01003	8b 44 24 38	 mov	 eax, DWORD PTR bits$[rsp]
  01007	39 84 24 90 00
	00 00		 cmp	 DWORD PTR accumbits$21902[rsp], eax
  0100e	7d 1c		 jge	 SHORT $LN159@long_forma
  01010	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  01016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0101d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@HAAJLKOA@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAi?$AAt?$AAs?$AA?$AA@
  01024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0102a	33 c0		 xor	 eax, eax
$LN159@long_forma:
$LN35@long_forma:
  0102c	8b 84 24 08 02
	00 00		 mov	 eax, DWORD PTR base$[rsp]
  01033	ff c8		 dec	 eax
  01035	48 98		 cdqe
  01037	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR accum$21901[rsp]
  0103f	48 23 c8	 and	 rcx, rax
  01042	48 8b c1	 mov	 rax, rcx
  01045	88 84 24 a0 00
	00 00		 mov	 BYTE PTR cdigit$21912[rsp], al
  0104c	0f be 84 24 a0
	00 00 00	 movsx	 eax, BYTE PTR cdigit$21912[rsp]
  01054	83 f8 0a	 cmp	 eax, 10
  01057	7d 0d		 jge	 SHORT $LN160@long_forma
  01059	c7 84 24 70 01
	00 00 30 00 00
	00		 mov	 DWORD PTR tv546[rsp], 48 ; 00000030H
  01064	eb 0b		 jmp	 SHORT $LN161@long_forma
$LN160@long_forma:
  01066	c7 84 24 70 01
	00 00 57 00 00
	00		 mov	 DWORD PTR tv546[rsp], 87 ; 00000057H
$LN161@long_forma:
  01071	0f be 84 24 a0
	00 00 00	 movsx	 eax, BYTE PTR cdigit$21912[rsp]
  01079	03 84 24 70 01
	00 00		 add	 eax, DWORD PTR tv546[rsp]
  01080	88 84 24 a0 00
	00 00		 mov	 BYTE PTR cdigit$21912[rsp], al
  01087	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$21861[rsp]
  0108f	48 83 e8 02	 sub	 rax, 2
  01093	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$21861[rsp], rax
  0109b	66 0f be 84 24
	a0 00 00 00	 movsx	 ax, BYTE PTR cdigit$21912[rsp]
  010a4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$21861[rsp]
  010ac	66 89 01	 mov	 WORD PTR [rcx], ax
  010af	8b 44 24 38	 mov	 eax, DWORD PTR bits$[rsp]
  010b3	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR accumbits$21902[rsp]
  010ba	2b c8		 sub	 ecx, eax
  010bc	8b c1		 mov	 eax, ecx
  010be	89 84 24 90 00
	00 00		 mov	 DWORD PTR accumbits$21902[rsp], eax
  010c5	48 63 44 24 38	 movsxd	 rax, DWORD PTR bits$[rsp]
  010ca	0f b6 c8	 movzx	 ecx, al
  010cd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR accum$21901[rsp]
  010d5	48 d3 e8	 shr	 rax, cl
  010d8	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR accum$21901[rsp], rax
  010e0	48 8b 44 24 40	 mov	 rax, QWORD PTR size_a$[rsp]
  010e5	48 ff c8	 dec	 rax
  010e8	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR i$21903[rsp], rax
  010f0	7d 35		 jge	 SHORT $LN166@long_forma
  010f2	8b 44 24 38	 mov	 eax, DWORD PTR bits$[rsp]
  010f6	39 84 24 90 00
	00 00		 cmp	 DWORD PTR accumbits$21902[rsp], eax
  010fd	7c 0d		 jl	 SHORT $LN164@long_forma
  010ff	c7 84 24 74 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv560[rsp], 1
  0110a	eb 0b		 jmp	 SHORT $LN165@long_forma
$LN164@long_forma:
  0110c	c7 84 24 74 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv560[rsp], 0
$LN165@long_forma:
  01117	8b 84 24 74 01
	00 00		 mov	 eax, DWORD PTR tv560[rsp]
  0111e	89 84 24 78 01
	00 00		 mov	 DWORD PTR tv561[rsp], eax
  01125	eb 31		 jmp	 SHORT $LN167@long_forma
$LN166@long_forma:
  01127	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR accum$21901[rsp], 0
  01130	76 0d		 jbe	 SHORT $LN162@long_forma
  01132	c7 84 24 7c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv559[rsp], 1
  0113d	eb 0b		 jmp	 SHORT $LN163@long_forma
$LN162@long_forma:
  0113f	c7 84 24 7c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv559[rsp], 0
$LN163@long_forma:
  0114a	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR tv559[rsp]
  01151	89 84 24 78 01
	00 00		 mov	 DWORD PTR tv561[rsp], eax
$LN167@long_forma:
  01158	83 bc 24 78 01
	00 00 00	 cmp	 DWORD PTR tv561[rsp], 0
  01160	0f 85 c6 fe ff
	ff		 jne	 $LN35@long_forma
  01166	e9 30 fe ff ff	 jmp	 $LN37@long_forma
$LN36@long_forma:
$LN39@long_forma:
  0116b	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR alternate$[rsp], 0
  01173	0f 84 a8 00 00
	00		 je	 $LN32@long_forma
  01179	83 bc 24 08 02
	00 00 10	 cmp	 DWORD PTR base$[rsp], 16
  01181	75 26		 jne	 SHORT $LN31@long_forma
  01183	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$21861[rsp]
  0118b	48 83 e8 02	 sub	 rax, 2
  0118f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$21861[rsp], rax
  01197	b8 78 00 00 00	 mov	 eax, 120		; 00000078H
  0119c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$21861[rsp]
  011a4	66 89 01	 mov	 WORD PTR [rcx], ax
  011a7	eb 54		 jmp	 SHORT $LN30@long_forma
$LN31@long_forma:
  011a9	83 bc 24 08 02
	00 00 08	 cmp	 DWORD PTR base$[rsp], 8
  011b1	75 26		 jne	 SHORT $LN29@long_forma
  011b3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$21861[rsp]
  011bb	48 83 e8 02	 sub	 rax, 2
  011bf	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$21861[rsp], rax
  011c7	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  011cc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$21861[rsp]
  011d4	66 89 01	 mov	 WORD PTR [rcx], ax
  011d7	eb 24		 jmp	 SHORT $LN28@long_forma
$LN29@long_forma:
  011d9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$21861[rsp]
  011e1	48 83 e8 02	 sub	 rax, 2
  011e5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$21861[rsp], rax
  011ed	b8 62 00 00 00	 mov	 eax, 98			; 00000062H
  011f2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$21861[rsp]
  011fa	66 89 01	 mov	 WORD PTR [rcx], ax
$LN28@long_forma:
$LN30@long_forma:
  011fd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$21861[rsp]
  01205	48 83 e8 02	 sub	 rax, 2
  01209	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$21861[rsp], rax
  01211	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  01216	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$21861[rsp]
  0121e	66 89 01	 mov	 WORD PTR [rcx], ax
$LN32@long_forma:
  01221	83 7c 24 20 00	 cmp	 DWORD PTR negative$[rsp], 0
  01226	74 24		 je	 SHORT $LN27@long_forma
  01228	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$21861[rsp]
  01230	48 83 e8 02	 sub	 rax, 2
  01234	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$21861[rsp], rax
  0123c	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  01241	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$21861[rsp]
  01249	66 89 01	 mov	 WORD PTR [rcx], ax
$LN27@long_forma:
  0124c	48 83 bc 24 20
	02 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  01255	0f 84 b0 01 00
	00		 je	 $LN26@long_forma
  0125b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01263	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01266	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0126a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01270	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01275	85 c0		 test	 eax, eax
  01277	75 1c		 jne	 SHORT $LN168@long_forma
  01279	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  0127f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  0128d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01293	33 c0		 xor	 eax, eax
$LN168@long_forma:
  01295	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0129d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  012a0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  012a3	c1 e8 05	 shr	 eax, 5
  012a6	83 e0 01	 and	 eax, 1
  012a9	85 c0		 test	 eax, eax
  012ab	0f 84 cc 00 00
	00		 je	 $LN174@long_forma
  012b1	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  012b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  012bc	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  012c0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  012c6	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  012cb	85 c0		 test	 eax, eax
  012cd	75 1c		 jne	 SHORT $LN169@long_forma
  012cf	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  012d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  012dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  012e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  012e9	33 c0		 xor	 eax, eax
$LN169@long_forma:
  012eb	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  012f3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  012f6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  012f9	c1 e8 07	 shr	 eax, 7
  012fc	83 e0 01	 and	 eax, 1
  012ff	85 c0		 test	 eax, eax
  01301	75 1c		 jne	 SHORT $LN170@long_forma
  01303	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  01309	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01310	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  01317	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0131d	33 c0		 xor	 eax, eax
$LN170@long_forma:
  0131f	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01327	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0132a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0132d	c1 e8 06	 shr	 eax, 6
  01330	83 e0 01	 and	 eax, 1
  01333	85 c0		 test	 eax, eax
  01335	74 1b		 je	 SHORT $LN171@long_forma
  01337	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0133f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01342	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01348	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv606[rsp], rax
  01350	eb 19		 jmp	 SHORT $LN172@long_forma
$LN171@long_forma:
  01352	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0135a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0135d	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01363	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv606[rsp], rax
$LN172@long_forma:
  0136b	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR tv606[rsp]
  01373	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv615[rsp], rax
  0137b	eb 4b		 jmp	 SHORT $LN175@long_forma
$LN174@long_forma:
  0137d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01385	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01388	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01390	75 1c		 jne	 SHORT $LN173@long_forma
  01392	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  01398	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0139f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  013a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  013ac	33 c0		 xor	 eax, eax
$LN173@long_forma:
  013ae	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  013b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  013b9	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  013c0	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv615[rsp], rax
$LN175@long_forma:
  013c8	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  013d0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  013d4	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR tv615[rsp]
  013dc	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  013e0	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR p$21861[rsp], rax
  013e8	74 1c		 je	 SHORT $LN176@long_forma
  013ea	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  013f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  013f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HM@NOGJJOMH@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@
  013fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01404	33 c0		 xor	 eax, eax
$LN176@long_forma:
  01406	e9 65 01 00 00	 jmp	 $LN25@long_forma
$LN26@long_forma:
  0140b	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01410	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01414	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0141a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0141f	85 c0		 test	 eax, eax
  01421	75 1c		 jne	 SHORT $LN177@long_forma
  01423	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  01429	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01430	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  01437	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0143d	33 c0		 xor	 eax, eax
$LN177@long_forma:
  0143f	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01444	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01447	c1 e8 05	 shr	 eax, 5
  0144a	83 e0 01	 and	 eax, 1
  0144d	85 c0		 test	 eax, eax
  0144f	0f 84 ae 00 00
	00		 je	 $LN183@long_forma
  01455	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  0145a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0145e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01464	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01469	85 c0		 test	 eax, eax
  0146b	75 1c		 jne	 SHORT $LN178@long_forma
  0146d	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  01473	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0147a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  01481	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01487	33 c0		 xor	 eax, eax
$LN178@long_forma:
  01489	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  0148e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01491	c1 e8 07	 shr	 eax, 7
  01494	83 e0 01	 and	 eax, 1
  01497	85 c0		 test	 eax, eax
  01499	75 1c		 jne	 SHORT $LN179@long_forma
  0149b	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  014a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  014a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  014af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  014b5	33 c0		 xor	 eax, eax
$LN179@long_forma:
  014b7	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  014bc	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  014bf	c1 e8 06	 shr	 eax, 6
  014c2	83 e0 01	 and	 eax, 1
  014c5	85 c0		 test	 eax, eax
  014c7	74 15		 je	 SHORT $LN180@long_forma
  014c9	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  014ce	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  014d4	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv657[rsp], rax
  014dc	eb 13		 jmp	 SHORT $LN181@long_forma
$LN180@long_forma:
  014de	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  014e3	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  014e9	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv657[rsp], rax
$LN181@long_forma:
  014f1	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR tv657[rsp]
  014f9	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv666[rsp], rax
  01501	eb 3f		 jmp	 SHORT $LN184@long_forma
$LN183@long_forma:
  01503	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01508	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01510	75 1c		 jne	 SHORT $LN182@long_forma
  01512	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  01518	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0151f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
  01526	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0152c	33 c0		 xor	 eax, eax
$LN182@long_forma:
  0152e	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01533	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0153a	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv666[rsp], rax
$LN184@long_forma:
  01542	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR tv666[rsp]
  0154a	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR p$21861[rsp], rax
  01552	74 1c		 je	 SHORT $LN185@long_forma
  01554	41 b8 4e 07 00
	00		 mov	 r8d, 1870		; 0000074eH
  0155a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01561	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@ECAMFMGK@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA2?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@
  01568	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0156e	33 c0		 xor	 eax, eax
$LN185@long_forma:
$LN25@long_forma:
  01570	33 c0		 xor	 eax, eax
  01572	85 c0		 test	 eax, eax
  01574	0f 85 d1 f6 ff
	ff		 jne	 $LN45@long_forma

; 1871 :     }
; 1872 :     else {

  0157a	e9 44 09 00 00	 jmp	 $LN24@long_forma
$LN46@long_forma:

; 1873 :         Py_UCS4 *p;
; 1874 :         assert (kind == PyUnicode_4BYTE_KIND);

  0157f	83 7c 24 24 04	 cmp	 DWORD PTR kind$[rsp], 4
  01584	74 1c		 je	 SHORT $LN186@long_forma
  01586	41 b8 52 07 00
	00		 mov	 r8d, 1874		; 00000752H
  0158c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01593	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@MKLBCJPK@?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AA4?$AAB?$AAY?$AAT?$AAE?$AA_?$AAK?$AAI?$AAN?$AAD?$AA?$AA@
  0159a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  015a0	33 c0		 xor	 eax, eax
$LN186@long_forma:
$LN23@long_forma:

; 1875 :         WRITE_DIGITS(Py_UCS4);

  015a2	48 83 bc 24 20
	02 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  015ab	0f 84 9b 01 00
	00		 je	 $LN20@long_forma
  015b1	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  015b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  015bc	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  015c0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  015c6	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  015cb	85 c0		 test	 eax, eax
  015cd	75 1c		 jne	 SHORT $LN187@long_forma
  015cf	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  015d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  015dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  015e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  015e9	33 c0		 xor	 eax, eax
$LN187@long_forma:
  015eb	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  015f3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  015f6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  015f9	c1 e8 05	 shr	 eax, 5
  015fc	83 e0 01	 and	 eax, 1
  015ff	85 c0		 test	 eax, eax
  01601	0f 84 cc 00 00
	00		 je	 $LN193@long_forma
  01607	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0160f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01612	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01616	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0161c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01621	85 c0		 test	 eax, eax
  01623	75 1c		 jne	 SHORT $LN188@long_forma
  01625	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  0162b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01632	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  01639	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0163f	33 c0		 xor	 eax, eax
$LN188@long_forma:
  01641	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01649	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0164c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0164f	c1 e8 07	 shr	 eax, 7
  01652	83 e0 01	 and	 eax, 1
  01655	85 c0		 test	 eax, eax
  01657	75 1c		 jne	 SHORT $LN189@long_forma
  01659	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  0165f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01666	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  0166d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01673	33 c0		 xor	 eax, eax
$LN189@long_forma:
  01675	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0167d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01680	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01683	c1 e8 06	 shr	 eax, 6
  01686	83 e0 01	 and	 eax, 1
  01689	85 c0		 test	 eax, eax
  0168b	74 1b		 je	 SHORT $LN190@long_forma
  0168d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01695	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01698	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0169e	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv712[rsp], rax
  016a6	eb 19		 jmp	 SHORT $LN191@long_forma
$LN190@long_forma:
  016a8	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  016b0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  016b3	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  016b9	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv712[rsp], rax
$LN191@long_forma:
  016c1	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR tv712[rsp]
  016c9	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv721[rsp], rax
  016d1	eb 4b		 jmp	 SHORT $LN194@long_forma
$LN193@long_forma:
  016d3	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  016db	48 8b 00	 mov	 rax, QWORD PTR [rax]
  016de	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  016e6	75 1c		 jne	 SHORT $LN192@long_forma
  016e8	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  016ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  016f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  016fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01702	33 c0		 xor	 eax, eax
$LN192@long_forma:
  01704	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  0170c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0170f	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01716	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv721[rsp], rax
$LN194@long_forma:
  0171e	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01726	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0172a	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv721[rsp]
  01732	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  01736	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sz$[rsp]
  0173b	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0173f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21958[rsp], rax
  01747	e9 50 01 00 00	 jmp	 $LN19@long_forma
$LN20@long_forma:
  0174c	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01751	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01755	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0175b	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01760	85 c0		 test	 eax, eax
  01762	75 1c		 jne	 SHORT $LN195@long_forma
  01764	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  0176a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01771	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  01778	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0177e	33 c0		 xor	 eax, eax
$LN195@long_forma:
  01780	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01785	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01788	c1 e8 05	 shr	 eax, 5
  0178b	83 e0 01	 and	 eax, 1
  0178e	85 c0		 test	 eax, eax
  01790	0f 84 ae 00 00
	00		 je	 $LN201@long_forma
  01796	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  0179b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0179f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  017a5	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  017aa	85 c0		 test	 eax, eax
  017ac	75 1c		 jne	 SHORT $LN196@long_forma
  017ae	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  017b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  017bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  017c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  017c8	33 c0		 xor	 eax, eax
$LN196@long_forma:
  017ca	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  017cf	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  017d2	c1 e8 07	 shr	 eax, 7
  017d5	83 e0 01	 and	 eax, 1
  017d8	85 c0		 test	 eax, eax
  017da	75 1c		 jne	 SHORT $LN197@long_forma
  017dc	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  017e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  017e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  017f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  017f6	33 c0		 xor	 eax, eax
$LN197@long_forma:
  017f8	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  017fd	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01800	c1 e8 06	 shr	 eax, 6
  01803	83 e0 01	 and	 eax, 1
  01806	85 c0		 test	 eax, eax
  01808	74 15		 je	 SHORT $LN198@long_forma
  0180a	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  0180f	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01815	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv760[rsp], rax
  0181d	eb 13		 jmp	 SHORT $LN199@long_forma
$LN198@long_forma:
  0181f	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01824	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0182a	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv760[rsp], rax
$LN199@long_forma:
  01832	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR tv760[rsp]
  0183a	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv769[rsp], rax
  01842	eb 3f		 jmp	 SHORT $LN202@long_forma
$LN201@long_forma:
  01844	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01849	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01851	75 1c		 jne	 SHORT $LN200@long_forma
  01853	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01859	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01860	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
  01867	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0186d	33 c0		 xor	 eax, eax
$LN200@long_forma:
  0186f	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01874	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0187b	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv769[rsp], rax
$LN202@long_forma:
  01883	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR tv769[rsp]
  0188b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sz$[rsp]
  01890	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  01894	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21958[rsp], rax
$LN19@long_forma:
  0189c	48 83 7c 24 40
	00		 cmp	 QWORD PTR size_a$[rsp], 0
  018a2	75 27		 jne	 SHORT $LN18@long_forma
  018a4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  018ac	48 83 e8 04	 sub	 rax, 4
  018b0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21958[rsp], rax
  018b8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  018c0	c7 00 30 00 00
	00		 mov	 DWORD PTR [rax], 48	; 00000030H
  018c6	e9 f3 01 00 00	 jmp	 $LN17@long_forma
$LN18@long_forma:
  018cb	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR accum$21999[rsp], 0
  018d7	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR accumbits$22000[rsp], 0
  018e2	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$22001[rsp], 0
  018ee	eb 13		 jmp	 SHORT $LN16@long_forma
$LN15@long_forma:
  018f0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i$22001[rsp]
  018f8	48 ff c0	 inc	 rax
  018fb	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR i$22001[rsp], rax
$LN16@long_forma:
  01903	48 8b 44 24 40	 mov	 rax, QWORD PTR size_a$[rsp]
  01908	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR i$22001[rsp], rax
  01910	0f 8d a8 01 00
	00		 jge	 $LN14@long_forma
  01916	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0191b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR i$22001[rsp]
  01923	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  01927	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR accumbits$22000[rsp]
  0192e	48 d3 e0	 shl	 rax, cl
  01931	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR accum$21999[rsp]
  01939	48 0b c8	 or	 rcx, rax
  0193c	48 8b c1	 mov	 rax, rcx
  0193f	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR accum$21999[rsp], rax
  01947	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR accumbits$22000[rsp]
  0194e	83 c0 1e	 add	 eax, 30
  01951	89 84 24 b8 00
	00 00		 mov	 DWORD PTR accumbits$22000[rsp], eax
  01958	8b 44 24 38	 mov	 eax, DWORD PTR bits$[rsp]
  0195c	39 84 24 b8 00
	00 00		 cmp	 DWORD PTR accumbits$22000[rsp], eax
  01963	7d 1c		 jge	 SHORT $LN203@long_forma
  01965	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  0196b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01972	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@HAAJLKOA@?$AAa?$AAc?$AAc?$AAu?$AAm?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAi?$AAt?$AAs?$AA?$AA@
  01979	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0197f	33 c0		 xor	 eax, eax
$LN203@long_forma:
$LN13@long_forma:
  01981	8b 84 24 08 02
	00 00		 mov	 eax, DWORD PTR base$[rsp]
  01988	ff c8		 dec	 eax
  0198a	48 98		 cdqe
  0198c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR accum$21999[rsp]
  01994	48 23 c8	 and	 rcx, rax
  01997	48 8b c1	 mov	 rax, rcx
  0199a	88 84 24 c8 00
	00 00		 mov	 BYTE PTR cdigit$22010[rsp], al
  019a1	0f be 84 24 c8
	00 00 00	 movsx	 eax, BYTE PTR cdigit$22010[rsp]
  019a9	83 f8 0a	 cmp	 eax, 10
  019ac	7d 0d		 jge	 SHORT $LN204@long_forma
  019ae	c7 84 24 c0 01
	00 00 30 00 00
	00		 mov	 DWORD PTR tv794[rsp], 48 ; 00000030H
  019b9	eb 0b		 jmp	 SHORT $LN205@long_forma
$LN204@long_forma:
  019bb	c7 84 24 c0 01
	00 00 57 00 00
	00		 mov	 DWORD PTR tv794[rsp], 87 ; 00000057H
$LN205@long_forma:
  019c6	0f be 84 24 c8
	00 00 00	 movsx	 eax, BYTE PTR cdigit$22010[rsp]
  019ce	03 84 24 c0 01
	00 00		 add	 eax, DWORD PTR tv794[rsp]
  019d5	88 84 24 c8 00
	00 00		 mov	 BYTE PTR cdigit$22010[rsp], al
  019dc	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  019e4	48 83 e8 04	 sub	 rax, 4
  019e8	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21958[rsp], rax
  019f0	0f be 84 24 c8
	00 00 00	 movsx	 eax, BYTE PTR cdigit$22010[rsp]
  019f8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR p$21958[rsp]
  01a00	89 01		 mov	 DWORD PTR [rcx], eax
  01a02	8b 44 24 38	 mov	 eax, DWORD PTR bits$[rsp]
  01a06	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR accumbits$22000[rsp]
  01a0d	2b c8		 sub	 ecx, eax
  01a0f	8b c1		 mov	 eax, ecx
  01a11	89 84 24 b8 00
	00 00		 mov	 DWORD PTR accumbits$22000[rsp], eax
  01a18	48 63 44 24 38	 movsxd	 rax, DWORD PTR bits$[rsp]
  01a1d	0f b6 c8	 movzx	 ecx, al
  01a20	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR accum$21999[rsp]
  01a28	48 d3 e8	 shr	 rax, cl
  01a2b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR accum$21999[rsp], rax
  01a33	48 8b 44 24 40	 mov	 rax, QWORD PTR size_a$[rsp]
  01a38	48 ff c8	 dec	 rax
  01a3b	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR i$22001[rsp], rax
  01a43	7d 35		 jge	 SHORT $LN210@long_forma
  01a45	8b 44 24 38	 mov	 eax, DWORD PTR bits$[rsp]
  01a49	39 84 24 b8 00
	00 00		 cmp	 DWORD PTR accumbits$22000[rsp], eax
  01a50	7c 0d		 jl	 SHORT $LN208@long_forma
  01a52	c7 84 24 c4 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv808[rsp], 1
  01a5d	eb 0b		 jmp	 SHORT $LN209@long_forma
$LN208@long_forma:
  01a5f	c7 84 24 c4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv808[rsp], 0
$LN209@long_forma:
  01a6a	8b 84 24 c4 01
	00 00		 mov	 eax, DWORD PTR tv808[rsp]
  01a71	89 84 24 c8 01
	00 00		 mov	 DWORD PTR tv809[rsp], eax
  01a78	eb 31		 jmp	 SHORT $LN211@long_forma
$LN210@long_forma:
  01a7a	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR accum$21999[rsp], 0
  01a83	76 0d		 jbe	 SHORT $LN206@long_forma
  01a85	c7 84 24 cc 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv807[rsp], 1
  01a90	eb 0b		 jmp	 SHORT $LN207@long_forma
$LN206@long_forma:
  01a92	c7 84 24 cc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv807[rsp], 0
$LN207@long_forma:
  01a9d	8b 84 24 cc 01
	00 00		 mov	 eax, DWORD PTR tv807[rsp]
  01aa4	89 84 24 c8 01
	00 00		 mov	 DWORD PTR tv809[rsp], eax
$LN211@long_forma:
  01aab	83 bc 24 c8 01
	00 00 00	 cmp	 DWORD PTR tv809[rsp], 0
  01ab3	0f 85 c8 fe ff
	ff		 jne	 $LN13@long_forma
  01ab9	e9 32 fe ff ff	 jmp	 $LN15@long_forma
$LN14@long_forma:
$LN17@long_forma:
  01abe	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR alternate$[rsp], 0
  01ac6	0f 84 a0 00 00
	00		 je	 $LN10@long_forma
  01acc	83 bc 24 08 02
	00 00 10	 cmp	 DWORD PTR base$[rsp], 16
  01ad4	75 24		 jne	 SHORT $LN9@long_forma
  01ad6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  01ade	48 83 e8 04	 sub	 rax, 4
  01ae2	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21958[rsp], rax
  01aea	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  01af2	c7 00 78 00 00
	00		 mov	 DWORD PTR [rax], 120	; 00000078H
  01af8	eb 50		 jmp	 SHORT $LN8@long_forma
$LN9@long_forma:
  01afa	83 bc 24 08 02
	00 00 08	 cmp	 DWORD PTR base$[rsp], 8
  01b02	75 24		 jne	 SHORT $LN7@long_forma
  01b04	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  01b0c	48 83 e8 04	 sub	 rax, 4
  01b10	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21958[rsp], rax
  01b18	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  01b20	c7 00 6f 00 00
	00		 mov	 DWORD PTR [rax], 111	; 0000006fH
  01b26	eb 22		 jmp	 SHORT $LN6@long_forma
$LN7@long_forma:
  01b28	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  01b30	48 83 e8 04	 sub	 rax, 4
  01b34	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21958[rsp], rax
  01b3c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  01b44	c7 00 62 00 00
	00		 mov	 DWORD PTR [rax], 98	; 00000062H
$LN6@long_forma:
$LN8@long_forma:
  01b4a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  01b52	48 83 e8 04	 sub	 rax, 4
  01b56	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21958[rsp], rax
  01b5e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  01b66	c7 00 30 00 00
	00		 mov	 DWORD PTR [rax], 48	; 00000030H
$LN10@long_forma:
  01b6c	83 7c 24 20 00	 cmp	 DWORD PTR negative$[rsp], 0
  01b71	74 22		 je	 SHORT $LN5@long_forma
  01b73	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  01b7b	48 83 e8 04	 sub	 rax, 4
  01b7f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$21958[rsp], rax
  01b87	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$21958[rsp]
  01b8f	c7 00 2d 00 00
	00		 mov	 DWORD PTR [rax], 45	; 0000002dH
$LN5@long_forma:
  01b95	48 83 bc 24 20
	02 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  01b9e	0f 84 b0 01 00
	00		 je	 $LN4@long_forma
  01ba4	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01bac	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01baf	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01bb3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01bb9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01bbe	85 c0		 test	 eax, eax
  01bc0	75 1c		 jne	 SHORT $LN212@long_forma
  01bc2	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01bc8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01bcf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  01bd6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01bdc	33 c0		 xor	 eax, eax
$LN212@long_forma:
  01bde	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01be6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01be9	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01bec	c1 e8 05	 shr	 eax, 5
  01bef	83 e0 01	 and	 eax, 1
  01bf2	85 c0		 test	 eax, eax
  01bf4	0f 84 cc 00 00
	00		 je	 $LN218@long_forma
  01bfa	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01c02	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01c05	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01c09	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01c0f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01c14	85 c0		 test	 eax, eax
  01c16	75 1c		 jne	 SHORT $LN213@long_forma
  01c18	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01c1e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01c25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@NPPKNACA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  01c2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01c32	33 c0		 xor	 eax, eax
$LN213@long_forma:
  01c34	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01c3c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01c3f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01c42	c1 e8 07	 shr	 eax, 7
  01c45	83 e0 01	 and	 eax, 1
  01c48	85 c0		 test	 eax, eax
  01c4a	75 1c		 jne	 SHORT $LN214@long_forma
  01c4c	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01c52	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01c59	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PPKNGJHM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf?$AAe@
  01c60	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01c66	33 c0		 xor	 eax, eax
$LN214@long_forma:
  01c68	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01c70	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01c73	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01c76	c1 e8 06	 shr	 eax, 6
  01c79	83 e0 01	 and	 eax, 1
  01c7c	85 c0		 test	 eax, eax
  01c7e	74 1b		 je	 SHORT $LN215@long_forma
  01c80	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01c88	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01c8b	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01c91	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv854[rsp], rax
  01c99	eb 19		 jmp	 SHORT $LN216@long_forma
$LN215@long_forma:
  01c9b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01ca3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01ca6	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01cac	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv854[rsp], rax
$LN216@long_forma:
  01cb4	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR tv854[rsp]
  01cbc	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR tv863[rsp], rax
  01cc4	eb 4b		 jmp	 SHORT $LN219@long_forma
$LN218@long_forma:
  01cc6	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01cce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01cd1	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01cd9	75 1c		 jne	 SHORT $LN217@long_forma
  01cdb	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01ce1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01ce8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@LMCAFPPO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AAr?$AAi?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAf@
  01cef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01cf5	33 c0		 xor	 eax, eax
$LN217@long_forma:
  01cf7	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01cff	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01d02	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01d09	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR tv863[rsp], rax
$LN219@long_forma:
  01d11	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01d19	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  01d1d	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR tv863[rsp]
  01d25	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  01d29	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR p$21958[rsp], rax
  01d31	74 1c		 je	 SHORT $LN220@long_forma
  01d33	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01d39	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01d40	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HM@HLIFOHHE@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAw@
  01d47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01d4d	33 c0		 xor	 eax, eax
$LN220@long_forma:
  01d4f	e9 65 01 00 00	 jmp	 $LN3@long_forma
$LN4@long_forma:
  01d54	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01d59	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01d5d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01d63	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01d68	85 c0		 test	 eax, eax
  01d6a	75 1c		 jne	 SHORT $LN221@long_forma
  01d6c	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01d72	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01d79	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  01d80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01d86	33 c0		 xor	 eax, eax
$LN221@long_forma:
  01d88	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01d8d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01d90	c1 e8 05	 shr	 eax, 5
  01d93	83 e0 01	 and	 eax, 1
  01d96	85 c0		 test	 eax, eax
  01d98	0f 84 ae 00 00
	00		 je	 $LN227@long_forma
  01d9e	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01da3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01da7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01dad	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01db2	85 c0		 test	 eax, eax
  01db4	75 1c		 jne	 SHORT $LN222@long_forma
  01db6	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01dbc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01dc3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JKDPOBNB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  01dca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01dd0	33 c0		 xor	 eax, eax
$LN222@long_forma:
  01dd2	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01dd7	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01dda	c1 e8 07	 shr	 eax, 7
  01ddd	83 e0 01	 and	 eax, 1
  01de0	85 c0		 test	 eax, eax
  01de2	75 1c		 jne	 SHORT $LN223@long_forma
  01de4	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01dea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01df1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DOFIPJKJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  01df8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01dfe	33 c0		 xor	 eax, eax
$LN223@long_forma:
  01e00	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01e05	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01e08	c1 e8 06	 shr	 eax, 6
  01e0b	83 e0 01	 and	 eax, 1
  01e0e	85 c0		 test	 eax, eax
  01e10	74 15		 je	 SHORT $LN224@long_forma
  01e12	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01e17	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01e1d	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv905[rsp], rax
  01e25	eb 13		 jmp	 SHORT $LN225@long_forma
$LN224@long_forma:
  01e27	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01e2c	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01e32	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv905[rsp], rax
$LN225@long_forma:
  01e3a	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR tv905[rsp]
  01e42	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv914[rsp], rax
  01e4a	eb 3f		 jmp	 SHORT $LN228@long_forma
$LN227@long_forma:
  01e4c	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01e51	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01e59	75 1c		 jne	 SHORT $LN226@long_forma
  01e5b	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01e61	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01e68	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@ONKOANJK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAv?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
  01e6f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01e75	33 c0		 xor	 eax, eax
$LN226@long_forma:
  01e77	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
  01e7c	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01e83	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv914[rsp], rax
$LN228@long_forma:
  01e8b	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR tv914[rsp]
  01e93	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR p$21958[rsp], rax
  01e9b	74 1c		 je	 SHORT $LN229@long_forma
  01e9d	41 b8 53 07 00
	00		 mov	 r8d, 1875		; 00000753H
  01ea3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01eaa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@DCHLEKIM@?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAU?$AAC?$AAS?$AA4?$AA?$CK?$AA?$CJ?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAD?$AAA?$AAT?$AAA?$AA?$CI?$AAv?$AA?$CJ@
  01eb1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01eb7	33 c0		 xor	 eax, eax
$LN229@long_forma:
$LN3@long_forma:
  01eb9	33 c0		 xor	 eax, eax
  01ebb	85 c0		 test	 eax, eax
  01ebd	0f 85 df f6 ff
	ff		 jne	 $LN23@long_forma
$LN24@long_forma:
$LN47@long_forma:

; 1876 :     }
; 1877 : #undef WRITE_DIGITS
; 1878 : 
; 1879 :     if (writer) {

  01ec3	48 83 bc 24 20
	02 00 00 00	 cmp	 QWORD PTR writer$[rsp], 0
  01ecc	74 1f		 je	 SHORT $LN2@long_forma

; 1880 :         writer->pos += sz;

  01ece	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR writer$[rsp]
  01ed6	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  01eda	48 03 44 24 48	 add	 rax, QWORD PTR sz$[rsp]
  01edf	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR writer$[rsp]
  01ee7	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1881 :     }
; 1882 :     else {

  01eeb	eb 3f		 jmp	 SHORT $LN1@long_forma
$LN2@long_forma:

; 1883 :         assert(_PyUnicode_CheckConsistency(v, 1));

  01eed	ba 01 00 00 00	 mov	 edx, 1
  01ef2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  01ef7	e8 00 00 00 00	 call	 _PyUnicode_CheckConsistency
  01efc	85 c0		 test	 eax, eax
  01efe	75 1c		 jne	 SHORT $LN230@long_forma
  01f00	41 b8 5b 07 00
	00		 mov	 r8d, 1883		; 0000075bH
  01f06	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  01f0d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@OGFJKBIM@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAv?$AA?0?$AA?5?$AA1@
  01f14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01f1a	33 c0		 xor	 eax, eax
$LN230@long_forma:

; 1884 :         *p_output = v;

  01f1c	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR p_output$[rsp]
  01f24	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  01f29	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@long_forma:

; 1885 :     }
; 1886 :     return 0;

  01f2c	33 c0		 xor	 eax, eax
$LN86@long_forma:

; 1887 : }

  01f2e	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  01f35	c3		 ret	 0
long_format_binary ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bits_in_digit DD imagerel bits_in_digit
	DD	imagerel bits_in_digit+77
	DD	imagerel $unwind$bits_in_digit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bits_in_digit DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bits_in_digit
_TEXT	SEGMENT
d_bits$ = 0
d$ = 32
bits_in_digit PROC					; COMDAT

; 1432 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 1433 :     int d_bits = 0;

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR d_bits$[rsp], 0
$LN2@bits_in_di:

; 1434 :     while (d >= 32) {

  0000f	83 7c 24 20 20	 cmp	 DWORD PTR d$[rsp], 32	; 00000020H
  00014	72 16		 jb	 SHORT $LN1@bits_in_di

; 1435 :         d_bits += 6;

  00016	8b 04 24	 mov	 eax, DWORD PTR d_bits$[rsp]
  00019	83 c0 06	 add	 eax, 6
  0001c	89 04 24	 mov	 DWORD PTR d_bits$[rsp], eax

; 1436 :         d >>= 6;

  0001f	8b 44 24 20	 mov	 eax, DWORD PTR d$[rsp]
  00023	c1 e8 06	 shr	 eax, 6
  00026	89 44 24 20	 mov	 DWORD PTR d$[rsp], eax

; 1437 :     }

  0002a	eb e3		 jmp	 SHORT $LN2@bits_in_di
$LN1@bits_in_di:

; 1438 :     d_bits += (int)BitLengthTable[d];

  0002c	8b 44 24 20	 mov	 eax, DWORD PTR d$[rsp]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:BitLengthTable
  00037	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003b	8b 0c 24	 mov	 ecx, DWORD PTR d_bits$[rsp]
  0003e	03 c8		 add	 ecx, eax
  00040	8b c1		 mov	 eax, ecx
  00042	89 04 24	 mov	 DWORD PTR d_bits$[rsp], eax

; 1439 :     return d_bits;

  00045	8b 04 24	 mov	 eax, DWORD PTR d_bits$[rsp]

; 1440 : }

  00048	48 83 c4 18	 add	 rsp, 24
  0004c	c3		 ret	 0
bits_in_digit ENDP
_TEXT	ENDS
PUBLIC	_PyLong_FormatWriter
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_FormatWriter DD imagerel $LN5
	DD	imagerel $LN5+89
	DD	imagerel $unwind$_PyLong_FormatWriter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_FormatWriter DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyLong_FormatWriter
_TEXT	SEGMENT
writer$ = 64
obj$ = 72
base$ = 80
alternate$ = 88
_PyLong_FormatWriter PROC				; COMDAT

; 1907 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1908 :     if (base == 10)

  00018	83 7c 24 50 0a	 cmp	 DWORD PTR base$[rsp], 10
  0001d	75 15		 jne	 SHORT $LN2@PyLong_For@2

; 1909 :         return long_to_decimal_string_internal(obj, NULL, writer);

  0001f	4c 8b 44 24 40	 mov	 r8, QWORD PTR writer$[rsp]
  00024	33 d2		 xor	 edx, edx
  00026	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obj$[rsp]
  0002b	e8 00 00 00 00	 call	 long_to_decimal_string_internal
  00030	eb 22		 jmp	 SHORT $LN3@PyLong_For@2

; 1910 :     else

  00032	eb 20		 jmp	 SHORT $LN1@PyLong_For@2
$LN2@PyLong_For@2:

; 1911 :         return long_format_binary(obj, base, alternate, NULL, writer);

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR writer$[rsp]
  00039	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003e	45 33 c9	 xor	 r9d, r9d
  00041	44 8b 44 24 58	 mov	 r8d, DWORD PTR alternate$[rsp]
  00046	8b 54 24 50	 mov	 edx, DWORD PTR base$[rsp]
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obj$[rsp]
  0004f	e8 00 00 00 00	 call	 long_format_binary
$LN1@PyLong_For@2:
$LN3@PyLong_For@2:

; 1912 : }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
_PyLong_FormatWriter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@ ; `string'
PUBLIC	??_C@_1CK@MHJHNDLK@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAz?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAz?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@CELMPDAK@?$AAc?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@FNLKKNFD@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAz?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BJEMNAAB@?$AAi?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	__real@41d0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0CD@JHJGICHC@int?$CI?$CJ?5arg?52?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?5@ ; `string'
PUBLIC	PyLong_FromString
EXTRN	PyUnicode_FromStringAndSize:PROC
EXTRN	strlen:PROC
EXTRN	memcpy:PROC
EXTRN	log:PROC
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromString DD imagerel $LN76
	DD	imagerel $LN76+2607
	DD	imagerel $unwind$PyLong_FromString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromString DD 021601H
	DD	01d0116H
xdata	ENDS
;	COMDAT ??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@
CONST	SEGMENT
??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@ DB 'inval'
	DB	'id literal for int() with base %d: %R', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@MHJHNDLK@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAz?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAz?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@MHJHNDLK@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAz?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAz?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'(', 00H, 'z', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '_', 00H, 'z', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@CELMPDAK@?$AAc?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@CELMPDAK@?$AAc?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@ DB 'c'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'L', 00H
	DB	'o', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'B', 00H, 'A', 00H, 'S'
	DB	00H, 'E', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FNLKKNFD@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAz?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@FNLKKNFD@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAz?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, '_', 00H, 'z', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BJEMNAAB@?$AAi?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BJEMNAAB@?$AAi?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'i', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT __real@41d0000000000000
CONST	SEGMENT
__real@41d0000000000000 DQ 041d0000000000000r	; 1.07374e+009
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0CD@JHJGICHC@int?$CI?$CJ?5arg?52?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?5@
CONST	SEGMENT
??_C@_0CD@JHJGICHC@int?$CI?$CJ?5arg?52?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?5@ DB 'i'
	DB	'nt() arg 2 must be >= 2 and <= 36', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLong_FromString
_TEXT	SEGMENT
slen$ = 32
orig_str$ = 40
error_if_nonzero$ = 48
start$ = 56
sign$ = 64
strobj$ = 72
z$ = 80
convmult$22191 = 88
i$22188 = 96
pz$22192 = 104
pzstop$22193 = 112
size_z$22187 = 120
scan$22194 = 128
convmultmax$22190 = 136
convwidth$22189 = 144
c$22186 = 152
i$22203 = 160
convmax$22202 = 168
next$22210 = 176
tmp$22260 = 184
tv180 = 192
tv305 = 200
tv350 = 208
str$ = 240
pend$ = 248
base$ = 256
PyLong_FromString PROC					; COMDAT

; 2016 : {

$LN76:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 2017 :     int sign = 1, error_if_nonzero = 0;

  00016	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1
  0001e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR error_if_nonzero$[rsp], 0

; 2018 :     char *start, *orig_str = str;

  00026	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0002e	48 89 44 24 28	 mov	 QWORD PTR orig_str$[rsp], rax

; 2019 :     PyLongObject *z = NULL;

  00033	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR z$[rsp], 0

; 2020 :     PyObject *strobj;
; 2021 :     Py_ssize_t slen;
; 2022 : 
; 2023 :     if ((base != 0 && base < 2) || base > 36) {

  0003c	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR base$[rsp], 0
  00044	74 0a		 je	 SHORT $LN64@PyLong_Fro@11
  00046	83 bc 24 00 01
	00 00 02	 cmp	 DWORD PTR base$[rsp], 2
  0004e	7c 0a		 jl	 SHORT $LN65@PyLong_Fro@11
$LN64@PyLong_Fro@11:
  00050	83 bc 24 00 01
	00 00 24	 cmp	 DWORD PTR base$[rsp], 36 ; 00000024H
  00058	7e 1a		 jle	 SHORT $LN66@PyLong_Fro@11
$LN65@PyLong_Fro@11:

; 2024 :         PyErr_SetString(PyExc_ValueError,
; 2025 :                         "int() arg 2 must be >= 2 and <= 36");

  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@JHJGICHC@int?$CI?$CJ?5arg?52?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?5@
  00061	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00068	e8 00 00 00 00	 call	 PyErr_SetString

; 2026 :         return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	e9 b3 09 00 00	 jmp	 $LN67@PyLong_Fro@11
$LN66@PyLong_Fro@11:
$LN63@PyLong_Fro@11:

; 2027 :     }
; 2028 :     while (*str != '\0' && Py_ISSPACE(Py_CHARMASK(*str)))

  00074	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0007c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0007f	85 c0		 test	 eax, eax
  00081	74 41		 je	 SHORT $LN62@PyLong_Fro@11
  00083	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0008b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	0f b6 c0	 movzx	 eax, al
  00096	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0009b	0f b6 c0	 movzx	 eax, al
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000a5	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000a8	83 e0 08	 and	 eax, 8
  000ab	85 c0		 test	 eax, eax
  000ad	74 15		 je	 SHORT $LN62@PyLong_Fro@11

; 2029 :         str++;

  000af	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  000b7	48 ff c0	 inc	 rax
  000ba	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR str$[rsp], rax
  000c2	eb b0		 jmp	 SHORT $LN63@PyLong_Fro@11
$LN62@PyLong_Fro@11:

; 2030 :     if (*str == '+')

  000c4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  000cc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000cf	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  000d2	75 15		 jne	 SHORT $LN61@PyLong_Fro@11

; 2031 :         ++str;

  000d4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  000dc	48 ff c0	 inc	 rax
  000df	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR str$[rsp], rax
  000e7	eb 2b		 jmp	 SHORT $LN60@PyLong_Fro@11
$LN61@PyLong_Fro@11:

; 2032 :     else if (*str == '-') {

  000e9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  000f1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f4	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000f7	75 1b		 jne	 SHORT $LN59@PyLong_Fro@11

; 2033 :         ++str;

  000f9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00101	48 ff c0	 inc	 rax
  00104	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR str$[rsp], rax

; 2034 :         sign = -1;

  0010c	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR sign$[rsp], -1
$LN59@PyLong_Fro@11:
$LN60@PyLong_Fro@11:

; 2035 :     }
; 2036 :     if (base == 0) {

  00114	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR base$[rsp], 0
  0011c	0f 85 c0 00 00
	00		 jne	 $LN58@PyLong_Fro@11

; 2037 :         if (str[0] != '0')

  00122	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0012a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0012d	83 f8 30	 cmp	 eax, 48			; 00000030H
  00130	74 10		 je	 SHORT $LN57@PyLong_Fro@11

; 2038 :             base = 10;

  00132	c7 84 24 00 01
	00 00 0a 00 00
	00		 mov	 DWORD PTR base$[rsp], 10
  0013d	e9 a0 00 00 00	 jmp	 $LN56@PyLong_Fro@11
$LN57@PyLong_Fro@11:

; 2039 :         else if (str[1] == 'x' || str[1] == 'X')

  00142	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0014a	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0014e	83 f8 78	 cmp	 eax, 120		; 00000078H
  00151	74 11		 je	 SHORT $LN54@PyLong_Fro@11
  00153	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0015b	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0015f	83 f8 58	 cmp	 eax, 88			; 00000058H
  00162	75 0d		 jne	 SHORT $LN55@PyLong_Fro@11
$LN54@PyLong_Fro@11:

; 2040 :             base = 16;

  00164	c7 84 24 00 01
	00 00 10 00 00
	00		 mov	 DWORD PTR base$[rsp], 16
  0016f	eb 71		 jmp	 SHORT $LN53@PyLong_Fro@11
$LN55@PyLong_Fro@11:

; 2041 :         else if (str[1] == 'o' || str[1] == 'O')

  00171	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00179	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0017d	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  00180	74 11		 je	 SHORT $LN51@PyLong_Fro@11
  00182	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0018a	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0018e	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  00191	75 0d		 jne	 SHORT $LN52@PyLong_Fro@11
$LN51@PyLong_Fro@11:

; 2042 :             base = 8;

  00193	c7 84 24 00 01
	00 00 08 00 00
	00		 mov	 DWORD PTR base$[rsp], 8
  0019e	eb 42		 jmp	 SHORT $LN50@PyLong_Fro@11
$LN52@PyLong_Fro@11:

; 2043 :         else if (str[1] == 'b' || str[1] == 'B')

  001a0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  001a8	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  001ac	83 f8 62	 cmp	 eax, 98			; 00000062H
  001af	74 11		 je	 SHORT $LN48@PyLong_Fro@11
  001b1	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  001b9	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  001bd	83 f8 42	 cmp	 eax, 66			; 00000042H
  001c0	75 0d		 jne	 SHORT $LN49@PyLong_Fro@11
$LN48@PyLong_Fro@11:

; 2044 :             base = 2;

  001c2	c7 84 24 00 01
	00 00 02 00 00
	00		 mov	 DWORD PTR base$[rsp], 2

; 2045 :         else {

  001cd	eb 13		 jmp	 SHORT $LN47@PyLong_Fro@11
$LN49@PyLong_Fro@11:

; 2046 :             /* "old" (C-style) octal literal, now invalid.
; 2047 :                it might still be zero though */
; 2048 :             error_if_nonzero = 1;

  001cf	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR error_if_nonzero$[rsp], 1

; 2049 :             base = 10;

  001d7	c7 84 24 00 01
	00 00 0a 00 00
	00		 mov	 DWORD PTR base$[rsp], 10
$LN47@PyLong_Fro@11:
$LN50@PyLong_Fro@11:
$LN53@PyLong_Fro@11:
$LN56@PyLong_Fro@11:
$LN58@PyLong_Fro@11:

; 2050 :         }
; 2051 :     }
; 2052 :     if (str[0] == '0' &&
; 2053 :         ((base == 16 && (str[1] == 'x' || str[1] == 'X')) ||
; 2054 :          (base == 8  && (str[1] == 'o' || str[1] == 'O')) ||
; 2055 :          (base == 2  && (str[1] == 'b' || str[1] == 'B'))))

  001e2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  001ea	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001ed	83 f8 30	 cmp	 eax, 48			; 00000030H
  001f0	0f 85 98 00 00
	00		 jne	 $LN46@PyLong_Fro@11
  001f6	83 bc 24 00 01
	00 00 10	 cmp	 DWORD PTR base$[rsp], 16
  001fe	75 22		 jne	 SHORT $LN44@PyLong_Fro@11
  00200	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00208	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0020c	83 f8 78	 cmp	 eax, 120		; 00000078H
  0020f	74 69		 je	 SHORT $LN45@PyLong_Fro@11
  00211	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00219	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0021d	83 f8 58	 cmp	 eax, 88			; 00000058H
  00220	74 58		 je	 SHORT $LN45@PyLong_Fro@11
$LN44@PyLong_Fro@11:
  00222	83 bc 24 00 01
	00 00 08	 cmp	 DWORD PTR base$[rsp], 8
  0022a	75 22		 jne	 SHORT $LN43@PyLong_Fro@11
  0022c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00234	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00238	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  0023b	74 3d		 je	 SHORT $LN45@PyLong_Fro@11
  0023d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00245	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00249	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  0024c	74 2c		 je	 SHORT $LN45@PyLong_Fro@11
$LN43@PyLong_Fro@11:
  0024e	83 bc 24 00 01
	00 00 02	 cmp	 DWORD PTR base$[rsp], 2
  00256	75 36		 jne	 SHORT $LN46@PyLong_Fro@11
  00258	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00260	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00264	83 f8 62	 cmp	 eax, 98			; 00000062H
  00267	74 11		 je	 SHORT $LN42@PyLong_Fro@11
  00269	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00271	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00275	83 f8 42	 cmp	 eax, 66			; 00000042H
  00278	75 14		 jne	 SHORT $LN46@PyLong_Fro@11
$LN42@PyLong_Fro@11:
$LN45@PyLong_Fro@11:

; 2056 :         str += 2;

  0027a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00282	48 83 c0 02	 add	 rax, 2
  00286	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR str$[rsp], rax
$LN46@PyLong_Fro@11:

; 2057 : 
; 2058 :     start = str;

  0028e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00296	48 89 44 24 38	 mov	 QWORD PTR start$[rsp], rax

; 2059 :     if ((base & (base - 1)) == 0)

  0029b	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR base$[rsp]
  002a2	ff c8		 dec	 eax
  002a4	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR base$[rsp]
  002ab	23 c8		 and	 ecx, eax
  002ad	8b c1		 mov	 eax, ecx
  002af	85 c0		 test	 eax, eax
  002b1	75 1e		 jne	 SHORT $LN41@PyLong_Fro@11

; 2060 :         z = long_from_binary_base(&str, base);

  002b3	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR base$[rsp]
  002ba	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  002c2	e8 00 00 00 00	 call	 long_from_binary_base
  002c7	48 89 44 24 50	 mov	 QWORD PTR z$[rsp], rax

; 2061 :     else {

  002cc	e9 82 05 00 00	 jmp	 $LN40@PyLong_Fro@11
$LN41@PyLong_Fro@11:

; 2062 : /***
; 2063 : Binary bases can be converted in time linear in the number of digits, because
; 2064 : Python's representation base is binary.  Other bases (including decimal!) use
; 2065 : the simple quadratic-time algorithm below, complicated by some speed tricks.
; 2066 : 
; 2067 : First some math:  the largest integer that can be expressed in N base-B digits
; 2068 : is B**N-1.  Consequently, if we have an N-digit input in base B, the worst-
; 2069 : case number of Python digits needed to hold it is the smallest integer n s.t.
; 2070 : 
; 2071 :     BASE**n-1 >= B**N-1  [or, adding 1 to both sides]
; 2072 :     BASE**n >= B**N      [taking logs to base BASE]
; 2073 :     n >= log(B**N)/log(BASE) = N * log(B)/log(BASE)
; 2074 : 
; 2075 : The static array log_base_BASE[base] == log(base)/log(BASE) so we can compute
; 2076 : this quickly.  A Python int with that much space is reserved near the start,
; 2077 : and the result is computed into it.
; 2078 : 
; 2079 : The input string is actually treated as being in base base**i (i.e., i digits
; 2080 : are processed at a time), where two more static arrays hold:
; 2081 : 
; 2082 :     convwidth_base[base] = the largest integer i such that base**i <= BASE
; 2083 :     convmultmax_base[base] = base ** convwidth_base[base]
; 2084 : 
; 2085 : The first of these is the largest i such that i consecutive input digits
; 2086 : must fit in a single Python digit.  The second is effectively the input
; 2087 : base we're really using.
; 2088 : 
; 2089 : Viewing the input as a sequence <c0, c1, ..., c_n-1> of digits in base
; 2090 : convmultmax_base[base], the result is "simply"
; 2091 : 
; 2092 :    (((c0*B + c1)*B + c2)*B + c3)*B + ... ))) + c_n-1
; 2093 : 
; 2094 : where B = convmultmax_base[base].
; 2095 : 
; 2096 : Error analysis:  as above, the number of Python digits `n` needed is worst-
; 2097 : case
; 2098 : 
; 2099 :     n >= N * log(B)/log(BASE)
; 2100 : 
; 2101 : where `N` is the number of input digits in base `B`.  This is computed via
; 2102 : 
; 2103 :     size_z = (Py_ssize_t)((scan - str) * log_base_BASE[base]) + 1;
; 2104 : 
; 2105 : below.  Two numeric concerns are how much space this can waste, and whether
; 2106 : the computed result can be too small.  To be concrete, assume BASE = 2**15,
; 2107 : which is the default (and it's unlikely anyone changes that).
; 2108 : 
; 2109 : Waste isn't a problem:  provided the first input digit isn't 0, the difference
; 2110 : between the worst-case input with N digits and the smallest input with N
; 2111 : digits is about a factor of B, but B is small compared to BASE so at most
; 2112 : one allocated Python digit can remain unused on that count.  If
; 2113 : N*log(B)/log(BASE) is mathematically an exact integer, then truncating that
; 2114 : and adding 1 returns a result 1 larger than necessary.  However, that can't
; 2115 : happen:  whenever B is a power of 2, long_from_binary_base() is called
; 2116 : instead, and it's impossible for B**i to be an integer power of 2**15 when
; 2117 : B is not a power of 2 (i.e., it's impossible for N*log(B)/log(BASE) to be
; 2118 : an exact integer when B is not a power of 2, since B**i has a prime factor
; 2119 : other than 2 in that case, but (2**15)**j's only prime factor is 2).
; 2120 : 
; 2121 : The computed result can be too small if the true value of N*log(B)/log(BASE)
; 2122 : is a little bit larger than an exact integer, but due to roundoff errors (in
; 2123 : computing log(B), log(BASE), their quotient, and/or multiplying that by N)
; 2124 : yields a numeric result a little less than that integer.  Unfortunately, "how
; 2125 : close can a transcendental function get to an integer over some range?"
; 2126 : questions are generally theoretically intractable.  Computer analysis via
; 2127 : continued fractions is practical:  expand log(B)/log(BASE) via continued
; 2128 : fractions, giving a sequence i/j of "the best" rational approximations.  Then
; 2129 : j*log(B)/log(BASE) is approximately equal to (the integer) i.  This shows that
; 2130 : we can get very close to being in trouble, but very rarely.  For example,
; 2131 : 76573 is a denominator in one of the continued-fraction approximations to
; 2132 : log(10)/log(2**15), and indeed:
; 2133 : 
; 2134 :     >>> log(10)/log(2**15)*76573
; 2135 :     16958.000000654003
; 2136 : 
; 2137 : is very close to an integer.  If we were working with IEEE single-precision,
; 2138 : rounding errors could kill us.  Finding worst cases in IEEE double-precision
; 2139 : requires better-than-double-precision log() functions, and Tim didn't bother.
; 2140 : Instead the code checks to see whether the allocated space is enough as each
; 2141 : new Python digit is added, and copies the whole thing to a larger int if not.
; 2142 : This should happen extremely rarely, and in fact I don't have a test case
; 2143 : that triggers it(!).  Instead the code was tested by artificially allocating
; 2144 : just 1 digit at the start, so that the copying code was exercised for every
; 2145 : digit beyond the first.
; 2146 : ***/
; 2147 :         register twodigits c;           /* current input character */
; 2148 :         Py_ssize_t size_z;
; 2149 :         int i;
; 2150 :         int convwidth;
; 2151 :         twodigits convmultmax, convmult;
; 2152 :         digit *pz, *pzstop;
; 2153 :         char* scan;
; 2154 : 
; 2155 :         static double log_base_BASE[37] = {0.0e0,};
; 2156 :         static int convwidth_base[37] = {0,};
; 2157 :         static twodigits convmultmax_base[37] = {0,};
; 2158 : 
; 2159 :         if (log_base_BASE[base] == 0.0) {

  002d1	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  002d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?log_base_BASE@?6??PyLong_FromString@@9@9
  002e0	f2 0f 10 04 c1	 movsdx	 xmm0, QWORD PTR [rcx+rax*8]
  002e5	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  002ed	0f 8a 19 01 00
	00		 jp	 $LN39@PyLong_Fro@11
  002f3	0f 85 13 01 00
	00		 jne	 $LN39@PyLong_Fro@11

; 2160 :             twodigits convmax = base;

  002f9	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  00301	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR convmax$22202[rsp], rax

; 2161 :             int i = 1;

  00309	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR i$22203[rsp], 1

; 2162 : 
; 2163 :             log_base_BASE[base] = (log((double)base) /
; 2164 :                                    log((double)PyLong_BASE));

  00314	66 0f 6e 84 24
	00 01 00 00	 movd	 xmm0, DWORD PTR base$[rsp]
  0031d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00321	e8 00 00 00 00	 call	 log
  00326	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR tv180[rsp], xmm0
  0032f	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@41d0000000000000
  00337	e8 00 00 00 00	 call	 log
  0033c	f2 0f 10 8c 24
	c0 00 00 00	 movsdx	 xmm1, QWORD PTR tv180[rsp]
  00345	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00349	66 0f 28 c1	 movapd	 xmm0, xmm1
  0034d	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  00355	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?log_base_BASE@?6??PyLong_FromString@@9@9
  0035c	f2 0f 11 04 c1	 movsdx	 QWORD PTR [rcx+rax*8], xmm0
$LN38@PyLong_Fro@11:

; 2165 :             for (;;) {
; 2166 :                 twodigits next = convmax * base;

  00361	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  00369	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR convmax$22202[rsp]
  00371	48 0f af c8	 imul	 rcx, rax
  00375	48 8b c1	 mov	 rax, rcx
  00378	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR next$22210[rsp], rax

; 2167 :                 if (next > PyLong_BASE)

  00380	48 81 bc 24 b0
	00 00 00 00 00
	00 40		 cmp	 QWORD PTR next$22210[rsp], 1073741824 ; 40000000H
  0038c	76 02		 jbe	 SHORT $LN36@PyLong_Fro@11

; 2168 :                     break;

  0038e	eb 22		 jmp	 SHORT $LN37@PyLong_Fro@11
$LN36@PyLong_Fro@11:

; 2169 :                 convmax = next;

  00390	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR next$22210[rsp]
  00398	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR convmax$22202[rsp], rax

; 2170 :                 ++i;

  003a0	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR i$22203[rsp]
  003a7	ff c0		 inc	 eax
  003a9	89 84 24 a0 00
	00 00		 mov	 DWORD PTR i$22203[rsp], eax

; 2171 :             }

  003b0	eb af		 jmp	 SHORT $LN38@PyLong_Fro@11
$LN37@PyLong_Fro@11:

; 2172 :             convmultmax_base[base] = convmax;

  003b2	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  003ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?convmultmax_base@?6??PyLong_FromString@@9@9
  003c1	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR convmax$22202[rsp]
  003c9	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 2173 :             assert(i > 0);

  003cd	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR i$22203[rsp], 0
  003d5	7f 1c		 jg	 SHORT $LN69@PyLong_Fro@11
  003d7	41 b8 7d 08 00
	00		 mov	 r8d, 2173		; 0000087dH
  003dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1M@BJEMNAAB@?$AAi?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  003eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003f1	33 c0		 xor	 eax, eax
$LN69@PyLong_Fro@11:

; 2174 :             convwidth_base[base] = i;

  003f3	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  003fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?convwidth_base@?6??PyLong_FromString@@9@9
  00402	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR i$22203[rsp]
  00409	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN39@PyLong_Fro@11:

; 2175 :         }
; 2176 : 
; 2177 :         /* Find length of the string of numeric characters. */
; 2178 :         scan = str;

  0040c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00414	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR scan$22194[rsp], rax
$LN35@PyLong_Fro@11:

; 2179 :         while (_PyLong_DigitValue[Py_CHARMASK(*scan)] < base)

  0041c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR scan$22194[rsp]
  00424	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00427	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0042c	0f b6 c0	 movzx	 eax, al
  0042f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  00436	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0043a	3b 84 24 00 01
	00 00		 cmp	 eax, DWORD PTR base$[rsp]
  00441	7d 15		 jge	 SHORT $LN34@PyLong_Fro@11

; 2180 :             ++scan;

  00443	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR scan$22194[rsp]
  0044b	48 ff c0	 inc	 rax
  0044e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR scan$22194[rsp], rax
  00456	eb c4		 jmp	 SHORT $LN35@PyLong_Fro@11
$LN34@PyLong_Fro@11:

; 2181 : 
; 2182 :         /* Create an int object that can contain the largest possible
; 2183 :          * integer with this base and length.  Note that there's no
; 2184 :          * need to initialize z->ob_digit -- no slot is read up before
; 2185 :          * being stored into.
; 2186 :          */
; 2187 :         size_z = (Py_ssize_t)((scan - str) * log_base_BASE[base]) + 1;

  00458	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00460	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR scan$22194[rsp]
  00468	48 2b c8	 sub	 rcx, rax
  0046b	48 8b c1	 mov	 rax, rcx
  0046e	66 0f ef c0	 pxor	 xmm0, xmm0
  00472	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00477	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  0047f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?log_base_BASE@?6??PyLong_FromString@@9@9
  00486	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  0048b	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  00490	48 ff c0	 inc	 rax
  00493	48 89 44 24 78	 mov	 QWORD PTR size_z$22187[rsp], rax

; 2188 :         /* Uncomment next line to test exceedingly rare copy code */
; 2189 :         /* size_z = 1; */
; 2190 :         assert(size_z > 0);

  00498	48 83 7c 24 78
	00		 cmp	 QWORD PTR size_z$22187[rsp], 0
  0049e	7f 1c		 jg	 SHORT $LN70@PyLong_Fro@11
  004a0	41 b8 8e 08 00
	00		 mov	 r8d, 2190		; 0000088eH
  004a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  004ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@FNLKKNFD@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAz?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  004b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004ba	33 c0		 xor	 eax, eax
$LN70@PyLong_Fro@11:

; 2191 :         z = _PyLong_New(size_z);

  004bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR size_z$22187[rsp]
  004c1	e8 00 00 00 00	 call	 _PyLong_New
  004c6	48 89 44 24 50	 mov	 QWORD PTR z$[rsp], rax

; 2192 :         if (z == NULL)

  004cb	48 83 7c 24 50
	00		 cmp	 QWORD PTR z$[rsp], 0
  004d1	75 07		 jne	 SHORT $LN33@PyLong_Fro@11

; 2193 :             return NULL;

  004d3	33 c0		 xor	 eax, eax
  004d5	e9 4d 05 00 00	 jmp	 $LN67@PyLong_Fro@11
$LN33@PyLong_Fro@11:

; 2194 :         Py_SIZE(z) = 0;

  004da	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  004df	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 2195 : 
; 2196 :         /* `convwidth` consecutive input digits are treated as a single
; 2197 :          * digit in base `convmultmax`.
; 2198 :          */
; 2199 :         convwidth = convwidth_base[base];

  004e7	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  004ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?convwidth_base@?6??PyLong_FromString@@9@9
  004f6	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  004f9	89 84 24 90 00
	00 00		 mov	 DWORD PTR convwidth$22189[rsp], eax

; 2200 :         convmultmax = convmultmax_base[base];

  00500	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  00508	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?convmultmax_base@?6??PyLong_FromString@@9@9
  0050f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00513	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR convmultmax$22190[rsp], rax
$LN32@PyLong_Fro@11:

; 2201 : 
; 2202 :         /* Work ;-) */
; 2203 :         while (str < scan) {

  0051b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR scan$22194[rsp]
  00523	48 39 84 24 f0
	00 00 00	 cmp	 QWORD PTR str$[rsp], rax
  0052b	0f 83 22 03 00
	00		 jae	 $LN31@PyLong_Fro@11

; 2204 :             /* grab up to convwidth digits from the input string */
; 2205 :             c = (digit)_PyLong_DigitValue[Py_CHARMASK(*str++)];

  00531	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00539	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0053c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00541	0f b6 c0	 movzx	 eax, al
  00544	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  0054b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0054f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR c$22186[rsp], rax
  00557	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0055f	48 ff c0	 inc	 rax
  00562	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR str$[rsp], rax

; 2206 :             for (i = 1; i < convwidth && str != scan; ++i, ++str) {

  0056a	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR i$22188[rsp], 1
  00572	eb 1d		 jmp	 SHORT $LN30@PyLong_Fro@11
$LN29@PyLong_Fro@11:
  00574	8b 44 24 60	 mov	 eax, DWORD PTR i$22188[rsp]
  00578	ff c0		 inc	 eax
  0057a	89 44 24 60	 mov	 DWORD PTR i$22188[rsp], eax
  0057e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00586	48 ff c0	 inc	 rax
  00589	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR str$[rsp], rax
$LN30@PyLong_Fro@11:
  00591	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR convwidth$22189[rsp]
  00598	39 44 24 60	 cmp	 DWORD PTR i$22188[rsp], eax
  0059c	0f 8d 82 00 00
	00		 jge	 $LN28@PyLong_Fro@11
  005a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR scan$22194[rsp]
  005aa	48 39 84 24 f0
	00 00 00	 cmp	 QWORD PTR str$[rsp], rax
  005b2	74 70		 je	 SHORT $LN28@PyLong_Fro@11

; 2207 :                 c = (twodigits)(c *  base +
; 2208 :                                 (int)_PyLong_DigitValue[Py_CHARMASK(*str)]);

  005b4	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  005bc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR c$22186[rsp]
  005c4	48 0f af c8	 imul	 rcx, rax
  005c8	48 8b c1	 mov	 rax, rcx
  005cb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  005d3	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  005d6	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  005dc	0f b6 c9	 movzx	 ecx, cl
  005df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_PyLong_DigitValue
  005e6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  005ea	48 03 c1	 add	 rax, rcx
  005ed	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR c$22186[rsp], rax

; 2209 :                 assert(c < PyLong_BASE);

  005f5	48 81 bc 24 98
	00 00 00 00 00
	00 40		 cmp	 QWORD PTR c$22186[rsp], 1073741824 ; 40000000H
  00601	72 1c		 jb	 SHORT $LN71@PyLong_Fro@11
  00603	41 b8 a1 08 00
	00		 mov	 r8d, 2209		; 000008a1H
  00609	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00610	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@CELMPDAK@?$AAc?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@
  00617	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0061d	33 c0		 xor	 eax, eax
$LN71@PyLong_Fro@11:

; 2210 :             }

  0061f	e9 50 ff ff ff	 jmp	 $LN29@PyLong_Fro@11
$LN28@PyLong_Fro@11:

; 2211 : 
; 2212 :             convmult = convmultmax;

  00624	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR convmultmax$22190[rsp]
  0062c	48 89 44 24 58	 mov	 QWORD PTR convmult$22191[rsp], rax

; 2213 :             /* Calculate the shift only if we couldn't get
; 2214 :              * convwidth digits.
; 2215 :              */
; 2216 :             if (i != convwidth) {

  00631	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR convwidth$22189[rsp]
  00638	39 44 24 60	 cmp	 DWORD PTR i$22188[rsp], eax
  0063c	74 3b		 je	 SHORT $LN27@PyLong_Fro@11

; 2217 :                 convmult = base;

  0063e	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  00646	48 89 44 24 58	 mov	 QWORD PTR convmult$22191[rsp], rax

; 2218 :                 for ( ; i > 1; --i)

  0064b	eb 0a		 jmp	 SHORT $LN26@PyLong_Fro@11
$LN25@PyLong_Fro@11:
  0064d	8b 44 24 60	 mov	 eax, DWORD PTR i$22188[rsp]
  00651	ff c8		 dec	 eax
  00653	89 44 24 60	 mov	 DWORD PTR i$22188[rsp], eax
$LN26@PyLong_Fro@11:
  00657	83 7c 24 60 01	 cmp	 DWORD PTR i$22188[rsp], 1
  0065c	7e 1b		 jle	 SHORT $LN24@PyLong_Fro@11

; 2219 :                     convmult *= base;

  0065e	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  00666	48 8b 4c 24 58	 mov	 rcx, QWORD PTR convmult$22191[rsp]
  0066b	48 0f af c8	 imul	 rcx, rax
  0066f	48 8b c1	 mov	 rax, rcx
  00672	48 89 44 24 58	 mov	 QWORD PTR convmult$22191[rsp], rax
  00677	eb d4		 jmp	 SHORT $LN25@PyLong_Fro@11
$LN24@PyLong_Fro@11:
$LN27@PyLong_Fro@11:

; 2220 :             }
; 2221 : 
; 2222 :             /* Multiply z by convmult, and add c. */
; 2223 :             pz = z->ob_digit;

  00679	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0067e	48 83 c0 70	 add	 rax, 112		; 00000070H
  00682	48 89 44 24 68	 mov	 QWORD PTR pz$22192[rsp], rax

; 2224 :             pzstop = pz + Py_SIZE(z);

  00687	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0068c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00690	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pz$22192[rsp]
  00695	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00699	48 89 44 24 70	 mov	 QWORD PTR pzstop$22193[rsp], rax

; 2225 :             for (; pz < pzstop; ++pz) {

  0069e	eb 0e		 jmp	 SHORT $LN23@PyLong_Fro@11
$LN22@PyLong_Fro@11:
  006a0	48 8b 44 24 68	 mov	 rax, QWORD PTR pz$22192[rsp]
  006a5	48 83 c0 04	 add	 rax, 4
  006a9	48 89 44 24 68	 mov	 QWORD PTR pz$22192[rsp], rax
$LN23@PyLong_Fro@11:
  006ae	48 8b 44 24 70	 mov	 rax, QWORD PTR pzstop$22193[rsp]
  006b3	48 39 44 24 68	 cmp	 QWORD PTR pz$22192[rsp], rax
  006b8	73 4e		 jae	 SHORT $LN21@PyLong_Fro@11

; 2226 :                 c += (twodigits)*pz * convmult;

  006ba	48 8b 44 24 68	 mov	 rax, QWORD PTR pz$22192[rsp]
  006bf	8b 00		 mov	 eax, DWORD PTR [rax]
  006c1	48 0f af 44 24
	58		 imul	 rax, QWORD PTR convmult$22191[rsp]
  006c7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR c$22186[rsp]
  006cf	48 03 c8	 add	 rcx, rax
  006d2	48 8b c1	 mov	 rax, rcx
  006d5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR c$22186[rsp], rax

; 2227 :                 *pz = (digit)(c & PyLong_MASK);

  006dd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR c$22186[rsp]
  006e5	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  006eb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pz$22192[rsp]
  006f0	89 01		 mov	 DWORD PTR [rcx], eax

; 2228 :                 c >>= PyLong_SHIFT;

  006f2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR c$22186[rsp]
  006fa	48 c1 e8 1e	 shr	 rax, 30
  006fe	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR c$22186[rsp], rax

; 2229 :             }

  00706	eb 98		 jmp	 SHORT $LN22@PyLong_Fro@11
$LN21@PyLong_Fro@11:

; 2230 :             /* carry off the current end? */
; 2231 :             if (c) {

  00708	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR c$22186[rsp], 0
  00711	0f 84 37 01 00
	00		 je	 $LN20@PyLong_Fro@11

; 2232 :                 assert(c < PyLong_BASE);

  00717	48 81 bc 24 98
	00 00 00 00 00
	00 40		 cmp	 QWORD PTR c$22186[rsp], 1073741824 ; 40000000H
  00723	72 1c		 jb	 SHORT $LN72@PyLong_Fro@11
  00725	41 b8 b8 08 00
	00		 mov	 r8d, 2232		; 000008b8H
  0072b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00732	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@CELMPDAK@?$AAc?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@
  00739	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0073f	33 c0		 xor	 eax, eax
$LN72@PyLong_Fro@11:

; 2233 :                 if (Py_SIZE(z) < size_z) {

  00741	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00746	48 8b 4c 24 78	 mov	 rcx, QWORD PTR size_z$22187[rsp]
  0074b	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0074f	7d 28		 jge	 SHORT $LN19@PyLong_Fro@11

; 2234 :                     *pz = (digit)c;

  00751	48 8b 44 24 68	 mov	 rax, QWORD PTR pz$22192[rsp]
  00756	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR c$22186[rsp]
  0075d	89 08		 mov	 DWORD PTR [rax], ecx

; 2235 :                     ++Py_SIZE(z);

  0075f	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00764	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00768	48 ff c0	 inc	 rax
  0076b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00770	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 2236 :                 }
; 2237 :                 else {

  00774	e9 d5 00 00 00	 jmp	 $LN18@PyLong_Fro@11
$LN19@PyLong_Fro@11:

; 2238 :                     PyLongObject *tmp;
; 2239 :                     /* Extremely rare.  Get more space. */
; 2240 :                     assert(Py_SIZE(z) == size_z);

  00779	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0077e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR size_z$22187[rsp]
  00783	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00787	74 1c		 je	 SHORT $LN73@PyLong_Fro@11
  00789	41 b8 c0 08 00
	00		 mov	 r8d, 2240		; 000008c0H
  0078f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00796	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MHJHNDLK@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAz?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAz?$AA?$AA@
  0079d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  007a3	33 c0		 xor	 eax, eax
$LN73@PyLong_Fro@11:

; 2241 :                     tmp = _PyLong_New(size_z + 1);

  007a5	48 8b 44 24 78	 mov	 rax, QWORD PTR size_z$22187[rsp]
  007aa	48 ff c0	 inc	 rax
  007ad	48 8b c8	 mov	 rcx, rax
  007b0	e8 00 00 00 00	 call	 _PyLong_New
  007b5	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tmp$22260[rsp], rax

; 2242 :                     if (tmp == NULL) {

  007bd	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR tmp$22260[rsp], 0
  007c6	75 11		 jne	 SHORT $LN17@PyLong_Fro@11

; 2243 :                         Py_DECREF(z);

  007c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  007cd	e8 00 00 00 00	 call	 _Py_DecRef

; 2244 :                         return NULL;

  007d2	33 c0		 xor	 eax, eax
  007d4	e9 4e 02 00 00	 jmp	 $LN67@PyLong_Fro@11
$LN17@PyLong_Fro@11:

; 2245 :                     }
; 2246 :                     memcpy(tmp->ob_digit,
; 2247 :                            z->ob_digit,
; 2248 :                            sizeof(digit) * size_z);

  007d9	48 8b 44 24 78	 mov	 rax, QWORD PTR size_z$22187[rsp]
  007de	48 c1 e0 02	 shl	 rax, 2
  007e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  007e7	48 83 c1 70	 add	 rcx, 112		; 00000070H
  007eb	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tmp$22260[rsp]
  007f3	48 83 c2 70	 add	 rdx, 112		; 00000070H
  007f7	48 89 94 24 c8
	00 00 00	 mov	 QWORD PTR tv305[rsp], rdx
  007ff	4c 8b c0	 mov	 r8, rax
  00802	48 8b d1	 mov	 rdx, rcx
  00805	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv305[rsp]
  0080d	48 8b c8	 mov	 rcx, rax
  00810	e8 00 00 00 00	 call	 memcpy

; 2249 :                     Py_DECREF(z);

  00815	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0081a	e8 00 00 00 00	 call	 _Py_DecRef

; 2250 :                     z = tmp;

  0081f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tmp$22260[rsp]
  00827	48 89 44 24 50	 mov	 QWORD PTR z$[rsp], rax

; 2251 :                     z->ob_digit[size_z] = (digit)c;

  0082c	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00831	48 8b 4c 24 78	 mov	 rcx, QWORD PTR size_z$22187[rsp]
  00836	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR c$22186[rsp]
  0083d	89 54 88 70	 mov	 DWORD PTR [rax+rcx*4+112], edx

; 2252 :                     ++size_z;

  00841	48 8b 44 24 78	 mov	 rax, QWORD PTR size_z$22187[rsp]
  00846	48 ff c0	 inc	 rax
  00849	48 89 44 24 78	 mov	 QWORD PTR size_z$22187[rsp], rax
$LN18@PyLong_Fro@11:
$LN20@PyLong_Fro@11:

; 2253 :                 }
; 2254 :             }
; 2255 :         }

  0084e	e9 c8 fc ff ff	 jmp	 $LN32@PyLong_Fro@11
$LN31@PyLong_Fro@11:
$LN40@PyLong_Fro@11:

; 2256 :     }
; 2257 :     if (z == NULL)

  00853	48 83 7c 24 50
	00		 cmp	 QWORD PTR z$[rsp], 0
  00859	75 07		 jne	 SHORT $LN16@PyLong_Fro@11

; 2258 :         return NULL;

  0085b	33 c0		 xor	 eax, eax
  0085d	e9 c5 01 00 00	 jmp	 $LN67@PyLong_Fro@11
$LN16@PyLong_Fro@11:

; 2259 :     if (error_if_nonzero) {

  00862	83 7c 24 30 00	 cmp	 DWORD PTR error_if_nonzero$[rsp], 0
  00867	74 1c		 je	 SHORT $LN15@PyLong_Fro@11

; 2260 :         /* reset the base to 0, else the exception message
; 2261 :            doesn't make too much sense */
; 2262 :         base = 0;

  00869	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR base$[rsp], 0

; 2263 :         if (Py_SIZE(z) != 0)

  00874	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00879	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0087e	74 05		 je	 SHORT $LN14@PyLong_Fro@11

; 2264 :             goto onError;

  00880	e9 e1 00 00 00	 jmp	 $onError$22277
$LN14@PyLong_Fro@11:
$LN15@PyLong_Fro@11:

; 2265 :         /* there might still be other problems, therefore base
; 2266 :            remains zero here for the same reason */
; 2267 :     }
; 2268 :     if (str == start)

  00885	48 8b 44 24 38	 mov	 rax, QWORD PTR start$[rsp]
  0088a	48 39 84 24 f0
	00 00 00	 cmp	 QWORD PTR str$[rsp], rax
  00892	75 05		 jne	 SHORT $LN13@PyLong_Fro@11

; 2269 :         goto onError;

  00894	e9 cd 00 00 00	 jmp	 $onError$22277
$LN13@PyLong_Fro@11:

; 2270 :     if (sign < 0)

  00899	83 7c 24 40 00	 cmp	 DWORD PTR sign$[rsp], 0
  0089e	7d 15		 jge	 SHORT $LN12@PyLong_Fro@11

; 2271 :         Py_SIZE(z) = -(Py_SIZE(z));

  008a0	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  008a5	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  008a9	48 f7 d8	 neg	 rax
  008ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  008b1	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN12@PyLong_Fro@11:
$LN11@PyLong_Fro@11:

; 2272 :     while (*str && Py_ISSPACE(Py_CHARMASK(*str)))

  008b5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  008bd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  008c0	85 c0		 test	 eax, eax
  008c2	74 41		 je	 SHORT $LN10@PyLong_Fro@11
  008c4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  008cc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  008cf	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008d4	0f b6 c0	 movzx	 eax, al
  008d7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008dc	0f b6 c0	 movzx	 eax, al
  008df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  008e6	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  008e9	83 e0 08	 and	 eax, 8
  008ec	85 c0		 test	 eax, eax
  008ee	74 15		 je	 SHORT $LN10@PyLong_Fro@11

; 2273 :         str++;

  008f0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  008f8	48 ff c0	 inc	 rax
  008fb	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR str$[rsp], rax
  00903	eb b0		 jmp	 SHORT $LN11@PyLong_Fro@11
$LN10@PyLong_Fro@11:

; 2274 :     if (*str != '\0')

  00905	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  0090d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00910	85 c0		 test	 eax, eax
  00912	74 02		 je	 SHORT $LN9@PyLong_Fro@11

; 2275 :         goto onError;

  00914	eb 50		 jmp	 SHORT $onError$22277
$LN9@PyLong_Fro@11:

; 2276 :     long_normalize(z);

  00916	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0091b	e8 00 00 00 00	 call	 long_normalize

; 2277 :     z = maybe_small_long(z);

  00920	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00925	e8 00 00 00 00	 call	 maybe_small_long
  0092a	48 89 44 24 50	 mov	 QWORD PTR z$[rsp], rax

; 2278 :     if (z == NULL)

  0092f	48 83 7c 24 50
	00		 cmp	 QWORD PTR z$[rsp], 0
  00935	75 07		 jne	 SHORT $LN8@PyLong_Fro@11

; 2279 :         return NULL;

  00937	33 c0		 xor	 eax, eax
  00939	e9 e9 00 00 00	 jmp	 $LN67@PyLong_Fro@11
$LN8@PyLong_Fro@11:

; 2280 :     if (pend != NULL)

  0093e	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR pend$[rsp], 0
  00947	74 13		 je	 SHORT $LN7@PyLong_Fro@11

; 2281 :         *pend = str;

  00949	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pend$[rsp]
  00951	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  00959	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN7@PyLong_Fro@11:

; 2282 :     return (PyObject *) z;

  0095c	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00961	e9 c1 00 00 00	 jmp	 $LN67@PyLong_Fro@11
$onError$22277:

; 2283 : 
; 2284 :   onError:
; 2285 :     if (pend != NULL)

  00966	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR pend$[rsp], 0
  0096f	74 13		 je	 SHORT $LN6@PyLong_Fro@11

; 2286 :         *pend = str;

  00971	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pend$[rsp]
  00979	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  00981	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN6@PyLong_Fro@11:
$LN5@PyLong_Fro@11:

; 2287 :     Py_XDECREF(z);

  00984	48 83 7c 24 50
	00		 cmp	 QWORD PTR z$[rsp], 0
  0098a	74 0a		 je	 SHORT $LN2@PyLong_Fro@11
  0098c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00991	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PyLong_Fro@11:
  00996	33 c0		 xor	 eax, eax
  00998	85 c0		 test	 eax, eax
  0099a	75 e8		 jne	 SHORT $LN5@PyLong_Fro@11

; 2288 :     slen = strlen(orig_str) < 200 ? strlen(orig_str) : 200;

  0099c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR orig_str$[rsp]
  009a1	e8 00 00 00 00	 call	 strlen
  009a6	48 3d c8 00 00
	00		 cmp	 rax, 200		; 000000c8H
  009ac	73 14		 jae	 SHORT $LN74@PyLong_Fro@11
  009ae	48 8b 4c 24 28	 mov	 rcx, QWORD PTR orig_str$[rsp]
  009b3	e8 00 00 00 00	 call	 strlen
  009b8	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv350[rsp], rax
  009c0	eb 0c		 jmp	 SHORT $LN75@PyLong_Fro@11
$LN74@PyLong_Fro@11:
  009c2	48 c7 84 24 d0
	00 00 00 c8 00
	00 00		 mov	 QWORD PTR tv350[rsp], 200 ; 000000c8H
$LN75@PyLong_Fro@11:
  009ce	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv350[rsp]
  009d6	48 89 44 24 20	 mov	 QWORD PTR slen$[rsp], rax

; 2289 :     strobj = PyUnicode_FromStringAndSize(orig_str, slen);

  009db	48 8b 54 24 20	 mov	 rdx, QWORD PTR slen$[rsp]
  009e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR orig_str$[rsp]
  009e5	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  009ea	48 89 44 24 48	 mov	 QWORD PTR strobj$[rsp], rax

; 2290 :     if (strobj == NULL)

  009ef	48 83 7c 24 48
	00		 cmp	 QWORD PTR strobj$[rsp], 0
  009f5	75 04		 jne	 SHORT $LN1@PyLong_Fro@11

; 2291 :         return NULL;

  009f7	33 c0		 xor	 eax, eax
  009f9	eb 2c		 jmp	 SHORT $LN67@PyLong_Fro@11
$LN1@PyLong_Fro@11:

; 2292 :     PyErr_Format(PyExc_ValueError,
; 2293 :                  "invalid literal for int() with base %d: %R",
; 2294 :                  base, strobj);

  009fb	4c 8b 4c 24 48	 mov	 r9, QWORD PTR strobj$[rsp]
  00a00	44 8b 84 24 00
	01 00 00	 mov	 r8d, DWORD PTR base$[rsp]
  00a08	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@
  00a0f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00a16	e8 00 00 00 00	 call	 PyErr_Format

; 2295 :     Py_DECREF(strobj);

  00a1b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR strobj$[rsp]
  00a20	e8 00 00 00 00	 call	 _Py_DecRef

; 2296 :     return NULL;

  00a25	33 c0		 xor	 eax, eax
$LN67@PyLong_Fro@11:

; 2297 : }

  00a27	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00a2e	c3		 ret	 0
PyLong_FromString ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$maybe_small_long DD imagerel maybe_small_long
	DD	imagerel maybe_small_long+200
	DD	imagerel $unwind$maybe_small_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$maybe_small_long DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT maybe_small_long
_TEXT	SEGMENT
ival$20308 = 32
tv70 = 40
tv82 = 48
tv81 = 52
v$ = 80
maybe_small_long PROC					; COMDAT

; 56   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 57   :     if (v && ABS(Py_SIZE(v)) <= 1) {

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR v$[rsp], 0
  0000f	0f 84 a9 00 00
	00		 je	 $LN2@maybe_smal
  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0001a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001f	7d 13		 jge	 SHORT $LN5@maybe_smal
  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00026	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002a	48 f7 d8	 neg	 rax
  0002d	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00032	eb 0e		 jmp	 SHORT $LN6@maybe_smal
$LN5@maybe_smal:
  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00039	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003d	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN6@maybe_smal:
  00042	48 83 7c 24 28
	01		 cmp	 QWORD PTR tv70[rsp], 1
  00048	7f 74		 jg	 SHORT $LN2@maybe_smal

; 58   :         sdigit ival = MEDIUM_VALUE(v);

  0004a	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0004f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00054	7d 10		 jge	 SHORT $LN9@maybe_smal
  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0005b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0005e	f7 d8		 neg	 eax
  00060	89 44 24 30	 mov	 DWORD PTR tv82[rsp], eax
  00064	eb 2a		 jmp	 SHORT $LN10@maybe_smal
$LN9@maybe_smal:
  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0006b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00070	75 0a		 jne	 SHORT $LN7@maybe_smal
  00072	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
  0007a	eb 0c		 jmp	 SHORT $LN8@maybe_smal
$LN7@maybe_smal:
  0007c	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00081	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00084	89 44 24 34	 mov	 DWORD PTR tv81[rsp], eax
$LN8@maybe_smal:
  00088	8b 44 24 34	 mov	 eax, DWORD PTR tv81[rsp]
  0008c	89 44 24 30	 mov	 DWORD PTR tv82[rsp], eax
$LN10@maybe_smal:
  00090	8b 44 24 30	 mov	 eax, DWORD PTR tv82[rsp]
  00094	89 44 24 20	 mov	 DWORD PTR ival$20308[rsp], eax

; 59   :         if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) {

  00098	83 7c 24 20 fb	 cmp	 DWORD PTR ival$20308[rsp], -5
  0009d	7c 1f		 jl	 SHORT $LN1@maybe_smal
  0009f	81 7c 24 20 01
	01 00 00	 cmp	 DWORD PTR ival$20308[rsp], 257 ; 00000101H
  000a7	7d 15		 jge	 SHORT $LN1@maybe_smal

; 60   :             Py_DECREF(v);

  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000ae	e8 00 00 00 00	 call	 _Py_DecRef

; 61   :             return (PyLongObject *)get_small_int(ival);

  000b3	8b 4c 24 20	 mov	 ecx, DWORD PTR ival$20308[rsp]
  000b7	e8 00 00 00 00	 call	 get_small_int
  000bc	eb 05		 jmp	 SHORT $LN3@maybe_smal
$LN1@maybe_smal:
$LN2@maybe_smal:

; 62   :         }
; 63   :     }
; 64   :     return v;

  000be	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
$LN3@maybe_smal:

; 65   : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
maybe_small_long ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DM@MPHFGDG@?$AAb?$AAi?$AAt?$AAs?$AA_?$AAi?$AAn?$AA_?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@KCCIOCFM@?$AAb?$AAi?$AAt?$AAs?$AA_?$AAi?$AAn?$AA_?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@EAKAHKGM@?$AAp?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?9?$AA?5?$AAz?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@LAJDOMFE@?$AAk?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAk?$AA?5?$AA?$DM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CA@KANPCKBN@int?5string?5too?5large?5to?5convert?$AA@ ; `string'
PUBLIC	??_C@_1GI@PHNEBJOM@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA3?$AA2?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAb?$AAa?$AAs?$AAe@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_from_binary_base DD imagerel long_from_binary_base
	DD	imagerel long_from_binary_base+939
	DD	imagerel $unwind$long_from_binary_base
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_from_binary_base DD 010d01H
	DD	0e20dH
xdata	ENDS
;	COMDAT ??_C@_1DM@MPHFGDG@?$AAb?$AAi?$AAt?$AAs?$AA_?$AAi?$AAn?$AA_?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@MPHFGDG@?$AAb?$AAi?$AAt?$AAs?$AA_?$AAi?$AAn?$AA_?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, '_', 00H, 'i', 00H, 'n', 00H
	DB	'_', 00H, 'a', 00H, 'c', 00H, 'c', 00H, 'u', 00H, 'm', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'L', 00H
	DB	'o', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'S', 00H, 'H', 00H, 'I'
	DB	00H, 'F', 00H, 'T', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@KCCIOCFM@?$AAb?$AAi?$AAt?$AAs?$AA_?$AAi?$AAn?$AA_?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@KCCIOCFM@?$AAb?$AAi?$AAt?$AAs?$AA_?$AAi?$AAn?$AA_?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, '_', 00H, 'i', 00H, 'n', 00H
	DB	'_', 00H, 'a', 00H, 'c', 00H, 'c', 00H, 'u', 00H, 'm', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'L', 00H, 'o', 00H
	DB	'n', 00H, 'g', 00H, '_', 00H, 'S', 00H, 'H', 00H, 'I', 00H, 'F'
	DB	00H, 'T', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@EAKAHKGM@?$AAp?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?9?$AA?5?$AAz?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@EAKAHKGM@?$AAp?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?9?$AA?5?$AAz?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?$AA@ DB 'p'
	DB	00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, 'z', 00H, '-', 00H, '>', 00H, 'o', 00H, 'b'
	DB	00H, '_', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LAJDOMFE@?$AAk?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAk?$AA?5?$AA?$DM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@LAJDOMFE@?$AAk?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAk?$AA?5?$AA?$DM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?$AA@ DB 'k'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'k', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KANPCKBN@int?5string?5too?5large?5to?5convert?$AA@
CONST	SEGMENT
??_C@_0CA@KANPCKBN@int?5string?5too?5large?5to?5convert?$AA@ DB 'int stri'
	DB	'ng too large to convert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@PHNEBJOM@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA3?$AA2?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAb?$AAa?$AAs?$AAe@
CONST	SEGMENT
??_C@_1GI@PHNEBJOM@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA3?$AA2?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAb?$AAa?$AAs?$AAe@ DB 'b'
	DB	00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '2', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'b'
	DB	00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '3', 00H, '2', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '(', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H
	DB	'&', 00H, ' ', 00H, '(', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, '1', 00H, ')', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_from_binary_base
_TEXT	SEGMENT
p$ = 32
bits_per_char$ = 40
n$ = 48
bits_in_accum$ = 56
accum$ = 64
start$ = 72
pdigit$ = 80
z$ = 88
k$22117 = 96
tv90 = 104
str$ = 128
base$ = 136
long_from_binary_base PROC				; COMDAT

; 1948 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1949 :     char *p = *str;

  0000d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00015	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00018	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1950 :     char *start = p;

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00022	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1951 :     int bits_per_char;
; 1952 :     Py_ssize_t n;
; 1953 :     PyLongObject *z;
; 1954 :     twodigits accum;
; 1955 :     int bits_in_accum;
; 1956 :     digit *pdigit;
; 1957 : 
; 1958 :     assert(base >= 2 && base <= 32 && (base & (base - 1)) == 0);

  00027	83 bc 24 88 00
	00 00 02	 cmp	 DWORD PTR base$[rsp], 2
  0002f	7c 22		 jl	 SHORT $LN16@long_from_
  00031	83 bc 24 88 00
	00 00 20	 cmp	 DWORD PTR base$[rsp], 32 ; 00000020H
  00039	7f 18		 jg	 SHORT $LN16@long_from_
  0003b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR base$[rsp]
  00042	ff c8		 dec	 eax
  00044	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR base$[rsp]
  0004b	23 c8		 and	 ecx, eax
  0004d	8b c1		 mov	 eax, ecx
  0004f	85 c0		 test	 eax, eax
  00051	74 1c		 je	 SHORT $LN17@long_from_
$LN16@long_from_:
  00053	41 b8 a6 07 00
	00		 mov	 r8d, 1958		; 000007a6H
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GI@PHNEBJOM@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA3?$AA2?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAb?$AAa?$AAs?$AAe@
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006d	33 c0		 xor	 eax, eax
$LN17@long_from_:

; 1959 :     n = base;

  0006f	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR base$[rsp]
  00077	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 1960 :     for (bits_per_char = -1; n; ++bits_per_char)

  0007c	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR bits_per_char$[rsp], -1
  00084	eb 0a		 jmp	 SHORT $LN13@long_from_
$LN12@long_from_:
  00086	8b 44 24 28	 mov	 eax, DWORD PTR bits_per_char$[rsp]
  0008a	ff c0		 inc	 eax
  0008c	89 44 24 28	 mov	 DWORD PTR bits_per_char$[rsp], eax
$LN13@long_from_:
  00090	48 83 7c 24 30
	00		 cmp	 QWORD PTR n$[rsp], 0
  00096	74 0f		 je	 SHORT $LN11@long_from_

; 1961 :         n >>= 1;

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0009d	48 d1 f8	 sar	 rax, 1
  000a0	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax
  000a5	eb df		 jmp	 SHORT $LN12@long_from_
$LN11@long_from_:
$LN10@long_from_:

; 1962 :     /* n <- total # of bits needed, while setting p to end-of-string */
; 1963 :     while (_PyLong_DigitValue[Py_CHARMASK(*p)] < base)

  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000ac	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000af	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b4	0f b6 c0	 movzx	 eax, al
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  000be	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c2	3b 84 24 88 00
	00 00		 cmp	 eax, DWORD PTR base$[rsp]
  000c9	7d 0f		 jge	 SHORT $LN9@long_from_

; 1964 :         ++p;

  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000d0	48 ff c0	 inc	 rax
  000d3	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  000d8	eb cd		 jmp	 SHORT $LN10@long_from_
$LN9@long_from_:

; 1965 :     *str = p;

  000da	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  000e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000e7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1966 :     /* n <- # of Python digits needed, = ceiling(n/PyLong_SHIFT). */
; 1967 :     n = (p - start) * bits_per_char + PyLong_SHIFT - 1;

  000ea	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  000ef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000f4	48 2b c8	 sub	 rcx, rax
  000f7	48 8b c1	 mov	 rax, rcx
  000fa	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR bits_per_char$[rsp]
  000ff	48 0f af c1	 imul	 rax, rcx
  00103	48 83 c0 1d	 add	 rax, 29
  00107	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 1968 :     if (n / bits_per_char < p - start) {

  0010c	48 63 44 24 28	 movsxd	 rax, DWORD PTR bits_per_char$[rsp]
  00111	48 89 44 24 68	 mov	 QWORD PTR tv90[rsp], rax
  00116	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0011b	48 99		 cdq
  0011d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv90[rsp]
  00122	48 f7 f9	 idiv	 rcx
  00125	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  0012a	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  0012f	48 2b d1	 sub	 rdx, rcx
  00132	48 8b ca	 mov	 rcx, rdx
  00135	48 3b c1	 cmp	 rax, rcx
  00138	7d 1a		 jge	 SHORT $LN8@long_from_

; 1969 :         PyErr_SetString(PyExc_ValueError,
; 1970 :                         "int string too large to convert");

  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KANPCKBN@int?5string?5too?5large?5to?5convert?$AA@
  00141	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00148	e8 00 00 00 00	 call	 PyErr_SetString

; 1971 :         return NULL;

  0014d	33 c0		 xor	 eax, eax
  0014f	e9 52 02 00 00	 jmp	 $LN14@long_from_
$LN8@long_from_:

; 1972 :     }
; 1973 :     n = n / PyLong_SHIFT;

  00154	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00159	48 99		 cdq
  0015b	b9 1e 00 00 00	 mov	 ecx, 30
  00160	48 f7 f9	 idiv	 rcx
  00163	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 1974 :     z = _PyLong_New(n);

  00168	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  0016d	e8 00 00 00 00	 call	 _PyLong_New
  00172	48 89 44 24 58	 mov	 QWORD PTR z$[rsp], rax

; 1975 :     if (z == NULL)

  00177	48 83 7c 24 58
	00		 cmp	 QWORD PTR z$[rsp], 0
  0017d	75 07		 jne	 SHORT $LN7@long_from_

; 1976 :         return NULL;

  0017f	33 c0		 xor	 eax, eax
  00181	e9 20 02 00 00	 jmp	 $LN14@long_from_
$LN7@long_from_:

; 1977 :     /* Read string from right, and fill in int from left; i.e.,
; 1978 :      * from least to most significant in both.
; 1979 :      */
; 1980 :     accum = 0;

  00186	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR accum$[rsp], 0

; 1981 :     bits_in_accum = 0;

  0018f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR bits_in_accum$[rsp], 0

; 1982 :     pdigit = z->ob_digit;

  00197	48 8b 44 24 58	 mov	 rax, QWORD PTR z$[rsp]
  0019c	48 83 c0 70	 add	 rax, 112		; 00000070H
  001a0	48 89 44 24 50	 mov	 QWORD PTR pdigit$[rsp], rax
$LN6@long_from_:

; 1983 :     while (--p >= start) {

  001a5	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001aa	48 ff c8	 dec	 rax
  001ad	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  001b2	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  001b7	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  001bc	0f 82 22 01 00
	00		 jb	 $LN5@long_from_

; 1984 :         int k = (int)_PyLong_DigitValue[Py_CHARMASK(*p)];

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001c7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001ca	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001cf	0f b6 c0	 movzx	 eax, al
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  001d9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001dd	89 44 24 60	 mov	 DWORD PTR k$22117[rsp], eax

; 1985 :         assert(k >= 0 && k < base);

  001e1	83 7c 24 60 00	 cmp	 DWORD PTR k$22117[rsp], 0
  001e6	7c 0d		 jl	 SHORT $LN18@long_from_
  001e8	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR base$[rsp]
  001ef	39 44 24 60	 cmp	 DWORD PTR k$22117[rsp], eax
  001f3	7c 1c		 jl	 SHORT $LN19@long_from_
$LN18@long_from_:
  001f5	41 b8 c1 07 00
	00		 mov	 r8d, 1985		; 000007c1H
  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@LAJDOMFE@?$AAk?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAk?$AA?5?$AA?$DM?$AA?5?$AAb?$AAa?$AAs?$AAe?$AA?$AA@
  00209	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0020f	33 c0		 xor	 eax, eax
$LN19@long_from_:

; 1986 :         accum |= (twodigits)k << bits_in_accum;

  00211	48 63 44 24 60	 movsxd	 rax, DWORD PTR k$22117[rsp]
  00216	8b 4c 24 38	 mov	 ecx, DWORD PTR bits_in_accum$[rsp]
  0021a	48 d3 e0	 shl	 rax, cl
  0021d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR accum$[rsp]
  00222	48 0b c8	 or	 rcx, rax
  00225	48 8b c1	 mov	 rax, rcx
  00228	48 89 44 24 40	 mov	 QWORD PTR accum$[rsp], rax

; 1987 :         bits_in_accum += bits_per_char;

  0022d	8b 44 24 28	 mov	 eax, DWORD PTR bits_per_char$[rsp]
  00231	8b 4c 24 38	 mov	 ecx, DWORD PTR bits_in_accum$[rsp]
  00235	03 c8		 add	 ecx, eax
  00237	8b c1		 mov	 eax, ecx
  00239	89 44 24 38	 mov	 DWORD PTR bits_in_accum$[rsp], eax

; 1988 :         if (bits_in_accum >= PyLong_SHIFT) {

  0023d	83 7c 24 38 1e	 cmp	 DWORD PTR bits_in_accum$[rsp], 30
  00242	0f 8c 97 00 00
	00		 jl	 $LN4@long_from_

; 1989 :             *pdigit++ = (digit)(accum & PyLong_MASK);

  00248	48 8b 44 24 40	 mov	 rax, QWORD PTR accum$[rsp]
  0024d	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  00253	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pdigit$[rsp]
  00258	89 01		 mov	 DWORD PTR [rcx], eax
  0025a	48 8b 44 24 50	 mov	 rax, QWORD PTR pdigit$[rsp]
  0025f	48 83 c0 04	 add	 rax, 4
  00263	48 89 44 24 50	 mov	 QWORD PTR pdigit$[rsp], rax

; 1990 :             assert(pdigit - z->ob_digit <= n);

  00268	48 8b 44 24 58	 mov	 rax, QWORD PTR z$[rsp]
  0026d	48 83 c0 70	 add	 rax, 112		; 00000070H
  00271	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pdigit$[rsp]
  00276	48 2b c8	 sub	 rcx, rax
  00279	48 8b c1	 mov	 rax, rcx
  0027c	48 c1 f8 02	 sar	 rax, 2
  00280	48 3b 44 24 30	 cmp	 rax, QWORD PTR n$[rsp]
  00285	7e 1c		 jle	 SHORT $LN20@long_from_
  00287	41 b8 c6 07 00
	00		 mov	 r8d, 1990		; 000007c6H
  0028d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00294	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@EAKAHKGM@?$AAp?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?9?$AA?5?$AAz?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?$AA@
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002a1	33 c0		 xor	 eax, eax
$LN20@long_from_:

; 1991 :             accum >>= PyLong_SHIFT;

  002a3	48 8b 44 24 40	 mov	 rax, QWORD PTR accum$[rsp]
  002a8	48 c1 e8 1e	 shr	 rax, 30
  002ac	48 89 44 24 40	 mov	 QWORD PTR accum$[rsp], rax

; 1992 :             bits_in_accum -= PyLong_SHIFT;

  002b1	8b 44 24 38	 mov	 eax, DWORD PTR bits_in_accum$[rsp]
  002b5	83 e8 1e	 sub	 eax, 30
  002b8	89 44 24 38	 mov	 DWORD PTR bits_in_accum$[rsp], eax

; 1993 :             assert(bits_in_accum < PyLong_SHIFT);

  002bc	83 7c 24 38 1e	 cmp	 DWORD PTR bits_in_accum$[rsp], 30
  002c1	7c 1c		 jl	 SHORT $LN21@long_from_
  002c3	41 b8 c9 07 00
	00		 mov	 r8d, 1993		; 000007c9H
  002c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@KCCIOCFM@?$AAb?$AAi?$AAt?$AAs?$AA_?$AAi?$AAn?$AA_?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002dd	33 c0		 xor	 eax, eax
$LN21@long_from_:
$LN4@long_from_:

; 1994 :         }
; 1995 :     }

  002df	e9 c1 fe ff ff	 jmp	 $LN6@long_from_
$LN5@long_from_:

; 1996 :     if (bits_in_accum) {

  002e4	83 7c 24 38 00	 cmp	 DWORD PTR bits_in_accum$[rsp], 0
  002e9	74 77		 je	 SHORT $LN3@long_from_

; 1997 :         assert(bits_in_accum <= PyLong_SHIFT);

  002eb	83 7c 24 38 1e	 cmp	 DWORD PTR bits_in_accum$[rsp], 30
  002f0	7e 1c		 jle	 SHORT $LN22@long_from_
  002f2	41 b8 cd 07 00
	00		 mov	 r8d, 1997		; 000007cdH
  002f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@MPHFGDG@?$AAb?$AAi?$AAt?$AAs?$AA_?$AAi?$AAn?$AA_?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@
  00306	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0030c	33 c0		 xor	 eax, eax
$LN22@long_from_:

; 1998 :         *pdigit++ = (digit)accum;

  0030e	48 8b 44 24 50	 mov	 rax, QWORD PTR pdigit$[rsp]
  00313	8b 4c 24 40	 mov	 ecx, DWORD PTR accum$[rsp]
  00317	89 08		 mov	 DWORD PTR [rax], ecx
  00319	48 8b 44 24 50	 mov	 rax, QWORD PTR pdigit$[rsp]
  0031e	48 83 c0 04	 add	 rax, 4
  00322	48 89 44 24 50	 mov	 QWORD PTR pdigit$[rsp], rax

; 1999 :         assert(pdigit - z->ob_digit <= n);

  00327	48 8b 44 24 58	 mov	 rax, QWORD PTR z$[rsp]
  0032c	48 83 c0 70	 add	 rax, 112		; 00000070H
  00330	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pdigit$[rsp]
  00335	48 2b c8	 sub	 rcx, rax
  00338	48 8b c1	 mov	 rax, rcx
  0033b	48 c1 f8 02	 sar	 rax, 2
  0033f	48 3b 44 24 30	 cmp	 rax, QWORD PTR n$[rsp]
  00344	7e 1c		 jle	 SHORT $LN23@long_from_
  00346	41 b8 cf 07 00
	00		 mov	 r8d, 1999		; 000007cfH
  0034c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00353	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@EAKAHKGM@?$AAp?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?9?$AA?5?$AAz?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?$AA@
  0035a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00360	33 c0		 xor	 eax, eax
$LN23@long_from_:
$LN3@long_from_:
$LN2@long_from_:

; 2000 :     }
; 2001 :     while (pdigit - z->ob_digit < n)

  00362	48 8b 44 24 58	 mov	 rax, QWORD PTR z$[rsp]
  00367	48 83 c0 70	 add	 rax, 112		; 00000070H
  0036b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pdigit$[rsp]
  00370	48 2b c8	 sub	 rcx, rax
  00373	48 8b c1	 mov	 rax, rcx
  00376	48 c1 f8 02	 sar	 rax, 2
  0037a	48 3b 44 24 30	 cmp	 rax, QWORD PTR n$[rsp]
  0037f	7d 1b		 jge	 SHORT $LN1@long_from_

; 2002 :         *pdigit++ = 0;

  00381	48 8b 44 24 50	 mov	 rax, QWORD PTR pdigit$[rsp]
  00386	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  0038c	48 8b 44 24 50	 mov	 rax, QWORD PTR pdigit$[rsp]
  00391	48 83 c0 04	 add	 rax, 4
  00395	48 89 44 24 50	 mov	 QWORD PTR pdigit$[rsp], rax
  0039a	eb c6		 jmp	 SHORT $LN2@long_from_
$LN1@long_from_:

; 2003 :     return long_normalize(z);

  0039c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR z$[rsp]
  003a1	e8 00 00 00 00	 call	 long_normalize
$LN14@long_from_:

; 2004 : }

  003a6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003aa	c3		 ret	 0
long_from_binary_base ENDP
_TEXT	ENDS
PUBLIC	_PyLong_FromBytes
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_FromBytes DD imagerel $LN12
	DD	imagerel $LN12+229
	DD	imagerel $unwind$_PyLong_FromBytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_FromBytes DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyLong_FromBytes
_TEXT	SEGMENT
end$ = 32
strobj$ = 40
result$ = 48
tv77 = 56
s$ = 80
len$ = 88
base$ = 96
_PyLong_FromBytes PROC					; COMDAT

; 2306 : {

$LN12:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2307 :     PyObject *result, *strobj;
; 2308 :     char *end = NULL;

  00013	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR end$[rsp], 0

; 2309 : 
; 2310 :     result = PyLong_FromString((char*)s, &end, base);

  0001c	44 8b 44 24 60	 mov	 r8d, DWORD PTR base$[rsp]
  00021	48 8d 54 24 20	 lea	 rdx, QWORD PTR end$[rsp]
  00026	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0002b	e8 00 00 00 00	 call	 PyLong_FromString
  00030	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 2311 :     if (end == NULL || (result != NULL && end == s + len))

  00035	48 83 7c 24 20
	00		 cmp	 QWORD PTR end$[rsp], 0
  0003b	74 1f		 je	 SHORT $LN6@PyLong_Fro@12
  0003d	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00043	74 1e		 je	 SHORT $LN7@PyLong_Fro@12
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  0004a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0004f	48 03 c8	 add	 rcx, rax
  00052	48 8b c1	 mov	 rax, rcx
  00055	48 39 44 24 20	 cmp	 QWORD PTR end$[rsp], rax
  0005a	75 07		 jne	 SHORT $LN7@PyLong_Fro@12
$LN6@PyLong_Fro@12:

; 2312 :         return result;

  0005c	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  00061	eb 7d		 jmp	 SHORT $LN8@PyLong_Fro@12
$LN7@PyLong_Fro@12:
$LN5@PyLong_Fro@12:

; 2313 :     Py_XDECREF(result);

  00063	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00069	74 0a		 je	 SHORT $LN2@PyLong_Fro@12
  0006b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00070	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PyLong_Fro@12:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 e8		 jne	 SHORT $LN5@PyLong_Fro@12

; 2314 :     strobj = PyBytes_FromStringAndSize(s, Py_MIN(len, 200));

  0007b	48 81 7c 24 58
	c8 00 00 00	 cmp	 QWORD PTR len$[rsp], 200 ; 000000c8H
  00084	7e 0b		 jle	 SHORT $LN10@PyLong_Fro@12
  00086	48 c7 44 24 38
	c8 00 00 00	 mov	 QWORD PTR tv77[rsp], 200 ; 000000c8H
  0008f	eb 0a		 jmp	 SHORT $LN11@PyLong_Fro@12
$LN10@PyLong_Fro@12:
  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  00096	48 89 44 24 38	 mov	 QWORD PTR tv77[rsp], rax
$LN11@PyLong_Fro@12:
  0009b	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv77[rsp]
  000a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000a5	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000aa	48 89 44 24 28	 mov	 QWORD PTR strobj$[rsp], rax

; 2315 :     if (strobj != NULL) {

  000af	48 83 7c 24 28
	00		 cmp	 QWORD PTR strobj$[rsp], 0
  000b5	74 27		 je	 SHORT $LN1@PyLong_Fro@12

; 2316 :         PyErr_Format(PyExc_ValueError,
; 2317 :                      "invalid literal for int() with base %d: %R",
; 2318 :                      base, strobj);

  000b7	4c 8b 4c 24 28	 mov	 r9, QWORD PTR strobj$[rsp]
  000bc	44 8b 44 24 60	 mov	 r8d, DWORD PTR base$[rsp]
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@
  000c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000cf	e8 00 00 00 00	 call	 PyErr_Format

; 2319 :         Py_DECREF(strobj);

  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strobj$[rsp]
  000d9	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyLong_Fro@12:

; 2320 :     }
; 2321 :     return NULL;

  000de	33 c0		 xor	 eax, eax
$LN8@PyLong_Fro@12:

; 2322 : }

  000e0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e4	c3		 ret	 0
_PyLong_FromBytes ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromUnicodeObject
PUBLIC	PyLong_FromUnicode
EXTRN	PyUnicode_FromUnicode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromUnicode DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$PyLong_FromUnicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromUnicode DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_FromUnicode
_TEXT	SEGMENT
v$ = 32
unicode$ = 40
u$ = 64
length$ = 72
base$ = 80
PyLong_FromUnicode PROC					; COMDAT

; 2326 : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2327 :     PyObject *v, *unicode = PyUnicode_FromUnicode(u, length);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR length$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR u$[rsp]
  0001d	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  00022	48 89 44 24 28	 mov	 QWORD PTR unicode$[rsp], rax

; 2328 :     if (unicode == NULL)

  00027	48 83 7c 24 28
	00		 cmp	 QWORD PTR unicode$[rsp], 0
  0002d	75 04		 jne	 SHORT $LN1@PyLong_Fro@13

; 2329 :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 22		 jmp	 SHORT $LN2@PyLong_Fro@13
$LN1@PyLong_Fro@13:

; 2330 :     v = PyLong_FromUnicodeObject(unicode, base);

  00033	8b 54 24 50	 mov	 edx, DWORD PTR base$[rsp]
  00037	48 8b 4c 24 28	 mov	 rcx, QWORD PTR unicode$[rsp]
  0003c	e8 00 00 00 00	 call	 PyLong_FromUnicodeObject
  00041	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2331 :     Py_DECREF(unicode);

  00046	48 8b 4c 24 28	 mov	 rcx, QWORD PTR unicode$[rsp]
  0004b	e8 00 00 00 00	 call	 _Py_DecRef

; 2332 :     return v;

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN2@PyLong_Fro@13:

; 2333 : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
PyLong_FromUnicode ENDP
_TEXT	ENDS
EXTRN	PySequence_GetSlice:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_UnicodeEncodeError:QWORD
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	_PyUnicode_TransformDecimalAndSpaceToASCII:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromUnicodeObject DD imagerel $LN14
	DD	imagerel $LN14+307
	DD	imagerel $unwind$PyLong_FromUnicodeObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromUnicodeObject DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_FromUnicodeObject
_TEXT	SEGMENT
buflen$ = 32
asciidig$ = 40
end$ = 48
strobj$ = 56
result$ = 64
buffer$ = 72
u$ = 96
base$ = 104
PyLong_FromUnicodeObject PROC				; COMDAT

; 2337 : {

$LN14:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2338 :     PyObject *result, *asciidig, *strobj;
; 2339 :     char *buffer, *end = NULL;

  0000d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR end$[rsp], 0

; 2340 :     Py_ssize_t buflen;
; 2341 : 
; 2342 :     asciidig = _PyUnicode_TransformDecimalAndSpaceToASCII(u);

  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR u$[rsp]
  0001b	e8 00 00 00 00	 call	 _PyUnicode_TransformDecimalAndSpaceToASCII
  00020	48 89 44 24 28	 mov	 QWORD PTR asciidig$[rsp], rax

; 2343 :     if (asciidig == NULL)

  00025	48 83 7c 24 28
	00		 cmp	 QWORD PTR asciidig$[rsp], 0
  0002b	75 07		 jne	 SHORT $LN11@PyLong_Fro@14

; 2344 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 fa 00 00 00	 jmp	 $LN12@PyLong_Fro@14
$LN11@PyLong_Fro@14:

; 2345 :     buffer = PyUnicode_AsUTF8AndSize(asciidig, &buflen);

  00034	48 8d 54 24 20	 lea	 rdx, QWORD PTR buflen$[rsp]
  00039	48 8b 4c 24 28	 mov	 rcx, QWORD PTR asciidig$[rsp]
  0003e	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  00043	48 89 44 24 48	 mov	 QWORD PTR buffer$[rsp], rax

; 2346 :     if (buffer == NULL) {

  00048	48 83 7c 24 48
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  0004e	75 23		 jne	 SHORT $LN10@PyLong_Fro@14

; 2347 :         Py_DECREF(asciidig);

  00050	48 8b 4c 24 28	 mov	 rcx, QWORD PTR asciidig$[rsp]
  00055	e8 00 00 00 00	 call	 _Py_DecRef

; 2348 :         if (!PyErr_ExceptionMatches(PyExc_UnicodeEncodeError))

  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeEncodeError
  00061	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00066	85 c0		 test	 eax, eax
  00068	75 07		 jne	 SHORT $LN9@PyLong_Fro@14

; 2349 :             return NULL;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 bd 00 00 00	 jmp	 $LN12@PyLong_Fro@14
$LN9@PyLong_Fro@14:

; 2350 :     }
; 2351 :     else {

  00071	eb 73		 jmp	 SHORT $LN8@PyLong_Fro@14
$LN10@PyLong_Fro@14:

; 2352 :         result = PyLong_FromString(buffer, &end, base);

  00073	44 8b 44 24 68	 mov	 r8d, DWORD PTR base$[rsp]
  00078	48 8d 54 24 30	 lea	 rdx, QWORD PTR end$[rsp]
  0007d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  00082	e8 00 00 00 00	 call	 PyLong_FromString
  00087	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 2353 :         if (end == NULL || (result != NULL && end == buffer + buflen)) {

  0008c	48 83 7c 24 30
	00		 cmp	 QWORD PTR end$[rsp], 0
  00092	74 1f		 je	 SHORT $LN6@PyLong_Fro@14
  00094	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$[rsp], 0
  0009a	74 28		 je	 SHORT $LN7@PyLong_Fro@14
  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR buflen$[rsp]
  000a1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  000a6	48 03 c8	 add	 rcx, rax
  000a9	48 8b c1	 mov	 rax, rcx
  000ac	48 39 44 24 30	 cmp	 QWORD PTR end$[rsp], rax
  000b1	75 11		 jne	 SHORT $LN7@PyLong_Fro@14
$LN6@PyLong_Fro@14:

; 2354 :             Py_DECREF(asciidig);

  000b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR asciidig$[rsp]
  000b8	e8 00 00 00 00	 call	 _Py_DecRef

; 2355 :             return result;

  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  000c2	eb 6a		 jmp	 SHORT $LN12@PyLong_Fro@14
$LN7@PyLong_Fro@14:

; 2356 :         }
; 2357 :         Py_DECREF(asciidig);

  000c4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR asciidig$[rsp]
  000c9	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@PyLong_Fro@14:

; 2358 :         Py_XDECREF(result);

  000ce	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$[rsp], 0
  000d4	74 0a		 je	 SHORT $LN2@PyLong_Fro@14
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  000db	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PyLong_Fro@14:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 e8		 jne	 SHORT $LN5@PyLong_Fro@14
$LN8@PyLong_Fro@14:

; 2359 :     }
; 2360 :     strobj = PySequence_GetSlice(u, 0, 200);

  000e6	41 b8 c8 00 00
	00		 mov	 r8d, 200		; 000000c8H
  000ec	33 d2		 xor	 edx, edx
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR u$[rsp]
  000f3	e8 00 00 00 00	 call	 PySequence_GetSlice
  000f8	48 89 44 24 38	 mov	 QWORD PTR strobj$[rsp], rax

; 2361 :     if (strobj != NULL) {

  000fd	48 83 7c 24 38
	00		 cmp	 QWORD PTR strobj$[rsp], 0
  00103	74 27		 je	 SHORT $LN1@PyLong_Fro@14

; 2362 :         PyErr_Format(PyExc_ValueError,
; 2363 :                      "invalid literal for int() with base %d: %R",
; 2364 :                      base, strobj);

  00105	4c 8b 4c 24 38	 mov	 r9, QWORD PTR strobj$[rsp]
  0010a	44 8b 44 24 68	 mov	 r8d, DWORD PTR base$[rsp]
  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@
  00116	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0011d	e8 00 00 00 00	 call	 PyErr_Format

; 2365 :         Py_DECREF(strobj);

  00122	48 8b 4c 24 38	 mov	 rcx, QWORD PTR strobj$[rsp]
  00127	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyLong_Fro@14:

; 2366 :     }
; 2367 :     return NULL;

  0012c	33 c0		 xor	 eax, eax
$LN12@PyLong_Fro@14:

; 2368 : }

  0012e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00132	c3		 ret	 0
PyLong_FromUnicodeObject ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_0DE@KPOPPGPJ@huge?5integer?3?5number?5of?5bits?5ove@ ; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4360000000000000
PUBLIC	??_C@_1HO@LCANCJLI@?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi@ ; `string'
PUBLIC	_PyLong_Frexp
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_Frexp DD imagerel $LN25
	DD	imagerel $LN25+1016
	DD	imagerel $unwind$_PyLong_Frexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_Frexp DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_0DE@KPOPPGPJ@huge?5integer?3?5number?5of?5bits?5ove@
CONST	SEGMENT
??_C@_0DE@KPOPPGPJ@huge?5integer?3?5number?5of?5bits?5ove@ DB 'huge integ'
	DB	'er: number of bits overflows a Py_ssize_t', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4360000000000000
CONST	SEGMENT
__real@4360000000000000 DQ 04360000000000000r	; 3.60288e+016
CONST	ENDS
;	COMDAT ??_C@_1HO@LCANCJLI@?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi@
CONST	SEGMENT
??_C@_1HO@LCANCJLI@?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi@ DB '1'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, '_', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'x', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '(', 00H, 'P'
	DB	00H, 'y', 00H, '_', 00H, 's', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, '_', 00H, 't', 00H, ')', 00H, 'P', 00H, 'y', 00H, '_'
	DB	00H, 'A', 00H, 'R', 00H, 'R', 00H, 'A', 00H, 'Y', 00H, '_', 00H
	DB	'L', 00H, 'E', 00H, 'N', 00H, 'G', 00H, 'T', 00H, 'H', 00H, '('
	DB	00H, 'x', 00H, '_', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, ')', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_Frexp
_TEXT	SEGMENT
x_size$ = 32
rem$ = 40
a_bits$ = 48
shift_bits$ = 56
a_size$ = 64
shift_digits$ = 72
dx$ = 80
x_digits$ = 88
tv69 = 104
tv191 = 112
a$ = 144
e$ = 152
_PyLong_Frexp PROC					; COMDAT

; 2571 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2572 :     Py_ssize_t a_size, a_bits, shift_digits, shift_bits, x_size;
; 2573 :     /* See below for why x_digits is always large enough. */
; 2574 :     digit rem, x_digits[2 + (DBL_MANT_DIG + 1) / PyLong_SHIFT];
; 2575 :     double dx;
; 2576 :     /* Correction term for round-half-to-even rounding.  For a digit x,
; 2577 :        "x + half_even_correction[x & 7]" gives x rounded to the nearest
; 2578 :        multiple of 4, rounding ties to a multiple of 8. */
; 2579 :     static const int half_even_correction[8] = {0, -1, -2, 1, 0, -1, 2, 1};
; 2580 : 
; 2581 :     a_size = ABS(Py_SIZE(a));

  00011	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00019	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001e	7d 16		 jge	 SHORT $LN19@PyLong_Fre
  00020	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00028	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002c	48 f7 d8	 neg	 rax
  0002f	48 89 44 24 68	 mov	 QWORD PTR tv69[rsp], rax
  00034	eb 11		 jmp	 SHORT $LN20@PyLong_Fre
$LN19@PyLong_Fre:
  00036	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0003e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00042	48 89 44 24 68	 mov	 QWORD PTR tv69[rsp], rax
$LN20@PyLong_Fre:
  00047	48 8b 44 24 68	 mov	 rax, QWORD PTR tv69[rsp]
  0004c	48 89 44 24 40	 mov	 QWORD PTR a_size$[rsp], rax

; 2582 :     if (a_size == 0) {

  00051	48 83 7c 24 40
	00		 cmp	 QWORD PTR a_size$[rsp], 0
  00057	75 18		 jne	 SHORT $LN16@PyLong_Fre

; 2583 :         /* Special case for 0: significand 0.0, exponent 0. */
; 2584 :         *e = 0;

  00059	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00061	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2585 :         return 0.0;

  00068	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0006c	e9 7f 03 00 00	 jmp	 $LN17@PyLong_Fre
$LN16@PyLong_Fre:

; 2586 :     }
; 2587 :     a_bits = bits_in_digit(a->ob_digit[a_size-1]);

  00071	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a_size$[rsp]
  0007e	8b 4c 88 6c	 mov	 ecx, DWORD PTR [rax+rcx*4+108]
  00082	e8 00 00 00 00	 call	 bits_in_digit
  00087	48 98		 cdqe
  00089	48 89 44 24 30	 mov	 QWORD PTR a_bits$[rsp], rax

; 2588 :     /* The following is an overflow-free version of the check
; 2589 :        "if ((a_size - 1) * PyLong_SHIFT + a_bits > PY_SSIZE_T_MAX) ..." */
; 2590 :     if (a_size >= (PY_SSIZE_T_MAX - 1) / PyLong_SHIFT + 1 &&
; 2591 :         (a_size > (PY_SSIZE_T_MAX - 1) / PyLong_SHIFT + 1 ||
; 2592 :          a_bits > (PY_SSIZE_T_MAX - 1) % PyLong_SHIFT + 1))

  0008e	48 b8 45 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825861	; 0444444444444445H
  00098	48 39 44 24 40	 cmp	 QWORD PTR a_size$[rsp], rax
  0009d	7c 1e		 jl	 SHORT $LN15@PyLong_Fre
  0009f	48 b8 45 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825861	; 0444444444444445H
  000a9	48 39 44 24 40	 cmp	 QWORD PTR a_size$[rsp], rax
  000ae	7f 08		 jg	 SHORT $LN14@PyLong_Fre
  000b0	48 83 7c 24 30
	07		 cmp	 QWORD PTR a_bits$[rsp], 7
  000b6	7e 05		 jle	 SHORT $LN15@PyLong_Fre
$LN14@PyLong_Fre:

; 2593 :         goto overflow;

  000b8	e9 09 03 00 00	 jmp	 $overflow$22605
$LN15@PyLong_Fre:

; 2594 :     a_bits = (a_size - 1) * PyLong_SHIFT + a_bits;

  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR a_size$[rsp]
  000c2	48 ff c8	 dec	 rax
  000c5	48 6b c0 1e	 imul	 rax, 30
  000c9	48 03 44 24 30	 add	 rax, QWORD PTR a_bits$[rsp]
  000ce	48 89 44 24 30	 mov	 QWORD PTR a_bits$[rsp], rax

; 2595 : 
; 2596 :     /* Shift the first DBL_MANT_DIG + 2 bits of a into x_digits[0:x_size]
; 2597 :        (shifting left if a_bits <= DBL_MANT_DIG + 2).
; 2598 : 
; 2599 :        Number of digits needed for result: write // for floor division.
; 2600 :        Then if shifting left, we end up using
; 2601 : 
; 2602 :          1 + a_size + (DBL_MANT_DIG + 2 - a_bits) // PyLong_SHIFT
; 2603 : 
; 2604 :        digits.  If shifting right, we use
; 2605 : 
; 2606 :          a_size - (a_bits - DBL_MANT_DIG - 2) // PyLong_SHIFT
; 2607 : 
; 2608 :        digits.  Using a_size = 1 + (a_bits - 1) // PyLong_SHIFT along with
; 2609 :        the inequalities
; 2610 : 
; 2611 :          m // PyLong_SHIFT + n // PyLong_SHIFT <= (m + n) // PyLong_SHIFT
; 2612 :          m // PyLong_SHIFT - n // PyLong_SHIFT <=
; 2613 :                                           1 + (m - n - 1) // PyLong_SHIFT,
; 2614 : 
; 2615 :        valid for any integers m and n, we find that x_size satisfies
; 2616 : 
; 2617 :          x_size <= 2 + (DBL_MANT_DIG + 1) // PyLong_SHIFT
; 2618 : 
; 2619 :        in both cases.
; 2620 :     */
; 2621 :     if (a_bits <= DBL_MANT_DIG + 2) {

  000d3	48 83 7c 24 30
	37		 cmp	 QWORD PTR a_bits$[rsp], 55 ; 00000037H
  000d9	0f 8f c6 00 00
	00		 jg	 $LN13@PyLong_Fre

; 2622 :         shift_digits = (DBL_MANT_DIG + 2 - a_bits) / PyLong_SHIFT;

  000df	b8 37 00 00 00	 mov	 eax, 55			; 00000037H
  000e4	48 2b 44 24 30	 sub	 rax, QWORD PTR a_bits$[rsp]
  000e9	48 99		 cdq
  000eb	b9 1e 00 00 00	 mov	 ecx, 30
  000f0	48 f7 f9	 idiv	 rcx
  000f3	48 89 44 24 48	 mov	 QWORD PTR shift_digits$[rsp], rax

; 2623 :         shift_bits = (DBL_MANT_DIG + 2 - a_bits) % PyLong_SHIFT;

  000f8	b8 37 00 00 00	 mov	 eax, 55			; 00000037H
  000fd	48 2b 44 24 30	 sub	 rax, QWORD PTR a_bits$[rsp]
  00102	48 99		 cdq
  00104	b9 1e 00 00 00	 mov	 ecx, 30
  00109	48 f7 f9	 idiv	 rcx
  0010c	48 8b c2	 mov	 rax, rdx
  0010f	48 89 44 24 38	 mov	 QWORD PTR shift_bits$[rsp], rax

; 2624 :         x_size = 0;

  00114	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR x_size$[rsp], 0
$LN12@PyLong_Fre:

; 2625 :         while (x_size < shift_digits)

  0011d	48 8b 44 24 48	 mov	 rax, QWORD PTR shift_digits$[rsp]
  00122	48 39 44 24 20	 cmp	 QWORD PTR x_size$[rsp], rax
  00127	7d 1c		 jge	 SHORT $LN11@PyLong_Fre

; 2626 :             x_digits[x_size++] = 0;

  00129	48 8b 44 24 20	 mov	 rax, QWORD PTR x_size$[rsp]
  0012e	c7 44 84 58 00
	00 00 00	 mov	 DWORD PTR x_digits$[rsp+rax*4], 0
  00136	48 8b 44 24 20	 mov	 rax, QWORD PTR x_size$[rsp]
  0013b	48 ff c0	 inc	 rax
  0013e	48 89 44 24 20	 mov	 QWORD PTR x_size$[rsp], rax
  00143	eb d8		 jmp	 SHORT $LN12@PyLong_Fre
$LN11@PyLong_Fre:

; 2627 :         rem = v_lshift(x_digits + x_size, a->ob_digit, a_size,
; 2628 :                        (int)shift_bits);

  00145	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0014d	48 83 c0 70	 add	 rax, 112		; 00000070H
  00151	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x_size$[rsp]
  00156	48 8d 4c 8c 58	 lea	 rcx, QWORD PTR x_digits$[rsp+rcx*4]
  0015b	44 8b 4c 24 38	 mov	 r9d, DWORD PTR shift_bits$[rsp]
  00160	4c 8b 44 24 40	 mov	 r8, QWORD PTR a_size$[rsp]
  00165	48 8b d0	 mov	 rdx, rax
  00168	e8 00 00 00 00	 call	 v_lshift
  0016d	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 2629 :         x_size += a_size;

  00171	48 8b 44 24 40	 mov	 rax, QWORD PTR a_size$[rsp]
  00176	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x_size$[rsp]
  0017b	48 03 c8	 add	 rcx, rax
  0017e	48 8b c1	 mov	 rax, rcx
  00181	48 89 44 24 20	 mov	 QWORD PTR x_size$[rsp], rax

; 2630 :         x_digits[x_size++] = rem;

  00186	48 8b 44 24 20	 mov	 rax, QWORD PTR x_size$[rsp]
  0018b	8b 4c 24 28	 mov	 ecx, DWORD PTR rem$[rsp]
  0018f	89 4c 84 58	 mov	 DWORD PTR x_digits$[rsp+rax*4], ecx
  00193	48 8b 44 24 20	 mov	 rax, QWORD PTR x_size$[rsp]
  00198	48 ff c0	 inc	 rax
  0019b	48 89 44 24 20	 mov	 QWORD PTR x_size$[rsp], rax

; 2631 :     }
; 2632 :     else {

  001a0	e9 cf 00 00 00	 jmp	 $LN10@PyLong_Fre
$LN13@PyLong_Fre:

; 2633 :         shift_digits = (a_bits - DBL_MANT_DIG - 2) / PyLong_SHIFT;

  001a5	48 8b 44 24 30	 mov	 rax, QWORD PTR a_bits$[rsp]
  001aa	48 83 e8 37	 sub	 rax, 55			; 00000037H
  001ae	48 99		 cdq
  001b0	b9 1e 00 00 00	 mov	 ecx, 30
  001b5	48 f7 f9	 idiv	 rcx
  001b8	48 89 44 24 48	 mov	 QWORD PTR shift_digits$[rsp], rax

; 2634 :         shift_bits = (a_bits - DBL_MANT_DIG - 2) % PyLong_SHIFT;

  001bd	48 8b 44 24 30	 mov	 rax, QWORD PTR a_bits$[rsp]
  001c2	48 83 e8 37	 sub	 rax, 55			; 00000037H
  001c6	48 99		 cdq
  001c8	b9 1e 00 00 00	 mov	 ecx, 30
  001cd	48 f7 f9	 idiv	 rcx
  001d0	48 8b c2	 mov	 rax, rdx
  001d3	48 89 44 24 38	 mov	 QWORD PTR shift_bits$[rsp], rax

; 2635 :         rem = v_rshift(x_digits, a->ob_digit + shift_digits,
; 2636 :                        a_size - shift_digits, (int)shift_bits);

  001d8	48 8b 44 24 48	 mov	 rax, QWORD PTR shift_digits$[rsp]
  001dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a_size$[rsp]
  001e2	48 2b c8	 sub	 rcx, rax
  001e5	48 8b c1	 mov	 rax, rcx
  001e8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001f0	48 8b 54 24 48	 mov	 rdx, QWORD PTR shift_digits$[rsp]
  001f5	48 8d 4c 91 70	 lea	 rcx, QWORD PTR [rcx+rdx*4+112]
  001fa	44 8b 4c 24 38	 mov	 r9d, DWORD PTR shift_bits$[rsp]
  001ff	4c 8b c0	 mov	 r8, rax
  00202	48 8b d1	 mov	 rdx, rcx
  00205	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x_digits$[rsp]
  0020a	e8 00 00 00 00	 call	 v_rshift
  0020f	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 2637 :         x_size = a_size - shift_digits;

  00213	48 8b 44 24 48	 mov	 rax, QWORD PTR shift_digits$[rsp]
  00218	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a_size$[rsp]
  0021d	48 2b c8	 sub	 rcx, rax
  00220	48 8b c1	 mov	 rax, rcx
  00223	48 89 44 24 20	 mov	 QWORD PTR x_size$[rsp], rax

; 2638 :         /* For correct rounding below, we need the least significant
; 2639 :            bit of x to be 'sticky' for this shift: if any of the bits
; 2640 :            shifted out was nonzero, we set the least significant bit
; 2641 :            of x. */
; 2642 :         if (rem)

  00228	83 7c 24 28 00	 cmp	 DWORD PTR rem$[rsp], 0
  0022d	74 0d		 je	 SHORT $LN9@PyLong_Fre

; 2643 :             x_digits[0] |= 1;

  0022f	8b 44 24 58	 mov	 eax, DWORD PTR x_digits$[rsp]
  00233	83 c8 01	 or	 eax, 1
  00236	89 44 24 58	 mov	 DWORD PTR x_digits$[rsp], eax

; 2644 :         else

  0023a	eb 38		 jmp	 SHORT $LN8@PyLong_Fre
$LN9@PyLong_Fre:
$LN7@PyLong_Fre:

; 2645 :             while (shift_digits > 0)

  0023c	48 83 7c 24 48
	00		 cmp	 QWORD PTR shift_digits$[rsp], 0
  00242	7e 30		 jle	 SHORT $LN6@PyLong_Fre

; 2646 :                 if (a->ob_digit[--shift_digits]) {

  00244	48 8b 44 24 48	 mov	 rax, QWORD PTR shift_digits$[rsp]
  00249	48 ff c8	 dec	 rax
  0024c	48 89 44 24 48	 mov	 QWORD PTR shift_digits$[rsp], rax
  00251	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00259	48 8b 4c 24 48	 mov	 rcx, QWORD PTR shift_digits$[rsp]
  0025e	83 7c 88 70 00	 cmp	 DWORD PTR [rax+rcx*4+112], 0
  00263	74 0d		 je	 SHORT $LN5@PyLong_Fre

; 2647 :                     x_digits[0] |= 1;

  00265	8b 44 24 58	 mov	 eax, DWORD PTR x_digits$[rsp]
  00269	83 c8 01	 or	 eax, 1
  0026c	89 44 24 58	 mov	 DWORD PTR x_digits$[rsp], eax

; 2648 :                     break;

  00270	eb 02		 jmp	 SHORT $LN6@PyLong_Fre
$LN5@PyLong_Fre:

; 2649 :                 }
; 2650 :     }

  00272	eb c8		 jmp	 SHORT $LN7@PyLong_Fre
$LN6@PyLong_Fre:
$LN8@PyLong_Fre:
$LN10@PyLong_Fre:

; 2651 :     assert(1 <= x_size && x_size <= (Py_ssize_t)Py_ARRAY_LENGTH(x_digits));

  00274	48 83 7c 24 20
	01		 cmp	 QWORD PTR x_size$[rsp], 1
  0027a	7c 08		 jl	 SHORT $LN21@PyLong_Fre
  0027c	48 83 7c 24 20
	03		 cmp	 QWORD PTR x_size$[rsp], 3
  00282	7e 1c		 jle	 SHORT $LN22@PyLong_Fre
$LN21@PyLong_Fre:
  00284	41 b8 5b 0a 00
	00		 mov	 r8d, 2651		; 00000a5bH
  0028a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00291	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HO@LCANCJLI@?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi@
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0029e	33 c0		 xor	 eax, eax
$LN22@PyLong_Fre:

; 2652 : 
; 2653 :     /* Round, and convert to double. */
; 2654 :     x_digits[0] += half_even_correction[x_digits[0] & 7];

  002a0	8b 44 24 58	 mov	 eax, DWORD PTR x_digits$[rsp]
  002a4	83 e0 07	 and	 eax, 7
  002a7	8b c0		 mov	 eax, eax
  002a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?half_even_correction@?1??_PyLong_Frexp@@9@9
  002b0	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  002b3	8b 4c 24 58	 mov	 ecx, DWORD PTR x_digits$[rsp]
  002b7	03 c8		 add	 ecx, eax
  002b9	8b c1		 mov	 eax, ecx
  002bb	89 44 24 58	 mov	 DWORD PTR x_digits$[rsp], eax

; 2655 :     dx = x_digits[--x_size];

  002bf	48 8b 44 24 20	 mov	 rax, QWORD PTR x_size$[rsp]
  002c4	48 ff c8	 dec	 rax
  002c7	48 89 44 24 20	 mov	 QWORD PTR x_size$[rsp], rax
  002cc	48 8b 44 24 20	 mov	 rax, QWORD PTR x_size$[rsp]
  002d1	8b 44 84 58	 mov	 eax, DWORD PTR x_digits$[rsp+rax*4]
  002d5	66 0f ef c0	 pxor	 xmm0, xmm0
  002d9	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  002de	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR dx$[rsp], xmm0
$LN4@PyLong_Fre:

; 2656 :     while (x_size > 0)

  002e4	48 83 7c 24 20
	00		 cmp	 QWORD PTR x_size$[rsp], 0
  002ea	7e 3d		 jle	 SHORT $LN3@PyLong_Fre

; 2657 :         dx = dx * PyLong_BASE + x_digits[--x_size];

  002ec	48 8b 44 24 20	 mov	 rax, QWORD PTR x_size$[rsp]
  002f1	48 ff c8	 dec	 rax
  002f4	48 89 44 24 20	 mov	 QWORD PTR x_size$[rsp], rax
  002f9	48 8b 44 24 20	 mov	 rax, QWORD PTR x_size$[rsp]
  002fe	8b 44 84 58	 mov	 eax, DWORD PTR x_digits$[rsp+rax*4]
  00302	66 0f ef c0	 pxor	 xmm0, xmm0
  00306	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0030b	f2 0f 10 4c 24
	50		 movsdx	 xmm1, QWORD PTR dx$[rsp]
  00311	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@41d0000000000000
  00319	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0031d	66 0f 28 c1	 movapd	 xmm0, xmm1
  00321	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR dx$[rsp], xmm0
  00327	eb bb		 jmp	 SHORT $LN4@PyLong_Fre
$LN3@PyLong_Fre:

; 2658 : 
; 2659 :     /* Rescale;  make correction if result is 1.0. */
; 2660 :     dx /= 4.0 * EXP2_DBL_MANT_DIG;

  00329	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR dx$[rsp]
  0032f	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4360000000000000
  00337	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR dx$[rsp], xmm0

; 2661 :     if (dx == 1.0) {

  0033d	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR dx$[rsp]
  00343	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  0034b	7a 30		 jp	 SHORT $LN2@PyLong_Fre
  0034d	75 2e		 jne	 SHORT $LN2@PyLong_Fre

; 2662 :         if (a_bits == PY_SSIZE_T_MAX)

  0034f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00359	48 39 44 24 30	 cmp	 QWORD PTR a_bits$[rsp], rax
  0035e	75 02		 jne	 SHORT $LN1@PyLong_Fre

; 2663 :             goto overflow;

  00360	eb 64		 jmp	 SHORT $overflow$22605
$LN1@PyLong_Fre:

; 2664 :         dx = 0.5;

  00362	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3fe0000000000000
  0036a	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR dx$[rsp], xmm0

; 2665 :         a_bits += 1;

  00370	48 8b 44 24 30	 mov	 rax, QWORD PTR a_bits$[rsp]
  00375	48 ff c0	 inc	 rax
  00378	48 89 44 24 30	 mov	 QWORD PTR a_bits$[rsp], rax
$LN2@PyLong_Fre:

; 2666 :     }
; 2667 : 
; 2668 :     *e = a_bits;

  0037d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00385	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a_bits$[rsp]
  0038a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2669 :     return Py_SIZE(a) < 0 ? -dx : dx;

  0038d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00395	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0039a	7d 16		 jge	 SHORT $LN23@PyLong_Fre
  0039c	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR dx$[rsp]
  003a2	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  003aa	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR tv191[rsp], xmm0
  003b0	eb 0c		 jmp	 SHORT $LN24@PyLong_Fre
$LN23@PyLong_Fre:
  003b2	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR dx$[rsp]
  003b8	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR tv191[rsp], xmm0
$LN24@PyLong_Fre:
  003be	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR tv191[rsp]
  003c4	eb 2a		 jmp	 SHORT $LN17@PyLong_Fre
$overflow$22605:

; 2670 : 
; 2671 :   overflow:
; 2672 :     /* exponent > PY_SSIZE_T_MAX */
; 2673 :     PyErr_SetString(PyExc_OverflowError,
; 2674 :                     "huge integer: number of bits overflows a Py_ssize_t");

  003c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@KPOPPGPJ@huge?5integer?3?5number?5of?5bits?5ove@
  003cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  003d4	e8 00 00 00 00	 call	 PyErr_SetString

; 2675 :     *e = 0;

  003d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  003e1	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2676 :     return -1.0;

  003e8	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
$LN17@PyLong_Fre:

; 2677 : }

  003f0	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  003f7	c3		 ret	 0
_PyLong_Frexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DG@DIDCIMHO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$v_lshift DD imagerel v_lshift
	DD	imagerel v_lshift+188
	DD	imagerel $unwind$v_lshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$v_lshift DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT ??_C@_1DG@DIDCIMHO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@DIDCIMHO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'd', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'd', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 'P', 00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H
	DB	'_', 00H, 'S', 00H, 'H', 00H, 'I', 00H, 'F', 00H, 'T', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT v_lshift
_TEXT	SEGMENT
i$ = 32
carry$ = 40
acc$21266 = 48
z$ = 80
a$ = 88
m$ = 96
d$ = 104
v_lshift PROC						; COMDAT

; 1499 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1500 :     Py_ssize_t i;
; 1501 :     digit carry = 0;

  00018	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0

; 1502 : 
; 1503 :     assert(0 <= d && d < PyLong_SHIFT);

  00020	83 7c 24 68 00	 cmp	 DWORD PTR d$[rsp], 0
  00025	7c 07		 jl	 SHORT $LN6@v_lshift
  00027	83 7c 24 68 1e	 cmp	 DWORD PTR d$[rsp], 30
  0002c	7c 1c		 jl	 SHORT $LN7@v_lshift
$LN6@v_lshift:
  0002e	41 b8 df 05 00
	00		 mov	 r8d, 1503		; 000005dfH
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@DIDCIMHO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00048	33 c0		 xor	 eax, eax
$LN7@v_lshift:

; 1504 :     for (i=0; i < m; i++) {

  0004a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00053	eb 0d		 jmp	 SHORT $LN3@v_lshift
$LN2@v_lshift:
  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0005a	48 ff c0	 inc	 rax
  0005d	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@v_lshift:
  00062	48 8b 44 24 60	 mov	 rax, QWORD PTR m$[rsp]
  00067	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0006c	7d 45		 jge	 SHORT $LN1@v_lshift

; 1505 :         twodigits acc = (twodigits)a[i] << d | carry;

  0006e	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp]
  00073	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00078	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0007b	8b 4c 24 68	 mov	 ecx, DWORD PTR d$[rsp]
  0007f	48 d3 e0	 shl	 rax, cl
  00082	8b 4c 24 28	 mov	 ecx, DWORD PTR carry$[rsp]
  00086	48 0b c1	 or	 rax, rcx
  00089	48 89 44 24 30	 mov	 QWORD PTR acc$21266[rsp], rax

; 1506 :         z[i] = (digit)acc & PyLong_MASK;

  0008e	8b 44 24 30	 mov	 eax, DWORD PTR acc$21266[rsp]
  00092	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00097	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0009c	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  000a1	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 1507 :         carry = (digit)(acc >> PyLong_SHIFT);

  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR acc$21266[rsp]
  000a9	48 c1 e8 1e	 shr	 rax, 30
  000ad	89 44 24 28	 mov	 DWORD PTR carry$[rsp], eax

; 1508 :     }

  000b1	eb a2		 jmp	 SHORT $LN2@v_lshift
$LN1@v_lshift:

; 1509 :     return carry;

  000b3	8b 44 24 28	 mov	 eax, DWORD PTR carry$[rsp]

; 1510 : }

  000b7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bb	c3		 ret	 0
v_lshift ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$v_rshift DD imagerel v_rshift
	DD	imagerel v_rshift+219
	DD	imagerel $unwind$v_rshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$v_rshift DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT v_rshift
_TEXT	SEGMENT
i$ = 32
mask$ = 40
carry$ = 44
acc$21290 = 48
tv90 = 56
z$ = 80
a$ = 88
m$ = 96
d$ = 104
v_rshift PROC						; COMDAT

; 1517 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1518 :     Py_ssize_t i;
; 1519 :     digit carry = 0;

  00018	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0

; 1520 :     digit mask = ((digit)1 << d) - 1U;

  00020	8b 44 24 68	 mov	 eax, DWORD PTR d$[rsp]
  00024	b9 01 00 00 00	 mov	 ecx, 1
  00029	89 4c 24 38	 mov	 DWORD PTR tv90[rsp], ecx
  0002d	0f b6 c8	 movzx	 ecx, al
  00030	8b 44 24 38	 mov	 eax, DWORD PTR tv90[rsp]
  00034	d3 e0		 shl	 eax, cl
  00036	ff c8		 dec	 eax
  00038	89 44 24 28	 mov	 DWORD PTR mask$[rsp], eax

; 1521 : 
; 1522 :     assert(0 <= d && d < PyLong_SHIFT);

  0003c	83 7c 24 68 00	 cmp	 DWORD PTR d$[rsp], 0
  00041	7c 07		 jl	 SHORT $LN5@v_rshift
  00043	83 7c 24 68 1e	 cmp	 DWORD PTR d$[rsp], 30
  00048	7c 1c		 jl	 SHORT $LN6@v_rshift
$LN5@v_rshift:
  0004a	41 b8 f2 05 00
	00		 mov	 r8d, 1522		; 000005f2H
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@DIDCIMHO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAd?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$AA@
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00064	33 c0		 xor	 eax, eax
$LN6@v_rshift:

; 1523 :     for (i=m; i-- > 0;) {

  00066	48 8b 44 24 60	 mov	 rax, QWORD PTR m$[rsp]
  0006b	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN2@v_rshift:
  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00075	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0007a	48 ff c9	 dec	 rcx
  0007d	48 89 4c 24 20	 mov	 QWORD PTR i$[rsp], rcx
  00082	48 85 c0	 test	 rax, rax
  00085	7e 4b		 jle	 SHORT $LN1@v_rshift

; 1524 :         twodigits acc = (twodigits)carry << PyLong_SHIFT | a[i];

  00087	8b 44 24 2c	 mov	 eax, DWORD PTR carry$[rsp]
  0008b	48 c1 e0 1e	 shl	 rax, 30
  0008f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  00094	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00099	8b 0c 91	 mov	 ecx, DWORD PTR [rcx+rdx*4]
  0009c	48 0b c1	 or	 rax, rcx
  0009f	48 89 44 24 30	 mov	 QWORD PTR acc$21290[rsp], rax

; 1525 :         carry = (digit)acc & mask;

  000a4	8b 44 24 28	 mov	 eax, DWORD PTR mask$[rsp]
  000a8	8b 4c 24 30	 mov	 ecx, DWORD PTR acc$21290[rsp]
  000ac	23 c8		 and	 ecx, eax
  000ae	8b c1		 mov	 eax, ecx
  000b0	89 44 24 2c	 mov	 DWORD PTR carry$[rsp], eax

; 1526 :         z[i] = (digit)(acc >> d);

  000b4	8b 44 24 68	 mov	 eax, DWORD PTR d$[rsp]
  000b8	0f b6 c8	 movzx	 ecx, al
  000bb	48 8b 44 24 30	 mov	 rax, QWORD PTR acc$21290[rsp]
  000c0	48 d3 e8	 shr	 rax, cl
  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  000c8	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  000cd	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 1527 :     }

  000d0	eb 9e		 jmp	 SHORT $LN2@v_rshift
$LN1@v_rshift:

; 1528 :     return carry;

  000d2	8b 44 24 2c	 mov	 eax, DWORD PTR carry$[rsp]

; 1529 : }

  000d6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000da	c3		 ret	 0
v_rshift ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@DONHKOON@long?5int?5too?5large?5to?5convert?5to@ ; `string'
PUBLIC	PyLong_AsDouble
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsDouble DD imagerel $LN8
	DD	imagerel $LN8+210
	DD	imagerel $unwind$PyLong_AsDouble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsDouble DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CH@DONHKOON@long?5int?5too?5large?5to?5convert?5to@
CONST	SEGMENT
??_C@_0CH@DONHKOON@long?5int?5too?5large?5to?5convert?5to@ DB 'long int t'
	DB	'oo large to convert to float', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLong_AsDouble
_TEXT	SEGMENT
x$ = 32
exponent$ = 40
v$ = 64
PyLong_AsDouble PROC					; COMDAT

; 2684 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2685 :     Py_ssize_t exponent;
; 2686 :     double x;
; 2687 : 
; 2688 :     if (v == NULL) {

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  0000f	75 1e		 jne	 SHORT $LN5@PyLong_AsD

; 2689 :         PyErr_BadInternalCall();

  00011	ba 81 0a 00 00	 mov	 edx, 2689		; 00000a81H
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0001d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2690 :         return -1.0;

  00022	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  0002a	e9 9e 00 00 00	 jmp	 $LN6@PyLong_AsD
$LN5@PyLong_AsD:

; 2691 :     }
; 2692 :     if (!PyLong_Check(v)) {

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00043	85 c0		 test	 eax, eax
  00045	75 1d		 jne	 SHORT $LN4@PyLong_AsD

; 2693 :         PyErr_SetString(PyExc_TypeError, "an integer is required");

  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00055	e8 00 00 00 00	 call	 PyErr_SetString

; 2694 :         return -1.0;

  0005a	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  00062	eb 69		 jmp	 SHORT $LN6@PyLong_AsD
$LN4@PyLong_AsD:

; 2695 :     }
; 2696 :     x = _PyLong_Frexp((PyLongObject *)v, &exponent);

  00064	48 8d 54 24 28	 lea	 rdx, QWORD PTR exponent$[rsp]
  00069	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0006e	e8 00 00 00 00	 call	 _PyLong_Frexp
  00073	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 2697 :     if ((x == -1.0 && PyErr_Occurred()) || exponent > DBL_MAX_EXP) {

  00079	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0007f	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00087	7a 0c		 jp	 SHORT $LN1@PyLong_AsD
  00089	75 0a		 jne	 SHORT $LN1@PyLong_AsD
  0008b	e8 00 00 00 00	 call	 PyErr_Occurred
  00090	48 85 c0	 test	 rax, rax
  00093	75 0b		 jne	 SHORT $LN2@PyLong_AsD
$LN1@PyLong_AsD:
  00095	48 81 7c 24 28
	00 04 00 00	 cmp	 QWORD PTR exponent$[rsp], 1024 ; 00000400H
  0009e	7e 1d		 jle	 SHORT $LN3@PyLong_AsD
$LN2@PyLong_AsD:

; 2698 :         PyErr_SetString(PyExc_OverflowError,
; 2699 :                         "long int too large to convert to float");

  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@DONHKOON@long?5int?5too?5large?5to?5convert?5to@
  000a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000ae	e8 00 00 00 00	 call	 PyErr_SetString

; 2700 :         return -1.0;

  000b3	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  000bb	eb 10		 jmp	 SHORT $LN6@PyLong_AsD
$LN3@PyLong_AsD:

; 2701 :     }
; 2702 :     return ldexp(x, (int)exponent);

  000bd	8b 54 24 28	 mov	 edx, DWORD PTR exponent$[rsp]
  000c1	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
$LN6@PyLong_AsD:

; 2703 : }

  000cd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d1	c3		 ret	 0
PyLong_AsDouble ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_dealloc DD imagerel long_dealloc
	DD	imagerel long_dealloc+34
	DD	imagerel $unwind$long_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_dealloc
_TEXT	SEGMENT
v$ = 48
long_dealloc PROC					; COMDAT

; 2709 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2710 :     Py_TYPE(v)->tp_free(v);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00017	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 2711 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
long_dealloc ENDP
_TEXT	ENDS
EXTRN	PyErr_BadArgument:PROC
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_richcompare DD imagerel long_richcompare
	DD	imagerel long_richcompare+516
	DD	imagerel $unwind$long_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_richcompare DD 011301H
	DD	0c213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_richcompare
_TEXT	SEGMENT
v$ = 32
result$ = 40
tv78 = 44
tv80 = 48
tv82 = 56
tv84 = 64
tv86 = 72
tv88 = 80
tv90 = 88
self$ = 112
other$ = 120
op$ = 128
long_richcompare PROC					; COMDAT

; 2741 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN16@long_richc:

; 2742 :     int result;
; 2743 :     PyObject *v;
; 2744 :     CHECK_BINOP(self, other);

  00013	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00027	85 c0		 test	 eax, eax
  00029	74 18		 je	 SHORT $LN12@long_richc
  0002b	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  00030	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00034	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003a	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003f	85 c0		 test	 eax, eax
  00041	75 18		 jne	 SHORT $LN13@long_richc
$LN12@long_richc:
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0004a	e8 00 00 00 00	 call	 _Py_IncRef
  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00056	e9 8c 01 00 00	 jmp	 $LN17@long_richc
$LN13@long_richc:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 b2		 jne	 SHORT $LN16@long_richc

; 2745 :     if (self == other)

  00061	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  00066	48 39 44 24 70	 cmp	 QWORD PTR self$[rsp], rax
  0006b	75 0a		 jne	 SHORT $LN11@long_richc

; 2746 :         result = 0;

  0006d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 2747 :     else

  00075	eb 13		 jmp	 SHORT $LN10@long_richc
$LN11@long_richc:

; 2748 :         result = long_compare((PyLongObject*)self, (PyLongObject*)other);

  00077	48 8b 54 24 78	 mov	 rdx, QWORD PTR other$[rsp]
  0007c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00081	e8 00 00 00 00	 call	 long_compare
  00086	89 44 24 28	 mov	 DWORD PTR result$[rsp], eax
$LN10@long_richc:

; 2749 :     /* Convert the return value to a Boolean */
; 2750 :     switch (op) {

  0008a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  00091	89 44 24 2c	 mov	 DWORD PTR tv78[rsp], eax
  00095	83 7c 24 2c 05	 cmp	 DWORD PTR tv78[rsp], 5
  0009a	0f 87 2f 01 00
	00		 ja	 $LN1@long_richc
  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR tv78[rsp]
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000ac	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN31@long_richc[rcx+rax*4]
  000b3	48 03 c1	 add	 rax, rcx
  000b6	ff e0		 jmp	 rax
$LN7@long_richc:

; 2751 :     case Py_EQ:
; 2752 :         v = TEST_COND(result == 0);

  000b8	83 7c 24 28 00	 cmp	 DWORD PTR result$[rsp], 0
  000bd	75 0e		 jne	 SHORT $LN19@long_richc
  000bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000c6	48 89 44 24 30	 mov	 QWORD PTR tv80[rsp], rax
  000cb	eb 0c		 jmp	 SHORT $LN20@long_richc
$LN19@long_richc:
  000cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000d4	48 89 44 24 30	 mov	 QWORD PTR tv80[rsp], rax
$LN20@long_richc:
  000d9	48 8b 44 24 30	 mov	 rax, QWORD PTR tv80[rsp]
  000de	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2753 :         break;

  000e3	e9 f0 00 00 00	 jmp	 $LN8@long_richc
$LN6@long_richc:

; 2754 :     case Py_NE:
; 2755 :         v = TEST_COND(result != 0);

  000e8	83 7c 24 28 00	 cmp	 DWORD PTR result$[rsp], 0
  000ed	74 0e		 je	 SHORT $LN21@long_richc
  000ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000f6	48 89 44 24 38	 mov	 QWORD PTR tv82[rsp], rax
  000fb	eb 0c		 jmp	 SHORT $LN22@long_richc
$LN21@long_richc:
  000fd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00104	48 89 44 24 38	 mov	 QWORD PTR tv82[rsp], rax
$LN22@long_richc:
  00109	48 8b 44 24 38	 mov	 rax, QWORD PTR tv82[rsp]
  0010e	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2756 :         break;

  00113	e9 c0 00 00 00	 jmp	 $LN8@long_richc
$LN5@long_richc:

; 2757 :     case Py_LE:
; 2758 :         v = TEST_COND(result <= 0);

  00118	83 7c 24 28 00	 cmp	 DWORD PTR result$[rsp], 0
  0011d	7f 0e		 jg	 SHORT $LN23@long_richc
  0011f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00126	48 89 44 24 40	 mov	 QWORD PTR tv84[rsp], rax
  0012b	eb 0c		 jmp	 SHORT $LN24@long_richc
$LN23@long_richc:
  0012d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00134	48 89 44 24 40	 mov	 QWORD PTR tv84[rsp], rax
$LN24@long_richc:
  00139	48 8b 44 24 40	 mov	 rax, QWORD PTR tv84[rsp]
  0013e	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2759 :         break;

  00143	e9 90 00 00 00	 jmp	 $LN8@long_richc
$LN4@long_richc:

; 2760 :     case Py_GE:
; 2761 :         v = TEST_COND(result >= 0);

  00148	83 7c 24 28 00	 cmp	 DWORD PTR result$[rsp], 0
  0014d	7c 0e		 jl	 SHORT $LN25@long_richc
  0014f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00156	48 89 44 24 48	 mov	 QWORD PTR tv86[rsp], rax
  0015b	eb 0c		 jmp	 SHORT $LN26@long_richc
$LN25@long_richc:
  0015d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00164	48 89 44 24 48	 mov	 QWORD PTR tv86[rsp], rax
$LN26@long_richc:
  00169	48 8b 44 24 48	 mov	 rax, QWORD PTR tv86[rsp]
  0016e	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2762 :         break;

  00173	eb 63		 jmp	 SHORT $LN8@long_richc
$LN3@long_richc:

; 2763 :     case Py_LT:
; 2764 :         v = TEST_COND(result == -1);

  00175	83 7c 24 28 ff	 cmp	 DWORD PTR result$[rsp], -1
  0017a	75 0e		 jne	 SHORT $LN27@long_richc
  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00183	48 89 44 24 50	 mov	 QWORD PTR tv88[rsp], rax
  00188	eb 0c		 jmp	 SHORT $LN28@long_richc
$LN27@long_richc:
  0018a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00191	48 89 44 24 50	 mov	 QWORD PTR tv88[rsp], rax
$LN28@long_richc:
  00196	48 8b 44 24 50	 mov	 rax, QWORD PTR tv88[rsp]
  0019b	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2765 :         break;

  001a0	eb 36		 jmp	 SHORT $LN8@long_richc
$LN2@long_richc:

; 2766 :     case Py_GT:
; 2767 :         v = TEST_COND(result == 1);

  001a2	83 7c 24 28 01	 cmp	 DWORD PTR result$[rsp], 1
  001a7	75 0e		 jne	 SHORT $LN29@long_richc
  001a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  001b0	48 89 44 24 58	 mov	 QWORD PTR tv90[rsp], rax
  001b5	eb 0c		 jmp	 SHORT $LN30@long_richc
$LN29@long_richc:
  001b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  001be	48 89 44 24 58	 mov	 QWORD PTR tv90[rsp], rax
$LN30@long_richc:
  001c3	48 8b 44 24 58	 mov	 rax, QWORD PTR tv90[rsp]
  001c8	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2768 :         break;

  001cd	eb 09		 jmp	 SHORT $LN8@long_richc
$LN1@long_richc:

; 2769 :     default:
; 2770 :         PyErr_BadArgument();

  001cf	e8 00 00 00 00	 call	 PyErr_BadArgument

; 2771 :         return NULL;

  001d4	33 c0		 xor	 eax, eax
  001d6	eb 0f		 jmp	 SHORT $LN17@long_richc
$LN8@long_richc:

; 2772 :     }
; 2773 :     Py_INCREF(v);

  001d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  001dd	e8 00 00 00 00	 call	 _Py_IncRef

; 2774 :     return v;

  001e2	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN17@long_richc:

; 2775 : }

  001e7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001eb	c3		 ret	 0
$LN31@long_richc:
  001ec	00 00 00 00	 DD	 $LN3@long_richc
  001f0	00 00 00 00	 DD	 $LN5@long_richc
  001f4	00 00 00 00	 DD	 $LN7@long_richc
  001f8	00 00 00 00	 DD	 $LN6@long_richc
  001fc	00 00 00 00	 DD	 $LN2@long_richc
  00200	00 00 00 00	 DD	 $LN4@long_richc
long_richcompare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_compare DD imagerel long_compare
	DD	imagerel long_compare+310
	DD	imagerel $unwind$long_compare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_compare DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_compare
_TEXT	SEGMENT
sign$ = 0
i$22665 = 8
tv75 = 16
tv132 = 24
tv131 = 28
a$ = 48
b$ = 56
long_compare PROC					; COMDAT

; 2715 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2716 :     Py_ssize_t sign;
; 2717 : 
; 2718 :     if (Py_SIZE(a) != Py_SIZE(b)) {

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$[rsp]
  00018	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0001c	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00020	74 1e		 je	 SHORT $LN7@long_compa

; 2719 :         sign = Py_SIZE(a) - Py_SIZE(b);

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00027	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$[rsp]
  0002c	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00030	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00034	48 2b c1	 sub	 rax, rcx
  00037	48 89 04 24	 mov	 QWORD PTR sign$[rsp], rax

; 2720 :     }
; 2721 :     else {

  0003b	e9 bb 00 00 00	 jmp	 $LN6@long_compa
$LN7@long_compa:

; 2722 :         Py_ssize_t i = ABS(Py_SIZE(a));

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00045	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0004a	7d 13		 jge	 SHORT $LN10@long_compa
  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00051	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00055	48 f7 d8	 neg	 rax
  00058	48 89 44 24 10	 mov	 QWORD PTR tv75[rsp], rax
  0005d	eb 0e		 jmp	 SHORT $LN11@long_compa
$LN10@long_compa:
  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00064	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00068	48 89 44 24 10	 mov	 QWORD PTR tv75[rsp], rax
$LN11@long_compa:
  0006d	48 8b 44 24 10	 mov	 rax, QWORD PTR tv75[rsp]
  00072	48 89 44 24 08	 mov	 QWORD PTR i$22665[rsp], rax
$LN5@long_compa:

; 2723 :         while (--i >= 0 && a->ob_digit[i] == b->ob_digit[i])

  00077	48 8b 44 24 08	 mov	 rax, QWORD PTR i$22665[rsp]
  0007c	48 ff c8	 dec	 rax
  0007f	48 89 44 24 08	 mov	 QWORD PTR i$22665[rsp], rax
  00084	48 83 7c 24 08
	00		 cmp	 QWORD PTR i$22665[rsp], 0
  0008a	7c 21		 jl	 SHORT $LN4@long_compa
  0008c	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00091	48 8b 4c 24 08	 mov	 rcx, QWORD PTR i$22665[rsp]
  00096	48 8b 54 24 38	 mov	 rdx, QWORD PTR b$[rsp]
  0009b	4c 8b 44 24 08	 mov	 r8, QWORD PTR i$22665[rsp]
  000a0	42 8b 54 82 70	 mov	 edx, DWORD PTR [rdx+r8*4+112]
  000a5	39 54 88 70	 cmp	 DWORD PTR [rax+rcx*4+112], edx
  000a9	75 02		 jne	 SHORT $LN4@long_compa

; 2724 :             ;

  000ab	eb ca		 jmp	 SHORT $LN5@long_compa
$LN4@long_compa:

; 2725 :         if (i < 0)

  000ad	48 83 7c 24 08
	00		 cmp	 QWORD PTR i$22665[rsp], 0
  000b3	7d 0a		 jge	 SHORT $LN3@long_compa

; 2726 :             sign = 0;

  000b5	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR sign$[rsp], 0

; 2727 :         else {

  000bd	eb 3c		 jmp	 SHORT $LN2@long_compa
$LN3@long_compa:

; 2728 :             sign = (sdigit)a->ob_digit[i] - (sdigit)b->ob_digit[i];

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000c4	48 8b 4c 24 08	 mov	 rcx, QWORD PTR i$22665[rsp]
  000c9	48 8b 54 24 38	 mov	 rdx, QWORD PTR b$[rsp]
  000ce	4c 8b 44 24 08	 mov	 r8, QWORD PTR i$22665[rsp]
  000d3	42 8b 54 82 70	 mov	 edx, DWORD PTR [rdx+r8*4+112]
  000d8	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  000dc	2b c2		 sub	 eax, edx
  000de	48 98		 cdqe
  000e0	48 89 04 24	 mov	 QWORD PTR sign$[rsp], rax

; 2729 :             if (Py_SIZE(a) < 0)

  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000e9	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000ee	7d 0b		 jge	 SHORT $LN1@long_compa

; 2730 :                 sign = -sign;

  000f0	48 8b 04 24	 mov	 rax, QWORD PTR sign$[rsp]
  000f4	48 f7 d8	 neg	 rax
  000f7	48 89 04 24	 mov	 QWORD PTR sign$[rsp], rax
$LN1@long_compa:
$LN2@long_compa:
$LN6@long_compa:

; 2731 :         }
; 2732 :     }
; 2733 :     return sign < 0 ? -1 : sign > 0 ? 1 : 0;

  000fb	48 83 3c 24 00	 cmp	 QWORD PTR sign$[rsp], 0
  00100	7d 0a		 jge	 SHORT $LN14@long_compa
  00102	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR tv132[rsp], -1
  0010a	eb 21		 jmp	 SHORT $LN15@long_compa
$LN14@long_compa:
  0010c	48 83 3c 24 00	 cmp	 QWORD PTR sign$[rsp], 0
  00111	7e 0a		 jle	 SHORT $LN12@long_compa
  00113	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  0011b	eb 08		 jmp	 SHORT $LN13@long_compa
$LN12@long_compa:
  0011d	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN13@long_compa:
  00125	8b 44 24 1c	 mov	 eax, DWORD PTR tv131[rsp]
  00129	89 44 24 18	 mov	 DWORD PTR tv132[rsp], eax
$LN15@long_compa:
  0012d	8b 44 24 18	 mov	 eax, DWORD PTR tv132[rsp]

; 2734 : }

  00131	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00135	c3		 ret	 0
long_compare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_hash DD imagerel long_hash
	DD	imagerel long_hash+340
	DD	imagerel $unwind$long_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_hash DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_hash
_TEXT	SEGMENT
x$ = 0
i$ = 8
sign$ = 16
tv65 = 24
tv72 = 32
v$ = 64
long_hash PROC						; COMDAT

; 2779 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2780 :     Py_uhash_t x;
; 2781 :     Py_ssize_t i;
; 2782 :     int sign;
; 2783 : 
; 2784 :     i = Py_SIZE(v);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 89 44 24 08	 mov	 QWORD PTR i$[rsp], rax

; 2785 :     switch(i) {

  00017	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0001c	48 89 44 24 18	 mov	 QWORD PTR tv65[rsp], rax
  00021	48 83 7c 24 18
	ff		 cmp	 QWORD PTR tv65[rsp], -1
  00027	74 12		 je	 SHORT $LN8@long_hash
  00029	48 83 7c 24 18
	00		 cmp	 QWORD PTR tv65[rsp], 0
  0002f	74 37		 je	 SHORT $LN7@long_hash
  00031	48 83 7c 24 18
	01		 cmp	 QWORD PTR tv65[rsp], 1
  00037	74 36		 je	 SHORT $LN6@long_hash
  00039	eb 41		 jmp	 SHORT $LN9@long_hash
$LN8@long_hash:

; 2786 :     case -1: return v->ob_digit[0]==1 ? -2 : -(sdigit)v->ob_digit[0];

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00040	83 78 70 01	 cmp	 DWORD PTR [rax+112], 1
  00044	75 0a		 jne	 SHORT $LN13@long_hash
  00046	c7 44 24 20 fe
	ff ff ff	 mov	 DWORD PTR tv72[rsp], -2
  0004e	eb 0e		 jmp	 SHORT $LN14@long_hash
$LN13@long_hash:
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00055	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00058	f7 d8		 neg	 eax
  0005a	89 44 24 20	 mov	 DWORD PTR tv72[rsp], eax
$LN14@long_hash:
  0005e	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv72[rsp]
  00063	e9 e7 00 00 00	 jmp	 $LN11@long_hash
$LN7@long_hash:

; 2787 :     case 0: return 0;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 e0 00 00 00	 jmp	 $LN11@long_hash
$LN6@long_hash:

; 2788 :     case 1: return v->ob_digit[0];

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00074	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00077	e9 d3 00 00 00	 jmp	 $LN11@long_hash
$LN9@long_hash:

; 2789 :     }
; 2790 :     sign = 1;

  0007c	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1

; 2791 :     x = 0;

  00084	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 2792 :     if (i < 0) {

  0008c	48 83 7c 24 08
	00		 cmp	 QWORD PTR i$[rsp], 0
  00092	7d 15		 jge	 SHORT $LN5@long_hash

; 2793 :         sign = -1;

  00094	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR sign$[rsp], -1

; 2794 :         i = -(i);

  0009c	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  000a1	48 f7 d8	 neg	 rax
  000a4	48 89 44 24 08	 mov	 QWORD PTR i$[rsp], rax
$LN5@long_hash:
$LN4@long_hash:

; 2795 :     }
; 2796 :     while (--i >= 0) {

  000a9	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  000ae	48 ff c8	 dec	 rax
  000b1	48 89 44 24 08	 mov	 QWORD PTR i$[rsp], rax
  000b6	48 83 7c 24 08
	00		 cmp	 QWORD PTR i$[rsp], 0
  000bc	7c 6a		 jl	 SHORT $LN3@long_hash

; 2797 :         /* Here x is a quantity in the range [0, _PyHASH_MODULUS); we
; 2798 :            want to compute x * 2**PyLong_SHIFT + v->ob_digit[i] modulo
; 2799 :            _PyHASH_MODULUS.
; 2800 : 
; 2801 :            The computation of x * 2**PyLong_SHIFT % _PyHASH_MODULUS
; 2802 :            amounts to a rotation of the bits of x.  To see this, write
; 2803 : 
; 2804 :              x * 2**PyLong_SHIFT = y * 2**_PyHASH_BITS + z
; 2805 : 
; 2806 :            where y = x >> (_PyHASH_BITS - PyLong_SHIFT) gives the top
; 2807 :            PyLong_SHIFT bits of x (those that are shifted out of the
; 2808 :            original _PyHASH_BITS bits, and z = (x << PyLong_SHIFT) &
; 2809 :            _PyHASH_MODULUS gives the bottom _PyHASH_BITS - PyLong_SHIFT
; 2810 :            bits of x, shifted up.  Then since 2**_PyHASH_BITS is
; 2811 :            congruent to 1 modulo _PyHASH_MODULUS, y*2**_PyHASH_BITS is
; 2812 :            congruent to y modulo _PyHASH_MODULUS.  So
; 2813 : 
; 2814 :              x * 2**PyLong_SHIFT = y + z (mod _PyHASH_MODULUS).
; 2815 : 
; 2816 :            The right-hand side is just the result of rotating the
; 2817 :            _PyHASH_BITS bits of x left by PyLong_SHIFT places; since
; 2818 :            not all _PyHASH_BITS bits of x are 1s, the same is true
; 2819 :            after rotation, so 0 <= y+z < _PyHASH_MODULUS and y + z is
; 2820 :            the reduction of x*2**PyLong_SHIFT modulo
; 2821 :            _PyHASH_MODULUS. */
; 2822 :         x = ((x << PyLong_SHIFT) & _PyHASH_MODULUS) |
; 2823 :             (x >> (_PyHASH_BITS - PyLong_SHIFT));

  000be	48 8b 04 24	 mov	 rax, QWORD PTR x$[rsp]
  000c2	48 c1 e0 1e	 shl	 rax, 30
  000c6	48 b9 ff ff ff
	ff ff ff ff 1f	 mov	 rcx, 2305843009213693951 ; 1fffffffffffffffH
  000d0	48 23 c1	 and	 rax, rcx
  000d3	48 8b 0c 24	 mov	 rcx, QWORD PTR x$[rsp]
  000d7	48 c1 e9 1f	 shr	 rcx, 31
  000db	48 0b c1	 or	 rax, rcx
  000de	48 89 04 24	 mov	 QWORD PTR x$[rsp], rax

; 2824 :         x += v->ob_digit[i];

  000e2	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  000e7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR i$[rsp]
  000ec	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  000f0	48 8b 0c 24	 mov	 rcx, QWORD PTR x$[rsp]
  000f4	48 03 c8	 add	 rcx, rax
  000f7	48 8b c1	 mov	 rax, rcx
  000fa	48 89 04 24	 mov	 QWORD PTR x$[rsp], rax

; 2825 :         if (x >= _PyHASH_MODULUS)

  000fe	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00108	48 39 04 24	 cmp	 QWORD PTR x$[rsp], rax
  0010c	72 18		 jb	 SHORT $LN2@long_hash

; 2826 :             x -= _PyHASH_MODULUS;

  0010e	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00118	48 8b 0c 24	 mov	 rcx, QWORD PTR x$[rsp]
  0011c	48 2b c8	 sub	 rcx, rax
  0011f	48 8b c1	 mov	 rax, rcx
  00122	48 89 04 24	 mov	 QWORD PTR x$[rsp], rax
$LN2@long_hash:

; 2827 :     }

  00126	eb 81		 jmp	 SHORT $LN4@long_hash
$LN3@long_hash:

; 2828 :     x = x * sign;

  00128	48 63 44 24 10	 movsxd	 rax, DWORD PTR sign$[rsp]
  0012d	48 8b 0c 24	 mov	 rcx, QWORD PTR x$[rsp]
  00131	48 0f af c8	 imul	 rcx, rax
  00135	48 8b c1	 mov	 rax, rcx
  00138	48 89 04 24	 mov	 QWORD PTR x$[rsp], rax

; 2829 :     if (x == (Py_uhash_t)-1)

  0013c	48 83 3c 24 ff	 cmp	 QWORD PTR x$[rsp], -1
  00141	75 08		 jne	 SHORT $LN1@long_hash

; 2830 :         x = (Py_uhash_t)-2;

  00143	48 c7 04 24 fe
	ff ff ff	 mov	 QWORD PTR x$[rsp], -2
$LN1@long_hash:

; 2831 :     return (Py_hash_t)x;

  0014b	48 8b 04 24	 mov	 rax, QWORD PTR x$[rsp]
$LN11@long_hash:

; 2832 : }

  0014f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00153	c3		 ret	 0
long_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_add DD imagerel long_add
	DD	imagerel long_add+553
	DD	imagerel $unwind$long_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_add DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_add
_TEXT	SEGMENT
z$ = 32
result$22871 = 40
tv79 = 48
tv86 = 56
tv131 = 64
tv130 = 68
tv142 = 72
tv141 = 76
a$ = 96
b$ = 104
long_add PROC						; COMDAT

; 2926 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN13@long_add:

; 2927 :     PyLongObject *z;
; 2928 : 
; 2929 :     CHECK_BINOP(a, b);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00022	85 c0		 test	 eax, eax
  00024	74 18		 je	 SHORT $LN9@long_add
  00026	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003a	85 c0		 test	 eax, eax
  0003c	75 18		 jne	 SHORT $LN10@long_add
$LN9@long_add:
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00045	e8 00 00 00 00	 call	 _Py_IncRef
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00051	e9 ce 01 00 00	 jmp	 $LN14@long_add
$LN10@long_add:
  00056	33 c0		 xor	 eax, eax
  00058	85 c0		 test	 eax, eax
  0005a	75 b2		 jne	 SHORT $LN13@long_add

; 2930 : 
; 2931 :     if (ABS(Py_SIZE(a)) <= 1 && ABS(Py_SIZE(b)) <= 1) {

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00061	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00066	7d 13		 jge	 SHORT $LN16@long_add
  00068	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0006d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00071	48 f7 d8	 neg	 rax
  00074	48 89 44 24 30	 mov	 QWORD PTR tv79[rsp], rax
  00079	eb 0e		 jmp	 SHORT $LN17@long_add
$LN16@long_add:
  0007b	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00080	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00084	48 89 44 24 30	 mov	 QWORD PTR tv79[rsp], rax
$LN17@long_add:
  00089	48 83 7c 24 30
	01		 cmp	 QWORD PTR tv79[rsp], 1
  0008f	0f 8f e7 00 00
	00		 jg	 $LN8@long_add
  00095	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  0009a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0009f	7d 13		 jge	 SHORT $LN18@long_add
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  000a6	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000aa	48 f7 d8	 neg	 rax
  000ad	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
  000b2	eb 0e		 jmp	 SHORT $LN19@long_add
$LN18@long_add:
  000b4	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  000b9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000bd	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
$LN19@long_add:
  000c2	48 83 7c 24 38
	01		 cmp	 QWORD PTR tv86[rsp], 1
  000c8	0f 8f ae 00 00
	00		 jg	 $LN8@long_add

; 2932 :         PyObject *result = PyLong_FromLong(MEDIUM_VALUE(a) +
; 2933 :                                           MEDIUM_VALUE(b));

  000ce	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  000d3	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000d8	7d 10		 jge	 SHORT $LN22@long_add
  000da	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  000df	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000e2	f7 d8		 neg	 eax
  000e4	89 44 24 40	 mov	 DWORD PTR tv131[rsp], eax
  000e8	eb 2a		 jmp	 SHORT $LN23@long_add
$LN22@long_add:
  000ea	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  000ef	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000f4	75 0a		 jne	 SHORT $LN20@long_add
  000f6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
  000fe	eb 0c		 jmp	 SHORT $LN21@long_add
$LN20@long_add:
  00100	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00105	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00108	89 44 24 44	 mov	 DWORD PTR tv130[rsp], eax
$LN21@long_add:
  0010c	8b 44 24 44	 mov	 eax, DWORD PTR tv130[rsp]
  00110	89 44 24 40	 mov	 DWORD PTR tv131[rsp], eax
$LN23@long_add:
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  00119	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0011e	7d 10		 jge	 SHORT $LN26@long_add
  00120	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  00125	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00128	f7 d8		 neg	 eax
  0012a	89 44 24 48	 mov	 DWORD PTR tv142[rsp], eax
  0012e	eb 2a		 jmp	 SHORT $LN27@long_add
$LN26@long_add:
  00130	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  00135	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0013a	75 0a		 jne	 SHORT $LN24@long_add
  0013c	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
  00144	eb 0c		 jmp	 SHORT $LN25@long_add
$LN24@long_add:
  00146	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  0014b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0014e	89 44 24 4c	 mov	 DWORD PTR tv141[rsp], eax
$LN25@long_add:
  00152	8b 44 24 4c	 mov	 eax, DWORD PTR tv141[rsp]
  00156	89 44 24 48	 mov	 DWORD PTR tv142[rsp], eax
$LN27@long_add:
  0015a	8b 44 24 48	 mov	 eax, DWORD PTR tv142[rsp]
  0015e	8b 4c 24 40	 mov	 ecx, DWORD PTR tv131[rsp]
  00162	03 c8		 add	 ecx, eax
  00164	8b c1		 mov	 eax, ecx
  00166	8b c8		 mov	 ecx, eax
  00168	e8 00 00 00 00	 call	 PyLong_FromLong
  0016d	48 89 44 24 28	 mov	 QWORD PTR result$22871[rsp], rax

; 2934 :         return result;

  00172	48 8b 44 24 28	 mov	 rax, QWORD PTR result$22871[rsp]
  00177	e9 a8 00 00 00	 jmp	 $LN14@long_add
$LN8@long_add:

; 2935 :     }
; 2936 :     if (Py_SIZE(a) < 0) {

  0017c	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00181	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00186	7d 61		 jge	 SHORT $LN7@long_add

; 2937 :         if (Py_SIZE(b) < 0) {

  00188	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  0018d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00192	7d 3f		 jge	 SHORT $LN6@long_add

; 2938 :             z = x_add(a, b);

  00194	48 8b 54 24 68	 mov	 rdx, QWORD PTR b$[rsp]
  00199	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  0019e	e8 00 00 00 00	 call	 x_add
  001a3	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax

; 2939 :             if (z != NULL && Py_SIZE(z) != 0)

  001a8	48 83 7c 24 20
	00		 cmp	 QWORD PTR z$[rsp], 0
  001ae	74 21		 je	 SHORT $LN5@long_add
  001b0	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  001b5	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001ba	74 15		 je	 SHORT $LN5@long_add

; 2940 :                 Py_SIZE(z) = -(Py_SIZE(z));

  001bc	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  001c1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001c5	48 f7 d8	 neg	 rax
  001c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR z$[rsp]
  001cd	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN5@long_add:

; 2941 :         }
; 2942 :         else

  001d1	eb 14		 jmp	 SHORT $LN4@long_add
$LN6@long_add:

; 2943 :             z = x_sub(b, a);

  001d3	48 8b 54 24 60	 mov	 rdx, QWORD PTR a$[rsp]
  001d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR b$[rsp]
  001dd	e8 00 00 00 00	 call	 x_sub
  001e2	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax
$LN4@long_add:

; 2944 :     }
; 2945 :     else {

  001e7	eb 36		 jmp	 SHORT $LN3@long_add
$LN7@long_add:

; 2946 :         if (Py_SIZE(b) < 0)

  001e9	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  001ee	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001f3	7d 16		 jge	 SHORT $LN2@long_add

; 2947 :             z = x_sub(a, b);

  001f5	48 8b 54 24 68	 mov	 rdx, QWORD PTR b$[rsp]
  001fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  001ff	e8 00 00 00 00	 call	 x_sub
  00204	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax

; 2948 :         else

  00209	eb 14		 jmp	 SHORT $LN1@long_add
$LN2@long_add:

; 2949 :             z = x_add(a, b);

  0020b	48 8b 54 24 68	 mov	 rdx, QWORD PTR b$[rsp]
  00210	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00215	e8 00 00 00 00	 call	 x_add
  0021a	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax
$LN1@long_add:
$LN3@long_add:

; 2950 :     }
; 2951 :     return (PyObject *)z;

  0021f	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
$LN14@long_add:

; 2952 : }

  00224	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00228	c3		 ret	 0
long_add ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$x_add DD	imagerel x_add
	DD	imagerel x_add+513
	DD	imagerel $unwind$x_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x_add DD 010e01H
	DD	0e20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT x_add
_TEXT	SEGMENT
i$ = 32
size_b$ = 40
carry$ = 48
z$ = 56
size_a$ = 64
temp$22772 = 72
size_temp$22773 = 80
tv69 = 88
tv75 = 96
a$ = 128
b$ = 136
x_add	PROC						; COMDAT

; 2839 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2840 :     Py_ssize_t size_a = ABS(Py_SIZE(a)), size_b = ABS(Py_SIZE(b));

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00016	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001b	7d 16		 jge	 SHORT $LN11@x_add
  0001d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00025	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00029	48 f7 d8	 neg	 rax
  0002c	48 89 44 24 58	 mov	 QWORD PTR tv69[rsp], rax
  00031	eb 11		 jmp	 SHORT $LN12@x_add
$LN11@x_add:
  00033	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0003b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003f	48 89 44 24 58	 mov	 QWORD PTR tv69[rsp], rax
$LN12@x_add:
  00044	48 8b 44 24 58	 mov	 rax, QWORD PTR tv69[rsp]
  00049	48 89 44 24 40	 mov	 QWORD PTR size_a$[rsp], rax
  0004e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00056	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0005b	7d 16		 jge	 SHORT $LN13@x_add
  0005d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00065	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00069	48 f7 d8	 neg	 rax
  0006c	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  00071	eb 11		 jmp	 SHORT $LN14@x_add
$LN13@x_add:
  00073	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0007b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0007f	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
$LN14@x_add:
  00084	48 8b 44 24 60	 mov	 rax, QWORD PTR tv75[rsp]
  00089	48 89 44 24 28	 mov	 QWORD PTR size_b$[rsp], rax

; 2841 :     PyLongObject *z;
; 2842 :     Py_ssize_t i;
; 2843 :     digit carry = 0;

  0008e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0

; 2844 : 
; 2845 :     /* Ensure a is the larger of the two: */
; 2846 :     if (size_a < size_b) {

  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR size_b$[rsp]
  0009b	48 39 44 24 40	 cmp	 QWORD PTR size_a$[rsp], rax
  000a0	7d 48		 jge	 SHORT $LN8@x_add

; 2847 :         { PyLongObject *temp = a; a = b; b = temp; }

  000a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000aa	48 89 44 24 48	 mov	 QWORD PTR temp$22772[rsp], rax
  000af	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000b7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR a$[rsp], rax
  000bf	48 8b 44 24 48	 mov	 rax, QWORD PTR temp$22772[rsp]
  000c4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2848 :         { Py_ssize_t size_temp = size_a;

  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR size_a$[rsp]
  000d1	48 89 44 24 50	 mov	 QWORD PTR size_temp$22773[rsp], rax

; 2849 :             size_a = size_b;

  000d6	48 8b 44 24 28	 mov	 rax, QWORD PTR size_b$[rsp]
  000db	48 89 44 24 40	 mov	 QWORD PTR size_a$[rsp], rax

; 2850 :             size_b = size_temp; }

  000e0	48 8b 44 24 50	 mov	 rax, QWORD PTR size_temp$22773[rsp]
  000e5	48 89 44 24 28	 mov	 QWORD PTR size_b$[rsp], rax
$LN8@x_add:

; 2851 :     }
; 2852 :     z = _PyLong_New(size_a+1);

  000ea	48 8b 44 24 40	 mov	 rax, QWORD PTR size_a$[rsp]
  000ef	48 ff c0	 inc	 rax
  000f2	48 8b c8	 mov	 rcx, rax
  000f5	e8 00 00 00 00	 call	 _PyLong_New
  000fa	48 89 44 24 38	 mov	 QWORD PTR z$[rsp], rax

; 2853 :     if (z == NULL)

  000ff	48 83 7c 24 38
	00		 cmp	 QWORD PTR z$[rsp], 0
  00105	75 07		 jne	 SHORT $LN7@x_add

; 2854 :         return NULL;

  00107	33 c0		 xor	 eax, eax
  00109	e9 ee 00 00 00	 jmp	 $LN9@x_add
$LN7@x_add:

; 2855 :     for (i = 0; i < size_b; ++i) {

  0010e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00117	eb 0d		 jmp	 SHORT $LN6@x_add
$LN5@x_add:
  00119	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0011e	48 ff c0	 inc	 rax
  00121	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@x_add:
  00126	48 8b 44 24 28	 mov	 rax, QWORD PTR size_b$[rsp]
  0012b	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00130	7d 52		 jge	 SHORT $LN4@x_add

; 2856 :         carry += a->ob_digit[i] + b->ob_digit[i];

  00132	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0013a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0013f	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  00143	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0014b	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00150	03 44 91 70	 add	 eax, DWORD PTR [rcx+rdx*4+112]
  00154	8b 4c 24 30	 mov	 ecx, DWORD PTR carry$[rsp]
  00158	03 c8		 add	 ecx, eax
  0015a	8b c1		 mov	 eax, ecx
  0015c	89 44 24 30	 mov	 DWORD PTR carry$[rsp], eax

; 2857 :         z->ob_digit[i] = carry & PyLong_MASK;

  00160	8b 44 24 30	 mov	 eax, DWORD PTR carry$[rsp]
  00164	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00169	48 8b 4c 24 38	 mov	 rcx, QWORD PTR z$[rsp]
  0016e	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00173	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax

; 2858 :         carry >>= PyLong_SHIFT;

  00177	8b 44 24 30	 mov	 eax, DWORD PTR carry$[rsp]
  0017b	c1 e8 1e	 shr	 eax, 30
  0017e	89 44 24 30	 mov	 DWORD PTR carry$[rsp], eax

; 2859 :     }

  00182	eb 95		 jmp	 SHORT $LN5@x_add
$LN4@x_add:

; 2860 :     for (; i < size_a; ++i) {

  00184	eb 0d		 jmp	 SHORT $LN3@x_add
$LN2@x_add:
  00186	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0018b	48 ff c0	 inc	 rax
  0018e	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@x_add:
  00193	48 8b 44 24 40	 mov	 rax, QWORD PTR size_a$[rsp]
  00198	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0019d	7d 41		 jge	 SHORT $LN1@x_add

; 2861 :         carry += a->ob_digit[i];

  0019f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  001ac	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  001b0	8b 4c 24 30	 mov	 ecx, DWORD PTR carry$[rsp]
  001b4	03 c8		 add	 ecx, eax
  001b6	8b c1		 mov	 eax, ecx
  001b8	89 44 24 30	 mov	 DWORD PTR carry$[rsp], eax

; 2862 :         z->ob_digit[i] = carry & PyLong_MASK;

  001bc	8b 44 24 30	 mov	 eax, DWORD PTR carry$[rsp]
  001c0	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  001c5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR z$[rsp]
  001ca	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  001cf	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax

; 2863 :         carry >>= PyLong_SHIFT;

  001d3	8b 44 24 30	 mov	 eax, DWORD PTR carry$[rsp]
  001d7	c1 e8 1e	 shr	 eax, 30
  001da	89 44 24 30	 mov	 DWORD PTR carry$[rsp], eax

; 2864 :     }

  001de	eb a6		 jmp	 SHORT $LN2@x_add
$LN1@x_add:

; 2865 :     z->ob_digit[i] = carry;

  001e0	48 8b 44 24 38	 mov	 rax, QWORD PTR z$[rsp]
  001e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  001ea	8b 54 24 30	 mov	 edx, DWORD PTR carry$[rsp]
  001ee	89 54 88 70	 mov	 DWORD PTR [rax+rcx*4+112], edx

; 2866 :     return long_normalize(z);

  001f2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR z$[rsp]
  001f7	e8 00 00 00 00	 call	 long_normalize
$LN9@x_add:

; 2867 : }

  001fc	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00200	c3		 ret	 0
x_add	ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@FOIOBMFH@?$AAb?$AAo?$AAr?$AAr?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$x_sub DD	imagerel x_sub
	DD	imagerel x_sub+968
	DD	imagerel $unwind$x_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x_sub DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_1BI@FOIOBMFH@?$AAb?$AAo?$AAr?$AAr?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@FOIOBMFH@?$AAb?$AAo?$AAr?$AAr?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'o', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'w', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT x_sub
_TEXT	SEGMENT
i$ = 32
size_b$ = 40
sign$ = 48
z$ = 56
borrow$ = 64
size_a$ = 72
temp$22806 = 80
size_temp$22807 = 88
temp$22816 = 96
tmp$22841 = 104
tv69 = 112
tv75 = 120
tv183 = 128
tv182 = 132
a$ = 160
b$ = 168
x_sub	PROC						; COMDAT

; 2873 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2874 :     Py_ssize_t size_a = ABS(Py_SIZE(a)), size_b = ABS(Py_SIZE(b));

  00011	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00019	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001e	7d 16		 jge	 SHORT $LN23@x_sub
  00020	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00028	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002c	48 f7 d8	 neg	 rax
  0002f	48 89 44 24 70	 mov	 QWORD PTR tv69[rsp], rax
  00034	eb 11		 jmp	 SHORT $LN24@x_sub
$LN23@x_sub:
  00036	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0003e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00042	48 89 44 24 70	 mov	 QWORD PTR tv69[rsp], rax
$LN24@x_sub:
  00047	48 8b 44 24 70	 mov	 rax, QWORD PTR tv69[rsp]
  0004c	48 89 44 24 48	 mov	 QWORD PTR size_a$[rsp], rax
  00051	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00059	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0005e	7d 16		 jge	 SHORT $LN25@x_sub
  00060	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00068	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006c	48 f7 d8	 neg	 rax
  0006f	48 89 44 24 78	 mov	 QWORD PTR tv75[rsp], rax
  00074	eb 11		 jmp	 SHORT $LN26@x_sub
$LN25@x_sub:
  00076	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0007e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00082	48 89 44 24 78	 mov	 QWORD PTR tv75[rsp], rax
$LN26@x_sub:
  00087	48 8b 44 24 78	 mov	 rax, QWORD PTR tv75[rsp]
  0008c	48 89 44 24 28	 mov	 QWORD PTR size_b$[rsp], rax

; 2875 :     PyLongObject *z;
; 2876 :     Py_ssize_t i;
; 2877 :     int sign = 1;

  00091	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1

; 2878 :     digit borrow = 0;

  00099	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR borrow$[rsp], 0

; 2879 : 
; 2880 :     /* Ensure a is the larger of the two: */
; 2881 :     if (size_a < size_b) {

  000a1	48 8b 44 24 28	 mov	 rax, QWORD PTR size_b$[rsp]
  000a6	48 39 44 24 48	 cmp	 QWORD PTR size_a$[rsp], rax
  000ab	7d 55		 jge	 SHORT $LN20@x_sub

; 2882 :         sign = -1;

  000ad	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR sign$[rsp], -1

; 2883 :         { PyLongObject *temp = a; a = b; b = temp; }

  000b5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000bd	48 89 44 24 50	 mov	 QWORD PTR temp$22806[rsp], rax
  000c2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000ca	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR a$[rsp], rax
  000d2	48 8b 44 24 50	 mov	 rax, QWORD PTR temp$22806[rsp]
  000d7	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2884 :         { Py_ssize_t size_temp = size_a;

  000df	48 8b 44 24 48	 mov	 rax, QWORD PTR size_a$[rsp]
  000e4	48 89 44 24 58	 mov	 QWORD PTR size_temp$22807[rsp], rax

; 2885 :             size_a = size_b;

  000e9	48 8b 44 24 28	 mov	 rax, QWORD PTR size_b$[rsp]
  000ee	48 89 44 24 48	 mov	 QWORD PTR size_a$[rsp], rax

; 2886 :             size_b = size_temp; }

  000f3	48 8b 44 24 58	 mov	 rax, QWORD PTR size_temp$22807[rsp]
  000f8	48 89 44 24 28	 mov	 QWORD PTR size_b$[rsp], rax
  000fd	e9 d8 00 00 00	 jmp	 $LN19@x_sub
$LN20@x_sub:

; 2887 :     }
; 2888 :     else if (size_a == size_b) {

  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR size_b$[rsp]
  00107	48 39 44 24 48	 cmp	 QWORD PTR size_a$[rsp], rax
  0010c	0f 85 c8 00 00
	00		 jne	 $LN18@x_sub

; 2889 :         /* Find highest digit where a and b differ: */
; 2890 :         i = size_a;

  00112	48 8b 44 24 48	 mov	 rax, QWORD PTR size_a$[rsp]
  00117	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN17@x_sub:

; 2891 :         while (--i >= 0 && a->ob_digit[i] == b->ob_digit[i])

  0011c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00121	48 ff c8	 dec	 rax
  00124	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00129	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0012f	7c 27		 jl	 SHORT $LN16@x_sub
  00131	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00139	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0013e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00146	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  0014b	42 8b 54 82 70	 mov	 edx, DWORD PTR [rdx+r8*4+112]
  00150	39 54 88 70	 cmp	 DWORD PTR [rax+rcx*4+112], edx
  00154	75 02		 jne	 SHORT $LN16@x_sub

; 2892 :             ;

  00156	eb c4		 jmp	 SHORT $LN17@x_sub
$LN16@x_sub:

; 2893 :         if (i < 0)

  00158	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0015e	7d 0c		 jge	 SHORT $LN15@x_sub

; 2894 :             return (PyLongObject *)PyLong_FromLong(0);

  00160	33 c9		 xor	 ecx, ecx
  00162	e8 00 00 00 00	 call	 PyLong_FromLong
  00167	e9 54 02 00 00	 jmp	 $LN21@x_sub
$LN15@x_sub:

; 2895 :         if (a->ob_digit[i] < b->ob_digit[i]) {

  0016c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00174	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00179	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00181	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00186	42 8b 54 82 70	 mov	 edx, DWORD PTR [rdx+r8*4+112]
  0018b	39 54 88 70	 cmp	 DWORD PTR [rax+rcx*4+112], edx
  0018f	73 32		 jae	 SHORT $LN14@x_sub

; 2896 :             sign = -1;

  00191	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR sign$[rsp], -1

; 2897 :             { PyLongObject *temp = a; a = b; b = temp; }

  00199	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001a1	48 89 44 24 60	 mov	 QWORD PTR temp$22816[rsp], rax
  001a6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  001ae	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR a$[rsp], rax
  001b6	48 8b 44 24 60	 mov	 rax, QWORD PTR temp$22816[rsp]
  001bb	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR b$[rsp], rax
$LN14@x_sub:

; 2898 :         }
; 2899 :         size_a = size_b = i+1;

  001c3	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  001c8	48 ff c0	 inc	 rax
  001cb	48 89 44 24 28	 mov	 QWORD PTR size_b$[rsp], rax
  001d0	48 8b 44 24 28	 mov	 rax, QWORD PTR size_b$[rsp]
  001d5	48 89 44 24 48	 mov	 QWORD PTR size_a$[rsp], rax
$LN18@x_sub:
$LN19@x_sub:

; 2900 :     }
; 2901 :     z = _PyLong_New(size_a);

  001da	48 8b 4c 24 48	 mov	 rcx, QWORD PTR size_a$[rsp]
  001df	e8 00 00 00 00	 call	 _PyLong_New
  001e4	48 89 44 24 38	 mov	 QWORD PTR z$[rsp], rax

; 2902 :     if (z == NULL)

  001e9	48 83 7c 24 38
	00		 cmp	 QWORD PTR z$[rsp], 0
  001ef	75 07		 jne	 SHORT $LN13@x_sub

; 2903 :         return NULL;

  001f1	33 c0		 xor	 eax, eax
  001f3	e9 c8 01 00 00	 jmp	 $LN21@x_sub
$LN13@x_sub:

; 2904 :     for (i = 0; i < size_b; ++i) {

  001f8	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00201	eb 0d		 jmp	 SHORT $LN12@x_sub
$LN11@x_sub:
  00203	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00208	48 ff c0	 inc	 rax
  0020b	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN12@x_sub:
  00210	48 8b 44 24 28	 mov	 rax, QWORD PTR size_b$[rsp]
  00215	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0021a	7d 5c		 jge	 SHORT $LN10@x_sub

; 2905 :         /* The following assumes unsigned arithmetic
; 2906 :            works module 2**N for some N>PyLong_SHIFT. */
; 2907 :         borrow = a->ob_digit[i] - b->ob_digit[i] - borrow;

  0021c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00224	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00229	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00231	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00236	42 8b 54 82 70	 mov	 edx, DWORD PTR [rdx+r8*4+112]
  0023b	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  0023f	2b c2		 sub	 eax, edx
  00241	2b 44 24 40	 sub	 eax, DWORD PTR borrow$[rsp]
  00245	89 44 24 40	 mov	 DWORD PTR borrow$[rsp], eax

; 2908 :         z->ob_digit[i] = borrow & PyLong_MASK;

  00249	8b 44 24 40	 mov	 eax, DWORD PTR borrow$[rsp]
  0024d	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00252	48 8b 4c 24 38	 mov	 rcx, QWORD PTR z$[rsp]
  00257	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0025c	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax

; 2909 :         borrow >>= PyLong_SHIFT;

  00260	8b 44 24 40	 mov	 eax, DWORD PTR borrow$[rsp]
  00264	c1 e8 1e	 shr	 eax, 30
  00267	89 44 24 40	 mov	 DWORD PTR borrow$[rsp], eax

; 2910 :         borrow &= 1; /* Keep only one sign bit */

  0026b	8b 44 24 40	 mov	 eax, DWORD PTR borrow$[rsp]
  0026f	83 e0 01	 and	 eax, 1
  00272	89 44 24 40	 mov	 DWORD PTR borrow$[rsp], eax

; 2911 :     }

  00276	eb 8b		 jmp	 SHORT $LN11@x_sub
$LN10@x_sub:

; 2912 :     for (; i < size_a; ++i) {

  00278	eb 0d		 jmp	 SHORT $LN9@x_sub
$LN8@x_sub:
  0027a	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0027f	48 ff c0	 inc	 rax
  00282	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN9@x_sub:
  00287	48 8b 44 24 48	 mov	 rax, QWORD PTR size_a$[rsp]
  0028c	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00291	7d 4a		 jge	 SHORT $LN7@x_sub

; 2913 :         borrow = a->ob_digit[i] - borrow;

  00293	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0029b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  002a0	8b 54 24 40	 mov	 edx, DWORD PTR borrow$[rsp]
  002a4	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  002a8	2b c2		 sub	 eax, edx
  002aa	89 44 24 40	 mov	 DWORD PTR borrow$[rsp], eax

; 2914 :         z->ob_digit[i] = borrow & PyLong_MASK;

  002ae	8b 44 24 40	 mov	 eax, DWORD PTR borrow$[rsp]
  002b2	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  002b7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR z$[rsp]
  002bc	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  002c1	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax

; 2915 :         borrow >>= PyLong_SHIFT;

  002c5	8b 44 24 40	 mov	 eax, DWORD PTR borrow$[rsp]
  002c9	c1 e8 1e	 shr	 eax, 30
  002cc	89 44 24 40	 mov	 DWORD PTR borrow$[rsp], eax

; 2916 :         borrow &= 1; /* Keep only one sign bit */

  002d0	8b 44 24 40	 mov	 eax, DWORD PTR borrow$[rsp]
  002d4	83 e0 01	 and	 eax, 1
  002d7	89 44 24 40	 mov	 DWORD PTR borrow$[rsp], eax

; 2917 :     }

  002db	eb 9d		 jmp	 SHORT $LN8@x_sub
$LN7@x_sub:

; 2918 :     assert(borrow == 0);

  002dd	83 7c 24 40 00	 cmp	 DWORD PTR borrow$[rsp], 0
  002e2	74 1c		 je	 SHORT $LN27@x_sub
  002e4	41 b8 66 0b 00
	00		 mov	 r8d, 2918		; 00000b66H
  002ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@FOIOBMFH@?$AAb?$AAo?$AAr?$AAr?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002fe	33 c0		 xor	 eax, eax
$LN27@x_sub:

; 2919 :     if (sign < 0)

  00300	83 7c 24 30 00	 cmp	 DWORD PTR sign$[rsp], 0
  00305	0f 8d ab 00 00
	00		 jge	 $LN6@x_sub
$LN5@x_sub:

; 2920 :         NEGATE(z);

  0030b	48 8b 44 24 38	 mov	 rax, QWORD PTR z$[rsp]
  00310	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  00315	75 17		 jne	 SHORT $LN2@x_sub
  00317	48 8b 44 24 38	 mov	 rax, QWORD PTR z$[rsp]
  0031c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00320	48 f7 d8	 neg	 rax
  00323	48 8b 4c 24 38	 mov	 rcx, QWORD PTR z$[rsp]
  00328	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  0032c	eb 7e		 jmp	 SHORT $LN1@x_sub
$LN2@x_sub:
  0032e	48 8b 44 24 38	 mov	 rax, QWORD PTR z$[rsp]
  00333	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00338	7d 13		 jge	 SHORT $LN30@x_sub
  0033a	48 8b 44 24 38	 mov	 rax, QWORD PTR z$[rsp]
  0033f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00342	f7 d8		 neg	 eax
  00344	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv183[rsp], eax
  0034b	eb 36		 jmp	 SHORT $LN31@x_sub
$LN30@x_sub:
  0034d	48 8b 44 24 38	 mov	 rax, QWORD PTR z$[rsp]
  00352	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00357	75 0d		 jne	 SHORT $LN28@x_sub
  00359	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
  00364	eb 0f		 jmp	 SHORT $LN29@x_sub
$LN28@x_sub:
  00366	48 8b 44 24 38	 mov	 rax, QWORD PTR z$[rsp]
  0036b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0036e	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv182[rsp], eax
$LN29@x_sub:
  00375	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv182[rsp]
  0037c	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv183[rsp], eax
$LN31@x_sub:
  00383	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv183[rsp]
  0038a	f7 d8		 neg	 eax
  0038c	8b c8		 mov	 ecx, eax
  0038e	e8 00 00 00 00	 call	 PyLong_FromLong
  00393	48 89 44 24 68	 mov	 QWORD PTR tmp$22841[rsp], rax
  00398	48 8b 4c 24 38	 mov	 rcx, QWORD PTR z$[rsp]
  0039d	e8 00 00 00 00	 call	 _Py_DecRef
  003a2	48 8b 44 24 68	 mov	 rax, QWORD PTR tmp$22841[rsp]
  003a7	48 89 44 24 38	 mov	 QWORD PTR z$[rsp], rax
$LN1@x_sub:
  003ac	33 c0		 xor	 eax, eax
  003ae	85 c0		 test	 eax, eax
  003b0	0f 85 55 ff ff
	ff		 jne	 $LN5@x_sub
$LN6@x_sub:

; 2921 :     return long_normalize(z);

  003b6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR z$[rsp]
  003bb	e8 00 00 00 00	 call	 long_normalize
$LN21@x_sub:

; 2922 : }

  003c0	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  003c7	c3		 ret	 0
x_sub	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_sub DD imagerel long_sub
	DD	imagerel long_sub+553
	DD	imagerel $unwind$long_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_sub DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_sub
_TEXT	SEGMENT
z$ = 32
r$22919 = 40
tv79 = 48
tv86 = 56
tv131 = 64
tv130 = 68
tv142 = 72
tv141 = 76
a$ = 96
b$ = 104
long_sub PROC						; COMDAT

; 2956 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN13@long_sub:

; 2957 :     PyLongObject *z;
; 2958 : 
; 2959 :     CHECK_BINOP(a, b);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00022	85 c0		 test	 eax, eax
  00024	74 18		 je	 SHORT $LN9@long_sub
  00026	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003a	85 c0		 test	 eax, eax
  0003c	75 18		 jne	 SHORT $LN10@long_sub
$LN9@long_sub:
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00045	e8 00 00 00 00	 call	 _Py_IncRef
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00051	e9 ce 01 00 00	 jmp	 $LN14@long_sub
$LN10@long_sub:
  00056	33 c0		 xor	 eax, eax
  00058	85 c0		 test	 eax, eax
  0005a	75 b2		 jne	 SHORT $LN13@long_sub

; 2960 : 
; 2961 :     if (ABS(Py_SIZE(a)) <= 1 && ABS(Py_SIZE(b)) <= 1) {

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00061	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00066	7d 13		 jge	 SHORT $LN16@long_sub
  00068	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0006d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00071	48 f7 d8	 neg	 rax
  00074	48 89 44 24 30	 mov	 QWORD PTR tv79[rsp], rax
  00079	eb 0e		 jmp	 SHORT $LN17@long_sub
$LN16@long_sub:
  0007b	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00080	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00084	48 89 44 24 30	 mov	 QWORD PTR tv79[rsp], rax
$LN17@long_sub:
  00089	48 83 7c 24 30
	01		 cmp	 QWORD PTR tv79[rsp], 1
  0008f	0f 8f e7 00 00
	00		 jg	 $LN8@long_sub
  00095	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  0009a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0009f	7d 13		 jge	 SHORT $LN18@long_sub
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  000a6	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000aa	48 f7 d8	 neg	 rax
  000ad	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
  000b2	eb 0e		 jmp	 SHORT $LN19@long_sub
$LN18@long_sub:
  000b4	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  000b9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000bd	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
$LN19@long_sub:
  000c2	48 83 7c 24 38
	01		 cmp	 QWORD PTR tv86[rsp], 1
  000c8	0f 8f ae 00 00
	00		 jg	 $LN8@long_sub

; 2962 :         PyObject* r;
; 2963 :         r = PyLong_FromLong(MEDIUM_VALUE(a)-MEDIUM_VALUE(b));

  000ce	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  000d3	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000d8	7d 10		 jge	 SHORT $LN22@long_sub
  000da	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  000df	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000e2	f7 d8		 neg	 eax
  000e4	89 44 24 40	 mov	 DWORD PTR tv131[rsp], eax
  000e8	eb 2a		 jmp	 SHORT $LN23@long_sub
$LN22@long_sub:
  000ea	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  000ef	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000f4	75 0a		 jne	 SHORT $LN20@long_sub
  000f6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
  000fe	eb 0c		 jmp	 SHORT $LN21@long_sub
$LN20@long_sub:
  00100	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00105	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00108	89 44 24 44	 mov	 DWORD PTR tv130[rsp], eax
$LN21@long_sub:
  0010c	8b 44 24 44	 mov	 eax, DWORD PTR tv130[rsp]
  00110	89 44 24 40	 mov	 DWORD PTR tv131[rsp], eax
$LN23@long_sub:
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  00119	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0011e	7d 10		 jge	 SHORT $LN26@long_sub
  00120	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  00125	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00128	f7 d8		 neg	 eax
  0012a	89 44 24 48	 mov	 DWORD PTR tv142[rsp], eax
  0012e	eb 2a		 jmp	 SHORT $LN27@long_sub
$LN26@long_sub:
  00130	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  00135	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0013a	75 0a		 jne	 SHORT $LN24@long_sub
  0013c	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
  00144	eb 0c		 jmp	 SHORT $LN25@long_sub
$LN24@long_sub:
  00146	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  0014b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0014e	89 44 24 4c	 mov	 DWORD PTR tv141[rsp], eax
$LN25@long_sub:
  00152	8b 44 24 4c	 mov	 eax, DWORD PTR tv141[rsp]
  00156	89 44 24 48	 mov	 DWORD PTR tv142[rsp], eax
$LN27@long_sub:
  0015a	8b 44 24 48	 mov	 eax, DWORD PTR tv142[rsp]
  0015e	8b 4c 24 40	 mov	 ecx, DWORD PTR tv131[rsp]
  00162	2b c8		 sub	 ecx, eax
  00164	8b c1		 mov	 eax, ecx
  00166	8b c8		 mov	 ecx, eax
  00168	e8 00 00 00 00	 call	 PyLong_FromLong
  0016d	48 89 44 24 28	 mov	 QWORD PTR r$22919[rsp], rax

; 2964 :         return r;

  00172	48 8b 44 24 28	 mov	 rax, QWORD PTR r$22919[rsp]
  00177	e9 a8 00 00 00	 jmp	 $LN14@long_sub
$LN8@long_sub:

; 2965 :     }
; 2966 :     if (Py_SIZE(a) < 0) {

  0017c	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00181	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00186	7d 61		 jge	 SHORT $LN7@long_sub

; 2967 :         if (Py_SIZE(b) < 0)

  00188	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  0018d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00192	7d 16		 jge	 SHORT $LN6@long_sub

; 2968 :             z = x_sub(a, b);

  00194	48 8b 54 24 68	 mov	 rdx, QWORD PTR b$[rsp]
  00199	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  0019e	e8 00 00 00 00	 call	 x_sub
  001a3	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax

; 2969 :         else

  001a8	eb 14		 jmp	 SHORT $LN5@long_sub
$LN6@long_sub:

; 2970 :             z = x_add(a, b);

  001aa	48 8b 54 24 68	 mov	 rdx, QWORD PTR b$[rsp]
  001af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  001b4	e8 00 00 00 00	 call	 x_add
  001b9	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax
$LN5@long_sub:

; 2971 :         if (z != NULL && Py_SIZE(z) != 0)

  001be	48 83 7c 24 20
	00		 cmp	 QWORD PTR z$[rsp], 0
  001c4	74 21		 je	 SHORT $LN4@long_sub
  001c6	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  001cb	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001d0	74 15		 je	 SHORT $LN4@long_sub

; 2972 :             Py_SIZE(z) = -(Py_SIZE(z));

  001d2	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  001d7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001db	48 f7 d8	 neg	 rax
  001de	48 8b 4c 24 20	 mov	 rcx, QWORD PTR z$[rsp]
  001e3	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN4@long_sub:

; 2973 :     }
; 2974 :     else {

  001e7	eb 36		 jmp	 SHORT $LN3@long_sub
$LN7@long_sub:

; 2975 :         if (Py_SIZE(b) < 0)

  001e9	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  001ee	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001f3	7d 16		 jge	 SHORT $LN2@long_sub

; 2976 :             z = x_add(a, b);

  001f5	48 8b 54 24 68	 mov	 rdx, QWORD PTR b$[rsp]
  001fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  001ff	e8 00 00 00 00	 call	 x_add
  00204	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax

; 2977 :         else

  00209	eb 14		 jmp	 SHORT $LN1@long_sub
$LN2@long_sub:

; 2978 :             z = x_sub(a, b);

  0020b	48 8b 54 24 68	 mov	 rdx, QWORD PTR b$[rsp]
  00210	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00215	e8 00 00 00 00	 call	 x_sub
  0021a	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax
$LN1@long_sub:
$LN3@long_sub:

; 2979 :     }
; 2980 :     return (PyObject *)z;

  0021f	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
$LN14@long_sub:

; 2981 : }

  00224	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00228	c3		 ret	 0
long_sub ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_mul DD imagerel long_mul
	DD	imagerel long_mul+605
	DD	imagerel $unwind$long_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_mul DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_mul
_TEXT	SEGMENT
z$ = 32
v$23276 = 40
tmp$23300 = 48
tv79 = 56
tv86 = 64
tv130 = 72
tv129 = 76
tv142 = 80
tv141 = 84
tv171 = 88
tv170 = 92
a$ = 112
b$ = 120
long_mul PROC						; COMDAT

; 3388 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN12@long_mul:

; 3389 :     PyLongObject *z;
; 3390 : 
; 3391 :     CHECK_BINOP(a, b);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00022	85 c0		 test	 eax, eax
  00024	74 18		 je	 SHORT $LN8@long_mul
  00026	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003a	85 c0		 test	 eax, eax
  0003c	75 18		 jne	 SHORT $LN9@long_mul
$LN8@long_mul:
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00045	e8 00 00 00 00	 call	 _Py_IncRef
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00051	e9 02 02 00 00	 jmp	 $LN13@long_mul
$LN9@long_mul:
  00056	33 c0		 xor	 eax, eax
  00058	85 c0		 test	 eax, eax
  0005a	75 b2		 jne	 SHORT $LN12@long_mul

; 3392 : 
; 3393 :     /* fast path for single-digit multiplication */
; 3394 :     if (ABS(Py_SIZE(a)) <= 1 && ABS(Py_SIZE(b)) <= 1) {

  0005c	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00061	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00066	7d 13		 jge	 SHORT $LN15@long_mul
  00068	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  0006d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00071	48 f7 d8	 neg	 rax
  00074	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
  00079	eb 0e		 jmp	 SHORT $LN16@long_mul
$LN15@long_mul:
  0007b	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00080	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00084	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
$LN16@long_mul:
  00089	48 83 7c 24 38
	01		 cmp	 QWORD PTR tv79[rsp], 1
  0008f	0f 8f e7 00 00
	00		 jg	 $LN7@long_mul
  00095	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  0009a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0009f	7d 13		 jge	 SHORT $LN17@long_mul
  000a1	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  000a6	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000aa	48 f7 d8	 neg	 rax
  000ad	48 89 44 24 40	 mov	 QWORD PTR tv86[rsp], rax
  000b2	eb 0e		 jmp	 SHORT $LN18@long_mul
$LN17@long_mul:
  000b4	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  000b9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000bd	48 89 44 24 40	 mov	 QWORD PTR tv86[rsp], rax
$LN18@long_mul:
  000c2	48 83 7c 24 40
	01		 cmp	 QWORD PTR tv86[rsp], 1
  000c8	0f 8f ae 00 00
	00		 jg	 $LN7@long_mul

; 3395 :         stwodigits v = (stwodigits)(MEDIUM_VALUE(a)) * MEDIUM_VALUE(b);

  000ce	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  000d3	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000d8	7d 10		 jge	 SHORT $LN21@long_mul
  000da	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  000df	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000e2	f7 d8		 neg	 eax
  000e4	89 44 24 48	 mov	 DWORD PTR tv130[rsp], eax
  000e8	eb 2a		 jmp	 SHORT $LN22@long_mul
$LN21@long_mul:
  000ea	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  000ef	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000f4	75 0a		 jne	 SHORT $LN19@long_mul
  000f6	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
  000fe	eb 0c		 jmp	 SHORT $LN20@long_mul
$LN19@long_mul:
  00100	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00105	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00108	89 44 24 4c	 mov	 DWORD PTR tv129[rsp], eax
$LN20@long_mul:
  0010c	8b 44 24 4c	 mov	 eax, DWORD PTR tv129[rsp]
  00110	89 44 24 48	 mov	 DWORD PTR tv130[rsp], eax
$LN22@long_mul:
  00114	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  00119	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0011e	7d 10		 jge	 SHORT $LN25@long_mul
  00120	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  00125	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00128	f7 d8		 neg	 eax
  0012a	89 44 24 50	 mov	 DWORD PTR tv142[rsp], eax
  0012e	eb 2a		 jmp	 SHORT $LN26@long_mul
$LN25@long_mul:
  00130	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  00135	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0013a	75 0a		 jne	 SHORT $LN23@long_mul
  0013c	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
  00144	eb 0c		 jmp	 SHORT $LN24@long_mul
$LN23@long_mul:
  00146	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  0014b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0014e	89 44 24 54	 mov	 DWORD PTR tv141[rsp], eax
$LN24@long_mul:
  00152	8b 44 24 54	 mov	 eax, DWORD PTR tv141[rsp]
  00156	89 44 24 50	 mov	 DWORD PTR tv142[rsp], eax
$LN26@long_mul:
  0015a	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv130[rsp]
  0015f	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR tv142[rsp]
  00164	48 0f af c1	 imul	 rax, rcx
  00168	48 89 44 24 28	 mov	 QWORD PTR v$23276[rsp], rax

; 3396 : #ifdef HAVE_LONG_LONG
; 3397 :         return PyLong_FromLongLong((PY_LONG_LONG)v);

  0016d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$23276[rsp]
  00172	e8 00 00 00 00	 call	 PyLong_FromLongLong
  00177	e9 dc 00 00 00	 jmp	 $LN13@long_mul
$LN7@long_mul:

; 3398 : #else
; 3399 :         /* if we don't have long long then we're almost certainly
; 3400 :            using 15-bit digits, so v will fit in a long.  In the
; 3401 :            unlikely event that we're using 30-bit digits on a platform
; 3402 :            without long long, a large v will just cause us to fall
; 3403 :            through to the general multiplication code below. */
; 3404 :         if (v >= LONG_MIN && v <= LONG_MAX)
; 3405 :             return PyLong_FromLong((long)v);
; 3406 : #endif
; 3407 :     }
; 3408 : 
; 3409 :     z = k_mul(a, b);

  0017c	48 8b 54 24 78	 mov	 rdx, QWORD PTR b$[rsp]
  00181	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a$[rsp]
  00186	e8 00 00 00 00	 call	 k_mul
  0018b	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax

; 3410 :     /* Negate if exactly one of the inputs is negative. */
; 3411 :     if (((Py_SIZE(a) ^ Py_SIZE(b)) < 0) && z)

  00190	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00195	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  0019a	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0019e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001a2	48 33 c1	 xor	 rax, rcx
  001a5	48 85 c0	 test	 rax, rax
  001a8	0f 8d a5 00 00
	00		 jge	 $LN6@long_mul
  001ae	48 83 7c 24 20
	00		 cmp	 QWORD PTR z$[rsp], 0
  001b4	0f 84 99 00 00
	00		 je	 $LN6@long_mul
$LN5@long_mul:

; 3412 :         NEGATE(z);

  001ba	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  001bf	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  001c4	75 17		 jne	 SHORT $LN2@long_mul
  001c6	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  001cb	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001cf	48 f7 d8	 neg	 rax
  001d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR z$[rsp]
  001d7	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  001db	eb 6c		 jmp	 SHORT $LN1@long_mul
$LN2@long_mul:
  001dd	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  001e2	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001e7	7d 10		 jge	 SHORT $LN29@long_mul
  001e9	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  001ee	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001f1	f7 d8		 neg	 eax
  001f3	89 44 24 58	 mov	 DWORD PTR tv171[rsp], eax
  001f7	eb 2a		 jmp	 SHORT $LN30@long_mul
$LN29@long_mul:
  001f9	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  001fe	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00203	75 0a		 jne	 SHORT $LN27@long_mul
  00205	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv170[rsp], 0
  0020d	eb 0c		 jmp	 SHORT $LN28@long_mul
$LN27@long_mul:
  0020f	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  00214	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00217	89 44 24 5c	 mov	 DWORD PTR tv170[rsp], eax
$LN28@long_mul:
  0021b	8b 44 24 5c	 mov	 eax, DWORD PTR tv170[rsp]
  0021f	89 44 24 58	 mov	 DWORD PTR tv171[rsp], eax
$LN30@long_mul:
  00223	8b 44 24 58	 mov	 eax, DWORD PTR tv171[rsp]
  00227	f7 d8		 neg	 eax
  00229	8b c8		 mov	 ecx, eax
  0022b	e8 00 00 00 00	 call	 PyLong_FromLong
  00230	48 89 44 24 30	 mov	 QWORD PTR tmp$23300[rsp], rax
  00235	48 8b 4c 24 20	 mov	 rcx, QWORD PTR z$[rsp]
  0023a	e8 00 00 00 00	 call	 _Py_DecRef
  0023f	48 8b 44 24 30	 mov	 rax, QWORD PTR tmp$23300[rsp]
  00244	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax
$LN1@long_mul:
  00249	33 c0		 xor	 eax, eax
  0024b	85 c0		 test	 eax, eax
  0024d	0f 85 67 ff ff
	ff		 jne	 $LN5@long_mul
$LN6@long_mul:

; 3413 :     return (PyObject *)z;

  00253	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
$LN13@long_mul:

; 3414 : }

  00258	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0025c	c3		 ret	 0
long_mul ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@MOBFFO@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA3?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@LPDLBLKI@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA2?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA?$CK?$AAs?$AAh?$AAi?$AAf?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@KOKGIEMP@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA2?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EM@BEDOBFIJ@?$AA2?$AA?$CK?$AAs?$AAh?$AAi?$AAf?$AAt?$AA?5?$AA?$CL?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA1?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE@ ; `string'
PUBLIC	??_C@_1CC@IHGODADN@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA1?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@LAOAPMKG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAa?$AAh?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$k_mul DD	imagerel k_mul
	DD	imagerel k_mul+1882
	DD	imagerel $unwind$k_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$k_mul DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_1CC@MOBFFO@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA3?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MOBFFO@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA3?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'(', 00H, 't', 00H, '3', 00H, ')', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@LPDLBLKI@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA2?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA?$CK?$AAs?$AAh?$AAi?$AAf?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@LPDLBLKI@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA2?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA?$CK?$AAs?$AAh?$AAi?$AAf?$AAt?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'(', 00H, 't', 00H, '2', 00H, ')', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, '2', 00H, '*', 00H, 's', 00H, 'h', 00H, 'i', 00H
	DB	'f', 00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@KOKGIEMP@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA2?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@KOKGIEMP@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA2?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'(', 00H, 't', 00H, '2', 00H, ')', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@BEDOBFIJ@?$AA2?$AA?$CK?$AAs?$AAh?$AAi?$AAf?$AAt?$AA?5?$AA?$CL?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA1?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE@
CONST	SEGMENT
??_C@_1EM@BEDOBFIJ@?$AA2?$AA?$CK?$AAs?$AAh?$AAi?$AAf?$AAt?$AA?5?$AA?$CL?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA1?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE@ DB '2'
	DB	00H, '*', 00H, 's', 00H, 'h', 00H, 'i', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, '+', 00H, ' ', 00H, 'P', 00H, 'y', 00H, '_', 00H, 'S'
	DB	00H, 'I', 00H, 'Z', 00H, 'E', 00H, '(', 00H, 't', 00H, '1', 00H
	DB	')', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'y'
	DB	00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '(', 00H
	DB	'r', 00H, 'e', 00H, 't', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@IHGODADN@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA1?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@IHGODADN@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA1?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'(', 00H, 't', 00H, '1', 00H, ')', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@LAOAPMKG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAa?$AAh?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@LAOAPMKG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAa?$AAh?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'(', 00H, 'a', 00H, 'h', 00H, ')', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT k_mul
_TEXT	SEGMENT
bh$ = 32
i$ = 40
t2$ = 48
t3$ = 56
bsize$ = 64
ah$ = 72
ret$ = 80
bl$ = 88
t1$ = 96
asize$ = 104
shift$ = 112
al$ = 120
tv69 = 128
tv75 = 136
tv78 = 144
tv184 = 152
tv226 = 160
a$ = 192
b$ = 200
k_mul	PROC						; COMDAT

; 3113 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 3114 :     Py_ssize_t asize = ABS(Py_SIZE(a));

  00011	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00019	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001e	7d 19		 jge	 SHORT $LN42@k_mul
  00020	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00028	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002c	48 f7 d8	 neg	 rax
  0002f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
  00037	eb 14		 jmp	 SHORT $LN43@k_mul
$LN42@k_mul:
  00039	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00041	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00045	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
$LN43@k_mul:
  0004d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv69[rsp]
  00055	48 89 44 24 68	 mov	 QWORD PTR asize$[rsp], rax

; 3115 :     Py_ssize_t bsize = ABS(Py_SIZE(b));

  0005a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00062	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00067	7d 19		 jge	 SHORT $LN44@k_mul
  00069	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00071	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00075	48 f7 d8	 neg	 rax
  00078	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  00080	eb 14		 jmp	 SHORT $LN45@k_mul
$LN44@k_mul:
  00082	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0008a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
$LN45@k_mul:
  00096	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  0009e	48 89 44 24 40	 mov	 QWORD PTR bsize$[rsp], rax

; 3116 :     PyLongObject *ah = NULL;

  000a3	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR ah$[rsp], 0

; 3117 :     PyLongObject *al = NULL;

  000ac	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR al$[rsp], 0

; 3118 :     PyLongObject *bh = NULL;

  000b5	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR bh$[rsp], 0

; 3119 :     PyLongObject *bl = NULL;

  000be	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR bl$[rsp], 0

; 3120 :     PyLongObject *ret = NULL;

  000c7	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR ret$[rsp], 0

; 3121 :     PyLongObject *t1, *t2, *t3;
; 3122 :     Py_ssize_t shift;           /* the number of digits we split off */
; 3123 :     Py_ssize_t i;
; 3124 : 
; 3125 :     /* (ah*X+al)(bh*X+bl) = ah*bh*X*X + (ah*bl + al*bh)*X + al*bl
; 3126 :      * Let k = (ah+al)*(bh+bl) = ah*bl + al*bh  + ah*bh + al*bl
; 3127 :      * Then the original product is
; 3128 :      *     ah*bh*X*X + (k - ah*bh - al*bl)*X + al*bl
; 3129 :      * By picking X to be a power of 2, "*X" is just shifting, and it's
; 3130 :      * been reduced to 3 multiplies on numbers half the size.
; 3131 :      */
; 3132 : 
; 3133 :     /* We want to split based on the larger number; fiddle so that b
; 3134 :      * is largest.
; 3135 :      */
; 3136 :     if (asize > bsize) {

  000d0	48 8b 44 24 40	 mov	 rax, QWORD PTR bsize$[rsp]
  000d5	48 39 44 24 68	 cmp	 QWORD PTR asize$[rsp], rax
  000da	7e 48		 jle	 SHORT $LN39@k_mul

; 3137 :         t1 = a;

  000dc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000e4	48 89 44 24 60	 mov	 QWORD PTR t1$[rsp], rax

; 3138 :         a = b;

  000e9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000f1	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR a$[rsp], rax

; 3139 :         b = t1;

  000f9	48 8b 44 24 60	 mov	 rax, QWORD PTR t1$[rsp]
  000fe	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 3140 : 
; 3141 :         i = asize;

  00106	48 8b 44 24 68	 mov	 rax, QWORD PTR asize$[rsp]
  0010b	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 3142 :         asize = bsize;

  00110	48 8b 44 24 40	 mov	 rax, QWORD PTR bsize$[rsp]
  00115	48 89 44 24 68	 mov	 QWORD PTR asize$[rsp], rax

; 3143 :         bsize = i;

  0011a	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0011f	48 89 44 24 40	 mov	 QWORD PTR bsize$[rsp], rax
$LN39@k_mul:

; 3144 :     }
; 3145 : 
; 3146 :     /* Use gradeschool math when either number is too small. */
; 3147 :     i = a == b ? KARATSUBA_SQUARE_CUTOFF : KARATSUBA_CUTOFF;

  00124	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0012c	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR a$[rsp], rax
  00134	75 0d		 jne	 SHORT $LN46@k_mul
  00136	c7 84 24 90 00
	00 00 8c 00 00
	00		 mov	 DWORD PTR tv78[rsp], 140 ; 0000008cH
  00141	eb 0b		 jmp	 SHORT $LN47@k_mul
$LN46@k_mul:
  00143	c7 84 24 90 00
	00 00 46 00 00
	00		 mov	 DWORD PTR tv78[rsp], 70	; 00000046H
$LN47@k_mul:
  0014e	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR tv78[rsp]
  00156	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 3148 :     if (asize <= i) {

  0015b	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00160	48 39 44 24 68	 cmp	 QWORD PTR asize$[rsp], rax
  00165	7f 30		 jg	 SHORT $LN38@k_mul

; 3149 :         if (asize == 0)

  00167	48 83 7c 24 68
	00		 cmp	 QWORD PTR asize$[rsp], 0
  0016d	75 0e		 jne	 SHORT $LN37@k_mul

; 3150 :             return (PyLongObject *)PyLong_FromLong(0);

  0016f	33 c9		 xor	 ecx, ecx
  00171	e8 00 00 00 00	 call	 PyLong_FromLong
  00176	e9 d7 05 00 00	 jmp	 $LN40@k_mul

; 3151 :         else

  0017b	eb 1a		 jmp	 SHORT $LN36@k_mul
$LN37@k_mul:

; 3152 :             return x_mul(a, b);

  0017d	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00185	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0018d	e8 00 00 00 00	 call	 x_mul
  00192	e9 bb 05 00 00	 jmp	 $LN40@k_mul
$LN36@k_mul:
$LN38@k_mul:

; 3153 :     }
; 3154 : 
; 3155 :     /* If a is small compared to b, splitting on b gives a degenerate
; 3156 :      * case with ah==0, and Karatsuba may be (even much) less efficient
; 3157 :      * than "grade school" then.  However, we can still win, by viewing
; 3158 :      * b as a string of "big digits", each of width a->ob_size.  That
; 3159 :      * leads to a sequence of balanced calls to k_mul.
; 3160 :      */
; 3161 :     if (2 * asize <= bsize)

  00197	48 8b 44 24 68	 mov	 rax, QWORD PTR asize$[rsp]
  0019c	48 d1 e0	 shl	 rax, 1
  0019f	48 3b 44 24 40	 cmp	 rax, QWORD PTR bsize$[rsp]
  001a4	7f 1a		 jg	 SHORT $LN35@k_mul

; 3162 :         return k_lopsided_mul(a, b);

  001a6	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  001ae	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001b6	e8 00 00 00 00	 call	 k_lopsided_mul
  001bb	e9 92 05 00 00	 jmp	 $LN40@k_mul
$LN35@k_mul:

; 3163 : 
; 3164 :     /* Split a & b into hi & lo pieces. */
; 3165 :     shift = bsize >> 1;

  001c0	48 8b 44 24 40	 mov	 rax, QWORD PTR bsize$[rsp]
  001c5	48 d1 f8	 sar	 rax, 1
  001c8	48 89 44 24 70	 mov	 QWORD PTR shift$[rsp], rax

; 3166 :     if (kmul_split(a, shift, &ah, &al) < 0) goto fail;

  001cd	4c 8d 4c 24 78	 lea	 r9, QWORD PTR al$[rsp]
  001d2	4c 8d 44 24 48	 lea	 r8, QWORD PTR ah$[rsp]
  001d7	48 8b 54 24 70	 mov	 rdx, QWORD PTR shift$[rsp]
  001dc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001e4	e8 00 00 00 00	 call	 kmul_split
  001e9	85 c0		 test	 eax, eax
  001eb	7d 05		 jge	 SHORT $LN34@k_mul
  001ed	e9 e6 04 00 00	 jmp	 $fail$23103
$LN34@k_mul:

; 3167 :     assert(Py_SIZE(ah) > 0);            /* the split isn't degenerate */

  001f2	48 8b 44 24 48	 mov	 rax, QWORD PTR ah$[rsp]
  001f7	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001fc	7f 1c		 jg	 SHORT $LN48@k_mul
  001fe	41 b8 5f 0c 00
	00		 mov	 r8d, 3167		; 00000c5fH
  00204	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@LAOAPMKG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAa?$AAh?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00218	33 c0		 xor	 eax, eax
$LN48@k_mul:

; 3168 : 
; 3169 :     if (a == b) {

  0021a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00222	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR a$[rsp], rax
  0022a	75 2a		 jne	 SHORT $LN33@k_mul

; 3170 :         bh = ah;

  0022c	48 8b 44 24 48	 mov	 rax, QWORD PTR ah$[rsp]
  00231	48 89 44 24 20	 mov	 QWORD PTR bh$[rsp], rax

; 3171 :         bl = al;

  00236	48 8b 44 24 78	 mov	 rax, QWORD PTR al$[rsp]
  0023b	48 89 44 24 58	 mov	 QWORD PTR bl$[rsp], rax

; 3172 :         Py_INCREF(bh);

  00240	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bh$[rsp]
  00245	e8 00 00 00 00	 call	 _Py_IncRef

; 3173 :         Py_INCREF(bl);

  0024a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bl$[rsp]
  0024f	e8 00 00 00 00	 call	 _Py_IncRef
  00254	eb 25		 jmp	 SHORT $LN32@k_mul
$LN33@k_mul:

; 3174 :     }
; 3175 :     else if (kmul_split(b, shift, &bh, &bl) < 0) goto fail;

  00256	4c 8d 4c 24 58	 lea	 r9, QWORD PTR bl$[rsp]
  0025b	4c 8d 44 24 20	 lea	 r8, QWORD PTR bh$[rsp]
  00260	48 8b 54 24 70	 mov	 rdx, QWORD PTR shift$[rsp]
  00265	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0026d	e8 00 00 00 00	 call	 kmul_split
  00272	85 c0		 test	 eax, eax
  00274	7d 05		 jge	 SHORT $LN31@k_mul
  00276	e9 5d 04 00 00	 jmp	 $fail$23103
$LN31@k_mul:
$LN32@k_mul:

; 3176 : 
; 3177 :     /* The plan:
; 3178 :      * 1. Allocate result space (asize + bsize digits:  that's always
; 3179 :      *    enough).
; 3180 :      * 2. Compute ah*bh, and copy into result at 2*shift.
; 3181 :      * 3. Compute al*bl, and copy into result at 0.  Note that this
; 3182 :      *    can't overlap with #2.
; 3183 :      * 4. Subtract al*bl from the result, starting at shift.  This may
; 3184 :      *    underflow (borrow out of the high digit), but we don't care:
; 3185 :      *    we're effectively doing unsigned arithmetic mod
; 3186 :      *    BASE**(sizea + sizeb), and so long as the *final* result fits,
; 3187 :      *    borrows and carries out of the high digit can be ignored.
; 3188 :      * 5. Subtract ah*bh from the result, starting at shift.
; 3189 :      * 6. Compute (ah+al)*(bh+bl), and add it into the result starting
; 3190 :      *    at shift.
; 3191 :      */
; 3192 : 
; 3193 :     /* 1. Allocate result space. */
; 3194 :     ret = _PyLong_New(asize + bsize);

  0027b	48 8b 44 24 40	 mov	 rax, QWORD PTR bsize$[rsp]
  00280	48 8b 4c 24 68	 mov	 rcx, QWORD PTR asize$[rsp]
  00285	48 03 c8	 add	 rcx, rax
  00288	48 8b c1	 mov	 rax, rcx
  0028b	48 8b c8	 mov	 rcx, rax
  0028e	e8 00 00 00 00	 call	 _PyLong_New
  00293	48 89 44 24 50	 mov	 QWORD PTR ret$[rsp], rax

; 3195 :     if (ret == NULL) goto fail;

  00298	48 83 7c 24 50
	00		 cmp	 QWORD PTR ret$[rsp], 0
  0029e	75 05		 jne	 SHORT $LN30@k_mul
  002a0	e9 33 04 00 00	 jmp	 $fail$23103
$LN30@k_mul:

; 3196 : #ifdef Py_DEBUG
; 3197 :     /* Fill with trash, to catch reference to uninitialized digits. */
; 3198 :     memset(ret->ob_digit, 0xDF, Py_SIZE(ret) * sizeof(digit));

  002a5	48 8b 44 24 50	 mov	 rax, QWORD PTR ret$[rsp]
  002aa	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002ae	48 c1 e0 02	 shl	 rax, 2
  002b2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ret$[rsp]
  002b7	48 83 c1 70	 add	 rcx, 112		; 00000070H
  002bb	4c 8b c0	 mov	 r8, rax
  002be	ba df 00 00 00	 mov	 edx, 223		; 000000dfH
  002c3	e8 00 00 00 00	 call	 memset

; 3199 : #endif
; 3200 : 
; 3201 :     /* 2. t1 <- ah*bh, and copy into high digits of result. */
; 3202 :     if ((t1 = k_mul(ah, bh)) == NULL) goto fail;

  002c8	48 8b 54 24 20	 mov	 rdx, QWORD PTR bh$[rsp]
  002cd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ah$[rsp]
  002d2	e8 00 00 00 00	 call	 k_mul
  002d7	48 89 44 24 60	 mov	 QWORD PTR t1$[rsp], rax
  002dc	48 83 7c 24 60
	00		 cmp	 QWORD PTR t1$[rsp], 0
  002e2	75 05		 jne	 SHORT $LN29@k_mul
  002e4	e9 ef 03 00 00	 jmp	 $fail$23103
$LN29@k_mul:

; 3203 :     assert(Py_SIZE(t1) >= 0);

  002e9	48 8b 44 24 60	 mov	 rax, QWORD PTR t1$[rsp]
  002ee	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  002f3	7d 1c		 jge	 SHORT $LN49@k_mul
  002f5	41 b8 83 0c 00
	00		 mov	 r8d, 3203		; 00000c83H
  002fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00302	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@IHGODADN@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA1?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00309	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0030f	33 c0		 xor	 eax, eax
$LN49@k_mul:

; 3204 :     assert(2*shift + Py_SIZE(t1) <= Py_SIZE(ret));

  00311	48 8b 44 24 60	 mov	 rax, QWORD PTR t1$[rsp]
  00316	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0031a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR shift$[rsp]
  0031f	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00323	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ret$[rsp]
  00328	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  0032c	7e 1c		 jle	 SHORT $LN50@k_mul
  0032e	41 b8 84 0c 00
	00		 mov	 r8d, 3204		; 00000c84H
  00334	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0033b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@BEDOBFIJ@?$AA2?$AA?$CK?$AAs?$AAh?$AAi?$AAf?$AAt?$AA?5?$AA?$CL?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA1?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE@
  00342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00348	33 c0		 xor	 eax, eax
$LN50@k_mul:

; 3205 :     memcpy(ret->ob_digit + 2*shift, t1->ob_digit,
; 3206 :            Py_SIZE(t1) * sizeof(digit));

  0034a	48 8b 44 24 60	 mov	 rax, QWORD PTR t1$[rsp]
  0034f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00353	48 c1 e0 02	 shl	 rax, 2
  00357	48 8b 4c 24 60	 mov	 rcx, QWORD PTR t1$[rsp]
  0035c	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00360	48 8b 54 24 70	 mov	 rdx, QWORD PTR shift$[rsp]
  00365	48 03 d2	 add	 rdx, rdx
  00368	4c 8b 44 24 50	 mov	 r8, QWORD PTR ret$[rsp]
  0036d	49 8d 54 90 70	 lea	 rdx, QWORD PTR [r8+rdx*4+112]
  00372	48 89 94 24 98
	00 00 00	 mov	 QWORD PTR tv184[rsp], rdx
  0037a	4c 8b c0	 mov	 r8, rax
  0037d	48 8b d1	 mov	 rdx, rcx
  00380	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv184[rsp]
  00388	48 8b c8	 mov	 rcx, rax
  0038b	e8 00 00 00 00	 call	 memcpy

; 3207 : 
; 3208 :     /* Zero-out the digits higher than the ah*bh copy. */
; 3209 :     i = Py_SIZE(ret) - 2*shift - Py_SIZE(t1);

  00390	48 8b 44 24 70	 mov	 rax, QWORD PTR shift$[rsp]
  00395	48 03 c0	 add	 rax, rax
  00398	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ret$[rsp]
  0039d	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  003a1	48 2b c8	 sub	 rcx, rax
  003a4	48 8b c1	 mov	 rax, rcx
  003a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR t1$[rsp]
  003ac	48 2b 41 60	 sub	 rax, QWORD PTR [rcx+96]
  003b0	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 3210 :     if (i)

  003b5	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  003bb	74 32		 je	 SHORT $LN28@k_mul

; 3211 :         memset(ret->ob_digit + 2*shift + Py_SIZE(t1), 0,
; 3212 :                i * sizeof(digit));

  003bd	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  003c2	48 c1 e0 02	 shl	 rax, 2
  003c6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR shift$[rsp]
  003cb	48 03 c9	 add	 rcx, rcx
  003ce	48 8b 54 24 50	 mov	 rdx, QWORD PTR ret$[rsp]
  003d3	48 8d 4c 8a 70	 lea	 rcx, QWORD PTR [rdx+rcx*4+112]
  003d8	48 8b 54 24 60	 mov	 rdx, QWORD PTR t1$[rsp]
  003dd	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  003e1	48 8d 0c 91	 lea	 rcx, QWORD PTR [rcx+rdx*4]
  003e5	4c 8b c0	 mov	 r8, rax
  003e8	33 d2		 xor	 edx, edx
  003ea	e8 00 00 00 00	 call	 memset
$LN28@k_mul:

; 3213 : 
; 3214 :     /* 3. t2 <- al*bl, and copy into the low digits. */
; 3215 :     if ((t2 = k_mul(al, bl)) == NULL) {

  003ef	48 8b 54 24 58	 mov	 rdx, QWORD PTR bl$[rsp]
  003f4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR al$[rsp]
  003f9	e8 00 00 00 00	 call	 k_mul
  003fe	48 89 44 24 30	 mov	 QWORD PTR t2$[rsp], rax
  00403	48 83 7c 24 30
	00		 cmp	 QWORD PTR t2$[rsp], 0
  00409	75 0f		 jne	 SHORT $LN27@k_mul

; 3216 :         Py_DECREF(t1);

  0040b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR t1$[rsp]
  00410	e8 00 00 00 00	 call	 _Py_DecRef

; 3217 :         goto fail;

  00415	e9 be 02 00 00	 jmp	 $fail$23103
$LN27@k_mul:

; 3218 :     }
; 3219 :     assert(Py_SIZE(t2) >= 0);

  0041a	48 8b 44 24 30	 mov	 rax, QWORD PTR t2$[rsp]
  0041f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00424	7d 1c		 jge	 SHORT $LN51@k_mul
  00426	41 b8 93 0c 00
	00		 mov	 r8d, 3219		; 00000c93H
  0042c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00433	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@KOKGIEMP@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA2?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0043a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00440	33 c0		 xor	 eax, eax
$LN51@k_mul:

; 3220 :     assert(Py_SIZE(t2) <= 2*shift); /* no overlap with high digits */

  00442	48 8b 44 24 70	 mov	 rax, QWORD PTR shift$[rsp]
  00447	48 03 c0	 add	 rax, rax
  0044a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t2$[rsp]
  0044f	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00453	7e 1c		 jle	 SHORT $LN52@k_mul
  00455	41 b8 94 0c 00
	00		 mov	 r8d, 3220		; 00000c94H
  0045b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00462	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@LPDLBLKI@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA2?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA?$CK?$AAs?$AAh?$AAi?$AAf?$AAt?$AA?$AA@
  00469	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0046f	33 c0		 xor	 eax, eax
$LN52@k_mul:

; 3221 :     memcpy(ret->ob_digit, t2->ob_digit, Py_SIZE(t2) * sizeof(digit));

  00471	48 8b 44 24 30	 mov	 rax, QWORD PTR t2$[rsp]
  00476	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0047a	48 c1 e0 02	 shl	 rax, 2
  0047e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t2$[rsp]
  00483	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00487	48 8b 54 24 50	 mov	 rdx, QWORD PTR ret$[rsp]
  0048c	48 83 c2 70	 add	 rdx, 112		; 00000070H
  00490	48 89 94 24 a0
	00 00 00	 mov	 QWORD PTR tv226[rsp], rdx
  00498	4c 8b c0	 mov	 r8, rax
  0049b	48 8b d1	 mov	 rdx, rcx
  0049e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv226[rsp]
  004a6	48 8b c8	 mov	 rcx, rax
  004a9	e8 00 00 00 00	 call	 memcpy

; 3222 : 
; 3223 :     /* Zero out remaining digits. */
; 3224 :     i = 2*shift - Py_SIZE(t2);          /* number of uninitialized digits */

  004ae	48 8b 44 24 70	 mov	 rax, QWORD PTR shift$[rsp]
  004b3	48 03 c0	 add	 rax, rax
  004b6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t2$[rsp]
  004bb	48 2b 41 60	 sub	 rax, QWORD PTR [rcx+96]
  004bf	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 3225 :     if (i)

  004c4	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  004ca	74 26		 je	 SHORT $LN26@k_mul

; 3226 :         memset(ret->ob_digit + Py_SIZE(t2), 0, i * sizeof(digit));

  004cc	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  004d1	48 c1 e0 02	 shl	 rax, 2
  004d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t2$[rsp]
  004da	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  004de	48 8b 54 24 50	 mov	 rdx, QWORD PTR ret$[rsp]
  004e3	48 8d 4c 8a 70	 lea	 rcx, QWORD PTR [rdx+rcx*4+112]
  004e8	4c 8b c0	 mov	 r8, rax
  004eb	33 d2		 xor	 edx, edx
  004ed	e8 00 00 00 00	 call	 memset
$LN26@k_mul:

; 3227 : 
; 3228 :     /* 4 & 5. Subtract ah*bh (t1) and al*bl (t2).  We do al*bl first
; 3229 :      * because it's fresher in cache.
; 3230 :      */
; 3231 :     i = Py_SIZE(ret) - shift;  /* # digits after shift */

  004f2	48 8b 44 24 50	 mov	 rax, QWORD PTR ret$[rsp]
  004f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR shift$[rsp]
  004fc	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00500	48 2b c1	 sub	 rax, rcx
  00503	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 3232 :     (void)v_isub(ret->ob_digit + shift, i, t2->ob_digit, Py_SIZE(t2));

  00508	48 8b 44 24 30	 mov	 rax, QWORD PTR t2$[rsp]
  0050d	48 83 c0 70	 add	 rax, 112		; 00000070H
  00511	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ret$[rsp]
  00516	48 8b 54 24 70	 mov	 rdx, QWORD PTR shift$[rsp]
  0051b	48 8d 4c 91 70	 lea	 rcx, QWORD PTR [rcx+rdx*4+112]
  00520	48 8b 54 24 30	 mov	 rdx, QWORD PTR t2$[rsp]
  00525	4c 8b 4a 60	 mov	 r9, QWORD PTR [rdx+96]
  00529	4c 8b c0	 mov	 r8, rax
  0052c	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00531	e8 00 00 00 00	 call	 v_isub

; 3233 :     Py_DECREF(t2);

  00536	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t2$[rsp]
  0053b	e8 00 00 00 00	 call	 _Py_DecRef

; 3234 : 
; 3235 :     (void)v_isub(ret->ob_digit + shift, i, t1->ob_digit, Py_SIZE(t1));

  00540	48 8b 44 24 60	 mov	 rax, QWORD PTR t1$[rsp]
  00545	48 83 c0 70	 add	 rax, 112		; 00000070H
  00549	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ret$[rsp]
  0054e	48 8b 54 24 70	 mov	 rdx, QWORD PTR shift$[rsp]
  00553	48 8d 4c 91 70	 lea	 rcx, QWORD PTR [rcx+rdx*4+112]
  00558	48 8b 54 24 60	 mov	 rdx, QWORD PTR t1$[rsp]
  0055d	4c 8b 4a 60	 mov	 r9, QWORD PTR [rdx+96]
  00561	4c 8b c0	 mov	 r8, rax
  00564	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00569	e8 00 00 00 00	 call	 v_isub

; 3236 :     Py_DECREF(t1);

  0056e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR t1$[rsp]
  00573	e8 00 00 00 00	 call	 _Py_DecRef

; 3237 : 
; 3238 :     /* 6. t3 <- (ah+al)(bh+bl), and add into result. */
; 3239 :     if ((t1 = x_add(ah, al)) == NULL) goto fail;

  00578	48 8b 54 24 78	 mov	 rdx, QWORD PTR al$[rsp]
  0057d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ah$[rsp]
  00582	e8 00 00 00 00	 call	 x_add
  00587	48 89 44 24 60	 mov	 QWORD PTR t1$[rsp], rax
  0058c	48 83 7c 24 60
	00		 cmp	 QWORD PTR t1$[rsp], 0
  00592	75 05		 jne	 SHORT $LN25@k_mul
  00594	e9 3f 01 00 00	 jmp	 $fail$23103
$LN25@k_mul:

; 3240 :     Py_DECREF(ah);

  00599	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ah$[rsp]
  0059e	e8 00 00 00 00	 call	 _Py_DecRef

; 3241 :     Py_DECREF(al);

  005a3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR al$[rsp]
  005a8	e8 00 00 00 00	 call	 _Py_DecRef

; 3242 :     ah = al = NULL;

  005ad	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR al$[rsp], 0
  005b6	48 8b 44 24 78	 mov	 rax, QWORD PTR al$[rsp]
  005bb	48 89 44 24 48	 mov	 QWORD PTR ah$[rsp], rax

; 3243 : 
; 3244 :     if (a == b) {

  005c0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  005c8	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR a$[rsp], rax
  005d0	75 16		 jne	 SHORT $LN24@k_mul

; 3245 :         t2 = t1;

  005d2	48 8b 44 24 60	 mov	 rax, QWORD PTR t1$[rsp]
  005d7	48 89 44 24 30	 mov	 QWORD PTR t2$[rsp], rax

; 3246 :         Py_INCREF(t2);

  005dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t2$[rsp]
  005e1	e8 00 00 00 00	 call	 _Py_IncRef
  005e6	eb 2b		 jmp	 SHORT $LN23@k_mul
$LN24@k_mul:

; 3247 :     }
; 3248 :     else if ((t2 = x_add(bh, bl)) == NULL) {

  005e8	48 8b 54 24 58	 mov	 rdx, QWORD PTR bl$[rsp]
  005ed	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bh$[rsp]
  005f2	e8 00 00 00 00	 call	 x_add
  005f7	48 89 44 24 30	 mov	 QWORD PTR t2$[rsp], rax
  005fc	48 83 7c 24 30
	00		 cmp	 QWORD PTR t2$[rsp], 0
  00602	75 0f		 jne	 SHORT $LN22@k_mul

; 3249 :         Py_DECREF(t1);

  00604	48 8b 4c 24 60	 mov	 rcx, QWORD PTR t1$[rsp]
  00609	e8 00 00 00 00	 call	 _Py_DecRef

; 3250 :         goto fail;

  0060e	e9 c5 00 00 00	 jmp	 $fail$23103
$LN22@k_mul:
$LN23@k_mul:

; 3251 :     }
; 3252 :     Py_DECREF(bh);

  00613	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bh$[rsp]
  00618	e8 00 00 00 00	 call	 _Py_DecRef

; 3253 :     Py_DECREF(bl);

  0061d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bl$[rsp]
  00622	e8 00 00 00 00	 call	 _Py_DecRef

; 3254 :     bh = bl = NULL;

  00627	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR bl$[rsp], 0
  00630	48 8b 44 24 58	 mov	 rax, QWORD PTR bl$[rsp]
  00635	48 89 44 24 20	 mov	 QWORD PTR bh$[rsp], rax

; 3255 : 
; 3256 :     t3 = k_mul(t1, t2);

  0063a	48 8b 54 24 30	 mov	 rdx, QWORD PTR t2$[rsp]
  0063f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR t1$[rsp]
  00644	e8 00 00 00 00	 call	 k_mul
  00649	48 89 44 24 38	 mov	 QWORD PTR t3$[rsp], rax

; 3257 :     Py_DECREF(t1);

  0064e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR t1$[rsp]
  00653	e8 00 00 00 00	 call	 _Py_DecRef

; 3258 :     Py_DECREF(t2);

  00658	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t2$[rsp]
  0065d	e8 00 00 00 00	 call	 _Py_DecRef

; 3259 :     if (t3 == NULL) goto fail;

  00662	48 83 7c 24 38
	00		 cmp	 QWORD PTR t3$[rsp], 0
  00668	75 02		 jne	 SHORT $LN21@k_mul
  0066a	eb 6c		 jmp	 SHORT $fail$23103
$LN21@k_mul:

; 3260 :     assert(Py_SIZE(t3) >= 0);

  0066c	48 8b 44 24 38	 mov	 rax, QWORD PTR t3$[rsp]
  00671	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00676	7d 1c		 jge	 SHORT $LN53@k_mul
  00678	41 b8 bc 0c 00
	00		 mov	 r8d, 3260		; 00000cbcH
  0067e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00685	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MOBFFO@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAt?$AA3?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0068c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00692	33 c0		 xor	 eax, eax
$LN53@k_mul:

; 3261 : 
; 3262 :     /* Add t3.  It's not obvious why we can't run out of room here.
; 3263 :      * See the (*) comment after this function.
; 3264 :      */
; 3265 :     (void)v_iadd(ret->ob_digit + shift, i, t3->ob_digit, Py_SIZE(t3));

  00694	48 8b 44 24 38	 mov	 rax, QWORD PTR t3$[rsp]
  00699	48 83 c0 70	 add	 rax, 112		; 00000070H
  0069d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ret$[rsp]
  006a2	48 8b 54 24 70	 mov	 rdx, QWORD PTR shift$[rsp]
  006a7	48 8d 4c 91 70	 lea	 rcx, QWORD PTR [rcx+rdx*4+112]
  006ac	48 8b 54 24 38	 mov	 rdx, QWORD PTR t3$[rsp]
  006b1	4c 8b 4a 60	 mov	 r9, QWORD PTR [rdx+96]
  006b5	4c 8b c0	 mov	 r8, rax
  006b8	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  006bd	e8 00 00 00 00	 call	 v_iadd

; 3266 :     Py_DECREF(t3);

  006c2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t3$[rsp]
  006c7	e8 00 00 00 00	 call	 _Py_DecRef

; 3267 : 
; 3268 :     return long_normalize(ret);

  006cc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ret$[rsp]
  006d1	e8 00 00 00 00	 call	 long_normalize
  006d6	eb 7a		 jmp	 SHORT $LN40@k_mul
$fail$23103:
$LN20@k_mul:

; 3269 : 
; 3270 :   fail:
; 3271 :     Py_XDECREF(ret);

  006d8	48 83 7c 24 50
	00		 cmp	 QWORD PTR ret$[rsp], 0
  006de	74 0a		 je	 SHORT $LN17@k_mul
  006e0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ret$[rsp]
  006e5	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@k_mul:
  006ea	33 c0		 xor	 eax, eax
  006ec	85 c0		 test	 eax, eax
  006ee	75 e8		 jne	 SHORT $LN20@k_mul
$LN16@k_mul:

; 3272 :     Py_XDECREF(ah);

  006f0	48 83 7c 24 48
	00		 cmp	 QWORD PTR ah$[rsp], 0
  006f6	74 0a		 je	 SHORT $LN13@k_mul
  006f8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ah$[rsp]
  006fd	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@k_mul:
  00702	33 c0		 xor	 eax, eax
  00704	85 c0		 test	 eax, eax
  00706	75 e8		 jne	 SHORT $LN16@k_mul
$LN12@k_mul:

; 3273 :     Py_XDECREF(al);

  00708	48 83 7c 24 78
	00		 cmp	 QWORD PTR al$[rsp], 0
  0070e	74 0a		 je	 SHORT $LN9@k_mul
  00710	48 8b 4c 24 78	 mov	 rcx, QWORD PTR al$[rsp]
  00715	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@k_mul:
  0071a	33 c0		 xor	 eax, eax
  0071c	85 c0		 test	 eax, eax
  0071e	75 e8		 jne	 SHORT $LN12@k_mul
$LN8@k_mul:

; 3274 :     Py_XDECREF(bh);

  00720	48 83 7c 24 20
	00		 cmp	 QWORD PTR bh$[rsp], 0
  00726	74 0a		 je	 SHORT $LN5@k_mul
  00728	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bh$[rsp]
  0072d	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@k_mul:
  00732	33 c0		 xor	 eax, eax
  00734	85 c0		 test	 eax, eax
  00736	75 e8		 jne	 SHORT $LN8@k_mul
$LN4@k_mul:

; 3275 :     Py_XDECREF(bl);

  00738	48 83 7c 24 58
	00		 cmp	 QWORD PTR bl$[rsp], 0
  0073e	74 0a		 je	 SHORT $LN1@k_mul
  00740	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bl$[rsp]
  00745	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@k_mul:
  0074a	33 c0		 xor	 eax, eax
  0074c	85 c0		 test	 eax, eax
  0074e	75 e8		 jne	 SHORT $LN4@k_mul

; 3276 :     return NULL;

  00750	33 c0		 xor	 eax, eax
$LN40@k_mul:

; 3277 : }

  00752	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00759	c3		 ret	 0
k_mul	ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@PPKFFGD@?$AA?$CI?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$CG?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@LJPFNDJD@?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAn?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$v_iadd DD imagerel v_iadd
	DD	imagerel v_iadd+372
	DD	imagerel $unwind$v_iadd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$v_iadd DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT ??_C@_1CK@PPKFFGD@?$AA?$CI?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$CG?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@PPKFFGD@?$AA?$CI?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$CG?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?$AA@ DB '('
	DB	00H, 'c', 00H, 'a', 00H, 'r', 00H, 'r', 00H, 'y', 00H, ' ', 00H
	DB	'&', 00H, ' ', 00H, '1', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'c', 00H, 'a', 00H, 'r', 00H, 'r', 00H, 'y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@LJPFNDJD@?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1O@LJPFNDJD@?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAn?$AA?$AA@ DB 'm', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'n', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT v_iadd
_TEXT	SEGMENT
i$ = 32
carry$ = 40
x$ = 64
m$ = 72
y$ = 80
n$ = 88
v_iadd	PROC						; COMDAT

; 1448 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1449 :     Py_ssize_t i;
; 1450 :     digit carry = 0;

  00018	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0

; 1451 : 
; 1452 :     assert(m >= n);

  00020	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00025	48 39 44 24 48	 cmp	 QWORD PTR m$[rsp], rax
  0002a	7d 1c		 jge	 SHORT $LN9@v_iadd
  0002c	41 b8 ac 05 00
	00		 mov	 r8d, 1452		; 000005acH
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@LJPFNDJD@?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAn?$AA?$AA@
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00046	33 c0		 xor	 eax, eax
$LN9@v_iadd:

; 1453 :     for (i = 0; i < n; ++i) {

  00048	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00051	eb 0d		 jmp	 SHORT $LN6@v_iadd
$LN5@v_iadd:
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00058	48 ff c0	 inc	 rax
  0005b	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@v_iadd:
  00060	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00065	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0006a	7d 75		 jge	 SHORT $LN4@v_iadd

; 1454 :         carry += x[i] + y[i];

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR x$[rsp]
  00071	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00076	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00079	48 8b 4c 24 50	 mov	 rcx, QWORD PTR y$[rsp]
  0007e	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00083	03 04 91	 add	 eax, DWORD PTR [rcx+rdx*4]
  00086	8b 4c 24 28	 mov	 ecx, DWORD PTR carry$[rsp]
  0008a	03 c8		 add	 ecx, eax
  0008c	8b c1		 mov	 eax, ecx
  0008e	89 44 24 28	 mov	 DWORD PTR carry$[rsp], eax

; 1455 :         x[i] = carry & PyLong_MASK;

  00092	8b 44 24 28	 mov	 eax, DWORD PTR carry$[rsp]
  00096	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x$[rsp]
  000a0	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  000a5	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 1456 :         carry >>= PyLong_SHIFT;

  000a8	8b 44 24 28	 mov	 eax, DWORD PTR carry$[rsp]
  000ac	c1 e8 1e	 shr	 eax, 30
  000af	89 44 24 28	 mov	 DWORD PTR carry$[rsp], eax

; 1457 :         assert((carry & 1) == carry);

  000b3	8b 44 24 28	 mov	 eax, DWORD PTR carry$[rsp]
  000b7	83 e0 01	 and	 eax, 1
  000ba	3b 44 24 28	 cmp	 eax, DWORD PTR carry$[rsp]
  000be	74 1c		 je	 SHORT $LN10@v_iadd
  000c0	41 b8 b1 05 00
	00		 mov	 r8d, 1457		; 000005b1H
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@PPKFFGD@?$AA?$CI?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$CG?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?$AA@
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000da	33 c0		 xor	 eax, eax
$LN10@v_iadd:

; 1458 :     }

  000dc	e9 72 ff ff ff	 jmp	 $LN5@v_iadd
$LN4@v_iadd:

; 1459 :     for (; carry && i < m; ++i) {

  000e1	eb 0d		 jmp	 SHORT $LN3@v_iadd
$LN2@v_iadd:
  000e3	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000e8	48 ff c0	 inc	 rax
  000eb	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@v_iadd:
  000f0	83 7c 24 28 00	 cmp	 DWORD PTR carry$[rsp], 0
  000f5	74 74		 je	 SHORT $LN1@v_iadd
  000f7	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  000fc	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00101	7d 68		 jge	 SHORT $LN1@v_iadd

; 1460 :         carry += x[i];

  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR x$[rsp]
  00108	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0010d	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00110	8b 4c 24 28	 mov	 ecx, DWORD PTR carry$[rsp]
  00114	03 c8		 add	 ecx, eax
  00116	8b c1		 mov	 eax, ecx
  00118	89 44 24 28	 mov	 DWORD PTR carry$[rsp], eax

; 1461 :         x[i] = carry & PyLong_MASK;

  0011c	8b 44 24 28	 mov	 eax, DWORD PTR carry$[rsp]
  00120	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00125	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x$[rsp]
  0012a	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0012f	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 1462 :         carry >>= PyLong_SHIFT;

  00132	8b 44 24 28	 mov	 eax, DWORD PTR carry$[rsp]
  00136	c1 e8 1e	 shr	 eax, 30
  00139	89 44 24 28	 mov	 DWORD PTR carry$[rsp], eax

; 1463 :         assert((carry & 1) == carry);

  0013d	8b 44 24 28	 mov	 eax, DWORD PTR carry$[rsp]
  00141	83 e0 01	 and	 eax, 1
  00144	3b 44 24 28	 cmp	 eax, DWORD PTR carry$[rsp]
  00148	74 1c		 je	 SHORT $LN11@v_iadd
  0014a	41 b8 b7 05 00
	00		 mov	 r8d, 1463		; 000005b7H
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@PPKFFGD@?$AA?$CI?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$CG?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?$AA@
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00164	33 c0		 xor	 eax, eax
$LN11@v_iadd:

; 1464 :     }

  00166	e9 78 ff ff ff	 jmp	 $LN2@v_iadd
$LN1@v_iadd:

; 1465 :     return carry;

  0016b	8b 44 24 28	 mov	 eax, DWORD PTR carry$[rsp]

; 1466 : }

  0016f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00173	c3		 ret	 0
v_iadd	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$v_isub DD imagerel v_isub
	DD	imagerel v_isub+303
	DD	imagerel $unwind$v_isub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$v_isub DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT v_isub
_TEXT	SEGMENT
i$ = 32
borrow$ = 40
x$ = 64
m$ = 72
y$ = 80
n$ = 88
v_isub	PROC						; COMDAT

; 1474 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1475 :     Py_ssize_t i;
; 1476 :     digit borrow = 0;

  00018	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR borrow$[rsp], 0

; 1477 : 
; 1478 :     assert(m >= n);

  00020	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00025	48 39 44 24 48	 cmp	 QWORD PTR m$[rsp], rax
  0002a	7d 1c		 jge	 SHORT $LN9@v_isub
  0002c	41 b8 c6 05 00
	00		 mov	 r8d, 1478		; 000005c6H
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@LJPFNDJD@?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAn?$AA?$AA@
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00046	33 c0		 xor	 eax, eax
$LN9@v_isub:

; 1479 :     for (i = 0; i < n; ++i) {

  00048	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00051	eb 0d		 jmp	 SHORT $LN6@v_isub
$LN5@v_isub:
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00058	48 ff c0	 inc	 rax
  0005b	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@v_isub:
  00060	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00065	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0006a	7d 53		 jge	 SHORT $LN4@v_isub

; 1480 :         borrow = x[i] - y[i] - borrow;

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR x$[rsp]
  00071	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00076	48 8b 54 24 50	 mov	 rdx, QWORD PTR y$[rsp]
  0007b	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00080	42 8b 14 82	 mov	 edx, DWORD PTR [rdx+r8*4]
  00084	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00087	2b c2		 sub	 eax, edx
  00089	2b 44 24 28	 sub	 eax, DWORD PTR borrow$[rsp]
  0008d	89 44 24 28	 mov	 DWORD PTR borrow$[rsp], eax

; 1481 :         x[i] = borrow & PyLong_MASK;

  00091	8b 44 24 28	 mov	 eax, DWORD PTR borrow$[rsp]
  00095	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0009a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x$[rsp]
  0009f	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  000a4	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 1482 :         borrow >>= PyLong_SHIFT;

  000a7	8b 44 24 28	 mov	 eax, DWORD PTR borrow$[rsp]
  000ab	c1 e8 1e	 shr	 eax, 30
  000ae	89 44 24 28	 mov	 DWORD PTR borrow$[rsp], eax

; 1483 :         borrow &= 1;            /* keep only 1 sign bit */

  000b2	8b 44 24 28	 mov	 eax, DWORD PTR borrow$[rsp]
  000b6	83 e0 01	 and	 eax, 1
  000b9	89 44 24 28	 mov	 DWORD PTR borrow$[rsp], eax

; 1484 :     }

  000bd	eb 94		 jmp	 SHORT $LN5@v_isub
$LN4@v_isub:

; 1485 :     for (; borrow && i < m; ++i) {

  000bf	eb 0d		 jmp	 SHORT $LN3@v_isub
$LN2@v_isub:
  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000c6	48 ff c0	 inc	 rax
  000c9	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@v_isub:
  000ce	83 7c 24 28 00	 cmp	 DWORD PTR borrow$[rsp], 0
  000d3	74 51		 je	 SHORT $LN1@v_isub
  000d5	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  000da	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000df	7d 45		 jge	 SHORT $LN1@v_isub

; 1486 :         borrow = x[i] - borrow;

  000e1	48 8b 44 24 40	 mov	 rax, QWORD PTR x$[rsp]
  000e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000eb	8b 54 24 28	 mov	 edx, DWORD PTR borrow$[rsp]
  000ef	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  000f2	2b c2		 sub	 eax, edx
  000f4	89 44 24 28	 mov	 DWORD PTR borrow$[rsp], eax

; 1487 :         x[i] = borrow & PyLong_MASK;

  000f8	8b 44 24 28	 mov	 eax, DWORD PTR borrow$[rsp]
  000fc	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00101	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x$[rsp]
  00106	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0010b	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 1488 :         borrow >>= PyLong_SHIFT;

  0010e	8b 44 24 28	 mov	 eax, DWORD PTR borrow$[rsp]
  00112	c1 e8 1e	 shr	 eax, 30
  00115	89 44 24 28	 mov	 DWORD PTR borrow$[rsp], eax

; 1489 :         borrow &= 1;

  00119	8b 44 24 28	 mov	 eax, DWORD PTR borrow$[rsp]
  0011d	83 e0 01	 and	 eax, 1
  00120	89 44 24 28	 mov	 DWORD PTR borrow$[rsp], eax

; 1490 :     }

  00124	eb 9b		 jmp	 SHORT $LN2@v_isub
$LN1@v_isub:

; 1491 :     return borrow;

  00126	8b 44 24 28	 mov	 eax, DWORD PTR borrow$[rsp]

; 1492 : }

  0012a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012e	c3		 ret	 0
v_isub	ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DK@OLFILHK@?$AA?$CI?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@LJDEHFAO@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AA1?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@BGIBPMG@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$x_mul DD	imagerel x_mul
	DD	imagerel x_mul+1304
	DD	imagerel $unwind$x_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x_mul DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_1DK@OLFILHK@?$AA?$CI?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@OLFILHK@?$AA?$CI?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB '('
	DB	00H, 'c', 00H, 'a', 00H, 'r', 00H, 'r', 00H, 'y', 00H, ' ', 00H
	DB	'>', 00H, '>', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'L', 00H, 'o'
	DB	00H, 'n', 00H, 'g', 00H, '_', 00H, 'S', 00H, 'H', 00H, 'I', 00H
	DB	'F', 00H, 'T', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@LJDEHFAO@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AA1?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@LJDEHFAO@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AA1?$AA?$CJ?$AA?$AA@ DB 'c'
	DB	00H, 'a', 00H, 'r', 00H, 'r', 00H, 'y', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '(', 00H, 'P', 00H, 'y', 00H, 'L', 00H, 'o'
	DB	00H, 'n', 00H, 'g', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'S', 00H
	DB	'K', 00H, ' ', 00H, '<', 00H, '<', 00H, ' ', 00H, '1', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@BGIBPMG@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@BGIBPMG@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?$AA@ DB 'c'
	DB	00H, 'a', 00H, 'r', 00H, 'r', 00H, 'y', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n'
	DB	00H, 'g', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'S', 00H, 'K', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT x_mul
_TEXT	SEGMENT
i$ = 32
size_b$ = 40
z$ = 48
size_a$ = 56
pz$22972 = 64
f$22971 = 72
paend$22974 = 80
pa$22973 = 88
carry$22970 = 96
pz$23014 = 104
f$23013 = 112
carry$23012 = 120
pb$23015 = 128
pbend$23016 = 136
tv69 = 144
tv75 = 152
a$ = 176
b$ = 184
x_mul	PROC						; COMDAT

; 2988 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2989 :     PyLongObject *z;
; 2990 :     Py_ssize_t size_a = ABS(Py_SIZE(a));

  00011	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00019	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001e	7d 19		 jge	 SHORT $LN27@x_mul
  00020	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00028	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002c	48 f7 d8	 neg	 rax
  0002f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
  00037	eb 14		 jmp	 SHORT $LN28@x_mul
$LN27@x_mul:
  00039	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00041	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00045	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
$LN28@x_mul:
  0004d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv69[rsp]
  00055	48 89 44 24 38	 mov	 QWORD PTR size_a$[rsp], rax

; 2991 :     Py_ssize_t size_b = ABS(Py_SIZE(b));

  0005a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00062	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00067	7d 19		 jge	 SHORT $LN29@x_mul
  00069	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00071	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00075	48 f7 d8	 neg	 rax
  00078	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  00080	eb 14		 jmp	 SHORT $LN30@x_mul
$LN29@x_mul:
  00082	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0008a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
$LN30@x_mul:
  00096	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  0009e	48 89 44 24 28	 mov	 QWORD PTR size_b$[rsp], rax

; 2992 :     Py_ssize_t i;
; 2993 : 
; 2994 :     z = _PyLong_New(size_a + size_b);

  000a3	48 8b 44 24 28	 mov	 rax, QWORD PTR size_b$[rsp]
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR size_a$[rsp]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	e8 00 00 00 00	 call	 _PyLong_New
  000bb	48 89 44 24 30	 mov	 QWORD PTR z$[rsp], rax

; 2995 :     if (z == NULL)

  000c0	48 83 7c 24 30
	00		 cmp	 QWORD PTR z$[rsp], 0
  000c6	75 07		 jne	 SHORT $LN24@x_mul

; 2996 :         return NULL;

  000c8	33 c0		 xor	 eax, eax
  000ca	e9 41 04 00 00	 jmp	 $LN25@x_mul
$LN24@x_mul:

; 2997 : 
; 2998 :     memset(z->ob_digit, 0, Py_SIZE(z) * sizeof(digit));

  000cf	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  000d4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d8	48 c1 e0 02	 shl	 rax, 2
  000dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR z$[rsp]
  000e1	48 83 c1 70	 add	 rcx, 112		; 00000070H
  000e5	4c 8b c0	 mov	 r8, rax
  000e8	33 d2		 xor	 edx, edx
  000ea	e8 00 00 00 00	 call	 memset

; 2999 :     if (a == b) {

  000ef	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000f7	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR a$[rsp], rax
  000ff	0f 85 5d 02 00
	00		 jne	 $LN23@x_mul

; 3000 :         /* Efficient squaring per HAC, Algorithm 14.16:
; 3001 :          * http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf
; 3002 :          * Gives slightly less than a 2x speedup when a == b,
; 3003 :          * via exploiting that each entry in the multiplication
; 3004 :          * pyramid appears twice (except for the size_a squares).
; 3005 :          */
; 3006 :         for (i = 0; i < size_a; ++i) {

  00105	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0010e	eb 0d		 jmp	 SHORT $LN22@x_mul
$LN21@x_mul:
  00110	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00115	48 ff c0	 inc	 rax
  00118	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN22@x_mul:
  0011d	48 8b 44 24 38	 mov	 rax, QWORD PTR size_a$[rsp]
  00122	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00127	0f 8d 30 02 00
	00		 jge	 $LN20@x_mul

; 3007 :             twodigits carry;
; 3008 :             twodigits f = a->ob_digit[i];

  0012d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00135	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0013a	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  0013e	48 89 44 24 48	 mov	 QWORD PTR f$22971[rsp], rax

; 3009 :             digit *pz = z->ob_digit + (i << 1);

  00143	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00148	48 03 c0	 add	 rax, rax
  0014b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR z$[rsp]
  00150	48 8d 44 81 70	 lea	 rax, QWORD PTR [rcx+rax*4+112]
  00155	48 89 44 24 40	 mov	 QWORD PTR pz$22972[rsp], rax

; 3010 :             digit *pa = a->ob_digit + i + 1;

  0015a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00162	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00167	48 8d 44 88 74	 lea	 rax, QWORD PTR [rax+rcx*4+116]
  0016c	48 89 44 24 58	 mov	 QWORD PTR pa$22973[rsp], rax

; 3011 :             digit *paend = a->ob_digit + size_a;

  00171	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00179	48 8b 4c 24 38	 mov	 rcx, QWORD PTR size_a$[rsp]
  0017e	48 8d 44 88 70	 lea	 rax, QWORD PTR [rax+rcx*4+112]
  00183	48 89 44 24 50	 mov	 QWORD PTR paend$22974[rsp], rax
$LN19@x_mul:

; 3012 : 
; 3013 :             SIGCHECK({
; 3014 :                     Py_DECREF(z);
; 3015 :                     return NULL;
; 3016 :                 });

  00188	e8 00 00 00 00	 call	 PyErr_CheckSignals
  0018d	85 c0		 test	 eax, eax
  0018f	74 11		 je	 SHORT $LN16@x_mul
  00191	48 8b 4c 24 30	 mov	 rcx, QWORD PTR z$[rsp]
  00196	e8 00 00 00 00	 call	 _Py_DecRef
  0019b	33 c0		 xor	 eax, eax
  0019d	e9 6e 03 00 00	 jmp	 $LN25@x_mul
$LN16@x_mul:
  001a2	33 c0		 xor	 eax, eax
  001a4	85 c0		 test	 eax, eax
  001a6	75 e0		 jne	 SHORT $LN19@x_mul

; 3017 : 
; 3018 :             carry = *pz + f * f;

  001a8	48 8b 44 24 40	 mov	 rax, QWORD PTR pz$22972[rsp]
  001ad	8b 00		 mov	 eax, DWORD PTR [rax]
  001af	48 8b 4c 24 48	 mov	 rcx, QWORD PTR f$22971[rsp]
  001b4	48 0f af 4c 24
	48		 imul	 rcx, QWORD PTR f$22971[rsp]
  001ba	48 03 c1	 add	 rax, rcx
  001bd	48 89 44 24 60	 mov	 QWORD PTR carry$22970[rsp], rax

; 3019 :             *pz++ = (digit)(carry & PyLong_MASK);

  001c2	48 8b 44 24 60	 mov	 rax, QWORD PTR carry$22970[rsp]
  001c7	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  001cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pz$22972[rsp]
  001d2	89 01		 mov	 DWORD PTR [rcx], eax
  001d4	48 8b 44 24 40	 mov	 rax, QWORD PTR pz$22972[rsp]
  001d9	48 83 c0 04	 add	 rax, 4
  001dd	48 89 44 24 40	 mov	 QWORD PTR pz$22972[rsp], rax

; 3020 :             carry >>= PyLong_SHIFT;

  001e2	48 8b 44 24 60	 mov	 rax, QWORD PTR carry$22970[rsp]
  001e7	48 c1 e8 1e	 shr	 rax, 30
  001eb	48 89 44 24 60	 mov	 QWORD PTR carry$22970[rsp], rax

; 3021 :             assert(carry <= PyLong_MASK);

  001f0	48 81 7c 24 60
	ff ff ff 3f	 cmp	 QWORD PTR carry$22970[rsp], 1073741823 ; 3fffffffH
  001f9	76 1c		 jbe	 SHORT $LN31@x_mul
  001fb	41 b8 cd 0b 00
	00		 mov	 r8d, 3021		; 00000bcdH
  00201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@BGIBPMG@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?$AA@
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00215	33 c0		 xor	 eax, eax
$LN31@x_mul:

; 3022 : 
; 3023 :             /* Now f is added in twice in each column of the
; 3024 :              * pyramid it appears.  Same as adding f<<1 once.
; 3025 :              */
; 3026 :             f <<= 1;

  00217	48 8b 44 24 48	 mov	 rax, QWORD PTR f$22971[rsp]
  0021c	48 d1 e0	 shl	 rax, 1
  0021f	48 89 44 24 48	 mov	 QWORD PTR f$22971[rsp], rax
$LN15@x_mul:

; 3027 :             while (pa < paend) {

  00224	48 8b 44 24 50	 mov	 rax, QWORD PTR paend$22974[rsp]
  00229	48 39 44 24 58	 cmp	 QWORD PTR pa$22973[rsp], rax
  0022e	0f 83 8c 00 00
	00		 jae	 $LN14@x_mul

; 3028 :                 carry += *pz + *pa++ * f;

  00234	48 8b 44 24 40	 mov	 rax, QWORD PTR pz$22972[rsp]
  00239	8b 00		 mov	 eax, DWORD PTR [rax]
  0023b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pa$22973[rsp]
  00240	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00242	48 0f af 4c 24
	48		 imul	 rcx, QWORD PTR f$22971[rsp]
  00248	48 03 4c 24 60	 add	 rcx, QWORD PTR carry$22970[rsp]
  0024d	48 03 c8	 add	 rcx, rax
  00250	48 8b c1	 mov	 rax, rcx
  00253	48 89 44 24 60	 mov	 QWORD PTR carry$22970[rsp], rax
  00258	48 8b 44 24 58	 mov	 rax, QWORD PTR pa$22973[rsp]
  0025d	48 83 c0 04	 add	 rax, 4
  00261	48 89 44 24 58	 mov	 QWORD PTR pa$22973[rsp], rax

; 3029 :                 *pz++ = (digit)(carry & PyLong_MASK);

  00266	48 8b 44 24 60	 mov	 rax, QWORD PTR carry$22970[rsp]
  0026b	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  00271	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pz$22972[rsp]
  00276	89 01		 mov	 DWORD PTR [rcx], eax
  00278	48 8b 44 24 40	 mov	 rax, QWORD PTR pz$22972[rsp]
  0027d	48 83 c0 04	 add	 rax, 4
  00281	48 89 44 24 40	 mov	 QWORD PTR pz$22972[rsp], rax

; 3030 :                 carry >>= PyLong_SHIFT;

  00286	48 8b 44 24 60	 mov	 rax, QWORD PTR carry$22970[rsp]
  0028b	48 c1 e8 1e	 shr	 rax, 30
  0028f	48 89 44 24 60	 mov	 QWORD PTR carry$22970[rsp], rax

; 3031 :                 assert(carry <= (PyLong_MASK << 1));

  00294	48 81 7c 24 60
	fe ff ff 7f	 cmp	 QWORD PTR carry$22970[rsp], 2147483646 ; 7ffffffeH
  0029d	76 1c		 jbe	 SHORT $LN32@x_mul
  0029f	41 b8 d7 0b 00
	00		 mov	 r8d, 3031		; 00000bd7H
  002a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@LJDEHFAO@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AA1?$AA?$CJ?$AA?$AA@
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002b9	33 c0		 xor	 eax, eax
$LN32@x_mul:

; 3032 :             }

  002bb	e9 64 ff ff ff	 jmp	 $LN15@x_mul
$LN14@x_mul:

; 3033 :             if (carry) {

  002c0	48 83 7c 24 60
	00		 cmp	 QWORD PTR carry$22970[rsp], 0
  002c6	74 45		 je	 SHORT $LN13@x_mul

; 3034 :                 carry += *pz;

  002c8	48 8b 44 24 40	 mov	 rax, QWORD PTR pz$22972[rsp]
  002cd	8b 00		 mov	 eax, DWORD PTR [rax]
  002cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR carry$22970[rsp]
  002d4	48 03 c8	 add	 rcx, rax
  002d7	48 8b c1	 mov	 rax, rcx
  002da	48 89 44 24 60	 mov	 QWORD PTR carry$22970[rsp], rax

; 3035 :                 *pz++ = (digit)(carry & PyLong_MASK);

  002df	48 8b 44 24 60	 mov	 rax, QWORD PTR carry$22970[rsp]
  002e4	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  002ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pz$22972[rsp]
  002ef	89 01		 mov	 DWORD PTR [rcx], eax
  002f1	48 8b 44 24 40	 mov	 rax, QWORD PTR pz$22972[rsp]
  002f6	48 83 c0 04	 add	 rax, 4
  002fa	48 89 44 24 40	 mov	 QWORD PTR pz$22972[rsp], rax

; 3036 :                 carry >>= PyLong_SHIFT;

  002ff	48 8b 44 24 60	 mov	 rax, QWORD PTR carry$22970[rsp]
  00304	48 c1 e8 1e	 shr	 rax, 30
  00308	48 89 44 24 60	 mov	 QWORD PTR carry$22970[rsp], rax
$LN13@x_mul:

; 3037 :             }
; 3038 :             if (carry)

  0030d	48 83 7c 24 60
	00		 cmp	 QWORD PTR carry$22970[rsp], 0
  00313	74 19		 je	 SHORT $LN12@x_mul

; 3039 :                 *pz += (digit)(carry & PyLong_MASK);

  00315	48 8b 44 24 60	 mov	 rax, QWORD PTR carry$22970[rsp]
  0031a	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  00320	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pz$22972[rsp]
  00325	03 01		 add	 eax, DWORD PTR [rcx]
  00327	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pz$22972[rsp]
  0032c	89 01		 mov	 DWORD PTR [rcx], eax
$LN12@x_mul:

; 3040 :             assert((carry >> PyLong_SHIFT) == 0);

  0032e	48 8b 44 24 60	 mov	 rax, QWORD PTR carry$22970[rsp]
  00333	48 c1 e8 1e	 shr	 rax, 30
  00337	48 85 c0	 test	 rax, rax
  0033a	74 1c		 je	 SHORT $LN33@x_mul
  0033c	41 b8 e0 0b 00
	00		 mov	 r8d, 3040		; 00000be0H
  00342	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00349	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@OLFILHK@?$AA?$CI?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00356	33 c0		 xor	 eax, eax
$LN33@x_mul:

; 3041 :         }

  00358	e9 b3 fd ff ff	 jmp	 $LN21@x_mul
$LN20@x_mul:

; 3042 :     }
; 3043 :     else {      /* a is not the same as b -- gradeschool int mult */

  0035d	e9 a4 01 00 00	 jmp	 $LN11@x_mul
$LN23@x_mul:

; 3044 :         for (i = 0; i < size_a; ++i) {

  00362	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0036b	eb 0d		 jmp	 SHORT $LN10@x_mul
$LN9@x_mul:
  0036d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00372	48 ff c0	 inc	 rax
  00375	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN10@x_mul:
  0037a	48 8b 44 24 38	 mov	 rax, QWORD PTR size_a$[rsp]
  0037f	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00384	0f 8d 7c 01 00
	00		 jge	 $LN8@x_mul

; 3045 :             twodigits carry = 0;

  0038a	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR carry$23012[rsp], 0

; 3046 :             twodigits f = a->ob_digit[i];

  00393	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0039b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  003a0	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  003a4	48 89 44 24 70	 mov	 QWORD PTR f$23013[rsp], rax

; 3047 :             digit *pz = z->ob_digit + i;

  003a9	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  003ae	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  003b3	48 8d 44 88 70	 lea	 rax, QWORD PTR [rax+rcx*4+112]
  003b8	48 89 44 24 68	 mov	 QWORD PTR pz$23014[rsp], rax

; 3048 :             digit *pb = b->ob_digit;

  003bd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  003c5	48 83 c0 70	 add	 rax, 112		; 00000070H
  003c9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pb$23015[rsp], rax

; 3049 :             digit *pbend = b->ob_digit + size_b;

  003d1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  003d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size_b$[rsp]
  003de	48 8d 44 88 70	 lea	 rax, QWORD PTR [rax+rcx*4+112]
  003e3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pbend$23016[rsp], rax
$LN7@x_mul:

; 3050 : 
; 3051 :             SIGCHECK({
; 3052 :                     Py_DECREF(z);
; 3053 :                     return NULL;
; 3054 :                 });

  003eb	e8 00 00 00 00	 call	 PyErr_CheckSignals
  003f0	85 c0		 test	 eax, eax
  003f2	74 11		 je	 SHORT $LN4@x_mul
  003f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR z$[rsp]
  003f9	e8 00 00 00 00	 call	 _Py_DecRef
  003fe	33 c0		 xor	 eax, eax
  00400	e9 0b 01 00 00	 jmp	 $LN25@x_mul
$LN4@x_mul:
  00405	33 c0		 xor	 eax, eax
  00407	85 c0		 test	 eax, eax
  00409	75 e0		 jne	 SHORT $LN7@x_mul
$LN3@x_mul:

; 3055 : 
; 3056 :             while (pb < pbend) {

  0040b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pbend$23016[rsp]
  00413	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR pb$23015[rsp], rax
  0041b	0f 83 95 00 00
	00		 jae	 $LN2@x_mul

; 3057 :                 carry += *pz + *pb++ * f;

  00421	48 8b 44 24 68	 mov	 rax, QWORD PTR pz$23014[rsp]
  00426	8b 00		 mov	 eax, DWORD PTR [rax]
  00428	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pb$23015[rsp]
  00430	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00432	48 0f af 4c 24
	70		 imul	 rcx, QWORD PTR f$23013[rsp]
  00438	48 03 4c 24 78	 add	 rcx, QWORD PTR carry$23012[rsp]
  0043d	48 03 c8	 add	 rcx, rax
  00440	48 8b c1	 mov	 rax, rcx
  00443	48 89 44 24 78	 mov	 QWORD PTR carry$23012[rsp], rax
  00448	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pb$23015[rsp]
  00450	48 83 c0 04	 add	 rax, 4
  00454	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pb$23015[rsp], rax

; 3058 :                 *pz++ = (digit)(carry & PyLong_MASK);

  0045c	48 8b 44 24 78	 mov	 rax, QWORD PTR carry$23012[rsp]
  00461	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  00467	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pz$23014[rsp]
  0046c	89 01		 mov	 DWORD PTR [rcx], eax
  0046e	48 8b 44 24 68	 mov	 rax, QWORD PTR pz$23014[rsp]
  00473	48 83 c0 04	 add	 rax, 4
  00477	48 89 44 24 68	 mov	 QWORD PTR pz$23014[rsp], rax

; 3059 :                 carry >>= PyLong_SHIFT;

  0047c	48 8b 44 24 78	 mov	 rax, QWORD PTR carry$23012[rsp]
  00481	48 c1 e8 1e	 shr	 rax, 30
  00485	48 89 44 24 78	 mov	 QWORD PTR carry$23012[rsp], rax

; 3060 :                 assert(carry <= PyLong_MASK);

  0048a	48 81 7c 24 78
	ff ff ff 3f	 cmp	 QWORD PTR carry$23012[rsp], 1073741823 ; 3fffffffH
  00493	76 1c		 jbe	 SHORT $LN34@x_mul
  00495	41 b8 f4 0b 00
	00		 mov	 r8d, 3060		; 00000bf4H
  0049b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  004a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@BGIBPMG@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?$AA@
  004a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004af	33 c0		 xor	 eax, eax
$LN34@x_mul:

; 3061 :             }

  004b1	e9 55 ff ff ff	 jmp	 $LN3@x_mul
$LN2@x_mul:

; 3062 :             if (carry)

  004b6	48 83 7c 24 78
	00		 cmp	 QWORD PTR carry$23012[rsp], 0
  004bc	74 19		 je	 SHORT $LN1@x_mul

; 3063 :                 *pz += (digit)(carry & PyLong_MASK);

  004be	48 8b 44 24 78	 mov	 rax, QWORD PTR carry$23012[rsp]
  004c3	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  004c9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pz$23014[rsp]
  004ce	03 01		 add	 eax, DWORD PTR [rcx]
  004d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pz$23014[rsp]
  004d5	89 01		 mov	 DWORD PTR [rcx], eax
$LN1@x_mul:

; 3064 :             assert((carry >> PyLong_SHIFT) == 0);

  004d7	48 8b 44 24 78	 mov	 rax, QWORD PTR carry$23012[rsp]
  004dc	48 c1 e8 1e	 shr	 rax, 30
  004e0	48 85 c0	 test	 rax, rax
  004e3	74 1c		 je	 SHORT $LN35@x_mul
  004e5	41 b8 f8 0b 00
	00		 mov	 r8d, 3064		; 00000bf8H
  004eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  004f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@OLFILHK@?$AA?$CI?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAS?$AAH?$AAI?$AAF?$AAT?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  004f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004ff	33 c0		 xor	 eax, eax
$LN35@x_mul:

; 3065 :         }

  00501	e9 67 fe ff ff	 jmp	 $LN9@x_mul
$LN8@x_mul:
$LN11@x_mul:

; 3066 :     }
; 3067 :     return long_normalize(z);

  00506	48 8b 4c 24 30	 mov	 rcx, QWORD PTR z$[rsp]
  0050b	e8 00 00 00 00	 call	 long_normalize
$LN25@x_mul:

; 3068 : }

  00510	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00517	c3		 ret	 0
x_mul	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kmul_split DD imagerel kmul_split
	DD	imagerel kmul_split+398
	DD	imagerel $unwind$kmul_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kmul_split DD 011801H
	DD	0e218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT kmul_split
_TEXT	SEGMENT
lo$ = 32
size_n$ = 40
size_hi$ = 48
size_lo$ = 56
hi$ = 64
tv69 = 72
tv71 = 80
tv85 = 88
tv93 = 96
n$ = 128
size$ = 136
high$ = 144
low$ = 152
kmul_split PROC						; COMDAT

; 3082 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3083 :     PyLongObject *hi, *lo;
; 3084 :     Py_ssize_t size_lo, size_hi;
; 3085 :     const Py_ssize_t size_n = ABS(Py_SIZE(n));

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00020	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00025	7d 16		 jge	 SHORT $LN5@kmul_split
  00027	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0002f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00033	48 f7 d8	 neg	 rax
  00036	48 89 44 24 48	 mov	 QWORD PTR tv69[rsp], rax
  0003b	eb 11		 jmp	 SHORT $LN6@kmul_split
$LN5@kmul_split:
  0003d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00045	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00049	48 89 44 24 48	 mov	 QWORD PTR tv69[rsp], rax
$LN6@kmul_split:
  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR tv69[rsp]
  00053	48 89 44 24 28	 mov	 QWORD PTR size_n$[rsp], rax

; 3086 : 
; 3087 :     size_lo = MIN(size_n, size);

  00058	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  00060	48 39 44 24 28	 cmp	 QWORD PTR size_n$[rsp], rax
  00065	7e 0f		 jle	 SHORT $LN7@kmul_split
  00067	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  0006f	48 89 44 24 50	 mov	 QWORD PTR tv71[rsp], rax
  00074	eb 0a		 jmp	 SHORT $LN8@kmul_split
$LN7@kmul_split:
  00076	48 8b 44 24 28	 mov	 rax, QWORD PTR size_n$[rsp]
  0007b	48 89 44 24 50	 mov	 QWORD PTR tv71[rsp], rax
$LN8@kmul_split:
  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR tv71[rsp]
  00085	48 89 44 24 38	 mov	 QWORD PTR size_lo$[rsp], rax

; 3088 :     size_hi = size_n - size_lo;

  0008a	48 8b 44 24 38	 mov	 rax, QWORD PTR size_lo$[rsp]
  0008f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size_n$[rsp]
  00094	48 2b c8	 sub	 rcx, rax
  00097	48 8b c1	 mov	 rax, rcx
  0009a	48 89 44 24 30	 mov	 QWORD PTR size_hi$[rsp], rax

; 3089 : 
; 3090 :     if ((hi = _PyLong_New(size_hi)) == NULL)

  0009f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size_hi$[rsp]
  000a4	e8 00 00 00 00	 call	 _PyLong_New
  000a9	48 89 44 24 40	 mov	 QWORD PTR hi$[rsp], rax
  000ae	48 83 7c 24 40
	00		 cmp	 QWORD PTR hi$[rsp], 0
  000b4	75 0a		 jne	 SHORT $LN2@kmul_split

; 3091 :         return -1;

  000b6	b8 ff ff ff ff	 mov	 eax, -1
  000bb	e9 c9 00 00 00	 jmp	 $LN3@kmul_split
$LN2@kmul_split:

; 3092 :     if ((lo = _PyLong_New(size_lo)) == NULL) {

  000c0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR size_lo$[rsp]
  000c5	e8 00 00 00 00	 call	 _PyLong_New
  000ca	48 89 44 24 20	 mov	 QWORD PTR lo$[rsp], rax
  000cf	48 83 7c 24 20
	00		 cmp	 QWORD PTR lo$[rsp], 0
  000d5	75 14		 jne	 SHORT $LN1@kmul_split

; 3093 :         Py_DECREF(hi);

  000d7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hi$[rsp]
  000dc	e8 00 00 00 00	 call	 _Py_DecRef

; 3094 :         return -1;

  000e1	b8 ff ff ff ff	 mov	 eax, -1
  000e6	e9 9e 00 00 00	 jmp	 $LN3@kmul_split
$LN1@kmul_split:

; 3095 :     }
; 3096 : 
; 3097 :     memcpy(lo->ob_digit, n->ob_digit, size_lo * sizeof(digit));

  000eb	48 8b 44 24 38	 mov	 rax, QWORD PTR size_lo$[rsp]
  000f0	48 c1 e0 02	 shl	 rax, 2
  000f4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  000fc	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00100	48 8b 54 24 20	 mov	 rdx, QWORD PTR lo$[rsp]
  00105	48 83 c2 70	 add	 rdx, 112		; 00000070H
  00109	48 89 54 24 58	 mov	 QWORD PTR tv85[rsp], rdx
  0010e	4c 8b c0	 mov	 r8, rax
  00111	48 8b d1	 mov	 rdx, rcx
  00114	48 8b 44 24 58	 mov	 rax, QWORD PTR tv85[rsp]
  00119	48 8b c8	 mov	 rcx, rax
  0011c	e8 00 00 00 00	 call	 memcpy

; 3098 :     memcpy(hi->ob_digit, n->ob_digit + size_lo, size_hi * sizeof(digit));

  00121	48 8b 44 24 30	 mov	 rax, QWORD PTR size_hi$[rsp]
  00126	48 c1 e0 02	 shl	 rax, 2
  0012a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00132	48 8b 54 24 38	 mov	 rdx, QWORD PTR size_lo$[rsp]
  00137	48 8d 4c 91 70	 lea	 rcx, QWORD PTR [rcx+rdx*4+112]
  0013c	48 8b 54 24 40	 mov	 rdx, QWORD PTR hi$[rsp]
  00141	48 83 c2 70	 add	 rdx, 112		; 00000070H
  00145	48 89 54 24 60	 mov	 QWORD PTR tv93[rsp], rdx
  0014a	4c 8b c0	 mov	 r8, rax
  0014d	48 8b d1	 mov	 rdx, rcx
  00150	48 8b 44 24 60	 mov	 rax, QWORD PTR tv93[rsp]
  00155	48 8b c8	 mov	 rcx, rax
  00158	e8 00 00 00 00	 call	 memcpy

; 3099 : 
; 3100 :     *high = long_normalize(hi);

  0015d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hi$[rsp]
  00162	e8 00 00 00 00	 call	 long_normalize
  00167	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR high$[rsp]
  0016f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 3101 :     *low = long_normalize(lo);

  00172	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lo$[rsp]
  00177	e8 00 00 00 00	 call	 long_normalize
  0017c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR low$[rsp]
  00184	48 89 01	 mov	 QWORD PTR [rcx], rax

; 3102 :     return 0;

  00187	33 c0		 xor	 eax, eax
$LN3@kmul_split:

; 3103 : }

  00189	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0018d	c3		 ret	 0
kmul_split ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CG@FHKCKJOC@?$AA2?$AA?5?$AA?$CK?$AA?5?$AAa?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@MHNKEOLO@?$AAa?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AAK?$AAA?$AAR?$AAA?$AAT?$AAS?$AAU?$AAB?$AAA?$AA_?$AAC?$AAU?$AAT?$AAO?$AAF?$AAF?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$k_lopsided_mul DD imagerel k_lopsided_mul
	DD	imagerel k_lopsided_mul+709
	DD	imagerel $unwind$k_lopsided_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$k_lopsided_mul DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_1CG@FHKCKJOC@?$AA2?$AA?5?$AA?$CK?$AA?5?$AAa?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@FHKCKJOC@?$AA2?$AA?5?$AA?$CK?$AA?5?$AAa?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB '2'
	DB	00H, ' ', 00H, '*', 00H, ' ', 00H, 'a', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'b'
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@MHNKEOLO@?$AAa?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AAK?$AAA?$AAR?$AAA?$AAT?$AAS?$AAU?$AAB?$AAA?$AA_?$AAC?$AAU?$AAT?$AAO?$AAF?$AAF?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@MHNKEOLO@?$AAa?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AAK?$AAA?$AAR?$AAA?$AAT?$AAS?$AAU?$AAB?$AAA?$AA_?$AAC?$AAU?$AAT?$AAO?$AAF?$AAF?$AA?$AA@ DB 'a'
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, 'K', 00H, 'A', 00H, 'R', 00H, 'A', 00H, 'T', 00H, 'S'
	DB	00H, 'U', 00H, 'B', 00H, 'A', 00H, '_', 00H, 'C', 00H, 'U', 00H
	DB	'T', 00H, 'O', 00H, 'F', 00H, 'F', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT k_lopsided_mul
_TEXT	SEGMENT
bslice$ = 32
nbdone$ = 40
bsize$ = 48
ret$ = 56
asize$ = 64
nbtouse$23237 = 72
product$23236 = 80
tv69 = 88
tv75 = 96
tv134 = 104
tv142 = 112
tv158 = 120
a$ = 144
b$ = 152
k_lopsided_mul PROC					; COMDAT

; 3334 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 3335 :     const Py_ssize_t asize = ABS(Py_SIZE(a));

  00011	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00019	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001e	7d 16		 jge	 SHORT $LN12@k_lopsided
  00020	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00028	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002c	48 f7 d8	 neg	 rax
  0002f	48 89 44 24 58	 mov	 QWORD PTR tv69[rsp], rax
  00034	eb 11		 jmp	 SHORT $LN13@k_lopsided
$LN12@k_lopsided:
  00036	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0003e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00042	48 89 44 24 58	 mov	 QWORD PTR tv69[rsp], rax
$LN13@k_lopsided:
  00047	48 8b 44 24 58	 mov	 rax, QWORD PTR tv69[rsp]
  0004c	48 89 44 24 40	 mov	 QWORD PTR asize$[rsp], rax

; 3336 :     Py_ssize_t bsize = ABS(Py_SIZE(b));

  00051	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00059	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0005e	7d 16		 jge	 SHORT $LN14@k_lopsided
  00060	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00068	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006c	48 f7 d8	 neg	 rax
  0006f	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  00074	eb 11		 jmp	 SHORT $LN15@k_lopsided
$LN14@k_lopsided:
  00076	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0007e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00082	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
$LN15@k_lopsided:
  00087	48 8b 44 24 60	 mov	 rax, QWORD PTR tv75[rsp]
  0008c	48 89 44 24 30	 mov	 QWORD PTR bsize$[rsp], rax

; 3337 :     Py_ssize_t nbdone;          /* # of b digits already multiplied */
; 3338 :     PyLongObject *ret;
; 3339 :     PyLongObject *bslice = NULL;

  00091	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR bslice$[rsp], 0

; 3340 : 
; 3341 :     assert(asize > KARATSUBA_CUTOFF);

  0009a	48 83 7c 24 40
	46		 cmp	 QWORD PTR asize$[rsp], 70 ; 00000046H
  000a0	7f 1c		 jg	 SHORT $LN16@k_lopsided
  000a2	41 b8 0d 0d 00
	00		 mov	 r8d, 3341		; 00000d0dH
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@MHNKEOLO@?$AAa?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AAK?$AAA?$AAR?$AAA?$AAT?$AAS?$AAU?$AAB?$AAA?$AA_?$AAC?$AAU?$AAT?$AAO?$AAF?$AAF?$AA?$AA@
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000bc	33 c0		 xor	 eax, eax
$LN16@k_lopsided:

; 3342 :     assert(2 * asize <= bsize);

  000be	48 8b 44 24 40	 mov	 rax, QWORD PTR asize$[rsp]
  000c3	48 d1 e0	 shl	 rax, 1
  000c6	48 3b 44 24 30	 cmp	 rax, QWORD PTR bsize$[rsp]
  000cb	7e 1c		 jle	 SHORT $LN17@k_lopsided
  000cd	41 b8 0e 0d 00
	00		 mov	 r8d, 3342		; 00000d0eH
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@FHKCKJOC@?$AA2?$AA?5?$AA?$CK?$AA?5?$AAa?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e7	33 c0		 xor	 eax, eax
$LN17@k_lopsided:

; 3343 : 
; 3344 :     /* Allocate result space, and zero it out. */
; 3345 :     ret = _PyLong_New(asize + bsize);

  000e9	48 8b 44 24 30	 mov	 rax, QWORD PTR bsize$[rsp]
  000ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR asize$[rsp]
  000f3	48 03 c8	 add	 rcx, rax
  000f6	48 8b c1	 mov	 rax, rcx
  000f9	48 8b c8	 mov	 rcx, rax
  000fc	e8 00 00 00 00	 call	 _PyLong_New
  00101	48 89 44 24 38	 mov	 QWORD PTR ret$[rsp], rax

; 3346 :     if (ret == NULL)

  00106	48 83 7c 24 38
	00		 cmp	 QWORD PTR ret$[rsp], 0
  0010c	75 07		 jne	 SHORT $LN9@k_lopsided

; 3347 :         return NULL;

  0010e	33 c0		 xor	 eax, eax
  00110	e9 a8 01 00 00	 jmp	 $LN10@k_lopsided
$LN9@k_lopsided:

; 3348 :     memset(ret->ob_digit, 0, Py_SIZE(ret) * sizeof(digit));

  00115	48 8b 44 24 38	 mov	 rax, QWORD PTR ret$[rsp]
  0011a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0011e	48 c1 e0 02	 shl	 rax, 2
  00122	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ret$[rsp]
  00127	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0012b	4c 8b c0	 mov	 r8, rax
  0012e	33 d2		 xor	 edx, edx
  00130	e8 00 00 00 00	 call	 memset

; 3349 : 
; 3350 :     /* Successive slices of b are copied into bslice. */
; 3351 :     bslice = _PyLong_New(asize);

  00135	48 8b 4c 24 40	 mov	 rcx, QWORD PTR asize$[rsp]
  0013a	e8 00 00 00 00	 call	 _PyLong_New
  0013f	48 89 44 24 20	 mov	 QWORD PTR bslice$[rsp], rax

; 3352 :     if (bslice == NULL)

  00144	48 83 7c 24 20
	00		 cmp	 QWORD PTR bslice$[rsp], 0
  0014a	75 05		 jne	 SHORT $LN8@k_lopsided

; 3353 :         goto fail;

  0014c	e9 48 01 00 00	 jmp	 $fail$23232
$LN8@k_lopsided:

; 3354 : 
; 3355 :     nbdone = 0;

  00151	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR nbdone$[rsp], 0
$LN7@k_lopsided:

; 3356 :     while (bsize > 0) {

  0015a	48 83 7c 24 30
	00		 cmp	 QWORD PTR bsize$[rsp], 0
  00160	0f 8e 1d 01 00
	00		 jle	 $LN6@k_lopsided

; 3357 :         PyLongObject *product;
; 3358 :         const Py_ssize_t nbtouse = MIN(bsize, asize);

  00166	48 8b 44 24 40	 mov	 rax, QWORD PTR asize$[rsp]
  0016b	48 39 44 24 30	 cmp	 QWORD PTR bsize$[rsp], rax
  00170	7e 0c		 jle	 SHORT $LN18@k_lopsided
  00172	48 8b 44 24 40	 mov	 rax, QWORD PTR asize$[rsp]
  00177	48 89 44 24 68	 mov	 QWORD PTR tv134[rsp], rax
  0017c	eb 0a		 jmp	 SHORT $LN19@k_lopsided
$LN18@k_lopsided:
  0017e	48 8b 44 24 30	 mov	 rax, QWORD PTR bsize$[rsp]
  00183	48 89 44 24 68	 mov	 QWORD PTR tv134[rsp], rax
$LN19@k_lopsided:
  00188	48 8b 44 24 68	 mov	 rax, QWORD PTR tv134[rsp]
  0018d	48 89 44 24 48	 mov	 QWORD PTR nbtouse$23237[rsp], rax

; 3359 : 
; 3360 :         /* Multiply the next slice of b by a. */
; 3361 :         memcpy(bslice->ob_digit, b->ob_digit + nbdone,
; 3362 :                nbtouse * sizeof(digit));

  00192	48 8b 44 24 48	 mov	 rax, QWORD PTR nbtouse$23237[rsp]
  00197	48 c1 e0 02	 shl	 rax, 2
  0019b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  001a3	48 8b 54 24 28	 mov	 rdx, QWORD PTR nbdone$[rsp]
  001a8	48 8d 4c 91 70	 lea	 rcx, QWORD PTR [rcx+rdx*4+112]
  001ad	48 8b 54 24 20	 mov	 rdx, QWORD PTR bslice$[rsp]
  001b2	48 83 c2 70	 add	 rdx, 112		; 00000070H
  001b6	48 89 54 24 70	 mov	 QWORD PTR tv142[rsp], rdx
  001bb	4c 8b c0	 mov	 r8, rax
  001be	48 8b d1	 mov	 rdx, rcx
  001c1	48 8b 44 24 70	 mov	 rax, QWORD PTR tv142[rsp]
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	e8 00 00 00 00	 call	 memcpy

; 3363 :         Py_SIZE(bslice) = nbtouse;

  001ce	48 8b 44 24 20	 mov	 rax, QWORD PTR bslice$[rsp]
  001d3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nbtouse$23237[rsp]
  001d8	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3364 :         product = k_mul(a, bslice);

  001dc	48 8b 54 24 20	 mov	 rdx, QWORD PTR bslice$[rsp]
  001e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001e9	e8 00 00 00 00	 call	 k_mul
  001ee	48 89 44 24 50	 mov	 QWORD PTR product$23236[rsp], rax

; 3365 :         if (product == NULL)

  001f3	48 83 7c 24 50
	00		 cmp	 QWORD PTR product$23236[rsp], 0
  001f9	75 05		 jne	 SHORT $LN5@k_lopsided

; 3366 :             goto fail;

  001fb	e9 99 00 00 00	 jmp	 $fail$23232
$LN5@k_lopsided:

; 3367 : 
; 3368 :         /* Add into result. */
; 3369 :         (void)v_iadd(ret->ob_digit + nbdone, Py_SIZE(ret) - nbdone,
; 3370 :                      product->ob_digit, Py_SIZE(product));

  00200	48 8b 44 24 50	 mov	 rax, QWORD PTR product$23236[rsp]
  00205	48 83 c0 70	 add	 rax, 112		; 00000070H
  00209	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ret$[rsp]
  0020e	48 8b 54 24 28	 mov	 rdx, QWORD PTR nbdone$[rsp]
  00213	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00217	48 2b ca	 sub	 rcx, rdx
  0021a	48 8b 54 24 38	 mov	 rdx, QWORD PTR ret$[rsp]
  0021f	4c 8b 44 24 28	 mov	 r8, QWORD PTR nbdone$[rsp]
  00224	4a 8d 54 82 70	 lea	 rdx, QWORD PTR [rdx+r8*4+112]
  00229	48 89 54 24 78	 mov	 QWORD PTR tv158[rsp], rdx
  0022e	4c 8b 44 24 50	 mov	 r8, QWORD PTR product$23236[rsp]
  00233	4d 8b 48 60	 mov	 r9, QWORD PTR [r8+96]
  00237	4c 8b c0	 mov	 r8, rax
  0023a	48 8b d1	 mov	 rdx, rcx
  0023d	48 8b 44 24 78	 mov	 rax, QWORD PTR tv158[rsp]
  00242	48 8b c8	 mov	 rcx, rax
  00245	e8 00 00 00 00	 call	 v_iadd

; 3371 :         Py_DECREF(product);

  0024a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR product$23236[rsp]
  0024f	e8 00 00 00 00	 call	 _Py_DecRef

; 3372 : 
; 3373 :         bsize -= nbtouse;

  00254	48 8b 44 24 48	 mov	 rax, QWORD PTR nbtouse$23237[rsp]
  00259	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bsize$[rsp]
  0025e	48 2b c8	 sub	 rcx, rax
  00261	48 8b c1	 mov	 rax, rcx
  00264	48 89 44 24 30	 mov	 QWORD PTR bsize$[rsp], rax

; 3374 :         nbdone += nbtouse;

  00269	48 8b 44 24 48	 mov	 rax, QWORD PTR nbtouse$23237[rsp]
  0026e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nbdone$[rsp]
  00273	48 03 c8	 add	 rcx, rax
  00276	48 8b c1	 mov	 rax, rcx
  00279	48 89 44 24 28	 mov	 QWORD PTR nbdone$[rsp], rax

; 3375 :     }

  0027e	e9 d7 fe ff ff	 jmp	 $LN7@k_lopsided
$LN6@k_lopsided:

; 3376 : 
; 3377 :     Py_DECREF(bslice);

  00283	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bslice$[rsp]
  00288	e8 00 00 00 00	 call	 _Py_DecRef

; 3378 :     return long_normalize(ret);

  0028d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ret$[rsp]
  00292	e8 00 00 00 00	 call	 long_normalize
  00297	eb 24		 jmp	 SHORT $LN10@k_lopsided
$fail$23232:

; 3379 : 
; 3380 :   fail:
; 3381 :     Py_DECREF(ret);

  00299	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ret$[rsp]
  0029e	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@k_lopsided:

; 3382 :     Py_XDECREF(bslice);

  002a3	48 83 7c 24 20
	00		 cmp	 QWORD PTR bslice$[rsp], 0
  002a9	74 0a		 je	 SHORT $LN1@k_lopsided
  002ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bslice$[rsp]
  002b0	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@k_lopsided:
  002b5	33 c0		 xor	 eax, eax
  002b7	85 c0		 test	 eax, eax
  002b9	75 e8		 jne	 SHORT $LN4@k_lopsided

; 3383 :     return NULL;

  002bb	33 c0		 xor	 eax, eax
$LN10@k_lopsided:

; 3384 : }

  002bd	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002c4	c3		 ret	 0
k_lopsided_mul ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_div DD imagerel long_div
	DD	imagerel long_div+135
	DD	imagerel $unwind$long_div
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_div DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_div
_TEXT	SEGMENT
div$ = 32
a$ = 64
b$ = 72
long_div PROC						; COMDAT

; 3483 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@long_div:

; 3484 :     PyLongObject *div;
; 3485 : 
; 3486 :     CHECK_BINOP(a, b);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00022	85 c0		 test	 eax, eax
  00024	74 18		 je	 SHORT $LN2@long_div
  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003a	85 c0		 test	 eax, eax
  0003c	75 15		 jne	 SHORT $LN3@long_div
$LN2@long_div:
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00045	e8 00 00 00 00	 call	 _Py_IncRef
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00051	eb 2f		 jmp	 SHORT $LN7@long_div
$LN3@long_div:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 b5		 jne	 SHORT $LN6@long_div

; 3487 :     if (l_divmod((PyLongObject*)a, (PyLongObject*)b, &div, NULL) < 0)

  00059	45 33 c9	 xor	 r9d, r9d
  0005c	4c 8d 44 24 20	 lea	 r8, QWORD PTR div$[rsp]
  00061	48 8b 54 24 48	 mov	 rdx, QWORD PTR b$[rsp]
  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0006b	e8 00 00 00 00	 call	 l_divmod
  00070	85 c0		 test	 eax, eax
  00072	7d 09		 jge	 SHORT $LN1@long_div

; 3488 :         div = NULL;

  00074	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR div$[rsp], 0
$LN1@long_div:

; 3489 :     return (PyObject *)div;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR div$[rsp]
$LN7@long_div:

; 3490 : }

  00082	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00086	c3		 ret	 0
long_div ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$l_divmod DD imagerel l_divmod
	DD	imagerel l_divmod+392
	DD	imagerel $unwind$l_divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$l_divmod DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT l_divmod
_TEXT	SEGMENT
div$ = 32
mod$ = 40
temp$23329 = 48
one$23330 = 56
v$ = 80
w$ = 88
pdiv$ = 96
pmod$ = 104
l_divmod PROC						; COMDAT

; 3440 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3441 :     PyLongObject *div, *mod;
; 3442 : 
; 3443 :     if (long_divrem(v, w, &div, &mod) < 0)

  00018	4c 8d 4c 24 28	 lea	 r9, QWORD PTR mod$[rsp]
  0001d	4c 8d 44 24 20	 lea	 r8, QWORD PTR div$[rsp]
  00022	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0002c	e8 00 00 00 00	 call	 long_divrem
  00031	85 c0		 test	 eax, eax
  00033	7d 0a		 jge	 SHORT $LN15@l_divmod

; 3444 :         return -1;

  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	e9 44 01 00 00	 jmp	 $LN16@l_divmod
$LN15@l_divmod:

; 3445 :     if ((Py_SIZE(mod) < 0 && Py_SIZE(w) > 0) ||
; 3446 :         (Py_SIZE(mod) > 0 && Py_SIZE(w) < 0)) {

  0003f	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  00044	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00049	7d 0c		 jge	 SHORT $LN12@l_divmod
  0004b	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  00050	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00055	7f 20		 jg	 SHORT $LN13@l_divmod
$LN12@l_divmod:
  00057	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  0005c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00061	0f 8e d8 00 00
	00		 jle	 $LN14@l_divmod
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  0006c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00071	0f 8d c8 00 00
	00		 jge	 $LN14@l_divmod
$LN13@l_divmod:

; 3447 :         PyLongObject *temp;
; 3448 :         PyLongObject *one;
; 3449 :         temp = (PyLongObject *) long_add(mod, w);

  00077	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  0007c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mod$[rsp]
  00081	e8 00 00 00 00	 call	 long_add
  00086	48 89 44 24 30	 mov	 QWORD PTR temp$23329[rsp], rax

; 3450 :         Py_DECREF(mod);

  0008b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mod$[rsp]
  00090	e8 00 00 00 00	 call	 _Py_DecRef

; 3451 :         mod = temp;

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$23329[rsp]
  0009a	48 89 44 24 28	 mov	 QWORD PTR mod$[rsp], rax

; 3452 :         if (mod == NULL) {

  0009f	48 83 7c 24 28
	00		 cmp	 QWORD PTR mod$[rsp], 0
  000a5	75 14		 jne	 SHORT $LN11@l_divmod

; 3453 :             Py_DECREF(div);

  000a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  000ac	e8 00 00 00 00	 call	 _Py_DecRef

; 3454 :             return -1;

  000b1	b8 ff ff ff ff	 mov	 eax, -1
  000b6	e9 c8 00 00 00	 jmp	 $LN16@l_divmod
$LN11@l_divmod:

; 3455 :         }
; 3456 :         one = (PyLongObject *) PyLong_FromLong(1L);

  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	e8 00 00 00 00	 call	 PyLong_FromLong
  000c5	48 89 44 24 38	 mov	 QWORD PTR one$23330[rsp], rax

; 3457 :         if (one == NULL ||
; 3458 :             (temp = (PyLongObject *) long_sub(div, one)) == NULL) {

  000ca	48 83 7c 24 38
	00		 cmp	 QWORD PTR one$23330[rsp], 0
  000d0	74 1c		 je	 SHORT $LN9@l_divmod
  000d2	48 8b 54 24 38	 mov	 rdx, QWORD PTR one$23330[rsp]
  000d7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  000dc	e8 00 00 00 00	 call	 long_sub
  000e1	48 89 44 24 30	 mov	 QWORD PTR temp$23329[rsp], rax
  000e6	48 83 7c 24 30
	00		 cmp	 QWORD PTR temp$23329[rsp], 0
  000ec	75 33		 jne	 SHORT $LN10@l_divmod
$LN9@l_divmod:

; 3459 :             Py_DECREF(mod);

  000ee	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mod$[rsp]
  000f3	e8 00 00 00 00	 call	 _Py_DecRef

; 3460 :             Py_DECREF(div);

  000f8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  000fd	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@l_divmod:

; 3461 :             Py_XDECREF(one);

  00102	48 83 7c 24 38
	00		 cmp	 QWORD PTR one$23330[rsp], 0
  00108	74 0a		 je	 SHORT $LN5@l_divmod
  0010a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR one$23330[rsp]
  0010f	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@l_divmod:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 e8		 jne	 SHORT $LN8@l_divmod

; 3462 :             return -1;

  0011a	b8 ff ff ff ff	 mov	 eax, -1
  0011f	eb 62		 jmp	 SHORT $LN16@l_divmod
$LN10@l_divmod:

; 3463 :         }
; 3464 :         Py_DECREF(one);

  00121	48 8b 4c 24 38	 mov	 rcx, QWORD PTR one$23330[rsp]
  00126	e8 00 00 00 00	 call	 _Py_DecRef

; 3465 :         Py_DECREF(div);

  0012b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  00130	e8 00 00 00 00	 call	 _Py_DecRef

; 3466 :         div = temp;

  00135	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$23329[rsp]
  0013a	48 89 44 24 20	 mov	 QWORD PTR div$[rsp], rax
$LN14@l_divmod:

; 3467 :     }
; 3468 :     if (pdiv != NULL)

  0013f	48 83 7c 24 60
	00		 cmp	 QWORD PTR pdiv$[rsp], 0
  00145	74 0f		 je	 SHORT $LN4@l_divmod

; 3469 :         *pdiv = div;

  00147	48 8b 44 24 60	 mov	 rax, QWORD PTR pdiv$[rsp]
  0014c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  00151	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3470 :     else

  00154	eb 0a		 jmp	 SHORT $LN3@l_divmod
$LN4@l_divmod:

; 3471 :         Py_DECREF(div);

  00156	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  0015b	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@l_divmod:

; 3472 : 
; 3473 :     if (pmod != NULL)

  00160	48 83 7c 24 68
	00		 cmp	 QWORD PTR pmod$[rsp], 0
  00166	74 0f		 je	 SHORT $LN2@l_divmod

; 3474 :         *pmod = mod;

  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR pmod$[rsp]
  0016d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mod$[rsp]
  00172	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3475 :     else

  00175	eb 0a		 jmp	 SHORT $LN1@l_divmod
$LN2@l_divmod:

; 3476 :         Py_DECREF(mod);

  00177	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mod$[rsp]
  0017c	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@l_divmod:

; 3477 : 
; 3478 :     return 0;

  00181	33 c0		 xor	 eax, eax
$LN16@l_divmod:

; 3479 : }

  00183	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00187	c3		 ret	 0
l_divmod ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@OPLMMFNH@integer?5division?5or?5modulo?5by?5ze@ ; `string'
EXTRN	PyExc_ZeroDivisionError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_divrem DD imagerel long_divrem
	DD	imagerel long_divrem+1025
	DD	imagerel $unwind$long_divrem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_divrem DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT ??_C@_0CD@OPLMMFNH@integer?5division?5or?5modulo?5by?5ze@
CONST	SEGMENT
??_C@_0CD@OPLMMFNH@integer?5division?5or?5modulo?5by?5ze@ DB 'integer div'
	DB	'ision or modulo by zero', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_divrem
_TEXT	SEGMENT
size_b$ = 32
z$ = 40
size_a$ = 48
rem$22417 = 56
tmp$22439 = 64
tmp$22458 = 72
tv69 = 80
tv75 = 88
tv148 = 96
tv147 = 100
tv166 = 104
tv165 = 108
tv191 = 112
tv190 = 116
a$ = 144
b$ = 152
pdiv$ = 160
prem$ = 168
long_divrem PROC					; COMDAT

; 2380 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2381 :     Py_ssize_t size_a = ABS(Py_SIZE(a)), size_b = ABS(Py_SIZE(b));

  0001b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00023	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00028	7d 16		 jge	 SHORT $LN24@long_divre
  0002a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00032	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00036	48 f7 d8	 neg	 rax
  00039	48 89 44 24 50	 mov	 QWORD PTR tv69[rsp], rax
  0003e	eb 11		 jmp	 SHORT $LN25@long_divre
$LN24@long_divre:
  00040	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00048	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004c	48 89 44 24 50	 mov	 QWORD PTR tv69[rsp], rax
$LN25@long_divre:
  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR tv69[rsp]
  00056	48 89 44 24 30	 mov	 QWORD PTR size_a$[rsp], rax
  0005b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00063	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00068	7d 16		 jge	 SHORT $LN26@long_divre
  0006a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00072	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00076	48 f7 d8	 neg	 rax
  00079	48 89 44 24 58	 mov	 QWORD PTR tv75[rsp], rax
  0007e	eb 11		 jmp	 SHORT $LN27@long_divre
$LN26@long_divre:
  00080	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00088	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008c	48 89 44 24 58	 mov	 QWORD PTR tv75[rsp], rax
$LN27@long_divre:
  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR tv75[rsp]
  00096	48 89 44 24 20	 mov	 QWORD PTR size_b$[rsp], rax

; 2382 :     PyLongObject *z;
; 2383 : 
; 2384 :     if (size_b == 0) {

  0009b	48 83 7c 24 20
	00		 cmp	 QWORD PTR size_b$[rsp], 0
  000a1	75 1d		 jne	 SHORT $LN21@long_divre

; 2385 :         PyErr_SetString(PyExc_ZeroDivisionError,
; 2386 :                         "integer division or modulo by zero");

  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@OPLMMFNH@integer?5division?5or?5modulo?5by?5ze@
  000aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  000b1	e8 00 00 00 00	 call	 PyErr_SetString

; 2387 :         return -1;

  000b6	b8 ff ff ff ff	 mov	 eax, -1
  000bb	e9 39 03 00 00	 jmp	 $LN22@long_divre
$LN21@long_divre:

; 2388 :     }
; 2389 :     if (size_a < size_b ||
; 2390 :         (size_a == size_b &&
; 2391 :          a->ob_digit[size_a-1] < b->ob_digit[size_b-1])) {

  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR size_b$[rsp]
  000c5	48 39 44 24 30	 cmp	 QWORD PTR size_a$[rsp], rax
  000ca	7c 31		 jl	 SHORT $LN19@long_divre
  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR size_b$[rsp]
  000d1	48 39 44 24 30	 cmp	 QWORD PTR size_a$[rsp], rax
  000d6	75 76		 jne	 SHORT $LN20@long_divre
  000d8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size_a$[rsp]
  000e5	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  000ed	4c 8b 44 24 20	 mov	 r8, QWORD PTR size_b$[rsp]
  000f2	42 8b 54 82 6c	 mov	 edx, DWORD PTR [rdx+r8*4+108]
  000f7	39 54 88 6c	 cmp	 DWORD PTR [rax+rcx*4+108], edx
  000fb	73 51		 jae	 SHORT $LN20@long_divre
$LN19@long_divre:

; 2392 :         /* |a| < |b|. */
; 2393 :         *pdiv = (PyLongObject*)PyLong_FromLong(0);

  000fd	33 c9		 xor	 ecx, ecx
  000ff	e8 00 00 00 00	 call	 PyLong_FromLong
  00104	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pdiv$[rsp]
  0010c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2394 :         if (*pdiv == NULL)

  0010f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pdiv$[rsp]
  00117	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0011b	75 0a		 jne	 SHORT $LN18@long_divre

; 2395 :             return -1;

  0011d	b8 ff ff ff ff	 mov	 eax, -1
  00122	e9 d2 02 00 00	 jmp	 $LN22@long_divre
$LN18@long_divre:

; 2396 :         Py_INCREF(a);

  00127	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0012f	e8 00 00 00 00	 call	 _Py_IncRef

; 2397 :         *prem = (PyLongObject *) a;

  00134	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  0013c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00144	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2398 :         return 0;

  00147	33 c0		 xor	 eax, eax
  00149	e9 ab 02 00 00	 jmp	 $LN22@long_divre
$LN20@long_divre:

; 2399 :     }
; 2400 :     if (size_b == 1) {

  0014e	48 83 7c 24 20
	01		 cmp	 QWORD PTR size_b$[rsp], 1
  00154	75 74		 jne	 SHORT $LN17@long_divre

; 2401 :         digit rem = 0;

  00156	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR rem$22417[rsp], 0

; 2402 :         z = divrem1(a, b->ob_digit[0], &rem);

  0015e	4c 8d 44 24 38	 lea	 r8, QWORD PTR rem$22417[rsp]
  00163	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0016b	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  0016e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00176	e8 00 00 00 00	 call	 divrem1
  0017b	48 89 44 24 28	 mov	 QWORD PTR z$[rsp], rax

; 2403 :         if (z == NULL)

  00180	48 83 7c 24 28
	00		 cmp	 QWORD PTR z$[rsp], 0
  00186	75 0a		 jne	 SHORT $LN16@long_divre

; 2404 :             return -1;

  00188	b8 ff ff ff ff	 mov	 eax, -1
  0018d	e9 67 02 00 00	 jmp	 $LN22@long_divre
$LN16@long_divre:

; 2405 :         *prem = (PyLongObject *) PyLong_FromLong((long)rem);

  00192	8b 4c 24 38	 mov	 ecx, DWORD PTR rem$22417[rsp]
  00196	e8 00 00 00 00	 call	 PyLong_FromLong
  0019b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR prem$[rsp]
  001a3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2406 :         if (*prem == NULL) {

  001a6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  001ae	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001b2	75 14		 jne	 SHORT $LN15@long_divre

; 2407 :             Py_DECREF(z);

  001b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR z$[rsp]
  001b9	e8 00 00 00 00	 call	 _Py_DecRef

; 2408 :             return -1;

  001be	b8 ff ff ff ff	 mov	 eax, -1
  001c3	e9 31 02 00 00	 jmp	 $LN22@long_divre
$LN15@long_divre:

; 2409 :         }
; 2410 :     }
; 2411 :     else {

  001c8	eb 34		 jmp	 SHORT $LN14@long_divre
$LN17@long_divre:

; 2412 :         z = x_divrem(a, b, prem);

  001ca	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR prem$[rsp]
  001d2	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  001da	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001e2	e8 00 00 00 00	 call	 x_divrem
  001e7	48 89 44 24 28	 mov	 QWORD PTR z$[rsp], rax

; 2413 :         if (z == NULL)

  001ec	48 83 7c 24 28
	00		 cmp	 QWORD PTR z$[rsp], 0
  001f2	75 0a		 jne	 SHORT $LN13@long_divre

; 2414 :             return -1;

  001f4	b8 ff ff ff ff	 mov	 eax, -1
  001f9	e9 fb 01 00 00	 jmp	 $LN22@long_divre
$LN13@long_divre:
$LN14@long_divre:

; 2415 :     }
; 2416 :     /* Set the signs.
; 2417 :        The quotient z has the sign of a*b;
; 2418 :        the remainder r has the sign of a,
; 2419 :        so a = b*z + r. */
; 2420 :     if ((Py_SIZE(a) < 0) != (Py_SIZE(b) < 0))

  001fe	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00206	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0020b	7d 0a		 jge	 SHORT $LN30@long_divre
  0020d	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv148[rsp], 1
  00215	eb 08		 jmp	 SHORT $LN31@long_divre
$LN30@long_divre:
  00217	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv148[rsp], 0
$LN31@long_divre:
  0021f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00227	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0022c	7d 0a		 jge	 SHORT $LN28@long_divre
  0022e	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  00236	eb 08		 jmp	 SHORT $LN29@long_divre
$LN28@long_divre:
  00238	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN29@long_divre:
  00240	8b 44 24 64	 mov	 eax, DWORD PTR tv147[rsp]
  00244	39 44 24 60	 cmp	 DWORD PTR tv148[rsp], eax
  00248	0f 84 99 00 00
	00		 je	 $LN12@long_divre
$LN11@long_divre:

; 2421 :         NEGATE(z);

  0024e	48 8b 44 24 28	 mov	 rax, QWORD PTR z$[rsp]
  00253	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  00258	75 17		 jne	 SHORT $LN8@long_divre
  0025a	48 8b 44 24 28	 mov	 rax, QWORD PTR z$[rsp]
  0025f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00263	48 f7 d8	 neg	 rax
  00266	48 8b 4c 24 28	 mov	 rcx, QWORD PTR z$[rsp]
  0026b	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  0026f	eb 6c		 jmp	 SHORT $LN7@long_divre
$LN8@long_divre:
  00271	48 8b 44 24 28	 mov	 rax, QWORD PTR z$[rsp]
  00276	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0027b	7d 10		 jge	 SHORT $LN34@long_divre
  0027d	48 8b 44 24 28	 mov	 rax, QWORD PTR z$[rsp]
  00282	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00285	f7 d8		 neg	 eax
  00287	89 44 24 68	 mov	 DWORD PTR tv166[rsp], eax
  0028b	eb 2a		 jmp	 SHORT $LN35@long_divre
$LN34@long_divre:
  0028d	48 8b 44 24 28	 mov	 rax, QWORD PTR z$[rsp]
  00292	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00297	75 0a		 jne	 SHORT $LN32@long_divre
  00299	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
  002a1	eb 0c		 jmp	 SHORT $LN33@long_divre
$LN32@long_divre:
  002a3	48 8b 44 24 28	 mov	 rax, QWORD PTR z$[rsp]
  002a8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002ab	89 44 24 6c	 mov	 DWORD PTR tv165[rsp], eax
$LN33@long_divre:
  002af	8b 44 24 6c	 mov	 eax, DWORD PTR tv165[rsp]
  002b3	89 44 24 68	 mov	 DWORD PTR tv166[rsp], eax
$LN35@long_divre:
  002b7	8b 44 24 68	 mov	 eax, DWORD PTR tv166[rsp]
  002bb	f7 d8		 neg	 eax
  002bd	8b c8		 mov	 ecx, eax
  002bf	e8 00 00 00 00	 call	 PyLong_FromLong
  002c4	48 89 44 24 40	 mov	 QWORD PTR tmp$22439[rsp], rax
  002c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR z$[rsp]
  002ce	e8 00 00 00 00	 call	 _Py_DecRef
  002d3	48 8b 44 24 40	 mov	 rax, QWORD PTR tmp$22439[rsp]
  002d8	48 89 44 24 28	 mov	 QWORD PTR z$[rsp], rax
$LN7@long_divre:
  002dd	33 c0		 xor	 eax, eax
  002df	85 c0		 test	 eax, eax
  002e1	0f 85 67 ff ff
	ff		 jne	 $LN11@long_divre
$LN12@long_divre:

; 2422 :     if (Py_SIZE(a) < 0 && Py_SIZE(*prem) != 0)

  002e7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002ef	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  002f4	0f 8d e8 00 00
	00		 jge	 $LN6@long_divre
  002fa	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  00302	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00305	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0030a	0f 84 d2 00 00
	00		 je	 $LN6@long_divre
$LN5@long_divre:

; 2423 :         NEGATE(*prem);

  00310	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  00318	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0031b	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  00320	75 26		 jne	 SHORT $LN2@long_divre
  00322	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  0032a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0032d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00331	48 f7 d8	 neg	 rax
  00334	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR prem$[rsp]
  0033c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0033f	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  00343	e9 90 00 00 00	 jmp	 $LN1@long_divre
$LN2@long_divre:
  00348	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  00350	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00353	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00358	7d 16		 jge	 SHORT $LN38@long_divre
  0035a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  00362	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00365	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00368	f7 d8		 neg	 eax
  0036a	89 44 24 70	 mov	 DWORD PTR tv191[rsp], eax
  0036e	eb 36		 jmp	 SHORT $LN39@long_divre
$LN38@long_divre:
  00370	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  00378	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0037b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00380	75 0a		 jne	 SHORT $LN36@long_divre
  00382	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv190[rsp], 0
  0038a	eb 12		 jmp	 SHORT $LN37@long_divre
$LN36@long_divre:
  0038c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  00394	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00397	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0039a	89 44 24 74	 mov	 DWORD PTR tv190[rsp], eax
$LN37@long_divre:
  0039e	8b 44 24 74	 mov	 eax, DWORD PTR tv190[rsp]
  003a2	89 44 24 70	 mov	 DWORD PTR tv191[rsp], eax
$LN39@long_divre:
  003a6	8b 44 24 70	 mov	 eax, DWORD PTR tv191[rsp]
  003aa	f7 d8		 neg	 eax
  003ac	8b c8		 mov	 ecx, eax
  003ae	e8 00 00 00 00	 call	 PyLong_FromLong
  003b3	48 89 44 24 48	 mov	 QWORD PTR tmp$22458[rsp], rax
  003b8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  003c0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003c3	e8 00 00 00 00	 call	 _Py_DecRef
  003c8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  003d0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tmp$22458[rsp]
  003d5	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@long_divre:
  003d8	33 c0		 xor	 eax, eax
  003da	85 c0		 test	 eax, eax
  003dc	0f 85 2e ff ff
	ff		 jne	 $LN5@long_divre
$LN6@long_divre:

; 2424 :     *pdiv = maybe_small_long(z);

  003e2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR z$[rsp]
  003e7	e8 00 00 00 00	 call	 maybe_small_long
  003ec	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pdiv$[rsp]
  003f4	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2425 :     return 0;

  003f7	33 c0		 xor	 eax, eax
$LN22@long_divre:

; 2426 : }

  003f9	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00400	c3		 ret	 0
long_divrem ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@OGBEBCHN@?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$divrem1 DD imagerel divrem1
	DD	imagerel divrem1+203
	DD	imagerel $unwind$divrem1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$divrem1 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT ??_C@_1DE@OGBEBCHN@?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@OGBEBCHN@?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?$AA@ DB 'n'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 'n', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, 'P', 00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H
	DB	'_', 00H, 'M', 00H, 'A', 00H, 'S', 00H, 'K', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT divrem1
_TEXT	SEGMENT
size$ = 32
z$ = 40
tv69 = 48
a$ = 80
n$ = 88
prem$ = 96
divrem1	PROC						; COMDAT

; 1560 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1561 :     const Py_ssize_t size = ABS(Py_SIZE(a));

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00017	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001c	7d 13		 jge	 SHORT $LN4@divrem1
  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00023	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00027	48 f7 d8	 neg	 rax
  0002a	48 89 44 24 30	 mov	 QWORD PTR tv69[rsp], rax
  0002f	eb 0e		 jmp	 SHORT $LN5@divrem1
$LN4@divrem1:
  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00036	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003a	48 89 44 24 30	 mov	 QWORD PTR tv69[rsp], rax
$LN5@divrem1:
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR tv69[rsp]
  00044	48 89 44 24 20	 mov	 QWORD PTR size$[rsp], rax

; 1562 :     PyLongObject *z;
; 1563 : 
; 1564 :     assert(n > 0 && n <= PyLong_MASK);

  00049	83 7c 24 58 00	 cmp	 DWORD PTR n$[rsp], 0
  0004e	76 0a		 jbe	 SHORT $LN6@divrem1
  00050	81 7c 24 58 ff
	ff ff 3f	 cmp	 DWORD PTR n$[rsp], 1073741823 ; 3fffffffH
  00058	76 1c		 jbe	 SHORT $LN7@divrem1
$LN6@divrem1:
  0005a	41 b8 1c 06 00
	00		 mov	 r8d, 1564		; 0000061cH
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@OGBEBCHN@?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?$AA@
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00074	33 c0		 xor	 eax, eax
$LN7@divrem1:

; 1565 :     z = _PyLong_New(size);

  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR size$[rsp]
  0007b	e8 00 00 00 00	 call	 _PyLong_New
  00080	48 89 44 24 28	 mov	 QWORD PTR z$[rsp], rax

; 1566 :     if (z == NULL)

  00085	48 83 7c 24 28
	00		 cmp	 QWORD PTR z$[rsp], 0
  0008b	75 04		 jne	 SHORT $LN1@divrem1

; 1567 :         return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 35		 jmp	 SHORT $LN2@divrem1
$LN1@divrem1:

; 1568 :     *prem = inplace_divrem1(z->ob_digit, a->ob_digit, size, n);

  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00096	48 83 c0 70	 add	 rax, 112		; 00000070H
  0009a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR z$[rsp]
  0009f	48 83 c1 70	 add	 rcx, 112		; 00000070H
  000a3	44 8b 4c 24 58	 mov	 r9d, DWORD PTR n$[rsp]
  000a8	4c 8b 44 24 20	 mov	 r8, QWORD PTR size$[rsp]
  000ad	48 8b d0	 mov	 rdx, rax
  000b0	e8 00 00 00 00	 call	 inplace_divrem1
  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prem$[rsp]
  000ba	89 01		 mov	 DWORD PTR [rcx], eax

; 1569 :     return long_normalize(z);

  000bc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR z$[rsp]
  000c1	e8 00 00 00 00	 call	 long_normalize
$LN2@divrem1:

; 1570 : }

  000c6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ca	c3		 ret	 0
divrem1	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inplace_divrem1 DD imagerel inplace_divrem1
	DD	imagerel inplace_divrem1+273
	DD	imagerel $unwind$inplace_divrem1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inplace_divrem1 DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inplace_divrem1
_TEXT	SEGMENT
rem$ = 32
hi$21312 = 40
tv81 = 48
pout$ = 80
pin$ = 88
size$ = 96
n$ = 104
inplace_divrem1 PROC					; COMDAT

; 1539 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1540 :     twodigits rem = 0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR rem$[rsp], 0

; 1541 : 
; 1542 :     assert(n > 0 && n <= PyLong_MASK);

  00021	83 7c 24 68 00	 cmp	 DWORD PTR n$[rsp], 0
  00026	76 0a		 jbe	 SHORT $LN5@inplace_di
  00028	81 7c 24 68 ff
	ff ff 3f	 cmp	 DWORD PTR n$[rsp], 1073741823 ; 3fffffffH
  00030	76 1c		 jbe	 SHORT $LN6@inplace_di
$LN5@inplace_di:
  00032	41 b8 06 06 00
	00		 mov	 r8d, 1542		; 00000606H
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@OGBEBCHN@?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAM?$AAA?$AAS?$AAK?$AA?$AA@
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004c	33 c0		 xor	 eax, eax
$LN6@inplace_di:

; 1543 :     pin += size;

  0004e	48 8b 44 24 58	 mov	 rax, QWORD PTR pin$[rsp]
  00053	48 8b 4c 24 60	 mov	 rcx, QWORD PTR size$[rsp]
  00058	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0005c	48 89 44 24 58	 mov	 QWORD PTR pin$[rsp], rax

; 1544 :     pout += size;

  00061	48 8b 44 24 50	 mov	 rax, QWORD PTR pout$[rsp]
  00066	48 8b 4c 24 60	 mov	 rcx, QWORD PTR size$[rsp]
  0006b	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0006f	48 89 44 24 50	 mov	 QWORD PTR pout$[rsp], rax
$LN2@inplace_di:

; 1545 :     while (--size >= 0) {

  00074	48 8b 44 24 60	 mov	 rax, QWORD PTR size$[rsp]
  00079	48 ff c8	 dec	 rax
  0007c	48 89 44 24 60	 mov	 QWORD PTR size$[rsp], rax
  00081	48 83 7c 24 60
	00		 cmp	 QWORD PTR size$[rsp], 0
  00087	7c 7f		 jl	 SHORT $LN1@inplace_di

; 1546 :         digit hi;
; 1547 :         rem = (rem << PyLong_SHIFT) | *--pin;

  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR pin$[rsp]
  0008e	48 83 e8 04	 sub	 rax, 4
  00092	48 89 44 24 58	 mov	 QWORD PTR pin$[rsp], rax
  00097	48 8b 44 24 58	 mov	 rax, QWORD PTR pin$[rsp]
  0009c	8b 00		 mov	 eax, DWORD PTR [rax]
  0009e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rem$[rsp]
  000a3	48 c1 e1 1e	 shl	 rcx, 30
  000a7	48 0b c8	 or	 rcx, rax
  000aa	48 8b c1	 mov	 rax, rcx
  000ad	48 89 44 24 20	 mov	 QWORD PTR rem$[rsp], rax

; 1548 :         *--pout = hi = (digit)(rem / n);

  000b2	8b 44 24 68	 mov	 eax, DWORD PTR n$[rsp]
  000b6	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  000bb	33 d2		 xor	 edx, edx
  000bd	48 8b 44 24 20	 mov	 rax, QWORD PTR rem$[rsp]
  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  000c7	48 f7 f1	 div	 rcx
  000ca	89 44 24 28	 mov	 DWORD PTR hi$21312[rsp], eax
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR pout$[rsp]
  000d3	48 83 e8 04	 sub	 rax, 4
  000d7	48 89 44 24 50	 mov	 QWORD PTR pout$[rsp], rax
  000dc	48 8b 44 24 50	 mov	 rax, QWORD PTR pout$[rsp]
  000e1	8b 4c 24 28	 mov	 ecx, DWORD PTR hi$21312[rsp]
  000e5	89 08		 mov	 DWORD PTR [rax], ecx

; 1549 :         rem -= (twodigits)hi * n;

  000e7	8b 44 24 28	 mov	 eax, DWORD PTR hi$21312[rsp]
  000eb	8b 4c 24 68	 mov	 ecx, DWORD PTR n$[rsp]
  000ef	48 0f af c1	 imul	 rax, rcx
  000f3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rem$[rsp]
  000f8	48 2b c8	 sub	 rcx, rax
  000fb	48 8b c1	 mov	 rax, rcx
  000fe	48 89 44 24 20	 mov	 QWORD PTR rem$[rsp], rax

; 1550 :     }

  00103	e9 6c ff ff ff	 jmp	 $LN2@inplace_di
$LN1@inplace_di:

; 1551 :     return (digit)rem;

  00108	8b 44 24 20	 mov	 eax, DWORD PTR rem$[rsp]

; 1552 : }

  0010c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00110	c3		 ret	 0
inplace_divrem1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BC@JNKLFFDJ@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@BCAJAPG@?$AAq?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GI@JDPLFPFJ@?$AA?$CI?$AAs?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AAv?$AAt?$AAo?$AAp?$AA?5?$AA?$CL?$AA?5?$AAz?$AAh?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAs?$AAd?$AAi@ ; `string'
PUBLIC	??_C@_1CC@KEJBDHPH@?$AAq?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@GPLJOBFL@?$AAv?$AAt?$AAo?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAw?$AAm?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@GKOFOALE@?$AAk?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@EPMFMPJB@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAv?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAw?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$x_divrem DD imagerel x_divrem
	DD	imagerel x_divrem+1772
	DD	imagerel $unwind$x_divrem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x_divrem DD 021601H
	DD	01b0116H
xdata	ENDS
;	COMDAT ??_C@_1BC@JNKLFFDJ@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@JNKLFFDJ@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@ DB 'c'
	DB	00H, 'a', 00H, 'r', 00H, 'r', 00H, 'y', 00H, '=', 00H, '=', 00H
	DB	'0', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@BCAJAPG@?$AAq?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@BCAJAPG@?$AAq?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@ DB 'q'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'L', 00H
	DB	'o', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'B', 00H, 'A', 00H, 'S'
	DB	00H, 'E', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@JDPLFPFJ@?$AA?$CI?$AAs?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AAv?$AAt?$AAo?$AAp?$AA?5?$AA?$CL?$AA?5?$AAz?$AAh?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAs?$AAd?$AAi@
CONST	SEGMENT
??_C@_1GI@JDPLFPFJ@?$AA?$CI?$AAs?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AAv?$AAt?$AAo?$AAp?$AA?5?$AA?$CL?$AA?5?$AAz?$AAh?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAs?$AAd?$AAi@ DB '('
	DB	00H, 's', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H
	DB	')', 00H, 'v', 00H, 't', 00H, 'o', 00H, 'p', 00H, ' ', 00H, '+'
	DB	00H, ' ', 00H, 'z', 00H, 'h', 00H, 'i', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '-', 00H, '1', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, '(', 00H, 's', 00H, 'd', 00H, 'i', 00H, 'g', 00H
	DB	'i', 00H, 't', 00H, ')', 00H, 'v', 00H, 't', 00H, 'o', 00H, 'p'
	DB	00H, ' ', 00H, '+', 00H, ' ', 00H, 'z', 00H, 'h', 00H, 'i', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@KEJBDHPH@?$AAq?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@KEJBDHPH@?$AAq?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@ DB 'q'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'y', 00H
	DB	'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'B', 00H, 'A'
	DB	00H, 'S', 00H, 'E', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@GPLJOBFL@?$AAv?$AAt?$AAo?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAw?$AAm?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@GPLJOBFL@?$AAv?$AAt?$AAo?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAw?$AAm?$AA1?$AA?$AA@ DB 'v'
	DB	00H, 't', 00H, 'o', 00H, 'p', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, 'w', 00H, 'm', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GKOFOALE@?$AAk?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1O@GKOFOALE@?$AAk?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'k', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@EPMFMPJB@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAv?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAw?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@EPMFMPJB@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAv?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAw?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?$AA@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, '_', 00H, 'v', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, '_', 00H, 'w', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '_', 00H, 'w', 00H, ' '
	DB	00H, '>', 00H, '=', 00H, ' ', 00H, '2', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT x_divrem
_TEXT	SEGMENT
vtop$ = 32
w$ = 40
vk$ = 48
v$ = 56
a$ = 64
zhi$ = 72
i$ = 80
vv$ = 88
wm1$ = 96
q$ = 100
carry$ = 104
size_w$ = 112
ak$ = 120
size_v$ = 128
z$ = 136
w0$ = 144
k$ = 152
r$ = 160
wm2$ = 164
d$ = 168
v0$ = 176
tv69 = 184
tv75 = 192
tv208 = 200
v1$ = 224
w1$ = 232
prem$ = 240
x_divrem PROC						; COMDAT

; 2433 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 2434 :     PyLongObject *v, *w, *a;
; 2435 :     Py_ssize_t i, k, size_v, size_w;
; 2436 :     int d;
; 2437 :     digit wm1, wm2, carry, q, r, vtop, *v0, *vk, *w0, *ak;
; 2438 :     twodigits vv;
; 2439 :     sdigit zhi;
; 2440 :     stwodigits z;
; 2441 : 
; 2442 :     /* We follow Knuth [The Art of Computer Programming, Vol. 2 (3rd
; 2443 :        edn.), section 4.3.1, Algorithm D], except that we don't explicitly
; 2444 :        handle the special case when the initial estimate q for a quotient
; 2445 :        digit is >= PyLong_BASE: the max value for q is PyLong_BASE+1, and
; 2446 :        that won't overflow a digit. */
; 2447 : 
; 2448 :     /* allocate space; w will also be used to hold the final remainder */
; 2449 :     size_v = ABS(Py_SIZE(v1));

  00016	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR v1$[rsp]
  0001e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00023	7d 19		 jge	 SHORT $LN24@x_divrem
  00025	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR v1$[rsp]
  0002d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00031	48 f7 d8	 neg	 rax
  00034	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
  0003c	eb 14		 jmp	 SHORT $LN25@x_divrem
$LN24@x_divrem:
  0003e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR v1$[rsp]
  00046	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004a	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
$LN25@x_divrem:
  00052	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv69[rsp]
  0005a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR size_v$[rsp], rax

; 2450 :     size_w = ABS(Py_SIZE(w1));

  00062	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR w1$[rsp]
  0006a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0006f	7d 19		 jge	 SHORT $LN26@x_divrem
  00071	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR w1$[rsp]
  00079	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0007d	48 f7 d8	 neg	 rax
  00080	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  00088	eb 14		 jmp	 SHORT $LN27@x_divrem
$LN26@x_divrem:
  0008a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR w1$[rsp]
  00092	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00096	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
$LN27@x_divrem:
  0009e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  000a6	48 89 44 24 70	 mov	 QWORD PTR size_w$[rsp], rax

; 2451 :     assert(size_v >= size_w && size_w >= 2); /* Assert checks by div() */

  000ab	48 8b 44 24 70	 mov	 rax, QWORD PTR size_w$[rsp]
  000b0	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR size_v$[rsp], rax
  000b8	7c 08		 jl	 SHORT $LN28@x_divrem
  000ba	48 83 7c 24 70
	02		 cmp	 QWORD PTR size_w$[rsp], 2
  000c0	7d 1c		 jge	 SHORT $LN29@x_divrem
$LN28@x_divrem:
  000c2	41 b8 93 09 00
	00		 mov	 r8d, 2451		; 00000993H
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@EPMFMPJB@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAv?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAw?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA_?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA?$AA@
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000dc	33 c0		 xor	 eax, eax
$LN29@x_divrem:

; 2452 :     v = _PyLong_New(size_v+1);

  000de	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR size_v$[rsp]
  000e6	48 ff c0	 inc	 rax
  000e9	48 8b c8	 mov	 rcx, rax
  000ec	e8 00 00 00 00	 call	 _PyLong_New
  000f1	48 89 44 24 38	 mov	 QWORD PTR v$[rsp], rax

; 2453 :     if (v == NULL) {

  000f6	48 83 7c 24 38
	00		 cmp	 QWORD PTR v$[rsp], 0
  000fc	75 16		 jne	 SHORT $LN21@x_divrem

; 2454 :         *prem = NULL;

  000fe	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  00106	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2455 :         return NULL;

  0010d	33 c0		 xor	 eax, eax
  0010f	e9 d0 05 00 00	 jmp	 $LN22@x_divrem
$LN21@x_divrem:

; 2456 :     }
; 2457 :     w = _PyLong_New(size_w);

  00114	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size_w$[rsp]
  00119	e8 00 00 00 00	 call	 _PyLong_New
  0011e	48 89 44 24 28	 mov	 QWORD PTR w$[rsp], rax

; 2458 :     if (w == NULL) {

  00123	48 83 7c 24 28
	00		 cmp	 QWORD PTR w$[rsp], 0
  00129	75 20		 jne	 SHORT $LN20@x_divrem

; 2459 :         Py_DECREF(v);

  0012b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  00130	e8 00 00 00 00	 call	 _Py_DecRef

; 2460 :         *prem = NULL;

  00135	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  0013d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2461 :         return NULL;

  00144	33 c0		 xor	 eax, eax
  00146	e9 99 05 00 00	 jmp	 $LN22@x_divrem
$LN20@x_divrem:

; 2462 :     }
; 2463 : 
; 2464 :     /* normalize: shift w1 left so that its top digit is >= PyLong_BASE/2.
; 2465 :        shift v1 left by the same amount.  Results go into w and v. */
; 2466 :     d = PyLong_SHIFT - bits_in_digit(w1->ob_digit[size_w-1]);

  0014b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR w1$[rsp]
  00153	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size_w$[rsp]
  00158	8b 4c 88 6c	 mov	 ecx, DWORD PTR [rax+rcx*4+108]
  0015c	e8 00 00 00 00	 call	 bits_in_digit
  00161	b9 1e 00 00 00	 mov	 ecx, 30
  00166	2b c8		 sub	 ecx, eax
  00168	8b c1		 mov	 eax, ecx
  0016a	89 84 24 a8 00
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 2467 :     carry = v_lshift(w->ob_digit, w1->ob_digit, size_w, d);

  00171	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR w1$[rsp]
  00179	48 83 c0 70	 add	 rax, 112		; 00000070H
  0017d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR w$[rsp]
  00182	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00186	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR d$[rsp]
  0018e	4c 8b 44 24 70	 mov	 r8, QWORD PTR size_w$[rsp]
  00193	48 8b d0	 mov	 rdx, rax
  00196	e8 00 00 00 00	 call	 v_lshift
  0019b	89 44 24 68	 mov	 DWORD PTR carry$[rsp], eax

; 2468 :     assert(carry == 0);

  0019f	83 7c 24 68 00	 cmp	 DWORD PTR carry$[rsp], 0
  001a4	74 1c		 je	 SHORT $LN30@x_divrem
  001a6	41 b8 a4 09 00
	00		 mov	 r8d, 2468		; 000009a4H
  001ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@NKCMNFPP@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001c0	33 c0		 xor	 eax, eax
$LN30@x_divrem:

; 2469 :     carry = v_lshift(v->ob_digit, v1->ob_digit, size_v, d);

  001c2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR v1$[rsp]
  001ca	48 83 c0 70	 add	 rax, 112		; 00000070H
  001ce	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  001d3	48 83 c1 70	 add	 rcx, 112		; 00000070H
  001d7	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR d$[rsp]
  001df	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR size_v$[rsp]
  001e7	48 8b d0	 mov	 rdx, rax
  001ea	e8 00 00 00 00	 call	 v_lshift
  001ef	89 44 24 68	 mov	 DWORD PTR carry$[rsp], eax

; 2470 :     if (carry != 0 || v->ob_digit[size_v-1] >= w->ob_digit[size_w-1]) {

  001f3	83 7c 24 68 00	 cmp	 DWORD PTR carry$[rsp], 0
  001f8	75 22		 jne	 SHORT $LN18@x_divrem
  001fa	48 8b 44 24 38	 mov	 rax, QWORD PTR v$[rsp]
  001ff	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR size_v$[rsp]
  00207	48 8b 54 24 28	 mov	 rdx, QWORD PTR w$[rsp]
  0020c	4c 8b 44 24 70	 mov	 r8, QWORD PTR size_w$[rsp]
  00211	42 8b 54 82 6c	 mov	 edx, DWORD PTR [rdx+r8*4+108]
  00216	39 54 88 6c	 cmp	 DWORD PTR [rax+rcx*4+108], edx
  0021a	72 28		 jb	 SHORT $LN19@x_divrem
$LN18@x_divrem:

; 2471 :         v->ob_digit[size_v] = carry;

  0021c	48 8b 44 24 38	 mov	 rax, QWORD PTR v$[rsp]
  00221	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR size_v$[rsp]
  00229	8b 54 24 68	 mov	 edx, DWORD PTR carry$[rsp]
  0022d	89 54 88 70	 mov	 DWORD PTR [rax+rcx*4+112], edx

; 2472 :         size_v++;

  00231	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR size_v$[rsp]
  00239	48 ff c0	 inc	 rax
  0023c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR size_v$[rsp], rax
$LN19@x_divrem:

; 2473 :     }
; 2474 : 
; 2475 :     /* Now v->ob_digit[size_v-1] < w->ob_digit[size_w-1], so quotient has
; 2476 :        at most (and usually exactly) k = size_v - size_w digits. */
; 2477 :     k = size_v - size_w;

  00244	48 8b 44 24 70	 mov	 rax, QWORD PTR size_w$[rsp]
  00249	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR size_v$[rsp]
  00251	48 2b c8	 sub	 rcx, rax
  00254	48 8b c1	 mov	 rax, rcx
  00257	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR k$[rsp], rax

; 2478 :     assert(k >= 0);

  0025f	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR k$[rsp], 0
  00268	7d 1c		 jge	 SHORT $LN31@x_divrem
  0026a	41 b8 ae 09 00
	00		 mov	 r8d, 2478		; 000009aeH
  00270	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00277	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@GKOFOALE@?$AAk?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0027e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00284	33 c0		 xor	 eax, eax
$LN31@x_divrem:

; 2479 :     a = _PyLong_New(k);

  00286	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  0028e	e8 00 00 00 00	 call	 _PyLong_New
  00293	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 2480 :     if (a == NULL) {

  00298	48 83 7c 24 40
	00		 cmp	 QWORD PTR a$[rsp], 0
  0029e	75 2a		 jne	 SHORT $LN17@x_divrem

; 2481 :         Py_DECREF(w);

  002a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR w$[rsp]
  002a5	e8 00 00 00 00	 call	 _Py_DecRef

; 2482 :         Py_DECREF(v);

  002aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  002af	e8 00 00 00 00	 call	 _Py_DecRef

; 2483 :         *prem = NULL;

  002b4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  002bc	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2484 :         return NULL;

  002c3	33 c0		 xor	 eax, eax
  002c5	e9 1a 04 00 00	 jmp	 $LN22@x_divrem
$LN17@x_divrem:

; 2485 :     }
; 2486 :     v0 = v->ob_digit;

  002ca	48 8b 44 24 38	 mov	 rax, QWORD PTR v$[rsp]
  002cf	48 83 c0 70	 add	 rax, 112		; 00000070H
  002d3	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR v0$[rsp], rax

; 2487 :     w0 = w->ob_digit;

  002db	48 8b 44 24 28	 mov	 rax, QWORD PTR w$[rsp]
  002e0	48 83 c0 70	 add	 rax, 112		; 00000070H
  002e4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR w0$[rsp], rax

; 2488 :     wm1 = w0[size_w-1];

  002ec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR w0$[rsp]
  002f4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size_w$[rsp]
  002f9	8b 44 88 fc	 mov	 eax, DWORD PTR [rax+rcx*4-4]
  002fd	89 44 24 60	 mov	 DWORD PTR wm1$[rsp], eax

; 2489 :     wm2 = w0[size_w-2];

  00301	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR w0$[rsp]
  00309	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size_w$[rsp]
  0030e	8b 44 88 f8	 mov	 eax, DWORD PTR [rax+rcx*4-8]
  00312	89 84 24 a4 00
	00 00		 mov	 DWORD PTR wm2$[rsp], eax

; 2490 :     for (vk = v0+k, ak = a->ob_digit + k; vk-- > v0;) {

  00319	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR v0$[rsp]
  00321	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  00329	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0032d	48 89 44 24 30	 mov	 QWORD PTR vk$[rsp], rax
  00332	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00337	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR k$[rsp]
  0033f	48 8d 44 88 70	 lea	 rax, QWORD PTR [rax+rcx*4+112]
  00344	48 89 44 24 78	 mov	 QWORD PTR ak$[rsp], rax
$LN16@x_divrem:
  00349	48 8b 44 24 30	 mov	 rax, QWORD PTR vk$[rsp]
  0034e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR v0$[rsp]
  00356	48 8b 54 24 30	 mov	 rdx, QWORD PTR vk$[rsp]
  0035b	48 83 ea 04	 sub	 rdx, 4
  0035f	48 89 54 24 30	 mov	 QWORD PTR vk$[rsp], rdx
  00364	48 3b c1	 cmp	 rax, rcx
  00367	0f 86 05 03 00
	00		 jbe	 $LN15@x_divrem
$LN14@x_divrem:

; 2491 :         /* inner loop: divide vk[0:size_w+1] by w0[0:size_w], giving
; 2492 :            single-digit quotient q, remainder in vk[0:size_w]. */
; 2493 : 
; 2494 :         SIGCHECK({
; 2495 :                 Py_DECREF(a);
; 2496 :                 Py_DECREF(w);
; 2497 :                 Py_DECREF(v);
; 2498 :                 *prem = NULL;
; 2499 :                 return NULL;
; 2500 :             });

  0036d	e8 00 00 00 00	 call	 PyErr_CheckSignals
  00372	85 c0		 test	 eax, eax
  00374	74 34		 je	 SHORT $LN11@x_divrem
  00376	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0037b	e8 00 00 00 00	 call	 _Py_DecRef
  00380	48 8b 4c 24 28	 mov	 rcx, QWORD PTR w$[rsp]
  00385	e8 00 00 00 00	 call	 _Py_DecRef
  0038a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  0038f	e8 00 00 00 00	 call	 _Py_DecRef
  00394	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR prem$[rsp]
  0039c	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  003a3	33 c0		 xor	 eax, eax
  003a5	e9 3a 03 00 00	 jmp	 $LN22@x_divrem
$LN11@x_divrem:
  003aa	33 c0		 xor	 eax, eax
  003ac	85 c0		 test	 eax, eax
  003ae	75 bd		 jne	 SHORT $LN14@x_divrem

; 2501 : 
; 2502 :         /* estimate quotient digit q; may overestimate by 1 (rare) */
; 2503 :         vtop = vk[size_w];

  003b0	48 8b 44 24 30	 mov	 rax, QWORD PTR vk$[rsp]
  003b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size_w$[rsp]
  003ba	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  003bd	89 44 24 20	 mov	 DWORD PTR vtop$[rsp], eax

; 2504 :         assert(vtop <= wm1);

  003c1	8b 44 24 60	 mov	 eax, DWORD PTR wm1$[rsp]
  003c5	39 44 24 20	 cmp	 DWORD PTR vtop$[rsp], eax
  003c9	76 1c		 jbe	 SHORT $LN32@x_divrem
  003cb	41 b8 c8 09 00
	00		 mov	 r8d, 2504		; 000009c8H
  003d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@GPLJOBFL@?$AAv?$AAt?$AAo?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAw?$AAm?$AA1?$AA?$AA@
  003df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003e5	33 c0		 xor	 eax, eax
$LN32@x_divrem:

; 2505 :         vv = ((twodigits)vtop << PyLong_SHIFT) | vk[size_w-1];

  003e7	8b 44 24 20	 mov	 eax, DWORD PTR vtop$[rsp]
  003eb	48 c1 e0 1e	 shl	 rax, 30
  003ef	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vk$[rsp]
  003f4	48 8b 54 24 70	 mov	 rdx, QWORD PTR size_w$[rsp]
  003f9	8b 4c 91 fc	 mov	 ecx, DWORD PTR [rcx+rdx*4-4]
  003fd	48 0b c1	 or	 rax, rcx
  00400	48 89 44 24 58	 mov	 QWORD PTR vv$[rsp], rax

; 2506 :         q = (digit)(vv / wm1);

  00405	8b 44 24 60	 mov	 eax, DWORD PTR wm1$[rsp]
  00409	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv208[rsp], rax
  00411	33 d2		 xor	 edx, edx
  00413	48 8b 44 24 58	 mov	 rax, QWORD PTR vv$[rsp]
  00418	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv208[rsp]
  00420	48 f7 f1	 div	 rcx
  00423	89 44 24 64	 mov	 DWORD PTR q$[rsp], eax

; 2507 :         r = (digit)(vv - (twodigits)wm1 * q); /* r = vv % wm1 */

  00427	8b 44 24 60	 mov	 eax, DWORD PTR wm1$[rsp]
  0042b	8b 4c 24 64	 mov	 ecx, DWORD PTR q$[rsp]
  0042f	48 0f af c1	 imul	 rax, rcx
  00433	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vv$[rsp]
  00438	48 2b c8	 sub	 rcx, rax
  0043b	48 8b c1	 mov	 rax, rcx
  0043e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR r$[rsp], eax
$LN10@x_divrem:

; 2508 :         while ((twodigits)wm2 * q > (((twodigits)r << PyLong_SHIFT)
; 2509 :                                      | vk[size_w-2])) {

  00445	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR wm2$[rsp]
  0044c	8b 4c 24 64	 mov	 ecx, DWORD PTR q$[rsp]
  00450	48 0f af c1	 imul	 rax, rcx
  00454	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR r$[rsp]
  0045b	48 c1 e1 1e	 shl	 rcx, 30
  0045f	48 8b 54 24 30	 mov	 rdx, QWORD PTR vk$[rsp]
  00464	4c 8b 44 24 70	 mov	 r8, QWORD PTR size_w$[rsp]
  00469	42 8b 54 82 f8	 mov	 edx, DWORD PTR [rdx+r8*4-8]
  0046e	48 0b ca	 or	 rcx, rdx
  00471	48 3b c1	 cmp	 rax, rcx
  00474	76 31		 jbe	 SHORT $LN9@x_divrem

; 2510 :             --q;

  00476	8b 44 24 64	 mov	 eax, DWORD PTR q$[rsp]
  0047a	ff c8		 dec	 eax
  0047c	89 44 24 64	 mov	 DWORD PTR q$[rsp], eax

; 2511 :             r += wm1;

  00480	8b 44 24 60	 mov	 eax, DWORD PTR wm1$[rsp]
  00484	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR r$[rsp]
  0048b	03 c8		 add	 ecx, eax
  0048d	8b c1		 mov	 eax, ecx
  0048f	89 84 24 a0 00
	00 00		 mov	 DWORD PTR r$[rsp], eax

; 2512 :             if (r >= PyLong_BASE)

  00496	81 bc 24 a0 00
	00 00 00 00 00
	40		 cmp	 DWORD PTR r$[rsp], 1073741824 ; 40000000H
  004a1	72 02		 jb	 SHORT $LN8@x_divrem

; 2513 :                 break;

  004a3	eb 02		 jmp	 SHORT $LN9@x_divrem
$LN8@x_divrem:

; 2514 :         }

  004a5	eb 9e		 jmp	 SHORT $LN10@x_divrem
$LN9@x_divrem:

; 2515 :         assert(q <= PyLong_BASE);

  004a7	81 7c 24 64 00
	00 00 40	 cmp	 DWORD PTR q$[rsp], 1073741824 ; 40000000H
  004af	76 1c		 jbe	 SHORT $LN33@x_divrem
  004b1	41 b8 d3 09 00
	00		 mov	 r8d, 2515		; 000009d3H
  004b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  004be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@KEJBDHPH@?$AAq?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@
  004c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004cb	33 c0		 xor	 eax, eax
$LN33@x_divrem:

; 2516 : 
; 2517 :         /* subtract q*w0[0:size_w] from vk[0:size_w+1] */
; 2518 :         zhi = 0;

  004cd	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR zhi$[rsp], 0

; 2519 :         for (i = 0; i < size_w; ++i) {

  004d5	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  004de	eb 0d		 jmp	 SHORT $LN7@x_divrem
$LN6@x_divrem:
  004e0	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  004e5	48 ff c0	 inc	 rax
  004e8	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax
$LN7@x_divrem:
  004ed	48 8b 44 24 70	 mov	 rax, QWORD PTR size_w$[rsp]
  004f2	48 39 44 24 50	 cmp	 QWORD PTR i$[rsp], rax
  004f7	7d 62		 jge	 SHORT $LN5@x_divrem

; 2520 :             /* invariants: -PyLong_BASE <= -q <= zhi <= 0;
; 2521 :                -PyLong_BASE * q <= z < PyLong_BASE */
; 2522 :             z = (sdigit)vk[i] + zhi -
; 2523 :                 (stwodigits)q * (stwodigits)w0[i];

  004f9	48 8b 44 24 30	 mov	 rax, QWORD PTR vk$[rsp]
  004fe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$[rsp]
  00503	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00506	03 44 24 48	 add	 eax, DWORD PTR zhi$[rsp]
  0050a	48 98		 cdqe
  0050c	8b 4c 24 64	 mov	 ecx, DWORD PTR q$[rsp]
  00510	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR w0$[rsp]
  00518	4c 8b 44 24 50	 mov	 r8, QWORD PTR i$[rsp]
  0051d	42 8b 14 82	 mov	 edx, DWORD PTR [rdx+r8*4]
  00521	48 0f af ca	 imul	 rcx, rdx
  00525	48 2b c1	 sub	 rax, rcx
  00528	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR z$[rsp], rax

; 2524 :             vk[i] = (digit)z & PyLong_MASK;

  00530	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR z$[rsp]
  00537	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0053c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vk$[rsp]
  00541	48 8b 54 24 50	 mov	 rdx, QWORD PTR i$[rsp]
  00546	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 2525 :             zhi = (sdigit)Py_ARITHMETIC_RIGHT_SHIFT(stwodigits,
; 2526 :                                                     z, PyLong_SHIFT);

  00549	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00551	48 c1 f8 1e	 sar	 rax, 30
  00555	89 44 24 48	 mov	 DWORD PTR zhi$[rsp], eax

; 2527 :         }

  00559	eb 85		 jmp	 SHORT $LN6@x_divrem
$LN5@x_divrem:

; 2528 : 
; 2529 :         /* add w back if q was too large (this branch taken rarely) */
; 2530 :         assert((sdigit)vtop + zhi == -1 || (sdigit)vtop + zhi == 0);

  0055b	8b 44 24 48	 mov	 eax, DWORD PTR zhi$[rsp]
  0055f	8b 4c 24 20	 mov	 ecx, DWORD PTR vtop$[rsp]
  00563	03 c8		 add	 ecx, eax
  00565	8b c1		 mov	 eax, ecx
  00567	83 f8 ff	 cmp	 eax, -1
  0056a	74 2c		 je	 SHORT $LN34@x_divrem
  0056c	8b 44 24 48	 mov	 eax, DWORD PTR zhi$[rsp]
  00570	8b 4c 24 20	 mov	 ecx, DWORD PTR vtop$[rsp]
  00574	03 c8		 add	 ecx, eax
  00576	8b c1		 mov	 eax, ecx
  00578	85 c0		 test	 eax, eax
  0057a	74 1c		 je	 SHORT $LN34@x_divrem
  0057c	41 b8 e2 09 00
	00		 mov	 r8d, 2530		; 000009e2H
  00582	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00589	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GI@JDPLFPFJ@?$AA?$CI?$AAs?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$CJ?$AAv?$AAt?$AAo?$AAp?$AA?5?$AA?$CL?$AA?5?$AAz?$AAh?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAs?$AAd?$AAi@
  00590	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00596	33 c0		 xor	 eax, eax
$LN34@x_divrem:

; 2531 :         if ((sdigit)vtop + zhi < 0) {

  00598	8b 44 24 48	 mov	 eax, DWORD PTR zhi$[rsp]
  0059c	8b 4c 24 20	 mov	 ecx, DWORD PTR vtop$[rsp]
  005a0	03 c8		 add	 ecx, eax
  005a2	8b c1		 mov	 eax, ecx
  005a4	85 c0		 test	 eax, eax
  005a6	0f 8d 82 00 00
	00		 jge	 $LN4@x_divrem

; 2532 :             carry = 0;

  005ac	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0

; 2533 :             for (i = 0; i < size_w; ++i) {

  005b4	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  005bd	eb 0d		 jmp	 SHORT $LN3@x_divrem
$LN2@x_divrem:
  005bf	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  005c4	48 ff c0	 inc	 rax
  005c7	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax
$LN3@x_divrem:
  005cc	48 8b 44 24 70	 mov	 rax, QWORD PTR size_w$[rsp]
  005d1	48 39 44 24 50	 cmp	 QWORD PTR i$[rsp], rax
  005d6	7d 4c		 jge	 SHORT $LN1@x_divrem

; 2534 :                 carry += vk[i] + w0[i];

  005d8	48 8b 44 24 30	 mov	 rax, QWORD PTR vk$[rsp]
  005dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$[rsp]
  005e2	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  005e5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR w0$[rsp]
  005ed	48 8b 54 24 50	 mov	 rdx, QWORD PTR i$[rsp]
  005f2	03 04 91	 add	 eax, DWORD PTR [rcx+rdx*4]
  005f5	8b 4c 24 68	 mov	 ecx, DWORD PTR carry$[rsp]
  005f9	03 c8		 add	 ecx, eax
  005fb	8b c1		 mov	 eax, ecx
  005fd	89 44 24 68	 mov	 DWORD PTR carry$[rsp], eax

; 2535 :                 vk[i] = carry & PyLong_MASK;

  00601	8b 44 24 68	 mov	 eax, DWORD PTR carry$[rsp]
  00605	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0060a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vk$[rsp]
  0060f	48 8b 54 24 50	 mov	 rdx, QWORD PTR i$[rsp]
  00614	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 2536 :                 carry >>= PyLong_SHIFT;

  00617	8b 44 24 68	 mov	 eax, DWORD PTR carry$[rsp]
  0061b	c1 e8 1e	 shr	 eax, 30
  0061e	89 44 24 68	 mov	 DWORD PTR carry$[rsp], eax

; 2537 :             }

  00622	eb 9b		 jmp	 SHORT $LN2@x_divrem
$LN1@x_divrem:

; 2538 :             --q;

  00624	8b 44 24 64	 mov	 eax, DWORD PTR q$[rsp]
  00628	ff c8		 dec	 eax
  0062a	89 44 24 64	 mov	 DWORD PTR q$[rsp], eax
$LN4@x_divrem:

; 2539 :         }
; 2540 : 
; 2541 :         /* store quotient digit */
; 2542 :         assert(q < PyLong_BASE);

  0062e	81 7c 24 64 00
	00 00 40	 cmp	 DWORD PTR q$[rsp], 1073741824 ; 40000000H
  00636	72 1c		 jb	 SHORT $LN35@x_divrem
  00638	41 b8 ee 09 00
	00		 mov	 r8d, 2542		; 000009eeH
  0063e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00645	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@BCAJAPG@?$AAq?$AA?5?$AA?$DM?$AA?5?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAB?$AAA?$AAS?$AAE?$AA?$AA@
  0064c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00652	33 c0		 xor	 eax, eax
$LN35@x_divrem:

; 2543 :         *--ak = q;

  00654	48 8b 44 24 78	 mov	 rax, QWORD PTR ak$[rsp]
  00659	48 83 e8 04	 sub	 rax, 4
  0065d	48 89 44 24 78	 mov	 QWORD PTR ak$[rsp], rax
  00662	48 8b 44 24 78	 mov	 rax, QWORD PTR ak$[rsp]
  00667	8b 4c 24 64	 mov	 ecx, DWORD PTR q$[rsp]
  0066b	89 08		 mov	 DWORD PTR [rax], ecx

; 2544 :     }

  0066d	e9 d7 fc ff ff	 jmp	 $LN16@x_divrem
$LN15@x_divrem:

; 2545 : 
; 2546 :     /* unshift remainder; we reuse w to store the result */
; 2547 :     carry = v_rshift(w0, v0, size_w, d);

  00672	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR d$[rsp]
  0067a	4c 8b 44 24 70	 mov	 r8, QWORD PTR size_w$[rsp]
  0067f	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR v0$[rsp]
  00687	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR w0$[rsp]
  0068f	e8 00 00 00 00	 call	 v_rshift
  00694	89 44 24 68	 mov	 DWORD PTR carry$[rsp], eax

; 2548 :     assert(carry==0);

  00698	83 7c 24 68 00	 cmp	 DWORD PTR carry$[rsp], 0
  0069d	74 1c		 je	 SHORT $LN36@x_divrem
  0069f	41 b8 f4 09 00
	00		 mov	 r8d, 2548		; 000009f4H
  006a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  006ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@JNKLFFDJ@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@
  006b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006b9	33 c0		 xor	 eax, eax
$LN36@x_divrem:

; 2549 :     Py_DECREF(v);

  006bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  006c0	e8 00 00 00 00	 call	 _Py_DecRef

; 2550 : 
; 2551 :     *prem = long_normalize(w);

  006c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR w$[rsp]
  006ca	e8 00 00 00 00	 call	 long_normalize
  006cf	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR prem$[rsp]
  006d7	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2552 :     return long_normalize(a);

  006da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  006df	e8 00 00 00 00	 call	 long_normalize
$LN22@x_divrem:

; 2553 : }

  006e4	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  006eb	c3		 ret	 0
x_divrem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@FMAPPLED@integer?5division?5result?5too?5larg@ ; `string'
PUBLIC	__real@8000000000000000
PUBLIC	??_C@_1EG@JEACKEOJ@?$AAe?$AAx?$AAt?$AAr?$AAa?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAe?$AAx?$AAt?$AAr?$AAa?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_1BG@MLPCOPPF@?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@LNLGEPMD@?$AAa?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAh?$AAi?$AAf?$AAt?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CG@JGBBDDEJ@intermediate?5overflow?5during?5div@ ; `string'
PUBLIC	??_C@_0BB@OMEBCKB@division?5by?5zero?$AA@	; `string'
EXTRN	PyFloat_FromDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_true_divide DD imagerel long_true_divide
	DD	imagerel long_true_divide+2826
	DD	imagerel $unwind$long_true_divide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_true_divide DD 021101H
	DD	02f0111H
xdata	ENDS
;	COMDAT ??_C@_0CO@FMAPPLED@integer?5division?5result?5too?5larg@
CONST	SEGMENT
??_C@_0CO@FMAPPLED@integer?5division?5result?5too?5larg@ DB 'integer divi'
	DB	'sion result too large for a float', 00H	; `string'
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT ??_C@_1EG@JEACKEOJ@?$AAe?$AAx?$AAt?$AAr?$AAa?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAe?$AAx?$AAt?$AAr?$AAa?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1EG@JEACKEOJ@?$AAe?$AAx?$AAt?$AAr?$AAa?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAe?$AAx?$AAt?$AAr?$AAa?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN@ DB 'e'
	DB	00H, 'x', 00H, 't', 00H, 'r', 00H, 'a', 00H, '_', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '2', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, 'r', 00H, 'a', 00H, '_', 00H, 'b', 00H, 'i'
	DB	00H, 't', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'3', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@MLPCOPPF@?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@MLPCOPPF@?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'x'
	DB	00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@LNLGEPMD@?$AAa?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAh?$AAi?$AAf?$AAt?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@LNLGEPMD@?$AAa?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAh?$AAi?$AAf?$AAt?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@ DB 'a'
	DB	00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, 's', 00H, 'h', 00H, 'i', 00H, 'f'
	DB	00H, 't', 00H, '_', 00H, 'd', 00H, 'i', 00H, 'g', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JGBBDDEJ@intermediate?5overflow?5during?5div@
CONST	SEGMENT
??_C@_0CG@JGBBDDEJ@intermediate?5overflow?5during?5div@ DB 'intermediate '
	DB	'overflow during division', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OMEBCKB@division?5by?5zero?$AA@
CONST	SEGMENT
??_C@_0BB@OMEBCKB@division?5by?5zero?$AA@ DB 'division by zero', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_true_divide
_TEXT	SEGMENT
b_is_small$ = 32
b_size$ = 40
inexact$ = 48
x_bits$ = 56
x_size$ = 64
x$ = 72
a$ = 80
a_is_small$ = 88
mask$ = 92
a_size$ = 96
b$ = 104
negate$ = 112
result$ = 120
low$ = 128
extra_bits$ = 136
dx$ = 144
diff$ = 152
shift$ = 160
db$23431 = 168
da$23430 = 176
i$23453 = 184
rem$23455 = 192
shift_digits$23454 = 200
rem$23467 = 208
shift_digits$23466 = 216
rem$23479 = 224
rem$23483 = 232
div$23482 = 240
tv79 = 248
tv85 = 256
tv91 = 264
tv90 = 268
tv135 = 272
tv142 = 276
tv175 = 280
tv183 = 288
tv195 = 296
tv225 = 304
tv251 = 312
tv289 = 320
tv296 = 328
tv308 = 336
tv572 = 344
tv361 = 352
tv365 = 360
v$ = 384
w$ = 392
long_true_divide PROC					; COMDAT

; 3499 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
$LN40@long_true_:

; 3500 :     PyLongObject *a, *b, *x;
; 3501 :     Py_ssize_t a_size, b_size, shift, extra_bits, diff, x_size, x_bits;
; 3502 :     digit mask, low;
; 3503 :     int inexact, negate, a_is_small, b_is_small;
; 3504 :     double dx, result;
; 3505 : 
; 3506 :     CHECK_BINOP(v, w);

  00011	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00019	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00023	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00028	85 c0		 test	 eax, eax
  0002a	74 1b		 je	 SHORT $LN36@long_true_
  0002c	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00043	85 c0		 test	 eax, eax
  00045	75 18		 jne	 SHORT $LN37@long_true_
$LN36@long_true_:
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0004e	e8 00 00 00 00	 call	 _Py_IncRef
  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0005a	e9 a3 0a 00 00	 jmp	 $LN41@long_true_
$LN37@long_true_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 ac		 jne	 SHORT $LN40@long_true_

; 3507 :     a = (PyLongObject *)v;

  00065	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0006d	48 89 44 24 50	 mov	 QWORD PTR a$[rsp], rax

; 3508 :     b = (PyLongObject *)w;

  00072	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR w$[rsp]
  0007a	48 89 44 24 68	 mov	 QWORD PTR b$[rsp], rax

; 3509 : 
; 3510 :     /*
; 3511 :        Method in a nutshell:
; 3512 : 
; 3513 :          0. reduce to case a, b > 0; filter out obvious underflow/overflow
; 3514 :          1. choose a suitable integer 'shift'
; 3515 :          2. use integer arithmetic to compute x = floor(2**-shift*a/b)
; 3516 :          3. adjust x for correct rounding
; 3517 :          4. convert x to a double dx with the same value
; 3518 :          5. return ldexp(dx, shift).
; 3519 : 
; 3520 :        In more detail:
; 3521 : 
; 3522 :        0. For any a, a/0 raises ZeroDivisionError; for nonzero b, 0/b
; 3523 :        returns either 0.0 or -0.0, depending on the sign of b.  For a and
; 3524 :        b both nonzero, ignore signs of a and b, and add the sign back in
; 3525 :        at the end.  Now write a_bits and b_bits for the bit lengths of a
; 3526 :        and b respectively (that is, a_bits = 1 + floor(log_2(a)); likewise
; 3527 :        for b).  Then
; 3528 : 
; 3529 :           2**(a_bits - b_bits - 1) < a/b < 2**(a_bits - b_bits + 1).
; 3530 : 
; 3531 :        So if a_bits - b_bits > DBL_MAX_EXP then a/b > 2**DBL_MAX_EXP and
; 3532 :        so overflows.  Similarly, if a_bits - b_bits < DBL_MIN_EXP -
; 3533 :        DBL_MANT_DIG - 1 then a/b underflows to 0.  With these cases out of
; 3534 :        the way, we can assume that
; 3535 : 
; 3536 :           DBL_MIN_EXP - DBL_MANT_DIG - 1 <= a_bits - b_bits <= DBL_MAX_EXP.
; 3537 : 
; 3538 :        1. The integer 'shift' is chosen so that x has the right number of
; 3539 :        bits for a double, plus two or three extra bits that will be used
; 3540 :        in the rounding decisions.  Writing a_bits and b_bits for the
; 3541 :        number of significant bits in a and b respectively, a
; 3542 :        straightforward formula for shift is:
; 3543 : 
; 3544 :           shift = a_bits - b_bits - DBL_MANT_DIG - 2
; 3545 : 
; 3546 :        This is fine in the usual case, but if a/b is smaller than the
; 3547 :        smallest normal float then it can lead to double rounding on an
; 3548 :        IEEE 754 platform, giving incorrectly rounded results.  So we
; 3549 :        adjust the formula slightly.  The actual formula used is:
; 3550 : 
; 3551 :            shift = MAX(a_bits - b_bits, DBL_MIN_EXP) - DBL_MANT_DIG - 2
; 3552 : 
; 3553 :        2. The quantity x is computed by first shifting a (left -shift bits
; 3554 :        if shift <= 0, right shift bits if shift > 0) and then dividing by
; 3555 :        b.  For both the shift and the division, we keep track of whether
; 3556 :        the result is inexact, in a flag 'inexact'; this information is
; 3557 :        needed at the rounding stage.
; 3558 : 
; 3559 :        With the choice of shift above, together with our assumption that
; 3560 :        a_bits - b_bits >= DBL_MIN_EXP - DBL_MANT_DIG - 1, it follows
; 3561 :        that x >= 1.
; 3562 : 
; 3563 :        3. Now x * 2**shift <= a/b < (x+1) * 2**shift.  We want to replace
; 3564 :        this with an exactly representable float of the form
; 3565 : 
; 3566 :           round(x/2**extra_bits) * 2**(extra_bits+shift).
; 3567 : 
; 3568 :        For float representability, we need x/2**extra_bits <
; 3569 :        2**DBL_MANT_DIG and extra_bits + shift >= DBL_MIN_EXP -
; 3570 :        DBL_MANT_DIG.  This translates to the condition:
; 3571 : 
; 3572 :           extra_bits >= MAX(x_bits, DBL_MIN_EXP - shift) - DBL_MANT_DIG
; 3573 : 
; 3574 :        To round, we just modify the bottom digit of x in-place; this can
; 3575 :        end up giving a digit with value > PyLONG_MASK, but that's not a
; 3576 :        problem since digits can hold values up to 2*PyLONG_MASK+1.
; 3577 : 
; 3578 :        With the original choices for shift above, extra_bits will always
; 3579 :        be 2 or 3.  Then rounding under the round-half-to-even rule, we
; 3580 :        round up iff the most significant of the extra bits is 1, and
; 3581 :        either: (a) the computation of x in step 2 had an inexact result,
; 3582 :        or (b) at least one other of the extra bits is 1, or (c) the least
; 3583 :        significant bit of x (above those to be rounded) is 1.
; 3584 : 
; 3585 :        4. Conversion to a double is straightforward; all floating-point
; 3586 :        operations involved in the conversion are exact, so there's no
; 3587 :        danger of rounding errors.
; 3588 : 
; 3589 :        5. Use ldexp(x, shift) to compute x*2**shift, the final result.
; 3590 :        The result will always be exactly representable as a double, except
; 3591 :        in the case that it overflows.  To avoid dependence on the exact
; 3592 :        behaviour of ldexp on overflow, we check for overflow before
; 3593 :        applying ldexp.  The result of ldexp is adjusted for sign before
; 3594 :        returning.
; 3595 :     */
; 3596 : 
; 3597 :     /* Reduce to case where a and b are both positive. */
; 3598 :     a_size = ABS(Py_SIZE(a));

  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00084	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00089	7d 16		 jge	 SHORT $LN43@long_true_
  0008b	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00090	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00094	48 f7 d8	 neg	 rax
  00097	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  0009f	eb 11		 jmp	 SHORT $LN44@long_true_
$LN43@long_true_:
  000a1	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000a6	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000aa	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
$LN44@long_true_:
  000b2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv79[rsp]
  000ba	48 89 44 24 60	 mov	 QWORD PTR a_size$[rsp], rax

; 3599 :     b_size = ABS(Py_SIZE(b));

  000bf	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  000c4	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000c9	7d 16		 jge	 SHORT $LN45@long_true_
  000cb	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  000d0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d4	48 f7 d8	 neg	 rax
  000d7	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv85[rsp], rax
  000df	eb 11		 jmp	 SHORT $LN46@long_true_
$LN45@long_true_:
  000e1	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  000e6	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ea	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv85[rsp], rax
$LN46@long_true_:
  000f2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv85[rsp]
  000fa	48 89 44 24 28	 mov	 QWORD PTR b_size$[rsp], rax

; 3600 :     negate = (Py_SIZE(a) < 0) ^ (Py_SIZE(b) < 0);

  000ff	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00104	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00109	7d 0d		 jge	 SHORT $LN49@long_true_
  0010b	c7 84 24 08 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv91[rsp], 1
  00116	eb 0b		 jmp	 SHORT $LN50@long_true_
$LN49@long_true_:
  00118	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv91[rsp], 0
$LN50@long_true_:
  00123	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  00128	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0012d	7d 0d		 jge	 SHORT $LN47@long_true_
  0012f	c7 84 24 0c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv90[rsp], 1
  0013a	eb 0b		 jmp	 SHORT $LN48@long_true_
$LN47@long_true_:
  0013c	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv90[rsp], 0
$LN48@long_true_:
  00147	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR tv90[rsp]
  0014e	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv91[rsp]
  00155	33 c8		 xor	 ecx, eax
  00157	8b c1		 mov	 eax, ecx
  00159	89 44 24 70	 mov	 DWORD PTR negate$[rsp], eax

; 3601 :     if (b_size == 0) {

  0015d	48 83 7c 24 28
	00		 cmp	 QWORD PTR b_size$[rsp], 0
  00163	75 18		 jne	 SHORT $LN35@long_true_

; 3602 :         PyErr_SetString(PyExc_ZeroDivisionError,
; 3603 :                         "division by zero");

  00165	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@OMEBCKB@division?5by?5zero?$AA@
  0016c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  00173	e8 00 00 00 00	 call	 PyErr_SetString

; 3604 :         goto error;

  00178	e9 83 09 00 00	 jmp	 $error$23426
$LN35@long_true_:

; 3605 :     }
; 3606 :     if (a_size == 0)

  0017d	48 83 7c 24 60
	00		 cmp	 QWORD PTR a_size$[rsp], 0
  00183	75 05		 jne	 SHORT $LN34@long_true_

; 3607 :         goto underflow_or_zero;

  00185	e9 2c 09 00 00	 jmp	 $underflow_or_zero$23428
$LN34@long_true_:

; 3608 : 
; 3609 :     /* Fast path for a and b small (exactly representable in a double).
; 3610 :        Relies on floating-point division being correctly rounded; results
; 3611 :        may be subject to double rounding on x86 machines that operate with
; 3612 :        the x87 FPU set to 64-bit precision. */
; 3613 :     a_is_small = a_size <= MANT_DIG_DIGITS ||
; 3614 :         (a_size == MANT_DIG_DIGITS+1 &&
; 3615 :          a->ob_digit[MANT_DIG_DIGITS] >> MANT_DIG_BITS == 0);

  0018a	48 83 7c 24 60
	01		 cmp	 QWORD PTR a_size$[rsp], 1
  00190	7e 24		 jle	 SHORT $LN52@long_true_
  00192	48 83 7c 24 60
	02		 cmp	 QWORD PTR a_size$[rsp], 2
  00198	75 0f		 jne	 SHORT $LN51@long_true_
  0019a	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0019f	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  001a2	c1 e8 17	 shr	 eax, 23
  001a5	85 c0		 test	 eax, eax
  001a7	74 0d		 je	 SHORT $LN52@long_true_
$LN51@long_true_:
  001a9	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv135[rsp], 0
  001b4	eb 0b		 jmp	 SHORT $LN53@long_true_
$LN52@long_true_:
  001b6	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv135[rsp], 1
$LN53@long_true_:
  001c1	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR tv135[rsp]
  001c8	89 44 24 58	 mov	 DWORD PTR a_is_small$[rsp], eax

; 3616 :     b_is_small = b_size <= MANT_DIG_DIGITS ||
; 3617 :         (b_size == MANT_DIG_DIGITS+1 &&
; 3618 :          b->ob_digit[MANT_DIG_DIGITS] >> MANT_DIG_BITS == 0);

  001cc	48 83 7c 24 28
	01		 cmp	 QWORD PTR b_size$[rsp], 1
  001d2	7e 24		 jle	 SHORT $LN55@long_true_
  001d4	48 83 7c 24 28
	02		 cmp	 QWORD PTR b_size$[rsp], 2
  001da	75 0f		 jne	 SHORT $LN54@long_true_
  001dc	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  001e1	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  001e4	c1 e8 17	 shr	 eax, 23
  001e7	85 c0		 test	 eax, eax
  001e9	74 0d		 je	 SHORT $LN55@long_true_
$LN54@long_true_:
  001eb	c7 84 24 14 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv142[rsp], 0
  001f6	eb 0b		 jmp	 SHORT $LN56@long_true_
$LN55@long_true_:
  001f8	c7 84 24 14 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv142[rsp], 1
$LN56@long_true_:
  00203	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR tv142[rsp]
  0020a	89 44 24 20	 mov	 DWORD PTR b_is_small$[rsp], eax

; 3619 :     if (a_is_small && b_is_small) {

  0020e	83 7c 24 58 00	 cmp	 DWORD PTR a_is_small$[rsp], 0
  00213	0f 84 22 01 00
	00		 je	 $LN33@long_true_
  00219	83 7c 24 20 00	 cmp	 DWORD PTR b_is_small$[rsp], 0
  0021e	0f 84 17 01 00
	00		 je	 $LN33@long_true_

; 3620 :         double da, db;
; 3621 :         da = a->ob_digit[--a_size];

  00224	48 8b 44 24 60	 mov	 rax, QWORD PTR a_size$[rsp]
  00229	48 ff c8	 dec	 rax
  0022c	48 89 44 24 60	 mov	 QWORD PTR a_size$[rsp], rax
  00231	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00236	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a_size$[rsp]
  0023b	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  0023f	66 0f ef c0	 pxor	 xmm0, xmm0
  00243	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00248	f2 0f 11 84 24
	b0 00 00 00	 movsdx	 QWORD PTR da$23430[rsp], xmm0
$LN32@long_true_:

; 3622 :         while (a_size > 0)

  00251	48 83 7c 24 60
	00		 cmp	 QWORD PTR a_size$[rsp], 0
  00257	7e 48		 jle	 SHORT $LN31@long_true_

; 3623 :             da = da * PyLong_BASE + a->ob_digit[--a_size];

  00259	48 8b 44 24 60	 mov	 rax, QWORD PTR a_size$[rsp]
  0025e	48 ff c8	 dec	 rax
  00261	48 89 44 24 60	 mov	 QWORD PTR a_size$[rsp], rax
  00266	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0026b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a_size$[rsp]
  00270	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  00274	66 0f ef c0	 pxor	 xmm0, xmm0
  00278	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0027d	f2 0f 10 8c 24
	b0 00 00 00	 movsdx	 xmm1, QWORD PTR da$23430[rsp]
  00286	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@41d0000000000000
  0028e	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00292	66 0f 28 c1	 movapd	 xmm0, xmm1
  00296	f2 0f 11 84 24
	b0 00 00 00	 movsdx	 QWORD PTR da$23430[rsp], xmm0
  0029f	eb b0		 jmp	 SHORT $LN32@long_true_
$LN31@long_true_:

; 3624 :         db = b->ob_digit[--b_size];

  002a1	48 8b 44 24 28	 mov	 rax, QWORD PTR b_size$[rsp]
  002a6	48 ff c8	 dec	 rax
  002a9	48 89 44 24 28	 mov	 QWORD PTR b_size$[rsp], rax
  002ae	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  002b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR b_size$[rsp]
  002b8	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  002bc	66 0f ef c0	 pxor	 xmm0, xmm0
  002c0	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  002c5	f2 0f 11 84 24
	a8 00 00 00	 movsdx	 QWORD PTR db$23431[rsp], xmm0
$LN30@long_true_:

; 3625 :         while (b_size > 0)

  002ce	48 83 7c 24 28
	00		 cmp	 QWORD PTR b_size$[rsp], 0
  002d4	7e 48		 jle	 SHORT $LN29@long_true_

; 3626 :             db = db * PyLong_BASE + b->ob_digit[--b_size];

  002d6	48 8b 44 24 28	 mov	 rax, QWORD PTR b_size$[rsp]
  002db	48 ff c8	 dec	 rax
  002de	48 89 44 24 28	 mov	 QWORD PTR b_size$[rsp], rax
  002e3	48 8b 44 24 68	 mov	 rax, QWORD PTR b$[rsp]
  002e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR b_size$[rsp]
  002ed	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  002f1	66 0f ef c0	 pxor	 xmm0, xmm0
  002f5	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  002fa	f2 0f 10 8c 24
	a8 00 00 00	 movsdx	 xmm1, QWORD PTR db$23431[rsp]
  00303	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@41d0000000000000
  0030b	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0030f	66 0f 28 c1	 movapd	 xmm0, xmm1
  00313	f2 0f 11 84 24
	a8 00 00 00	 movsdx	 QWORD PTR db$23431[rsp], xmm0
  0031c	eb b0		 jmp	 SHORT $LN30@long_true_
$LN29@long_true_:

; 3627 :         result = da / db;

  0031e	f2 0f 10 84 24
	b0 00 00 00	 movsdx	 xmm0, QWORD PTR da$23430[rsp]
  00327	f2 0f 5e 84 24
	a8 00 00 00	 divsd	 xmm0, QWORD PTR db$23431[rsp]
  00330	f2 0f 11 44 24
	78		 movsdx	 QWORD PTR result$[rsp], xmm0

; 3628 :         goto success;

  00336	e9 3c 07 00 00	 jmp	 $success$23440
$LN33@long_true_:

; 3629 :     }
; 3630 : 
; 3631 :     /* Catch obvious cases of underflow and overflow */
; 3632 :     diff = a_size - b_size;

  0033b	48 8b 44 24 28	 mov	 rax, QWORD PTR b_size$[rsp]
  00340	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a_size$[rsp]
  00345	48 2b c8	 sub	 rcx, rax
  00348	48 8b c1	 mov	 rax, rcx
  0034b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR diff$[rsp], rax

; 3633 :     if (diff > PY_SSIZE_T_MAX/PyLong_SHIFT - 1)

  00353	48 b8 43 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825859	; 0444444444444443H
  0035d	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR diff$[rsp], rax
  00365	7e 07		 jle	 SHORT $LN28@long_true_

; 3634 :         /* Extreme overflow */
; 3635 :         goto overflow;

  00367	e9 81 07 00 00	 jmp	 $overflow$23444
  0036c	eb 19		 jmp	 SHORT $LN27@long_true_
$LN28@long_true_:

; 3636 :     else if (diff < 1 - PY_SSIZE_T_MAX/PyLong_SHIFT)

  0036e	48 b8 bd bb bb
	bb bb bb bb fb	 mov	 rax, -307445734561825859 ; fbbbbbbbbbbbbbbdH
  00378	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR diff$[rsp], rax
  00380	7d 05		 jge	 SHORT $LN26@long_true_

; 3637 :         /* Extreme underflow */
; 3638 :         goto underflow_or_zero;

  00382	e9 2f 07 00 00	 jmp	 $underflow_or_zero$23428
$LN26@long_true_:
$LN27@long_true_:

; 3639 :     /* Next line is now safe from overflowing a Py_ssize_t */
; 3640 :     diff = diff * PyLong_SHIFT + bits_in_digit(a->ob_digit[a_size - 1]) -
; 3641 :         bits_in_digit(b->ob_digit[b_size - 1]);

  00387	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR diff$[rsp]
  0038f	48 6b c0 1e	 imul	 rax, 30
  00393	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv175[rsp], rax
  0039b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  003a0	48 8b 54 24 60	 mov	 rdx, QWORD PTR a_size$[rsp]
  003a5	8b 4c 91 6c	 mov	 ecx, DWORD PTR [rcx+rdx*4+108]
  003a9	e8 00 00 00 00	 call	 bits_in_digit
  003ae	48 98		 cdqe
  003b0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv175[rsp]
  003b8	48 03 c8	 add	 rcx, rax
  003bb	48 8b c1	 mov	 rax, rcx
  003be	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv183[rsp], rax
  003c6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR b$[rsp]
  003cb	48 8b 54 24 28	 mov	 rdx, QWORD PTR b_size$[rsp]
  003d0	8b 4c 91 6c	 mov	 ecx, DWORD PTR [rcx+rdx*4+108]
  003d4	e8 00 00 00 00	 call	 bits_in_digit
  003d9	48 98		 cdqe
  003db	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv183[rsp]
  003e3	48 2b c8	 sub	 rcx, rax
  003e6	48 8b c1	 mov	 rax, rcx
  003e9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR diff$[rsp], rax

; 3642 :     /* Now diff = a_bits - b_bits. */
; 3643 :     if (diff > DBL_MAX_EXP)

  003f1	48 81 bc 24 98
	00 00 00 00 04
	00 00		 cmp	 QWORD PTR diff$[rsp], 1024 ; 00000400H
  003fd	7e 07		 jle	 SHORT $LN25@long_true_

; 3644 :         goto overflow;

  003ff	e9 e9 06 00 00	 jmp	 $overflow$23444
  00404	eb 13		 jmp	 SHORT $LN24@long_true_
$LN25@long_true_:

; 3645 :     else if (diff < DBL_MIN_EXP - DBL_MANT_DIG - 1)

  00406	48 81 bc 24 98
	00 00 00 cd fb
	ff ff		 cmp	 QWORD PTR diff$[rsp], -1075 ; fffffffffffffbcdH
  00412	7d 05		 jge	 SHORT $LN23@long_true_

; 3646 :         goto underflow_or_zero;

  00414	e9 9d 06 00 00	 jmp	 $underflow_or_zero$23428
$LN23@long_true_:
$LN24@long_true_:

; 3647 : 
; 3648 :     /* Choose value for shift; see comments for step 1 above. */
; 3649 :     shift = MAX(diff, DBL_MIN_EXP) - DBL_MANT_DIG - 2;

  00419	48 81 bc 24 98
	00 00 00 03 fc
	ff ff		 cmp	 QWORD PTR diff$[rsp], -1021 ; fffffffffffffc03H
  00425	7d 0e		 jge	 SHORT $LN57@long_true_
  00427	48 c7 84 24 28
	01 00 00 03 fc
	ff ff		 mov	 QWORD PTR tv195[rsp], -1021 ; fffffffffffffc03H
  00433	eb 10		 jmp	 SHORT $LN58@long_true_
$LN57@long_true_:
  00435	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR diff$[rsp]
  0043d	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv195[rsp], rax
$LN58@long_true_:
  00445	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv195[rsp]
  0044d	48 83 e8 37	 sub	 rax, 55			; 00000037H
  00451	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR shift$[rsp], rax

; 3650 : 
; 3651 :     inexact = 0;

  00459	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR inexact$[rsp], 0

; 3652 : 
; 3653 :     /* x = abs(a * 2**-shift) */
; 3654 :     if (shift <= 0) {

  00461	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR shift$[rsp], 0
  0046a	0f 8f 49 01 00
	00		 jg	 $LN22@long_true_

; 3655 :         Py_ssize_t i, shift_digits = -shift / PyLong_SHIFT;

  00470	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR shift$[rsp]
  00478	48 f7 d8	 neg	 rax
  0047b	48 99		 cdq
  0047d	b9 1e 00 00 00	 mov	 ecx, 30
  00482	48 f7 f9	 idiv	 rcx
  00485	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR shift_digits$23454[rsp], rax

; 3656 :         digit rem;
; 3657 :         /* x = a << -shift */
; 3658 :         if (a_size >= PY_SSIZE_T_MAX - 1 - shift_digits) {

  0048d	48 b8 fe ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775806 ; 7ffffffffffffffeH
  00497	48 2b 84 24 c8
	00 00 00	 sub	 rax, QWORD PTR shift_digits$23454[rsp]
  0049f	48 39 44 24 60	 cmp	 QWORD PTR a_size$[rsp], rax
  004a4	7c 18		 jl	 SHORT $LN21@long_true_

; 3659 :             /* In practice, it's probably impossible to end up
; 3660 :                here.  Both a and b would have to be enormous,
; 3661 :                using close to SIZE_T_MAX bytes of memory each. */
; 3662 :             PyErr_SetString(PyExc_OverflowError,
; 3663 :                             "intermediate overflow during division");

  004a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@JGBBDDEJ@intermediate?5overflow?5during?5div@
  004ad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  004b4	e8 00 00 00 00	 call	 PyErr_SetString

; 3664 :             goto error;

  004b9	e9 42 06 00 00	 jmp	 $error$23426
$LN21@long_true_:

; 3665 :         }
; 3666 :         x = _PyLong_New(a_size + shift_digits + 1);

  004be	48 8b 44 24 60	 mov	 rax, QWORD PTR a_size$[rsp]
  004c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR shift_digits$23454[rsp]
  004cb	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  004d0	48 8b c8	 mov	 rcx, rax
  004d3	e8 00 00 00 00	 call	 _PyLong_New
  004d8	48 89 44 24 48	 mov	 QWORD PTR x$[rsp], rax

; 3667 :         if (x == NULL)

  004dd	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  004e3	75 05		 jne	 SHORT $LN20@long_true_

; 3668 :             goto error;

  004e5	e9 16 06 00 00	 jmp	 $error$23426
$LN20@long_true_:

; 3669 :         for (i = 0; i < shift_digits; i++)

  004ea	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$23453[rsp], 0
  004f6	eb 13		 jmp	 SHORT $LN19@long_true_
$LN18@long_true_:
  004f8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR i$23453[rsp]
  00500	48 ff c0	 inc	 rax
  00503	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR i$23453[rsp], rax
$LN19@long_true_:
  0050b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR shift_digits$23454[rsp]
  00513	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR i$23453[rsp], rax
  0051b	7d 17		 jge	 SHORT $LN17@long_true_

; 3670 :             x->ob_digit[i] = 0;

  0051d	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  00522	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR i$23453[rsp]
  0052a	c7 44 88 70 00
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+112], 0
  00532	eb c4		 jmp	 SHORT $LN18@long_true_
$LN17@long_true_:

; 3671 :         rem = v_lshift(x->ob_digit + shift_digits, a->ob_digit,
; 3672 :                        a_size, -shift % PyLong_SHIFT);

  00534	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR shift$[rsp]
  0053c	48 f7 d8	 neg	 rax
  0053f	48 99		 cdq
  00541	b9 1e 00 00 00	 mov	 ecx, 30
  00546	48 f7 f9	 idiv	 rcx
  00549	48 8b c2	 mov	 rax, rdx
  0054c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00551	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00555	48 8b 54 24 48	 mov	 rdx, QWORD PTR x$[rsp]
  0055a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR shift_digits$23454[rsp]
  00562	4a 8d 54 82 70	 lea	 rdx, QWORD PTR [rdx+r8*4+112]
  00567	48 89 94 24 30
	01 00 00	 mov	 QWORD PTR tv225[rsp], rdx
  0056f	44 8b c8	 mov	 r9d, eax
  00572	4c 8b 44 24 60	 mov	 r8, QWORD PTR a_size$[rsp]
  00577	48 8b d1	 mov	 rdx, rcx
  0057a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv225[rsp]
  00582	48 8b c8	 mov	 rcx, rax
  00585	e8 00 00 00 00	 call	 v_lshift
  0058a	89 84 24 c0 00
	00 00		 mov	 DWORD PTR rem$23455[rsp], eax

; 3673 :         x->ob_digit[a_size + shift_digits] = rem;

  00591	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR shift_digits$23454[rsp]
  00599	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a_size$[rsp]
  0059e	48 03 c8	 add	 rcx, rax
  005a1	48 8b c1	 mov	 rax, rcx
  005a4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  005a9	8b 94 24 c0 00
	00 00		 mov	 edx, DWORD PTR rem$23455[rsp]
  005b0	89 54 81 70	 mov	 DWORD PTR [rcx+rax*4+112], edx

; 3674 :     }
; 3675 :     else {

  005b4	e9 2f 01 00 00	 jmp	 $LN16@long_true_
$LN22@long_true_:

; 3676 :         Py_ssize_t shift_digits = shift / PyLong_SHIFT;

  005b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR shift$[rsp]
  005c1	48 99		 cdq
  005c3	b9 1e 00 00 00	 mov	 ecx, 30
  005c8	48 f7 f9	 idiv	 rcx
  005cb	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR shift_digits$23466[rsp], rax

; 3677 :         digit rem;
; 3678 :         /* x = a >> shift */
; 3679 :         assert(a_size >= shift_digits);

  005d3	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR shift_digits$23466[rsp]
  005db	48 39 44 24 60	 cmp	 QWORD PTR a_size$[rsp], rax
  005e0	7d 1c		 jge	 SHORT $LN59@long_true_
  005e2	41 b8 5f 0e 00
	00		 mov	 r8d, 3679		; 00000e5fH
  005e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  005ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@LNLGEPMD@?$AAa?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAh?$AAi?$AAf?$AAt?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AAs?$AA?$AA@
  005f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005fc	33 c0		 xor	 eax, eax
$LN59@long_true_:

; 3680 :         x = _PyLong_New(a_size - shift_digits);

  005fe	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR shift_digits$23466[rsp]
  00606	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a_size$[rsp]
  0060b	48 2b c8	 sub	 rcx, rax
  0060e	48 8b c1	 mov	 rax, rcx
  00611	48 8b c8	 mov	 rcx, rax
  00614	e8 00 00 00 00	 call	 _PyLong_New
  00619	48 89 44 24 48	 mov	 QWORD PTR x$[rsp], rax

; 3681 :         if (x == NULL)

  0061e	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  00624	75 05		 jne	 SHORT $LN15@long_true_

; 3682 :             goto error;

  00626	e9 d5 04 00 00	 jmp	 $error$23426
$LN15@long_true_:

; 3683 :         rem = v_rshift(x->ob_digit, a->ob_digit + shift_digits,
; 3684 :                        a_size - shift_digits, shift % PyLong_SHIFT);

  0062b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR shift$[rsp]
  00633	48 99		 cdq
  00635	b9 1e 00 00 00	 mov	 ecx, 30
  0063a	48 f7 f9	 idiv	 rcx
  0063d	48 8b c2	 mov	 rax, rdx
  00640	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR shift_digits$23466[rsp]
  00648	48 8b 54 24 60	 mov	 rdx, QWORD PTR a_size$[rsp]
  0064d	48 2b d1	 sub	 rdx, rcx
  00650	48 8b ca	 mov	 rcx, rdx
  00653	48 8b 54 24 50	 mov	 rdx, QWORD PTR a$[rsp]
  00658	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR shift_digits$23466[rsp]
  00660	4a 8d 54 82 70	 lea	 rdx, QWORD PTR [rdx+r8*4+112]
  00665	4c 8b 44 24 48	 mov	 r8, QWORD PTR x$[rsp]
  0066a	49 83 c0 70	 add	 r8, 112			; 00000070H
  0066e	4c 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv251[rsp], r8
  00676	44 8b c8	 mov	 r9d, eax
  00679	4c 8b c1	 mov	 r8, rcx
  0067c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR tv251[rsp]
  00684	48 8b c8	 mov	 rcx, rax
  00687	e8 00 00 00 00	 call	 v_rshift
  0068c	89 84 24 d0 00
	00 00		 mov	 DWORD PTR rem$23467[rsp], eax

; 3685 :         /* set inexact if any of the bits shifted out is nonzero */
; 3686 :         if (rem)

  00693	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR rem$23467[rsp], 0
  0069b	74 08		 je	 SHORT $LN14@long_true_

; 3687 :             inexact = 1;

  0069d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR inexact$[rsp], 1
$LN14@long_true_:
$LN13@long_true_:

; 3688 :         while (!inexact && shift_digits > 0)

  006a5	83 7c 24 30 00	 cmp	 DWORD PTR inexact$[rsp], 0
  006aa	75 3c		 jne	 SHORT $LN12@long_true_
  006ac	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR shift_digits$23466[rsp], 0
  006b5	7e 31		 jle	 SHORT $LN12@long_true_

; 3689 :             if (a->ob_digit[--shift_digits])

  006b7	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR shift_digits$23466[rsp]
  006bf	48 ff c8	 dec	 rax
  006c2	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR shift_digits$23466[rsp], rax
  006ca	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  006cf	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR shift_digits$23466[rsp]
  006d7	83 7c 88 70 00	 cmp	 DWORD PTR [rax+rcx*4+112], 0
  006dc	74 08		 je	 SHORT $LN11@long_true_

; 3690 :                 inexact = 1;

  006de	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR inexact$[rsp], 1
$LN11@long_true_:

; 3691 :     }

  006e6	eb bd		 jmp	 SHORT $LN13@long_true_
$LN12@long_true_:
$LN16@long_true_:

; 3692 :     long_normalize(x);

  006e8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  006ed	e8 00 00 00 00	 call	 long_normalize

; 3693 :     x_size = Py_SIZE(x);

  006f2	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  006f7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  006fb	48 89 44 24 40	 mov	 QWORD PTR x_size$[rsp], rax

; 3694 : 
; 3695 :     /* x //= b. If the remainder is nonzero, set inexact.  We own the only
; 3696 :        reference to x, so it's safe to modify it in-place. */
; 3697 :     if (b_size == 1) {

  00700	48 83 7c 24 28
	01		 cmp	 QWORD PTR b_size$[rsp], 1
  00706	75 4d		 jne	 SHORT $LN10@long_true_

; 3698 :         digit rem = inplace_divrem1(x->ob_digit, x->ob_digit, x_size,
; 3699 :                               b->ob_digit[0]);

  00708	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  0070d	48 83 c0 70	 add	 rax, 112		; 00000070H
  00711	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  00716	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0071a	48 8b 54 24 68	 mov	 rdx, QWORD PTR b$[rsp]
  0071f	44 8b 4a 70	 mov	 r9d, DWORD PTR [rdx+112]
  00723	4c 8b 44 24 40	 mov	 r8, QWORD PTR x_size$[rsp]
  00728	48 8b d0	 mov	 rdx, rax
  0072b	e8 00 00 00 00	 call	 inplace_divrem1
  00730	89 84 24 e0 00
	00 00		 mov	 DWORD PTR rem$23479[rsp], eax

; 3700 :         long_normalize(x);

  00737	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  0073c	e8 00 00 00 00	 call	 long_normalize

; 3701 :         if (rem)

  00741	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR rem$23479[rsp], 0
  00749	74 08		 je	 SHORT $LN9@long_true_

; 3702 :             inexact = 1;

  0074b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR inexact$[rsp], 1
$LN9@long_true_:

; 3703 :     }
; 3704 :     else {

  00753	eb 67		 jmp	 SHORT $LN8@long_true_
$LN10@long_true_:

; 3705 :         PyLongObject *div, *rem;
; 3706 :         div = x_divrem(x, b, &rem);

  00755	4c 8d 84 24 e8
	00 00 00	 lea	 r8, QWORD PTR rem$23483[rsp]
  0075d	48 8b 54 24 68	 mov	 rdx, QWORD PTR b$[rsp]
  00762	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  00767	e8 00 00 00 00	 call	 x_divrem
  0076c	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR div$23482[rsp], rax

; 3707 :         Py_DECREF(x);

  00774	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  00779	e8 00 00 00 00	 call	 _Py_DecRef

; 3708 :         x = div;

  0077e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR div$23482[rsp]
  00786	48 89 44 24 48	 mov	 QWORD PTR x$[rsp], rax

; 3709 :         if (x == NULL)

  0078b	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  00791	75 05		 jne	 SHORT $LN7@long_true_

; 3710 :             goto error;

  00793	e9 68 03 00 00	 jmp	 $error$23426
$LN7@long_true_:

; 3711 :         if (Py_SIZE(rem))

  00798	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR rem$23483[rsp]
  007a0	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  007a5	74 08		 je	 SHORT $LN6@long_true_

; 3712 :             inexact = 1;

  007a7	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR inexact$[rsp], 1
$LN6@long_true_:

; 3713 :         Py_DECREF(rem);

  007af	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR rem$23483[rsp]
  007b7	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@long_true_:

; 3714 :     }
; 3715 :     x_size = ABS(Py_SIZE(x));

  007bc	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  007c1	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  007c6	7d 16		 jge	 SHORT $LN60@long_true_
  007c8	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  007cd	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  007d1	48 f7 d8	 neg	 rax
  007d4	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv289[rsp], rax
  007dc	eb 11		 jmp	 SHORT $LN61@long_true_
$LN60@long_true_:
  007de	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  007e3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  007e7	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv289[rsp], rax
$LN61@long_true_:
  007ef	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR tv289[rsp]
  007f7	48 89 44 24 40	 mov	 QWORD PTR x_size$[rsp], rax

; 3716 :     assert(x_size > 0); /* result of division is never zero */

  007fc	48 83 7c 24 40
	00		 cmp	 QWORD PTR x_size$[rsp], 0
  00802	7f 1c		 jg	 SHORT $LN62@long_true_
  00804	41 b8 84 0e 00
	00		 mov	 r8d, 3716		; 00000e84H
  0080a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00811	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@MLPCOPPF@?$AAx?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00818	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0081e	33 c0		 xor	 eax, eax
$LN62@long_true_:

; 3717 :     x_bits = (x_size-1)*PyLong_SHIFT+bits_in_digit(x->ob_digit[x_size-1]);

  00820	48 8b 44 24 40	 mov	 rax, QWORD PTR x_size$[rsp]
  00825	48 ff c8	 dec	 rax
  00828	48 6b c0 1e	 imul	 rax, 30
  0082c	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv296[rsp], rax
  00834	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  00839	48 8b 54 24 40	 mov	 rdx, QWORD PTR x_size$[rsp]
  0083e	8b 4c 91 6c	 mov	 ecx, DWORD PTR [rcx+rdx*4+108]
  00842	e8 00 00 00 00	 call	 bits_in_digit
  00847	48 98		 cdqe
  00849	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv296[rsp]
  00851	48 03 c8	 add	 rcx, rax
  00854	48 8b c1	 mov	 rax, rcx
  00857	48 89 44 24 38	 mov	 QWORD PTR x_bits$[rsp], rax

; 3718 : 
; 3719 :     /* The number of extra bits that have to be rounded away. */
; 3720 :     extra_bits = MAX(x_bits, DBL_MIN_EXP - shift) - DBL_MANT_DIG;

  0085c	48 c7 c0 03 fc
	ff ff		 mov	 rax, -1021		; fffffffffffffc03H
  00863	48 2b 84 24 a0
	00 00 00	 sub	 rax, QWORD PTR shift$[rsp]
  0086b	48 39 44 24 38	 cmp	 QWORD PTR x_bits$[rsp], rax
  00870	7d 19		 jge	 SHORT $LN63@long_true_
  00872	48 c7 c0 03 fc
	ff ff		 mov	 rax, -1021		; fffffffffffffc03H
  00879	48 2b 84 24 a0
	00 00 00	 sub	 rax, QWORD PTR shift$[rsp]
  00881	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv308[rsp], rax
  00889	eb 0d		 jmp	 SHORT $LN64@long_true_
$LN63@long_true_:
  0088b	48 8b 44 24 38	 mov	 rax, QWORD PTR x_bits$[rsp]
  00890	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv308[rsp], rax
$LN64@long_true_:
  00898	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR tv308[rsp]
  008a0	48 83 e8 35	 sub	 rax, 53			; 00000035H
  008a4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR extra_bits$[rsp], rax

; 3721 :     assert(extra_bits == 2 || extra_bits == 3);

  008ac	48 83 bc 24 88
	00 00 00 02	 cmp	 QWORD PTR extra_bits$[rsp], 2
  008b5	74 27		 je	 SHORT $LN65@long_true_
  008b7	48 83 bc 24 88
	00 00 00 03	 cmp	 QWORD PTR extra_bits$[rsp], 3
  008c0	74 1c		 je	 SHORT $LN65@long_true_
  008c2	41 b8 89 0e 00
	00		 mov	 r8d, 3721		; 00000e89H
  008c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  008cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@JEACKEOJ@?$AAe?$AAx?$AAt?$AAr?$AAa?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAe?$AAx?$AAt?$AAr?$AAa?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN@
  008d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  008dc	33 c0		 xor	 eax, eax
$LN65@long_true_:

; 3722 : 
; 3723 :     /* Round by directly modifying the low digit of x. */
; 3724 :     mask = (digit)1 << (extra_bits - 1);

  008de	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR extra_bits$[rsp]
  008e6	48 ff c8	 dec	 rax
  008e9	b9 01 00 00 00	 mov	 ecx, 1
  008ee	89 8c 24 58 01
	00 00		 mov	 DWORD PTR tv572[rsp], ecx
  008f5	0f b6 c8	 movzx	 ecx, al
  008f8	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR tv572[rsp]
  008ff	d3 e0		 shl	 eax, cl
  00901	89 44 24 5c	 mov	 DWORD PTR mask$[rsp], eax

; 3725 :     low = x->ob_digit[0] | inexact;

  00905	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  0090a	8b 4c 24 30	 mov	 ecx, DWORD PTR inexact$[rsp]
  0090e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00911	0b c1		 or	 eax, ecx
  00913	89 84 24 80 00
	00 00		 mov	 DWORD PTR low$[rsp], eax

; 3726 :     if (low & mask && low & (3*mask-1))

  0091a	8b 44 24 5c	 mov	 eax, DWORD PTR mask$[rsp]
  0091e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR low$[rsp]
  00925	23 c8		 and	 ecx, eax
  00927	8b c1		 mov	 eax, ecx
  00929	85 c0		 test	 eax, eax
  0092b	74 2e		 je	 SHORT $LN5@long_true_
  0092d	8b 44 24 5c	 mov	 eax, DWORD PTR mask$[rsp]
  00931	6b c0 03	 imul	 eax, 3
  00934	ff c8		 dec	 eax
  00936	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR low$[rsp]
  0093d	23 c8		 and	 ecx, eax
  0093f	8b c1		 mov	 eax, ecx
  00941	85 c0		 test	 eax, eax
  00943	74 16		 je	 SHORT $LN5@long_true_

; 3727 :         low += mask;

  00945	8b 44 24 5c	 mov	 eax, DWORD PTR mask$[rsp]
  00949	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR low$[rsp]
  00950	03 c8		 add	 ecx, eax
  00952	8b c1		 mov	 eax, ecx
  00954	89 84 24 80 00
	00 00		 mov	 DWORD PTR low$[rsp], eax
$LN5@long_true_:

; 3728 :     x->ob_digit[0] = low & ~(mask-1U);

  0095b	8b 44 24 5c	 mov	 eax, DWORD PTR mask$[rsp]
  0095f	ff c8		 dec	 eax
  00961	f7 d0		 not	 eax
  00963	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR low$[rsp]
  0096a	23 c8		 and	 ecx, eax
  0096c	8b c1		 mov	 eax, ecx
  0096e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  00973	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 3729 : 
; 3730 :     /* Convert x to a double dx; the conversion is exact. */
; 3731 :     dx = x->ob_digit[--x_size];

  00976	48 8b 44 24 40	 mov	 rax, QWORD PTR x_size$[rsp]
  0097b	48 ff c8	 dec	 rax
  0097e	48 89 44 24 40	 mov	 QWORD PTR x_size$[rsp], rax
  00983	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  00988	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x_size$[rsp]
  0098d	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  00991	66 0f ef c0	 pxor	 xmm0, xmm0
  00995	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0099a	f2 0f 11 84 24
	90 00 00 00	 movsdx	 QWORD PTR dx$[rsp], xmm0
$LN4@long_true_:

; 3732 :     while (x_size > 0)

  009a3	48 83 7c 24 40
	00		 cmp	 QWORD PTR x_size$[rsp], 0
  009a9	7e 48		 jle	 SHORT $LN3@long_true_

; 3733 :         dx = dx * PyLong_BASE + x->ob_digit[--x_size];

  009ab	48 8b 44 24 40	 mov	 rax, QWORD PTR x_size$[rsp]
  009b0	48 ff c8	 dec	 rax
  009b3	48 89 44 24 40	 mov	 QWORD PTR x_size$[rsp], rax
  009b8	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  009bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x_size$[rsp]
  009c2	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  009c6	66 0f ef c0	 pxor	 xmm0, xmm0
  009ca	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  009cf	f2 0f 10 8c 24
	90 00 00 00	 movsdx	 xmm1, QWORD PTR dx$[rsp]
  009d8	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@41d0000000000000
  009e0	f2 0f 58 c8	 addsd	 xmm1, xmm0
  009e4	66 0f 28 c1	 movapd	 xmm0, xmm1
  009e8	f2 0f 11 84 24
	90 00 00 00	 movsdx	 QWORD PTR dx$[rsp], xmm0
  009f1	eb b0		 jmp	 SHORT $LN4@long_true_
$LN3@long_true_:

; 3734 :     Py_DECREF(x);

  009f3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  009f8	e8 00 00 00 00	 call	 _Py_DecRef

; 3735 : 
; 3736 :     /* Check whether ldexp result will overflow a double. */
; 3737 :     if (shift + x_bits >= DBL_MAX_EXP &&
; 3738 :         (shift + x_bits > DBL_MAX_EXP || dx == ldexp(1.0, (int)x_bits)))

  009fd	48 8b 44 24 38	 mov	 rax, QWORD PTR x_bits$[rsp]
  00a02	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR shift$[rsp]
  00a0a	48 03 c8	 add	 rcx, rax
  00a0d	48 8b c1	 mov	 rax, rcx
  00a10	48 3d 00 04 00
	00		 cmp	 rax, 1024		; 00000400H
  00a16	7c 43		 jl	 SHORT $LN2@long_true_
  00a18	48 8b 44 24 38	 mov	 rax, QWORD PTR x_bits$[rsp]
  00a1d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR shift$[rsp]
  00a25	48 03 c8	 add	 rcx, rax
  00a28	48 8b c1	 mov	 rax, rcx
  00a2b	48 3d 00 04 00
	00		 cmp	 rax, 1024		; 00000400H
  00a31	7f 23		 jg	 SHORT $LN1@long_true_
  00a33	8b 54 24 38	 mov	 edx, DWORD PTR x_bits$[rsp]
  00a37	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00a3f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00a45	f2 0f 10 8c 24
	90 00 00 00	 movsdx	 xmm1, QWORD PTR dx$[rsp]
  00a4e	66 0f 2e c8	 ucomisd xmm1, xmm0
  00a52	7a 07		 jp	 SHORT $LN2@long_true_
  00a54	75 05		 jne	 SHORT $LN2@long_true_
$LN1@long_true_:

; 3739 :         goto overflow;

  00a56	e9 92 00 00 00	 jmp	 $overflow$23444
$LN2@long_true_:

; 3740 :     result = ldexp(dx, (int)shift);

  00a5b	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR shift$[rsp]
  00a62	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR dx$[rsp]
  00a6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00a71	f2 0f 11 44 24
	78		 movsdx	 QWORD PTR result$[rsp], xmm0
$success$23440:

; 3741 : 
; 3742 :   success:
; 3743 :     return PyFloat_FromDouble(negate ? -result : result);

  00a77	83 7c 24 70 00	 cmp	 DWORD PTR negate$[rsp], 0
  00a7c	74 19		 je	 SHORT $LN66@long_true_
  00a7e	f2 0f 10 44 24
	78		 movsdx	 xmm0, QWORD PTR result$[rsp]
  00a84	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00a8c	f2 0f 11 84 24
	60 01 00 00	 movsdx	 QWORD PTR tv361[rsp], xmm0
  00a95	eb 0f		 jmp	 SHORT $LN67@long_true_
$LN66@long_true_:
  00a97	f2 0f 10 44 24
	78		 movsdx	 xmm0, QWORD PTR result$[rsp]
  00a9d	f2 0f 11 84 24
	60 01 00 00	 movsdx	 QWORD PTR tv361[rsp], xmm0
$LN67@long_true_:
  00aa6	f2 0f 10 84 24
	60 01 00 00	 movsdx	 xmm0, QWORD PTR tv361[rsp]
  00aaf	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00ab4	eb 4c		 jmp	 SHORT $LN41@long_true_
$underflow_or_zero$23428:

; 3744 : 
; 3745 :   underflow_or_zero:
; 3746 :     return PyFloat_FromDouble(negate ? -0.0 : 0.0);

  00ab6	83 7c 24 70 00	 cmp	 DWORD PTR negate$[rsp], 0
  00abb	74 13		 je	 SHORT $LN68@long_true_
  00abd	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@8000000000000000
  00ac5	f2 0f 11 84 24
	68 01 00 00	 movsdx	 QWORD PTR tv365[rsp], xmm0
  00ace	eb 0d		 jmp	 SHORT $LN69@long_true_
$LN68@long_true_:
  00ad0	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00ad4	f2 0f 11 84 24
	68 01 00 00	 movsdx	 QWORD PTR tv365[rsp], xmm0
$LN69@long_true_:
  00add	f2 0f 10 84 24
	68 01 00 00	 movsdx	 xmm0, QWORD PTR tv365[rsp]
  00ae6	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00aeb	eb 15		 jmp	 SHORT $LN41@long_true_
$overflow$23444:

; 3747 : 
; 3748 :   overflow:
; 3749 :     PyErr_SetString(PyExc_OverflowError,
; 3750 :                     "integer division result too large for a float");

  00aed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@FMAPPLED@integer?5division?5result?5too?5larg@
  00af4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00afb	e8 00 00 00 00	 call	 PyErr_SetString
$error$23426:

; 3751 :   error:
; 3752 :     return NULL;

  00b00	33 c0		 xor	 eax, eax
$LN41@long_true_:

; 3753 : }

  00b02	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  00b09	c3		 ret	 0
long_true_divide ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_mod DD imagerel long_mod
	DD	imagerel long_mod+135
	DD	imagerel $unwind$long_mod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_mod DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_mod
_TEXT	SEGMENT
mod$ = 32
a$ = 64
b$ = 72
long_mod PROC						; COMDAT

; 3757 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@long_mod:

; 3758 :     PyLongObject *mod;
; 3759 : 
; 3760 :     CHECK_BINOP(a, b);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00022	85 c0		 test	 eax, eax
  00024	74 18		 je	 SHORT $LN2@long_mod
  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003a	85 c0		 test	 eax, eax
  0003c	75 15		 jne	 SHORT $LN3@long_mod
$LN2@long_mod:
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00045	e8 00 00 00 00	 call	 _Py_IncRef
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00051	eb 2f		 jmp	 SHORT $LN7@long_mod
$LN3@long_mod:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 b5		 jne	 SHORT $LN6@long_mod

; 3761 : 
; 3762 :     if (l_divmod((PyLongObject*)a, (PyLongObject*)b, NULL, &mod) < 0)

  00059	4c 8d 4c 24 20	 lea	 r9, QWORD PTR mod$[rsp]
  0005e	45 33 c0	 xor	 r8d, r8d
  00061	48 8b 54 24 48	 mov	 rdx, QWORD PTR b$[rsp]
  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0006b	e8 00 00 00 00	 call	 l_divmod
  00070	85 c0		 test	 eax, eax
  00072	7d 09		 jge	 SHORT $LN1@long_mod

; 3763 :         mod = NULL;

  00074	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR mod$[rsp], 0
$LN1@long_mod:

; 3764 :     return (PyObject *)mod;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR mod$[rsp]
$LN7@long_mod:

; 3765 : }

  00082	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00086	c3		 ret	 0
long_mod ENDP
_TEXT	ENDS
EXTRN	PyTuple_SetItem:PROC
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_divmod DD imagerel long_divmod
	DD	imagerel long_divmod+214
	DD	imagerel $unwind$long_divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_divmod DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_divmod
_TEXT	SEGMENT
div$ = 32
z$ = 40
mod$ = 48
a$ = 80
b$ = 88
long_divmod PROC					; COMDAT

; 3769 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN8@long_divmo:

; 3770 :     PyLongObject *div, *mod;
; 3771 :     PyObject *z;
; 3772 : 
; 3773 :     CHECK_BINOP(a, b);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00022	85 c0		 test	 eax, eax
  00024	74 18		 je	 SHORT $LN4@long_divmo
  00026	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003a	85 c0		 test	 eax, eax
  0003c	75 15		 jne	 SHORT $LN5@long_divmo
$LN4@long_divmo:
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00045	e8 00 00 00 00	 call	 _Py_IncRef
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00051	eb 7e		 jmp	 SHORT $LN9@long_divmo
$LN5@long_divmo:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 b5		 jne	 SHORT $LN8@long_divmo

; 3774 : 
; 3775 :     if (l_divmod((PyLongObject*)a, (PyLongObject*)b, &div, &mod) < 0) {

  00059	4c 8d 4c 24 30	 lea	 r9, QWORD PTR mod$[rsp]
  0005e	4c 8d 44 24 20	 lea	 r8, QWORD PTR div$[rsp]
  00063	48 8b 54 24 58	 mov	 rdx, QWORD PTR b$[rsp]
  00068	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  0006d	e8 00 00 00 00	 call	 l_divmod
  00072	85 c0		 test	 eax, eax
  00074	7d 04		 jge	 SHORT $LN3@long_divmo

; 3776 :         return NULL;

  00076	33 c0		 xor	 eax, eax
  00078	eb 57		 jmp	 SHORT $LN9@long_divmo
$LN3@long_divmo:

; 3777 :     }
; 3778 :     z = PyTuple_New(2);

  0007a	b9 02 00 00 00	 mov	 ecx, 2
  0007f	e8 00 00 00 00	 call	 PyTuple_New
  00084	48 89 44 24 28	 mov	 QWORD PTR z$[rsp], rax

; 3779 :     if (z != NULL) {

  00089	48 83 7c 24 28
	00		 cmp	 QWORD PTR z$[rsp], 0
  0008f	74 27		 je	 SHORT $LN2@long_divmo

; 3780 :         PyTuple_SetItem(z, 0, (PyObject *) div);

  00091	4c 8b 44 24 20	 mov	 r8, QWORD PTR div$[rsp]
  00096	33 d2		 xor	 edx, edx
  00098	48 8b 4c 24 28	 mov	 rcx, QWORD PTR z$[rsp]
  0009d	e8 00 00 00 00	 call	 PyTuple_SetItem

; 3781 :         PyTuple_SetItem(z, 1, (PyObject *) mod);

  000a2	4c 8b 44 24 30	 mov	 r8, QWORD PTR mod$[rsp]
  000a7	ba 01 00 00 00	 mov	 edx, 1
  000ac	48 8b 4c 24 28	 mov	 rcx, QWORD PTR z$[rsp]
  000b1	e8 00 00 00 00	 call	 PyTuple_SetItem

; 3782 :     }
; 3783 :     else {

  000b6	eb 14		 jmp	 SHORT $LN1@long_divmo
$LN2@long_divmo:

; 3784 :         Py_DECREF(div);

  000b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  000bd	e8 00 00 00 00	 call	 _Py_DecRef

; 3785 :         Py_DECREF(mod);

  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mod$[rsp]
  000c7	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@long_divmo:

; 3786 :     }
; 3787 :     return z;

  000cc	48 8b 44 24 28	 mov	 rax, QWORD PTR z$[rsp]
$LN9@long_divmo:

; 3788 : }

  000d1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d5	c3		 ret	 0
long_divmod ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@OLNKGOFI@pow?$CI?$CJ?53rd?5argument?5cannot?5be?50?$AA@ ; `string'
PUBLIC	??_C@_0EC@HKEPHICC@pow?$CI?$CJ?52nd?5argument?5cannot?5be?5neg@ ; `string'
EXTRN	PyFloat_Type:BYTE
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_pow DD imagerel long_pow
	DD	imagerel long_pow+3175
	DD	imagerel $unwind$long_pow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_pow DD 021601H
	DD	0330116H
xdata	ENDS
;	COMDAT ??_C@_0BP@OLNKGOFI@pow?$CI?$CJ?53rd?5argument?5cannot?5be?50?$AA@
CONST	SEGMENT
??_C@_0BP@OLNKGOFI@pow?$CI?$CJ?53rd?5argument?5cannot?5be?50?$AA@ DB 'pow'
	DB	'() 3rd argument cannot be 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HKEPHICC@pow?$CI?$CJ?52nd?5argument?5cannot?5be?5neg@
CONST	SEGMENT
??_C@_0EC@HKEPHICC@pow?$CI?$CJ?52nd?5argument?5cannot?5be?5neg@ DB 'pow()'
	DB	' 2nd argument cannot be negative when 3rd argument specified', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_pow
_TEXT	SEGMENT
a$ = 32
i$ = 40
temp$ = 48
table$ = 64
b$ = 320
k$ = 328
z$ = 336
negativeOutput$ = 344
c$ = 352
j$ = 360
tmp$23629 = 368
bi$23661 = 376
bi$23751 = 380
index$23755 = 384
tv220 = 388
tv219 = 392
v$ = 416
w$ = 424
x$ = 432
long_pow PROC						; COMDAT

; 3793 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H

; 3794 :     PyLongObject *a, *b, *c; /* a,b,c = v,w,x */
; 3795 :     int negativeOutput = 0;  /* if x<0 return negative output */

  00016	c7 84 24 58 01
	00 00 00 00 00
	00		 mov	 DWORD PTR negativeOutput$[rsp], 0

; 3796 : 
; 3797 :     PyLongObject *z = NULL;  /* accumulated result */

  00021	48 c7 84 24 50
	01 00 00 00 00
	00 00		 mov	 QWORD PTR z$[rsp], 0

; 3798 :     Py_ssize_t i, j, k;             /* counters */
; 3799 :     PyLongObject *temp = NULL;

  0002d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0

; 3800 : 
; 3801 :     /* 5-ary values.  If the exponent is large enough, table is
; 3802 :      * precomputed so that table[i] == a**i % c for i in range(32).
; 3803 :      */
; 3804 :     PyLongObject *table[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  00036	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR table$[rsp], 0
  0003f	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR table$[rsp+8], 0
  00048	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR table$[rsp+16], 0
  00051	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR table$[rsp+24], 0
  0005a	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR table$[rsp+32], 0
  00063	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR table$[rsp+40], 0
  0006c	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR table$[rsp+48], 0
  00075	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR table$[rsp+56], 0
  0007e	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+64], 0
  0008a	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+72], 0
  00096	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+80], 0
  000a2	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+88], 0
  000ae	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+96], 0
  000ba	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+104], 0
  000c6	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+112], 0
  000d2	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+120], 0

; 3805 :                                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

  000de	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+128], 0
  000ea	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+136], 0
  000f6	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+144], 0
  00102	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+152], 0
  0010e	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+160], 0
  0011a	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+168], 0
  00126	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+176], 0
  00132	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+184], 0
  0013e	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+192], 0
  0014a	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+200], 0
  00156	48 c7 84 24 10
	01 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+208], 0
  00162	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+216], 0
  0016e	48 c7 84 24 20
	01 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+224], 0
  0017a	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+232], 0
  00186	48 c7 84 24 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+240], 0
  00192	48 c7 84 24 38
	01 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp+248], 0
$LN152@long_pow:

; 3806 : 
; 3807 :     /* a, b, c = v, w, x */
; 3808 :     CHECK_BINOP(v, w);

  0019e	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  001a6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001aa	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001b0	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  001b5	85 c0		 test	 eax, eax
  001b7	74 1b		 je	 SHORT $LN148@long_pow
  001b9	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR w$[rsp]
  001c1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001c5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001cb	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  001d0	85 c0		 test	 eax, eax
  001d2	75 18		 jne	 SHORT $LN149@long_pow
$LN148@long_pow:
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  001db	e8 00 00 00 00	 call	 _Py_IncRef
  001e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  001e7	e9 73 0a 00 00	 jmp	 $LN153@long_pow
$LN149@long_pow:
  001ec	33 c0		 xor	 eax, eax
  001ee	85 c0		 test	 eax, eax
  001f0	75 ac		 jne	 SHORT $LN152@long_pow

; 3809 :     a = (PyLongObject*)v; Py_INCREF(a);

  001f2	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  001fa	48 89 44 24 20	 mov	 QWORD PTR a$[rsp], rax
  001ff	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  00204	e8 00 00 00 00	 call	 _Py_IncRef

; 3810 :     b = (PyLongObject*)w; Py_INCREF(b);

  00209	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00211	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR b$[rsp], rax
  00219	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00221	e8 00 00 00 00	 call	 _Py_IncRef

; 3811 :     if (PyLong_Check(x)) {

  00226	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0022e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00232	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00238	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0023d	85 c0		 test	 eax, eax
  0023f	74 1f		 je	 SHORT $LN147@long_pow

; 3812 :         c = (PyLongObject *)x;

  00241	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00249	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR c$[rsp], rax

; 3813 :         Py_INCREF(x);

  00251	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  00259	e8 00 00 00 00	 call	 _Py_IncRef
  0025e	eb 4e		 jmp	 SHORT $LN146@long_pow
$LN147@long_pow:

; 3814 :     }
; 3815 :     else if (x == Py_None)

  00260	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00267	48 39 84 24 b0
	01 00 00	 cmp	 QWORD PTR x$[rsp], rax
  0026f	75 0e		 jne	 SHORT $LN145@long_pow

; 3816 :         c = NULL;

  00271	48 c7 84 24 60
	01 00 00 00 00
	00 00		 mov	 QWORD PTR c$[rsp], 0

; 3817 :     else {

  0027d	eb 2f		 jmp	 SHORT $LN144@long_pow
$LN145@long_pow:

; 3818 :         Py_DECREF(a);

  0027f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  00284	e8 00 00 00 00	 call	 _Py_DecRef

; 3819 :         Py_DECREF(b);

  00289	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00291	e8 00 00 00 00	 call	 _Py_DecRef

; 3820 :         Py_RETURN_NOTIMPLEMENTED;

  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0029d	e8 00 00 00 00	 call	 _Py_IncRef
  002a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  002a9	e9 b1 09 00 00	 jmp	 $LN153@long_pow
$LN144@long_pow:
$LN146@long_pow:

; 3821 :     }
; 3822 : 
; 3823 :     if (Py_SIZE(b) < 0) {  /* if exponent is negative */

  002ae	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR b$[rsp]
  002b6	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  002bb	7d 63		 jge	 SHORT $LN143@long_pow

; 3824 :         if (c) {

  002bd	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR c$[rsp], 0
  002c6	74 1a		 je	 SHORT $LN142@long_pow

; 3825 :             PyErr_SetString(PyExc_TypeError, "pow() 2nd argument "
; 3826 :                             "cannot be negative when 3rd argument specified");

  002c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@HKEPHICC@pow?$CI?$CJ?52nd?5argument?5cannot?5be?5neg@
  002cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002d6	e8 00 00 00 00	 call	 PyErr_SetString

; 3827 :             goto Error;

  002db	e9 b3 08 00 00	 jmp	 $Error$23606

; 3828 :         }
; 3829 :         else {

  002e0	eb 3e		 jmp	 SHORT $LN141@long_pow
$LN142@long_pow:

; 3830 :             /* else return a float.  This works because we know
; 3831 :                that this calls float_pow() which converts its
; 3832 :                arguments to double. */
; 3833 :             Py_DECREF(a);

  002e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  002e7	e8 00 00 00 00	 call	 _Py_DecRef

; 3834 :             Py_DECREF(b);

  002ec	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  002f4	e8 00 00 00 00	 call	 _Py_DecRef

; 3835 :             return PyFloat_Type.tp_as_number->nb_power(v, w, x);

  002f9	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR x$[rsp]
  00301	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR w$[rsp]
  00309	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00311	48 8b 05 b8 00
	00 00		 mov	 rax, QWORD PTR PyFloat_Type+184
  00318	ff 50 28	 call	 QWORD PTR [rax+40]
  0031b	e9 3f 09 00 00	 jmp	 $LN153@long_pow
$LN141@long_pow:
$LN143@long_pow:

; 3836 :         }
; 3837 :     }
; 3838 : 
; 3839 :     if (c) {

  00320	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR c$[rsp], 0
  00329	0f 84 ea 01 00
	00		 je	 $LN140@long_pow

; 3840 :         /* if modulus == 0:
; 3841 :                raise ValueError() */
; 3842 :         if (Py_SIZE(c) == 0) {

  0032f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00337	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0033c	75 18		 jne	 SHORT $LN139@long_pow

; 3843 :             PyErr_SetString(PyExc_ValueError,
; 3844 :                             "pow() 3rd argument cannot be 0");

  0033e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@OLNKGOFI@pow?$CI?$CJ?53rd?5argument?5cannot?5be?50?$AA@
  00345	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0034c	e8 00 00 00 00	 call	 PyErr_SetString

; 3845 :             goto Error;

  00351	e9 3d 08 00 00	 jmp	 $Error$23606
$LN139@long_pow:

; 3846 :         }
; 3847 : 
; 3848 :         /* if modulus < 0:
; 3849 :                negativeOutput = True
; 3850 :                modulus = -modulus */
; 3851 :         if (Py_SIZE(c) < 0) {

  00356	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0035e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00363	0f 8d 1c 01 00
	00		 jge	 $LN138@long_pow

; 3852 :             negativeOutput = 1;

  00369	c7 84 24 58 01
	00 00 01 00 00
	00		 mov	 DWORD PTR negativeOutput$[rsp], 1

; 3853 :             temp = (PyLongObject *)_PyLong_Copy(c);

  00374	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0037c	e8 00 00 00 00	 call	 _PyLong_Copy
  00381	48 89 44 24 30	 mov	 QWORD PTR temp$[rsp], rax

; 3854 :             if (temp == NULL)

  00386	48 83 7c 24 30
	00		 cmp	 QWORD PTR temp$[rsp], 0
  0038c	75 05		 jne	 SHORT $LN137@long_pow

; 3855 :                 goto Error;

  0038e	e9 00 08 00 00	 jmp	 $Error$23606
$LN137@long_pow:

; 3856 :             Py_DECREF(c);

  00393	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0039b	e8 00 00 00 00	 call	 _Py_DecRef

; 3857 :             c = temp;

  003a0	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  003a5	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR c$[rsp], rax

; 3858 :             temp = NULL;

  003ad	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN136@long_pow:

; 3859 :             NEGATE(c);

  003b6	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  003be	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  003c3	75 20		 jne	 SHORT $LN133@long_pow
  003c5	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  003cd	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  003d1	48 f7 d8	 neg	 rax
  003d4	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003dc	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  003e0	e9 96 00 00 00	 jmp	 $LN132@long_pow
$LN133@long_pow:
  003e5	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  003ed	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  003f2	7d 16		 jge	 SHORT $LN157@long_pow
  003f4	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  003fc	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003ff	f7 d8		 neg	 eax
  00401	89 84 24 84 01
	00 00		 mov	 DWORD PTR tv220[rsp], eax
  00408	eb 3c		 jmp	 SHORT $LN158@long_pow
$LN157@long_pow:
  0040a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00412	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00417	75 0d		 jne	 SHORT $LN155@long_pow
  00419	c7 84 24 88 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv219[rsp], 0
  00424	eb 12		 jmp	 SHORT $LN156@long_pow
$LN155@long_pow:
  00426	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0042e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00431	89 84 24 88 01
	00 00		 mov	 DWORD PTR tv219[rsp], eax
$LN156@long_pow:
  00438	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR tv219[rsp]
  0043f	89 84 24 84 01
	00 00		 mov	 DWORD PTR tv220[rsp], eax
$LN158@long_pow:
  00446	8b 84 24 84 01
	00 00		 mov	 eax, DWORD PTR tv220[rsp]
  0044d	f7 d8		 neg	 eax
  0044f	8b c8		 mov	 ecx, eax
  00451	e8 00 00 00 00	 call	 PyLong_FromLong
  00456	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tmp$23629[rsp], rax
  0045e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00466	e8 00 00 00 00	 call	 _Py_DecRef
  0046b	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR tmp$23629[rsp]
  00473	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR c$[rsp], rax
$LN132@long_pow:
  0047b	33 c0		 xor	 eax, eax
  0047d	85 c0		 test	 eax, eax
  0047f	0f 85 31 ff ff
	ff		 jne	 $LN136@long_pow
$LN138@long_pow:

; 3860 :         }
; 3861 : 
; 3862 :         /* if modulus == 1:
; 3863 :                return 0 */
; 3864 :         if ((Py_SIZE(c) == 1) && (c->ob_digit[0] == 1)) {

  00485	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0048d	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  00492	75 22		 jne	 SHORT $LN131@long_pow
  00494	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0049c	83 78 70 01	 cmp	 DWORD PTR [rax+112], 1
  004a0	75 14		 jne	 SHORT $LN131@long_pow

; 3865 :             z = (PyLongObject *)PyLong_FromLong(0L);

  004a2	33 c9		 xor	 ecx, ecx
  004a4	e8 00 00 00 00	 call	 PyLong_FromLong
  004a9	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax

; 3866 :             goto Done;

  004b1	e9 01 07 00 00	 jmp	 $Done$23640
$LN131@long_pow:

; 3867 :         }
; 3868 : 
; 3869 :         /* Reduce base by modulus in some cases:
; 3870 :            1. If base < 0.  Forcing the base non-negative makes things easier.
; 3871 :            2. If base is obviously larger than the modulus.  The "small
; 3872 :               exponent" case later can multiply directly by base repeatedly,
; 3873 :               while the "large exponent" case multiplies directly by base 31
; 3874 :               times.  It can be unboundedly faster to multiply by
; 3875 :               base % modulus instead.
; 3876 :            We could _always_ do this reduction, but l_divmod() isn't cheap,
; 3877 :            so we only do it when it buys something. */
; 3878 :         if (Py_SIZE(a) < 0 || Py_SIZE(a) > Py_SIZE(c)) {

  004b6	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  004bb	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  004c0	7c 17		 jl	 SHORT $LN129@long_pow
  004c2	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  004c7	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  004cf	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  004d3	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  004d7	7e 40		 jle	 SHORT $LN130@long_pow
$LN129@long_pow:

; 3879 :             if (l_divmod(a, c, NULL, &temp) < 0)

  004d9	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  004de	45 33 c0	 xor	 r8d, r8d
  004e1	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  004e9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  004ee	e8 00 00 00 00	 call	 l_divmod
  004f3	85 c0		 test	 eax, eax
  004f5	7d 05		 jge	 SHORT $LN128@long_pow

; 3880 :                 goto Error;

  004f7	e9 97 06 00 00	 jmp	 $Error$23606
$LN128@long_pow:

; 3881 :             Py_DECREF(a);

  004fc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  00501	e8 00 00 00 00	 call	 _Py_DecRef

; 3882 :             a = temp;

  00506	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  0050b	48 89 44 24 20	 mov	 QWORD PTR a$[rsp], rax

; 3883 :             temp = NULL;

  00510	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN130@long_pow:
$LN140@long_pow:

; 3884 :         }
; 3885 :     }
; 3886 : 
; 3887 :     /* At this point a, b, and c are guaranteed non-negative UNLESS
; 3888 :        c is NULL, in which case a may be negative. */
; 3889 : 
; 3890 :     z = (PyLongObject *)PyLong_FromLong(1L);

  00519	b9 01 00 00 00	 mov	 ecx, 1
  0051e	e8 00 00 00 00	 call	 PyLong_FromLong
  00523	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax

; 3891 :     if (z == NULL)

  0052b	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR z$[rsp], 0
  00534	75 05		 jne	 SHORT $LN127@long_pow

; 3892 :         goto Error;

  00536	e9 58 06 00 00	 jmp	 $Error$23606
$LN127@long_pow:

; 3893 : 
; 3894 :     /* Perform a modular reduction, X = X % c, but leave X alone if c
; 3895 :      * is NULL.
; 3896 :      */
; 3897 : #define REDUCE(X)                                       \
; 3898 :     do {                                                \
; 3899 :         if (c != NULL) {                                \
; 3900 :             if (l_divmod(X, c, NULL, &temp) < 0)        \
; 3901 :                 goto Error;                             \
; 3902 :             Py_XDECREF(X);                              \
; 3903 :             X = temp;                                   \
; 3904 :             temp = NULL;                                \
; 3905 :         }                                               \
; 3906 :     } while(0)
; 3907 : 
; 3908 :     /* Multiply two values, then reduce the result:
; 3909 :        result = X*Y % c.  If c is NULL, skip the mod. */
; 3910 : #define MULT(X, Y, result)                      \
; 3911 :     do {                                        \
; 3912 :         temp = (PyLongObject *)long_mul(X, Y);  \
; 3913 :         if (temp == NULL)                       \
; 3914 :             goto Error;                         \
; 3915 :         Py_XDECREF(result);                     \
; 3916 :         result = temp;                          \
; 3917 :         temp = NULL;                            \
; 3918 :         REDUCE(result);                         \
; 3919 :     } while(0)
; 3920 : 
; 3921 :     if (Py_SIZE(b) <= FIVEARY_CUTOFF) {

  0053b	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00543	48 83 78 60 08	 cmp	 QWORD PTR [rax+96], 8
  00548	0f 8f 3b 02 00
	00		 jg	 $LN126@long_pow

; 3922 :         /* Left-to-right binary exponentiation (HAC Algorithm 14.79) */
; 3923 :         /* http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf    */
; 3924 :         for (i = Py_SIZE(b) - 1; i >= 0; --i) {

  0054e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00556	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0055a	48 ff c8	 dec	 rax
  0055d	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00562	eb 0d		 jmp	 SHORT $LN125@long_pow
$LN124@long_pow:
  00564	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00569	48 ff c8	 dec	 rax
  0056c	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN125@long_pow:
  00571	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00577	0f 8c 07 02 00
	00		 jl	 $LN123@long_pow

; 3925 :             digit bi = b->ob_digit[i];

  0057d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00585	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0058a	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  0058e	89 84 24 78 01
	00 00		 mov	 DWORD PTR bi$23661[rsp], eax

; 3926 : 
; 3927 :             for (j = (digit)1 << (PyLong_SHIFT-1); j != 0; j >>= 1) {

  00595	48 c7 84 24 68
	01 00 00 00 00
	00 20		 mov	 QWORD PTR j$[rsp], 536870912 ; 20000000H
  005a1	eb 13		 jmp	 SHORT $LN122@long_pow
$LN121@long_pow:
  005a3	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  005ab	48 d1 f8	 sar	 rax, 1
  005ae	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR j$[rsp], rax
$LN122@long_pow:
  005b6	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR j$[rsp], 0
  005bf	0f 84 ba 01 00
	00		 je	 $LN120@long_pow
$LN119@long_pow:

; 3928 :                 MULT(z, z, z);

  005c5	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  005cd	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  005d5	e8 00 00 00 00	 call	 long_mul
  005da	48 89 44 24 30	 mov	 QWORD PTR temp$[rsp], rax
  005df	48 83 7c 24 30
	00		 cmp	 QWORD PTR temp$[rsp], 0
  005e5	75 05		 jne	 SHORT $LN116@long_pow
  005e7	e9 a7 05 00 00	 jmp	 $Error$23606
$LN116@long_pow:
$LN115@long_pow:
  005ec	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR z$[rsp], 0
  005f5	74 0d		 je	 SHORT $LN112@long_pow
  005f7	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  005ff	e8 00 00 00 00	 call	 _Py_DecRef
$LN112@long_pow:
  00604	33 c0		 xor	 eax, eax
  00606	85 c0		 test	 eax, eax
  00608	75 e2		 jne	 SHORT $LN115@long_pow
  0060a	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  0060f	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax
  00617	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN111@long_pow:
  00620	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR c$[rsp], 0
  00629	74 5a		 je	 SHORT $LN108@long_pow
  0062b	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  00630	45 33 c0	 xor	 r8d, r8d
  00633	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  0063b	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00643	e8 00 00 00 00	 call	 l_divmod
  00648	85 c0		 test	 eax, eax
  0064a	7d 05		 jge	 SHORT $LN107@long_pow
  0064c	e9 42 05 00 00	 jmp	 $Error$23606
$LN107@long_pow:
$LN106@long_pow:
  00651	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR z$[rsp], 0
  0065a	74 0d		 je	 SHORT $LN103@long_pow
  0065c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00664	e8 00 00 00 00	 call	 _Py_DecRef
$LN103@long_pow:
  00669	33 c0		 xor	 eax, eax
  0066b	85 c0		 test	 eax, eax
  0066d	75 e2		 jne	 SHORT $LN106@long_pow
  0066f	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  00674	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax
  0067c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN108@long_pow:
  00685	33 c0		 xor	 eax, eax
  00687	85 c0		 test	 eax, eax
  00689	75 95		 jne	 SHORT $LN111@long_pow
  0068b	33 c0		 xor	 eax, eax
  0068d	85 c0		 test	 eax, eax
  0068f	0f 85 30 ff ff
	ff		 jne	 $LN119@long_pow

; 3929 :                 if (bi & j)

  00695	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR bi$23661[rsp]
  0069c	48 23 84 24 68
	01 00 00	 and	 rax, QWORD PTR j$[rsp]
  006a4	48 85 c0	 test	 rax, rax
  006a7	0f 84 cd 00 00
	00		 je	 $LN102@long_pow
$LN101@long_pow:

; 3930 :                     MULT(z, a, z);

  006ad	48 8b 54 24 20	 mov	 rdx, QWORD PTR a$[rsp]
  006b2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006ba	e8 00 00 00 00	 call	 long_mul
  006bf	48 89 44 24 30	 mov	 QWORD PTR temp$[rsp], rax
  006c4	48 83 7c 24 30
	00		 cmp	 QWORD PTR temp$[rsp], 0
  006ca	75 05		 jne	 SHORT $LN98@long_pow
  006cc	e9 c2 04 00 00	 jmp	 $Error$23606
$LN98@long_pow:
$LN97@long_pow:
  006d1	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR z$[rsp], 0
  006da	74 0d		 je	 SHORT $LN94@long_pow
  006dc	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006e4	e8 00 00 00 00	 call	 _Py_DecRef
$LN94@long_pow:
  006e9	33 c0		 xor	 eax, eax
  006eb	85 c0		 test	 eax, eax
  006ed	75 e2		 jne	 SHORT $LN97@long_pow
  006ef	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  006f4	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax
  006fc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN93@long_pow:
  00705	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR c$[rsp], 0
  0070e	74 5a		 je	 SHORT $LN90@long_pow
  00710	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  00715	45 33 c0	 xor	 r8d, r8d
  00718	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00720	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00728	e8 00 00 00 00	 call	 l_divmod
  0072d	85 c0		 test	 eax, eax
  0072f	7d 05		 jge	 SHORT $LN89@long_pow
  00731	e9 5d 04 00 00	 jmp	 $Error$23606
$LN89@long_pow:
$LN88@long_pow:
  00736	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR z$[rsp], 0
  0073f	74 0d		 je	 SHORT $LN85@long_pow
  00741	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00749	e8 00 00 00 00	 call	 _Py_DecRef
$LN85@long_pow:
  0074e	33 c0		 xor	 eax, eax
  00750	85 c0		 test	 eax, eax
  00752	75 e2		 jne	 SHORT $LN88@long_pow
  00754	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  00759	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax
  00761	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN90@long_pow:
  0076a	33 c0		 xor	 eax, eax
  0076c	85 c0		 test	 eax, eax
  0076e	75 95		 jne	 SHORT $LN93@long_pow
  00770	33 c0		 xor	 eax, eax
  00772	85 c0		 test	 eax, eax
  00774	0f 85 33 ff ff
	ff		 jne	 $LN101@long_pow
$LN102@long_pow:

; 3931 :             }

  0077a	e9 24 fe ff ff	 jmp	 $LN121@long_pow
$LN120@long_pow:

; 3932 :         }

  0077f	e9 e0 fd ff ff	 jmp	 $LN124@long_pow
$LN123@long_pow:

; 3933 :     }
; 3934 :     else {

  00784	e9 a8 03 00 00	 jmp	 $LN84@long_pow
$LN126@long_pow:

; 3935 :         /* Left-to-right 5-ary exponentiation (HAC Algorithm 14.82) */
; 3936 :         Py_INCREF(z);           /* still holds 1L */

  00789	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00791	e8 00 00 00 00	 call	 _Py_IncRef

; 3937 :         table[0] = z;

  00796	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0079e	48 89 44 24 40	 mov	 QWORD PTR table$[rsp], rax

; 3938 :         for (i = 1; i < 32; ++i)

  007a3	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR i$[rsp], 1
  007ac	eb 0d		 jmp	 SHORT $LN83@long_pow
$LN82@long_pow:
  007ae	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  007b3	48 ff c0	 inc	 rax
  007b6	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN83@long_pow:
  007bb	48 83 7c 24 28
	20		 cmp	 QWORD PTR i$[rsp], 32	; 00000020H
  007c1	0f 8d e2 00 00
	00		 jge	 $LN81@long_pow
$LN80@long_pow:

; 3939 :             MULT(table[i-1], a, table[i]);

  007c7	48 8b 54 24 20	 mov	 rdx, QWORD PTR a$[rsp]
  007cc	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  007d1	48 8b 4c c4 38	 mov	 rcx, QWORD PTR table$[rsp+rax*8-8]
  007d6	e8 00 00 00 00	 call	 long_mul
  007db	48 89 44 24 30	 mov	 QWORD PTR temp$[rsp], rax
  007e0	48 83 7c 24 30
	00		 cmp	 QWORD PTR temp$[rsp], 0
  007e6	75 05		 jne	 SHORT $LN77@long_pow
  007e8	e9 a6 03 00 00	 jmp	 $Error$23606
$LN77@long_pow:
$LN76@long_pow:
  007ed	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  007f2	48 83 7c c4 40
	00		 cmp	 QWORD PTR table$[rsp+rax*8], 0
  007f8	74 0f		 je	 SHORT $LN73@long_pow
  007fa	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  007ff	48 8b 4c c4 40	 mov	 rcx, QWORD PTR table$[rsp+rax*8]
  00804	e8 00 00 00 00	 call	 _Py_DecRef
$LN73@long_pow:
  00809	33 c0		 xor	 eax, eax
  0080b	85 c0		 test	 eax, eax
  0080d	75 de		 jne	 SHORT $LN76@long_pow
  0080f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00814	48 8b 4c 24 30	 mov	 rcx, QWORD PTR temp$[rsp]
  00819	48 89 4c c4 40	 mov	 QWORD PTR table$[rsp+rax*8], rcx
  0081e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN72@long_pow:
  00827	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR c$[rsp], 0
  00830	74 62		 je	 SHORT $LN69@long_pow
  00832	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  00837	45 33 c0	 xor	 r8d, r8d
  0083a	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00842	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00847	48 8b 4c c4 40	 mov	 rcx, QWORD PTR table$[rsp+rax*8]
  0084c	e8 00 00 00 00	 call	 l_divmod
  00851	85 c0		 test	 eax, eax
  00853	7d 05		 jge	 SHORT $LN68@long_pow
  00855	e9 39 03 00 00	 jmp	 $Error$23606
$LN68@long_pow:
$LN67@long_pow:
  0085a	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0085f	48 83 7c c4 40
	00		 cmp	 QWORD PTR table$[rsp+rax*8], 0
  00865	74 0f		 je	 SHORT $LN64@long_pow
  00867	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0086c	48 8b 4c c4 40	 mov	 rcx, QWORD PTR table$[rsp+rax*8]
  00871	e8 00 00 00 00	 call	 _Py_DecRef
$LN64@long_pow:
  00876	33 c0		 xor	 eax, eax
  00878	85 c0		 test	 eax, eax
  0087a	75 de		 jne	 SHORT $LN67@long_pow
  0087c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00881	48 8b 4c 24 30	 mov	 rcx, QWORD PTR temp$[rsp]
  00886	48 89 4c c4 40	 mov	 QWORD PTR table$[rsp+rax*8], rcx
  0088b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN69@long_pow:
  00894	33 c0		 xor	 eax, eax
  00896	85 c0		 test	 eax, eax
  00898	75 8d		 jne	 SHORT $LN72@long_pow
  0089a	33 c0		 xor	 eax, eax
  0089c	85 c0		 test	 eax, eax
  0089e	0f 85 23 ff ff
	ff		 jne	 $LN80@long_pow
  008a4	e9 05 ff ff ff	 jmp	 $LN82@long_pow
$LN81@long_pow:

; 3940 : 
; 3941 :         for (i = Py_SIZE(b) - 1; i >= 0; --i) {

  008a9	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR b$[rsp]
  008b1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  008b5	48 ff c8	 dec	 rax
  008b8	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  008bd	eb 0d		 jmp	 SHORT $LN63@long_pow
$LN62@long_pow:
  008bf	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  008c4	48 ff c8	 dec	 rax
  008c7	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN63@long_pow:
  008cc	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  008d2	0f 8c 59 02 00
	00		 jl	 $LN61@long_pow

; 3942 :             const digit bi = b->ob_digit[i];

  008d8	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR b$[rsp]
  008e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  008e5	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  008e9	89 84 24 7c 01
	00 00		 mov	 DWORD PTR bi$23751[rsp], eax

; 3943 : 
; 3944 :             for (j = PyLong_SHIFT - 5; j >= 0; j -= 5) {

  008f0	48 c7 84 24 68
	01 00 00 19 00
	00 00		 mov	 QWORD PTR j$[rsp], 25
  008fc	eb 14		 jmp	 SHORT $LN60@long_pow
$LN59@long_pow:
  008fe	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00906	48 83 e8 05	 sub	 rax, 5
  0090a	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR j$[rsp], rax
$LN60@long_pow:
  00912	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR j$[rsp], 0
  0091b	0f 8c 0b 02 00
	00		 jl	 $LN58@long_pow

; 3945 :                 const int index = (bi >> j) & 0x1f;

  00921	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00929	0f b6 c8	 movzx	 ecx, al
  0092c	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR bi$23751[rsp]
  00933	d3 e8		 shr	 eax, cl
  00935	83 e0 1f	 and	 eax, 31
  00938	89 84 24 80 01
	00 00		 mov	 DWORD PTR index$23755[rsp], eax

; 3946 :                 for (k = 0; k < 5; ++k)

  0093f	48 c7 84 24 48
	01 00 00 00 00
	00 00		 mov	 QWORD PTR k$[rsp], 0
  0094b	eb 13		 jmp	 SHORT $LN57@long_pow
$LN56@long_pow:
  0094d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR k$[rsp]
  00955	48 ff c0	 inc	 rax
  00958	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR k$[rsp], rax
$LN57@long_pow:
  00960	48 83 bc 24 48
	01 00 00 05	 cmp	 QWORD PTR k$[rsp], 5
  00969	0f 8d d5 00 00
	00		 jge	 $LN55@long_pow
$LN54@long_pow:

; 3947 :                     MULT(z, z, z);

  0096f	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00977	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0097f	e8 00 00 00 00	 call	 long_mul
  00984	48 89 44 24 30	 mov	 QWORD PTR temp$[rsp], rax
  00989	48 83 7c 24 30
	00		 cmp	 QWORD PTR temp$[rsp], 0
  0098f	75 05		 jne	 SHORT $LN51@long_pow
  00991	e9 fd 01 00 00	 jmp	 $Error$23606
$LN51@long_pow:
$LN50@long_pow:
  00996	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR z$[rsp], 0
  0099f	74 0d		 je	 SHORT $LN47@long_pow
  009a1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  009a9	e8 00 00 00 00	 call	 _Py_DecRef
$LN47@long_pow:
  009ae	33 c0		 xor	 eax, eax
  009b0	85 c0		 test	 eax, eax
  009b2	75 e2		 jne	 SHORT $LN50@long_pow
  009b4	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  009b9	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax
  009c1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN46@long_pow:
  009ca	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR c$[rsp], 0
  009d3	74 5a		 je	 SHORT $LN43@long_pow
  009d5	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  009da	45 33 c0	 xor	 r8d, r8d
  009dd	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  009e5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  009ed	e8 00 00 00 00	 call	 l_divmod
  009f2	85 c0		 test	 eax, eax
  009f4	7d 05		 jge	 SHORT $LN42@long_pow
  009f6	e9 98 01 00 00	 jmp	 $Error$23606
$LN42@long_pow:
$LN41@long_pow:
  009fb	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR z$[rsp], 0
  00a04	74 0d		 je	 SHORT $LN38@long_pow
  00a06	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a0e	e8 00 00 00 00	 call	 _Py_DecRef
$LN38@long_pow:
  00a13	33 c0		 xor	 eax, eax
  00a15	85 c0		 test	 eax, eax
  00a17	75 e2		 jne	 SHORT $LN41@long_pow
  00a19	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  00a1e	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax
  00a26	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN43@long_pow:
  00a2f	33 c0		 xor	 eax, eax
  00a31	85 c0		 test	 eax, eax
  00a33	75 95		 jne	 SHORT $LN46@long_pow
  00a35	33 c0		 xor	 eax, eax
  00a37	85 c0		 test	 eax, eax
  00a39	0f 85 30 ff ff
	ff		 jne	 $LN54@long_pow
  00a3f	e9 09 ff ff ff	 jmp	 $LN56@long_pow
$LN55@long_pow:

; 3948 :                 if (index)

  00a44	83 bc 24 80 01
	00 00 00	 cmp	 DWORD PTR index$23755[rsp], 0
  00a4c	0f 84 d5 00 00
	00		 je	 $LN37@long_pow
$LN36@long_pow:

; 3949 :                     MULT(z, table[index], z);

  00a52	48 63 84 24 80
	01 00 00	 movsxd	 rax, DWORD PTR index$23755[rsp]
  00a5a	48 8b 54 c4 40	 mov	 rdx, QWORD PTR table$[rsp+rax*8]
  00a5f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a67	e8 00 00 00 00	 call	 long_mul
  00a6c	48 89 44 24 30	 mov	 QWORD PTR temp$[rsp], rax
  00a71	48 83 7c 24 30
	00		 cmp	 QWORD PTR temp$[rsp], 0
  00a77	75 05		 jne	 SHORT $LN33@long_pow
  00a79	e9 15 01 00 00	 jmp	 $Error$23606
$LN33@long_pow:
$LN32@long_pow:
  00a7e	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR z$[rsp], 0
  00a87	74 0d		 je	 SHORT $LN29@long_pow
  00a89	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a91	e8 00 00 00 00	 call	 _Py_DecRef
$LN29@long_pow:
  00a96	33 c0		 xor	 eax, eax
  00a98	85 c0		 test	 eax, eax
  00a9a	75 e2		 jne	 SHORT $LN32@long_pow
  00a9c	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  00aa1	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax
  00aa9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN28@long_pow:
  00ab2	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR c$[rsp], 0
  00abb	74 5a		 je	 SHORT $LN25@long_pow
  00abd	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  00ac2	45 33 c0	 xor	 r8d, r8d
  00ac5	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00acd	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00ad5	e8 00 00 00 00	 call	 l_divmod
  00ada	85 c0		 test	 eax, eax
  00adc	7d 05		 jge	 SHORT $LN24@long_pow
  00ade	e9 b0 00 00 00	 jmp	 $Error$23606
$LN24@long_pow:
$LN23@long_pow:
  00ae3	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR z$[rsp], 0
  00aec	74 0d		 je	 SHORT $LN20@long_pow
  00aee	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00af6	e8 00 00 00 00	 call	 _Py_DecRef
$LN20@long_pow:
  00afb	33 c0		 xor	 eax, eax
  00afd	85 c0		 test	 eax, eax
  00aff	75 e2		 jne	 SHORT $LN23@long_pow
  00b01	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  00b06	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax
  00b0e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN25@long_pow:
  00b17	33 c0		 xor	 eax, eax
  00b19	85 c0		 test	 eax, eax
  00b1b	75 95		 jne	 SHORT $LN28@long_pow
  00b1d	33 c0		 xor	 eax, eax
  00b1f	85 c0		 test	 eax, eax
  00b21	0f 85 2b ff ff
	ff		 jne	 $LN36@long_pow
$LN37@long_pow:

; 3950 :             }

  00b27	e9 d2 fd ff ff	 jmp	 $LN59@long_pow
$LN58@long_pow:

; 3951 :         }

  00b2c	e9 8e fd ff ff	 jmp	 $LN62@long_pow
$LN61@long_pow:
$LN84@long_pow:

; 3952 :     }
; 3953 : 
; 3954 :     if (negativeOutput && (Py_SIZE(z) != 0)) {

  00b31	83 bc 24 58 01
	00 00 00	 cmp	 DWORD PTR negativeOutput$[rsp], 0
  00b39	74 56		 je	 SHORT $LN19@long_pow
  00b3b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00b43	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00b48	74 47		 je	 SHORT $LN19@long_pow

; 3955 :         temp = (PyLongObject *)long_sub(z, c);

  00b4a	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00b52	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b5a	e8 00 00 00 00	 call	 long_sub
  00b5f	48 89 44 24 30	 mov	 QWORD PTR temp$[rsp], rax

; 3956 :         if (temp == NULL)

  00b64	48 83 7c 24 30
	00		 cmp	 QWORD PTR temp$[rsp], 0
  00b6a	75 02		 jne	 SHORT $LN18@long_pow

; 3957 :             goto Error;

  00b6c	eb 25		 jmp	 SHORT $Error$23606
$LN18@long_pow:

; 3958 :         Py_DECREF(z);

  00b6e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b76	e8 00 00 00 00	 call	 _Py_DecRef

; 3959 :         z = temp;

  00b7b	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  00b80	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR z$[rsp], rax

; 3960 :         temp = NULL;

  00b88	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR temp$[rsp], 0
$LN19@long_pow:

; 3961 :     }
; 3962 :     goto Done;

  00b91	eb 24		 jmp	 SHORT $Done$23640
$Error$23606:

; 3963 : 
; 3964 :   Error:
; 3965 :     if (z != NULL) {

  00b93	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR z$[rsp], 0
  00b9c	74 19		 je	 SHORT $LN17@long_pow

; 3966 :         Py_DECREF(z);

  00b9e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00ba6	e8 00 00 00 00	 call	 _Py_DecRef

; 3967 :         z = NULL;

  00bab	48 c7 84 24 50
	01 00 00 00 00
	00 00		 mov	 QWORD PTR z$[rsp], 0
$LN17@long_pow:
$Done$23640:

; 3968 :     }
; 3969 :     /* fall through */
; 3970 :   Done:
; 3971 :     if (Py_SIZE(b) > FIVEARY_CUTOFF) {

  00bb7	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00bbf	48 83 78 60 08	 cmp	 QWORD PTR [rax+96], 8
  00bc4	7e 44		 jle	 SHORT $LN16@long_pow

; 3972 :         for (i = 0; i < 32; ++i)

  00bc6	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00bcf	eb 0d		 jmp	 SHORT $LN15@long_pow
$LN14@long_pow:
  00bd1	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00bd6	48 ff c0	 inc	 rax
  00bd9	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN15@long_pow:
  00bde	48 83 7c 24 28
	20		 cmp	 QWORD PTR i$[rsp], 32	; 00000020H
  00be4	7d 24		 jge	 SHORT $LN13@long_pow
$LN12@long_pow:

; 3973 :             Py_XDECREF(table[i]);

  00be6	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00beb	48 83 7c c4 40
	00		 cmp	 QWORD PTR table$[rsp+rax*8], 0
  00bf1	74 0f		 je	 SHORT $LN9@long_pow
  00bf3	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00bf8	48 8b 4c c4 40	 mov	 rcx, QWORD PTR table$[rsp+rax*8]
  00bfd	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@long_pow:
  00c02	33 c0		 xor	 eax, eax
  00c04	85 c0		 test	 eax, eax
  00c06	75 de		 jne	 SHORT $LN12@long_pow
  00c08	eb c7		 jmp	 SHORT $LN14@long_pow
$LN13@long_pow:
$LN16@long_pow:

; 3974 :     }
; 3975 :     Py_DECREF(a);

  00c0a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  00c0f	e8 00 00 00 00	 call	 _Py_DecRef

; 3976 :     Py_DECREF(b);

  00c14	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00c1c	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@long_pow:

; 3977 :     Py_XDECREF(c);

  00c21	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR c$[rsp], 0
  00c2a	74 0d		 je	 SHORT $LN5@long_pow
  00c2c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00c34	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@long_pow:
  00c39	33 c0		 xor	 eax, eax
  00c3b	85 c0		 test	 eax, eax
  00c3d	75 e2		 jne	 SHORT $LN8@long_pow
$LN4@long_pow:

; 3978 :     Py_XDECREF(temp);

  00c3f	48 83 7c 24 30
	00		 cmp	 QWORD PTR temp$[rsp], 0
  00c45	74 0a		 je	 SHORT $LN1@long_pow
  00c47	48 8b 4c 24 30	 mov	 rcx, QWORD PTR temp$[rsp]
  00c4c	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@long_pow:
  00c51	33 c0		 xor	 eax, eax
  00c53	85 c0		 test	 eax, eax
  00c55	75 e8		 jne	 SHORT $LN4@long_pow

; 3979 :     return (PyObject *)z;

  00c57	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
$LN153@long_pow:

; 3980 : }

  00c5f	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00c66	c3		 ret	 0
long_pow ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_invert DD imagerel long_invert
	DD	imagerel long_invert+254
	DD	imagerel $unwind$long_invert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_invert DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_invert
_TEXT	SEGMENT
w$ = 32
x$ = 40
tv69 = 48
tv82 = 56
tv81 = 60
v$ = 80
long_invert PROC					; COMDAT

; 3984 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3985 :     /* Implement ~x as -(x+1) */
; 3986 :     PyLongObject *x;
; 3987 :     PyLongObject *w;
; 3988 :     if (ABS(Py_SIZE(v)) <=1)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	7d 13		 jge	 SHORT $LN6@long_inver
  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0001a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001e	48 f7 d8	 neg	 rax
  00021	48 89 44 24 30	 mov	 QWORD PTR tv69[rsp], rax
  00026	eb 0e		 jmp	 SHORT $LN7@long_inver
$LN6@long_inver:
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0002d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00031	48 89 44 24 30	 mov	 QWORD PTR tv69[rsp], rax
$LN7@long_inver:
  00036	48 83 7c 24 30
	01		 cmp	 QWORD PTR tv69[rsp], 1
  0003c	7f 57		 jg	 SHORT $LN3@long_inver

; 3989 :         return PyLong_FromLong(-(MEDIUM_VALUE(v)+1));

  0003e	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00043	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00048	7d 10		 jge	 SHORT $LN10@long_inver
  0004a	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0004f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00052	f7 d8		 neg	 eax
  00054	89 44 24 38	 mov	 DWORD PTR tv82[rsp], eax
  00058	eb 2a		 jmp	 SHORT $LN11@long_inver
$LN10@long_inver:
  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0005f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00064	75 0a		 jne	 SHORT $LN8@long_inver
  00066	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
  0006e	eb 0c		 jmp	 SHORT $LN9@long_inver
$LN8@long_inver:
  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00075	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00078	89 44 24 3c	 mov	 DWORD PTR tv81[rsp], eax
$LN9@long_inver:
  0007c	8b 44 24 3c	 mov	 eax, DWORD PTR tv81[rsp]
  00080	89 44 24 38	 mov	 DWORD PTR tv82[rsp], eax
$LN11@long_inver:
  00084	8b 44 24 38	 mov	 eax, DWORD PTR tv82[rsp]
  00088	ff c0		 inc	 eax
  0008a	f7 d8		 neg	 eax
  0008c	8b c8		 mov	 ecx, eax
  0008e	e8 00 00 00 00	 call	 PyLong_FromLong
  00093	eb 64		 jmp	 SHORT $LN4@long_inver
$LN3@long_inver:

; 3990 :     w = (PyLongObject *)PyLong_FromLong(1L);

  00095	b9 01 00 00 00	 mov	 ecx, 1
  0009a	e8 00 00 00 00	 call	 PyLong_FromLong
  0009f	48 89 44 24 20	 mov	 QWORD PTR w$[rsp], rax

; 3991 :     if (w == NULL)

  000a4	48 83 7c 24 20
	00		 cmp	 QWORD PTR w$[rsp], 0
  000aa	75 04		 jne	 SHORT $LN2@long_inver

; 3992 :         return NULL;

  000ac	33 c0		 xor	 eax, eax
  000ae	eb 49		 jmp	 SHORT $LN4@long_inver
$LN2@long_inver:

; 3993 :     x = (PyLongObject *) long_add(v, w);

  000b0	48 8b 54 24 20	 mov	 rdx, QWORD PTR w$[rsp]
  000b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000ba	e8 00 00 00 00	 call	 long_add
  000bf	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax

; 3994 :     Py_DECREF(w);

  000c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR w$[rsp]
  000c9	e8 00 00 00 00	 call	 _Py_DecRef

; 3995 :     if (x == NULL)

  000ce	48 83 7c 24 28
	00		 cmp	 QWORD PTR x$[rsp], 0
  000d4	75 04		 jne	 SHORT $LN1@long_inver

; 3996 :         return NULL;

  000d6	33 c0		 xor	 eax, eax
  000d8	eb 1f		 jmp	 SHORT $LN4@long_inver
$LN1@long_inver:

; 3997 :     Py_SIZE(x) = -(Py_SIZE(x));

  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  000df	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000e3	48 f7 d8	 neg	 rax
  000e6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  000eb	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 3998 :     return (PyObject *)maybe_small_long(x);

  000ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  000f4	e8 00 00 00 00	 call	 maybe_small_long
$LN4@long_inver:

; 3999 : }

  000f9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fd	c3		 ret	 0
long_invert ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_neg DD imagerel long_neg
	DD	imagerel long_neg+201
	DD	imagerel $unwind$long_neg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_neg DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_neg
_TEXT	SEGMENT
z$ = 32
tv69 = 40
tv82 = 48
tv81 = 52
v$ = 80
long_neg PROC						; COMDAT

; 4003 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4004 :     PyLongObject *z;
; 4005 :     if (ABS(Py_SIZE(v)) <= 1)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	7d 13		 jge	 SHORT $LN5@long_neg
  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0001a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001e	48 f7 d8	 neg	 rax
  00021	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00026	eb 0e		 jmp	 SHORT $LN6@long_neg
$LN5@long_neg:
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0002d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00031	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
$LN6@long_neg:
  00036	48 83 7c 24 28
	01		 cmp	 QWORD PTR tv69[rsp], 1
  0003c	7f 55		 jg	 SHORT $LN2@long_neg

; 4006 :         return PyLong_FromLong(-MEDIUM_VALUE(v));

  0003e	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00043	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00048	7d 10		 jge	 SHORT $LN9@long_neg
  0004a	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0004f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00052	f7 d8		 neg	 eax
  00054	89 44 24 30	 mov	 DWORD PTR tv82[rsp], eax
  00058	eb 2a		 jmp	 SHORT $LN10@long_neg
$LN9@long_neg:
  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0005f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00064	75 0a		 jne	 SHORT $LN7@long_neg
  00066	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
  0006e	eb 0c		 jmp	 SHORT $LN8@long_neg
$LN7@long_neg:
  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00075	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00078	89 44 24 34	 mov	 DWORD PTR tv81[rsp], eax
$LN8@long_neg:
  0007c	8b 44 24 34	 mov	 eax, DWORD PTR tv81[rsp]
  00080	89 44 24 30	 mov	 DWORD PTR tv82[rsp], eax
$LN10@long_neg:
  00084	8b 44 24 30	 mov	 eax, DWORD PTR tv82[rsp]
  00088	f7 d8		 neg	 eax
  0008a	8b c8		 mov	 ecx, eax
  0008c	e8 00 00 00 00	 call	 PyLong_FromLong
  00091	eb 31		 jmp	 SHORT $LN3@long_neg
$LN2@long_neg:

; 4007 :     z = (PyLongObject *)_PyLong_Copy(v);

  00093	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00098	e8 00 00 00 00	 call	 _PyLong_Copy
  0009d	48 89 44 24 20	 mov	 QWORD PTR z$[rsp], rax

; 4008 :     if (z != NULL)

  000a2	48 83 7c 24 20
	00		 cmp	 QWORD PTR z$[rsp], 0
  000a8	74 15		 je	 SHORT $LN1@long_neg

; 4009 :         Py_SIZE(z) = -(Py_SIZE(v));

  000aa	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  000af	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b3	48 f7 d8	 neg	 rax
  000b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR z$[rsp]
  000bb	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN1@long_neg:

; 4010 :     return (PyObject *)z;

  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
$LN3@long_neg:

; 4011 : }

  000c4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c8	c3		 ret	 0
long_neg ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_abs DD imagerel long_abs
	DD	imagerel long_abs+50
	DD	imagerel $unwind$long_abs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_abs DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_abs
_TEXT	SEGMENT
v$ = 48
long_abs PROC						; COMDAT

; 4015 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4016 :     if (Py_SIZE(v) < 0)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	7d 0e		 jge	 SHORT $LN2@long_abs

; 4017 :         return long_neg(v);

  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0001a	e8 00 00 00 00	 call	 long_neg
  0001f	eb 0c		 jmp	 SHORT $LN3@long_abs

; 4018 :     else

  00021	eb 0a		 jmp	 SHORT $LN1@long_abs
$LN2@long_abs:

; 4019 :         return long_long((PyObject *)v);

  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00028	e8 00 00 00 00	 call	 long_long
$LN1@long_abs:
$LN3@long_abs:

; 4020 : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
long_abs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_bool DD imagerel long_bool
	DD	imagerel long_bool+45
	DD	imagerel $unwind$long_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_bool DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_bool
_TEXT	SEGMENT
tv66 = 0
v$ = 32
long_bool PROC						; COMDAT

; 4024 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 4025 :     return Py_SIZE(v) != 0;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 09		 je	 SHORT $LN3@long_bool
  00015	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv66[rsp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@long_bool
$LN3@long_bool:
  0001e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv66[rsp], 0
$LN4@long_bool:
  00025	8b 04 24	 mov	 eax, DWORD PTR tv66[rsp]

; 4026 : }

  00028	48 83 c4 18	 add	 rsp, 24
  0002c	c3		 ret	 0
long_bool ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NDIOBNCG@negative?5shift?5count?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_rshift DD imagerel long_rshift
	DD	imagerel long_rshift+835
	DD	imagerel $unwind$long_rshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_rshift DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_0BF@NDIOBNCG@negative?5shift?5count?$AA@
CONST	SEGMENT
??_C@_0BF@NDIOBNCG@negative?5shift?5count?$AA@ DB 'negative shift count', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_rshift
_TEXT	SEGMENT
shiftby$ = 32
i$ = 40
wordshift$ = 48
newsize$ = 56
loshift$ = 64
himask$ = 72
z$ = 80
hishift$ = 88
lomask$ = 96
j$ = 104
a1$23931 = 112
a2$23932 = 120
tv133 = 128
tv224 = 136
tv237 = 144
tv245 = 152
a$ = 176
b$ = 184
long_rshift PROC					; COMDAT

; 4030 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 4031 :     PyLongObject *z = NULL;

  00011	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR z$[rsp], 0
$LN18@long_rshif:

; 4032 :     Py_ssize_t shiftby, newsize, wordshift, loshift, hishift, i, j;
; 4033 :     digit lomask, himask;
; 4034 : 
; 4035 :     CHECK_BINOP(a, b);

  0001a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00022	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00026	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002c	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00031	85 c0		 test	 eax, eax
  00033	74 1b		 je	 SHORT $LN14@long_rshif
  00035	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0003d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00041	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00047	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0004c	85 c0		 test	 eax, eax
  0004e	75 18		 jne	 SHORT $LN15@long_rshif
$LN14@long_rshif:
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00057	e8 00 00 00 00	 call	 _Py_IncRef
  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00063	e9 d3 02 00 00	 jmp	 $LN19@long_rshif
$LN15@long_rshif:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 ac		 jne	 SHORT $LN18@long_rshif

; 4036 : 
; 4037 :     if (Py_SIZE(a) < 0) {

  0006e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00076	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0007b	7d 6b		 jge	 SHORT $LN13@long_rshif

; 4038 :         /* Right shifting negative numbers is harder */
; 4039 :         PyLongObject *a1, *a2;
; 4040 :         a1 = (PyLongObject *) long_invert(a);

  0007d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00085	e8 00 00 00 00	 call	 long_invert
  0008a	48 89 44 24 70	 mov	 QWORD PTR a1$23931[rsp], rax

; 4041 :         if (a1 == NULL)

  0008f	48 83 7c 24 70
	00		 cmp	 QWORD PTR a1$23931[rsp], 0
  00095	75 05		 jne	 SHORT $LN12@long_rshif

; 4042 :             goto rshift_error;

  00097	e9 95 02 00 00	 jmp	 $rshift_error$23936
$LN12@long_rshif:

; 4043 :         a2 = (PyLongObject *) long_rshift(a1, b);

  0009c	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  000a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a1$23931[rsp]
  000a9	e8 00 00 00 00	 call	 long_rshift
  000ae	48 89 44 24 78	 mov	 QWORD PTR a2$23932[rsp], rax

; 4044 :         Py_DECREF(a1);

  000b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a1$23931[rsp]
  000b8	e8 00 00 00 00	 call	 _Py_DecRef

; 4045 :         if (a2 == NULL)

  000bd	48 83 7c 24 78
	00		 cmp	 QWORD PTR a2$23932[rsp], 0
  000c3	75 05		 jne	 SHORT $LN11@long_rshif

; 4046 :             goto rshift_error;

  000c5	e9 67 02 00 00	 jmp	 $rshift_error$23936
$LN11@long_rshif:

; 4047 :         z = (PyLongObject *) long_invert(a2);

  000ca	48 8b 4c 24 78	 mov	 rcx, QWORD PTR a2$23932[rsp]
  000cf	e8 00 00 00 00	 call	 long_invert
  000d4	48 89 44 24 50	 mov	 QWORD PTR z$[rsp], rax

; 4048 :         Py_DECREF(a2);

  000d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR a2$23932[rsp]
  000de	e8 00 00 00 00	 call	 _Py_DecRef

; 4049 :     }
; 4050 :     else {

  000e3	e9 49 02 00 00	 jmp	 $LN10@long_rshif
$LN13@long_rshif:

; 4051 :         shiftby = PyLong_AsSsize_t((PyObject *)b);

  000e8	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  000f0	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000f5	48 89 44 24 20	 mov	 QWORD PTR shiftby$[rsp], rax

; 4052 :         if (shiftby == -1L && PyErr_Occurred())

  000fa	48 83 7c 24 20
	ff		 cmp	 QWORD PTR shiftby$[rsp], -1
  00100	75 0f		 jne	 SHORT $LN9@long_rshif
  00102	e8 00 00 00 00	 call	 PyErr_Occurred
  00107	48 85 c0	 test	 rax, rax
  0010a	74 05		 je	 SHORT $LN9@long_rshif

; 4053 :             goto rshift_error;

  0010c	e9 20 02 00 00	 jmp	 $rshift_error$23936
$LN9@long_rshif:

; 4054 :         if (shiftby < 0) {

  00111	48 83 7c 24 20
	00		 cmp	 QWORD PTR shiftby$[rsp], 0
  00117	7d 18		 jge	 SHORT $LN8@long_rshif

; 4055 :             PyErr_SetString(PyExc_ValueError,
; 4056 :                             "negative shift count");

  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@NDIOBNCG@negative?5shift?5count?$AA@
  00120	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00127	e8 00 00 00 00	 call	 PyErr_SetString

; 4057 :             goto rshift_error;

  0012c	e9 00 02 00 00	 jmp	 $rshift_error$23936
$LN8@long_rshif:

; 4058 :         }
; 4059 :         wordshift = shiftby / PyLong_SHIFT;

  00131	48 8b 44 24 20	 mov	 rax, QWORD PTR shiftby$[rsp]
  00136	48 99		 cdq
  00138	b9 1e 00 00 00	 mov	 ecx, 30
  0013d	48 f7 f9	 idiv	 rcx
  00140	48 89 44 24 30	 mov	 QWORD PTR wordshift$[rsp], rax

; 4060 :         newsize = ABS(Py_SIZE(a)) - wordshift;

  00145	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0014d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00152	7d 19		 jge	 SHORT $LN21@long_rshif
  00154	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0015c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00160	48 f7 d8	 neg	 rax
  00163	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  0016b	eb 14		 jmp	 SHORT $LN22@long_rshif
$LN21@long_rshif:
  0016d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00175	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00179	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
$LN22@long_rshif:
  00181	48 8b 44 24 30	 mov	 rax, QWORD PTR wordshift$[rsp]
  00186	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  0018e	48 2b c8	 sub	 rcx, rax
  00191	48 8b c1	 mov	 rax, rcx
  00194	48 89 44 24 38	 mov	 QWORD PTR newsize$[rsp], rax

; 4061 :         if (newsize <= 0)

  00199	48 83 7c 24 38
	00		 cmp	 QWORD PTR newsize$[rsp], 0
  0019f	7f 0c		 jg	 SHORT $LN7@long_rshif

; 4062 :             return PyLong_FromLong(0);

  001a1	33 c9		 xor	 ecx, ecx
  001a3	e8 00 00 00 00	 call	 PyLong_FromLong
  001a8	e9 8e 01 00 00	 jmp	 $LN19@long_rshif
$LN7@long_rshif:

; 4063 :         loshift = shiftby % PyLong_SHIFT;

  001ad	48 8b 44 24 20	 mov	 rax, QWORD PTR shiftby$[rsp]
  001b2	48 99		 cdq
  001b4	b9 1e 00 00 00	 mov	 ecx, 30
  001b9	48 f7 f9	 idiv	 rcx
  001bc	48 8b c2	 mov	 rax, rdx
  001bf	48 89 44 24 40	 mov	 QWORD PTR loshift$[rsp], rax

; 4064 :         hishift = PyLong_SHIFT - loshift;

  001c4	b8 1e 00 00 00	 mov	 eax, 30
  001c9	48 2b 44 24 40	 sub	 rax, QWORD PTR loshift$[rsp]
  001ce	48 89 44 24 58	 mov	 QWORD PTR hishift$[rsp], rax

; 4065 :         lomask = ((digit)1 << hishift) - 1;

  001d3	48 8b 44 24 58	 mov	 rax, QWORD PTR hishift$[rsp]
  001d8	b9 01 00 00 00	 mov	 ecx, 1
  001dd	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv224[rsp], ecx
  001e4	0f b6 c8	 movzx	 ecx, al
  001e7	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv224[rsp]
  001ee	d3 e0		 shl	 eax, cl
  001f0	ff c8		 dec	 eax
  001f2	89 44 24 60	 mov	 DWORD PTR lomask$[rsp], eax

; 4066 :         himask = PyLong_MASK ^ lomask;

  001f6	8b 44 24 60	 mov	 eax, DWORD PTR lomask$[rsp]
  001fa	35 ff ff ff 3f	 xor	 eax, 1073741823		; 3fffffffH
  001ff	89 44 24 48	 mov	 DWORD PTR himask$[rsp], eax

; 4067 :         z = _PyLong_New(newsize);

  00203	48 8b 4c 24 38	 mov	 rcx, QWORD PTR newsize$[rsp]
  00208	e8 00 00 00 00	 call	 _PyLong_New
  0020d	48 89 44 24 50	 mov	 QWORD PTR z$[rsp], rax

; 4068 :         if (z == NULL)

  00212	48 83 7c 24 50
	00		 cmp	 QWORD PTR z$[rsp], 0
  00218	75 05		 jne	 SHORT $LN6@long_rshif

; 4069 :             goto rshift_error;

  0021a	e9 12 01 00 00	 jmp	 $rshift_error$23936
$LN6@long_rshif:

; 4070 :         if (Py_SIZE(a) < 0)

  0021f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00227	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0022c	7d 15		 jge	 SHORT $LN5@long_rshif

; 4071 :             Py_SIZE(z) = -(Py_SIZE(z));

  0022e	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00233	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00237	48 f7 d8	 neg	 rax
  0023a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0023f	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN5@long_rshif:

; 4072 :         for (i = 0, j = wordshift; i < newsize; i++, j++) {

  00243	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0024c	48 8b 44 24 30	 mov	 rax, QWORD PTR wordshift$[rsp]
  00251	48 89 44 24 68	 mov	 QWORD PTR j$[rsp], rax
  00256	eb 1a		 jmp	 SHORT $LN4@long_rshif
$LN3@long_rshif:
  00258	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0025d	48 ff c0	 inc	 rax
  00260	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00265	48 8b 44 24 68	 mov	 rax, QWORD PTR j$[rsp]
  0026a	48 ff c0	 inc	 rax
  0026d	48 89 44 24 68	 mov	 QWORD PTR j$[rsp], rax
$LN4@long_rshif:
  00272	48 8b 44 24 38	 mov	 rax, QWORD PTR newsize$[rsp]
  00277	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0027c	0f 8d a0 00 00
	00		 jge	 $LN2@long_rshif

; 4073 :             z->ob_digit[i] = (a->ob_digit[j] >> loshift) & lomask;

  00282	48 8b 44 24 40	 mov	 rax, QWORD PTR loshift$[rsp]
  00287	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0028f	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv237[rsp], rcx
  00297	48 8b 54 24 68	 mov	 rdx, QWORD PTR j$[rsp]
  0029c	0f b6 c8	 movzx	 ecx, al
  0029f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv237[rsp]
  002a7	8b 44 90 70	 mov	 eax, DWORD PTR [rax+rdx*4+112]
  002ab	d3 e8		 shr	 eax, cl
  002ad	23 44 24 60	 and	 eax, DWORD PTR lomask$[rsp]
  002b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  002b6	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  002bb	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax

; 4074 :             if (i+1 < newsize)

  002bf	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  002c4	48 ff c0	 inc	 rax
  002c7	48 3b 44 24 38	 cmp	 rax, QWORD PTR newsize$[rsp]
  002cc	7d 4f		 jge	 SHORT $LN1@long_rshif

; 4075 :                 z->ob_digit[i] |= (a->ob_digit[j+1] << hishift) & himask;

  002ce	48 8b 44 24 58	 mov	 rax, QWORD PTR hishift$[rsp]
  002d3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  002db	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tv245[rsp], rcx
  002e3	48 8b 54 24 68	 mov	 rdx, QWORD PTR j$[rsp]
  002e8	0f b6 c8	 movzx	 ecx, al
  002eb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv245[rsp]
  002f3	8b 44 90 74	 mov	 eax, DWORD PTR [rax+rdx*4+116]
  002f7	d3 e0		 shl	 eax, cl
  002f9	23 44 24 48	 and	 eax, DWORD PTR himask$[rsp]
  002fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00302	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00307	8b 4c 91 70	 mov	 ecx, DWORD PTR [rcx+rdx*4+112]
  0030b	0b c8		 or	 ecx, eax
  0030d	8b c1		 mov	 eax, ecx
  0030f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00314	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00319	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax
$LN1@long_rshif:

; 4076 :         }

  0031d	e9 36 ff ff ff	 jmp	 $LN3@long_rshif
$LN2@long_rshif:

; 4077 :         z = long_normalize(z);

  00322	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00327	e8 00 00 00 00	 call	 long_normalize
  0032c	48 89 44 24 50	 mov	 QWORD PTR z$[rsp], rax
$LN10@long_rshif:
$rshift_error$23936:

; 4078 :     }
; 4079 :   rshift_error:
; 4080 :     return (PyObject *) maybe_small_long(z);

  00331	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00336	e8 00 00 00 00	 call	 maybe_small_long
$LN19@long_rshif:

; 4081 : 
; 4082 : }

  0033b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00342	c3		 ret	 0
long_rshift ENDP
_TEXT	ENDS
PUBLIC	??_C@_1O@DLMPJEHG@?$AA?$CB?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_lshift DD imagerel long_lshift
	DD	imagerel long_lshift+866
	DD	imagerel $unwind$long_lshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_lshift DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_1O@DLMPJEHG@?$AA?$CB?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1O@DLMPJEHG@?$AA?$CB?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?$AA@ DB '!', 00H, 'a'
	DB	00H, 'c', 00H, 'c', 00H, 'u', 00H, 'm', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_lshift
_TEXT	SEGMENT
shiftby$ = 32
remshift$ = 40
oldsize$ = 48
a$ = 56
i$ = 64
wordshift$ = 72
newsize$ = 80
accum$ = 88
b$ = 96
z$ = 104
j$ = 112
tmp$24014 = 120
tv90 = 128
tv147 = 136
tv146 = 140
v$ = 160
w$ = 168
long_lshift PROC					; COMDAT

; 4086 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 4087 :     /* This version due to Tim Peters */
; 4088 :     PyLongObject *a = (PyLongObject*)v;

  00011	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00019	48 89 44 24 38	 mov	 QWORD PTR a$[rsp], rax

; 4089 :     PyLongObject *b = (PyLongObject*)w;

  0001e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00026	48 89 44 24 60	 mov	 QWORD PTR b$[rsp], rax

; 4090 :     PyLongObject *z = NULL;

  0002b	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR z$[rsp], 0
$LN23@long_lshif:

; 4091 :     Py_ssize_t shiftby, oldsize, newsize, wordshift, remshift, i, j;
; 4092 :     twodigits accum;
; 4093 : 
; 4094 :     CHECK_BINOP(a, b);

  00034	48 8b 44 24 38	 mov	 rax, QWORD PTR a$[rsp]
  00039	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00043	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00048	85 c0		 test	 eax, eax
  0004a	74 18		 je	 SHORT $LN19@long_lshif
  0004c	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
  00051	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00055	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005b	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00060	85 c0		 test	 eax, eax
  00062	75 18		 jne	 SHORT $LN20@long_lshif
$LN19@long_lshif:
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00077	e9 de 02 00 00	 jmp	 $LN24@long_lshif
$LN20@long_lshif:
  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 b2		 jne	 SHORT $LN23@long_lshif

; 4095 : 
; 4096 :     shiftby = PyLong_AsSsize_t((PyObject *)b);

  00082	48 8b 4c 24 60	 mov	 rcx, QWORD PTR b$[rsp]
  00087	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0008c	48 89 44 24 20	 mov	 QWORD PTR shiftby$[rsp], rax

; 4097 :     if (shiftby == -1L && PyErr_Occurred())

  00091	48 83 7c 24 20
	ff		 cmp	 QWORD PTR shiftby$[rsp], -1
  00097	75 0f		 jne	 SHORT $LN18@long_lshif
  00099	e8 00 00 00 00	 call	 PyErr_Occurred
  0009e	48 85 c0	 test	 rax, rax
  000a1	74 05		 je	 SHORT $LN18@long_lshif

; 4098 :         goto lshift_error;

  000a3	e9 a8 02 00 00	 jmp	 $lshift_error$23996
$LN18@long_lshif:

; 4099 :     if (shiftby < 0) {

  000a8	48 83 7c 24 20
	00		 cmp	 QWORD PTR shiftby$[rsp], 0
  000ae	7d 18		 jge	 SHORT $LN17@long_lshif

; 4100 :         PyErr_SetString(PyExc_ValueError, "negative shift count");

  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@NDIOBNCG@negative?5shift?5count?$AA@
  000b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000be	e8 00 00 00 00	 call	 PyErr_SetString

; 4101 :         goto lshift_error;

  000c3	e9 88 02 00 00	 jmp	 $lshift_error$23996
$LN17@long_lshif:

; 4102 :     }
; 4103 :     /* wordshift, remshift = divmod(shiftby, PyLong_SHIFT) */
; 4104 :     wordshift = shiftby / PyLong_SHIFT;

  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR shiftby$[rsp]
  000cd	48 99		 cdq
  000cf	b9 1e 00 00 00	 mov	 ecx, 30
  000d4	48 f7 f9	 idiv	 rcx
  000d7	48 89 44 24 48	 mov	 QWORD PTR wordshift$[rsp], rax

; 4105 :     remshift  = shiftby - wordshift * PyLong_SHIFT;

  000dc	48 8b 44 24 48	 mov	 rax, QWORD PTR wordshift$[rsp]
  000e1	48 6b c0 1e	 imul	 rax, 30
  000e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR shiftby$[rsp]
  000ea	48 2b c8	 sub	 rcx, rax
  000ed	48 8b c1	 mov	 rax, rcx
  000f0	48 89 44 24 28	 mov	 QWORD PTR remshift$[rsp], rax

; 4106 : 
; 4107 :     oldsize = ABS(Py_SIZE(a));

  000f5	48 8b 44 24 38	 mov	 rax, QWORD PTR a$[rsp]
  000fa	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000ff	7d 16		 jge	 SHORT $LN26@long_lshif
  00101	48 8b 44 24 38	 mov	 rax, QWORD PTR a$[rsp]
  00106	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0010a	48 f7 d8	 neg	 rax
  0010d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  00115	eb 11		 jmp	 SHORT $LN27@long_lshif
$LN26@long_lshif:
  00117	48 8b 44 24 38	 mov	 rax, QWORD PTR a$[rsp]
  0011c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00120	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
$LN27@long_lshif:
  00128	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv90[rsp]
  00130	48 89 44 24 30	 mov	 QWORD PTR oldsize$[rsp], rax

; 4108 :     newsize = oldsize + wordshift;

  00135	48 8b 44 24 48	 mov	 rax, QWORD PTR wordshift$[rsp]
  0013a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR oldsize$[rsp]
  0013f	48 03 c8	 add	 rcx, rax
  00142	48 8b c1	 mov	 rax, rcx
  00145	48 89 44 24 50	 mov	 QWORD PTR newsize$[rsp], rax

; 4109 :     if (remshift)

  0014a	48 83 7c 24 28
	00		 cmp	 QWORD PTR remshift$[rsp], 0
  00150	74 0d		 je	 SHORT $LN16@long_lshif

; 4110 :         ++newsize;

  00152	48 8b 44 24 50	 mov	 rax, QWORD PTR newsize$[rsp]
  00157	48 ff c0	 inc	 rax
  0015a	48 89 44 24 50	 mov	 QWORD PTR newsize$[rsp], rax
$LN16@long_lshif:

; 4111 :     z = _PyLong_New(newsize);

  0015f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newsize$[rsp]
  00164	e8 00 00 00 00	 call	 _PyLong_New
  00169	48 89 44 24 68	 mov	 QWORD PTR z$[rsp], rax

; 4112 :     if (z == NULL)

  0016e	48 83 7c 24 68
	00		 cmp	 QWORD PTR z$[rsp], 0
  00174	75 05		 jne	 SHORT $LN15@long_lshif

; 4113 :         goto lshift_error;

  00176	e9 d5 01 00 00	 jmp	 $lshift_error$23996
$LN15@long_lshif:

; 4114 :     if (Py_SIZE(a) < 0)

  0017b	48 8b 44 24 38	 mov	 rax, QWORD PTR a$[rsp]
  00180	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00185	0f 8d ab 00 00
	00		 jge	 $LN14@long_lshif
$LN13@long_lshif:

; 4115 :         NEGATE(z);

  0018b	48 8b 44 24 68	 mov	 rax, QWORD PTR z$[rsp]
  00190	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  00195	75 17		 jne	 SHORT $LN10@long_lshif
  00197	48 8b 44 24 68	 mov	 rax, QWORD PTR z$[rsp]
  0019c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001a0	48 f7 d8	 neg	 rax
  001a3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR z$[rsp]
  001a8	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  001ac	eb 7e		 jmp	 SHORT $LN9@long_lshif
$LN10@long_lshif:
  001ae	48 8b 44 24 68	 mov	 rax, QWORD PTR z$[rsp]
  001b3	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001b8	7d 13		 jge	 SHORT $LN30@long_lshif
  001ba	48 8b 44 24 68	 mov	 rax, QWORD PTR z$[rsp]
  001bf	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001c2	f7 d8		 neg	 eax
  001c4	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv147[rsp], eax
  001cb	eb 36		 jmp	 SHORT $LN31@long_lshif
$LN30@long_lshif:
  001cd	48 8b 44 24 68	 mov	 rax, QWORD PTR z$[rsp]
  001d2	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001d7	75 0d		 jne	 SHORT $LN28@long_lshif
  001d9	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv146[rsp], 0
  001e4	eb 0f		 jmp	 SHORT $LN29@long_lshif
$LN28@long_lshif:
  001e6	48 8b 44 24 68	 mov	 rax, QWORD PTR z$[rsp]
  001eb	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001ee	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv146[rsp], eax
$LN29@long_lshif:
  001f5	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv146[rsp]
  001fc	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv147[rsp], eax
$LN31@long_lshif:
  00203	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv147[rsp]
  0020a	f7 d8		 neg	 eax
  0020c	8b c8		 mov	 ecx, eax
  0020e	e8 00 00 00 00	 call	 PyLong_FromLong
  00213	48 89 44 24 78	 mov	 QWORD PTR tmp$24014[rsp], rax
  00218	48 8b 4c 24 68	 mov	 rcx, QWORD PTR z$[rsp]
  0021d	e8 00 00 00 00	 call	 _Py_DecRef
  00222	48 8b 44 24 78	 mov	 rax, QWORD PTR tmp$24014[rsp]
  00227	48 89 44 24 68	 mov	 QWORD PTR z$[rsp], rax
$LN9@long_lshif:
  0022c	33 c0		 xor	 eax, eax
  0022e	85 c0		 test	 eax, eax
  00230	0f 85 55 ff ff
	ff		 jne	 $LN13@long_lshif
$LN14@long_lshif:

; 4116 :     for (i = 0; i < wordshift; i++)

  00236	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0023f	eb 0d		 jmp	 SHORT $LN8@long_lshif
$LN7@long_lshif:
  00241	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00246	48 ff c0	 inc	 rax
  00249	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN8@long_lshif:
  0024e	48 8b 44 24 48	 mov	 rax, QWORD PTR wordshift$[rsp]
  00253	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  00258	7d 14		 jge	 SHORT $LN6@long_lshif

; 4117 :         z->ob_digit[i] = 0;

  0025a	48 8b 44 24 68	 mov	 rax, QWORD PTR z$[rsp]
  0025f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00264	c7 44 88 70 00
	00 00 00	 mov	 DWORD PTR [rax+rcx*4+112], 0
  0026c	eb d3		 jmp	 SHORT $LN7@long_lshif
$LN6@long_lshif:

; 4118 :     accum = 0;

  0026e	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR accum$[rsp], 0

; 4119 :     for (i = wordshift, j = 0; j < oldsize; i++, j++) {

  00277	48 8b 44 24 48	 mov	 rax, QWORD PTR wordshift$[rsp]
  0027c	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00281	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  0028a	eb 1a		 jmp	 SHORT $LN5@long_lshif
$LN4@long_lshif:
  0028c	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00291	48 ff c0	 inc	 rax
  00294	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00299	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  0029e	48 ff c0	 inc	 rax
  002a1	48 89 44 24 70	 mov	 QWORD PTR j$[rsp], rax
$LN5@long_lshif:
  002a6	48 8b 44 24 30	 mov	 rax, QWORD PTR oldsize$[rsp]
  002ab	48 39 44 24 70	 cmp	 QWORD PTR j$[rsp], rax
  002b0	7d 4f		 jge	 SHORT $LN3@long_lshif

; 4120 :         accum |= (twodigits)a->ob_digit[j] << remshift;

  002b2	48 8b 44 24 38	 mov	 rax, QWORD PTR a$[rsp]
  002b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR j$[rsp]
  002bc	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  002c0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR remshift$[rsp]
  002c5	48 d3 e0	 shl	 rax, cl
  002c8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR accum$[rsp]
  002cd	48 0b c8	 or	 rcx, rax
  002d0	48 8b c1	 mov	 rax, rcx
  002d3	48 89 44 24 58	 mov	 QWORD PTR accum$[rsp], rax

; 4121 :         z->ob_digit[i] = (digit)(accum & PyLong_MASK);

  002d8	48 8b 44 24 58	 mov	 rax, QWORD PTR accum$[rsp]
  002dd	48 25 ff ff ff
	3f		 and	 rax, 1073741823		; 3fffffffH
  002e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR z$[rsp]
  002e8	48 8b 54 24 40	 mov	 rdx, QWORD PTR i$[rsp]
  002ed	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax

; 4122 :         accum >>= PyLong_SHIFT;

  002f1	48 8b 44 24 58	 mov	 rax, QWORD PTR accum$[rsp]
  002f6	48 c1 e8 1e	 shr	 rax, 30
  002fa	48 89 44 24 58	 mov	 QWORD PTR accum$[rsp], rax

; 4123 :     }

  002ff	eb 8b		 jmp	 SHORT $LN4@long_lshif
$LN3@long_lshif:

; 4124 :     if (remshift)

  00301	48 83 7c 24 28
	00		 cmp	 QWORD PTR remshift$[rsp], 0
  00307	74 14		 je	 SHORT $LN2@long_lshif

; 4125 :         z->ob_digit[newsize-1] = (digit)accum;

  00309	48 8b 44 24 68	 mov	 rax, QWORD PTR z$[rsp]
  0030e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newsize$[rsp]
  00313	8b 54 24 58	 mov	 edx, DWORD PTR accum$[rsp]
  00317	89 54 88 6c	 mov	 DWORD PTR [rax+rcx*4+108], edx

; 4126 :     else

  0031b	eb 24		 jmp	 SHORT $LN1@long_lshif
$LN2@long_lshif:

; 4127 :         assert(!accum);

  0031d	48 83 7c 24 58
	00		 cmp	 QWORD PTR accum$[rsp], 0
  00323	74 1c		 je	 SHORT $LN32@long_lshif
  00325	41 b8 1f 10 00
	00		 mov	 r8d, 4127		; 0000101fH
  0032b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00332	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@DLMPJEHG@?$AA?$CB?$AAa?$AAc?$AAc?$AAu?$AAm?$AA?$AA@
  00339	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0033f	33 c0		 xor	 eax, eax
$LN32@long_lshif:
$LN1@long_lshif:

; 4128 :     z = long_normalize(z);

  00341	48 8b 4c 24 68	 mov	 rcx, QWORD PTR z$[rsp]
  00346	e8 00 00 00 00	 call	 long_normalize
  0034b	48 89 44 24 68	 mov	 QWORD PTR z$[rsp], rax
$lshift_error$23996:

; 4129 :   lshift_error:
; 4130 :     return (PyObject *) maybe_small_long(z);

  00350	48 8b 4c 24 68	 mov	 rcx, QWORD PTR z$[rsp]
  00355	e8 00 00 00 00	 call	 maybe_small_long
$LN24@long_lshif:

; 4131 : }

  0035a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00361	c3		 ret	 0
long_lshift ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_and DD imagerel long_and
	DD	imagerel long_and+124
	DD	imagerel $unwind$long_and
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_and DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_and
_TEXT	SEGMENT
c$ = 32
a$ = 64
b$ = 72
long_and PROC						; COMDAT

; 4277 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN5@long_and:

; 4278 :     PyObject *c;
; 4279 :     CHECK_BINOP(a, b);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00022	85 c0		 test	 eax, eax
  00024	74 18		 je	 SHORT $LN1@long_and
  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003a	85 c0		 test	 eax, eax
  0003c	75 15		 jne	 SHORT $LN2@long_and
$LN1@long_and:
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00045	e8 00 00 00 00	 call	 _Py_IncRef
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00051	eb 24		 jmp	 SHORT $LN6@long_and
$LN2@long_and:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 b5		 jne	 SHORT $LN5@long_and

; 4280 :     c = long_bitwise((PyLongObject*)a, '&', (PyLongObject*)b);

  00059	4c 8b 44 24 48	 mov	 r8, QWORD PTR b$[rsp]
  0005e	ba 26 00 00 00	 mov	 edx, 38			; 00000026H
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00068	e8 00 00 00 00	 call	 long_bitwise
  0006d	48 89 44 24 20	 mov	 QWORD PTR c$[rsp], rax

; 4281 :     return c;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]
$LN6@long_and:

; 4282 : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
long_and ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_bitwise DD imagerel long_bitwise
	DD	imagerel long_bitwise+1497
	DD	imagerel $unwind$long_bitwise
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_bitwise DD 021501H
	DD	0150115H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_bitwise
_TEXT	SEGMENT
i$ = 32
negz$ = 40
negb$ = 44
size_b$ = 48
size_z$ = 56
z$ = 64
size_a$ = 72
nega$ = 80
tv69 = 88
tv72 = 96
tv88 = 104
tv91 = 112
tv136 = 116
tv140 = 120
tv143 = 128
tv154 = 136
tv216 = 144
tv228 = 152
a$ = 176
op$ = 184
b$ = 192
long_bitwise PROC					; COMDAT

; 4156 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 4157 :     int nega, negb, negz;
; 4158 :     Py_ssize_t size_a, size_b, size_z, i;
; 4159 :     PyLongObject *z;
; 4160 : 
; 4161 :     /* Bitwise operations for negative numbers operate as though
; 4162 :        on a two's complement representation.  So convert arguments
; 4163 :        from sign-magnitude to two's complement, and convert the
; 4164 :        result back to sign-magnitude at the end. */
; 4165 : 
; 4166 :     /* If a is negative, replace it by its two's complement. */
; 4167 :     size_a = ABS(Py_SIZE(a));

  00015	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0001d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00022	7d 16		 jge	 SHORT $LN39@long_bitwi
  00024	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0002c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00030	48 f7 d8	 neg	 rax
  00033	48 89 44 24 58	 mov	 QWORD PTR tv69[rsp], rax
  00038	eb 11		 jmp	 SHORT $LN40@long_bitwi
$LN39@long_bitwi:
  0003a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00042	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00046	48 89 44 24 58	 mov	 QWORD PTR tv69[rsp], rax
$LN40@long_bitwi:
  0004b	48 8b 44 24 58	 mov	 rax, QWORD PTR tv69[rsp]
  00050	48 89 44 24 48	 mov	 QWORD PTR size_a$[rsp], rax

; 4168 :     nega = Py_SIZE(a) < 0;

  00055	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0005d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00062	7d 0a		 jge	 SHORT $LN41@long_bitwi
  00064	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0006c	eb 08		 jmp	 SHORT $LN42@long_bitwi
$LN41@long_bitwi:
  0006e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN42@long_bitwi:
  00076	8b 44 24 60	 mov	 eax, DWORD PTR tv72[rsp]
  0007a	89 44 24 50	 mov	 DWORD PTR nega$[rsp], eax

; 4169 :     if (nega) {

  0007e	83 7c 24 50 00	 cmp	 DWORD PTR nega$[rsp], 0
  00083	74 4f		 je	 SHORT $LN36@long_bitwi

; 4170 :         z = _PyLong_New(size_a);

  00085	48 8b 4c 24 48	 mov	 rcx, QWORD PTR size_a$[rsp]
  0008a	e8 00 00 00 00	 call	 _PyLong_New
  0008f	48 89 44 24 40	 mov	 QWORD PTR z$[rsp], rax

; 4171 :         if (z == NULL)

  00094	48 83 7c 24 40
	00		 cmp	 QWORD PTR z$[rsp], 0
  0009a	75 07		 jne	 SHORT $LN35@long_bitwi

; 4172 :             return NULL;

  0009c	33 c0		 xor	 eax, eax
  0009e	e9 2e 05 00 00	 jmp	 $LN37@long_bitwi
$LN35@long_bitwi:

; 4173 :         v_complement(z->ob_digit, a->ob_digit, size_a);

  000a3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000ab	48 83 c0 70	 add	 rax, 112		; 00000070H
  000af	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000b4	48 83 c1 70	 add	 rcx, 112		; 00000070H
  000b8	4c 8b 44 24 48	 mov	 r8, QWORD PTR size_a$[rsp]
  000bd	48 8b d0	 mov	 rdx, rax
  000c0	e8 00 00 00 00	 call	 v_complement

; 4174 :         a = z;

  000c5	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  000ca	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR a$[rsp], rax

; 4175 :     }
; 4176 :     else

  000d2	eb 0d		 jmp	 SHORT $LN34@long_bitwi
$LN36@long_bitwi:

; 4177 :         /* Keep reference count consistent. */
; 4178 :         Py_INCREF(a);

  000d4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000dc	e8 00 00 00 00	 call	 _Py_IncRef
$LN34@long_bitwi:

; 4179 : 
; 4180 :     /* Same for b. */
; 4181 :     size_b = ABS(Py_SIZE(b));

  000e1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000e9	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000ee	7d 16		 jge	 SHORT $LN43@long_bitwi
  000f0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000f8	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000fc	48 f7 d8	 neg	 rax
  000ff	48 89 44 24 68	 mov	 QWORD PTR tv88[rsp], rax
  00104	eb 11		 jmp	 SHORT $LN44@long_bitwi
$LN43@long_bitwi:
  00106	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0010e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00112	48 89 44 24 68	 mov	 QWORD PTR tv88[rsp], rax
$LN44@long_bitwi:
  00117	48 8b 44 24 68	 mov	 rax, QWORD PTR tv88[rsp]
  0011c	48 89 44 24 30	 mov	 QWORD PTR size_b$[rsp], rax

; 4182 :     negb = Py_SIZE(b) < 0;

  00121	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00129	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0012e	7d 0a		 jge	 SHORT $LN45@long_bitwi
  00130	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  00138	eb 08		 jmp	 SHORT $LN46@long_bitwi
$LN45@long_bitwi:
  0013a	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN46@long_bitwi:
  00142	8b 44 24 70	 mov	 eax, DWORD PTR tv91[rsp]
  00146	89 44 24 2c	 mov	 DWORD PTR negb$[rsp], eax

; 4183 :     if (negb) {

  0014a	83 7c 24 2c 00	 cmp	 DWORD PTR negb$[rsp], 0
  0014f	74 5c		 je	 SHORT $LN33@long_bitwi

; 4184 :         z = _PyLong_New(size_b);

  00151	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size_b$[rsp]
  00156	e8 00 00 00 00	 call	 _PyLong_New
  0015b	48 89 44 24 40	 mov	 QWORD PTR z$[rsp], rax

; 4185 :         if (z == NULL) {

  00160	48 83 7c 24 40
	00		 cmp	 QWORD PTR z$[rsp], 0
  00166	75 14		 jne	 SHORT $LN32@long_bitwi

; 4186 :             Py_DECREF(a);

  00168	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00170	e8 00 00 00 00	 call	 _Py_DecRef

; 4187 :             return NULL;

  00175	33 c0		 xor	 eax, eax
  00177	e9 55 04 00 00	 jmp	 $LN37@long_bitwi
$LN32@long_bitwi:

; 4188 :         }
; 4189 :         v_complement(z->ob_digit, b->ob_digit, size_b);

  0017c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00184	48 83 c0 70	 add	 rax, 112		; 00000070H
  00188	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0018d	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00191	4c 8b 44 24 30	 mov	 r8, QWORD PTR size_b$[rsp]
  00196	48 8b d0	 mov	 rdx, rax
  00199	e8 00 00 00 00	 call	 v_complement

; 4190 :         b = z;

  0019e	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  001a3	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 4191 :     }
; 4192 :     else

  001ab	eb 0d		 jmp	 SHORT $LN31@long_bitwi
$LN33@long_bitwi:

; 4193 :         Py_INCREF(b);

  001ad	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  001b5	e8 00 00 00 00	 call	 _Py_IncRef
$LN31@long_bitwi:

; 4194 : 
; 4195 :     /* Swap a and b if necessary to ensure size_a >= size_b. */
; 4196 :     if (size_a < size_b) {

  001ba	48 8b 44 24 30	 mov	 rax, QWORD PTR size_b$[rsp]
  001bf	48 39 44 24 48	 cmp	 QWORD PTR size_a$[rsp], rax
  001c4	7d 60		 jge	 SHORT $LN30@long_bitwi

; 4197 :         z = a; a = b; b = z;

  001c6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001ce	48 89 44 24 40	 mov	 QWORD PTR z$[rsp], rax
  001d3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  001db	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR a$[rsp], rax
  001e3	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  001e8	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 4198 :         size_z = size_a; size_a = size_b; size_b = size_z;

  001f0	48 8b 44 24 48	 mov	 rax, QWORD PTR size_a$[rsp]
  001f5	48 89 44 24 38	 mov	 QWORD PTR size_z$[rsp], rax
  001fa	48 8b 44 24 30	 mov	 rax, QWORD PTR size_b$[rsp]
  001ff	48 89 44 24 48	 mov	 QWORD PTR size_a$[rsp], rax
  00204	48 8b 44 24 38	 mov	 rax, QWORD PTR size_z$[rsp]
  00209	48 89 44 24 30	 mov	 QWORD PTR size_b$[rsp], rax

; 4199 :         negz = nega; nega = negb; negb = negz;

  0020e	8b 44 24 50	 mov	 eax, DWORD PTR nega$[rsp]
  00212	89 44 24 28	 mov	 DWORD PTR negz$[rsp], eax
  00216	8b 44 24 2c	 mov	 eax, DWORD PTR negb$[rsp]
  0021a	89 44 24 50	 mov	 DWORD PTR nega$[rsp], eax
  0021e	8b 44 24 28	 mov	 eax, DWORD PTR negz$[rsp]
  00222	89 44 24 2c	 mov	 DWORD PTR negb$[rsp], eax
$LN30@long_bitwi:

; 4200 :     }
; 4201 : 
; 4202 :     /* JRH: The original logic here was to allocate the result value (z)
; 4203 :        as the longer of the two operands.  However, there are some cases
; 4204 :        where the result is guaranteed to be shorter than that: AND of two
; 4205 :        positives, OR of two negatives: use the shorter number.  AND with
; 4206 :        mixed signs: use the positive number.  OR with mixed signs: use the
; 4207 :        negative number.
; 4208 :     */
; 4209 :     switch (op) {

  00226	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  0022d	89 44 24 74	 mov	 DWORD PTR tv136[rsp], eax
  00231	83 7c 24 74 26	 cmp	 DWORD PTR tv136[rsp], 38 ; 00000026H
  00236	74 32		 je	 SHORT $LN26@long_bitwi
  00238	83 7c 24 74 5e	 cmp	 DWORD PTR tv136[rsp], 94 ; 0000005eH
  0023d	74 0c		 je	 SHORT $LN27@long_bitwi
  0023f	83 7c 24 74 7c	 cmp	 DWORD PTR tv136[rsp], 124 ; 0000007cH
  00244	74 5d		 je	 SHORT $LN25@long_bitwi
  00246	e9 9a 00 00 00	 jmp	 $LN24@long_bitwi
$LN27@long_bitwi:

; 4210 :     case '^':
; 4211 :         negz = nega ^ negb;

  0024b	8b 44 24 2c	 mov	 eax, DWORD PTR negb$[rsp]
  0024f	8b 4c 24 50	 mov	 ecx, DWORD PTR nega$[rsp]
  00253	33 c8		 xor	 ecx, eax
  00255	8b c1		 mov	 eax, ecx
  00257	89 44 24 28	 mov	 DWORD PTR negz$[rsp], eax

; 4212 :         size_z = size_a;

  0025b	48 8b 44 24 48	 mov	 rax, QWORD PTR size_a$[rsp]
  00260	48 89 44 24 38	 mov	 QWORD PTR size_z$[rsp], rax

; 4213 :         break;

  00265	e9 87 00 00 00	 jmp	 $LN28@long_bitwi
$LN26@long_bitwi:

; 4214 :     case '&':
; 4215 :         negz = nega & negb;

  0026a	8b 44 24 2c	 mov	 eax, DWORD PTR negb$[rsp]
  0026e	8b 4c 24 50	 mov	 ecx, DWORD PTR nega$[rsp]
  00272	23 c8		 and	 ecx, eax
  00274	8b c1		 mov	 eax, ecx
  00276	89 44 24 28	 mov	 DWORD PTR negz$[rsp], eax

; 4216 :         size_z = negb ? size_a : size_b;

  0027a	83 7c 24 2c 00	 cmp	 DWORD PTR negb$[rsp], 0
  0027f	74 0c		 je	 SHORT $LN47@long_bitwi
  00281	48 8b 44 24 48	 mov	 rax, QWORD PTR size_a$[rsp]
  00286	48 89 44 24 78	 mov	 QWORD PTR tv140[rsp], rax
  0028b	eb 0a		 jmp	 SHORT $LN48@long_bitwi
$LN47@long_bitwi:
  0028d	48 8b 44 24 30	 mov	 rax, QWORD PTR size_b$[rsp]
  00292	48 89 44 24 78	 mov	 QWORD PTR tv140[rsp], rax
$LN48@long_bitwi:
  00297	48 8b 44 24 78	 mov	 rax, QWORD PTR tv140[rsp]
  0029c	48 89 44 24 38	 mov	 QWORD PTR size_z$[rsp], rax

; 4217 :         break;

  002a1	eb 4e		 jmp	 SHORT $LN28@long_bitwi
$LN25@long_bitwi:

; 4218 :     case '|':
; 4219 :         negz = nega | negb;

  002a3	8b 44 24 2c	 mov	 eax, DWORD PTR negb$[rsp]
  002a7	8b 4c 24 50	 mov	 ecx, DWORD PTR nega$[rsp]
  002ab	0b c8		 or	 ecx, eax
  002ad	8b c1		 mov	 eax, ecx
  002af	89 44 24 28	 mov	 DWORD PTR negz$[rsp], eax

; 4220 :         size_z = negb ? size_b : size_a;

  002b3	83 7c 24 2c 00	 cmp	 DWORD PTR negb$[rsp], 0
  002b8	74 0f		 je	 SHORT $LN49@long_bitwi
  002ba	48 8b 44 24 30	 mov	 rax, QWORD PTR size_b$[rsp]
  002bf	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
  002c7	eb 0d		 jmp	 SHORT $LN50@long_bitwi
$LN49@long_bitwi:
  002c9	48 8b 44 24 48	 mov	 rax, QWORD PTR size_a$[rsp]
  002ce	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
$LN50@long_bitwi:
  002d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv143[rsp]
  002de	48 89 44 24 38	 mov	 QWORD PTR size_z$[rsp], rax

; 4221 :         break;

  002e3	eb 0c		 jmp	 SHORT $LN28@long_bitwi
$LN24@long_bitwi:

; 4222 :     default:
; 4223 :         PyErr_BadArgument();

  002e5	e8 00 00 00 00	 call	 PyErr_BadArgument

; 4224 :         return NULL;

  002ea	33 c0		 xor	 eax, eax
  002ec	e9 e0 02 00 00	 jmp	 $LN37@long_bitwi
$LN28@long_bitwi:

; 4225 :     }
; 4226 : 
; 4227 :     /* We allow an extra digit if z is negative, to make sure that
; 4228 :        the final two's complement of z doesn't overflow. */
; 4229 :     z = _PyLong_New(size_z + negz);

  002f1	48 63 44 24 28	 movsxd	 rax, DWORD PTR negz$[rsp]
  002f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR size_z$[rsp]
  002fb	48 03 c8	 add	 rcx, rax
  002fe	48 8b c1	 mov	 rax, rcx
  00301	48 8b c8	 mov	 rcx, rax
  00304	e8 00 00 00 00	 call	 _PyLong_New
  00309	48 89 44 24 40	 mov	 QWORD PTR z$[rsp], rax

; 4230 :     if (z == NULL) {

  0030e	48 83 7c 24 40
	00		 cmp	 QWORD PTR z$[rsp], 0
  00314	75 21		 jne	 SHORT $LN23@long_bitwi

; 4231 :         Py_DECREF(a);

  00316	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0031e	e8 00 00 00 00	 call	 _Py_DecRef

; 4232 :         Py_DECREF(b);

  00323	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0032b	e8 00 00 00 00	 call	 _Py_DecRef

; 4233 :         return NULL;

  00330	33 c0		 xor	 eax, eax
  00332	e9 9a 02 00 00	 jmp	 $LN37@long_bitwi
$LN23@long_bitwi:

; 4234 :     }
; 4235 : 
; 4236 :     /* Compute digits for overlap of a and b. */
; 4237 :     switch(op) {

  00337	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  0033e	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv154[rsp], eax
  00345	83 bc 24 88 00
	00 00 26	 cmp	 DWORD PTR tv154[rsp], 38 ; 00000026H
  0034d	74 1d		 je	 SHORT $LN20@long_bitwi
  0034f	83 bc 24 88 00
	00 00 5e	 cmp	 DWORD PTR tv154[rsp], 94 ; 0000005eH
  00357	0f 84 c8 00 00
	00		 je	 $LN12@long_bitwi
  0035d	83 bc 24 88 00
	00 00 7c	 cmp	 DWORD PTR tv154[rsp], 124 ; 0000007cH
  00365	74 63		 je	 SHORT $LN16@long_bitwi
  00367	e9 14 01 00 00	 jmp	 $LN8@long_bitwi
$LN20@long_bitwi:

; 4238 :     case '&':
; 4239 :         for (i = 0; i < size_b; ++i)

  0036c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00375	eb 0d		 jmp	 SHORT $LN19@long_bitwi
$LN18@long_bitwi:
  00377	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0037c	48 ff c0	 inc	 rax
  0037f	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN19@long_bitwi:
  00384	48 8b 44 24 30	 mov	 rax, QWORD PTR size_b$[rsp]
  00389	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0038e	7d 35		 jge	 SHORT $LN17@long_bitwi

; 4240 :             z->ob_digit[i] = a->ob_digit[i] & b->ob_digit[i];

  00390	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00398	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0039d	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  003a5	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  003aa	42 8b 54 82 70	 mov	 edx, DWORD PTR [rdx+r8*4+112]
  003af	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  003b3	23 c2		 and	 eax, edx
  003b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  003ba	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  003bf	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax
  003c3	eb b2		 jmp	 SHORT $LN18@long_bitwi
$LN17@long_bitwi:

; 4241 :         break;

  003c5	e9 c2 00 00 00	 jmp	 $LN21@long_bitwi
$LN16@long_bitwi:

; 4242 :     case '|':
; 4243 :         for (i = 0; i < size_b; ++i)

  003ca	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  003d3	eb 0d		 jmp	 SHORT $LN15@long_bitwi
$LN14@long_bitwi:
  003d5	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  003da	48 ff c0	 inc	 rax
  003dd	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN15@long_bitwi:
  003e2	48 8b 44 24 30	 mov	 rax, QWORD PTR size_b$[rsp]
  003e7	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  003ec	7d 35		 jge	 SHORT $LN13@long_bitwi

; 4244 :             z->ob_digit[i] = a->ob_digit[i] | b->ob_digit[i];

  003ee	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  003f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  003fb	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00403	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00408	42 8b 54 82 70	 mov	 edx, DWORD PTR [rdx+r8*4+112]
  0040d	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  00411	0b c2		 or	 eax, edx
  00413	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00418	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0041d	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax
  00421	eb b2		 jmp	 SHORT $LN14@long_bitwi
$LN13@long_bitwi:

; 4245 :         break;

  00423	eb 67		 jmp	 SHORT $LN21@long_bitwi
$LN12@long_bitwi:

; 4246 :     case '^':
; 4247 :         for (i = 0; i < size_b; ++i)

  00425	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0042e	eb 0d		 jmp	 SHORT $LN11@long_bitwi
$LN10@long_bitwi:
  00430	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00435	48 ff c0	 inc	 rax
  00438	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN11@long_bitwi:
  0043d	48 8b 44 24 30	 mov	 rax, QWORD PTR size_b$[rsp]
  00442	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00447	7d 35		 jge	 SHORT $LN9@long_bitwi

; 4248 :             z->ob_digit[i] = a->ob_digit[i] ^ b->ob_digit[i];

  00449	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00451	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00456	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  0045e	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00463	42 8b 54 82 70	 mov	 edx, DWORD PTR [rdx+r8*4+112]
  00468	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  0046c	33 c2		 xor	 eax, edx
  0046e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00473	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00478	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax
  0047c	eb b2		 jmp	 SHORT $LN10@long_bitwi
$LN9@long_bitwi:

; 4249 :         break;

  0047e	eb 0c		 jmp	 SHORT $LN21@long_bitwi
$LN8@long_bitwi:

; 4250 :     default:
; 4251 :         PyErr_BadArgument();

  00480	e8 00 00 00 00	 call	 PyErr_BadArgument

; 4252 :         return NULL;

  00485	33 c0		 xor	 eax, eax
  00487	e9 45 01 00 00	 jmp	 $LN37@long_bitwi
$LN21@long_bitwi:

; 4253 :     }
; 4254 : 
; 4255 :     /* Copy any remaining digits of a, inverting if necessary. */
; 4256 :     if (op == '^' && negb)

  0048c	83 bc 24 b8 00
	00 00 5e	 cmp	 DWORD PTR op$[rsp], 94	; 0000005eH
  00494	75 4a		 jne	 SHORT $LN7@long_bitwi
  00496	83 7c 24 2c 00	 cmp	 DWORD PTR negb$[rsp], 0
  0049b	74 43		 je	 SHORT $LN7@long_bitwi

; 4257 :         for (; i < size_z; ++i)

  0049d	eb 0d		 jmp	 SHORT $LN6@long_bitwi
$LN5@long_bitwi:
  0049f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  004a4	48 ff c0	 inc	 rax
  004a7	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@long_bitwi:
  004ac	48 8b 44 24 38	 mov	 rax, QWORD PTR size_z$[rsp]
  004b1	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  004b6	7d 26		 jge	 SHORT $LN4@long_bitwi

; 4258 :             z->ob_digit[i] = a->ob_digit[i] ^ PyLong_MASK;

  004b8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  004c0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  004c5	8b 44 88 70	 mov	 eax, DWORD PTR [rax+rcx*4+112]
  004c9	35 ff ff ff 3f	 xor	 eax, 1073741823		; 3fffffffH
  004ce	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  004d3	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  004d8	89 44 91 70	 mov	 DWORD PTR [rcx+rdx*4+112], eax
  004dc	eb c1		 jmp	 SHORT $LN5@long_bitwi
$LN4@long_bitwi:

; 4259 :     else if (i < size_z)

  004de	eb 5f		 jmp	 SHORT $LN3@long_bitwi
$LN7@long_bitwi:
  004e0	48 8b 44 24 38	 mov	 rax, QWORD PTR size_z$[rsp]
  004e5	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  004ea	7d 53		 jge	 SHORT $LN2@long_bitwi

; 4260 :         memcpy(&z->ob_digit[i], &a->ob_digit[i],
; 4261 :                (size_z-i)*sizeof(digit));

  004ec	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  004f1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR size_z$[rsp]
  004f6	48 2b c8	 sub	 rcx, rax
  004f9	48 8b c1	 mov	 rax, rcx
  004fc	48 c1 e0 02	 shl	 rax, 2
  00500	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00508	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0050d	48 8d 4c 91 70	 lea	 rcx, QWORD PTR [rcx+rdx*4+112]
  00512	48 8b 54 24 40	 mov	 rdx, QWORD PTR z$[rsp]
  00517	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  0051c	4a 8d 54 82 70	 lea	 rdx, QWORD PTR [rdx+r8*4+112]
  00521	48 89 94 24 90
	00 00 00	 mov	 QWORD PTR tv216[rsp], rdx
  00529	4c 8b c0	 mov	 r8, rax
  0052c	48 8b d1	 mov	 rdx, rcx
  0052f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv216[rsp]
  00537	48 8b c8	 mov	 rcx, rax
  0053a	e8 00 00 00 00	 call	 memcpy
$LN2@long_bitwi:
$LN3@long_bitwi:

; 4262 : 
; 4263 :     /* Complement result if negative. */
; 4264 :     if (negz) {

  0053f	83 7c 24 28 00	 cmp	 DWORD PTR negz$[rsp], 0
  00544	74 5f		 je	 SHORT $LN1@long_bitwi

; 4265 :         Py_SIZE(z) = -(Py_SIZE(z));

  00546	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0054b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0054f	48 f7 d8	 neg	 rax
  00552	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00557	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 4266 :         z->ob_digit[size_z] = PyLong_MASK;

  0055b	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00560	48 8b 4c 24 38	 mov	 rcx, QWORD PTR size_z$[rsp]
  00565	c7 44 88 70 ff
	ff ff 3f	 mov	 DWORD PTR [rax+rcx*4+112], 1073741823 ; 3fffffffH

; 4267 :         v_complement(z->ob_digit, z->ob_digit, size_z+1);

  0056d	48 8b 44 24 38	 mov	 rax, QWORD PTR size_z$[rsp]
  00572	48 ff c0	 inc	 rax
  00575	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0057a	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0057e	48 8b 54 24 40	 mov	 rdx, QWORD PTR z$[rsp]
  00583	48 83 c2 70	 add	 rdx, 112		; 00000070H
  00587	48 89 94 24 98
	00 00 00	 mov	 QWORD PTR tv228[rsp], rdx
  0058f	4c 8b c0	 mov	 r8, rax
  00592	48 8b d1	 mov	 rdx, rcx
  00595	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv228[rsp]
  0059d	48 8b c8	 mov	 rcx, rax
  005a0	e8 00 00 00 00	 call	 v_complement
$LN1@long_bitwi:

; 4268 :     }
; 4269 : 
; 4270 :     Py_DECREF(a);

  005a5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  005ad	e8 00 00 00 00	 call	 _Py_DecRef

; 4271 :     Py_DECREF(b);

  005b2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  005ba	e8 00 00 00 00	 call	 _Py_DecRef

; 4272 :     return (PyObject *)maybe_small_long(long_normalize(z));

  005bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  005c4	e8 00 00 00 00	 call	 long_normalize
  005c9	48 8b c8	 mov	 rcx, rax
  005cc	e8 00 00 00 00	 call	 maybe_small_long
$LN37@long_bitwi:

; 4273 : }

  005d1	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  005d8	c3		 ret	 0
long_bitwise ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$v_complement DD imagerel v_complement
	DD	imagerel v_complement+168
	DD	imagerel $unwind$v_complement
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$v_complement DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT v_complement
_TEXT	SEGMENT
i$ = 32
carry$ = 40
z$ = 64
a$ = 72
m$ = 80
v_complement PROC					; COMDAT

; 4139 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4140 :     Py_ssize_t i;
; 4141 :     digit carry = 1;

  00013	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR carry$[rsp], 1

; 4142 :     for (i = 0; i < m; ++i) {

  0001b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00024	eb 0d		 jmp	 SHORT $LN3@v_compleme
$LN2@v_compleme:
  00026	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0002b	48 ff c0	 inc	 rax
  0002e	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@v_compleme:
  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR m$[rsp]
  00038	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0003d	7d 41		 jge	 SHORT $LN1@v_compleme

; 4143 :         carry += a[i] ^ PyLong_MASK;

  0003f	48 8b 44 24 48	 mov	 rax, QWORD PTR a$[rsp]
  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00049	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0004c	35 ff ff ff 3f	 xor	 eax, 1073741823		; 3fffffffH
  00051	8b 4c 24 28	 mov	 ecx, DWORD PTR carry$[rsp]
  00055	03 c8		 add	 ecx, eax
  00057	8b c1		 mov	 eax, ecx
  00059	89 44 24 28	 mov	 DWORD PTR carry$[rsp], eax

; 4144 :         z[i] = carry & PyLong_MASK;

  0005d	8b 44 24 28	 mov	 eax, DWORD PTR carry$[rsp]
  00061	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0006b	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00070	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 4145 :         carry >>= PyLong_SHIFT;

  00073	8b 44 24 28	 mov	 eax, DWORD PTR carry$[rsp]
  00077	c1 e8 1e	 shr	 eax, 30
  0007a	89 44 24 28	 mov	 DWORD PTR carry$[rsp], eax

; 4146 :     }

  0007e	eb a6		 jmp	 SHORT $LN2@v_compleme
$LN1@v_compleme:

; 4147 :     assert(carry == 0);

  00080	83 7c 24 28 00	 cmp	 DWORD PTR carry$[rsp], 0
  00085	74 1c		 je	 SHORT $LN6@v_compleme
  00087	41 b8 33 10 00
	00		 mov	 r8d, 4147		; 00001033H
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@NKCMNFPP@?$AAc?$AAa?$AAr?$AAr?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a1	33 c0		 xor	 eax, eax
$LN6@v_compleme:

; 4148 : }

  000a3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a7	c3		 ret	 0
v_complement ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_xor DD imagerel long_xor
	DD	imagerel long_xor+124
	DD	imagerel $unwind$long_xor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_xor DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_xor
_TEXT	SEGMENT
c$ = 32
a$ = 64
b$ = 72
long_xor PROC						; COMDAT

; 4286 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN5@long_xor:

; 4287 :     PyObject *c;
; 4288 :     CHECK_BINOP(a, b);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00022	85 c0		 test	 eax, eax
  00024	74 18		 je	 SHORT $LN1@long_xor
  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003a	85 c0		 test	 eax, eax
  0003c	75 15		 jne	 SHORT $LN2@long_xor
$LN1@long_xor:
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00045	e8 00 00 00 00	 call	 _Py_IncRef
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00051	eb 24		 jmp	 SHORT $LN6@long_xor
$LN2@long_xor:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 b5		 jne	 SHORT $LN5@long_xor

; 4289 :     c = long_bitwise((PyLongObject*)a, '^', (PyLongObject*)b);

  00059	4c 8b 44 24 48	 mov	 r8, QWORD PTR b$[rsp]
  0005e	ba 5e 00 00 00	 mov	 edx, 94			; 0000005eH
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00068	e8 00 00 00 00	 call	 long_bitwise
  0006d	48 89 44 24 20	 mov	 QWORD PTR c$[rsp], rax

; 4290 :     return c;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]
$LN6@long_xor:

; 4291 : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
long_xor ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_or DD imagerel long_or
	DD	imagerel long_or+124
	DD	imagerel $unwind$long_or
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_or DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_or
_TEXT	SEGMENT
c$ = 32
a$ = 64
b$ = 72
long_or	PROC						; COMDAT

; 4295 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN5@long_or:

; 4296 :     PyObject *c;
; 4297 :     CHECK_BINOP(a, b);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00022	85 c0		 test	 eax, eax
  00024	74 18		 je	 SHORT $LN1@long_or
  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003a	85 c0		 test	 eax, eax
  0003c	75 15		 jne	 SHORT $LN2@long_or
$LN1@long_or:
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00045	e8 00 00 00 00	 call	 _Py_IncRef
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00051	eb 24		 jmp	 SHORT $LN6@long_or
$LN2@long_or:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 b5		 jne	 SHORT $LN5@long_or

; 4298 :     c = long_bitwise((PyLongObject*)a, '|', (PyLongObject*)b);

  00059	4c 8b 44 24 48	 mov	 r8, QWORD PTR b$[rsp]
  0005e	ba 7c 00 00 00	 mov	 edx, 124		; 0000007cH
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00068	e8 00 00 00 00	 call	 long_bitwise
  0006d	48 89 44 24 20	 mov	 QWORD PTR c$[rsp], rax

; 4299 :     return c;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]
$LN6@long_or:

; 4300 : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
long_or	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_long DD imagerel long_long
	DD	imagerel long_long+64
	DD	imagerel $unwind$long_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_long DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_long
_TEXT	SEGMENT
v$ = 48
long_long PROC						; COMDAT

; 4304 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4305 :     if (PyLong_CheckExact(v))

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	75 0c		 jne	 SHORT $LN2@long_long

; 4306 :         Py_INCREF(v);

  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00020	e8 00 00 00 00	 call	 _Py_IncRef

; 4307 :     else

  00025	eb 0f		 jmp	 SHORT $LN1@long_long
$LN2@long_long:

; 4308 :         v = _PyLong_Copy((PyLongObject *)v);

  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0002c	e8 00 00 00 00	 call	 _PyLong_Copy
  00031	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax
$LN1@long_long:

; 4309 :     return v;

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]

; 4310 : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
long_long ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_float DD imagerel long_float
	DD	imagerel long_float+73
	DD	imagerel $unwind$long_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_float DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_float
_TEXT	SEGMENT
result$ = 32
v$ = 64
long_float PROC						; COMDAT

; 4314 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4315 :     double result;
; 4316 :     result = PyLong_AsDouble(v);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0000e	e8 00 00 00 00	 call	 PyLong_AsDouble
  00013	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR result$[rsp], xmm0

; 4317 :     if (result == -1.0 && PyErr_Occurred())

  00019	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR result$[rsp]
  0001f	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00027	7a 10		 jp	 SHORT $LN1@long_float
  00029	75 0e		 jne	 SHORT $LN1@long_float
  0002b	e8 00 00 00 00	 call	 PyErr_Occurred
  00030	48 85 c0	 test	 rax, rax
  00033	74 04		 je	 SHORT $LN1@long_float

; 4318 :         return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	eb 0b		 jmp	 SHORT $LN2@long_float
$LN1@long_float:

; 4319 :     return PyFloat_FromDouble(result);

  00039	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR result$[rsp]
  0003f	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN2@long_float:

; 4320 : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
long_float ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@OAMPAPFL@int?$CI?$CJ?5can?8t?5convert?5non?9string?5w@ ; `string'
PUBLIC	??_C@_1CC@JFAOAEJJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@JAOKLFLB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CC@HFLKJAMF@int?$CI?$CJ?5base?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?53@ ; `string'
PUBLIC	??_C@_0BO@MFMCCHH@int?$CI?$CJ?5missing?5string?5argument?$AA@ ; `string'
PUBLIC	??_C@_07IJMKFLBG@?$HMOO?3int?$AA@		; `string'
EXTRN	_PyByteArray_empty_string:BYTE
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyByteArray_Type:BYTE
EXTRN	PyNumber_Long:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_new DD imagerel long_new
	DD	imagerel long_new+724
	DD	imagerel $unwind$long_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_new DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0DC@OAMPAPFL@int?$CI?$CJ?5can?8t?5convert?5non?9string?5w@
CONST	SEGMENT
??_C@_0DC@OAMPAPFL@int?$CI?$CJ?5can?8t?5convert?5non?9string?5w@ DB 'int('
	DB	') can''t convert non-string with explicit base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@JFAOAEJJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@JFAOAEJJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'x', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@JAOKLFLB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@JAOKLFLB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'x', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HFLKJAMF@int?$CI?$CJ?5base?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?53@
CONST	SEGMENT
??_C@_0CC@HFLKJAMF@int?$CI?$CJ?5base?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?53@ DB 'i'
	DB	'nt() base must be >= 2 and <= 36', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MFMCCHH@int?$CI?$CJ?5missing?5string?5argument?$AA@
CONST	SEGMENT
??_C@_0BO@MFMCCHH@int?$CI?$CJ?5missing?5string?5argument?$AA@ DB 'int() m'
	DB	'issing string argument', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IJMKFLBG@?$HMOO?3int?$AA@
CONST	SEGMENT
??_C@_07IJMKFLBG@?$HMOO?3int?$AA@ DB '|OO:int', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_new
_TEXT	SEGMENT
x$ = 48
overflow$ = 56
base$ = 60
obase$ = 64
string$24262 = 72
tv169 = 80
type$ = 112
args$ = 120
kwds$ = 128
long_new PROC						; COMDAT

; 4327 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4328 :     PyObject *obase = NULL, *x = NULL;

  00013	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR obase$[rsp], 0
  0001c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 4329 :     long base;
; 4330 :     int overflow;
; 4331 :     static char *kwlist[] = {"x", "base", 0};
; 4332 : 
; 4333 :     if (type != &PyLong_Type)

  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  0002c	48 39 44 24 70	 cmp	 QWORD PTR type$[rsp], rax
  00031	74 1c		 je	 SHORT $LN17@long_new

; 4334 :         return long_subtype_new(type, args, kwds); /* Wimp out */

  00033	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR kwds$[rsp]
  0003b	48 8b 54 24 78	 mov	 rdx, QWORD PTR args$[rsp]
  00040	48 8b 4c 24 70	 mov	 rcx, QWORD PTR type$[rsp]
  00045	e8 00 00 00 00	 call	 long_subtype_new
  0004a	e9 80 02 00 00	 jmp	 $LN18@long_new
$LN17@long_new:

; 4335 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|OO:int", kwlist,
; 4336 :                                      &x, &obase))

  0004f	48 8d 44 24 40	 lea	 rax, QWORD PTR obase$[rsp]
  00054	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00059	48 8d 44 24 30	 lea	 rax, QWORD PTR x$[rsp]
  0005e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00063	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??long_new@@9@9
  0006a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07IJMKFLBG@?$HMOO?3int?$AA@
  00071	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00079	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  0007e	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00083	85 c0		 test	 eax, eax
  00085	75 07		 jne	 SHORT $LN16@long_new

; 4337 :         return NULL;

  00087	33 c0		 xor	 eax, eax
  00089	e9 41 02 00 00	 jmp	 $LN18@long_new
$LN16@long_new:

; 4338 :     if (x == NULL) {

  0008e	48 83 7c 24 30
	00		 cmp	 QWORD PTR x$[rsp], 0
  00094	75 2e		 jne	 SHORT $LN15@long_new

; 4339 :         if (obase != NULL) {

  00096	48 83 7c 24 40
	00		 cmp	 QWORD PTR obase$[rsp], 0
  0009c	74 1a		 je	 SHORT $LN14@long_new

; 4340 :             PyErr_SetString(PyExc_TypeError,
; 4341 :                             "int() missing string argument");

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@MFMCCHH@int?$CI?$CJ?5missing?5string?5argument?$AA@
  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ac	e8 00 00 00 00	 call	 PyErr_SetString

; 4342 :             return NULL;

  000b1	33 c0		 xor	 eax, eax
  000b3	e9 17 02 00 00	 jmp	 $LN18@long_new
$LN14@long_new:

; 4343 :         }
; 4344 :         return PyLong_FromLong(0L);

  000b8	33 c9		 xor	 ecx, ecx
  000ba	e8 00 00 00 00	 call	 PyLong_FromLong
  000bf	e9 0b 02 00 00	 jmp	 $LN18@long_new
$LN15@long_new:

; 4345 :     }
; 4346 :     if (obase == NULL)

  000c4	48 83 7c 24 40
	00		 cmp	 QWORD PTR obase$[rsp], 0
  000ca	75 0f		 jne	 SHORT $LN13@long_new

; 4347 :         return PyNumber_Long(x);

  000cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  000d1	e8 00 00 00 00	 call	 PyNumber_Long
  000d6	e9 f4 01 00 00	 jmp	 $LN18@long_new
$LN13@long_new:

; 4348 : 
; 4349 :     base = PyLong_AsLongAndOverflow(obase, &overflow);

  000db	48 8d 54 24 38	 lea	 rdx, QWORD PTR overflow$[rsp]
  000e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obase$[rsp]
  000e5	e8 00 00 00 00	 call	 PyLong_AsLongAndOverflow
  000ea	89 44 24 3c	 mov	 DWORD PTR base$[rsp], eax

; 4350 :     if (base == -1 && PyErr_Occurred())

  000ee	83 7c 24 3c ff	 cmp	 DWORD PTR base$[rsp], -1
  000f3	75 11		 jne	 SHORT $LN12@long_new
  000f5	e8 00 00 00 00	 call	 PyErr_Occurred
  000fa	48 85 c0	 test	 rax, rax
  000fd	74 07		 je	 SHORT $LN12@long_new

; 4351 :         return NULL;

  000ff	33 c0		 xor	 eax, eax
  00101	e9 c9 01 00 00	 jmp	 $LN18@long_new
$LN12@long_new:

; 4352 :     if (overflow || (base != 0 && base < 2) || base > 36) {

  00106	83 7c 24 38 00	 cmp	 DWORD PTR overflow$[rsp], 0
  0010b	75 15		 jne	 SHORT $LN10@long_new
  0010d	83 7c 24 3c 00	 cmp	 DWORD PTR base$[rsp], 0
  00112	74 07		 je	 SHORT $LN9@long_new
  00114	83 7c 24 3c 02	 cmp	 DWORD PTR base$[rsp], 2
  00119	7c 07		 jl	 SHORT $LN10@long_new
$LN9@long_new:
  0011b	83 7c 24 3c 24	 cmp	 DWORD PTR base$[rsp], 36 ; 00000024H
  00120	7e 1a		 jle	 SHORT $LN11@long_new
$LN10@long_new:

; 4353 :         PyErr_SetString(PyExc_ValueError,
; 4354 :                         "int() base must be >= 2 and <= 36");

  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@HFLKJAMF@int?$CI?$CJ?5base?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?53@
  00129	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00130	e8 00 00 00 00	 call	 PyErr_SetString

; 4355 :         return NULL;

  00135	33 c0		 xor	 eax, eax
  00137	e9 93 01 00 00	 jmp	 $LN18@long_new
$LN11@long_new:

; 4356 :     }
; 4357 : 
; 4358 :     if (PyUnicode_Check(x))

  0013c	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  00141	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00145	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0014b	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00150	85 c0		 test	 eax, eax
  00152	74 18		 je	 SHORT $LN8@long_new

; 4359 :         return PyLong_FromUnicodeObject(x, (int)base);

  00154	8b 54 24 3c	 mov	 edx, DWORD PTR base$[rsp]
  00158	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  0015d	e8 00 00 00 00	 call	 PyLong_FromUnicodeObject
  00162	e9 68 01 00 00	 jmp	 $LN18@long_new
  00167	e9 63 01 00 00	 jmp	 $LN7@long_new
$LN8@long_new:

; 4360 :     else if (PyByteArray_Check(x) || PyBytes_Check(x)) {

  0016c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00173	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  00178	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0017c	74 35		 je	 SHORT $LN5@long_new
  0017e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00185	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  0018a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0018e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00193	85 c0		 test	 eax, eax
  00195	75 1c		 jne	 SHORT $LN5@long_new
  00197	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  0019c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001a0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001a6	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001ab	85 c0		 test	 eax, eax
  001ad	0f 84 07 01 00
	00		 je	 $LN6@long_new
$LN5@long_new:

; 4361 :         char *string;
; 4362 :         if (PyByteArray_Check(x))

  001b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  001bf	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001c3	74 19		 je	 SHORT $LN3@long_new
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001cc	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  001d1	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001d5	e8 00 00 00 00	 call	 PyType_IsSubtype
  001da	85 c0		 test	 eax, eax
  001dc	74 7e		 je	 SHORT $LN4@long_new
$LN3@long_new:

; 4363 :             string = PyByteArray_AS_STRING(x);

  001de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  001ea	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001ee	74 35		 je	 SHORT $LN20@long_new
  001f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001f7	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  001fc	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00200	e8 00 00 00 00	 call	 PyType_IsSubtype
  00205	85 c0		 test	 eax, eax
  00207	75 1c		 jne	 SHORT $LN20@long_new
  00209	41 b8 0b 11 00
	00		 mov	 r8d, 4363		; 0000110bH
  0020f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JAOKLFLB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00223	33 c0		 xor	 eax, eax
$LN20@long_new:
  00225	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  0022a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0022f	74 13		 je	 SHORT $LN21@long_new
  00231	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  00236	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0023d	48 89 44 24 50	 mov	 QWORD PTR tv169[rsp], rax
  00242	eb 0c		 jmp	 SHORT $LN22@long_new
$LN21@long_new:
  00244	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0024b	48 89 44 24 50	 mov	 QWORD PTR tv169[rsp], rax
$LN22@long_new:
  00250	48 8b 44 24 50	 mov	 rax, QWORD PTR tv169[rsp]
  00255	48 89 44 24 48	 mov	 QWORD PTR string$24262[rsp], rax

; 4364 :         else

  0025a	eb 42		 jmp	 SHORT $LN2@long_new
$LN4@long_new:

; 4365 :             string = PyBytes_AS_STRING(x);

  0025c	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  00261	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00265	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0026b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00270	85 c0		 test	 eax, eax
  00272	75 1c		 jne	 SHORT $LN23@long_new
  00274	41 b8 0d 11 00
	00		 mov	 r8d, 4365		; 0000110dH
  0027a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@JFAOAEJJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0028e	33 c0		 xor	 eax, eax
$LN23@long_new:
  00290	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  00295	48 83 c0 78	 add	 rax, 120		; 00000078H
  00299	48 89 44 24 48	 mov	 QWORD PTR string$24262[rsp], rax
$LN2@long_new:

; 4366 :         return _PyLong_FromBytes(string, Py_SIZE(x), (int)base);

  0029e	44 8b 44 24 3c	 mov	 r8d, DWORD PTR base$[rsp]
  002a3	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  002a8	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  002ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR string$24262[rsp]
  002b1	e8 00 00 00 00	 call	 _PyLong_FromBytes
  002b6	eb 17		 jmp	 SHORT $LN18@long_new

; 4367 :     }
; 4368 :     else {

  002b8	eb 15		 jmp	 SHORT $LN1@long_new
$LN6@long_new:

; 4369 :         PyErr_SetString(PyExc_TypeError,
; 4370 :                         "int() can't convert non-string with explicit base");

  002ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@OAMPAPFL@int?$CI?$CJ?5can?8t?5convert?5non?9string?5w@
  002c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002c8	e8 00 00 00 00	 call	 PyErr_SetString

; 4371 :         return NULL;

  002cd	33 c0		 xor	 eax, eax
$LN1@long_new:
$LN7@long_new:
$LN18@long_new:

; 4372 :     }
; 4373 : }

  002cf	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002d3	c3		 ret	 0
long_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@GCHMMLOI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@PCDBBNPK@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EK@LOCMBIFL@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAT@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_subtype_new DD imagerel long_subtype_new
	DD	imagerel long_subtype_new+399
	DD	imagerel $unwind$long_subtype_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_subtype_new DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_1CK@GCHMMLOI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@GCHMMLOI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'n'
	DB	00H, 'e', 00H, 'w', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@PCDBBNPK@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@PCDBBNPK@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'E', 00H, 'x'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, '(', 00H, 't', 00H, 'm', 00H
	DB	'p', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@LOCMBIFL@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAT@
CONST	SEGMENT
??_C@_1EK@LOCMBIFL@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAT@ DB 'P'
	DB	00H, 'y', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H
	DB	'I', 00H, 's', 00H, 'S', 00H, 'u', 00H, 'b', 00H, 't', 00H, 'y'
	DB	00H, 'p', 00H, 'e', 00H, '(', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, ',', 00H, ' ', 00H, '&', 00H, 'P', 00H, 'y', 00H, 'L'
	DB	00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, ')', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_subtype_new
_TEXT	SEGMENT
n$ = 32
i$ = 40
tmp$ = 48
newobj$ = 56
type$ = 80
args$ = 88
kwds$ = 96
long_subtype_new PROC					; COMDAT

; 4382 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4383 :     PyLongObject *tmp, *newobj;
; 4384 :     Py_ssize_t i, n;
; 4385 : 
; 4386 :     assert(PyType_IsSubtype(type, &PyLong_Type));

  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyLong_Type
  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR type$[rsp]
  0001f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00024	85 c0		 test	 eax, eax
  00026	75 1c		 jne	 SHORT $LN9@long_subty
  00028	41 b8 22 11 00
	00		 mov	 r8d, 4386		; 00001122H
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@LOCMBIFL@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAT@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00042	33 c0		 xor	 eax, eax
$LN9@long_subty:

; 4387 :     tmp = (PyLongObject *)long_new(&PyLong_Type, args, kwds);

  00044	4c 8b 44 24 60	 mov	 r8, QWORD PTR kwds$[rsp]
  00049	48 8b 54 24 58	 mov	 rdx, QWORD PTR args$[rsp]
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyLong_Type
  00055	e8 00 00 00 00	 call	 long_new
  0005a	48 89 44 24 30	 mov	 QWORD PTR tmp$[rsp], rax

; 4388 :     if (tmp == NULL)

  0005f	48 83 7c 24 30
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00065	75 07		 jne	 SHORT $LN6@long_subty

; 4389 :         return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	e9 1c 01 00 00	 jmp	 $LN7@long_subty
$LN6@long_subty:

; 4390 :     assert(PyLong_CheckExact(tmp));

  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  00075	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp$[rsp]
  0007a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0007e	74 1c		 je	 SHORT $LN10@long_subty
  00080	41 b8 26 11 00
	00		 mov	 r8d, 4390		; 00001126H
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@PCDBBNPK@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009a	33 c0		 xor	 eax, eax
$LN10@long_subty:

; 4391 :     n = Py_SIZE(tmp);

  0009c	48 8b 44 24 30	 mov	 rax, QWORD PTR tmp$[rsp]
  000a1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a5	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 4392 :     if (n < 0)

  000aa	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  000b0	7d 0d		 jge	 SHORT $LN5@long_subty

; 4393 :         n = -n;

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000b7	48 f7 d8	 neg	 rax
  000ba	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax
$LN5@long_subty:

; 4394 :     newobj = (PyLongObject *)type->tp_alloc(type, n);

  000bf	48 8b 54 24 20	 mov	 rdx, QWORD PTR n$[rsp]
  000c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR type$[rsp]
  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR type$[rsp]
  000ce	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000d4	48 89 44 24 38	 mov	 QWORD PTR newobj$[rsp], rax

; 4395 :     if (newobj == NULL) {

  000d9	48 83 7c 24 38
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  000df	75 11		 jne	 SHORT $LN4@long_subty

; 4396 :         Py_DECREF(tmp);

  000e1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp$[rsp]
  000e6	e8 00 00 00 00	 call	 _Py_DecRef

; 4397 :         return NULL;

  000eb	33 c0		 xor	 eax, eax
  000ed	e9 98 00 00 00	 jmp	 $LN7@long_subty
$LN4@long_subty:

; 4398 :     }
; 4399 :     assert(PyLong_Check(newobj));

  000f2	48 8b 44 24 38	 mov	 rax, QWORD PTR newobj$[rsp]
  000f7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000fb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00101	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00106	85 c0		 test	 eax, eax
  00108	75 1c		 jne	 SHORT $LN11@long_subty
  0010a	41 b8 2f 11 00
	00		 mov	 r8d, 4399		; 0000112fH
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00117	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@GCHMMLOI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00124	33 c0		 xor	 eax, eax
$LN11@long_subty:

; 4400 :     Py_SIZE(newobj) = Py_SIZE(tmp);

  00126	48 8b 44 24 38	 mov	 rax, QWORD PTR newobj$[rsp]
  0012b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp$[rsp]
  00130	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00134	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 4401 :     for (i = 0; i < n; i++)

  00138	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00141	eb 0d		 jmp	 SHORT $LN3@long_subty
$LN2@long_subty:
  00143	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00148	48 ff c0	 inc	 rax
  0014b	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN3@long_subty:
  00150	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00155	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0015a	7d 1f		 jge	 SHORT $LN1@long_subty

; 4402 :         newobj->ob_digit[i] = tmp->ob_digit[i];

  0015c	48 8b 44 24 38	 mov	 rax, QWORD PTR newobj$[rsp]
  00161	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00166	48 8b 54 24 30	 mov	 rdx, QWORD PTR tmp$[rsp]
  0016b	4c 8b 44 24 28	 mov	 r8, QWORD PTR i$[rsp]
  00170	42 8b 54 82 70	 mov	 edx, DWORD PTR [rdx+r8*4+112]
  00175	89 54 88 70	 mov	 DWORD PTR [rax+rcx*4+112], edx
  00179	eb c8		 jmp	 SHORT $LN2@long_subty
$LN1@long_subty:

; 4403 :     Py_DECREF(tmp);

  0017b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp$[rsp]
  00180	e8 00 00 00 00	 call	 _Py_DecRef

; 4404 :     return (PyObject *)newobj;

  00185	48 8b 44 24 38	 mov	 rax, QWORD PTR newobj$[rsp]
$LN7@long_subty:

; 4405 : }

  0018a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0018e	c3		 ret	 0
long_subtype_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@			; `string'
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_getnewargs DD imagerel long_getnewargs
	DD	imagerel long_getnewargs+39
	DD	imagerel $unwind$long_getnewargs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_getnewargs DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@ DB '(N)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_getnewargs
_TEXT	SEGMENT
v$ = 48
long_getnewargs PROC					; COMDAT

; 4409 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4410 :     return Py_BuildValue("(N)", _PyLong_Copy(v));

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0000e	e8 00 00 00 00	 call	 _PyLong_Copy
  00013	48 8b d0	 mov	 rdx, rax
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@
  0001d	e8 00 00 00 00	 call	 Py_BuildValue

; 4411 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
long_getnewargs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_get0 DD imagerel long_get0
	DD	imagerel long_get0+26
	DD	imagerel $unwind$long_get0
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_get0 DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_get0
_TEXT	SEGMENT
v$ = 48
context$ = 56
long_get0 PROC						; COMDAT

; 4414 : long_get0(PyLongObject *v, void *context) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4415 :     return PyLong_FromLong(0L);

  0000e	33 c9		 xor	 ecx, ecx
  00010	e8 00 00 00 00	 call	 PyLong_FromLong

; 4416 : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
long_get0 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_get1 DD imagerel long_get1
	DD	imagerel long_get1+29
	DD	imagerel $unwind$long_get1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_get1 DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_get1
_TEXT	SEGMENT
v$ = 48
context$ = 56
long_get1 PROC						; COMDAT

; 4419 : long_get1(PyLongObject *v, void *context) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4420 :     return PyLong_FromLong(1L);

  0000e	b9 01 00 00 00	 mov	 ecx, 1
  00013	e8 00 00 00 00	 call	 PyLong_FromLong

; 4421 : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
long_get1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EA@DCIJOEKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@JLLBFDEO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0N@EKIKMBMC@U?3__format__?$AA@		; `string'
EXTRN	_PyUnicodeWriter_Finish:PROC
EXTRN	_PyUnicodeWriter_Dealloc:PROC
EXTRN	_PyLong_FormatAdvancedWriter:PROC
EXTRN	_PyUnicodeWriter_Init:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long__format__ DD imagerel long__format__
	DD	imagerel long__format__+246
	DD	imagerel $unwind$long__format__
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long__format__ DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_1EA@DCIJOEKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@DCIJOEKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'f', 00H
	DB	'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, '_', 00H, 's'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@JLLBFDEO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@JLLBFDEO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H
	DB	'a', 00H, 't', 00H, '_', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKIKMBMC@U?3__format__?$AA@
CONST	SEGMENT
??_C@_0N@EKIKMBMC@U?3__format__?$AA@ DB 'U:__format__', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long__format__
_TEXT	SEGMENT
writer$ = 48
format_spec$ = 104
ret$ = 112
self$ = 144
args$ = 152
long__format__ PROC					; COMDAT

; 4425 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 4426 :     PyObject *format_spec;
; 4427 :     _PyUnicodeWriter writer;
; 4428 :     int ret;
; 4429 : 
; 4430 :     if (!PyArg_ParseTuple(args, "U:__format__", &format_spec))

  00011	4c 8d 44 24 68	 lea	 r8, QWORD PTR format_spec$[rsp]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EKIKMBMC@U?3__format__?$AA@
  0001d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00025	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN2@long__form

; 4431 :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 b9 00 00 00	 jmp	 $LN3@long__form
$LN2@long__form:

; 4432 : 
; 4433 :     _PyUnicodeWriter_Init(&writer, 0);

  00035	33 d2		 xor	 edx, edx
  00037	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  0003c	e8 00 00 00 00	 call	 _PyUnicodeWriter_Init

; 4434 :     ret = _PyLong_FormatAdvancedWriter(
; 4435 :         &writer,
; 4436 :         self,
; 4437 :         format_spec, 0, PyUnicode_GET_LENGTH(format_spec));

  00041	48 8b 44 24 68	 mov	 rax, QWORD PTR format_spec$[rsp]
  00046	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00050	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00055	85 c0		 test	 eax, eax
  00057	75 1c		 jne	 SHORT $LN5@long__form
  00059	41 b8 55 11 00
	00		 mov	 r8d, 4437		; 00001155H
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@JLLBFDEO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00073	33 c0		 xor	 eax, eax
$LN5@long__form:
  00075	48 8b 44 24 68	 mov	 rax, QWORD PTR format_spec$[rsp]
  0007a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0007d	c1 e8 07	 shr	 eax, 7
  00080	83 e0 01	 and	 eax, 1
  00083	85 c0		 test	 eax, eax
  00085	75 1c		 jne	 SHORT $LN6@long__form
  00087	41 b8 55 11 00
	00		 mov	 r8d, 4437		; 00001155H
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@DCIJOEKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a1	33 c0		 xor	 eax, eax
$LN6@long__form:
  000a3	48 8b 44 24 68	 mov	 rax, QWORD PTR format_spec$[rsp]
  000a8	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b1	45 33 c9	 xor	 r9d, r9d
  000b4	4c 8b 44 24 68	 mov	 r8, QWORD PTR format_spec$[rsp]
  000b9	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  000c1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  000c6	e8 00 00 00 00	 call	 _PyLong_FormatAdvancedWriter
  000cb	89 44 24 70	 mov	 DWORD PTR ret$[rsp], eax

; 4438 :     if (ret == -1) {

  000cf	83 7c 24 70 ff	 cmp	 DWORD PTR ret$[rsp], -1
  000d4	75 0e		 jne	 SHORT $LN1@long__form

; 4439 :         _PyUnicodeWriter_Dealloc(&writer);

  000d6	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  000db	e8 00 00 00 00	 call	 _PyUnicodeWriter_Dealloc

; 4440 :         return NULL;

  000e0	33 c0		 xor	 eax, eax
  000e2	eb 0a		 jmp	 SHORT $LN3@long__form
$LN1@long__form:

; 4441 :     }
; 4442 :     return _PyUnicodeWriter_Finish(&writer);

  000e4	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  000e9	e8 00 00 00 00	 call	 _PyUnicodeWriter_Finish
$LN3@long__form:

; 4443 : }

  000ee	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000f5	c3		 ret	 0
long__format__ ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@NJOBDKOI@non?9integer?5arguments?5in?5divisio@ ; `string'
PUBLIC	_PyLong_DivmodNear
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_DivmodNear DD imagerel $LN45
	DD	imagerel $LN45+900
	DD	imagerel $unwind$_PyLong_DivmodNear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_DivmodNear DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0CC@NJOBDKOI@non?9integer?5arguments?5in?5divisio@
CONST	SEGMENT
??_C@_0CC@NJOBDKOI@non?9integer?5arguments?5in?5divisio@ DB 'non-integer '
	DB	'arguments in division', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_DivmodNear
_TEXT	SEGMENT
quo_is_neg$ = 32
rem$ = 40
quo$ = 48
temp$ = 56
twice_rem$ = 64
quo_is_odd$ = 72
one$ = 80
result$ = 88
cmp$ = 96
tv79 = 100
tv78 = 104
tv81 = 108
tv142 = 112
tv148 = 116
tv149 = 120
tv147 = 124
a$ = 144
b$ = 152
_PyLong_DivmodNear PROC					; COMDAT

; 4452 : {

$LN45:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 4453 :     PyLongObject *quo = NULL, *rem = NULL;

  00011	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR quo$[rsp], 0
  0001a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR rem$[rsp], 0

; 4454 :     PyObject *one = NULL, *twice_rem, *result, *temp;

  00023	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR one$[rsp], 0

; 4455 :     int cmp, quo_is_odd, quo_is_neg;
; 4456 : 
; 4457 :     /* Equivalent Python code:
; 4458 : 
; 4459 :        def divmod_near(a, b):
; 4460 :            q, r = divmod(a, b)
; 4461 :            # round up if either r / b > 0.5, or r / b == 0.5 and q is odd.
; 4462 :            # The expression r / b > 0.5 is equivalent to 2 * r > b if b is
; 4463 :            # positive, 2 * r < b if b negative.
; 4464 :            greater_than_half = 2*r > b if b > 0 else 2*r < b
; 4465 :            exactly_half = 2*r == b
; 4466 :            if greater_than_half or exactly_half and q % 2 == 1:
; 4467 :                q += 1
; 4468 :                r -= b
; 4469 :            return q, r
; 4470 : 
; 4471 :     */
; 4472 :     if (!PyLong_Check(a) || !PyLong_Check(b)) {

  0002c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003e	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00043	85 c0		 test	 eax, eax
  00045	74 1b		 je	 SHORT $LN27@PyLong_Div
  00047	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0004f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00053	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00059	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0005e	85 c0		 test	 eax, eax
  00060	75 1a		 jne	 SHORT $LN28@PyLong_Div
$LN27@PyLong_Div:

; 4473 :         PyErr_SetString(PyExc_TypeError,
; 4474 :                         "non-integer arguments in division");

  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@NJOBDKOI@non?9integer?5arguments?5in?5divisio@
  00069	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00070	e8 00 00 00 00	 call	 PyErr_SetString

; 4475 :         return NULL;

  00075	33 c0		 xor	 eax, eax
  00077	e9 00 03 00 00	 jmp	 $LN29@PyLong_Div
$LN28@PyLong_Div:

; 4476 :     }
; 4477 : 
; 4478 :     /* Do a and b have different signs?  If so, quotient is negative. */
; 4479 :     quo_is_neg = (Py_SIZE(a) < 0) != (Py_SIZE(b) < 0);

  0007c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00084	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00089	7d 0a		 jge	 SHORT $LN33@PyLong_Div
  0008b	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00093	eb 08		 jmp	 SHORT $LN34@PyLong_Div
$LN33@PyLong_Div:
  00095	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN34@PyLong_Div:
  0009d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000a5	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000aa	7d 0a		 jge	 SHORT $LN31@PyLong_Div
  000ac	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  000b4	eb 08		 jmp	 SHORT $LN32@PyLong_Div
$LN31@PyLong_Div:
  000b6	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN32@PyLong_Div:
  000be	8b 44 24 68	 mov	 eax, DWORD PTR tv78[rsp]
  000c2	39 44 24 64	 cmp	 DWORD PTR tv79[rsp], eax
  000c6	74 0a		 je	 SHORT $LN35@PyLong_Div
  000c8	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  000d0	eb 08		 jmp	 SHORT $LN36@PyLong_Div
$LN35@PyLong_Div:
  000d2	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN36@PyLong_Div:
  000da	8b 44 24 6c	 mov	 eax, DWORD PTR tv81[rsp]
  000de	89 44 24 20	 mov	 DWORD PTR quo_is_neg$[rsp], eax

; 4480 : 
; 4481 :     one = PyLong_FromLong(1L);

  000e2	b9 01 00 00 00	 mov	 ecx, 1
  000e7	e8 00 00 00 00	 call	 PyLong_FromLong
  000ec	48 89 44 24 50	 mov	 QWORD PTR one$[rsp], rax

; 4482 :     if (one == NULL)

  000f1	48 83 7c 24 50
	00		 cmp	 QWORD PTR one$[rsp], 0
  000f7	75 07		 jne	 SHORT $LN26@PyLong_Div

; 4483 :         return NULL;

  000f9	33 c0		 xor	 eax, eax
  000fb	e9 7c 02 00 00	 jmp	 $LN29@PyLong_Div
$LN26@PyLong_Div:

; 4484 : 
; 4485 :     if (long_divrem((PyLongObject*)a, (PyLongObject*)b, &quo, &rem) < 0)

  00100	4c 8d 4c 24 28	 lea	 r9, QWORD PTR rem$[rsp]
  00105	4c 8d 44 24 30	 lea	 r8, QWORD PTR quo$[rsp]
  0010a	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0011a	e8 00 00 00 00	 call	 long_divrem
  0011f	85 c0		 test	 eax, eax
  00121	7d 05		 jge	 SHORT $LN25@PyLong_Div

; 4486 :         goto error;

  00123	e9 0a 02 00 00	 jmp	 $error$24389
$LN25@PyLong_Div:

; 4487 : 
; 4488 :     /* compare twice the remainder with the divisor, to see
; 4489 :        if we need to adjust the quotient and remainder */
; 4490 :     twice_rem = long_lshift((PyObject *)rem, one);

  00128	48 8b 54 24 50	 mov	 rdx, QWORD PTR one$[rsp]
  0012d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rem$[rsp]
  00132	e8 00 00 00 00	 call	 long_lshift
  00137	48 89 44 24 40	 mov	 QWORD PTR twice_rem$[rsp], rax

; 4491 :     if (twice_rem == NULL)

  0013c	48 83 7c 24 40
	00		 cmp	 QWORD PTR twice_rem$[rsp], 0
  00142	75 05		 jne	 SHORT $LN24@PyLong_Div

; 4492 :         goto error;

  00144	e9 e9 01 00 00	 jmp	 $error$24389
$LN24@PyLong_Div:

; 4493 :     if (quo_is_neg) {

  00149	83 7c 24 20 00	 cmp	 DWORD PTR quo_is_neg$[rsp], 0
  0014e	74 30		 je	 SHORT $LN23@PyLong_Div

; 4494 :         temp = long_neg((PyLongObject*)twice_rem);

  00150	48 8b 4c 24 40	 mov	 rcx, QWORD PTR twice_rem$[rsp]
  00155	e8 00 00 00 00	 call	 long_neg
  0015a	48 89 44 24 38	 mov	 QWORD PTR temp$[rsp], rax

; 4495 :         Py_DECREF(twice_rem);

  0015f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR twice_rem$[rsp]
  00164	e8 00 00 00 00	 call	 _Py_DecRef

; 4496 :         twice_rem = temp;

  00169	48 8b 44 24 38	 mov	 rax, QWORD PTR temp$[rsp]
  0016e	48 89 44 24 40	 mov	 QWORD PTR twice_rem$[rsp], rax

; 4497 :         if (twice_rem == NULL)

  00173	48 83 7c 24 40
	00		 cmp	 QWORD PTR twice_rem$[rsp], 0
  00179	75 05		 jne	 SHORT $LN22@PyLong_Div

; 4498 :             goto error;

  0017b	e9 b2 01 00 00	 jmp	 $error$24389
$LN22@PyLong_Div:
$LN23@PyLong_Div:

; 4499 :     }
; 4500 :     cmp = long_compare((PyLongObject *)twice_rem, (PyLongObject *)b);

  00180	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00188	48 8b 4c 24 40	 mov	 rcx, QWORD PTR twice_rem$[rsp]
  0018d	e8 00 00 00 00	 call	 long_compare
  00192	89 44 24 60	 mov	 DWORD PTR cmp$[rsp], eax

; 4501 :     Py_DECREF(twice_rem);

  00196	48 8b 4c 24 40	 mov	 rcx, QWORD PTR twice_rem$[rsp]
  0019b	e8 00 00 00 00	 call	 _Py_DecRef

; 4502 : 
; 4503 :     quo_is_odd = Py_SIZE(quo) != 0 && ((quo->ob_digit[0] & 1) != 0);

  001a0	48 8b 44 24 30	 mov	 rax, QWORD PTR quo$[rsp]
  001a5	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001aa	74 19		 je	 SHORT $LN37@PyLong_Div
  001ac	48 8b 44 24 30	 mov	 rax, QWORD PTR quo$[rsp]
  001b1	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001b4	83 e0 01	 and	 eax, 1
  001b7	85 c0		 test	 eax, eax
  001b9	74 0a		 je	 SHORT $LN37@PyLong_Div
  001bb	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  001c3	eb 08		 jmp	 SHORT $LN38@PyLong_Div
$LN37@PyLong_Div:
  001c5	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN38@PyLong_Div:
  001cd	8b 44 24 70	 mov	 eax, DWORD PTR tv142[rsp]
  001d1	89 44 24 48	 mov	 DWORD PTR quo_is_odd$[rsp], eax

; 4504 :     if ((Py_SIZE(b) < 0 ? cmp < 0 : cmp > 0) || (cmp == 0 && quo_is_odd)) {

  001d5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  001dd	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001e2	7d 23		 jge	 SHORT $LN43@PyLong_Div
  001e4	83 7c 24 60 00	 cmp	 DWORD PTR cmp$[rsp], 0
  001e9	7d 0a		 jge	 SHORT $LN41@PyLong_Div
  001eb	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv148[rsp], 1
  001f3	eb 08		 jmp	 SHORT $LN42@PyLong_Div
$LN41@PyLong_Div:
  001f5	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv148[rsp], 0
$LN42@PyLong_Div:
  001fd	8b 44 24 74	 mov	 eax, DWORD PTR tv148[rsp]
  00201	89 44 24 78	 mov	 DWORD PTR tv149[rsp], eax
  00205	eb 21		 jmp	 SHORT $LN44@PyLong_Div
$LN43@PyLong_Div:
  00207	83 7c 24 60 00	 cmp	 DWORD PTR cmp$[rsp], 0
  0020c	7e 0a		 jle	 SHORT $LN39@PyLong_Div
  0020e	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  00216	eb 08		 jmp	 SHORT $LN40@PyLong_Div
$LN39@PyLong_Div:
  00218	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN40@PyLong_Div:
  00220	8b 44 24 7c	 mov	 eax, DWORD PTR tv147[rsp]
  00224	89 44 24 78	 mov	 DWORD PTR tv149[rsp], eax
$LN44@PyLong_Div:
  00228	83 7c 24 78 00	 cmp	 DWORD PTR tv149[rsp], 0
  0022d	75 16		 jne	 SHORT $LN20@PyLong_Div
  0022f	83 7c 24 60 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00234	0f 85 b2 00 00
	00		 jne	 $LN21@PyLong_Div
  0023a	83 7c 24 48 00	 cmp	 DWORD PTR quo_is_odd$[rsp], 0
  0023f	0f 84 a7 00 00
	00		 je	 $LN21@PyLong_Div
$LN20@PyLong_Div:

; 4505 :         /* fix up quotient */
; 4506 :         if (quo_is_neg)

  00245	83 7c 24 20 00	 cmp	 DWORD PTR quo_is_neg$[rsp], 0
  0024a	74 16		 je	 SHORT $LN19@PyLong_Div

; 4507 :             temp = long_sub(quo, (PyLongObject *)one);

  0024c	48 8b 54 24 50	 mov	 rdx, QWORD PTR one$[rsp]
  00251	48 8b 4c 24 30	 mov	 rcx, QWORD PTR quo$[rsp]
  00256	e8 00 00 00 00	 call	 long_sub
  0025b	48 89 44 24 38	 mov	 QWORD PTR temp$[rsp], rax

; 4508 :         else

  00260	eb 14		 jmp	 SHORT $LN18@PyLong_Div
$LN19@PyLong_Div:

; 4509 :             temp = long_add(quo, (PyLongObject *)one);

  00262	48 8b 54 24 50	 mov	 rdx, QWORD PTR one$[rsp]
  00267	48 8b 4c 24 30	 mov	 rcx, QWORD PTR quo$[rsp]
  0026c	e8 00 00 00 00	 call	 long_add
  00271	48 89 44 24 38	 mov	 QWORD PTR temp$[rsp], rax
$LN18@PyLong_Div:

; 4510 :         Py_DECREF(quo);

  00276	48 8b 4c 24 30	 mov	 rcx, QWORD PTR quo$[rsp]
  0027b	e8 00 00 00 00	 call	 _Py_DecRef

; 4511 :         quo = (PyLongObject *)temp;

  00280	48 8b 44 24 38	 mov	 rax, QWORD PTR temp$[rsp]
  00285	48 89 44 24 30	 mov	 QWORD PTR quo$[rsp], rax

; 4512 :         if (quo == NULL)

  0028a	48 83 7c 24 30
	00		 cmp	 QWORD PTR quo$[rsp], 0
  00290	75 05		 jne	 SHORT $LN17@PyLong_Div

; 4513 :             goto error;

  00292	e9 9b 00 00 00	 jmp	 $error$24389
$LN17@PyLong_Div:

; 4514 :         /* and remainder */
; 4515 :         if (quo_is_neg)

  00297	83 7c 24 20 00	 cmp	 DWORD PTR quo_is_neg$[rsp], 0
  0029c	74 19		 je	 SHORT $LN16@PyLong_Div

; 4516 :             temp = long_add(rem, (PyLongObject *)b);

  0029e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  002a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rem$[rsp]
  002ab	e8 00 00 00 00	 call	 long_add
  002b0	48 89 44 24 38	 mov	 QWORD PTR temp$[rsp], rax

; 4517 :         else

  002b5	eb 17		 jmp	 SHORT $LN15@PyLong_Div
$LN16@PyLong_Div:

; 4518 :             temp = long_sub(rem, (PyLongObject *)b);

  002b7	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  002bf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rem$[rsp]
  002c4	e8 00 00 00 00	 call	 long_sub
  002c9	48 89 44 24 38	 mov	 QWORD PTR temp$[rsp], rax
$LN15@PyLong_Div:

; 4519 :         Py_DECREF(rem);

  002ce	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rem$[rsp]
  002d3	e8 00 00 00 00	 call	 _Py_DecRef

; 4520 :         rem = (PyLongObject *)temp;

  002d8	48 8b 44 24 38	 mov	 rax, QWORD PTR temp$[rsp]
  002dd	48 89 44 24 28	 mov	 QWORD PTR rem$[rsp], rax

; 4521 :         if (rem == NULL)

  002e2	48 83 7c 24 28
	00		 cmp	 QWORD PTR rem$[rsp], 0
  002e8	75 02		 jne	 SHORT $LN14@PyLong_Div

; 4522 :             goto error;

  002ea	eb 46		 jmp	 SHORT $error$24389
$LN14@PyLong_Div:
$LN21@PyLong_Div:

; 4523 :     }
; 4524 : 
; 4525 :     result = PyTuple_New(2);

  002ec	b9 02 00 00 00	 mov	 ecx, 2
  002f1	e8 00 00 00 00	 call	 PyTuple_New
  002f6	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 4526 :     if (result == NULL)

  002fb	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  00301	75 02		 jne	 SHORT $LN13@PyLong_Div

; 4527 :         goto error;

  00303	eb 2d		 jmp	 SHORT $error$24389
$LN13@PyLong_Div:

; 4528 : 
; 4529 :     /* PyTuple_SET_ITEM steals references */
; 4530 :     PyTuple_SET_ITEM(result, 0, (PyObject *)quo);

  00305	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  0030a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR quo$[rsp]
  0030f	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 4531 :     PyTuple_SET_ITEM(result, 1, (PyObject *)rem);

  00313	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00318	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rem$[rsp]
  0031d	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 4532 :     Py_DECREF(one);

  00321	48 8b 4c 24 50	 mov	 rcx, QWORD PTR one$[rsp]
  00326	e8 00 00 00 00	 call	 _Py_DecRef

; 4533 :     return result;

  0032b	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00330	eb 4a		 jmp	 SHORT $LN29@PyLong_Div
$error$24389:
$LN12@PyLong_Div:

; 4534 : 
; 4535 :   error:
; 4536 :     Py_XDECREF(quo);

  00332	48 83 7c 24 30
	00		 cmp	 QWORD PTR quo$[rsp], 0
  00338	74 0a		 je	 SHORT $LN9@PyLong_Div
  0033a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR quo$[rsp]
  0033f	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@PyLong_Div:
  00344	33 c0		 xor	 eax, eax
  00346	85 c0		 test	 eax, eax
  00348	75 e8		 jne	 SHORT $LN12@PyLong_Div
$LN8@PyLong_Div:

; 4537 :     Py_XDECREF(rem);

  0034a	48 83 7c 24 28
	00		 cmp	 QWORD PTR rem$[rsp], 0
  00350	74 0a		 je	 SHORT $LN5@PyLong_Div
  00352	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rem$[rsp]
  00357	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@PyLong_Div:
  0035c	33 c0		 xor	 eax, eax
  0035e	85 c0		 test	 eax, eax
  00360	75 e8		 jne	 SHORT $LN8@PyLong_Div
$LN4@PyLong_Div:

; 4538 :     Py_XDECREF(one);

  00362	48 83 7c 24 50
	00		 cmp	 QWORD PTR one$[rsp], 0
  00368	74 0a		 je	 SHORT $LN1@PyLong_Div
  0036a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR one$[rsp]
  0036f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyLong_Div:
  00374	33 c0		 xor	 eax, eax
  00376	85 c0		 test	 eax, eax
  00378	75 e8		 jne	 SHORT $LN4@PyLong_Div

; 4539 :     return NULL;

  0037a	33 c0		 xor	 eax, eax
$LN29@PyLong_Div:

; 4540 : }

  0037c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00383	c3		 ret	 0
_PyLong_DivmodNear ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CKLEOEBD@?$HMO?$AA@			; `string'
EXTRN	PyNumber_Index:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_round DD imagerel long_round
	DD	imagerel long_round+411
	DD	imagerel $unwind$long_round
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_round DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_02CKLEOEBD@?$HMO?$AA@
CONST	SEGMENT
??_C@_02CKLEOEBD@?$HMO?$AA@ DB '|O', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_round
_TEXT	SEGMENT
temp$ = 32
ndigits$ = 40
o_ndigits$ = 48
result$ = 56
self$ = 80
args$ = 88
long_round PROC						; COMDAT

; 4544 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4545 :     PyObject *o_ndigits=NULL, *temp, *result, *ndigits;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR o_ndigits$[rsp], 0

; 4546 : 
; 4547 :     /* To round an integer m to the nearest 10**n (n positive), we make use of
; 4548 :      * the divmod_near operation, defined by:
; 4549 :      *
; 4550 :      *   divmod_near(a, b) = (q, r)
; 4551 :      *
; 4552 :      * where q is the nearest integer to the quotient a / b (the
; 4553 :      * nearest even integer in the case of a tie) and r == a - q * b.
; 4554 :      * Hence q * b = a - r is the nearest multiple of b to a,
; 4555 :      * preferring even multiples in the case of a tie.
; 4556 :      *
; 4557 :      * So the nearest multiple of 10**n to m is:
; 4558 :      *
; 4559 :      *   m - divmod_near(m, 10**n)[1].
; 4560 :      */
; 4561 :     if (!PyArg_ParseTuple(args, "|O", &o_ndigits))

  00017	4c 8d 44 24 30	 lea	 r8, QWORD PTR o_ndigits$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02CKLEOEBD@?$HMO?$AA@
  00023	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN8@long_round

; 4562 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 5e 01 00 00	 jmp	 $LN9@long_round
$LN8@long_round:

; 4563 :     if (o_ndigits == NULL)

  00038	48 83 7c 24 30
	00		 cmp	 QWORD PTR o_ndigits$[rsp], 0
  0003e	75 0f		 jne	 SHORT $LN7@long_round

; 4564 :         return long_long(self);

  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00045	e8 00 00 00 00	 call	 long_long
  0004a	e9 47 01 00 00	 jmp	 $LN9@long_round
$LN7@long_round:

; 4565 : 
; 4566 :     ndigits = PyNumber_Index(o_ndigits);

  0004f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR o_ndigits$[rsp]
  00054	e8 00 00 00 00	 call	 PyNumber_Index
  00059	48 89 44 24 28	 mov	 QWORD PTR ndigits$[rsp], rax

; 4567 :     if (ndigits == NULL)

  0005e	48 83 7c 24 28
	00		 cmp	 QWORD PTR ndigits$[rsp], 0
  00064	75 07		 jne	 SHORT $LN6@long_round

; 4568 :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	e9 29 01 00 00	 jmp	 $LN9@long_round
$LN6@long_round:

; 4569 : 
; 4570 :     /* if ndigits >= 0 then no rounding is necessary; return self unchanged */
; 4571 :     if (Py_SIZE(ndigits) >= 0) {

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR ndigits$[rsp]
  00072	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00077	7c 19		 jl	 SHORT $LN5@long_round

; 4572 :         Py_DECREF(ndigits);

  00079	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ndigits$[rsp]
  0007e	e8 00 00 00 00	 call	 _Py_DecRef

; 4573 :         return long_long(self);

  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00088	e8 00 00 00 00	 call	 long_long
  0008d	e9 04 01 00 00	 jmp	 $LN9@long_round
$LN5@long_round:

; 4574 :     }
; 4575 : 
; 4576 :     /* result = self - divmod_near(self, 10 ** -ndigits)[1] */
; 4577 :     temp = long_neg((PyLongObject*)ndigits);

  00092	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ndigits$[rsp]
  00097	e8 00 00 00 00	 call	 long_neg
  0009c	48 89 44 24 20	 mov	 QWORD PTR temp$[rsp], rax

; 4578 :     Py_DECREF(ndigits);

  000a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ndigits$[rsp]
  000a6	e8 00 00 00 00	 call	 _Py_DecRef

; 4579 :     ndigits = temp;

  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR temp$[rsp]
  000b0	48 89 44 24 28	 mov	 QWORD PTR ndigits$[rsp], rax

; 4580 :     if (ndigits == NULL)

  000b5	48 83 7c 24 28
	00		 cmp	 QWORD PTR ndigits$[rsp], 0
  000bb	75 07		 jne	 SHORT $LN4@long_round

; 4581 :         return NULL;

  000bd	33 c0		 xor	 eax, eax
  000bf	e9 d2 00 00 00	 jmp	 $LN9@long_round
$LN4@long_round:

; 4582 : 
; 4583 :     result = PyLong_FromLong(10L);

  000c4	b9 0a 00 00 00	 mov	 ecx, 10
  000c9	e8 00 00 00 00	 call	 PyLong_FromLong
  000ce	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 4584 :     if (result == NULL) {

  000d3	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  000d9	75 11		 jne	 SHORT $LN3@long_round

; 4585 :         Py_DECREF(ndigits);

  000db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ndigits$[rsp]
  000e0	e8 00 00 00 00	 call	 _Py_DecRef

; 4586 :         return NULL;

  000e5	33 c0		 xor	 eax, eax
  000e7	e9 aa 00 00 00	 jmp	 $LN9@long_round
$LN3@long_round:

; 4587 :     }
; 4588 : 
; 4589 :     temp = long_pow(result, ndigits, Py_None);

  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  000f3	48 8b 54 24 28	 mov	 rdx, QWORD PTR ndigits$[rsp]
  000f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  000fd	e8 00 00 00 00	 call	 long_pow
  00102	48 89 44 24 20	 mov	 QWORD PTR temp$[rsp], rax

; 4590 :     Py_DECREF(ndigits);

  00107	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ndigits$[rsp]
  0010c	e8 00 00 00 00	 call	 _Py_DecRef

; 4591 :     Py_DECREF(result);

  00111	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00116	e8 00 00 00 00	 call	 _Py_DecRef

; 4592 :     result = temp;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR temp$[rsp]
  00120	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 4593 :     if (result == NULL)

  00125	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  0012b	75 04		 jne	 SHORT $LN2@long_round

; 4594 :         return NULL;

  0012d	33 c0		 xor	 eax, eax
  0012f	eb 65		 jmp	 SHORT $LN9@long_round
$LN2@long_round:

; 4595 : 
; 4596 :     temp = _PyLong_DivmodNear(self, result);

  00131	48 8b 54 24 38	 mov	 rdx, QWORD PTR result$[rsp]
  00136	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0013b	e8 00 00 00 00	 call	 _PyLong_DivmodNear
  00140	48 89 44 24 20	 mov	 QWORD PTR temp$[rsp], rax

; 4597 :     Py_DECREF(result);

  00145	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  0014a	e8 00 00 00 00	 call	 _Py_DecRef

; 4598 :     result = temp;

  0014f	48 8b 44 24 20	 mov	 rax, QWORD PTR temp$[rsp]
  00154	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 4599 :     if (result == NULL)

  00159	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  0015f	75 04		 jne	 SHORT $LN1@long_round

; 4600 :         return NULL;

  00161	33 c0		 xor	 eax, eax
  00163	eb 31		 jmp	 SHORT $LN9@long_round
$LN1@long_round:

; 4601 : 
; 4602 :     temp = long_sub((PyLongObject *)self,
; 4603 :                     (PyLongObject *)PyTuple_GET_ITEM(result, 1));

  00165	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  0016a	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  0016e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00173	e8 00 00 00 00	 call	 long_sub
  00178	48 89 44 24 20	 mov	 QWORD PTR temp$[rsp], rax

; 4604 :     Py_DECREF(result);

  0017d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00182	e8 00 00 00 00	 call	 _Py_DecRef

; 4605 :     result = temp;

  00187	48 8b 44 24 20	 mov	 rax, QWORD PTR temp$[rsp]
  0018c	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 4606 : 
; 4607 :     return result;

  00191	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN9@long_round:

; 4608 : }

  00196	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0019a	c3		 ret	 0
long_round ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_sizeof DD imagerel long_sizeof
	DD	imagerel long_sizeof+87
	DD	imagerel $unwind$long_sizeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_sizeof DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_sizeof
_TEXT	SEGMENT
res$ = 32
tv69 = 40
v$ = 64
long_sizeof PROC					; COMDAT

; 4612 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4613 :     Py_ssize_t res;
; 4614 : 
; 4615 :     res = offsetof(PyLongObject, ob_digit) + ABS(Py_SIZE(v))*sizeof(digit);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	7d 13		 jge	 SHORT $LN3@long_sizeo
  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0001a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001e	48 f7 d8	 neg	 rax
  00021	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00026	eb 0e		 jmp	 SHORT $LN4@long_sizeo
$LN3@long_sizeo:
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0002d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00031	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
$LN4@long_sizeo:
  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR tv69[rsp]
  0003b	48 8d 04 85 70
	00 00 00	 lea	 rax, QWORD PTR [rax*4+112]
  00043	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 4616 :     return PyLong_FromSsize_t(res);

  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  0004d	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 4617 : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
long_sizeof ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_bit_length DD imagerel long_bit_length
	DD	imagerel long_bit_length+543
	DD	imagerel $unwind$long_bit_length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_bit_length DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT long_bit_length
_TEXT	SEGMENT
msd$ = 32
y$ = 40
x$ = 48
msd_bits$ = 56
ndigits$ = 64
result$ = 72
tv82 = 80
v$ = 112
long_bit_length PROC					; COMDAT

; 4621 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4622 :     PyLongObject *result, *x, *y;
; 4623 :     Py_ssize_t ndigits, msd_bits = 0;

  00009	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR msd_bits$[rsp], 0

; 4624 :     digit msd;
; 4625 : 
; 4626 :     assert(v != NULL);

  00012	48 83 7c 24 70
	00		 cmp	 QWORD PTR v$[rsp], 0
  00018	75 1c		 jne	 SHORT $LN12@long_bit_l
  0001a	41 b8 12 12 00
	00		 mov	 r8d, 4626		; 00001212H
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00034	33 c0		 xor	 eax, eax
$LN12@long_bit_l:

; 4627 :     assert(PyLong_Check(v));

  00036	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  0003b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00045	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0004a	85 c0		 test	 eax, eax
  0004c	75 1c		 jne	 SHORT $LN13@long_bit_l
  0004e	41 b8 13 12 00
	00		 mov	 r8d, 4627		; 00001213H
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00068	33 c0		 xor	 eax, eax
$LN13@long_bit_l:

; 4628 : 
; 4629 :     ndigits = ABS(Py_SIZE(v));

  0006a	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  0006f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00074	7d 13		 jge	 SHORT $LN14@long_bit_l
  00076	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  0007b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0007f	48 f7 d8	 neg	 rax
  00082	48 89 44 24 50	 mov	 QWORD PTR tv82[rsp], rax
  00087	eb 0e		 jmp	 SHORT $LN15@long_bit_l
$LN14@long_bit_l:
  00089	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  0008e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00092	48 89 44 24 50	 mov	 QWORD PTR tv82[rsp], rax
$LN15@long_bit_l:
  00097	48 8b 44 24 50	 mov	 rax, QWORD PTR tv82[rsp]
  0009c	48 89 44 24 40	 mov	 QWORD PTR ndigits$[rsp], rax

; 4630 :     if (ndigits == 0)

  000a1	48 83 7c 24 40
	00		 cmp	 QWORD PTR ndigits$[rsp], 0
  000a7	75 0c		 jne	 SHORT $LN9@long_bit_l

; 4631 :         return PyLong_FromLong(0);

  000a9	33 c9		 xor	 ecx, ecx
  000ab	e8 00 00 00 00	 call	 PyLong_FromLong
  000b0	e9 65 01 00 00	 jmp	 $LN10@long_bit_l
$LN9@long_bit_l:

; 4632 : 
; 4633 :     msd = v->ob_digit[ndigits-1];

  000b5	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  000ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ndigits$[rsp]
  000bf	8b 44 88 6c	 mov	 eax, DWORD PTR [rax+rcx*4+108]
  000c3	89 44 24 20	 mov	 DWORD PTR msd$[rsp], eax
$LN8@long_bit_l:

; 4634 :     while (msd >= 32) {

  000c7	83 7c 24 20 20	 cmp	 DWORD PTR msd$[rsp], 32	; 00000020H
  000cc	72 1b		 jb	 SHORT $LN7@long_bit_l

; 4635 :         msd_bits += 6;

  000ce	48 8b 44 24 38	 mov	 rax, QWORD PTR msd_bits$[rsp]
  000d3	48 83 c0 06	 add	 rax, 6
  000d7	48 89 44 24 38	 mov	 QWORD PTR msd_bits$[rsp], rax

; 4636 :         msd >>= 6;

  000dc	8b 44 24 20	 mov	 eax, DWORD PTR msd$[rsp]
  000e0	c1 e8 06	 shr	 eax, 6
  000e3	89 44 24 20	 mov	 DWORD PTR msd$[rsp], eax

; 4637 :     }

  000e7	eb de		 jmp	 SHORT $LN8@long_bit_l
$LN7@long_bit_l:

; 4638 :     msd_bits += (long)(BitLengthTable[msd]);

  000e9	8b 44 24 20	 mov	 eax, DWORD PTR msd$[rsp]
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:BitLengthTable
  000f4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR msd_bits$[rsp]
  000fd	48 03 c8	 add	 rcx, rax
  00100	48 8b c1	 mov	 rax, rcx
  00103	48 89 44 24 38	 mov	 QWORD PTR msd_bits$[rsp], rax

; 4639 : 
; 4640 :     if (ndigits <= PY_SSIZE_T_MAX/PyLong_SHIFT)

  00108	48 b8 44 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825860	; 0444444444444444H
  00112	48 39 44 24 40	 cmp	 QWORD PTR ndigits$[rsp], rax
  00117	7f 1e		 jg	 SHORT $LN6@long_bit_l

; 4641 :         return PyLong_FromSsize_t((ndigits-1)*PyLong_SHIFT + msd_bits);

  00119	48 8b 44 24 40	 mov	 rax, QWORD PTR ndigits$[rsp]
  0011e	48 ff c8	 dec	 rax
  00121	48 6b c0 1e	 imul	 rax, 30
  00125	48 03 44 24 38	 add	 rax, QWORD PTR msd_bits$[rsp]
  0012a	48 8b c8	 mov	 rcx, rax
  0012d	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00132	e9 e3 00 00 00	 jmp	 $LN10@long_bit_l
$LN6@long_bit_l:

; 4642 : 
; 4643 :     /* expression above may overflow; use Python integers instead */
; 4644 :     result = (PyLongObject *)PyLong_FromSsize_t(ndigits - 1);

  00137	48 8b 44 24 40	 mov	 rax, QWORD PTR ndigits$[rsp]
  0013c	48 ff c8	 dec	 rax
  0013f	48 8b c8	 mov	 rcx, rax
  00142	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00147	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 4645 :     if (result == NULL)

  0014c	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  00152	75 07		 jne	 SHORT $LN5@long_bit_l

; 4646 :         return NULL;

  00154	33 c0		 xor	 eax, eax
  00156	e9 bf 00 00 00	 jmp	 $LN10@long_bit_l
$LN5@long_bit_l:

; 4647 :     x = (PyLongObject *)PyLong_FromLong(PyLong_SHIFT);

  0015b	b9 1e 00 00 00	 mov	 ecx, 30
  00160	e8 00 00 00 00	 call	 PyLong_FromLong
  00165	48 89 44 24 30	 mov	 QWORD PTR x$[rsp], rax

; 4648 :     if (x == NULL)

  0016a	48 83 7c 24 30
	00		 cmp	 QWORD PTR x$[rsp], 0
  00170	75 05		 jne	 SHORT $LN4@long_bit_l

; 4649 :         goto error;

  00172	e9 97 00 00 00	 jmp	 $error$24532
$LN4@long_bit_l:

; 4650 :     y = (PyLongObject *)long_mul(result, x);

  00177	48 8b 54 24 30	 mov	 rdx, QWORD PTR x$[rsp]
  0017c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00181	e8 00 00 00 00	 call	 long_mul
  00186	48 89 44 24 28	 mov	 QWORD PTR y$[rsp], rax

; 4651 :     Py_DECREF(x);

  0018b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  00190	e8 00 00 00 00	 call	 _Py_DecRef

; 4652 :     if (y == NULL)

  00195	48 83 7c 24 28
	00		 cmp	 QWORD PTR y$[rsp], 0
  0019b	75 02		 jne	 SHORT $LN3@long_bit_l

; 4653 :         goto error;

  0019d	eb 6f		 jmp	 SHORT $error$24532
$LN3@long_bit_l:

; 4654 :     Py_DECREF(result);

  0019f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  001a4	e8 00 00 00 00	 call	 _Py_DecRef

; 4655 :     result = y;

  001a9	48 8b 44 24 28	 mov	 rax, QWORD PTR y$[rsp]
  001ae	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 4656 : 
; 4657 :     x = (PyLongObject *)PyLong_FromLong((long)msd_bits);

  001b3	8b 4c 24 38	 mov	 ecx, DWORD PTR msd_bits$[rsp]
  001b7	e8 00 00 00 00	 call	 PyLong_FromLong
  001bc	48 89 44 24 30	 mov	 QWORD PTR x$[rsp], rax

; 4658 :     if (x == NULL)

  001c1	48 83 7c 24 30
	00		 cmp	 QWORD PTR x$[rsp], 0
  001c7	75 02		 jne	 SHORT $LN2@long_bit_l

; 4659 :         goto error;

  001c9	eb 43		 jmp	 SHORT $error$24532
$LN2@long_bit_l:

; 4660 :     y = (PyLongObject *)long_add(result, x);

  001cb	48 8b 54 24 30	 mov	 rdx, QWORD PTR x$[rsp]
  001d0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  001d5	e8 00 00 00 00	 call	 long_add
  001da	48 89 44 24 28	 mov	 QWORD PTR y$[rsp], rax

; 4661 :     Py_DECREF(x);

  001df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  001e4	e8 00 00 00 00	 call	 _Py_DecRef

; 4662 :     if (y == NULL)

  001e9	48 83 7c 24 28
	00		 cmp	 QWORD PTR y$[rsp], 0
  001ef	75 02		 jne	 SHORT $LN1@long_bit_l

; 4663 :         goto error;

  001f1	eb 1b		 jmp	 SHORT $error$24532
$LN1@long_bit_l:

; 4664 :     Py_DECREF(result);

  001f3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  001f8	e8 00 00 00 00	 call	 _Py_DecRef

; 4665 :     result = y;

  001fd	48 8b 44 24 28	 mov	 rax, QWORD PTR y$[rsp]
  00202	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 4666 : 
; 4667 :     return (PyObject *)result;

  00207	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  0020c	eb 0c		 jmp	 SHORT $LN10@long_bit_l
$error$24532:

; 4668 : 
; 4669 :   error:
; 4670 :     Py_DECREF(result);

  0020e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00213	e8 00 00 00 00	 call	 _Py_DecRef

; 4671 :     return NULL;

  00218	33 c0		 xor	 eax, eax
$LN10@long_bit_l:

; 4672 : }

  0021a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0021e	c3		 ret	 0
long_bit_length ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CF@DOGCLHPA@length?5argument?5must?5be?5non?9nega@ ; `string'
PUBLIC	??_C@_0CL@NMHKNCFJ@byteorder?5must?5be?5either?5?8little@ ; `string'
PUBLIC	??_C@_03CCCOBCKE@big?$AA@			; `string'
PUBLIC	??_C@_06LADGIEOA@little?$AA@			; `string'
PUBLIC	??_C@_0CE@NEILIJIN@?8signed?8?5is?5a?5keyword?9only?5argum@ ; `string'
PUBLIC	??_C@_0O@IDCGKBE@nU?$HMO?3to_bytes?$AA@		; `string'
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyUnicode_CompareWithASCIIString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_to_bytes DD imagerel long_to_bytes
	DD	imagerel long_to_bytes+509
	DD	imagerel $unwind$long_to_bytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_to_bytes DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DOGCLHPA@length?5argument?5must?5be?5non?9nega@
CONST	SEGMENT
??_C@_0CF@DOGCLHPA@length?5argument?5must?5be?5non?9nega@ DB 'length argu'
	DB	'ment must be non-negative', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NMHKNCFJ@byteorder?5must?5be?5either?5?8little@
CONST	SEGMENT
??_C@_0CL@NMHKNCFJ@byteorder?5must?5be?5either?5?8little@ DB 'byteorder m'
	DB	'ust be either ''little'' or ''big''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCCOBCKE@big?$AA@
CONST	SEGMENT
??_C@_03CCCOBCKE@big?$AA@ DB 'big', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LADGIEOA@little?$AA@
CONST	SEGMENT
??_C@_06LADGIEOA@little?$AA@ DB 'little', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NEILIJIN@?8signed?8?5is?5a?5keyword?9only?5argum@
CONST	SEGMENT
??_C@_0CE@NEILIJIN@?8signed?8?5is?5a?5keyword?9only?5argum@ DB '''signed'''
	DB	' is a keyword-only argument', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IDCGKBE@nU?$HMO?3to_bytes?$AA@
CONST	SEGMENT
??_C@_0O@IDCGKBE@nU?$HMO?3to_bytes?$AA@ DB 'nU|O:to_bytes', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_to_bytes
_TEXT	SEGMENT
length$ = 64
little_endian$ = 72
is_signed$ = 76
is_signed_obj$ = 80
bytes$ = 88
byteorder_str$ = 96
cmp$24590 = 104
tv93 = 108
v$ = 128
args$ = 136
kwds$ = 144
long_to_bytes PROC					; COMDAT

; 4694 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4695 :     PyObject *byteorder_str;
; 4696 :     PyObject *is_signed_obj = NULL;

  00013	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR is_signed_obj$[rsp], 0

; 4697 :     Py_ssize_t length;
; 4698 :     int little_endian;
; 4699 :     int is_signed;
; 4700 :     PyObject *bytes;
; 4701 :     static char *kwlist[] = {"length", "byteorder", "signed", NULL};
; 4702 : 
; 4703 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "nU|O:to_bytes", kwlist,
; 4704 :                                      &length, &byteorder_str,
; 4705 :                                      &is_signed_obj))

  0001c	48 8d 44 24 50	 lea	 rax, QWORD PTR is_signed_obj$[rsp]
  00021	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00026	48 8d 44 24 60	 lea	 rax, QWORD PTR byteorder_str$[rsp]
  0002b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00030	48 8d 44 24 40	 lea	 rax, QWORD PTR length$[rsp]
  00035	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??long_to_bytes@@9@9
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@IDCGKBE@nU?$HMO?3to_bytes?$AA@
  00048	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00050	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00058	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0005d	85 c0		 test	 eax, eax
  0005f	75 07		 jne	 SHORT $LN12@long_to_by

; 4706 :         return NULL;

  00061	33 c0		 xor	 eax, eax
  00063	e9 90 01 00 00	 jmp	 $LN13@long_to_by
$LN12@long_to_by:

; 4707 : 
; 4708 :     if (args != NULL && Py_SIZE(args) > 2) {

  00068	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR args$[rsp], 0
  00071	74 29		 je	 SHORT $LN11@long_to_by
  00073	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  0007b	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  00080	7e 1a		 jle	 SHORT $LN11@long_to_by

; 4709 :         PyErr_SetString(PyExc_TypeError,
; 4710 :             "'signed' is a keyword-only argument");

  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NEILIJIN@?8signed?8?5is?5a?5keyword?9only?5argum@
  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00090	e8 00 00 00 00	 call	 PyErr_SetString

; 4711 :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	e9 5c 01 00 00	 jmp	 $LN13@long_to_by
$LN11@long_to_by:

; 4712 :     }
; 4713 : 
; 4714 :     if (!PyUnicode_CompareWithASCIIString(byteorder_str, "little"))

  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06LADGIEOA@little?$AA@
  000a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR byteorder_str$[rsp]
  000a8	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  000ad	85 c0		 test	 eax, eax
  000af	75 0a		 jne	 SHORT $LN10@long_to_by

; 4715 :         little_endian = 1;

  000b1	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR little_endian$[rsp], 1
  000b9	eb 39		 jmp	 SHORT $LN9@long_to_by
$LN10@long_to_by:

; 4716 :     else if (!PyUnicode_CompareWithASCIIString(byteorder_str, "big"))

  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03CCCOBCKE@big?$AA@
  000c2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR byteorder_str$[rsp]
  000c7	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  000cc	85 c0		 test	 eax, eax
  000ce	75 0a		 jne	 SHORT $LN8@long_to_by

; 4717 :         little_endian = 0;

  000d0	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR little_endian$[rsp], 0

; 4718 :     else {

  000d8	eb 1a		 jmp	 SHORT $LN7@long_to_by
$LN8@long_to_by:

; 4719 :         PyErr_SetString(PyExc_ValueError,
; 4720 :             "byteorder must be either 'little' or 'big'");

  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@NMHKNCFJ@byteorder?5must?5be?5either?5?8little@
  000e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000e8	e8 00 00 00 00	 call	 PyErr_SetString

; 4721 :         return NULL;

  000ed	33 c0		 xor	 eax, eax
  000ef	e9 04 01 00 00	 jmp	 $LN13@long_to_by
$LN7@long_to_by:
$LN9@long_to_by:

; 4722 :     }
; 4723 : 
; 4724 :     if (is_signed_obj != NULL) {

  000f4	48 83 7c 24 50
	00		 cmp	 QWORD PTR is_signed_obj$[rsp], 0
  000fa	74 3f		 je	 SHORT $LN6@long_to_by

; 4725 :         int cmp = PyObject_IsTrue(is_signed_obj);

  000fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR is_signed_obj$[rsp]
  00101	e8 00 00 00 00	 call	 PyObject_IsTrue
  00106	89 44 24 68	 mov	 DWORD PTR cmp$24590[rsp], eax

; 4726 :         if (cmp < 0)

  0010a	83 7c 24 68 00	 cmp	 DWORD PTR cmp$24590[rsp], 0
  0010f	7d 07		 jge	 SHORT $LN5@long_to_by

; 4727 :             return NULL;

  00111	33 c0		 xor	 eax, eax
  00113	e9 e0 00 00 00	 jmp	 $LN13@long_to_by
$LN5@long_to_by:

; 4728 :         is_signed = cmp ? 1 : 0;

  00118	83 7c 24 68 00	 cmp	 DWORD PTR cmp$24590[rsp], 0
  0011d	74 0a		 je	 SHORT $LN15@long_to_by
  0011f	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  00127	eb 08		 jmp	 SHORT $LN16@long_to_by
$LN15@long_to_by:
  00129	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN16@long_to_by:
  00131	8b 44 24 6c	 mov	 eax, DWORD PTR tv93[rsp]
  00135	89 44 24 4c	 mov	 DWORD PTR is_signed$[rsp], eax

; 4729 :     }
; 4730 :     else {

  00139	eb 08		 jmp	 SHORT $LN4@long_to_by
$LN6@long_to_by:

; 4731 :         /* If the signed argument was omitted, use False as the
; 4732 :            default. */
; 4733 :         is_signed = 0;

  0013b	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR is_signed$[rsp], 0
$LN4@long_to_by:

; 4734 :     }
; 4735 : 
; 4736 :     if (length < 0) {

  00143	48 83 7c 24 40
	00		 cmp	 QWORD PTR length$[rsp], 0
  00149	7d 1a		 jge	 SHORT $LN3@long_to_by

; 4737 :         PyErr_SetString(PyExc_ValueError,
; 4738 :                         "length argument must be non-negative");

  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@DOGCLHPA@length?5argument?5must?5be?5non?9nega@
  00152	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00159	e8 00 00 00 00	 call	 PyErr_SetString

; 4739 :         return NULL;

  0015e	33 c0		 xor	 eax, eax
  00160	e9 93 00 00 00	 jmp	 $LN13@long_to_by
$LN3@long_to_by:

; 4740 :     }
; 4741 : 
; 4742 :     bytes = PyBytes_FromStringAndSize(NULL, length);

  00165	48 8b 54 24 40	 mov	 rdx, QWORD PTR length$[rsp]
  0016a	33 c9		 xor	 ecx, ecx
  0016c	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00171	48 89 44 24 58	 mov	 QWORD PTR bytes$[rsp], rax

; 4743 :     if (bytes == NULL)

  00176	48 83 7c 24 58
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  0017c	75 04		 jne	 SHORT $LN2@long_to_by

; 4744 :         return NULL;

  0017e	33 c0		 xor	 eax, eax
  00180	eb 76		 jmp	 SHORT $LN13@long_to_by
$LN2@long_to_by:

; 4745 : 
; 4746 :     if (_PyLong_AsByteArray(v, (unsigned char *)PyBytes_AS_STRING(bytes),
; 4747 :                             length, little_endian, is_signed) < 0) {

  00182	48 8b 44 24 58	 mov	 rax, QWORD PTR bytes$[rsp]
  00187	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0018b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00191	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00196	85 c0		 test	 eax, eax
  00198	75 1c		 jne	 SHORT $LN17@long_to_by
  0019a	41 b8 8a 12 00
	00		 mov	 r8d, 4746		; 0000128aH
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b4	33 c0		 xor	 eax, eax
$LN17@long_to_by:
  001b6	48 8b 44 24 58	 mov	 rax, QWORD PTR bytes$[rsp]
  001bb	48 83 c0 78	 add	 rax, 120		; 00000078H
  001bf	8b 4c 24 4c	 mov	 ecx, DWORD PTR is_signed$[rsp]
  001c3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  001c7	44 8b 4c 24 48	 mov	 r9d, DWORD PTR little_endian$[rsp]
  001cc	4c 8b 44 24 40	 mov	 r8, QWORD PTR length$[rsp]
  001d1	48 8b d0	 mov	 rdx, rax
  001d4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  001dc	e8 00 00 00 00	 call	 _PyLong_AsByteArray
  001e1	85 c0		 test	 eax, eax
  001e3	7d 0e		 jge	 SHORT $LN1@long_to_by

; 4748 :         Py_DECREF(bytes);

  001e5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bytes$[rsp]
  001ea	e8 00 00 00 00	 call	 _Py_DecRef

; 4749 :         return NULL;

  001ef	33 c0		 xor	 eax, eax
  001f1	eb 05		 jmp	 SHORT $LN13@long_to_by
$LN1@long_to_by:

; 4750 :     }
; 4751 : 
; 4752 :     return bytes;

  001f3	48 8b 44 24 58	 mov	 rax, QWORD PTR bytes$[rsp]
$LN13@long_to_by:

; 4753 : }

  001f8	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001fc	c3		 ret	 0
long_to_bytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@OCGOJEAF@OU?$HMO?3from_bytes?$AA@	; `string'
EXTRN	PyObject_Bytes:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_from_bytes DD imagerel long_from_bytes
	DD	imagerel long_from_bytes+837
	DD	imagerel $unwind$long_from_bytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_from_bytes DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_0BA@OCGOJEAF@OU?$HMO?3from_bytes?$AA@
CONST	SEGMENT
??_C@_0BA@OCGOJEAF@OU?$HMO?3from_bytes?$AA@ DB 'OU|O:from_bytes', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT long_from_bytes
_TEXT	SEGMENT
little_endian$ = 64
is_signed$ = 68
is_signed_obj$ = 72
bytes$ = 80
long_obj$ = 88
obj$ = 96
byteorder_str$ = 104
cmp$24644 = 112
n$24660 = 120
i$24659 = 128
newobj$24658 = 136
tv93 = 144
tv155 = 152
type$ = 176
args$ = 184
kwds$ = 192
long_from_bytes PROC					; COMDAT

; 4776 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 4777 :     PyObject *byteorder_str;
; 4778 :     PyObject *is_signed_obj = NULL;

  00016	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR is_signed_obj$[rsp], 0

; 4779 :     int little_endian;
; 4780 :     int is_signed;
; 4781 :     PyObject *obj;
; 4782 :     PyObject *bytes;
; 4783 :     PyObject *long_obj;
; 4784 :     static char *kwlist[] = {"bytes", "byteorder", "signed", NULL};
; 4785 : 
; 4786 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "OU|O:from_bytes", kwlist,
; 4787 :                                      &obj, &byteorder_str,
; 4788 :                                      &is_signed_obj))

  0001f	48 8d 44 24 48	 lea	 rax, QWORD PTR is_signed_obj$[rsp]
  00024	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00029	48 8d 44 24 68	 lea	 rax, QWORD PTR byteorder_str$[rsp]
  0002e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00033	48 8d 44 24 60	 lea	 rax, QWORD PTR obj$[rsp]
  00038	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??long_from_bytes@@9@9
  00044	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@OCGOJEAF@OU?$HMO?3from_bytes?$AA@
  0004b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00053	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0005b	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00060	85 c0		 test	 eax, eax
  00062	75 07		 jne	 SHORT $LN15@long_from_@2

; 4789 :         return NULL;

  00064	33 c0		 xor	 eax, eax
  00066	e9 d2 02 00 00	 jmp	 $LN16@long_from_@2
$LN15@long_from_@2:

; 4790 : 
; 4791 :     if (args != NULL && Py_SIZE(args) > 2) {

  0006b	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR args$[rsp], 0
  00074	74 29		 je	 SHORT $LN14@long_from_@2
  00076	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  0007e	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  00083	7e 1a		 jle	 SHORT $LN14@long_from_@2

; 4792 :         PyErr_SetString(PyExc_TypeError,
; 4793 :             "'signed' is a keyword-only argument");

  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NEILIJIN@?8signed?8?5is?5a?5keyword?9only?5argum@
  0008c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00093	e8 00 00 00 00	 call	 PyErr_SetString

; 4794 :         return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	e9 9e 02 00 00	 jmp	 $LN16@long_from_@2
$LN14@long_from_@2:

; 4795 :     }
; 4796 : 
; 4797 :     if (!PyUnicode_CompareWithASCIIString(byteorder_str, "little"))

  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06LADGIEOA@little?$AA@
  000a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR byteorder_str$[rsp]
  000ab	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  000b0	85 c0		 test	 eax, eax
  000b2	75 0a		 jne	 SHORT $LN13@long_from_@2

; 4798 :         little_endian = 1;

  000b4	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR little_endian$[rsp], 1
  000bc	eb 39		 jmp	 SHORT $LN12@long_from_@2
$LN13@long_from_@2:

; 4799 :     else if (!PyUnicode_CompareWithASCIIString(byteorder_str, "big"))

  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03CCCOBCKE@big?$AA@
  000c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR byteorder_str$[rsp]
  000ca	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  000cf	85 c0		 test	 eax, eax
  000d1	75 0a		 jne	 SHORT $LN11@long_from_@2

; 4800 :         little_endian = 0;

  000d3	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR little_endian$[rsp], 0

; 4801 :     else {

  000db	eb 1a		 jmp	 SHORT $LN10@long_from_@2
$LN11@long_from_@2:

; 4802 :         PyErr_SetString(PyExc_ValueError,
; 4803 :             "byteorder must be either 'little' or 'big'");

  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@NMHKNCFJ@byteorder?5must?5be?5either?5?8little@
  000e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000eb	e8 00 00 00 00	 call	 PyErr_SetString

; 4804 :         return NULL;

  000f0	33 c0		 xor	 eax, eax
  000f2	e9 46 02 00 00	 jmp	 $LN16@long_from_@2
$LN10@long_from_@2:
$LN12@long_from_@2:

; 4805 :     }
; 4806 : 
; 4807 :     if (is_signed_obj != NULL) {

  000f7	48 83 7c 24 48
	00		 cmp	 QWORD PTR is_signed_obj$[rsp], 0
  000fd	74 48		 je	 SHORT $LN9@long_from_@2

; 4808 :         int cmp = PyObject_IsTrue(is_signed_obj);

  000ff	48 8b 4c 24 48	 mov	 rcx, QWORD PTR is_signed_obj$[rsp]
  00104	e8 00 00 00 00	 call	 PyObject_IsTrue
  00109	89 44 24 70	 mov	 DWORD PTR cmp$24644[rsp], eax

; 4809 :         if (cmp < 0)

  0010d	83 7c 24 70 00	 cmp	 DWORD PTR cmp$24644[rsp], 0
  00112	7d 07		 jge	 SHORT $LN8@long_from_@2

; 4810 :             return NULL;

  00114	33 c0		 xor	 eax, eax
  00116	e9 22 02 00 00	 jmp	 $LN16@long_from_@2
$LN8@long_from_@2:

; 4811 :         is_signed = cmp ? 1 : 0;

  0011b	83 7c 24 70 00	 cmp	 DWORD PTR cmp$24644[rsp], 0
  00120	74 0d		 je	 SHORT $LN18@long_from_@2
  00122	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv93[rsp], 1
  0012d	eb 0b		 jmp	 SHORT $LN19@long_from_@2
$LN18@long_from_@2:
  0012f	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv93[rsp], 0
$LN19@long_from_@2:
  0013a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv93[rsp]
  00141	89 44 24 44	 mov	 DWORD PTR is_signed$[rsp], eax

; 4812 :     }
; 4813 :     else {

  00145	eb 08		 jmp	 SHORT $LN7@long_from_@2
$LN9@long_from_@2:

; 4814 :         /* If the signed argument was omitted, use False as the
; 4815 :            default. */
; 4816 :         is_signed = 0;

  00147	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR is_signed$[rsp], 0
$LN7@long_from_@2:

; 4817 :     }
; 4818 : 
; 4819 :     bytes = PyObject_Bytes(obj);

  0014f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR obj$[rsp]
  00154	e8 00 00 00 00	 call	 PyObject_Bytes
  00159	48 89 44 24 50	 mov	 QWORD PTR bytes$[rsp], rax

; 4820 :     if (bytes == NULL)

  0015e	48 83 7c 24 50
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  00164	75 07		 jne	 SHORT $LN6@long_from_@2

; 4821 :         return NULL;

  00166	33 c0		 xor	 eax, eax
  00168	e9 d0 01 00 00	 jmp	 $LN16@long_from_@2
$LN6@long_from_@2:

; 4822 : 
; 4823 :     long_obj = _PyLong_FromByteArray(
; 4824 :         (unsigned char *)PyBytes_AS_STRING(bytes), Py_SIZE(bytes),
; 4825 :         little_endian, is_signed);

  0016d	48 8b 44 24 50	 mov	 rax, QWORD PTR bytes$[rsp]
  00172	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00176	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0017c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00181	85 c0		 test	 eax, eax
  00183	75 1c		 jne	 SHORT $LN20@long_from_@2
  00185	41 b8 d8 12 00
	00		 mov	 r8d, 4824		; 000012d8H
  0018b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  00199	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0019f	33 c0		 xor	 eax, eax
$LN20@long_from_@2:
  001a1	48 8b 44 24 50	 mov	 rax, QWORD PTR bytes$[rsp]
  001a6	48 83 c0 78	 add	 rax, 120		; 00000078H
  001aa	44 8b 4c 24 44	 mov	 r9d, DWORD PTR is_signed$[rsp]
  001af	44 8b 44 24 40	 mov	 r8d, DWORD PTR little_endian$[rsp]
  001b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bytes$[rsp]
  001b9	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  001bd	48 8b c8	 mov	 rcx, rax
  001c0	e8 00 00 00 00	 call	 _PyLong_FromByteArray
  001c5	48 89 44 24 58	 mov	 QWORD PTR long_obj$[rsp], rax

; 4826 :     Py_DECREF(bytes);

  001ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bytes$[rsp]
  001cf	e8 00 00 00 00	 call	 _Py_DecRef

; 4827 : 
; 4828 :     /* If from_bytes() was used on subclass, allocate new subclass
; 4829 :      * instance, initialize it with decoded int value and return it.
; 4830 :      */
; 4831 :     if (type != &PyLong_Type && PyType_IsSubtype(type, &PyLong_Type)) {

  001d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  001db	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR type$[rsp], rax
  001e3	0f 84 4f 01 00
	00		 je	 $LN5@long_from_@2
  001e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyLong_Type
  001f0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  001f8	e8 00 00 00 00	 call	 PyType_IsSubtype
  001fd	85 c0		 test	 eax, eax
  001ff	0f 84 33 01 00
	00		 je	 $LN5@long_from_@2

; 4832 :         PyLongObject *newobj;
; 4833 :         int i;
; 4834 :         Py_ssize_t n = ABS(Py_SIZE(long_obj));

  00205	48 8b 44 24 58	 mov	 rax, QWORD PTR long_obj$[rsp]
  0020a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0020f	7d 16		 jge	 SHORT $LN21@long_from_@2
  00211	48 8b 44 24 58	 mov	 rax, QWORD PTR long_obj$[rsp]
  00216	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0021a	48 f7 d8	 neg	 rax
  0021d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  00225	eb 11		 jmp	 SHORT $LN22@long_from_@2
$LN21@long_from_@2:
  00227	48 8b 44 24 58	 mov	 rax, QWORD PTR long_obj$[rsp]
  0022c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00230	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN22@long_from_@2:
  00238	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv155[rsp]
  00240	48 89 44 24 78	 mov	 QWORD PTR n$24660[rsp], rax

; 4835 : 
; 4836 :         newobj = (PyLongObject *)type->tp_alloc(type, n);

  00245	48 8b 54 24 78	 mov	 rdx, QWORD PTR n$24660[rsp]
  0024a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  00252	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  0025a	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00260	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR newobj$24658[rsp], rax

; 4837 :         if (newobj == NULL) {

  00268	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR newobj$24658[rsp], 0
  00271	75 11		 jne	 SHORT $LN4@long_from_@2

; 4838 :             Py_DECREF(long_obj);

  00273	48 8b 4c 24 58	 mov	 rcx, QWORD PTR long_obj$[rsp]
  00278	e8 00 00 00 00	 call	 _Py_DecRef

; 4839 :             return NULL;

  0027d	33 c0		 xor	 eax, eax
  0027f	e9 b9 00 00 00	 jmp	 $LN16@long_from_@2
$LN4@long_from_@2:

; 4840 :         }
; 4841 :         assert(PyLong_Check(newobj));

  00284	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR newobj$24658[rsp]
  0028c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00290	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00296	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0029b	85 c0		 test	 eax, eax
  0029d	75 1c		 jne	 SHORT $LN23@long_from_@2
  0029f	41 b8 e9 12 00
	00		 mov	 r8d, 4841		; 000012e9H
  002a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@GCHMMLOI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002b9	33 c0		 xor	 eax, eax
$LN23@long_from_@2:

; 4842 :         Py_SIZE(newobj) = Py_SIZE(long_obj);

  002bb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR newobj$24658[rsp]
  002c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR long_obj$[rsp]
  002c8	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  002cc	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 4843 :         for (i = 0; i < n; i++) {

  002d0	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$24659[rsp], 0
  002db	eb 10		 jmp	 SHORT $LN3@long_from_@2
$LN2@long_from_@2:
  002dd	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$24659[rsp]
  002e4	ff c0		 inc	 eax
  002e6	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$24659[rsp], eax
$LN3@long_from_@2:
  002ed	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$24659[rsp]
  002f5	48 3b 44 24 78	 cmp	 rax, QWORD PTR n$24660[rsp]
  002fa	7d 28		 jge	 SHORT $LN1@long_from_@2

; 4844 :             newobj->ob_digit[i] =
; 4845 :                 ((PyLongObject *)long_obj)->ob_digit[i];

  002fc	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$24659[rsp]
  00304	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$24659[rsp]
  0030c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR newobj$24658[rsp]
  00314	4c 8b 44 24 58	 mov	 r8, QWORD PTR long_obj$[rsp]
  00319	41 8b 44 80 70	 mov	 eax, DWORD PTR [r8+rax*4+112]
  0031e	89 44 8a 70	 mov	 DWORD PTR [rdx+rcx*4+112], eax

; 4846 :         }

  00322	eb b9		 jmp	 SHORT $LN2@long_from_@2
$LN1@long_from_@2:

; 4847 :         Py_DECREF(long_obj);

  00324	48 8b 4c 24 58	 mov	 rcx, QWORD PTR long_obj$[rsp]
  00329	e8 00 00 00 00	 call	 _Py_DecRef

; 4848 :         return (PyObject *)newobj;

  0032e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR newobj$24658[rsp]
  00336	eb 05		 jmp	 SHORT $LN16@long_from_@2
$LN5@long_from_@2:

; 4849 :     }
; 4850 : 
; 4851 :     return long_obj;

  00338	48 8b 44 24 58	 mov	 rax, QWORD PTR long_obj$[rsp]
$LN16@long_from_@2:

; 4852 : }

  0033d	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00344	c3		 ret	 0
long_from_bytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@EJEPDOAF@PyLong_GetInfo?$AA@		; `string'
PUBLIC	PyLong_GetInfo
EXTRN	PyStructSequence_New:PROC
_BSS	SEGMENT
Int_InfoType DB	01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_GetInfo DD imagerel $LN9
	DD	imagerel $LN9+223
	DD	imagerel $unwind$PyLong_GetInfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_GetInfo DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0P@EJEPDOAF@PyLong_GetInfo?$AA@
CONST	SEGMENT
??_C@_0P@EJEPDOAF@PyLong_GetInfo?$AA@ DB 'PyLong_GetInfo', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLong_GetInfo
_TEXT	SEGMENT
field$ = 48
int_info$ = 56
_py_tmp$24793 = 64
PyLong_GetInfo PROC					; COMDAT

; 5040 : {

$LN9:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5041 :     PyObject* int_info;
; 5042 :     int field = 0;

  00004	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR field$[rsp], 0

; 5043 :     int_info = PyStructSequence_New(&Int_InfoType);

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Int_InfoType
  00013	e8 00 00 00 00	 call	 PyStructSequence_New
  00018	48 89 44 24 38	 mov	 QWORD PTR int_info$[rsp], rax

; 5044 :     if (int_info == NULL)

  0001d	48 83 7c 24 38
	00		 cmp	 QWORD PTR int_info$[rsp], 0
  00023	75 07		 jne	 SHORT $LN6@PyLong_Get

; 5045 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	e9 ae 00 00 00	 jmp	 $LN7@PyLong_Get
$LN6@PyLong_Get:

; 5046 :     PyStructSequence_SET_ITEM(int_info, field++,
; 5047 :                               PyLong_FromLong(PyLong_SHIFT));

  0002c	b9 1e 00 00 00	 mov	 ecx, 30
  00031	e8 00 00 00 00	 call	 PyLong_FromLong
  00036	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR field$[rsp]
  0003b	48 8b 54 24 38	 mov	 rdx, QWORD PTR int_info$[rsp]
  00040	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  00045	8b 44 24 30	 mov	 eax, DWORD PTR field$[rsp]
  00049	ff c0		 inc	 eax
  0004b	89 44 24 30	 mov	 DWORD PTR field$[rsp], eax

; 5048 :     PyStructSequence_SET_ITEM(int_info, field++,
; 5049 :                               PyLong_FromLong(sizeof(digit)));

  0004f	b9 04 00 00 00	 mov	 ecx, 4
  00054	e8 00 00 00 00	 call	 PyLong_FromLong
  00059	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR field$[rsp]
  0005e	48 8b 54 24 38	 mov	 rdx, QWORD PTR int_info$[rsp]
  00063	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  00068	8b 44 24 30	 mov	 eax, DWORD PTR field$[rsp]
  0006c	ff c0		 inc	 eax
  0006e	89 44 24 30	 mov	 DWORD PTR field$[rsp], eax

; 5050 :     if (PyErr_Occurred()) {

  00072	e8 00 00 00 00	 call	 PyErr_Occurred
  00077	48 85 c0	 test	 rax, rax
  0007a	74 59		 je	 SHORT $LN5@PyLong_Get
$LN4@PyLong_Get:

; 5051 :         Py_CLEAR(int_info);

  0007c	48 83 7c 24 38
	00		 cmp	 QWORD PTR int_info$[rsp], 0
  00082	74 47		 je	 SHORT $LN1@PyLong_Get
  00084	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008c	4c 8b 4c 24 38	 mov	 r9, QWORD PTR int_info$[rsp]
  00091	41 b8 bb 13 00
	00		 mov	 r8d, 5051		; 000013bbH
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@EJEPDOAF@PyLong_GetInfo?$AA@
  000a5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000aa	85 c0		 test	 eax, eax
  000ac	75 1d		 jne	 SHORT $LN1@PyLong_Get
  000ae	48 8b 44 24 38	 mov	 rax, QWORD PTR int_info$[rsp]
  000b3	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$24793[rsp], rax
  000b8	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR int_info$[rsp], 0
  000c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$24793[rsp]
  000c6	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyLong_Get:
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	75 ab		 jne	 SHORT $LN4@PyLong_Get

; 5052 :         return NULL;

  000d1	33 c0		 xor	 eax, eax
  000d3	eb 05		 jmp	 SHORT $LN7@PyLong_Get
$LN5@PyLong_Get:

; 5053 :     }
; 5054 :     return int_info;

  000d5	48 8b 44 24 38	 mov	 rax, QWORD PTR int_info$[rsp]
$LN7@PyLong_Get:

; 5055 : }

  000da	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000de	c3		 ret	 0
PyLong_GetInfo ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DI@GMLJDABO@?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAb?$AAs?$AA?$CI?$AAi?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@DLPIBGDL@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	_PyLong_Init
EXTRN	PyStructSequence_InitType:PROC
EXTRN	abs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_Init DD imagerel $LN17
	DD	imagerel $LN17+415
	DD	imagerel $unwind$_PyLong_Init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_Init DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_1DI@GMLJDABO@?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAb?$AAs?$AA?$CI?$AAi?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@GMLJDABO@?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAb?$AAs?$AA?$CI?$AAi?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@ DB 'v'
	DB	00H, '-', 00H, '>', 00H, 'o', 00H, 'b', 00H, '_', 00H, 'd', 00H
	DB	'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, '[', 00H, '0', 00H, ']'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'a', 00H, 'b', 00H
	DB	's', 00H, '(', 00H, 'i', 00H, 'v', 00H, 'a', 00H, 'l', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@DLPIBGDL@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@DLPIBGDL@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'(', 00H, 'o', 00H, 'p', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyLong_Init
_TEXT	SEGMENT
v$ = 32
size$ = 40
ival$ = 44
refcnt$24809 = 48
op$24810 = 56
tv70 = 64
tv69 = 68
tv76 = 72
_PyLong_Init PROC					; COMDAT

; 5059 : {

$LN17:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5060 : #if NSMALLNEGINTS + NSMALLPOSINTS > 0
; 5061 :     int ival, size;
; 5062 :     PyLongObject *v = small_ints;

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:small_ints
  0000b	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 5063 : 
; 5064 :     for (ival = -NSMALLNEGINTS; ival <  NSMALLPOSINTS; ival++, v++) {

  00010	c7 44 24 2c fb
	ff ff ff	 mov	 DWORD PTR ival$[rsp], -5
  00018	eb 1a		 jmp	 SHORT $LN6@PyLong_Ini
$LN5@PyLong_Ini:
  0001a	8b 44 24 2c	 mov	 eax, DWORD PTR ival$[rsp]
  0001e	ff c0		 inc	 eax
  00020	89 44 24 2c	 mov	 DWORD PTR ival$[rsp], eax
  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00029	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0002f	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
$LN6@PyLong_Ini:
  00034	81 7c 24 2c 01
	01 00 00	 cmp	 DWORD PTR ival$[rsp], 257 ; 00000101H
  0003c	0f 8d 36 01 00
	00		 jge	 $LN4@PyLong_Ini

; 5065 :         size = (ival < 0) ? -1 : ((ival == 0) ? 0 : 1);

  00042	83 7c 24 2c 00	 cmp	 DWORD PTR ival$[rsp], 0
  00047	7d 0a		 jge	 SHORT $LN11@PyLong_Ini
  00049	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR tv70[rsp], -1
  00051	eb 21		 jmp	 SHORT $LN12@PyLong_Ini
$LN11@PyLong_Ini:
  00053	83 7c 24 2c 00	 cmp	 DWORD PTR ival$[rsp], 0
  00058	75 0a		 jne	 SHORT $LN9@PyLong_Ini
  0005a	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  00062	eb 08		 jmp	 SHORT $LN10@PyLong_Ini
$LN9@PyLong_Ini:
  00064	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
$LN10@PyLong_Ini:
  0006c	8b 44 24 44	 mov	 eax, DWORD PTR tv69[rsp]
  00070	89 44 24 40	 mov	 DWORD PTR tv70[rsp], eax
$LN12@PyLong_Ini:
  00074	8b 44 24 40	 mov	 eax, DWORD PTR tv70[rsp]
  00078	89 44 24 28	 mov	 DWORD PTR size$[rsp], eax

; 5066 :         if (Py_TYPE(v) == &PyLong_Type) {

  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00088	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0008c	0f 85 b1 00 00
	00		 jne	 $LN3@PyLong_Ini

; 5067 :             /* The element is already initialized, most likely
; 5068 :              * the Python interpreter was initialized before.
; 5069 :              */
; 5070 :             Py_ssize_t refcnt;
; 5071 :             PyObject* op = (PyObject*)v;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00097	48 89 44 24 38	 mov	 QWORD PTR op$24810[rsp], rax

; 5072 : 
; 5073 :             refcnt = Py_REFCNT(op) < 0 ? 0 : Py_REFCNT(op);

  0009c	48 8b 44 24 38	 mov	 rax, QWORD PTR op$24810[rsp]
  000a1	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000a6	7d 0b		 jge	 SHORT $LN13@PyLong_Ini
  000a8	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv76[rsp], 0
  000b1	eb 0e		 jmp	 SHORT $LN14@PyLong_Ini
$LN13@PyLong_Ini:
  000b3	48 8b 44 24 38	 mov	 rax, QWORD PTR op$24810[rsp]
  000b8	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000bc	48 89 44 24 48	 mov	 QWORD PTR tv76[rsp], rax
$LN14@PyLong_Ini:
  000c1	48 8b 44 24 48	 mov	 rax, QWORD PTR tv76[rsp]
  000c6	48 89 44 24 30	 mov	 QWORD PTR refcnt$24809[rsp], rax

; 5074 :             _Py_NewReference(op);

  000cb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$24810[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_NewReference

; 5075 :             /* _Py_NewReference sets the ref count to 1 but
; 5076 :              * the ref count might be larger. Set the refcnt
; 5077 :              * to the original refcnt + 1 */
; 5078 :             Py_REFCNT(op) = refcnt + 1;

  000d5	48 8b 44 24 30	 mov	 rax, QWORD PTR refcnt$24809[rsp]
  000da	48 ff c0	 inc	 rax
  000dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$24810[rsp]
  000e2	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 5079 :             assert(Py_SIZE(op) == size);

  000e6	48 63 44 24 28	 movsxd	 rax, DWORD PTR size$[rsp]
  000eb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$24810[rsp]
  000f0	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  000f4	74 1c		 je	 SHORT $LN15@PyLong_Ini
  000f6	41 b8 d7 13 00
	00		 mov	 r8d, 5079		; 000013d7H
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@DLPIBGDL@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00110	33 c0		 xor	 eax, eax
$LN15@PyLong_Ini:

; 5080 :             assert(v->ob_digit[0] == abs(ival));

  00112	8b 4c 24 2c	 mov	 ecx, DWORD PTR ival$[rsp]
  00116	e8 00 00 00 00	 call	 abs
  0011b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00120	39 41 70	 cmp	 DWORD PTR [rcx+112], eax
  00123	74 1c		 je	 SHORT $LN16@PyLong_Ini
  00125	41 b8 d8 13 00
	00		 mov	 r8d, 5080		; 000013d8H
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@PBBNJFBE@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAl?$AAo?$AAn?$AAg?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@GMLJDABO@?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAb?$AAs?$AA?$CI?$AAi?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0013f	33 c0		 xor	 eax, eax
$LN16@PyLong_Ini:

; 5081 :         }
; 5082 :         else {

  00141	eb 11		 jmp	 SHORT $LN2@PyLong_Ini
$LN3@PyLong_Ini:

; 5083 :             PyObject_INIT((PyObject *)v, &PyLong_Type);

  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyLong_Type
  0014a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0014f	e8 00 00 00 00	 call	 PyObject_INIT
$LN2@PyLong_Ini:

; 5084 :         }
; 5085 :         Py_SIZE(v) = size;

  00154	48 63 44 24 28	 movsxd	 rax, DWORD PTR size$[rsp]
  00159	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0015e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 5086 :         v->ob_digit[0] = abs(ival);

  00162	8b 4c 24 2c	 mov	 ecx, DWORD PTR ival$[rsp]
  00166	e8 00 00 00 00	 call	 abs
  0016b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00170	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 5087 :     }

  00173	e9 a2 fe ff ff	 jmp	 $LN5@PyLong_Ini
$LN4@PyLong_Ini:

; 5088 : #endif
; 5089 :     /* initialize int_info */
; 5090 :     if (Int_InfoType.tp_name == 0)

  00178	48 83 3d 70 00
	00 00 00	 cmp	 QWORD PTR Int_InfoType+112, 0
  00180	75 13		 jne	 SHORT $LN1@PyLong_Ini

; 5091 :         PyStructSequence_InitType(&Int_InfoType, &int_info_desc);

  00182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:int_info_desc
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Int_InfoType
  00190	e8 00 00 00 00	 call	 PyStructSequence_InitType
$LN1@PyLong_Ini:

; 5092 : 
; 5093 :     return 1;

  00195	b8 01 00 00 00	 mov	 eax, 1

; 5094 : }

  0019a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0019e	c3		 ret	 0
_PyLong_Init ENDP
_TEXT	ENDS
EXTRN	_PxObject_Init:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$PyObject_INIT DD imagerel PyObject_INIT
	DD	imagerel PyObject_INIT+84
	DD	imagerel $unwind$PyObject_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_INIT
_TEXT	SEGMENT
op$ = 48
tp$ = 56
PyObject_INIT PROC					; COMDAT

; 236  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 237  :     Px_RETURN(_PxObject_Init(op, tp))

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 11		 je	 SHORT $LN1@PyObject_I@3
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR tp$[rsp]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00021	e8 00 00 00 00	 call	 _PxObject_Init
  00026	eb 27		 jmp	 SHORT $LN2@PyObject_I@3
$LN1@PyObject_I@3:

; 238  :     Py_TYPE(op) = tp;

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tp$[rsp]
  00032	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 239  :     _PyObject_InitHead(op);

  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0003b	e8 00 00 00 00	 call	 _PyObject_InitHead

; 240  :     _Py_NewReference(op);

  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00045	e8 00 00 00 00	 call	 _Py_NewReference

; 241  :     return op;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
$LN2@PyObject_I@3:

; 242  : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
PyObject_INIT ENDP
_TEXT	ENDS
PUBLIC	PyLong_Fini
EXTRN	_Py_ForgetReference:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\longobject.c
pdata	SEGMENT
$pdata$PyLong_Fini DD imagerel $LN8
	DD	imagerel $LN8+107
	DD	imagerel $unwind$PyLong_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_Fini DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyLong_Fini
_TEXT	SEGMENT
v$ = 32
i$ = 40
PyLong_Fini PROC					; COMDAT

; 5098 : {

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5099 :     /* Integers are currently statically allocated. Py_DECREF is not
; 5100 :        needed, but Python must forget about the reference or multiple
; 5101 :        reinitializations will fail. */
; 5102 : #if NSMALLNEGINTS + NSMALLPOSINTS > 0
; 5103 :     int i;
; 5104 :     PyLongObject *v = small_ints;

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:small_ints
  0000b	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 5105 :     for (i = 0; i < NSMALLNEGINTS + NSMALLPOSINTS; i++, v++) {

  00010	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00018	eb 1a		 jmp	 SHORT $LN3@PyLong_Fin
$LN2@PyLong_Fin:
  0001a	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0001e	ff c0		 inc	 eax
  00020	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00029	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0002f	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
$LN3@PyLong_Fin:
  00034	81 7c 24 28 06
	01 00 00	 cmp	 DWORD PTR i$[rsp], 262	; 00000106H
  0003c	7d 28		 jge	 SHORT $LN1@PyLong_Fin

; 5106 :         _Py_DEC_REFTOTAL;

  0003e	e8 00 00 00 00	 call	 _Py_PXCTX
  00043	85 c0		 test	 eax, eax
  00045	74 02		 je	 SHORT $LN6@PyLong_Fin
  00047	eb 11		 jmp	 SHORT $LN7@PyLong_Fin
$LN6@PyLong_Fin:
  00049	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00050	48 ff c8	 dec	 rax
  00053	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN7@PyLong_Fin:

; 5107 :         _Py_ForgetReference((PyObject*)v);

  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0005f	e8 00 00 00 00	 call	 _Py_ForgetReference

; 5108 :     }

  00064	eb b4		 jmp	 SHORT $LN2@PyLong_Fin
$LN1@PyLong_Fin:

; 5109 : #endif
; 5110 : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
PyLong_Fini ENDP
_TEXT	ENDS
END
