; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06OHDDMFCG@winreg?$AA@			; `string'
PUBLIC	??_C@_0L@ICGGAOLB@SetValueEx?$AA@		; `string'
PUBLIC	??_C@_08JHMAAEPA@SetValue?$AA@			; `string'
PUBLIC	??_C@_07BMOIJBEL@SaveKey?$AA@			; `string'
PUBLIC	??_C@_0BD@CBDGFLPG@QueryReflectionKey?$AA@	; `string'
PUBLIC	??_C@_0N@MDCBENNB@QueryInfoKey?$AA@		; `string'
PUBLIC	??_C@_0N@HKICBNFG@QueryValueEx?$AA@		; `string'
PUBLIC	??_C@_0L@PJJMANCA@QueryValue?$AA@		; `string'
PUBLIC	??_C@_09HDCIMAEH@OpenKeyEx?$AA@			; `string'
PUBLIC	??_C@_07EMHGDHB@OpenKey?$AA@			; `string'
PUBLIC	??_C@_07MKPPNCAC@LoadKey?$AA@			; `string'
PUBLIC	??_C@_08FFGKIMAP@FlushKey?$AA@			; `string'
PUBLIC	??_C@_0BJ@FIJODGGF@ExpandEnvironmentStrings?$AA@ ; `string'
PUBLIC	??_C@_09LLFDHLHP@EnumValue?$AA@			; `string'
PUBLIC	??_C@_07OGJAOAGB@EnumKey?$AA@			; `string'
PUBLIC	??_C@_0BE@FOGLKLAG@EnableReflectionKey?$AA@	; `string'
PUBLIC	??_C@_0BF@BLABHKJP@DisableReflectionKey?$AA@	; `string'
PUBLIC	??_C@_0M@PPLCJLKN@DeleteValue?$AA@		; `string'
PUBLIC	??_C@_0M@JLKACAJ@DeleteKeyEx?$AA@		; `string'
PUBLIC	??_C@_09POIPIBKM@DeleteKey?$AA@			; `string'
PUBLIC	??_C@_0M@FLBGEAAI@CreateKeyEx?$AA@		; `string'
PUBLIC	??_C@_09DPPCIKFF@CreateKey?$AA@			; `string'
PUBLIC	??_C@_0BA@GBJAIKNL@ConnectRegistry?$AA@		; `string'
PUBLIC	??_C@_08CEMDMOHB@CloseKey?$AA@			; `string'
PUBLIC	??_C@_06FENFPALN@PyHKEY?$AA@			; `string'
PUBLIC	??_C@_06NCGDPKCC@handle?$AA@			; `string'
PUBLIC	??_C@_08CMFIGCJD@__exit__?$AA@			; `string'
PUBLIC	??_C@_09OAJHKKGH@__enter__?$AA@			; `string'
PUBLIC	??_C@_06OCJDKNLN@Detach?$AA@			; `string'
PUBLIC	??_C@_05LGELBCGM@Close?$AA@			; `string'
PUBLIC	??_C@_0BB@HNACHIIA@bad?5operand?5type?$AA@	; `string'
PUBLIC	PyHKEY_Type
;	COMDAT ??_C@_06OHDDMFCG@winreg?$AA@
CONST	SEGMENT
??_C@_06OHDDMFCG@winreg?$AA@ DB 'winreg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICGGAOLB@SetValueEx?$AA@
CONST	SEGMENT
??_C@_0L@ICGGAOLB@SetValueEx?$AA@ DB 'SetValueEx', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JHMAAEPA@SetValue?$AA@
CONST	SEGMENT
??_C@_08JHMAAEPA@SetValue?$AA@ DB 'SetValue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BMOIJBEL@SaveKey?$AA@
CONST	SEGMENT
??_C@_07BMOIJBEL@SaveKey?$AA@ DB 'SaveKey', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CBDGFLPG@QueryReflectionKey?$AA@
CONST	SEGMENT
??_C@_0BD@CBDGFLPG@QueryReflectionKey?$AA@ DB 'QueryReflectionKey', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDCBENNB@QueryInfoKey?$AA@
CONST	SEGMENT
??_C@_0N@MDCBENNB@QueryInfoKey?$AA@ DB 'QueryInfoKey', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HKICBNFG@QueryValueEx?$AA@
CONST	SEGMENT
??_C@_0N@HKICBNFG@QueryValueEx?$AA@ DB 'QueryValueEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJJMANCA@QueryValue?$AA@
CONST	SEGMENT
??_C@_0L@PJJMANCA@QueryValue?$AA@ DB 'QueryValue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HDCIMAEH@OpenKeyEx?$AA@
CONST	SEGMENT
??_C@_09HDCIMAEH@OpenKeyEx?$AA@ DB 'OpenKeyEx', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EMHGDHB@OpenKey?$AA@
CONST	SEGMENT
??_C@_07EMHGDHB@OpenKey?$AA@ DB 'OpenKey', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MKPPNCAC@LoadKey?$AA@
CONST	SEGMENT
??_C@_07MKPPNCAC@LoadKey?$AA@ DB 'LoadKey', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FFGKIMAP@FlushKey?$AA@
CONST	SEGMENT
??_C@_08FFGKIMAP@FlushKey?$AA@ DB 'FlushKey', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FIJODGGF@ExpandEnvironmentStrings?$AA@
CONST	SEGMENT
??_C@_0BJ@FIJODGGF@ExpandEnvironmentStrings?$AA@ DB 'ExpandEnvironmentStr'
	DB	'ings', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09LLFDHLHP@EnumValue?$AA@
CONST	SEGMENT
??_C@_09LLFDHLHP@EnumValue?$AA@ DB 'EnumValue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OGJAOAGB@EnumKey?$AA@
CONST	SEGMENT
??_C@_07OGJAOAGB@EnumKey?$AA@ DB 'EnumKey', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FOGLKLAG@EnableReflectionKey?$AA@
CONST	SEGMENT
??_C@_0BE@FOGLKLAG@EnableReflectionKey?$AA@ DB 'EnableReflectionKey', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BLABHKJP@DisableReflectionKey?$AA@
CONST	SEGMENT
??_C@_0BF@BLABHKJP@DisableReflectionKey?$AA@ DB 'DisableReflectionKey', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PPLCJLKN@DeleteValue?$AA@
CONST	SEGMENT
??_C@_0M@PPLCJLKN@DeleteValue?$AA@ DB 'DeleteValue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JLKACAJ@DeleteKeyEx?$AA@
CONST	SEGMENT
??_C@_0M@JLKACAJ@DeleteKeyEx?$AA@ DB 'DeleteKeyEx', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09POIPIBKM@DeleteKey?$AA@
CONST	SEGMENT
??_C@_09POIPIBKM@DeleteKey?$AA@ DB 'DeleteKey', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FLBGEAAI@CreateKeyEx?$AA@
CONST	SEGMENT
??_C@_0M@FLBGEAAI@CreateKeyEx?$AA@ DB 'CreateKeyEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DPPCIKFF@CreateKey?$AA@
CONST	SEGMENT
??_C@_09DPPCIKFF@CreateKey?$AA@ DB 'CreateKey', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GBJAIKNL@ConnectRegistry?$AA@
CONST	SEGMENT
??_C@_0BA@GBJAIKNL@ConnectRegistry?$AA@ DB 'ConnectRegistry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CEMDMOHB@CloseKey?$AA@
CONST	SEGMENT
??_C@_08CEMDMOHB@CloseKey?$AA@ DB 'CloseKey', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FENFPALN@PyHKEY?$AA@
CONST	SEGMENT
??_C@_06FENFPALN@PyHKEY?$AA@ DB 'PyHKEY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NCGDPKCC@handle?$AA@
CONST	SEGMENT
??_C@_06NCGDPKCC@handle?$AA@ DB 'handle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMFIGCJD@__exit__?$AA@
CONST	SEGMENT
??_C@_08CMFIGCJD@__exit__?$AA@ DB '__exit__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAJHKKGH@__enter__?$AA@
CONST	SEGMENT
??_C@_09OAJHKKGH@__enter__?$AA@ DB '__enter__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OCJDKNLN@Detach?$AA@
CONST	SEGMENT
??_C@_06OCJDKNLN@Detach?$AA@ DB 'Detach', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LGELBCGM@Close?$AA@
CONST	SEGMENT
??_C@_05LGELBCGM@Close?$AA@ DB 'Close', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNACHIIA@bad?5operand?5type?$AA@
CONST	SEGMENT
??_C@_0BB@HNACHIIA@bad?5operand?5type?$AA@ DB 'bad operand type', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
errNotAHandle DB 'Object is not a handle', 00H
	ORG $+9
module_doc DB	'This module provides access to the Windows registry API.'
	DB	0aH, 0aH, 'Functions:', 0aH, 0aH, 'CloseKey() - Closes a regis'
	DB	'try key.', 0aH, 'ConnectRegistry() - Establishes a connection'
	DB	' to a predefined registry handle', 0aH, '                    '
	DB	'on another computer.', 0aH, 'CreateKey() - Creates the specif'
	DB	'ied key, or opens it if it already exists.', 0aH, 'DeleteKey('
	DB	') - Deletes the specified key.', 0aH, 'DeleteValue() - Remove'
	DB	's a named value from the specified registry key.', 0aH, 'Enum'
	DB	'Key() - Enumerates subkeys of the specified open registry key'
	DB	'.', 0aH, 'EnumValue() - Enumerates values of the specified op'
	DB	'en registry key.', 0aH, 'ExpandEnvironmentStrings() - Expand '
	DB	'the env strings in a REG_EXPAND_SZ string.', 0aH, 'FlushKey()'
	DB	' - Writes all the attributes of the specified key to the regi'
	DB	'stry.', 0aH, 'LoadKey() - Creates a subkey under HKEY_USER or'
	DB	' HKEY_LOCAL_MACHINE and stores', 0aH, '            registrati'
	DB	'on information from a specified file into that subkey.', 0aH, 'O'
	DB	'penKey() - Opens the specified key.', 0aH, 'OpenKeyEx() - Ali'
	DB	'as of OpenKey().', 0aH, 'QueryValue() - Retrieves the value a'
	DB	'ssociated with the unnamed value for a', 0aH, '              '
	DB	' specified key in the registry.', 0aH, 'QueryValueEx() - Retr'
	DB	'ieves the type and data for a specified value name', 0aH, '  '
	DB	'               associated with an open registry key.', 0aH, 'Q'
	DB	'ueryInfoKey() - Returns information about the specified key.', 0aH
	DB	'SaveKey() - Saves the specified key, and all its subkeys a fi'
	DB	'le.', 0aH, 'SetValue() - Associates a value with a specified '
	DB	'key.', 0aH, 'SetValueEx() - Stores data in the value field of'
	DB	' an open registry key.', 0aH, 0aH, 'Special objects:', 0aH, 0aH
	DB	'HKEYType -- type object for HKEY objects', 0aH, 'error -- exc'
	DB	'eption raised for Win32 errors', 0aH, 0aH, 'Integer constants'
	DB	':', 0aH, 'Many constants are defined - see the documentation '
	DB	'for each function', 0aH, 'to see what constants are used, and'
	DB	' where.', 00H
	ORG $+1
CloseKey_doc DB	'CloseKey(hkey)', 0aH, 'Closes a previously opened regist'
	DB	'ry key.', 0aH, 0aH, 'The hkey argument specifies a previously'
	DB	' opened key.', 0aH, 0aH, 'Note that if the key is not closed '
	DB	'using this method, it will be', 0aH, 'closed when the hkey ob'
	DB	'ject is destroyed by Python.', 00H
	ORG $+4
OpenKeyEx_doc DB 'See OpenKey()', 00H
	ORG $+2
failMsg	DQ	FLAT:??_C@_0BB@HNACHIIA@bad?5operand?5type?$AA@
ConnectRegistry_doc DB 'ConnectRegistry(computer_name, key) -> key', 0aH, 'E'
	DB	'stablishes a connection to a predefined registry handle on an'
	DB	'other computer.', 0aH, 0aH, 'computer_name is the name of the'
	DB	' remote computer, of the form \\computername.', 0aH, '       '
	DB	'       If None, the local computer is used.', 0aH, 'key is th'
	DB	'e predefined handle to connect to.', 0aH, 0aH, 'The return va'
	DB	'lue is the handle of the opened key.', 0aH, 'If the function '
	DB	'fails, an OSError exception is raised.', 00H
	ORG $+15
CreateKey_doc DB 'CreateKey(key, sub_key) -> key', 0aH, 'Creates or opens'
	DB	' the specified key.', 0aH, 0aH, 'key is an already open key, '
	DB	'or one of the predefined HKEY_* constants.', 0aH, 'sub_key is'
	DB	' a string that names the key this method opens or creates.', 0aH
	DB	0aH, 'If key is one of the predefined keys, sub_key may be Non'
	DB	'e. In that case,', 0aH, 'the handle returned is the same key '
	DB	'handle passed in to the function.', 0aH, 0aH, 'If the key alr'
	DB	'eady exists, this function opens the existing key.', 0aH, 0aH
	DB	'The return value is the handle of the opened key.', 0aH, 'If '
	DB	'the function fails, an OSError exception is raised.', 00H
	ORG $+4
CreateKeyEx_doc DB 'CreateKeyEx(key, sub_key, reserved=0, access=KEY_WRIT'
	DB	'E) -> key', 0aH, 'Creates or opens the specified key.', 0aH, 0aH
	DB	'key is an already open key, or one of the predefined HKEY_* c'
	DB	'onstants', 0aH, 'sub_key is a string that names the key this '
	DB	'method opens or creates.', 0aH, 'reserved is a reserved integ'
	DB	'er, and must be zero.  Default is zero.', 0aH, 'access is an '
	DB	'integer that specifies an access mask that describes the ', 0aH
	DB	'       desired security access for the key. Default is KEY_WR'
	DB	'ITE.', 0aH, 0aH, 'If key is one of the predefined keys, sub_k'
	DB	'ey may be None. In that case,', 0aH, 'the handle returned is '
	DB	'the same key handle passed in to the function.', 0aH, 0aH, 'I'
	DB	'f the key already exists, this function opens the existing ke'
	DB	'y', 0aH, 0aH, 'The return value is the handle of the opened k'
	DB	'ey.', 0aH, 'If the function fails, an OSError exception is ra'
	DB	'ised.', 00H
	ORG $+9
DeleteKey_doc DB 'DeleteKey(key, sub_key)', 0aH, 'Deletes the specified k'
	DB	'ey.', 0aH, 0aH, 'key is an already open key, or any one of th'
	DB	'e predefined HKEY_* constants.', 0aH, 'sub_key is a string th'
	DB	'at must be a subkey of the key identified by the key', 0aH, ' '
	DB	'       parameter. This value must not be None, and the key ma'
	DB	'y not have', 0aH, '        subkeys.', 0aH, 0aH, 'This method '
	DB	'can not delete keys with subkeys.', 0aH, 0aH, 'If the functio'
	DB	'n succeeds, the entire key, including all of its values,', 0aH
	DB	'is removed.  If the function fails, an OSError exception is r'
	DB	'aised.', 00H
	ORG $+1
DeleteKeyEx_doc DB 'DeleteKeyEx(key, sub_key, access=KEY_WOW64_64KEY, res'
	DB	'erved=0)', 0aH, 'Deletes the specified key (64-bit OS only).', 0aH
	DB	0aH, 'key is an already open key, or any one of the predefined'
	DB	' HKEY_* constants.', 0aH, 'sub_key is a string that must be a'
	DB	' subkey of the key identified by the key', 0aH, '        para'
	DB	'meter. This value must not be None, and the key may not have', 0aH
	DB	'        subkeys.', 0aH, 'reserved is a reserved integer, and '
	DB	'must be zero.  Default is zero.', 0aH, 'access is an integer '
	DB	'that specifies an access mask that describes the ', 0aH, '   '
	DB	'    desired security access for the key. Default is KEY_WOW64'
	DB	'_64KEY.', 0aH, 0aH, 'This method can not delete keys with sub'
	DB	'keys.', 0aH, 0aH, 'If the function succeeds, the entire key, '
	DB	'including all of its values,', 0aH, 'is removed.  If the func'
	DB	'tion fails, an OSError exception is raised.', 0aH, 'On unsupp'
	DB	'orted Windows versions, NotImplementedError is raised.', 00H
	ORG $+7
DeleteValue_doc DB 'DeleteValue(key, value)', 0aH, 'Removes a named value'
	DB	' from a registry key.', 0aH, 0aH, 'key is an already open key'
	DB	', or any one of the predefined HKEY_* constants.', 0aH, 'valu'
	DB	'e is a string that identifies the value to remove.', 00H
	ORG $+10
EnumKey_doc DB	'EnumKey(key, index) -> string', 0aH, 'Enumerates subkeys'
	DB	' of an open registry key.', 0aH, 0aH, 'key is an already open'
	DB	' key, or any one of the predefined HKEY_* constants.', 0aH, 'i'
	DB	'ndex is an integer that identifies the index of the key to re'
	DB	'trieve.', 0aH, 0aH, 'The function retrieves the name of one s'
	DB	'ubkey each time it is called.', 0aH, 'It is typically called '
	DB	'repeatedly until an OSError exception is', 0aH, 'raised, indi'
	DB	'cating no more values are available.', 00H
	ORG $+12
EnumValue_doc DB 'EnumValue(key, index) -> tuple', 0aH, 'Enumerates value'
	DB	's of an open registry key.', 0aH, 'key is an already open key'
	DB	', or any one of the predefined HKEY_* constants.', 0aH, 'inde'
	DB	'x is an integer that identifies the index of the value to ret'
	DB	'rieve.', 0aH, 0aH, 'The function retrieves the name of one su'
	DB	'bkey each time it is called.', 0aH, 'It is typically called r'
	DB	'epeatedly, until an OSError exception', 0aH, 'is raised, indi'
	DB	'cating no more values.', 0aH, 0aH, 'The result is a tuple of '
	DB	'3 items:', 0aH, 'value_name is a string that identifies the v'
	DB	'alue.', 0aH, 'value_data is an object that holds the value da'
	DB	'ta, and whose type depends', 0aH, '           on the underlyi'
	DB	'ng registry type.', 0aH, 'data_type is an integer that identi'
	DB	'fies the type of the value data.', 00H
	ORG $+9
ExpandEnvironmentStrings_doc DB 'ExpandEnvironmentStrings(string) -> stri'
	DB	'ng', 0aH, 'Expand environment vars.', 0aH, 00H
	ORG $+11
FlushKey_doc DB	'FlushKey(key)', 0aH, 'Writes all the attributes of a key'
	DB	' to the registry.', 0aH, 0aH, 'key is an already open key, or'
	DB	' any one of the predefined HKEY_* constants.', 0aH, 0aH, 'It '
	DB	'is not necessary to call FlushKey to change a key.  Registry '
	DB	'changes are', 0aH, 'flushed to disk by the registry using its'
	DB	' lazy flusher.  Registry changes are', 0aH, 'also flushed to '
	DB	'disk at system shutdown.  Unlike CloseKey(), the FlushKey()', 0aH
	DB	'method returns only when all the data has been written to the'
	DB	' registry.', 0aH, 0aH, 'An application should only call Flush'
	DB	'Key() if it requires absolute certainty', 0aH, 'that registry'
	DB	' changes are on disk.  If you don''t know whether a FlushKey('
	DB	')', 0aH, 'call is required, it probably isn''t.', 00H
	ORG $+5
LoadKey_doc DB	'LoadKey(key, sub_key, file_name)', 0aH, 'Creates a subke'
	DB	'y under the specified key and stores registration information'
	DB	0aH, 'from a specified file into that subkey.', 0aH, 0aH, 'key'
	DB	' is an already open key, or any one of the predefined HKEY_* '
	DB	'constants.', 0aH, 'sub_key is a string that identifies the su'
	DB	'b_key to load.', 0aH, 'file_name is the name of the file to l'
	DB	'oad registry data from.  This file must', 0aH, '          hav'
	DB	'e been created with the SaveKey() function.  Under the file', 0aH
	DB	'          allocation table (FAT) file system, the filename ma'
	DB	'y not have an', 0aH, '          extension.', 0aH, 0aH, 'A cal'
	DB	'l to LoadKey() fails if the calling process does not have the'
	DB	0aH, 'SE_RESTORE_PRIVILEGE privilege.', 0aH, 0aH, 'If key is a'
	DB	' handle returned by ConnectRegistry(), then the path specifie'
	DB	'd', 0aH, 'in fileName is relative to the remote computer.', 0aH
	DB	0aH, 'The docs imply key must be in the HKEY_USER or HKEY_LOCA'
	DB	'L_MACHINE tree', 00H
	ORG $+7
OpenKey_doc DB	'OpenKey(key, sub_key, reserved=0, access=KEY_READ) -> ke'
	DB	'y', 0aH, 'Opens the specified key.', 0aH, 0aH, 'key is an alr'
	DB	'eady open key, or any one of the predefined HKEY_* constants.'
	DB	0aH, 'sub_key is a string that identifies the sub_key to open.'
	DB	0aH, 'reserved is a reserved integer, and must be zero.  Defau'
	DB	'lt is zero.', 0aH, 'access is an integer that specifies an ac'
	DB	'cess mask that describes the desired', 0aH, '       security '
	DB	'access for the key.  Default is KEY_READ', 0aH, 0aH, 'The res'
	DB	'ult is a new handle to the specified key', 0aH, 'If the funct'
	DB	'ion fails, an OSError exception is raised.', 00H
	ORG $+5
QueryInfoKey_doc DB 'QueryInfoKey(key) -> tuple', 0aH, 'Returns informati'
	DB	'on about a key.', 0aH, 0aH, 'key is an already open key, or a'
	DB	'ny one of the predefined HKEY_* constants.', 0aH, 0aH, 'The r'
	DB	'esult is a tuple of 3 items:An integer that identifies the nu'
	DB	'mber of sub keys this key has.', 0aH, 'An integer that identi'
	DB	'fies the number of values this key has.', 0aH, 'An integer th'
	DB	'at identifies when the key was last modified (if available)', 0aH
	DB	' as 100''s of nanoseconds since Jan 1, 1600.', 00H
	ORG $+3
QueryValue_doc DB 'QueryValue(key, sub_key) -> string', 0aH, 'Retrieves t'
	DB	'he unnamed value for a key.', 0aH, 0aH, 'key is an already op'
	DB	'en key, or any one of the predefined HKEY_* constants.', 0aH, 's'
	DB	'ub_key is a string that holds the name of the subkey with whi'
	DB	'ch the value', 0aH, '        is associated.  If this paramete'
	DB	'r is None or empty, the function', 0aH, '        retrieves th'
	DB	'e value set by the SetValue() method for the key', 0aH, '    '
	DB	'    identified by key.', 0aH, 'Values in the registry have na'
	DB	'me, type, and data components. This method', 0aH, 'retrieves '
	DB	'the data for a key''s first value that has a NULL name.', 0aH
	DB	'But the underlying API call doesn''t return the type, Lame La'
	DB	'me Lame, DONT USE THIS!!!', 00H
	ORG $+6
QueryValueEx_doc DB 'QueryValueEx(key, value_name) -> (value, type_id)', 0aH
	DB	'Retrieves the type and data for a specified value name associ'
	DB	'ated with an', 0aH, 'open registry key.', 0aH, 0aH, 'key is a'
	DB	'n already open key, or any one of the predefined HKEY_* const'
	DB	'ants.', 0aH, 'value_name is a string indicating the value to '
	DB	'query', 00H
SaveKey_doc DB	'SaveKey(key, file_name)', 0aH, 'Saves the specified key,'
	DB	' and all its subkeys to the specified file.', 0aH, 0aH, 'key '
	DB	'is an already open key, or any one of the predefined HKEY_* c'
	DB	'onstants.', 0aH, 'file_name is the name of the file to save r'
	DB	'egistry data to.  This file cannot', 0aH, '          already '
	DB	'exist. If this filename includes an extension, it cannot be', 0aH
	DB	'          used on file allocation table (FAT) file systems by'
	DB	' the LoadKey(),', 0aH, '          ReplaceKey() or RestoreKey('
	DB	') methods.', 0aH, 0aH, 'If key represents a key on a remote c'
	DB	'omputer, the path described by file_name', 0aH, 'is relative '
	DB	'to the remote computer.', 0aH, 0aH, 'The caller of this metho'
	DB	'd must possess the SeBackupPrivilege security', 0aH, 'privile'
	DB	'ge.  This function passes NULL for security_attributes to the'
	DB	' API.', 00H
	ORG $+11
SetValue_doc DB	'SetValue(key, sub_key, type, value)', 0aH, 'Associates a'
	DB	' value with a specified key.', 0aH, 0aH, 'key is an already o'
	DB	'pen key, or any one of the predefined HKEY_* constants.', 0aH
	DB	'sub_key is a string that names the subkey with which the valu'
	DB	'e is associated.', 0aH, 'type is an integer that specifies th'
	DB	'e type of the data.  Currently this must', 0aH, '     be REG_'
	DB	'SZ, meaning only strings are supported.', 0aH, 'value is a st'
	DB	'ring that specifies the new value.', 0aH, 0aH, 'If the key sp'
	DB	'ecified by the sub_key parameter does not exist, the SetValue'
	DB	0aH, 'function creates it.', 0aH, 0aH, 'Value lengths are limi'
	DB	'ted by available memory. Long values (more than', 0aH, '2048 '
	DB	'bytes) should be stored as files with the filenames stored in'
	DB	' ', 0aH, 'the configuration registry.  This helps the registr'
	DB	'y perform efficiently.', 0aH, 0aH, 'The key identified by the'
	DB	' key parameter must have been opened with', 0aH, 'KEY_SET_VAL'
	DB	'UE access.', 00H
	ORG $+8
SetValueEx_doc DB 'SetValueEx(key, value_name, reserved, type, value)', 0aH
	DB	'Stores data in the value field of an open registry key.', 0aH
	DB	0aH, 'key is an already open key, or any one of the predefined'
	DB	' HKEY_* constants.', 0aH, 'value_name is a string containing '
	DB	'the name of the value to set, or None.', 0aH, 'reserved can b'
	DB	'e anything - zero is always passed to the API.', 0aH, 'type i'
	DB	's an integer that specifies the type of the data.  This shoul'
	DB	'd be one of:', 0aH, '  REG_BINARY -- Binary data in any form.'
	DB	0aH, '  REG_DWORD -- A 32-bit number.', 0aH, '  REG_DWORD_LITT'
	DB	'LE_ENDIAN -- A 32-bit number in little-endian format.', 0aH, ' '
	DB	' REG_DWORD_BIG_ENDIAN -- A 32-bit number in big-endian format'
	DB	'.', 0aH, '  REG_EXPAND_SZ -- A null-terminated string that co'
	DB	'ntains unexpanded references', 0aH, '                   to en'
	DB	'vironment variables (for example, %PATH%).', 0aH, '  REG_LINK'
	DB	' -- A Unicode symbolic link.', 0aH, '  REG_MULTI_SZ -- An seq'
	DB	'uence of null-terminated strings, terminated by', 0aH, '     '
	DB	'             two null characters.  Note that Python handles t'
	DB	'his', 0aH, '                  termination automatically.', 0aH
	DB	'  REG_NONE -- No defined value type.', 0aH, '  REG_RESOURCE_L'
	DB	'IST -- A device-driver resource list.', 0aH, '  REG_SZ -- A n'
	DB	'ull-terminated string.', 0aH, 'value is a string that specifi'
	DB	'es the new value.', 0aH, 0aH, 'This method can also set addit'
	DB	'ional value and type information for the', 0aH, 'specified ke'
	DB	'y.  The key identified by the key parameter must have been', 0aH
	DB	'opened with KEY_SET_VALUE access.', 0aH, 0aH, 'To open the ke'
	DB	'y, use the CreateKeyEx() or OpenKeyEx() methods.', 0aH, 0aH, 'V'
	DB	'alue lengths are limited by available memory. Long values (mo'
	DB	're than', 0aH, '2048 bytes) should be stored as files with th'
	DB	'e filenames stored in ', 0aH, 'the configuration registry.  T'
	DB	'his helps the registry perform efficiently.', 00H
	ORG $+8
DisableReflectionKey_doc DB 'Disables registry reflection for 32-bit proc'
	DB	'esses running on a 64-bit', 0aH, 'Operating System.  Will gen'
	DB	'erally raise NotImplemented if executed on', 0aH, 'a 32-bit O'
	DB	'perating System.', 0aH, 0aH, 'If the key is not on the reflec'
	DB	'tion list, the function succeeds but has no effect.', 0aH, 'D'
	DB	'isabling reflection for a key does not affect reflection of a'
	DB	'ny subkeys.', 00H
	ORG $+11
EnableReflectionKey_doc DB 'Restores registry reflection for the specifie'
	DB	'd disabled key.', 0aH, 'Will generally raise NotImplemented i'
	DB	'f executed on a 32-bit Operating System.', 0aH, 'Restoring re'
	DB	'flection for a key does not affect reflection of any subkeys.'
	DB	00H
	ORG $+11
QueryReflectionKey_doc DB 'QueryReflectionKey(hkey) -> bool', 0aH, 'Deter'
	DB	'mines the reflection state for the specified key.', 0aH, 'Wil'
	DB	'l generally raise NotImplemented if executed on a 32-bit Oper'
	DB	'ating System.', 0aH, 00H
	ORG $+9
PyHKEY_doc DB	'PyHKEY Object - A Python object, representing a win32 re'
	DB	'gistry key.', 0aH, 0aH, 'This object wraps a Windows HKEY obj'
	DB	'ect, automatically closing it when', 0aH, 'the object is dest'
	DB	'royed.  To guarantee cleanup, you can call either', 0aH, 'the'
	DB	' Close() method on the PyHKEY, or the CloseKey() method.', 0aH
	DB	0aH, 'All functions which accept a handle object also accept a'
	DB	'n integer - ', 0aH, 'however, use of the handle object is enc'
	DB	'ouraged.', 0aH, 0aH, 'Functions:', 0aH, 'Close() - Closes the'
	DB	' underlying handle.', 0aH, 'Detach() - Returns the integer Wi'
	DB	'n32 handle, detaching it from the object', 0aH, 0aH, 'Propert'
	DB	'ies:', 0aH, 'handle - The integer Win32 handle.', 0aH, 0aH, 'O'
	DB	'perations:', 0aH, '__bool__ - Handles with an open object ret'
	DB	'urn true, otherwise false.', 0aH, '__int__ - Converting a han'
	DB	'dle to an integer returns the Win32 handle.', 0aH, 'rich comp'
	DB	'arison - Handle objects are compared using the handle value.', 00H
	ORG $+1
PyHKEY_Close_doc DB 'key.Close()', 0aH, 'Closes the underlying Windows ha'
	DB	'ndle.', 0aH, 0aH, 'If the handle is already closed, no error '
	DB	'is raised.', 00H
	ORG $+8
PyHKEY_Detach_doc DB 'key.Detach() -> int', 0aH, 'Detaches the Windows ha'
	DB	'ndle from the handle object.', 0aH, 0aH, 'The result is the v'
	DB	'alue of the handle before it is detached.  If the', 0aH, 'han'
	DB	'dle is already detached, this will return zero.', 0aH, 0aH, 'A'
	DB	'fter calling this function, the handle is effectively invalid'
	DB	'ated,', 0aH, 'but the handle is not closed.  You would call t'
	DB	'his function when you', 0aH, 'need the underlying win32 handl'
	DB	'e to exist beyond the lifetime of the', 0aH, 'handle object.', 00H
	ORG $+1
PyHKEY_NumberMethods DQ FLAT:PyHKEY_binaryFailureFunc
	DQ	FLAT:PyHKEY_binaryFailureFunc
	DQ	FLAT:PyHKEY_binaryFailureFunc
	DQ	FLAT:PyHKEY_binaryFailureFunc
	DQ	FLAT:PyHKEY_binaryFailureFunc
	DQ	FLAT:PyHKEY_ternaryFailureFunc
	DQ	FLAT:PyHKEY_unaryFailureFunc
	DQ	FLAT:PyHKEY_unaryFailureFunc
	DQ	FLAT:PyHKEY_unaryFailureFunc
	DQ	FLAT:PyHKEY_boolFunc
	DQ	FLAT:PyHKEY_unaryFailureFunc
	DQ	FLAT:PyHKEY_binaryFailureFunc
	DQ	FLAT:PyHKEY_binaryFailureFunc
	DQ	FLAT:PyHKEY_binaryFailureFunc
	DQ	FLAT:PyHKEY_binaryFailureFunc
	DQ	FLAT:PyHKEY_binaryFailureFunc
	DQ	FLAT:PyHKEY_intFunc
	DQ	0000000000000000H
	DQ	FLAT:PyHKEY_unaryFailureFunc
	ORG $+120
PyHKEY_methods DQ FLAT:??_C@_05LGELBCGM@Close?$AA@
	DQ	FLAT:PyHKEY_CloseMethod
	DD	01H
	ORG $+4
	DQ	FLAT:PyHKEY_Close_doc
	DQ	FLAT:??_C@_06OCJDKNLN@Detach?$AA@
	DQ	FLAT:PyHKEY_DetachMethod
	DD	01H
	ORG $+4
	DQ	FLAT:PyHKEY_Detach_doc
	DQ	FLAT:??_C@_09OAJHKKGH@__enter__?$AA@
	DQ	FLAT:PyHKEY_Enter
	DD	04H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_08CMFIGCJD@__exit__?$AA@
	DQ	FLAT:PyHKEY_Exit
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+24
PyHKEY_memberlist DQ FLAT:??_C@_06NCGDPKCC@handle?$AA@
	DD	01H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
PyHKEY_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06FENFPALN@PyHKEY?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:PyHKEY_deallocFunc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyHKEY_NumberMethods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyHKEY_hashFunc
	DQ	0000000000000000H
	DQ	FLAT:PyHKEY_strFunc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	00H
	ORG $+4
	DQ	FLAT:PyHKEY_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyHKEY_methods
	DQ	FLAT:PyHKEY_memberlist
	ORG $+144
winreg_methods DQ FLAT:??_C@_08CEMDMOHB@CloseKey?$AA@
	DQ	FLAT:PyCloseKey
	DD	01H
	ORG $+4
	DQ	FLAT:CloseKey_doc
	DQ	FLAT:??_C@_0BA@GBJAIKNL@ConnectRegistry?$AA@
	DQ	FLAT:PyConnectRegistry
	DD	01H
	ORG $+4
	DQ	FLAT:ConnectRegistry_doc
	DQ	FLAT:??_C@_09DPPCIKFF@CreateKey?$AA@
	DQ	FLAT:PyCreateKey
	DD	01H
	ORG $+4
	DQ	FLAT:CreateKey_doc
	DQ	FLAT:??_C@_0M@FLBGEAAI@CreateKeyEx?$AA@
	DQ	FLAT:PyCreateKeyEx
	DD	03H
	ORG $+4
	DQ	FLAT:CreateKeyEx_doc
	DQ	FLAT:??_C@_09POIPIBKM@DeleteKey?$AA@
	DQ	FLAT:PyDeleteKey
	DD	01H
	ORG $+4
	DQ	FLAT:DeleteKey_doc
	DQ	FLAT:??_C@_0M@JLKACAJ@DeleteKeyEx?$AA@
	DQ	FLAT:PyDeleteKeyEx
	DD	03H
	ORG $+4
	DQ	FLAT:DeleteKeyEx_doc
	DQ	FLAT:??_C@_0M@PPLCJLKN@DeleteValue?$AA@
	DQ	FLAT:PyDeleteValue
	DD	01H
	ORG $+4
	DQ	FLAT:DeleteValue_doc
	DQ	FLAT:??_C@_0BF@BLABHKJP@DisableReflectionKey?$AA@
	DQ	FLAT:PyDisableReflectionKey
	DD	01H
	ORG $+4
	DQ	FLAT:DisableReflectionKey_doc
	DQ	FLAT:??_C@_0BE@FOGLKLAG@EnableReflectionKey?$AA@
	DQ	FLAT:PyEnableReflectionKey
	DD	01H
	ORG $+4
	DQ	FLAT:EnableReflectionKey_doc
	DQ	FLAT:??_C@_07OGJAOAGB@EnumKey?$AA@
	DQ	FLAT:PyEnumKey
	DD	01H
	ORG $+4
	DQ	FLAT:EnumKey_doc
	DQ	FLAT:??_C@_09LLFDHLHP@EnumValue?$AA@
	DQ	FLAT:PyEnumValue
	DD	01H
	ORG $+4
	DQ	FLAT:EnumValue_doc
	DQ	FLAT:??_C@_0BJ@FIJODGGF@ExpandEnvironmentStrings?$AA@
	DQ	FLAT:PyExpandEnvironmentStrings
	DD	01H
	ORG $+4
	DQ	FLAT:ExpandEnvironmentStrings_doc
	DQ	FLAT:??_C@_08FFGKIMAP@FlushKey?$AA@
	DQ	FLAT:PyFlushKey
	DD	01H
	ORG $+4
	DQ	FLAT:FlushKey_doc
	DQ	FLAT:??_C@_07MKPPNCAC@LoadKey?$AA@
	DQ	FLAT:PyLoadKey
	DD	01H
	ORG $+4
	DQ	FLAT:LoadKey_doc
	DQ	FLAT:??_C@_07EMHGDHB@OpenKey?$AA@
	DQ	FLAT:PyOpenKey
	DD	03H
	ORG $+4
	DQ	FLAT:OpenKey_doc
	DQ	FLAT:??_C@_09HDCIMAEH@OpenKeyEx?$AA@
	DQ	FLAT:PyOpenKey
	DD	03H
	ORG $+4
	DQ	FLAT:OpenKeyEx_doc
	DQ	FLAT:??_C@_0L@PJJMANCA@QueryValue?$AA@
	DQ	FLAT:PyQueryValue
	DD	01H
	ORG $+4
	DQ	FLAT:QueryValue_doc
	DQ	FLAT:??_C@_0N@HKICBNFG@QueryValueEx?$AA@
	DQ	FLAT:PyQueryValueEx
	DD	01H
	ORG $+4
	DQ	FLAT:QueryValueEx_doc
	DQ	FLAT:??_C@_0N@MDCBENNB@QueryInfoKey?$AA@
	DQ	FLAT:PyQueryInfoKey
	DD	01H
	ORG $+4
	DQ	FLAT:QueryInfoKey_doc
	DQ	FLAT:??_C@_0BD@CBDGFLPG@QueryReflectionKey?$AA@
	DQ	FLAT:PyQueryReflectionKey
	DD	01H
	ORG $+4
	DQ	FLAT:QueryReflectionKey_doc
	DQ	FLAT:??_C@_07BMOIJBEL@SaveKey?$AA@
	DQ	FLAT:PySaveKey
	DD	01H
	ORG $+4
	DQ	FLAT:SaveKey_doc
	DQ	FLAT:??_C@_08JHMAAEPA@SetValue?$AA@
	DQ	FLAT:PySetValue
	DD	01H
	ORG $+4
	DQ	FLAT:SetValue_doc
	DQ	FLAT:??_C@_0L@ICGGAOLB@SetValueEx?$AA@
	DQ	FLAT:PySetValueEx
	DD	01H
	ORG $+4
	DQ	FLAT:SetValueEx_doc
	DQ	0000000000000000H
	ORG $+24
winregmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06OHDDMFCG@winreg?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:winreg_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\pc\winreg.c
pdata	SEGMENT
$pdata$PyHKEY_unaryFailureFunc DD imagerel PyHKEY_unaryFailureFunc
	DD	imagerel PyHKEY_unaryFailureFunc+35
	DD	imagerel $unwind$PyHKEY_unaryFailureFunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_unaryFailureFunc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_unaryFailureFunc
_TEXT	SEGMENT
ob$ = 48
PyHKEY_unaryFailureFunc PROC				; COMDAT

; 427  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 428  :     PyErr_SetString(PyExc_TypeError, failMsg);

  00009	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR failMsg
  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00017	e8 00 00 00 00	 call	 PyErr_SetString

; 429  :     return NULL;

  0001c	33 c0		 xor	 eax, eax

; 430  : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
PyHKEY_unaryFailureFunc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_binaryFailureFunc DD imagerel PyHKEY_binaryFailureFunc
	DD	imagerel PyHKEY_binaryFailureFunc+40
	DD	imagerel $unwind$PyHKEY_binaryFailureFunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_binaryFailureFunc DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_binaryFailureFunc
_TEXT	SEGMENT
ob1$ = 48
ob2$ = 56
PyHKEY_binaryFailureFunc PROC				; COMDAT

; 433  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 434  :     PyErr_SetString(PyExc_TypeError, failMsg);

  0000e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR failMsg
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0001c	e8 00 00 00 00	 call	 PyErr_SetString

; 435  :     return NULL;

  00021	33 c0		 xor	 eax, eax

; 436  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
PyHKEY_binaryFailureFunc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_ternaryFailureFunc DD imagerel PyHKEY_ternaryFailureFunc
	DD	imagerel PyHKEY_ternaryFailureFunc+45
	DD	imagerel $unwind$PyHKEY_ternaryFailureFunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_ternaryFailureFunc DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_ternaryFailureFunc
_TEXT	SEGMENT
ob1$ = 48
ob2$ = 56
ob3$ = 64
PyHKEY_ternaryFailureFunc PROC				; COMDAT

; 439  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 440  :     PyErr_SetString(PyExc_TypeError, failMsg);

  00013	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR failMsg
  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00021	e8 00 00 00 00	 call	 PyErr_SetString

; 441  :     return NULL;

  00026	33 c0		 xor	 eax, eax

; 442  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
PyHKEY_ternaryFailureFunc ENDP
_TEXT	ENDS
EXTRN	_PyObject_DebugFree:PROC
EXTRN	__imp_RegCloseKey:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_deallocFunc DD imagerel PyHKEY_deallocFunc
	DD	imagerel PyHKEY_deallocFunc+61
	DD	imagerel $unwind$PyHKEY_deallocFunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_deallocFunc DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_deallocFunc
_TEXT	SEGMENT
obkey$ = 32
ob$ = 64
PyHKEY_deallocFunc PROC					; COMDAT

; 446  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 447  :     /* Can not call PyHKEY_Close, as the ob->tp_type
; 448  :        has already been cleared, thus causing the type
; 449  :        check to fail!
; 450  :     */
; 451  :     PyHKEYObject *obkey = (PyHKEYObject *)ob;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ob$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR obkey$[rsp], rax

; 452  :     if (obkey->hkey)

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR obkey$[rsp]
  00018	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0001d	74 0f		 je	 SHORT $LN1@PyHKEY_dea

; 453  :         RegCloseKey((HKEY)obkey->hkey);

  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR obkey$[rsp]
  00024	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey
$LN1@PyHKEY_dea:

; 454  :     PyObject_DEL(ob);

  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ob$[rsp]
  00033	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 455  : }

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	c3		 ret	 0
PyHKEY_deallocFunc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_boolFunc DD imagerel PyHKEY_boolFunc
	DD	imagerel PyHKEY_boolFunc+45
	DD	imagerel $unwind$PyHKEY_boolFunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_boolFunc DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_boolFunc
_TEXT	SEGMENT
tv66 = 0
ob$ = 32
PyHKEY_boolFunc PROC					; COMDAT

; 459  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 460  :     return ((PyHKEYObject *)ob)->hkey != 0;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ob$[rsp]
  0000e	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00013	74 09		 je	 SHORT $LN3@PyHKEY_boo
  00015	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv66[rsp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@PyHKEY_boo
$LN3@PyHKEY_boo:
  0001e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv66[rsp], 0
$LN4@PyHKEY_boo:
  00025	8b 04 24	 mov	 eax, DWORD PTR tv66[rsp]

; 461  : }

  00028	48 83 c4 18	 add	 rsp, 24
  0002c	c3		 ret	 0
PyHKEY_boolFunc ENDP
_TEXT	ENDS
EXTRN	PyLong_FromVoidPtr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_intFunc DD imagerel PyHKEY_intFunc
	DD	imagerel PyHKEY_intFunc+38
	DD	imagerel $unwind$PyHKEY_intFunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_intFunc DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_intFunc
_TEXT	SEGMENT
pyhkey$ = 32
ob$ = 64
PyHKEY_intFunc PROC					; COMDAT

; 465  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 466  :     PyHKEYObject *pyhkey = (PyHKEYObject *)ob;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ob$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR pyhkey$[rsp], rax

; 467  :     return PyLong_FromVoidPtr(pyhkey->hkey);

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR pyhkey$[rsp]
  00018	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0001c	e8 00 00 00 00	 call	 PyLong_FromVoidPtr

; 468  : }

  00021	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00025	c3		 ret	 0
PyHKEY_intFunc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@KCKNMBCA@?$DMPyHKEY?3?$CFp?$DO?$AA@	; `string'
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_strFunc DD imagerel PyHKEY_strFunc
	DD	imagerel PyHKEY_strFunc+45
	DD	imagerel $unwind$PyHKEY_strFunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_strFunc DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0M@KCKNMBCA@?$DMPyHKEY?3?$CFp?$DO?$AA@
CONST	SEGMENT
??_C@_0M@KCKNMBCA@?$DMPyHKEY?3?$CFp?$DO?$AA@ DB '<PyHKEY:%p>', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyHKEY_strFunc
_TEXT	SEGMENT
pyhkey$ = 32
ob$ = 64
PyHKEY_strFunc PROC					; COMDAT

; 472  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 473  :     PyHKEYObject *pyhkey = (PyHKEYObject *)ob;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ob$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR pyhkey$[rsp], rax

; 474  :     return PyUnicode_FromFormat("<PyHKEY:%p>", pyhkey->hkey);

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR pyhkey$[rsp]
  00018	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@KCKNMBCA@?$DMPyHKEY?3?$CFp?$DO?$AA@
  00023	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 475  : }

  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	c3		 ret	 0
PyHKEY_strFunc ENDP
_TEXT	ENDS
EXTRN	_Py_HashPointer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_hashFunc DD imagerel PyHKEY_hashFunc
	DD	imagerel PyHKEY_hashFunc+24
	DD	imagerel $unwind$PyHKEY_hashFunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_hashFunc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_hashFunc
_TEXT	SEGMENT
ob$ = 48
PyHKEY_hashFunc PROC					; COMDAT

; 488  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 489  :     /* Just use the address.
; 490  :        XXX - should we use the handle value?
; 491  :     */
; 492  :     return _Py_HashPointer(ob);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ob$[rsp]
  0000e	e8 00 00 00 00	 call	 _Py_HashPointer

; 493  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
PyHKEY_hashFunc ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_06JGPGJGKN@?3Close?$AA@			; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_CloseMethod DD imagerel PyHKEY_CloseMethod
	DD	imagerel PyHKEY_CloseMethod+81
	DD	imagerel $unwind$PyHKEY_CloseMethod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_CloseMethod DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_06JGPGJGKN@?3Close?$AA@
CONST	SEGMENT
??_C@_06JGPGJGKN@?3Close?$AA@ DB ':Close', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyHKEY_CloseMethod
_TEXT	SEGMENT
self$ = 48
args$ = 56
PyHKEY_CloseMethod PROC					; COMDAT

; 579  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 580  :     if (!PyArg_ParseTuple(args, ":Close"))

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JGPGJGKN@?3Close?$AA@
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001f	85 c0		 test	 eax, eax
  00021	75 04		 jne	 SHORT $LN2@PyHKEY_Clo

; 581  :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 25		 jmp	 SHORT $LN3@PyHKEY_Clo
$LN2@PyHKEY_Clo:

; 582  :     if (!PyHKEY_Close(self))

  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0002c	e8 00 00 00 00	 call	 PyHKEY_Close
  00031	85 c0		 test	 eax, eax
  00033	75 04		 jne	 SHORT $LN1@PyHKEY_Clo

; 583  :         return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	eb 13		 jmp	 SHORT $LN3@PyHKEY_Clo
$LN1@PyHKEY_Clo:

; 584  :     Py_INCREF(Py_None);

  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00040	e8 00 00 00 00	 call	 _Py_IncRef

; 585  :     return Py_None;

  00045	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@PyHKEY_Clo:

; 586  : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
PyHKEY_CloseMethod ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_07ONAOCBP@?3Detach?$AA@			; `string'
;	COMDAT pdata
; File c:\src\pyparallel\pc\winreg.c
pdata	SEGMENT
$pdata$PyHKEY_DetachMethod DD imagerel PyHKEY_DetachMethod
	DD	imagerel PyHKEY_DetachMethod+91
	DD	imagerel $unwind$PyHKEY_DetachMethod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_DetachMethod DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_07ONAOCBP@?3Detach?$AA@
CONST	SEGMENT
??_C@_07ONAOCBP@?3Detach?$AA@ DB ':Detach', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyHKEY_DetachMethod
_TEXT	SEGMENT
pThis$ = 32
ret$ = 40
self$ = 64
args$ = 72
PyHKEY_DetachMethod PROC				; COMDAT

; 590  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 591  :     void* ret;
; 592  :     PyHKEYObject *pThis = (PyHKEYObject *)self;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR pThis$[rsp], rax

; 593  :     if (!PyArg_ParseTuple(args, ":Detach"))

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07ONAOCBP@?3Detach?$AA@
  0001f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN1@PyHKEY_Det

; 594  :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 25		 jmp	 SHORT $LN2@PyHKEY_Det
$LN1@PyHKEY_Det:

; 595  :     ret = (void*)pThis->hkey;

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR pThis$[rsp]
  00036	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0003a	48 89 44 24 28	 mov	 QWORD PTR ret$[rsp], rax

; 596  :     pThis->hkey = 0;

  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR pThis$[rsp]
  00044	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 597  :     return PyLong_FromVoidPtr(ret);

  0004c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ret$[rsp]
  00051	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
$LN2@PyHKEY_Det:

; 598  : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
PyHKEY_DetachMethod ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_Enter DD imagerel PyHKEY_Enter
	DD	imagerel PyHKEY_Enter+43
	DD	imagerel $unwind$PyHKEY_Enter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_Enter DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_Enter
_TEXT	SEGMENT
self$ = 48
PyHKEY_Enter PROC					; COMDAT

; 602  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@PyHKEY_Ent:

; 603  :     Py_XINCREF(self);

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR self$[rsp], 0
  0000f	74 0a		 je	 SHORT $LN1@PyHKEY_Ent
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00016	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@PyHKEY_Ent:
  0001b	33 c0		 xor	 eax, eax
  0001d	85 c0		 test	 eax, eax
  0001f	75 e8		 jne	 SHORT $LN4@PyHKEY_Ent

; 604  :     return self;

  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]

; 605  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
PyHKEY_Enter ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_Exit DD imagerel PyHKEY_Exit
	DD	imagerel PyHKEY_Exit+56
	DD	imagerel $unwind$PyHKEY_Exit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_Exit DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_Exit
_TEXT	SEGMENT
self$ = 48
args$ = 56
PyHKEY_Exit PROC					; COMDAT

; 609  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 610  :     if (!PyHKEY_Close(self))

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 PyHKEY_Close
  00018	85 c0		 test	 eax, eax
  0001a	75 04		 jne	 SHORT $LN1@PyHKEY_Exi

; 611  :         return NULL;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 13		 jmp	 SHORT $LN2@PyHKEY_Exi
$LN1@PyHKEY_Exi:

; 612  :     Py_RETURN_NONE;

  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00027	e8 00 00 00 00	 call	 _Py_IncRef
  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@PyHKEY_Exi:

; 613  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
PyHKEY_Exit ENDP
_TEXT	ENDS
PUBLIC	PyHKEY_New
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_New DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$PyHKEY_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_New DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_New
_TEXT	SEGMENT
key$ = 32
hInit$ = 64
PyHKEY_New PROC						; COMDAT

; 621  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 622  :     PyHKEYObject *key = PyObject_NEW(PyHKEYObject, &PyHKEY_Type);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyHKEY_Type
  00010	e8 00 00 00 00	 call	 _PyObject_NEW
  00015	48 89 44 24 20	 mov	 QWORD PTR key$[rsp], rax

; 623  :     if (key)

  0001a	48 83 7c 24 20
	00		 cmp	 QWORD PTR key$[rsp], 0
  00020	74 0e		 je	 SHORT $LN1@PyHKEY_New

; 624  :         key->hkey = hInit;

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR key$[rsp]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hInit$[rsp]
  0002c	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
$LN1@PyHKEY_New:

; 625  :     return (PyObject *)key;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR key$[rsp]

; 626  : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyHKEY_New ENDP
_TEXT	ENDS
EXTRN	PyObject_Init:PROC
EXTRN	_PyObject_DebugMalloc:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$_PyObject_NEW DD imagerel _PyObject_NEW
	DD	imagerel _PyObject_NEW+62
	DD	imagerel $unwind$_PyObject_NEW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_NEW DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_NEW
_TEXT	SEGMENT
tp$ = 48
_PyObject_NEW PROC					; COMDAT

; 293  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 294  :     Px_RETURN(_PxObject_New(tp))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0c		 je	 SHORT $LN1@PyObject_N
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tp$[rsp]
  00017	e8 00 00 00 00	 call	 _PxObject_New
  0001c	eb 1b		 jmp	 SHORT $LN2@PyObject_N
$LN1@PyObject_N:

; 295  :     return PyObject_Init((PyObject *)PyObject_MALLOC(_PyObject_SIZE(tp)), tp);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR tp$[rsp]
  00023	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00027	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  0002c	48 8b 54 24 30	 mov	 rdx, QWORD PTR tp$[rsp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 PyObject_Init
$LN2@PyObject_N:

; 296  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
_PyObject_NEW ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromWindowsErr:PROC
;	COMDAT pdata
; File c:\src\pyparallel\pc\winreg.c
pdata	SEGMENT
$pdata$PyHKEY_Close DD imagerel PyHKEY_Close
	DD	imagerel PyHKEY_Close+172
	DD	imagerel $unwind$PyHKEY_Close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_Close DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_Close
_TEXT	SEGMENT
rc$ = 32
key$ = 40
tv73 = 48
tv78 = 52
ob_handle$ = 80
PyHKEY_Close PROC					; COMDAT

; 630  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 631  :     LONG rc;
; 632  :     PyHKEYObject *key;
; 633  : 
; 634  :     if (!PyHKEY_Check(ob_handle)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyHKEY_Type
  00010	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ob_handle$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 17		 je	 SHORT $LN2@PyHKEY_Clo@2

; 635  :         PyErr_SetString(PyExc_TypeError, "bad operand type");

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@HNACHIIA@bad?5operand?5type?$AA@
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00029	e8 00 00 00 00	 call	 PyErr_SetString

; 636  :         return FALSE;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 75		 jmp	 SHORT $LN3@PyHKEY_Clo@2
$LN2@PyHKEY_Clo@2:

; 637  :     }
; 638  :     key = (PyHKEYObject *)ob_handle;

  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR ob_handle$[rsp]
  00037	48 89 44 24 28	 mov	 QWORD PTR key$[rsp], rax

; 639  :     rc = key->hkey ? RegCloseKey((HKEY)key->hkey) : ERROR_SUCCESS;

  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR key$[rsp]
  00041	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00046	74 15		 je	 SHORT $LN5@PyHKEY_Clo@2
  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR key$[rsp]
  0004d	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey
  00057	89 44 24 30	 mov	 DWORD PTR tv73[rsp], eax
  0005b	eb 08		 jmp	 SHORT $LN6@PyHKEY_Clo@2
$LN5@PyHKEY_Clo@2:
  0005d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN6@PyHKEY_Clo@2:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR tv73[rsp]
  00069	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 640  :     key->hkey = 0;

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR key$[rsp]
  00072	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 641  :     if (rc != ERROR_SUCCESS)

  0007a	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0007f	74 09		 je	 SHORT $LN1@PyHKEY_Clo@2

; 642  :         PyErr_SetFromWindowsErrWithFunction(rc, "RegCloseKey");

  00081	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  00085	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN1@PyHKEY_Clo@2:

; 643  :     return rc == ERROR_SUCCESS;

  0008a	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0008f	75 0a		 jne	 SHORT $LN7@PyHKEY_Clo@2
  00091	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  00099	eb 08		 jmp	 SHORT $LN8@PyHKEY_Clo@2
$LN7@PyHKEY_Clo@2:
  0009b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN8@PyHKEY_Clo@2:
  000a3	8b 44 24 34	 mov	 eax, DWORD PTR tv78[rsp]
$LN3@PyHKEY_Clo@2:

; 644  : }

  000a7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ab	c3		 ret	 0
PyHKEY_Close ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@OFKHMLAJ@A?5handle?5must?5be?5a?5HKEY?5object?5o@ ; `string'
PUBLIC	PyWinObject_CloseHKEY
EXTRN	PyLong_AsVoidPtr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyWinObject_CloseHKEY DD imagerel $LN10
	DD	imagerel $LN10+173
	DD	imagerel $unwind$PyWinObject_CloseHKEY
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyWinObject_CloseHKEY DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CN@OFKHMLAJ@A?5handle?5must?5be?5a?5HKEY?5object?5o@
CONST	SEGMENT
??_C@_0CN@OFKHMLAJ@A?5handle?5must?5be?5a?5HKEY?5object?5o@ DB 'A handle '
	DB	'must be a HKEY object or an integer', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyWinObject_CloseHKEY
_TEXT	SEGMENT
ok$ = 32
rc$120692 = 36
tv77 = 40
obHandle$ = 64
PyWinObject_CloseHKEY PROC				; COMDAT

; 698  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 699  :     BOOL ok;
; 700  :     if (PyHKEY_Check(obHandle)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyHKEY_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obHandle$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	75 10		 jne	 SHORT $LN5@PyWinObjec

; 701  :         ok = PyHKEY_Close(obHandle);

  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obHandle$[rsp]
  00020	e8 00 00 00 00	 call	 PyHKEY_Close
  00025	89 44 24 20	 mov	 DWORD PTR ok$[rsp], eax
  00029	eb 79		 jmp	 SHORT $LN4@PyWinObjec
$LN5@PyWinObjec:

; 702  :     }
; 703  : #if SIZEOF_LONG >= SIZEOF_HKEY
; 704  :     else if (PyLong_Check(obHandle)) {
; 705  :         long rc = RegCloseKey((HKEY)PyLong_AsLong(obHandle));
; 706  :         ok = (rc == ERROR_SUCCESS);
; 707  :         if (!ok)
; 708  :             PyErr_SetFromWindowsErrWithFunction(rc, "RegCloseKey");
; 709  :     }
; 710  : #else
; 711  :     else if (PyLong_Check(obHandle)) {

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR obHandle$[rsp]
  00030	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00034	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0003a	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0003f	85 c0		 test	 eax, eax
  00041	74 4a		 je	 SHORT $LN3@PyWinObjec

; 712  :         long rc = RegCloseKey((HKEY)PyLong_AsVoidPtr(obHandle));

  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obHandle$[rsp]
  00048	e8 00 00 00 00	 call	 PyLong_AsVoidPtr
  0004d	48 8b c8	 mov	 rcx, rax
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey
  00056	89 44 24 24	 mov	 DWORD PTR rc$120692[rsp], eax

; 713  :         ok = (rc == ERROR_SUCCESS);

  0005a	83 7c 24 24 00	 cmp	 DWORD PTR rc$120692[rsp], 0
  0005f	75 0a		 jne	 SHORT $LN8@PyWinObjec
  00061	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
  00069	eb 08		 jmp	 SHORT $LN9@PyWinObjec
$LN8@PyWinObjec:
  0006b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN9@PyWinObjec:
  00073	8b 44 24 28	 mov	 eax, DWORD PTR tv77[rsp]
  00077	89 44 24 20	 mov	 DWORD PTR ok$[rsp], eax

; 714  :         if (!ok)

  0007b	83 7c 24 20 00	 cmp	 DWORD PTR ok$[rsp], 0
  00080	75 09		 jne	 SHORT $LN2@PyWinObjec

; 715  :             PyErr_SetFromWindowsErrWithFunction(rc, "RegCloseKey");

  00082	8b 4c 24 24	 mov	 ecx, DWORD PTR rc$120692[rsp]
  00086	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN2@PyWinObjec:

; 716  :     }
; 717  : #endif
; 718  :     else {

  0008b	eb 17		 jmp	 SHORT $LN1@PyWinObjec
$LN3@PyWinObjec:

; 719  :         PyErr_SetString(
; 720  :             PyExc_TypeError,
; 721  :             "A handle must be a HKEY object or an integer");

  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@OFKHMLAJ@A?5handle?5must?5be?5a?5HKEY?5object?5o@
  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009b	e8 00 00 00 00	 call	 PyErr_SetString

; 722  :         return FALSE;

  000a0	33 c0		 xor	 eax, eax
  000a2	eb 04		 jmp	 SHORT $LN6@PyWinObjec
$LN1@PyWinObjec:
$LN4@PyWinObjec:

; 723  :     }
; 724  :     return ok;

  000a4	8b 44 24 20	 mov	 eax, DWORD PTR ok$[rsp]
$LN6@PyWinObjec:

; 725  : }

  000a8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ac	c3		 ret	 0
PyWinObject_CloseHKEY ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@JDCMJEOL@O?3CloseKey?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCloseKey DD imagerel PyCloseKey
	DD	imagerel PyCloseKey+86
	DD	imagerel $unwind$PyCloseKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCloseKey DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0L@JDCMJEOL@O?3CloseKey?$AA@
CONST	SEGMENT
??_C@_0L@JDCMJEOL@O?3CloseKey?$AA@ DB 'O:CloseKey', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyCloseKey
_TEXT	SEGMENT
obKey$ = 32
self$ = 64
args$ = 72
PyCloseKey PROC						; COMDAT

; 985  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 986  :     PyObject *obKey;
; 987  :     if (!PyArg_ParseTuple(args, "O:CloseKey", &obKey))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR obKey$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@JDCMJEOL@O?3CloseKey?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@PyCloseKey

; 988  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 25		 jmp	 SHORT $LN3@PyCloseKey
$LN2@PyCloseKey:

; 989  :     if (!PyHKEY_Close(obKey))

  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR obKey$[rsp]
  00031	e8 00 00 00 00	 call	 PyHKEY_Close
  00036	85 c0		 test	 eax, eax
  00038	75 04		 jne	 SHORT $LN1@PyCloseKey

; 990  :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 13		 jmp	 SHORT $LN3@PyCloseKey
$LN1@PyCloseKey:

; 991  :     Py_INCREF(Py_None);

  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00045	e8 00 00 00 00	 call	 _Py_IncRef

; 992  :     return Py_None;

  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@PyCloseKey:

; 993  : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
PyCloseKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@DDFAGEGB@ZO?3ConnectRegistry?$AA@	; `string'
EXTRN	PyEval_RestoreThread:PROC
EXTRN	__imp_RegConnectRegistryW:PROC
EXTRN	PyEval_SaveThread:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyConnectRegistry DD imagerel PyConnectRegistry
	DD	imagerel PyConnectRegistry+162
	DD	imagerel $unwind$PyConnectRegistry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyConnectRegistry DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BD@DDFAGEGB@ZO?3ConnectRegistry?$AA@
CONST	SEGMENT
??_C@_0BD@DDFAGEGB@ZO?3ConnectRegistry?$AA@ DB 'ZO:ConnectRegistry', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyConnectRegistry
_TEXT	SEGMENT
rc$ = 32
retKey$ = 40
szCompName$ = 48
hKey$ = 56
obKey$ = 64
_save$120961 = 72
self$ = 96
args$ = 104
PyConnectRegistry PROC					; COMDAT

; 997  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 998  :     HKEY hKey;
; 999  :     PyObject *obKey;
; 1000 :     wchar_t *szCompName = NULL;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR szCompName$[rsp], 0

; 1001 :     HKEY retKey;
; 1002 :     long rc;
; 1003 :     if (!PyArg_ParseTuple(args, "ZO:ConnectRegistry", &szCompName, &obKey))

  00017	4c 8d 4c 24 40	 lea	 r9, QWORD PTR obKey$[rsp]
  0001c	4c 8d 44 24 30	 lea	 r8, QWORD PTR szCompName$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@DDFAGEGB@ZO?3ConnectRegistry?$AA@
  00028	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0002d	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00032	85 c0		 test	 eax, eax
  00034	75 04		 jne	 SHORT $LN3@PyConnectR

; 1004 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 63		 jmp	 SHORT $LN4@PyConnectR
$LN3@PyConnectR:

; 1005 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  0003a	45 33 c0	 xor	 r8d, r8d
  0003d	48 8d 54 24 38	 lea	 rdx, QWORD PTR hKey$[rsp]
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obKey$[rsp]
  00047	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  0004c	85 c0		 test	 eax, eax
  0004e	75 04		 jne	 SHORT $LN2@PyConnectR

; 1006 :         return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	eb 49		 jmp	 SHORT $LN4@PyConnectR
$LN2@PyConnectR:

; 1007 :     Py_BEGIN_ALLOW_THREADS

  00054	e8 00 00 00 00	 call	 PyEval_SaveThread
  00059	48 89 44 24 48	 mov	 QWORD PTR _save$120961[rsp], rax

; 1008 :     rc = RegConnectRegistryW(szCompName, hKey, &retKey);

  0005e	4c 8d 44 24 28	 lea	 r8, QWORD PTR retKey$[rsp]
  00063	48 8b 54 24 38	 mov	 rdx, QWORD PTR hKey$[rsp]
  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR szCompName$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegConnectRegistryW
  00073	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1009 :     Py_END_ALLOW_THREADS

  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _save$120961[rsp]
  0007c	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1010 :     if (rc != ERROR_SUCCESS)

  00081	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00086	74 0b		 je	 SHORT $LN1@PyConnectR

; 1011 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1012 :                                                    "ConnectRegistry");

  00088	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  0008c	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00091	eb 0a		 jmp	 SHORT $LN4@PyConnectR
$LN1@PyConnectR:

; 1013 :     return PyHKEY_FromHKEY(retKey);

  00093	48 8b 4c 24 28	 mov	 rcx, QWORD PTR retKey$[rsp]
  00098	e8 00 00 00 00	 call	 PyHKEY_FromHKEY
$LN4@PyConnectR:

; 1014 : }

  0009d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000a1	c3		 ret	 0
PyConnectRegistry ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@GPIIECHJ@The?5object?5is?5not?5a?5PyHKEY?5objec@ ; `string'
PUBLIC	??_C@_0CJ@JPBLOMCN@None?5is?5not?5a?5valid?5HKEY?5in?5this@ ; `string'
EXTRN	PyErr_Occurred:PROC
EXTRN	PyErr_Clear:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_AsHKEY DD imagerel PyHKEY_AsHKEY
	DD	imagerel PyHKEY_AsHKEY+226
	DD	imagerel $unwind$PyHKEY_AsHKEY
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_AsHKEY DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CC@GPIIECHJ@The?5object?5is?5not?5a?5PyHKEY?5objec@
CONST	SEGMENT
??_C@_0CC@GPIIECHJ@The?5object?5is?5not?5a?5PyHKEY?5objec@ DB 'The object'
	DB	' is not a PyHKEY object', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JPBLOMCN@None?5is?5not?5a?5valid?5HKEY?5in?5this@
CONST	SEGMENT
??_C@_0CJ@JPBLOMCN@None?5is?5not?5a?5valid?5HKEY?5in?5this@ DB 'None is n'
	DB	'ot a valid HKEY in this context', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyHKEY_AsHKEY
_TEXT	SEGMENT
pH$120665 = 32
ob$ = 64
pHANDLE$ = 72
bNoneOK$ = 80
PyHKEY_AsHKEY PROC					; COMDAT

; 648  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 649  :     if (ob == Py_None) {

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001a	48 39 44 24 40	 cmp	 QWORD PTR ob$[rsp], rax
  0001f	75 32		 jne	 SHORT $LN8@PyHKEY_AsH

; 650  :         if (!bNoneOK) {

  00021	83 7c 24 50 00	 cmp	 DWORD PTR bNoneOK$[rsp], 0
  00026	75 1a		 jne	 SHORT $LN7@PyHKEY_AsH

; 651  :             PyErr_SetString(
; 652  :                       PyExc_TypeError,
; 653  :                       "None is not a valid HKEY in this context");

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@JPBLOMCN@None?5is?5not?5a?5valid?5HKEY?5in?5this@
  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00036	e8 00 00 00 00	 call	 PyErr_SetString

; 654  :             return FALSE;

  0003b	33 c0		 xor	 eax, eax
  0003d	e9 9b 00 00 00	 jmp	 $LN9@PyHKEY_AsH
$LN7@PyHKEY_AsH:

; 655  :         }
; 656  :         *pHANDLE = (HKEY)0;

  00042	48 8b 44 24 48	 mov	 rax, QWORD PTR pHANDLE$[rsp]
  00047	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  0004e	e9 85 00 00 00	 jmp	 $LN6@PyHKEY_AsH
$LN8@PyHKEY_AsH:

; 657  :     }
; 658  :     else if (PyHKEY_Check(ob)) {

  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyHKEY_Type
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ob$[rsp]
  0005f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00063	75 1d		 jne	 SHORT $LN5@PyHKEY_AsH

; 659  :         PyHKEYObject *pH = (PyHKEYObject *)ob;

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR ob$[rsp]
  0006a	48 89 44 24 20	 mov	 QWORD PTR pH$120665[rsp], rax

; 660  :         *pHANDLE = pH->hkey;

  0006f	48 8b 44 24 48	 mov	 rax, QWORD PTR pHANDLE$[rsp]
  00074	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pH$120665[rsp]
  00079	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0007d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00080	eb 56		 jmp	 SHORT $LN4@PyHKEY_AsH
$LN5@PyHKEY_AsH:

; 661  :     }
; 662  :     else if (PyLong_Check(ob)) {

  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR ob$[rsp]
  00087	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00091	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00096	85 c0		 test	 eax, eax
  00098	74 27		 je	 SHORT $LN3@PyHKEY_AsH

; 663  :         /* We also support integers */
; 664  :         PyErr_Clear();

  0009a	e8 00 00 00 00	 call	 PyErr_Clear

; 665  :         *pHANDLE = (HKEY)PyLong_AsVoidPtr(ob);

  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ob$[rsp]
  000a4	e8 00 00 00 00	 call	 PyLong_AsVoidPtr
  000a9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pHANDLE$[rsp]
  000ae	48 89 01	 mov	 QWORD PTR [rcx], rax

; 666  :         if (PyErr_Occurred())

  000b1	e8 00 00 00 00	 call	 PyErr_Occurred
  000b6	48 85 c0	 test	 rax, rax
  000b9	74 04		 je	 SHORT $LN2@PyHKEY_AsH

; 667  :             return FALSE;

  000bb	33 c0		 xor	 eax, eax
  000bd	eb 1e		 jmp	 SHORT $LN9@PyHKEY_AsH
$LN2@PyHKEY_AsH:

; 668  :     }
; 669  :     else {

  000bf	eb 17		 jmp	 SHORT $LN1@PyHKEY_AsH
$LN3@PyHKEY_AsH:

; 670  :         PyErr_SetString(
; 671  :                         PyExc_TypeError,
; 672  :             "The object is not a PyHKEY object");

  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@GPIIECHJ@The?5object?5is?5not?5a?5PyHKEY?5objec@
  000c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000cf	e8 00 00 00 00	 call	 PyErr_SetString

; 673  :         return FALSE;

  000d4	33 c0		 xor	 eax, eax
  000d6	eb 05		 jmp	 SHORT $LN9@PyHKEY_AsH
$LN1@PyHKEY_AsH:
$LN4@PyHKEY_AsH:
$LN6@PyHKEY_AsH:

; 674  :     }
; 675  :     return TRUE;

  000d8	b8 01 00 00 00	 mov	 eax, 1
$LN9@PyHKEY_AsH:

; 676  : }

  000dd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e1	c3		 ret	 0
PyHKEY_AsHKEY ENDP
_TEXT	ENDS
EXTRN	PyErr_NoMemory:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyHKEY_FromHKEY DD imagerel PyHKEY_FromHKEY
	DD	imagerel PyHKEY_FromHKEY+80
	DD	imagerel $unwind$PyHKEY_FromHKEY
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyHKEY_FromHKEY DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyHKEY_FromHKEY
_TEXT	SEGMENT
op$ = 32
h$ = 64
PyHKEY_FromHKEY PROC					; COMDAT

; 680  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 681  :     PyHKEYObject *op;
; 682  : 
; 683  :     /* Inline PyObject_New */
; 684  :     op = (PyHKEYObject *) PyObject_MALLOC(sizeof(PyHKEYObject));

  00009	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0000e	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00013	48 89 44 24 20	 mov	 QWORD PTR op$[rsp], rax

; 685  :     if (op == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR op$[rsp], 0
  0001e	75 07		 jne	 SHORT $LN1@PyHKEY_Fro

; 686  :         return PyErr_NoMemory();

  00020	e8 00 00 00 00	 call	 PyErr_NoMemory
  00025	eb 24		 jmp	 SHORT $LN2@PyHKEY_Fro
$LN1@PyHKEY_Fro:

; 687  :     PyObject_INIT(op, &PyHKEY_Type);

  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyHKEY_Type
  0002e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  00033	e8 00 00 00 00	 call	 PyObject_INIT

; 688  :     op->hkey = h;

  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR h$[rsp]
  00042	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 689  :     return (PyObject *)op;

  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
$LN2@PyHKEY_Fro:

; 690  : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
PyHKEY_FromHKEY ENDP
_TEXT	ENDS
EXTRN	_Py_NewReference:PROC
EXTRN	_PxObject_Init:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$PyObject_INIT DD imagerel PyObject_INIT
	DD	imagerel PyObject_INIT+84
	DD	imagerel $unwind$PyObject_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_INIT
_TEXT	SEGMENT
op$ = 48
tp$ = 56
PyObject_INIT PROC					; COMDAT

; 236  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 237  :     Px_RETURN(_PxObject_Init(op, tp))

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 11		 je	 SHORT $LN1@PyObject_I
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR tp$[rsp]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00021	e8 00 00 00 00	 call	 _PxObject_Init
  00026	eb 27		 jmp	 SHORT $LN2@PyObject_I
$LN1@PyObject_I:

; 238  :     Py_TYPE(op) = tp;

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tp$[rsp]
  00032	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 239  :     _PyObject_InitHead(op);

  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0003b	e8 00 00 00 00	 call	 _PyObject_InitHead

; 240  :     _Py_NewReference(op);

  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00045	e8 00 00 00 00	 call	 _Py_NewReference

; 241  :     return op;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
$LN2@PyObject_I:

; 242  : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
PyObject_INIT ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_InitHead DD imagerel _PyObject_InitHead
	DD	imagerel _PyObject_InitHead+182
	DD	imagerel $unwind$_PyObject_InitHead
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_InitHead DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H
	DB	'(', 00H, 'o', 00H, 'p', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@
CONST	SEGMENT
??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 48
_PyObject_InitHead PROC					; COMDAT

; 215  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 216  :     assert(Py_TYPE(op));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0000e	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  00013	75 1c		 jne	 SHORT $LN3@PyObject_I@2
  00015	41 b8 d8 00 00
	00		 mov	 r8d, 216		; 000000d8H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	33 c0		 xor	 eax, eax
$LN3@PyObject_I@2:

; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00036	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx

; 218  :     op->px    = _Py_NOT_PARALLEL;

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00048	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00052	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 219  :     op->slist_entry.Next = NULL;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0005b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00068	48 c7 40 20 01
	00 00 00	 mov	 QWORD PTR [rax+32], 1

; 221  :     op->srw_lock  = NULL;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00075	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 222  :     op->event     = NULL;

  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 223  :     op->orig_type = NULL;

  0008a	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0008f	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;

  00097	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0009c	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 226  :     op->_ob_prev = NULL;

  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  000a9	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;
; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;
; 230  : #endif
; 231  : }

  000b1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b5	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FFHIEBMK@OZ?3CreateKey?$AA@		; `string'
EXTRN	__imp_RegCreateKeyW:PROC
;	COMDAT pdata
; File c:\src\pyparallel\pc\winreg.c
pdata	SEGMENT
$pdata$PyCreateKey DD imagerel PyCreateKey
	DD	imagerel PyCreateKey+133
	DD	imagerel $unwind$PyCreateKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCreateKey DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0N@FFHIEBMK@OZ?3CreateKey?$AA@
CONST	SEGMENT
??_C@_0N@FFHIEBMK@OZ?3CreateKey?$AA@ DB 'OZ:CreateKey', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyCreateKey
_TEXT	SEGMENT
subKey$ = 32
rc$ = 40
retKey$ = 48
hKey$ = 56
obKey$ = 64
self$ = 96
args$ = 104
PyCreateKey PROC					; COMDAT

; 1018 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1019 :     HKEY hKey;
; 1020 :     PyObject *obKey;
; 1021 :     wchar_t *subKey;
; 1022 :     HKEY retKey;
; 1023 :     long rc;
; 1024 :     if (!PyArg_ParseTuple(args, "OZ:CreateKey", &obKey, &subKey))

  0000e	4c 8d 4c 24 20	 lea	 r9, QWORD PTR subKey$[rsp]
  00013	4c 8d 44 24 40	 lea	 r8, QWORD PTR obKey$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@FFHIEBMK@OZ?3CreateKey?$AA@
  0001f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN3@PyCreateKe

; 1025 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 4f		 jmp	 SHORT $LN4@PyCreateKe
$LN3@PyCreateKe:

; 1026 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8d 54 24 38	 lea	 rdx, QWORD PTR hKey$[rsp]
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obKey$[rsp]
  0003e	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  00043	85 c0		 test	 eax, eax
  00045	75 04		 jne	 SHORT $LN2@PyCreateKe

; 1027 :         return NULL;

  00047	33 c0		 xor	 eax, eax
  00049	eb 35		 jmp	 SHORT $LN4@PyCreateKe
$LN2@PyCreateKe:

; 1028 :     rc = RegCreateKeyW(hKey, subKey, &retKey);

  0004b	4c 8d 44 24 30	 lea	 r8, QWORD PTR retKey$[rsp]
  00050	48 8b 54 24 20	 mov	 rdx, QWORD PTR subKey$[rsp]
  00055	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hKey$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCreateKeyW
  00060	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 1029 :     if (rc != ERROR_SUCCESS)

  00064	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00069	74 0b		 je	 SHORT $LN1@PyCreateKe

; 1030 :         return PyErr_SetFromWindowsErrWithFunction(rc, "CreateKey");

  0006b	8b 4c 24 28	 mov	 ecx, DWORD PTR rc$[rsp]
  0006f	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00074	eb 0a		 jmp	 SHORT $LN4@PyCreateKe
$LN1@PyCreateKe:

; 1031 :     return PyHKEY_FromHKEY(retKey);

  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR retKey$[rsp]
  0007b	e8 00 00 00 00	 call	 PyHKEY_FromHKEY
$LN4@PyCreateKe:

; 1032 : }

  00080	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00084	c3		 ret	 0
PyCreateKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@CALEHHMP@OZ?$HMii?3CreateKeyEx?$AA@	; `string'
PUBLIC	??_C@_06EBPNOMLE@access?$AA@			; `string'
PUBLIC	??_C@_08FINKBBAF@reserved?$AA@			; `string'
PUBLIC	??_C@_07KFOLAEFE@sub_key?$AA@			; `string'
PUBLIC	??_C@_03ICHNJLJF@key?$AA@			; `string'
EXTRN	__imp_RegCreateKeyExW:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCreateKeyEx DD imagerel PyCreateKeyEx
	DD	imagerel PyCreateKeyEx+355
	DD	imagerel $unwind$PyCreateKeyEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCreateKeyEx DD 021601H
	DD	0170116H
xdata	ENDS
;	COMDAT ??_C@_0BC@CALEHHMP@OZ?$HMii?3CreateKeyEx?$AA@
CONST	SEGMENT
??_C@_0BC@CALEHHMP@OZ?$HMii?3CreateKeyEx?$AA@ DB 'OZ|ii:CreateKeyEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBPNOMLE@access?$AA@
CONST	SEGMENT
??_C@_06EBPNOMLE@access?$AA@ DB 'access', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FINKBBAF@reserved?$AA@
CONST	SEGMENT
??_C@_08FINKBBAF@reserved?$AA@ DB 'reserved', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFOLAEFE@sub_key?$AA@
CONST	SEGMENT
??_C@_07KFOLAEFE@sub_key?$AA@ DB 'sub_key', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICHNJLJF@key?$AA@
CONST	SEGMENT
??_C@_03ICHNJLJF@key?$AA@ DB 'key', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyCreateKeyEx
_TEXT	SEGMENT
kwlist$ = 80
rc$ = 120
retKey$ = 128
hKey$ = 136
sub_key$ = 144
key$ = 152
access$ = 160
reserved$ = 164
self$ = 192
args$ = 200
kwargs$ = 208
PyCreateKeyEx PROC					; COMDAT

; 1036 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1037 :     HKEY hKey;
; 1038 :     PyObject *key;
; 1039 :     wchar_t *sub_key;
; 1040 :     HKEY retKey;
; 1041 :     int reserved = 0;

  00016	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR reserved$[rsp], 0

; 1042 :     REGSAM access = KEY_WRITE;

  00021	c7 84 24 a0 00
	00 00 06 00 02
	00		 mov	 DWORD PTR access$[rsp], 131078 ; 00020006H

; 1043 :     long rc;
; 1044 : 
; 1045 :     char *kwlist[] = {"key", "sub_key", "reserved", "access", NULL};

  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03ICHNJLJF@key?$AA@
  00033	48 89 44 24 50	 mov	 QWORD PTR kwlist$[rsp], rax
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07KFOLAEFE@sub_key?$AA@
  0003f	48 89 44 24 58	 mov	 QWORD PTR kwlist$[rsp+8], rax
  00044	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08FINKBBAF@reserved?$AA@
  0004b	48 89 44 24 60	 mov	 QWORD PTR kwlist$[rsp+16], rax
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06EBPNOMLE@access?$AA@
  00057	48 89 44 24 68	 mov	 QWORD PTR kwlist$[rsp+24], rax
  0005c	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR kwlist$[rsp+32], 0

; 1046 : 
; 1047 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OZ|ii:CreateKeyEx", kwlist,
; 1048 :                                      &key, &sub_key, &reserved, &access))

  00065	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR access$[rsp]
  0006d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00072	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR reserved$[rsp]
  0007a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0007f	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR sub_key$[rsp]
  00087	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008c	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR key$[rsp]
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8d 4c 24 50	 lea	 r9, QWORD PTR kwlist$[rsp]
  0009e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BC@CALEHHMP@OZ?$HMii?3CreateKeyEx?$AA@
  000a5	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  000ad	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000b5	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000ba	85 c0		 test	 eax, eax
  000bc	75 07		 jne	 SHORT $LN3@PyCreateKe@2

; 1049 :         return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	e9 96 00 00 00	 jmp	 $LN4@PyCreateKe@2
$LN3@PyCreateKe@2:

; 1050 :     if (!PyHKEY_AsHKEY(key, &hKey, FALSE))

  000c5	45 33 c0	 xor	 r8d, r8d
  000c8	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR hKey$[rsp]
  000d0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  000d8	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  000dd	85 c0		 test	 eax, eax
  000df	75 04		 jne	 SHORT $LN2@PyCreateKe@2

; 1051 :         return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	eb 76		 jmp	 SHORT $LN4@PyCreateKe@2
$LN2@PyCreateKe@2:

; 1052 : 
; 1053 :     rc = RegCreateKeyExW(hKey, sub_key, reserved, NULL, (DWORD)NULL,
; 1054 :                          access, NULL, &retKey, NULL);

  000e5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  000ee	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR retKey$[rsp]
  000f6	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000fb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00104	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR access$[rsp]
  0010b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0010f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00117	45 33 c9	 xor	 r9d, r9d
  0011a	44 8b 84 24 a4
	00 00 00	 mov	 r8d, DWORD PTR reserved$[rsp]
  00122	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR sub_key$[rsp]
  0012a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR hKey$[rsp]
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCreateKeyExW
  00138	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 1055 :     if (rc != ERROR_SUCCESS)

  0013c	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  00141	74 0b		 je	 SHORT $LN1@PyCreateKe@2

; 1056 :         return PyErr_SetFromWindowsErrWithFunction(rc, "CreateKeyEx");

  00143	8b 4c 24 78	 mov	 ecx, DWORD PTR rc$[rsp]
  00147	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  0014c	eb 0d		 jmp	 SHORT $LN4@PyCreateKe@2
$LN1@PyCreateKe@2:

; 1057 :     return PyHKEY_FromHKEY(retKey);

  0014e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR retKey$[rsp]
  00156	e8 00 00 00 00	 call	 PyHKEY_FromHKEY
$LN4@PyCreateKe@2:

; 1058 : }

  0015b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00162	c3		 ret	 0
PyCreateKeyEx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@POKAAOLK@Ou?3DeleteKey?$AA@		; `string'
EXTRN	__imp_RegDeleteKeyW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyDeleteKey DD imagerel PyDeleteKey
	DD	imagerel PyDeleteKey+137
	DD	imagerel $unwind$PyDeleteKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyDeleteKey DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0N@POKAAOLK@Ou?3DeleteKey?$AA@
CONST	SEGMENT
??_C@_0N@POKAAOLK@Ou?3DeleteKey?$AA@ DB 'Ou:DeleteKey', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyDeleteKey
_TEXT	SEGMENT
subKey$ = 32
rc$ = 40
hKey$ = 48
obKey$ = 56
self$ = 80
args$ = 88
PyDeleteKey PROC					; COMDAT

; 1062 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1063 :     HKEY hKey;
; 1064 :     PyObject *obKey;
; 1065 :     wchar_t *subKey;
; 1066 :     long rc;
; 1067 :     if (!PyArg_ParseTuple(args, "Ou:DeleteKey", &obKey, &subKey))

  0000e	4c 8d 4c 24 20	 lea	 r9, QWORD PTR subKey$[rsp]
  00013	4c 8d 44 24 38	 lea	 r8, QWORD PTR obKey$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@POKAAOLK@Ou?3DeleteKey?$AA@
  0001f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN3@PyDeleteKe

; 1068 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 53		 jmp	 SHORT $LN4@PyDeleteKe
$LN3@PyDeleteKe:

; 1069 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8d 54 24 30	 lea	 rdx, QWORD PTR hKey$[rsp]
  00039	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obKey$[rsp]
  0003e	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  00043	85 c0		 test	 eax, eax
  00045	75 04		 jne	 SHORT $LN2@PyDeleteKe

; 1070 :         return NULL;

  00047	33 c0		 xor	 eax, eax
  00049	eb 39		 jmp	 SHORT $LN4@PyDeleteKe
$LN2@PyDeleteKe:

; 1071 :     rc = RegDeleteKeyW(hKey, subKey );

  0004b	48 8b 54 24 20	 mov	 rdx, QWORD PTR subKey$[rsp]
  00050	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hKey$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegDeleteKeyW
  0005b	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 1072 :     if (rc != ERROR_SUCCESS)

  0005f	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00064	74 0b		 je	 SHORT $LN1@PyDeleteKe

; 1073 :         return PyErr_SetFromWindowsErrWithFunction(rc, "RegDeleteKey");

  00066	8b 4c 24 28	 mov	 ecx, DWORD PTR rc$[rsp]
  0006a	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  0006f	eb 13		 jmp	 SHORT $LN4@PyDeleteKe
$LN1@PyDeleteKe:

; 1074 :     Py_INCREF(Py_None);

  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00078	e8 00 00 00 00	 call	 _Py_IncRef

; 1075 :     return Py_None;

  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@PyDeleteKe:

; 1076 : }

  00084	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00088	c3		 ret	 0
PyDeleteKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@ODEKPPJP@not?5implemented?5on?5this?5platform@ ; `string'
PUBLIC	??_C@_0BA@LILAPHGE@RegDeleteKeyExW?$AA@		; `string'
PUBLIC	??_C@_1BK@JHLNAEJL@?$AAa?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BC@JKDJDEOB@Ou?$HMii?3DeleteKeyEx?$AA@	; `string'
EXTRN	PyExc_NotImplementedError:QWORD
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_GetModuleHandleW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyDeleteKeyEx DD imagerel PyDeleteKeyEx
	DD	imagerel PyDeleteKeyEx+441
	DD	imagerel $unwind$PyDeleteKeyEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyDeleteKeyEx DD 021601H
	DD	0170116H
xdata	ENDS
;	COMDAT ??_C@_0CB@ODEKPPJP@not?5implemented?5on?5this?5platform@
CONST	SEGMENT
??_C@_0CB@ODEKPPJP@not?5implemented?5on?5this?5platform@ DB 'not implemen'
	DB	'ted on this platform', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LILAPHGE@RegDeleteKeyExW?$AA@
CONST	SEGMENT
??_C@_0BA@LILAPHGE@RegDeleteKeyExW?$AA@ DB 'RegDeleteKeyExW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@JHLNAEJL@?$AAa?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@JHLNAEJL@?$AAa?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 'd', 00H, 'v', 00H, 'a', 00H, 'p', 00H, 'i', 00H, '3', 00H
	DB	'2', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JKDJDEOB@Ou?$HMii?3DeleteKeyEx?$AA@
CONST	SEGMENT
??_C@_0BC@JKDJDEOB@Ou?$HMii?3DeleteKeyEx?$AA@ DB 'Ou|ii:DeleteKeyEx', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyDeleteKeyEx
_TEXT	SEGMENT
kwlist$ = 64
rc$ = 104
hKey$ = 112
sub_key$ = 120
hMod$ = 128
key$ = 136
access$ = 144
reserved$ = 148
pfn$ = 152
_save$121065 = 160
self$ = 192
args$ = 200
kwargs$ = 208
PyDeleteKeyEx PROC					; COMDAT

; 1080 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1081 :     HKEY hKey;
; 1082 :     PyObject *key;
; 1083 :     HMODULE hMod;
; 1084 :     typedef LONG (WINAPI *RDKEFunc)(HKEY, const wchar_t*, REGSAM, int);
; 1085 :     RDKEFunc pfn = NULL;

  00016	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pfn$[rsp], 0

; 1086 :     wchar_t *sub_key;
; 1087 :     long rc;
; 1088 :     int reserved = 0;

  00022	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR reserved$[rsp], 0

; 1089 :     REGSAM access = KEY_WOW64_64KEY;

  0002d	c7 84 24 90 00
	00 00 00 01 00
	00		 mov	 DWORD PTR access$[rsp], 256 ; 00000100H

; 1090 : 
; 1091 :     char *kwlist[] = {"key", "sub_key", "access", "reserved", NULL};

  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03ICHNJLJF@key?$AA@
  0003f	48 89 44 24 40	 mov	 QWORD PTR kwlist$[rsp], rax
  00044	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07KFOLAEFE@sub_key?$AA@
  0004b	48 89 44 24 48	 mov	 QWORD PTR kwlist$[rsp+8], rax
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06EBPNOMLE@access?$AA@
  00057	48 89 44 24 50	 mov	 QWORD PTR kwlist$[rsp+16], rax
  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08FINKBBAF@reserved?$AA@
  00063	48 89 44 24 58	 mov	 QWORD PTR kwlist$[rsp+24], rax
  00068	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR kwlist$[rsp+32], 0

; 1092 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Ou|ii:DeleteKeyEx", kwlist,
; 1093 :                                      &key, &sub_key, &access, &reserved))

  00071	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR reserved$[rsp]
  00079	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0007e	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR access$[rsp]
  00086	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0008b	48 8d 44 24 78	 lea	 rax, QWORD PTR sub_key$[rsp]
  00090	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00095	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR key$[rsp]
  0009d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a2	4c 8d 4c 24 40	 lea	 r9, QWORD PTR kwlist$[rsp]
  000a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BC@JKDJDEOB@Ou?$HMii?3DeleteKeyEx?$AA@
  000ae	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  000b6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000be	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000c3	85 c0		 test	 eax, eax
  000c5	75 07		 jne	 SHORT $LN5@PyDeleteKe@2

; 1094 :         return NULL;

  000c7	33 c0		 xor	 eax, eax
  000c9	e9 e3 00 00 00	 jmp	 $LN6@PyDeleteKe@2
$LN5@PyDeleteKe@2:

; 1095 :     if (!PyHKEY_AsHKEY(key, &hKey, FALSE))

  000ce	45 33 c0	 xor	 r8d, r8d
  000d1	48 8d 54 24 70	 lea	 rdx, QWORD PTR hKey$[rsp]
  000d6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  000de	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  000e3	85 c0		 test	 eax, eax
  000e5	75 07		 jne	 SHORT $LN4@PyDeleteKe@2

; 1096 :         return NULL;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 c3 00 00 00	 jmp	 $LN6@PyDeleteKe@2
$LN4@PyDeleteKe@2:

; 1097 : 
; 1098 :     /* Only available on 64bit platforms, so we must load it
; 1099 :        dynamically. */
; 1100 :     hMod = GetModuleHandleW(L"advapi32.dll");

  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@JHLNAEJL@?$AAa?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleW
  000fb	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR hMod$[rsp], rax

; 1101 :     if (hMod)

  00103	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR hMod$[rsp], 0
  0010c	74 1d		 je	 SHORT $LN3@PyDeleteKe@2

; 1102 :         pfn = (RDKEFunc)GetProcAddress(hMod,
; 1103 :                                                                    "RegDeleteKeyExW");

  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@LILAPHGE@RegDeleteKeyExW?$AA@
  00115	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hMod$[rsp]
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00123	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pfn$[rsp], rax
$LN3@PyDeleteKe@2:

; 1104 :     if (!pfn) {

  0012b	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR pfn$[rsp], 0
  00134	75 17		 jne	 SHORT $LN2@PyDeleteKe@2

; 1105 :         PyErr_SetString(PyExc_NotImplementedError,
; 1106 :                                         "not implemented on this platform");

  00136	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@ODEKPPJP@not?5implemented?5on?5this?5platform@
  0013d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00144	e8 00 00 00 00	 call	 PyErr_SetString

; 1107 :         return NULL;

  00149	33 c0		 xor	 eax, eax
  0014b	eb 64		 jmp	 SHORT $LN6@PyDeleteKe@2
$LN2@PyDeleteKe@2:

; 1108 :     }
; 1109 :     Py_BEGIN_ALLOW_THREADS

  0014d	e8 00 00 00 00	 call	 PyEval_SaveThread
  00152	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR _save$121065[rsp], rax

; 1110 :     rc = (*pfn)(hKey, sub_key, access, reserved);

  0015a	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR reserved$[rsp]
  00162	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR access$[rsp]
  0016a	48 8b 54 24 78	 mov	 rdx, QWORD PTR sub_key$[rsp]
  0016f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hKey$[rsp]
  00174	ff 94 24 98 00
	00 00		 call	 QWORD PTR pfn$[rsp]
  0017b	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1111 :     Py_END_ALLOW_THREADS

  0017f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _save$121065[rsp]
  00187	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1112 : 
; 1113 :     if (rc != ERROR_SUCCESS)

  0018c	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00191	74 0b		 je	 SHORT $LN1@PyDeleteKe@2

; 1114 :         return PyErr_SetFromWindowsErrWithFunction(rc, "RegDeleteKeyEx");

  00193	8b 4c 24 68	 mov	 ecx, DWORD PTR rc$[rsp]
  00197	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  0019c	eb 13		 jmp	 SHORT $LN6@PyDeleteKe@2
$LN1@PyDeleteKe@2:

; 1115 :     Py_INCREF(Py_None);

  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  001a5	e8 00 00 00 00	 call	 _Py_IncRef

; 1116 :     return Py_None;

  001aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN6@PyDeleteKe@2:

; 1117 : }

  001b1	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  001b8	c3		 ret	 0
PyDeleteKeyEx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@FNNHMMK@OZ?3DeleteValue?$AA@		; `string'
EXTRN	__imp_RegDeleteValueW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyDeleteValue DD imagerel PyDeleteValue
	DD	imagerel PyDeleteValue+157
	DD	imagerel $unwind$PyDeleteValue
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyDeleteValue DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0P@FNNHMMK@OZ?3DeleteValue?$AA@
CONST	SEGMENT
??_C@_0P@FNNHMMK@OZ?3DeleteValue?$AA@ DB 'OZ:DeleteValue', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyDeleteValue
_TEXT	SEGMENT
subKey$ = 32
rc$ = 40
hKey$ = 48
obKey$ = 56
_save$121083 = 64
self$ = 96
args$ = 104
PyDeleteValue PROC					; COMDAT

; 1121 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1122 :     HKEY hKey;
; 1123 :     PyObject *obKey;
; 1124 :     wchar_t *subKey;
; 1125 :     long rc;
; 1126 :     if (!PyArg_ParseTuple(args, "OZ:DeleteValue", &obKey, &subKey))

  0000e	4c 8d 4c 24 20	 lea	 r9, QWORD PTR subKey$[rsp]
  00013	4c 8d 44 24 38	 lea	 r8, QWORD PTR obKey$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FNNHMMK@OZ?3DeleteValue?$AA@
  0001f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN3@PyDeleteVa

; 1127 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 67		 jmp	 SHORT $LN4@PyDeleteVa
$LN3@PyDeleteVa:

; 1128 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8d 54 24 30	 lea	 rdx, QWORD PTR hKey$[rsp]
  00039	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obKey$[rsp]
  0003e	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  00043	85 c0		 test	 eax, eax
  00045	75 04		 jne	 SHORT $LN2@PyDeleteVa

; 1129 :         return NULL;

  00047	33 c0		 xor	 eax, eax
  00049	eb 4d		 jmp	 SHORT $LN4@PyDeleteVa
$LN2@PyDeleteVa:

; 1130 :     Py_BEGIN_ALLOW_THREADS

  0004b	e8 00 00 00 00	 call	 PyEval_SaveThread
  00050	48 89 44 24 40	 mov	 QWORD PTR _save$121083[rsp], rax

; 1131 :     rc = RegDeleteValueW(hKey, subKey);

  00055	48 8b 54 24 20	 mov	 rdx, QWORD PTR subKey$[rsp]
  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hKey$[rsp]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegDeleteValueW
  00065	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 1132 :     Py_END_ALLOW_THREADS

  00069	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _save$121083[rsp]
  0006e	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1133 :     if (rc !=ERROR_SUCCESS)

  00073	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00078	74 0b		 je	 SHORT $LN1@PyDeleteVa

; 1134 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1135 :                                                    "RegDeleteValue");

  0007a	8b 4c 24 28	 mov	 ecx, DWORD PTR rc$[rsp]
  0007e	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00083	eb 13		 jmp	 SHORT $LN4@PyDeleteVa
$LN1@PyDeleteVa:

; 1136 :     Py_INCREF(Py_None);

  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0008c	e8 00 00 00 00	 call	 _Py_IncRef

; 1137 :     return Py_None;

  00091	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@PyDeleteVa:

; 1138 : }

  00098	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009c	c3		 ret	 0
PyDeleteValue ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DLGIAGDL@Oi?3EnumKey?$AA@		; `string'
EXTRN	PyUnicode_FromWideChar:PROC
EXTRN	__imp_RegEnumKeyExW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEnumKey DD imagerel PyEnumKey
	DD	imagerel PyEnumKey+253
	DD	imagerel $unwind$PyEnumKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEnumKey DD 021101H
	DD	0530111H
xdata	ENDS
;	COMDAT ??_C@_0L@DLGIAGDL@Oi?3EnumKey?$AA@
CONST	SEGMENT
??_C@_0L@DLGIAGDL@Oi?3EnumKey?$AA@ DB 'Oi:EnumKey', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyEnumKey
_TEXT	SEGMENT
rc$ = 64
hKey$ = 72
obKey$ = 80
index$ = 88
tmpbuf$ = 96
len$ = 624
retStr$ = 632
_save$121105 = 640
self$ = 672
args$ = 680
PyEnumKey PROC						; COMDAT

; 1142 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 02
	00 00		 sub	 rsp, 664		; 00000298H

; 1143 :     HKEY hKey;
; 1144 :     PyObject *obKey;
; 1145 :     int index;
; 1146 :     long rc;
; 1147 :     PyObject *retStr;
; 1148 : 
; 1149 :     /* The Windows docs claim that the max key name length is 255
; 1150 :      * characters, plus a terminating nul character.  However,
; 1151 :      * empirical testing demonstrates that it is possible to
; 1152 :      * create a 256 character key that is missing the terminating
; 1153 :      * nul.  RegEnumKeyEx requires a 257 character buffer to
; 1154 :      * retrieve such a key name. */
; 1155 :     wchar_t tmpbuf[257];
; 1156 :     DWORD len = sizeof(tmpbuf)/sizeof(wchar_t); /* includes NULL terminator */

  00011	c7 84 24 70 02
	00 00 01 01 00
	00		 mov	 DWORD PTR len$[rsp], 257 ; 00000101H

; 1157 : 
; 1158 :     if (!PyArg_ParseTuple(args, "Oi:EnumKey", &obKey, &index))

  0001c	4c 8d 4c 24 58	 lea	 r9, QWORD PTR index$[rsp]
  00021	4c 8d 44 24 50	 lea	 r8, QWORD PTR obKey$[rsp]
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@DLGIAGDL@Oi?3EnumKey?$AA@
  0002d	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00035	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0003a	85 c0		 test	 eax, eax
  0003c	75 07		 jne	 SHORT $LN3@PyEnumKey

; 1159 :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	e9 b0 00 00 00	 jmp	 $LN4@PyEnumKey
$LN3@PyEnumKey:

; 1160 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00045	45 33 c0	 xor	 r8d, r8d
  00048	48 8d 54 24 48	 lea	 rdx, QWORD PTR hKey$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obKey$[rsp]
  00052	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  00057	85 c0		 test	 eax, eax
  00059	75 07		 jne	 SHORT $LN2@PyEnumKey

; 1161 :         return NULL;

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 93 00 00 00	 jmp	 $LN4@PyEnumKey
$LN2@PyEnumKey:

; 1162 : 
; 1163 :     Py_BEGIN_ALLOW_THREADS

  00062	e8 00 00 00 00	 call	 PyEval_SaveThread
  00067	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR _save$121105[rsp], rax

; 1164 :     rc = RegEnumKeyExW(hKey, index, tmpbuf, &len, NULL, NULL, NULL, NULL);

  0006f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00078	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00081	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0008a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00093	4c 8d 8c 24 70
	02 00 00	 lea	 r9, QWORD PTR len$[rsp]
  0009b	4c 8d 44 24 60	 lea	 r8, QWORD PTR tmpbuf$[rsp]
  000a0	8b 54 24 58	 mov	 edx, DWORD PTR index$[rsp]
  000a4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hKey$[rsp]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegEnumKeyExW
  000af	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 1165 :     Py_END_ALLOW_THREADS

  000b3	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR _save$121105[rsp]
  000bb	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1166 :     if (rc != ERROR_SUCCESS)

  000c0	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  000c5	74 0b		 je	 SHORT $LN1@PyEnumKey

; 1167 :         return PyErr_SetFromWindowsErrWithFunction(rc, "RegEnumKeyEx");

  000c7	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$[rsp]
  000cb	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000d0	eb 23		 jmp	 SHORT $LN4@PyEnumKey
$LN1@PyEnumKey:

; 1168 : 
; 1169 :     retStr = PyUnicode_FromWideChar(tmpbuf, len);

  000d2	8b 84 24 70 02
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000d9	8b d0		 mov	 edx, eax
  000db	48 8d 4c 24 60	 lea	 rcx, QWORD PTR tmpbuf$[rsp]
  000e0	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  000e5	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR retStr$[rsp], rax

; 1170 :     return retStr;  /* can be NULL */

  000ed	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR retStr$[rsp]
$LN4@PyEnumKey:

; 1171 : }

  000f5	48 81 c4 98 02
	00 00		 add	 rsp, 664		; 00000298H
  000fc	c3		 ret	 0
PyEnumKey ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_03ENKDGKFO@uOi?$AA@			; `string'
PUBLIC	??_C@_0N@LCGOFEBE@Oi?3EnumValue?$AA@		; `string'
EXTRN	Py_BuildValue:PROC
EXTRN	PyMem_Realloc:PROC
EXTRN	__imp_RegEnumValueW:PROC
EXTRN	PyMem_Free:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	__imp_RegQueryInfoKeyW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEnumValue DD imagerel PyEnumValue
	DD	imagerel PyEnumValue+784
	DD	imagerel $unwind$PyEnumValue
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEnumValue DD 021101H
	DD	01b0111H
xdata	ENDS
;	COMDAT ??_C@_03ENKDGKFO@uOi?$AA@
CONST	SEGMENT
??_C@_03ENKDGKFO@uOi?$AA@ DB 'uOi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCGOFEBE@Oi?3EnumValue?$AA@
CONST	SEGMENT
??_C@_0N@LCGOFEBE@Oi?3EnumValue?$AA@ DB 'Oi:EnumValue', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyEnumValue
_TEXT	SEGMENT
retValueBuf$ = 96
rc$ = 104
retVal$ = 112
retDataSize$ = 120
retDataBuf$ = 128
hKey$ = 136
obKey$ = 144
index$ = 152
tmpBuf$ = 160
obData$ = 168
typ$ = 176
bufValueSize$ = 180
bufDataSize$ = 184
retValueSize$ = 188
_save$121156 = 192
self$ = 224
args$ = 232
PyEnumValue PROC					; COMDAT

; 1175 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1176 :     HKEY hKey;
; 1177 :     PyObject *obKey;
; 1178 :     int index;
; 1179 :     long rc;
; 1180 :     wchar_t *retValueBuf;
; 1181 :     BYTE *tmpBuf;
; 1182 :     BYTE *retDataBuf;
; 1183 :     DWORD retValueSize, bufValueSize;
; 1184 :     DWORD retDataSize, bufDataSize;
; 1185 :     DWORD typ;
; 1186 :     PyObject *obData;
; 1187 :     PyObject *retVal;
; 1188 : 
; 1189 :     if (!PyArg_ParseTuple(args, "Oi:EnumValue", &obKey, &index))

  00011	4c 8d 8c 24 98
	00 00 00	 lea	 r9, QWORD PTR index$[rsp]
  00019	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR obKey$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LCGOFEBE@Oi?3EnumValue?$AA@
  00028	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00030	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN11@PyEnumValu

; 1190 :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 c8 02 00 00	 jmp	 $LN12@PyEnumValu
$LN11@PyEnumValu:

; 1191 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00040	45 33 c0	 xor	 r8d, r8d
  00043	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR hKey$[rsp]
  0004b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR obKey$[rsp]
  00053	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  00058	85 c0		 test	 eax, eax
  0005a	75 07		 jne	 SHORT $LN10@PyEnumValu

; 1192 :         return NULL;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 a5 02 00 00	 jmp	 $LN12@PyEnumValu
$LN10@PyEnumValu:

; 1193 : 
; 1194 :     if ((rc = RegQueryInfoKeyW(hKey, NULL, NULL, NULL, NULL, NULL, NULL,
; 1195 :                               NULL,
; 1196 :                               &retValueSize, &retDataSize, NULL, NULL))
; 1197 :         != ERROR_SUCCESS)

  00063	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  0006c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR [rsp+80], 0
  00075	48 8d 44 24 78	 lea	 rax, QWORD PTR retDataSize$[rsp]
  0007a	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0007f	48 8d 84 24 bc
	00 00 00	 lea	 rax, QWORD PTR retValueSize$[rsp]
  00087	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0008c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00095	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0009e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000a7	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000b0	45 33 c9	 xor	 r9d, r9d
  000b3	45 33 c0	 xor	 r8d, r8d
  000b6	33 d2		 xor	 edx, edx
  000b8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR hKey$[rsp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryInfoKeyW
  000c6	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
  000ca	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  000cf	74 0e		 je	 SHORT $LN9@PyEnumValu

; 1198 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1199 :                                                    "RegQueryInfoKey");

  000d1	8b 4c 24 68	 mov	 ecx, DWORD PTR rc$[rsp]
  000d5	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000da	e9 29 02 00 00	 jmp	 $LN12@PyEnumValu
$LN9@PyEnumValu:

; 1200 :     ++retValueSize;    /* include null terminators */

  000df	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR retValueSize$[rsp]
  000e6	ff c0		 inc	 eax
  000e8	89 84 24 bc 00
	00 00		 mov	 DWORD PTR retValueSize$[rsp], eax

; 1201 :     ++retDataSize;

  000ef	8b 44 24 78	 mov	 eax, DWORD PTR retDataSize$[rsp]
  000f3	ff c0		 inc	 eax
  000f5	89 44 24 78	 mov	 DWORD PTR retDataSize$[rsp], eax

; 1202 :     bufDataSize = retDataSize;

  000f9	8b 44 24 78	 mov	 eax, DWORD PTR retDataSize$[rsp]
  000fd	89 84 24 b8 00
	00 00		 mov	 DWORD PTR bufDataSize$[rsp], eax

; 1203 :     bufValueSize = retValueSize;

  00104	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR retValueSize$[rsp]
  0010b	89 84 24 b4 00
	00 00		 mov	 DWORD PTR bufValueSize$[rsp], eax

; 1204 :     retValueBuf = (wchar_t *)PyMem_Malloc(sizeof(wchar_t) * retValueSize);

  00112	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR retValueSize$[rsp]
  00119	48 d1 e0	 shl	 rax, 1
  0011c	48 8b c8	 mov	 rcx, rax
  0011f	e8 00 00 00 00	 call	 PyMem_Malloc
  00124	48 89 44 24 60	 mov	 QWORD PTR retValueBuf$[rsp], rax

; 1205 :     if (retValueBuf == NULL)

  00129	48 83 7c 24 60
	00		 cmp	 QWORD PTR retValueBuf$[rsp], 0
  0012f	75 0a		 jne	 SHORT $LN8@PyEnumValu

; 1206 :         return PyErr_NoMemory();

  00131	e8 00 00 00 00	 call	 PyErr_NoMemory
  00136	e9 cd 01 00 00	 jmp	 $LN12@PyEnumValu
$LN8@PyEnumValu:

; 1207 :     retDataBuf = (BYTE *)PyMem_Malloc(retDataSize);

  0013b	8b 44 24 78	 mov	 eax, DWORD PTR retDataSize$[rsp]
  0013f	8b c8		 mov	 ecx, eax
  00141	e8 00 00 00 00	 call	 PyMem_Malloc
  00146	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR retDataBuf$[rsp], rax

; 1208 :     if (retDataBuf == NULL) {

  0014e	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR retDataBuf$[rsp], 0
  00157	75 14		 jne	 SHORT $LN7@PyEnumValu

; 1209 :         PyMem_Free(retValueBuf);

  00159	48 8b 4c 24 60	 mov	 rcx, QWORD PTR retValueBuf$[rsp]
  0015e	e8 00 00 00 00	 call	 PyMem_Free

; 1210 :         return PyErr_NoMemory();

  00163	e8 00 00 00 00	 call	 PyErr_NoMemory
  00168	e9 9b 01 00 00	 jmp	 $LN12@PyEnumValu
$LN7@PyEnumValu:
$LN6@PyEnumValu:

; 1211 :     }
; 1212 : 
; 1213 :     while (1) {

  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 01	 cmp	 eax, 1
  00172	0f 84 f3 00 00
	00		 je	 $LN5@PyEnumValu

; 1214 :         Py_BEGIN_ALLOW_THREADS

  00178	e8 00 00 00 00	 call	 PyEval_SaveThread
  0017d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR _save$121156[rsp], rax

; 1215 :         rc = RegEnumValueW(hKey,
; 1216 :                   index,
; 1217 :                   retValueBuf,
; 1218 :                   &retValueSize,
; 1219 :                   NULL,
; 1220 :                   &typ,
; 1221 :                   (BYTE *)retDataBuf,
; 1222 :                   &retDataSize);

  00185	48 8d 44 24 78	 lea	 rax, QWORD PTR retDataSize$[rsp]
  0018a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0018f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  00197	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0019c	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR typ$[rsp]
  001a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001b2	4c 8d 8c 24 bc
	00 00 00	 lea	 r9, QWORD PTR retValueSize$[rsp]
  001ba	4c 8b 44 24 60	 mov	 r8, QWORD PTR retValueBuf$[rsp]
  001bf	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR index$[rsp]
  001c6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR hKey$[rsp]
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegEnumValueW
  001d4	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1223 :         Py_END_ALLOW_THREADS

  001d8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR _save$121156[rsp]
  001e0	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1224 : 
; 1225 :         if (rc != ERROR_MORE_DATA)

  001e5	81 7c 24 68 ea
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 234	; 000000eaH
  001ed	74 02		 je	 SHORT $LN4@PyEnumValu

; 1226 :             break;

  001ef	eb 7a		 jmp	 SHORT $LN5@PyEnumValu
$LN4@PyEnumValu:

; 1227 : 
; 1228 :         bufDataSize *= 2;

  001f1	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR bufDataSize$[rsp]
  001f8	d1 e0		 shl	 eax, 1
  001fa	89 84 24 b8 00
	00 00		 mov	 DWORD PTR bufDataSize$[rsp], eax

; 1229 :         tmpBuf = (BYTE *)PyMem_Realloc(retDataBuf, bufDataSize);

  00201	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR bufDataSize$[rsp]
  00208	8b d0		 mov	 edx, eax
  0020a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR retDataBuf$[rsp]
  00212	e8 00 00 00 00	 call	 PyMem_Realloc
  00217	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tmpBuf$[rsp], rax

; 1230 :         if (tmpBuf == NULL) {

  0021f	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR tmpBuf$[rsp], 0
  00228	75 13		 jne	 SHORT $LN3@PyEnumValu

; 1231 :             PyErr_NoMemory();

  0022a	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1232 :             retVal = NULL;

  0022f	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR retVal$[rsp], 0

; 1233 :             goto fail;

  00238	e9 af 00 00 00	 jmp	 $fail$121164
$LN3@PyEnumValu:

; 1234 :         }
; 1235 :         retDataBuf = tmpBuf;

  0023d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tmpBuf$[rsp]
  00245	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR retDataBuf$[rsp], rax

; 1236 :         retDataSize = bufDataSize;

  0024d	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR bufDataSize$[rsp]
  00254	89 44 24 78	 mov	 DWORD PTR retDataSize$[rsp], eax

; 1237 :         retValueSize = bufValueSize;

  00258	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR bufValueSize$[rsp]
  0025f	89 84 24 bc 00
	00 00		 mov	 DWORD PTR retValueSize$[rsp], eax

; 1238 :     }

  00266	e9 02 ff ff ff	 jmp	 $LN6@PyEnumValu
$LN5@PyEnumValu:

; 1239 : 
; 1240 :     if (rc != ERROR_SUCCESS) {

  0026b	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00270	74 10		 je	 SHORT $LN2@PyEnumValu

; 1241 :         retVal = PyErr_SetFromWindowsErrWithFunction(rc,
; 1242 :                                                      "PyRegEnumValue");

  00272	8b 4c 24 68	 mov	 ecx, DWORD PTR rc$[rsp]
  00276	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  0027b	48 89 44 24 70	 mov	 QWORD PTR retVal$[rsp], rax

; 1243 :         goto fail;

  00280	eb 6a		 jmp	 SHORT $fail$121164
$LN2@PyEnumValu:

; 1244 :     }
; 1245 :     obData = Reg2Py(retDataBuf, retDataSize, typ);

  00282	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR typ$[rsp]
  0028a	8b 54 24 78	 mov	 edx, DWORD PTR retDataSize$[rsp]
  0028e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR retDataBuf$[rsp]
  00296	e8 00 00 00 00	 call	 Reg2Py
  0029b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR obData$[rsp], rax

; 1246 :     if (obData == NULL) {

  002a3	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR obData$[rsp], 0
  002ac	75 0b		 jne	 SHORT $LN1@PyEnumValu

; 1247 :         retVal = NULL;

  002ae	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR retVal$[rsp], 0

; 1248 :         goto fail;

  002b7	eb 33		 jmp	 SHORT $fail$121164
$LN1@PyEnumValu:

; 1249 :     }
; 1250 :     retVal = Py_BuildValue("uOi", retValueBuf, obData, typ);

  002b9	44 8b 8c 24 b0
	00 00 00	 mov	 r9d, DWORD PTR typ$[rsp]
  002c1	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR obData$[rsp]
  002c9	48 8b 54 24 60	 mov	 rdx, QWORD PTR retValueBuf$[rsp]
  002ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03ENKDGKFO@uOi?$AA@
  002d5	e8 00 00 00 00	 call	 Py_BuildValue
  002da	48 89 44 24 70	 mov	 QWORD PTR retVal$[rsp], rax

; 1251 :     Py_DECREF(obData);

  002df	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR obData$[rsp]
  002e7	e8 00 00 00 00	 call	 _Py_DecRef
$fail$121164:

; 1252 :   fail:
; 1253 :     PyMem_Free(retValueBuf);

  002ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR retValueBuf$[rsp]
  002f1	e8 00 00 00 00	 call	 PyMem_Free

; 1254 :     PyMem_Free(retDataBuf);

  002f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR retDataBuf$[rsp]
  002fe	e8 00 00 00 00	 call	 PyMem_Free

; 1255 :     return retVal;

  00303	48 8b 44 24 70	 mov	 rax, QWORD PTR retVal$[rsp]
$LN12@PyEnumValu:

; 1256 : }

  00308	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0030f	c3		 ret	 0
PyEnumValue ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@BLJKMNPB@registry?5string?5is?5too?5long?5for?5@ ; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	__imp_free:PROC
EXTRN	PyList_SetItem:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	__imp_wcslen:PROC
EXTRN	__imp_malloc:PROC
EXTRN	PyList_New:PROC
EXTRN	PyLong_FromUnsignedLong:PROC
;	COMDAT pdata
; File c:\src\pyparallel\pc\winreg.c
pdata	SEGMENT
$pdata$Reg2Py DD imagerel Reg2Py
	DD	imagerel Reg2Py+680
	DD	imagerel $unwind$Reg2Py
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Reg2Py DD 011201H
	DD	0e212H
xdata	ENDS
;	COMDAT ??_C@_0DA@BLJKMNPB@registry?5string?5is?5too?5long?5for?5@
CONST	SEGMENT
??_C@_0DA@BLJKMNPB@registry?5string?5is?5too?5long?5for?5@ DB 'registry s'
	DB	'tring is too long for a Python string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Reg2Py
_TEXT	SEGMENT
obData$ = 32
len$120898 = 40
data$120896 = 48
s$120909 = 56
index$120905 = 60
len$120908 = 64
data$120906 = 72
str$120910 = 80
len$120921 = 88
tv64 = 96
retDataBuf$ = 128
retDataSize$ = 136
typ$ = 144
Reg2Py	PROC						; COMDAT

; 908  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 909  :     PyObject *obData;
; 910  : 
; 911  :     switch (typ) {

  00012	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR typ$[rsp]
  00019	89 44 24 60	 mov	 DWORD PTR tv64[rsp], eax
  0001d	83 7c 24 60 00	 cmp	 DWORD PTR tv64[rsp], 0
  00022	0f 86 37 02 00
	00		 jbe	 $LN3@Reg2Py
  00028	83 7c 24 60 02	 cmp	 DWORD PTR tv64[rsp], 2
  0002d	76 48		 jbe	 SHORT $LN15@Reg2Py
  0002f	83 7c 24 60 04	 cmp	 DWORD PTR tv64[rsp], 4
  00034	74 10		 je	 SHORT $LN18@Reg2Py
  00036	83 7c 24 60 07	 cmp	 DWORD PTR tv64[rsp], 7
  0003b	0f 84 c5 00 00
	00		 je	 $LN12@Reg2Py
  00041	e9 19 02 00 00	 jmp	 $LN3@Reg2Py
$LN18@Reg2Py:

; 912  :         case REG_DWORD:
; 913  :             if (retDataSize == 0)

  00046	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR retDataSize$[rsp], 0
  0004e	75 0e		 jne	 SHORT $LN17@Reg2Py

; 914  :                 obData = PyLong_FromUnsignedLong(0);

  00050	33 c9		 xor	 ecx, ecx
  00052	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  00057	48 89 44 24 20	 mov	 QWORD PTR obData$[rsp], rax

; 915  :             else

  0005c	eb 14		 jmp	 SHORT $LN16@Reg2Py
$LN17@Reg2Py:

; 916  :                 obData = PyLong_FromUnsignedLong(*(int *)retDataBuf);

  0005e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  00066	8b 08		 mov	 ecx, DWORD PTR [rax]
  00068	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  0006d	48 89 44 24 20	 mov	 QWORD PTR obData$[rsp], rax
$LN16@Reg2Py:

; 917  :             break;

  00072	e9 27 02 00 00	 jmp	 $LN19@Reg2Py
$LN15@Reg2Py:

; 918  :         case REG_SZ:
; 919  :         case REG_EXPAND_SZ:
; 920  :             {
; 921  :                 /* the buffer may or may not have a trailing NULL */
; 922  :                 wchar_t *data = (wchar_t *)retDataBuf;

  00077	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  0007f	48 89 44 24 30	 mov	 QWORD PTR data$120896[rsp], rax

; 923  :                 int len = retDataSize / 2;

  00084	33 d2		 xor	 edx, edx
  00086	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR retDataSize$[rsp]
  0008d	b9 02 00 00 00	 mov	 ecx, 2
  00092	f7 f1		 div	 ecx
  00094	89 44 24 28	 mov	 DWORD PTR len$120898[rsp], eax

; 924  :                 if (retDataSize && data[len-1] == '\0')

  00098	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR retDataSize$[rsp], 0
  000a0	74 26		 je	 SHORT $LN14@Reg2Py
  000a2	8b 44 24 28	 mov	 eax, DWORD PTR len$120898[rsp]
  000a6	ff c8		 dec	 eax
  000a8	48 98		 cdqe
  000aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$120896[rsp]
  000af	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  000b3	85 c0		 test	 eax, eax
  000b5	75 11		 jne	 SHORT $LN14@Reg2Py

; 925  :                     retDataSize -= 2;

  000b7	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR retDataSize$[rsp]
  000be	83 e8 02	 sub	 eax, 2
  000c1	89 84 24 88 00
	00 00		 mov	 DWORD PTR retDataSize$[rsp], eax
$LN14@Reg2Py:

; 926  :                 if (retDataSize <= 0)

  000c8	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR retDataSize$[rsp], 0
  000d0	77 0c		 ja	 SHORT $LN13@Reg2Py

; 927  :                     data = L"";

  000d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_11LOCGONAA@?$AA?$AA@
  000d9	48 89 44 24 30	 mov	 QWORD PTR data$120896[rsp], rax
$LN13@Reg2Py:

; 928  :                 obData = PyUnicode_FromWideChar(data, retDataSize/2);

  000de	33 d2		 xor	 edx, edx
  000e0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR retDataSize$[rsp]
  000e7	b9 02 00 00 00	 mov	 ecx, 2
  000ec	f7 f1		 div	 ecx
  000ee	8b c0		 mov	 eax, eax
  000f0	8b d0		 mov	 edx, eax
  000f2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$120896[rsp]
  000f7	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  000fc	48 89 44 24 20	 mov	 QWORD PTR obData$[rsp], rax

; 929  :                 break;

  00101	e9 98 01 00 00	 jmp	 $LN19@Reg2Py
$LN12@Reg2Py:

; 930  :             }
; 931  :         case REG_MULTI_SZ:
; 932  :             if (retDataSize == 0)

  00106	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR retDataSize$[rsp], 0
  0010e	75 11		 jne	 SHORT $LN11@Reg2Py

; 933  :                 obData = PyList_New(0);

  00110	33 c9		 xor	 ecx, ecx
  00112	e8 00 00 00 00	 call	 PyList_New
  00117	48 89 44 24 20	 mov	 QWORD PTR obData$[rsp], rax

; 934  :             else

  0011c	e9 3e 01 00 00	 jmp	 $LN10@Reg2Py
$LN11@Reg2Py:

; 935  :             {
; 936  :                 int index = 0;

  00121	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR index$120905[rsp], 0

; 937  :                 wchar_t *data = (wchar_t *)retDataBuf;

  00129	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  00131	48 89 44 24 48	 mov	 QWORD PTR data$120906[rsp], rax

; 938  :                 int len = retDataSize / 2;

  00136	33 d2		 xor	 edx, edx
  00138	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR retDataSize$[rsp]
  0013f	b9 02 00 00 00	 mov	 ecx, 2
  00144	f7 f1		 div	 ecx
  00146	89 44 24 40	 mov	 DWORD PTR len$120908[rsp], eax

; 939  :                 int s = countStrings(data, len);

  0014a	8b 54 24 40	 mov	 edx, DWORD PTR len$120908[rsp]
  0014e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR data$120906[rsp]
  00153	e8 00 00 00 00	 call	 countStrings
  00158	89 44 24 38	 mov	 DWORD PTR s$120909[rsp], eax

; 940  :                 wchar_t **str = (wchar_t **)malloc(sizeof(wchar_t *)*s);

  0015c	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$120909[rsp]
  00161	48 c1 e0 03	 shl	 rax, 3
  00165	48 8b c8	 mov	 rcx, rax
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0016e	48 89 44 24 50	 mov	 QWORD PTR str$120910[rsp], rax

; 941  :                 if (str == NULL)

  00173	48 83 7c 24 50
	00		 cmp	 QWORD PTR str$120910[rsp], 0
  00179	75 0a		 jne	 SHORT $LN9@Reg2Py

; 942  :                     return PyErr_NoMemory();

  0017b	e8 00 00 00 00	 call	 PyErr_NoMemory
  00180	e9 1e 01 00 00	 jmp	 $LN21@Reg2Py
$LN9@Reg2Py:

; 943  : 
; 944  :                 fixupMultiSZ(str, data, len);

  00185	44 8b 44 24 40	 mov	 r8d, DWORD PTR len$120908[rsp]
  0018a	48 8b 54 24 48	 mov	 rdx, QWORD PTR data$120906[rsp]
  0018f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$120910[rsp]
  00194	e8 00 00 00 00	 call	 fixupMultiSZ

; 945  :                 obData = PyList_New(s);

  00199	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$120909[rsp]
  0019e	48 8b c8	 mov	 rcx, rax
  001a1	e8 00 00 00 00	 call	 PyList_New
  001a6	48 89 44 24 20	 mov	 QWORD PTR obData$[rsp], rax

; 946  :                 if (obData == NULL)

  001ab	48 83 7c 24 20
	00		 cmp	 QWORD PTR obData$[rsp], 0
  001b1	75 07		 jne	 SHORT $LN8@Reg2Py

; 947  :                     return NULL;

  001b3	33 c0		 xor	 eax, eax
  001b5	e9 e9 00 00 00	 jmp	 $LN21@Reg2Py
$LN8@Reg2Py:

; 948  :                 for (index = 0; index < s; index++)

  001ba	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR index$120905[rsp], 0
  001c2	eb 0a		 jmp	 SHORT $LN7@Reg2Py
$LN6@Reg2Py:
  001c4	8b 44 24 3c	 mov	 eax, DWORD PTR index$120905[rsp]
  001c8	ff c0		 inc	 eax
  001ca	89 44 24 3c	 mov	 DWORD PTR index$120905[rsp], eax
$LN7@Reg2Py:
  001ce	8b 44 24 38	 mov	 eax, DWORD PTR s$120909[rsp]
  001d2	39 44 24 3c	 cmp	 DWORD PTR index$120905[rsp], eax
  001d6	7d 7a		 jge	 SHORT $LN5@Reg2Py

; 949  :                 {
; 950  :                     size_t len = wcslen(str[index]);

  001d8	48 63 44 24 3c	 movsxd	 rax, DWORD PTR index$120905[rsp]
  001dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$120910[rsp]
  001e2	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  001ec	48 89 44 24 58	 mov	 QWORD PTR len$120921[rsp], rax

; 951  :                     if (len > INT_MAX) {

  001f1	48 81 7c 24 58
	ff ff ff 7f	 cmp	 QWORD PTR len$120921[rsp], 2147483647 ; 7fffffffH
  001fa	76 24		 jbe	 SHORT $LN4@Reg2Py

; 952  :                         PyErr_SetString(PyExc_OverflowError,
; 953  :                             "registry string is too long for a Python string");

  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@BLJKMNPB@registry?5string?5is?5too?5long?5for?5@
  00203	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0020a	e8 00 00 00 00	 call	 PyErr_SetString

; 954  :                         Py_DECREF(obData);

  0020f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR obData$[rsp]
  00214	e8 00 00 00 00	 call	 _Py_DecRef

; 955  :                         return NULL;

  00219	33 c0		 xor	 eax, eax
  0021b	e9 83 00 00 00	 jmp	 $LN21@Reg2Py
$LN4@Reg2Py:

; 956  :                     }
; 957  :                     PyList_SetItem(obData,
; 958  :                                    index,
; 959  :                                    PyUnicode_FromWideChar(str[index], len));

  00220	48 63 44 24 3c	 movsxd	 rax, DWORD PTR index$120905[rsp]
  00225	48 8b 54 24 58	 mov	 rdx, QWORD PTR len$120921[rsp]
  0022a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$120910[rsp]
  0022f	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00233	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  00238	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR index$120905[rsp]
  0023d	4c 8b c0	 mov	 r8, rax
  00240	48 8b d1	 mov	 rdx, rcx
  00243	48 8b 4c 24 20	 mov	 rcx, QWORD PTR obData$[rsp]
  00248	e8 00 00 00 00	 call	 PyList_SetItem

; 960  :                 }

  0024d	e9 72 ff ff ff	 jmp	 $LN6@Reg2Py
$LN5@Reg2Py:

; 961  :                 free(str);

  00252	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$120910[rsp]
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 962  : 
; 963  :                 break;

  0025d	eb 3f		 jmp	 SHORT $LN19@Reg2Py
$LN10@Reg2Py:
$LN3@Reg2Py:

; 964  :             }
; 965  :         case REG_BINARY:
; 966  :         /* ALSO handle ALL unknown data types here.  Even if we can't
; 967  :            support it natively, we should handle the bits. */
; 968  :         default:
; 969  :             if (retDataSize == 0) {

  0025f	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR retDataSize$[rsp], 0
  00267	75 1a		 jne	 SHORT $LN2@Reg2Py

; 970  :                 Py_INCREF(Py_None);

  00269	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00270	e8 00 00 00 00	 call	 _Py_IncRef

; 971  :                 obData = Py_None;

  00275	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0027c	48 89 44 24 20	 mov	 QWORD PTR obData$[rsp], rax

; 972  :             }
; 973  :             else

  00281	eb 1b		 jmp	 SHORT $LN1@Reg2Py
$LN2@Reg2Py:

; 974  :                 obData = PyBytes_FromStringAndSize(
; 975  :                              (char *)retDataBuf, retDataSize);

  00283	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR retDataSize$[rsp]
  0028a	8b d0		 mov	 edx, eax
  0028c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR retDataBuf$[rsp]
  00294	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00299	48 89 44 24 20	 mov	 QWORD PTR obData$[rsp], rax
$LN1@Reg2Py:
$LN19@Reg2Py:

; 976  :             break;
; 977  :     }
; 978  :     return obData;

  0029e	48 8b 44 24 20	 mov	 rax, QWORD PTR obData$[rsp]
$LN21@Reg2Py:

; 979  : }

  002a3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002a7	c3		 ret	 0
Reg2Py	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fixupMultiSZ DD imagerel fixupMultiSZ
	DD	imagerel fixupMultiSZ+160
	DD	imagerel $unwind$fixupMultiSZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fixupMultiSZ DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fixupMultiSZ
_TEXT	SEGMENT
Q$ = 0
i$ = 8
P$ = 16
str$ = 48
data$ = 56
len$ = 64
fixupMultiSZ PROC					; COMDAT

; 740  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 741  :     wchar_t *P;
; 742  :     int i;
; 743  :     wchar_t *Q;
; 744  : 
; 745  :     Q = data + len;

  00013	48 63 44 24 40	 movsxd	 rax, DWORD PTR len$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  0001d	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00021	48 89 04 24	 mov	 QWORD PTR Q$[rsp], rax

; 746  :     for (P = data, i = 0; P < Q && *P != '\0'; P++, i++) {

  00025	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  0002a	48 89 44 24 10	 mov	 QWORD PTR P$[rsp], rax
  0002f	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00037	eb 18		 jmp	 SHORT $LN6@fixupMulti
$LN5@fixupMulti:
  00039	48 8b 44 24 10	 mov	 rax, QWORD PTR P$[rsp]
  0003e	48 83 c0 02	 add	 rax, 2
  00042	48 89 44 24 10	 mov	 QWORD PTR P$[rsp], rax
  00047	8b 44 24 08	 mov	 eax, DWORD PTR i$[rsp]
  0004b	ff c0		 inc	 eax
  0004d	89 44 24 08	 mov	 DWORD PTR i$[rsp], eax
$LN6@fixupMulti:
  00051	48 8b 04 24	 mov	 rax, QWORD PTR Q$[rsp]
  00055	48 39 44 24 10	 cmp	 QWORD PTR P$[rsp], rax
  0005a	73 3f		 jae	 SHORT $LN4@fixupMulti
  0005c	48 8b 44 24 10	 mov	 rax, QWORD PTR P$[rsp]
  00061	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00064	85 c0		 test	 eax, eax
  00066	74 33		 je	 SHORT $LN4@fixupMulti

; 747  :         str[i] = P;

  00068	48 63 44 24 08	 movsxd	 rax, DWORD PTR i$[rsp]
  0006d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR str$[rsp]
  00072	48 8b 54 24 10	 mov	 rdx, QWORD PTR P$[rsp]
  00077	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 748  :         for(; *P != '\0'; P++)

  0007b	eb 0e		 jmp	 SHORT $LN3@fixupMulti
$LN2@fixupMulti:
  0007d	48 8b 44 24 10	 mov	 rax, QWORD PTR P$[rsp]
  00082	48 83 c0 02	 add	 rax, 2
  00086	48 89 44 24 10	 mov	 QWORD PTR P$[rsp], rax
$LN3@fixupMulti:
  0008b	48 8b 44 24 10	 mov	 rax, QWORD PTR P$[rsp]
  00090	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00093	85 c0		 test	 eax, eax
  00095	74 02		 je	 SHORT $LN1@fixupMulti

; 749  :             ;

  00097	eb e4		 jmp	 SHORT $LN2@fixupMulti
$LN1@fixupMulti:

; 750  :     }

  00099	eb 9e		 jmp	 SHORT $LN5@fixupMulti
$LN4@fixupMulti:

; 751  : }

  0009b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009f	c3		 ret	 0
fixupMultiSZ ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$countStrings DD imagerel countStrings
	DD	imagerel countStrings+150
	DD	imagerel $unwind$countStrings
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$countStrings DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT countStrings
_TEXT	SEGMENT
Q$ = 0
P$ = 8
strings$ = 16
data$ = 48
len$ = 56
countStrings PROC					; COMDAT

; 755  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 756  :     int strings;
; 757  :     wchar_t *P;
; 758  :     wchar_t *Q = data + len;

  0000d	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00017	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  0001b	48 89 04 24	 mov	 QWORD PTR Q$[rsp], rax

; 759  : 
; 760  :     for (P = data, strings = 0; P < Q && *P != '\0'; P++, strings++)

  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR data$[rsp]
  00024	48 89 44 24 08	 mov	 QWORD PTR P$[rsp], rax
  00029	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR strings$[rsp], 0
  00031	eb 18		 jmp	 SHORT $LN6@countStrin
$LN5@countStrin:
  00033	48 8b 44 24 08	 mov	 rax, QWORD PTR P$[rsp]
  00038	48 83 c0 02	 add	 rax, 2
  0003c	48 89 44 24 08	 mov	 QWORD PTR P$[rsp], rax
  00041	8b 44 24 10	 mov	 eax, DWORD PTR strings$[rsp]
  00045	ff c0		 inc	 eax
  00047	89 44 24 10	 mov	 DWORD PTR strings$[rsp], eax
$LN6@countStrin:
  0004b	48 8b 04 24	 mov	 rax, QWORD PTR Q$[rsp]
  0004f	48 39 44 24 08	 cmp	 QWORD PTR P$[rsp], rax
  00054	73 37		 jae	 SHORT $LN4@countStrin
  00056	48 8b 44 24 08	 mov	 rax, QWORD PTR P$[rsp]
  0005b	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0005e	85 c0		 test	 eax, eax
  00060	74 2b		 je	 SHORT $LN4@countStrin

; 761  :         for (; P < Q && *P != '\0'; P++)

  00062	eb 0e		 jmp	 SHORT $LN3@countStrin
$LN2@countStrin:
  00064	48 8b 44 24 08	 mov	 rax, QWORD PTR P$[rsp]
  00069	48 83 c0 02	 add	 rax, 2
  0006d	48 89 44 24 08	 mov	 QWORD PTR P$[rsp], rax
$LN3@countStrin:
  00072	48 8b 04 24	 mov	 rax, QWORD PTR Q$[rsp]
  00076	48 39 44 24 08	 cmp	 QWORD PTR P$[rsp], rax
  0007b	73 0e		 jae	 SHORT $LN1@countStrin
  0007d	48 8b 44 24 08	 mov	 rax, QWORD PTR P$[rsp]
  00082	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00085	85 c0		 test	 eax, eax
  00087	74 02		 je	 SHORT $LN1@countStrin

; 762  :             ;

  00089	eb d9		 jmp	 SHORT $LN2@countStrin
$LN1@countStrin:
  0008b	eb a6		 jmp	 SHORT $LN5@countStrin
$LN4@countStrin:

; 763  :     return strings;

  0008d	8b 44 24 10	 mov	 eax, DWORD PTR strings$[rsp]

; 764  : }

  00091	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00095	c3		 ret	 0
countStrings ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@IBDMMBKN@u?3ExpandEnvironmentStrings?$AA@ ; `string'
EXTRN	__imp_ExpandEnvironmentStringsW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyExpandEnvironmentStrings DD imagerel PyExpandEnvironmentStrings
	DD	imagerel PyExpandEnvironmentStrings+237
	DD	imagerel $unwind$PyExpandEnvironmentStrings
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyExpandEnvironmentStrings DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BL@IBDMMBKN@u?3ExpandEnvironmentStrings?$AA@
CONST	SEGMENT
??_C@_0BL@IBDMMBKN@u?3ExpandEnvironmentStrings?$AA@ DB 'u:ExpandEnvironme'
	DB	'ntStrings', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyExpandEnvironmentStrings
_TEXT	SEGMENT
rc$ = 32
retValueSize$ = 36
src$ = 40
o$ = 48
retValue$ = 56
self$ = 80
args$ = 88
PyExpandEnvironmentStrings PROC				; COMDAT

; 1260 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1261 :     wchar_t *retValue = NULL;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR retValue$[rsp], 0

; 1262 :     wchar_t *src;
; 1263 :     DWORD retValueSize;
; 1264 :     DWORD rc;
; 1265 :     PyObject *o;
; 1266 : 
; 1267 :     if (!PyArg_ParseTuple(args, "u:ExpandEnvironmentStrings", &src))

  00017	4c 8d 44 24 28	 lea	 r8, QWORD PTR src$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@IBDMMBKN@u?3ExpandEnvironmentStrings?$AA@
  00023	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN4@PyExpandEn

; 1268 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 b0 00 00 00	 jmp	 $LN5@PyExpandEn
$LN4@PyExpandEn:

; 1269 : 
; 1270 :     retValueSize = ExpandEnvironmentStringsW(src, retValue, 0);

  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 8b 54 24 38	 mov	 rdx, QWORD PTR retValue$[rsp]
  00040	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExpandEnvironmentStringsW
  0004b	89 44 24 24	 mov	 DWORD PTR retValueSize$[rsp], eax

; 1271 :     if (retValueSize == 0) {

  0004f	83 7c 24 24 00	 cmp	 DWORD PTR retValueSize$[rsp], 0
  00054	75 0e		 jne	 SHORT $LN3@PyExpandEn

; 1272 :         return PyErr_SetFromWindowsErrWithFunction(retValueSize,
; 1273 :                                         "ExpandEnvironmentStrings");

  00056	8b 4c 24 24	 mov	 ecx, DWORD PTR retValueSize$[rsp]
  0005a	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  0005f	e9 84 00 00 00	 jmp	 $LN5@PyExpandEn
$LN3@PyExpandEn:

; 1274 :     }
; 1275 :     retValue = (wchar_t *)PyMem_Malloc(retValueSize * sizeof(wchar_t));

  00064	8b 44 24 24	 mov	 eax, DWORD PTR retValueSize$[rsp]
  00068	48 d1 e0	 shl	 rax, 1
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 PyMem_Malloc
  00073	48 89 44 24 38	 mov	 QWORD PTR retValue$[rsp], rax

; 1276 :     if (retValue == NULL) {

  00078	48 83 7c 24 38
	00		 cmp	 QWORD PTR retValue$[rsp], 0
  0007e	75 07		 jne	 SHORT $LN2@PyExpandEn

; 1277 :         return PyErr_NoMemory();

  00080	e8 00 00 00 00	 call	 PyErr_NoMemory
  00085	eb 61		 jmp	 SHORT $LN5@PyExpandEn
$LN2@PyExpandEn:

; 1278 :     }
; 1279 : 
; 1280 :     rc = ExpandEnvironmentStringsW(src, retValue, retValueSize);

  00087	44 8b 44 24 24	 mov	 r8d, DWORD PTR retValueSize$[rsp]
  0008c	48 8b 54 24 38	 mov	 rdx, QWORD PTR retValue$[rsp]
  00091	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExpandEnvironmentStringsW
  0009c	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1281 :     if (rc == 0) {

  000a0	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000a5	75 15		 jne	 SHORT $LN1@PyExpandEn

; 1282 :         PyMem_Free(retValue);

  000a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR retValue$[rsp]
  000ac	e8 00 00 00 00	 call	 PyMem_Free

; 1283 :         return PyErr_SetFromWindowsErrWithFunction(retValueSize,
; 1284 :                                         "ExpandEnvironmentStrings");

  000b1	8b 4c 24 24	 mov	 ecx, DWORD PTR retValueSize$[rsp]
  000b5	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000ba	eb 2c		 jmp	 SHORT $LN5@PyExpandEn
$LN1@PyExpandEn:

; 1285 :     }
; 1286 :     o = PyUnicode_FromWideChar(retValue, wcslen(retValue));

  000bc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR retValue$[rsp]
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  000c7	48 8b d0	 mov	 rdx, rax
  000ca	48 8b 4c 24 38	 mov	 rcx, QWORD PTR retValue$[rsp]
  000cf	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  000d4	48 89 44 24 30	 mov	 QWORD PTR o$[rsp], rax

; 1287 :     PyMem_Free(retValue);

  000d9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR retValue$[rsp]
  000de	e8 00 00 00 00	 call	 PyMem_Free

; 1288 :     return o;

  000e3	48 8b 44 24 30	 mov	 rax, QWORD PTR o$[rsp]
$LN5@PyExpandEn:

; 1289 : }

  000e8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ec	c3		 ret	 0
PyExpandEnvironmentStrings ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@OCIFNGJF@O?3FlushKey?$AA@		; `string'
EXTRN	__imp_RegFlushKey:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFlushKey DD imagerel PyFlushKey
	DD	imagerel PyFlushKey+147
	DD	imagerel $unwind$PyFlushKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFlushKey DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0L@OCIFNGJF@O?3FlushKey?$AA@
CONST	SEGMENT
??_C@_0L@OCIFNGJF@O?3FlushKey?$AA@ DB 'O:FlushKey', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyFlushKey
_TEXT	SEGMENT
rc$ = 32
hKey$ = 40
obKey$ = 48
_save$121206 = 56
self$ = 80
args$ = 88
PyFlushKey PROC						; COMDAT

; 1293 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1294 :     HKEY hKey;
; 1295 :     PyObject *obKey;
; 1296 :     long rc;
; 1297 :     if (!PyArg_ParseTuple(args, "O:FlushKey", &obKey))

  0000e	4c 8d 44 24 30	 lea	 r8, QWORD PTR obKey$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@OCIFNGJF@O?3FlushKey?$AA@
  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN3@PyFlushKey

; 1298 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 62		 jmp	 SHORT $LN4@PyFlushKey
$LN3@PyFlushKey:

; 1299 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8d 54 24 28	 lea	 rdx, QWORD PTR hKey$[rsp]
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR obKey$[rsp]
  00039	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  0003e	85 c0		 test	 eax, eax
  00040	75 04		 jne	 SHORT $LN2@PyFlushKey

; 1300 :         return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	eb 48		 jmp	 SHORT $LN4@PyFlushKey
$LN2@PyFlushKey:

; 1301 :     Py_BEGIN_ALLOW_THREADS

  00046	e8 00 00 00 00	 call	 PyEval_SaveThread
  0004b	48 89 44 24 38	 mov	 QWORD PTR _save$121206[rsp], rax

; 1302 :     rc = RegFlushKey(hKey);

  00050	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hKey$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegFlushKey
  0005b	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1303 :     Py_END_ALLOW_THREADS

  0005f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _save$121206[rsp]
  00064	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1304 :     if (rc != ERROR_SUCCESS)

  00069	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0006e	74 0b		 je	 SHORT $LN1@PyFlushKey

; 1305 :         return PyErr_SetFromWindowsErrWithFunction(rc, "RegFlushKey");

  00070	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  00074	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00079	eb 13		 jmp	 SHORT $LN4@PyFlushKey
$LN1@PyFlushKey:

; 1306 :     Py_INCREF(Py_None);

  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00082	e8 00 00 00 00	 call	 _Py_IncRef

; 1307 :     return Py_None;

  00087	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@PyFlushKey:

; 1308 : }

  0008e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00092	c3		 ret	 0
PyFlushKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@LCPFBJKE@Ouu?3LoadKey?$AA@		; `string'
EXTRN	__imp_RegLoadKeyW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLoadKey DD imagerel PyLoadKey
	DD	imagerel PyLoadKey+172
	DD	imagerel $unwind$PyLoadKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLoadKey DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0M@LCPFBJKE@Ouu?3LoadKey?$AA@
CONST	SEGMENT
??_C@_0M@LCPFBJKE@Ouu?3LoadKey?$AA@ DB 'Ouu:LoadKey', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyLoadKey
_TEXT	SEGMENT
subKey$ = 48
rc$ = 56
hKey$ = 64
obKey$ = 72
fileName$ = 80
_save$121225 = 88
self$ = 112
args$ = 120
PyLoadKey PROC						; COMDAT

; 1311 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1312 :     HKEY hKey;
; 1313 :     PyObject *obKey;
; 1314 :     wchar_t *subKey;
; 1315 :     wchar_t *fileName;
; 1316 : 
; 1317 :     long rc;
; 1318 :     if (!PyArg_ParseTuple(args, "Ouu:LoadKey", &obKey, &subKey, &fileName))

  0000e	48 8d 44 24 50	 lea	 rax, QWORD PTR fileName$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00018	4c 8d 4c 24 30	 lea	 r9, QWORD PTR subKey$[rsp]
  0001d	4c 8d 44 24 48	 lea	 r8, QWORD PTR obKey$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@LCPFBJKE@Ouu?3LoadKey?$AA@
  00029	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  0002e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00033	85 c0		 test	 eax, eax
  00035	75 04		 jne	 SHORT $LN3@PyLoadKey

; 1319 :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	eb 6c		 jmp	 SHORT $LN4@PyLoadKey
$LN3@PyLoadKey:

; 1320 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  0003b	45 33 c0	 xor	 r8d, r8d
  0003e	48 8d 54 24 40	 lea	 rdx, QWORD PTR hKey$[rsp]
  00043	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obKey$[rsp]
  00048	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  0004d	85 c0		 test	 eax, eax
  0004f	75 04		 jne	 SHORT $LN2@PyLoadKey

; 1321 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	eb 52		 jmp	 SHORT $LN4@PyLoadKey
$LN2@PyLoadKey:

; 1322 :     Py_BEGIN_ALLOW_THREADS

  00055	e8 00 00 00 00	 call	 PyEval_SaveThread
  0005a	48 89 44 24 58	 mov	 QWORD PTR _save$121225[rsp], rax

; 1323 :     rc = RegLoadKeyW(hKey, subKey, fileName );

  0005f	4c 8b 44 24 50	 mov	 r8, QWORD PTR fileName$[rsp]
  00064	48 8b 54 24 30	 mov	 rdx, QWORD PTR subKey$[rsp]
  00069	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hKey$[rsp]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegLoadKeyW
  00074	89 44 24 38	 mov	 DWORD PTR rc$[rsp], eax

; 1324 :     Py_END_ALLOW_THREADS

  00078	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _save$121225[rsp]
  0007d	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1325 :     if (rc != ERROR_SUCCESS)

  00082	83 7c 24 38 00	 cmp	 DWORD PTR rc$[rsp], 0
  00087	74 0b		 je	 SHORT $LN1@PyLoadKey

; 1326 :         return PyErr_SetFromWindowsErrWithFunction(rc, "RegLoadKey");

  00089	8b 4c 24 38	 mov	 ecx, DWORD PTR rc$[rsp]
  0008d	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00092	eb 13		 jmp	 SHORT $LN4@PyLoadKey
$LN1@PyLoadKey:

; 1327 :     Py_INCREF(Py_None);

  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0009b	e8 00 00 00 00	 call	 _Py_IncRef

; 1328 :     return Py_None;

  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@PyLoadKey:

; 1329 : }

  000a7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ab	c3		 ret	 0
PyLoadKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@IJCNGLB@OZ?$HMii?3OpenKey?$AA@		; `string'
EXTRN	__imp_RegOpenKeyExW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOpenKey DD imagerel PyOpenKey
	DD	imagerel PyOpenKey+337
	DD	imagerel $unwind$PyOpenKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOpenKey DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_0O@IJCNGLB@OZ?$HMii?3OpenKey?$AA@
CONST	SEGMENT
??_C@_0O@IJCNGLB@OZ?$HMii?3OpenKey?$AA@ DB 'OZ|ii:OpenKey', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyOpenKey
_TEXT	SEGMENT
kwlist$ = 64
rc$ = 104
retKey$ = 112
hKey$ = 120
sub_key$ = 128
key$ = 136
access$ = 144
reserved$ = 148
_save$121250 = 152
self$ = 176
args$ = 184
kwargs$ = 192
PyOpenKey PROC						; COMDAT

; 1333 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1334 :     HKEY hKey;
; 1335 :     PyObject *key;
; 1336 :     wchar_t *sub_key;
; 1337 :     int reserved = 0;

  00016	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR reserved$[rsp], 0

; 1338 :     HKEY retKey;
; 1339 :     long rc;
; 1340 :     REGSAM access = KEY_READ;

  00021	c7 84 24 90 00
	00 00 19 00 02
	00		 mov	 DWORD PTR access$[rsp], 131097 ; 00020019H

; 1341 : 
; 1342 :     char *kwlist[] = {"key", "sub_key", "reserved", "access", NULL};

  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03ICHNJLJF@key?$AA@
  00033	48 89 44 24 40	 mov	 QWORD PTR kwlist$[rsp], rax
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07KFOLAEFE@sub_key?$AA@
  0003f	48 89 44 24 48	 mov	 QWORD PTR kwlist$[rsp+8], rax
  00044	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08FINKBBAF@reserved?$AA@
  0004b	48 89 44 24 50	 mov	 QWORD PTR kwlist$[rsp+16], rax
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06EBPNOMLE@access?$AA@
  00057	48 89 44 24 58	 mov	 QWORD PTR kwlist$[rsp+24], rax
  0005c	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR kwlist$[rsp+32], 0

; 1343 : 
; 1344 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OZ|ii:OpenKey", kwlist,
; 1345 :                                      &key, &sub_key, &reserved, &access))

  00065	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR access$[rsp]
  0006d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00072	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR reserved$[rsp]
  0007a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0007f	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR sub_key$[rsp]
  00087	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008c	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR key$[rsp]
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8d 4c 24 40	 lea	 r9, QWORD PTR kwlist$[rsp]
  0009e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@IJCNGLB@OZ?$HMii?3OpenKey?$AA@
  000a5	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  000ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000b5	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000ba	85 c0		 test	 eax, eax
  000bc	75 07		 jne	 SHORT $LN3@PyOpenKey

; 1346 :         return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	e9 84 00 00 00	 jmp	 $LN4@PyOpenKey
$LN3@PyOpenKey:

; 1347 :     if (!PyHKEY_AsHKEY(key, &hKey, FALSE))

  000c5	45 33 c0	 xor	 r8d, r8d
  000c8	48 8d 54 24 78	 lea	 rdx, QWORD PTR hKey$[rsp]
  000cd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  000d5	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  000da	85 c0		 test	 eax, eax
  000dc	75 04		 jne	 SHORT $LN2@PyOpenKey

; 1348 :         return NULL;

  000de	33 c0		 xor	 eax, eax
  000e0	eb 67		 jmp	 SHORT $LN4@PyOpenKey
$LN2@PyOpenKey:

; 1349 : 
; 1350 :     Py_BEGIN_ALLOW_THREADS

  000e2	e8 00 00 00 00	 call	 PyEval_SaveThread
  000e7	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR _save$121250[rsp], rax

; 1351 :     rc = RegOpenKeyExW(hKey, sub_key, reserved, access, &retKey);

  000ef	48 8d 44 24 70	 lea	 rax, QWORD PTR retKey$[rsp]
  000f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f9	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR access$[rsp]
  00101	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR reserved$[rsp]
  00109	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR sub_key$[rsp]
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hKey$[rsp]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExW
  0011c	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1352 :     Py_END_ALLOW_THREADS

  00120	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR _save$121250[rsp]
  00128	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1353 :     if (rc != ERROR_SUCCESS)

  0012d	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00132	74 0b		 je	 SHORT $LN1@PyOpenKey

; 1354 :         return PyErr_SetFromWindowsErrWithFunction(rc, "RegOpenKeyEx");

  00134	8b 4c 24 68	 mov	 ecx, DWORD PTR rc$[rsp]
  00138	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  0013d	eb 0a		 jmp	 SHORT $LN4@PyOpenKey
$LN1@PyOpenKey:

; 1355 :     return PyHKEY_FromHKEY(retKey);

  0013f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR retKey$[rsp]
  00144	e8 00 00 00 00	 call	 PyHKEY_FromHKEY
$LN4@PyOpenKey:

; 1356 : }

  00149	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00150	c3		 ret	 0
PyOpenKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_03KIHCDLAP@iiO?$AA@			; `string'
PUBLIC	??_C@_0P@PMBECOHL@O?3QueryInfoKey?$AA@		; `string'
EXTRN	PyLong_FromLongLong:PROC
EXTRN	__imp_RegQueryInfoKeyA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyQueryInfoKey DD imagerel PyQueryInfoKey
	DD	imagerel PyQueryInfoKey+334
	DD	imagerel $unwind$PyQueryInfoKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyQueryInfoKey DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_03KIHCDLAP@iiO?$AA@
CONST	SEGMENT
??_C@_03KIHCDLAP@iiO?$AA@ DB 'iiO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PMBECOHL@O?3QueryInfoKey?$AA@
CONST	SEGMENT
??_C@_0P@PMBECOHL@O?3QueryInfoKey?$AA@ DB 'O:QueryInfoKey', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyQueryInfoKey
_TEXT	SEGMENT
ft$ = 96
rc$ = 104
hKey$ = 112
obKey$ = 120
ret$ = 128
nValues$ = 136
l$ = 144
li$ = 152
nSubKeys$ = 160
self$ = 192
args$ = 200
PyQueryInfoKey PROC					; COMDAT

; 1361 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1362 :   HKEY hKey;
; 1363 :   PyObject *obKey;
; 1364 :   long rc;
; 1365 :   DWORD nSubKeys, nValues;
; 1366 :   FILETIME ft;
; 1367 :   LARGE_INTEGER li;
; 1368 :   PyObject *l;
; 1369 :   PyObject *ret;
; 1370 :   if (!PyArg_ParseTuple(args, "O:QueryInfoKey", &obKey))

  00011	4c 8d 44 24 78	 lea	 r8, QWORD PTR obKey$[rsp]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@PMBECOHL@O?3QueryInfoKey?$AA@
  0001d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00025	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN4@PyQueryInf

; 1371 :     return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 11 01 00 00	 jmp	 $LN5@PyQueryInf
$LN4@PyQueryInf:

; 1372 :   if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00035	45 33 c0	 xor	 r8d, r8d
  00038	48 8d 54 24 70	 lea	 rdx, QWORD PTR hKey$[rsp]
  0003d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obKey$[rsp]
  00042	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  00047	85 c0		 test	 eax, eax
  00049	75 07		 jne	 SHORT $LN3@PyQueryInf

; 1373 :     return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	e9 f4 00 00 00	 jmp	 $LN5@PyQueryInf
$LN3@PyQueryInf:

; 1374 :   if ((rc = RegQueryInfoKey(hKey, NULL, NULL, 0, &nSubKeys, NULL, NULL,
; 1375 :                             &nValues,  NULL,  NULL, NULL, &ft))
; 1376 :       != ERROR_SUCCESS)

  00052	48 8d 44 24 60	 lea	 rax, QWORD PTR ft$[rsp]
  00057	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0005c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR [rsp+80], 0
  00065	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  0006e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00077	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR nValues$[rsp]
  0007f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00084	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0008d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00096	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR nSubKeys$[rsp]
  0009e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a3	45 33 c9	 xor	 r9d, r9d
  000a6	45 33 c0	 xor	 r8d, r8d
  000a9	33 d2		 xor	 edx, edx
  000ab	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hKey$[rsp]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryInfoKeyA
  000b6	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
  000ba	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bf	74 0b		 je	 SHORT $LN2@PyQueryInf

; 1377 :     return PyErr_SetFromWindowsErrWithFunction(rc, "RegQueryInfoKey");

  000c1	8b 4c 24 68	 mov	 ecx, DWORD PTR rc$[rsp]
  000c5	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000ca	eb 7a		 jmp	 SHORT $LN5@PyQueryInf
$LN2@PyQueryInf:

; 1378 :   li.LowPart = ft.dwLowDateTime;

  000cc	8b 44 24 60	 mov	 eax, DWORD PTR ft$[rsp]
  000d0	89 84 24 98 00
	00 00		 mov	 DWORD PTR li$[rsp], eax

; 1379 :   li.HighPart = ft.dwHighDateTime;

  000d7	8b 44 24 64	 mov	 eax, DWORD PTR ft$[rsp+4]
  000db	89 84 24 9c 00
	00 00		 mov	 DWORD PTR li$[rsp+4], eax

; 1380 :   l = PyLong_FromLongLong(li.QuadPart);

  000e2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR li$[rsp]
  000ea	e8 00 00 00 00	 call	 PyLong_FromLongLong
  000ef	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR l$[rsp], rax

; 1381 :   if (l == NULL)

  000f7	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR l$[rsp], 0
  00100	75 04		 jne	 SHORT $LN1@PyQueryInf

; 1382 :     return NULL;

  00102	33 c0		 xor	 eax, eax
  00104	eb 40		 jmp	 SHORT $LN5@PyQueryInf
$LN1@PyQueryInf:

; 1383 :   ret = Py_BuildValue("iiO", nSubKeys, nValues, l);

  00106	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR l$[rsp]
  0010e	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR nValues$[rsp]
  00116	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR nSubKeys$[rsp]
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03KIHCDLAP@iiO?$AA@
  00124	e8 00 00 00 00	 call	 Py_BuildValue
  00129	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ret$[rsp], rax

; 1384 :   Py_DECREF(l);

  00131	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR l$[rsp]
  00139	e8 00 00 00 00	 call	 _Py_DecRef

; 1385 :   return ret;

  0013e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ret$[rsp]
$LN5@PyQueryInf:

; 1386 : }

  00146	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0014d	c3		 ret	 0
PyQueryInfoKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@JJEGAJDO@OZ?3QueryValue?$AA@		; `string'
EXTRN	__imp_RegQueryValueW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyQueryValue DD imagerel PyQueryValue
	DD	imagerel PyQueryValue+413
	DD	imagerel $unwind$PyQueryValue
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyQueryValue DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0O@JJEGAJDO@OZ?3QueryValue?$AA@
CONST	SEGMENT
??_C@_0O@JJEGAJDO@OZ?3QueryValue?$AA@ DB 'OZ:QueryValue', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyQueryValue
_TEXT	SEGMENT
subKey$ = 32
rc$ = 40
retBuf$ = 48
hKey$ = 56
obKey$ = 64
tmp$ = 72
retSize$ = 80
retStr$ = 88
bufSize$ = 96
self$ = 128
args$ = 136
PyQueryValue PROC					; COMDAT

; 1390 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1391 :     HKEY hKey;
; 1392 :     PyObject *obKey;
; 1393 :     wchar_t *subKey;
; 1394 :     long rc;
; 1395 :     PyObject *retStr;
; 1396 :     wchar_t *retBuf;
; 1397 :     DWORD bufSize = 0;

  0000e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR bufSize$[rsp], 0

; 1398 :     DWORD retSize = 0;

  00016	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR retSize$[rsp], 0

; 1399 :     wchar_t *tmp;
; 1400 : 
; 1401 :     if (!PyArg_ParseTuple(args, "OZ:QueryValue", &obKey, &subKey))

  0001e	4c 8d 4c 24 20	 lea	 r9, QWORD PTR subKey$[rsp]
  00023	4c 8d 44 24 40	 lea	 r8, QWORD PTR obKey$[rsp]
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@JJEGAJDO@OZ?3QueryValue?$AA@
  0002f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00037	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0003c	85 c0		 test	 eax, eax
  0003e	75 07		 jne	 SHORT $LN11@PyQueryVal

; 1402 :         return NULL;

  00040	33 c0		 xor	 eax, eax
  00042	e9 51 01 00 00	 jmp	 $LN12@PyQueryVal
$LN11@PyQueryVal:

; 1403 : 
; 1404 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00047	45 33 c0	 xor	 r8d, r8d
  0004a	48 8d 54 24 38	 lea	 rdx, QWORD PTR hKey$[rsp]
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obKey$[rsp]
  00054	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  00059	85 c0		 test	 eax, eax
  0005b	75 07		 jne	 SHORT $LN10@PyQueryVal

; 1405 :         return NULL;

  0005d	33 c0		 xor	 eax, eax
  0005f	e9 34 01 00 00	 jmp	 $LN12@PyQueryVal
$LN10@PyQueryVal:

; 1406 : 
; 1407 :     rc = RegQueryValueW(hKey, subKey, NULL, &retSize);

  00064	4c 8d 4c 24 50	 lea	 r9, QWORD PTR retSize$[rsp]
  00069	45 33 c0	 xor	 r8d, r8d
  0006c	48 8b 54 24 20	 mov	 rdx, QWORD PTR subKey$[rsp]
  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hKey$[rsp]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueW
  0007c	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 1408 :     if (rc == ERROR_MORE_DATA)

  00080	81 7c 24 28 ea
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 234	; 000000eaH
  00088	75 0a		 jne	 SHORT $LN9@PyQueryVal

; 1409 :         retSize = 256;

  0008a	c7 44 24 50 00
	01 00 00	 mov	 DWORD PTR retSize$[rsp], 256 ; 00000100H
  00092	eb 15		 jmp	 SHORT $LN8@PyQueryVal
$LN9@PyQueryVal:

; 1410 :     else if (rc != ERROR_SUCCESS)

  00094	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00099	74 0e		 je	 SHORT $LN7@PyQueryVal

; 1411 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1412 :                                                    "RegQueryValue");

  0009b	8b 4c 24 28	 mov	 ecx, DWORD PTR rc$[rsp]
  0009f	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000a4	e9 ef 00 00 00	 jmp	 $LN12@PyQueryVal
$LN7@PyQueryVal:
$LN8@PyQueryVal:

; 1413 : 
; 1414 :     bufSize = retSize;

  000a9	8b 44 24 50	 mov	 eax, DWORD PTR retSize$[rsp]
  000ad	89 44 24 60	 mov	 DWORD PTR bufSize$[rsp], eax

; 1415 :     retBuf = (wchar_t *) PyMem_Malloc(bufSize);

  000b1	8b 44 24 60	 mov	 eax, DWORD PTR bufSize$[rsp]
  000b5	8b c8		 mov	 ecx, eax
  000b7	e8 00 00 00 00	 call	 PyMem_Malloc
  000bc	48 89 44 24 30	 mov	 QWORD PTR retBuf$[rsp], rax

; 1416 :     if (retBuf == NULL)

  000c1	48 83 7c 24 30
	00		 cmp	 QWORD PTR retBuf$[rsp], 0
  000c7	75 0a		 jne	 SHORT $LN6@PyQueryVal

; 1417 :         return PyErr_NoMemory();

  000c9	e8 00 00 00 00	 call	 PyErr_NoMemory
  000ce	e9 c5 00 00 00	 jmp	 $LN12@PyQueryVal
$LN6@PyQueryVal:
$LN5@PyQueryVal:

; 1418 : 
; 1419 :     while (1) {

  000d3	33 c0		 xor	 eax, eax
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	74 76		 je	 SHORT $LN4@PyQueryVal

; 1420 :         retSize = bufSize;

  000da	8b 44 24 60	 mov	 eax, DWORD PTR bufSize$[rsp]
  000de	89 44 24 50	 mov	 DWORD PTR retSize$[rsp], eax

; 1421 :         rc = RegQueryValueW(hKey, subKey, retBuf, &retSize);

  000e2	4c 8d 4c 24 50	 lea	 r9, QWORD PTR retSize$[rsp]
  000e7	4c 8b 44 24 30	 mov	 r8, QWORD PTR retBuf$[rsp]
  000ec	48 8b 54 24 20	 mov	 rdx, QWORD PTR subKey$[rsp]
  000f1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hKey$[rsp]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueW
  000fc	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 1422 :         if (rc != ERROR_MORE_DATA)

  00100	81 7c 24 28 ea
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 234	; 000000eaH
  00108	74 02		 je	 SHORT $LN3@PyQueryVal

; 1423 :             break;

  0010a	eb 44		 jmp	 SHORT $LN4@PyQueryVal
$LN3@PyQueryVal:

; 1424 : 
; 1425 :         bufSize *= 2;

  0010c	8b 44 24 60	 mov	 eax, DWORD PTR bufSize$[rsp]
  00110	d1 e0		 shl	 eax, 1
  00112	89 44 24 60	 mov	 DWORD PTR bufSize$[rsp], eax

; 1426 :         tmp = (wchar_t *) PyMem_Realloc(retBuf, bufSize);

  00116	8b 44 24 60	 mov	 eax, DWORD PTR bufSize$[rsp]
  0011a	8b d0		 mov	 edx, eax
  0011c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR retBuf$[rsp]
  00121	e8 00 00 00 00	 call	 PyMem_Realloc
  00126	48 89 44 24 48	 mov	 QWORD PTR tmp$[rsp], rax

; 1427 :         if (tmp == NULL) {

  0012b	48 83 7c 24 48
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00131	75 11		 jne	 SHORT $LN2@PyQueryVal

; 1428 :             PyMem_Free(retBuf);

  00133	48 8b 4c 24 30	 mov	 rcx, QWORD PTR retBuf$[rsp]
  00138	e8 00 00 00 00	 call	 PyMem_Free

; 1429 :             return PyErr_NoMemory();

  0013d	e8 00 00 00 00	 call	 PyErr_NoMemory
  00142	eb 54		 jmp	 SHORT $LN12@PyQueryVal
$LN2@PyQueryVal:

; 1430 :         }
; 1431 :         retBuf = tmp;

  00144	48 8b 44 24 48	 mov	 rax, QWORD PTR tmp$[rsp]
  00149	48 89 44 24 30	 mov	 QWORD PTR retBuf$[rsp], rax

; 1432 :     }

  0014e	eb 83		 jmp	 SHORT $LN5@PyQueryVal
$LN4@PyQueryVal:

; 1433 : 
; 1434 :     if (rc != ERROR_SUCCESS) {

  00150	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00155	74 15		 je	 SHORT $LN1@PyQueryVal

; 1435 :         PyMem_Free(retBuf);

  00157	48 8b 4c 24 30	 mov	 rcx, QWORD PTR retBuf$[rsp]
  0015c	e8 00 00 00 00	 call	 PyMem_Free

; 1436 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1437 :                                                    "RegQueryValue");

  00161	8b 4c 24 28	 mov	 ecx, DWORD PTR rc$[rsp]
  00165	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  0016a	eb 2c		 jmp	 SHORT $LN12@PyQueryVal
$LN1@PyQueryVal:

; 1438 :     }
; 1439 : 
; 1440 :     retStr = PyUnicode_FromWideChar(retBuf, wcslen(retBuf));

  0016c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR retBuf$[rsp]
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00177	48 8b d0	 mov	 rdx, rax
  0017a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR retBuf$[rsp]
  0017f	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  00184	48 89 44 24 58	 mov	 QWORD PTR retStr$[rsp], rax

; 1441 :     PyMem_Free(retBuf);

  00189	48 8b 4c 24 30	 mov	 rcx, QWORD PTR retBuf$[rsp]
  0018e	e8 00 00 00 00	 call	 PyMem_Free

; 1442 :     return retStr;

  00193	48 8b 44 24 58	 mov	 rax, QWORD PTR retStr$[rsp]
$LN12@PyQueryVal:

; 1443 : }

  00198	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0019c	c3		 ret	 0
PyQueryValue ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MPEHDMPO@Oi?$AA@			; `string'
PUBLIC	??_C@_0BA@KJKOIGEK@OZ?3QueryValueEx?$AA@	; `string'
EXTRN	__imp_RegQueryValueExW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyQueryValueEx DD imagerel PyQueryValueEx
	DD	imagerel PyQueryValueEx+492
	DD	imagerel $unwind$PyQueryValueEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyQueryValueEx DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_02MPEHDMPO@Oi?$AA@
CONST	SEGMENT
??_C@_02MPEHDMPO@Oi?$AA@ DB 'Oi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KJKOIGEK@OZ?3QueryValueEx?$AA@
CONST	SEGMENT
??_C@_0BA@KJKOIGEK@OZ?3QueryValueEx?$AA@ DB 'OZ:QueryValueEx', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyQueryValueEx
_TEXT	SEGMENT
rc$ = 48
retBuf$ = 56
valueName$ = 64
hKey$ = 72
obKey$ = 80
tmp$ = 88
retSize$ = 96
obData$ = 104
typ$ = 112
bufSize$ = 116
result$ = 120
self$ = 144
args$ = 152
PyQueryValueEx PROC					; COMDAT

; 1447 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1448 :     HKEY hKey;
; 1449 :     PyObject *obKey;
; 1450 :     wchar_t *valueName;
; 1451 : 
; 1452 :     long rc;
; 1453 :     BYTE *retBuf, *tmp;
; 1454 :     DWORD bufSize = 0, retSize;

  00011	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR bufSize$[rsp], 0

; 1455 :     DWORD typ;
; 1456 :     PyObject *obData;
; 1457 :     PyObject *result;
; 1458 : 
; 1459 :     if (!PyArg_ParseTuple(args, "OZ:QueryValueEx", &obKey, &valueName))

  00019	4c 8d 4c 24 40	 lea	 r9, QWORD PTR valueName$[rsp]
  0001e	4c 8d 44 24 50	 lea	 r8, QWORD PTR obKey$[rsp]
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@KJKOIGEK@OZ?3QueryValueEx?$AA@
  0002a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00032	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00037	85 c0		 test	 eax, eax
  00039	75 07		 jne	 SHORT $LN12@PyQueryVal@2

; 1460 :         return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	e9 a2 01 00 00	 jmp	 $LN13@PyQueryVal@2
$LN12@PyQueryVal@2:

; 1461 : 
; 1462 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00042	45 33 c0	 xor	 r8d, r8d
  00045	48 8d 54 24 48	 lea	 rdx, QWORD PTR hKey$[rsp]
  0004a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obKey$[rsp]
  0004f	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  00054	85 c0		 test	 eax, eax
  00056	75 07		 jne	 SHORT $LN11@PyQueryVal@2

; 1463 :         return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 85 01 00 00	 jmp	 $LN13@PyQueryVal@2
$LN11@PyQueryVal@2:

; 1464 : 
; 1465 :     rc = RegQueryValueExW(hKey, valueName, NULL, NULL, NULL, &bufSize);

  0005f	48 8d 44 24 74	 lea	 rax, QWORD PTR bufSize$[rsp]
  00064	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00069	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00072	45 33 c9	 xor	 r9d, r9d
  00075	45 33 c0	 xor	 r8d, r8d
  00078	48 8b 54 24 40	 mov	 rdx, QWORD PTR valueName$[rsp]
  0007d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hKey$[rsp]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExW
  00088	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 1466 :     if (rc == ERROR_MORE_DATA)

  0008c	81 7c 24 30 ea
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 234	; 000000eaH
  00094	75 0a		 jne	 SHORT $LN10@PyQueryVal@2

; 1467 :         bufSize = 256;

  00096	c7 44 24 74 00
	01 00 00	 mov	 DWORD PTR bufSize$[rsp], 256 ; 00000100H
  0009e	eb 15		 jmp	 SHORT $LN9@PyQueryVal@2
$LN10@PyQueryVal@2:

; 1468 :     else if (rc != ERROR_SUCCESS)

  000a0	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  000a5	74 0e		 je	 SHORT $LN8@PyQueryVal@2

; 1469 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1470 :                                                    "RegQueryValueEx");

  000a7	8b 4c 24 30	 mov	 ecx, DWORD PTR rc$[rsp]
  000ab	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000b0	e9 2f 01 00 00	 jmp	 $LN13@PyQueryVal@2
$LN8@PyQueryVal@2:
$LN9@PyQueryVal@2:

; 1471 :     retBuf = (BYTE *)PyMem_Malloc(bufSize);

  000b5	8b 44 24 74	 mov	 eax, DWORD PTR bufSize$[rsp]
  000b9	8b c8		 mov	 ecx, eax
  000bb	e8 00 00 00 00	 call	 PyMem_Malloc
  000c0	48 89 44 24 38	 mov	 QWORD PTR retBuf$[rsp], rax

; 1472 :     if (retBuf == NULL)

  000c5	48 83 7c 24 38
	00		 cmp	 QWORD PTR retBuf$[rsp], 0
  000cb	75 0a		 jne	 SHORT $LN7@PyQueryVal@2

; 1473 :         return PyErr_NoMemory();

  000cd	e8 00 00 00 00	 call	 PyErr_NoMemory
  000d2	e9 0d 01 00 00	 jmp	 $LN13@PyQueryVal@2
$LN7@PyQueryVal@2:
$LN6@PyQueryVal@2:

; 1474 : 
; 1475 :     while (1) {

  000d7	33 c0		 xor	 eax, eax
  000d9	83 f8 01	 cmp	 eax, 1
  000dc	0f 84 8e 00 00
	00		 je	 $LN5@PyQueryVal@2

; 1476 :         retSize = bufSize;

  000e2	8b 44 24 74	 mov	 eax, DWORD PTR bufSize$[rsp]
  000e6	89 44 24 60	 mov	 DWORD PTR retSize$[rsp], eax

; 1477 :         rc = RegQueryValueExW(hKey, valueName, NULL, &typ,
; 1478 :                              (BYTE *)retBuf, &retSize);

  000ea	48 8d 44 24 60	 lea	 rax, QWORD PTR retSize$[rsp]
  000ef	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f4	48 8b 44 24 38	 mov	 rax, QWORD PTR retBuf$[rsp]
  000f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fe	4c 8d 4c 24 70	 lea	 r9, QWORD PTR typ$[rsp]
  00103	45 33 c0	 xor	 r8d, r8d
  00106	48 8b 54 24 40	 mov	 rdx, QWORD PTR valueName$[rsp]
  0010b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hKey$[rsp]
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExW
  00116	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 1479 :         if (rc != ERROR_MORE_DATA)

  0011a	81 7c 24 30 ea
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 234	; 000000eaH
  00122	74 02		 je	 SHORT $LN4@PyQueryVal@2

; 1480 :             break;

  00124	eb 4a		 jmp	 SHORT $LN5@PyQueryVal@2
$LN4@PyQueryVal@2:

; 1481 : 
; 1482 :         bufSize *= 2;

  00126	8b 44 24 74	 mov	 eax, DWORD PTR bufSize$[rsp]
  0012a	d1 e0		 shl	 eax, 1
  0012c	89 44 24 74	 mov	 DWORD PTR bufSize$[rsp], eax

; 1483 :         tmp = (char *) PyMem_Realloc(retBuf, bufSize);

  00130	8b 44 24 74	 mov	 eax, DWORD PTR bufSize$[rsp]
  00134	8b d0		 mov	 edx, eax
  00136	48 8b 4c 24 38	 mov	 rcx, QWORD PTR retBuf$[rsp]
  0013b	e8 00 00 00 00	 call	 PyMem_Realloc
  00140	48 89 44 24 58	 mov	 QWORD PTR tmp$[rsp], rax

; 1484 :         if (tmp == NULL) {

  00145	48 83 7c 24 58
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0014b	75 14		 jne	 SHORT $LN3@PyQueryVal@2

; 1485 :             PyMem_Free(retBuf);

  0014d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR retBuf$[rsp]
  00152	e8 00 00 00 00	 call	 PyMem_Free

; 1486 :             return PyErr_NoMemory();

  00157	e8 00 00 00 00	 call	 PyErr_NoMemory
  0015c	e9 83 00 00 00	 jmp	 $LN13@PyQueryVal@2
$LN3@PyQueryVal@2:

; 1487 :         }
; 1488 :        retBuf = tmp;

  00161	48 8b 44 24 58	 mov	 rax, QWORD PTR tmp$[rsp]
  00166	48 89 44 24 38	 mov	 QWORD PTR retBuf$[rsp], rax

; 1489 :     }

  0016b	e9 67 ff ff ff	 jmp	 $LN6@PyQueryVal@2
$LN5@PyQueryVal@2:

; 1490 : 
; 1491 :     if (rc != ERROR_SUCCESS) {

  00170	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  00175	74 15		 je	 SHORT $LN2@PyQueryVal@2

; 1492 :         PyMem_Free(retBuf);

  00177	48 8b 4c 24 38	 mov	 rcx, QWORD PTR retBuf$[rsp]
  0017c	e8 00 00 00 00	 call	 PyMem_Free

; 1493 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1494 :                                                    "RegQueryValueEx");

  00181	8b 4c 24 30	 mov	 ecx, DWORD PTR rc$[rsp]
  00185	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  0018a	eb 58		 jmp	 SHORT $LN13@PyQueryVal@2
$LN2@PyQueryVal@2:

; 1495 :     }
; 1496 :     obData = Reg2Py(retBuf, bufSize, typ);

  0018c	44 8b 44 24 70	 mov	 r8d, DWORD PTR typ$[rsp]
  00191	8b 54 24 74	 mov	 edx, DWORD PTR bufSize$[rsp]
  00195	48 8b 4c 24 38	 mov	 rcx, QWORD PTR retBuf$[rsp]
  0019a	e8 00 00 00 00	 call	 Reg2Py
  0019f	48 89 44 24 68	 mov	 QWORD PTR obData$[rsp], rax

; 1497 :     PyMem_Free(retBuf);

  001a4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR retBuf$[rsp]
  001a9	e8 00 00 00 00	 call	 PyMem_Free

; 1498 :     if (obData == NULL)

  001ae	48 83 7c 24 68
	00		 cmp	 QWORD PTR obData$[rsp], 0
  001b4	75 04		 jne	 SHORT $LN1@PyQueryVal@2

; 1499 :         return NULL;

  001b6	33 c0		 xor	 eax, eax
  001b8	eb 2a		 jmp	 SHORT $LN13@PyQueryVal@2
$LN1@PyQueryVal@2:

; 1500 :     result = Py_BuildValue("Oi", obData, typ);

  001ba	44 8b 44 24 70	 mov	 r8d, DWORD PTR typ$[rsp]
  001bf	48 8b 54 24 68	 mov	 rdx, QWORD PTR obData$[rsp]
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02MPEHDMPO@Oi?$AA@
  001cb	e8 00 00 00 00	 call	 Py_BuildValue
  001d0	48 89 44 24 78	 mov	 QWORD PTR result$[rsp], rax

; 1501 :     Py_DECREF(obData);

  001d5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR obData$[rsp]
  001da	e8 00 00 00 00	 call	 _Py_DecRef

; 1502 :     return result;

  001df	48 8b 44 24 78	 mov	 rax, QWORD PTR result$[rsp]
$LN13@PyQueryVal@2:

; 1503 : }

  001e4	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001eb	c3		 ret	 0
PyQueryValueEx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@PMICBGHH@Ou?3SaveKey?$AA@		; `string'
EXTRN	__imp_RegSaveKeyW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySaveKey DD imagerel PySaveKey
	DD	imagerel PySaveKey+171
	DD	imagerel $unwind$PySaveKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySaveKey DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0L@PMICBGHH@Ou?3SaveKey?$AA@
CONST	SEGMENT
??_C@_0L@PMICBGHH@Ou?3SaveKey?$AA@ DB 'Ou:SaveKey', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySaveKey
_TEXT	SEGMENT
rc$ = 32
hKey$ = 40
obKey$ = 48
pSA$ = 56
fileName$ = 64
_save$121383 = 72
self$ = 96
args$ = 104
PySaveKey PROC						; COMDAT

; 1508 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1509 :     HKEY hKey;
; 1510 :     PyObject *obKey;
; 1511 :     wchar_t *fileName;
; 1512 :     LPSECURITY_ATTRIBUTES pSA = NULL;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pSA$[rsp], 0

; 1513 : 
; 1514 :     long rc;
; 1515 :     if (!PyArg_ParseTuple(args, "Ou:SaveKey", &obKey, &fileName))

  00017	4c 8d 4c 24 40	 lea	 r9, QWORD PTR fileName$[rsp]
  0001c	4c 8d 44 24 30	 lea	 r8, QWORD PTR obKey$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@PMICBGHH@Ou?3SaveKey?$AA@
  00028	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0002d	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00032	85 c0		 test	 eax, eax
  00034	75 04		 jne	 SHORT $LN3@PySaveKey

; 1516 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 6c		 jmp	 SHORT $LN4@PySaveKey
$LN3@PySaveKey:

; 1517 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  0003a	45 33 c0	 xor	 r8d, r8d
  0003d	48 8d 54 24 28	 lea	 rdx, QWORD PTR hKey$[rsp]
  00042	48 8b 4c 24 30	 mov	 rcx, QWORD PTR obKey$[rsp]
  00047	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  0004c	85 c0		 test	 eax, eax
  0004e	75 04		 jne	 SHORT $LN2@PySaveKey

; 1518 :         return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	eb 52		 jmp	 SHORT $LN4@PySaveKey
$LN2@PySaveKey:

; 1519 : /*  One day we may get security into the core?
; 1520 :     if (!PyWinObject_AsSECURITY_ATTRIBUTES(obSA, &pSA, TRUE))
; 1521 :         return NULL;
; 1522 : */
; 1523 :     Py_BEGIN_ALLOW_THREADS

  00054	e8 00 00 00 00	 call	 PyEval_SaveThread
  00059	48 89 44 24 48	 mov	 QWORD PTR _save$121383[rsp], rax

; 1524 :     rc = RegSaveKeyW(hKey, fileName, pSA );

  0005e	4c 8b 44 24 38	 mov	 r8, QWORD PTR pSA$[rsp]
  00063	48 8b 54 24 40	 mov	 rdx, QWORD PTR fileName$[rsp]
  00068	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hKey$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegSaveKeyW
  00073	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1525 :     Py_END_ALLOW_THREADS

  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _save$121383[rsp]
  0007c	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1526 :     if (rc != ERROR_SUCCESS)

  00081	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00086	74 0b		 je	 SHORT $LN1@PySaveKey

; 1527 :         return PyErr_SetFromWindowsErrWithFunction(rc, "RegSaveKey");

  00088	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  0008c	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00091	eb 13		 jmp	 SHORT $LN4@PySaveKey
$LN1@PySaveKey:

; 1528 :     Py_INCREF(Py_None);

  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0009a	e8 00 00 00 00	 call	 _Py_IncRef

; 1529 :     return Py_None;

  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@PySaveKey:

; 1530 : }

  000a6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000aa	c3		 ret	 0
PySaveKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@KBMNOFOJ@Type?5must?5be?5winreg?4REG_SZ?$AA@ ; `string'
PUBLIC	??_C@_0P@JIHFGHCK@OZiu?$CD?3SetValue?$AA@	; `string'
EXTRN	__imp_RegSetValueW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySetValue DD imagerel PySetValue
	DD	imagerel PySetValue+253
	DD	imagerel $unwind$PySetValue
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySetValue DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0BL@KBMNOFOJ@Type?5must?5be?5winreg?4REG_SZ?$AA@
CONST	SEGMENT
??_C@_0BL@KBMNOFOJ@Type?5must?5be?5winreg?4REG_SZ?$AA@ DB 'Type must be w'
	DB	'inreg.REG_SZ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JIHFGHCK@OZiu?$CD?3SetValue?$AA@
CONST	SEGMENT
??_C@_0P@JIHFGHCK@OZiu?$CD?3SetValue?$AA@ DB 'OZiu#:SetValue', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySetValue
_TEXT	SEGMENT
subKey$ = 64
rc$ = 72
hKey$ = 80
obKey$ = 88
len$ = 96
typ$ = 100
str$ = 104
_save$121407 = 112
self$ = 144
args$ = 152
PySetValue PROC						; COMDAT

; 1534 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1535 :     HKEY hKey;
; 1536 :     PyObject *obKey;
; 1537 :     wchar_t *subKey;
; 1538 :     wchar_t *str;
; 1539 :     DWORD typ;
; 1540 :     DWORD len;
; 1541 :     long rc;
; 1542 :     if (!PyArg_ParseTuple(args, "OZiu#:SetValue",
; 1543 :                           &obKey,
; 1544 :                           &subKey,
; 1545 :                           &typ,
; 1546 :                           &str,
; 1547 :                           &len))

  00011	48 8d 44 24 60	 lea	 rax, QWORD PTR len$[rsp]
  00016	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0001b	48 8d 44 24 68	 lea	 rax, QWORD PTR str$[rsp]
  00020	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00025	48 8d 44 24 64	 lea	 rax, QWORD PTR typ$[rsp]
  0002a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002f	4c 8d 4c 24 40	 lea	 r9, QWORD PTR subKey$[rsp]
  00034	4c 8d 44 24 58	 lea	 r8, QWORD PTR obKey$[rsp]
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@JIHFGHCK@OZiu?$CD?3SetValue?$AA@
  00040	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00048	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0004d	85 c0		 test	 eax, eax
  0004f	75 07		 jne	 SHORT $LN4@PySetValue

; 1548 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	e9 9d 00 00 00	 jmp	 $LN5@PySetValue
$LN4@PySetValue:

; 1549 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00058	45 33 c0	 xor	 r8d, r8d
  0005b	48 8d 54 24 50	 lea	 rdx, QWORD PTR hKey$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR obKey$[rsp]
  00065	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  0006a	85 c0		 test	 eax, eax
  0006c	75 07		 jne	 SHORT $LN3@PySetValue

; 1550 :         return NULL;

  0006e	33 c0		 xor	 eax, eax
  00070	e9 80 00 00 00	 jmp	 $LN5@PySetValue
$LN3@PySetValue:

; 1551 :     if (typ != REG_SZ) {

  00075	83 7c 24 64 01	 cmp	 DWORD PTR typ$[rsp], 1
  0007a	74 17		 je	 SHORT $LN2@PySetValue

; 1552 :         PyErr_SetString(PyExc_TypeError,
; 1553 :                         "Type must be winreg.REG_SZ");

  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@KBMNOFOJ@Type?5must?5be?5winreg?4REG_SZ?$AA@
  00083	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0008a	e8 00 00 00 00	 call	 PyErr_SetString

; 1554 :         return NULL;

  0008f	33 c0		 xor	 eax, eax
  00091	eb 62		 jmp	 SHORT $LN5@PySetValue
$LN2@PySetValue:

; 1555 :     }
; 1556 : 
; 1557 :     Py_BEGIN_ALLOW_THREADS

  00093	e8 00 00 00 00	 call	 PyEval_SaveThread
  00098	48 89 44 24 70	 mov	 QWORD PTR _save$121407[rsp], rax

; 1558 :     rc = RegSetValueW(hKey, subKey, REG_SZ, str, len+1);

  0009d	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  000a1	ff c0		 inc	 eax
  000a3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000a7	4c 8b 4c 24 68	 mov	 r9, QWORD PTR str$[rsp]
  000ac	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b2	48 8b 54 24 40	 mov	 rdx, QWORD PTR subKey$[rsp]
  000b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hKey$[rsp]
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegSetValueW
  000c2	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 1559 :     Py_END_ALLOW_THREADS

  000c6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _save$121407[rsp]
  000cb	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1560 :     if (rc != ERROR_SUCCESS)

  000d0	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  000d5	74 0b		 je	 SHORT $LN1@PySetValue

; 1561 :         return PyErr_SetFromWindowsErrWithFunction(rc, "RegSetValue");

  000d7	8b 4c 24 48	 mov	 ecx, DWORD PTR rc$[rsp]
  000db	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000e0	eb 13		 jmp	 SHORT $LN5@PySetValue
$LN1@PySetValue:

; 1562 :     Py_INCREF(Py_None);

  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000e9	e8 00 00 00 00	 call	 _Py_IncRef

; 1563 :     return Py_None;

  000ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN5@PySetValue:

; 1564 : }

  000f5	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000fc	c3		 ret	 0
PySetValue ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@HEEHIAF@Could?5not?5convert?5the?5data?5to?5th@ ; `string'
PUBLIC	??_C@_0BB@FPDLDIPL@OZOiO?3SetValueEx?$AA@	; `string'
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	__imp_RegSetValueExW:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySetValueEx DD imagerel PySetValueEx
	DD	imagerel PySetValueEx+351
	DD	imagerel $unwind$PySetValueEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySetValueEx DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0DC@HEEHIAF@Could?5not?5convert?5the?5data?5to?5th@
CONST	SEGMENT
??_C@_0DC@HEEHIAF@Could?5not?5convert?5the?5data?5to?5th@ DB 'Could not c'
	DB	'onvert the data to the specified type.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FPDLDIPL@OZOiO?3SetValueEx?$AA@
CONST	SEGMENT
??_C@_0BB@FPDLDIPL@OZOiO?3SetValueEx?$AA@ DB 'OZOiO:SetValueEx', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySetValueEx
_TEXT	SEGMENT
obRes$ = 64
rc$ = 72
value$ = 80
valueName$ = 88
hKey$ = 96
obKey$ = 104
len$ = 112
typ$ = 116
data$ = 120
_save$121434 = 128
tv133 = 136
self$ = 160
args$ = 168
PySetValueEx PROC					; COMDAT

; 1568 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1569 :     HKEY hKey;
; 1570 :     PyObject *obKey;
; 1571 :     wchar_t *valueName;
; 1572 :     PyObject *obRes;
; 1573 :     PyObject *value;
; 1574 :     BYTE *data;
; 1575 :     DWORD len;
; 1576 :     DWORD typ;
; 1577 : 
; 1578 :     LONG rc;
; 1579 : 
; 1580 :     if (!PyArg_ParseTuple(args, "OZOiO:SetValueEx",
; 1581 :                           &obKey,
; 1582 :                           &valueName,
; 1583 :                           &obRes,
; 1584 :                           &typ,
; 1585 :                           &value))

  00011	48 8d 44 24 50	 lea	 rax, QWORD PTR value$[rsp]
  00016	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0001b	48 8d 44 24 74	 lea	 rax, QWORD PTR typ$[rsp]
  00020	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00025	48 8d 44 24 40	 lea	 rax, QWORD PTR obRes$[rsp]
  0002a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002f	4c 8d 4c 24 58	 lea	 r9, QWORD PTR valueName$[rsp]
  00034	4c 8d 44 24 68	 lea	 r8, QWORD PTR obKey$[rsp]
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@FPDLDIPL@OZOiO?3SetValueEx?$AA@
  00040	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00048	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0004d	85 c0		 test	 eax, eax
  0004f	75 07		 jne	 SHORT $LN5@PySetValue@2

; 1586 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	e9 ff 00 00 00	 jmp	 $LN6@PySetValue@2
$LN5@PySetValue@2:

; 1587 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00058	45 33 c0	 xor	 r8d, r8d
  0005b	48 8d 54 24 60	 lea	 rdx, QWORD PTR hKey$[rsp]
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR obKey$[rsp]
  00065	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  0006a	85 c0		 test	 eax, eax
  0006c	75 07		 jne	 SHORT $LN4@PySetValue@2

; 1588 :         return NULL;

  0006e	33 c0		 xor	 eax, eax
  00070	e9 e2 00 00 00	 jmp	 $LN6@PySetValue@2
$LN4@PySetValue@2:

; 1589 :     if (!Py2Reg(value, typ, &data, &len))

  00075	4c 8d 4c 24 70	 lea	 r9, QWORD PTR len$[rsp]
  0007a	4c 8d 44 24 78	 lea	 r8, QWORD PTR data$[rsp]
  0007f	8b 54 24 74	 mov	 edx, DWORD PTR typ$[rsp]
  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  00088	e8 00 00 00 00	 call	 Py2Reg
  0008d	85 c0		 test	 eax, eax
  0008f	75 24		 jne	 SHORT $LN3@PySetValue@2

; 1590 :     {
; 1591 :         if (!PyErr_Occurred())

  00091	e8 00 00 00 00	 call	 PyErr_Occurred
  00096	48 85 c0	 test	 rax, rax
  00099	75 13		 jne	 SHORT $LN2@PySetValue@2

; 1592 :             PyErr_SetString(PyExc_ValueError,
; 1593 :                      "Could not convert the data to the specified type.");

  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@HEEHIAF@Could?5not?5convert?5the?5data?5to?5th@
  000a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a9	e8 00 00 00 00	 call	 PyErr_SetString
$LN2@PySetValue@2:

; 1594 :         return NULL;

  000ae	33 c0		 xor	 eax, eax
  000b0	e9 a2 00 00 00	 jmp	 $LN6@PySetValue@2
$LN3@PySetValue@2:

; 1595 :     }
; 1596 :     Py_BEGIN_ALLOW_THREADS

  000b5	e8 00 00 00 00	 call	 PyEval_SaveThread
  000ba	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR _save$121434[rsp], rax

; 1597 :     rc = RegSetValueExW(hKey, valueName, 0, typ, data, len);

  000c2	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  000c6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000ca	48 8b 44 24 78	 mov	 rax, QWORD PTR data$[rsp]
  000cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d4	44 8b 4c 24 74	 mov	 r9d, DWORD PTR typ$[rsp]
  000d9	45 33 c0	 xor	 r8d, r8d
  000dc	48 8b 54 24 58	 mov	 rdx, QWORD PTR valueName$[rsp]
  000e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hKey$[rsp]
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegSetValueExW
  000ec	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 1598 :     Py_END_ALLOW_THREADS

  000f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _save$121434[rsp]
  000f8	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1599 :     PyMem_DEL(data);

  000fd	e8 00 00 00 00	 call	 _Py_PXCTX
  00102	85 c0		 test	 eax, eax
  00104	74 17		 je	 SHORT $LN8@PySetValue@2
  00106	48 8b 4c 24 78	 mov	 rcx, QWORD PTR data$[rsp]
  0010b	e8 00 00 00 00	 call	 _PxMem_Free
  00110	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv133[rsp], 0
  0011b	eb 15		 jmp	 SHORT $LN9@PySetValue@2
$LN8@PySetValue@2:
  0011d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR data$[rsp]
  00122	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00127	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv133[rsp], 0
$LN9@PySetValue@2:

; 1600 :     if (rc != ERROR_SUCCESS)

  00132	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  00137	74 0b		 je	 SHORT $LN1@PySetValue@2

; 1601 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1602 :                                                    "RegSetValueEx");

  00139	8b 4c 24 48	 mov	 ecx, DWORD PTR rc$[rsp]
  0013d	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00142	eb 13		 jmp	 SHORT $LN6@PySetValue@2
$LN1@PySetValue@2:

; 1603 :     Py_INCREF(Py_None);

  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0014b	e8 00 00 00 00	 call	 _Py_IncRef

; 1604 :     return Py_None;

  00150	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN6@PySetValue@2:

; 1605 : }

  00157	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0015e	c3		 ret	 0
PySetValueEx ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FI@CKKHLMKO@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AAv?$AAi?$AAe?$AAw?$AA?4?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_0DP@KGDGBJCB@Objects?5of?5type?5?8?$CFs?8?5can?5not?5be?5@ ; `string'
PUBLIC	??_C@_1JM@DKLHIKFL@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AA?$CI?$AAl?$AAe?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	??_C@_1KE@PCNCENON@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AA?$CI?$AAl?$AAe?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$CK?$AA?5@ ; `string'
PUBLIC	??_C@_1BO@JGJJJABN@?$AA?4?$AA?4?$AA?2?$AAP?$AAC?$AA?2?$AAw?$AAi?$AAn?$AAr?$AAe?$AAg?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	PyBuffer_Release:PROC
EXTRN	PyObject_GetBuffer:PROC
EXTRN	PyErr_Format:PROC
EXTRN	__imp_wcscpy:PROC
EXTRN	PyUnicode_AsUnicodeAndSize:PROC
EXTRN	PyList_Size:PROC
EXTRN	PyUnicode_AsWideCharString:PROC
EXTRN	PyLong_AsUnsignedLong:PROC
EXTRN	memcpy:PROC
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py2Reg DD imagerel Py2Reg
	DD	imagerel Py2Reg+1750
	DD	imagerel $unwind$Py2Reg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py2Reg DD 021a01H
	DD	023011aH
xdata	ENDS
;	COMDAT ??_C@_1FI@CKKHLMKO@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AAv?$AAi?$AAe?$AAw?$AA?4?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1FI@CKKHLMKO@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AAv?$AAi?$AAe?$AAw?$AA?4?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@ DB '('
	DB	00H, 'P', 00H, 'y', 00H, '_', 00H, 's', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H, 'D'
	DB	00H, 'W', 00H, 'O', 00H, 'R', 00H, 'D', 00H, ')', 00H, '(', 00H
	DB	'v', 00H, 'i', 00H, 'e', 00H, 'w', 00H, '.', 00H, 'l', 00H, 'e'
	DB	00H, 'n', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'(', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w', 00H, '.', 00H, 'l'
	DB	00H, 'e', 00H, 'n', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KGDGBJCB@Objects?5of?5type?5?8?$CFs?8?5can?5not?5be?5@
CONST	SEGMENT
??_C@_0DP@KGDGBJCB@Objects?5of?5type?5?8?$CFs?8?5can?5not?5be?5@ DB 'Obje'
	DB	'cts of type ''%s'' can not be used as binary registry values', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JM@DKLHIKFL@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AA?$CI?$AAl?$AAe?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1JM@DKLHIKFL@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AA?$CI?$AAl?$AAe?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe@ DB '('
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	')', 00H, '(', 00H, 'D', 00H, 'W', 00H, 'O', 00H, 'R', 00H, 'D'
	DB	00H, ')', 00H, '(', 00H, '(', 00H, 'l', 00H, 'e', 00H, 'n', 00H
	DB	' ', 00H, '+', 00H, ' ', 00H, '1', 00H, ')', 00H, ' ', 00H, '*'
	DB	00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H
	DB	'f', 00H, '(', 00H, 'w', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r'
	DB	00H, '_', 00H, 't', 00H, ')', 00H, ')', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '(', 00H, '(', 00H, 'l', 00H, 'e', 00H, 'n'
	DB	00H, ' ', 00H, '+', 00H, ' ', 00H, '1', 00H, ')', 00H, ' ', 00H
	DB	'*', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o'
	DB	00H, 'f', 00H, '(', 00H, 'w', 00H, 'c', 00H, 'h', 00H, 'a', 00H
	DB	'r', 00H, '_', 00H, 't', 00H, ')', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KE@PCNCENON@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AA?$CI?$AAl?$AAe?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$CK?$AA?5@
CONST	SEGMENT
??_C@_1KE@PCNCENON@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AA?$CI?$AAl?$AAe?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$CK?$AA?5@ DB '('
	DB	00H, 'P', 00H, 'y', 00H, '_', 00H, 's', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H, 'D'
	DB	00H, 'W', 00H, 'O', 00H, 'R', 00H, 'D', 00H, ')', 00H, '(', 00H
	DB	'(', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H, '+', 00H, ' '
	DB	00H, '1', 00H, ')', 00H, ' ', 00H, '*', 00H, ' ', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H, 'w'
	DB	00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '_', 00H, 't', 00H
	DB	')', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '('
	DB	00H, '(', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H, '+', 00H
	DB	' ', 00H, '1', 00H, ')', 00H, ' ', 00H, '*', 00H, ' ', 00H, 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H
	DB	'w', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '_', 00H, 't'
	DB	00H, ')', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@JGJJJABN@?$AA?4?$AA?4?$AA?2?$AAP?$AAC?$AA?2?$AAw?$AAi?$AAn?$AAr?$AAe?$AAg?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@JGJJJABN@?$AA?4?$AA?4?$AA?2?$AAP?$AAC?$AA?2?$AAw?$AAi?$AAn?$AAr?$AAe?$AAg?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'C', 00H, '\', 00H, 'w', 00H
	DB	'i', 00H, 'n', 00H, 'r', 00H, 'e', 00H, 'g', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Py2Reg
_TEXT	SEGMENT
i$ = 32
j$ = 40
zero$120763 = 48
d$120766 = 52
len$120770 = 56
P$120803 = 64
size$120802 = 72
len$120813 = 80
t$120811 = 88
wstr$120812 = 96
len$120846 = 104
t$120844 = 112
wstr$120845 = 120
view$120853 = 128
tv64 = 208
tv76 = 216
tv148 = 224
tv198 = 232
tv197 = 240
tv240 = 248
tv239 = 256
value$ = 288
typ$ = 296
retDataBuf$ = 304
retDataSize$ = 312
Py2Reg	PROC						; COMDAT

; 770  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 771  :     Py_ssize_t i,j;
; 772  :     switch (typ) {

  0001a	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR typ$[rsp]
  00021	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv64[rsp], eax
  00028	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 0
  00030	0f 86 ea 04 00
	00		 jbe	 $LN7@Py2Reg
  00036	83 bc 24 d0 00
	00 00 02	 cmp	 DWORD PTR tv64[rsp], 2
  0003e	0f 86 21 01 00
	00		 jbe	 $LN27@Py2Reg
  00044	83 bc 24 d0 00
	00 00 04	 cmp	 DWORD PTR tv64[rsp], 4
  0004c	74 13		 je	 SHORT $LN32@Py2Reg
  0004e	83 bc 24 d0 00
	00 00 07	 cmp	 DWORD PTR tv64[rsp], 7
  00056	0f 84 3e 02 00
	00		 je	 $LN21@Py2Reg
  0005c	e9 bf 04 00 00	 jmp	 $LN7@Py2Reg
$LN32@Py2Reg:

; 773  :         case REG_DWORD:
; 774  :             if (value != Py_None && !PyLong_Check(value))

  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00068	48 39 84 24 20
	01 00 00	 cmp	 QWORD PTR value$[rsp], rax
  00070	74 22		 je	 SHORT $LN31@Py2Reg
  00072	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR value$[rsp]
  0007a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0007e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00084	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00089	85 c0		 test	 eax, eax
  0008b	75 07		 jne	 SHORT $LN31@Py2Reg

; 775  :                 return FALSE;

  0008d	33 c0		 xor	 eax, eax
  0008f	e9 3a 06 00 00	 jmp	 $LN35@Py2Reg
$LN31@Py2Reg:

; 776  :             *retDataBuf = (BYTE *)PyMem_NEW(DWORD, 1);

  00094	e8 00 00 00 00	 call	 _Py_PXCTX
  00099	85 c0		 test	 eax, eax
  0009b	74 14		 je	 SHORT $LN37@Py2Reg
  0009d	b9 04 00 00 00	 mov	 ecx, 4
  000a2	e8 00 00 00 00	 call	 _PxMem_Malloc
  000a7	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv76[rsp], rax
  000af	eb 12		 jmp	 SHORT $LN38@Py2Reg
$LN37@Py2Reg:
  000b1	b9 04 00 00 00	 mov	 ecx, 4
  000b6	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  000bb	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv76[rsp], rax
$LN38@Py2Reg:
  000c3	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  000cb	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv76[rsp]
  000d3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 777  :             if (*retDataBuf==NULL){

  000d6	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  000de	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000e2	75 0c		 jne	 SHORT $LN30@Py2Reg

; 778  :                 PyErr_NoMemory();

  000e4	e8 00 00 00 00	 call	 PyErr_NoMemory

; 779  :                 return FALSE;

  000e9	33 c0		 xor	 eax, eax
  000eb	e9 de 05 00 00	 jmp	 $LN35@Py2Reg
$LN30@Py2Reg:

; 780  :             }
; 781  :             *retDataSize = sizeof(DWORD);

  000f0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR retDataSize$[rsp]
  000f8	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 782  :             if (value == Py_None) {

  000fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00105	48 39 84 24 20
	01 00 00	 cmp	 QWORD PTR value$[rsp], rax
  0010d	75 25		 jne	 SHORT $LN29@Py2Reg

; 783  :                 DWORD zero = 0;

  0010f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR zero$120763[rsp], 0

; 784  :                 memcpy(*retDataBuf, &zero, sizeof(DWORD));

  00117	41 b8 04 00 00
	00		 mov	 r8d, 4
  0011d	48 8d 54 24 30	 lea	 rdx, QWORD PTR zero$120763[rsp]
  00122	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  0012a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0012d	e8 00 00 00 00	 call	 memcpy

; 785  :             }
; 786  :             else {

  00132	eb 2c		 jmp	 SHORT $LN28@Py2Reg
$LN29@Py2Reg:

; 787  :                 DWORD d = PyLong_AsUnsignedLong(value);

  00134	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  0013c	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  00141	89 44 24 34	 mov	 DWORD PTR d$120766[rsp], eax

; 788  :                 memcpy(*retDataBuf, &d, sizeof(DWORD));

  00145	41 b8 04 00 00
	00		 mov	 r8d, 4
  0014b	48 8d 54 24 34	 lea	 rdx, QWORD PTR d$120766[rsp]
  00150	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  00158	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0015b	e8 00 00 00 00	 call	 memcpy
$LN28@Py2Reg:

; 789  :             }
; 790  :             break;

  00160	e9 64 05 00 00	 jmp	 $LN33@Py2Reg
$LN27@Py2Reg:

; 791  :         case REG_SZ:
; 792  :         case REG_EXPAND_SZ:
; 793  :             {
; 794  :                 if (value != Py_None) {

  00165	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0016c	48 39 84 24 20
	01 00 00	 cmp	 QWORD PTR value$[rsp], rax
  00174	0f 84 a1 00 00
	00		 je	 $LN26@Py2Reg

; 795  :                     Py_ssize_t len;
; 796  :                     if (!PyUnicode_Check(value))

  0017a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR value$[rsp]
  00182	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00186	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0018c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00191	85 c0		 test	 eax, eax
  00193	75 07		 jne	 SHORT $LN25@Py2Reg

; 797  :                         return FALSE;

  00195	33 c0		 xor	 eax, eax
  00197	e9 32 05 00 00	 jmp	 $LN35@Py2Reg
$LN25@Py2Reg:

; 798  :                     *retDataBuf = (BYTE*)PyUnicode_AsWideCharString(value, &len);

  0019c	48 8d 54 24 38	 lea	 rdx, QWORD PTR len$120770[rsp]
  001a1	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  001a9	e8 00 00 00 00	 call	 PyUnicode_AsWideCharString
  001ae	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR retDataBuf$[rsp]
  001b6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 799  :                     if (*retDataBuf == NULL)

  001b9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  001c1	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001c5	75 07		 jne	 SHORT $LN24@Py2Reg

; 800  :                         return FALSE;

  001c7	33 c0		 xor	 eax, eax
  001c9	e9 00 05 00 00	 jmp	 $LN35@Py2Reg
$LN24@Py2Reg:

; 801  :                     *retDataSize = Py_SAFE_DOWNCAST(
; 802  :                         (len + 1) * sizeof(wchar_t),
; 803  :                         Py_ssize_t, DWORD);

  001ce	48 8b 44 24 38	 mov	 rax, QWORD PTR len$120770[rsp]
  001d3	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  001d8	8b c0		 mov	 eax, eax
  001da	48 8b 4c 24 38	 mov	 rcx, QWORD PTR len$120770[rsp]
  001df	48 8d 4c 09 02	 lea	 rcx, QWORD PTR [rcx+rcx+2]
  001e4	48 3b c1	 cmp	 rax, rcx
  001e7	74 1c		 je	 SHORT $LN39@Py2Reg
  001e9	41 b8 23 03 00
	00		 mov	 r8d, 803		; 00000323H
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BO@JGJJJABN@?$AA?4?$AA?4?$AA?2?$AAP?$AAC?$AA?2?$AAw?$AAi?$AAn?$AAr?$AAe?$AAg?$AA?4?$AAc?$AA?$AA@
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KE@PCNCENON@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AA?$CI?$AAl?$AAe?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$CK?$AA?5@
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00203	33 c0		 xor	 eax, eax
$LN39@Py2Reg:
  00205	48 8b 44 24 38	 mov	 rax, QWORD PTR len$120770[rsp]
  0020a	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  0020f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR retDataSize$[rsp]
  00217	89 01		 mov	 DWORD PTR [rcx], eax

; 804  :                 }
; 805  :                 else {

  00219	eb 7a		 jmp	 SHORT $LN23@Py2Reg
$LN26@Py2Reg:

; 806  :                     *retDataBuf = (BYTE *)PyMem_NEW(wchar_t, 1);

  0021b	e8 00 00 00 00	 call	 _Py_PXCTX
  00220	85 c0		 test	 eax, eax
  00222	74 14		 je	 SHORT $LN40@Py2Reg
  00224	b9 02 00 00 00	 mov	 ecx, 2
  00229	e8 00 00 00 00	 call	 _PxMem_Malloc
  0022e	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
  00236	eb 12		 jmp	 SHORT $LN41@Py2Reg
$LN40@Py2Reg:
  00238	b9 02 00 00 00	 mov	 ecx, 2
  0023d	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00242	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
$LN41@Py2Reg:
  0024a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  00252	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv148[rsp]
  0025a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 807  :                     if (*retDataBuf == NULL) {

  0025d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  00265	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00269	75 0c		 jne	 SHORT $LN22@Py2Reg

; 808  :                         PyErr_NoMemory();

  0026b	e8 00 00 00 00	 call	 PyErr_NoMemory

; 809  :                         return FALSE;

  00270	33 c0		 xor	 eax, eax
  00272	e9 57 04 00 00	 jmp	 $LN35@Py2Reg
$LN22@Py2Reg:

; 810  :                     }
; 811  :                     ((wchar_t *)*retDataBuf)[0] = L'\0';

  00277	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  0027f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00282	33 c9		 xor	 ecx, ecx
  00284	66 89 08	 mov	 WORD PTR [rax], cx

; 812  :                     *retDataSize = 1 * sizeof(wchar_t);

  00287	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR retDataSize$[rsp]
  0028f	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN23@Py2Reg:

; 813  :                 }
; 814  :                 break;

  00295	e9 2f 04 00 00	 jmp	 $LN33@Py2Reg
$LN21@Py2Reg:

; 815  :             }
; 816  :         case REG_MULTI_SZ:
; 817  :             {
; 818  :                 DWORD size = 0;

  0029a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR size$120802[rsp], 0

; 819  :                 wchar_t *P;
; 820  : 
; 821  :                 if (value == Py_None)

  002a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  002a9	48 39 84 24 20
	01 00 00	 cmp	 QWORD PTR value$[rsp], rax
  002b1	75 0b		 jne	 SHORT $LN20@Py2Reg

; 822  :                     i = 0;

  002b3	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0

; 823  :                 else {

  002bc	eb 34		 jmp	 SHORT $LN19@Py2Reg
$LN20@Py2Reg:

; 824  :                     if (!PyList_Check(value))

  002be	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR value$[rsp]
  002c6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002ca	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002d0	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  002d5	85 c0		 test	 eax, eax
  002d7	75 07		 jne	 SHORT $LN18@Py2Reg

; 825  :                         return FALSE;

  002d9	33 c0		 xor	 eax, eax
  002db	e9 ee 03 00 00	 jmp	 $LN35@Py2Reg
$LN18@Py2Reg:

; 826  :                     i = PyList_Size(value);

  002e0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  002e8	e8 00 00 00 00	 call	 PyList_Size
  002ed	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN19@Py2Reg:

; 827  :                 }
; 828  :                 for (j = 0; j < i; j++)

  002f2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  002fb	eb 0d		 jmp	 SHORT $LN17@Py2Reg
$LN16@Py2Reg:
  002fd	48 8b 44 24 28	 mov	 rax, QWORD PTR j$[rsp]
  00302	48 ff c0	 inc	 rax
  00305	48 89 44 24 28	 mov	 QWORD PTR j$[rsp], rax
$LN17@Py2Reg:
  0030a	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0030f	48 39 44 24 28	 cmp	 QWORD PTR j$[rsp], rax
  00314	0f 8d ae 00 00
	00		 jge	 $LN15@Py2Reg

; 829  :                 {
; 830  :                     PyObject *t;
; 831  :                     wchar_t *wstr;
; 832  :                     Py_ssize_t len;
; 833  : 
; 834  :                     t = PyList_GET_ITEM(value, j);

  0031a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR value$[rsp]
  00322	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00326	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  0032b	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0032f	48 89 44 24 58	 mov	 QWORD PTR t$120811[rsp], rax

; 835  :                     if (!PyUnicode_Check(t))

  00334	48 8b 44 24 58	 mov	 rax, QWORD PTR t$120811[rsp]
  00339	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0033d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00343	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00348	85 c0		 test	 eax, eax
  0034a	75 07		 jne	 SHORT $LN14@Py2Reg

; 836  :                         return FALSE;

  0034c	33 c0		 xor	 eax, eax
  0034e	e9 7b 03 00 00	 jmp	 $LN35@Py2Reg
$LN14@Py2Reg:

; 837  :                     wstr = PyUnicode_AsUnicodeAndSize(t, &len);

  00353	48 8d 54 24 50	 lea	 rdx, QWORD PTR len$120813[rsp]
  00358	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t$120811[rsp]
  0035d	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeAndSize
  00362	48 89 44 24 60	 mov	 QWORD PTR wstr$120812[rsp], rax

; 838  :                     if (wstr == NULL)

  00367	48 83 7c 24 60
	00		 cmp	 QWORD PTR wstr$120812[rsp], 0
  0036d	75 07		 jne	 SHORT $LN13@Py2Reg

; 839  :                         return FALSE;

  0036f	33 c0		 xor	 eax, eax
  00371	e9 58 03 00 00	 jmp	 $LN35@Py2Reg
$LN13@Py2Reg:

; 840  :                     size += Py_SAFE_DOWNCAST((len + 1) * sizeof(wchar_t),
; 841  :                                              size_t, DWORD);

  00376	48 8b 44 24 50	 mov	 rax, QWORD PTR len$120813[rsp]
  0037b	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  00380	8b c0		 mov	 eax, eax
  00382	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$120813[rsp]
  00387	48 8d 4c 09 02	 lea	 rcx, QWORD PTR [rcx+rcx+2]
  0038c	48 3b c1	 cmp	 rax, rcx
  0038f	74 1c		 je	 SHORT $LN42@Py2Reg
  00391	41 b8 49 03 00
	00		 mov	 r8d, 841		; 00000349H
  00397	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BO@JGJJJABN@?$AA?4?$AA?4?$AA?2?$AAP?$AAC?$AA?2?$AAw?$AAi?$AAn?$AAr?$AAe?$AAg?$AA?4?$AAc?$AA?$AA@
  0039e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JM@DKLHIKFL@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AA?$CI?$AAl?$AAe?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe@
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003ab	33 c0		 xor	 eax, eax
$LN42@Py2Reg:
  003ad	48 8b 44 24 50	 mov	 rax, QWORD PTR len$120813[rsp]
  003b2	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  003b7	8b 4c 24 48	 mov	 ecx, DWORD PTR size$120802[rsp]
  003bb	03 c8		 add	 ecx, eax
  003bd	8b c1		 mov	 eax, ecx
  003bf	89 44 24 48	 mov	 DWORD PTR size$120802[rsp], eax

; 842  :                 }

  003c3	e9 35 ff ff ff	 jmp	 $LN16@Py2Reg
$LN15@Py2Reg:

; 843  : 
; 844  :                 *retDataSize = size + 2;

  003c8	8b 44 24 48	 mov	 eax, DWORD PTR size$120802[rsp]
  003cc	83 c0 02	 add	 eax, 2
  003cf	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR retDataSize$[rsp]
  003d7	89 01		 mov	 DWORD PTR [rcx], eax

; 845  :                 *retDataBuf = (BYTE *)PyMem_NEW(char,
; 846  :                                                 *retDataSize);

  003d9	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR retDataSize$[rsp]
  003e1	8b 00		 mov	 eax, DWORD PTR [rax]
  003e3	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  003ed	48 3b c1	 cmp	 rax, rcx
  003f0	76 0e		 jbe	 SHORT $LN45@Py2Reg
  003f2	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv198[rsp], 0
  003fe	eb 4d		 jmp	 SHORT $LN46@Py2Reg
$LN45@Py2Reg:
  00400	e8 00 00 00 00	 call	 _Py_PXCTX
  00405	85 c0		 test	 eax, eax
  00407	74 1b		 je	 SHORT $LN43@Py2Reg
  00409	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR retDataSize$[rsp]
  00411	8b 00		 mov	 eax, DWORD PTR [rax]
  00413	8b c8		 mov	 ecx, eax
  00415	e8 00 00 00 00	 call	 _PxMem_Malloc
  0041a	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv197[rsp], rax
  00422	eb 19		 jmp	 SHORT $LN44@Py2Reg
$LN43@Py2Reg:
  00424	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR retDataSize$[rsp]
  0042c	8b 00		 mov	 eax, DWORD PTR [rax]
  0042e	8b c8		 mov	 ecx, eax
  00430	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00435	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv197[rsp], rax
$LN44@Py2Reg:
  0043d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv197[rsp]
  00445	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
$LN46@Py2Reg:
  0044d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  00455	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv198[rsp]
  0045d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 847  :                 if (*retDataBuf==NULL){

  00460	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  00468	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0046c	75 0c		 jne	 SHORT $LN12@Py2Reg

; 848  :                     PyErr_NoMemory();

  0046e	e8 00 00 00 00	 call	 PyErr_NoMemory

; 849  :                     return FALSE;

  00473	33 c0		 xor	 eax, eax
  00475	e9 54 02 00 00	 jmp	 $LN35@Py2Reg
$LN12@Py2Reg:

; 850  :                 }
; 851  :                 P = (wchar_t *)*retDataBuf;

  0047a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  00482	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00485	48 89 44 24 40	 mov	 QWORD PTR P$120803[rsp], rax

; 852  : 
; 853  :                 for (j = 0; j < i; j++)

  0048a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00493	eb 0d		 jmp	 SHORT $LN11@Py2Reg
$LN10@Py2Reg:
  00495	48 8b 44 24 28	 mov	 rax, QWORD PTR j$[rsp]
  0049a	48 ff c0	 inc	 rax
  0049d	48 89 44 24 28	 mov	 QWORD PTR j$[rsp], rax
$LN11@Py2Reg:
  004a2	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  004a7	48 39 44 24 28	 cmp	 QWORD PTR j$[rsp], rax
  004ac	7d 63		 jge	 SHORT $LN9@Py2Reg

; 854  :                 {
; 855  :                     PyObject *t;
; 856  :                     wchar_t *wstr;
; 857  :                     Py_ssize_t len;
; 858  : 
; 859  :                     t = PyList_GET_ITEM(value, j);

  004ae	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR value$[rsp]
  004b6	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  004ba	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  004bf	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  004c3	48 89 44 24 70	 mov	 QWORD PTR t$120844[rsp], rax

; 860  :                     wstr = PyUnicode_AsUnicodeAndSize(t, &len);

  004c8	48 8d 54 24 68	 lea	 rdx, QWORD PTR len$120846[rsp]
  004cd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR t$120844[rsp]
  004d2	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeAndSize
  004d7	48 89 44 24 78	 mov	 QWORD PTR wstr$120845[rsp], rax

; 861  :                     if (wstr == NULL)

  004dc	48 83 7c 24 78
	00		 cmp	 QWORD PTR wstr$120845[rsp], 0
  004e2	75 07		 jne	 SHORT $LN8@Py2Reg

; 862  :                         return FALSE;

  004e4	33 c0		 xor	 eax, eax
  004e6	e9 e3 01 00 00	 jmp	 $LN35@Py2Reg
$LN8@Py2Reg:

; 863  :                     wcscpy(P, wstr);

  004eb	48 8b 54 24 78	 mov	 rdx, QWORD PTR wstr$120845[rsp]
  004f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR P$120803[rsp]
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 864  :                     P += (len + 1);

  004fb	48 8b 44 24 40	 mov	 rax, QWORD PTR P$120803[rsp]
  00500	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$120846[rsp]
  00505	48 8d 44 48 02	 lea	 rax, QWORD PTR [rax+rcx*2+2]
  0050a	48 89 44 24 40	 mov	 QWORD PTR P$120803[rsp], rax

; 865  :                 }

  0050f	eb 84		 jmp	 SHORT $LN10@Py2Reg
$LN9@Py2Reg:

; 866  :                 /* And doubly-terminate the list... */
; 867  :                 *P = '\0';

  00511	33 c0		 xor	 eax, eax
  00513	48 8b 4c 24 40	 mov	 rcx, QWORD PTR P$120803[rsp]
  00518	66 89 01	 mov	 WORD PTR [rcx], ax

; 868  :                 break;

  0051b	e9 a9 01 00 00	 jmp	 $LN33@Py2Reg
$LN7@Py2Reg:

; 869  :             }
; 870  :         case REG_BINARY:
; 871  :         /* ALSO handle ALL unknown data types here.  Even if we can't
; 872  :            support it natively, we should handle the bits. */
; 873  :         default:
; 874  :             if (value == Py_None)

  00520	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00527	48 39 84 24 20
	01 00 00	 cmp	 QWORD PTR value$[rsp], rax
  0052f	75 13		 jne	 SHORT $LN6@Py2Reg

; 875  :                 *retDataSize = 0;

  00531	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR retDataSize$[rsp]
  00539	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 876  :             else {

  0053f	e9 85 01 00 00	 jmp	 $LN5@Py2Reg
$LN6@Py2Reg:

; 877  :                 Py_buffer view;
; 878  : 
; 879  :                 if (!PyObject_CheckBuffer(value)) {

  00544	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR value$[rsp]
  0054c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00550	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  00558	74 19		 je	 SHORT $LN3@Py2Reg
  0055a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR value$[rsp]
  00562	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00566	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  0056d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00571	75 2a		 jne	 SHORT $LN4@Py2Reg
$LN3@Py2Reg:

; 880  :                     PyErr_Format(PyExc_TypeError,
; 881  :                         "Objects of type '%s' can not "
; 882  :                         "be used as binary registry values",
; 883  :                         value->ob_type->tp_name);

  00573	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR value$[rsp]
  0057b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0057f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00583	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@KGDGBJCB@Objects?5of?5type?5?8?$CFs?8?5can?5not?5be?5@
  0058a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00591	e8 00 00 00 00	 call	 PyErr_Format

; 884  :                     return FALSE;

  00596	33 c0		 xor	 eax, eax
  00598	e9 31 01 00 00	 jmp	 $LN35@Py2Reg
$LN4@Py2Reg:

; 885  :                 }
; 886  : 
; 887  :                 if (PyObject_GetBuffer(value, &view, PyBUF_SIMPLE) < 0)

  0059d	45 33 c0	 xor	 r8d, r8d
  005a0	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR view$120853[rsp]
  005a8	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  005b0	e8 00 00 00 00	 call	 PyObject_GetBuffer
  005b5	85 c0		 test	 eax, eax
  005b7	7d 07		 jge	 SHORT $LN2@Py2Reg

; 888  :                     return FALSE;

  005b9	33 c0		 xor	 eax, eax
  005bb	e9 0e 01 00 00	 jmp	 $LN35@Py2Reg
$LN2@Py2Reg:

; 889  : 
; 890  :                 *retDataBuf = (BYTE *)PyMem_NEW(char, view.len);

  005c0	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  005ca	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR view$120853[rsp+16], rax
  005d2	76 0e		 jbe	 SHORT $LN49@Py2Reg
  005d4	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv240[rsp], 0
  005e0	eb 45		 jmp	 SHORT $LN50@Py2Reg
$LN49@Py2Reg:
  005e2	e8 00 00 00 00	 call	 _Py_PXCTX
  005e7	85 c0		 test	 eax, eax
  005e9	74 17		 je	 SHORT $LN47@Py2Reg
  005eb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR view$120853[rsp+16]
  005f3	e8 00 00 00 00	 call	 _PxMem_Malloc
  005f8	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv239[rsp], rax
  00600	eb 15		 jmp	 SHORT $LN48@Py2Reg
$LN47@Py2Reg:
  00602	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR view$120853[rsp+16]
  0060a	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0060f	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv239[rsp], rax
$LN48@Py2Reg:
  00617	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv239[rsp]
  0061f	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv240[rsp], rax
$LN50@Py2Reg:
  00627	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  0062f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv240[rsp]
  00637	48 89 08	 mov	 QWORD PTR [rax], rcx

; 891  :                 if (*retDataBuf==NULL){

  0063a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  00642	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00646	75 16		 jne	 SHORT $LN1@Py2Reg

; 892  :                     PyBuffer_Release(&view);

  00648	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR view$120853[rsp]
  00650	e8 00 00 00 00	 call	 PyBuffer_Release

; 893  :                     PyErr_NoMemory();

  00655	e8 00 00 00 00	 call	 PyErr_NoMemory

; 894  :                     return FALSE;

  0065a	33 c0		 xor	 eax, eax
  0065c	eb 70		 jmp	 SHORT $LN35@Py2Reg
$LN1@Py2Reg:

; 895  :                 }
; 896  :                 *retDataSize = Py_SAFE_DOWNCAST(view.len, Py_ssize_t, DWORD);

  0065e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR view$120853[rsp+16]
  00665	48 3b 84 24 90
	00 00 00	 cmp	 rax, QWORD PTR view$120853[rsp+16]
  0066d	74 1c		 je	 SHORT $LN51@Py2Reg
  0066f	41 b8 80 03 00
	00		 mov	 r8d, 896		; 00000380H
  00675	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BO@JGJJJABN@?$AA?4?$AA?4?$AA?2?$AAP?$AAC?$AA?2?$AAw?$AAi?$AAn?$AAr?$AAe?$AAg?$AA?4?$AAc?$AA?$AA@
  0067c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FI@CKKHLMKO@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AA?$CI?$AAv?$AAi?$AAe?$AAw?$AA?4?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@
  00683	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00689	33 c0		 xor	 eax, eax
$LN51@Py2Reg:
  0068b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR retDataSize$[rsp]
  00693	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR view$120853[rsp+16]
  0069a	89 08		 mov	 DWORD PTR [rax], ecx

; 897  :                 memcpy(*retDataBuf, view.buf, view.len);

  0069c	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR view$120853[rsp+16]
  006a4	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR view$120853[rsp]
  006ac	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR retDataBuf$[rsp]
  006b4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006b7	e8 00 00 00 00	 call	 memcpy

; 898  :                 PyBuffer_Release(&view);

  006bc	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR view$120853[rsp]
  006c4	e8 00 00 00 00	 call	 PyBuffer_Release
$LN5@Py2Reg:
$LN33@Py2Reg:

; 899  :             }
; 900  :             break;
; 901  :     }
; 902  :     return TRUE;

  006c9	b8 01 00 00 00	 mov	 eax, 1
$LN35@Py2Reg:

; 903  : }

  006ce	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  006d5	c3		 ret	 0
Py2Reg	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@MCEAONBI@RegDisableReflectionKey?$AA@	; `string'
PUBLIC	??_C@_0BH@ONBEGOOK@O?3DisableReflectionKey?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyDisableReflectionKey DD imagerel PyDisableReflectionKey
	DD	imagerel PyDisableReflectionKey+240
	DD	imagerel $unwind$PyDisableReflectionKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyDisableReflectionKey DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BI@MCEAONBI@RegDisableReflectionKey?$AA@
CONST	SEGMENT
??_C@_0BI@MCEAONBI@RegDisableReflectionKey?$AA@ DB 'RegDisableReflectionK'
	DB	'ey', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ONBEGOOK@O?3DisableReflectionKey?$AA@
CONST	SEGMENT
??_C@_0BH@ONBEGOOK@O?3DisableReflectionKey?$AA@ DB 'O:DisableReflectionKe'
	DB	'y', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyDisableReflectionKey
_TEXT	SEGMENT
rc$ = 32
hKey$ = 40
hMod$ = 48
obKey$ = 56
pfn$ = 64
_save$121461 = 72
self$ = 96
args$ = 104
PyDisableReflectionKey PROC				; COMDAT

; 1609 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1610 :     HKEY hKey;
; 1611 :     PyObject *obKey;
; 1612 :     HMODULE hMod;
; 1613 :     typedef LONG (WINAPI *RDRKFunc)(HKEY);
; 1614 :     RDRKFunc pfn = NULL;

  0000e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pfn$[rsp], 0

; 1615 :     LONG rc;
; 1616 : 
; 1617 :     if (!PyArg_ParseTuple(args, "O:DisableReflectionKey", &obKey))

  00017	4c 8d 44 24 38	 lea	 r8, QWORD PTR obKey$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@ONBEGOOK@O?3DisableReflectionKey?$AA@
  00023	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN5@PyDisableR

; 1618 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 b3 00 00 00	 jmp	 $LN6@PyDisableR
$LN5@PyDisableR:

; 1619 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 8d 54 24 28	 lea	 rdx, QWORD PTR hKey$[rsp]
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obKey$[rsp]
  00045	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  0004a	85 c0		 test	 eax, eax
  0004c	75 07		 jne	 SHORT $LN4@PyDisableR

; 1620 :         return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 96 00 00 00	 jmp	 $LN6@PyDisableR
$LN4@PyDisableR:

; 1621 : 
; 1622 :     /* Only available on 64bit platforms, so we must load it
; 1623 :        dynamically.*/
; 1624 :     hMod = GetModuleHandleW(L"advapi32.dll");

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@JHLNAEJL@?$AAa?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleW
  00062	48 89 44 24 30	 mov	 QWORD PTR hMod$[rsp], rax

; 1625 :     if (hMod)

  00067	48 83 7c 24 30
	00		 cmp	 QWORD PTR hMod$[rsp], 0
  0006d	74 17		 je	 SHORT $LN3@PyDisableR

; 1626 :         pfn = (RDRKFunc)GetProcAddress(hMod,
; 1627 :                                        "RegDisableReflectionKey");

  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@MCEAONBI@RegDisableReflectionKey?$AA@
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hMod$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00081	48 89 44 24 40	 mov	 QWORD PTR pfn$[rsp], rax
$LN3@PyDisableR:

; 1628 :     if (!pfn) {

  00086	48 83 7c 24 40
	00		 cmp	 QWORD PTR pfn$[rsp], 0
  0008c	75 17		 jne	 SHORT $LN2@PyDisableR

; 1629 :         PyErr_SetString(PyExc_NotImplementedError,
; 1630 :                         "not implemented on this platform");

  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@ODEKPPJP@not?5implemented?5on?5this?5platform@
  00095	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0009c	e8 00 00 00 00	 call	 PyErr_SetString

; 1631 :         return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	eb 46		 jmp	 SHORT $LN6@PyDisableR
$LN2@PyDisableR:

; 1632 :     }
; 1633 :     Py_BEGIN_ALLOW_THREADS

  000a5	e8 00 00 00 00	 call	 PyEval_SaveThread
  000aa	48 89 44 24 48	 mov	 QWORD PTR _save$121461[rsp], rax

; 1634 :     rc = (*pfn)(hKey);

  000af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hKey$[rsp]
  000b4	ff 54 24 40	 call	 QWORD PTR pfn$[rsp]
  000b8	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1635 :     Py_END_ALLOW_THREADS

  000bc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _save$121461[rsp]
  000c1	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1636 :     if (rc != ERROR_SUCCESS)

  000c6	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000cb	74 0b		 je	 SHORT $LN1@PyDisableR

; 1637 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1638 :                                                    "RegDisableReflectionKey");

  000cd	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  000d1	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000d6	eb 13		 jmp	 SHORT $LN6@PyDisableR
$LN1@PyDisableR:

; 1639 :     Py_INCREF(Py_None);

  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000df	e8 00 00 00 00	 call	 _Py_IncRef

; 1640 :     return Py_None;

  000e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN6@PyDisableR:

; 1641 : }

  000eb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ef	c3		 ret	 0
PyDisableReflectionKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@MJKGPAOP@RegEnableReflectionKey?$AA@	; `string'
PUBLIC	??_C@_0BG@PCFJIFND@O?3EnableReflectionKey?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEnableReflectionKey DD imagerel PyEnableReflectionKey
	DD	imagerel PyEnableReflectionKey+240
	DD	imagerel $unwind$PyEnableReflectionKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEnableReflectionKey DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BH@MJKGPAOP@RegEnableReflectionKey?$AA@
CONST	SEGMENT
??_C@_0BH@MJKGPAOP@RegEnableReflectionKey?$AA@ DB 'RegEnableReflectionKey'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PCFJIFND@O?3EnableReflectionKey?$AA@
CONST	SEGMENT
??_C@_0BG@PCFJIFND@O?3EnableReflectionKey?$AA@ DB 'O:EnableReflectionKey', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyEnableReflectionKey
_TEXT	SEGMENT
rc$ = 32
hKey$ = 40
hMod$ = 48
obKey$ = 56
pfn$ = 64
_save$121488 = 72
self$ = 96
args$ = 104
PyEnableReflectionKey PROC				; COMDAT

; 1645 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1646 :     HKEY hKey;
; 1647 :     PyObject *obKey;
; 1648 :     HMODULE hMod;
; 1649 :     typedef LONG (WINAPI *RERKFunc)(HKEY);
; 1650 :     RERKFunc pfn = NULL;

  0000e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pfn$[rsp], 0

; 1651 :     LONG rc;
; 1652 : 
; 1653 :     if (!PyArg_ParseTuple(args, "O:EnableReflectionKey", &obKey))

  00017	4c 8d 44 24 38	 lea	 r8, QWORD PTR obKey$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PCFJIFND@O?3EnableReflectionKey?$AA@
  00023	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN5@PyEnableRe

; 1654 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 b3 00 00 00	 jmp	 $LN6@PyEnableRe
$LN5@PyEnableRe:

; 1655 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 8d 54 24 28	 lea	 rdx, QWORD PTR hKey$[rsp]
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obKey$[rsp]
  00045	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  0004a	85 c0		 test	 eax, eax
  0004c	75 07		 jne	 SHORT $LN4@PyEnableRe

; 1656 :         return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 96 00 00 00	 jmp	 $LN6@PyEnableRe
$LN4@PyEnableRe:

; 1657 : 
; 1658 :     /* Only available on 64bit platforms, so we must load it
; 1659 :        dynamically.*/
; 1660 :     hMod = GetModuleHandleW(L"advapi32.dll");

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@JHLNAEJL@?$AAa?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleW
  00062	48 89 44 24 30	 mov	 QWORD PTR hMod$[rsp], rax

; 1661 :     if (hMod)

  00067	48 83 7c 24 30
	00		 cmp	 QWORD PTR hMod$[rsp], 0
  0006d	74 17		 je	 SHORT $LN3@PyEnableRe

; 1662 :         pfn = (RERKFunc)GetProcAddress(hMod,
; 1663 :                                        "RegEnableReflectionKey");

  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MJKGPAOP@RegEnableReflectionKey?$AA@
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hMod$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00081	48 89 44 24 40	 mov	 QWORD PTR pfn$[rsp], rax
$LN3@PyEnableRe:

; 1664 :     if (!pfn) {

  00086	48 83 7c 24 40
	00		 cmp	 QWORD PTR pfn$[rsp], 0
  0008c	75 17		 jne	 SHORT $LN2@PyEnableRe

; 1665 :         PyErr_SetString(PyExc_NotImplementedError,
; 1666 :                         "not implemented on this platform");

  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@ODEKPPJP@not?5implemented?5on?5this?5platform@
  00095	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0009c	e8 00 00 00 00	 call	 PyErr_SetString

; 1667 :         return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	eb 46		 jmp	 SHORT $LN6@PyEnableRe
$LN2@PyEnableRe:

; 1668 :     }
; 1669 :     Py_BEGIN_ALLOW_THREADS

  000a5	e8 00 00 00 00	 call	 PyEval_SaveThread
  000aa	48 89 44 24 48	 mov	 QWORD PTR _save$121488[rsp], rax

; 1670 :     rc = (*pfn)(hKey);

  000af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hKey$[rsp]
  000b4	ff 54 24 40	 call	 QWORD PTR pfn$[rsp]
  000b8	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1671 :     Py_END_ALLOW_THREADS

  000bc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _save$121488[rsp]
  000c1	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1672 :     if (rc != ERROR_SUCCESS)

  000c6	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000cb	74 0b		 je	 SHORT $LN1@PyEnableRe

; 1673 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1674 :                                                    "RegEnableReflectionKey");

  000cd	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  000d1	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000d6	eb 13		 jmp	 SHORT $LN6@PyEnableRe
$LN1@PyEnableRe:

; 1675 :     Py_INCREF(Py_None);

  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000df	e8 00 00 00 00	 call	 _Py_IncRef

; 1676 :     return Py_None;

  000e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN6@PyEnableRe:

; 1677 : }

  000eb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ef	c3		 ret	 0
PyEnableReflectionKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@DOLEDKPN@RegQueryReflectionKey?$AA@	; `string'
PUBLIC	??_C@_0BF@KPOBMONN@O?3QueryReflectionKey?$AA@	; `string'
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyQueryReflectionKey DD imagerel PyQueryReflectionKey
	DD	imagerel PyQueryReflectionKey+235
	DD	imagerel $unwind$PyQueryReflectionKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyQueryReflectionKey DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0BG@DOLEDKPN@RegQueryReflectionKey?$AA@
CONST	SEGMENT
??_C@_0BG@DOLEDKPN@RegQueryReflectionKey?$AA@ DB 'RegQueryReflectionKey', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KPOBMONN@O?3QueryReflectionKey?$AA@
CONST	SEGMENT
??_C@_0BF@KPOBMONN@O?3QueryReflectionKey?$AA@ DB 'O:QueryReflectionKey', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyQueryReflectionKey
_TEXT	SEGMENT
rc$ = 32
hKey$ = 40
hMod$ = 48
obKey$ = 56
result$ = 64
pfn$ = 72
_save$121517 = 80
self$ = 112
args$ = 120
PyQueryReflectionKey PROC				; COMDAT

; 1681 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1682 :     HKEY hKey;
; 1683 :     PyObject *obKey;
; 1684 :     HMODULE hMod;
; 1685 :     typedef LONG (WINAPI *RQRKFunc)(HKEY, BOOL *);
; 1686 :     RQRKFunc pfn = NULL;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR pfn$[rsp], 0

; 1687 :     BOOL result;
; 1688 :     LONG rc;
; 1689 : 
; 1690 :     if (!PyArg_ParseTuple(args, "O:QueryReflectionKey", &obKey))

  00017	4c 8d 44 24 38	 lea	 r8, QWORD PTR obKey$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@KPOBMONN@O?3QueryReflectionKey?$AA@
  00023	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN5@PyQueryRef

; 1691 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 ae 00 00 00	 jmp	 $LN6@PyQueryRef
$LN5@PyQueryRef:

; 1692 :     if (!PyHKEY_AsHKEY(obKey, &hKey, FALSE))

  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 8d 54 24 28	 lea	 rdx, QWORD PTR hKey$[rsp]
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obKey$[rsp]
  00045	e8 00 00 00 00	 call	 PyHKEY_AsHKEY
  0004a	85 c0		 test	 eax, eax
  0004c	75 07		 jne	 SHORT $LN4@PyQueryRef

; 1693 :         return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 91 00 00 00	 jmp	 $LN6@PyQueryRef
$LN4@PyQueryRef:

; 1694 : 
; 1695 :     /* Only available on 64bit platforms, so we must load it
; 1696 :        dynamically.*/
; 1697 :     hMod = GetModuleHandleW(L"advapi32.dll");

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@JHLNAEJL@?$AAa?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleW
  00062	48 89 44 24 30	 mov	 QWORD PTR hMod$[rsp], rax

; 1698 :     if (hMod)

  00067	48 83 7c 24 30
	00		 cmp	 QWORD PTR hMod$[rsp], 0
  0006d	74 17		 je	 SHORT $LN3@PyQueryRef

; 1699 :         pfn = (RQRKFunc)GetProcAddress(hMod,
; 1700 :                                        "RegQueryReflectionKey");

  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@DOLEDKPN@RegQueryReflectionKey?$AA@
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hMod$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00081	48 89 44 24 48	 mov	 QWORD PTR pfn$[rsp], rax
$LN3@PyQueryRef:

; 1701 :     if (!pfn) {

  00086	48 83 7c 24 48
	00		 cmp	 QWORD PTR pfn$[rsp], 0
  0008c	75 17		 jne	 SHORT $LN2@PyQueryRef

; 1702 :         PyErr_SetString(PyExc_NotImplementedError,
; 1703 :                         "not implemented on this platform");

  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@ODEKPPJP@not?5implemented?5on?5this?5platform@
  00095	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0009c	e8 00 00 00 00	 call	 PyErr_SetString

; 1704 :         return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	eb 41		 jmp	 SHORT $LN6@PyQueryRef
$LN2@PyQueryRef:

; 1705 :     }
; 1706 :     Py_BEGIN_ALLOW_THREADS

  000a5	e8 00 00 00 00	 call	 PyEval_SaveThread
  000aa	48 89 44 24 50	 mov	 QWORD PTR _save$121517[rsp], rax

; 1707 :     rc = (*pfn)(hKey, &result);

  000af	48 8d 54 24 40	 lea	 rdx, QWORD PTR result$[rsp]
  000b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hKey$[rsp]
  000b9	ff 54 24 48	 call	 QWORD PTR pfn$[rsp]
  000bd	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1708 :     Py_END_ALLOW_THREADS

  000c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _save$121517[rsp]
  000c6	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1709 :     if (rc != ERROR_SUCCESS)

  000cb	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000d0	74 0b		 je	 SHORT $LN1@PyQueryRef

; 1710 :         return PyErr_SetFromWindowsErrWithFunction(rc,
; 1711 :                                                    "RegQueryReflectionKey");

  000d2	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  000d6	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000db	eb 09		 jmp	 SHORT $LN6@PyQueryRef
$LN1@PyQueryRef:

; 1712 :     return PyBool_FromLong(result);

  000dd	8b 4c 24 40	 mov	 ecx, DWORD PTR result$[rsp]
  000e1	e8 00 00 00 00	 call	 PyBool_FromLong
$LN6@PyQueryRef:

; 1713 : }

  000e6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ea	c3		 ret	 0
PyQueryReflectionKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@GKOINNIK@REG_RESOURCE_REQUIREMENTS_LIST?$AA@ ; `string'
PUBLIC	??_C@_0BN@KMFEBHNF@REG_FULL_RESOURCE_DESCRIPTOR?$AA@ ; `string'
PUBLIC	??_C@_0BC@EFKADEAE@REG_RESOURCE_LIST?$AA@	; `string'
PUBLIC	??_C@_0N@EIHNGGOL@REG_MULTI_SZ?$AA@		; `string'
PUBLIC	??_C@_08EKMNCLAG@REG_LINK?$AA@			; `string'
PUBLIC	??_C@_0BF@EDNOFOLE@REG_DWORD_BIG_ENDIAN?$AA@	; `string'
PUBLIC	??_C@_0BI@MOFBPOOP@REG_DWORD_LITTLE_ENDIAN?$AA@	; `string'
PUBLIC	??_C@_09OFPELGAL@REG_DWORD?$AA@			; `string'
PUBLIC	??_C@_0L@MBCFJDPB@REG_BINARY?$AA@		; `string'
PUBLIC	??_C@_0O@MEJMNBPK@REG_EXPAND_SZ?$AA@		; `string'
PUBLIC	??_C@_06NOFPPNFK@REG_SZ?$AA@			; `string'
PUBLIC	??_C@_08ILOFAKDE@REG_NONE?$AA@			; `string'
PUBLIC	??_C@_0BI@OAGFGNBM@REG_LEGAL_CHANGE_FILTER?$AA@	; `string'
PUBLIC	??_C@_0BL@DJJMNICH@REG_NOTIFY_CHANGE_SECURITY?$AA@ ; `string'
PUBLIC	??_C@_0BL@NFDNAFG@REG_NOTIFY_CHANGE_LAST_SET?$AA@ ; `string'
PUBLIC	??_C@_0BN@IJIMOIEE@REG_NOTIFY_CHANGE_ATTRIBUTES?$AA@ ; `string'
PUBLIC	??_C@_0BH@HEOAPJFK@REG_NOTIFY_CHANGE_NAME?$AA@	; `string'
PUBLIC	??_C@_0BC@MMHJFPCD@REG_NO_LAZY_FLUSH?$AA@	; `string'
PUBLIC	??_C@_0BB@DAEDFLMD@REG_REFRESH_HIVE?$AA@	; `string'
PUBLIC	??_C@_0BI@HJHMBAFJ@REG_WHOLE_HIVE_VOLATILE?$AA@	; `string'
PUBLIC	??_C@_0BI@LPFPOFMF@REG_OPENED_EXISTING_KEY?$AA@	; `string'
PUBLIC	??_C@_0BE@LNMPGKOD@REG_CREATED_NEW_KEY?$AA@	; `string'
PUBLIC	??_C@_0BB@OJFLAAHK@REG_LEGAL_OPTION?$AA@	; `string'
PUBLIC	??_C@_0BF@JLFBEHG@REG_OPTION_OPEN_LINK?$AA@	; `string'
PUBLIC	??_C@_0BK@JJEPBCEJ@REG_OPTION_BACKUP_RESTORE?$AA@ ; `string'
PUBLIC	??_C@_0BH@EFFNCNMF@REG_OPTION_CREATE_LINK?$AA@	; `string'
PUBLIC	??_C@_0BE@IGFBDPLM@REG_OPTION_VOLATILE?$AA@	; `string'
PUBLIC	??_C@_0BI@PMOOLGON@REG_OPTION_NON_VOLATILE?$AA@	; `string'
PUBLIC	??_C@_0BE@NBIKGEOO@REG_OPTION_RESERVED?$AA@	; `string'
PUBLIC	??_C@_0BA@OOKCCMHH@KEY_WOW64_32KEY?$AA@		; `string'
PUBLIC	??_C@_0BA@DBCPEIGE@KEY_WOW64_64KEY?$AA@		; `string'
PUBLIC	??_C@_0P@DJGMGCHM@KEY_ALL_ACCESS?$AA@		; `string'
PUBLIC	??_C@_0M@KBMHKMEF@KEY_EXECUTE?$AA@		; `string'
PUBLIC	??_C@_09CCCBNCFK@KEY_WRITE?$AA@			; `string'
PUBLIC	??_C@_08GEINPFBG@KEY_READ?$AA@			; `string'
PUBLIC	??_C@_0BA@MHHOCJPM@KEY_CREATE_LINK?$AA@		; `string'
PUBLIC	??_C@_0L@JFKONFFF@KEY_NOTIFY?$AA@		; `string'
PUBLIC	??_C@_0BH@BMBFGKMC@KEY_ENUMERATE_SUB_KEYS?$AA@	; `string'
PUBLIC	??_C@_0BD@PJFPBLKN@KEY_CREATE_SUB_KEY?$AA@	; `string'
PUBLIC	??_C@_0O@IBNLBEAP@KEY_SET_VALUE?$AA@		; `string'
PUBLIC	??_C@_0BA@KFDBODKN@KEY_QUERY_VALUE?$AA@		; `string'
PUBLIC	??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@		; `string'
PUBLIC	??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@	; `string'
PUBLIC	??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@	; `string'
PUBLIC	??_C@_0L@OEMMANAM@HKEY_USERS?$AA@		; `string'
PUBLIC	??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@	; `string'
PUBLIC	??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@	; `string'
PUBLIC	??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@	; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_08KCCGOGLL@HKEYType?$AA@			; `string'
PUBLIC	PyInit_winreg
EXTRN	PyExc_WindowsError:QWORD
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyType_Ready:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_winreg DD imagerel $LN7
	DD	imagerel $LN7+1299
	DD	imagerel $unwind$PyInit_winreg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_winreg DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BP@GKOINNIK@REG_RESOURCE_REQUIREMENTS_LIST?$AA@
CONST	SEGMENT
??_C@_0BP@GKOINNIK@REG_RESOURCE_REQUIREMENTS_LIST?$AA@ DB 'REG_RESOURCE_R'
	DB	'EQUIREMENTS_LIST', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KMFEBHNF@REG_FULL_RESOURCE_DESCRIPTOR?$AA@
CONST	SEGMENT
??_C@_0BN@KMFEBHNF@REG_FULL_RESOURCE_DESCRIPTOR?$AA@ DB 'REG_FULL_RESOURC'
	DB	'E_DESCRIPTOR', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EFKADEAE@REG_RESOURCE_LIST?$AA@
CONST	SEGMENT
??_C@_0BC@EFKADEAE@REG_RESOURCE_LIST?$AA@ DB 'REG_RESOURCE_LIST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EIHNGGOL@REG_MULTI_SZ?$AA@
CONST	SEGMENT
??_C@_0N@EIHNGGOL@REG_MULTI_SZ?$AA@ DB 'REG_MULTI_SZ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EKMNCLAG@REG_LINK?$AA@
CONST	SEGMENT
??_C@_08EKMNCLAG@REG_LINK?$AA@ DB 'REG_LINK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EDNOFOLE@REG_DWORD_BIG_ENDIAN?$AA@
CONST	SEGMENT
??_C@_0BF@EDNOFOLE@REG_DWORD_BIG_ENDIAN?$AA@ DB 'REG_DWORD_BIG_ENDIAN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MOFBPOOP@REG_DWORD_LITTLE_ENDIAN?$AA@
CONST	SEGMENT
??_C@_0BI@MOFBPOOP@REG_DWORD_LITTLE_ENDIAN?$AA@ DB 'REG_DWORD_LITTLE_ENDI'
	DB	'AN', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09OFPELGAL@REG_DWORD?$AA@
CONST	SEGMENT
??_C@_09OFPELGAL@REG_DWORD?$AA@ DB 'REG_DWORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MBCFJDPB@REG_BINARY?$AA@
CONST	SEGMENT
??_C@_0L@MBCFJDPB@REG_BINARY?$AA@ DB 'REG_BINARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEJMNBPK@REG_EXPAND_SZ?$AA@
CONST	SEGMENT
??_C@_0O@MEJMNBPK@REG_EXPAND_SZ?$AA@ DB 'REG_EXPAND_SZ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOFPPNFK@REG_SZ?$AA@
CONST	SEGMENT
??_C@_06NOFPPNFK@REG_SZ?$AA@ DB 'REG_SZ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILOFAKDE@REG_NONE?$AA@
CONST	SEGMENT
??_C@_08ILOFAKDE@REG_NONE?$AA@ DB 'REG_NONE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OAGFGNBM@REG_LEGAL_CHANGE_FILTER?$AA@
CONST	SEGMENT
??_C@_0BI@OAGFGNBM@REG_LEGAL_CHANGE_FILTER?$AA@ DB 'REG_LEGAL_CHANGE_FILT'
	DB	'ER', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DJJMNICH@REG_NOTIFY_CHANGE_SECURITY?$AA@
CONST	SEGMENT
??_C@_0BL@DJJMNICH@REG_NOTIFY_CHANGE_SECURITY?$AA@ DB 'REG_NOTIFY_CHANGE_'
	DB	'SECURITY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NFDNAFG@REG_NOTIFY_CHANGE_LAST_SET?$AA@
CONST	SEGMENT
??_C@_0BL@NFDNAFG@REG_NOTIFY_CHANGE_LAST_SET?$AA@ DB 'REG_NOTIFY_CHANGE_L'
	DB	'AST_SET', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IJIMOIEE@REG_NOTIFY_CHANGE_ATTRIBUTES?$AA@
CONST	SEGMENT
??_C@_0BN@IJIMOIEE@REG_NOTIFY_CHANGE_ATTRIBUTES?$AA@ DB 'REG_NOTIFY_CHANG'
	DB	'E_ATTRIBUTES', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HEOAPJFK@REG_NOTIFY_CHANGE_NAME?$AA@
CONST	SEGMENT
??_C@_0BH@HEOAPJFK@REG_NOTIFY_CHANGE_NAME?$AA@ DB 'REG_NOTIFY_CHANGE_NAME'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MMHJFPCD@REG_NO_LAZY_FLUSH?$AA@
CONST	SEGMENT
??_C@_0BC@MMHJFPCD@REG_NO_LAZY_FLUSH?$AA@ DB 'REG_NO_LAZY_FLUSH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DAEDFLMD@REG_REFRESH_HIVE?$AA@
CONST	SEGMENT
??_C@_0BB@DAEDFLMD@REG_REFRESH_HIVE?$AA@ DB 'REG_REFRESH_HIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HJHMBAFJ@REG_WHOLE_HIVE_VOLATILE?$AA@
CONST	SEGMENT
??_C@_0BI@HJHMBAFJ@REG_WHOLE_HIVE_VOLATILE?$AA@ DB 'REG_WHOLE_HIVE_VOLATI'
	DB	'LE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LPFPOFMF@REG_OPENED_EXISTING_KEY?$AA@
CONST	SEGMENT
??_C@_0BI@LPFPOFMF@REG_OPENED_EXISTING_KEY?$AA@ DB 'REG_OPENED_EXISTING_K'
	DB	'EY', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LNMPGKOD@REG_CREATED_NEW_KEY?$AA@
CONST	SEGMENT
??_C@_0BE@LNMPGKOD@REG_CREATED_NEW_KEY?$AA@ DB 'REG_CREATED_NEW_KEY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OJFLAAHK@REG_LEGAL_OPTION?$AA@
CONST	SEGMENT
??_C@_0BB@OJFLAAHK@REG_LEGAL_OPTION?$AA@ DB 'REG_LEGAL_OPTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JLFBEHG@REG_OPTION_OPEN_LINK?$AA@
CONST	SEGMENT
??_C@_0BF@JLFBEHG@REG_OPTION_OPEN_LINK?$AA@ DB 'REG_OPTION_OPEN_LINK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JJEPBCEJ@REG_OPTION_BACKUP_RESTORE?$AA@
CONST	SEGMENT
??_C@_0BK@JJEPBCEJ@REG_OPTION_BACKUP_RESTORE?$AA@ DB 'REG_OPTION_BACKUP_R'
	DB	'ESTORE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EFFNCNMF@REG_OPTION_CREATE_LINK?$AA@
CONST	SEGMENT
??_C@_0BH@EFFNCNMF@REG_OPTION_CREATE_LINK?$AA@ DB 'REG_OPTION_CREATE_LINK'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGFBDPLM@REG_OPTION_VOLATILE?$AA@
CONST	SEGMENT
??_C@_0BE@IGFBDPLM@REG_OPTION_VOLATILE?$AA@ DB 'REG_OPTION_VOLATILE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PMOOLGON@REG_OPTION_NON_VOLATILE?$AA@
CONST	SEGMENT
??_C@_0BI@PMOOLGON@REG_OPTION_NON_VOLATILE?$AA@ DB 'REG_OPTION_NON_VOLATI'
	DB	'LE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NBIKGEOO@REG_OPTION_RESERVED?$AA@
CONST	SEGMENT
??_C@_0BE@NBIKGEOO@REG_OPTION_RESERVED?$AA@ DB 'REG_OPTION_RESERVED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OOKCCMHH@KEY_WOW64_32KEY?$AA@
CONST	SEGMENT
??_C@_0BA@OOKCCMHH@KEY_WOW64_32KEY?$AA@ DB 'KEY_WOW64_32KEY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DBCPEIGE@KEY_WOW64_64KEY?$AA@
CONST	SEGMENT
??_C@_0BA@DBCPEIGE@KEY_WOW64_64KEY?$AA@ DB 'KEY_WOW64_64KEY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DJGMGCHM@KEY_ALL_ACCESS?$AA@
CONST	SEGMENT
??_C@_0P@DJGMGCHM@KEY_ALL_ACCESS?$AA@ DB 'KEY_ALL_ACCESS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KBMHKMEF@KEY_EXECUTE?$AA@
CONST	SEGMENT
??_C@_0M@KBMHKMEF@KEY_EXECUTE?$AA@ DB 'KEY_EXECUTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CCCBNCFK@KEY_WRITE?$AA@
CONST	SEGMENT
??_C@_09CCCBNCFK@KEY_WRITE?$AA@ DB 'KEY_WRITE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GEINPFBG@KEY_READ?$AA@
CONST	SEGMENT
??_C@_08GEINPFBG@KEY_READ?$AA@ DB 'KEY_READ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MHHOCJPM@KEY_CREATE_LINK?$AA@
CONST	SEGMENT
??_C@_0BA@MHHOCJPM@KEY_CREATE_LINK?$AA@ DB 'KEY_CREATE_LINK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JFKONFFF@KEY_NOTIFY?$AA@
CONST	SEGMENT
??_C@_0L@JFKONFFF@KEY_NOTIFY?$AA@ DB 'KEY_NOTIFY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BMBFGKMC@KEY_ENUMERATE_SUB_KEYS?$AA@
CONST	SEGMENT
??_C@_0BH@BMBFGKMC@KEY_ENUMERATE_SUB_KEYS?$AA@ DB 'KEY_ENUMERATE_SUB_KEYS'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJFPBLKN@KEY_CREATE_SUB_KEY?$AA@
CONST	SEGMENT
??_C@_0BD@PJFPBLKN@KEY_CREATE_SUB_KEY?$AA@ DB 'KEY_CREATE_SUB_KEY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IBNLBEAP@KEY_SET_VALUE?$AA@
CONST	SEGMENT
??_C@_0O@IBNLBEAP@KEY_SET_VALUE?$AA@ DB 'KEY_SET_VALUE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KFDBODKN@KEY_QUERY_VALUE?$AA@
CONST	SEGMENT
??_C@_0BA@KFDBODKN@KEY_QUERY_VALUE?$AA@ DB 'KEY_QUERY_VALUE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@
CONST	SEGMENT
??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@ DB 'HKEY_DYN_DATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@
CONST	SEGMENT
??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@ DB 'HKEY_CURRENT_CONFIG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@
CONST	SEGMENT
??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@ DB 'HKEY_PERFORMANCE_DATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OEMMANAM@HKEY_USERS?$AA@
CONST	SEGMENT
??_C@_0L@OEMMANAM@HKEY_USERS?$AA@ DB 'HKEY_USERS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@
CONST	SEGMENT
??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@ DB 'HKEY_LOCAL_MACHINE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@
CONST	SEGMENT
??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@ DB 'HKEY_CURRENT_USER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@
CONST	SEGMENT
??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@ DB 'HKEY_CLASSES_ROOT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCCGOGLL@HKEYType?$AA@
CONST	SEGMENT
??_C@_08KCCGOGLL@HKEYType?$AA@ DB 'HKEYType', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit_winreg
_TEXT	SEGMENT
d$ = 32
m$ = 40
PyInit_winreg PROC					; COMDAT

; 1783 : {

$LN7:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1784 :     PyObject *m, *d;
; 1785 :     m = PyModule_Create(&winregmodule);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:winregmodule
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 28	 mov	 QWORD PTR m$[rsp], rax

; 1786 :     if (m == NULL)

  0001a	48 83 7c 24 28
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	75 07		 jne	 SHORT $LN4@PyInit_win

; 1787 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 e5 04 00 00	 jmp	 $LN5@PyInit_win
$LN4@PyInit_win:

; 1788 :     d = PyModule_GetDict(m);

  00029	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  0002e	e8 00 00 00 00	 call	 PyModule_GetDict
  00033	48 89 44 24 20	 mov	 QWORD PTR d$[rsp], rax

; 1789 :     PyHKEY_Type.tp_doc = PyHKEY_doc;

  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyHKEY_doc
  0003f	48 89 05 08 01
	00 00		 mov	 QWORD PTR PyHKEY_Type+264, rax

; 1790 :     if (PyType_Ready(&PyHKEY_Type) < 0)

  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyHKEY_Type
  0004d	e8 00 00 00 00	 call	 PyType_Ready
  00052	85 c0		 test	 eax, eax
  00054	7d 07		 jge	 SHORT $LN3@PyInit_win

; 1791 :         return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	e9 b1 04 00 00	 jmp	 $LN5@PyInit_win
$LN3@PyInit_win:

; 1792 :     Py_INCREF(&PyHKEY_Type);

  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyHKEY_Type
  00064	e8 00 00 00 00	 call	 _Py_IncRef

; 1793 :     if (PyDict_SetItemString(d, "HKEYType",
; 1794 :                              (PyObject *)&PyHKEY_Type) != 0)

  00069	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyHKEY_Type
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KCCGOGLL@HKEYType?$AA@
  00077	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0007c	e8 00 00 00 00	 call	 PyDict_SetItemString
  00081	85 c0		 test	 eax, eax
  00083	74 07		 je	 SHORT $LN2@PyInit_win

; 1795 :         return NULL;

  00085	33 c0		 xor	 eax, eax
  00087	e9 82 04 00 00	 jmp	 $LN5@PyInit_win
$LN2@PyInit_win:

; 1796 :     Py_INCREF(PyExc_WindowsError);

  0008c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_WindowsError
  00093	e8 00 00 00 00	 call	 _Py_IncRef

; 1797 :     if (PyDict_SetItemString(d, "error",
; 1798 :                              PyExc_WindowsError) != 0)

  00098	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PyExc_WindowsError
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  000a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  000ab	e8 00 00 00 00	 call	 PyDict_SetItemString
  000b0	85 c0		 test	 eax, eax
  000b2	74 07		 je	 SHORT $LN1@PyInit_win

; 1799 :         return NULL;

  000b4	33 c0		 xor	 eax, eax
  000b6	e9 53 04 00 00	 jmp	 $LN5@PyInit_win
$LN1@PyInit_win:

; 1800 : 
; 1801 :     /* Add the relevant constants */
; 1802 :     ADD_KEY(HKEY_CLASSES_ROOT);

  000bb	49 c7 c0 00 00
	00 80		 mov	 r8, -2147483648		; ffffffff80000000H
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@
  000c9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  000ce	e8 00 00 00 00	 call	 inskey

; 1803 :     ADD_KEY(HKEY_CURRENT_USER);

  000d3	49 c7 c0 01 00
	00 80		 mov	 r8, -2147483647		; ffffffff80000001H
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@
  000e1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  000e6	e8 00 00 00 00	 call	 inskey

; 1804 :     ADD_KEY(HKEY_LOCAL_MACHINE);

  000eb	49 c7 c0 02 00
	00 80		 mov	 r8, -2147483646		; ffffffff80000002H
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@
  000f9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  000fe	e8 00 00 00 00	 call	 inskey

; 1805 :     ADD_KEY(HKEY_USERS);

  00103	49 c7 c0 03 00
	00 80		 mov	 r8, -2147483645		; ffffffff80000003H
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@OEMMANAM@HKEY_USERS?$AA@
  00111	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00116	e8 00 00 00 00	 call	 inskey

; 1806 :     ADD_KEY(HKEY_PERFORMANCE_DATA);

  0011b	49 c7 c0 04 00
	00 80		 mov	 r8, -2147483644		; ffffffff80000004H
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@
  00129	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0012e	e8 00 00 00 00	 call	 inskey

; 1807 : #ifdef HKEY_CURRENT_CONFIG
; 1808 :     ADD_KEY(HKEY_CURRENT_CONFIG);

  00133	49 c7 c0 05 00
	00 80		 mov	 r8, -2147483643		; ffffffff80000005H
  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@
  00141	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00146	e8 00 00 00 00	 call	 inskey

; 1809 : #endif
; 1810 : #ifdef HKEY_DYN_DATA
; 1811 :     ADD_KEY(HKEY_DYN_DATA);

  0014b	49 c7 c0 06 00
	00 80		 mov	 r8, -2147483642		; ffffffff80000006H
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@
  00159	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0015e	e8 00 00 00 00	 call	 inskey

; 1812 : #endif
; 1813 :     ADD_INT(KEY_QUERY_VALUE);

  00163	41 b8 01 00 00
	00		 mov	 r8d, 1
  00169	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@KFDBODKN@KEY_QUERY_VALUE?$AA@
  00170	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00175	e8 00 00 00 00	 call	 insint

; 1814 :     ADD_INT(KEY_SET_VALUE);

  0017a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00180	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@IBNLBEAP@KEY_SET_VALUE?$AA@
  00187	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0018c	e8 00 00 00 00	 call	 insint

; 1815 :     ADD_INT(KEY_CREATE_SUB_KEY);

  00191	41 b8 04 00 00
	00		 mov	 r8d, 4
  00197	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@PJFPBLKN@KEY_CREATE_SUB_KEY?$AA@
  0019e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  001a3	e8 00 00 00 00	 call	 insint

; 1816 :     ADD_INT(KEY_ENUMERATE_SUB_KEYS);

  001a8	41 b8 08 00 00
	00		 mov	 r8d, 8
  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@BMBFGKMC@KEY_ENUMERATE_SUB_KEYS?$AA@
  001b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  001ba	e8 00 00 00 00	 call	 insint

; 1817 :     ADD_INT(KEY_NOTIFY);

  001bf	41 b8 10 00 00
	00		 mov	 r8d, 16
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@JFKONFFF@KEY_NOTIFY?$AA@
  001cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  001d1	e8 00 00 00 00	 call	 insint

; 1818 :     ADD_INT(KEY_CREATE_LINK);

  001d6	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@MHHOCJPM@KEY_CREATE_LINK?$AA@
  001e3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  001e8	e8 00 00 00 00	 call	 insint

; 1819 :     ADD_INT(KEY_READ);

  001ed	41 b8 19 00 02
	00		 mov	 r8d, 131097		; 00020019H
  001f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08GEINPFBG@KEY_READ?$AA@
  001fa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  001ff	e8 00 00 00 00	 call	 insint

; 1820 :     ADD_INT(KEY_WRITE);

  00204	41 b8 06 00 02
	00		 mov	 r8d, 131078		; 00020006H
  0020a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09CCCBNCFK@KEY_WRITE?$AA@
  00211	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00216	e8 00 00 00 00	 call	 insint

; 1821 :     ADD_INT(KEY_EXECUTE);

  0021b	41 b8 19 00 02
	00		 mov	 r8d, 131097		; 00020019H
  00221	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@KBMHKMEF@KEY_EXECUTE?$AA@
  00228	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0022d	e8 00 00 00 00	 call	 insint

; 1822 :     ADD_INT(KEY_ALL_ACCESS);

  00232	41 b8 3f 00 0f
	00		 mov	 r8d, 983103		; 000f003fH
  00238	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DJGMGCHM@KEY_ALL_ACCESS?$AA@
  0023f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00244	e8 00 00 00 00	 call	 insint

; 1823 : #ifdef KEY_WOW64_64KEY
; 1824 :     ADD_INT(KEY_WOW64_64KEY);

  00249	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0024f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@DBCPEIGE@KEY_WOW64_64KEY?$AA@
  00256	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0025b	e8 00 00 00 00	 call	 insint

; 1825 : #endif
; 1826 : #ifdef KEY_WOW64_32KEY
; 1827 :     ADD_INT(KEY_WOW64_32KEY);

  00260	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00266	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@OOKCCMHH@KEY_WOW64_32KEY?$AA@
  0026d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00272	e8 00 00 00 00	 call	 insint

; 1828 : #endif
; 1829 :     ADD_INT(REG_OPTION_RESERVED);

  00277	45 33 c0	 xor	 r8d, r8d
  0027a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@NBIKGEOO@REG_OPTION_RESERVED?$AA@
  00281	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00286	e8 00 00 00 00	 call	 insint

; 1830 :     ADD_INT(REG_OPTION_NON_VOLATILE);

  0028b	45 33 c0	 xor	 r8d, r8d
  0028e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PMOOLGON@REG_OPTION_NON_VOLATILE?$AA@
  00295	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0029a	e8 00 00 00 00	 call	 insint

; 1831 :     ADD_INT(REG_OPTION_VOLATILE);

  0029f	41 b8 01 00 00
	00		 mov	 r8d, 1
  002a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@IGFBDPLM@REG_OPTION_VOLATILE?$AA@
  002ac	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  002b1	e8 00 00 00 00	 call	 insint

; 1832 :     ADD_INT(REG_OPTION_CREATE_LINK);

  002b6	41 b8 02 00 00
	00		 mov	 r8d, 2
  002bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@EFFNCNMF@REG_OPTION_CREATE_LINK?$AA@
  002c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  002c8	e8 00 00 00 00	 call	 insint

; 1833 :     ADD_INT(REG_OPTION_BACKUP_RESTORE);

  002cd	41 b8 04 00 00
	00		 mov	 r8d, 4
  002d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JJEPBCEJ@REG_OPTION_BACKUP_RESTORE?$AA@
  002da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  002df	e8 00 00 00 00	 call	 insint

; 1834 :     ADD_INT(REG_OPTION_OPEN_LINK);

  002e4	41 b8 08 00 00
	00		 mov	 r8d, 8
  002ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@JLFBEHG@REG_OPTION_OPEN_LINK?$AA@
  002f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  002f6	e8 00 00 00 00	 call	 insint

; 1835 :     ADD_INT(REG_LEGAL_OPTION);

  002fb	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00301	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@OJFLAAHK@REG_LEGAL_OPTION?$AA@
  00308	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0030d	e8 00 00 00 00	 call	 insint

; 1836 :     ADD_INT(REG_CREATED_NEW_KEY);

  00312	41 b8 01 00 00
	00		 mov	 r8d, 1
  00318	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@LNMPGKOD@REG_CREATED_NEW_KEY?$AA@
  0031f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00324	e8 00 00 00 00	 call	 insint

; 1837 :     ADD_INT(REG_OPENED_EXISTING_KEY);

  00329	41 b8 02 00 00
	00		 mov	 r8d, 2
  0032f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LPFPOFMF@REG_OPENED_EXISTING_KEY?$AA@
  00336	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0033b	e8 00 00 00 00	 call	 insint

; 1838 :     ADD_INT(REG_WHOLE_HIVE_VOLATILE);

  00340	41 b8 01 00 00
	00		 mov	 r8d, 1
  00346	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HJHMBAFJ@REG_WHOLE_HIVE_VOLATILE?$AA@
  0034d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00352	e8 00 00 00 00	 call	 insint

; 1839 :     ADD_INT(REG_REFRESH_HIVE);

  00357	41 b8 02 00 00
	00		 mov	 r8d, 2
  0035d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@DAEDFLMD@REG_REFRESH_HIVE?$AA@
  00364	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00369	e8 00 00 00 00	 call	 insint

; 1840 :     ADD_INT(REG_NO_LAZY_FLUSH);

  0036e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00374	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@MMHJFPCD@REG_NO_LAZY_FLUSH?$AA@
  0037b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00380	e8 00 00 00 00	 call	 insint

; 1841 :     ADD_INT(REG_NOTIFY_CHANGE_NAME);

  00385	41 b8 01 00 00
	00		 mov	 r8d, 1
  0038b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@HEOAPJFK@REG_NOTIFY_CHANGE_NAME?$AA@
  00392	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00397	e8 00 00 00 00	 call	 insint

; 1842 :     ADD_INT(REG_NOTIFY_CHANGE_ATTRIBUTES);

  0039c	41 b8 02 00 00
	00		 mov	 r8d, 2
  003a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@IJIMOIEE@REG_NOTIFY_CHANGE_ATTRIBUTES?$AA@
  003a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  003ae	e8 00 00 00 00	 call	 insint

; 1843 :     ADD_INT(REG_NOTIFY_CHANGE_LAST_SET);

  003b3	41 b8 04 00 00
	00		 mov	 r8d, 4
  003b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@NFDNAFG@REG_NOTIFY_CHANGE_LAST_SET?$AA@
  003c0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  003c5	e8 00 00 00 00	 call	 insint

; 1844 :     ADD_INT(REG_NOTIFY_CHANGE_SECURITY);

  003ca	41 b8 08 00 00
	00		 mov	 r8d, 8
  003d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJJMNICH@REG_NOTIFY_CHANGE_SECURITY?$AA@
  003d7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  003dc	e8 00 00 00 00	 call	 insint

; 1845 :     ADD_INT(REG_LEGAL_CHANGE_FILTER);

  003e1	41 b8 0f 00 00
	00		 mov	 r8d, 15
  003e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@OAGFGNBM@REG_LEGAL_CHANGE_FILTER?$AA@
  003ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  003f3	e8 00 00 00 00	 call	 insint

; 1846 :     ADD_INT(REG_NONE);

  003f8	45 33 c0	 xor	 r8d, r8d
  003fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08ILOFAKDE@REG_NONE?$AA@
  00402	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00407	e8 00 00 00 00	 call	 insint

; 1847 :     ADD_INT(REG_SZ);

  0040c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00412	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06NOFPPNFK@REG_SZ?$AA@
  00419	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0041e	e8 00 00 00 00	 call	 insint

; 1848 :     ADD_INT(REG_EXPAND_SZ);

  00423	41 b8 02 00 00
	00		 mov	 r8d, 2
  00429	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@MEJMNBPK@REG_EXPAND_SZ?$AA@
  00430	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00435	e8 00 00 00 00	 call	 insint

; 1849 :     ADD_INT(REG_BINARY);

  0043a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00440	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@MBCFJDPB@REG_BINARY?$AA@
  00447	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0044c	e8 00 00 00 00	 call	 insint

; 1850 :     ADD_INT(REG_DWORD);

  00451	41 b8 04 00 00
	00		 mov	 r8d, 4
  00457	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09OFPELGAL@REG_DWORD?$AA@
  0045e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00463	e8 00 00 00 00	 call	 insint

; 1851 :     ADD_INT(REG_DWORD_LITTLE_ENDIAN);

  00468	41 b8 04 00 00
	00		 mov	 r8d, 4
  0046e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@MOFBPOOP@REG_DWORD_LITTLE_ENDIAN?$AA@
  00475	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  0047a	e8 00 00 00 00	 call	 insint

; 1852 :     ADD_INT(REG_DWORD_BIG_ENDIAN);

  0047f	41 b8 05 00 00
	00		 mov	 r8d, 5
  00485	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@EDNOFOLE@REG_DWORD_BIG_ENDIAN?$AA@
  0048c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00491	e8 00 00 00 00	 call	 insint

; 1853 :     ADD_INT(REG_LINK);

  00496	41 b8 06 00 00
	00		 mov	 r8d, 6
  0049c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08EKMNCLAG@REG_LINK?$AA@
  004a3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  004a8	e8 00 00 00 00	 call	 insint

; 1854 :     ADD_INT(REG_MULTI_SZ);

  004ad	41 b8 07 00 00
	00		 mov	 r8d, 7
  004b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EIHNGGOL@REG_MULTI_SZ?$AA@
  004ba	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  004bf	e8 00 00 00 00	 call	 insint

; 1855 :     ADD_INT(REG_RESOURCE_LIST);

  004c4	41 b8 08 00 00
	00		 mov	 r8d, 8
  004ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EFKADEAE@REG_RESOURCE_LIST?$AA@
  004d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  004d6	e8 00 00 00 00	 call	 insint

; 1856 :     ADD_INT(REG_FULL_RESOURCE_DESCRIPTOR);

  004db	41 b8 09 00 00
	00		 mov	 r8d, 9
  004e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMFEBHNF@REG_FULL_RESOURCE_DESCRIPTOR?$AA@
  004e8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  004ed	e8 00 00 00 00	 call	 insint

; 1857 :     ADD_INT(REG_RESOURCE_REQUIREMENTS_LIST);

  004f2	41 b8 0a 00 00
	00		 mov	 r8d, 10
  004f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@GKOINNIK@REG_RESOURCE_REQUIREMENTS_LIST?$AA@
  004ff	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00504	e8 00 00 00 00	 call	 insint

; 1858 :     return m;

  00509	48 8b 44 24 28	 mov	 rax, QWORD PTR m$[rsp]
$LN5@PyInit_win:

; 1859 : }

  0050e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00512	c3		 ret	 0
PyInit_winreg ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$insint DD imagerel insint
	DD	imagerel insint+99
	DD	imagerel $unwind$insint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insint DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT insint
_TEXT	SEGMENT
v$ = 32
d$ = 64
name$ = 72
value$ = 80
insint	PROC						; COMDAT

; 1749 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1750 :     PyObject *v = PyLong_FromLong(value);

  00013	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  00017	e8 00 00 00 00	 call	 PyLong_FromLong
  0001c	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1751 :     if (!v || PyDict_SetItemString(d, name, v))

  00021	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00027	74 18		 je	 SHORT $LN5@insint
  00029	4c 8b 44 24 20	 mov	 r8, QWORD PTR v$[rsp]
  0002e	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00038	e8 00 00 00 00	 call	 PyDict_SetItemString
  0003d	85 c0		 test	 eax, eax
  0003f	74 05		 je	 SHORT $LN6@insint
$LN5@insint:

; 1752 :         PyErr_Clear();

  00041	e8 00 00 00 00	 call	 PyErr_Clear
$LN6@insint:
$LN4@insint:

; 1753 :     Py_XDECREF(v);

  00046	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  0004c	74 0a		 je	 SHORT $LN1@insint
  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00053	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@insint:
  00058	33 c0		 xor	 eax, eax
  0005a	85 c0		 test	 eax, eax
  0005c	75 e8		 jne	 SHORT $LN4@insint

; 1754 : }

  0005e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00062	c3		 ret	 0
insint	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inskey DD imagerel inskey
	DD	imagerel inskey+100
	DD	imagerel $unwind$inskey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inskey DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inskey
_TEXT	SEGMENT
v$ = 32
d$ = 64
name$ = 72
key$ = 80
inskey	PROC						; COMDAT

; 1760 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1761 :     PyObject *v = PyLong_FromVoidPtr(key);

  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR key$[rsp]
  00018	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  0001d	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1762 :     if (!v || PyDict_SetItemString(d, name, v))

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00028	74 18		 je	 SHORT $LN5@inskey
  0002a	4c 8b 44 24 20	 mov	 r8, QWORD PTR v$[rsp]
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00039	e8 00 00 00 00	 call	 PyDict_SetItemString
  0003e	85 c0		 test	 eax, eax
  00040	74 05		 je	 SHORT $LN6@inskey
$LN5@inskey:

; 1763 :         PyErr_Clear();

  00042	e8 00 00 00 00	 call	 PyErr_Clear
$LN6@inskey:
$LN4@inskey:

; 1764 :     Py_XDECREF(v);

  00047	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  0004d	74 0a		 je	 SHORT $LN1@inskey
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00054	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@inskey:
  00059	33 c0		 xor	 eax, eax
  0005b	85 c0		 test	 eax, eax
  0005d	75 e8		 jne	 SHORT $LN4@inskey

; 1765 : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
inskey	ENDP
_TEXT	ENDS
END
