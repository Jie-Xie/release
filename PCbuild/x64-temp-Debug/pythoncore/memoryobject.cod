; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@NFBFFIOL@memoryview?$AA@		; `string'
PUBLIC	??_C@_08CMFIGCJD@__exit__?$AA@			; `string'
PUBLIC	??_C@_09OAJHKKGH@__enter__?$AA@			; `string'
PUBLIC	??_C@_04HJDBPPOC@cast?$AA@			; `string'
PUBLIC	??_C@_06IEBOCBAI@tolist?$AA@			; `string'
PUBLIC	??_C@_07NAJELLCK@tobytes?$AA@			; `string'
PUBLIC	??_C@_07EOGFDLKI@release?$AA@			; `string'
PUBLIC	??_C@_0L@MOJJBKDL@contiguous?$AA@		; `string'
PUBLIC	??_C@_0N@EKJDCNKL@f_contiguous?$AA@		; `string'
PUBLIC	??_C@_0N@FHLMJOLI@c_contiguous?$AA@		; `string'
PUBLIC	??_C@_0L@ELCNMNAH@suboffsets?$AA@		; `string'
PUBLIC	??_C@_07IMKHLIIB@strides?$AA@			; `string'
PUBLIC	??_C@_04DMMOEENP@ndim?$AA@			; `string'
PUBLIC	??_C@_08BFHIGMPA@itemsize?$AA@			; `string'
PUBLIC	??_C@_08JOKHDEJH@readonly?$AA@			; `string'
PUBLIC	??_C@_06KGLHCPOD@nbytes?$AA@			; `string'
PUBLIC	??_C@_03GJLPFLNF@obj?$AA@			; `string'
PUBLIC	??_C@_05KFCIHKGL@shape?$AA@			; `string'
PUBLIC	??_C@_06DLEPGFEF@format?$AA@			; `string'
PUBLIC	??_C@_06IEOJBDIK@object?$AA@			; `string'
PUBLIC	??_C@_0O@PLLNAAOP@managedbuffer?$AA@		; `string'
PUBLIC	_PyManagedBuffer_Type
PUBLIC	PyMemoryView_Type
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
;	COMDAT ??_C@_0L@NFBFFIOL@memoryview?$AA@
CONST	SEGMENT
??_C@_0L@NFBFFIOL@memoryview?$AA@ DB 'memoryview', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMFIGCJD@__exit__?$AA@
CONST	SEGMENT
??_C@_08CMFIGCJD@__exit__?$AA@ DB '__exit__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAJHKKGH@__enter__?$AA@
CONST	SEGMENT
??_C@_09OAJHKKGH@__enter__?$AA@ DB '__enter__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJDBPPOC@cast?$AA@
CONST	SEGMENT
??_C@_04HJDBPPOC@cast?$AA@ DB 'cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IEBOCBAI@tolist?$AA@
CONST	SEGMENT
??_C@_06IEBOCBAI@tolist?$AA@ DB 'tolist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NAJELLCK@tobytes?$AA@
CONST	SEGMENT
??_C@_07NAJELLCK@tobytes?$AA@ DB 'tobytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOGFDLKI@release?$AA@
CONST	SEGMENT
??_C@_07EOGFDLKI@release?$AA@ DB 'release', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MOJJBKDL@contiguous?$AA@
CONST	SEGMENT
??_C@_0L@MOJJBKDL@contiguous?$AA@ DB 'contiguous', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKJDCNKL@f_contiguous?$AA@
CONST	SEGMENT
??_C@_0N@EKJDCNKL@f_contiguous?$AA@ DB 'f_contiguous', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FHLMJOLI@c_contiguous?$AA@
CONST	SEGMENT
??_C@_0N@FHLMJOLI@c_contiguous?$AA@ DB 'c_contiguous', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ELCNMNAH@suboffsets?$AA@
CONST	SEGMENT
??_C@_0L@ELCNMNAH@suboffsets?$AA@ DB 'suboffsets', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMKHLIIB@strides?$AA@
CONST	SEGMENT
??_C@_07IMKHLIIB@strides?$AA@ DB 'strides', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DMMOEENP@ndim?$AA@
CONST	SEGMENT
??_C@_04DMMOEENP@ndim?$AA@ DB 'ndim', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BFHIGMPA@itemsize?$AA@
CONST	SEGMENT
??_C@_08BFHIGMPA@itemsize?$AA@ DB 'itemsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JOKHDEJH@readonly?$AA@
CONST	SEGMENT
??_C@_08JOKHDEJH@readonly?$AA@ DB 'readonly', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KGLHCPOD@nbytes?$AA@
CONST	SEGMENT
??_C@_06KGLHCPOD@nbytes?$AA@ DB 'nbytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJLPFLNF@obj?$AA@
CONST	SEGMENT
??_C@_03GJLPFLNF@obj?$AA@ DB 'obj', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFCIHKGL@shape?$AA@
CONST	SEGMENT
??_C@_05KFCIHKGL@shape?$AA@ DB 'shape', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLEPGFEF@format?$AA@
CONST	SEGMENT
??_C@_06DLEPGFEF@format?$AA@ DB 'format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IEOJBDIK@object?$AA@
CONST	SEGMENT
??_C@_06IEOJBDIK@object?$AA@ DB 'object', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_PyManagedBuffer_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@PLLNAAOP@managedbuffer?$AA@
	DQ	00000000000000c0H
	DQ	0000000000000000H
	DQ	FLAT:mbuf_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:mbuf_traverse
	DQ	FLAT:mbuf_clear
	ORG $+192
memory_doc DB	'memoryview(object)', 0aH, 0aH, 'Create a new memoryview '
	DB	'object which references the given object.', 00H
	ORG $+2
?kwlist@?1??memory_new@@9@9 DQ FLAT:??_C@_06IEOJBDIK@object?$AA@ ; `memory_new'::`2'::kwlist
	DQ	0000000000000000H
?kwlist@?1??memory_cast@@9@9 DQ FLAT:??_C@_06DLEPGFEF@format?$AA@ ; `memory_cast'::`2'::kwlist
	DQ	FLAT:??_C@_05KFCIHKGL@shape?$AA@
	DQ	0000000000000000H
memory_as_buffer DQ FLAT:memory_getbuf
	DQ	FLAT:memory_releasebuf
memory_as_mapping DQ FLAT:memory_length
	DQ	FLAT:memory_subscript
	DQ	FLAT:memory_ass_sub
	ORG $+8
memory_as_sequence DQ 0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:memory_item
	ORG $+48
memory_obj_doc DB 'The underlying object of the memoryview.', 00H
	ORG $+7
memory_nbytes_doc DB 'The amount of space in bytes that the array would u'
	DB	'se in', 0aH, ' a contiguous representation.', 00H
	ORG $+1
memory_readonly_doc DB 'A bool indicating whether the memory is read only'
	DB	'.', 00H
	ORG $+5
memory_itemsize_doc DB 'The size in bytes of each element of the memoryvi'
	DB	'ew.', 00H
	ORG $+11
memory_format_doc DB 'A string containing the format (in struct module st'
	DB	'yle)', 0aH, ' for each element in the view.', 00H
	ORG $+9
memory_ndim_doc DB 'An integer indicating how many dimensions of a multi-'
	DB	'dimensional', 0aH, ' array the memory represents.', 00H
	ORG $+1
memory_shape_doc DB 'A tuple of ndim integers giving the shape of the mem'
	DB	'ory', 0aH, ' as an N-dimensional array.', 00H
	ORG $+12
memory_strides_doc DB 'A tuple of ndim integers giving the size in bytes '
	DB	'to access', 0aH, ' each element for each dimension of the arr'
	DB	'ay.', 00H
	ORG $+5
memory_suboffsets_doc DB 'A tuple of integers used internally for PIL-sty'
	DB	'le arrays.', 00H
	ORG $+6
memory_c_contiguous_doc DB 'A bool indicating whether the memory is C con'
	DB	'tiguous.', 00H
	ORG $+2
memory_f_contiguous_doc DB 'A bool indicating whether the memory is Fortr'
	DB	'an contiguous.', 00H
	ORG $+4
memory_contiguous_doc DB 'A bool indicating whether the memory is contigu'
	DB	'ous.', 00H
	ORG $+4
memory_getsetlist DQ FLAT:??_C@_03GJLPFLNF@obj?$AA@
	DQ	FLAT:memory_obj_get
	DQ	0000000000000000H
	DQ	FLAT:memory_obj_doc
	ORG $+8
	DQ	FLAT:??_C@_06KGLHCPOD@nbytes?$AA@
	DQ	FLAT:memory_nbytes_get
	DQ	0000000000000000H
	DQ	FLAT:memory_nbytes_doc
	ORG $+8
	DQ	FLAT:??_C@_08JOKHDEJH@readonly?$AA@
	DQ	FLAT:memory_readonly_get
	DQ	0000000000000000H
	DQ	FLAT:memory_readonly_doc
	ORG $+8
	DQ	FLAT:??_C@_08BFHIGMPA@itemsize?$AA@
	DQ	FLAT:memory_itemsize_get
	DQ	0000000000000000H
	DQ	FLAT:memory_itemsize_doc
	ORG $+8
	DQ	FLAT:??_C@_06DLEPGFEF@format?$AA@
	DQ	FLAT:memory_format_get
	DQ	0000000000000000H
	DQ	FLAT:memory_format_doc
	ORG $+8
	DQ	FLAT:??_C@_04DMMOEENP@ndim?$AA@
	DQ	FLAT:memory_ndim_get
	DQ	0000000000000000H
	DQ	FLAT:memory_ndim_doc
	ORG $+8
	DQ	FLAT:??_C@_05KFCIHKGL@shape?$AA@
	DQ	FLAT:memory_shape_get
	DQ	0000000000000000H
	DQ	FLAT:memory_shape_doc
	ORG $+8
	DQ	FLAT:??_C@_07IMKHLIIB@strides?$AA@
	DQ	FLAT:memory_strides_get
	DQ	0000000000000000H
	DQ	FLAT:memory_strides_doc
	ORG $+8
	DQ	FLAT:??_C@_0L@ELCNMNAH@suboffsets?$AA@
	DQ	FLAT:memory_suboffsets_get
	DQ	0000000000000000H
	DQ	FLAT:memory_suboffsets_doc
	ORG $+8
	DQ	FLAT:??_C@_0N@FHLMJOLI@c_contiguous?$AA@
	DQ	FLAT:memory_c_contiguous
	DQ	0000000000000000H
	DQ	FLAT:memory_c_contiguous_doc
	ORG $+8
	DQ	FLAT:??_C@_0N@EKJDCNKL@f_contiguous?$AA@
	DQ	FLAT:memory_f_contiguous
	DQ	0000000000000000H
	DQ	FLAT:memory_f_contiguous_doc
	ORG $+8
	DQ	FLAT:??_C@_0L@MOJJBKDL@contiguous?$AA@
	DQ	FLAT:memory_contiguous
	DQ	0000000000000000H
	DQ	FLAT:memory_contiguous_doc
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	ORG $+8
memory_release_doc DB 'M.release() -> None', 0aH, 0aH, 'Release the under'
	DB	'lying buffer exposed by the memoryview object.', 00H
	ORG $+11
memory_tobytes_doc DB 'M.tobytes() -> bytes', 0aH, 0aH, 'Return the data '
	DB	'in the buffer as a byte string.', 00H
	ORG $+10
memory_tolist_doc DB 'M.tolist() -> list', 0aH, 0aH, 'Return the data in '
	DB	'the buffer as a list of elements.', 00H
	ORG $+7
memory_cast_doc DB 'M.cast(format[, shape]) -> memoryview', 0aH, 0aH, 'Ca'
	DB	'st a memoryview to a new format or shape.', 00H
	ORG $+13
memory_methods DQ FLAT:??_C@_07EOGFDLKI@release?$AA@
	DQ	FLAT:memory_release
	DD	04H
	ORG $+4
	DQ	FLAT:memory_release_doc
	DQ	FLAT:??_C@_07NAJELLCK@tobytes?$AA@
	DQ	FLAT:memory_tobytes
	DD	04H
	ORG $+4
	DQ	FLAT:memory_tobytes_doc
	DQ	FLAT:??_C@_06IEBOCBAI@tolist?$AA@
	DQ	FLAT:memory_tolist
	DD	04H
	ORG $+4
	DQ	FLAT:memory_tolist_doc
	DQ	FLAT:??_C@_04HJDBPPOC@cast?$AA@
	DQ	FLAT:memory_cast
	DD	03H
	ORG $+4
	DQ	FLAT:memory_cast_doc
	DQ	FLAT:??_C@_09OAJHKKGH@__enter__?$AA@
	DQ	FLAT:memory_enter
	DD	04H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_08CMFIGCJD@__exit__?$AA@
	DQ	FLAT:memory_exit
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyMemoryView_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0L@NFBFFIOL@memoryview?$AA@
	DQ	00000000000000f0H
	DQ	0000000000000008H
	DQ	FLAT:memory_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:memory_repr
	DQ	0000000000000000H
	DQ	FLAT:memory_as_sequence
	DQ	FLAT:memory_as_mapping
	DQ	FLAT:memory_hash
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	FLAT:memory_as_buffer
	DD	044000H
	ORG $+4
	DQ	FLAT:memory_doc
	DQ	FLAT:memory_traverse
	DQ	FLAT:memory_clear
	DQ	FLAT:memory_richcompare
	DQ	00000000000000e8H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:memory_methods
	DQ	0000000000000000H
	DQ	FLAT:memory_getsetlist
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:memory_new
	ORG $+72
_DATA	ENDS
;	COMDAT ??_C@_0O@PLLNAAOP@managedbuffer?$AA@
CONST	SEGMENT
??_C@_0O@PLLNAAOP@managedbuffer?$AA@ DB 'managedbuffer', 00H ; `string'
CONST	ENDS
PUBLIC	??_C@_1CG@OCBNCNJM@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyMem_Free:PROC
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\memoryobject.c
pdata	SEGMENT
$pdata$mbuf_dealloc DD imagerel mbuf_dealloc
	DD	imagerel mbuf_dealloc+106
	DD	imagerel $unwind$mbuf_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_dealloc DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1CG@OCBNCNJM@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@OCBNCNJM@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'e', 00H
	DB	'x', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, 's', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'm', 00H, 'e', 00H, 'm'
	DB	00H, 'o', 00H, 'r', 00H, 'y', 00H, 'o', 00H, 'b', 00H, 'j', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mbuf_dealloc
_TEXT	SEGMENT
self$ = 48
mbuf_dealloc PROC					; COMDAT

; 114  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 115  :     assert(self->exports == 0);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	74 1c		 je	 SHORT $LN4@mbuf_deall
  00015	41 b8 73 00 00
	00		 mov	 r8d, 115		; 00000073H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@OCBNCNJM@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	33 c0		 xor	 eax, eax
$LN4@mbuf_deall:

; 116  :     mbuf_release(self);

  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00036	e8 00 00 00 00	 call	 mbuf_release

; 117  :     if (self->flags&_Py_MANAGED_BUFFER_FREE_FORMAT)

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00040	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00043	83 e0 02	 and	 eax, 2
  00046	85 c0		 test	 eax, eax
  00048	74 11		 je	 SHORT $LN1@mbuf_deall

; 118  :         PyMem_Free(self->master.format);

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004f	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00056	e8 00 00 00 00	 call	 PyMem_Free
$LN1@mbuf_deall:

; 119  :     PyObject_GC_Del(self);

  0005b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00060	e8 00 00 00 00	 call	 PyObject_GC_Del

; 120  : }

  00065	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00069	c3		 ret	 0
mbuf_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ ; `string'
PUBLIC	??_C@_0N@FHOCOONF@mbuf_release?$AA@		; `string'
PUBLIC	??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@ ; `string'
EXTRN	PyBuffer_Release:PROC
EXTRN	_PyParallel_Guard:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_release DD imagerel mbuf_release
	DD	imagerel mbuf_release+309
	DD	imagerel $unwind$mbuf_release
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_release DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
CONST	SEGMENT
??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ DB 'g'
	DB	00H, '-', 00H, '>', 00H, 'g', 00H, 'c', 00H, '.', 00H, 'g', 00H
	DB	'c', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 's', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H, 'y', 00H
	DB	'G', 00H, 'C', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'S'
	DB	00H, '_', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H
	DB	'C', 00H, 'K', 00H, 'E', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FHOCOONF@mbuf_release?$AA@
CONST	SEGMENT
??_C@_0N@FHOCOONF@mbuf_release?$AA@ DB 'mbuf_release', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
CONST	SEGMENT
??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@ DB '..\Objects\mem'
	DB	'oryobject.c', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mbuf_release
_TEXT	SEGMENT
g$20335 = 48
tv85 = 56
self$ = 80
mbuf_release PROC					; COMDAT

; 99   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 100  :     if (self->flags&_Py_MANAGED_BUFFER_RELEASED)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00011	83 e0 01	 and	 eax, 1
  00014	85 c0		 test	 eax, eax
  00016	74 05		 je	 SHORT $LN5@mbuf_relea

; 101  :         return;

  00018	e9 13 01 00 00	 jmp	 $LN6@mbuf_relea
$LN5@mbuf_relea:

; 102  : 
; 103  :     /* NOTE: at this point self->exports can still be > 0 if this function
; 104  :        is called from mbuf_clear() to break up a reference cycle. */
; 105  :     self->flags |= _Py_MANAGED_BUFFER_RELEASED;

  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00022	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00025	83 c8 01	 or	 eax, 1
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0002d	89 41 60	 mov	 DWORD PTR [rcx+96], eax

; 106  : 
; 107  :     /* PyBuffer_Release() decrements master->obj and sets it to NULL. */
; 108  :     _PyObject_GC_UNTRACK(self);

  00030	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00038	4c 8b 4c 24 50	 mov	 r9, QWORD PTR self$[rsp]
  0003d	41 b8 6c 00 00
	00		 mov	 r8d, 108		; 0000006cH
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FHOCOONF@mbuf_release?$AA@
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	85 c0		 test	 eax, eax
  00058	0f 85 c1 00 00
	00		 jne	 $LN4@mbuf_relea
$LN3@mbuf_relea:
  0005e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00066	4c 8b 4c 24 50	 mov	 r9, QWORD PTR self$[rsp]
  0006b	41 b8 6c 00 00
	00		 mov	 r8d, 108		; 0000006cH
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FHOCOONF@mbuf_release?$AA@
  0007f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00084	85 c0		 test	 eax, eax
  00086	74 0b		 je	 SHORT $LN8@mbuf_relea
  00088	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv85[rsp], 0
  00091	eb 0e		 jmp	 SHORT $LN9@mbuf_relea
$LN8@mbuf_relea:
  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00098	48 83 e8 18	 sub	 rax, 24
  0009c	48 89 44 24 38	 mov	 QWORD PTR tv85[rsp], rax
$LN9@mbuf_relea:
  000a1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv85[rsp]
  000a6	48 89 44 24 30	 mov	 QWORD PTR g$20335[rsp], rax
  000ab	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20335[rsp]
  000b0	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  000b5	75 1c		 jne	 SHORT $LN10@mbuf_relea
  000b7	41 b8 6c 00 00
	00		 mov	 r8d, 108		; 0000006cH
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d1	33 c0		 xor	 eax, eax
$LN10@mbuf_relea:
  000d3	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20335[rsp]
  000d8	48 c7 40 10 fe
	ff ff ff	 mov	 QWORD PTR [rax+16], -2
  000e0	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20335[rsp]
  000e5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$20335[rsp]
  000ee	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000f1	48 89 08	 mov	 QWORD PTR [rax], rcx
  000f4	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20335[rsp]
  000f9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$20335[rsp]
  00101	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00105	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00109	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20335[rsp]
  0010e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	0f 85 3f ff ff
	ff		 jne	 $LN3@mbuf_relea
$LN4@mbuf_relea:

; 109  :     PyBuffer_Release(&self->master);

  0011f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00124	48 83 c0 70	 add	 rax, 112		; 00000070H
  00128	48 8b c8	 mov	 rcx, rax
  0012b	e8 00 00 00 00	 call	 PyBuffer_Release
$LN6@mbuf_relea:

; 110  : }

  00130	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00134	c3		 ret	 0
mbuf_release ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@FKACBFHN@mbuf_traverse?$AA@		; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_traverse DD imagerel mbuf_traverse
	DD	imagerel mbuf_traverse+116
	DD	imagerel $unwind$mbuf_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0O@FKACBFHN@mbuf_traverse?$AA@
CONST	SEGMENT
??_C@_0O@FKACBFHN@mbuf_traverse?$AA@ DB 'mbuf_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mbuf_traverse
_TEXT	SEGMENT
vret$20363 = 32
self$ = 64
visit$ = 72
arg$ = 80
mbuf_traverse PROC					; COMDAT

; 124  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@mbuf_trave:

; 125  :     Py_VISIT(self->master.obj);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@mbuf_trave
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 7d 00 00
	00		 mov	 r8d, 125		; 0000007dH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@FKACBFHN@mbuf_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@mbuf_trave:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00042	74 23		 je	 SHORT $LN2@mbuf_trave
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$20363[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$20363[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@mbuf_trave
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$20363[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@mbuf_trave
$LN1@mbuf_trave:
$LN2@mbuf_trave:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@mbuf_trave

; 126  :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@mbuf_trave:

; 127  : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
mbuf_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CG@JCKJGJP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_clear DD imagerel mbuf_clear
	DD	imagerel mbuf_clear+66
	DD	imagerel $unwind$mbuf_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_clear DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1CG@JCKJGJP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JCKJGJP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'e', 00H
	DB	'x', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, 's', 00H, ' '
	DB	00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mbuf_clear
_TEXT	SEGMENT
self$ = 48
mbuf_clear PROC						; COMDAT

; 131  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 132  :     assert(self->exports >= 0);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	7d 1c		 jge	 SHORT $LN3@mbuf_clear
  00015	41 b8 84 00 00
	00		 mov	 r8d, 132		; 00000084H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JCKJGJP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	33 c0		 xor	 eax, eax
$LN3@mbuf_clear:

; 133  :     mbuf_release(self);

  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00036	e8 00 00 00 00	 call	 mbuf_release

; 134  :     return 0;

  0003b	33 c0		 xor	 eax, eax

; 135  : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
mbuf_clear ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_1FI@FDDHOAME@?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ ; `string'
PUBLIC	??_C@_1BI@PKPGBMEK@?$AAm?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	PyMemoryView_FromMemory
EXTRN	PyBuffer_FillInfo:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoryView_FromMemory DD imagerel $LN8
	DD	imagerel $LN8+243
	DD	imagerel $unwind$PyMemoryView_FromMemory
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoryView_FromMemory DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_1FI@FDDHOAME@?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1FI@FDDHOAME@?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ DB 'f'
	DB	00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'B', 00H, 'U', 00H, 'F'
	DB	00H, '_', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'D', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g'
	DB	00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'P', 00H
	DB	'y', 00H, 'B', 00H, 'U', 00H, 'F', 00H, '_', 00H, 'W', 00H, 'R'
	DB	00H, 'I', 00H, 'T', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@PKPGBMEK@?$AAm?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@PKPGBMEK@?$AAm?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'm'
	DB	00H, 'e', 00H, 'm', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyMemoryView_FromMemory
_TEXT	SEGMENT
mv$ = 48
mbuf$ = 56
readonly$ = 64
tv78 = 68
mem$ = 96
size$ = 104
flags$ = 112
PyMemoryView_FromMemory PROC				; COMDAT

; 720  : {

$LN8:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 721  :     _PyManagedBufferObject *mbuf;
; 722  :     PyObject *mv;
; 723  :     int readonly;
; 724  : 
; 725  :     assert(mem != NULL);

  00013	48 83 7c 24 60
	00		 cmp	 QWORD PTR mem$[rsp], 0
  00019	75 1c		 jne	 SHORT $LN4@PyMemoryVi
  0001b	41 b8 d5 02 00
	00		 mov	 r8d, 725		; 000002d5H
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@PKPGBMEK@?$AAm?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00035	33 c0		 xor	 eax, eax
$LN4@PyMemoryVi:

; 726  :     assert(flags == PyBUF_READ || flags == PyBUF_WRITE);

  00037	81 7c 24 70 00
	01 00 00	 cmp	 DWORD PTR flags$[rsp], 256 ; 00000100H
  0003f	74 26		 je	 SHORT $LN5@PyMemoryVi
  00041	81 7c 24 70 00
	02 00 00	 cmp	 DWORD PTR flags$[rsp], 512 ; 00000200H
  00049	74 1c		 je	 SHORT $LN5@PyMemoryVi
  0004b	41 b8 d6 02 00
	00		 mov	 r8d, 726		; 000002d6H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FI@FDDHOAME@?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00065	33 c0		 xor	 eax, eax
$LN5@PyMemoryVi:

; 727  : 
; 728  :     mbuf = mbuf_alloc();

  00067	e8 00 00 00 00	 call	 mbuf_alloc
  0006c	48 89 44 24 38	 mov	 QWORD PTR mbuf$[rsp], rax

; 729  :     if (mbuf == NULL)

  00071	48 83 7c 24 38
	00		 cmp	 QWORD PTR mbuf$[rsp], 0
  00077	75 04		 jne	 SHORT $LN1@PyMemoryVi

; 730  :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	eb 71		 jmp	 SHORT $LN2@PyMemoryVi
$LN1@PyMemoryVi:

; 731  : 
; 732  :     readonly = (flags == PyBUF_WRITE) ? 0 : 1;

  0007d	81 7c 24 70 00
	02 00 00	 cmp	 DWORD PTR flags$[rsp], 512 ; 00000200H
  00085	75 0a		 jne	 SHORT $LN6@PyMemoryVi
  00087	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  0008f	eb 08		 jmp	 SHORT $LN7@PyMemoryVi
$LN6@PyMemoryVi:
  00091	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
$LN7@PyMemoryVi:
  00099	8b 44 24 44	 mov	 eax, DWORD PTR tv78[rsp]
  0009d	89 44 24 40	 mov	 DWORD PTR readonly$[rsp], eax

; 733  :     (void)PyBuffer_FillInfo(&mbuf->master, NULL, mem, size, readonly,
; 734  :                             PyBUF_FULL_RO);

  000a1	48 8b 44 24 38	 mov	 rax, QWORD PTR mbuf$[rsp]
  000a6	48 83 c0 70	 add	 rax, 112		; 00000070H
  000aa	c7 44 24 28 1c
	01 00 00	 mov	 DWORD PTR [rsp+40], 284	; 0000011cH
  000b2	8b 4c 24 40	 mov	 ecx, DWORD PTR readonly$[rsp]
  000b6	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000ba	4c 8b 4c 24 68	 mov	 r9, QWORD PTR size$[rsp]
  000bf	4c 8b 44 24 60	 mov	 r8, QWORD PTR mem$[rsp]
  000c4	33 d2		 xor	 edx, edx
  000c6	48 8b c8	 mov	 rcx, rax
  000c9	e8 00 00 00 00	 call	 PyBuffer_FillInfo

; 735  : 
; 736  :     mv = mbuf_add_view(mbuf, NULL);

  000ce	33 d2		 xor	 edx, edx
  000d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000d5	e8 00 00 00 00	 call	 mbuf_add_view
  000da	48 89 44 24 30	 mov	 QWORD PTR mv$[rsp], rax

; 737  :     Py_DECREF(mbuf);

  000df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000e4	e8 00 00 00 00	 call	 _Py_DecRef

; 738  : 
; 739  :     return mv;

  000e9	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
$LN2@PyMemoryVi:

; 740  : }

  000ee	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f2	c3		 ret	 0
PyMemoryView_FromMemory ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_0L@EAMGENOI@mbuf_alloc?$AA@		; `string'
EXTRN	_PyGC_generation0:QWORD
EXTRN	Py_FatalError:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\memoryobject.c
pdata	SEGMENT
$pdata$mbuf_alloc DD imagerel mbuf_alloc
	DD	imagerel mbuf_alloc+360
	DD	imagerel $unwind$mbuf_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_alloc DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EAMGENOI@mbuf_alloc?$AA@
CONST	SEGMENT
??_C@_0L@EAMGENOI@mbuf_alloc?$AA@ DB 'mbuf_alloc', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mbuf_alloc
_TEXT	SEGMENT
mbuf$ = 48
g$20307 = 56
tv70 = 64
tv90 = 72
mbuf_alloc PROC						; COMDAT

; 64   : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 65   :     _PyManagedBufferObject *mbuf;
; 66   : 
; 67   :     mbuf = (_PyManagedBufferObject *)
; 68   :         PyObject_GC_New(_PyManagedBufferObject, &_PyManagedBuffer_Type);

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 13		 je	 SHORT $LN9@mbuf_alloc
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyManagedBuffer_Type
  00014	e8 00 00 00 00	 call	 _PxObject_New
  00019	48 89 44 24 40	 mov	 QWORD PTR tv70[rsp], rax
  0001e	eb 11		 jmp	 SHORT $LN10@mbuf_alloc
$LN9@mbuf_alloc:
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyManagedBuffer_Type
  00027	e8 00 00 00 00	 call	 _PyObject_GC_New
  0002c	48 89 44 24 40	 mov	 QWORD PTR tv70[rsp], rax
$LN10@mbuf_alloc:
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR tv70[rsp]
  00036	48 89 44 24 30	 mov	 QWORD PTR mbuf$[rsp], rax

; 69   :     if (mbuf == NULL)

  0003b	48 83 7c 24 30
	00		 cmp	 QWORD PTR mbuf$[rsp], 0
  00041	75 07		 jne	 SHORT $LN6@mbuf_alloc

; 70   :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 19 01 00 00	 jmp	 $LN7@mbuf_alloc
$LN6@mbuf_alloc:

; 71   :     mbuf->flags = 0;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR mbuf$[rsp]
  0004f	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [rax+96], 0

; 72   :     mbuf->exports = 0;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR mbuf$[rsp]
  0005b	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 73   :     mbuf->master.obj = NULL;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR mbuf$[rsp]
  00068	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 74   :     _PyObject_GC_TRACK(mbuf);

  00070	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00078	4c 8b 4c 24 30	 mov	 r9, QWORD PTR mbuf$[rsp]
  0007d	41 b8 4a 00 00
	00		 mov	 r8d, 74			; 0000004aH
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@EAMGENOI@mbuf_alloc?$AA@
  00091	e8 00 00 00 00	 call	 _PyParallel_Guard
  00096	85 c0		 test	 eax, eax
  00098	0f 85 c0 00 00
	00		 jne	 $LN5@mbuf_alloc
$LN4@mbuf_alloc:
  0009e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a6	4c 8b 4c 24 30	 mov	 r9, QWORD PTR mbuf$[rsp]
  000ab	41 b8 4a 00 00
	00		 mov	 r8d, 74			; 0000004aH
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@EAMGENOI@mbuf_alloc?$AA@
  000bf	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c4	85 c0		 test	 eax, eax
  000c6	74 0b		 je	 SHORT $LN11@mbuf_alloc
  000c8	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv90[rsp], 0
  000d1	eb 0e		 jmp	 SHORT $LN12@mbuf_alloc
$LN11@mbuf_alloc:
  000d3	48 8b 44 24 30	 mov	 rax, QWORD PTR mbuf$[rsp]
  000d8	48 83 e8 18	 sub	 rax, 24
  000dc	48 89 44 24 48	 mov	 QWORD PTR tv90[rsp], rax
$LN12@mbuf_alloc:
  000e1	48 8b 44 24 48	 mov	 rax, QWORD PTR tv90[rsp]
  000e6	48 89 44 24 38	 mov	 QWORD PTR g$20307[rsp], rax
  000eb	48 8b 44 24 38	 mov	 rax, QWORD PTR g$20307[rsp]
  000f0	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  000f5	74 0c		 je	 SHORT $LN1@mbuf_alloc
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  000fe	e8 00 00 00 00	 call	 Py_FatalError
$LN1@mbuf_alloc:
  00103	48 8b 44 24 38	 mov	 rax, QWORD PTR g$20307[rsp]
  00108	48 c7 40 10 fd
	ff ff ff	 mov	 QWORD PTR [rax+16], -3
  00110	48 8b 44 24 38	 mov	 rax, QWORD PTR g$20307[rsp]
  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  0011c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0011f	48 8b 44 24 38	 mov	 rax, QWORD PTR g$20307[rsp]
  00124	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  0012b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0012f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00133	48 8b 44 24 38	 mov	 rax, QWORD PTR g$20307[rsp]
  00138	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0013c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$20307[rsp]
  00141	48 89 08	 mov	 QWORD PTR [rax], rcx
  00144	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0014b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$20307[rsp]
  00150	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00154	33 c0		 xor	 eax, eax
  00156	85 c0		 test	 eax, eax
  00158	0f 85 40 ff ff
	ff		 jne	 $LN4@mbuf_alloc
$LN5@mbuf_alloc:

; 75   : 
; 76   :     return mbuf;

  0015e	48 8b 44 24 30	 mov	 rax, QWORD PTR mbuf$[rsp]
$LN7@mbuf_alloc:

; 77   : }

  00163	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00167	c3		 ret	 0
mbuf_alloc ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0DE@EHEPBPHJ@memoryview?3?5number?5of?5dimensions@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_add_view DD imagerel mbuf_add_view
	DD	imagerel mbuf_add_view+229
	DD	imagerel $unwind$mbuf_add_view
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_add_view DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0DE@EHEPBPHJ@memoryview?3?5number?5of?5dimensions@
CONST	SEGMENT
??_C@_0DE@EHEPBPHJ@memoryview?3?5number?5of?5dimensions@ DB 'memoryview: '
	DB	'number of dimensions must not exceed 64', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mbuf_add_view
_TEXT	SEGMENT
dest$ = 32
mv$ = 40
mbuf$ = 64
src$ = 72
mbuf_add_view PROC					; COMDAT

; 653  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 654  :     PyMemoryViewObject *mv;
; 655  :     Py_buffer *dest;
; 656  : 
; 657  :     if (src == NULL)

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR src$[rsp], 0
  00014	75 0e		 jne	 SHORT $LN3@mbuf_add_v

; 658  :         src = &mbuf->master;

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR mbuf$[rsp]
  0001b	48 83 c0 70	 add	 rax, 112		; 00000070H
  0001f	48 89 44 24 48	 mov	 QWORD PTR src$[rsp], rax
$LN3@mbuf_add_v:

; 659  : 
; 660  :     if (src->ndim > PyBUF_MAX_NDIM) {

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR src$[rsp]
  00029	83 78 24 40	 cmp	 DWORD PTR [rax+36], 64	; 00000040H
  0002d	7e 1a		 jle	 SHORT $LN2@mbuf_add_v

; 661  :         PyErr_SetString(PyExc_ValueError,
; 662  :             "memoryview: number of dimensions must not exceed "
; 663  :             STRINGIZE(PyBUF_MAX_NDIM));

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@EHEPBPHJ@memoryview?3?5number?5of?5dimensions@
  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003d	e8 00 00 00 00	 call	 PyErr_SetString

; 664  :         return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	e9 97 00 00 00	 jmp	 $LN4@mbuf_add_v
$LN2@mbuf_add_v:

; 665  :     }
; 666  : 
; 667  :     mv = memory_alloc(src->ndim);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR src$[rsp]
  0004e	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  00051	e8 00 00 00 00	 call	 memory_alloc
  00056	48 89 44 24 28	 mov	 QWORD PTR mv$[rsp], rax

; 668  :     if (mv == NULL)

  0005b	48 83 7c 24 28
	00		 cmp	 QWORD PTR mv$[rsp], 0
  00061	75 04		 jne	 SHORT $LN1@mbuf_add_v

; 669  :         return NULL;

  00063	33 c0		 xor	 eax, eax
  00065	eb 79		 jmp	 SHORT $LN4@mbuf_add_v
$LN1@mbuf_add_v:

; 670  : 
; 671  :     dest = &mv->view;

  00067	48 8b 44 24 28	 mov	 rax, QWORD PTR mv$[rsp]
  0006c	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00072	48 89 44 24 20	 mov	 QWORD PTR dest$[rsp], rax

; 672  :     init_shared_values(dest, src);

  00077	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dest$[rsp]
  00081	e8 00 00 00 00	 call	 init_shared_values

; 673  :     init_shape_strides(dest, src);

  00086	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dest$[rsp]
  00090	e8 00 00 00 00	 call	 init_shape_strides

; 674  :     init_suboffsets(dest, src);

  00095	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  0009a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dest$[rsp]
  0009f	e8 00 00 00 00	 call	 init_suboffsets

; 675  :     init_flags(mv);

  000a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mv$[rsp]
  000a9	e8 00 00 00 00	 call	 init_flags

; 676  : 
; 677  :     mv->mbuf = mbuf;

  000ae	48 8b 44 24 28	 mov	 rax, QWORD PTR mv$[rsp]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000b8	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 678  :     Py_INCREF(mbuf);

  000bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000c1	e8 00 00 00 00	 call	 _Py_IncRef

; 679  :     mbuf->exports++;

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR mbuf$[rsp]
  000cb	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000cf	48 ff c0	 inc	 rax
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000d7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 680  : 
; 681  :     return (PyObject *)mv;

  000db	48 8b 44 24 28	 mov	 rax, QWORD PTR mv$[rsp]
$LN4@mbuf_add_v:

; 682  : }

  000e0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e4	c3		 ret	 0
mbuf_add_view ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
;	COMDAT pdata
; File c:\src\pyparallel\objects\memoryobject.c
pdata	SEGMENT
$pdata$init_shared_values DD imagerel init_shared_values
	DD	imagerel init_shared_values+174
	DD	imagerel $unwind$init_shared_values
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_shared_values DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT init_shared_values
_TEXT	SEGMENT
tv76 = 0
dest$ = 32
src$ = 40
init_shared_values PROC					; COMDAT

; 520  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 521  :     dest->obj = src->obj;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR dest$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  00018	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0001c	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 522  :     dest->buf = src->buf;

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR dest$[rsp]
  00025	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  0002a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 523  :     dest->len = src->len;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR dest$[rsp]
  00035	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  0003a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003e	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 524  :     dest->itemsize = src->itemsize;

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR dest$[rsp]
  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  0004c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00050	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 525  :     dest->readonly = src->readonly;

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR dest$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  0005e	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00061	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 526  :     dest->format = src->format ? src->format : "B";

  00064	48 8b 44 24 28	 mov	 rax, QWORD PTR src$[rsp]
  00069	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0006e	74 0f		 je	 SHORT $LN3@init_share
  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR src$[rsp]
  00075	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00079	48 89 04 24	 mov	 QWORD PTR tv76[rsp], rax
  0007d	eb 0b		 jmp	 SHORT $LN4@init_share
$LN3@init_share:
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01HMGJMAIH@B?$AA@
  00086	48 89 04 24	 mov	 QWORD PTR tv76[rsp], rax
$LN4@init_share:
  0008a	48 8b 44 24 20	 mov	 rax, QWORD PTR dest$[rsp]
  0008f	48 8b 0c 24	 mov	 rcx, QWORD PTR tv76[rsp]
  00093	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 527  :     dest->internal = src->internal;

  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR dest$[rsp]
  0009c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  000a1	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  000a5	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 528  : }

  000a9	48 83 c4 18	 add	 rsp, 24
  000ad	c3		 ret	 0
init_shared_values ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_shape_strides DD imagerel init_shape_strides
	DD	imagerel init_shape_strides+396
	DD	imagerel $unwind$init_shape_strides
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_shape_strides DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT init_shape_strides
_TEXT	SEGMENT
i$ = 32
tv78 = 40
tv86 = 48
dest$ = 80
src$ = 88
init_shape_strides PROC					; COMDAT

; 533  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 534  :     Py_ssize_t i;
; 535  : 
; 536  :     if (src->ndim == 0) {

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  00013	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00017	75 1f		 jne	 SHORT $LN10@init_shape

; 537  :         dest->shape = NULL;

  00019	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0001e	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 538  :         dest->strides = NULL;

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0002b	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 539  :         return;

  00033	e9 4f 01 00 00	 jmp	 $LN11@init_shape
$LN10@init_shape:

; 540  :     }
; 541  :     if (src->ndim == 1) {

  00038	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  0003d	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  00041	0f 85 8c 00 00
	00		 jne	 $LN9@init_shape

; 542  :         dest->shape[0] = src->shape ? src->shape[0] : src->len / src->itemsize;

  00047	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  0004c	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00051	74 13		 je	 SHORT $LN13@init_shape
  00053	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  00058	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0005c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005f	48 89 44 24 28	 mov	 QWORD PTR tv78[rsp], rax
  00064	eb 19		 jmp	 SHORT $LN14@init_shape
$LN13@init_shape:
  00066	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  0006b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006f	48 99		 cdq
  00071	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  00076	48 f7 79 18	 idiv	 QWORD PTR [rcx+24]
  0007a	48 89 44 24 28	 mov	 QWORD PTR tv78[rsp], rax
$LN14@init_shape:
  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00084	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00088	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv78[rsp]
  0008d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 543  :         dest->strides[0] = src->strides ? src->strides[0] : src->itemsize;

  00090	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  00095	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0009a	74 13		 je	 SHORT $LN15@init_shape
  0009c	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  000a1	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000a5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a8	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
  000ad	eb 0e		 jmp	 SHORT $LN16@init_shape
$LN15@init_shape:
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  000b4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000b8	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
$LN16@init_shape:
  000bd	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000c2	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv86[rsp]
  000cb	48 89 08	 mov	 QWORD PTR [rax], rcx

; 544  :         return;

  000ce	e9 b4 00 00 00	 jmp	 $LN11@init_shape
$LN9@init_shape:

; 545  :     }
; 546  : 
; 547  :     for (i = 0; i < src->ndim; i++)

  000d3	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000dc	eb 0d		 jmp	 SHORT $LN8@init_shape
$LN7@init_shape:
  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000e3	48 ff c0	 inc	 rax
  000e6	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN8@init_shape:
  000eb	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  000f0	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  000f4	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000f9	7d 26		 jge	 SHORT $LN6@init_shape

; 548  :         dest->shape[i] = src->shape[i];

  000fb	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  00100	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00104	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00109	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0010d	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00112	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00117	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  0011b	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0011f	eb bd		 jmp	 SHORT $LN7@init_shape
$LN6@init_shape:

; 549  :     if (src->strides) {

  00121	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  00126	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0012b	74 50		 je	 SHORT $LN5@init_shape

; 550  :         for (i = 0; i < src->ndim; i++)

  0012d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00136	eb 0d		 jmp	 SHORT $LN4@init_shape
$LN3@init_shape:
  00138	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0013d	48 ff c0	 inc	 rax
  00140	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@init_shape:
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  0014a	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  0014e	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00153	7d 26		 jge	 SHORT $LN2@init_shape

; 551  :             dest->strides[i] = src->strides[i];

  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  0015a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0015e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00163	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00167	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0016c	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00171	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  00175	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00179	eb bd		 jmp	 SHORT $LN3@init_shape
$LN2@init_shape:

; 552  :     }
; 553  :     else {

  0017b	eb 0a		 jmp	 SHORT $LN1@init_shape
$LN5@init_shape:

; 554  :         init_strides_from_shape(dest);

  0017d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00182	e8 00 00 00 00	 call	 init_strides_from_shape
$LN1@init_shape:
$LN11@init_shape:

; 555  :     }
; 556  : }

  00187	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0018b	c3		 ret	 0
init_shape_strides ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BO@IOIDCJGK@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_strides_from_shape DD imagerel init_strides_from_shape
	DD	imagerel init_strides_from_shape+187
	DD	imagerel $unwind$init_strides_from_shape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_strides_from_shape DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1BO@IOIDCJGK@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@IOIDCJGK@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'v'
	DB	00H, 'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'd', 00H, 'i', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT init_strides_from_shape
_TEXT	SEGMENT
i$ = 32
view$ = 64
init_strides_from_shape PROC				; COMDAT

; 445  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 446  :     Py_ssize_t i;
; 447  : 
; 448  :     assert(view->ndim > 0);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  0000e	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00012	7f 1c		 jg	 SHORT $LN6@init_strid
  00014	41 b8 c0 01 00
	00		 mov	 r8d, 448		; 000001c0H
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@IOIDCJGK@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002e	33 c0		 xor	 eax, eax
$LN6@init_strid:

; 449  : 
; 450  :     view->strides[view->ndim-1] = view->itemsize;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  00035	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00038	ff c8		 dec	 eax
  0003a	48 98		 cdqe
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR view$[rsp]
  00041	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00045	48 8b 54 24 40	 mov	 rdx, QWORD PTR view$[rsp]
  0004a	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0004e	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 451  :     for (i = view->ndim-2; i >= 0; i--)

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  00057	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0005a	83 e8 02	 sub	 eax, 2
  0005d	48 98		 cdqe
  0005f	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00064	eb 0d		 jmp	 SHORT $LN3@init_strid
$LN2@init_strid:
  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0006b	48 ff c8	 dec	 rax
  0006e	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@init_strid:
  00073	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  00079	7c 3b		 jl	 SHORT $LN1@init_strid

; 452  :         view->strides[i] = view->strides[i+1] * view->shape[i+1];

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  00080	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR view$[rsp]
  00089	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0008d	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00092	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00097	48 8b 44 d0 08	 mov	 rax, QWORD PTR [rax+rdx*8+8]
  0009c	4a 0f af 44 c1
	08		 imul	 rax, QWORD PTR [rcx+r8*8+8]
  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR view$[rsp]
  000a7	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000ab	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  000b0	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  000b4	eb b0		 jmp	 SHORT $LN2@init_strid
$LN1@init_strid:

; 453  : }

  000b6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ba	c3		 ret	 0
init_strides_from_shape ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_suboffsets DD imagerel init_suboffsets
	DD	imagerel init_suboffsets+118
	DD	imagerel $unwind$init_suboffsets
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_suboffsets DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT init_suboffsets
_TEXT	SEGMENT
i$ = 0
dest$ = 32
src$ = 40
init_suboffsets PROC					; COMDAT

; 560  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 561  :     Py_ssize_t i;
; 562  : 
; 563  :     if (src->suboffsets == NULL) {

  0000e	48 8b 44 24 28	 mov	 rax, QWORD PTR src$[rsp]
  00013	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00018	75 0f		 jne	 SHORT $LN4@init_subof

; 564  :         dest->suboffsets = NULL;

  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR dest$[rsp]
  0001f	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 565  :         return;

  00027	eb 48		 jmp	 SHORT $LN5@init_subof
$LN4@init_subof:

; 566  :     }
; 567  :     for (i = 0; i < src->ndim; i++)

  00029	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00031	eb 0b		 jmp	 SHORT $LN3@init_subof
$LN2@init_subof:
  00033	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00037	48 ff c0	 inc	 rax
  0003a	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN3@init_subof:
  0003e	48 8b 44 24 28	 mov	 rax, QWORD PTR src$[rsp]
  00043	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00047	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  0004b	7d 24		 jge	 SHORT $LN1@init_subof

; 568  :         dest->suboffsets[i] = src->suboffsets[i];

  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR src$[rsp]
  00052	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00056	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dest$[rsp]
  0005b	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0005f	48 8b 14 24	 mov	 rdx, QWORD PTR i$[rsp]
  00063	4c 8b 04 24	 mov	 r8, QWORD PTR i$[rsp]
  00067	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  0006b	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0006f	eb c2		 jmp	 SHORT $LN2@init_subof
$LN1@init_subof:
$LN5@init_subof:

; 569  : }

  00071	48 83 c4 18	 add	 rsp, 24
  00075	c3		 ret	 0
init_suboffsets ENDP
_TEXT	ENDS
EXTRN	PyBuffer_IsContiguous:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_flags DD imagerel init_flags
	DD	imagerel init_flags+233
	DD	imagerel $unwind$init_flags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_flags DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT init_flags
_TEXT	SEGMENT
flags$ = 32
view$ = 40
tv66 = 48
mv$ = 80
init_flags PROC						; COMDAT

; 588  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 589  :     const Py_buffer *view = &mv->view;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR mv$[rsp]
  0000e	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00014	48 89 44 24 28	 mov	 QWORD PTR view$[rsp], rax

; 590  :     int flags = 0;

  00019	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR flags$[rsp], 0

; 591  : 
; 592  :     switch (view->ndim) {

  00021	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  00026	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00029	89 44 24 30	 mov	 DWORD PTR tv66[rsp], eax
  0002d	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00032	74 09		 je	 SHORT $LN8@init_flags
  00034	83 7c 24 30 01	 cmp	 DWORD PTR tv66[rsp], 1
  00039	74 0f		 je	 SHORT $LN7@init_flags
  0003b	eb 40		 jmp	 SHORT $LN4@init_flags
$LN8@init_flags:

; 593  :     case 0:
; 594  :         flags |= (_Py_MEMORYVIEW_SCALAR|_Py_MEMORYVIEW_C|
; 595  :                   _Py_MEMORYVIEW_FORTRAN);

  0003d	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00041	83 c8 0e	 or	 eax, 14
  00044	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax

; 596  :         break;

  00048	eb 69		 jmp	 SHORT $LN9@init_flags
$LN7@init_flags:

; 597  :     case 1:
; 598  :         if (MV_CONTIGUOUS_NDIM1(view))

  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  0004f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00053	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00057	74 17		 je	 SHORT $LN5@init_flags
  00059	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  0005e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00062	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  00067	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0006b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0006e	75 0b		 jne	 SHORT $LN6@init_flags
$LN5@init_flags:

; 599  :             flags |= (_Py_MEMORYVIEW_C|_Py_MEMORYVIEW_FORTRAN);

  00070	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00074	83 c8 06	 or	 eax, 6
  00077	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN6@init_flags:

; 600  :         break;

  0007b	eb 36		 jmp	 SHORT $LN9@init_flags
$LN4@init_flags:

; 601  :     default:
; 602  :         if (PyBuffer_IsContiguous(view, 'C'))

  0007d	b2 43		 mov	 dl, 67			; 00000043H
  0007f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  00084	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  00089	85 c0		 test	 eax, eax
  0008b	74 0b		 je	 SHORT $LN3@init_flags

; 603  :             flags |= _Py_MEMORYVIEW_C;

  0008d	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00091	83 c8 02	 or	 eax, 2
  00094	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN3@init_flags:

; 604  :         if (PyBuffer_IsContiguous(view, 'F'))

  00098	b2 46		 mov	 dl, 70			; 00000046H
  0009a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  0009f	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  000a4	85 c0		 test	 eax, eax
  000a6	74 0b		 je	 SHORT $LN2@init_flags

; 605  :             flags |= _Py_MEMORYVIEW_FORTRAN;

  000a8	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  000ac	83 c8 04	 or	 eax, 4
  000af	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN2@init_flags:
$LN9@init_flags:

; 606  :         break;
; 607  :     }
; 608  : 
; 609  :     if (view->suboffsets) {

  000b3	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  000b8	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  000bd	74 16		 je	 SHORT $LN1@init_flags

; 610  :         flags |= _Py_MEMORYVIEW_PIL;

  000bf	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  000c3	83 c8 10	 or	 eax, 16
  000c6	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax

; 611  :         flags &= ~(_Py_MEMORYVIEW_C|_Py_MEMORYVIEW_FORTRAN);

  000ca	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  000ce	83 e0 f9	 and	 eax, -7
  000d1	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN1@init_flags:

; 612  :     }
; 613  : 
; 614  :     mv->flags = flags;

  000d5	48 8b 44 24 50	 mov	 rax, QWORD PTR mv$[rsp]
  000da	8b 4c 24 20	 mov	 ecx, DWORD PTR flags$[rsp]
  000de	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx

; 615  : }

  000e4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e8	c3		 ret	 0
init_flags ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@OJBPNOEA@memory_alloc?$AA@		; `string'
EXTRN	_PyObject_GC_NewVar:PROC
EXTRN	_PxObject_NewVar:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_alloc DD imagerel memory_alloc
	DD	imagerel memory_alloc+524
	DD	imagerel $unwind$memory_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_alloc DD 010801H
	DD	0a208H
xdata	ENDS
;	COMDAT ??_C@_0N@OJBPNOEA@memory_alloc?$AA@
CONST	SEGMENT
??_C@_0N@OJBPNOEA@memory_alloc?$AA@ DB 'memory_alloc', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_alloc
_TEXT	SEGMENT
mv$ = 48
g$20684 = 56
tv76 = 64
tv144 = 72
ndim$ = 96
memory_alloc PROC					; COMDAT

; 621  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 622  :     PyMemoryViewObject *mv;
; 623  : 
; 624  :     mv = (PyMemoryViewObject *)
; 625  :         PyObject_GC_NewVar(PyMemoryViewObject, &PyMemoryView_Type, 3*ndim);

  00008	e8 00 00 00 00	 call	 _Py_PXCTX
  0000d	85 c0		 test	 eax, eax
  0000f	74 1f		 je	 SHORT $LN9@memory_all
  00011	8b 44 24 60	 mov	 eax, DWORD PTR ndim$[rsp]
  00015	6b c0 03	 imul	 eax, 3
  00018	48 98		 cdqe
  0001a	48 8b d0	 mov	 rdx, rax
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyMemoryView_Type
  00024	e8 00 00 00 00	 call	 _PxObject_NewVar
  00029	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
  0002e	eb 1d		 jmp	 SHORT $LN10@memory_all
$LN9@memory_all:
  00030	8b 44 24 60	 mov	 eax, DWORD PTR ndim$[rsp]
  00034	6b c0 03	 imul	 eax, 3
  00037	48 98		 cdqe
  00039	48 8b d0	 mov	 rdx, rax
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyMemoryView_Type
  00043	e8 00 00 00 00	 call	 _PyObject_GC_NewVar
  00048	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
$LN10@memory_all:
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR tv76[rsp]
  00052	48 89 44 24 30	 mov	 QWORD PTR mv$[rsp], rax

; 626  :     if (mv == NULL)

  00057	48 83 7c 24 30
	00		 cmp	 QWORD PTR mv$[rsp], 0
  0005d	75 07		 jne	 SHORT $LN6@memory_all

; 627  :         return NULL;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 a1 01 00 00	 jmp	 $LN7@memory_all
$LN6@memory_all:

; 628  : 
; 629  :     mv->mbuf = NULL;

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
  0006b	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 630  :     mv->hash = -1;

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
  00078	48 c7 40 78 ff
	ff ff ff	 mov	 QWORD PTR [rax+120], -1

; 631  :     mv->flags = 0;

  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
  00085	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+128], 0

; 632  :     mv->exports = 0;

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
  00094	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 633  :     mv->view.ndim = ndim;

  0009f	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
  000a4	8b 4c 24 60	 mov	 ecx, DWORD PTR ndim$[rsp]
  000a8	89 88 b4 00 00
	00		 mov	 DWORD PTR [rax+180], ecx

; 634  :     mv->view.shape = mv->ob_array;

  000ae	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
  000b3	48 05 f0 00 00
	00		 add	 rax, 240		; 000000f0H
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mv$[rsp]
  000be	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 635  :     mv->view.strides = mv->ob_array + ndim;

  000c5	48 63 44 24 60	 movsxd	 rax, DWORD PTR ndim$[rsp]
  000ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mv$[rsp]
  000cf	48 8d 84 c1 f0
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+240]
  000d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mv$[rsp]
  000dc	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax

; 636  :     mv->view.suboffsets = mv->ob_array + 2 * ndim;

  000e3	8b 44 24 60	 mov	 eax, DWORD PTR ndim$[rsp]
  000e7	d1 e0		 shl	 eax, 1
  000e9	48 98		 cdqe
  000eb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mv$[rsp]
  000f0	48 8d 84 c1 f0
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+240]
  000f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mv$[rsp]
  000fd	48 89 81 d0 00
	00 00		 mov	 QWORD PTR [rcx+208], rax

; 637  :     mv->weakreflist = NULL;

  00104	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
  00109	48 c7 80 e8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+232], 0

; 638  : 
; 639  :     _PyObject_GC_TRACK(mv);

  00114	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0011c	4c 8b 4c 24 30	 mov	 r9, QWORD PTR mv$[rsp]
  00121	41 b8 7f 02 00
	00		 mov	 r8d, 639		; 0000027fH
  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@OJBPNOEA@memory_alloc?$AA@
  00135	e8 00 00 00 00	 call	 _PyParallel_Guard
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 c0 00 00
	00		 jne	 $LN5@memory_all
$LN4@memory_all:
  00142	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0014a	4c 8b 4c 24 30	 mov	 r9, QWORD PTR mv$[rsp]
  0014f	41 b8 7f 02 00
	00		 mov	 r8d, 639		; 0000027fH
  00155	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@OJBPNOEA@memory_alloc?$AA@
  00163	e8 00 00 00 00	 call	 _PyParallel_Guard
  00168	85 c0		 test	 eax, eax
  0016a	74 0b		 je	 SHORT $LN11@memory_all
  0016c	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv144[rsp], 0
  00175	eb 0e		 jmp	 SHORT $LN12@memory_all
$LN11@memory_all:
  00177	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
  0017c	48 83 e8 18	 sub	 rax, 24
  00180	48 89 44 24 48	 mov	 QWORD PTR tv144[rsp], rax
$LN12@memory_all:
  00185	48 8b 44 24 48	 mov	 rax, QWORD PTR tv144[rsp]
  0018a	48 89 44 24 38	 mov	 QWORD PTR g$20684[rsp], rax
  0018f	48 8b 44 24 38	 mov	 rax, QWORD PTR g$20684[rsp]
  00194	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  00199	74 0c		 je	 SHORT $LN1@memory_all
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  001a2	e8 00 00 00 00	 call	 Py_FatalError
$LN1@memory_all:
  001a7	48 8b 44 24 38	 mov	 rax, QWORD PTR g$20684[rsp]
  001ac	48 c7 40 10 fd
	ff ff ff	 mov	 QWORD PTR [rax+16], -3
  001b4	48 8b 44 24 38	 mov	 rax, QWORD PTR g$20684[rsp]
  001b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  001c0	48 89 08	 mov	 QWORD PTR [rax], rcx
  001c3	48 8b 44 24 38	 mov	 rax, QWORD PTR g$20684[rsp]
  001c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  001cf	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001d3	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  001d7	48 8b 44 24 38	 mov	 rax, QWORD PTR g$20684[rsp]
  001dc	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001e0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$20684[rsp]
  001e5	48 89 08	 mov	 QWORD PTR [rax], rcx
  001e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  001ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$20684[rsp]
  001f4	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  001f8	33 c0		 xor	 eax, eax
  001fa	85 c0		 test	 eax, eax
  001fc	0f 85 40 ff ff
	ff		 jne	 $LN4@memory_all
$LN5@memory_all:

; 640  :     return mv;

  00202	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
$LN7@memory_all:

; 641  : }

  00207	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0020b	c3		 ret	 0
memory_alloc ENDP
_TEXT	ENDS
PUBLIC	$T23245
PUBLIC	??_C@_0DG@KPKNPNEK@PyMemoryView_FromBuffer?$CI?$CJ?3?5info?9@ ; `string'
PUBLIC	PyMemoryView_FromBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoryView_FromBuffer DD imagerel $LN5
	DD	imagerel $LN5+175
	DD	imagerel $unwind$PyMemoryView_FromBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoryView_FromBuffer DD 040e01H
	DD	011010eH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_0DG@KPKNPNEK@PyMemoryView_FromBuffer?$CI?$CJ?3?5info?9@
CONST	SEGMENT
??_C@_0DG@KPKNPNEK@PyMemoryView_FromBuffer?$CI?$CJ?3?5info?9@ DB 'PyMemor'
	DB	'yView_FromBuffer(): info->buf must not be NULL', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyMemoryView_FromBuffer
_TEXT	SEGMENT
mv$ = 32
mbuf$ = 40
$T23245 = 48
info$ = 160
PyMemoryView_FromBuffer PROC				; COMDAT

; 749  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 750  :     _PyManagedBufferObject *mbuf;
; 751  :     PyObject *mv;
; 752  : 
; 753  :     if (info->buf == NULL) {

  0000e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00016	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001a	75 17		 jne	 SHORT $LN2@PyMemoryVi@2

; 754  :         PyErr_SetString(PyExc_ValueError,
; 755  :             "PyMemoryView_FromBuffer(): info->buf must not be NULL");

  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@KPKNPNEK@PyMemoryView_FromBuffer?$CI?$CJ?3?5info?9@
  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002a	e8 00 00 00 00	 call	 PyErr_SetString

; 756  :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 72		 jmp	 SHORT $LN3@PyMemoryVi@2
$LN2@PyMemoryVi@2:

; 757  :     }
; 758  : 
; 759  :     mbuf = mbuf_alloc();

  00033	e8 00 00 00 00	 call	 mbuf_alloc
  00038	48 89 44 24 28	 mov	 QWORD PTR mbuf$[rsp], rax

; 760  :     if (mbuf == NULL)

  0003d	48 83 7c 24 28
	00		 cmp	 QWORD PTR mbuf$[rsp], 0
  00043	75 04		 jne	 SHORT $LN1@PyMemoryVi@2

; 761  :         return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	eb 5c		 jmp	 SHORT $LN3@PyMemoryVi@2
$LN1@PyMemoryVi@2:

; 762  : 
; 763  :     /* info->obj is either NULL or a borrowed reference. This reference
; 764  :        should not be decremented in PyBuffer_Release(). */
; 765  :     mbuf->master = *info;

  00049	48 8d 44 24 30	 lea	 rax, QWORD PTR $T23245[rsp]
  0004e	48 8b f8	 mov	 rdi, rax
  00051	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR info$[rsp]
  00059	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0005e	f3 a4		 rep movsb
  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR mbuf$[rsp]
  00065	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T23245[rsp]
  0006a	48 8d 78 70	 lea	 rdi, QWORD PTR [rax+112]
  0006e	48 8b f1	 mov	 rsi, rcx
  00071	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00076	f3 a4		 rep movsb

; 766  :     mbuf->master.obj = NULL;

  00078	48 8b 44 24 28	 mov	 rax, QWORD PTR mbuf$[rsp]
  0007d	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 767  : 
; 768  :     mv = mbuf_add_view(mbuf, NULL);

  00085	33 d2		 xor	 edx, edx
  00087	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mbuf$[rsp]
  0008c	e8 00 00 00 00	 call	 mbuf_add_view
  00091	48 89 44 24 20	 mov	 QWORD PTR mv$[rsp], rax

; 769  :     Py_DECREF(mbuf);

  00096	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mbuf$[rsp]
  0009b	e8 00 00 00 00	 call	 _Py_DecRef

; 770  : 
; 771  :     return mv;

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR mv$[rsp]
$LN3@PyMemoryVi@2:

; 772  : }

  000a5	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000ac	5f		 pop	 rdi
  000ad	5e		 pop	 rsi
  000ae	c3		 ret	 0
PyMemoryView_FromBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@CBBPDCPH@memoryview?3?5?$CF?4200s?5object?5does?5n@ ; `string'
PUBLIC	??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@ ; `string'
PUBLIC	PyMemoryView_FromObject
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoryView_FromObject DD imagerel $LN9
	DD	imagerel $LN9+276
	DD	imagerel $unwind$PyMemoryView_FromObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoryView_FromObject DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0DN@CBBPDCPH@memoryview?3?5?$CF?4200s?5object?5does?5n@
CONST	SEGMENT
??_C@_0DN@CBBPDCPH@memoryview?3?5?$CF?4200s?5object?5does?5n@ DB 'memoryv'
	DB	'iew: %.200s object does not have the buffer interface', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
CONST	SEGMENT
??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@ DB 'operation fo'
	DB	'rbidden on released memoryview object', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyMemoryView_FromObject
_TEXT	SEGMENT
mbuf$ = 32
mv$20768 = 40
ret$20780 = 48
v$ = 80
PyMemoryView_FromObject PROC				; COMDAT

; 779  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 780  :     _PyManagedBufferObject *mbuf;
; 781  : 
; 782  :     if (PyMemoryView_Check(v)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyMemoryView_Type
  00010	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	75 6c		 jne	 SHORT $LN6@PyMemoryVi@3

; 783  :         PyMemoryViewObject *mv = (PyMemoryViewObject *)v;

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00020	48 89 44 24 28	 mov	 QWORD PTR mv$20768[rsp], rax

; 784  :         CHECK_RELEASED(mv);

  00025	48 8b 44 24 28	 mov	 rax, QWORD PTR mv$20768[rsp]
  0002a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	75 13		 jne	 SHORT $LN4@PyMemoryVi@3
  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR mv$20768[rsp]
  0003c	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00040	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00043	83 e0 01	 and	 eax, 1
  00046	85 c0		 test	 eax, eax
  00048	74 1a		 je	 SHORT $LN5@PyMemoryVi@3
$LN4@PyMemoryVi@3:
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00058	e8 00 00 00 00	 call	 PyErr_SetString
  0005d	33 c0		 xor	 eax, eax
  0005f	e9 ab 00 00 00	 jmp	 $LN7@PyMemoryVi@3
$LN5@PyMemoryVi@3:

; 785  :         return mbuf_add_view(mv->mbuf, &mv->view);

  00064	48 8b 44 24 28	 mov	 rax, QWORD PTR mv$20768[rsp]
  00069	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  0006f	48 8b d0	 mov	 rdx, rax
  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR mv$20768[rsp]
  00077	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0007b	e8 00 00 00 00	 call	 mbuf_add_view
  00080	e9 8a 00 00 00	 jmp	 $LN7@PyMemoryVi@3
  00085	eb 66		 jmp	 SHORT $LN3@PyMemoryVi@3
$LN6@PyMemoryVi@3:

; 786  :     }
; 787  :     else if (PyObject_CheckBuffer(v)) {

  00087	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0008c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00090	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  00098	74 53		 je	 SHORT $LN2@PyMemoryVi@3
  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0009f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a3	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  000aa	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000ae	74 3d		 je	 SHORT $LN2@PyMemoryVi@3

; 788  :         PyObject *ret;
; 789  :         mbuf = (_PyManagedBufferObject *)_PyManagedBuffer_FromObject(v);

  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000b5	e8 00 00 00 00	 call	 _PyManagedBuffer_FromObject
  000ba	48 89 44 24 20	 mov	 QWORD PTR mbuf$[rsp], rax

; 790  :         if (mbuf == NULL)

  000bf	48 83 7c 24 20
	00		 cmp	 QWORD PTR mbuf$[rsp], 0
  000c5	75 04		 jne	 SHORT $LN1@PyMemoryVi@3

; 791  :             return NULL;

  000c7	33 c0		 xor	 eax, eax
  000c9	eb 44		 jmp	 SHORT $LN7@PyMemoryVi@3
$LN1@PyMemoryVi@3:

; 792  :         ret = mbuf_add_view(mbuf, NULL);

  000cb	33 d2		 xor	 edx, edx
  000cd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000d2	e8 00 00 00 00	 call	 mbuf_add_view
  000d7	48 89 44 24 30	 mov	 QWORD PTR ret$20780[rsp], rax

; 793  :         Py_DECREF(mbuf);

  000dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000e1	e8 00 00 00 00	 call	 _Py_DecRef

; 794  :         return ret;

  000e6	48 8b 44 24 30	 mov	 rax, QWORD PTR ret$20780[rsp]
  000eb	eb 22		 jmp	 SHORT $LN7@PyMemoryVi@3
$LN2@PyMemoryVi@3:
$LN3@PyMemoryVi@3:

; 795  :     }
; 796  : 
; 797  :     PyErr_Format(PyExc_TypeError,
; 798  :         "memoryview: %.200s object does not have the buffer interface",
; 799  :         Py_TYPE(v)->tp_name);

  000ed	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  000f2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f6	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@CBBPDCPH@memoryview?3?5?$CF?4200s?5object?5does?5n@
  00101	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00108	e8 00 00 00 00	 call	 PyErr_Format

; 800  :     return NULL;

  0010d	33 c0		 xor	 eax, eax
$LN7@PyMemoryVi@3:

; 801  : }

  0010f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00113	c3		 ret	 0
PyMemoryView_FromObject ENDP
_TEXT	ENDS
EXTRN	PyObject_GetBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyManagedBuffer_FromObject DD imagerel _PyManagedBuffer_FromObject
	DD	imagerel _PyManagedBuffer_FromObject+100
	DD	imagerel $unwind$_PyManagedBuffer_FromObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyManagedBuffer_FromObject DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyManagedBuffer_FromObject
_TEXT	SEGMENT
mbuf$ = 32
base$ = 64
_PyManagedBuffer_FromObject PROC			; COMDAT

; 81   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 82   :     _PyManagedBufferObject *mbuf;
; 83   : 
; 84   :     mbuf = mbuf_alloc();

  00009	e8 00 00 00 00	 call	 mbuf_alloc
  0000e	48 89 44 24 20	 mov	 QWORD PTR mbuf$[rsp], rax

; 85   :     if (mbuf == NULL)

  00013	48 83 7c 24 20
	00		 cmp	 QWORD PTR mbuf$[rsp], 0
  00019	75 04		 jne	 SHORT $LN2@PyManagedB

; 86   :         return NULL;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 40		 jmp	 SHORT $LN3@PyManagedB
$LN2@PyManagedB:

; 87   : 
; 88   :     if (PyObject_GetBuffer(base, &mbuf->master, PyBUF_FULL_RO) < 0) {

  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR mbuf$[rsp]
  00024	48 83 c0 70	 add	 rax, 112		; 00000070H
  00028	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR base$[rsp]
  00036	e8 00 00 00 00	 call	 PyObject_GetBuffer
  0003b	85 c0		 test	 eax, eax
  0003d	7d 1b		 jge	 SHORT $LN1@PyManagedB

; 89   :         mbuf->master.obj = NULL;

  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR mbuf$[rsp]
  00044	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 90   :         Py_DECREF(mbuf);

  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mbuf$[rsp]
  00051	e8 00 00 00 00	 call	 _Py_DecRef

; 91   :         return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	eb 05		 jmp	 SHORT $LN3@PyManagedB
$LN1@PyManagedB:

; 92   :     }
; 93   : 
; 94   :     return (PyObject *)mbuf;

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR mbuf$[rsp]
$LN3@PyManagedB:

; 95   : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
_PyManagedBuffer_FromObject ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@NKCCDMPD@writable?5contiguous?5buffer?5reque@ ; `string'
PUBLIC	??_C@_0CC@BGBIMGDI@underlying?5buffer?5is?5not?5writabl@ ; `string'
PUBLIC	??_C@_1FK@KLDJBKOL@?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAC?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAF?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5@ ; `string'
PUBLIC	??_C@_1GM@GJLDBKH@?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAu?$AAf?$AAf@ ; `string'
PUBLIC	PyMemoryView_GetContiguous
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoryView_GetContiguous DD imagerel $LN9
	DD	imagerel $LN9+333
	DD	imagerel $unwind$PyMemoryView_GetContiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoryView_GetContiguous DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT ??_C@_0EC@NKCCDMPD@writable?5contiguous?5buffer?5reque@
CONST	SEGMENT
??_C@_0EC@NKCCDMPD@writable?5contiguous?5buffer?5reque@ DB 'writable cont'
	DB	'iguous buffer requested for a non-contiguous object.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BGBIMGDI@underlying?5buffer?5is?5not?5writabl@
CONST	SEGMENT
??_C@_0CC@BGBIMGDI@underlying?5buffer?5is?5not?5writabl@ DB 'underlying b'
	DB	'uffer is not writable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@KLDJBKOL@?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAC?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAF?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5@
CONST	SEGMENT
??_C@_1FK@KLDJBKOL@?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAC?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAF?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5@ DB 'o'
	DB	00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '''', 00H, 'C', 00H, '''', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '''', 00H, 'F'
	DB	00H, '''', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'o', 00H
	DB	'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '''', 00H, 'A', 00H, '''', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@GJLDBKH@?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAu?$AAf?$AAf@
CONST	SEGMENT
??_C@_1GM@GJLDBKH@?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAu?$AAf?$AAf@ DB 'b'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'P', 00H, 'y', 00H, 'B', 00H, 'U', 00H, 'F', 00H, '_', 00H
	DB	'R', 00H, 'E', 00H, 'A', 00H, 'D', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'B', 00H, 'U', 00H
	DB	'F', 00H, '_', 00H, 'W', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'E'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyMemoryView_GetContiguous
_TEXT	SEGMENT
mv$ = 32
view$ = 40
ret$ = 48
obj$ = 80
buffertype$ = 88
order$ = 96
PyMemoryView_GetContiguous PROC				; COMDAT

; 911  : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 912  :     PyMemoryViewObject *mv;
; 913  :     PyObject *ret;
; 914  :     Py_buffer *view;
; 915  : 
; 916  :     assert(buffertype == PyBUF_READ || buffertype == PyBUF_WRITE);

  00012	81 7c 24 58 00
	01 00 00	 cmp	 DWORD PTR buffertype$[rsp], 256 ; 00000100H
  0001a	74 26		 je	 SHORT $LN7@PyMemoryVi@4
  0001c	81 7c 24 58 00
	02 00 00	 cmp	 DWORD PTR buffertype$[rsp], 512 ; 00000200H
  00024	74 1c		 je	 SHORT $LN7@PyMemoryVi@4
  00026	41 b8 94 03 00
	00		 mov	 r8d, 916		; 00000394H
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GM@GJLDBKH@?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAR?$AAE?$AAA?$AAD?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAu?$AAf?$AAf@
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00040	33 c0		 xor	 eax, eax
$LN7@PyMemoryVi@4:

; 917  :     assert(order == 'C' || order == 'F' || order == 'A');

  00042	0f be 44 24 60	 movsx	 eax, BYTE PTR order$[rsp]
  00047	83 f8 43	 cmp	 eax, 67			; 00000043H
  0004a	74 30		 je	 SHORT $LN8@PyMemoryVi@4
  0004c	0f be 44 24 60	 movsx	 eax, BYTE PTR order$[rsp]
  00051	83 f8 46	 cmp	 eax, 70			; 00000046H
  00054	74 26		 je	 SHORT $LN8@PyMemoryVi@4
  00056	0f be 44 24 60	 movsx	 eax, BYTE PTR order$[rsp]
  0005b	83 f8 41	 cmp	 eax, 65			; 00000041H
  0005e	74 1c		 je	 SHORT $LN8@PyMemoryVi@4
  00060	41 b8 95 03 00
	00		 mov	 r8d, 917		; 00000395H
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@KLDJBKOL@?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAC?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAF?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5@
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007a	33 c0		 xor	 eax, eax
$LN8@PyMemoryVi@4:

; 918  : 
; 919  :     mv = (PyMemoryViewObject *)PyMemoryView_FromObject(obj);

  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj$[rsp]
  00081	e8 00 00 00 00	 call	 PyMemoryView_FromObject
  00086	48 89 44 24 20	 mov	 QWORD PTR mv$[rsp], rax

; 920  :     if (mv == NULL)

  0008b	48 83 7c 24 20
	00		 cmp	 QWORD PTR mv$[rsp], 0
  00091	75 07		 jne	 SHORT $LN4@PyMemoryVi@4

; 921  :         return NULL;

  00093	33 c0		 xor	 eax, eax
  00095	e9 ae 00 00 00	 jmp	 $LN5@PyMemoryVi@4
$LN4@PyMemoryVi@4:

; 922  : 
; 923  :     view = &mv->view;

  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR mv$[rsp]
  0009f	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  000a5	48 89 44 24 28	 mov	 QWORD PTR view$[rsp], rax

; 924  :     if (buffertype == PyBUF_WRITE && view->readonly) {

  000aa	81 7c 24 58 00
	02 00 00	 cmp	 DWORD PTR buffertype$[rsp], 512 ; 00000200H
  000b2	75 2c		 jne	 SHORT $LN3@PyMemoryVi@4
  000b4	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  000b9	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  000bd	74 21		 je	 SHORT $LN3@PyMemoryVi@4

; 925  :         PyErr_SetString(PyExc_BufferError,
; 926  :             "underlying buffer is not writable");

  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@BGBIMGDI@underlying?5buffer?5is?5not?5writabl@
  000c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  000cd	e8 00 00 00 00	 call	 PyErr_SetString

; 927  :         Py_DECREF(mv);

  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mv$[rsp]
  000d7	e8 00 00 00 00	 call	 _Py_DecRef

; 928  :         return NULL;

  000dc	33 c0		 xor	 eax, eax
  000de	eb 68		 jmp	 SHORT $LN5@PyMemoryVi@4
$LN3@PyMemoryVi@4:

; 929  :     }
; 930  : 
; 931  :     if (PyBuffer_IsContiguous(view, order))

  000e0	0f b6 54 24 60	 movzx	 edx, BYTE PTR order$[rsp]
  000e5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  000ea	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  000ef	85 c0		 test	 eax, eax
  000f1	74 07		 je	 SHORT $LN2@PyMemoryVi@4

; 932  :         return (PyObject *)mv;

  000f3	48 8b 44 24 20	 mov	 rax, QWORD PTR mv$[rsp]
  000f8	eb 4e		 jmp	 SHORT $LN5@PyMemoryVi@4
$LN2@PyMemoryVi@4:

; 933  : 
; 934  :     if (buffertype == PyBUF_WRITE) {

  000fa	81 7c 24 58 00
	02 00 00	 cmp	 DWORD PTR buffertype$[rsp], 512 ; 00000200H
  00102	75 21		 jne	 SHORT $LN1@PyMemoryVi@4

; 935  :         PyErr_SetString(PyExc_BufferError,
; 936  :             "writable contiguous buffer requested "
; 937  :             "for a non-contiguous object.");

  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@NKCCDMPD@writable?5contiguous?5buffer?5reque@
  0010b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00112	e8 00 00 00 00	 call	 PyErr_SetString

; 938  :         Py_DECREF(mv);

  00117	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mv$[rsp]
  0011c	e8 00 00 00 00	 call	 _Py_DecRef

; 939  :         return NULL;

  00121	33 c0		 xor	 eax, eax
  00123	eb 23		 jmp	 SHORT $LN5@PyMemoryVi@4
$LN1@PyMemoryVi@4:

; 940  :     }
; 941  : 
; 942  :     ret = memory_from_contiguous_copy(view, order);

  00125	0f b6 54 24 60	 movzx	 edx, BYTE PTR order$[rsp]
  0012a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  0012f	e8 00 00 00 00	 call	 memory_from_contiguous_copy
  00134	48 89 44 24 30	 mov	 QWORD PTR ret$[rsp], rax

; 943  :     Py_DECREF(mv);

  00139	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mv$[rsp]
  0013e	e8 00 00 00 00	 call	 _Py_DecRef

; 944  :     return ret;

  00143	48 8b 44 24 30	 mov	 rax, QWORD PTR ret$[rsp]
$LN5@PyMemoryVi@4:

; 945  : }

  00148	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0014c	c3		 ret	 0
PyMemoryView_GetContiguous ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CG@FJBAFCEJ@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@HPCHJKHH@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_from_contiguous_copy DD imagerel memory_from_contiguous_copy
	DD	imagerel memory_from_contiguous_copy+473
	DD	imagerel $unwind$memory_from_contiguous_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_from_contiguous_copy DD 010d01H
	DD	0a20dH
xdata	ENDS
;	COMDAT ??_C@_1CG@FJBAFCEJ@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@FJBAFCEJ@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, 'c', 00H, '-', 00H, '>', 00H, 's', 00H, 'h', 00H
	DB	'a', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@HPCHJKHH@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@HPCHJKHH@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, 'c', 00H, '-', 00H, '>', 00H, 'n', 00H, 'd', 00H
	DB	'i', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_from_contiguous_copy
_TEXT	SEGMENT
i$ = 32
dest$ = 40
mv$ = 48
mbuf$ = 56
bytes$ = 64
src$ = 96
order$ = 104
memory_from_contiguous_copy PROC			; COMDAT

; 834  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 835  :     _PyManagedBufferObject *mbuf;
; 836  :     PyMemoryViewObject *mv;
; 837  :     PyObject *bytes;
; 838  :     Py_buffer *dest;
; 839  :     int i;
; 840  : 
; 841  :     assert(src->ndim > 0);

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR src$[rsp]
  00012	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00016	7f 1c		 jg	 SHORT $LN14@memory_fro
  00018	41 b8 49 03 00
	00		 mov	 r8d, 841		; 00000349H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@HPCHJKHH@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00032	33 c0		 xor	 eax, eax
$LN14@memory_fro:

; 842  :     assert(src->shape != NULL);

  00034	48 8b 44 24 60	 mov	 rax, QWORD PTR src$[rsp]
  00039	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0003e	75 1c		 jne	 SHORT $LN15@memory_fro
  00040	41 b8 4a 03 00
	00		 mov	 r8d, 842		; 0000034aH
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@FJBAFCEJ@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005a	33 c0		 xor	 eax, eax
$LN15@memory_fro:

; 843  : 
; 844  :     bytes = PyBytes_FromStringAndSize(NULL, src->len);

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR src$[rsp]
  00061	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00065	33 c9		 xor	 ecx, ecx
  00067	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0006c	48 89 44 24 40	 mov	 QWORD PTR bytes$[rsp], rax

; 845  :     if (bytes == NULL)

  00071	48 83 7c 24 40
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  00077	75 07		 jne	 SHORT $LN11@memory_fro

; 846  :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 54 01 00 00	 jmp	 $LN12@memory_fro
$LN11@memory_fro:

; 847  : 
; 848  :     mbuf = (_PyManagedBufferObject *)_PyManagedBuffer_FromObject(bytes);

  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytes$[rsp]
  00085	e8 00 00 00 00	 call	 _PyManagedBuffer_FromObject
  0008a	48 89 44 24 38	 mov	 QWORD PTR mbuf$[rsp], rax

; 849  :     Py_DECREF(bytes);

  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytes$[rsp]
  00094	e8 00 00 00 00	 call	 _Py_DecRef

; 850  :     if (mbuf == NULL)

  00099	48 83 7c 24 38
	00		 cmp	 QWORD PTR mbuf$[rsp], 0
  0009f	75 07		 jne	 SHORT $LN10@memory_fro

; 851  :         return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	e9 2c 01 00 00	 jmp	 $LN12@memory_fro
$LN10@memory_fro:

; 852  : 
; 853  :     if (mbuf_copy_format(mbuf, src->format) < 0) {

  000a8	48 8b 44 24 60	 mov	 rax, QWORD PTR src$[rsp]
  000ad	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  000b1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000b6	e8 00 00 00 00	 call	 mbuf_copy_format
  000bb	85 c0		 test	 eax, eax
  000bd	7d 11		 jge	 SHORT $LN9@memory_fro

; 854  :         Py_DECREF(mbuf);

  000bf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000c4	e8 00 00 00 00	 call	 _Py_DecRef

; 855  :         return NULL;

  000c9	33 c0		 xor	 eax, eax
  000cb	e9 04 01 00 00	 jmp	 $LN12@memory_fro
$LN9@memory_fro:

; 856  :     }
; 857  : 
; 858  :     mv = (PyMemoryViewObject *)mbuf_add_incomplete_view(mbuf, NULL, src->ndim);

  000d0	48 8b 44 24 60	 mov	 rax, QWORD PTR src$[rsp]
  000d5	44 8b 40 24	 mov	 r8d, DWORD PTR [rax+36]
  000d9	33 d2		 xor	 edx, edx
  000db	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000e0	e8 00 00 00 00	 call	 mbuf_add_incomplete_view
  000e5	48 89 44 24 30	 mov	 QWORD PTR mv$[rsp], rax

; 859  :     Py_DECREF(mbuf);

  000ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000ef	e8 00 00 00 00	 call	 _Py_DecRef

; 860  :     if (mv == NULL)

  000f4	48 83 7c 24 30
	00		 cmp	 QWORD PTR mv$[rsp], 0
  000fa	75 07		 jne	 SHORT $LN8@memory_fro

; 861  :         return NULL;

  000fc	33 c0		 xor	 eax, eax
  000fe	e9 d1 00 00 00	 jmp	 $LN12@memory_fro
$LN8@memory_fro:

; 862  : 
; 863  :     dest = &mv->view;

  00103	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
  00108	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  0010e	48 89 44 24 28	 mov	 QWORD PTR dest$[rsp], rax

; 864  : 
; 865  :     /* shared values are initialized correctly except for itemsize */
; 866  :     dest->itemsize = src->itemsize;

  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$[rsp]
  00118	48 8b 4c 24 60	 mov	 rcx, QWORD PTR src$[rsp]
  0011d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00121	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 867  : 
; 868  :     /* shape and strides */
; 869  :     for (i = 0; i < src->ndim; i++) {

  00125	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0012d	eb 0a		 jmp	 SHORT $LN7@memory_fro
$LN6@memory_fro:
  0012f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00133	ff c0		 inc	 eax
  00135	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@memory_fro:
  00139	48 8b 44 24 60	 mov	 rax, QWORD PTR src$[rsp]
  0013e	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00141	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00145	7d 26		 jge	 SHORT $LN5@memory_fro

; 870  :         dest->shape[i] = src->shape[i];

  00147	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0014c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR src$[rsp]
  00151	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00155	48 63 54 24 20	 movsxd	 rdx, DWORD PTR i$[rsp]
  0015a	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$[rsp]
  0015f	4d 8b 40 30	 mov	 r8, QWORD PTR [r8+48]
  00163	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00167	49 89 04 d0	 mov	 QWORD PTR [r8+rdx*8], rax

; 871  :     }

  0016b	eb c2		 jmp	 SHORT $LN6@memory_fro
$LN5@memory_fro:

; 872  :     if (order == 'C' || order == 'A') {

  0016d	0f be 44 24 68	 movsx	 eax, BYTE PTR order$[rsp]
  00172	83 f8 43	 cmp	 eax, 67			; 00000043H
  00175	74 0a		 je	 SHORT $LN3@memory_fro
  00177	0f be 44 24 68	 movsx	 eax, BYTE PTR order$[rsp]
  0017c	83 f8 41	 cmp	 eax, 65			; 00000041H
  0017f	75 0c		 jne	 SHORT $LN4@memory_fro
$LN3@memory_fro:

; 873  :         init_strides_from_shape(dest);

  00181	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$[rsp]
  00186	e8 00 00 00 00	 call	 init_strides_from_shape

; 874  :     }
; 875  :     else {

  0018b	eb 0a		 jmp	 SHORT $LN2@memory_fro
$LN4@memory_fro:

; 876  :         init_fortran_strides_from_shape(dest);

  0018d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$[rsp]
  00192	e8 00 00 00 00	 call	 init_fortran_strides_from_shape
$LN2@memory_fro:

; 877  :     }
; 878  :     /* suboffsets */
; 879  :     dest->suboffsets = NULL;

  00197	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$[rsp]
  0019c	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 880  : 
; 881  :     /* flags */
; 882  :     init_flags(mv);

  001a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mv$[rsp]
  001a9	e8 00 00 00 00	 call	 init_flags

; 883  : 
; 884  :     if (copy_buffer(dest, src) < 0) {

  001ae	48 8b 54 24 60	 mov	 rdx, QWORD PTR src$[rsp]
  001b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$[rsp]
  001b8	e8 00 00 00 00	 call	 copy_buffer
  001bd	85 c0		 test	 eax, eax
  001bf	7d 0e		 jge	 SHORT $LN1@memory_fro

; 885  :         Py_DECREF(mv);

  001c1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mv$[rsp]
  001c6	e8 00 00 00 00	 call	 _Py_DecRef

; 886  :         return NULL;

  001cb	33 c0		 xor	 eax, eax
  001cd	eb 05		 jmp	 SHORT $LN12@memory_fro
$LN1@memory_fro:

; 887  :     }
; 888  : 
; 889  :     return (PyObject *)mv;

  001cf	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$[rsp]
$LN12@memory_fro:

; 890  : }

  001d4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d8	c3		 ret	 0
memory_from_contiguous_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BO@EAEEOAAF@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_buffer DD imagerel copy_buffer
	DD	imagerel copy_buffer+328
	DD	imagerel $unwind$copy_buffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_buffer DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_1BO@EAEEOAAF@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@EAEEOAAF@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'd'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'd', 00H, 'i', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT copy_buffer
_TEXT	SEGMENT
mem$ = 80
dest$ = 112
src$ = 120
copy_buffer PROC					; COMDAT

; 415  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 416  :     char *mem = NULL;

  0000e	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR mem$[rsp], 0

; 417  : 
; 418  :     assert(dest->ndim > 0);

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  0001c	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00020	7f 1c		 jg	 SHORT $LN7@copy_buffe
  00022	41 b8 a2 01 00
	00		 mov	 r8d, 418		; 000001a2H
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@EAEEOAAF@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003c	33 c0		 xor	 eax, eax
$LN7@copy_buffe:

; 419  : 
; 420  :     if (!equiv_structure(dest, src))

  0003e	48 8b 54 24 78	 mov	 rdx, QWORD PTR src$[rsp]
  00043	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dest$[rsp]
  00048	e8 00 00 00 00	 call	 equiv_structure
  0004d	85 c0		 test	 eax, eax
  0004f	75 0a		 jne	 SHORT $LN4@copy_buffe

; 421  :         return -1;

  00051	b8 ff ff ff ff	 mov	 eax, -1
  00056	e9 e8 00 00 00	 jmp	 $LN5@copy_buffe
$LN4@copy_buffe:

; 422  : 
; 423  :     if (!last_dim_is_contiguous(dest, src)) {

  0005b	48 8b 54 24 78	 mov	 rdx, QWORD PTR src$[rsp]
  00060	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dest$[rsp]
  00065	e8 00 00 00 00	 call	 last_dim_is_contiguous
  0006a	85 c0		 test	 eax, eax
  0006c	75 47		 jne	 SHORT $LN3@copy_buffe

; 424  :         mem = PyMem_Malloc(dest->shape[dest->ndim-1] * dest->itemsize);

  0006e	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  00073	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00076	ff c8		 dec	 eax
  00078	48 98		 cdqe
  0007a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dest$[rsp]
  0007f	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00083	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  00088	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0008c	48 0f af 42 18	 imul	 rax, QWORD PTR [rdx+24]
  00091	48 8b c8	 mov	 rcx, rax
  00094	e8 00 00 00 00	 call	 PyMem_Malloc
  00099	48 89 44 24 50	 mov	 QWORD PTR mem$[rsp], rax

; 425  :         if (mem == NULL) {

  0009e	48 83 7c 24 50
	00		 cmp	 QWORD PTR mem$[rsp], 0
  000a4	75 0f		 jne	 SHORT $LN2@copy_buffe

; 426  :             PyErr_NoMemory();

  000a6	e8 00 00 00 00	 call	 PyErr_NoMemory

; 427  :             return -1;

  000ab	b8 ff ff ff ff	 mov	 eax, -1
  000b0	e9 8e 00 00 00	 jmp	 $LN5@copy_buffe
$LN2@copy_buffe:
$LN3@copy_buffe:

; 428  :         }
; 429  :     }
; 430  : 
; 431  :     copy_rec(dest->shape, dest->ndim, dest->itemsize,
; 432  :              dest->buf, dest->strides, dest->suboffsets,
; 433  :              src->buf, src->strides, src->suboffsets,
; 434  :              mem);

  000b5	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  000ba	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mem$[rsp]
  000c3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR src$[rsp]
  000cd	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000d1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR src$[rsp]
  000db	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000df	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000e4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR src$[rsp]
  000e9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ec	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dest$[rsp]
  000f6	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000fa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dest$[rsp]
  00104	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00108	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0010d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dest$[rsp]
  00112	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00115	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dest$[rsp]
  0011a	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  00126	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0012a	e8 00 00 00 00	 call	 copy_rec

; 435  : 
; 436  :     if (mem)

  0012f	48 83 7c 24 50
	00		 cmp	 QWORD PTR mem$[rsp], 0
  00135	74 0a		 je	 SHORT $LN1@copy_buffe

; 437  :         PyMem_Free(mem);

  00137	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mem$[rsp]
  0013c	e8 00 00 00 00	 call	 PyMem_Free
$LN1@copy_buffe:

; 438  : 
; 439  :     return 0;

  00141	33 c0		 xor	 eax, eax
$LN5@copy_buffe:

; 440  : }

  00143	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00147	c3		 ret	 0
copy_buffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EA@GHKHDKJL@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$last_dim_is_contiguous DD imagerel last_dim_is_contiguous
	DD	imagerel last_dim_is_contiguous+243
	DD	imagerel $unwind$last_dim_is_contiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$last_dim_is_contiguous DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1EA@GHKHDKJL@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@GHKHDKJL@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'd'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'd', 00H, 'i', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 's', 00H, 'r', 00H
	DB	'c', 00H, '-', 00H, '>', 00H, 'n', 00H, 'd', 00H, 'i', 00H, 'm'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT last_dim_is_contiguous
_TEXT	SEGMENT
tv138 = 32
dest$ = 64
src$ = 72
last_dim_is_contiguous PROC				; COMDAT

; 250  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 251  :     assert(dest->ndim > 0 && src->ndim > 0);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR dest$[rsp]
  00013	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00017	7e 0b		 jle	 SHORT $LN3@last_dim_i
  00019	48 8b 44 24 48	 mov	 rax, QWORD PTR src$[rsp]
  0001e	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00022	7f 1c		 jg	 SHORT $LN4@last_dim_i
$LN3@last_dim_i:
  00024	41 b8 fb 00 00
	00		 mov	 r8d, 251		; 000000fbH
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@GHKHDKJL@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003e	33 c0		 xor	 eax, eax
$LN4@last_dim_i:

; 252  :     return (!HAVE_SUBOFFSETS_IN_LAST_DIM(dest) &&
; 253  :             !HAVE_SUBOFFSETS_IN_LAST_DIM(src) &&
; 254  :             dest->strides[dest->ndim-1] == dest->itemsize &&
; 255  :             src->strides[src->ndim-1] == src->itemsize);

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR dest$[rsp]
  00045	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  0004a	74 1c		 je	 SHORT $LN5@last_dim_i
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR dest$[rsp]
  00051	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00054	ff c8		 dec	 eax
  00056	48 98		 cdqe
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  0005d	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00061	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00066	7d 7a		 jge	 SHORT $LN7@last_dim_i
$LN5@last_dim_i:
  00068	48 8b 44 24 48	 mov	 rax, QWORD PTR src$[rsp]
  0006d	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00072	74 1c		 je	 SHORT $LN6@last_dim_i
  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR dest$[rsp]
  00079	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0007c	ff c8		 dec	 eax
  0007e	48 98		 cdqe
  00080	48 8b 4c 24 48	 mov	 rcx, QWORD PTR src$[rsp]
  00085	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00089	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0008e	7d 52		 jge	 SHORT $LN7@last_dim_i
$LN6@last_dim_i:
  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR dest$[rsp]
  00095	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00098	ff c8		 dec	 eax
  0009a	48 98		 cdqe
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  000a1	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000a5	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest$[rsp]
  000aa	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  000ae	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  000b2	75 2e		 jne	 SHORT $LN7@last_dim_i
  000b4	48 8b 44 24 48	 mov	 rax, QWORD PTR src$[rsp]
  000b9	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000bc	ff c8		 dec	 eax
  000be	48 98		 cdqe
  000c0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR src$[rsp]
  000c5	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000c9	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  000ce	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  000d2	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  000d6	75 0a		 jne	 SHORT $LN7@last_dim_i
  000d8	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  000e0	eb 08		 jmp	 SHORT $LN8@last_dim_i
$LN7@last_dim_i:
  000e2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN8@last_dim_i:
  000ea	8b 44 24 20	 mov	 eax, DWORD PTR tv138[rsp]

; 256  : }

  000ee	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f2	c3		 ret	 0
last_dim_is_contiguous ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@PKOGHNKL@memoryview?5assignment?3?5lvalue?5an@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$equiv_structure DD imagerel equiv_structure
	DD	imagerel equiv_structure+85
	DD	imagerel $unwind$equiv_structure
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$equiv_structure DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0ED@PKOGHNKL@memoryview?5assignment?3?5lvalue?5an@
CONST	SEGMENT
??_C@_0ED@PKOGHNKL@memoryview?5assignment?3?5lvalue?5an@ DB 'memoryview a'
	DB	'ssignment: lvalue and rvalue have different structures', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT equiv_structure
_TEXT	SEGMENT
dest$ = 48
src$ = 56
equiv_structure PROC					; COMDAT

; 306  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 307  :     if (!equiv_format(dest, src) ||
; 308  :         !equiv_shape(dest, src)) {

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR src$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dest$[rsp]
  00018	e8 00 00 00 00	 call	 equiv_format
  0001d	85 c0		 test	 eax, eax
  0001f	74 13		 je	 SHORT $LN1@equiv_stru
  00021	48 8b 54 24 38	 mov	 rdx, QWORD PTR src$[rsp]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dest$[rsp]
  0002b	e8 00 00 00 00	 call	 equiv_shape
  00030	85 c0		 test	 eax, eax
  00032	75 17		 jne	 SHORT $LN2@equiv_stru
$LN1@equiv_stru:

; 309  :         PyErr_SetString(PyExc_ValueError,
; 310  :             "memoryview assignment: lvalue and rvalue have different "
; 311  :             "structures");

  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@PKOGHNKL@memoryview?5assignment?3?5lvalue?5an@
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00042	e8 00 00 00 00	 call	 PyErr_SetString

; 312  :         return 0;

  00047	33 c0		 xor	 eax, eax
  00049	eb 05		 jmp	 SHORT $LN3@equiv_stru
$LN2@equiv_stru:

; 313  :     }
; 314  : 
; 315  :     return 1;

  0004b	b8 01 00 00 00	 mov	 eax, 1
$LN3@equiv_stru:

; 316  : }

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
equiv_structure ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DI@IIPFDFEE@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$AA@ ; `string'
EXTRN	strcmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$equiv_format DD imagerel equiv_format
	DD	imagerel equiv_format+239
	DD	imagerel $unwind$equiv_format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$equiv_format DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1DI@IIPFDFEE@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@IIPFDFEE@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$AA@ DB 'd'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, '-', 00H, '>', 00H, 'f', 00H
	DB	'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 's', 00H, 'r', 00H, 'c', 00H, '-', 00H
	DB	'>', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT equiv_format
_TEXT	SEGMENT
dfmt$ = 32
sfmt$ = 40
tv79 = 48
tv87 = 56
dest$ = 80
src$ = 88
equiv_format PROC					; COMDAT

; 266  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 267  :     const char *dfmt, *sfmt;
; 268  : 
; 269  :     assert(dest->format && src->format);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00013	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00018	74 0c		 je	 SHORT $LN5@equiv_form
  0001a	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  0001f	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00024	75 1c		 jne	 SHORT $LN6@equiv_form
$LN5@equiv_form:
  00026	41 b8 0d 01 00
	00		 mov	 r8d, 269		; 0000010dH
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@IIPFDFEE@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$AA@
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00040	33 c0		 xor	 eax, eax
$LN6@equiv_form:

; 270  :     dfmt = dest->format[0] == '@' ? dest->format+1 : dest->format;

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00047	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00051	75 13		 jne	 SHORT $LN7@equiv_form
  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00058	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005c	48 ff c0	 inc	 rax
  0005f	48 89 44 24 30	 mov	 QWORD PTR tv79[rsp], rax
  00064	eb 0e		 jmp	 SHORT $LN8@equiv_form
$LN7@equiv_form:
  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0006b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006f	48 89 44 24 30	 mov	 QWORD PTR tv79[rsp], rax
$LN8@equiv_form:
  00074	48 8b 44 24 30	 mov	 rax, QWORD PTR tv79[rsp]
  00079	48 89 44 24 20	 mov	 QWORD PTR dfmt$[rsp], rax

; 271  :     sfmt = src->format[0] == '@' ? src->format+1 : src->format;

  0007e	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  00083	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00087	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0008a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0008d	75 13		 jne	 SHORT $LN9@equiv_form
  0008f	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  00094	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00098	48 ff c0	 inc	 rax
  0009b	48 89 44 24 38	 mov	 QWORD PTR tv87[rsp], rax
  000a0	eb 0e		 jmp	 SHORT $LN10@equiv_form
$LN9@equiv_form:
  000a2	48 8b 44 24 58	 mov	 rax, QWORD PTR src$[rsp]
  000a7	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000ab	48 89 44 24 38	 mov	 QWORD PTR tv87[rsp], rax
$LN10@equiv_form:
  000b0	48 8b 44 24 38	 mov	 rax, QWORD PTR tv87[rsp]
  000b5	48 89 44 24 28	 mov	 QWORD PTR sfmt$[rsp], rax

; 272  : 
; 273  :     if (strcmp(dfmt, sfmt) != 0 ||
; 274  :         dest->itemsize != src->itemsize) {

  000ba	48 8b 54 24 28	 mov	 rdx, QWORD PTR sfmt$[rsp]
  000bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dfmt$[rsp]
  000c4	e8 00 00 00 00	 call	 strcmp
  000c9	85 c0		 test	 eax, eax
  000cb	75 14		 jne	 SHORT $LN1@equiv_form
  000cd	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000d2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  000d7	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000db	48 39 48 18	 cmp	 QWORD PTR [rax+24], rcx
  000df	74 04		 je	 SHORT $LN2@equiv_form
$LN1@equiv_form:

; 275  :         return 0;

  000e1	33 c0		 xor	 eax, eax
  000e3	eb 05		 jmp	 SHORT $LN3@equiv_form
$LN2@equiv_form:

; 276  :     }
; 277  : 
; 278  :     return 1;

  000e5	b8 01 00 00 00	 mov	 eax, 1
$LN3@equiv_form:

; 279  : }

  000ea	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ee	c3		 ret	 0
equiv_format ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$equiv_shape DD imagerel equiv_shape
	DD	imagerel equiv_shape+140
	DD	imagerel $unwind$equiv_shape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$equiv_shape DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT equiv_shape
_TEXT	SEGMENT
i$ = 0
dest$ = 32
src$ = 40
equiv_shape PROC					; COMDAT

; 286  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 287  :     int i;
; 288  : 
; 289  :     if (dest->ndim != src->ndim)

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR dest$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  00018	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  0001b	39 48 24	 cmp	 DWORD PTR [rax+36], ecx
  0001e	74 04		 je	 SHORT $LN6@equiv_shap

; 290  :         return 0;

  00020	33 c0		 xor	 eax, eax
  00022	eb 63		 jmp	 SHORT $LN7@equiv_shap
$LN6@equiv_shap:

; 291  : 
; 292  :     for (i = 0; i < dest->ndim; i++) {

  00024	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0002b	eb 08		 jmp	 SHORT $LN5@equiv_shap
$LN4@equiv_shap:
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00030	ff c0		 inc	 eax
  00032	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN5@equiv_shap:
  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR dest$[rsp]
  0003a	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0003d	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00040	7d 40		 jge	 SHORT $LN3@equiv_shap

; 293  :         if (dest->shape[i] != src->shape[i])

  00042	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dest$[rsp]
  0004b	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0004f	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  00053	4c 8b 44 24 28	 mov	 r8, QWORD PTR src$[rsp]
  00058	4d 8b 40 30	 mov	 r8, QWORD PTR [r8+48]
  0005c	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  00060	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  00064	74 04		 je	 SHORT $LN2@equiv_shap

; 294  :             return 0;

  00066	33 c0		 xor	 eax, eax
  00068	eb 1d		 jmp	 SHORT $LN7@equiv_shap
$LN2@equiv_shap:

; 295  :         if (dest->shape[i] == 0)

  0006a	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0006e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dest$[rsp]
  00073	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00077	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0007c	75 02		 jne	 SHORT $LN1@equiv_shap

; 296  :             break;

  0007e	eb 02		 jmp	 SHORT $LN3@equiv_shap
$LN1@equiv_shap:

; 297  :     }

  00080	eb ab		 jmp	 SHORT $LN4@equiv_shap
$LN3@equiv_shap:

; 298  : 
; 299  :     return 1;

  00082	b8 01 00 00 00	 mov	 eax, 1
$LN7@equiv_shap:

; 300  : }

  00087	48 83 c4 18	 add	 rsp, 24
  0008b	c3		 ret	 0
equiv_shape ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@MKFAAJFI@?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_rec DD imagerel copy_rec
	DD	imagerel copy_rec+687
	DD	imagerel $unwind$copy_rec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_rec DD 021b01H
	DD	013011bH
xdata	ENDS
;	COMDAT ??_C@_1BE@MKFAAJFI@?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@MKFAAJFI@?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'n'
	DB	00H, 'd', 00H, 'i', 00H, 'm', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT copy_rec
_TEXT	SEGMENT
i$ = 80
xsptr$20522 = 88
xdptr$20520 = 96
tv86 = 104
tv90 = 112
tv94 = 120
tv133 = 128
tv141 = 136
shape$ = 160
ndim$ = 168
itemsize$ = 176
dptr$ = 184
dstrides$ = 192
dsuboffsets$ = 200
sptr$ = 208
sstrides$ = 216
ssuboffsets$ = 224
mem$ = 232
copy_rec PROC						; COMDAT

; 356  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 357  :     Py_ssize_t i;
; 358  : 
; 359  :     assert(ndim >= 1);

  0001b	48 83 bc 24 a8
	00 00 00 01	 cmp	 QWORD PTR ndim$[rsp], 1
  00024	7d 1c		 jge	 SHORT $LN7@copy_rec
  00026	41 b8 67 01 00
	00		 mov	 r8d, 359		; 00000167H
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@MKFAAJFI@?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00040	33 c0		 xor	 eax, eax
$LN7@copy_rec:

; 360  : 
; 361  :     if (ndim == 1) {

  00042	48 83 bc 24 a8
	00 00 00 01	 cmp	 QWORD PTR ndim$[rsp], 1
  0004b	75 6b		 jne	 SHORT $LN4@copy_rec

; 362  :         copy_base(shape, itemsize,
; 363  :                   dptr, dstrides, dsuboffsets,
; 364  :                   sptr, sstrides, ssuboffsets,
; 365  :                   mem);

  0004d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR mem$[rsp]
  00055	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0005a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR ssuboffsets$[rsp]
  00062	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00067	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR sstrides$[rsp]
  0006f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00074	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR sptr$[rsp]
  0007c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00081	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR dsuboffsets$[rsp]
  00089	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008e	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR dstrides$[rsp]
  00096	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR dptr$[rsp]
  0009e	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR itemsize$[rsp]
  000a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR shape$[rsp]
  000ae	e8 00 00 00 00	 call	 copy_base

; 366  :         return;

  000b3	e9 ef 01 00 00	 jmp	 $LN5@copy_rec
$LN4@copy_rec:

; 367  :     }
; 368  : 
; 369  :     for (i = 0; i < shape[0]; dptr+=dstrides[0], sptr+=sstrides[0], i++) {

  000b8	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000c1	eb 4f		 jmp	 SHORT $LN3@copy_rec
$LN2@copy_rec:
  000c3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dstrides$[rsp]
  000cb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ce	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR dptr$[rsp]
  000d6	48 03 c8	 add	 rcx, rax
  000d9	48 8b c1	 mov	 rax, rcx
  000dc	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR dptr$[rsp], rax
  000e4	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR sstrides$[rsp]
  000ec	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ef	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR sptr$[rsp]
  000f7	48 03 c8	 add	 rcx, rax
  000fa	48 8b c1	 mov	 rax, rcx
  000fd	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR sptr$[rsp], rax
  00105	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  0010a	48 ff c0	 inc	 rax
  0010d	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax
$LN3@copy_rec:
  00112	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR shape$[rsp]
  0011a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011d	48 39 44 24 50	 cmp	 QWORD PTR i$[rsp], rax
  00122	0f 8d 7f 01 00
	00		 jge	 $LN1@copy_rec

; 370  :         char *xdptr = ADJUST_PTR(dptr, dsuboffsets);

  00128	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR dsuboffsets$[rsp], 0
  00131	74 2b		 je	 SHORT $LN8@copy_rec
  00133	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR dsuboffsets$[rsp]
  0013b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0013f	7c 1d		 jl	 SHORT $LN8@copy_rec
  00141	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR dptr$[rsp]
  00149	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0014c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR dsuboffsets$[rsp]
  00154	48 03 01	 add	 rax, QWORD PTR [rcx]
  00157	48 89 44 24 68	 mov	 QWORD PTR tv86[rsp], rax
  0015c	eb 0d		 jmp	 SHORT $LN9@copy_rec
$LN8@copy_rec:
  0015e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR dptr$[rsp]
  00166	48 89 44 24 68	 mov	 QWORD PTR tv86[rsp], rax
$LN9@copy_rec:
  0016b	48 8b 44 24 68	 mov	 rax, QWORD PTR tv86[rsp]
  00170	48 89 44 24 60	 mov	 QWORD PTR xdptr$20520[rsp], rax

; 371  :         char *xsptr = ADJUST_PTR(sptr, ssuboffsets);

  00175	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR ssuboffsets$[rsp], 0
  0017e	74 2b		 je	 SHORT $LN10@copy_rec
  00180	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR ssuboffsets$[rsp]
  00188	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0018c	7c 1d		 jl	 SHORT $LN10@copy_rec
  0018e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR sptr$[rsp]
  00196	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00199	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ssuboffsets$[rsp]
  001a1	48 03 01	 add	 rax, QWORD PTR [rcx]
  001a4	48 89 44 24 70	 mov	 QWORD PTR tv90[rsp], rax
  001a9	eb 0d		 jmp	 SHORT $LN11@copy_rec
$LN10@copy_rec:
  001ab	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR sptr$[rsp]
  001b3	48 89 44 24 70	 mov	 QWORD PTR tv90[rsp], rax
$LN11@copy_rec:
  001b8	48 8b 44 24 70	 mov	 rax, QWORD PTR tv90[rsp]
  001bd	48 89 44 24 58	 mov	 QWORD PTR xsptr$20522[rsp], rax

; 372  : 
; 373  :         copy_rec(shape+1, ndim-1, itemsize,
; 374  :                  xdptr, dstrides+1, dsuboffsets ? dsuboffsets+1 : NULL,
; 375  :                  xsptr, sstrides+1, ssuboffsets ? ssuboffsets+1 : NULL,
; 376  :                  mem);

  001c2	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR ssuboffsets$[rsp], 0
  001cb	74 13		 je	 SHORT $LN12@copy_rec
  001cd	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR ssuboffsets$[rsp]
  001d5	48 83 c0 08	 add	 rax, 8
  001d9	48 89 44 24 78	 mov	 QWORD PTR tv94[rsp], rax
  001de	eb 09		 jmp	 SHORT $LN13@copy_rec
$LN12@copy_rec:
  001e0	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv94[rsp], 0
$LN13@copy_rec:
  001e9	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR dsuboffsets$[rsp], 0
  001f2	74 16		 je	 SHORT $LN14@copy_rec
  001f4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR dsuboffsets$[rsp]
  001fc	48 83 c0 08	 add	 rax, 8
  00200	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  00208	eb 0c		 jmp	 SHORT $LN15@copy_rec
$LN14@copy_rec:
  0020a	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv133[rsp], 0
$LN15@copy_rec:
  00216	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR sstrides$[rsp]
  0021e	48 83 c0 08	 add	 rax, 8
  00222	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dstrides$[rsp]
  0022a	48 83 c1 08	 add	 rcx, 8
  0022e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR ndim$[rsp]
  00236	48 ff ca	 dec	 rdx
  00239	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR shape$[rsp]
  00241	49 83 c0 08	 add	 r8, 8
  00245	4c 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv141[rsp], r8
  0024d	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR mem$[rsp]
  00255	4c 89 4c 24 48	 mov	 QWORD PTR [rsp+72], r9
  0025a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR tv94[rsp]
  0025f	4c 89 4c 24 40	 mov	 QWORD PTR [rsp+64], r9
  00264	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00269	48 8b 44 24 58	 mov	 rax, QWORD PTR xsptr$20522[rsp]
  0026e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00273	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv133[rsp]
  0027b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00280	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00285	4c 8b 4c 24 60	 mov	 r9, QWORD PTR xdptr$20520[rsp]
  0028a	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR itemsize$[rsp]
  00292	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv141[rsp]
  0029a	48 8b c8	 mov	 rcx, rax
  0029d	e8 00 00 00 00	 call	 copy_rec

; 377  :     }

  002a2	e9 1c fe ff ff	 jmp	 $LN2@copy_rec
$LN1@copy_rec:
$LN5@copy_rec:

; 378  : }

  002a7	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002ae	c3		 ret	 0
copy_rec ENDP
_TEXT	ENDS
EXTRN	__imp_memmove:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_base DD imagerel copy_base
	DD	imagerel copy_base+597
	DD	imagerel $unwind$copy_base
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_base DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT copy_base
_TEXT	SEGMENT
size$20474 = 32
p$20479 = 40
i$20480 = 48
xsptr$20484 = 56
xdptr$20489 = 64
tv83 = 72
tv94 = 80
shape$ = 112
itemsize$ = 120
dptr$ = 128
dstrides$ = 136
dsuboffsets$ = 144
sptr$ = 152
sstrides$ = 160
ssuboffsets$ = 168
mem$ = 176
copy_base PROC						; COMDAT

; 326  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 327  :     if (mem == NULL) { /* contiguous */

  00018	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR mem$[rsp], 0
  00021	0f 85 89 00 00
	00		 jne	 $LN11@copy_base

; 328  :         Py_ssize_t size = shape[0] * itemsize;

  00027	48 8b 44 24 70	 mov	 rax, QWORD PTR shape$[rsp]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	48 0f af 44 24
	78		 imul	 rax, QWORD PTR itemsize$[rsp]
  00035	48 89 44 24 20	 mov	 QWORD PTR size$20474[rsp], rax

; 329  :         if (dptr + size < sptr || sptr + size < dptr)

  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR size$20474[rsp]
  0003f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dptr$[rsp]
  00047	48 03 c8	 add	 rcx, rax
  0004a	48 8b c1	 mov	 rax, rcx
  0004d	48 3b 84 24 98
	00 00 00	 cmp	 rax, QWORD PTR sptr$[rsp]
  00055	72 1d		 jb	 SHORT $LN9@copy_base
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR size$20474[rsp]
  0005c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR sptr$[rsp]
  00064	48 03 c8	 add	 rcx, rax
  00067	48 8b c1	 mov	 rax, rcx
  0006a	48 3b 84 24 80
	00 00 00	 cmp	 rax, QWORD PTR dptr$[rsp]
  00072	73 1c		 jae	 SHORT $LN10@copy_base
$LN9@copy_base:

; 330  :             memcpy(dptr, sptr, size); /* no overlapping */

  00074	4c 8b 44 24 20	 mov	 r8, QWORD PTR size$20474[rsp]
  00079	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR sptr$[rsp]
  00081	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dptr$[rsp]
  00089	e8 00 00 00 00	 call	 memcpy

; 331  :         else

  0008e	eb 1b		 jmp	 SHORT $LN8@copy_base
$LN10@copy_base:

; 332  :             memmove(dptr, sptr, size);

  00090	4c 8b 44 24 20	 mov	 r8, QWORD PTR size$20474[rsp]
  00095	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR sptr$[rsp]
  0009d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dptr$[rsp]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN8@copy_base:

; 333  :     }
; 334  :     else {

  000ab	e9 a0 01 00 00	 jmp	 $LN7@copy_base
$LN11@copy_base:

; 335  :         char *p;
; 336  :         Py_ssize_t i;
; 337  :         for (i=0, p=mem; i < shape[0]; p+=itemsize, sptr+=sstrides[0], i++) {

  000b0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$20480[rsp], 0
  000b9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mem$[rsp]
  000c1	48 89 44 24 28	 mov	 QWORD PTR p$20479[rsp], rax
  000c6	eb 43		 jmp	 SHORT $LN6@copy_base
$LN5@copy_base:
  000c8	48 8b 44 24 78	 mov	 rax, QWORD PTR itemsize$[rsp]
  000cd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$20479[rsp]
  000d2	48 03 c8	 add	 rcx, rax
  000d5	48 8b c1	 mov	 rax, rcx
  000d8	48 89 44 24 28	 mov	 QWORD PTR p$20479[rsp], rax
  000dd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sstrides$[rsp]
  000e5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR sptr$[rsp]
  000f0	48 03 c8	 add	 rcx, rax
  000f3	48 8b c1	 mov	 rax, rcx
  000f6	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR sptr$[rsp], rax
  000fe	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20480[rsp]
  00103	48 ff c0	 inc	 rax
  00106	48 89 44 24 30	 mov	 QWORD PTR i$20480[rsp], rax
$LN6@copy_base:
  0010b	48 8b 44 24 70	 mov	 rax, QWORD PTR shape$[rsp]
  00110	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00113	48 39 44 24 30	 cmp	 QWORD PTR i$20480[rsp], rax
  00118	7d 66		 jge	 SHORT $LN4@copy_base

; 338  :             char *xsptr = ADJUST_PTR(sptr, ssuboffsets);

  0011a	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR ssuboffsets$[rsp], 0
  00123	74 2b		 je	 SHORT $LN14@copy_base
  00125	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ssuboffsets$[rsp]
  0012d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00131	7c 1d		 jl	 SHORT $LN14@copy_base
  00133	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sptr$[rsp]
  0013b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0013e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ssuboffsets$[rsp]
  00146	48 03 01	 add	 rax, QWORD PTR [rcx]
  00149	48 89 44 24 48	 mov	 QWORD PTR tv83[rsp], rax
  0014e	eb 0d		 jmp	 SHORT $LN15@copy_base
$LN14@copy_base:
  00150	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sptr$[rsp]
  00158	48 89 44 24 48	 mov	 QWORD PTR tv83[rsp], rax
$LN15@copy_base:
  0015d	48 8b 44 24 48	 mov	 rax, QWORD PTR tv83[rsp]
  00162	48 89 44 24 38	 mov	 QWORD PTR xsptr$20484[rsp], rax

; 339  :             memcpy(p, xsptr, itemsize);

  00167	4c 8b 44 24 78	 mov	 r8, QWORD PTR itemsize$[rsp]
  0016c	48 8b 54 24 38	 mov	 rdx, QWORD PTR xsptr$20484[rsp]
  00171	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$20479[rsp]
  00176	e8 00 00 00 00	 call	 memcpy

; 340  :         }

  0017b	e9 48 ff ff ff	 jmp	 $LN5@copy_base
$LN4@copy_base:

; 341  :         for (i=0, p=mem; i < shape[0]; p+=itemsize, dptr+=dstrides[0], i++) {

  00180	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$20480[rsp], 0
  00189	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR mem$[rsp]
  00191	48 89 44 24 28	 mov	 QWORD PTR p$20479[rsp], rax
  00196	eb 43		 jmp	 SHORT $LN3@copy_base
$LN2@copy_base:
  00198	48 8b 44 24 78	 mov	 rax, QWORD PTR itemsize$[rsp]
  0019d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$20479[rsp]
  001a2	48 03 c8	 add	 rcx, rax
  001a5	48 8b c1	 mov	 rax, rcx
  001a8	48 89 44 24 28	 mov	 QWORD PTR p$20479[rsp], rax
  001ad	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dstrides$[rsp]
  001b5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dptr$[rsp]
  001c0	48 03 c8	 add	 rcx, rax
  001c3	48 8b c1	 mov	 rax, rcx
  001c6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dptr$[rsp], rax
  001ce	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20480[rsp]
  001d3	48 ff c0	 inc	 rax
  001d6	48 89 44 24 30	 mov	 QWORD PTR i$20480[rsp], rax
$LN3@copy_base:
  001db	48 8b 44 24 70	 mov	 rax, QWORD PTR shape$[rsp]
  001e0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e3	48 39 44 24 30	 cmp	 QWORD PTR i$20480[rsp], rax
  001e8	7d 66		 jge	 SHORT $LN1@copy_base

; 342  :             char *xdptr = ADJUST_PTR(dptr, dsuboffsets);

  001ea	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dsuboffsets$[rsp], 0
  001f3	74 2b		 je	 SHORT $LN16@copy_base
  001f5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dsuboffsets$[rsp]
  001fd	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00201	7c 1d		 jl	 SHORT $LN16@copy_base
  00203	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dptr$[rsp]
  0020b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dsuboffsets$[rsp]
  00216	48 03 01	 add	 rax, QWORD PTR [rcx]
  00219	48 89 44 24 50	 mov	 QWORD PTR tv94[rsp], rax
  0021e	eb 0d		 jmp	 SHORT $LN17@copy_base
$LN16@copy_base:
  00220	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dptr$[rsp]
  00228	48 89 44 24 50	 mov	 QWORD PTR tv94[rsp], rax
$LN17@copy_base:
  0022d	48 8b 44 24 50	 mov	 rax, QWORD PTR tv94[rsp]
  00232	48 89 44 24 40	 mov	 QWORD PTR xdptr$20489[rsp], rax

; 343  :             memcpy(xdptr, p, itemsize);

  00237	4c 8b 44 24 78	 mov	 r8, QWORD PTR itemsize$[rsp]
  0023c	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$20479[rsp]
  00241	48 8b 4c 24 40	 mov	 rcx, QWORD PTR xdptr$20489[rsp]
  00246	e8 00 00 00 00	 call	 memcpy

; 344  :         }

  0024b	e9 48 ff ff ff	 jmp	 $LN2@copy_base
$LN1@copy_base:
$LN7@copy_base:

; 345  :     }
; 346  : 
; 347  : }

  00250	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00254	c3		 ret	 0
copy_base ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_fortran_strides_from_shape DD imagerel init_fortran_strides_from_shape
	DD	imagerel init_fortran_strides_from_shape+173
	DD	imagerel $unwind$init_fortran_strides_from_shape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_fortran_strides_from_shape DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT init_fortran_strides_from_shape
_TEXT	SEGMENT
i$ = 32
view$ = 64
init_fortran_strides_from_shape PROC			; COMDAT

; 458  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 459  :     Py_ssize_t i;
; 460  : 
; 461  :     assert(view->ndim > 0);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  0000e	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00012	7f 1c		 jg	 SHORT $LN6@init_fortr
  00014	41 b8 cd 01 00
	00		 mov	 r8d, 461		; 000001cdH
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@IOIDCJGK@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002e	33 c0		 xor	 eax, eax
$LN6@init_fortr:

; 462  : 
; 463  :     view->strides[0] = view->itemsize;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  00035	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR view$[rsp]
  0003e	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00042	48 89 08	 mov	 QWORD PTR [rax], rcx

; 464  :     for (i = 1; i < view->ndim; i++)

  00045	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR i$[rsp], 1
  0004e	eb 0d		 jmp	 SHORT $LN3@init_fortr
$LN2@init_fortr:
  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00055	48 ff c0	 inc	 rax
  00058	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@init_fortr:
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  00062	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00066	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0006b	7d 3b		 jge	 SHORT $LN1@init_fortr

; 465  :         view->strides[i] = view->strides[i-1] * view->shape[i-1];

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  00072	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR view$[rsp]
  0007b	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0007f	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00084	4c 8b 44 24 20	 mov	 r8, QWORD PTR i$[rsp]
  00089	48 8b 44 d0 f8	 mov	 rax, QWORD PTR [rax+rdx*8-8]
  0008e	4a 0f af 44 c1
	f8		 imul	 rax, QWORD PTR [rcx+r8*8-8]
  00094	48 8b 4c 24 40	 mov	 rcx, QWORD PTR view$[rsp]
  00099	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0009d	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  000a2	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  000a6	eb a8		 jmp	 SHORT $LN2@init_fortr
$LN1@init_fortr:

; 466  : }

  000a8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ac	c3		 ret	 0
init_fortran_strides_from_shape ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CO@POJBHGDN@?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAM?$AAA?$AAX?$AA_?$AAN?$AAD?$AAI?$AAM?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_add_incomplete_view DD imagerel mbuf_add_incomplete_view
	DD	imagerel mbuf_add_incomplete_view+188
	DD	imagerel $unwind$mbuf_add_incomplete_view
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_add_incomplete_view DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1CO@POJBHGDN@?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAM?$AAA?$AAX?$AA_?$AAN?$AAD?$AAI?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@POJBHGDN@?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAM?$AAA?$AAX?$AA_?$AAN?$AAD?$AAI?$AAM?$AA?$AA@ DB 'n'
	DB	00H, 'd', 00H, 'i', 00H, 'm', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, 'P', 00H, 'y', 00H, 'B', 00H, 'U', 00H, 'F', 00H, '_'
	DB	00H, 'M', 00H, 'A', 00H, 'X', 00H, '_', 00H, 'N', 00H, 'D', 00H
	DB	'I', 00H, 'M', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mbuf_add_incomplete_view
_TEXT	SEGMENT
dest$ = 32
mv$ = 40
mbuf$ = 64
src$ = 72
ndim$ = 80
mbuf_add_incomplete_view PROC				; COMDAT

; 692  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 693  :     PyMemoryViewObject *mv;
; 694  :     Py_buffer *dest;
; 695  : 
; 696  :     if (src == NULL)

  00013	48 83 7c 24 48
	00		 cmp	 QWORD PTR src$[rsp], 0
  00019	75 0e		 jne	 SHORT $LN2@mbuf_add_i

; 697  :         src = &mbuf->master;

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR mbuf$[rsp]
  00020	48 83 c0 70	 add	 rax, 112		; 00000070H
  00024	48 89 44 24 48	 mov	 QWORD PTR src$[rsp], rax
$LN2@mbuf_add_i:

; 698  : 
; 699  :     assert(ndim <= PyBUF_MAX_NDIM);

  00029	83 7c 24 50 40	 cmp	 DWORD PTR ndim$[rsp], 64 ; 00000040H
  0002e	7e 1c		 jle	 SHORT $LN5@mbuf_add_i
  00030	41 b8 bb 02 00
	00		 mov	 r8d, 699		; 000002bbH
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@POJBHGDN@?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AAB?$AAU?$AAF?$AA_?$AAM?$AAA?$AAX?$AA_?$AAN?$AAD?$AAI?$AAM?$AA?$AA@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004a	33 c0		 xor	 eax, eax
$LN5@mbuf_add_i:

; 700  : 
; 701  :     mv = memory_alloc(ndim);

  0004c	8b 4c 24 50	 mov	 ecx, DWORD PTR ndim$[rsp]
  00050	e8 00 00 00 00	 call	 memory_alloc
  00055	48 89 44 24 28	 mov	 QWORD PTR mv$[rsp], rax

; 702  :     if (mv == NULL)

  0005a	48 83 7c 24 28
	00		 cmp	 QWORD PTR mv$[rsp], 0
  00060	75 04		 jne	 SHORT $LN1@mbuf_add_i

; 703  :         return NULL;

  00062	33 c0		 xor	 eax, eax
  00064	eb 51		 jmp	 SHORT $LN3@mbuf_add_i
$LN1@mbuf_add_i:

; 704  : 
; 705  :     dest = &mv->view;

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR mv$[rsp]
  0006b	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00071	48 89 44 24 20	 mov	 QWORD PTR dest$[rsp], rax

; 706  :     init_shared_values(dest, src);

  00076	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dest$[rsp]
  00080	e8 00 00 00 00	 call	 init_shared_values

; 707  : 
; 708  :     mv->mbuf = mbuf;

  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR mv$[rsp]
  0008a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mbuf$[rsp]
  0008f	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 709  :     Py_INCREF(mbuf);

  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mbuf$[rsp]
  00098	e8 00 00 00 00	 call	 _Py_IncRef

; 710  :     mbuf->exports++;

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR mbuf$[rsp]
  000a2	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a6	48 ff c0	 inc	 rax
  000a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mbuf$[rsp]
  000ae	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 711  : 
; 712  :     return (PyObject *)mv;

  000b2	48 8b 44 24 28	 mov	 rax, QWORD PTR mv$[rsp]
$LN3@mbuf_add_i:

; 713  : }

  000b7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bb	c3		 ret	 0
mbuf_add_incomplete_view ENDP
_TEXT	ENDS
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_copy_format DD imagerel mbuf_copy_format
	DD	imagerel mbuf_copy_format+121
	DD	imagerel $unwind$mbuf_copy_format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_copy_format DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mbuf_copy_format
_TEXT	SEGMENT
cp$20798 = 32
mbuf$ = 64
fmt$ = 72
mbuf_copy_format PROC					; COMDAT

; 806  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 807  :     if (fmt != NULL) {

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR fmt$[rsp], 0
  00014	74 5c		 je	 SHORT $LN2@mbuf_copy_

; 808  :         char *cp = PyMem_Malloc(strlen(fmt)+1);

  00016	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fmt$[rsp]
  0001b	e8 00 00 00 00	 call	 strlen
  00020	48 ff c0	 inc	 rax
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 PyMem_Malloc
  0002b	48 89 44 24 20	 mov	 QWORD PTR cp$20798[rsp], rax

; 809  :         if (cp == NULL) {

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR cp$20798[rsp], 0
  00036	75 0c		 jne	 SHORT $LN1@mbuf_copy_

; 810  :             PyErr_NoMemory();

  00038	e8 00 00 00 00	 call	 PyErr_NoMemory

; 811  :             return -1;

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	eb 30		 jmp	 SHORT $LN3@mbuf_copy_
$LN1@mbuf_copy_:

; 812  :         }
; 813  :         mbuf->master.format = strcpy(cp, fmt);

  00044	48 8b 54 24 48	 mov	 rdx, QWORD PTR fmt$[rsp]
  00049	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cp$20798[rsp]
  0004e	e8 00 00 00 00	 call	 strcpy
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mbuf$[rsp]
  00058	48 89 81 98 00
	00 00		 mov	 QWORD PTR [rcx+152], rax

; 814  :         mbuf->flags |= _Py_MANAGED_BUFFER_FREE_FORMAT;

  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR mbuf$[rsp]
  00064	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00067	83 c8 02	 or	 eax, 2
  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mbuf$[rsp]
  0006f	89 41 60	 mov	 DWORD PTR [rcx+96], eax
$LN2@mbuf_copy_:

; 815  :     }
; 816  : 
; 817  :     return 0;

  00072	33 c0		 xor	 eax, eax
$LN3@mbuf_copy_:

; 818  : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
mbuf_copy_format ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NFAFDFHO@O?3memoryview?$AA@		; `string'
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_new DD imagerel memory_new
	DD	imagerel memory_new+81
	DD	imagerel $unwind$memory_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_new DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0N@NFAFDFHO@O?3memoryview?$AA@
CONST	SEGMENT
??_C@_0N@NFAFDFHO@O?3memoryview?$AA@ DB 'O:memoryview', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_new
_TEXT	SEGMENT
obj$ = 48
subtype$ = 80
args$ = 88
kwds$ = 96
memory_new PROC						; COMDAT

; 950  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 951  :     PyObject *obj;
; 952  :     static char *kwlist[] = {"object", NULL};
; 953  : 
; 954  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:memoryview", kwlist,
; 955  :                                      &obj)) {

  00013	48 8d 44 24 30	 lea	 rax, QWORD PTR obj$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??memory_new@@9@9
  00024	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@NFAFDFHO@O?3memoryview?$AA@
  0002b	48 8b 54 24 60	 mov	 rdx, QWORD PTR kwds$[rsp]
  00030	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00035	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0003a	85 c0		 test	 eax, eax
  0003c	75 04		 jne	 SHORT $LN1@memory_new

; 956  :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 0a		 jmp	 SHORT $LN2@memory_new
$LN1@memory_new:

; 957  :     }
; 958  : 
; 959  :     return PyMemoryView_FromObject(obj);

  00042	48 8b 4c 24 30	 mov	 rcx, QWORD PTR obj$[rsp]
  00047	e8 00 00 00 00	 call	 PyMemoryView_FromObject
$LN2@memory_new:

; 960  : }

  0004c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00050	c3		 ret	 0
memory_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@GJDLHDMI@PyBuffer_ToContiguous?3?5len?5?$CB?$DN?5vi@ ; `string'
PUBLIC	PyBuffer_ToContiguous
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_ToContiguous DD imagerel $LN7
	DD	imagerel $LN7+434
	DD	imagerel $unwind$PyBuffer_ToContiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_ToContiguous DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT ??_C@_0CI@GJDLHDMI@PyBuffer_ToContiguous?3?5len?5?$CB?$DN?5vi@
CONST	SEGMENT
??_C@_0CI@GJDLHDMI@PyBuffer_ToContiguous?3?5len?5?$CB?$DN?5vi@ DB 'PyBuff'
	DB	'er_ToContiguous: len != view->len', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBuffer_ToContiguous
_TEXT	SEGMENT
fb$ = 32
ret$ = 40
buf$ = 64
src$ = 72
len$ = 80
order$ = 88
PyBuffer_ToContiguous PROC				; COMDAT

; 974  : {

$LN7:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 975  :     Py_buffer_full *fb = NULL;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR fb$[rsp], 0

; 976  :     int ret;
; 977  : 
; 978  :     assert(order == 'C' || order == 'F' || order == 'A');

  00021	0f be 44 24 58	 movsx	 eax, BYTE PTR order$[rsp]
  00026	83 f8 43	 cmp	 eax, 67			; 00000043H
  00029	74 30		 je	 SHORT $LN6@PyBuffer_T
  0002b	0f be 44 24 58	 movsx	 eax, BYTE PTR order$[rsp]
  00030	83 f8 46	 cmp	 eax, 70			; 00000046H
  00033	74 26		 je	 SHORT $LN6@PyBuffer_T
  00035	0f be 44 24 58	 movsx	 eax, BYTE PTR order$[rsp]
  0003a	83 f8 41	 cmp	 eax, 65			; 00000041H
  0003d	74 1c		 je	 SHORT $LN6@PyBuffer_T
  0003f	41 b8 d2 03 00
	00		 mov	 r8d, 978		; 000003d2H
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@KLDJBKOL@?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAC?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAF?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5@
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00059	33 c0		 xor	 eax, eax
$LN6@PyBuffer_T:

; 979  : 
; 980  :     if (len != src->len) {

  0005b	48 8b 44 24 48	 mov	 rax, QWORD PTR src$[rsp]
  00060	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00064	48 39 44 24 50	 cmp	 QWORD PTR len$[rsp], rax
  00069	74 1d		 je	 SHORT $LN3@PyBuffer_T

; 981  :         PyErr_SetString(PyExc_ValueError,
; 982  :             "PyBuffer_ToContiguous: len != view->len");

  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@GJDLHDMI@PyBuffer_ToContiguous?3?5len?5?$CB?$DN?5vi@
  00072	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00079	e8 00 00 00 00	 call	 PyErr_SetString

; 983  :         return -1;

  0007e	b8 ff ff ff ff	 mov	 eax, -1
  00083	e9 25 01 00 00	 jmp	 $LN4@PyBuffer_T
$LN3@PyBuffer_T:

; 984  :     }
; 985  : 
; 986  :     if (PyBuffer_IsContiguous(src, order)) {

  00088	0f b6 54 24 58	 movzx	 edx, BYTE PTR order$[rsp]
  0008d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR src$[rsp]
  00092	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  00097	85 c0		 test	 eax, eax
  00099	74 1e		 je	 SHORT $LN2@PyBuffer_T

; 987  :         memcpy((char *)buf, src->buf, len);

  0009b	4c 8b 44 24 50	 mov	 r8, QWORD PTR len$[rsp]
  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR src$[rsp]
  000a5	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf$[rsp]
  000ad	e8 00 00 00 00	 call	 memcpy

; 988  :         return 0;

  000b2	33 c0		 xor	 eax, eax
  000b4	e9 f4 00 00 00	 jmp	 $LN4@PyBuffer_T
$LN2@PyBuffer_T:

; 989  :     }
; 990  : 
; 991  :     /* buffer_to_contiguous() assumes PyBUF_FULL */
; 992  :     fb = PyMem_Malloc(sizeof *fb + 3 * src->ndim * (sizeof *fb->array));

  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR src$[rsp]
  000be	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000c1	6b c0 03	 imul	 eax, 3
  000c4	48 98		 cdqe
  000c6	48 8d 04 c5 58
	00 00 00	 lea	 rax, QWORD PTR [rax*8+88]
  000ce	48 8b c8	 mov	 rcx, rax
  000d1	e8 00 00 00 00	 call	 PyMem_Malloc
  000d6	48 89 44 24 20	 mov	 QWORD PTR fb$[rsp], rax

; 993  :     if (fb == NULL) {

  000db	48 83 7c 24 20
	00		 cmp	 QWORD PTR fb$[rsp], 0
  000e1	75 0f		 jne	 SHORT $LN1@PyBuffer_T

; 994  :         PyErr_NoMemory();

  000e3	e8 00 00 00 00	 call	 PyErr_NoMemory

; 995  :         return -1;

  000e8	b8 ff ff ff ff	 mov	 eax, -1
  000ed	e9 bb 00 00 00	 jmp	 $LN4@PyBuffer_T
$LN1@PyBuffer_T:

; 996  :     }
; 997  :     fb->view.ndim = src->ndim;

  000f2	48 8b 44 24 20	 mov	 rax, QWORD PTR fb$[rsp]
  000f7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR src$[rsp]
  000fc	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  000ff	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 998  :     fb->view.shape = fb->array;

  00102	48 8b 44 24 20	 mov	 rax, QWORD PTR fb$[rsp]
  00107	48 83 c0 50	 add	 rax, 80			; 00000050H
  0010b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fb$[rsp]
  00110	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 999  :     fb->view.strides = fb->array + src->ndim;

  00114	48 8b 44 24 48	 mov	 rax, QWORD PTR src$[rsp]
  00119	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  0011d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fb$[rsp]
  00122	48 8d 44 c1 50	 lea	 rax, QWORD PTR [rcx+rax*8+80]
  00127	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fb$[rsp]
  0012c	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 1000 :     fb->view.suboffsets = fb->array + 2 * src->ndim;

  00130	48 8b 44 24 48	 mov	 rax, QWORD PTR src$[rsp]
  00135	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00138	d1 e0		 shl	 eax, 1
  0013a	48 98		 cdqe
  0013c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fb$[rsp]
  00141	48 8d 44 c1 50	 lea	 rax, QWORD PTR [rcx+rax*8+80]
  00146	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fb$[rsp]
  0014b	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 1001 : 
; 1002 :     init_shared_values(&fb->view, src);

  0014f	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  00154	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fb$[rsp]
  00159	e8 00 00 00 00	 call	 init_shared_values

; 1003 :     init_shape_strides(&fb->view, src);

  0015e	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  00163	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fb$[rsp]
  00168	e8 00 00 00 00	 call	 init_shape_strides

; 1004 :     init_suboffsets(&fb->view, src);

  0016d	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  00172	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fb$[rsp]
  00177	e8 00 00 00 00	 call	 init_suboffsets

; 1005 : 
; 1006 :     src = &fb->view;

  0017c	48 8b 44 24 20	 mov	 rax, QWORD PTR fb$[rsp]
  00181	48 89 44 24 48	 mov	 QWORD PTR src$[rsp], rax

; 1007 : 
; 1008 :     ret = buffer_to_contiguous(buf, src, order);

  00186	44 0f b6 44 24
	58		 movzx	 r8d, BYTE PTR order$[rsp]
  0018c	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  00191	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf$[rsp]
  00196	e8 00 00 00 00	 call	 buffer_to_contiguous
  0019b	89 44 24 28	 mov	 DWORD PTR ret$[rsp], eax

; 1009 :     PyMem_Free(fb);

  0019f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fb$[rsp]
  001a4	e8 00 00 00 00	 call	 PyMem_Free

; 1010 :     return ret;

  001a9	8b 44 24 28	 mov	 eax, DWORD PTR ret$[rsp]
$LN4@PyBuffer_T:

; 1011 : }

  001ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001b1	c3		 ret	 0
PyBuffer_ToContiguous ENDP
_TEXT	ENDS
PUBLIC	$T23388
PUBLIC	??_C@_1CK@OBGDMHMH@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@NMFLFDOJ@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$buffer_to_contiguous DD imagerel buffer_to_contiguous
	DD	imagerel buffer_to_contiguous+388
	DD	imagerel $unwind$buffer_to_contiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$buffer_to_contiguous DD 041801H
	DD	01d0118H
	DD	060107011H
xdata	ENDS
;	COMDAT ??_C@_1CK@OBGDMHMH@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@OBGDMHMH@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, 'c', 00H, '-', 00H, '>', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 's', 00H, ' ', 00H, '!'
	DB	00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@NMFLFDOJ@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@NMFLFDOJ@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, 'c', 00H, '-', 00H, '>', 00H, 'n', 00H, 'd', 00H
	DB	'i', 00H, 'm', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT buffer_to_contiguous
_TEXT	SEGMENT
strides$ = 32
dest$ = 48
ret$ = 128
$T23388 = 136
mem$ = 256
src$ = 264
order$ = 272
buffer_to_contiguous PROC				; COMDAT

; 473  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 474  :     Py_buffer dest;
; 475  :     Py_ssize_t *strides;
; 476  :     int ret;
; 477  : 
; 478  :     assert(src->ndim >= 1);

  00018	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR src$[rsp]
  00020	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  00024	7d 1c		 jge	 SHORT $LN7@buffer_to_
  00026	41 b8 de 01 00
	00		 mov	 r8d, 478		; 000001deH
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@NMFLFDOJ@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00040	33 c0		 xor	 eax, eax
$LN7@buffer_to_:

; 479  :     assert(src->shape != NULL);

  00042	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR src$[rsp]
  0004a	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0004f	75 1c		 jne	 SHORT $LN8@buffer_to_
  00051	41 b8 df 01 00
	00		 mov	 r8d, 479		; 000001dfH
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@FJBAFCEJ@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006b	33 c0		 xor	 eax, eax
$LN8@buffer_to_:

; 480  :     assert(src->strides != NULL);

  0006d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR src$[rsp]
  00075	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0007a	75 1c		 jne	 SHORT $LN9@buffer_to_
  0007c	41 b8 e0 01 00
	00		 mov	 r8d, 480		; 000001e0H
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@OBGDMHMH@?$AAs?$AAr?$AAc?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00096	33 c0		 xor	 eax, eax
$LN9@buffer_to_:

; 481  : 
; 482  :     strides = PyMem_Malloc(src->ndim * (sizeof *src->strides));

  00098	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR src$[rsp]
  000a0	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  000a4	48 c1 e0 03	 shl	 rax, 3
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	e8 00 00 00 00	 call	 PyMem_Malloc
  000b0	48 89 44 24 20	 mov	 QWORD PTR strides$[rsp], rax

; 483  :     if (strides == NULL) {

  000b5	48 83 7c 24 20
	00		 cmp	 QWORD PTR strides$[rsp], 0
  000bb	75 0f		 jne	 SHORT $LN4@buffer_to_

; 484  :         PyErr_NoMemory();

  000bd	e8 00 00 00 00	 call	 PyErr_NoMemory

; 485  :         return -1;

  000c2	b8 ff ff ff ff	 mov	 eax, -1
  000c7	e9 ae 00 00 00	 jmp	 $LN5@buffer_to_
$LN4@buffer_to_:

; 486  :     }
; 487  : 
; 488  :     /* initialize dest */
; 489  :     dest = *src;

  000cc	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR $T23388[rsp]
  000d4	48 8b f8	 mov	 rdi, rax
  000d7	48 8b b4 24 08
	01 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000df	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  000e4	f3 a4		 rep movsb
  000e6	48 8d 44 24 30	 lea	 rax, QWORD PTR dest$[rsp]
  000eb	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR $T23388[rsp]
  000f3	48 8b f8	 mov	 rdi, rax
  000f6	48 8b f1	 mov	 rsi, rcx
  000f9	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  000fe	f3 a4		 rep movsb

; 490  :     dest.buf = mem;

  00100	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR mem$[rsp]
  00108	48 89 44 24 30	 mov	 QWORD PTR dest$[rsp], rax

; 491  :     /* shape is constant and shared: the logical representation of the
; 492  :        array is unaltered. */
; 493  : 
; 494  :     /* The physical representation determined by strides (and possibly
; 495  :        suboffsets) may change. */
; 496  :     dest.strides = strides;

  0010d	48 8b 44 24 20	 mov	 rax, QWORD PTR strides$[rsp]
  00112	48 89 44 24 68	 mov	 QWORD PTR dest$[rsp+56], rax

; 497  :     if (order == 'C' || order == 'A') {

  00117	0f be 84 24 10
	01 00 00	 movsx	 eax, BYTE PTR order$[rsp]
  0011f	83 f8 43	 cmp	 eax, 67			; 00000043H
  00122	74 0d		 je	 SHORT $LN2@buffer_to_
  00124	0f be 84 24 10
	01 00 00	 movsx	 eax, BYTE PTR order$[rsp]
  0012c	83 f8 41	 cmp	 eax, 65			; 00000041H
  0012f	75 0c		 jne	 SHORT $LN3@buffer_to_
$LN2@buffer_to_:

; 498  :         init_strides_from_shape(&dest);

  00131	48 8d 4c 24 30	 lea	 rcx, QWORD PTR dest$[rsp]
  00136	e8 00 00 00 00	 call	 init_strides_from_shape

; 499  :     }
; 500  :     else {

  0013b	eb 0a		 jmp	 SHORT $LN1@buffer_to_
$LN3@buffer_to_:

; 501  :         init_fortran_strides_from_shape(&dest);

  0013d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR dest$[rsp]
  00142	e8 00 00 00 00	 call	 init_fortran_strides_from_shape
$LN1@buffer_to_:

; 502  :     }
; 503  : 
; 504  :     dest.suboffsets = NULL;

  00147	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR dest$[rsp+64], 0

; 505  : 
; 506  :     ret = copy_buffer(&dest, src);

  00150	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  00158	48 8d 4c 24 30	 lea	 rcx, QWORD PTR dest$[rsp]
  0015d	e8 00 00 00 00	 call	 copy_buffer
  00162	89 84 24 80 00
	00 00		 mov	 DWORD PTR ret$[rsp], eax

; 507  : 
; 508  :     PyMem_Free(strides);

  00169	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strides$[rsp]
  0016e	e8 00 00 00 00	 call	 PyMem_Free

; 509  :     return ret;

  00173	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR ret$[rsp]
$LN5@buffer_to_:

; 510  : }

  0017a	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00181	5f		 pop	 rdi
  00182	5e		 pop	 rsi
  00183	c3		 ret	 0
buffer_to_contiguous ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_release DD imagerel memory_release
	DD	imagerel memory_release+56
	DD	imagerel $unwind$memory_release
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_release DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_release
_TEXT	SEGMENT
self$ = 48
noargs$ = 56
memory_release PROC					; COMDAT

; 1050 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1051 :     if (_memory_release(self) < 0)

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 _memory_release
  00018	85 c0		 test	 eax, eax
  0001a	7d 04		 jge	 SHORT $LN1@memory_rel

; 1052 :         return NULL;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 13		 jmp	 SHORT $LN2@memory_rel
$LN1@memory_rel:

; 1053 :     Py_RETURN_NONE;

  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00027	e8 00 00 00 00	 call	 _Py_IncRef
  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@memory_rel:

; 1054 : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
memory_release ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@PAJHFMGJ@_memory_release?$CI?$CJ?3?5negative?5expo@ ; `string'
PUBLIC	??_C@_0CF@MCKFMDHA@memoryview?5has?5?$CFzd?5exported?5buff@ ; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_1DA@CMPKIPFP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAb?$AAu?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_memory_release DD imagerel _memory_release
	DD	imagerel _memory_release+308
	DD	imagerel $unwind$_memory_release
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_memory_release DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CJ@PAJHFMGJ@_memory_release?$CI?$CJ?3?5negative?5expo@
CONST	SEGMENT
??_C@_0CJ@PAJHFMGJ@_memory_release?$CI?$CJ?3?5negative?5expo@ DB '_memory'
	DB	'_release(): negative export count', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MCKFMDHA@memoryview?5has?5?$CFzd?5exported?5buff@
CONST	SEGMENT
??_C@_0CF@MCKFMDHA@memoryview?5has?5?$CFzd?5exported?5buff@ DB 'memoryvie'
	DB	'w has %zd exported buffer%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@CMPKIPFP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAb?$AAu?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@CMPKIPFP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAb?$AAu?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 'm', 00H
	DB	'b', 00H, 'u', 00H, 'f', 00H, '-', 00H, '>', 00H, 'e', 00H, 'x'
	DB	00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, 's', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _memory_release
_TEXT	SEGMENT
tv83 = 32
tv92 = 40
self$ = 64
_memory_release PROC					; COMDAT

; 1026 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1027 :     if (self->flags & _Py_MEMORYVIEW_RELEASED)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	74 07		 je	 SHORT $LN4@memory_rel@2

; 1028 :         return 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	e9 0d 01 00 00	 jmp	 $LN5@memory_rel@2
$LN4@memory_rel@2:

; 1029 : 
; 1030 :     if (self->exports == 0) {

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0002f	0f 85 86 00 00
	00		 jne	 $LN3@memory_rel@2

; 1031 :         self->flags |= _Py_MEMORYVIEW_RELEASED;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00040	83 c8 01	 or	 eax, 1
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00048	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 1032 :         assert(self->mbuf->exports > 0);

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00053	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00057	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0005c	7f 1c		 jg	 SHORT $LN7@memory_rel@2
  0005e	41 b8 08 04 00
	00		 mov	 r8d, 1032		; 00000408H
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CMPKIPFP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAm?$AAb?$AAu?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00078	33 c0		 xor	 eax, eax
$LN7@memory_rel@2:

; 1033 :         if (--self->mbuf->exports == 0)

  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0007f	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00083	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00087	48 ff c8	 dec	 rax
  0008a	48 89 44 24 20	 mov	 QWORD PTR tv83[rsp], rax
  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00094	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00098	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv83[rsp]
  0009d	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000a1	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv83[rsp], 0
  000a7	75 0e		 jne	 SHORT $LN2@memory_rel@2

; 1034 :             mbuf_release(self->mbuf);

  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000ae	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000b2	e8 00 00 00 00	 call	 mbuf_release
$LN2@memory_rel@2:

; 1035 :         return 0;

  000b7	33 c0		 xor	 eax, eax
  000b9	eb 74		 jmp	 SHORT $LN5@memory_rel@2
$LN3@memory_rel@2:

; 1036 :     }
; 1037 :     if (self->exports > 0) {

  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c0	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  000c8	7e 54		 jle	 SHORT $LN1@memory_rel@2

; 1038 :         PyErr_Format(PyExc_BufferError,
; 1039 :             "memoryview has %zd exported buffer%s", self->exports,
; 1040 :             self->exports==1 ? "" : "s");

  000ca	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000cf	48 83 b8 88 00
	00 00 01	 cmp	 QWORD PTR [rax+136], 1
  000d7	75 0e		 jne	 SHORT $LN8@memory_rel@2
  000d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000e0	48 89 44 24 28	 mov	 QWORD PTR tv92[rsp], rax
  000e5	eb 0c		 jmp	 SHORT $LN9@memory_rel@2
$LN8@memory_rel@2:
  000e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  000ee	48 89 44 24 28	 mov	 QWORD PTR tv92[rsp], rax
$LN9@memory_rel@2:
  000f3	4c 8b 4c 24 28	 mov	 r9, QWORD PTR tv92[rsp]
  000f8	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000fd	4c 8b 80 88 00
	00 00		 mov	 r8, QWORD PTR [rax+136]
  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@MCKFMDHA@memoryview?5has?5?$CFzd?5exported?5buff@
  0010b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00112	e8 00 00 00 00	 call	 PyErr_Format

; 1041 :         return -1;

  00117	b8 ff ff ff ff	 mov	 eax, -1
  0011c	eb 11		 jmp	 SHORT $LN5@memory_rel@2
$LN1@memory_rel@2:

; 1042 :     }
; 1043 : 
; 1044 :     Py_FatalError("_memory_release(): negative export count");

  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@PAJHFMGJ@_memory_release?$CI?$CJ?3?5negative?5expo@
  00125	e8 00 00 00 00	 call	 Py_FatalError

; 1045 :     return -1;

  0012a	b8 ff ff ff ff	 mov	 eax, -1
$LN5@memory_rel@2:

; 1046 : }

  0012f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00133	c3		 ret	 0
_memory_release ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@OCGMNPFP@memory_dealloc?$AA@		; `string'
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_dealloc DD imagerel memory_dealloc
	DD	imagerel memory_dealloc+442
	DD	imagerel $unwind$memory_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_dealloc DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0P@OCGMNPFP@memory_dealloc?$AA@
CONST	SEGMENT
??_C@_0P@OCGMNPFP@memory_dealloc?$AA@ DB 'memory_dealloc', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_dealloc
_TEXT	SEGMENT
g$20946 = 48
_py_tmp$20956 = 56
tv85 = 64
self$ = 96
memory_dealloc PROC					; COMDAT

; 1058 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1059 :     assert(self->exports == 0);

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00016	74 1c		 je	 SHORT $LN12@memory_dea
  00018	41 b8 23 04 00
	00		 mov	 r8d, 1059		; 00000423H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@OCBNCNJM@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAe?$AAx?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00032	33 c0		 xor	 eax, eax
$LN12@memory_dea:

; 1060 :     _PyObject_GC_UNTRACK(self);

  00034	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0003c	4c 8b 4c 24 60	 mov	 r9, QWORD PTR self$[rsp]
  00041	41 b8 24 04 00
	00		 mov	 r8d, 1060		; 00000424H
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OCGMNPFP@memory_dealloc?$AA@
  00055	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005a	85 c0		 test	 eax, eax
  0005c	0f 85 c1 00 00
	00		 jne	 $LN9@memory_dea
$LN8@memory_dea:
  00062	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0006a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR self$[rsp]
  0006f	41 b8 24 04 00
	00		 mov	 r8d, 1060		; 00000424H
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OCGMNPFP@memory_dealloc?$AA@
  00083	e8 00 00 00 00	 call	 _PyParallel_Guard
  00088	85 c0		 test	 eax, eax
  0008a	74 0b		 je	 SHORT $LN13@memory_dea
  0008c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv85[rsp], 0
  00095	eb 0e		 jmp	 SHORT $LN14@memory_dea
$LN13@memory_dea:
  00097	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 e8 18	 sub	 rax, 24
  000a0	48 89 44 24 40	 mov	 QWORD PTR tv85[rsp], rax
$LN14@memory_dea:
  000a5	48 8b 44 24 40	 mov	 rax, QWORD PTR tv85[rsp]
  000aa	48 89 44 24 30	 mov	 QWORD PTR g$20946[rsp], rax
  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20946[rsp]
  000b4	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  000b9	75 1c		 jne	 SHORT $LN15@memory_dea
  000bb	41 b8 24 04 00
	00		 mov	 r8d, 1060		; 00000424H
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d5	33 c0		 xor	 eax, eax
$LN15@memory_dea:
  000d7	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20946[rsp]
  000dc	48 c7 40 10 fe
	ff ff ff	 mov	 QWORD PTR [rax+16], -2
  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20946[rsp]
  000e9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$20946[rsp]
  000f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000f5	48 89 08	 mov	 QWORD PTR [rax], rcx
  000f8	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20946[rsp]
  000fd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00100	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$20946[rsp]
  00105	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00109	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0010d	48 8b 44 24 30	 mov	 rax, QWORD PTR g$20946[rsp]
  00112	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 3f ff ff
	ff		 jne	 $LN8@memory_dea
$LN9@memory_dea:

; 1061 :     (void)_memory_release(self);

  00123	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00128	e8 00 00 00 00	 call	 _memory_release
$LN5@memory_dea:

; 1062 :     Py_CLEAR(self->mbuf);

  0012d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00132	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00137	74 53		 je	 SHORT $LN2@memory_dea
  00139	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00141	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00146	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  0014a	41 b8 26 04 00
	00		 mov	 r8d, 1062		; 00000426H
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OCGMNPFP@memory_dealloc?$AA@
  0015e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00163	85 c0		 test	 eax, eax
  00165	75 25		 jne	 SHORT $LN2@memory_dea
  00167	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0016c	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00170	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$20956[rsp], rax
  00175	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0017a	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  00182	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$20956[rsp]
  00187	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@memory_dea:
  0018c	33 c0		 xor	 eax, eax
  0018e	85 c0		 test	 eax, eax
  00190	75 9b		 jne	 SHORT $LN5@memory_dea

; 1063 :     if (self->weakreflist != NULL)

  00192	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00197	48 83 b8 e8 00
	00 00 00	 cmp	 QWORD PTR [rax+232], 0
  0019f	74 0a		 je	 SHORT $LN1@memory_dea

; 1064 :         PyObject_ClearWeakRefs((PyObject *) self);

  001a1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001a6	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN1@memory_dea:

; 1065 :     PyObject_GC_Del(self);

  001ab	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001b0	e8 00 00 00 00	 call	 PyObject_GC_Del

; 1066 : }

  001b5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b9	c3		 ret	 0
memory_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@CIAKKKKF@memory_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_traverse DD imagerel memory_traverse
	DD	imagerel memory_traverse+116
	DD	imagerel $unwind$memory_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BA@CIAKKKKF@memory_traverse?$AA@
CONST	SEGMENT
??_C@_0BA@CIAKKKKF@memory_traverse?$AA@ DB 'memory_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_traverse
_TEXT	SEGMENT
vret$20977 = 32
self$ = 64
visit$ = 72
arg$ = 80
memory_traverse PROC					; COMDAT

; 1070 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@memory_tra:

; 1071 :     Py_VISIT(self->mbuf);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@memory_tra
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 2f 04 00
	00		 mov	 r8d, 1071		; 0000042fH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CIAKKKKF@memory_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@memory_tra:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00042	74 23		 je	 SHORT $LN2@memory_tra
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$20977[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$20977[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@memory_tra
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$20977[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@memory_tra
$LN1@memory_tra:
$LN2@memory_tra:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@memory_tra

; 1072 :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@memory_tra:

; 1073 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
memory_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@IAJIDONL@memory_clear?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_clear DD imagerel memory_clear
	DD	imagerel memory_clear+127
	DD	imagerel $unwind$memory_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_clear DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0N@IAJIDONL@memory_clear?$AA@
CONST	SEGMENT
??_C@_0N@IAJIDONL@memory_clear?$AA@ DB 'memory_clear', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_clear
_TEXT	SEGMENT
_py_tmp$20990 = 48
self$ = 80
memory_clear PROC					; COMDAT

; 1077 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1078 :     (void)_memory_release(self);

  00009	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 _memory_release
$LN4@memory_cle:

; 1079 :     Py_CLEAR(self->mbuf);

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0001d	74 53		 je	 SHORT $LN1@memory_cle
  0001f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0002c	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00030	41 b8 37 04 00
	00		 mov	 r8d, 1079		; 00000437H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@IAJIDONL@memory_clear?$AA@
  00044	e8 00 00 00 00	 call	 _PyParallel_Guard
  00049	85 c0		 test	 eax, eax
  0004b	75 25		 jne	 SHORT $LN1@memory_cle
  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00052	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00056	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$20990[rsp], rax
  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00060	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$20990[rsp]
  0006d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@memory_cle:
  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 9b		 jne	 SHORT $LN4@memory_cle

; 1080 :     return 0;

  00078	33 c0		 xor	 eax, eax

; 1081 : }

  0007a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007e	c3		 ret	 0
memory_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_enter DD imagerel memory_enter
	DD	imagerel memory_enter+94
	DD	imagerel $unwind$memory_enter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_enter DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_enter
_TEXT	SEGMENT
self$ = 48
args$ = 56
memory_enter PROC					; COMDAT

; 1085 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1086 :     CHECK_RELEASED(self);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00019	83 e0 01	 and	 eax, 1
  0001c	85 c0		 test	 eax, eax
  0001e	75 13		 jne	 SHORT $LN1@memory_ent
  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00025	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00029	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0002c	83 e0 01	 and	 eax, 1
  0002f	85 c0		 test	 eax, eax
  00031	74 17		 je	 SHORT $LN2@memory_ent
$LN1@memory_ent:
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00041	e8 00 00 00 00	 call	 PyErr_SetString
  00046	33 c0		 xor	 eax, eax
  00048	eb 0f		 jmp	 SHORT $LN3@memory_ent
$LN2@memory_ent:

; 1087 :     Py_INCREF(self);

  0004a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0004f	e8 00 00 00 00	 call	 _Py_IncRef

; 1088 :     return self;

  00054	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
$LN3@memory_ent:

; 1089 : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
memory_enter ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_exit DD imagerel memory_exit
	DD	imagerel memory_exit+31
	DD	imagerel $unwind$memory_exit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_exit DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_exit
_TEXT	SEGMENT
self$ = 48
args$ = 56
memory_exit PROC					; COMDAT

; 1093 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1094 :     return memory_release((PyMemoryViewObject *)self, NULL);

  0000e	33 d2		 xor	 edx, edx
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00015	e8 00 00 00 00	 call	 memory_release

; 1095 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
memory_exit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@KMHJIFPP@memoryview?3?5cast?5must?5be?51D?5?9?$DO?5N@ ; `string'
PUBLIC	??_C@_0CA@IAOMAELM@shape?5must?5be?5a?5list?5or?5a?5tuple?$AA@ ; `string'
PUBLIC	??_C@_0DM@HAJAMMBA@memoryview?3?5cannot?5cast?5view?5wit@ ; `string'
PUBLIC	??_C@_0DH@NNCKOAHO@memoryview?3?5casts?5are?5restricted@ ; `string'
PUBLIC	??_C@_0CN@JOOFLLJP@memoryview?3?5format?5argument?5must@ ; `string'
PUBLIC	??_C@_03DHMGKKHG@O?$HMO?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_cast DD imagerel memory_cast
	DD	imagerel memory_cast+715
	DD	imagerel $unwind$memory_cast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_cast DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0CO@KMHJIFPP@memoryview?3?5cast?5must?5be?51D?5?9?$DO?5N@
CONST	SEGMENT
??_C@_0CO@KMHJIFPP@memoryview?3?5cast?5must?5be?51D?5?9?$DO?5N@ DB 'memor'
	DB	'yview: cast must be 1D -> ND or ND -> 1D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IAOMAELM@shape?5must?5be?5a?5list?5or?5a?5tuple?$AA@
CONST	SEGMENT
??_C@_0CA@IAOMAELM@shape?5must?5be?5a?5list?5or?5a?5tuple?$AA@ DB 'shape '
	DB	'must be a list or a tuple', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HAJAMMBA@memoryview?3?5cannot?5cast?5view?5wit@
CONST	SEGMENT
??_C@_0DM@HAJAMMBA@memoryview?3?5cannot?5cast?5view?5wit@ DB 'memoryview:'
	DB	' cannot cast view with zeros in shape or strides', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NNCKOAHO@memoryview?3?5casts?5are?5restricted@
CONST	SEGMENT
??_C@_0DH@NNCKOAHO@memoryview?3?5casts?5are?5restricted@ DB 'memoryview: '
	DB	'casts are restricted to C-contiguous views', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JOOFLLJP@memoryview?3?5format?5argument?5must@
CONST	SEGMENT
??_C@_0CN@JOOFLLJP@memoryview?3?5format?5argument?5must@ DB 'memoryview: '
	DB	'format argument must be a string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DHMGKKHG@O?$HMO?$AA@
CONST	SEGMENT
??_C@_03DHMGKKHG@O?$HMO?$AA@ DB 'O|O', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_cast
_TEXT	SEGMENT
ndim$ = 48
mv$ = 56
format$ = 64
shape$ = 72
tv149 = 80
tv160 = 88
self$ = 112
args$ = 120
kwds$ = 128
memory_cast PROC					; COMDAT

; 1310 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1311 :     static char *kwlist[] = {"format", "shape", NULL};
; 1312 :     PyMemoryViewObject *mv = NULL;

  00013	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR mv$[rsp], 0

; 1313 :     PyObject *shape = NULL;

  0001c	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR shape$[rsp], 0

; 1314 :     PyObject *format;
; 1315 :     Py_ssize_t ndim = 1;

  00025	48 c7 44 24 30
	01 00 00 00	 mov	 QWORD PTR ndim$[rsp], 1

; 1316 : 
; 1317 :     CHECK_RELEASED(self);

  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00033	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00039	83 e0 01	 and	 eax, 1
  0003c	85 c0		 test	 eax, eax
  0003e	75 13		 jne	 SHORT $LN13@memory_cas
  00040	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00045	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00049	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0004c	83 e0 01	 and	 eax, 1
  0004f	85 c0		 test	 eax, eax
  00051	74 1a		 je	 SHORT $LN14@memory_cas
$LN13@memory_cas:
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00061	e8 00 00 00 00	 call	 PyErr_SetString
  00066	33 c0		 xor	 eax, eax
  00068	e9 59 02 00 00	 jmp	 $LN15@memory_cas
$LN14@memory_cas:

; 1318 : 
; 1319 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|O", kwlist,
; 1320 :                                      &format, &shape)) {

  0006d	48 8d 44 24 48	 lea	 rax, QWORD PTR shape$[rsp]
  00072	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00077	48 8d 44 24 40	 lea	 rax, QWORD PTR format$[rsp]
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??memory_cast@@9@9
  00088	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03DHMGKKHG@O?$HMO?$AA@
  0008f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00097	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  0009c	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000a1	85 c0		 test	 eax, eax
  000a3	75 07		 jne	 SHORT $LN12@memory_cas

; 1321 :         return NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	e9 1a 02 00 00	 jmp	 $LN15@memory_cas
$LN12@memory_cas:

; 1322 :     }
; 1323 :     if (!PyUnicode_Check(format)) {

  000ac	48 8b 44 24 40	 mov	 rax, QWORD PTR format$[rsp]
  000b1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000b5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000bb	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000c0	85 c0		 test	 eax, eax
  000c2	75 1a		 jne	 SHORT $LN11@memory_cas

; 1324 :         PyErr_SetString(PyExc_TypeError,
; 1325 :             "memoryview: format argument must be a string");

  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@JOOFLLJP@memoryview?3?5format?5argument?5must@
  000cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d2	e8 00 00 00 00	 call	 PyErr_SetString

; 1326 :         return NULL;

  000d7	33 c0		 xor	 eax, eax
  000d9	e9 e8 01 00 00	 jmp	 $LN15@memory_cas
$LN11@memory_cas:

; 1327 :     }
; 1328 :     if (!MV_C_CONTIGUOUS(self->flags)) {

  000de	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000e3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000e9	83 e0 0a	 and	 eax, 10
  000ec	85 c0		 test	 eax, eax
  000ee	75 1a		 jne	 SHORT $LN10@memory_cas

; 1329 :         PyErr_SetString(PyExc_TypeError,
; 1330 :             "memoryview: casts are restricted to C-contiguous views");

  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@NNCKOAHO@memoryview?3?5casts?5are?5restricted@
  000f7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000fe	e8 00 00 00 00	 call	 PyErr_SetString

; 1331 :         return NULL;

  00103	33 c0		 xor	 eax, eax
  00105	e9 bc 01 00 00	 jmp	 $LN15@memory_cas
$LN10@memory_cas:

; 1332 :     }
; 1333 :     if ((shape || self->view.ndim != 1) && zero_in_shape(self)) {

  0010a	48 83 7c 24 48
	00		 cmp	 QWORD PTR shape$[rsp], 0
  00110	75 0e		 jne	 SHORT $LN8@memory_cas
  00112	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00117	83 b8 b4 00 00
	00 01		 cmp	 DWORD PTR [rax+180], 1
  0011e	74 28		 je	 SHORT $LN9@memory_cas
$LN8@memory_cas:
  00120	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00125	e8 00 00 00 00	 call	 zero_in_shape
  0012a	85 c0		 test	 eax, eax
  0012c	74 1a		 je	 SHORT $LN9@memory_cas

; 1334 :         PyErr_SetString(PyExc_TypeError,
; 1335 :             "memoryview: cannot cast view with zeros in shape or strides");

  0012e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DM@HAJAMMBA@memoryview?3?5cannot?5cast?5view?5wit@
  00135	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0013c	e8 00 00 00 00	 call	 PyErr_SetString

; 1336 :         return NULL;

  00141	33 c0		 xor	 eax, eax
  00143	e9 7e 01 00 00	 jmp	 $LN15@memory_cas
$LN9@memory_cas:

; 1337 :     }
; 1338 :     if (shape) {

  00148	48 83 7c 24 48
	00		 cmp	 QWORD PTR shape$[rsp], 0
  0014e	0f 84 dc 00 00
	00		 je	 $LN7@memory_cas

; 1339 :         CHECK_LIST_OR_TUPLE(shape)

  00154	48 8b 44 24 48	 mov	 rax, QWORD PTR shape$[rsp]
  00159	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0015d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00163	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00168	85 c0		 test	 eax, eax
  0016a	75 32		 jne	 SHORT $LN6@memory_cas
  0016c	48 8b 44 24 48	 mov	 rax, QWORD PTR shape$[rsp]
  00171	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00175	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0017b	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00180	85 c0		 test	 eax, eax
  00182	75 1a		 jne	 SHORT $LN6@memory_cas
  00184	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@IAOMAELM@shape?5must?5be?5a?5list?5or?5a?5tuple?$AA@
  0018b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00192	e8 00 00 00 00	 call	 PyErr_SetString
  00197	33 c0		 xor	 eax, eax
  00199	e9 28 01 00 00	 jmp	 $LN15@memory_cas
$LN6@memory_cas:

; 1340 :         ndim = PySequence_Fast_GET_SIZE(shape);

  0019e	48 8b 44 24 48	 mov	 rax, QWORD PTR shape$[rsp]
  001a3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001a7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001ad	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  001b2	85 c0		 test	 eax, eax
  001b4	74 10		 je	 SHORT $LN17@memory_cas
  001b6	48 8b 44 24 48	 mov	 rax, QWORD PTR shape$[rsp]
  001bb	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001bf	48 89 44 24 50	 mov	 QWORD PTR tv149[rsp], rax
  001c4	eb 0e		 jmp	 SHORT $LN18@memory_cas
$LN17@memory_cas:
  001c6	48 8b 44 24 48	 mov	 rax, QWORD PTR shape$[rsp]
  001cb	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001cf	48 89 44 24 50	 mov	 QWORD PTR tv149[rsp], rax
$LN18@memory_cas:
  001d4	48 8b 44 24 50	 mov	 rax, QWORD PTR tv149[rsp]
  001d9	48 89 44 24 30	 mov	 QWORD PTR ndim$[rsp], rax

; 1341 :         if (ndim > PyBUF_MAX_NDIM) {

  001de	48 83 7c 24 30
	40		 cmp	 QWORD PTR ndim$[rsp], 64 ; 00000040H
  001e4	7e 1a		 jle	 SHORT $LN5@memory_cas

; 1342 :             PyErr_SetString(PyExc_ValueError,
; 1343 :                 "memoryview: number of dimensions must not exceed "
; 1344 :                 STRINGIZE(PyBUF_MAX_NDIM));

  001e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@EHEPBPHJ@memoryview?3?5number?5of?5dimensions@
  001ed	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001f4	e8 00 00 00 00	 call	 PyErr_SetString

; 1345 :             return NULL;

  001f9	33 c0		 xor	 eax, eax
  001fb	e9 c6 00 00 00	 jmp	 $LN15@memory_cas
$LN5@memory_cas:

; 1346 :         }
; 1347 :         if (self->view.ndim != 1 && ndim != 1) {

  00200	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00205	83 b8 b4 00 00
	00 01		 cmp	 DWORD PTR [rax+180], 1
  0020c	74 22		 je	 SHORT $LN4@memory_cas
  0020e	48 83 7c 24 30
	01		 cmp	 QWORD PTR ndim$[rsp], 1
  00214	74 1a		 je	 SHORT $LN4@memory_cas

; 1348 :             PyErr_SetString(PyExc_TypeError,
; 1349 :                 "memoryview: cast must be 1D -> ND or ND -> 1D");

  00216	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@KMHJIFPP@memoryview?3?5cast?5must?5be?51D?5?9?$DO?5N@
  0021d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00224	e8 00 00 00 00	 call	 PyErr_SetString

; 1350 :             return NULL;

  00229	33 c0		 xor	 eax, eax
  0022b	e9 96 00 00 00	 jmp	 $LN15@memory_cas
$LN4@memory_cas:
$LN7@memory_cas:

; 1351 :         }
; 1352 :     }
; 1353 : 
; 1354 :     mv = (PyMemoryViewObject *)
; 1355 :         mbuf_add_incomplete_view(self->mbuf, &self->view, ndim==0 ? 1 : (int)ndim);

  00230	48 83 7c 24 30
	00		 cmp	 QWORD PTR ndim$[rsp], 0
  00236	75 0a		 jne	 SHORT $LN19@memory_cas
  00238	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv160[rsp], 1
  00240	eb 08		 jmp	 SHORT $LN20@memory_cas
$LN19@memory_cas:
  00242	8b 44 24 30	 mov	 eax, DWORD PTR ndim$[rsp]
  00246	89 44 24 58	 mov	 DWORD PTR tv160[rsp], eax
$LN20@memory_cas:
  0024a	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0024f	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00255	44 8b 44 24 58	 mov	 r8d, DWORD PTR tv160[rsp]
  0025a	48 8b d0	 mov	 rdx, rax
  0025d	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00262	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00266	e8 00 00 00 00	 call	 mbuf_add_incomplete_view
  0026b	48 89 44 24 38	 mov	 QWORD PTR mv$[rsp], rax

; 1356 :     if (mv == NULL)

  00270	48 83 7c 24 38
	00		 cmp	 QWORD PTR mv$[rsp], 0
  00276	75 04		 jne	 SHORT $LN3@memory_cas

; 1357 :         return NULL;

  00278	33 c0		 xor	 eax, eax
  0027a	eb 4a		 jmp	 SHORT $LN15@memory_cas
$LN3@memory_cas:

; 1358 : 
; 1359 :     if (cast_to_1D(mv, format) < 0)

  0027c	48 8b 54 24 40	 mov	 rdx, QWORD PTR format$[rsp]
  00281	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mv$[rsp]
  00286	e8 00 00 00 00	 call	 cast_to_1D
  0028b	85 c0		 test	 eax, eax
  0028d	7d 02		 jge	 SHORT $LN2@memory_cas

; 1360 :         goto error;

  0028f	eb 29		 jmp	 SHORT $error$21217
$LN2@memory_cas:

; 1361 :     if (shape && cast_to_ND(mv, shape, (int)ndim) < 0)

  00291	48 83 7c 24 48
	00		 cmp	 QWORD PTR shape$[rsp], 0
  00297	74 1a		 je	 SHORT $LN1@memory_cas
  00299	44 8b 44 24 30	 mov	 r8d, DWORD PTR ndim$[rsp]
  0029e	48 8b 54 24 48	 mov	 rdx, QWORD PTR shape$[rsp]
  002a3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mv$[rsp]
  002a8	e8 00 00 00 00	 call	 cast_to_ND
  002ad	85 c0		 test	 eax, eax
  002af	7d 02		 jge	 SHORT $LN1@memory_cas

; 1362 :         goto error;

  002b1	eb 07		 jmp	 SHORT $error$21217
$LN1@memory_cas:

; 1363 : 
; 1364 :     return (PyObject *)mv;

  002b3	48 8b 44 24 38	 mov	 rax, QWORD PTR mv$[rsp]
  002b8	eb 0c		 jmp	 SHORT $LN15@memory_cas
$error$21217:

; 1365 : 
; 1366 : error:
; 1367 :     Py_DECREF(mv);

  002ba	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mv$[rsp]
  002bf	e8 00 00 00 00	 call	 _Py_DecRef

; 1368 :     return NULL;

  002c4	33 c0		 xor	 eax, eax
$LN15@memory_cas:

; 1369 : }

  002c6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002ca	c3		 ret	 0
memory_cast ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@JEJCGHHM@memoryview?3?5length?5is?5not?5a?5mult@ ; `string'
PUBLIC	??_C@_0DF@JMICJEHE@memoryview?3?5cannot?5cast?5between?5@ ; `string'
PUBLIC	??_C@_0GG@FIIDFGEP@memoryview?3?5destination?5format?5m@ ; `string'
PUBLIC	??_C@_1DA@JOJBGMN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAs?$AAc?$AAi?$AAi?$AAf?$AAm?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0GB@NACJPCHP@memoryview?3?5source?5format?5must?5b@ ; `string'
PUBLIC	??_C@_1GA@NOFGCNNM@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAu?$AAb?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy@ ; `string'
PUBLIC	??_C@_1FG@DEKMKHBF@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AA?$CL?$AA?5@ ; `string'
PUBLIC	??_C@_1DI@JDHLADDP@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@DOFKEPCG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAm?$AAv?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$CK?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@HBFPCMGH@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
EXTRN	__imp_strncpy:PROC
EXTRN	PyUnicode_AsASCIIString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$cast_to_1D DD imagerel cast_to_1D
	DD	imagerel cast_to_1D+880
	DD	imagerel $unwind$cast_to_1D
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cast_to_1D DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0DB@JEJCGHHM@memoryview?3?5length?5is?5not?5a?5mult@
CONST	SEGMENT
??_C@_0DB@JEJCGHHM@memoryview?3?5length?5is?5not?5a?5mult@ DB 'memoryview'
	DB	': length is not a multiple of itemsize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JMICJEHE@memoryview?3?5cannot?5cast?5between?5@
CONST	SEGMENT
??_C@_0DF@JMICJEHE@memoryview?3?5cannot?5cast?5between?5@ DB 'memoryview:'
	DB	' cannot cast between two non-byte formats', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@FIIDFGEP@memoryview?3?5destination?5format?5m@
CONST	SEGMENT
??_C@_0GG@FIIDFGEP@memoryview?3?5destination?5format?5m@ DB 'memoryview: '
	DB	'destination format must be a native single character format p'
	DB	'refixed with an optional ''@''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@JOJBGMN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAs?$AAc?$AAi?$AAi?$AAf?$AAm?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@JOJBGMN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAs?$AAc?$AAi?$AAi?$AAf?$AAm?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'a', 00H, 's', 00H, 'c', 00H, 'i', 00H, 'i', 00H, 'f', 00H
	DB	'm', 00H, 't', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@NACJPCHP@memoryview?3?5source?5format?5must?5b@
CONST	SEGMENT
??_C@_0GB@NACJPCHP@memoryview?3?5source?5format?5must?5b@ DB 'memoryview:'
	DB	' source format must be a native single character format prefi'
	DB	'xed with an optional ''@''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GA@NOFGCNNM@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAu?$AAb?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy@
CONST	SEGMENT
??_C@_1GA@NOFGCNNM@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAu?$AAb?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy@ DB 'v'
	DB	00H, 'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'u', 00H, 'b', 00H, 'o', 00H, 'f', 00H, 'f', 00H, 's', 00H, 'e'
	DB	00H, 't', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'm', 00H, 'v', 00H, '-', 00H, '>', 00H, 'o', 00H, 'b', 00H, '_'
	DB	00H, 'a', 00H, 'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, '2', 00H, '*', 00H, 'v', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, '-', 00H, '>', 00H, 'n', 00H, 'd', 00H, 'i', 00H
	DB	'm', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@DEKMKHBF@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AA?$CL?$AA?5@
CONST	SEGMENT
??_C@_1FG@DEKMKHBF@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AA?$CL?$AA?5@ DB 'v'
	DB	00H, 'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 's', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'm', 00H, 'v', 00H, '-', 00H
	DB	'>', 00H, 'o', 00H, 'b', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'r'
	DB	00H, 'a', 00H, 'y', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'v', 00H
	DB	'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 'n', 00H, 'd'
	DB	00H, 'i', 00H, 'm', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@JDHLADDP@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@JDHLADDP@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ DB 'v'
	DB	00H, 'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'm', 00H, 'v', 00H, '-', 00H, '>', 00H, 'o', 00H
	DB	'b', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'r', 00H, 'a', 00H, 'y'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@DOFKEPCG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAm?$AAv?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$CK?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@DOFKEPCG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAm?$AAv?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$CK?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'(', 00H, 'm', 00H, 'v', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '3', 00H, '*', 00H, 'v', 00H, 'i', 00H, 'e', 00H
	DB	'w', 00H, '-', 00H, '>', 00H, 'n', 00H, 'd', 00H, 'i', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@HBFPCMGH@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@HBFPCMGH@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'v'
	DB	00H, 'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'd', 00H, 'i', 00H, 'm', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '1', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cast_to_1D
_TEXT	SEGMENT
srcchar$ = 32
itemsize$ = 40
asciifmt$ = 48
view$ = 56
ret$ = 64
destchar$ = 68
mv$ = 96
format$ = 104
cast_to_1D PROC						; COMDAT

; 1144 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1145 :     Py_buffer *view = &mv->view;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR mv$[rsp]
  00013	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00019	48 89 44 24 38	 mov	 QWORD PTR view$[rsp], rax

; 1146 :     PyObject *asciifmt;
; 1147 :     char srcchar, destchar;
; 1148 :     Py_ssize_t itemsize;
; 1149 :     int ret = -1;

  0001e	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -1

; 1150 : 
; 1151 :     assert(view->ndim >= 1);

  00026	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  0002b	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  0002f	7d 1c		 jge	 SHORT $LN8@cast_to_1D
  00031	41 b8 7f 04 00
	00		 mov	 r8d, 1151		; 0000047fH
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@HBFPCMGH@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004b	33 c0		 xor	 eax, eax
$LN8@cast_to_1D:

; 1152 :     assert(Py_SIZE(mv) == 3*view->ndim);

  0004d	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00052	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00055	6b c0 03	 imul	 eax, 3
  00058	48 98		 cdqe
  0005a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mv$[rsp]
  0005f	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00063	74 1c		 je	 SHORT $LN9@cast_to_1D
  00065	41 b8 80 04 00
	00		 mov	 r8d, 1152		; 00000480H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@DOFKEPCG@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAm?$AAv?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$CK?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?$AA@
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007f	33 c0		 xor	 eax, eax
$LN9@cast_to_1D:

; 1153 :     assert(view->shape == mv->ob_array);

  00081	48 8b 44 24 60	 mov	 rax, QWORD PTR mv$[rsp]
  00086	48 05 f0 00 00
	00		 add	 rax, 240		; 000000f0H
  0008c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00091	48 39 41 30	 cmp	 QWORD PTR [rcx+48], rax
  00095	74 1c		 je	 SHORT $LN10@cast_to_1D
  00097	41 b8 81 04 00
	00		 mov	 r8d, 1153		; 00000481H
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@JDHLADDP@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b1	33 c0		 xor	 eax, eax
$LN10@cast_to_1D:

; 1154 :     assert(view->strides == mv->ob_array + view->ndim);

  000b3	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000b8	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  000bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mv$[rsp]
  000c1	48 8d 84 c1 f0
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+240]
  000c9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  000ce	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  000d2	74 1c		 je	 SHORT $LN11@cast_to_1D
  000d4	41 b8 82 04 00
	00		 mov	 r8d, 1154		; 00000482H
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FG@DEKMKHBF@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AA?$CL?$AA?5@
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ee	33 c0		 xor	 eax, eax
$LN11@cast_to_1D:

; 1155 :     assert(view->suboffsets == mv->ob_array + 2*view->ndim);

  000f0	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000f5	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000f8	d1 e0		 shl	 eax, 1
  000fa	48 98		 cdqe
  000fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mv$[rsp]
  00101	48 8d 84 c1 f0
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+240]
  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  0010e	48 39 41 40	 cmp	 QWORD PTR [rcx+64], rax
  00112	74 1c		 je	 SHORT $LN12@cast_to_1D
  00114	41 b8 83 04 00
	00		 mov	 r8d, 1155		; 00000483H
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GA@NOFGCNNM@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAu?$AAb?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy@
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0012e	33 c0		 xor	 eax, eax
$LN12@cast_to_1D:

; 1156 : 
; 1157 :     if (get_native_fmtchar(&srcchar, view->format) < 0) {

  00130	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00135	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  00139	48 8d 4c 24 20	 lea	 rcx, QWORD PTR srcchar$[rsp]
  0013e	e8 00 00 00 00	 call	 get_native_fmtchar
  00143	48 85 c0	 test	 rax, rax
  00146	7d 1c		 jge	 SHORT $LN5@cast_to_1D

; 1158 :         PyErr_SetString(PyExc_ValueError,
; 1159 :             "memoryview: source format must be a native single character "
; 1160 :             "format prefixed with an optional '@'");

  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GB@NACJPCHP@memoryview?3?5source?5format?5must?5b@
  0014f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00156	e8 00 00 00 00	 call	 PyErr_SetString

; 1161 :         return ret;

  0015b	8b 44 24 40	 mov	 eax, DWORD PTR ret$[rsp]
  0015f	e9 07 02 00 00	 jmp	 $LN6@cast_to_1D
$LN5@cast_to_1D:

; 1162 :     }
; 1163 : 
; 1164 :     asciifmt = PyUnicode_AsASCIIString(format);

  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR format$[rsp]
  00169	e8 00 00 00 00	 call	 PyUnicode_AsASCIIString
  0016e	48 89 44 24 30	 mov	 QWORD PTR asciifmt$[rsp], rax

; 1165 :     if (asciifmt == NULL)

  00173	48 83 7c 24 30
	00		 cmp	 QWORD PTR asciifmt$[rsp], 0
  00179	75 09		 jne	 SHORT $LN4@cast_to_1D

; 1166 :         return ret;

  0017b	8b 44 24 40	 mov	 eax, DWORD PTR ret$[rsp]
  0017f	e9 e7 01 00 00	 jmp	 $LN6@cast_to_1D
$LN4@cast_to_1D:

; 1167 : 
; 1168 :     itemsize = get_native_fmtchar(&destchar, PyBytes_AS_STRING(asciifmt));

  00184	48 8b 44 24 30	 mov	 rax, QWORD PTR asciifmt$[rsp]
  00189	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0018d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00193	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00198	85 c0		 test	 eax, eax
  0019a	75 1c		 jne	 SHORT $LN13@cast_to_1D
  0019c	41 b8 90 04 00
	00		 mov	 r8d, 1168		; 00000490H
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@JOJBGMN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAs?$AAc?$AAi?$AAi?$AAf?$AAm?$AAt?$AA?$CJ?$AA?$AA@
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b6	33 c0		 xor	 eax, eax
$LN13@cast_to_1D:
  001b8	48 8b 44 24 30	 mov	 rax, QWORD PTR asciifmt$[rsp]
  001bd	48 83 c0 78	 add	 rax, 120		; 00000078H
  001c1	48 8b d0	 mov	 rdx, rax
  001c4	48 8d 4c 24 44	 lea	 rcx, QWORD PTR destchar$[rsp]
  001c9	e8 00 00 00 00	 call	 get_native_fmtchar
  001ce	48 89 44 24 28	 mov	 QWORD PTR itemsize$[rsp], rax

; 1169 :     if (itemsize < 0) {

  001d3	48 83 7c 24 28
	00		 cmp	 QWORD PTR itemsize$[rsp], 0
  001d9	7d 18		 jge	 SHORT $LN3@cast_to_1D

; 1170 :         PyErr_SetString(PyExc_ValueError,
; 1171 :             "memoryview: destination format must be a native single "
; 1172 :             "character format prefixed with an optional '@'");

  001db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GG@FIIDFGEP@memoryview?3?5destination?5format?5m@
  001e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001e9	e8 00 00 00 00	 call	 PyErr_SetString

; 1173 :         goto out;

  001ee	e9 6a 01 00 00	 jmp	 $out$21081
$LN3@cast_to_1D:

; 1174 :     }
; 1175 : 
; 1176 :     if (!IS_BYTE_FORMAT(srcchar) && !IS_BYTE_FORMAT(destchar)) {

  001f3	0f be 44 24 20	 movsx	 eax, BYTE PTR srcchar$[rsp]
  001f8	83 f8 62	 cmp	 eax, 98			; 00000062H
  001fb	74 4a		 je	 SHORT $LN2@cast_to_1D
  001fd	0f be 44 24 20	 movsx	 eax, BYTE PTR srcchar$[rsp]
  00202	83 f8 42	 cmp	 eax, 66			; 00000042H
  00205	74 40		 je	 SHORT $LN2@cast_to_1D
  00207	0f be 44 24 20	 movsx	 eax, BYTE PTR srcchar$[rsp]
  0020c	83 f8 63	 cmp	 eax, 99			; 00000063H
  0020f	74 36		 je	 SHORT $LN2@cast_to_1D
  00211	0f be 44 24 44	 movsx	 eax, BYTE PTR destchar$[rsp]
  00216	83 f8 62	 cmp	 eax, 98			; 00000062H
  00219	74 2c		 je	 SHORT $LN2@cast_to_1D
  0021b	0f be 44 24 44	 movsx	 eax, BYTE PTR destchar$[rsp]
  00220	83 f8 42	 cmp	 eax, 66			; 00000042H
  00223	74 22		 je	 SHORT $LN2@cast_to_1D
  00225	0f be 44 24 44	 movsx	 eax, BYTE PTR destchar$[rsp]
  0022a	83 f8 63	 cmp	 eax, 99			; 00000063H
  0022d	74 18		 je	 SHORT $LN2@cast_to_1D

; 1177 :         PyErr_SetString(PyExc_TypeError,
; 1178 :             "memoryview: cannot cast between two non-byte formats");

  0022f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@JMICJEHE@memoryview?3?5cannot?5cast?5between?5@
  00236	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0023d	e8 00 00 00 00	 call	 PyErr_SetString

; 1179 :         goto out;

  00242	e9 16 01 00 00	 jmp	 $out$21081
$LN2@cast_to_1D:

; 1180 :     }
; 1181 :     if (view->len % itemsize) {

  00247	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  0024c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00250	48 99		 cdq
  00252	48 f7 7c 24 28	 idiv	 QWORD PTR itemsize$[rsp]
  00257	48 8b c2	 mov	 rax, rdx
  0025a	48 85 c0	 test	 rax, rax
  0025d	74 18		 je	 SHORT $LN1@cast_to_1D

; 1182 :         PyErr_SetString(PyExc_TypeError,
; 1183 :             "memoryview: length is not a multiple of itemsize");

  0025f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JEJCGHHM@memoryview?3?5length?5is?5not?5a?5mult@
  00266	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0026d	e8 00 00 00 00	 call	 PyErr_SetString

; 1184 :         goto out;

  00272	e9 e6 00 00 00	 jmp	 $out$21081
$LN1@cast_to_1D:

; 1185 :     }
; 1186 : 
; 1187 :     strncpy(mv->format, PyBytes_AS_STRING(asciifmt),
; 1188 :             _Py_MEMORYVIEW_MAX_FORMAT);

  00277	48 8b 44 24 30	 mov	 rax, QWORD PTR asciifmt$[rsp]
  0027c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00280	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00286	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0028b	85 c0		 test	 eax, eax
  0028d	75 1c		 jne	 SHORT $LN14@cast_to_1D
  0028f	41 b8 a3 04 00
	00		 mov	 r8d, 1187		; 000004a3H
  00295	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@JOJBGMN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAs?$AAc?$AAi?$AAi?$AAf?$AAm?$AAt?$AA?$CJ?$AA?$AA@
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002a9	33 c0		 xor	 eax, eax
$LN14@cast_to_1D:
  002ab	48 8b 44 24 30	 mov	 rax, QWORD PTR asciifmt$[rsp]
  002b0	48 83 c0 78	 add	 rax, 120		; 00000078H
  002b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mv$[rsp]
  002b9	48 81 c1 e0 00
	00 00		 add	 rcx, 224		; 000000e0H
  002c0	41 b8 03 00 00
	00		 mov	 r8d, 3
  002c6	48 8b d0	 mov	 rdx, rax
  002c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 1189 :     mv->format[_Py_MEMORYVIEW_MAX_FORMAT-1] = '\0';

  002cf	48 8b 44 24 60	 mov	 rax, QWORD PTR mv$[rsp]
  002d4	c6 80 e2 00 00
	00 00		 mov	 BYTE PTR [rax+226], 0

; 1190 :     view->format = mv->format;

  002db	48 8b 44 24 60	 mov	 rax, QWORD PTR mv$[rsp]
  002e0	48 05 e0 00 00
	00		 add	 rax, 224		; 000000e0H
  002e6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  002eb	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1191 :     view->itemsize = itemsize;

  002ef	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  002f4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR itemsize$[rsp]
  002f9	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1192 : 
; 1193 :     view->ndim = 1;

  002fd	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00302	c7 40 24 01 00
	00 00		 mov	 DWORD PTR [rax+36], 1

; 1194 :     view->shape[0] = view->len / view->itemsize;

  00309	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  0030e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00312	48 99		 cdq
  00314	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00319	48 f7 79 18	 idiv	 QWORD PTR [rcx+24]
  0031d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00322	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00326	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1195 :     view->strides[0] = view->itemsize;

  00329	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  0032e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00332	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00337	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0033b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1196 :     view->suboffsets = NULL;

  0033e	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00343	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 1197 : 
; 1198 :     init_flags(mv);

  0034b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mv$[rsp]
  00350	e8 00 00 00 00	 call	 init_flags

; 1199 :  
; 1200 :     ret = 0;

  00355	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0
$out$21081:

; 1201 : 
; 1202 : out:
; 1203 :     Py_DECREF(asciifmt);

  0035d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR asciifmt$[rsp]
  00362	e8 00 00 00 00	 call	 _Py_DecRef

; 1204 :     return ret;

  00367	8b 44 24 40	 mov	 eax, DWORD PTR ret$[rsp]
$LN6@cast_to_1D:

; 1205 : }

  0036b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0036f	c3		 ret	 0
cast_to_1D ENDP
_TEXT	ENDS
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_native_fmtchar DD imagerel get_native_fmtchar
	DD	imagerel get_native_fmtchar+363
	DD	imagerel $unwind$get_native_fmtchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_native_fmtchar DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_native_fmtchar
_TEXT	SEGMENT
size$ = 0
tv68 = 8
result$ = 32
fmt$ = 40
get_native_fmtchar PROC					; COMDAT

; 1106 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1107 :     Py_ssize_t size = -1;

  0000e	48 c7 04 24 ff
	ff ff ff	 mov	 QWORD PTR size$[rsp], -1

; 1108 : 
; 1109 :     if (fmt[0] == '@') fmt++;

  00016	48 8b 44 24 28	 mov	 rax, QWORD PTR fmt$[rsp]
  0001b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0001e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00021	75 0d		 jne	 SHORT $LN14@get_native
  00023	48 8b 44 24 28	 mov	 rax, QWORD PTR fmt$[rsp]
  00028	48 ff c0	 inc	 rax
  0002b	48 89 44 24 28	 mov	 QWORD PTR fmt$[rsp], rax
$LN14@get_native:

; 1110 : 
; 1111 :     switch (fmt[0]) {

  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR fmt$[rsp]
  00035	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00038	89 44 24 08	 mov	 DWORD PTR tv68[rsp], eax
  0003c	8b 44 24 08	 mov	 eax, DWORD PTR tv68[rsp]
  00040	83 e8 3f	 sub	 eax, 63			; 0000003fH
  00043	89 44 24 08	 mov	 DWORD PTR tv68[rsp], eax
  00047	83 7c 24 08 32	 cmp	 DWORD PTR tv68[rsp], 50	; 00000032H
  0004c	0f 87 82 00 00
	00		 ja	 $LN12@get_native
  00052	48 63 44 24 08	 movsxd	 rax, DWORD PTR tv68[rsp]
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0005e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN17@get_native[rcx+rax]
  00066	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN18@get_native[rcx+rax*4]
  0006d	48 03 c1	 add	 rax, rcx
  00070	ff e0		 jmp	 rax
$LN11@get_native:

; 1112 :     case 'c': case 'b': case 'B': size = sizeof(char); break;

  00072	48 c7 04 24 01
	00 00 00	 mov	 QWORD PTR size$[rsp], 1
  0007a	eb 58		 jmp	 SHORT $LN12@get_native
$LN10@get_native:

; 1113 :     case 'h': case 'H': size = sizeof(short); break;

  0007c	48 c7 04 24 02
	00 00 00	 mov	 QWORD PTR size$[rsp], 2
  00084	eb 4e		 jmp	 SHORT $LN12@get_native
$LN9@get_native:

; 1114 :     case 'i': case 'I': size = sizeof(int); break;

  00086	48 c7 04 24 04
	00 00 00	 mov	 QWORD PTR size$[rsp], 4
  0008e	eb 44		 jmp	 SHORT $LN12@get_native
$LN8@get_native:

; 1115 :     case 'l': case 'L': size = sizeof(long); break;

  00090	48 c7 04 24 04
	00 00 00	 mov	 QWORD PTR size$[rsp], 4
  00098	eb 3a		 jmp	 SHORT $LN12@get_native
$LN7@get_native:

; 1116 :     #ifdef HAVE_LONG_LONG
; 1117 :     case 'q': case 'Q': size = sizeof(PY_LONG_LONG); break;

  0009a	48 c7 04 24 08
	00 00 00	 mov	 QWORD PTR size$[rsp], 8
  000a2	eb 30		 jmp	 SHORT $LN12@get_native
$LN6@get_native:

; 1118 :     #endif
; 1119 :     case 'n': case 'N': size = sizeof(Py_ssize_t); break;

  000a4	48 c7 04 24 08
	00 00 00	 mov	 QWORD PTR size$[rsp], 8
  000ac	eb 26		 jmp	 SHORT $LN12@get_native
$LN5@get_native:

; 1120 :     case 'f': size = sizeof(float); break;

  000ae	48 c7 04 24 04
	00 00 00	 mov	 QWORD PTR size$[rsp], 4
  000b6	eb 1c		 jmp	 SHORT $LN12@get_native
$LN4@get_native:

; 1121 :     case 'd': size = sizeof(double); break;

  000b8	48 c7 04 24 08
	00 00 00	 mov	 QWORD PTR size$[rsp], 8
  000c0	eb 12		 jmp	 SHORT $LN12@get_native
$LN3@get_native:

; 1122 :     #ifdef HAVE_C99_BOOL
; 1123 :     case '?': size = sizeof(_Bool); break;
; 1124 :     #else
; 1125 :     case '?': size = sizeof(char); break;

  000c2	48 c7 04 24 01
	00 00 00	 mov	 QWORD PTR size$[rsp], 1
  000ca	eb 08		 jmp	 SHORT $LN12@get_native
$LN2@get_native:

; 1126 :     #endif
; 1127 :     case 'P': size = sizeof(void *); break;

  000cc	48 c7 04 24 08
	00 00 00	 mov	 QWORD PTR size$[rsp], 8
$LN12@get_native:

; 1128 :     }
; 1129 : 
; 1130 :     if (size > 0 && fmt[1] == '\0') {

  000d4	48 83 3c 24 00	 cmp	 QWORD PTR size$[rsp], 0
  000d9	7e 22		 jle	 SHORT $LN1@get_native
  000db	48 8b 44 24 28	 mov	 rax, QWORD PTR fmt$[rsp]
  000e0	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000e4	85 c0		 test	 eax, eax
  000e6	75 15		 jne	 SHORT $LN1@get_native

; 1131 :         *result = fmt[0];

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fmt$[rsp]
  000f2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000f5	88 08		 mov	 BYTE PTR [rax], cl

; 1132 :         return size;

  000f7	48 8b 04 24	 mov	 rax, QWORD PTR size$[rsp]
  000fb	eb 07		 jmp	 SHORT $LN15@get_native
$LN1@get_native:

; 1133 :     }
; 1134 : 
; 1135 :     return -1;

  000fd	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN15@get_native:

; 1136 : }

  00104	48 83 c4 18	 add	 rsp, 24
  00108	c3		 ret	 0
  00109	0f 1f 00	 npad	 3
$LN18@get_native:
  0010c	00 00 00 00	 DD	 $LN3@get_native
  00110	00 00 00 00	 DD	 $LN11@get_native
  00114	00 00 00 00	 DD	 $LN10@get_native
  00118	00 00 00 00	 DD	 $LN9@get_native
  0011c	00 00 00 00	 DD	 $LN8@get_native
  00120	00 00 00 00	 DD	 $LN6@get_native
  00124	00 00 00 00	 DD	 $LN2@get_native
  00128	00 00 00 00	 DD	 $LN7@get_native
  0012c	00 00 00 00	 DD	 $LN4@get_native
  00130	00 00 00 00	 DD	 $LN5@get_native
  00134	00 00 00 00	 DD	 $LN12@get_native
$LN17@get_native:
  00138	00		 DB	 0
  00139	0a		 DB	 10
  0013a	0a		 DB	 10
  0013b	01		 DB	 1
  0013c	0a		 DB	 10
  0013d	0a		 DB	 10
  0013e	0a		 DB	 10
  0013f	0a		 DB	 10
  00140	0a		 DB	 10
  00141	02		 DB	 2
  00142	03		 DB	 3
  00143	0a		 DB	 10
  00144	0a		 DB	 10
  00145	04		 DB	 4
  00146	0a		 DB	 10
  00147	05		 DB	 5
  00148	0a		 DB	 10
  00149	06		 DB	 6
  0014a	07		 DB	 7
  0014b	0a		 DB	 10
  0014c	0a		 DB	 10
  0014d	0a		 DB	 10
  0014e	0a		 DB	 10
  0014f	0a		 DB	 10
  00150	0a		 DB	 10
  00151	0a		 DB	 10
  00152	0a		 DB	 10
  00153	0a		 DB	 10
  00154	0a		 DB	 10
  00155	0a		 DB	 10
  00156	0a		 DB	 10
  00157	0a		 DB	 10
  00158	0a		 DB	 10
  00159	0a		 DB	 10
  0015a	0a		 DB	 10
  0015b	01		 DB	 1
  0015c	01		 DB	 1
  0015d	08		 DB	 8
  0015e	0a		 DB	 10
  0015f	09		 DB	 9
  00160	0a		 DB	 10
  00161	02		 DB	 2
  00162	03		 DB	 3
  00163	0a		 DB	 10
  00164	0a		 DB	 10
  00165	04		 DB	 4
  00166	0a		 DB	 10
  00167	05		 DB	 5
  00168	0a		 DB	 10
  00169	0a		 DB	 10
  0016a	07		 DB	 7
get_native_fmtchar ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@GLJFEKGA@memoryview?3?5product?$CIshape?$CJ?5?$CK?5ite@ ; `string'
PUBLIC	??_C@_1DC@LACGNJAJ@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAu?$AAb?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GC@OCHIDNEC@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AA?$CL?$AA?5@ ; `string'
PUBLIC	??_C@_1EE@JEEFONBE@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAm?$AAv?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$CK?$AA?$CI?$AAn?$AAd?$AAi?$AAm?$AA?$DN?$AA?$DN?$AA0?$AA?$DP?$AA1?$AA?3?$AAn?$AAd?$AAi?$AAm@ ; `string'
PUBLIC	??_C@_1CA@JKGIJHGE@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cast_to_ND DD imagerel cast_to_ND
	DD	imagerel cast_to_ND+509
	DD	imagerel $unwind$cast_to_ND
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cast_to_ND DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0DF@GLJFEKGA@memoryview?3?5product?$CIshape?$CJ?5?$CK?5ite@
CONST	SEGMENT
??_C@_0DF@GLJFEKGA@memoryview?3?5product?$CIshape?$CJ?5?$CK?5ite@ DB 'mem'
	DB	'oryview: product(shape) * itemsize != buffer size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@LACGNJAJ@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAu?$AAb?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@LACGNJAJ@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAu?$AAb?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'v'
	DB	00H, 'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'u', 00H, 'b', 00H, 'o', 00H, 'f', 00H, 'f', 00H, 's', 00H, 'e'
	DB	00H, 't', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@OCHIDNEC@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AA?$CL?$AA?5@
CONST	SEGMENT
??_C@_1GC@OCHIDNEC@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AA?$CL?$AA?5@ DB 'v'
	DB	00H, 'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 's', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'm', 00H, 'v', 00H, '-', 00H
	DB	'>', 00H, 'o', 00H, 'b', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'r'
	DB	00H, 'a', 00H, 'y', 00H, ' ', 00H, '+', 00H, ' ', 00H, '(', 00H
	DB	'n', 00H, 'd', 00H, 'i', 00H, 'm', 00H, '=', 00H, '=', 00H, '0'
	DB	00H, '?', 00H, '1', 00H, ':', 00H, 'n', 00H, 'd', 00H, 'i', 00H
	DB	'm', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@JEEFONBE@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAm?$AAv?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$CK?$AA?$CI?$AAn?$AAd?$AAi?$AAm?$AA?$DN?$AA?$DN?$AA0?$AA?$DP?$AA1?$AA?3?$AAn?$AAd?$AAi?$AAm@
CONST	SEGMENT
??_C@_1EE@JEEFONBE@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAm?$AAv?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$CK?$AA?$CI?$AAn?$AAd?$AAi?$AAm?$AA?$DN?$AA?$DN?$AA0?$AA?$DP?$AA1?$AA?3?$AAn?$AAd?$AAi?$AAm@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	'(', 00H, 'm', 00H, 'v', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '3', 00H, '*', 00H, '(', 00H, 'n', 00H, 'd', 00H
	DB	'i', 00H, 'm', 00H, '=', 00H, '=', 00H, '0', 00H, '?', 00H, '1'
	DB	00H, ':', 00H, 'n', 00H, 'd', 00H, 'i', 00H, 'm', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@JKGIJHGE@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@JKGIJHGE@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'v'
	DB	00H, 'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'd', 00H, 'i', 00H, 'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '1', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cast_to_ND
_TEXT	SEGMENT
len$ = 32
view$ = 40
tv73 = 48
tv91 = 52
mv$ = 80
shape$ = 88
ndim$ = 96
cast_to_ND PROC						; COMDAT

; 1249 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1250 :     Py_buffer *view = &mv->view;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR mv$[rsp]
  00018	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  0001e	48 89 44 24 28	 mov	 QWORD PTR view$[rsp], rax

; 1251 :     Py_ssize_t len;
; 1252 : 
; 1253 :     assert(view->ndim == 1); /* ndim from cast_to_1D() */

  00023	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  00028	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  0002c	74 1c		 je	 SHORT $LN7@cast_to_ND
  0002e	41 b8 e5 04 00
	00		 mov	 r8d, 1253		; 000004e5H
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@JKGIJHGE@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00048	33 c0		 xor	 eax, eax
$LN7@cast_to_ND:

; 1254 :     assert(Py_SIZE(mv) == 3*(ndim==0?1:ndim)); /* ndim of result array */

  0004a	83 7c 24 60 00	 cmp	 DWORD PTR ndim$[rsp], 0
  0004f	75 0a		 jne	 SHORT $LN8@cast_to_ND
  00051	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00059	eb 08		 jmp	 SHORT $LN9@cast_to_ND
$LN8@cast_to_ND:
  0005b	8b 44 24 60	 mov	 eax, DWORD PTR ndim$[rsp]
  0005f	89 44 24 30	 mov	 DWORD PTR tv73[rsp], eax
$LN9@cast_to_ND:
  00063	8b 44 24 30	 mov	 eax, DWORD PTR tv73[rsp]
  00067	6b c0 03	 imul	 eax, 3
  0006a	48 98		 cdqe
  0006c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mv$[rsp]
  00071	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00075	74 1c		 je	 SHORT $LN10@cast_to_ND
  00077	41 b8 e6 04 00
	00		 mov	 r8d, 1254		; 000004e6H
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JEEFONBE@?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAm?$AAv?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$CK?$AA?$CI?$AAn?$AAd?$AAi?$AAm?$AA?$DN?$AA?$DN?$AA0?$AA?$DP?$AA1?$AA?3?$AAn?$AAd?$AAi?$AAm@
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00091	33 c0		 xor	 eax, eax
$LN10@cast_to_ND:

; 1255 :     assert(view->shape == mv->ob_array);

  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR mv$[rsp]
  00098	48 05 f0 00 00
	00		 add	 rax, 240		; 000000f0H
  0009e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  000a3	48 39 41 30	 cmp	 QWORD PTR [rcx+48], rax
  000a7	74 1c		 je	 SHORT $LN11@cast_to_ND
  000a9	41 b8 e7 04 00
	00		 mov	 r8d, 1255		; 000004e7H
  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@JDHLADDP@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c3	33 c0		 xor	 eax, eax
$LN11@cast_to_ND:

; 1256 :     assert(view->strides == mv->ob_array + (ndim==0?1:ndim));

  000c5	83 7c 24 60 00	 cmp	 DWORD PTR ndim$[rsp], 0
  000ca	75 0a		 jne	 SHORT $LN12@cast_to_ND
  000cc	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000d4	eb 08		 jmp	 SHORT $LN13@cast_to_ND
$LN12@cast_to_ND:
  000d6	8b 44 24 60	 mov	 eax, DWORD PTR ndim$[rsp]
  000da	89 44 24 34	 mov	 DWORD PTR tv91[rsp], eax
$LN13@cast_to_ND:
  000de	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv91[rsp]
  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mv$[rsp]
  000e8	48 8d 84 c1 f0
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+240]
  000f0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  000f5	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  000f9	74 1c		 je	 SHORT $LN14@cast_to_ND
  000fb	41 b8 e8 04 00
	00		 mov	 r8d, 1256		; 000004e8H
  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GC@OCHIDNEC@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAv?$AA?9?$AA?$DO?$AAo?$AAb?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AA?$CL?$AA?5@
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00115	33 c0		 xor	 eax, eax
$LN14@cast_to_ND:

; 1257 :     assert(view->suboffsets == NULL);

  00117	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  0011c	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00121	74 1c		 je	 SHORT $LN15@cast_to_ND
  00123	41 b8 e9 04 00
	00		 mov	 r8d, 1257		; 000004e9H
  00129	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@LACGNJAJ@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAu?$AAb?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0013d	33 c0		 xor	 eax, eax
$LN15@cast_to_ND:

; 1258 : 
; 1259 :     view->ndim = ndim;

  0013f	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  00144	8b 4c 24 60	 mov	 ecx, DWORD PTR ndim$[rsp]
  00148	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 1260 :     if (view->ndim == 0) {

  0014b	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  00150	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00154	75 2a		 jne	 SHORT $LN4@cast_to_ND

; 1261 :         view->shape = NULL;

  00156	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  0015b	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 1262 :         view->strides = NULL;

  00163	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  00168	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 1263 :         len = view->itemsize;

  00170	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  00175	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00179	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 1264 :     }
; 1265 :     else {

  0017e	eb 42		 jmp	 SHORT $LN3@cast_to_ND
$LN4@cast_to_ND:

; 1266 :         len = copy_shape(view->shape, shape, ndim, view->itemsize);

  00180	48 63 44 24 60	 movsxd	 rax, DWORD PTR ndim$[rsp]
  00185	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  0018a	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
  0018e	4c 8b c0	 mov	 r8, rax
  00191	48 8b 54 24 58	 mov	 rdx, QWORD PTR shape$[rsp]
  00196	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  0019b	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0019f	e8 00 00 00 00	 call	 copy_shape
  001a4	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 1267 :         if (len < 0)

  001a9	48 83 7c 24 20
	00		 cmp	 QWORD PTR len$[rsp], 0
  001af	7d 07		 jge	 SHORT $LN2@cast_to_ND

; 1268 :             return -1;

  001b1	b8 ff ff ff ff	 mov	 eax, -1
  001b6	eb 40		 jmp	 SHORT $LN5@cast_to_ND
$LN2@cast_to_ND:

; 1269 :         init_strides_from_shape(view);

  001b8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  001bd	e8 00 00 00 00	 call	 init_strides_from_shape
$LN3@cast_to_ND:

; 1270 :     }
; 1271 : 
; 1272 :     if (view->len != len) {

  001c2	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  001c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  001cc	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  001d0	74 1a		 je	 SHORT $LN1@cast_to_ND

; 1273 :         PyErr_SetString(PyExc_TypeError,
; 1274 :             "memoryview: product(shape) * itemsize != buffer size");

  001d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@GLJFEKGA@memoryview?3?5product?$CIshape?$CJ?5?$CK?5ite@
  001d9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001e0	e8 00 00 00 00	 call	 PyErr_SetString

; 1275 :         return -1;

  001e5	b8 ff ff ff ff	 mov	 eax, -1
  001ea	eb 0c		 jmp	 SHORT $LN5@cast_to_ND
$LN1@cast_to_ND:

; 1276 :     }
; 1277 : 
; 1278 :     init_flags(mv);

  001ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mv$[rsp]
  001f1	e8 00 00 00 00	 call	 init_flags

; 1279 : 
; 1280 :     return 0;

  001f6	33 c0		 xor	 eax, eax
$LN5@cast_to_ND:

; 1281 : }

  001f8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001fc	c3		 ret	 0
cast_to_ND ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@DCMKEPPB@memoryview?4cast?$CI?$CJ?3?5product?$CIshape@ ; `string'
PUBLIC	??_C@_0DK@LAONIDJE@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@ ; `string'
PUBLIC	??_C@_0DG@HHOGHKMK@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@ ; `string'
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_shape DD imagerel copy_shape
	DD	imagerel copy_shape+391
	DD	imagerel $unwind$copy_shape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_shape DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT ??_C@_0CO@DCMKEPPB@memoryview?4cast?$CI?$CJ?3?5product?$CIshape@
CONST	SEGMENT
??_C@_0CO@DCMKEPPB@memoryview?4cast?$CI?$CJ?3?5product?$CIshape@ DB 'memo'
	DB	'ryview.cast(): product(shape) > SSIZE_MAX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@LAONIDJE@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@
CONST	SEGMENT
??_C@_0DK@LAONIDJE@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@ DB 'memor'
	DB	'yview.cast(): elements of shape must be integers > 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HHOGHKMK@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@
CONST	SEGMENT
??_C@_0DG@HHOGHKMK@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@ DB 'memor'
	DB	'yview.cast(): elements of shape must be integers', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT copy_shape
_TEXT	SEGMENT
x$ = 32
i$ = 40
len$ = 48
tmp$21107 = 56
tv76 = 64
shape$ = 96
seq$ = 104
ndim$ = 112
itemsize$ = 120
copy_shape PROC						; COMDAT

; 1211 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1212 :     Py_ssize_t x, i;
; 1213 :     Py_ssize_t len = itemsize;

  00018	48 8b 44 24 78	 mov	 rax, QWORD PTR itemsize$[rsp]
  0001d	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 1214 : 
; 1215 :     for (i = 0; i < ndim; i++) {

  00022	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0002b	eb 0d		 jmp	 SHORT $LN7@copy_shape
$LN6@copy_shape:
  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00032	48 ff c0	 inc	 rax
  00035	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN7@copy_shape:
  0003a	48 8b 44 24 70	 mov	 rax, QWORD PTR ndim$[rsp]
  0003f	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00044	0f 8d 33 01 00
	00		 jge	 $LN5@copy_shape

; 1216 :         PyObject *tmp = PySequence_Fast_GET_ITEM(seq, i);

  0004a	48 8b 44 24 68	 mov	 rax, QWORD PTR seq$[rsp]
  0004f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00053	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00059	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0005e	85 c0		 test	 eax, eax
  00060	74 19		 je	 SHORT $LN10@copy_shape
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR seq$[rsp]
  00067	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0006b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00070	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00074	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
  00079	eb 14		 jmp	 SHORT $LN11@copy_shape
$LN10@copy_shape:
  0007b	48 8b 44 24 68	 mov	 rax, QWORD PTR seq$[rsp]
  00080	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00085	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  0008a	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
$LN11@copy_shape:
  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR tv76[rsp]
  00094	48 89 44 24 38	 mov	 QWORD PTR tmp$21107[rsp], rax

; 1217 :         if (!PyLong_Check(tmp)) {

  00099	48 8b 44 24 38	 mov	 rax, QWORD PTR tmp$21107[rsp]
  0009e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000a8	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000ad	85 c0		 test	 eax, eax
  000af	75 1f		 jne	 SHORT $LN4@copy_shape

; 1218 :             PyErr_SetString(PyExc_TypeError,
; 1219 :                 "memoryview.cast(): elements of shape must be integers");

  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@HHOGHKMK@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@
  000b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000bf	e8 00 00 00 00	 call	 PyErr_SetString

; 1220 :             return -1;

  000c4	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000cb	e9 b2 00 00 00	 jmp	 $LN8@copy_shape
$LN4@copy_shape:

; 1221 :         }
; 1222 :         x = PyLong_AsSsize_t(tmp);

  000d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tmp$21107[rsp]
  000d5	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000da	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1223 :         if (x == -1 && PyErr_Occurred()) {

  000df	48 83 7c 24 20
	ff		 cmp	 QWORD PTR x$[rsp], -1
  000e5	75 16		 jne	 SHORT $LN3@copy_shape
  000e7	e8 00 00 00 00	 call	 PyErr_Occurred
  000ec	48 85 c0	 test	 rax, rax
  000ef	74 0c		 je	 SHORT $LN3@copy_shape

; 1224 :             return -1;

  000f1	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000f8	e9 85 00 00 00	 jmp	 $LN8@copy_shape
$LN3@copy_shape:

; 1225 :         }
; 1226 :         if (x <= 0) {

  000fd	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  00103	7f 1c		 jg	 SHORT $LN2@copy_shape

; 1227 :             /* In general elements of shape may be 0, but not for casting. */
; 1228 :             PyErr_Format(PyExc_ValueError,
; 1229 :                 "memoryview.cast(): elements of shape must be integers > 0");

  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DK@LAONIDJE@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@
  0010c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00113	e8 00 00 00 00	 call	 PyErr_Format

; 1230 :             return -1;

  00118	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0011f	eb 61		 jmp	 SHORT $LN8@copy_shape
$LN2@copy_shape:

; 1231 :         }
; 1232 :         if (x > PY_SSIZE_T_MAX / len) {

  00121	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0012b	48 99		 cdq
  0012d	48 f7 7c 24 30	 idiv	 QWORD PTR len$[rsp]
  00132	48 39 44 24 20	 cmp	 QWORD PTR x$[rsp], rax
  00137	7e 1c		 jle	 SHORT $LN1@copy_shape

; 1233 :             PyErr_Format(PyExc_ValueError,
; 1234 :                 "memoryview.cast(): product(shape) > SSIZE_MAX");

  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@DCMKEPPB@memoryview?4cast?$CI?$CJ?3?5product?$CIshape@
  00140	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00147	e8 00 00 00 00	 call	 PyErr_Format

; 1235 :             return -1;

  0014c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00153	eb 2d		 jmp	 SHORT $LN8@copy_shape
$LN1@copy_shape:

; 1236 :         }
; 1237 :         len *= x;

  00155	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  0015a	48 0f af 44 24
	20		 imul	 rax, QWORD PTR x$[rsp]
  00160	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 1238 :         shape[i] = x;

  00165	48 8b 44 24 60	 mov	 rax, QWORD PTR shape$[rsp]
  0016a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0016f	48 8b 54 24 20	 mov	 rdx, QWORD PTR x$[rsp]
  00174	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 1239 :     }

  00178	e9 b0 fe ff ff	 jmp	 $LN6@copy_shape
$LN5@copy_shape:

; 1240 : 
; 1241 :     return len;

  0017d	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
$LN8@copy_shape:

; 1242 : }

  00182	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00186	c3		 ret	 0
copy_shape ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$zero_in_shape DD imagerel zero_in_shape
	DD	imagerel zero_in_shape+97
	DD	imagerel $unwind$zero_in_shape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zero_in_shape DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT zero_in_shape
_TEXT	SEGMENT
i$ = 0
view$ = 8
mv$ = 32
zero_in_shape PROC					; COMDAT

; 1285 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1286 :     Py_buffer *view = &mv->view;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR mv$[rsp]
  0000e	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00014	48 89 44 24 08	 mov	 QWORD PTR view$[rsp], rax

; 1287 :     Py_ssize_t i;
; 1288 : 
; 1289 :     for (i = 0; i < view->ndim; i++)

  00019	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00021	eb 0b		 jmp	 SHORT $LN4@zero_in_sh
$LN3@zero_in_sh:
  00023	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00027	48 ff c0	 inc	 rax
  0002a	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN4@zero_in_sh:
  0002e	48 8b 44 24 08	 mov	 rax, QWORD PTR view$[rsp]
  00033	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00037	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  0003b	7d 1d		 jge	 SHORT $LN2@zero_in_sh

; 1290 :         if (view->shape[i] == 0)

  0003d	48 8b 44 24 08	 mov	 rax, QWORD PTR view$[rsp]
  00042	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00046	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0004a	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  0004f	75 07		 jne	 SHORT $LN1@zero_in_sh

; 1291 :             return 1;

  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	eb 04		 jmp	 SHORT $LN5@zero_in_sh
$LN1@zero_in_sh:

; 1292 : 
; 1293 :     return 0;

  00058	eb c9		 jmp	 SHORT $LN3@zero_in_sh
$LN2@zero_in_sh:
  0005a	33 c0		 xor	 eax, eax
$LN5@zero_in_sh:

; 1294 : }

  0005c	48 83 c4 18	 add	 rsp, 24
  00060	c3		 ret	 0
zero_in_shape ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EI@IFFNMBMI@memoryview?3?5cannot?5cast?5to?5unsig@ ; `string'
PUBLIC	??_C@_0DC@DGPBKM@memoryview?3?5underlying?5buffer?5re@ ; `string'
PUBLIC	??_C@_0DA@DGLEPGEE@memoryview?3?5underlying?5buffer?5is@ ; `string'
PUBLIC	??_C@_0DI@CEIDACMO@memoryview?3?5underlying?5buffer?5is@ ; `string'
PUBLIC	??_C@_0DC@CNKIPJGB@memoryview?3?5underlying?5buffer?5is@ ; `string'
PUBLIC	??_C@_0CO@BMACNGDB@memoryview?3?5underlying?5buffer?5is@ ; `string'
PUBLIC	$T23505
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_getbuf DD imagerel memory_getbuf
	DD	imagerel memory_getbuf+744
	DD	imagerel $unwind$memory_getbuf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_getbuf DD 041801H
	DD	0110118H
	DD	060107011H
xdata	ENDS
;	COMDAT ??_C@_0EI@IFFNMBMI@memoryview?3?5cannot?5cast?5to?5unsig@
CONST	SEGMENT
??_C@_0EI@IFFNMBMI@memoryview?3?5cannot?5cast?5to?5unsig@ DB 'memoryview:'
	DB	' cannot cast to unsigned bytes if the format flag is present', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DGPBKM@memoryview?3?5underlying?5buffer?5re@
CONST	SEGMENT
??_C@_0DC@DGPBKM@memoryview?3?5underlying?5buffer?5re@ DB 'memoryview: un'
	DB	'derlying buffer requires suboffsets', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DGLEPGEE@memoryview?3?5underlying?5buffer?5is@
CONST	SEGMENT
??_C@_0DA@DGLEPGEE@memoryview?3?5underlying?5buffer?5is@ DB 'memoryview: '
	DB	'underlying buffer is not contiguous', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CEIDACMO@memoryview?3?5underlying?5buffer?5is@
CONST	SEGMENT
??_C@_0DI@CEIDACMO@memoryview?3?5underlying?5buffer?5is@ DB 'memoryview: '
	DB	'underlying buffer is not Fortran contiguous', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CNKIPJGB@memoryview?3?5underlying?5buffer?5is@
CONST	SEGMENT
??_C@_0DC@CNKIPJGB@memoryview?3?5underlying?5buffer?5is@ DB 'memoryview: '
	DB	'underlying buffer is not C-contiguous', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BMACNGDB@memoryview?3?5underlying?5buffer?5is@
CONST	SEGMENT
??_C@_0CO@BMACNGDB@memoryview?3?5underlying?5buffer?5is@ DB 'memoryview: '
	DB	'underlying buffer is not writable', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_getbuf
_TEXT	SEGMENT
base$ = 32
baseflags$ = 40
$T23505 = 48
self$ = 160
view$ = 168
flags$ = 176
memory_getbuf PROC					; COMDAT

; 1378 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1379 :     Py_buffer *base = &self->view;

  00018	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00026	48 89 44 24 20	 mov	 QWORD PTR base$[rsp], rax

; 1380 :     int baseflags = self->flags;

  0002b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00033	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00039	89 44 24 28	 mov	 DWORD PTR baseflags$[rsp], eax

; 1381 : 
; 1382 :     CHECK_RELEASED_INT(self);

  0003d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00045	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0004b	83 e0 01	 and	 eax, 1
  0004e	85 c0		 test	 eax, eax
  00050	75 16		 jne	 SHORT $LN11@memory_get
  00052	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0005e	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00061	83 e0 01	 and	 eax, 1
  00064	85 c0		 test	 eax, eax
  00066	74 1d		 je	 SHORT $LN12@memory_get
$LN11@memory_get:
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0006f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00076	e8 00 00 00 00	 call	 PyErr_SetString
  0007b	b8 ff ff ff ff	 mov	 eax, -1
  00080	e9 59 02 00 00	 jmp	 $LN13@memory_get
$LN12@memory_get:

; 1383 : 
; 1384 :     /* start with complete information */
; 1385 :     *view = *base;

  00085	48 8d 44 24 30	 lea	 rax, QWORD PTR $T23505[rsp]
  0008a	48 8b f8	 mov	 rdi, rax
  0008d	48 8b 74 24 20	 mov	 rsi, QWORD PTR base$[rsp]
  00092	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00097	f3 a4		 rep movsb
  00099	48 8d 44 24 30	 lea	 rax, QWORD PTR $T23505[rsp]
  0009e	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR view$[rsp]
  000a6	48 8b f0	 mov	 rsi, rax
  000a9	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  000ae	f3 a4		 rep movsb

; 1386 :     view->obj = NULL;

  000b0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR view$[rsp]
  000b8	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1387 : 
; 1388 :     if (REQ_WRITABLE(flags) && base->readonly) {

  000c0	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  000c7	83 e0 01	 and	 eax, 1
  000ca	85 c0		 test	 eax, eax
  000cc	74 28		 je	 SHORT $LN10@memory_get
  000ce	48 8b 44 24 20	 mov	 rax, QWORD PTR base$[rsp]
  000d3	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  000d7	74 1d		 je	 SHORT $LN10@memory_get

; 1389 :         PyErr_SetString(PyExc_BufferError,
; 1390 :             "memoryview: underlying buffer is not writable");

  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@BMACNGDB@memoryview?3?5underlying?5buffer?5is@
  000e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  000e7	e8 00 00 00 00	 call	 PyErr_SetString

; 1391 :         return -1;

  000ec	b8 ff ff ff ff	 mov	 eax, -1
  000f1	e9 e8 01 00 00	 jmp	 $LN13@memory_get
$LN10@memory_get:

; 1392 :     }
; 1393 :     if (!REQ_FORMAT(flags)) {

  000f6	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  000fd	83 e0 04	 and	 eax, 4
  00100	85 c0		 test	 eax, eax
  00102	75 10		 jne	 SHORT $LN9@memory_get

; 1394 :         /* NULL indicates that the buffer's data type has been cast to 'B'.
; 1395 :            view->itemsize is the _previous_ itemsize. If shape is present,
; 1396 :            the equality product(shape) * itemsize = len still holds at this
; 1397 :            point. The equality calcsize(format) = itemsize does _not_ hold
; 1398 :            from here on! */
; 1399 :         view->format = NULL;

  00104	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR view$[rsp]
  0010c	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
$LN9@memory_get:

; 1400 :     }
; 1401 : 
; 1402 :     if (REQ_C_CONTIGUOUS(flags) && !MV_C_CONTIGUOUS(baseflags)) {

  00114	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0011b	83 e0 38	 and	 eax, 56			; 00000038H
  0011e	83 f8 38	 cmp	 eax, 56			; 00000038H
  00121	75 28		 jne	 SHORT $LN8@memory_get
  00123	8b 44 24 28	 mov	 eax, DWORD PTR baseflags$[rsp]
  00127	83 e0 0a	 and	 eax, 10
  0012a	85 c0		 test	 eax, eax
  0012c	75 1d		 jne	 SHORT $LN8@memory_get

; 1403 :         PyErr_SetString(PyExc_BufferError,
; 1404 :             "memoryview: underlying buffer is not C-contiguous");

  0012e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@CNKIPJGB@memoryview?3?5underlying?5buffer?5is@
  00135	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0013c	e8 00 00 00 00	 call	 PyErr_SetString

; 1405 :         return -1;

  00141	b8 ff ff ff ff	 mov	 eax, -1
  00146	e9 93 01 00 00	 jmp	 $LN13@memory_get
$LN8@memory_get:

; 1406 :     }
; 1407 :     if (REQ_F_CONTIGUOUS(flags) && !MV_F_CONTIGUOUS(baseflags)) {

  0014b	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00152	83 e0 58	 and	 eax, 88			; 00000058H
  00155	83 f8 58	 cmp	 eax, 88			; 00000058H
  00158	75 28		 jne	 SHORT $LN7@memory_get
  0015a	8b 44 24 28	 mov	 eax, DWORD PTR baseflags$[rsp]
  0015e	83 e0 0c	 and	 eax, 12
  00161	85 c0		 test	 eax, eax
  00163	75 1d		 jne	 SHORT $LN7@memory_get

; 1408 :         PyErr_SetString(PyExc_BufferError,
; 1409 :             "memoryview: underlying buffer is not Fortran contiguous");

  00165	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@CEIDACMO@memoryview?3?5underlying?5buffer?5is@
  0016c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00173	e8 00 00 00 00	 call	 PyErr_SetString

; 1410 :         return -1;

  00178	b8 ff ff ff ff	 mov	 eax, -1
  0017d	e9 5c 01 00 00	 jmp	 $LN13@memory_get
$LN7@memory_get:

; 1411 :     }
; 1412 :     if (REQ_ANY_CONTIGUOUS(flags) && !MV_ANY_CONTIGUOUS(baseflags)) {

  00182	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00189	25 98 00 00 00	 and	 eax, 152		; 00000098H
  0018e	3d 98 00 00 00	 cmp	 eax, 152		; 00000098H
  00193	75 28		 jne	 SHORT $LN6@memory_get
  00195	8b 44 24 28	 mov	 eax, DWORD PTR baseflags$[rsp]
  00199	83 e0 0e	 and	 eax, 14
  0019c	85 c0		 test	 eax, eax
  0019e	75 1d		 jne	 SHORT $LN6@memory_get

; 1413 :         PyErr_SetString(PyExc_BufferError,
; 1414 :             "memoryview: underlying buffer is not contiguous");

  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@DGLEPGEE@memoryview?3?5underlying?5buffer?5is@
  001a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  001ae	e8 00 00 00 00	 call	 PyErr_SetString

; 1415 :         return -1;

  001b3	b8 ff ff ff ff	 mov	 eax, -1
  001b8	e9 21 01 00 00	 jmp	 $LN13@memory_get
$LN6@memory_get:

; 1416 :     }
; 1417 :     if (!REQ_INDIRECT(flags) && (baseflags & _Py_MEMORYVIEW_PIL)) {

  001bd	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  001c4	25 18 01 00 00	 and	 eax, 280		; 00000118H
  001c9	3d 18 01 00 00	 cmp	 eax, 280		; 00000118H
  001ce	74 28		 je	 SHORT $LN5@memory_get
  001d0	8b 44 24 28	 mov	 eax, DWORD PTR baseflags$[rsp]
  001d4	83 e0 10	 and	 eax, 16
  001d7	85 c0		 test	 eax, eax
  001d9	74 1d		 je	 SHORT $LN5@memory_get

; 1418 :         PyErr_SetString(PyExc_BufferError,
; 1419 :             "memoryview: underlying buffer requires suboffsets");

  001db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DGPBKM@memoryview?3?5underlying?5buffer?5re@
  001e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  001e9	e8 00 00 00 00	 call	 PyErr_SetString

; 1420 :         return -1;

  001ee	b8 ff ff ff ff	 mov	 eax, -1
  001f3	e9 e6 00 00 00	 jmp	 $LN13@memory_get
$LN5@memory_get:

; 1421 :     }
; 1422 :     if (!REQ_STRIDES(flags)) {

  001f8	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  001ff	83 e0 18	 and	 eax, 24
  00202	83 f8 18	 cmp	 eax, 24
  00205	74 38		 je	 SHORT $LN4@memory_get

; 1423 :         if (!MV_C_CONTIGUOUS(baseflags)) {

  00207	8b 44 24 28	 mov	 eax, DWORD PTR baseflags$[rsp]
  0020b	83 e0 0a	 and	 eax, 10
  0020e	85 c0		 test	 eax, eax
  00210	75 1d		 jne	 SHORT $LN3@memory_get

; 1424 :             PyErr_SetString(PyExc_BufferError,
; 1425 :                 "memoryview: underlying buffer is not C-contiguous");

  00212	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@CNKIPJGB@memoryview?3?5underlying?5buffer?5is@
  00219	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00220	e8 00 00 00 00	 call	 PyErr_SetString

; 1426 :             return -1;

  00225	b8 ff ff ff ff	 mov	 eax, -1
  0022a	e9 af 00 00 00	 jmp	 $LN13@memory_get
$LN3@memory_get:

; 1427 :         }
; 1428 :         view->strides = NULL;

  0022f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR view$[rsp]
  00237	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN4@memory_get:

; 1429 :     }
; 1430 :     if (!REQ_SHAPE(flags)) {

  0023f	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00246	83 e0 08	 and	 eax, 8
  00249	83 f8 08	 cmp	 eax, 8
  0024c	74 48		 je	 SHORT $LN2@memory_get

; 1431 :         /* PyBUF_SIMPLE or PyBUF_WRITABLE: at this point buf is C-contiguous,
; 1432 :            so base->buf = ndbuf->data. */
; 1433 :         if (view->format != NULL) {

  0024e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR view$[rsp]
  00256	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0025b	74 1a		 je	 SHORT $LN1@memory_get

; 1434 :             /* PyBUF_SIMPLE|PyBUF_FORMAT and PyBUF_WRITABLE|PyBUF_FORMAT do
; 1435 :                not make sense. */
; 1436 :             PyErr_Format(PyExc_BufferError,
; 1437 :                 "memoryview: cannot cast to unsigned bytes if the format flag "
; 1438 :                 "is present");

  0025d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EI@IFFNMBMI@memoryview?3?5cannot?5cast?5to?5unsig@
  00264	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0026b	e8 00 00 00 00	 call	 PyErr_Format

; 1439 :             return -1;

  00270	b8 ff ff ff ff	 mov	 eax, -1
  00275	eb 67		 jmp	 SHORT $LN13@memory_get
$LN1@memory_get:

; 1440 :         }
; 1441 :         /* product(shape) * itemsize = len and calcsize(format) = itemsize
; 1442 :            do _not_ hold from here on! */
; 1443 :         view->ndim = 1;

  00277	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR view$[rsp]
  0027f	c7 40 24 01 00
	00 00		 mov	 DWORD PTR [rax+36], 1

; 1444 :         view->shape = NULL;

  00286	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR view$[rsp]
  0028e	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0
$LN2@memory_get:

; 1445 :     }
; 1446 : 
; 1447 : 
; 1448 :     view->obj = (PyObject *)self;

  00296	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR view$[rsp]
  0029e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002a6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1449 :     Py_INCREF(view->obj);

  002aa	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR view$[rsp]
  002b2	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002b6	e8 00 00 00 00	 call	 _Py_IncRef

; 1450 :     self->exports++;

  002bb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002c3	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  002ca	48 ff c0	 inc	 rax
  002cd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002d5	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 1451 : 
; 1452 :     return 0;

  002dc	33 c0		 xor	 eax, eax
$LN13@memory_get:

; 1453 : }

  002de	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002e5	5f		 pop	 rdi
  002e6	5e		 pop	 rsi
  002e7	c3		 ret	 0
memory_getbuf ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT memory_releasebuf
_TEXT	SEGMENT
self$ = 8
view$ = 16
memory_releasebuf PROC					; COMDAT

; 1457 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1458 :     self->exports--;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  0000f	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00016	48 ff c8	 dec	 rax
  00019	48 8b 4c 24 08	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 1459 :     return;
; 1460 :     /* PyBuffer_Release() decrements view->obj after this function returns. */
; 1461 : }

  00025	c3		 ret	 0
memory_releasebuf ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_tolist DD imagerel memory_tolist
	DD	imagerel memory_tolist+299
	DD	imagerel $unwind$memory_tolist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_tolist DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_tolist
_TEXT	SEGMENT
fmt$ = 48
view$ = 56
mv$ = 80
noargs$ = 88
memory_tolist PROC					; COMDAT

; 2067 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2068 :     const Py_buffer *view = &(mv->view);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR mv$[rsp]
  00013	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00019	48 89 44 24 38	 mov	 QWORD PTR view$[rsp], rax

; 2069 :     const char *fmt;
; 2070 : 
; 2071 :     CHECK_RELEASED(mv);

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR mv$[rsp]
  00023	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00029	83 e0 01	 and	 eax, 1
  0002c	85 c0		 test	 eax, eax
  0002e	75 13		 jne	 SHORT $LN6@memory_tol
  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR mv$[rsp]
  00035	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00039	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	74 1a		 je	 SHORT $LN7@memory_tol
$LN6@memory_tol:
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00051	e8 00 00 00 00	 call	 PyErr_SetString
  00056	33 c0		 xor	 eax, eax
  00058	e9 c9 00 00 00	 jmp	 $LN8@memory_tol
$LN7@memory_tol:

; 2072 : 
; 2073 :     fmt = adjust_fmt(view);

  0005d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00062	e8 00 00 00 00	 call	 adjust_fmt
  00067	48 89 44 24 30	 mov	 QWORD PTR fmt$[rsp], rax

; 2074 :     if (fmt == NULL)

  0006c	48 83 7c 24 30
	00		 cmp	 QWORD PTR fmt$[rsp], 0
  00072	75 07		 jne	 SHORT $LN5@memory_tol

; 2075 :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	e9 ab 00 00 00	 jmp	 $LN8@memory_tol
$LN5@memory_tol:

; 2076 :     if (view->ndim == 0) {

  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00080	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00084	75 1c		 jne	 SHORT $LN4@memory_tol

; 2077 :         return unpack_single(view->buf, fmt);

  00086	48 8b 54 24 30	 mov	 rdx, QWORD PTR fmt$[rsp]
  0008b	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00090	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00093	e8 00 00 00 00	 call	 unpack_single
  00098	e9 89 00 00 00	 jmp	 $LN8@memory_tol
  0009d	e9 84 00 00 00	 jmp	 $LN3@memory_tol
$LN4@memory_tol:

; 2078 :     }
; 2079 :     else if (view->ndim == 1) {

  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000a7	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  000ab	75 36		 jne	 SHORT $LN2@memory_tol

; 2080 :         return tolist_base(view->buf, view->shape,
; 2081 :                            view->strides, view->suboffsets,
; 2082 :                            fmt);

  000ad	48 8b 44 24 30	 mov	 rax, QWORD PTR fmt$[rsp]
  000b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b7	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000bc	4c 8b 48 40	 mov	 r9, QWORD PTR [rax+64]
  000c0	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000c5	4c 8b 40 38	 mov	 r8, QWORD PTR [rax+56]
  000c9	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000ce	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  000d2	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000d7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000da	e8 00 00 00 00	 call	 tolist_base
  000df	eb 45		 jmp	 SHORT $LN8@memory_tol

; 2083 :     }
; 2084 :     else {

  000e1	eb 43		 jmp	 SHORT $LN1@memory_tol
$LN2@memory_tol:

; 2085 :         return tolist_rec(view->buf, view->ndim, view->shape,
; 2086 :                           view->strides, view->suboffsets,
; 2087 :                           fmt);

  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000e8	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  000ec	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fmt$[rsp]
  000f1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  000fb	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000ff	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00104	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00109	4c 8b 49 38	 mov	 r9, QWORD PTR [rcx+56]
  0010d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00112	4c 8b 41 30	 mov	 r8, QWORD PTR [rcx+48]
  00116	48 8b d0	 mov	 rdx, rax
  00119	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  0011e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00121	e8 00 00 00 00	 call	 tolist_rec
$LN1@memory_tol:
$LN3@memory_tol:
$LN8@memory_tol:

; 2088 :     }
; 2089 : }

  00126	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012a	c3		 ret	 0
memory_tolist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@NAELFKBL@memoryview?3?5format?5?$CFs?5not?5suppor@ ; `string'
EXTRN	PyExc_NotImplementedError:QWORD
EXTRN	PyLong_FromVoidPtr:PROC
EXTRN	PyBool_FromLong:PROC
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyLong_FromSize_t:PROC
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	PyLong_FromUnsignedLongLong:PROC
EXTRN	PyLong_FromLongLong:PROC
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_single DD imagerel unpack_single
	DD	imagerel unpack_single+1135
	DD	imagerel $unwind$unpack_single
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_single DD 021101H
	DD	01b0111H
xdata	ENDS
;	COMDAT ??_C@_0CE@NAELFKBL@memoryview?3?5format?5?$CFs?5not?5suppor@
CONST	SEGMENT
??_C@_0CE@NAELFKBL@memoryview?3?5format?5?$CFs?5not?5suppor@ DB 'memoryvi'
	DB	'ew: format %s not supported', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT unpack_single
_TEXT	SEGMENT
p$ = 32
uc$ = 40
lld$ = 48
lu$ = 56
llu$ = 64
ld$ = 72
zu$ = 80
d$ = 88
zd$ = 96
x$21376 = 104
x$21382 = 108
x$21388 = 112
x$21394 = 116
x$21401 = 120
x$21408 = 124
x$21414 = 128
x$21420 = 136
x$21427 = 144
x$21434 = 152
x$21441 = 160
x$21448 = 168
x$21455 = 176
x$21463 = 184
tv65 = 192
ptr$ = 224
fmt$ = 232
unpack_single PROC					; COMDAT

; 1621 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1622 :     unsigned PY_LONG_LONG llu;
; 1623 :     unsigned long lu;
; 1624 :     size_t zu;
; 1625 :     PY_LONG_LONG lld;
; 1626 :     long ld;
; 1627 :     Py_ssize_t zd;
; 1628 :     double d;
; 1629 :     unsigned char uc;
; 1630 :     void *p;
; 1631 : 
; 1632 :     switch (fmt[0]) {

  00011	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00019	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0001c	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00023	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv65[rsp]
  0002a	83 e8 3f	 sub	 eax, 63			; 0000003fH
  0002d	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00034	83 bc 24 c0 00
	00 00 32	 cmp	 DWORD PTR tv65[rsp], 50	; 00000032H
  0003c	0f 87 f2 02 00
	00		 ja	 $LN1@unpack_sin
  00042	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR tv65[rsp]
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00051	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN65@unpack_sin[rcx+rax]
  00059	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN66@unpack_sin[rcx+rax*4]
  00060	48 03 c1	 add	 rax, rcx
  00063	ff e0		 jmp	 rax
$LN60@unpack_sin:

; 1633 : 
; 1634 :     /* signed integers and fast path for 'B' */
; 1635 :     case 'B': uc = *((unsigned char *)ptr); goto convert_uc;

  00065	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR ptr$[rsp]
  0006d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00070	88 44 24 28	 mov	 BYTE PTR uc$[rsp], al
  00074	e9 c0 02 00 00	 jmp	 $convert_uc$21368
$LN59@unpack_sin:

; 1636 :     case 'b': ld =   *((signed char *)ptr); goto convert_ld;

  00079	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR ptr$[rsp]
  00081	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00084	89 44 24 48	 mov	 DWORD PTR ld$[rsp], eax
  00088	e9 bd 02 00 00	 jmp	 $convert_ld$21371
$LN58@unpack_sin:
$LN57@unpack_sin:

; 1637 :     case 'h': UNPACK_SINGLE(ld, ptr, short); goto convert_ld;

  0008d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00093	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  0009b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x$21376[rsp]
  000a0	e8 00 00 00 00	 call	 memcpy
  000a5	0f bf 44 24 68	 movsx	 eax, WORD PTR x$21376[rsp]
  000aa	89 44 24 48	 mov	 DWORD PTR ld$[rsp], eax
  000ae	33 c0		 xor	 eax, eax
  000b0	85 c0		 test	 eax, eax
  000b2	75 d9		 jne	 SHORT $LN57@unpack_sin
  000b4	e9 91 02 00 00	 jmp	 $convert_ld$21371
$LN54@unpack_sin:
$LN53@unpack_sin:

; 1638 :     case 'i': UNPACK_SINGLE(ld, ptr, int); goto convert_ld;

  000b9	41 b8 04 00 00
	00		 mov	 r8d, 4
  000bf	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  000c7	48 8d 4c 24 6c	 lea	 rcx, QWORD PTR x$21382[rsp]
  000cc	e8 00 00 00 00	 call	 memcpy
  000d1	8b 44 24 6c	 mov	 eax, DWORD PTR x$21382[rsp]
  000d5	89 44 24 48	 mov	 DWORD PTR ld$[rsp], eax
  000d9	33 c0		 xor	 eax, eax
  000db	85 c0		 test	 eax, eax
  000dd	75 da		 jne	 SHORT $LN53@unpack_sin
  000df	e9 66 02 00 00	 jmp	 $convert_ld$21371
$LN50@unpack_sin:
$LN49@unpack_sin:

; 1639 :     case 'l': UNPACK_SINGLE(ld, ptr, long); goto convert_ld;

  000e4	41 b8 04 00 00
	00		 mov	 r8d, 4
  000ea	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  000f2	48 8d 4c 24 70	 lea	 rcx, QWORD PTR x$21388[rsp]
  000f7	e8 00 00 00 00	 call	 memcpy
  000fc	8b 44 24 70	 mov	 eax, DWORD PTR x$21388[rsp]
  00100	89 44 24 48	 mov	 DWORD PTR ld$[rsp], eax
  00104	33 c0		 xor	 eax, eax
  00106	85 c0		 test	 eax, eax
  00108	75 da		 jne	 SHORT $LN49@unpack_sin
  0010a	e9 3b 02 00 00	 jmp	 $convert_ld$21371
$LN46@unpack_sin:
$LN45@unpack_sin:

; 1640 : 
; 1641 :     /* boolean */
; 1642 :     #ifdef HAVE_C99_BOOL
; 1643 :     case '?': UNPACK_SINGLE(ld, ptr, _Bool); goto convert_bool;
; 1644 :     #else
; 1645 :     case '?': UNPACK_SINGLE(ld, ptr, char); goto convert_bool;

  0010f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00115	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  0011d	48 8d 4c 24 74	 lea	 rcx, QWORD PTR x$21394[rsp]
  00122	e8 00 00 00 00	 call	 memcpy
  00127	0f be 44 24 74	 movsx	 eax, BYTE PTR x$21394[rsp]
  0012c	89 44 24 48	 mov	 DWORD PTR ld$[rsp], eax
  00130	33 c0		 xor	 eax, eax
  00132	85 c0		 test	 eax, eax
  00134	75 d9		 jne	 SHORT $LN45@unpack_sin
  00136	e9 68 02 00 00	 jmp	 $convert_bool$21396
$LN42@unpack_sin:
$LN41@unpack_sin:

; 1646 :     #endif
; 1647 : 
; 1648 :     /* unsigned integers */
; 1649 :     case 'H': UNPACK_SINGLE(lu, ptr, unsigned short); goto convert_lu;

  0013b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00141	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  00149	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x$21401[rsp]
  0014e	e8 00 00 00 00	 call	 memcpy
  00153	0f b7 44 24 78	 movzx	 eax, WORD PTR x$21401[rsp]
  00158	89 44 24 38	 mov	 DWORD PTR lu$[rsp], eax
  0015c	33 c0		 xor	 eax, eax
  0015e	85 c0		 test	 eax, eax
  00160	75 d9		 jne	 SHORT $LN41@unpack_sin
  00162	e9 f1 01 00 00	 jmp	 $convert_lu$21403
$LN38@unpack_sin:
$LN37@unpack_sin:

; 1650 :     case 'I': UNPACK_SINGLE(lu, ptr, unsigned int); goto convert_lu;

  00167	41 b8 04 00 00
	00		 mov	 r8d, 4
  0016d	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  00175	48 8d 4c 24 7c	 lea	 rcx, QWORD PTR x$21408[rsp]
  0017a	e8 00 00 00 00	 call	 memcpy
  0017f	8b 44 24 7c	 mov	 eax, DWORD PTR x$21408[rsp]
  00183	89 44 24 38	 mov	 DWORD PTR lu$[rsp], eax
  00187	33 c0		 xor	 eax, eax
  00189	85 c0		 test	 eax, eax
  0018b	75 da		 jne	 SHORT $LN37@unpack_sin
  0018d	e9 c6 01 00 00	 jmp	 $convert_lu$21403
$LN34@unpack_sin:
$LN33@unpack_sin:

; 1651 :     case 'L': UNPACK_SINGLE(lu, ptr, unsigned long); goto convert_lu;

  00192	41 b8 04 00 00
	00		 mov	 r8d, 4
  00198	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  001a0	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR x$21414[rsp]
  001a8	e8 00 00 00 00	 call	 memcpy
  001ad	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR x$21414[rsp]
  001b4	89 44 24 38	 mov	 DWORD PTR lu$[rsp], eax
  001b8	33 c0		 xor	 eax, eax
  001ba	85 c0		 test	 eax, eax
  001bc	75 d4		 jne	 SHORT $LN33@unpack_sin
  001be	e9 95 01 00 00	 jmp	 $convert_lu$21403
$LN30@unpack_sin:
$LN29@unpack_sin:

; 1652 : 
; 1653 :     /* native 64-bit */
; 1654 :     #ifdef HAVE_LONG_LONG
; 1655 :     case 'q': UNPACK_SINGLE(lld, ptr, PY_LONG_LONG); goto convert_lld;

  001c3	41 b8 08 00 00
	00		 mov	 r8d, 8
  001c9	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  001d1	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x$21420[rsp]
  001d9	e8 00 00 00 00	 call	 memcpy
  001de	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR x$21420[rsp]
  001e6	48 89 44 24 30	 mov	 QWORD PTR lld$[rsp], rax
  001eb	33 c0		 xor	 eax, eax
  001ed	85 c0		 test	 eax, eax
  001ef	75 d2		 jne	 SHORT $LN29@unpack_sin
  001f1	e9 70 01 00 00	 jmp	 $convert_lld$21422
$LN26@unpack_sin:
$LN25@unpack_sin:

; 1656 :     case 'Q': UNPACK_SINGLE(llu, ptr, unsigned PY_LONG_LONG); goto convert_llu;

  001f6	41 b8 08 00 00
	00		 mov	 r8d, 8
  001fc	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  00204	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR x$21427[rsp]
  0020c	e8 00 00 00 00	 call	 memcpy
  00211	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR x$21427[rsp]
  00219	48 89 44 24 40	 mov	 QWORD PTR llu$[rsp], rax
  0021e	33 c0		 xor	 eax, eax
  00220	85 c0		 test	 eax, eax
  00222	75 d2		 jne	 SHORT $LN25@unpack_sin
  00224	e9 49 01 00 00	 jmp	 $convert_llu$21429
$LN22@unpack_sin:
$LN21@unpack_sin:

; 1657 :     #endif
; 1658 : 
; 1659 :     /* ssize_t and size_t */
; 1660 :     case 'n': UNPACK_SINGLE(zd, ptr, Py_ssize_t); goto convert_zd;

  00229	41 b8 08 00 00
	00		 mov	 r8d, 8
  0022f	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  00237	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x$21434[rsp]
  0023f	e8 00 00 00 00	 call	 memcpy
  00244	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR x$21434[rsp]
  0024c	48 89 44 24 60	 mov	 QWORD PTR zd$[rsp], rax
  00251	33 c0		 xor	 eax, eax
  00253	85 c0		 test	 eax, eax
  00255	75 d2		 jne	 SHORT $LN21@unpack_sin
  00257	e9 22 01 00 00	 jmp	 $convert_zd$21436
$LN18@unpack_sin:
$LN17@unpack_sin:

; 1661 :     case 'N': UNPACK_SINGLE(zu, ptr, size_t); goto convert_zu;

  0025c	41 b8 08 00 00
	00		 mov	 r8d, 8
  00262	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  0026a	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR x$21441[rsp]
  00272	e8 00 00 00 00	 call	 memcpy
  00277	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR x$21441[rsp]
  0027f	48 89 44 24 50	 mov	 QWORD PTR zu$[rsp], rax
  00284	33 c0		 xor	 eax, eax
  00286	85 c0		 test	 eax, eax
  00288	75 d2		 jne	 SHORT $LN17@unpack_sin
  0028a	e9 fb 00 00 00	 jmp	 $convert_zu$21443
$LN14@unpack_sin:
$LN13@unpack_sin:

; 1662 : 
; 1663 :     /* floats */
; 1664 :     case 'f': UNPACK_SINGLE(d, ptr, float); goto convert_double;

  0028f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00295	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  0029d	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR x$21448[rsp]
  002a5	e8 00 00 00 00	 call	 memcpy
  002aa	66 0f 6e 84 24
	a8 00 00 00	 movd	 xmm0, DWORD PTR x$21448[rsp]
  002b3	0f 5a c0	 cvtps2pd xmm0, xmm0
  002b6	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR d$[rsp], xmm0
  002bc	33 c0		 xor	 eax, eax
  002be	85 c0		 test	 eax, eax
  002c0	75 cd		 jne	 SHORT $LN13@unpack_sin
  002c2	e9 cf 00 00 00	 jmp	 $convert_double$21450
$LN10@unpack_sin:
$LN9@unpack_sin:

; 1665 :     case 'd': UNPACK_SINGLE(d, ptr, double); goto convert_double;

  002c7	41 b8 08 00 00
	00		 mov	 r8d, 8
  002cd	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  002d5	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR x$21455[rsp]
  002dd	e8 00 00 00 00	 call	 memcpy
  002e2	f2 0f 10 84 24
	b0 00 00 00	 movsdx	 xmm0, QWORD PTR x$21455[rsp]
  002eb	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR d$[rsp], xmm0
  002f1	33 c0		 xor	 eax, eax
  002f3	85 c0		 test	 eax, eax
  002f5	75 d0		 jne	 SHORT $LN9@unpack_sin
  002f7	e9 9a 00 00 00	 jmp	 $convert_double$21450
$LN6@unpack_sin:

; 1666 : 
; 1667 :     /* bytes object */
; 1668 :     case 'c': goto convert_bytes;

  002fc	e9 ad 00 00 00	 jmp	 $convert_bytes$21458
$LN5@unpack_sin:
$LN4@unpack_sin:

; 1669 : 
; 1670 :     /* pointer */
; 1671 :     case 'P': UNPACK_SINGLE(p, ptr, void *); goto convert_pointer;

  00301	41 b8 08 00 00
	00		 mov	 r8d, 8
  00307	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ptr$[rsp]
  0030f	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR x$21463[rsp]
  00317	e8 00 00 00 00	 call	 memcpy
  0031c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR x$21463[rsp]
  00324	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00329	33 c0		 xor	 eax, eax
  0032b	85 c0		 test	 eax, eax
  0032d	75 d2		 jne	 SHORT $LN4@unpack_sin
  0032f	e9 8e 00 00 00	 jmp	 $convert_pointer$21465
$LN1@unpack_sin:

; 1672 : 
; 1673 :     /* default */
; 1674 :     default: goto err_format;

  00334	e9 95 00 00 00	 jmp	 $err_format$21467
$convert_uc$21368:

; 1675 :     }
; 1676 : 
; 1677 : convert_uc:
; 1678 :     /* PyLong_FromUnsignedLong() is slower */
; 1679 :     return PyLong_FromLong(uc);

  00339	0f b6 44 24 28	 movzx	 eax, BYTE PTR uc$[rsp]
  0033e	8b c8		 mov	 ecx, eax
  00340	e8 00 00 00 00	 call	 PyLong_FromLong
  00345	e9 a1 00 00 00	 jmp	 $LN63@unpack_sin
$convert_ld$21371:

; 1680 : convert_ld:
; 1681 :     return PyLong_FromLong(ld);

  0034a	8b 4c 24 48	 mov	 ecx, DWORD PTR ld$[rsp]
  0034e	e8 00 00 00 00	 call	 PyLong_FromLong
  00353	e9 93 00 00 00	 jmp	 $LN63@unpack_sin
$convert_lu$21403:

; 1682 : convert_lu:
; 1683 :     return PyLong_FromUnsignedLong(lu);

  00358	8b 4c 24 38	 mov	 ecx, DWORD PTR lu$[rsp]
  0035c	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  00361	e9 85 00 00 00	 jmp	 $LN63@unpack_sin
$convert_lld$21422:

; 1684 : convert_lld:
; 1685 :     return PyLong_FromLongLong(lld);

  00366	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lld$[rsp]
  0036b	e8 00 00 00 00	 call	 PyLong_FromLongLong
  00370	eb 79		 jmp	 SHORT $LN63@unpack_sin
$convert_llu$21429:

; 1686 : convert_llu:
; 1687 :     return PyLong_FromUnsignedLongLong(llu);

  00372	48 8b 4c 24 40	 mov	 rcx, QWORD PTR llu$[rsp]
  00377	e8 00 00 00 00	 call	 PyLong_FromUnsignedLongLong
  0037c	eb 6d		 jmp	 SHORT $LN63@unpack_sin
$convert_zd$21436:

; 1688 : convert_zd:
; 1689 :     return PyLong_FromSsize_t(zd);

  0037e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR zd$[rsp]
  00383	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00388	eb 61		 jmp	 SHORT $LN63@unpack_sin
$convert_zu$21443:

; 1690 : convert_zu:
; 1691 :     return PyLong_FromSize_t(zu);

  0038a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR zu$[rsp]
  0038f	e8 00 00 00 00	 call	 PyLong_FromSize_t
  00394	eb 55		 jmp	 SHORT $LN63@unpack_sin
$convert_double$21450:

; 1692 : convert_double:
; 1693 :     return PyFloat_FromDouble(d);

  00396	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR d$[rsp]
  0039c	e8 00 00 00 00	 call	 PyFloat_FromDouble
  003a1	eb 48		 jmp	 SHORT $LN63@unpack_sin
$convert_bool$21396:

; 1694 : convert_bool:
; 1695 :     return PyBool_FromLong(ld);

  003a3	8b 4c 24 48	 mov	 ecx, DWORD PTR ld$[rsp]
  003a7	e8 00 00 00 00	 call	 PyBool_FromLong
  003ac	eb 3d		 jmp	 SHORT $LN63@unpack_sin
$convert_bytes$21458:

; 1696 : convert_bytes:
; 1697 :     return PyBytes_FromStringAndSize(ptr, 1);

  003ae	ba 01 00 00 00	 mov	 edx, 1
  003b3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  003bb	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  003c0	eb 29		 jmp	 SHORT $LN63@unpack_sin
$convert_pointer$21465:

; 1698 : convert_pointer:
; 1699 :     return PyLong_FromVoidPtr(p);

  003c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  003c7	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  003cc	eb 1d		 jmp	 SHORT $LN63@unpack_sin
$err_format$21467:

; 1700 : err_format:
; 1701 :     PyErr_Format(PyExc_NotImplementedError,
; 1702 :         "memoryview: format %s not supported", fmt);

  003ce	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  003d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NAELFKBL@memoryview?3?5format?5?$CFs?5not?5suppor@
  003dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  003e4	e8 00 00 00 00	 call	 PyErr_Format

; 1703 :     return NULL;

  003e9	33 c0		 xor	 eax, eax
$LN63@unpack_sin:

; 1704 : }

  003eb	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  003f2	c3		 ret	 0
  003f3	90		 npad	 1
$LN66@unpack_sin:
  003f4	00 00 00 00	 DD	 $LN46@unpack_sin
  003f8	00 00 00 00	 DD	 $LN60@unpack_sin
  003fc	00 00 00 00	 DD	 $LN42@unpack_sin
  00400	00 00 00 00	 DD	 $LN38@unpack_sin
  00404	00 00 00 00	 DD	 $LN34@unpack_sin
  00408	00 00 00 00	 DD	 $LN18@unpack_sin
  0040c	00 00 00 00	 DD	 $LN5@unpack_sin
  00410	00 00 00 00	 DD	 $LN26@unpack_sin
  00414	00 00 00 00	 DD	 $LN59@unpack_sin
  00418	00 00 00 00	 DD	 $LN6@unpack_sin
  0041c	00 00 00 00	 DD	 $LN10@unpack_sin
  00420	00 00 00 00	 DD	 $LN14@unpack_sin
  00424	00 00 00 00	 DD	 $LN58@unpack_sin
  00428	00 00 00 00	 DD	 $LN54@unpack_sin
  0042c	00 00 00 00	 DD	 $LN50@unpack_sin
  00430	00 00 00 00	 DD	 $LN22@unpack_sin
  00434	00 00 00 00	 DD	 $LN30@unpack_sin
  00438	00 00 00 00	 DD	 $LN1@unpack_sin
$LN65@unpack_sin:
  0043c	00		 DB	 0
  0043d	11		 DB	 17
  0043e	11		 DB	 17
  0043f	01		 DB	 1
  00440	11		 DB	 17
  00441	11		 DB	 17
  00442	11		 DB	 17
  00443	11		 DB	 17
  00444	11		 DB	 17
  00445	02		 DB	 2
  00446	03		 DB	 3
  00447	11		 DB	 17
  00448	11		 DB	 17
  00449	04		 DB	 4
  0044a	11		 DB	 17
  0044b	05		 DB	 5
  0044c	11		 DB	 17
  0044d	06		 DB	 6
  0044e	07		 DB	 7
  0044f	11		 DB	 17
  00450	11		 DB	 17
  00451	11		 DB	 17
  00452	11		 DB	 17
  00453	11		 DB	 17
  00454	11		 DB	 17
  00455	11		 DB	 17
  00456	11		 DB	 17
  00457	11		 DB	 17
  00458	11		 DB	 17
  00459	11		 DB	 17
  0045a	11		 DB	 17
  0045b	11		 DB	 17
  0045c	11		 DB	 17
  0045d	11		 DB	 17
  0045e	11		 DB	 17
  0045f	08		 DB	 8
  00460	09		 DB	 9
  00461	0a		 DB	 10
  00462	11		 DB	 17
  00463	0b		 DB	 11
  00464	11		 DB	 17
  00465	0c		 DB	 12
  00466	0d		 DB	 13
  00467	11		 DB	 17
  00468	11		 DB	 17
  00469	0e		 DB	 14
  0046a	11		 DB	 17
  0046b	0f		 DB	 15
  0046c	11		 DB	 17
  0046d	11		 DB	 17
  0046e	10		 DB	 16
unpack_single ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$adjust_fmt DD imagerel adjust_fmt
	DD	imagerel adjust_fmt+136
	DD	imagerel $unwind$adjust_fmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adjust_fmt DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@
CONST	SEGMENT
??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@ DB 'memoryvie'
	DB	'w: unsupported format %s', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT adjust_fmt
_TEXT	SEGMENT
fmt$ = 32
tv71 = 40
view$ = 64
adjust_fmt PROC						; COMDAT

; 1989 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1990 :     const char *fmt;
; 1991 : 
; 1992 :     fmt = (view->format[0] == '@') ? view->format+1 : view->format;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  0000e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00012	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00015	83 f8 40	 cmp	 eax, 64			; 00000040H
  00018	75 13		 jne	 SHORT $LN4@adjust_fmt
  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  0001f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00023	48 ff c0	 inc	 rax
  00026	48 89 44 24 28	 mov	 QWORD PTR tv71[rsp], rax
  0002b	eb 0e		 jmp	 SHORT $LN5@adjust_fmt
$LN4@adjust_fmt:
  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  00032	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00036	48 89 44 24 28	 mov	 QWORD PTR tv71[rsp], rax
$LN5@adjust_fmt:
  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR tv71[rsp]
  00040	48 89 44 24 20	 mov	 QWORD PTR fmt$[rsp], rax

; 1993 :     if (fmt[0] && fmt[1] == '\0')

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR fmt$[rsp]
  0004a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004d	85 c0		 test	 eax, eax
  0004f	74 14		 je	 SHORT $LN1@adjust_fmt
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR fmt$[rsp]
  00056	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0005a	85 c0		 test	 eax, eax
  0005c	75 07		 jne	 SHORT $LN1@adjust_fmt

; 1994 :         return fmt;

  0005e	48 8b 44 24 20	 mov	 rax, QWORD PTR fmt$[rsp]
  00063	eb 1e		 jmp	 SHORT $LN2@adjust_fmt
$LN1@adjust_fmt:

; 1995 : 
; 1996 :     PyErr_Format(PyExc_NotImplementedError,
; 1997 :         "memoryview: unsupported format %s", view->format);

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  0006a	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@
  00075	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0007c	e8 00 00 00 00	 call	 PyErr_Format

; 1998 :     return NULL;

  00081	33 c0		 xor	 eax, eax
$LN2@adjust_fmt:

; 1999 : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
adjust_fmt ENDP
_TEXT	ENDS
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tolist_base DD imagerel tolist_base
	DD	imagerel tolist_base+269
	DD	imagerel $unwind$tolist_base
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tolist_base DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT tolist_base
_TEXT	SEGMENT
i$ = 32
lst$ = 40
item$ = 48
xptr$21775 = 56
tv73 = 64
ptr$ = 96
shape$ = 104
strides$ = 112
suboffsets$ = 120
fmt$ = 128
tolist_base PROC					; COMDAT

; 2006 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2007 :     PyObject *lst, *item;
; 2008 :     Py_ssize_t i;
; 2009 : 
; 2010 :     lst = PyList_New(shape[0]);

  00018	48 8b 44 24 68	 mov	 rax, QWORD PTR shape$[rsp]
  0001d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00020	e8 00 00 00 00	 call	 PyList_New
  00025	48 89 44 24 28	 mov	 QWORD PTR lst$[rsp], rax

; 2011 :     if (lst == NULL)

  0002a	48 83 7c 24 28
	00		 cmp	 QWORD PTR lst$[rsp], 0
  00030	75 07		 jne	 SHORT $LN5@tolist_bas

; 2012 :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 cf 00 00 00	 jmp	 $LN6@tolist_bas
$LN5@tolist_bas:

; 2013 : 
; 2014 :     for (i = 0; i < shape[0]; ptr+=strides[0], i++) {

  00039	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00042	eb 25		 jmp	 SHORT $LN4@tolist_bas
$LN3@tolist_bas:
  00044	48 8b 44 24 70	 mov	 rax, QWORD PTR strides$[rsp]
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ptr$[rsp]
  00051	48 03 c8	 add	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 89 44 24 60	 mov	 QWORD PTR ptr$[rsp], rax
  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00061	48 ff c0	 inc	 rax
  00064	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@tolist_bas:
  00069	48 8b 44 24 68	 mov	 rax, QWORD PTR shape$[rsp]
  0006e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00071	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00076	0f 8d 87 00 00
	00		 jge	 $LN2@tolist_bas

; 2015 :         const char *xptr = ADJUST_PTR(ptr, suboffsets);

  0007c	48 83 7c 24 78
	00		 cmp	 QWORD PTR suboffsets$[rsp], 0
  00082	74 22		 je	 SHORT $LN8@tolist_bas
  00084	48 8b 44 24 78	 mov	 rax, QWORD PTR suboffsets$[rsp]
  00089	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008d	7c 17		 jl	 SHORT $LN8@tolist_bas
  0008f	48 8b 44 24 60	 mov	 rax, QWORD PTR ptr$[rsp]
  00094	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00097	48 8b 4c 24 78	 mov	 rcx, QWORD PTR suboffsets$[rsp]
  0009c	48 03 01	 add	 rax, QWORD PTR [rcx]
  0009f	48 89 44 24 40	 mov	 QWORD PTR tv73[rsp], rax
  000a4	eb 0a		 jmp	 SHORT $LN9@tolist_bas
$LN8@tolist_bas:
  000a6	48 8b 44 24 60	 mov	 rax, QWORD PTR ptr$[rsp]
  000ab	48 89 44 24 40	 mov	 QWORD PTR tv73[rsp], rax
$LN9@tolist_bas:
  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR tv73[rsp]
  000b5	48 89 44 24 38	 mov	 QWORD PTR xptr$21775[rsp], rax

; 2016 :         item = unpack_single(xptr, fmt);

  000ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  000c2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR xptr$21775[rsp]
  000c7	e8 00 00 00 00	 call	 unpack_single
  000cc	48 89 44 24 30	 mov	 QWORD PTR item$[rsp], rax

; 2017 :         if (item == NULL) {

  000d1	48 83 7c 24 30
	00		 cmp	 QWORD PTR item$[rsp], 0
  000d7	75 0e		 jne	 SHORT $LN1@tolist_bas

; 2018 :             Py_DECREF(lst);

  000d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lst$[rsp]
  000de	e8 00 00 00 00	 call	 _Py_DecRef

; 2019 :             return NULL;

  000e3	33 c0		 xor	 eax, eax
  000e5	eb 21		 jmp	 SHORT $LN6@tolist_bas
$LN1@tolist_bas:

; 2020 :         }
; 2021 :         PyList_SET_ITEM(lst, i, item);

  000e7	48 8b 44 24 28	 mov	 rax, QWORD PTR lst$[rsp]
  000ec	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000f5	48 8b 54 24 30	 mov	 rdx, QWORD PTR item$[rsp]
  000fa	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 2022 :     }

  000fe	e9 41 ff ff ff	 jmp	 $LN3@tolist_bas
$LN2@tolist_bas:

; 2023 : 
; 2024 :     return lst;

  00103	48 8b 44 24 28	 mov	 rax, QWORD PTR lst$[rsp]
$LN6@tolist_bas:

; 2025 : }

  00108	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010c	c3		 ret	 0
tolist_base ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CA@LDADJHOA@?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@EBIOKAGI@?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$tolist_rec DD imagerel tolist_rec
	DD	imagerel tolist_rec+553
	DD	imagerel $unwind$tolist_rec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tolist_rec DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT ??_C@_1CA@LDADJHOA@?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@LDADJHOA@?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 's', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L'
	DB	00H, 'L', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@EBIOKAGI@?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@EBIOKAGI@?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'h', 00H, 'a', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tolist_rec
_TEXT	SEGMENT
i$ = 48
lst$ = 56
item$ = 64
xptr$21813 = 72
tv95 = 80
tv132 = 88
ptr$ = 112
ndim$ = 120
shape$ = 128
strides$ = 136
suboffsets$ = 144
fmt$ = 152
tolist_rec PROC						; COMDAT

; 2033 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2034 :     PyObject *lst, *item;
; 2035 :     Py_ssize_t i;
; 2036 : 
; 2037 :     assert(ndim >= 1);

  00018	48 83 7c 24 78
	01		 cmp	 QWORD PTR ndim$[rsp], 1
  0001e	7d 1c		 jge	 SHORT $LN9@tolist_rec
  00020	41 b8 f5 07 00
	00		 mov	 r8d, 2037		; 000007f5H
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@MKFAAJFI@?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003a	33 c0		 xor	 eax, eax
$LN9@tolist_rec:

; 2038 :     assert(shape != NULL);

  0003c	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR shape$[rsp], 0
  00045	75 1c		 jne	 SHORT $LN10@tolist_rec
  00047	41 b8 f6 07 00
	00		 mov	 r8d, 2038		; 000007f6H
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@EBIOKAGI@?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN10@tolist_rec:

; 2039 :     assert(strides != NULL);

  00063	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR strides$[rsp], 0
  0006c	75 1c		 jne	 SHORT $LN11@tolist_rec
  0006e	41 b8 f7 07 00
	00		 mov	 r8d, 2039		; 000007f7H
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@LDADJHOA@?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00088	33 c0		 xor	 eax, eax
$LN11@tolist_rec:

; 2040 : 
; 2041 :     if (ndim == 1)

  0008a	48 83 7c 24 78
	01		 cmp	 QWORD PTR ndim$[rsp], 1
  00090	75 34		 jne	 SHORT $LN6@tolist_rec

; 2042 :         return tolist_base(ptr, shape, strides, suboffsets, fmt);

  00092	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0009a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009f	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR suboffsets$[rsp]
  000a7	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR strides$[rsp]
  000af	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR shape$[rsp]
  000b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ptr$[rsp]
  000bc	e8 00 00 00 00	 call	 tolist_base
  000c1	e9 5e 01 00 00	 jmp	 $LN7@tolist_rec
$LN6@tolist_rec:

; 2043 : 
; 2044 :     lst = PyList_New(shape[0]);

  000c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shape$[rsp]
  000ce	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000d1	e8 00 00 00 00	 call	 PyList_New
  000d6	48 89 44 24 38	 mov	 QWORD PTR lst$[rsp], rax

; 2045 :     if (lst == NULL)

  000db	48 83 7c 24 38
	00		 cmp	 QWORD PTR lst$[rsp], 0
  000e1	75 07		 jne	 SHORT $LN5@tolist_rec

; 2046 :         return NULL;

  000e3	33 c0		 xor	 eax, eax
  000e5	e9 3a 01 00 00	 jmp	 $LN7@tolist_rec
$LN5@tolist_rec:

; 2047 : 
; 2048 :     for (i = 0; i < shape[0]; ptr+=strides[0], i++) {

  000ea	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000f3	eb 28		 jmp	 SHORT $LN4@tolist_rec
$LN3@tolist_rec:
  000f5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR strides$[rsp]
  000fd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00100	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ptr$[rsp]
  00105	48 03 c8	 add	 rcx, rax
  00108	48 8b c1	 mov	 rax, rcx
  0010b	48 89 44 24 70	 mov	 QWORD PTR ptr$[rsp], rax
  00110	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00115	48 ff c0	 inc	 rax
  00118	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN4@tolist_rec:
  0011d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shape$[rsp]
  00125	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00128	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0012d	0f 8d ec 00 00
	00		 jge	 $LN2@tolist_rec

; 2049 :         const char *xptr = ADJUST_PTR(ptr, suboffsets);

  00133	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR suboffsets$[rsp], 0
  0013c	74 28		 je	 SHORT $LN12@tolist_rec
  0013e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR suboffsets$[rsp]
  00146	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0014a	7c 1a		 jl	 SHORT $LN12@tolist_rec
  0014c	48 8b 44 24 70	 mov	 rax, QWORD PTR ptr$[rsp]
  00151	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00154	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR suboffsets$[rsp]
  0015c	48 03 01	 add	 rax, QWORD PTR [rcx]
  0015f	48 89 44 24 50	 mov	 QWORD PTR tv95[rsp], rax
  00164	eb 0a		 jmp	 SHORT $LN13@tolist_rec
$LN12@tolist_rec:
  00166	48 8b 44 24 70	 mov	 rax, QWORD PTR ptr$[rsp]
  0016b	48 89 44 24 50	 mov	 QWORD PTR tv95[rsp], rax
$LN13@tolist_rec:
  00170	48 8b 44 24 50	 mov	 rax, QWORD PTR tv95[rsp]
  00175	48 89 44 24 48	 mov	 QWORD PTR xptr$21813[rsp], rax

; 2050 :         item = tolist_rec(xptr, ndim-1, shape+1,
; 2051 :                           strides+1, suboffsets ? suboffsets+1 : NULL,
; 2052 :                           fmt);

  0017a	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR suboffsets$[rsp], 0
  00183	74 13		 je	 SHORT $LN14@tolist_rec
  00185	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR suboffsets$[rsp]
  0018d	48 83 c0 08	 add	 rax, 8
  00191	48 89 44 24 58	 mov	 QWORD PTR tv132[rsp], rax
  00196	eb 09		 jmp	 SHORT $LN15@tolist_rec
$LN14@tolist_rec:
  00198	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv132[rsp], 0
$LN15@tolist_rec:
  001a1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR strides$[rsp]
  001a9	48 83 c0 08	 add	 rax, 8
  001ad	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR shape$[rsp]
  001b5	48 83 c1 08	 add	 rcx, 8
  001b9	48 8b 54 24 78	 mov	 rdx, QWORD PTR ndim$[rsp]
  001be	48 ff ca	 dec	 rdx
  001c1	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  001c9	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  001ce	4c 8b 44 24 58	 mov	 r8, QWORD PTR tv132[rsp]
  001d3	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  001d8	4c 8b c8	 mov	 r9, rax
  001db	4c 8b c1	 mov	 r8, rcx
  001de	48 8b 4c 24 48	 mov	 rcx, QWORD PTR xptr$21813[rsp]
  001e3	e8 00 00 00 00	 call	 tolist_rec
  001e8	48 89 44 24 40	 mov	 QWORD PTR item$[rsp], rax

; 2053 :         if (item == NULL) {

  001ed	48 83 7c 24 40
	00		 cmp	 QWORD PTR item$[rsp], 0
  001f3	75 0e		 jne	 SHORT $LN1@tolist_rec

; 2054 :             Py_DECREF(lst);

  001f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR lst$[rsp]
  001fa	e8 00 00 00 00	 call	 _Py_DecRef

; 2055 :             return NULL;

  001ff	33 c0		 xor	 eax, eax
  00201	eb 21		 jmp	 SHORT $LN7@tolist_rec
$LN1@tolist_rec:

; 2056 :         }
; 2057 :         PyList_SET_ITEM(lst, i, item);

  00203	48 8b 44 24 38	 mov	 rax, QWORD PTR lst$[rsp]
  00208	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0020c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00211	48 8b 54 24 40	 mov	 rdx, QWORD PTR item$[rsp]
  00216	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 2058 :     }

  0021a	e9 d6 fe ff ff	 jmp	 $LN3@tolist_rec
$LN2@tolist_rec:

; 2059 : 
; 2060 :     return lst;

  0021f	48 8b 44 24 38	 mov	 rax, QWORD PTR lst$[rsp]
$LN7@tolist_rec:

; 2061 : }

  00224	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00228	c3		 ret	 0
tolist_rec ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_tobytes DD imagerel memory_tobytes
	DD	imagerel memory_tobytes+285
	DD	imagerel $unwind$memory_tobytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_tobytes DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ')', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_tobytes
_TEXT	SEGMENT
bytes$ = 32
src$ = 40
self$ = 64
dummy$ = 72
memory_tobytes PROC					; COMDAT

; 2093 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2094 :     Py_buffer *src = VIEW_ADDR(self);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00019	48 89 44 24 28	 mov	 QWORD PTR src$[rsp], rax

; 2095 :     PyObject *bytes = NULL;

  0001e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR bytes$[rsp], 0

; 2096 : 
; 2097 :     CHECK_RELEASED(self);

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00032	83 e0 01	 and	 eax, 1
  00035	85 c0		 test	 eax, eax
  00037	75 13		 jne	 SHORT $LN4@memory_tob
  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00042	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	74 1a		 je	 SHORT $LN5@memory_tob
$LN4@memory_tob:
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0005a	e8 00 00 00 00	 call	 PyErr_SetString
  0005f	33 c0		 xor	 eax, eax
  00061	e9 b2 00 00 00	 jmp	 $LN6@memory_tob
$LN5@memory_tob:

; 2098 : 
; 2099 :     if (MV_C_CONTIGUOUS(self->flags)) {

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00071	83 e0 0a	 and	 eax, 10
  00074	85 c0		 test	 eax, eax
  00076	74 1b		 je	 SHORT $LN3@memory_tob

; 2100 :         return PyBytes_FromStringAndSize(src->buf, src->len);

  00078	48 8b 44 24 28	 mov	 rax, QWORD PTR src$[rsp]
  0007d	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR src$[rsp]
  00086	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00089	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0008e	e9 85 00 00 00	 jmp	 $LN6@memory_tob
$LN3@memory_tob:

; 2101 :     }
; 2102 : 
; 2103 :     bytes = PyBytes_FromStringAndSize(NULL, src->len);

  00093	48 8b 44 24 28	 mov	 rax, QWORD PTR src$[rsp]
  00098	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0009c	33 c9		 xor	 ecx, ecx
  0009e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000a3	48 89 44 24 20	 mov	 QWORD PTR bytes$[rsp], rax

; 2104 :     if (bytes == NULL)

  000a8	48 83 7c 24 20
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  000ae	75 04		 jne	 SHORT $LN2@memory_tob

; 2105 :         return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	eb 64		 jmp	 SHORT $LN6@memory_tob
$LN2@memory_tob:

; 2106 : 
; 2107 :     if (buffer_to_contiguous(PyBytes_AS_STRING(bytes), src, 'C') < 0) {

  000b4	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes$[rsp]
  000b9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000bd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000c3	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000c8	85 c0		 test	 eax, eax
  000ca	75 1c		 jne	 SHORT $LN8@memory_tob
  000cc	41 b8 3b 08 00
	00		 mov	 r8d, 2107		; 0000083bH
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e6	33 c0		 xor	 eax, eax
$LN8@memory_tob:
  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes$[rsp]
  000ed	48 83 c0 78	 add	 rax, 120		; 00000078H
  000f1	41 b0 43	 mov	 r8b, 67			; 00000043H
  000f4	48 8b 54 24 28	 mov	 rdx, QWORD PTR src$[rsp]
  000f9	48 8b c8	 mov	 rcx, rax
  000fc	e8 00 00 00 00	 call	 buffer_to_contiguous
  00101	85 c0		 test	 eax, eax
  00103	7d 0e		 jge	 SHORT $LN1@memory_tob

; 2108 :         Py_DECREF(bytes);

  00105	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes$[rsp]
  0010a	e8 00 00 00 00	 call	 _Py_DecRef

; 2109 :         return NULL;

  0010f	33 c0		 xor	 eax, eax
  00111	eb 05		 jmp	 SHORT $LN6@memory_tob
$LN1@memory_tob:

; 2110 :     }
; 2111 : 
; 2112 :     return bytes;

  00113	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes$[rsp]
$LN6@memory_tob:

; 2113 : }

  00118	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011c	c3		 ret	 0
memory_tobytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@FFPFCENE@?$DMmemory?5at?5?$CFp?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BI@FNECJCPN@?$DMreleased?5memory?5at?5?$CFp?$DO?$AA@ ; `string'
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_repr DD imagerel memory_repr
	DD	imagerel memory_repr+70
	DD	imagerel $unwind$memory_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_repr DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0P@FFPFCENE@?$DMmemory?5at?5?$CFp?$DO?$AA@
CONST	SEGMENT
??_C@_0P@FFPFCENE@?$DMmemory?5at?5?$CFp?$DO?$AA@ DB '<memory at %p>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FNECJCPN@?$DMreleased?5memory?5at?5?$CFp?$DO?$AA@
CONST	SEGMENT
??_C@_0BI@FNECJCPN@?$DMreleased?5memory?5at?5?$CFp?$DO?$AA@ DB '<released'
	DB	' memory at %p>', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_repr
_TEXT	SEGMENT
self$ = 48
memory_repr PROC					; COMDAT

; 2117 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2118 :     if (self->flags & _Py_MEMORYVIEW_RELEASED)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	74 15		 je	 SHORT $LN2@memory_rep

; 2119 :         return PyUnicode_FromFormat("<released memory at %p>", self);

  0001b	48 8b 54 24 30	 mov	 rdx, QWORD PTR self$[rsp]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@FNECJCPN@?$DMreleased?5memory?5at?5?$CFp?$DO?$AA@
  00027	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0002c	eb 13		 jmp	 SHORT $LN3@memory_rep

; 2120 :     else

  0002e	eb 11		 jmp	 SHORT $LN1@memory_rep
$LN2@memory_rep:

; 2121 :         return PyUnicode_FromFormat("<memory at %p>", self);

  00030	48 8b 54 24 30	 mov	 rdx, QWORD PTR self$[rsp]
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@FFPFCENE@?$DMmemory?5at?5?$CFp?$DO?$AA@
  0003c	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN1@memory_rep:
$LN3@memory_rep:

; 2122 : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
memory_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@HBCJDDJF@multi?9dimensional?5sub?9views?5are?5@ ; `string'
PUBLIC	??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_item DD imagerel memory_item
	DD	imagerel memory_item+240
	DD	imagerel $unwind$memory_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_item DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0DA@HBCJDDJF@multi?9dimensional?5sub?9views?5are?5@
CONST	SEGMENT
??_C@_0DA@HBCJDDJF@multi?9dimensional?5sub?9views?5are?5@ DB 'multi-dimen'
	DB	'sional sub-views are not implemented', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@
CONST	SEGMENT
??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@ DB 'invalid ind'
	DB	'exing of 0-dim memory', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_item
_TEXT	SEGMENT
fmt$ = 32
view$ = 40
ptr$21915 = 48
self$ = 80
index$ = 88
memory_item PROC					; COMDAT

; 2161 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2162 :     Py_buffer *view = &(self->view);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00019	48 89 44 24 28	 mov	 QWORD PTR view$[rsp], rax

; 2163 :     const char *fmt;
; 2164 : 
; 2165 :     CHECK_RELEASED(self);

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00023	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00029	83 e0 01	 and	 eax, 1
  0002c	85 c0		 test	 eax, eax
  0002e	75 13		 jne	 SHORT $LN5@memory_ite
  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00035	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00039	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	74 1a		 je	 SHORT $LN6@memory_ite
$LN5@memory_ite:
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00051	e8 00 00 00 00	 call	 PyErr_SetString
  00056	33 c0		 xor	 eax, eax
  00058	e9 8e 00 00 00	 jmp	 $LN7@memory_ite
$LN6@memory_ite:

; 2166 : 
; 2167 :     fmt = adjust_fmt(view);

  0005d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  00062	e8 00 00 00 00	 call	 adjust_fmt
  00067	48 89 44 24 20	 mov	 QWORD PTR fmt$[rsp], rax

; 2168 :     if (fmt == NULL)

  0006c	48 83 7c 24 20
	00		 cmp	 QWORD PTR fmt$[rsp], 0
  00072	75 04		 jne	 SHORT $LN4@memory_ite

; 2169 :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	eb 73		 jmp	 SHORT $LN7@memory_ite
$LN4@memory_ite:

; 2170 : 
; 2171 :     if (view->ndim == 0) {

  00078	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  0007d	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00081	75 17		 jne	 SHORT $LN3@memory_ite

; 2172 :         PyErr_SetString(PyExc_TypeError, "invalid indexing of 0-dim memory");

  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@
  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00091	e8 00 00 00 00	 call	 PyErr_SetString

; 2173 :         return NULL;

  00096	33 c0		 xor	 eax, eax
  00098	eb 51		 jmp	 SHORT $LN7@memory_ite
$LN3@memory_ite:

; 2174 :     }
; 2175 :     if (view->ndim == 1) {

  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR view$[rsp]
  0009f	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  000a3	75 31		 jne	 SHORT $LN2@memory_ite

; 2176 :         char *ptr = ptr_from_index(view, index);

  000a5	48 8b 54 24 58	 mov	 rdx, QWORD PTR index$[rsp]
  000aa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp]
  000af	e8 00 00 00 00	 call	 ptr_from_index
  000b4	48 89 44 24 30	 mov	 QWORD PTR ptr$21915[rsp], rax

; 2177 :         if (ptr == NULL)

  000b9	48 83 7c 24 30
	00		 cmp	 QWORD PTR ptr$21915[rsp], 0
  000bf	75 04		 jne	 SHORT $LN1@memory_ite

; 2178 :             return NULL;

  000c1	33 c0		 xor	 eax, eax
  000c3	eb 26		 jmp	 SHORT $LN7@memory_ite
$LN1@memory_ite:

; 2179 :         return unpack_single(ptr, fmt);

  000c5	48 8b 54 24 20	 mov	 rdx, QWORD PTR fmt$[rsp]
  000ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$21915[rsp]
  000cf	e8 00 00 00 00	 call	 unpack_single
  000d4	eb 15		 jmp	 SHORT $LN7@memory_ite
$LN2@memory_ite:

; 2180 :     }
; 2181 : 
; 2182 :     PyErr_SetString(PyExc_NotImplementedError,
; 2183 :         "multi-dimensional sub-views are not implemented");

  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@HBCJDDJF@multi?9dimensional?5sub?9views?5are?5@
  000dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  000e4	e8 00 00 00 00	 call	 PyErr_SetString

; 2184 :     return NULL;

  000e9	33 c0		 xor	 eax, eax
$LN7@memory_ite:

; 2185 : }

  000eb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ef	c3		 ret	 0
memory_item ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@PJNGABLJ@index?5out?5of?5bounds?$AA@	; `string'
PUBLIC	??_C@_1BM@CONIEBNK@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@HPFHMENC@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?$AA@ ; `string'
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$ptr_from_index DD imagerel ptr_from_index
	DD	imagerel ptr_from_index+320
	DD	imagerel $unwind$ptr_from_index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ptr_from_index DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BE@PJNGABLJ@index?5out?5of?5bounds?$AA@
CONST	SEGMENT
??_C@_0BE@PJNGABLJ@index?5out?5of?5bounds?$AA@ DB 'index out of bounds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@CONIEBNK@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@CONIEBNK@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?$AA@ DB 'v'
	DB	00H, 'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@HPFHMENC@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@HPFHMENC@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'i', 00H, 'e', 00H, 'w', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'p', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ptr_from_index
_TEXT	SEGMENT
ptr$ = 32
nitems$ = 40
tv128 = 48
view$ = 80
index$ = 88
ptr_from_index PROC					; COMDAT

; 2132 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2133 :     char *ptr;
; 2134 :     Py_ssize_t nitems; /* items in the first dimension */
; 2135 : 
; 2136 :     assert(view->shape);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR view$[rsp]
  00013	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00018	75 1c		 jne	 SHORT $LN6@ptr_from_i
  0001a	41 b8 58 08 00
	00		 mov	 r8d, 2136		; 00000858H
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@HPFHMENC@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?$AA@
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00034	33 c0		 xor	 eax, eax
$LN6@ptr_from_i:

; 2137 :     assert(view->strides);

  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR view$[rsp]
  0003b	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00040	75 1c		 jne	 SHORT $LN7@ptr_from_i
  00042	41 b8 59 08 00
	00		 mov	 r8d, 2137		; 00000859H
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@CONIEBNK@?$AAv?$AAi?$AAe?$AAw?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?$AA@
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005c	33 c0		 xor	 eax, eax
$LN7@ptr_from_i:

; 2138 : 
; 2139 :     nitems = view->shape[0];

  0005e	48 8b 44 24 50	 mov	 rax, QWORD PTR view$[rsp]
  00063	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00067	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006a	48 89 44 24 28	 mov	 QWORD PTR nitems$[rsp], rax

; 2140 :     if (index < 0) {

  0006f	48 83 7c 24 58
	00		 cmp	 QWORD PTR index$[rsp], 0
  00075	7d 15		 jge	 SHORT $LN3@ptr_from_i

; 2141 :         index += nitems;

  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR nitems$[rsp]
  0007c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR index$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 58	 mov	 QWORD PTR index$[rsp], rax
$LN3@ptr_from_i:

; 2142 :     }
; 2143 :     if (index < 0 || index >= nitems) {

  0008c	48 83 7c 24 58
	00		 cmp	 QWORD PTR index$[rsp], 0
  00092	7c 0c		 jl	 SHORT $LN1@ptr_from_i
  00094	48 8b 44 24 28	 mov	 rax, QWORD PTR nitems$[rsp]
  00099	48 39 44 24 58	 cmp	 QWORD PTR index$[rsp], rax
  0009e	7c 1a		 jl	 SHORT $LN2@ptr_from_i
$LN1@ptr_from_i:

; 2144 :         PyErr_SetString(PyExc_IndexError, "index out of bounds");

  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@PJNGABLJ@index?5out?5of?5bounds?$AA@
  000a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000ae	e8 00 00 00 00	 call	 PyErr_SetString

; 2145 :         return NULL;

  000b3	33 c0		 xor	 eax, eax
  000b5	e9 81 00 00 00	 jmp	 $LN4@ptr_from_i
$LN2@ptr_from_i:

; 2146 :     }
; 2147 : 
; 2148 :     ptr = (char *)view->buf;

  000ba	48 8b 44 24 50	 mov	 rax, QWORD PTR view$[rsp]
  000bf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c2	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax

; 2149 :     ptr += view->strides[0] * index;

  000c7	48 8b 44 24 50	 mov	 rax, QWORD PTR view$[rsp]
  000cc	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000d0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d3	48 0f af 44 24
	58		 imul	 rax, QWORD PTR index$[rsp]
  000d9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  000de	48 03 c8	 add	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax

; 2150 : 
; 2151 :     ptr = ADJUST_PTR(ptr, view->suboffsets);

  000e9	48 8b 44 24 50	 mov	 rax, QWORD PTR view$[rsp]
  000ee	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  000f3	74 2d		 je	 SHORT $LN8@ptr_from_i
  000f5	48 8b 44 24 50	 mov	 rax, QWORD PTR view$[rsp]
  000fa	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000fe	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00102	7c 1e		 jl	 SHORT $LN8@ptr_from_i
  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR view$[rsp]
  00109	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0010d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  00112	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00115	48 03 08	 add	 rcx, QWORD PTR [rax]
  00118	48 8b c1	 mov	 rax, rcx
  0011b	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
  00120	eb 0a		 jmp	 SHORT $LN9@ptr_from_i
$LN8@ptr_from_i:
  00122	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  00127	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
$LN9@ptr_from_i:
  0012c	48 8b 44 24 30	 mov	 rax, QWORD PTR tv128[rsp]
  00131	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax

; 2152 : 
; 2153 :     return ptr;

  00136	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
$LN4@ptr_from_i:

; 2154 : }

  0013b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013f	c3		 ret	 0
ptr_from_index ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@JBOMHNNO@memoryview?3?5invalid?5slice?5key?$AA@ ; `string'
PUBLIC	??_C@_0CN@IJFACBLG@multi?9dimensional?5slicing?5is?5not@ ; `string'
EXTRN	PySlice_Type:BYTE
EXTRN	PyNumber_AsSsize_t:PROC
EXTRN	_Py_EllipsisObject:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_subscript DD imagerel memory_subscript
	DD	imagerel memory_subscript+581
	DD	imagerel $unwind$memory_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_subscript DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BO@JBOMHNNO@memoryview?3?5invalid?5slice?5key?$AA@
CONST	SEGMENT
??_C@_0BO@JBOMHNNO@memoryview?3?5invalid?5slice?5key?$AA@ DB 'memoryview:'
	DB	' invalid slice key', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IJFACBLG@multi?9dimensional?5slicing?5is?5not@
CONST	SEGMENT
??_C@_0CN@IJFACBLG@multi?9dimensional?5slicing?5is?5not@ DB 'multi-dimens'
	DB	'ional slicing is not implemented', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_subscript
_TEXT	SEGMENT
view$ = 32
fmt$21978 = 40
index$21991 = 48
sliced$21997 = 56
self$ = 80
key$ = 88
memory_subscript PROC					; COMDAT

; 2243 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2244 :     Py_buffer *view;
; 2245 :     view = &(self->view);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00019	48 89 44 24 20	 mov	 QWORD PTR view$[rsp], rax

; 2246 :     
; 2247 :     CHECK_RELEASED(self);

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00023	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00029	83 e0 01	 and	 eax, 1
  0002c	85 c0		 test	 eax, eax
  0002e	75 13		 jne	 SHORT $LN15@memory_sub
  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00035	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00039	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	74 1a		 je	 SHORT $LN16@memory_sub
$LN15@memory_sub:
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00051	e8 00 00 00 00	 call	 PyErr_SetString
  00056	33 c0		 xor	 eax, eax
  00058	e9 e3 01 00 00	 jmp	 $LN17@memory_sub
$LN16@memory_sub:

; 2248 : 
; 2249 :     if (view->ndim == 0) {

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  00062	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00066	0f 85 99 00 00
	00		 jne	 $LN14@memory_sub

; 2250 :         if (PyTuple_Check(key) && PyTuple_GET_SIZE(key) == 0) {

  0006c	48 8b 44 24 58	 mov	 rax, QWORD PTR key$[rsp]
  00071	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00075	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0007b	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00080	85 c0		 test	 eax, eax
  00082	74 43		 je	 SHORT $LN13@memory_sub
  00084	48 8b 44 24 58	 mov	 rax, QWORD PTR key$[rsp]
  00089	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0008e	75 37		 jne	 SHORT $LN13@memory_sub

; 2251 :             const char *fmt = adjust_fmt(view);

  00090	48 8b 4c 24 20	 mov	 rcx, QWORD PTR view$[rsp]
  00095	e8 00 00 00 00	 call	 adjust_fmt
  0009a	48 89 44 24 28	 mov	 QWORD PTR fmt$21978[rsp], rax

; 2252 :             if (fmt == NULL)

  0009f	48 83 7c 24 28
	00		 cmp	 QWORD PTR fmt$21978[rsp], 0
  000a5	75 07		 jne	 SHORT $LN12@memory_sub

; 2253 :                 return NULL;

  000a7	33 c0		 xor	 eax, eax
  000a9	e9 92 01 00 00	 jmp	 $LN17@memory_sub
$LN12@memory_sub:

; 2254 :             return unpack_single(view->buf, fmt);

  000ae	48 8b 54 24 28	 mov	 rdx, QWORD PTR fmt$21978[rsp]
  000b3	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  000b8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000bb	e8 00 00 00 00	 call	 unpack_single
  000c0	e9 7b 01 00 00	 jmp	 $LN17@memory_sub
  000c5	eb 3e		 jmp	 SHORT $LN11@memory_sub
$LN13@memory_sub:

; 2255 :         }
; 2256 :         else if (key == Py_Ellipsis) {

  000c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_EllipsisObject
  000ce	48 39 44 24 58	 cmp	 QWORD PTR key$[rsp], rax
  000d3	75 16		 jne	 SHORT $LN10@memory_sub

; 2257 :             Py_INCREF(self);

  000d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000da	e8 00 00 00 00	 call	 _Py_IncRef

; 2258 :             return (PyObject *)self;

  000df	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000e4	e9 57 01 00 00	 jmp	 $LN17@memory_sub

; 2259 :         }
; 2260 :         else {

  000e9	eb 1a		 jmp	 SHORT $LN9@memory_sub
$LN10@memory_sub:

; 2261 :             PyErr_SetString(PyExc_TypeError,
; 2262 :                 "invalid indexing of 0-dim memory");

  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@
  000f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000f9	e8 00 00 00 00	 call	 PyErr_SetString

; 2263 :             return NULL;

  000fe	33 c0		 xor	 eax, eax
  00100	e9 3b 01 00 00	 jmp	 $LN17@memory_sub
$LN9@memory_sub:
$LN11@memory_sub:
$LN14@memory_sub:

; 2264 :         }
; 2265 :     }
; 2266 : 
; 2267 :     if (PyIndex_Check(key)) {

  00105	48 8b 44 24 58	 mov	 rax, QWORD PTR key$[rsp]
  0010a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0010e	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00116	74 62		 je	 SHORT $LN8@memory_sub
  00118	48 8b 44 24 58	 mov	 rax, QWORD PTR key$[rsp]
  0011d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00121	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00128	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00130	74 48		 je	 SHORT $LN8@memory_sub

; 2268 :         Py_ssize_t index;
; 2269 :         index = PyNumber_AsSsize_t(key, PyExc_IndexError);

  00132	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00139	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0013e	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00143	48 89 44 24 30	 mov	 QWORD PTR index$21991[rsp], rax

; 2270 :         if (index == -1 && PyErr_Occurred())

  00148	48 83 7c 24 30
	ff		 cmp	 QWORD PTR index$21991[rsp], -1
  0014e	75 11		 jne	 SHORT $LN7@memory_sub
  00150	e8 00 00 00 00	 call	 PyErr_Occurred
  00155	48 85 c0	 test	 rax, rax
  00158	74 07		 je	 SHORT $LN7@memory_sub

; 2271 :             return NULL;

  0015a	33 c0		 xor	 eax, eax
  0015c	e9 df 00 00 00	 jmp	 $LN17@memory_sub
$LN7@memory_sub:

; 2272 :         return memory_item(self, index);

  00161	48 8b 54 24 30	 mov	 rdx, QWORD PTR index$21991[rsp]
  00166	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0016b	e8 00 00 00 00	 call	 memory_item
  00170	e9 cb 00 00 00	 jmp	 $LN17@memory_sub
  00175	e9 b1 00 00 00	 jmp	 $LN6@memory_sub
$LN8@memory_sub:

; 2273 :     }
; 2274 :     else if (PySlice_Check(key)) {

  0017a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  00181	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00186	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0018a	75 7a		 jne	 SHORT $LN5@memory_sub

; 2275 :         PyMemoryViewObject *sliced;
; 2276 : 
; 2277 :         sliced = (PyMemoryViewObject *)mbuf_add_view(self->mbuf, view);

  0018c	48 8b 54 24 20	 mov	 rdx, QWORD PTR view$[rsp]
  00191	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00196	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0019a	e8 00 00 00 00	 call	 mbuf_add_view
  0019f	48 89 44 24 38	 mov	 QWORD PTR sliced$21997[rsp], rax

; 2278 :         if (sliced == NULL)

  001a4	48 83 7c 24 38
	00		 cmp	 QWORD PTR sliced$21997[rsp], 0
  001aa	75 07		 jne	 SHORT $LN4@memory_sub

; 2279 :             return NULL;

  001ac	33 c0		 xor	 eax, eax
  001ae	e9 8d 00 00 00	 jmp	 $LN17@memory_sub
$LN4@memory_sub:

; 2280 : 
; 2281 :         if (init_slice(&sliced->view, key, 0) < 0) {

  001b3	48 8b 44 24 38	 mov	 rax, QWORD PTR sliced$21997[rsp]
  001b8	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  001be	45 33 c0	 xor	 r8d, r8d
  001c1	48 8b 54 24 58	 mov	 rdx, QWORD PTR key$[rsp]
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	e8 00 00 00 00	 call	 init_slice
  001ce	85 c0		 test	 eax, eax
  001d0	7d 0e		 jge	 SHORT $LN3@memory_sub

; 2282 :             Py_DECREF(sliced);

  001d2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sliced$21997[rsp]
  001d7	e8 00 00 00 00	 call	 _Py_DecRef

; 2283 :             return NULL;

  001dc	33 c0		 xor	 eax, eax
  001de	eb 60		 jmp	 SHORT $LN17@memory_sub
$LN3@memory_sub:

; 2284 :         }
; 2285 :         init_len(&sliced->view);

  001e0	48 8b 44 24 38	 mov	 rax, QWORD PTR sliced$21997[rsp]
  001e5	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  001eb	48 8b c8	 mov	 rcx, rax
  001ee	e8 00 00 00 00	 call	 init_len

; 2286 :         init_flags(sliced);

  001f3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sliced$21997[rsp]
  001f8	e8 00 00 00 00	 call	 init_flags

; 2287 : 
; 2288 :         return (PyObject *)sliced;

  001fd	48 8b 44 24 38	 mov	 rax, QWORD PTR sliced$21997[rsp]
  00202	eb 3c		 jmp	 SHORT $LN17@memory_sub
  00204	eb 25		 jmp	 SHORT $LN2@memory_sub
$LN5@memory_sub:

; 2289 :     }
; 2290 :     else if (is_multislice(key)) {

  00206	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0020b	e8 00 00 00 00	 call	 is_multislice
  00210	85 c0		 test	 eax, eax
  00212	74 17		 je	 SHORT $LN1@memory_sub

; 2291 :         PyErr_SetString(PyExc_NotImplementedError,
; 2292 :             "multi-dimensional slicing is not implemented");

  00214	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@IJFACBLG@multi?9dimensional?5slicing?5is?5not@
  0021b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00222	e8 00 00 00 00	 call	 PyErr_SetString

; 2293 :         return NULL;

  00227	33 c0		 xor	 eax, eax
  00229	eb 15		 jmp	 SHORT $LN17@memory_sub
$LN1@memory_sub:
$LN2@memory_sub:
$LN6@memory_sub:

; 2294 :     }
; 2295 : 
; 2296 :     PyErr_SetString(PyExc_TypeError, "memoryview: invalid slice key");

  0022b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@JBOMHNNO@memoryview?3?5invalid?5slice?5key?$AA@
  00232	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00239	e8 00 00 00 00	 call	 PyErr_SetString

; 2297 :     return NULL;

  0023e	33 c0		 xor	 eax, eax
$LN17@memory_sub:

; 2298 : }

  00240	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00244	c3		 ret	 0
memory_subscript ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_len DD imagerel init_len
	DD	imagerel init_len+129
	DD	imagerel $unwind$init_len
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_len DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT init_len
_TEXT	SEGMENT
i$ = 0
len$ = 8
view$ = 32
init_len PROC						; COMDAT

; 574  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 575  :     Py_ssize_t i, len;
; 576  : 
; 577  :     len = 1;

  00009	48 c7 44 24 08
	01 00 00 00	 mov	 QWORD PTR len$[rsp], 1

; 578  :     for (i = 0; i < view->ndim; i++)

  00012	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001a	eb 0b		 jmp	 SHORT $LN3@init_len
$LN2@init_len:
  0001c	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00020	48 ff c0	 inc	 rax
  00023	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN3@init_len:
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  0002c	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00030	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  00034	7d 21		 jge	 SHORT $LN1@init_len

; 579  :         len *= view->shape[i];

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  0003b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0003f	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00043	48 8b 54 24 08	 mov	 rdx, QWORD PTR len$[rsp]
  00048	48 0f af 14 c8	 imul	 rdx, QWORD PTR [rax+rcx*8]
  0004d	48 8b c2	 mov	 rax, rdx
  00050	48 89 44 24 08	 mov	 QWORD PTR len$[rsp], rax
  00055	eb c5		 jmp	 SHORT $LN2@init_len
$LN1@init_len:

; 580  :     len *= view->itemsize;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  0005c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR len$[rsp]
  00061	48 0f af 48 18	 imul	 rcx, QWORD PTR [rax+24]
  00066	48 8b c1	 mov	 rax, rcx
  00069	48 89 44 24 08	 mov	 QWORD PTR len$[rsp], rax

; 581  : 
; 582  :     view->len = len;

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  00073	48 8b 4c 24 08	 mov	 rcx, QWORD PTR len$[rsp]
  00078	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 583  : }

  0007c	48 83 c4 18	 add	 rsp, 24
  00080	c3		 ret	 0
init_len ENDP
_TEXT	ENDS
EXTRN	PySlice_GetIndicesEx:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_slice DD imagerel init_slice
	DD	imagerel init_slice+381
	DD	imagerel $unwind$init_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_slice DD 011301H
	DD	0c213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT init_slice
_TEXT	SEGMENT
slicelength$ = 48
step$ = 56
stop$ = 64
start$ = 72
n$21940 = 80
base$ = 112
key$ = 120
dim$ = 128
init_slice PROC						; COMDAT

; 2189 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2190 :     Py_ssize_t start, stop, step, slicelength;
; 2191 : 
; 2192 :     if (PySlice_GetIndicesEx(key, base->shape[dim],
; 2193 :                              &start, &stop, &step, &slicelength) < 0) {

  00013	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR dim$[rsp]
  0001b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR base$[rsp]
  00020	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00024	48 8d 54 24 30	 lea	 rdx, QWORD PTR slicelength$[rsp]
  00029	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0002e	48 8d 54 24 38	 lea	 rdx, QWORD PTR step$[rsp]
  00033	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00038	4c 8d 4c 24 40	 lea	 r9, QWORD PTR stop$[rsp]
  0003d	4c 8d 44 24 48	 lea	 r8, QWORD PTR start$[rsp]
  00042	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00046	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  0004b	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  00050	85 c0		 test	 eax, eax
  00052	7d 0a		 jge	 SHORT $LN7@init_slice

; 2194 :         return -1;

  00054	b8 ff ff ff ff	 mov	 eax, -1
  00059	e9 1a 01 00 00	 jmp	 $LN8@init_slice
$LN7@init_slice:

; 2195 :     }
; 2196 : 
; 2197 : 
; 2198 :     if (base->suboffsets == NULL || dim == 0) {

  0005e	48 8b 44 24 70	 mov	 rax, QWORD PTR base$[rsp]
  00063	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00068	74 0a		 je	 SHORT $LN5@init_slice
  0006a	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR dim$[rsp], 0
  00072	75 30		 jne	 SHORT $LN6@init_slice
$LN5@init_slice:
$adjust_buf$21937:

; 2199 :     adjust_buf:
; 2200 :         base->buf = (char *)base->buf + base->strides[dim] * start;

  00074	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR dim$[rsp]
  0007c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR base$[rsp]
  00081	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00085	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00089	48 0f af 44 24
	48		 imul	 rax, QWORD PTR start$[rsp]
  0008f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR base$[rsp]
  00094	48 03 01	 add	 rax, QWORD PTR [rcx]
  00097	48 8b 4c 24 70	 mov	 rcx, QWORD PTR base$[rsp]
  0009c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2201 :     }
; 2202 :     else {

  0009f	e9 88 00 00 00	 jmp	 $LN4@init_slice
$LN6@init_slice:

; 2203 :         Py_ssize_t n = dim-1;

  000a4	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR dim$[rsp]
  000ab	ff c8		 dec	 eax
  000ad	48 98		 cdqe
  000af	48 89 44 24 50	 mov	 QWORD PTR n$21940[rsp], rax
$LN3@init_slice:

; 2204 :         while (n >= 0 && base->suboffsets[n] < 0)

  000b4	48 83 7c 24 50
	00		 cmp	 QWORD PTR n$21940[rsp], 0
  000ba	7c 24		 jl	 SHORT $LN2@init_slice
  000bc	48 8b 44 24 70	 mov	 rax, QWORD PTR base$[rsp]
  000c1	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR n$21940[rsp]
  000ca	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  000cf	7d 0f		 jge	 SHORT $LN2@init_slice

; 2205 :             n--;

  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR n$21940[rsp]
  000d6	48 ff c8	 dec	 rax
  000d9	48 89 44 24 50	 mov	 QWORD PTR n$21940[rsp], rax
  000de	eb d4		 jmp	 SHORT $LN3@init_slice
$LN2@init_slice:

; 2206 :         if (n < 0)

  000e0	48 83 7c 24 50
	00		 cmp	 QWORD PTR n$21940[rsp], 0
  000e6	7d 02		 jge	 SHORT $LN1@init_slice

; 2207 :             goto adjust_buf; /* all suboffsets are negative */

  000e8	eb 8a		 jmp	 SHORT $adjust_buf$21937
$LN1@init_slice:

; 2208 :         base->suboffsets[n] = base->suboffsets[n] + base->strides[dim] * start;

  000ea	48 8b 44 24 70	 mov	 rax, QWORD PTR base$[rsp]
  000ef	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000f3	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR dim$[rsp]
  000fb	48 8b 54 24 70	 mov	 rdx, QWORD PTR base$[rsp]
  00100	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  00104	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00108	48 0f af 4c 24
	48		 imul	 rcx, QWORD PTR start$[rsp]
  0010e	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$21940[rsp]
  00113	48 03 0c d0	 add	 rcx, QWORD PTR [rax+rdx*8]
  00117	48 8b c1	 mov	 rax, rcx
  0011a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR base$[rsp]
  0011f	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00123	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$21940[rsp]
  00128	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
$LN4@init_slice:

; 2209 :     }
; 2210 :     base->shape[dim] = slicelength;

  0012c	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR dim$[rsp]
  00134	48 8b 4c 24 70	 mov	 rcx, QWORD PTR base$[rsp]
  00139	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0013d	48 8b 54 24 30	 mov	 rdx, QWORD PTR slicelength$[rsp]
  00142	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 2211 :     base->strides[dim] = base->strides[dim] * step;

  00146	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR dim$[rsp]
  0014e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR base$[rsp]
  00153	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00157	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0015b	48 0f af 44 24
	38		 imul	 rax, QWORD PTR step$[rsp]
  00161	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR dim$[rsp]
  00169	48 8b 54 24 70	 mov	 rdx, QWORD PTR base$[rsp]
  0016e	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  00172	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 2212 : 
; 2213 :     return 0;

  00176	33 c0		 xor	 eax, eax
$LN8@init_slice:

; 2214 : }

  00178	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017c	c3		 ret	 0
init_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_multislice DD imagerel is_multislice
	DD	imagerel is_multislice+148
	DD	imagerel $unwind$is_multislice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_multislice DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT is_multislice
_TEXT	SEGMENT
i$ = 0
size$ = 8
x$21958 = 16
key$ = 48
is_multislice PROC					; COMDAT

; 2218 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2219 :     Py_ssize_t size, i;
; 2220 : 
; 2221 :     if (!PyTuple_Check(key))

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR key$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0001d	85 c0		 test	 eax, eax
  0001f	75 04		 jne	 SHORT $LN6@is_multisl

; 2222 :         return 0;

  00021	33 c0		 xor	 eax, eax
  00023	eb 6a		 jmp	 SHORT $LN7@is_multisl
$LN6@is_multisl:

; 2223 :     size = PyTuple_GET_SIZE(key);

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR key$[rsp]
  0002a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002e	48 89 44 24 08	 mov	 QWORD PTR size$[rsp], rax

; 2224 :     if (size == 0)

  00033	48 83 7c 24 08
	00		 cmp	 QWORD PTR size$[rsp], 0
  00039	75 04		 jne	 SHORT $LN5@is_multisl

; 2225 :         return 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 50		 jmp	 SHORT $LN7@is_multisl
$LN5@is_multisl:

; 2226 : 
; 2227 :     for (i = 0; i < size; i++) {

  0003f	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00047	eb 0b		 jmp	 SHORT $LN4@is_multisl
$LN3@is_multisl:
  00049	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  0004d	48 ff c0	 inc	 rax
  00050	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN4@is_multisl:
  00054	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  00059	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  0005d	7d 2b		 jge	 SHORT $LN2@is_multisl

; 2228 :         PyObject *x = PyTuple_GET_ITEM(key, i);

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR key$[rsp]
  00064	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00068	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  0006d	48 89 44 24 10	 mov	 QWORD PTR x$21958[rsp], rax

; 2229 :         if (!PySlice_Check(x))

  00072	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  00079	48 8b 4c 24 10	 mov	 rcx, QWORD PTR x$21958[rsp]
  0007e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00082	74 04		 je	 SHORT $LN1@is_multisl

; 2230 :             return 0;

  00084	33 c0		 xor	 eax, eax
  00086	eb 07		 jmp	 SHORT $LN7@is_multisl
$LN1@is_multisl:

; 2231 :     }

  00088	eb bf		 jmp	 SHORT $LN3@is_multisl
$LN2@is_multisl:

; 2232 :     return 1;

  0008a	b8 01 00 00 00	 mov	 eax, 1
$LN7@is_multisl:

; 2233 : }

  0008f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00093	c3		 ret	 0
is_multislice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@FKBBMJOI@memoryview?5slice?5assignments?5are@ ; `string'
PUBLIC	$T23611
PUBLIC	??_C@_0DM@HEIJLNGM@memoryview?5assignments?5are?5curre@ ; `string'
PUBLIC	??_C@_0BF@FICMIAHK@cannot?5delete?5memory?$AA@	; `string'
PUBLIC	??_C@_0BP@LDOIJEIN@cannot?5modify?5read?9only?5memory?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_ass_sub DD imagerel memory_ass_sub
	DD	imagerel memory_ass_sub+1075
	DD	imagerel $unwind$memory_ass_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_ass_sub DD 041801H
	DD	02d0118H
	DD	060107011H
xdata	ENDS
;	COMDAT ??_C@_0EC@FKBBMJOI@memoryview?5slice?5assignments?5are@
CONST	SEGMENT
??_C@_0EC@FKBBMJOI@memoryview?5slice?5assignments?5are@ DB 'memoryview sl'
	DB	'ice assignments are currently restricted to ndim = 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HEIJLNGM@memoryview?5assignments?5are?5curre@
CONST	SEGMENT
??_C@_0DM@HEIJLNGM@memoryview?5assignments?5are?5curre@ DB 'memoryview as'
	DB	'signments are currently restricted to ndim = 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FICMIAHK@cannot?5delete?5memory?$AA@
CONST	SEGMENT
??_C@_0BF@FICMIAHK@cannot?5delete?5memory?$AA@ DB 'cannot delete memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LDOIJEIN@cannot?5modify?5read?9only?5memory?$AA@
CONST	SEGMENT
??_C@_0BP@LDOIJEIN@cannot?5modify?5read?9only?5memory?$AA@ DB 'cannot mod'
	DB	'ify read-only memory', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_ass_sub
_TEXT	SEGMENT
ptr$ = 32
fmt$ = 40
view$ = 48
src$ = 64
index$22047 = 144
dest$22053 = 160
ret$22055 = 240
arrays$22054 = 248
$T23611 = 272
self$ = 384
key$ = 392
value$ = 400
memory_ass_sub PROC					; COMDAT

; 2302 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H

; 2303 :     Py_buffer *view = &(self->view);

  00018	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00026	48 89 44 24 30	 mov	 QWORD PTR view$[rsp], rax

; 2304 :     Py_buffer src;
; 2305 :     const char *fmt;
; 2306 :     char *ptr;
; 2307 : 
; 2308 :     CHECK_RELEASED_INT(self);

  0002b	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00033	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00039	83 e0 01	 and	 eax, 1
  0003c	85 c0		 test	 eax, eax
  0003e	75 16		 jne	 SHORT $LN19@memory_ass
  00040	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00048	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0004c	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0004f	83 e0 01	 and	 eax, 1
  00052	85 c0		 test	 eax, eax
  00054	74 1d		 je	 SHORT $LN20@memory_ass
$LN19@memory_ass:
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0005d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00064	e8 00 00 00 00	 call	 PyErr_SetString
  00069	b8 ff ff ff ff	 mov	 eax, -1
  0006e	e9 b6 03 00 00	 jmp	 $LN21@memory_ass
$LN20@memory_ass:

; 2309 : 
; 2310 :     fmt = adjust_fmt(view);

  00073	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp]
  00078	e8 00 00 00 00	 call	 adjust_fmt
  0007d	48 89 44 24 28	 mov	 QWORD PTR fmt$[rsp], rax

; 2311 :     if (fmt == NULL)

  00082	48 83 7c 24 28
	00		 cmp	 QWORD PTR fmt$[rsp], 0
  00088	75 0a		 jne	 SHORT $LN18@memory_ass

; 2312 :         return -1;

  0008a	b8 ff ff ff ff	 mov	 eax, -1
  0008f	e9 95 03 00 00	 jmp	 $LN21@memory_ass
$LN18@memory_ass:

; 2313 : 
; 2314 :     if (view->readonly) {

  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00099	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  0009d	74 1d		 je	 SHORT $LN17@memory_ass

; 2315 :         PyErr_SetString(PyExc_TypeError, "cannot modify read-only memory");

  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@LDOIJEIN@cannot?5modify?5read?9only?5memory?$AA@
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ad	e8 00 00 00 00	 call	 PyErr_SetString

; 2316 :         return -1;

  000b2	b8 ff ff ff ff	 mov	 eax, -1
  000b7	e9 6d 03 00 00	 jmp	 $LN21@memory_ass
$LN17@memory_ass:

; 2317 :     }
; 2318 :     if (value == NULL) {

  000bc	48 83 bc 24 90
	01 00 00 00	 cmp	 QWORD PTR value$[rsp], 0
  000c5	75 1d		 jne	 SHORT $LN16@memory_ass

; 2319 :         PyErr_SetString(PyExc_TypeError, "cannot delete memory");

  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@FICMIAHK@cannot?5delete?5memory?$AA@
  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d5	e8 00 00 00 00	 call	 PyErr_SetString

; 2320 :         return -1;

  000da	b8 ff ff ff ff	 mov	 eax, -1
  000df	e9 45 03 00 00	 jmp	 $LN21@memory_ass
$LN16@memory_ass:

; 2321 :     }
; 2322 :     if (view->ndim == 0) {

  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  000e9	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  000ed	0f 85 83 00 00
	00		 jne	 $LN15@memory_ass

; 2323 :         if (key == Py_Ellipsis ||
; 2324 :             (PyTuple_Check(key) && PyTuple_GET_SIZE(key)==0)) {

  000f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_EllipsisObject
  000fa	48 39 84 24 88
	01 00 00	 cmp	 QWORD PTR key$[rsp], rax
  00102	74 2a		 je	 SHORT $LN13@memory_ass
  00104	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR key$[rsp]
  0010c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00110	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00116	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0011b	85 c0		 test	 eax, eax
  0011d	74 3a		 je	 SHORT $LN14@memory_ass
  0011f	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR key$[rsp]
  00127	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0012c	75 2b		 jne	 SHORT $LN14@memory_ass
$LN13@memory_ass:

; 2325 :             ptr = (char *)view->buf;

  0012e	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00133	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00136	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax

; 2326 :             return pack_single(ptr, value, fmt);

  0013b	4c 8b 44 24 28	 mov	 r8, QWORD PTR fmt$[rsp]
  00140	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR value$[rsp]
  00148	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  0014d	e8 00 00 00 00	 call	 pack_single
  00152	e9 d2 02 00 00	 jmp	 $LN21@memory_ass

; 2327 :         }
; 2328 :         else {

  00157	eb 1d		 jmp	 SHORT $LN12@memory_ass
$LN14@memory_ass:

; 2329 :             PyErr_SetString(PyExc_TypeError,
; 2330 :                 "invalid indexing of 0-dim memory");

  00159	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@
  00160	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00167	e8 00 00 00 00	 call	 PyErr_SetString

; 2331 :             return -1;

  0016c	b8 ff ff ff ff	 mov	 eax, -1
  00171	e9 b3 02 00 00	 jmp	 $LN21@memory_ass
$LN12@memory_ass:
$LN15@memory_ass:

; 2332 :         }
; 2333 :     }
; 2334 :     if (view->ndim != 1) {

  00176	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0017b	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  0017f	74 1d		 je	 SHORT $LN11@memory_ass

; 2335 :         PyErr_SetString(PyExc_NotImplementedError,
; 2336 :             "memoryview assignments are currently restricted to ndim = 1");

  00181	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DM@HEIJLNGM@memoryview?5assignments?5are?5curre@
  00188	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0018f	e8 00 00 00 00	 call	 PyErr_SetString

; 2337 :         return -1;

  00194	b8 ff ff ff ff	 mov	 eax, -1
  00199	e9 8b 02 00 00	 jmp	 $LN21@memory_ass
$LN11@memory_ass:

; 2338 :     }
; 2339 : 
; 2340 :     if (PyIndex_Check(key)) {

  0019e	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR key$[rsp]
  001a6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001aa	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  001b2	0f 84 a1 00 00
	00		 je	 $LN10@memory_ass
  001b8	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR key$[rsp]
  001c0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001c4	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  001cb	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  001d3	0f 84 80 00 00
	00		 je	 $LN10@memory_ass

; 2341 :         Py_ssize_t index = PyNumber_AsSsize_t(key, PyExc_IndexError);

  001d9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  001e0	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  001e8	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  001ed	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR index$22047[rsp], rax

; 2342 :         if (index == -1 && PyErr_Occurred())

  001f5	48 83 bc 24 90
	00 00 00 ff	 cmp	 QWORD PTR index$22047[rsp], -1
  001fe	75 14		 jne	 SHORT $LN9@memory_ass
  00200	e8 00 00 00 00	 call	 PyErr_Occurred
  00205	48 85 c0	 test	 rax, rax
  00208	74 0a		 je	 SHORT $LN9@memory_ass

; 2343 :             return -1;

  0020a	b8 ff ff ff ff	 mov	 eax, -1
  0020f	e9 15 02 00 00	 jmp	 $LN21@memory_ass
$LN9@memory_ass:

; 2344 :         ptr = ptr_from_index(view, index);

  00214	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR index$22047[rsp]
  0021c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp]
  00221	e8 00 00 00 00	 call	 ptr_from_index
  00226	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax

; 2345 :         if (ptr == NULL)

  0022b	48 83 7c 24 20
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  00231	75 0a		 jne	 SHORT $LN8@memory_ass

; 2346 :             return -1;

  00233	b8 ff ff ff ff	 mov	 eax, -1
  00238	e9 ec 01 00 00	 jmp	 $LN21@memory_ass
$LN8@memory_ass:

; 2347 :         return pack_single(ptr, value, fmt);

  0023d	4c 8b 44 24 28	 mov	 r8, QWORD PTR fmt$[rsp]
  00242	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR value$[rsp]
  0024a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  0024f	e8 00 00 00 00	 call	 pack_single
  00254	e9 d0 01 00 00	 jmp	 $LN21@memory_ass
$LN10@memory_ass:

; 2348 :     }
; 2349 :     /* one-dimensional: fast path */
; 2350 :     if (PySlice_Check(key) && view->ndim == 1) {

  00259	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  00260	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  00268	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0026c	0f 85 5f 01 00
	00		 jne	 $LN7@memory_ass
  00272	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00277	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  0027b	0f 85 50 01 00
	00		 jne	 $LN7@memory_ass

; 2351 :         Py_buffer dest; /* sliced view */
; 2352 :         Py_ssize_t arrays[3];
; 2353 :         int ret = -1;

  00281	c7 84 24 f0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ret$22055[rsp], -1

; 2354 : 
; 2355 :         /* rvalue must be an exporter */
; 2356 :         if (PyObject_GetBuffer(value, &src, PyBUF_FULL_RO) < 0)

  0028c	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  00292	48 8d 54 24 40	 lea	 rdx, QWORD PTR src$[rsp]
  00297	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  0029f	e8 00 00 00 00	 call	 PyObject_GetBuffer
  002a4	85 c0		 test	 eax, eax
  002a6	7d 0c		 jge	 SHORT $LN6@memory_ass

; 2357 :             return ret;

  002a8	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ret$22055[rsp]
  002af	e9 75 01 00 00	 jmp	 $LN21@memory_ass
$LN6@memory_ass:

; 2358 : 
; 2359 :         dest = *view;

  002b4	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR $T23611[rsp]
  002bc	48 8b f8	 mov	 rdi, rax
  002bf	48 8b 74 24 30	 mov	 rsi, QWORD PTR view$[rsp]
  002c4	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  002c9	f3 a4		 rep movsb
  002cb	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dest$22053[rsp]
  002d3	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T23611[rsp]
  002db	48 8b f8	 mov	 rdi, rax
  002de	48 8b f1	 mov	 rsi, rcx
  002e1	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  002e6	f3 a4		 rep movsb

; 2360 :         dest.shape = &arrays[0]; dest.shape[0] = view->shape[0];

  002e8	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR arrays$22054[rsp]
  002f0	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR dest$22053[rsp+48], rax
  002f8	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  002fd	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00301	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dest$22053[rsp+48]
  00309	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0030c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2361 :         dest.strides = &arrays[1]; dest.strides[0] = view->strides[0];

  0030f	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR arrays$22054[rsp+8]
  00317	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR dest$22053[rsp+56], rax
  0031f	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00324	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00328	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dest$22053[rsp+56]
  00330	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00333	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2362 :         if (view->suboffsets) {

  00336	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0033b	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00340	74 27		 je	 SHORT $LN5@memory_ass

; 2363 :             dest.suboffsets = &arrays[2]; dest.suboffsets[0] = view->suboffsets[0];

  00342	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR arrays$22054[rsp+16]
  0034a	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR dest$22053[rsp+64], rax
  00352	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00357	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0035b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dest$22053[rsp+64]
  00363	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00366	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN5@memory_ass:

; 2364 :         }
; 2365 : 
; 2366 :         if (init_slice(&dest, key, 0) < 0)

  00369	45 33 c0	 xor	 r8d, r8d
  0036c	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00374	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dest$22053[rsp]
  0037c	e8 00 00 00 00	 call	 init_slice
  00381	85 c0		 test	 eax, eax
  00383	7d 02		 jge	 SHORT $LN4@memory_ass

; 2367 :             goto end_block;

  00385	eb 35		 jmp	 SHORT $end_block$22059
$LN4@memory_ass:

; 2368 :         dest.len = dest.shape[0] * dest.itemsize;

  00387	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dest$22053[rsp+48]
  0038f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00392	48 0f af 84 24
	b8 00 00 00	 imul	 rax, QWORD PTR dest$22053[rsp+24]
  0039b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR dest$22053[rsp+16], rax

; 2369 : 
; 2370 :         ret = copy_single(&dest, &src);

  003a3	48 8d 54 24 40	 lea	 rdx, QWORD PTR src$[rsp]
  003a8	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dest$22053[rsp]
  003b0	e8 00 00 00 00	 call	 copy_single
  003b5	89 84 24 f0 00
	00 00		 mov	 DWORD PTR ret$22055[rsp], eax
$end_block$22059:

; 2371 : 
; 2372 :     end_block:
; 2373 :         PyBuffer_Release(&src);

  003bc	48 8d 4c 24 40	 lea	 rcx, QWORD PTR src$[rsp]
  003c1	e8 00 00 00 00	 call	 PyBuffer_Release

; 2374 :         return ret;

  003c6	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ret$22055[rsp]
  003cd	eb 5a		 jmp	 SHORT $LN21@memory_ass
  003cf	eb 40		 jmp	 SHORT $LN3@memory_ass
$LN7@memory_ass:

; 2375 :     }
; 2376 :     else if (PySlice_Check(key) || is_multislice(key)) {

  003d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  003d8	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  003e0	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  003e4	74 11		 je	 SHORT $LN1@memory_ass
  003e6	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  003ee	e8 00 00 00 00	 call	 is_multislice
  003f3	85 c0		 test	 eax, eax
  003f5	74 1a		 je	 SHORT $LN2@memory_ass
$LN1@memory_ass:

; 2377 :         /* Call memory_subscript() to produce a sliced lvalue, then copy
; 2378 :            rvalue into lvalue. This is already implemented in _testbuffer.c. */
; 2379 :         PyErr_SetString(PyExc_NotImplementedError,
; 2380 :             "memoryview slice assignments are currently restricted "
; 2381 :             "to ndim = 1");

  003f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@FKBBMJOI@memoryview?5slice?5assignments?5are@
  003fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00405	e8 00 00 00 00	 call	 PyErr_SetString

; 2382 :         return -1;

  0040a	b8 ff ff ff ff	 mov	 eax, -1
  0040f	eb 18		 jmp	 SHORT $LN21@memory_ass
$LN2@memory_ass:
$LN3@memory_ass:

; 2383 :     }
; 2384 : 
; 2385 :     PyErr_SetString(PyExc_TypeError, "memoryview: invalid slice key");

  00411	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@JBOMHNNO@memoryview?3?5invalid?5slice?5key?$AA@
  00418	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0041f	e8 00 00 00 00	 call	 PyErr_SetString

; 2386 :     return -1;

  00424	b8 ff ff ff ff	 mov	 eax, -1
$LN21@memory_ass:

; 2387 : }

  00429	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  00430	5f		 pop	 rdi
  00431	5e		 pop	 rsi
  00432	c3		 ret	 0
memory_ass_sub ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CA@JKLFFENP@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_single DD imagerel copy_single
	DD	imagerel copy_single+295
	DD	imagerel $unwind$copy_single
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_single DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_1CA@JKLFFENP@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@JKLFFENP@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'd'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'd', 00H, 'i', 00H, 'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '1', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT copy_single
_TEXT	SEGMENT
mem$ = 80
dest$ = 112
src$ = 120
copy_single PROC					; COMDAT

; 383  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 384  :     char *mem = NULL;

  0000e	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR mem$[rsp], 0

; 385  : 
; 386  :     assert(dest->ndim == 1);

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  0001c	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  00020	74 1c		 je	 SHORT $LN7@copy_singl
  00022	41 b8 82 01 00
	00		 mov	 r8d, 386		; 00000182H
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@JKLFFENP@?$AAd?$AAe?$AAs?$AAt?$AA?9?$AA?$DO?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003c	33 c0		 xor	 eax, eax
$LN7@copy_singl:

; 387  : 
; 388  :     if (!equiv_structure(dest, src))

  0003e	48 8b 54 24 78	 mov	 rdx, QWORD PTR src$[rsp]
  00043	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dest$[rsp]
  00048	e8 00 00 00 00	 call	 equiv_structure
  0004d	85 c0		 test	 eax, eax
  0004f	75 0a		 jne	 SHORT $LN4@copy_singl

; 389  :         return -1;

  00051	b8 ff ff ff ff	 mov	 eax, -1
  00056	e9 c7 00 00 00	 jmp	 $LN5@copy_singl
$LN4@copy_singl:

; 390  : 
; 391  :     if (!last_dim_is_contiguous(dest, src)) {

  0005b	48 8b 54 24 78	 mov	 rdx, QWORD PTR src$[rsp]
  00060	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dest$[rsp]
  00065	e8 00 00 00 00	 call	 last_dim_is_contiguous
  0006a	85 c0		 test	 eax, eax
  0006c	75 37		 jne	 SHORT $LN3@copy_singl

; 392  :         mem = PyMem_Malloc(dest->shape[0] * dest->itemsize);

  0006e	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  00073	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00077	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dest$[rsp]
  0007c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007f	48 0f af 41 18	 imul	 rax, QWORD PTR [rcx+24]
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 PyMem_Malloc
  0008c	48 89 44 24 50	 mov	 QWORD PTR mem$[rsp], rax

; 393  :         if (mem == NULL) {

  00091	48 83 7c 24 50
	00		 cmp	 QWORD PTR mem$[rsp], 0
  00097	75 0c		 jne	 SHORT $LN2@copy_singl

; 394  :             PyErr_NoMemory();

  00099	e8 00 00 00 00	 call	 PyErr_NoMemory

; 395  :             return -1;

  0009e	b8 ff ff ff ff	 mov	 eax, -1
  000a3	eb 7d		 jmp	 SHORT $LN5@copy_singl
$LN2@copy_singl:
$LN3@copy_singl:

; 396  :         }
; 397  :     }
; 398  : 
; 399  :     copy_base(dest->shape, dest->itemsize,
; 400  :               dest->buf, dest->strides, dest->suboffsets,
; 401  :               src->buf, src->strides, src->suboffsets,
; 402  :               mem);

  000a5	48 8b 44 24 50	 mov	 rax, QWORD PTR mem$[rsp]
  000aa	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000af	48 8b 44 24 78	 mov	 rax, QWORD PTR src$[rsp]
  000b4	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000b8	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000bd	48 8b 44 24 78	 mov	 rax, QWORD PTR src$[rsp]
  000c2	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000c6	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000cb	48 8b 44 24 78	 mov	 rax, QWORD PTR src$[rsp]
  000d0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d8	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  000dd	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e6	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  000eb	4c 8b 48 38	 mov	 r9, QWORD PTR [rax+56]
  000ef	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  000f4	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  000f7	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  000fc	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00100	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
  00105	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00109	e8 00 00 00 00	 call	 copy_base

; 403  : 
; 404  :     if (mem)

  0010e	48 83 7c 24 50
	00		 cmp	 QWORD PTR mem$[rsp], 0
  00114	74 0a		 je	 SHORT $LN1@copy_singl

; 405  :         PyMem_Free(mem);

  00116	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mem$[rsp]
  0011b	e8 00 00 00 00	 call	 PyMem_Free
$LN1@copy_singl:

; 406  : 
; 407  :     return 0;

  00120	33 c0		 xor	 eax, eax
$LN5@copy_singl:

; 408  : }

  00122	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00126	c3		 ret	 0
copy_single ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CI@POOCBCOH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	__real@bff0000000000000
EXTRN	PyLong_AsVoidPtr:PROC
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyFloat_AsDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pack_single DD imagerel pack_single
	DD	imagerel pack_single+1779
	DD	imagerel $unwind$pack_single
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pack_single DD 021601H
	DD	01b0116H
xdata	ENDS
;	COMDAT ??_C@_1CI@POOCBCOH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@POOCBCOH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'm', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT pack_single
_TEXT	SEGMENT
p$ = 32
lld$ = 40
lu$ = 48
llu$ = 56
ld$ = 64
zu$ = 72
d$ = 80
zd$ = 88
x$21510 = 96
x$21519 = 100
x$21526 = 104
x$21545 = 108
x$21553 = 112
x$21560 = 116
x$21568 = 120
x$21577 = 128
x$21585 = 136
x$21594 = 144
x$21603 = 152
x$21610 = 160
x$21618 = 168
x$21638 = 176
tv65 = 184
tv72 = 188
tv134 = 192
ptr$ = 224
item$ = 232
fmt$ = 240
pack_single PROC					; COMDAT

; 1717 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1718 :     unsigned PY_LONG_LONG llu;
; 1719 :     unsigned long lu;
; 1720 :     size_t zu;
; 1721 :     PY_LONG_LONG lld;
; 1722 :     long ld;
; 1723 :     Py_ssize_t zd;
; 1724 :     double d;
; 1725 :     void *p;
; 1726 : 
; 1727 :     switch (fmt[0]) {

  00016	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0001e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00021	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00028	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv65[rsp]
  0002f	83 e8 3f	 sub	 eax, 63			; 0000003fH
  00032	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00039	83 bc 24 b8 00
	00 00 32	 cmp	 DWORD PTR tv65[rsp], 50	; 00000032H
  00041	0f 87 ff 05 00
	00		 ja	 $LN1@pack_singl
  00047	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR tv65[rsp]
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00056	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN94@pack_singl[rcx+rax]
  0005e	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN95@pack_singl[rcx+rax*4]
  00065	48 03 c1	 add	 rax, rcx
  00068	ff e0		 jmp	 rax
$LN87@pack_singl:

; 1728 :     /* signed integers */
; 1729 :     case 'b': case 'h': case 'i': case 'l':
; 1730 :         ld = pylong_as_ld(item);

  0006a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00072	e8 00 00 00 00	 call	 pylong_as_ld
  00077	89 44 24 40	 mov	 DWORD PTR ld$[rsp], eax

; 1731 :         if (ld == -1 && PyErr_Occurred())

  0007b	83 7c 24 40 ff	 cmp	 DWORD PTR ld$[rsp], -1
  00080	75 0f		 jne	 SHORT $LN86@pack_singl
  00082	e8 00 00 00 00	 call	 PyErr_Occurred
  00087	48 85 c0	 test	 rax, rax
  0008a	74 05		 je	 SHORT $LN86@pack_singl

; 1732 :             goto err_occurred;

  0008c	e9 bb 05 00 00	 jmp	 $err_occurred$21493
$LN86@pack_singl:

; 1733 :         switch (fmt[0]) {

  00091	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00099	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009c	88 84 24 bc 00
	00 00		 mov	 BYTE PTR tv72[rsp], al
  000a3	80 bc 24 bc 00
	00 00 62	 cmp	 BYTE PTR tv72[rsp], 98	; 00000062H
  000ab	74 19		 je	 SHORT $LN83@pack_singl
  000ad	80 bc 24 bc 00
	00 00 68	 cmp	 BYTE PTR tv72[rsp], 104	; 00000068H
  000b5	74 36		 je	 SHORT $LN80@pack_singl
  000b7	80 bc 24 bc 00
	00 00 69	 cmp	 BYTE PTR tv72[rsp], 105	; 00000069H
  000bf	74 6f		 je	 SHORT $LN74@pack_singl
  000c1	e9 ab 00 00 00	 jmp	 $LN68@pack_singl
$LN83@pack_singl:

; 1734 :         case 'b':
; 1735 :             if (ld < SCHAR_MIN || ld > SCHAR_MAX) goto err_range;

  000c6	83 7c 24 40 80	 cmp	 DWORD PTR ld$[rsp], -128 ; ffffffffffffff80H
  000cb	7c 07		 jl	 SHORT $LN81@pack_singl
  000cd	83 7c 24 40 7f	 cmp	 DWORD PTR ld$[rsp], 127	; 0000007fH
  000d2	7e 05		 jle	 SHORT $LN82@pack_singl
$LN81@pack_singl:
  000d4	e9 82 05 00 00	 jmp	 $err_range$21501
$LN82@pack_singl:

; 1736 :             *((signed char *)ptr) = (signed char)ld; break;

  000d9	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR ptr$[rsp]
  000e1	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ld$[rsp]
  000e6	88 08		 mov	 BYTE PTR [rax], cl
  000e8	e9 aa 00 00 00	 jmp	 $LN84@pack_singl
$LN80@pack_singl:

; 1737 :         case 'h':
; 1738 :             if (ld < SHRT_MIN || ld > SHRT_MAX) goto err_range;

  000ed	81 7c 24 40 00
	80 ff ff	 cmp	 DWORD PTR ld$[rsp], -32768 ; ffffffffffff8000H
  000f5	7c 0a		 jl	 SHORT $LN78@pack_singl
  000f7	81 7c 24 40 ff
	7f 00 00	 cmp	 DWORD PTR ld$[rsp], 32767 ; 00007fffH
  000ff	7e 05		 jle	 SHORT $LN79@pack_singl
$LN78@pack_singl:
  00101	e9 55 05 00 00	 jmp	 $err_range$21501
$LN79@pack_singl:
$LN77@pack_singl:

; 1739 :             PACK_SINGLE(ptr, ld, short); break;

  00106	0f b7 44 24 40	 movzx	 eax, WORD PTR ld$[rsp]
  0010b	66 89 44 24 60	 mov	 WORD PTR x$21510[rsp], ax
  00110	41 b8 02 00 00
	00		 mov	 r8d, 2
  00116	48 8d 54 24 60	 lea	 rdx, QWORD PTR x$21510[rsp]
  0011b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  00123	e8 00 00 00 00	 call	 memcpy
  00128	33 c0		 xor	 eax, eax
  0012a	85 c0		 test	 eax, eax
  0012c	75 d8		 jne	 SHORT $LN77@pack_singl
  0012e	eb 67		 jmp	 SHORT $LN84@pack_singl
$LN74@pack_singl:

; 1740 :         case 'i':
; 1741 :             if (ld < INT_MIN || ld > INT_MAX) goto err_range;

  00130	81 7c 24 40 00
	00 00 80	 cmp	 DWORD PTR ld$[rsp], -2147483648 ; ffffffff80000000H
  00138	7c 0a		 jl	 SHORT $LN72@pack_singl
  0013a	81 7c 24 40 ff
	ff ff 7f	 cmp	 DWORD PTR ld$[rsp], 2147483647 ; 7fffffffH
  00142	7e 05		 jle	 SHORT $LN73@pack_singl
$LN72@pack_singl:
  00144	e9 12 05 00 00	 jmp	 $err_range$21501
$LN73@pack_singl:
$LN71@pack_singl:

; 1742 :             PACK_SINGLE(ptr, ld, int); break;

  00149	8b 44 24 40	 mov	 eax, DWORD PTR ld$[rsp]
  0014d	89 44 24 64	 mov	 DWORD PTR x$21519[rsp], eax
  00151	41 b8 04 00 00
	00		 mov	 r8d, 4
  00157	48 8d 54 24 64	 lea	 rdx, QWORD PTR x$21519[rsp]
  0015c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  00164	e8 00 00 00 00	 call	 memcpy
  00169	33 c0		 xor	 eax, eax
  0016b	85 c0		 test	 eax, eax
  0016d	75 da		 jne	 SHORT $LN71@pack_singl
  0016f	eb 26		 jmp	 SHORT $LN84@pack_singl
$LN68@pack_singl:
$LN67@pack_singl:

; 1743 :         default: /* 'l' */
; 1744 :             PACK_SINGLE(ptr, ld, long); break;

  00171	8b 44 24 40	 mov	 eax, DWORD PTR ld$[rsp]
  00175	89 44 24 68	 mov	 DWORD PTR x$21526[rsp], eax
  00179	41 b8 04 00 00
	00		 mov	 r8d, 4
  0017f	48 8d 54 24 68	 lea	 rdx, QWORD PTR x$21526[rsp]
  00184	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  0018c	e8 00 00 00 00	 call	 memcpy
  00191	33 c0		 xor	 eax, eax
  00193	85 c0		 test	 eax, eax
  00195	75 da		 jne	 SHORT $LN67@pack_singl
$LN84@pack_singl:

; 1745 :         }
; 1746 :         break;

  00197	e9 ac 04 00 00	 jmp	 $LN88@pack_singl
$LN64@pack_singl:

; 1747 : 
; 1748 :     /* unsigned integers */
; 1749 :     case 'B': case 'H': case 'I': case 'L':
; 1750 :         lu = pylong_as_lu(item);

  0019c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  001a4	e8 00 00 00 00	 call	 pylong_as_lu
  001a9	89 44 24 30	 mov	 DWORD PTR lu$[rsp], eax

; 1751 :         if (lu == (unsigned long)-1 && PyErr_Occurred())

  001ad	83 7c 24 30 ff	 cmp	 DWORD PTR lu$[rsp], -1	; ffffffffH
  001b2	75 0f		 jne	 SHORT $LN63@pack_singl
  001b4	e8 00 00 00 00	 call	 PyErr_Occurred
  001b9	48 85 c0	 test	 rax, rax
  001bc	74 05		 je	 SHORT $LN63@pack_singl

; 1752 :             goto err_occurred;

  001be	e9 89 04 00 00	 jmp	 $err_occurred$21493
$LN63@pack_singl:

; 1753 :         switch (fmt[0]) {

  001c3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  001cb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001ce	88 84 24 c0 00
	00 00		 mov	 BYTE PTR tv134[rsp], al
  001d5	80 bc 24 c0 00
	00 00 42	 cmp	 BYTE PTR tv134[rsp], 66	; 00000042H
  001dd	74 19		 je	 SHORT $LN60@pack_singl
  001df	80 bc 24 c0 00
	00 00 48	 cmp	 BYTE PTR tv134[rsp], 72	; 00000048H
  001e7	74 32		 je	 SHORT $LN58@pack_singl
  001e9	80 bc 24 c0 00
	00 00 49	 cmp	 BYTE PTR tv134[rsp], 73	; 00000049H
  001f1	74 61		 je	 SHORT $LN53@pack_singl
  001f3	e9 90 00 00 00	 jmp	 $LN48@pack_singl
$LN60@pack_singl:

; 1754 :         case 'B':
; 1755 :             if (lu > UCHAR_MAX) goto err_range;

  001f8	81 7c 24 30 ff
	00 00 00	 cmp	 DWORD PTR lu$[rsp], 255	; 000000ffH
  00200	76 05		 jbe	 SHORT $LN59@pack_singl
  00202	e9 54 04 00 00	 jmp	 $err_range$21501
$LN59@pack_singl:

; 1756 :             *((unsigned char *)ptr) = (unsigned char)lu; break;

  00207	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR ptr$[rsp]
  0020f	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR lu$[rsp]
  00214	88 08		 mov	 BYTE PTR [rax], cl
  00216	e9 93 00 00 00	 jmp	 $LN61@pack_singl
$LN58@pack_singl:

; 1757 :         case 'H':
; 1758 :             if (lu > USHRT_MAX) goto err_range;

  0021b	81 7c 24 30 ff
	ff 00 00	 cmp	 DWORD PTR lu$[rsp], 65535 ; 0000ffffH
  00223	76 05		 jbe	 SHORT $LN57@pack_singl
  00225	e9 31 04 00 00	 jmp	 $err_range$21501
$LN57@pack_singl:
$LN56@pack_singl:

; 1759 :             PACK_SINGLE(ptr, lu, unsigned short); break;

  0022a	0f b7 44 24 30	 movzx	 eax, WORD PTR lu$[rsp]
  0022f	66 89 44 24 6c	 mov	 WORD PTR x$21545[rsp], ax
  00234	41 b8 02 00 00
	00		 mov	 r8d, 2
  0023a	48 8d 54 24 6c	 lea	 rdx, QWORD PTR x$21545[rsp]
  0023f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  00247	e8 00 00 00 00	 call	 memcpy
  0024c	33 c0		 xor	 eax, eax
  0024e	85 c0		 test	 eax, eax
  00250	75 d8		 jne	 SHORT $LN56@pack_singl
  00252	eb 5a		 jmp	 SHORT $LN61@pack_singl
$LN53@pack_singl:

; 1760 :         case 'I':
; 1761 :             if (lu > UINT_MAX) goto err_range;

  00254	83 7c 24 30 ff	 cmp	 DWORD PTR lu$[rsp], -1	; ffffffffH
  00259	76 05		 jbe	 SHORT $LN52@pack_singl
  0025b	e9 fb 03 00 00	 jmp	 $err_range$21501
$LN52@pack_singl:
$LN51@pack_singl:

; 1762 :             PACK_SINGLE(ptr, lu, unsigned int); break;

  00260	8b 44 24 30	 mov	 eax, DWORD PTR lu$[rsp]
  00264	89 44 24 70	 mov	 DWORD PTR x$21553[rsp], eax
  00268	41 b8 04 00 00
	00		 mov	 r8d, 4
  0026e	48 8d 54 24 70	 lea	 rdx, QWORD PTR x$21553[rsp]
  00273	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  0027b	e8 00 00 00 00	 call	 memcpy
  00280	33 c0		 xor	 eax, eax
  00282	85 c0		 test	 eax, eax
  00284	75 da		 jne	 SHORT $LN51@pack_singl
  00286	eb 26		 jmp	 SHORT $LN61@pack_singl
$LN48@pack_singl:
$LN47@pack_singl:

; 1763 :         default: /* 'L' */
; 1764 :             PACK_SINGLE(ptr, lu, unsigned long); break;

  00288	8b 44 24 30	 mov	 eax, DWORD PTR lu$[rsp]
  0028c	89 44 24 74	 mov	 DWORD PTR x$21560[rsp], eax
  00290	41 b8 04 00 00
	00		 mov	 r8d, 4
  00296	48 8d 54 24 74	 lea	 rdx, QWORD PTR x$21560[rsp]
  0029b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  002a3	e8 00 00 00 00	 call	 memcpy
  002a8	33 c0		 xor	 eax, eax
  002aa	85 c0		 test	 eax, eax
  002ac	75 da		 jne	 SHORT $LN47@pack_singl
$LN61@pack_singl:

; 1765 :         }
; 1766 :         break;

  002ae	e9 95 03 00 00	 jmp	 $LN88@pack_singl
$LN44@pack_singl:

; 1767 : 
; 1768 :     /* native 64-bit */
; 1769 :     #ifdef HAVE_LONG_LONG
; 1770 :     case 'q':
; 1771 :         lld = pylong_as_lld(item);

  002b3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  002bb	e8 00 00 00 00	 call	 pylong_as_lld
  002c0	48 89 44 24 28	 mov	 QWORD PTR lld$[rsp], rax

; 1772 :         if (lld == -1 && PyErr_Occurred())

  002c5	48 83 7c 24 28
	ff		 cmp	 QWORD PTR lld$[rsp], -1
  002cb	75 0f		 jne	 SHORT $LN43@pack_singl
  002cd	e8 00 00 00 00	 call	 PyErr_Occurred
  002d2	48 85 c0	 test	 rax, rax
  002d5	74 05		 je	 SHORT $LN43@pack_singl

; 1773 :             goto err_occurred;

  002d7	e9 70 03 00 00	 jmp	 $err_occurred$21493
$LN43@pack_singl:
$LN42@pack_singl:

; 1774 :         PACK_SINGLE(ptr, lld, PY_LONG_LONG);

  002dc	48 8b 44 24 28	 mov	 rax, QWORD PTR lld$[rsp]
  002e1	48 89 44 24 78	 mov	 QWORD PTR x$21568[rsp], rax
  002e6	41 b8 08 00 00
	00		 mov	 r8d, 8
  002ec	48 8d 54 24 78	 lea	 rdx, QWORD PTR x$21568[rsp]
  002f1	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  002f9	e8 00 00 00 00	 call	 memcpy
  002fe	33 c0		 xor	 eax, eax
  00300	85 c0		 test	 eax, eax
  00302	75 d8		 jne	 SHORT $LN42@pack_singl

; 1775 :         break;

  00304	e9 3f 03 00 00	 jmp	 $LN88@pack_singl
$LN39@pack_singl:

; 1776 :     case 'Q':
; 1777 :         llu = pylong_as_llu(item);

  00309	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00311	e8 00 00 00 00	 call	 pylong_as_llu
  00316	48 89 44 24 38	 mov	 QWORD PTR llu$[rsp], rax

; 1778 :         if (llu == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())

  0031b	48 83 7c 24 38
	ff		 cmp	 QWORD PTR llu$[rsp], -1
  00321	75 0f		 jne	 SHORT $LN38@pack_singl
  00323	e8 00 00 00 00	 call	 PyErr_Occurred
  00328	48 85 c0	 test	 rax, rax
  0032b	74 05		 je	 SHORT $LN38@pack_singl

; 1779 :             goto err_occurred;

  0032d	e9 1a 03 00 00	 jmp	 $err_occurred$21493
$LN38@pack_singl:
$LN37@pack_singl:

; 1780 :         PACK_SINGLE(ptr, llu, unsigned PY_LONG_LONG);

  00332	48 8b 44 24 38	 mov	 rax, QWORD PTR llu$[rsp]
  00337	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR x$21577[rsp], rax
  0033f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00345	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR x$21577[rsp]
  0034d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  00355	e8 00 00 00 00	 call	 memcpy
  0035a	33 c0		 xor	 eax, eax
  0035c	85 c0		 test	 eax, eax
  0035e	75 d2		 jne	 SHORT $LN37@pack_singl

; 1781 :         break;

  00360	e9 e3 02 00 00	 jmp	 $LN88@pack_singl
$LN34@pack_singl:

; 1782 :     #endif
; 1783 : 
; 1784 :     /* ssize_t and size_t */
; 1785 :     case 'n':
; 1786 :         zd = pylong_as_zd(item);

  00365	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  0036d	e8 00 00 00 00	 call	 pylong_as_zd
  00372	48 89 44 24 58	 mov	 QWORD PTR zd$[rsp], rax

; 1787 :         if (zd == -1 && PyErr_Occurred())

  00377	48 83 7c 24 58
	ff		 cmp	 QWORD PTR zd$[rsp], -1
  0037d	75 0f		 jne	 SHORT $LN33@pack_singl
  0037f	e8 00 00 00 00	 call	 PyErr_Occurred
  00384	48 85 c0	 test	 rax, rax
  00387	74 05		 je	 SHORT $LN33@pack_singl

; 1788 :             goto err_occurred;

  00389	e9 be 02 00 00	 jmp	 $err_occurred$21493
$LN33@pack_singl:
$LN32@pack_singl:

; 1789 :         PACK_SINGLE(ptr, zd, Py_ssize_t);

  0038e	48 8b 44 24 58	 mov	 rax, QWORD PTR zd$[rsp]
  00393	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR x$21585[rsp], rax
  0039b	41 b8 08 00 00
	00		 mov	 r8d, 8
  003a1	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x$21585[rsp]
  003a9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  003b1	e8 00 00 00 00	 call	 memcpy
  003b6	33 c0		 xor	 eax, eax
  003b8	85 c0		 test	 eax, eax
  003ba	75 d2		 jne	 SHORT $LN32@pack_singl

; 1790 :         break;

  003bc	e9 87 02 00 00	 jmp	 $LN88@pack_singl
$LN29@pack_singl:

; 1791 :     case 'N':
; 1792 :         zu = pylong_as_zu(item);

  003c1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  003c9	e8 00 00 00 00	 call	 pylong_as_zu
  003ce	48 89 44 24 48	 mov	 QWORD PTR zu$[rsp], rax

; 1793 :         if (zu == (size_t)-1 && PyErr_Occurred())

  003d3	48 83 7c 24 48
	ff		 cmp	 QWORD PTR zu$[rsp], -1
  003d9	75 0f		 jne	 SHORT $LN28@pack_singl
  003db	e8 00 00 00 00	 call	 PyErr_Occurred
  003e0	48 85 c0	 test	 rax, rax
  003e3	74 05		 je	 SHORT $LN28@pack_singl

; 1794 :             goto err_occurred;

  003e5	e9 62 02 00 00	 jmp	 $err_occurred$21493
$LN28@pack_singl:
$LN27@pack_singl:

; 1795 :         PACK_SINGLE(ptr, zu, size_t);

  003ea	48 8b 44 24 48	 mov	 rax, QWORD PTR zu$[rsp]
  003ef	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR x$21594[rsp], rax
  003f7	41 b8 08 00 00
	00		 mov	 r8d, 8
  003fd	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR x$21594[rsp]
  00405	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  0040d	e8 00 00 00 00	 call	 memcpy
  00412	33 c0		 xor	 eax, eax
  00414	85 c0		 test	 eax, eax
  00416	75 d2		 jne	 SHORT $LN27@pack_singl

; 1796 :         break;

  00418	e9 2b 02 00 00	 jmp	 $LN88@pack_singl
$LN24@pack_singl:

; 1797 : 
; 1798 :     /* floats */
; 1799 :     case 'f': case 'd':
; 1800 :         d = PyFloat_AsDouble(item);

  0041d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00425	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0042a	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR d$[rsp], xmm0

; 1801 :         if (d == -1.0 && PyErr_Occurred())

  00430	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR d$[rsp]
  00436	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0043e	7a 11		 jp	 SHORT $LN23@pack_singl
  00440	75 0f		 jne	 SHORT $LN23@pack_singl
  00442	e8 00 00 00 00	 call	 PyErr_Occurred
  00447	48 85 c0	 test	 rax, rax
  0044a	74 05		 je	 SHORT $LN23@pack_singl

; 1802 :             goto err_occurred;

  0044c	e9 fb 01 00 00	 jmp	 $err_occurred$21493
$LN23@pack_singl:

; 1803 :         if (fmt[0] == 'f') {

  00451	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00459	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0045c	83 f8 66	 cmp	 eax, 102		; 00000066H
  0045f	75 32		 jne	 SHORT $LN22@pack_singl
$LN21@pack_singl:

; 1804 :             PACK_SINGLE(ptr, d, float);

  00461	f2 0f 5a 44 24
	50		 cvtsd2ss xmm0, QWORD PTR d$[rsp]
  00467	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR x$21603[rsp], xmm0
  00470	41 b8 04 00 00
	00		 mov	 r8d, 4
  00476	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x$21603[rsp]
  0047e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  00486	e8 00 00 00 00	 call	 memcpy
  0048b	33 c0		 xor	 eax, eax
  0048d	85 c0		 test	 eax, eax
  0048f	75 d0		 jne	 SHORT $LN21@pack_singl

; 1805 :         }
; 1806 :         else {

  00491	eb 30		 jmp	 SHORT $LN18@pack_singl
$LN22@pack_singl:
$LN17@pack_singl:

; 1807 :             PACK_SINGLE(ptr, d, double);

  00493	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR d$[rsp]
  00499	f2 0f 11 84 24
	a0 00 00 00	 movsdx	 QWORD PTR x$21610[rsp], xmm0
  004a2	41 b8 08 00 00
	00		 mov	 r8d, 8
  004a8	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR x$21610[rsp]
  004b0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  004b8	e8 00 00 00 00	 call	 memcpy
  004bd	33 c0		 xor	 eax, eax
  004bf	85 c0		 test	 eax, eax
  004c1	75 d0		 jne	 SHORT $LN17@pack_singl
$LN18@pack_singl:

; 1808 :         }
; 1809 :         break;

  004c3	e9 80 01 00 00	 jmp	 $LN88@pack_singl
$LN14@pack_singl:

; 1810 : 
; 1811 :     /* bool */
; 1812 :     case '?':
; 1813 :         ld = PyObject_IsTrue(item);

  004c8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  004d0	e8 00 00 00 00	 call	 PyObject_IsTrue
  004d5	89 44 24 40	 mov	 DWORD PTR ld$[rsp], eax

; 1814 :         if (ld < 0)

  004d9	83 7c 24 40 00	 cmp	 DWORD PTR ld$[rsp], 0
  004de	7d 0a		 jge	 SHORT $LN13@pack_singl

; 1815 :             return -1; /* preserve original error */

  004e0	b8 ff ff ff ff	 mov	 eax, -1
  004e5	e9 a0 01 00 00	 jmp	 $LN90@pack_singl
$LN13@pack_singl:
$LN12@pack_singl:

; 1816 :     #ifdef HAVE_C99_BOOL
; 1817 :         PACK_SINGLE(ptr, ld, _Bool);
; 1818 :     #else
; 1819 :         PACK_SINGLE(ptr, ld, char);

  004ea	0f b6 44 24 40	 movzx	 eax, BYTE PTR ld$[rsp]
  004ef	88 84 24 a8 00
	00 00		 mov	 BYTE PTR x$21618[rsp], al
  004f6	41 b8 01 00 00
	00		 mov	 r8d, 1
  004fc	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR x$21618[rsp]
  00504	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  0050c	e8 00 00 00 00	 call	 memcpy
  00511	33 c0		 xor	 eax, eax
  00513	85 c0		 test	 eax, eax
  00515	75 d3		 jne	 SHORT $LN12@pack_singl

; 1820 :     #endif
; 1821 :          break;

  00517	e9 2c 01 00 00	 jmp	 $LN88@pack_singl
$LN9@pack_singl:

; 1822 : 
; 1823 :     /* bytes object */
; 1824 :     case 'c':
; 1825 :         if (!PyBytes_Check(item))

  0051c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00524	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00528	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0052e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00533	85 c0		 test	 eax, eax
  00535	75 12		 jne	 SHORT $LN8@pack_singl

; 1826 :             return type_error_int(fmt);

  00537	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  0053f	e8 00 00 00 00	 call	 type_error_int
  00544	e9 41 01 00 00	 jmp	 $LN90@pack_singl
$LN8@pack_singl:

; 1827 :         if (PyBytes_GET_SIZE(item) != 1)

  00549	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00551	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00555	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0055b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00560	85 c0		 test	 eax, eax
  00562	75 1c		 jne	 SHORT $LN92@pack_singl
  00564	41 b8 23 07 00
	00		 mov	 r8d, 1827		; 00000723H
  0056a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00571	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@POOCBCOH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@
  00578	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0057e	33 c0		 xor	 eax, eax
$LN92@pack_singl:
  00580	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00588	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  0058d	74 12		 je	 SHORT $LN7@pack_singl

; 1828 :             return value_error_int(fmt);

  0058f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00597	e8 00 00 00 00	 call	 value_error_int
  0059c	e9 e9 00 00 00	 jmp	 $LN90@pack_singl
$LN7@pack_singl:

; 1829 :         *ptr = PyBytes_AS_STRING(item)[0];

  005a1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  005a9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005ad	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005b3	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  005b8	85 c0		 test	 eax, eax
  005ba	75 1c		 jne	 SHORT $LN93@pack_singl
  005bc	41 b8 25 07 00
	00		 mov	 r8d, 1829		; 00000725H
  005c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  005c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@POOCBCOH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AA?$CJ?$AA?$AA@
  005d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005d6	33 c0		 xor	 eax, eax
$LN93@pack_singl:
  005d8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR ptr$[rsp]
  005e0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  005e8	0f b6 49 78	 movzx	 ecx, BYTE PTR [rcx+120]
  005ec	88 08		 mov	 BYTE PTR [rax], cl

; 1830 :         break;

  005ee	eb 58		 jmp	 SHORT $LN88@pack_singl
$LN6@pack_singl:

; 1831 : 
; 1832 :     /* pointer */
; 1833 :     case 'P':
; 1834 :         p = PyLong_AsVoidPtr(item);

  005f0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  005f8	e8 00 00 00 00	 call	 PyLong_AsVoidPtr
  005fd	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1835 :         if (p == NULL && PyErr_Occurred())

  00602	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  00608	75 0c		 jne	 SHORT $LN5@pack_singl
  0060a	e8 00 00 00 00	 call	 PyErr_Occurred
  0060f	48 85 c0	 test	 rax, rax
  00612	74 02		 je	 SHORT $LN5@pack_singl

; 1836 :             goto err_occurred;

  00614	eb 36		 jmp	 SHORT $err_occurred$21493
$LN5@pack_singl:
$LN4@pack_singl:

; 1837 :         PACK_SINGLE(ptr, p, void *);

  00616	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0061b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR x$21638[rsp], rax
  00623	41 b8 08 00 00
	00		 mov	 r8d, 8
  00629	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR x$21638[rsp]
  00631	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  00639	e8 00 00 00 00	 call	 memcpy
  0063e	33 c0		 xor	 eax, eax
  00640	85 c0		 test	 eax, eax
  00642	75 d2		 jne	 SHORT $LN4@pack_singl

; 1838 :         break;

  00644	eb 02		 jmp	 SHORT $LN88@pack_singl
$LN1@pack_singl:

; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;

  00646	eb 22		 jmp	 SHORT $err_format$21642
$LN88@pack_singl:

; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  00648	33 c0		 xor	 eax, eax
  0064a	eb 3e		 jmp	 SHORT $LN90@pack_singl
$err_occurred$21493:

; 1845 : 
; 1846 : err_occurred:
; 1847 :     return fix_error_int(fmt);

  0064c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00654	e8 00 00 00 00	 call	 fix_error_int
  00659	eb 2f		 jmp	 SHORT $LN90@pack_singl
$err_range$21501:

; 1848 : err_range:
; 1849 :     return value_error_int(fmt);

  0065b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00663	e8 00 00 00 00	 call	 value_error_int
  00668	eb 20		 jmp	 SHORT $LN90@pack_singl
$err_format$21642:

; 1850 : err_format:
; 1851 :     PyErr_Format(PyExc_NotImplementedError,
; 1852 :         "memoryview: format %s not supported", fmt);

  0066a	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  00672	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NAELFKBL@memoryview?3?5format?5?$CFs?5not?5suppor@
  00679	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00680	e8 00 00 00 00	 call	 PyErr_Format

; 1853 :     return -1;

  00685	b8 ff ff ff ff	 mov	 eax, -1
$LN90@pack_singl:

; 1854 : }

  0068a	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00691	c3		 ret	 0
  00692	66 90		 npad	 2
$LN95@pack_singl:
  00694	00 00 00 00	 DD	 $LN14@pack_singl
  00698	00 00 00 00	 DD	 $LN64@pack_singl
  0069c	00 00 00 00	 DD	 $LN29@pack_singl
  006a0	00 00 00 00	 DD	 $LN6@pack_singl
  006a4	00 00 00 00	 DD	 $LN39@pack_singl
  006a8	00 00 00 00	 DD	 $LN87@pack_singl
  006ac	00 00 00 00	 DD	 $LN9@pack_singl
  006b0	00 00 00 00	 DD	 $LN24@pack_singl
  006b4	00 00 00 00	 DD	 $LN34@pack_singl
  006b8	00 00 00 00	 DD	 $LN44@pack_singl
  006bc	00 00 00 00	 DD	 $LN1@pack_singl
$LN94@pack_singl:
  006c0	00		 DB	 0
  006c1	0a		 DB	 10
  006c2	0a		 DB	 10
  006c3	01		 DB	 1
  006c4	0a		 DB	 10
  006c5	0a		 DB	 10
  006c6	0a		 DB	 10
  006c7	0a		 DB	 10
  006c8	0a		 DB	 10
  006c9	01		 DB	 1
  006ca	01		 DB	 1
  006cb	0a		 DB	 10
  006cc	0a		 DB	 10
  006cd	01		 DB	 1
  006ce	0a		 DB	 10
  006cf	02		 DB	 2
  006d0	0a		 DB	 10
  006d1	03		 DB	 3
  006d2	04		 DB	 4
  006d3	0a		 DB	 10
  006d4	0a		 DB	 10
  006d5	0a		 DB	 10
  006d6	0a		 DB	 10
  006d7	0a		 DB	 10
  006d8	0a		 DB	 10
  006d9	0a		 DB	 10
  006da	0a		 DB	 10
  006db	0a		 DB	 10
  006dc	0a		 DB	 10
  006dd	0a		 DB	 10
  006de	0a		 DB	 10
  006df	0a		 DB	 10
  006e0	0a		 DB	 10
  006e1	0a		 DB	 10
  006e2	0a		 DB	 10
  006e3	05		 DB	 5
  006e4	06		 DB	 6
  006e5	07		 DB	 7
  006e6	0a		 DB	 10
  006e7	07		 DB	 7
  006e8	0a		 DB	 10
  006e9	05		 DB	 5
  006ea	05		 DB	 5
  006eb	0a		 DB	 10
  006ec	0a		 DB	 10
  006ed	05		 DB	 5
  006ee	0a		 DB	 10
  006ef	08		 DB	 8
  006f0	0a		 DB	 10
  006f1	0a		 DB	 10
  006f2	09		 DB	 9
pack_single ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@ODBNDFBK@memoryview?3?5invalid?5type?5for?5for@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_error_int DD imagerel type_error_int
	DD	imagerel type_error_int+43
	DD	imagerel $unwind$type_error_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_error_int DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0CJ@ODBNDFBK@memoryview?3?5invalid?5type?5for?5for@
CONST	SEGMENT
??_C@_0CJ@ODBNDFBK@memoryview?3?5invalid?5type?5for?5for@ DB 'memoryview:'
	DB	' invalid type for format ''%s''', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT type_error_int
_TEXT	SEGMENT
fmt$ = 48
type_error_int PROC					; COMDAT

; 1482 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1483 :     PyErr_Format(PyExc_TypeError,
; 1484 :         "memoryview: invalid type for format '%s'", fmt);

  00009	4c 8b 44 24 30	 mov	 r8, QWORD PTR fmt$[rsp]
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@ODBNDFBK@memoryview?3?5invalid?5type?5for?5for@
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0001c	e8 00 00 00 00	 call	 PyErr_Format

; 1485 :     return -1;

  00021	b8 ff ff ff ff	 mov	 eax, -1

; 1486 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
type_error_int ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@JECCJFFJ@memoryview?3?5invalid?5value?5for?5fo@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$value_error_int DD imagerel value_error_int
	DD	imagerel value_error_int+43
	DD	imagerel $unwind$value_error_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$value_error_int DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0CK@JECCJFFJ@memoryview?3?5invalid?5value?5for?5fo@
CONST	SEGMENT
??_C@_0CK@JECCJFFJ@memoryview?3?5invalid?5value?5for?5fo@ DB 'memoryview:'
	DB	' invalid value for format ''%s''', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT value_error_int
_TEXT	SEGMENT
fmt$ = 48
value_error_int PROC					; COMDAT

; 1490 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1491 :     PyErr_Format(PyExc_ValueError,
; 1492 :         "memoryview: invalid value for format '%s'", fmt);

  00009	4c 8b 44 24 30	 mov	 r8, QWORD PTR fmt$[rsp]
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@JECCJFFJ@memoryview?3?5invalid?5value?5for?5fo@
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001c	e8 00 00 00 00	 call	 PyErr_Format

; 1493 :     return -1;

  00021	b8 ff ff ff ff	 mov	 eax, -1

; 1494 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
value_error_int ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@DNBCFJEA@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fix_error_int DD imagerel fix_error_int
	DD	imagerel fix_error_int+141
	DD	imagerel $unwind$fix_error_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fix_error_int DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1CC@DNBCFJEA@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DNBCFJEA@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'E', 00H, 'r', 00H, 'r', 00H, '_', 00H, 'O', 00H
	DB	'c', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'd'
	DB	00H, '(', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fix_error_int
_TEXT	SEGMENT
fmt$ = 48
fix_error_int PROC					; COMDAT

; 1498 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1499 :     assert(PyErr_Occurred());

  00009	e8 00 00 00 00	 call	 PyErr_Occurred
  0000e	48 85 c0	 test	 rax, rax
  00011	75 1c		 jne	 SHORT $LN7@fix_error_
  00013	41 b8 db 05 00
	00		 mov	 r8d, 1499		; 000005dbH
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@DNBCFJEA@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002d	33 c0		 xor	 eax, eax
$LN7@fix_error_:

; 1500 :     if (PyErr_ExceptionMatches(PyExc_TypeError)) {

  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00036	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0003b	85 c0		 test	 eax, eax
  0003d	74 13		 je	 SHORT $LN4@fix_error_

; 1501 :         PyErr_Clear();

  0003f	e8 00 00 00 00	 call	 PyErr_Clear

; 1502 :         return type_error_int(fmt);

  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fmt$[rsp]
  00049	e8 00 00 00 00	 call	 type_error_int
  0004e	eb 38		 jmp	 SHORT $LN5@fix_error_

; 1503 :     }
; 1504 :     else if (PyErr_ExceptionMatches(PyExc_OverflowError) ||

  00050	eb 31		 jmp	 SHORT $LN3@fix_error_
$LN4@fix_error_:

; 1505 :              PyErr_ExceptionMatches(PyExc_ValueError)) {

  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00059	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0005e	85 c0		 test	 eax, eax
  00060	75 10		 jne	 SHORT $LN1@fix_error_
  00062	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00069	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0006e	85 c0		 test	 eax, eax
  00070	74 11		 je	 SHORT $LN2@fix_error_
$LN1@fix_error_:

; 1506 :         PyErr_Clear();

  00072	e8 00 00 00 00	 call	 PyErr_Clear

; 1507 :         return value_error_int(fmt);

  00077	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fmt$[rsp]
  0007c	e8 00 00 00 00	 call	 value_error_int
  00081	eb 05		 jmp	 SHORT $LN5@fix_error_
$LN2@fix_error_:
$LN3@fix_error_:

; 1508 :     }
; 1509 : 
; 1510 :     return -1;

  00083	b8 ff ff ff ff	 mov	 eax, -1
$LN5@fix_error_:

; 1511 : }

  00088	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008c	c3		 ret	 0
fix_error_int ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLong:PROC
EXTRN	PyNumber_Index:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_ld DD imagerel pylong_as_ld
	DD	imagerel pylong_as_ld+72
	DD	imagerel $unwind$pylong_as_ld
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_ld DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pylong_as_ld
_TEXT	SEGMENT
tmp$ = 32
ld$ = 40
item$ = 64
pylong_as_ld PROC					; COMDAT

; 1516 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1517 :     PyObject *tmp;
; 1518 :     long ld;
; 1519 : 
; 1520 :     tmp = PyNumber_Index(item);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  0000e	e8 00 00 00 00	 call	 PyNumber_Index
  00013	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 1521 :     if (tmp == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0001e	75 07		 jne	 SHORT $LN1@pylong_as_

; 1522 :         return -1;

  00020	b8 ff ff ff ff	 mov	 eax, -1
  00025	eb 1c		 jmp	 SHORT $LN2@pylong_as_
$LN1@pylong_as_:

; 1523 : 
; 1524 :     ld = PyLong_AsLong(tmp);

  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0002c	e8 00 00 00 00	 call	 PyLong_AsLong
  00031	89 44 24 28	 mov	 DWORD PTR ld$[rsp], eax

; 1525 :     Py_DECREF(tmp);

  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0003a	e8 00 00 00 00	 call	 _Py_DecRef

; 1526 :     return ld;

  0003f	8b 44 24 28	 mov	 eax, DWORD PTR ld$[rsp]
$LN2@pylong_as_:

; 1527 : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
pylong_as_ld ENDP
_TEXT	ENDS
EXTRN	PyLong_AsUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_lu DD imagerel pylong_as_lu
	DD	imagerel pylong_as_lu+72
	DD	imagerel $unwind$pylong_as_lu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_lu DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pylong_as_lu
_TEXT	SEGMENT
tmp$ = 32
lu$ = 40
item$ = 64
pylong_as_lu PROC					; COMDAT

; 1531 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1532 :     PyObject *tmp;
; 1533 :     unsigned long lu;
; 1534 : 
; 1535 :     tmp = PyNumber_Index(item);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  0000e	e8 00 00 00 00	 call	 PyNumber_Index
  00013	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 1536 :     if (tmp == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0001e	75 07		 jne	 SHORT $LN1@pylong_as_@2

; 1537 :         return (unsigned long)-1;

  00020	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00025	eb 1c		 jmp	 SHORT $LN2@pylong_as_@2
$LN1@pylong_as_@2:

; 1538 : 
; 1539 :     lu = PyLong_AsUnsignedLong(tmp);

  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0002c	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  00031	89 44 24 28	 mov	 DWORD PTR lu$[rsp], eax

; 1540 :     Py_DECREF(tmp);

  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0003a	e8 00 00 00 00	 call	 _Py_DecRef

; 1541 :     return lu;

  0003f	8b 44 24 28	 mov	 eax, DWORD PTR lu$[rsp]
$LN2@pylong_as_@2:

; 1542 : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
pylong_as_lu ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_lld DD imagerel pylong_as_lld
	DD	imagerel pylong_as_lld+76
	DD	imagerel $unwind$pylong_as_lld
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_lld DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pylong_as_lld
_TEXT	SEGMENT
tmp$ = 32
lld$ = 40
item$ = 64
pylong_as_lld PROC					; COMDAT

; 1547 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1548 :     PyObject *tmp;
; 1549 :     PY_LONG_LONG lld;
; 1550 : 
; 1551 :     tmp = PyNumber_Index(item);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  0000e	e8 00 00 00 00	 call	 PyNumber_Index
  00013	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 1552 :     if (tmp == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0001e	75 09		 jne	 SHORT $LN1@pylong_as_@3

; 1553 :         return -1;

  00020	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00027	eb 1e		 jmp	 SHORT $LN2@pylong_as_@3
$LN1@pylong_as_@3:

; 1554 : 
; 1555 :     lld = PyLong_AsLongLong(tmp);

  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0002e	e8 00 00 00 00	 call	 PyLong_AsLongLong
  00033	48 89 44 24 28	 mov	 QWORD PTR lld$[rsp], rax

; 1556 :     Py_DECREF(tmp);

  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0003d	e8 00 00 00 00	 call	 _Py_DecRef

; 1557 :     return lld;

  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR lld$[rsp]
$LN2@pylong_as_@3:

; 1558 : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
pylong_as_lld ENDP
_TEXT	ENDS
EXTRN	PyLong_AsUnsignedLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_llu DD imagerel pylong_as_llu
	DD	imagerel pylong_as_llu+76
	DD	imagerel $unwind$pylong_as_llu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_llu DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pylong_as_llu
_TEXT	SEGMENT
tmp$ = 32
llu$ = 40
item$ = 64
pylong_as_llu PROC					; COMDAT

; 1562 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1563 :     PyObject *tmp;
; 1564 :     unsigned PY_LONG_LONG llu;
; 1565 : 
; 1566 :     tmp = PyNumber_Index(item);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  0000e	e8 00 00 00 00	 call	 PyNumber_Index
  00013	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 1567 :     if (tmp == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0001e	75 09		 jne	 SHORT $LN1@pylong_as_@4

; 1568 :         return (unsigned PY_LONG_LONG)-1;

  00020	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00027	eb 1e		 jmp	 SHORT $LN2@pylong_as_@4
$LN1@pylong_as_@4:

; 1569 : 
; 1570 :     llu = PyLong_AsUnsignedLongLong(tmp);

  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0002e	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongLong
  00033	48 89 44 24 28	 mov	 QWORD PTR llu$[rsp], rax

; 1571 :     Py_DECREF(tmp);

  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0003d	e8 00 00 00 00	 call	 _Py_DecRef

; 1572 :     return llu;

  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR llu$[rsp]
$LN2@pylong_as_@4:

; 1573 : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
pylong_as_llu ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_zd DD imagerel pylong_as_zd
	DD	imagerel pylong_as_zd+76
	DD	imagerel $unwind$pylong_as_zd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_zd DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pylong_as_zd
_TEXT	SEGMENT
tmp$ = 32
zd$ = 40
item$ = 64
pylong_as_zd PROC					; COMDAT

; 1578 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1579 :     PyObject *tmp;
; 1580 :     Py_ssize_t zd;
; 1581 : 
; 1582 :     tmp = PyNumber_Index(item);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  0000e	e8 00 00 00 00	 call	 PyNumber_Index
  00013	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 1583 :     if (tmp == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0001e	75 09		 jne	 SHORT $LN1@pylong_as_@5

; 1584 :         return -1;

  00020	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00027	eb 1e		 jmp	 SHORT $LN2@pylong_as_@5
$LN1@pylong_as_@5:

; 1585 : 
; 1586 :     zd = PyLong_AsSsize_t(tmp);

  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0002e	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00033	48 89 44 24 28	 mov	 QWORD PTR zd$[rsp], rax

; 1587 :     Py_DECREF(tmp);

  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0003d	e8 00 00 00 00	 call	 _Py_DecRef

; 1588 :     return zd;

  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR zd$[rsp]
$LN2@pylong_as_@5:

; 1589 : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
pylong_as_zd ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_zu DD imagerel pylong_as_zu
	DD	imagerel pylong_as_zu+76
	DD	imagerel $unwind$pylong_as_zu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_zu DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pylong_as_zu
_TEXT	SEGMENT
tmp$ = 32
zu$ = 40
item$ = 64
pylong_as_zu PROC					; COMDAT

; 1593 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1594 :     PyObject *tmp;
; 1595 :     size_t zu;
; 1596 : 
; 1597 :     tmp = PyNumber_Index(item);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  0000e	e8 00 00 00 00	 call	 PyNumber_Index
  00013	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 1598 :     if (tmp == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0001e	75 09		 jne	 SHORT $LN1@pylong_as_@6

; 1599 :         return (size_t)-1;

  00020	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00027	eb 1e		 jmp	 SHORT $LN2@pylong_as_@6
$LN1@pylong_as_@6:

; 1600 : 
; 1601 :     zu = PyLong_AsSize_t(tmp);

  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0002e	e8 00 00 00 00	 call	 PyLong_AsSize_t
  00033	48 89 44 24 28	 mov	 QWORD PTR zu$[rsp], rax

; 1602 :     Py_DECREF(tmp);

  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0003d	e8 00 00 00 00	 call	 _Py_DecRef

; 1603 :     return zu;

  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR zu$[rsp]
$LN2@pylong_as_@6:

; 1604 : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
pylong_as_zu ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_length DD imagerel memory_length
	DD	imagerel memory_length+129
	DD	imagerel $unwind$memory_length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_length DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_length
_TEXT	SEGMENT
tv77 = 32
self$ = 64
memory_length PROC					; COMDAT

; 2391 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2392 :     CHECK_RELEASED_INT(self);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 13		 jne	 SHORT $LN1@memory_len
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 1c		 je	 SHORT $LN2@memory_len
$LN1@memory_len:
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	e8 00 00 00 00	 call	 PyErr_SetString
  00041	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00048	eb 32		 jmp	 SHORT $LN3@memory_len
$LN2@memory_len:

; 2393 :     return self->view.ndim == 0 ? 1 : self->view.shape[0];

  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004f	83 b8 b4 00 00
	00 00		 cmp	 DWORD PTR [rax+180], 0
  00056	75 0b		 jne	 SHORT $LN5@memory_len
  00058	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR tv77[rsp], 1
  00061	eb 14		 jmp	 SHORT $LN6@memory_len
$LN5@memory_len:
  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00068	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0006f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00072	48 89 44 24 20	 mov	 QWORD PTR tv77[rsp], rax
$LN6@memory_len:
  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR tv77[rsp]
$LN3@memory_len:

; 2394 : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
memory_length ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@ELHMEAOK@?$AAP?$AAy?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAV?$AAi?$AAe?$AAw?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_richcompare DD imagerel memory_richcompare
	DD	imagerel memory_richcompare+1302
	DD	imagerel $unwind$memory_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_richcompare DD 021601H
	DD	0210116H
xdata	ENDS
;	COMDAT ??_C@_1CM@ELHMEAOK@?$AAP?$AAy?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAV?$AAi?$AAe?$AAw?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@ELHMEAOK@?$AAP?$AAy?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAV?$AAi?$AAe?$AAw?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H
	DB	'y', 00H, 'V', 00H, 'i', 00H, 'e', 00H, 'w', 00H, '_', 00H, 'C'
	DB	00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'v', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_richcompare
_TEXT	SEGMENT
res$ = 96
vv$ = 104
wfmt$ = 112
vfmt$ = 113
unpack_w$ = 120
equal$ = 128
wbuf$ = 144
unpack_v$ = 224
ww$ = 232
tv80 = 240
tv92 = 244
v$ = 272
w$ = 280
op$ = 288
memory_richcompare PROC					; COMDAT

; 2599 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 2600 :     PyObject *res;
; 2601 :     Py_buffer wbuf, *vv;
; 2602 :     Py_buffer *ww = NULL;

  00016	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ww$[rsp], 0

; 2603 :     struct unpacker *unpack_v = NULL;

  00022	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR unpack_v$[rsp], 0

; 2604 :     struct unpacker *unpack_w = NULL;

  0002e	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR unpack_w$[rsp], 0

; 2605 :     char vfmt, wfmt;
; 2606 :     int equal = MV_COMPARE_NOT_IMPL;

  00037	c7 84 24 80 00
	00 00 fe ff ff
	ff		 mov	 DWORD PTR equal$[rsp], -2

; 2607 : 
; 2608 :     if (op != Py_EQ && op != Py_NE)

  00042	83 bc 24 20 01
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  0004a	74 0f		 je	 SHORT $LN32@memory_ric
  0004c	83 bc 24 20 01
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  00054	74 05		 je	 SHORT $LN32@memory_ric

; 2609 :         goto result; /* Py_NotImplemented */

  00056	e9 f1 03 00 00	 jmp	 $result$22349
$LN32@memory_ric:

; 2610 : 
; 2611 :     assert(PyMemoryView_Check(v));

  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyMemoryView_Type
  00062	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0006a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0006e	74 1c		 je	 SHORT $LN35@memory_ric
  00070	41 b8 33 0a 00
	00		 mov	 r8d, 2611		; 00000a33H
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@ELHMEAOK@?$AAP?$AAy?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAV?$AAi?$AAe?$AAw?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008a	33 c0		 xor	 eax, eax
$LN35@memory_ric:

; 2612 :     if (BASE_INACCESSIBLE(v)) {

  0008c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00094	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0009a	83 e0 01	 and	 eax, 1
  0009d	85 c0		 test	 eax, eax
  0009f	75 16		 jne	 SHORT $LN30@memory_ric
  000a1	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  000a9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000ad	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  000b0	83 e0 01	 and	 eax, 1
  000b3	85 c0		 test	 eax, eax
  000b5	74 3d		 je	 SHORT $LN31@memory_ric
$LN30@memory_ric:

; 2613 :         equal = (v == w);

  000b7	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000bf	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR v$[rsp], rax
  000c7	75 0d		 jne	 SHORT $LN36@memory_ric
  000c9	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv80[rsp], 1
  000d4	eb 0b		 jmp	 SHORT $LN37@memory_ric
$LN36@memory_ric:
  000d6	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv80[rsp], 0
$LN37@memory_ric:
  000e1	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv80[rsp]
  000e8	89 84 24 80 00
	00 00		 mov	 DWORD PTR equal$[rsp], eax

; 2614 :         goto result;

  000ef	e9 58 03 00 00	 jmp	 $result$22349
$LN31@memory_ric:

; 2615 :     }
; 2616 :     vv = VIEW_ADDR(v);

  000f4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  000fc	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00102	48 89 44 24 68	 mov	 QWORD PTR vv$[rsp], rax

; 2617 : 
; 2618 :     if (PyMemoryView_Check(w)) {

  00107	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyMemoryView_Type
  0010e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  00116	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0011a	0f 85 80 00 00
	00		 jne	 $LN29@memory_ric

; 2619 :         if (BASE_INACCESSIBLE(w)) {

  00120	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00128	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0012e	83 e0 01	 and	 eax, 1
  00131	85 c0		 test	 eax, eax
  00133	75 16		 jne	 SHORT $LN27@memory_ric
  00135	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR w$[rsp]
  0013d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00141	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00144	83 e0 01	 and	 eax, 1
  00147	85 c0		 test	 eax, eax
  00149	74 3d		 je	 SHORT $LN28@memory_ric
$LN27@memory_ric:

; 2620 :             equal = (v == w);

  0014b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00153	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR v$[rsp], rax
  0015b	75 0d		 jne	 SHORT $LN38@memory_ric
  0015d	c7 84 24 f4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv92[rsp], 1
  00168	eb 0b		 jmp	 SHORT $LN39@memory_ric
$LN38@memory_ric:
  0016a	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv92[rsp], 0
$LN39@memory_ric:
  00175	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv92[rsp]
  0017c	89 84 24 80 00
	00 00		 mov	 DWORD PTR equal$[rsp], eax

; 2621 :             goto result;

  00183	e9 c4 02 00 00	 jmp	 $result$22349
$LN28@memory_ric:

; 2622 :         }
; 2623 :         ww = VIEW_ADDR(w);

  00188	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00190	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00196	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR ww$[rsp], rax

; 2624 :     }
; 2625 :     else {

  0019e	eb 39		 jmp	 SHORT $LN26@memory_ric
$LN29@memory_ric:

; 2626 :         if (PyObject_GetBuffer(w, &wbuf, PyBUF_FULL_RO) < 0) {

  001a0	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  001a6	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR wbuf$[rsp]
  001ae	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  001b6	e8 00 00 00 00	 call	 PyObject_GetBuffer
  001bb	85 c0		 test	 eax, eax
  001bd	7d 0a		 jge	 SHORT $LN25@memory_ric

; 2627 :             PyErr_Clear();

  001bf	e8 00 00 00 00	 call	 PyErr_Clear

; 2628 :             goto result; /* Py_NotImplemented */

  001c4	e9 83 02 00 00	 jmp	 $result$22349
$LN25@memory_ric:

; 2629 :         }
; 2630 :         ww = &wbuf;

  001c9	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR wbuf$[rsp]
  001d1	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR ww$[rsp], rax
$LN26@memory_ric:

; 2631 :     }
; 2632 : 
; 2633 :     if (!equiv_shape(vv, ww)) {

  001d9	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR ww$[rsp]
  001e1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vv$[rsp]
  001e6	e8 00 00 00 00	 call	 equiv_shape
  001eb	85 c0		 test	 eax, eax
  001ed	75 15		 jne	 SHORT $LN24@memory_ric

; 2634 :         PyErr_Clear();

  001ef	e8 00 00 00 00	 call	 PyErr_Clear

; 2635 :         equal = 0;

  001f4	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR equal$[rsp], 0

; 2636 :         goto result;

  001ff	e9 48 02 00 00	 jmp	 $result$22349
$LN24@memory_ric:

; 2637 :     }
; 2638 : 
; 2639 :     /* Use fast unpacking for identical primitive C type formats. */
; 2640 :     if (get_native_fmtchar(&vfmt, vv->format) < 0)

  00204	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  00209	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  0020d	48 8d 4c 24 71	 lea	 rcx, QWORD PTR vfmt$[rsp]
  00212	e8 00 00 00 00	 call	 get_native_fmtchar
  00217	48 85 c0	 test	 rax, rax
  0021a	7d 05		 jge	 SHORT $LN23@memory_ric

; 2641 :         vfmt = '_';

  0021c	c6 44 24 71 5f	 mov	 BYTE PTR vfmt$[rsp], 95	; 0000005fH
$LN23@memory_ric:

; 2642 :     if (get_native_fmtchar(&wfmt, ww->format) < 0)

  00221	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ww$[rsp]
  00229	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  0022d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR wfmt$[rsp]
  00232	e8 00 00 00 00	 call	 get_native_fmtchar
  00237	48 85 c0	 test	 rax, rax
  0023a	7d 05		 jge	 SHORT $LN22@memory_ric

; 2643 :         wfmt = '_';

  0023c	c6 44 24 70 5f	 mov	 BYTE PTR wfmt$[rsp], 95	; 0000005fH
$LN22@memory_ric:

; 2644 :     if (vfmt == '_' || wfmt == '_' || vfmt != wfmt) {

  00241	0f be 44 24 71	 movsx	 eax, BYTE PTR vfmt$[rsp]
  00246	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00249	74 18		 je	 SHORT $LN20@memory_ric
  0024b	0f be 44 24 70	 movsx	 eax, BYTE PTR wfmt$[rsp]
  00250	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00253	74 0e		 je	 SHORT $LN20@memory_ric
  00255	0f be 44 24 71	 movsx	 eax, BYTE PTR vfmt$[rsp]
  0025a	0f be 4c 24 70	 movsx	 ecx, BYTE PTR wfmt$[rsp]
  0025f	3b c1		 cmp	 eax, ecx
  00261	74 7b		 je	 SHORT $LN21@memory_ric
$LN20@memory_ric:

; 2645 :         /* Use struct module unpacking. NOTE: Even for equal format strings,
; 2646 :            memcmp() cannot be used for item comparison since it would give
; 2647 :            incorrect results in the case of NaNs or uninitialized padding
; 2648 :            bytes. */
; 2649 :         vfmt = '_';

  00263	c6 44 24 71 5f	 mov	 BYTE PTR vfmt$[rsp], 95	; 0000005fH

; 2650 :         unpack_v = struct_get_unpacker(vv->format, vv->itemsize);

  00268	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  0026d	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00271	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  00276	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0027a	e8 00 00 00 00	 call	 struct_get_unpacker
  0027f	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR unpack_v$[rsp], rax

; 2651 :         if (unpack_v == NULL) {

  00287	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR unpack_v$[rsp], 0
  00290	75 11		 jne	 SHORT $LN19@memory_ric

; 2652 :             equal = fix_struct_error_int();

  00292	e8 00 00 00 00	 call	 fix_struct_error_int
  00297	89 84 24 80 00
	00 00		 mov	 DWORD PTR equal$[rsp], eax

; 2653 :             goto result;

  0029e	e9 a9 01 00 00	 jmp	 $result$22349
$LN19@memory_ric:

; 2654 :         }
; 2655 :         unpack_w = struct_get_unpacker(ww->format, ww->itemsize);

  002a3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ww$[rsp]
  002ab	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  002af	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ww$[rsp]
  002b7	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  002bb	e8 00 00 00 00	 call	 struct_get_unpacker
  002c0	48 89 44 24 78	 mov	 QWORD PTR unpack_w$[rsp], rax

; 2656 :         if (unpack_w == NULL) {

  002c5	48 83 7c 24 78
	00		 cmp	 QWORD PTR unpack_w$[rsp], 0
  002cb	75 11		 jne	 SHORT $LN18@memory_ric

; 2657 :             equal = fix_struct_error_int();

  002cd	e8 00 00 00 00	 call	 fix_struct_error_int
  002d2	89 84 24 80 00
	00 00		 mov	 DWORD PTR equal$[rsp], eax

; 2658 :             goto result;

  002d9	e9 6e 01 00 00	 jmp	 $result$22349
$LN18@memory_ric:
$LN21@memory_ric:

; 2659 :         }
; 2660 :     }
; 2661 : 
; 2662 :     if (vv->ndim == 0) {

  002de	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  002e3	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  002e7	75 3c		 jne	 SHORT $LN17@memory_ric

; 2663 :         equal = unpack_cmp(vv->buf, ww->buf,
; 2664 :                            vfmt, unpack_v, unpack_w);

  002e9	48 8b 44 24 78	 mov	 rax, QWORD PTR unpack_w$[rsp]
  002ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f3	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR unpack_v$[rsp]
  002fb	44 0f b6 44 24
	71		 movzx	 r8d, BYTE PTR vfmt$[rsp]
  00301	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ww$[rsp]
  00309	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0030c	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  00311	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00314	e8 00 00 00 00	 call	 unpack_cmp
  00319	89 84 24 80 00
	00 00		 mov	 DWORD PTR equal$[rsp], eax
  00320	e9 27 01 00 00	 jmp	 $LN16@memory_ric
$LN17@memory_ric:

; 2665 :     }
; 2666 :     else if (vv->ndim == 1) {

  00325	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  0032a	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  0032e	0f 85 86 00 00
	00		 jne	 $LN15@memory_ric

; 2667 :         equal = cmp_base(vv->buf, ww->buf, vv->shape,
; 2668 :                          vv->strides, vv->suboffsets,
; 2669 :                          ww->strides, ww->suboffsets,
; 2670 :                          vfmt, unpack_v, unpack_w);

  00334	48 8b 44 24 78	 mov	 rax, QWORD PTR unpack_w$[rsp]
  00339	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0033e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR unpack_v$[rsp]
  00346	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0034b	0f b6 44 24 71	 movzx	 eax, BYTE PTR vfmt$[rsp]
  00350	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  00354	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ww$[rsp]
  0035c	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00360	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00365	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ww$[rsp]
  0036d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00371	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00376	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  0037b	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0037f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00384	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  00389	4c 8b 48 38	 mov	 r9, QWORD PTR [rax+56]
  0038d	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  00392	4c 8b 40 30	 mov	 r8, QWORD PTR [rax+48]
  00396	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ww$[rsp]
  0039e	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  003a1	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  003a6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003a9	e8 00 00 00 00	 call	 cmp_base
  003ae	89 84 24 80 00
	00 00		 mov	 DWORD PTR equal$[rsp], eax

; 2671 :     }
; 2672 :     else {

  003b5	e9 92 00 00 00	 jmp	 $LN14@memory_ric
$LN15@memory_ric:

; 2673 :         equal = cmp_rec(vv->buf, ww->buf, vv->ndim, vv->shape,
; 2674 :                         vv->strides, vv->suboffsets,
; 2675 :                         ww->strides, ww->suboffsets,
; 2676 :                         vfmt, unpack_v, unpack_w);

  003ba	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  003bf	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  003c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR unpack_w$[rsp]
  003c8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003cd	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR unpack_v$[rsp]
  003d5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003da	0f b6 4c 24 71	 movzx	 ecx, BYTE PTR vfmt$[rsp]
  003df	88 4c 24 40	 mov	 BYTE PTR [rsp+64], cl
  003e3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ww$[rsp]
  003eb	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  003ef	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003f4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ww$[rsp]
  003fc	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00400	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00405	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vv$[rsp]
  0040a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0040e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00413	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vv$[rsp]
  00418	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0041c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00421	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vv$[rsp]
  00426	4c 8b 49 30	 mov	 r9, QWORD PTR [rcx+48]
  0042a	4c 8b c0	 mov	 r8, rax
  0042d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ww$[rsp]
  00435	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00438	48 8b 44 24 68	 mov	 rax, QWORD PTR vv$[rsp]
  0043d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00440	e8 00 00 00 00	 call	 cmp_rec
  00445	89 84 24 80 00
	00 00		 mov	 DWORD PTR equal$[rsp], eax
$LN14@memory_ric:
$LN16@memory_ric:
$result$22349:

; 2677 :     }
; 2678 : 
; 2679 : result:
; 2680 :     if (equal < 0) {

  0044c	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR equal$[rsp], 0
  00454	7d 23		 jge	 SHORT $LN13@memory_ric

; 2681 :         if (equal == MV_COMPARE_NOT_IMPL)

  00456	83 bc 24 80 00
	00 00 fe	 cmp	 DWORD PTR equal$[rsp], -2
  0045e	75 0e		 jne	 SHORT $LN12@memory_ric

; 2682 :             res = Py_NotImplemented;

  00460	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00467	48 89 44 24 60	 mov	 QWORD PTR res$[rsp], rax

; 2683 :         else /* exception */

  0046c	eb 09		 jmp	 SHORT $LN11@memory_ric
$LN12@memory_ric:

; 2684 :             res = NULL;

  0046e	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR res$[rsp], 0
$LN11@memory_ric:

; 2685 :     }
; 2686 :     else if ((equal && op == Py_EQ) || (!equal && op == Py_NE))

  00477	eb 42		 jmp	 SHORT $LN10@memory_ric
$LN13@memory_ric:
  00479	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR equal$[rsp], 0
  00481	74 0a		 je	 SHORT $LN7@memory_ric
  00483	83 bc 24 20 01
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  0048b	74 14		 je	 SHORT $LN8@memory_ric
$LN7@memory_ric:
  0048d	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR equal$[rsp], 0
  00495	75 18		 jne	 SHORT $LN9@memory_ric
  00497	83 bc 24 20 01
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  0049f	75 0e		 jne	 SHORT $LN9@memory_ric
$LN8@memory_ric:

; 2687 :         res = Py_True;

  004a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  004a8	48 89 44 24 60	 mov	 QWORD PTR res$[rsp], rax

; 2688 :     else

  004ad	eb 0c		 jmp	 SHORT $LN6@memory_ric
$LN9@memory_ric:

; 2689 :         res = Py_False;

  004af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  004b6	48 89 44 24 60	 mov	 QWORD PTR res$[rsp], rax
$LN6@memory_ric:
$LN10@memory_ric:

; 2690 : 
; 2691 :     if (ww == &wbuf)

  004bb	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR wbuf$[rsp]
  004c3	48 39 84 24 e8
	00 00 00	 cmp	 QWORD PTR ww$[rsp], rax
  004cb	75 0d		 jne	 SHORT $LN5@memory_ric

; 2692 :         PyBuffer_Release(ww);

  004cd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ww$[rsp]
  004d5	e8 00 00 00 00	 call	 PyBuffer_Release
$LN5@memory_ric:

; 2693 : 
; 2694 :     unpacker_free(unpack_v);

  004da	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR unpack_v$[rsp]
  004e2	e8 00 00 00 00	 call	 unpacker_free

; 2695 :     unpacker_free(unpack_w);

  004e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR unpack_w$[rsp]
  004ec	e8 00 00 00 00	 call	 unpacker_free
$LN4@memory_ric:

; 2696 : 
; 2697 :     Py_XINCREF(res);

  004f1	48 83 7c 24 60
	00		 cmp	 QWORD PTR res$[rsp], 0
  004f7	74 0a		 je	 SHORT $LN1@memory_ric
  004f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR res$[rsp]
  004fe	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@memory_ric:
  00503	33 c0		 xor	 eax, eax
  00505	85 c0		 test	 eax, eax
  00507	75 e8		 jne	 SHORT $LN4@memory_ric

; 2698 :     return res;

  00509	48 8b 44 24 60	 mov	 rax, QWORD PTR res$[rsp]

; 2699 : }

  0050e	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00515	c3		 ret	 0
memory_richcompare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpacker_free DD imagerel unpacker_free
	DD	imagerel unpacker_free+108
	DD	imagerel $unwind$unpacker_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpacker_free DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT unpacker_free
_TEXT	SEGMENT
x$ = 48
unpacker_free PROC					; COMDAT

; 1892 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1893 :     if (x) {

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR x$[rsp], 0
  0000f	74 56		 je	 SHORT $LN9@unpacker_f
$LN8@unpacker_f:

; 1894 :         Py_XDECREF(x->unpack_from);

  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  00016	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001a	74 0d		 je	 SHORT $LN5@unpacker_f
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  00021	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00024	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@unpacker_f:
  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	75 e2		 jne	 SHORT $LN8@unpacker_f
$LN4@unpacker_f:

; 1895 :         Py_XDECREF(x->mview);

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  00034	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00039	74 0e		 je	 SHORT $LN1@unpacker_f
  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  00040	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00044	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@unpacker_f:
  00049	33 c0		 xor	 eax, eax
  0004b	85 c0		 test	 eax, eax
  0004d	75 e0		 jne	 SHORT $LN4@unpacker_f

; 1896 :         PyMem_Free(x->item);

  0004f	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  00054	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00058	e8 00 00 00 00	 call	 PyMem_Free

; 1897 :         PyMem_Free(x);

  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  00062	e8 00 00 00 00	 call	 PyMem_Free
$LN9@unpacker_f:

; 1898 :     }
; 1899 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
unpacker_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@OJKBBEFN@unpack_from?$AA@		; `string'
PUBLIC	??_C@_06DOCMLGPG@Struct?$AA@			; `string'
PUBLIC	??_C@_06PBJBIPGK@struct?$AA@			; `string'
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyBytes_FromString:PROC
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$struct_get_unpacker DD imagerel struct_get_unpacker
	DD	imagerel struct_get_unpacker+465
	DD	imagerel $unwind$struct_get_unpacker
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$struct_get_unpacker DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0M@OJKBBEFN@unpack_from?$AA@
CONST	SEGMENT
??_C@_0M@OJKBBEFN@unpack_from?$AA@ DB 'unpack_from', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DOCMLGPG@Struct?$AA@
CONST	SEGMENT
??_C@_06DOCMLGPG@Struct?$AA@ DB 'Struct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PBJBIPGK@struct?$AA@
CONST	SEGMENT
??_C@_06PBJBIPGK@struct?$AA@ DB 'struct', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT struct_get_unpacker
_TEXT	SEGMENT
structmodule$ = 32
x$ = 40
Struct$ = 48
structobj$ = 56
format$ = 64
fmt$ = 96
itemsize$ = 104
struct_get_unpacker PROC				; COMDAT

; 1904 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1905 :     PyObject *structmodule;     /* XXX cache these two */
; 1906 :     PyObject *Struct = NULL;    /* XXX in globals?     */

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR Struct$[rsp], 0

; 1907 :     PyObject *structobj = NULL;

  00017	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR structobj$[rsp], 0

; 1908 :     PyObject *format = NULL;

  00020	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR format$[rsp], 0

; 1909 :     struct unpacker *x = NULL;

  00029	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 1910 : 
; 1911 :     structmodule = PyImport_ImportModule("struct");

  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06PBJBIPGK@struct?$AA@
  00039	e8 00 00 00 00	 call	 PyImport_ImportModule
  0003e	48 89 44 24 20	 mov	 QWORD PTR structmodule$[rsp], rax

; 1912 :     if (structmodule == NULL)

  00043	48 83 7c 24 20
	00		 cmp	 QWORD PTR structmodule$[rsp], 0
  00049	75 07		 jne	 SHORT $LN20@struct_get

; 1913 :         return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	e9 7a 01 00 00	 jmp	 $LN21@struct_get
$LN20@struct_get:

; 1914 : 
; 1915 :     Struct = PyObject_GetAttrString(structmodule, "Struct");

  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DOCMLGPG@Struct?$AA@
  00059	48 8b 4c 24 20	 mov	 rcx, QWORD PTR structmodule$[rsp]
  0005e	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00063	48 89 44 24 30	 mov	 QWORD PTR Struct$[rsp], rax

; 1916 :     Py_DECREF(structmodule);

  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR structmodule$[rsp]
  0006d	e8 00 00 00 00	 call	 _Py_DecRef

; 1917 :     if (Struct == NULL)

  00072	48 83 7c 24 30
	00		 cmp	 QWORD PTR Struct$[rsp], 0
  00078	75 07		 jne	 SHORT $LN19@struct_get

; 1918 :         return NULL;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 4b 01 00 00	 jmp	 $LN21@struct_get
$LN19@struct_get:

; 1919 : 
; 1920 :     x = unpacker_new();

  00081	e8 00 00 00 00	 call	 unpacker_new
  00086	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax

; 1921 :     if (x == NULL)

  0008b	48 83 7c 24 28
	00		 cmp	 QWORD PTR x$[rsp], 0
  00091	75 05		 jne	 SHORT $LN18@struct_get

; 1922 :         goto error;

  00093	e9 1f 01 00 00	 jmp	 $error$21699
$LN18@struct_get:

; 1923 : 
; 1924 :     format = PyBytes_FromString(fmt);

  00098	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fmt$[rsp]
  0009d	e8 00 00 00 00	 call	 PyBytes_FromString
  000a2	48 89 44 24 40	 mov	 QWORD PTR format$[rsp], rax

; 1925 :     if (format == NULL)

  000a7	48 83 7c 24 40
	00		 cmp	 QWORD PTR format$[rsp], 0
  000ad	75 05		 jne	 SHORT $LN17@struct_get

; 1926 :         goto error;

  000af	e9 03 01 00 00	 jmp	 $error$21699
$LN17@struct_get:

; 1927 : 
; 1928 :     structobj = PyObject_CallFunctionObjArgs(Struct, format, NULL);

  000b4	45 33 c0	 xor	 r8d, r8d
  000b7	48 8b 54 24 40	 mov	 rdx, QWORD PTR format$[rsp]
  000bc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Struct$[rsp]
  000c1	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  000c6	48 89 44 24 38	 mov	 QWORD PTR structobj$[rsp], rax

; 1929 :     if (structobj == NULL)

  000cb	48 83 7c 24 38
	00		 cmp	 QWORD PTR structobj$[rsp], 0
  000d1	75 05		 jne	 SHORT $LN16@struct_get

; 1930 :         goto error;

  000d3	e9 df 00 00 00	 jmp	 $error$21699
$LN16@struct_get:

; 1931 : 
; 1932 :     x->unpack_from = PyObject_GetAttrString(structobj, "unpack_from");

  000d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OJKBBEFN@unpack_from?$AA@
  000df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR structobj$[rsp]
  000e4	e8 00 00 00 00	 call	 PyObject_GetAttrString
  000e9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  000ee	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1933 :     if (x->unpack_from == NULL)

  000f1	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  000f6	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000fa	75 05		 jne	 SHORT $LN15@struct_get

; 1934 :         goto error;

  000fc	e9 b6 00 00 00	 jmp	 $error$21699
$LN15@struct_get:

; 1935 : 
; 1936 :     x->item = PyMem_Malloc(itemsize);

  00101	48 8b 4c 24 68	 mov	 rcx, QWORD PTR itemsize$[rsp]
  00106	e8 00 00 00 00	 call	 PyMem_Malloc
  0010b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  00110	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1937 :     if (x->item == NULL) {

  00114	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  00119	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0011e	75 0a		 jne	 SHORT $LN14@struct_get

; 1938 :         PyErr_NoMemory();

  00120	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1939 :         goto error;

  00125	e9 8d 00 00 00	 jmp	 $error$21699
$LN14@struct_get:

; 1940 :     }
; 1941 :     x->itemsize = itemsize;

  0012a	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  0012f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR itemsize$[rsp]
  00134	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1942 : 
; 1943 :     x->mview = PyMemoryView_FromMemory(x->item, itemsize, PyBUF_WRITE);

  00138	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0013e	48 8b 54 24 68	 mov	 rdx, QWORD PTR itemsize$[rsp]
  00143	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  00148	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0014c	e8 00 00 00 00	 call	 PyMemoryView_FromMemory
  00151	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  00156	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1944 :     if (x->mview == NULL)

  0015a	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  0015f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00164	75 02		 jne	 SHORT $LN13@struct_get

; 1945 :         goto error;

  00166	eb 4f		 jmp	 SHORT $error$21699
$LN13@struct_get:
$out$21712:
$LN12@struct_get:

; 1946 : 
; 1947 : 
; 1948 : out:
; 1949 :     Py_XDECREF(Struct);

  00168	48 83 7c 24 30
	00		 cmp	 QWORD PTR Struct$[rsp], 0
  0016e	74 0a		 je	 SHORT $LN9@struct_get
  00170	48 8b 4c 24 30	 mov	 rcx, QWORD PTR Struct$[rsp]
  00175	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@struct_get:
  0017a	33 c0		 xor	 eax, eax
  0017c	85 c0		 test	 eax, eax
  0017e	75 e8		 jne	 SHORT $LN12@struct_get
$LN8@struct_get:

; 1950 :     Py_XDECREF(format);

  00180	48 83 7c 24 40
	00		 cmp	 QWORD PTR format$[rsp], 0
  00186	74 0a		 je	 SHORT $LN5@struct_get
  00188	48 8b 4c 24 40	 mov	 rcx, QWORD PTR format$[rsp]
  0018d	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@struct_get:
  00192	33 c0		 xor	 eax, eax
  00194	85 c0		 test	 eax, eax
  00196	75 e8		 jne	 SHORT $LN8@struct_get
$LN4@struct_get:

; 1951 :     Py_XDECREF(structobj);

  00198	48 83 7c 24 38
	00		 cmp	 QWORD PTR structobj$[rsp], 0
  0019e	74 0a		 je	 SHORT $LN1@struct_get
  001a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR structobj$[rsp]
  001a5	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@struct_get:
  001aa	33 c0		 xor	 eax, eax
  001ac	85 c0		 test	 eax, eax
  001ae	75 e8		 jne	 SHORT $LN4@struct_get

; 1952 :     return x;

  001b0	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  001b5	eb 15		 jmp	 SHORT $LN21@struct_get
$error$21699:

; 1953 : 
; 1954 : error:
; 1955 :     unpacker_free(x);

  001b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  001bc	e8 00 00 00 00	 call	 unpacker_free

; 1956 :     x = NULL;

  001c1	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 1957 :     goto out;

  001ca	eb 9c		 jmp	 SHORT $out$21712
$LN21@struct_get:

; 1958 : }

  001cc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d0	c3		 ret	 0
struct_get_unpacker ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpacker_new DD imagerel unpacker_new
	DD	imagerel unpacker_new+97
	DD	imagerel $unwind$unpacker_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpacker_new DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT unpacker_new
_TEXT	SEGMENT
x$ = 32
unpacker_new PROC					; COMDAT

; 1874 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1875 :     struct unpacker *x = PyMem_Malloc(sizeof *x);

  00004	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00009	e8 00 00 00 00	 call	 PyMem_Malloc
  0000e	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 1876 : 
; 1877 :     if (x == NULL) {

  00013	48 83 7c 24 20
	00		 cmp	 QWORD PTR x$[rsp], 0
  00019	75 09		 jne	 SHORT $LN1@unpacker_n

; 1878 :         PyErr_NoMemory();

  0001b	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1879 :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	eb 38		 jmp	 SHORT $LN2@unpacker_n
$LN1@unpacker_n:

; 1880 :     }
; 1881 : 
; 1882 :     x->unpack_from = NULL;

  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  00029	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1883 :     x->mview = NULL;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  00035	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1884 :     x->item = NULL;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  00042	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1885 :     x->itemsize = 0;

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  0004f	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 1886 : 
; 1887 :     return x;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
$LN2@unpacker_n:

; 1888 : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
unpacker_new ENDP
_TEXT	ENDS
EXTRN	PyExc_MemoryError:QWORD
EXTRN	PyExc_ImportError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$fix_struct_error_int DD imagerel fix_struct_error_int
	DD	imagerel fix_struct_error_int+93
	DD	imagerel $unwind$fix_struct_error_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fix_struct_error_int DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fix_struct_error_int
_TEXT	SEGMENT
fix_struct_error_int PROC				; COMDAT

; 2422 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2423 :     assert(PyErr_Occurred());

  00004	e8 00 00 00 00	 call	 PyErr_Occurred
  00009	48 85 c0	 test	 rax, rax
  0000c	75 1c		 jne	 SHORT $LN5@fix_struct
  0000e	41 b8 77 09 00
	00		 mov	 r8d, 2423		; 00000977H
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@DNBCFJEA@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00028	33 c0		 xor	 eax, eax
$LN5@fix_struct:

; 2424 :     /* XXX Cannot get at StructError directly? */
; 2425 :     if (PyErr_ExceptionMatches(PyExc_ImportError) ||
; 2426 :         PyErr_ExceptionMatches(PyExc_MemoryError)) {

  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  00031	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00036	85 c0		 test	 eax, eax
  00038	75 10		 jne	 SHORT $LN1@fix_struct
  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  00041	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00046	85 c0		 test	 eax, eax
  00048	74 07		 je	 SHORT $LN2@fix_struct
$LN1@fix_struct:

; 2427 :         return MV_COMPARE_EX;

  0004a	b8 ff ff ff ff	 mov	 eax, -1
  0004f	eb 07		 jmp	 SHORT $LN3@fix_struct
$LN2@fix_struct:

; 2428 :     }
; 2429 :     /* StructError: invalid or unknown format -> not equal */
; 2430 :     PyErr_Clear();

  00051	e8 00 00 00 00	 call	 PyErr_Clear

; 2431 :     return 0;

  00056	33 c0		 xor	 eax, eax
$LN3@fix_struct:

; 2432 : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
fix_struct_error_int ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@JGBOLOHN@memoryview?3?5internal?5error?5in?5ri@ ; `string'
PUBLIC	??_C@_1BC@GMCHFDFG@?$AAu?$AAn?$AAp?$AAa?$AAc?$AAk?$AA_?$AAq?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@NEJLDEDD@?$AAu?$AAn?$AAp?$AAa?$AAc?$AAk?$AA_?$AAp?$AA?$AA@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_cmp DD imagerel unpack_cmp
	DD	imagerel unpack_cmp+2171
	DD	imagerel $unwind$unpack_cmp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_cmp DD 021b01H
	DD	023011bH
xdata	ENDS
;	COMDAT ??_C@_0CK@JGBOLOHN@memoryview?3?5internal?5error?5in?5ri@
CONST	SEGMENT
??_C@_0CK@JGBOLOHN@memoryview?3?5internal?5error?5in?5ri@ DB 'memoryview:'
	DB	' internal error in richcompare', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@GMCHFDFG@?$AAu?$AAn?$AAp?$AAa?$AAc?$AAk?$AA_?$AAq?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@GMCHFDFG@?$AAu?$AAn?$AAp?$AAa?$AAc?$AAk?$AA_?$AAq?$AA?$AA@ DB 'u'
	DB	00H, 'n', 00H, 'p', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '_', 00H
	DB	'q', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@NEJLDEDD@?$AAu?$AAn?$AAp?$AAa?$AAc?$AAk?$AA_?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@NEJLDEDD@?$AAu?$AAn?$AAp?$AAa?$AAc?$AAk?$AA_?$AAp?$AA?$AA@ DB 'u'
	DB	00H, 'n', 00H, 'p', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '_', 00H
	DB	'p', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT unpack_cmp
_TEXT	SEGMENT
equal$ = 32
y$22136 = 36
x$22135 = 40
y$22144 = 44
x$22143 = 48
y$22152 = 52
x$22151 = 56
y$22160 = 60
x$22159 = 61
y$22168 = 64
x$22167 = 68
y$22176 = 72
x$22175 = 76
y$22184 = 80
x$22183 = 84
y$22192 = 88
x$22191 = 96
y$22200 = 104
x$22199 = 112
y$22208 = 120
x$22207 = 128
y$22216 = 136
x$22215 = 144
y$22224 = 152
x$22223 = 156
y$22232 = 160
x$22231 = 168
y$22241 = 176
x$22240 = 184
tv65 = 192
tv69 = 196
tv73 = 200
tv83 = 204
tv92 = 208
tv133 = 212
tv144 = 216
tv155 = 220
tv164 = 224
tv173 = 228
tv182 = 232
tv191 = 236
tv200 = 240
tv209 = 244
tv218 = 248
tv227 = 252
tv232 = 256
tv240 = 260
p$ = 288
q$ = 296
fmt$ = 304
unpack_p$ = 312
unpack_q$ = 320
unpack_cmp PROC						; COMDAT

; 2480 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 2481 :     int equal;
; 2482 : 
; 2483 :     switch (fmt) {

  0001b	0f be 84 24 30
	01 00 00	 movsx	 eax, BYTE PTR fmt$[rsp]
  00023	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  0002a	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv65[rsp]
  00031	83 e8 3f	 sub	 eax, 63			; 0000003fH
  00034	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  0003b	83 bc 24 c0 00
	00 00 32	 cmp	 DWORD PTR tv65[rsp], 50	; 00000032H
  00043	0f 87 91 07 00
	00		 ja	 $LN61@unpack_cmp
  00049	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR tv65[rsp]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00058	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN101@unpack_cmp[rcx+rax]
  00060	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN102@unpack_cmp[rcx+rax*4]
  00067	48 03 c1	 add	 rax, rcx
  0006a	ff e0		 jmp	 rax
$LN60@unpack_cmp:

; 2484 : 
; 2485 :     /* signed integers and fast path for 'B' */
; 2486 :     case 'B': return *((unsigned char *)p) == *((unsigned char *)q);

  0006c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00074	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00077	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR q$[rsp]
  0007f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00082	3b c1		 cmp	 eax, ecx
  00084	75 0d		 jne	 SHORT $LN65@unpack_cmp
  00086	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv69[rsp], 1
  00091	eb 0b		 jmp	 SHORT $LN66@unpack_cmp
$LN65@unpack_cmp:
  00093	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv69[rsp], 0
$LN66@unpack_cmp:
  0009e	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv69[rsp]
  000a5	e9 48 07 00 00	 jmp	 $LN63@unpack_cmp
$LN59@unpack_cmp:

; 2487 :     case 'b': return *((signed char *)p) == *((signed char *)q);

  000aa	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]
  000b2	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b5	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR q$[rsp]
  000bd	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  000c0	3b c1		 cmp	 eax, ecx
  000c2	75 0d		 jne	 SHORT $LN67@unpack_cmp
  000c4	c7 84 24 c8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv73[rsp], 1
  000cf	eb 0b		 jmp	 SHORT $LN68@unpack_cmp
$LN67@unpack_cmp:
  000d1	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv73[rsp], 0
$LN68@unpack_cmp:
  000dc	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv73[rsp]
  000e3	e9 0a 07 00 00	 jmp	 $LN63@unpack_cmp
$LN58@unpack_cmp:
$LN57@unpack_cmp:

; 2488 :     case 'h': CMP_SINGLE(p, q, short); return equal;

  000e8	41 b8 02 00 00
	00		 mov	 r8d, 2
  000ee	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  000f6	48 8d 4c 24 28	 lea	 rcx, QWORD PTR x$22135[rsp]
  000fb	e8 00 00 00 00	 call	 memcpy
  00100	41 b8 02 00 00
	00		 mov	 r8d, 2
  00106	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  0010e	48 8d 4c 24 24	 lea	 rcx, QWORD PTR y$22136[rsp]
  00113	e8 00 00 00 00	 call	 memcpy
  00118	0f bf 44 24 28	 movsx	 eax, WORD PTR x$22135[rsp]
  0011d	0f bf 4c 24 24	 movsx	 ecx, WORD PTR y$22136[rsp]
  00122	3b c1		 cmp	 eax, ecx
  00124	75 0d		 jne	 SHORT $LN69@unpack_cmp
  00126	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv83[rsp], 1
  00131	eb 0b		 jmp	 SHORT $LN70@unpack_cmp
$LN69@unpack_cmp:
  00133	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv83[rsp], 0
$LN70@unpack_cmp:
  0013e	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR tv83[rsp]
  00145	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 99		 jne	 SHORT $LN57@unpack_cmp
  0014f	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  00153	e9 9a 06 00 00	 jmp	 $LN63@unpack_cmp
$LN54@unpack_cmp:
$LN53@unpack_cmp:

; 2489 :     case 'i': CMP_SINGLE(p, q, int); return equal;

  00158	41 b8 04 00 00
	00		 mov	 r8d, 4
  0015e	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00166	48 8d 4c 24 30	 lea	 rcx, QWORD PTR x$22143[rsp]
  0016b	e8 00 00 00 00	 call	 memcpy
  00170	41 b8 04 00 00
	00		 mov	 r8d, 4
  00176	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  0017e	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR y$22144[rsp]
  00183	e8 00 00 00 00	 call	 memcpy
  00188	8b 44 24 2c	 mov	 eax, DWORD PTR y$22144[rsp]
  0018c	39 44 24 30	 cmp	 DWORD PTR x$22143[rsp], eax
  00190	75 0d		 jne	 SHORT $LN71@unpack_cmp
  00192	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv92[rsp], 1
  0019d	eb 0b		 jmp	 SHORT $LN72@unpack_cmp
$LN71@unpack_cmp:
  0019f	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv92[rsp], 0
$LN72@unpack_cmp:
  001aa	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv92[rsp]
  001b1	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 9d		 jne	 SHORT $LN53@unpack_cmp
  001bb	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  001bf	e9 2e 06 00 00	 jmp	 $LN63@unpack_cmp
$LN50@unpack_cmp:
$LN49@unpack_cmp:

; 2490 :     case 'l': CMP_SINGLE(p, q, long); return equal;

  001c4	41 b8 04 00 00
	00		 mov	 r8d, 4
  001ca	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  001d2	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x$22151[rsp]
  001d7	e8 00 00 00 00	 call	 memcpy
  001dc	41 b8 04 00 00
	00		 mov	 r8d, 4
  001e2	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  001ea	48 8d 4c 24 34	 lea	 rcx, QWORD PTR y$22152[rsp]
  001ef	e8 00 00 00 00	 call	 memcpy
  001f4	8b 44 24 34	 mov	 eax, DWORD PTR y$22152[rsp]
  001f8	39 44 24 38	 cmp	 DWORD PTR x$22151[rsp], eax
  001fc	75 0d		 jne	 SHORT $LN73@unpack_cmp
  001fe	c7 84 24 d4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv133[rsp], 1
  00209	eb 0b		 jmp	 SHORT $LN74@unpack_cmp
$LN73@unpack_cmp:
  0020b	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv133[rsp], 0
$LN74@unpack_cmp:
  00216	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv133[rsp]
  0021d	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  00221	33 c0		 xor	 eax, eax
  00223	85 c0		 test	 eax, eax
  00225	75 9d		 jne	 SHORT $LN49@unpack_cmp
  00227	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  0022b	e9 c2 05 00 00	 jmp	 $LN63@unpack_cmp
$LN46@unpack_cmp:
$LN45@unpack_cmp:

; 2491 : 
; 2492 :     /* boolean */
; 2493 :     #ifdef HAVE_C99_BOOL
; 2494 :     case '?': CMP_SINGLE(p, q, _Bool); return equal;
; 2495 :     #else
; 2496 :     case '?': CMP_SINGLE(p, q, char); return equal;

  00230	41 b8 01 00 00
	00		 mov	 r8d, 1
  00236	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  0023e	48 8d 4c 24 3d	 lea	 rcx, QWORD PTR x$22159[rsp]
  00243	e8 00 00 00 00	 call	 memcpy
  00248	41 b8 01 00 00
	00		 mov	 r8d, 1
  0024e	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  00256	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR y$22160[rsp]
  0025b	e8 00 00 00 00	 call	 memcpy
  00260	0f be 44 24 3d	 movsx	 eax, BYTE PTR x$22159[rsp]
  00265	0f be 4c 24 3c	 movsx	 ecx, BYTE PTR y$22160[rsp]
  0026a	3b c1		 cmp	 eax, ecx
  0026c	75 0d		 jne	 SHORT $LN75@unpack_cmp
  0026e	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv144[rsp], 1
  00279	eb 0b		 jmp	 SHORT $LN76@unpack_cmp
$LN75@unpack_cmp:
  0027b	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv144[rsp], 0
$LN76@unpack_cmp:
  00286	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv144[rsp]
  0028d	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  00291	33 c0		 xor	 eax, eax
  00293	85 c0		 test	 eax, eax
  00295	75 99		 jne	 SHORT $LN45@unpack_cmp
  00297	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  0029b	e9 52 05 00 00	 jmp	 $LN63@unpack_cmp
$LN42@unpack_cmp:
$LN41@unpack_cmp:

; 2497 :     #endif
; 2498 : 
; 2499 :     /* unsigned integers */
; 2500 :     case 'H': CMP_SINGLE(p, q, unsigned short); return equal;

  002a0	41 b8 02 00 00
	00		 mov	 r8d, 2
  002a6	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  002ae	48 8d 4c 24 44	 lea	 rcx, QWORD PTR x$22167[rsp]
  002b3	e8 00 00 00 00	 call	 memcpy
  002b8	41 b8 02 00 00
	00		 mov	 r8d, 2
  002be	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  002c6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR y$22168[rsp]
  002cb	e8 00 00 00 00	 call	 memcpy
  002d0	0f b7 44 24 44	 movzx	 eax, WORD PTR x$22167[rsp]
  002d5	0f b7 4c 24 40	 movzx	 ecx, WORD PTR y$22168[rsp]
  002da	3b c1		 cmp	 eax, ecx
  002dc	75 0d		 jne	 SHORT $LN77@unpack_cmp
  002de	c7 84 24 dc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv155[rsp], 1
  002e9	eb 0b		 jmp	 SHORT $LN78@unpack_cmp
$LN77@unpack_cmp:
  002eb	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv155[rsp], 0
$LN78@unpack_cmp:
  002f6	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR tv155[rsp]
  002fd	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  00301	33 c0		 xor	 eax, eax
  00303	85 c0		 test	 eax, eax
  00305	75 99		 jne	 SHORT $LN41@unpack_cmp
  00307	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  0030b	e9 e2 04 00 00	 jmp	 $LN63@unpack_cmp
$LN38@unpack_cmp:
$LN37@unpack_cmp:

; 2501 :     case 'I': CMP_SINGLE(p, q, unsigned int); return equal;

  00310	41 b8 04 00 00
	00		 mov	 r8d, 4
  00316	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  0031e	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR x$22175[rsp]
  00323	e8 00 00 00 00	 call	 memcpy
  00328	41 b8 04 00 00
	00		 mov	 r8d, 4
  0032e	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  00336	48 8d 4c 24 48	 lea	 rcx, QWORD PTR y$22176[rsp]
  0033b	e8 00 00 00 00	 call	 memcpy
  00340	8b 44 24 48	 mov	 eax, DWORD PTR y$22176[rsp]
  00344	39 44 24 4c	 cmp	 DWORD PTR x$22175[rsp], eax
  00348	75 0d		 jne	 SHORT $LN79@unpack_cmp
  0034a	c7 84 24 e0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv164[rsp], 1
  00355	eb 0b		 jmp	 SHORT $LN80@unpack_cmp
$LN79@unpack_cmp:
  00357	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv164[rsp], 0
$LN80@unpack_cmp:
  00362	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv164[rsp]
  00369	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  0036d	33 c0		 xor	 eax, eax
  0036f	85 c0		 test	 eax, eax
  00371	75 9d		 jne	 SHORT $LN37@unpack_cmp
  00373	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  00377	e9 76 04 00 00	 jmp	 $LN63@unpack_cmp
$LN34@unpack_cmp:
$LN33@unpack_cmp:

; 2502 :     case 'L': CMP_SINGLE(p, q, unsigned long); return equal;

  0037c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00382	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  0038a	48 8d 4c 24 54	 lea	 rcx, QWORD PTR x$22183[rsp]
  0038f	e8 00 00 00 00	 call	 memcpy
  00394	41 b8 04 00 00
	00		 mov	 r8d, 4
  0039a	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  003a2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR y$22184[rsp]
  003a7	e8 00 00 00 00	 call	 memcpy
  003ac	8b 44 24 50	 mov	 eax, DWORD PTR y$22184[rsp]
  003b0	39 44 24 54	 cmp	 DWORD PTR x$22183[rsp], eax
  003b4	75 0d		 jne	 SHORT $LN81@unpack_cmp
  003b6	c7 84 24 e4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv173[rsp], 1
  003c1	eb 0b		 jmp	 SHORT $LN82@unpack_cmp
$LN81@unpack_cmp:
  003c3	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv173[rsp], 0
$LN82@unpack_cmp:
  003ce	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR tv173[rsp]
  003d5	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  003d9	33 c0		 xor	 eax, eax
  003db	85 c0		 test	 eax, eax
  003dd	75 9d		 jne	 SHORT $LN33@unpack_cmp
  003df	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  003e3	e9 0a 04 00 00	 jmp	 $LN63@unpack_cmp
$LN30@unpack_cmp:
$LN29@unpack_cmp:

; 2503 : 
; 2504 :     /* native 64-bit */
; 2505 :     #ifdef HAVE_LONG_LONG
; 2506 :     case 'q': CMP_SINGLE(p, q, PY_LONG_LONG); return equal;

  003e8	41 b8 08 00 00
	00		 mov	 r8d, 8
  003ee	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  003f6	48 8d 4c 24 60	 lea	 rcx, QWORD PTR x$22191[rsp]
  003fb	e8 00 00 00 00	 call	 memcpy
  00400	41 b8 08 00 00
	00		 mov	 r8d, 8
  00406	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  0040e	48 8d 4c 24 58	 lea	 rcx, QWORD PTR y$22192[rsp]
  00413	e8 00 00 00 00	 call	 memcpy
  00418	48 8b 44 24 58	 mov	 rax, QWORD PTR y$22192[rsp]
  0041d	48 39 44 24 60	 cmp	 QWORD PTR x$22191[rsp], rax
  00422	75 0d		 jne	 SHORT $LN83@unpack_cmp
  00424	c7 84 24 e8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv182[rsp], 1
  0042f	eb 0b		 jmp	 SHORT $LN84@unpack_cmp
$LN83@unpack_cmp:
  00431	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
$LN84@unpack_cmp:
  0043c	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv182[rsp]
  00443	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  00447	33 c0		 xor	 eax, eax
  00449	85 c0		 test	 eax, eax
  0044b	75 9b		 jne	 SHORT $LN29@unpack_cmp
  0044d	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  00451	e9 9c 03 00 00	 jmp	 $LN63@unpack_cmp
$LN26@unpack_cmp:
$LN25@unpack_cmp:

; 2507 :     case 'Q': CMP_SINGLE(p, q, unsigned PY_LONG_LONG); return equal;

  00456	41 b8 08 00 00
	00		 mov	 r8d, 8
  0045c	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00464	48 8d 4c 24 70	 lea	 rcx, QWORD PTR x$22199[rsp]
  00469	e8 00 00 00 00	 call	 memcpy
  0046e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00474	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  0047c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR y$22200[rsp]
  00481	e8 00 00 00 00	 call	 memcpy
  00486	48 8b 44 24 68	 mov	 rax, QWORD PTR y$22200[rsp]
  0048b	48 39 44 24 70	 cmp	 QWORD PTR x$22199[rsp], rax
  00490	75 0d		 jne	 SHORT $LN85@unpack_cmp
  00492	c7 84 24 ec 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv191[rsp], 1
  0049d	eb 0b		 jmp	 SHORT $LN86@unpack_cmp
$LN85@unpack_cmp:
  0049f	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv191[rsp], 0
$LN86@unpack_cmp:
  004aa	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR tv191[rsp]
  004b1	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  004b5	33 c0		 xor	 eax, eax
  004b7	85 c0		 test	 eax, eax
  004b9	75 9b		 jne	 SHORT $LN25@unpack_cmp
  004bb	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  004bf	e9 2e 03 00 00	 jmp	 $LN63@unpack_cmp
$LN22@unpack_cmp:
$LN21@unpack_cmp:

; 2508 :     #endif
; 2509 : 
; 2510 :     /* ssize_t and size_t */
; 2511 :     case 'n': CMP_SINGLE(p, q, Py_ssize_t); return equal;

  004c4	41 b8 08 00 00
	00		 mov	 r8d, 8
  004ca	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  004d2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR x$22207[rsp]
  004da	e8 00 00 00 00	 call	 memcpy
  004df	41 b8 08 00 00
	00		 mov	 r8d, 8
  004e5	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  004ed	48 8d 4c 24 78	 lea	 rcx, QWORD PTR y$22208[rsp]
  004f2	e8 00 00 00 00	 call	 memcpy
  004f7	48 8b 44 24 78	 mov	 rax, QWORD PTR y$22208[rsp]
  004fc	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR x$22207[rsp], rax
  00504	75 0d		 jne	 SHORT $LN87@unpack_cmp
  00506	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv200[rsp], 1
  00511	eb 0b		 jmp	 SHORT $LN88@unpack_cmp
$LN87@unpack_cmp:
  00513	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv200[rsp], 0
$LN88@unpack_cmp:
  0051e	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv200[rsp]
  00525	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  00529	33 c0		 xor	 eax, eax
  0052b	85 c0		 test	 eax, eax
  0052d	75 95		 jne	 SHORT $LN21@unpack_cmp
  0052f	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  00533	e9 ba 02 00 00	 jmp	 $LN63@unpack_cmp
$LN18@unpack_cmp:
$LN17@unpack_cmp:

; 2512 :     case 'N': CMP_SINGLE(p, q, size_t); return equal;

  00538	41 b8 08 00 00
	00		 mov	 r8d, 8
  0053e	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00546	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR x$22215[rsp]
  0054e	e8 00 00 00 00	 call	 memcpy
  00553	41 b8 08 00 00
	00		 mov	 r8d, 8
  00559	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  00561	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR y$22216[rsp]
  00569	e8 00 00 00 00	 call	 memcpy
  0056e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR y$22216[rsp]
  00576	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR x$22215[rsp], rax
  0057e	75 0d		 jne	 SHORT $LN89@unpack_cmp
  00580	c7 84 24 f4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv209[rsp], 1
  0058b	eb 0b		 jmp	 SHORT $LN90@unpack_cmp
$LN89@unpack_cmp:
  0058d	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv209[rsp], 0
$LN90@unpack_cmp:
  00598	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv209[rsp]
  0059f	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  005a3	33 c0		 xor	 eax, eax
  005a5	85 c0		 test	 eax, eax
  005a7	75 8f		 jne	 SHORT $LN17@unpack_cmp
  005a9	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  005ad	e9 40 02 00 00	 jmp	 $LN63@unpack_cmp
$LN14@unpack_cmp:
$LN13@unpack_cmp:

; 2513 : 
; 2514 :     /* floats */
; 2515 :     /* XXX DBL_EPSILON? */
; 2516 :     case 'f': CMP_SINGLE(p, q, float); return equal;

  005b2	41 b8 04 00 00
	00		 mov	 r8d, 4
  005b8	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  005c0	48 8d 8c 24 9c
	00 00 00	 lea	 rcx, QWORD PTR x$22223[rsp]
  005c8	e8 00 00 00 00	 call	 memcpy
  005cd	41 b8 04 00 00
	00		 mov	 r8d, 4
  005d3	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  005db	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR y$22224[rsp]
  005e3	e8 00 00 00 00	 call	 memcpy
  005e8	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR x$22223[rsp]
  005f1	0f 2e 84 24 98
	00 00 00	 ucomiss xmm0, DWORD PTR y$22224[rsp]
  005f9	7a 0f		 jp	 SHORT $LN91@unpack_cmp
  005fb	75 0d		 jne	 SHORT $LN91@unpack_cmp
  005fd	c7 84 24 f8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv218[rsp], 1
  00608	eb 0b		 jmp	 SHORT $LN92@unpack_cmp
$LN91@unpack_cmp:
  0060a	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv218[rsp], 0
$LN92@unpack_cmp:
  00615	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv218[rsp]
  0061c	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  00620	33 c0		 xor	 eax, eax
  00622	85 c0		 test	 eax, eax
  00624	75 8c		 jne	 SHORT $LN13@unpack_cmp
  00626	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  0062a	e9 c3 01 00 00	 jmp	 $LN63@unpack_cmp
$LN10@unpack_cmp:
$LN9@unpack_cmp:

; 2517 :     case 'd': CMP_SINGLE(p, q, double); return equal;

  0062f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00635	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  0063d	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR x$22231[rsp]
  00645	e8 00 00 00 00	 call	 memcpy
  0064a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00650	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  00658	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR y$22232[rsp]
  00660	e8 00 00 00 00	 call	 memcpy
  00665	f2 0f 10 84 24
	a8 00 00 00	 movsdx	 xmm0, QWORD PTR x$22231[rsp]
  0066e	66 0f 2e 84 24
	a0 00 00 00	 ucomisd xmm0, QWORD PTR y$22232[rsp]
  00677	7a 0f		 jp	 SHORT $LN93@unpack_cmp
  00679	75 0d		 jne	 SHORT $LN93@unpack_cmp
  0067b	c7 84 24 fc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv227[rsp], 1
  00686	eb 0b		 jmp	 SHORT $LN94@unpack_cmp
$LN93@unpack_cmp:
  00688	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv227[rsp], 0
$LN94@unpack_cmp:
  00693	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR tv227[rsp]
  0069a	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  0069e	33 c0		 xor	 eax, eax
  006a0	85 c0		 test	 eax, eax
  006a2	75 8b		 jne	 SHORT $LN9@unpack_cmp
  006a4	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  006a8	e9 45 01 00 00	 jmp	 $LN63@unpack_cmp
$LN6@unpack_cmp:

; 2518 : 
; 2519 :     /* bytes object */
; 2520 :     case 'c': return *p == *q;

  006ad	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]
  006b5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  006b8	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR q$[rsp]
  006c0	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  006c3	3b c1		 cmp	 eax, ecx
  006c5	75 0d		 jne	 SHORT $LN95@unpack_cmp
  006c7	c7 84 24 00 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv232[rsp], 1
  006d2	eb 0b		 jmp	 SHORT $LN96@unpack_cmp
$LN95@unpack_cmp:
  006d4	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv232[rsp], 0
$LN96@unpack_cmp:
  006df	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR tv232[rsp]
  006e6	e9 07 01 00 00	 jmp	 $LN63@unpack_cmp
$LN5@unpack_cmp:
$LN4@unpack_cmp:

; 2521 : 
; 2522 :     /* pointer */
; 2523 :     case 'P': CMP_SINGLE(p, q, void *); return equal;

  006eb	41 b8 08 00 00
	00		 mov	 r8d, 8
  006f1	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  006f9	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR x$22240[rsp]
  00701	e8 00 00 00 00	 call	 memcpy
  00706	41 b8 08 00 00
	00		 mov	 r8d, 8
  0070c	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  00714	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR y$22241[rsp]
  0071c	e8 00 00 00 00	 call	 memcpy
  00721	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR y$22241[rsp]
  00729	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR x$22240[rsp], rax
  00731	75 0d		 jne	 SHORT $LN97@unpack_cmp
  00733	c7 84 24 04 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv240[rsp], 1
  0073e	eb 0b		 jmp	 SHORT $LN98@unpack_cmp
$LN97@unpack_cmp:
  00740	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv240[rsp], 0
$LN98@unpack_cmp:
  0074b	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv240[rsp]
  00752	89 44 24 20	 mov	 DWORD PTR equal$[rsp], eax
  00756	33 c0		 xor	 eax, eax
  00758	85 c0		 test	 eax, eax
  0075a	75 8f		 jne	 SHORT $LN4@unpack_cmp
  0075c	8b 44 24 20	 mov	 eax, DWORD PTR equal$[rsp]
  00760	e9 8d 00 00 00	 jmp	 $LN63@unpack_cmp
$LN1@unpack_cmp:

; 2524 : 
; 2525 :     /* use the struct module */
; 2526 :     case '_':
; 2527 :         assert(unpack_p);

  00765	48 83 bc 24 38
	01 00 00 00	 cmp	 QWORD PTR unpack_p$[rsp], 0
  0076e	75 1c		 jne	 SHORT $LN99@unpack_cmp
  00770	41 b8 df 09 00
	00		 mov	 r8d, 2527		; 000009dfH
  00776	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0077d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@NEJLDEDD@?$AAu?$AAn?$AAp?$AAa?$AAc?$AAk?$AA_?$AAp?$AA?$AA@
  00784	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0078a	33 c0		 xor	 eax, eax
$LN99@unpack_cmp:

; 2528 :         assert(unpack_q);

  0078c	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR unpack_q$[rsp], 0
  00795	75 1c		 jne	 SHORT $LN100@unpack_cmp
  00797	41 b8 e0 09 00
	00		 mov	 r8d, 2528		; 000009e0H
  0079d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  007a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@GMCHFDFG@?$AAu?$AAn?$AAp?$AAa?$AAc?$AAk?$AA_?$AAq?$AA?$AA@
  007ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  007b1	33 c0		 xor	 eax, eax
$LN100@unpack_cmp:

; 2529 :         return struct_unpack_cmp(p, q, unpack_p, unpack_q);

  007b3	4c 8b 8c 24 40
	01 00 00	 mov	 r9, QWORD PTR unpack_q$[rsp]
  007bb	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR unpack_p$[rsp]
  007c3	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  007cb	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  007d3	e8 00 00 00 00	 call	 struct_unpack_cmp
  007d8	eb 18		 jmp	 SHORT $LN63@unpack_cmp
$LN61@unpack_cmp:

; 2530 :     }
; 2531 : 
; 2532 :     /* NOT REACHED */
; 2533 :     PyErr_SetString(PyExc_RuntimeError,
; 2534 :         "memoryview: internal error in richcompare");

  007da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@JGBOLOHN@memoryview?3?5internal?5error?5in?5ri@
  007e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  007e8	e8 00 00 00 00	 call	 PyErr_SetString

; 2535 :     return MV_COMPARE_EX;

  007ed	b8 ff ff ff ff	 mov	 eax, -1
$LN63@unpack_cmp:

; 2536 : }

  007f2	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  007f9	c3		 ret	 0
  007fa	66 90		 npad	 2
$LN102@unpack_cmp:
  007fc	00 00 00 00	 DD	 $LN46@unpack_cmp
  00800	00 00 00 00	 DD	 $LN60@unpack_cmp
  00804	00 00 00 00	 DD	 $LN42@unpack_cmp
  00808	00 00 00 00	 DD	 $LN38@unpack_cmp
  0080c	00 00 00 00	 DD	 $LN34@unpack_cmp
  00810	00 00 00 00	 DD	 $LN18@unpack_cmp
  00814	00 00 00 00	 DD	 $LN5@unpack_cmp
  00818	00 00 00 00	 DD	 $LN26@unpack_cmp
  0081c	00 00 00 00	 DD	 $LN1@unpack_cmp
  00820	00 00 00 00	 DD	 $LN59@unpack_cmp
  00824	00 00 00 00	 DD	 $LN6@unpack_cmp
  00828	00 00 00 00	 DD	 $LN10@unpack_cmp
  0082c	00 00 00 00	 DD	 $LN14@unpack_cmp
  00830	00 00 00 00	 DD	 $LN58@unpack_cmp
  00834	00 00 00 00	 DD	 $LN54@unpack_cmp
  00838	00 00 00 00	 DD	 $LN50@unpack_cmp
  0083c	00 00 00 00	 DD	 $LN22@unpack_cmp
  00840	00 00 00 00	 DD	 $LN30@unpack_cmp
  00844	00 00 00 00	 DD	 $LN61@unpack_cmp
$LN101@unpack_cmp:
  00848	00		 DB	 0
  00849	12		 DB	 18
  0084a	12		 DB	 18
  0084b	01		 DB	 1
  0084c	12		 DB	 18
  0084d	12		 DB	 18
  0084e	12		 DB	 18
  0084f	12		 DB	 18
  00850	12		 DB	 18
  00851	02		 DB	 2
  00852	03		 DB	 3
  00853	12		 DB	 18
  00854	12		 DB	 18
  00855	04		 DB	 4
  00856	12		 DB	 18
  00857	05		 DB	 5
  00858	12		 DB	 18
  00859	06		 DB	 6
  0085a	07		 DB	 7
  0085b	12		 DB	 18
  0085c	12		 DB	 18
  0085d	12		 DB	 18
  0085e	12		 DB	 18
  0085f	12		 DB	 18
  00860	12		 DB	 18
  00861	12		 DB	 18
  00862	12		 DB	 18
  00863	12		 DB	 18
  00864	12		 DB	 18
  00865	12		 DB	 18
  00866	12		 DB	 18
  00867	12		 DB	 18
  00868	08		 DB	 8
  00869	12		 DB	 18
  0086a	12		 DB	 18
  0086b	09		 DB	 9
  0086c	0a		 DB	 10
  0086d	0b		 DB	 11
  0086e	12		 DB	 18
  0086f	0c		 DB	 12
  00870	12		 DB	 18
  00871	0d		 DB	 13
  00872	0e		 DB	 14
  00873	12		 DB	 18
  00874	12		 DB	 18
  00875	0f		 DB	 15
  00876	12		 DB	 18
  00877	10		 DB	 16
  00878	12		 DB	 18
  00879	12		 DB	 18
  0087a	11		 DB	 17
unpack_cmp ENDP
_TEXT	ENDS
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$struct_unpack_cmp DD imagerel struct_unpack_cmp
	DD	imagerel struct_unpack_cmp+158
	DD	imagerel $unwind$struct_unpack_cmp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$struct_unpack_cmp DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT struct_unpack_cmp
_TEXT	SEGMENT
w$ = 32
v$ = 40
ret$ = 48
p$ = 80
q$ = 88
unpack_p$ = 96
unpack_q$ = 104
struct_unpack_cmp PROC					; COMDAT

; 2438 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2439 :     PyObject *v, *w;
; 2440 :     int ret;
; 2441 : 
; 2442 :     /* At this point any exception from the struct module should not be
; 2443 :        StructError, since both formats have been accepted already. */
; 2444 :     v = struct_unpack_single(p, unpack_p);

  00018	48 8b 54 24 60	 mov	 rdx, QWORD PTR unpack_p$[rsp]
  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00022	e8 00 00 00 00	 call	 struct_unpack_single
  00027	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 2445 :     if (v == NULL)

  0002c	48 83 7c 24 28
	00		 cmp	 QWORD PTR v$[rsp], 0
  00032	75 07		 jne	 SHORT $LN2@struct_unp

; 2446 :         return MV_COMPARE_EX;

  00034	b8 ff ff ff ff	 mov	 eax, -1
  00039	eb 5e		 jmp	 SHORT $LN3@struct_unp
$LN2@struct_unp:

; 2447 : 
; 2448 :     w = struct_unpack_single(q, unpack_q);

  0003b	48 8b 54 24 68	 mov	 rdx, QWORD PTR unpack_q$[rsp]
  00040	48 8b 4c 24 58	 mov	 rcx, QWORD PTR q$[rsp]
  00045	e8 00 00 00 00	 call	 struct_unpack_single
  0004a	48 89 44 24 20	 mov	 QWORD PTR w$[rsp], rax

; 2449 :     if (w == NULL) {

  0004f	48 83 7c 24 20
	00		 cmp	 QWORD PTR w$[rsp], 0
  00055	75 11		 jne	 SHORT $LN1@struct_unp

; 2450 :         Py_DECREF(v);

  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  0005c	e8 00 00 00 00	 call	 _Py_DecRef

; 2451 :         return MV_COMPARE_EX;

  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	eb 31		 jmp	 SHORT $LN3@struct_unp
$LN1@struct_unp:

; 2452 :     }
; 2453 : 
; 2454 :     /* MV_COMPARE_EX == -1: exceptions are preserved */
; 2455 :     ret = PyObject_RichCompareBool(v, w, Py_EQ);

  00068	41 b8 02 00 00
	00		 mov	 r8d, 2
  0006e	48 8b 54 24 20	 mov	 rdx, QWORD PTR w$[rsp]
  00073	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  00078	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0007d	89 44 24 30	 mov	 DWORD PTR ret$[rsp], eax

; 2456 :     Py_DECREF(v);

  00081	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  00086	e8 00 00 00 00	 call	 _Py_DecRef

; 2457 :     Py_DECREF(w);

  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR w$[rsp]
  00090	e8 00 00 00 00	 call	 _Py_DecRef

; 2458 : 
; 2459 :     return ret;

  00095	8b 44 24 30	 mov	 eax, DWORD PTR ret$[rsp]
$LN3@struct_unp:

; 2460 : }

  00099	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009d	c3		 ret	 0
struct_unpack_cmp ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$struct_unpack_single DD imagerel struct_unpack_single
	DD	imagerel struct_unpack_single+147
	DD	imagerel $unwind$struct_unpack_single
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$struct_unpack_single DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT struct_unpack_single
_TEXT	SEGMENT
v$ = 32
tmp$21742 = 40
ptr$ = 64
x$ = 72
struct_unpack_single PROC				; COMDAT

; 1963 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1964 :     PyObject *v;
; 1965 : 
; 1966 :     memcpy(x->item, ptr, x->itemsize);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  00013	4c 8b 40 18	 mov	 r8, QWORD PTR [rax+24]
  00017	48 8b 54 24 40	 mov	 rdx, QWORD PTR ptr$[rsp]
  0001c	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  00021	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00025	e8 00 00 00 00	 call	 memcpy

; 1967 :     v = PyObject_CallFunctionObjArgs(x->unpack_from, x->mview, NULL);

  0002a	45 33 c0	 xor	 r8d, r8d
  0002d	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  00032	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  0003b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003e	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00043	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1968 :     if (v == NULL)

  00048	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  0004e	75 04		 jne	 SHORT $LN2@struct_unp@2

; 1969 :         return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	eb 3a		 jmp	 SHORT $LN3@struct_unp@2
$LN2@struct_unp@2:

; 1970 : 
; 1971 :     if (PyTuple_GET_SIZE(v) == 1) {

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00059	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  0005e	75 29		 jne	 SHORT $LN1@struct_unp@2

; 1972 :         PyObject *tmp = PyTuple_GET_ITEM(v, 0);

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00065	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00069	48 89 44 24 28	 mov	 QWORD PTR tmp$21742[rsp], rax

; 1973 :         Py_INCREF(tmp);

  0006e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmp$21742[rsp]
  00073	e8 00 00 00 00	 call	 _Py_IncRef

; 1974 :         Py_DECREF(v);

  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0007d	e8 00 00 00 00	 call	 _Py_DecRef

; 1975 :         return tmp;

  00082	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$21742[rsp]
  00087	eb 05		 jmp	 SHORT $LN3@struct_unp@2
$LN1@struct_unp@2:

; 1976 :     }
; 1977 : 
; 1978 :     return v;

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN3@struct_unp@2:

; 1979 : }

  0008e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00092	c3		 ret	 0
struct_unpack_single ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmp_base DD imagerel cmp_base
	DD	imagerel cmp_base+343
	DD	imagerel $unwind$cmp_base
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmp_base DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cmp_base
_TEXT	SEGMENT
i$ = 48
equal$ = 56
xp$22277 = 64
xq$22279 = 72
tv71 = 80
tv75 = 88
p$ = 112
q$ = 120
shape$ = 128
pstrides$ = 136
psuboffsets$ = 144
qstrides$ = 152
qsuboffsets$ = 160
fmt$ = 168
unpack_p$ = 176
unpack_q$ = 184
cmp_base PROC						; COMDAT

; 2544 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2545 :     Py_ssize_t i;
; 2546 :     int equal;
; 2547 : 
; 2548 :     for (i = 0; i < shape[0]; p+=pstrides[0], q+=qstrides[0], i++) {

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00021	eb 43		 jmp	 SHORT $LN4@cmp_base
$LN3@cmp_base:
  00023	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pstrides$[rsp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  00033	48 03 c8	 add	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax
  0003e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qstrides$[rsp]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00049	48 8b 4c 24 78	 mov	 rcx, QWORD PTR q$[rsp]
  0004e	48 03 c8	 add	 rcx, rax
  00051	48 8b c1	 mov	 rax, rcx
  00054	48 89 44 24 78	 mov	 QWORD PTR q$[rsp], rax
  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0005e	48 ff c0	 inc	 rax
  00061	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN4@cmp_base:
  00066	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shape$[rsp]
  0006e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00071	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00076	0f 8d d1 00 00
	00		 jge	 $LN2@cmp_base

; 2549 :         const char *xp = ADJUST_PTR(p, psuboffsets);

  0007c	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR psuboffsets$[rsp], 0
  00085	74 28		 je	 SHORT $LN7@cmp_base
  00087	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR psuboffsets$[rsp]
  0008f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00093	7c 1a		 jl	 SHORT $LN7@cmp_base
  00095	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  0009a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR psuboffsets$[rsp]
  000a5	48 03 01	 add	 rax, QWORD PTR [rcx]
  000a8	48 89 44 24 50	 mov	 QWORD PTR tv71[rsp], rax
  000ad	eb 0a		 jmp	 SHORT $LN8@cmp_base
$LN7@cmp_base:
  000af	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  000b4	48 89 44 24 50	 mov	 QWORD PTR tv71[rsp], rax
$LN8@cmp_base:
  000b9	48 8b 44 24 50	 mov	 rax, QWORD PTR tv71[rsp]
  000be	48 89 44 24 40	 mov	 QWORD PTR xp$22277[rsp], rax

; 2550 :         const char *xq = ADJUST_PTR(q, qsuboffsets);

  000c3	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR qsuboffsets$[rsp], 0
  000cc	74 28		 je	 SHORT $LN9@cmp_base
  000ce	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qsuboffsets$[rsp]
  000d6	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000da	7c 1a		 jl	 SHORT $LN9@cmp_base
  000dc	48 8b 44 24 78	 mov	 rax, QWORD PTR q$[rsp]
  000e1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR qsuboffsets$[rsp]
  000ec	48 03 01	 add	 rax, QWORD PTR [rcx]
  000ef	48 89 44 24 58	 mov	 QWORD PTR tv75[rsp], rax
  000f4	eb 0a		 jmp	 SHORT $LN10@cmp_base
$LN9@cmp_base:
  000f6	48 8b 44 24 78	 mov	 rax, QWORD PTR q$[rsp]
  000fb	48 89 44 24 58	 mov	 QWORD PTR tv75[rsp], rax
$LN10@cmp_base:
  00100	48 8b 44 24 58	 mov	 rax, QWORD PTR tv75[rsp]
  00105	48 89 44 24 48	 mov	 QWORD PTR xq$22279[rsp], rax

; 2551 :         equal = unpack_cmp(xp, xq, fmt, unpack_p, unpack_q);

  0010a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR unpack_q$[rsp]
  00112	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00117	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR unpack_p$[rsp]
  0011f	44 0f b6 84 24
	a8 00 00 00	 movzx	 r8d, BYTE PTR fmt$[rsp]
  00128	48 8b 54 24 48	 mov	 rdx, QWORD PTR xq$22279[rsp]
  0012d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR xp$22277[rsp]
  00132	e8 00 00 00 00	 call	 unpack_cmp
  00137	89 44 24 38	 mov	 DWORD PTR equal$[rsp], eax

; 2552 :         if (equal <= 0)

  0013b	83 7c 24 38 00	 cmp	 DWORD PTR equal$[rsp], 0
  00140	7f 06		 jg	 SHORT $LN1@cmp_base

; 2553 :             return equal;

  00142	8b 44 24 38	 mov	 eax, DWORD PTR equal$[rsp]
  00146	eb 0a		 jmp	 SHORT $LN5@cmp_base
$LN1@cmp_base:

; 2554 :     }

  00148	e9 d6 fe ff ff	 jmp	 $LN3@cmp_base
$LN2@cmp_base:

; 2555 : 
; 2556 :     return 1;

  0014d	b8 01 00 00 00	 mov	 eax, 1
$LN5@cmp_base:

; 2557 : }

  00152	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00156	c3		 ret	 0
cmp_base ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@DHPILDDI@?$AAq?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@BDHKOCAO@?$AAp?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmp_rec DD imagerel cmp_rec
	DD	imagerel cmp_rec+863
	DD	imagerel $unwind$cmp_rec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmp_rec DD 021b01H
	DD	015011bH
xdata	ENDS
;	COMDAT ??_C@_1CC@DHPILDDI@?$AAq?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DHPILDDI@?$AAq?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'q'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BDHKOCAO@?$AAp?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@BDHKOCAO@?$AAp?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'p'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cmp_rec
_TEXT	SEGMENT
i$ = 96
equal$ = 104
xp$22321 = 112
xq$22323 = 120
tv135 = 128
tv139 = 136
tv146 = 144
tv152 = 152
p$ = 176
q$ = 184
ndim$ = 192
shape$ = 200
pstrides$ = 208
psuboffsets$ = 216
qstrides$ = 224
qsuboffsets$ = 232
fmt$ = 240
unpack_p$ = 248
unpack_q$ = 256
cmp_rec	PROC						; COMDAT

; 2567 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2568 :     Py_ssize_t i;
; 2569 :     int equal;
; 2570 : 
; 2571 :     assert(ndim >= 1);

  0001b	48 83 bc 24 c0
	00 00 00 01	 cmp	 QWORD PTR ndim$[rsp], 1
  00024	7d 1c		 jge	 SHORT $LN8@cmp_rec
  00026	41 b8 0b 0a 00
	00		 mov	 r8d, 2571		; 00000a0bH
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@MKFAAJFI@?$AAn?$AAd?$AAi?$AAm?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00040	33 c0		 xor	 eax, eax
$LN8@cmp_rec:

; 2572 :     assert(shape != NULL);

  00042	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR shape$[rsp], 0
  0004b	75 1c		 jne	 SHORT $LN9@cmp_rec
  0004d	41 b8 0c 0a 00
	00		 mov	 r8d, 2572		; 00000a0cH
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@EBIOKAGI@?$AAs?$AAh?$AAa?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00067	33 c0		 xor	 eax, eax
$LN9@cmp_rec:

; 2573 :     assert(pstrides != NULL);

  00069	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR pstrides$[rsp], 0
  00072	75 1c		 jne	 SHORT $LN10@cmp_rec
  00074	41 b8 0d 0a 00
	00		 mov	 r8d, 2573		; 00000a0dH
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@BDHKOCAO@?$AAp?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008e	33 c0		 xor	 eax, eax
$LN10@cmp_rec:

; 2574 :     assert(qstrides != NULL);

  00090	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR qstrides$[rsp], 0
  00099	75 1c		 jne	 SHORT $LN11@cmp_rec
  0009b	41 b8 0e 0a 00
	00		 mov	 r8d, 2574		; 00000a0eH
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@KDOFNAMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@DHPILDDI@?$AAq?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b5	33 c0		 xor	 eax, eax
$LN11@cmp_rec:

; 2575 : 
; 2576 :     if (ndim == 1) {

  000b7	48 83 bc 24 c0
	00 00 00 01	 cmp	 QWORD PTR ndim$[rsp], 1
  000c0	75 77		 jne	 SHORT $LN5@cmp_rec

; 2577 :         return cmp_base(p, q, shape,
; 2578 :                         pstrides, psuboffsets,
; 2579 :                         qstrides, qsuboffsets,
; 2580 :                         fmt, unpack_p, unpack_q);

  000c2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR unpack_q$[rsp]
  000ca	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000cf	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unpack_p$[rsp]
  000d7	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000dc	0f b6 84 24 f0
	00 00 00	 movzx	 eax, BYTE PTR fmt$[rsp]
  000e4	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  000e8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR qsuboffsets$[rsp]
  000f0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000f5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR qstrides$[rsp]
  000fd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00102	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR psuboffsets$[rsp]
  0010a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010f	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR pstrides$[rsp]
  00117	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR shape$[rsp]
  0011f	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  00127	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  0012f	e8 00 00 00 00	 call	 cmp_base
  00134	e9 1e 02 00 00	 jmp	 $LN6@cmp_rec
$LN5@cmp_rec:

; 2581 :     }
; 2582 : 
; 2583 :     for (i = 0; i < shape[0]; p+=pstrides[0], q+=qstrides[0], i++) {

  00139	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00142	eb 4f		 jmp	 SHORT $LN4@cmp_rec
$LN3@cmp_rec:
  00144	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pstrides$[rsp]
  0014c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0014f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00157	48 03 c8	 add	 rcx, rax
  0015a	48 8b c1	 mov	 rax, rcx
  0015d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR p$[rsp], rax
  00165	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR qstrides$[rsp]
  0016d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00170	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR q$[rsp]
  00178	48 03 c8	 add	 rcx, rax
  0017b	48 8b c1	 mov	 rax, rcx
  0017e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR q$[rsp], rax
  00186	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  0018b	48 ff c0	 inc	 rax
  0018e	48 89 44 24 60	 mov	 QWORD PTR i$[rsp], rax
$LN4@cmp_rec:
  00193	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR shape$[rsp]
  0019b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019e	48 39 44 24 60	 cmp	 QWORD PTR i$[rsp], rax
  001a3	0f 8d a9 01 00
	00		 jge	 $LN2@cmp_rec

; 2584 :         const char *xp = ADJUST_PTR(p, psuboffsets);

  001a9	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR psuboffsets$[rsp], 0
  001b2	74 2e		 je	 SHORT $LN12@cmp_rec
  001b4	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR psuboffsets$[rsp]
  001bc	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001c0	7c 20		 jl	 SHORT $LN12@cmp_rec
  001c2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cd	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR psuboffsets$[rsp]
  001d5	48 03 01	 add	 rax, QWORD PTR [rcx]
  001d8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  001e0	eb 10		 jmp	 SHORT $LN13@cmp_rec
$LN12@cmp_rec:
  001e2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001ea	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
$LN13@cmp_rec:
  001f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv135[rsp]
  001fa	48 89 44 24 70	 mov	 QWORD PTR xp$22321[rsp], rax

; 2585 :         const char *xq = ADJUST_PTR(q, qsuboffsets);

  001ff	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR qsuboffsets$[rsp], 0
  00208	74 2e		 je	 SHORT $LN14@cmp_rec
  0020a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR qsuboffsets$[rsp]
  00212	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00216	7c 20		 jl	 SHORT $LN14@cmp_rec
  00218	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  00220	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00223	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR qsuboffsets$[rsp]
  0022b	48 03 01	 add	 rax, QWORD PTR [rcx]
  0022e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
  00236	eb 10		 jmp	 SHORT $LN15@cmp_rec
$LN14@cmp_rec:
  00238	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  00240	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
$LN15@cmp_rec:
  00248	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv139[rsp]
  00250	48 89 44 24 78	 mov	 QWORD PTR xq$22323[rsp], rax

; 2586 :         equal = cmp_rec(xp, xq, ndim-1, shape+1,
; 2587 :                         pstrides+1, psuboffsets ? psuboffsets+1 : NULL,
; 2588 :                         qstrides+1, qsuboffsets ? qsuboffsets+1 : NULL,
; 2589 :                         fmt, unpack_p, unpack_q);

  00255	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR qsuboffsets$[rsp], 0
  0025e	74 16		 je	 SHORT $LN16@cmp_rec
  00260	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR qsuboffsets$[rsp]
  00268	48 83 c0 08	 add	 rax, 8
  0026c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv146[rsp], rax
  00274	eb 0c		 jmp	 SHORT $LN17@cmp_rec
$LN16@cmp_rec:
  00276	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv146[rsp], 0
$LN17@cmp_rec:
  00282	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR psuboffsets$[rsp], 0
  0028b	74 16		 je	 SHORT $LN18@cmp_rec
  0028d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR psuboffsets$[rsp]
  00295	48 83 c0 08	 add	 rax, 8
  00299	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv152[rsp], rax
  002a1	eb 0c		 jmp	 SHORT $LN19@cmp_rec
$LN18@cmp_rec:
  002a3	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv152[rsp], 0
$LN19@cmp_rec:
  002af	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR qstrides$[rsp]
  002b7	48 83 c0 08	 add	 rax, 8
  002bb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pstrides$[rsp]
  002c3	48 83 c1 08	 add	 rcx, 8
  002c7	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR shape$[rsp]
  002cf	48 83 c2 08	 add	 rdx, 8
  002d3	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR ndim$[rsp]
  002db	49 ff c8	 dec	 r8
  002de	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR unpack_q$[rsp]
  002e6	4c 89 4c 24 50	 mov	 QWORD PTR [rsp+80], r9
  002eb	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR unpack_p$[rsp]
  002f3	4c 89 4c 24 48	 mov	 QWORD PTR [rsp+72], r9
  002f8	44 0f b6 8c 24
	f0 00 00 00	 movzx	 r9d, BYTE PTR fmt$[rsp]
  00301	44 88 4c 24 40	 mov	 BYTE PTR [rsp+64], r9b
  00306	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR tv146[rsp]
  0030e	4c 89 4c 24 38	 mov	 QWORD PTR [rsp+56], r9
  00313	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00318	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv152[rsp]
  00320	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00325	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0032a	4c 8b ca	 mov	 r9, rdx
  0032d	48 8b 54 24 78	 mov	 rdx, QWORD PTR xq$22323[rsp]
  00332	48 8b 4c 24 70	 mov	 rcx, QWORD PTR xp$22321[rsp]
  00337	e8 00 00 00 00	 call	 cmp_rec
  0033c	89 44 24 68	 mov	 DWORD PTR equal$[rsp], eax

; 2590 :         if (equal <= 0)

  00340	83 7c 24 68 00	 cmp	 DWORD PTR equal$[rsp], 0
  00345	7f 06		 jg	 SHORT $LN1@cmp_rec

; 2591 :             return equal;

  00347	8b 44 24 68	 mov	 eax, DWORD PTR equal$[rsp]
  0034b	eb 0a		 jmp	 SHORT $LN6@cmp_rec
$LN1@cmp_rec:

; 2592 :     }

  0034d	e9 f2 fd ff ff	 jmp	 $LN3@cmp_rec
$LN2@cmp_rec:

; 2593 : 
; 2594 :     return 1;

  00352	b8 01 00 00 00	 mov	 eax, 1
$LN6@cmp_rec:

; 2595 : }

  00357	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0035e	c3		 ret	 0
cmp_rec	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@FBHGAFDH@memoryview?3?5hashing?5is?5restricte@ ; `string'
PUBLIC	??_C@_0CH@HDKCDPKN@cannot?5hash?5writable?5memoryview?5@ ; `string'
EXTRN	_Py_HashBytes:PROC
EXTRN	PyObject_Hash:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_hash DD imagerel memory_hash
	DD	imagerel memory_hash+468
	DD	imagerel $unwind$memory_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_hash DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0DN@FBHGAFDH@memoryview?3?5hashing?5is?5restricte@
CONST	SEGMENT
??_C@_0DN@FBHGAFDH@memoryview?3?5hashing?5is?5restricte@ DB 'memoryview: '
	DB	'hashing is restricted to formats ''B'', ''b'' or ''c''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HDKCDPKN@cannot?5hash?5writable?5memoryview?5@
CONST	SEGMENT
??_C@_0CH@HDKCDPKN@cannot?5hash?5writable?5memoryview?5@ DB 'cannot hash '
	DB	'writable memoryview object', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT memory_hash
_TEXT	SEGMENT
fmt$22405 = 32
view$22402 = 40
ret$22404 = 48
mem$22403 = 56
self$ = 80
memory_hash PROC					; COMDAT

; 2707 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2708 :     if (self->hash == -1) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 78 ff	 cmp	 QWORD PTR [rax+120], -1
  00013	0f 85 ad 01 00
	00		 jne	 $LN11@memory_has

; 2709 :         Py_buffer *view = &self->view;

  00019	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001e	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00024	48 89 44 24 28	 mov	 QWORD PTR view$22402[rsp], rax

; 2710 :         char *mem = view->buf;

  00029	48 8b 44 24 28	 mov	 rax, QWORD PTR view$22402[rsp]
  0002e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00031	48 89 44 24 38	 mov	 QWORD PTR mem$22403[rsp], rax

; 2711 :         Py_ssize_t ret;
; 2712 :         char fmt;
; 2713 : 
; 2714 :         CHECK_RELEASED_INT(self);

  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0003b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00041	83 e0 01	 and	 eax, 1
  00044	85 c0		 test	 eax, eax
  00046	75 13		 jne	 SHORT $LN9@memory_has
  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0004d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00051	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00054	83 e0 01	 and	 eax, 1
  00057	85 c0		 test	 eax, eax
  00059	74 1f		 je	 SHORT $LN10@memory_has
$LN9@memory_has:
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00062	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00069	e8 00 00 00 00	 call	 PyErr_SetString
  0006e	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00075	e9 55 01 00 00	 jmp	 $LN12@memory_has
$LN10@memory_has:

; 2715 : 
; 2716 :         if (!view->readonly) {

  0007a	48 8b 44 24 28	 mov	 rax, QWORD PTR view$22402[rsp]
  0007f	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00083	75 1f		 jne	 SHORT $LN8@memory_has

; 2717 :             PyErr_SetString(PyExc_ValueError,
; 2718 :                 "cannot hash writable memoryview object");

  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@HDKCDPKN@cannot?5hash?5writable?5memoryview?5@
  0008c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00093	e8 00 00 00 00	 call	 PyErr_SetString

; 2719 :             return -1;

  00098	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0009f	e9 2b 01 00 00	 jmp	 $LN12@memory_has
$LN8@memory_has:

; 2720 :         }
; 2721 :         ret = get_native_fmtchar(&fmt, view->format);

  000a4	48 8b 44 24 28	 mov	 rax, QWORD PTR view$22402[rsp]
  000a9	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  000ad	48 8d 4c 24 20	 lea	 rcx, QWORD PTR fmt$22405[rsp]
  000b2	e8 00 00 00 00	 call	 get_native_fmtchar
  000b7	48 89 44 24 30	 mov	 QWORD PTR ret$22404[rsp], rax

; 2722 :         if (ret < 0 || !IS_BYTE_FORMAT(fmt)) {

  000bc	48 83 7c 24 30
	00		 cmp	 QWORD PTR ret$22404[rsp], 0
  000c2	7c 1e		 jl	 SHORT $LN6@memory_has
  000c4	0f be 44 24 20	 movsx	 eax, BYTE PTR fmt$22405[rsp]
  000c9	83 f8 62	 cmp	 eax, 98			; 00000062H
  000cc	74 33		 je	 SHORT $LN7@memory_has
  000ce	0f be 44 24 20	 movsx	 eax, BYTE PTR fmt$22405[rsp]
  000d3	83 f8 42	 cmp	 eax, 66			; 00000042H
  000d6	74 29		 je	 SHORT $LN7@memory_has
  000d8	0f be 44 24 20	 movsx	 eax, BYTE PTR fmt$22405[rsp]
  000dd	83 f8 63	 cmp	 eax, 99			; 00000063H
  000e0	74 1f		 je	 SHORT $LN7@memory_has
$LN6@memory_has:

; 2723 :             PyErr_SetString(PyExc_ValueError,
; 2724 :                 "memoryview: hashing is restricted to formats 'B', 'b' or 'c'");

  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@FBHGAFDH@memoryview?3?5hashing?5is?5restricte@
  000e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000f0	e8 00 00 00 00	 call	 PyErr_SetString

; 2725 :             return -1;

  000f5	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000fc	e9 ce 00 00 00	 jmp	 $LN12@memory_has
$LN7@memory_has:

; 2726 :         }
; 2727 :         if (view->obj != NULL && PyObject_Hash(view->obj) == -1) {

  00101	48 8b 44 24 28	 mov	 rax, QWORD PTR view$22402[rsp]
  00106	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0010b	74 20		 je	 SHORT $LN5@memory_has
  0010d	48 8b 44 24 28	 mov	 rax, QWORD PTR view$22402[rsp]
  00112	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00116	e8 00 00 00 00	 call	 PyObject_Hash
  0011b	48 83 f8 ff	 cmp	 rax, -1
  0011f	75 0c		 jne	 SHORT $LN5@memory_has

; 2728 :             /* Keep the original error message */
; 2729 :             return -1;

  00121	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00128	e9 a2 00 00 00	 jmp	 $LN12@memory_has
$LN5@memory_has:

; 2730 :         }
; 2731 : 
; 2732 :         if (!MV_C_CONTIGUOUS(self->flags)) {

  0012d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00132	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00138	83 e0 0a	 and	 eax, 10
  0013b	85 c0		 test	 eax, eax
  0013d	75 52		 jne	 SHORT $LN4@memory_has

; 2733 :             mem = PyMem_Malloc(view->len);

  0013f	48 8b 44 24 28	 mov	 rax, QWORD PTR view$22402[rsp]
  00144	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00148	e8 00 00 00 00	 call	 PyMem_Malloc
  0014d	48 89 44 24 38	 mov	 QWORD PTR mem$22403[rsp], rax

; 2734 :             if (mem == NULL) {

  00152	48 83 7c 24 38
	00		 cmp	 QWORD PTR mem$22403[rsp], 0
  00158	75 0e		 jne	 SHORT $LN3@memory_has

; 2735 :                 PyErr_NoMemory();

  0015a	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2736 :                 return -1;

  0015f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00166	eb 67		 jmp	 SHORT $LN12@memory_has
$LN3@memory_has:

; 2737 :             }
; 2738 :             if (buffer_to_contiguous(mem, view, 'C') < 0) {

  00168	41 b0 43	 mov	 r8b, 67			; 00000043H
  0016b	48 8b 54 24 28	 mov	 rdx, QWORD PTR view$22402[rsp]
  00170	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mem$22403[rsp]
  00175	e8 00 00 00 00	 call	 buffer_to_contiguous
  0017a	85 c0		 test	 eax, eax
  0017c	7d 13		 jge	 SHORT $LN2@memory_has

; 2739 :                 PyMem_Free(mem);

  0017e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mem$22403[rsp]
  00183	e8 00 00 00 00	 call	 PyMem_Free

; 2740 :                 return -1;

  00188	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0018f	eb 3e		 jmp	 SHORT $LN12@memory_has
$LN2@memory_has:
$LN4@memory_has:

; 2741 :             }
; 2742 :         }
; 2743 : 
; 2744 :         /* Can't fail */
; 2745 :         self->hash = _Py_HashBytes((unsigned char *)mem, view->len);

  00191	48 8b 44 24 28	 mov	 rax, QWORD PTR view$22402[rsp]
  00196	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0019a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mem$22403[rsp]
  0019f	e8 00 00 00 00	 call	 _Py_HashBytes
  001a4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  001a9	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 2746 : 
; 2747 :         if (mem != view->buf)

  001ad	48 8b 44 24 28	 mov	 rax, QWORD PTR view$22402[rsp]
  001b2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b5	48 39 44 24 38	 cmp	 QWORD PTR mem$22403[rsp], rax
  001ba	74 0a		 je	 SHORT $LN1@memory_has

; 2748 :             PyMem_Free(mem);

  001bc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mem$22403[rsp]
  001c1	e8 00 00 00 00	 call	 PyMem_Free
$LN1@memory_has:
$LN11@memory_has:

; 2749 :     }
; 2750 : 
; 2751 :     return self->hash;

  001c6	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001cb	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
$LN12@memory_has:

; 2752 : }

  001cf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001d3	c3		 ret	 0
memory_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_obj_get DD imagerel memory_obj_get
	DD	imagerel memory_obj_get+146
	DD	imagerel $unwind$memory_obj_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_obj_get DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_obj_get
_TEXT	SEGMENT
view$ = 32
self$ = 64
memory_obj_get PROC					; COMDAT

; 2785 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2786 :     Py_buffer *view = &self->view;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00014	48 89 44 24 20	 mov	 QWORD PTR view$[rsp], rax

; 2787 : 
; 2788 :     CHECK_RELEASED(self);

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0001e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00024	83 e0 01	 and	 eax, 1
  00027	85 c0		 test	 eax, eax
  00029	75 13		 jne	 SHORT $LN2@memory_obj
  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00030	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00034	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00037	83 e0 01	 and	 eax, 1
  0003a	85 c0		 test	 eax, eax
  0003c	74 17		 je	 SHORT $LN3@memory_obj
$LN2@memory_obj:
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0004c	e8 00 00 00 00	 call	 PyErr_SetString
  00051	33 c0		 xor	 eax, eax
  00053	eb 38		 jmp	 SHORT $LN4@memory_obj
$LN3@memory_obj:

; 2789 :     if (view->obj == NULL) {

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  0005a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0005f	75 15		 jne	 SHORT $LN1@memory_obj

; 2790 :         Py_RETURN_NONE;

  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00068	e8 00 00 00 00	 call	 _Py_IncRef
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00074	eb 17		 jmp	 SHORT $LN4@memory_obj
$LN1@memory_obj:

; 2791 :     }
; 2792 :     Py_INCREF(view->obj);

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  0007b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0007f	e8 00 00 00 00	 call	 _Py_IncRef

; 2793 :     return view->obj;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  00089	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN4@memory_obj:

; 2794 : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
memory_obj_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_nbytes_get DD imagerel memory_nbytes_get
	DD	imagerel memory_nbytes_get+91
	DD	imagerel $unwind$memory_nbytes_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_nbytes_get DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_nbytes_get
_TEXT	SEGMENT
self$ = 48
memory_nbytes_get PROC					; COMDAT

; 2798 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2799 :     CHECK_RELEASED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 13		 jne	 SHORT $LN1@memory_nby
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 17		 je	 SHORT $LN2@memory_nby
$LN1@memory_nby:
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	e8 00 00 00 00	 call	 PyErr_SetString
  00041	33 c0		 xor	 eax, eax
  00043	eb 11		 jmp	 SHORT $LN3@memory_nby
$LN2@memory_nby:

; 2800 :     return PyLong_FromSsize_t(self->view.len);

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  00051	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN3@memory_nby:

; 2801 : }

  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
memory_nbytes_get ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_format_get DD imagerel memory_format_get
	DD	imagerel memory_format_get+91
	DD	imagerel $unwind$memory_format_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_format_get DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_format_get
_TEXT	SEGMENT
self$ = 48
memory_format_get PROC					; COMDAT

; 2805 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2806 :     CHECK_RELEASED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 13		 jne	 SHORT $LN1@memory_for@2
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 17		 je	 SHORT $LN2@memory_for@2
$LN1@memory_for@2:
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	e8 00 00 00 00	 call	 PyErr_SetString
  00041	33 c0		 xor	 eax, eax
  00043	eb 11		 jmp	 SHORT $LN3@memory_for@2
$LN2@memory_for@2:

; 2807 :     return PyUnicode_FromString(self->view.format);

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 88 b8 00
	00 00		 mov	 rcx, QWORD PTR [rax+184]
  00051	e8 00 00 00 00	 call	 PyUnicode_FromString
$LN3@memory_for@2:

; 2808 : }

  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
memory_format_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_itemsize_get DD imagerel memory_itemsize_get
	DD	imagerel memory_itemsize_get+91
	DD	imagerel $unwind$memory_itemsize_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_itemsize_get DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_itemsize_get
_TEXT	SEGMENT
self$ = 48
memory_itemsize_get PROC				; COMDAT

; 2812 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2813 :     CHECK_RELEASED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 13		 jne	 SHORT $LN1@memory_ite@2
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 17		 je	 SHORT $LN2@memory_ite@2
$LN1@memory_ite@2:
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	e8 00 00 00 00	 call	 PyErr_SetString
  00041	33 c0		 xor	 eax, eax
  00043	eb 11		 jmp	 SHORT $LN3@memory_ite@2
$LN2@memory_ite@2:

; 2814 :     return PyLong_FromSsize_t(self->view.itemsize);

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  00051	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN3@memory_ite@2:

; 2815 : }

  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
memory_itemsize_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_shape_get DD imagerel memory_shape_get
	DD	imagerel memory_shape_get+102
	DD	imagerel $unwind$memory_shape_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_shape_get DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_shape_get
_TEXT	SEGMENT
self$ = 48
memory_shape_get PROC					; COMDAT

; 2819 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2820 :     CHECK_RELEASED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 13		 jne	 SHORT $LN1@memory_sha
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 17		 je	 SHORT $LN2@memory_sha
$LN1@memory_sha:
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	e8 00 00 00 00	 call	 PyErr_SetString
  00041	33 c0		 xor	 eax, eax
  00043	eb 1c		 jmp	 SHORT $LN3@memory_sha
$LN2@memory_sha:

; 2821 :     return _IntTupleFromSsizet(self->view.ndim, self->view.shape);

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 90 c0 00
	00 00		 mov	 rdx, QWORD PTR [rax+192]
  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00056	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [rax+180]
  0005c	e8 00 00 00 00	 call	 _IntTupleFromSsizet
$LN3@memory_sha:

; 2822 : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
memory_shape_get ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_IntTupleFromSsizet DD imagerel _IntTupleFromSsizet
	DD	imagerel _IntTupleFromSsizet+171
	DD	imagerel $unwind$_IntTupleFromSsizet
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_IntTupleFromSsizet DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _IntTupleFromSsizet
_TEXT	SEGMENT
i$ = 32
intTuple$ = 40
o$ = 48
len$ = 80
vals$ = 88
_IntTupleFromSsizet PROC				; COMDAT

; 2761 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2762 :     int i;
; 2763 :     PyObject *o;
; 2764 :     PyObject *intTuple;
; 2765 : 
; 2766 :     if (vals == NULL)

  0000d	48 83 7c 24 58
	00		 cmp	 QWORD PTR vals$[rsp], 0
  00013	75 0c		 jne	 SHORT $LN6@IntTupleFr

; 2767 :         return PyTuple_New(0);

  00015	33 c9		 xor	 ecx, ecx
  00017	e8 00 00 00 00	 call	 PyTuple_New
  0001c	e9 85 00 00 00	 jmp	 $LN7@IntTupleFr
$LN6@IntTupleFr:

; 2768 : 
; 2769 :     intTuple = PyTuple_New(len);

  00021	48 63 44 24 50	 movsxd	 rax, DWORD PTR len$[rsp]
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 PyTuple_New
  0002e	48 89 44 24 28	 mov	 QWORD PTR intTuple$[rsp], rax

; 2770 :     if (!intTuple)

  00033	48 83 7c 24 28
	00		 cmp	 QWORD PTR intTuple$[rsp], 0
  00039	75 04		 jne	 SHORT $LN5@IntTupleFr

; 2771 :         return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 67		 jmp	 SHORT $LN7@IntTupleFr
$LN5@IntTupleFr:

; 2772 :     for (i=0; i<len; i++) {

  0003f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00047	eb 0a		 jmp	 SHORT $LN4@IntTupleFr
$LN3@IntTupleFr:
  00049	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0004d	ff c0		 inc	 eax
  0004f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@IntTupleFr:
  00053	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  00057	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0005b	7d 44		 jge	 SHORT $LN2@IntTupleFr

; 2773 :         o = PyLong_FromSsize_t(vals[i]);

  0005d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00062	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vals$[rsp]
  00067	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0006b	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00070	48 89 44 24 30	 mov	 QWORD PTR o$[rsp], rax

; 2774 :         if (!o) {

  00075	48 83 7c 24 30
	00		 cmp	 QWORD PTR o$[rsp], 0
  0007b	75 0e		 jne	 SHORT $LN1@IntTupleFr

; 2775 :             Py_DECREF(intTuple);

  0007d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR intTuple$[rsp]
  00082	e8 00 00 00 00	 call	 _Py_DecRef

; 2776 :             return NULL;

  00087	33 c0		 xor	 eax, eax
  00089	eb 1b		 jmp	 SHORT $LN7@IntTupleFr
$LN1@IntTupleFr:

; 2777 :         }
; 2778 :         PyTuple_SET_ITEM(intTuple, i, o);

  0008b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00090	48 8b 4c 24 28	 mov	 rcx, QWORD PTR intTuple$[rsp]
  00095	48 8b 54 24 30	 mov	 rdx, QWORD PTR o$[rsp]
  0009a	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 2779 :     }

  0009f	eb a8		 jmp	 SHORT $LN3@IntTupleFr
$LN2@IntTupleFr:

; 2780 :     return intTuple;

  000a1	48 8b 44 24 28	 mov	 rax, QWORD PTR intTuple$[rsp]
$LN7@IntTupleFr:

; 2781 : }

  000a6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000aa	c3		 ret	 0
_IntTupleFromSsizet ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_strides_get DD imagerel memory_strides_get
	DD	imagerel memory_strides_get+102
	DD	imagerel $unwind$memory_strides_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_strides_get DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_strides_get
_TEXT	SEGMENT
self$ = 48
memory_strides_get PROC					; COMDAT

; 2826 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2827 :     CHECK_RELEASED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 13		 jne	 SHORT $LN1@memory_str
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 17		 je	 SHORT $LN2@memory_str
$LN1@memory_str:
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	e8 00 00 00 00	 call	 PyErr_SetString
  00041	33 c0		 xor	 eax, eax
  00043	eb 1c		 jmp	 SHORT $LN3@memory_str
$LN2@memory_str:

; 2828 :     return _IntTupleFromSsizet(self->view.ndim, self->view.strides);

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 90 c8 00
	00 00		 mov	 rdx, QWORD PTR [rax+200]
  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00056	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [rax+180]
  0005c	e8 00 00 00 00	 call	 _IntTupleFromSsizet
$LN3@memory_str:

; 2829 : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
memory_strides_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_suboffsets_get DD imagerel memory_suboffsets_get
	DD	imagerel memory_suboffsets_get+102
	DD	imagerel $unwind$memory_suboffsets_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_suboffsets_get DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_suboffsets_get
_TEXT	SEGMENT
self$ = 48
memory_suboffsets_get PROC				; COMDAT

; 2833 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2834 :     CHECK_RELEASED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 13		 jne	 SHORT $LN1@memory_sub@2
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 17		 je	 SHORT $LN2@memory_sub@2
$LN1@memory_sub@2:
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	e8 00 00 00 00	 call	 PyErr_SetString
  00041	33 c0		 xor	 eax, eax
  00043	eb 1c		 jmp	 SHORT $LN3@memory_sub@2
$LN2@memory_sub@2:

; 2835 :     return _IntTupleFromSsizet(self->view.ndim, self->view.suboffsets);

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 90 d0 00
	00 00		 mov	 rdx, QWORD PTR [rax+208]
  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00056	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [rax+180]
  0005c	e8 00 00 00 00	 call	 _IntTupleFromSsizet
$LN3@memory_sub@2:

; 2836 : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
memory_suboffsets_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_readonly_get DD imagerel memory_readonly_get
	DD	imagerel memory_readonly_get+90
	DD	imagerel $unwind$memory_readonly_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_readonly_get DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_readonly_get
_TEXT	SEGMENT
self$ = 48
memory_readonly_get PROC				; COMDAT

; 2840 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2841 :     CHECK_RELEASED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 13		 jne	 SHORT $LN1@memory_rea
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 17		 je	 SHORT $LN2@memory_rea
$LN1@memory_rea:
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	e8 00 00 00 00	 call	 PyErr_SetString
  00041	33 c0		 xor	 eax, eax
  00043	eb 10		 jmp	 SHORT $LN3@memory_rea
$LN2@memory_rea:

; 2842 :     return PyBool_FromLong(self->view.readonly);

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004a	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [rax+176]
  00050	e8 00 00 00 00	 call	 PyBool_FromLong
$LN3@memory_rea:

; 2843 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
memory_readonly_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_ndim_get DD imagerel memory_ndim_get
	DD	imagerel memory_ndim_get+90
	DD	imagerel $unwind$memory_ndim_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_ndim_get DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_ndim_get
_TEXT	SEGMENT
self$ = 48
memory_ndim_get PROC					; COMDAT

; 2847 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2848 :     CHECK_RELEASED(self);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 13		 jne	 SHORT $LN1@memory_ndi
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 17		 je	 SHORT $LN2@memory_ndi
$LN1@memory_ndi:
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	e8 00 00 00 00	 call	 PyErr_SetString
  00041	33 c0		 xor	 eax, eax
  00043	eb 10		 jmp	 SHORT $LN3@memory_ndi
$LN2@memory_ndi:

; 2849 :     return PyLong_FromLong(self->view.ndim);

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004a	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [rax+180]
  00050	e8 00 00 00 00	 call	 PyLong_FromLong
$LN3@memory_ndi:

; 2850 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
memory_ndim_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_c_contiguous DD imagerel memory_c_contiguous
	DD	imagerel memory_c_contiguous+100
	DD	imagerel $unwind$memory_c_contiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_c_contiguous DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_c_contiguous
_TEXT	SEGMENT
self$ = 48
dummy$ = 56
memory_c_contiguous PROC				; COMDAT

; 2854 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2855 :     CHECK_RELEASED(self);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00019	83 e0 01	 and	 eax, 1
  0001c	85 c0		 test	 eax, eax
  0001e	75 13		 jne	 SHORT $LN1@memory_c_c
  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00025	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00029	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0002c	83 e0 01	 and	 eax, 1
  0002f	85 c0		 test	 eax, eax
  00031	74 17		 je	 SHORT $LN2@memory_c_c
$LN1@memory_c_c:
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00041	e8 00 00 00 00	 call	 PyErr_SetString
  00046	33 c0		 xor	 eax, eax
  00048	eb 15		 jmp	 SHORT $LN3@memory_c_c
$LN2@memory_c_c:

; 2856 :     return PyBool_FromLong(MV_C_CONTIGUOUS(self->flags));

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00055	83 e0 0a	 and	 eax, 10
  00058	8b c8		 mov	 ecx, eax
  0005a	e8 00 00 00 00	 call	 PyBool_FromLong
$LN3@memory_c_c:

; 2857 : }

  0005f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00063	c3		 ret	 0
memory_c_contiguous ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_f_contiguous DD imagerel memory_f_contiguous
	DD	imagerel memory_f_contiguous+100
	DD	imagerel $unwind$memory_f_contiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_f_contiguous DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_f_contiguous
_TEXT	SEGMENT
self$ = 48
dummy$ = 56
memory_f_contiguous PROC				; COMDAT

; 2861 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2862 :     CHECK_RELEASED(self);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00019	83 e0 01	 and	 eax, 1
  0001c	85 c0		 test	 eax, eax
  0001e	75 13		 jne	 SHORT $LN1@memory_f_c
  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00025	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00029	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0002c	83 e0 01	 and	 eax, 1
  0002f	85 c0		 test	 eax, eax
  00031	74 17		 je	 SHORT $LN2@memory_f_c
$LN1@memory_f_c:
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00041	e8 00 00 00 00	 call	 PyErr_SetString
  00046	33 c0		 xor	 eax, eax
  00048	eb 15		 jmp	 SHORT $LN3@memory_f_c
$LN2@memory_f_c:

; 2863 :     return PyBool_FromLong(MV_F_CONTIGUOUS(self->flags));

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00055	83 e0 0c	 and	 eax, 12
  00058	8b c8		 mov	 ecx, eax
  0005a	e8 00 00 00 00	 call	 PyBool_FromLong
$LN3@memory_f_c:

; 2864 : }

  0005f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00063	c3		 ret	 0
memory_f_contiguous ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_contiguous DD imagerel memory_contiguous
	DD	imagerel memory_contiguous+100
	DD	imagerel $unwind$memory_contiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_contiguous DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT memory_contiguous
_TEXT	SEGMENT
self$ = 48
dummy$ = 56
memory_contiguous PROC					; COMDAT

; 2868 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2869 :     CHECK_RELEASED(self);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00019	83 e0 01	 and	 eax, 1
  0001c	85 c0		 test	 eax, eax
  0001e	75 13		 jne	 SHORT $LN1@memory_con
  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00025	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00029	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0002c	83 e0 01	 and	 eax, 1
  0002f	85 c0		 test	 eax, eax
  00031	74 17		 je	 SHORT $LN2@memory_con
$LN1@memory_con:
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00041	e8 00 00 00 00	 call	 PyErr_SetString
  00046	33 c0		 xor	 eax, eax
  00048	eb 15		 jmp	 SHORT $LN3@memory_con
$LN2@memory_con:

; 2870 :     return PyBool_FromLong(MV_ANY_CONTIGUOUS(self->flags));

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00055	83 e0 0e	 and	 eax, 14
  00058	8b c8		 mov	 ecx, eax
  0005a	e8 00 00 00 00	 call	 PyBool_FromLong
$LN3@memory_con:

; 2871 : }

  0005f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00063	c3		 ret	 0
memory_contiguous ENDP
_TEXT	ENDS
END
