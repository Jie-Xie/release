; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05KNFBNCOH@float?$AA@			; `string'
PUBLIC	??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@ ; `string'
PUBLIC	??_C@_04HBKGOHH@imag?$AA@			; `string'
PUBLIC	??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@ ; `string'
PUBLIC	??_C@_04DGGKDJMA@real?$AA@			; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0O@PDHIBBE@__setformat__?$AA@		; `string'
PUBLIC	??_C@_0O@CJFHJH@__getformat__?$AA@		; `string'
PUBLIC	??_C@_0P@BCBHENLA@__getnewargs__?$AA@		; `string'
PUBLIC	??_C@_0CI@BKHKHHHJ@Return?5True?5if?5the?5float?5is?5an?5i@ ; `string'
PUBLIC	??_C@_0L@CPNMLAFF@is_integer?$AA@		; `string'
PUBLIC	??_C@_03IJNDAFDK@hex?$AA@			; `string'
PUBLIC	??_C@_07DIMGGDAC@fromhex?$AA@			; `string'
PUBLIC	??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@	; `string'
PUBLIC	??_C@_0HP@PDOBDLCN@Return?5the?5Integral?5closest?5to?5x@ ; `string'
PUBLIC	??_C@_09PJGAHDBG@__round__?$AA@			; `string'
PUBLIC	??_C@_0DC@GGJOGKMD@Return?5the?5Integral?5closest?5to?5x@ ; `string'
PUBLIC	??_C@_09KENBLPCG@__trunc__?$AA@			; `string'
PUBLIC	??_C@_0DB@PIKJGALP@Return?5self?0?5the?5complex?5conjuga@ ; `string'
PUBLIC	??_C@_09PHMNDPIK@conjugate?$AA@			; `string'
PUBLIC	??_C@_01FJMABOPO@x?$AA@				; `string'
PUBLIC	??_C@_0P@GFDAFFFN@sys?4float_info?$AA@		; `string'
PUBLIC	??_C@_0BO@POLMBODL@FLT_ROUNDS?5?9?9?5addition?5rounds?$AA@ ; `string'
PUBLIC	??_C@_06EBMBPKEK@rounds?$AA@			; `string'
PUBLIC	??_C@_0BP@MBMDGMCC@FLT_RADIX?5?9?9?5radix?5of?5exponent?$AA@ ; `string'
PUBLIC	??_C@_05LICBMPGO@radix?$AA@			; `string'
PUBLIC	??_C@_0EF@DGCBBCHJ@DBL_EPSILON?5?9?9?5Difference?5betwee@ ; `string'
PUBLIC	??_C@_07DOCPLGLO@epsilon?$AA@			; `string'
PUBLIC	??_C@_0CA@LMDNBIKF@DBL_MANT_DIG?5?9?9?5mantissa?5digits?$AA@ ; `string'
PUBLIC	??_C@_08IABMGAGJ@mant_dig?$AA@			; `string'
PUBLIC	??_C@_0BC@JCDBCLA@DBL_DIG?5?9?9?5digits?$AA@	; `string'
PUBLIC	??_C@_03HEFENHI@dig?$AA@			; `string'
PUBLIC	??_C@_0EA@HMMAHPHF@DBL_MIN_10_EXP?5?9?9?5minimum?5int?5e?5@ ; `string'
PUBLIC	??_C@_0L@PDGFLHLE@min_10_exp?$AA@		; `string'
PUBLIC	??_C@_0EK@DEEKODGB@DBL_MIN_EXP?5?9?9?5minimum?5int?5e?5suc@ ; `string'
PUBLIC	??_C@_07DOIFONNF@min_exp?$AA@			; `string'
PUBLIC	??_C@_0CN@LLOJMAEG@DBL_MIN?5?9?9?5Minimum?5positive?5norm@ ; `string'
PUBLIC	??_C@_03KLIPLJLL@min?$AA@			; `string'
PUBLIC	??_C@_0EB@OLMLCLAI@DBL_MAX_10_EXP?5?9?9?5maximum?5int?5e?5@ ; `string'
PUBLIC	??_C@_0L@DPGIMMLL@max_10_exp?$AA@		; `string'
PUBLIC	??_C@_0EF@ICFFOOL@DBL_MAX_EXP?5?9?9?5maximum?5int?5e?5suc@ ; `string'
PUBLIC	??_C@_07NIOFECDE@max_exp?$AA@			; `string'
PUBLIC	??_C@_0CO@DNMBKDDN@DBL_MAX?5?9?9?5maximum?5representable@ ; `string'
PUBLIC	??_C@_03LJAEFNNE@max?$AA@			; `string'
PUBLIC	PyFloat_Type
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
_BSS	SEGMENT
numfree	DD	01H DUP (?)
	ALIGN	8

free_list DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_05KNFBNCOH@float?$AA@
CONST	SEGMENT
??_C@_05KNFBNCOH@float?$AA@ DB 'float', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@
CONST	SEGMENT
??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@ DB 'the imagin'
	DB	'ary part of a complex number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HBKGOHH@imag?$AA@
CONST	SEGMENT
??_C@_04HBKGOHH@imag?$AA@ DB 'imag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@
CONST	SEGMENT
??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@ DB 'the real pa'
	DB	'rt of a complex number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DGGKDJMA@real?$AA@
CONST	SEGMENT
??_C@_04DGGKDJMA@real?$AA@ DB 'real', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PDHIBBE@__setformat__?$AA@
CONST	SEGMENT
??_C@_0O@PDHIBBE@__setformat__?$AA@ DB '__setformat__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CJFHJH@__getformat__?$AA@
CONST	SEGMENT
??_C@_0O@CJFHJH@__getformat__?$AA@ DB '__getformat__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BCBHENLA@__getnewargs__?$AA@
CONST	SEGMENT
??_C@_0P@BCBHENLA@__getnewargs__?$AA@ DB '__getnewargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BKHKHHHJ@Return?5True?5if?5the?5float?5is?5an?5i@
CONST	SEGMENT
??_C@_0CI@BKHKHHHJ@Return?5True?5if?5the?5float?5is?5an?5i@ DB 'Return Tr'
	DB	'ue if the float is an integer.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CPNMLAFF@is_integer?$AA@
CONST	SEGMENT
??_C@_0L@CPNMLAFF@is_integer?$AA@ DB 'is_integer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03IJNDAFDK@hex?$AA@
CONST	SEGMENT
??_C@_03IJNDAFDK@hex?$AA@ DB 'hex', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIMGGDAC@fromhex?$AA@
CONST	SEGMENT
??_C@_07DIMGGDAC@fromhex?$AA@ DB 'fromhex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@
CONST	SEGMENT
??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@ DB 'as_integer_ratio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@PDOBDLCN@Return?5the?5Integral?5closest?5to?5x@
CONST	SEGMENT
??_C@_0HP@PDOBDLCN@Return?5the?5Integral?5closest?5to?5x@ DB 'Return the '
	DB	'Integral closest to x, rounding half toward even.', 0aH, 'Whe'
	DB	'n an argument is passed, work like built-in round(x, ndigits)'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJGAHDBG@__round__?$AA@
CONST	SEGMENT
??_C@_09PJGAHDBG@__round__?$AA@ DB '__round__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@GGJOGKMD@Return?5the?5Integral?5closest?5to?5x@
CONST	SEGMENT
??_C@_0DC@GGJOGKMD@Return?5the?5Integral?5closest?5to?5x@ DB 'Return the '
	DB	'Integral closest to x between 0 and x.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KENBLPCG@__trunc__?$AA@
CONST	SEGMENT
??_C@_09KENBLPCG@__trunc__?$AA@ DB '__trunc__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PIKJGALP@Return?5self?0?5the?5complex?5conjuga@
CONST	SEGMENT
??_C@_0DB@PIKJGALP@Return?5self?0?5the?5complex?5conjuga@ DB 'Return self'
	DB	', the complex conjugate of any float.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PHMNDPIK@conjugate?$AA@
CONST	SEGMENT
??_C@_09PHMNDPIK@conjugate?$AA@ DB 'conjugate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01FJMABOPO@x?$AA@
CONST	SEGMENT
??_C@_01FJMABOPO@x?$AA@ DB 'x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GFDAFFFN@sys?4float_info?$AA@
CONST	SEGMENT
??_C@_0P@GFDAFFFN@sys?4float_info?$AA@ DB 'sys.float_info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@POLMBODL@FLT_ROUNDS?5?9?9?5addition?5rounds?$AA@
CONST	SEGMENT
??_C@_0BO@POLMBODL@FLT_ROUNDS?5?9?9?5addition?5rounds?$AA@ DB 'FLT_ROUNDS'
	DB	' -- addition rounds', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBMBPKEK@rounds?$AA@
CONST	SEGMENT
??_C@_06EBMBPKEK@rounds?$AA@ DB 'rounds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MBMDGMCC@FLT_RADIX?5?9?9?5radix?5of?5exponent?$AA@
CONST	SEGMENT
??_C@_0BP@MBMDGMCC@FLT_RADIX?5?9?9?5radix?5of?5exponent?$AA@ DB 'FLT_RADI'
	DB	'X -- radix of exponent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LICBMPGO@radix?$AA@
CONST	SEGMENT
??_C@_05LICBMPGO@radix?$AA@ DB 'radix', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DGCBBCHJ@DBL_EPSILON?5?9?9?5Difference?5betwee@
CONST	SEGMENT
??_C@_0EF@DGCBBCHJ@DBL_EPSILON?5?9?9?5Difference?5betwee@ DB 'DBL_EPSILON'
	DB	' -- Difference between 1 and the next representable float', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DOCPLGLO@epsilon?$AA@
CONST	SEGMENT
??_C@_07DOCPLGLO@epsilon?$AA@ DB 'epsilon', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LMDNBIKF@DBL_MANT_DIG?5?9?9?5mantissa?5digits?$AA@
CONST	SEGMENT
??_C@_0CA@LMDNBIKF@DBL_MANT_DIG?5?9?9?5mantissa?5digits?$AA@ DB 'DBL_MANT'
	DB	'_DIG -- mantissa digits', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IABMGAGJ@mant_dig?$AA@
CONST	SEGMENT
??_C@_08IABMGAGJ@mant_dig?$AA@ DB 'mant_dig', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JCDBCLA@DBL_DIG?5?9?9?5digits?$AA@
CONST	SEGMENT
??_C@_0BC@JCDBCLA@DBL_DIG?5?9?9?5digits?$AA@ DB 'DBL_DIG -- digits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HEFENHI@dig?$AA@
CONST	SEGMENT
??_C@_03HEFENHI@dig?$AA@ DB 'dig', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HMMAHPHF@DBL_MIN_10_EXP?5?9?9?5minimum?5int?5e?5@
CONST	SEGMENT
??_C@_0EA@HMMAHPHF@DBL_MIN_10_EXP?5?9?9?5minimum?5int?5e?5@ DB 'DBL_MIN_1'
	DB	'0_EXP -- minimum int e such that 10**e is a normalized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PDGFLHLE@min_10_exp?$AA@
CONST	SEGMENT
??_C@_0L@PDGFLHLE@min_10_exp?$AA@ DB 'min_10_exp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@DEEKODGB@DBL_MIN_EXP?5?9?9?5minimum?5int?5e?5suc@
CONST	SEGMENT
??_C@_0EK@DEEKODGB@DBL_MIN_EXP?5?9?9?5minimum?5int?5e?5suc@ DB 'DBL_MIN_E'
	DB	'XP -- minimum int e such that radix**(e-1) is a normalized fl'
	DB	'oat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07DOIFONNF@min_exp?$AA@
CONST	SEGMENT
??_C@_07DOIFONNF@min_exp?$AA@ DB 'min_exp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LLOJMAEG@DBL_MIN?5?9?9?5Minimum?5positive?5norm@
CONST	SEGMENT
??_C@_0CN@LLOJMAEG@DBL_MIN?5?9?9?5Minimum?5positive?5norm@ DB 'DBL_MIN --'
	DB	' Minimum positive normalizer float', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLIPLJLL@min?$AA@
CONST	SEGMENT
??_C@_03KLIPLJLL@min?$AA@ DB 'min', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@OLMLCLAI@DBL_MAX_10_EXP?5?9?9?5maximum?5int?5e?5@
CONST	SEGMENT
??_C@_0EB@OLMLCLAI@DBL_MAX_10_EXP?5?9?9?5maximum?5int?5e?5@ DB 'DBL_MAX_1'
	DB	'0_EXP -- maximum int e such that 10**e is representable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DPGIMMLL@max_10_exp?$AA@
CONST	SEGMENT
??_C@_0L@DPGIMMLL@max_10_exp?$AA@ DB 'max_10_exp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@ICFFOOL@DBL_MAX_EXP?5?9?9?5maximum?5int?5e?5suc@
CONST	SEGMENT
??_C@_0EF@ICFFOOL@DBL_MAX_EXP?5?9?9?5maximum?5int?5e?5suc@ DB 'DBL_MAX_EX'
	DB	'P -- maximum int e such that radix**(e-1) is representable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NIOFECDE@max_exp?$AA@
CONST	SEGMENT
??_C@_07NIOFECDE@max_exp?$AA@ DB 'max_exp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DNMBKDDN@DBL_MAX?5?9?9?5maximum?5representable@
CONST	SEGMENT
??_C@_0CO@DNMBKDDN@DBL_MAX?5?9?9?5maximum?5representable@ DB 'DBL_MAX -- '
	DB	'maximum representable finite float', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max?$AA@
CONST	SEGMENT
??_C@_03LJAEFNNE@max?$AA@ DB 'max', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
floatinfo__doc__ DB 'sys.float_info', 0aH, 0aH, 'A structseq holding info'
	DB	'rmation about the float type. It contains low level', 0aH, 'i'
	DB	'nformation about the precision and internal representation. P'
	DB	'lease study', 0aH, 'your system''s :file:`float.h` for more i'
	DB	'nformation.', 00H
	ORG $+6
floatinfo_fields DQ FLAT:??_C@_03LJAEFNNE@max?$AA@
	DQ	FLAT:??_C@_0CO@DNMBKDDN@DBL_MAX?5?9?9?5maximum?5representable@
	DQ	FLAT:??_C@_07NIOFECDE@max_exp?$AA@
	DQ	FLAT:??_C@_0EF@ICFFOOL@DBL_MAX_EXP?5?9?9?5maximum?5int?5e?5suc@
	DQ	FLAT:??_C@_0L@DPGIMMLL@max_10_exp?$AA@
	DQ	FLAT:??_C@_0EB@OLMLCLAI@DBL_MAX_10_EXP?5?9?9?5maximum?5int?5e?5@
	DQ	FLAT:??_C@_03KLIPLJLL@min?$AA@
	DQ	FLAT:??_C@_0CN@LLOJMAEG@DBL_MIN?5?9?9?5Minimum?5positive?5norm@
	DQ	FLAT:??_C@_07DOIFONNF@min_exp?$AA@
	DQ	FLAT:??_C@_0EK@DEEKODGB@DBL_MIN_EXP?5?9?9?5minimum?5int?5e?5suc@
	DQ	FLAT:??_C@_0L@PDGFLHLE@min_10_exp?$AA@
	DQ	FLAT:??_C@_0EA@HMMAHPHF@DBL_MIN_10_EXP?5?9?9?5minimum?5int?5e?5@
	DQ	FLAT:??_C@_03HEFENHI@dig?$AA@
	DQ	FLAT:??_C@_0BC@JCDBCLA@DBL_DIG?5?9?9?5digits?$AA@
	DQ	FLAT:??_C@_08IABMGAGJ@mant_dig?$AA@
	DQ	FLAT:??_C@_0CA@LMDNBIKF@DBL_MANT_DIG?5?9?9?5mantissa?5digits?$AA@
	DQ	FLAT:??_C@_07DOCPLGLO@epsilon?$AA@
	DQ	FLAT:??_C@_0EF@DGCBBCHJ@DBL_EPSILON?5?9?9?5Difference?5betwee@
	DQ	FLAT:??_C@_05LICBMPGO@radix?$AA@
	DQ	FLAT:??_C@_0BP@MBMDGMCC@FLT_RADIX?5?9?9?5radix?5of?5exponent?$AA@
	DQ	FLAT:??_C@_06EBMBPKEK@rounds?$AA@
	DQ	FLAT:??_C@_0BO@POLMBODL@FLT_ROUNDS?5?9?9?5addition?5rounds?$AA@
	DQ	0000000000000000H
	ORG $+8
floatinfo_desc DQ FLAT:??_C@_0P@GFDAFFFN@sys?4float_info?$AA@
	DQ	FLAT:floatinfo__doc__
	DQ	FLAT:floatinfo_fields
	DD	0bH
	ORG $+4
float_hex_doc DB 'float.hex() -> string', 0aH, 0aH, 'Return a hexadecimal'
	DB	' representation of a floating-point number.', 0aH, '>>> (-0.1'
	DB	').hex()', 0aH, '''-0x1.999999999999ap-4''', 0aH, '>>> 3.14159'
	DB	'.hex()', 0aH, '''0x1.921f9f01b866ep+1''', 00H
	ORG $+7
float_fromhex_doc DB 'float.fromhex(string) -> float', 0aH, 0aH, 'Create '
	DB	'a floating-point number from a hexadecimal string.', 0aH, '>>'
	DB	'> float.fromhex(''0x1.ffffp10'')', 0aH, '2047.984375', 0aH, '>'
	DB	'>> float.fromhex(''-0x1p-1074'')', 0aH, '-4.9406564584124654e'
	DB	'-324', 00H
float_as_integer_ratio_doc DB 'float.as_integer_ratio() -> (int, int)', 0aH
	DB	0aH, 'Return a pair of integers, whose ratio is exactly equal '
	DB	'to the original', 0aH, 'float and with a positive denominator'
	DB	'.', 0aH, 'Raise OverflowError on infinities and a ValueError '
	DB	'on NaNs.', 0aH, 0aH, '>>> (10.0).as_integer_ratio()', 0aH, '('
	DB	'10, 1)', 0aH, '>>> (0.0).as_integer_ratio()', 0aH, '(0, 1)', 0aH
	DB	'>>> (-.25).as_integer_ratio()', 0aH, '(-1, 4)', 00H
	ORG $+4
?kwlist@?1??float_new@@9@9 DQ FLAT:??_C@_01FJMABOPO@x?$AA@ ; `float_new'::`2'::kwlist
	DQ	0000000000000000H
	ORG $+8
float_getformat_doc DB 'float.__getformat__(typestr) -> string', 0aH, 0aH
	DB	'You probably don''t want to use this function.  It exists mai'
	DB	'nly to be', 0aH, 'used in Python''s test suite.', 0aH, 0aH, 't'
	DB	'ypestr must be ''double'' or ''float''.  This function return'
	DB	's whichever of', 0aH, '''unknown'', ''IEEE, big-endian'' or '''
	DB	'IEEE, little-endian'' best describes the', 0aH, 'format of fl'
	DB	'oating point numbers used by the C type named by typestr.', 00H
	ORG $+11
float_setformat_doc DB 'float.__setformat__(typestr, fmt) -> None', 0aH, 0aH
	DB	'You probably don''t want to use this function.  It exists mai'
	DB	'nly to be', 0aH, 'used in Python''s test suite.', 0aH, 0aH, 't'
	DB	'ypestr must be ''double'' or ''float''.  fmt must be one of '''
	DB	'unknown'',', 0aH, '''IEEE, big-endian'' or ''IEEE, little-end'
	DB	'ian'', and in addition can only be', 0aH, 'one of the latter '
	DB	'two if it appears to match the underlying C reality.', 0aH, 0aH
	DB	'Override the automatic determination of C-level floating poin'
	DB	't type.', 0aH, 'This affects how floats are converted to and '
	DB	'from binary strings.', 00H
	ORG $+5
float__format__doc DB 'float.__format__(format_spec) -> string', 0aH, 0aH
	DB	'Formats the float according to format_spec.', 00H
	ORG $+11
float_methods DQ FLAT:??_C@_09PHMNDPIK@conjugate?$AA@
	DQ	FLAT:float_float
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DB@PIKJGALP@Return?5self?0?5the?5complex?5conjuga@
	DQ	FLAT:??_C@_09KENBLPCG@__trunc__?$AA@
	DQ	FLAT:float_trunc
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DC@GGJOGKMD@Return?5the?5Integral?5closest?5to?5x@
	DQ	FLAT:??_C@_09PJGAHDBG@__round__?$AA@
	DQ	FLAT:float_round
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0HP@PDOBDLCN@Return?5the?5Integral?5closest?5to?5x@
	DQ	FLAT:??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@
	DQ	FLAT:float_as_integer_ratio
	DD	04H
	ORG $+4
	DQ	FLAT:float_as_integer_ratio_doc
	DQ	FLAT:??_C@_07DIMGGDAC@fromhex?$AA@
	DQ	FLAT:float_fromhex
	DD	018H
	ORG $+4
	DQ	FLAT:float_fromhex_doc
	DQ	FLAT:??_C@_03IJNDAFDK@hex?$AA@
	DQ	FLAT:float_hex
	DD	04H
	ORG $+4
	DQ	FLAT:float_hex_doc
	DQ	FLAT:??_C@_0L@CPNMLAFF@is_integer?$AA@
	DQ	FLAT:float_is_integer
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CI@BKHKHHHJ@Return?5True?5if?5the?5float?5is?5an?5i@
	DQ	FLAT:??_C@_0P@BCBHENLA@__getnewargs__?$AA@
	DQ	FLAT:float_getnewargs
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0O@CJFHJH@__getformat__?$AA@
	DQ	FLAT:float_getformat
	DD	018H
	ORG $+4
	DQ	FLAT:float_getformat_doc
	DQ	FLAT:??_C@_0O@PDHIBBE@__setformat__?$AA@
	DQ	FLAT:float_setformat
	DD	011H
	ORG $+4
	DQ	FLAT:float_setformat_doc
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:float__format__
	DD	01H
	ORG $+4
	DQ	FLAT:float__format__doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
float_getset DQ	FLAT:??_C@_04DGGKDJMA@real?$AA@
	DQ	FLAT:float_float
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_04HBKGOHH@imag?$AA@
	DQ	FLAT:float_getzero
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
float_doc DB	'float(x) -> floating point number', 0aH, 0aH, 'Convert a'
	DB	' string or number to a floating point number, if possible.', 00H
	ORG $+9
float_as_number DQ FLAT:float_add
	DQ	FLAT:float_sub
	DQ	FLAT:float_mul
	DQ	FLAT:float_rem
	DQ	FLAT:float_divmod
	DQ	FLAT:float_pow
	DQ	FLAT:float_neg
	DQ	FLAT:float_float
	DQ	FLAT:float_abs
	DQ	FLAT:float_bool
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_trunc
	DQ	0000000000000000H
	DQ	FLAT:float_float
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_floor_div
	DQ	FLAT:float_div
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
PyFloat_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_05KNFBNCOH@float?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:float_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_repr
	DQ	FLAT:float_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_hash
	DQ	0000000000000000H
	DQ	FLAT:float_repr
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:float_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_methods
	DQ	0000000000000000H
	DQ	FLAT:float_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_new
	ORG $+72
_DATA	ENDS
PUBLIC	__real@7fefffffffffffff
PUBLIC	PyFloat_GetMax
EXTRN	_fltused:DWORD
;	COMDAT __real@7fefffffffffffff
; File c:\src\pyparallel\objects\floatobject.c
CONST	SEGMENT
__real@7fefffffffffffff DQ 07fefffffffffffffr	; 1.79769e+308
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyFloat_GetMax
_TEXT	SEGMENT
PyFloat_GetMax PROC					; COMDAT

; 32   :     return DBL_MAX;

  00000	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@7fefffffffffffff

; 33   : }

  00008	c3		 ret	 0
PyFloat_GetMax ENDP
_TEXT	ENDS
PUBLIC	__real@0010000000000000
PUBLIC	PyFloat_GetMin
;	COMDAT __real@0010000000000000
CONST	SEGMENT
__real@0010000000000000 DQ 00010000000000000r	; 2.22507e-308
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyFloat_GetMin
_TEXT	SEGMENT
PyFloat_GetMin PROC					; COMDAT

; 38   :     return DBL_MIN;

  00000	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@0010000000000000

; 39   : }

  00008	c3		 ret	 0
PyFloat_GetMin ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0BA@FFJEOCLI@PyFloat_GetInfo?$AA@		; `string'
PUBLIC	??_C@_0BJ@BGCHDLFF@?4?4?2Objects?2floatobject?4c?$AA@ ; `string'
PUBLIC	__real@3cb0000000000000
PUBLIC	PyFloat_FromDouble
PUBLIC	PyFloat_GetInfo
EXTRN	_PyParallel_Guard:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyStructSequence_New:PROC
_BSS	SEGMENT
FloatInfoType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFloat_GetInfo DD imagerel $LN9
	DD	imagerel $LN9+547
	DD	imagerel $unwind$PyFloat_GetInfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_GetInfo DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0BA@FFJEOCLI@PyFloat_GetInfo?$AA@
CONST	SEGMENT
??_C@_0BA@FFJEOCLI@PyFloat_GetInfo?$AA@ DB 'PyFloat_GetInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BGCHDLFF@?4?4?2Objects?2floatobject?4c?$AA@
CONST	SEGMENT
??_C@_0BJ@BGCHDLFF@?4?4?2Objects?2floatobject?4c?$AA@ DB '..\Objects\floa'
	DB	'tobject.c', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3cb0000000000000
CONST	SEGMENT
__real@3cb0000000000000 DQ 03cb0000000000000r	; 2.22045e-016
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyFloat_GetInfo
_TEXT	SEGMENT
floatinfo$ = 48
pos$ = 56
_py_tmp$20351 = 64
PyFloat_GetInfo PROC					; COMDAT

; 79   : {

$LN9:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 80   :     PyObject* floatinfo;
; 81   :     int pos = 0;

  00004	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR pos$[rsp], 0

; 82   : 
; 83   :     floatinfo = PyStructSequence_New(&FloatInfoType);

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:FloatInfoType
  00013	e8 00 00 00 00	 call	 PyStructSequence_New
  00018	48 89 44 24 30	 mov	 QWORD PTR floatinfo$[rsp], rax

; 84   :     if (floatinfo == NULL) {

  0001d	48 83 7c 24 30
	00		 cmp	 QWORD PTR floatinfo$[rsp], 0
  00023	75 07		 jne	 SHORT $LN6@PyFloat_Ge

; 85   :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	e9 f2 01 00 00	 jmp	 $LN7@PyFloat_Ge
$LN6@PyFloat_Ge:

; 86   :     }
; 87   : 
; 88   : #define SetIntFlag(flag) \
; 89   :     PyStructSequence_SET_ITEM(floatinfo, pos++, PyLong_FromLong(flag))
; 90   : #define SetDblFlag(flag) \
; 91   :     PyStructSequence_SET_ITEM(floatinfo, pos++, PyFloat_FromDouble(flag))
; 92   : 
; 93   :     SetDblFlag(DBL_MAX);

  0002c	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@7fefffffffffffff
  00034	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00039	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  0003e	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  00043	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  00048	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 94   :     SetIntFlag(DBL_MAX_EXP);

  00052	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00057	e8 00 00 00 00	 call	 PyLong_FromLong
  0005c	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  00061	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  00066	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  0006b	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  0006f	ff c0		 inc	 eax
  00071	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 95   :     SetIntFlag(DBL_MAX_10_EXP);

  00075	b9 34 01 00 00	 mov	 ecx, 308		; 00000134H
  0007a	e8 00 00 00 00	 call	 PyLong_FromLong
  0007f	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  00084	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  00089	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  0008e	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  00092	ff c0		 inc	 eax
  00094	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 96   :     SetDblFlag(DBL_MIN);

  00098	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@0010000000000000
  000a0	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000a5	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  000aa	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  000af	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  000b4	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  000b8	ff c0		 inc	 eax
  000ba	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 97   :     SetIntFlag(DBL_MIN_EXP);

  000be	b9 03 fc ff ff	 mov	 ecx, -1021		; fffffffffffffc03H
  000c3	e8 00 00 00 00	 call	 PyLong_FromLong
  000c8	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  000cd	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  000d2	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  000d7	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  000db	ff c0		 inc	 eax
  000dd	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 98   :     SetIntFlag(DBL_MIN_10_EXP);

  000e1	b9 cd fe ff ff	 mov	 ecx, -307		; fffffffffffffecdH
  000e6	e8 00 00 00 00	 call	 PyLong_FromLong
  000eb	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  000f0	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  000f5	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  000fa	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  000fe	ff c0		 inc	 eax
  00100	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 99   :     SetIntFlag(DBL_DIG);

  00104	b9 0f 00 00 00	 mov	 ecx, 15
  00109	e8 00 00 00 00	 call	 PyLong_FromLong
  0010e	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  00113	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  00118	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  0011d	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  00121	ff c0		 inc	 eax
  00123	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 100  :     SetIntFlag(DBL_MANT_DIG);

  00127	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0012c	e8 00 00 00 00	 call	 PyLong_FromLong
  00131	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  00136	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  0013b	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  00140	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  00144	ff c0		 inc	 eax
  00146	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 101  :     SetDblFlag(DBL_EPSILON);

  0014a	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3cb0000000000000
  00152	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00157	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  0015c	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  00161	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  00166	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  0016a	ff c0		 inc	 eax
  0016c	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 102  :     SetIntFlag(FLT_RADIX);

  00170	b9 02 00 00 00	 mov	 ecx, 2
  00175	e8 00 00 00 00	 call	 PyLong_FromLong
  0017a	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  0017f	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  00184	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  00189	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  0018d	ff c0		 inc	 eax
  0018f	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 103  :     SetIntFlag(FLT_ROUNDS);

  00193	b9 01 00 00 00	 mov	 ecx, 1
  00198	e8 00 00 00 00	 call	 PyLong_FromLong
  0019d	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR pos$[rsp]
  001a2	48 8b 54 24 30	 mov	 rdx, QWORD PTR floatinfo$[rsp]
  001a7	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
  001ac	8b 44 24 38	 mov	 eax, DWORD PTR pos$[rsp]
  001b0	ff c0		 inc	 eax
  001b2	89 44 24 38	 mov	 DWORD PTR pos$[rsp], eax

; 104  : #undef SetIntFlag
; 105  : #undef SetDblFlag
; 106  : 
; 107  :     if (PyErr_Occurred()) {

  001b6	e8 00 00 00 00	 call	 PyErr_Occurred
  001bb	48 85 c0	 test	 rax, rax
  001be	74 59		 je	 SHORT $LN5@PyFloat_Ge
$LN4@PyFloat_Ge:

; 108  :         Py_CLEAR(floatinfo);

  001c0	48 83 7c 24 30
	00		 cmp	 QWORD PTR floatinfo$[rsp], 0
  001c6	74 47		 je	 SHORT $LN1@PyFloat_Ge
  001c8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d0	4c 8b 4c 24 30	 mov	 r9, QWORD PTR floatinfo$[rsp]
  001d5	41 b8 6c 00 00
	00		 mov	 r8d, 108		; 0000006cH
  001db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@BGCHDLFF@?4?4?2Objects?2floatobject?4c?$AA@
  001e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FFJEOCLI@PyFloat_GetInfo?$AA@
  001e9	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ee	85 c0		 test	 eax, eax
  001f0	75 1d		 jne	 SHORT $LN1@PyFloat_Ge
  001f2	48 8b 44 24 30	 mov	 rax, QWORD PTR floatinfo$[rsp]
  001f7	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$20351[rsp], rax
  001fc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR floatinfo$[rsp], 0
  00205	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$20351[rsp]
  0020a	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyFloat_Ge:
  0020f	33 c0		 xor	 eax, eax
  00211	85 c0		 test	 eax, eax
  00213	75 ab		 jne	 SHORT $LN4@PyFloat_Ge

; 109  :         return NULL;

  00215	33 c0		 xor	 eax, eax
  00217	eb 05		 jmp	 SHORT $LN7@PyFloat_Ge
$LN5@PyFloat_Ge:

; 110  :     }
; 111  :     return floatinfo;

  00219	48 8b 44 24 30	 mov	 rax, QWORD PTR floatinfo$[rsp]
$LN7@PyFloat_Ge:

; 112  : }

  0021e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00222	c3		 ret	 0
PyFloat_GetInfo ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyObject_DebugMalloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\floatobject.c
pdata	SEGMENT
$pdata$PyFloat_FromDouble DD imagerel $LN8
	DD	imagerel $LN8+165
	DD	imagerel $unwind$PyFloat_FromDouble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_FromDouble DD 010a01H
	DD	0620aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyFloat_FromDouble
_TEXT	SEGMENT
op$ = 32
tv66 = 40
fval$ = 64
PyFloat_FromDouble PROC					; COMDAT

; 116  : {

$LN8:
  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 117  :     register PyFloatObject *op = (Py_PXCTX ? 0 : free_list);

  0000a	e8 00 00 00 00	 call	 _Py_PXCTX
  0000f	85 c0		 test	 eax, eax
  00011	74 0b		 je	 SHORT $LN6@PyFloat_Fr
  00013	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv66[rsp], 0
  0001c	eb 0c		 jmp	 SHORT $LN7@PyFloat_Fr
$LN6@PyFloat_Fr:
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR free_list
  00025	48 89 44 24 28	 mov	 QWORD PTR tv66[rsp], rax
$LN7@PyFloat_Fr:
  0002a	48 8b 44 24 28	 mov	 rax, QWORD PTR tv66[rsp]
  0002f	48 89 44 24 20	 mov	 QWORD PTR op$[rsp], rax

; 118  :     if (op != NULL) {

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR op$[rsp], 0
  0003a	74 20		 je	 SHORT $LN3@PyFloat_Fr

; 119  :         free_list = (PyFloatObject *) Py_TYPE(op);

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00045	48 89 05 00 00
	00 00		 mov	 QWORD PTR free_list, rax

; 120  :         numfree--;

  0004c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  00052	ff c8		 dec	 eax
  00054	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax

; 121  :     } else {

  0005a	eb 1e		 jmp	 SHORT $LN2@PyFloat_Fr
$LN3@PyFloat_Fr:

; 122  :         op = (PyFloatObject*) PyObject_MALLOC(sizeof(PyFloatObject));

  0005c	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00061	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00066	48 89 44 24 20	 mov	 QWORD PTR op$[rsp], rax

; 123  :         if (!op)

  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR op$[rsp], 0
  00071	75 07		 jne	 SHORT $LN1@PyFloat_Fr

; 124  :             return PyErr_NoMemory();

  00073	e8 00 00 00 00	 call	 PyErr_NoMemory
  00078	eb 26		 jmp	 SHORT $LN4@PyFloat_Fr
$LN1@PyFloat_Fr:
$LN2@PyFloat_Fr:

; 125  :     }
; 126  :     /* Inline PyObject_New */
; 127  :     PyObject_INIT(op, &PyFloat_Type);

  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00081	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  00086	e8 00 00 00 00	 call	 PyObject_INIT

; 128  :     op->ob_fval = fval;

  0008b	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
  00090	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR fval$[rsp]
  00096	f2 0f 11 40 60	 movsdx	 QWORD PTR [rax+96], xmm0

; 129  :     return (PyObject *) op;

  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR op$[rsp]
$LN4@PyFloat_Fr:

; 130  : }

  000a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a4	c3		 ret	 0
PyFloat_FromDouble ENDP
_TEXT	ENDS
EXTRN	_Py_NewReference:PROC
EXTRN	_PxObject_Init:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$PyObject_INIT DD imagerel PyObject_INIT
	DD	imagerel PyObject_INIT+84
	DD	imagerel $unwind$PyObject_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_INIT
_TEXT	SEGMENT
op$ = 48
tp$ = 56
PyObject_INIT PROC					; COMDAT

; 236  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 237  :     Px_RETURN(_PxObject_Init(op, tp))

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 11		 je	 SHORT $LN1@PyObject_I
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR tp$[rsp]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00021	e8 00 00 00 00	 call	 _PxObject_Init
  00026	eb 27		 jmp	 SHORT $LN2@PyObject_I
$LN1@PyObject_I:

; 238  :     Py_TYPE(op) = tp;

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tp$[rsp]
  00032	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 239  :     _PyObject_InitHead(op);

  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0003b	e8 00 00 00 00	 call	 _PyObject_InitHead

; 240  :     _Py_NewReference(op);

  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00045	e8 00 00 00 00	 call	 _Py_NewReference

; 241  :     return op;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
$LN2@PyObject_I:

; 242  : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
PyObject_INIT ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_InitHead DD imagerel _PyObject_InitHead
	DD	imagerel _PyObject_InitHead+182
	DD	imagerel $unwind$_PyObject_InitHead
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_InitHead DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H
	DB	'(', 00H, 'o', 00H, 'p', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@
CONST	SEGMENT
??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 48
_PyObject_InitHead PROC					; COMDAT

; 215  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 216  :     assert(Py_TYPE(op));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0000e	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  00013	75 1c		 jne	 SHORT $LN3@PyObject_I@2
  00015	41 b8 d8 00 00
	00		 mov	 r8d, 216		; 000000d8H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	33 c0		 xor	 eax, eax
$LN3@PyObject_I@2:

; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00036	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx

; 218  :     op->px    = _Py_NOT_PARALLEL;

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00048	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00052	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 219  :     op->slist_entry.Next = NULL;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0005b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00068	48 c7 40 20 01
	00 00 00	 mov	 QWORD PTR [rax+32], 1

; 221  :     op->srw_lock  = NULL;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00075	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 222  :     op->event     = NULL;

  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 223  :     op->orig_type = NULL;

  0008a	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0008f	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;

  00097	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0009c	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 226  :     op->_ob_prev = NULL;

  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  000a9	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;
; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;
; 230  : #endif
; 231  : }

  000b1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b5	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_0CG@CENPHJMO@could?5not?5convert?5string?5to?5floa@ ; `string'
PUBLIC	??_C@_0CO@KCGIELOE@float?$CI?$CJ?5argument?5must?5be?5a?5strin@ ; `string'
PUBLIC	PyFloat_FromString
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyOS_string_to_double:PROC
EXTRN	_Py_ctype_table:BYTE
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyObject_AsCharBuffer:PROC
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	_PyUnicode_TransformDecimalAndSpaceToASCII:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\floatobject.c
pdata	SEGMENT
$pdata$PyFloat_FromString DD imagerel $LN20
	DD	imagerel $LN20+483
	DD	imagerel $unwind$PyFloat_FromString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_FromString DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_0CG@CENPHJMO@could?5not?5convert?5string?5to?5floa@
CONST	SEGMENT
??_C@_0CG@CENPHJMO@could?5not?5convert?5string?5to?5floa@ DB 'could not c'
	DB	'onvert string to float: %R', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KCGIELOE@float?$CI?$CJ?5argument?5must?5be?5a?5strin@
CONST	SEGMENT
??_C@_0CO@KCGIELOE@float?$CI?$CJ?5argument?5must?5be?5a?5strin@ DB 'float'
	DB	'() argument must be a string or a number', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyFloat_FromString
_TEXT	SEGMENT
x$ = 32
last$ = 40
s$ = 48
len$ = 56
end$ = 64
result$ = 72
s_buffer$ = 80
v$ = 112
PyFloat_FromString PROC					; COMDAT

; 134  : {

$LN20:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 135  :     const char *s, *last, *end;
; 136  :     double x;
; 137  :     PyObject *s_buffer = NULL;

  00009	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR s_buffer$[rsp], 0

; 138  :     Py_ssize_t len;
; 139  :     PyObject *result = NULL;

  00012	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 140  : 
; 141  :     if (PyUnicode_Check(v)) {

  0001b	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  00020	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00024	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0002f	85 c0		 test	 eax, eax
  00031	74 4d		 je	 SHORT $LN17@PyFloat_Fr@2

; 142  :         s_buffer = _PyUnicode_TransformDecimalAndSpaceToASCII(v);

  00033	48 8b 4c 24 70	 mov	 rcx, QWORD PTR v$[rsp]
  00038	e8 00 00 00 00	 call	 _PyUnicode_TransformDecimalAndSpaceToASCII
  0003d	48 89 44 24 50	 mov	 QWORD PTR s_buffer$[rsp], rax

; 143  :         if (s_buffer == NULL)

  00042	48 83 7c 24 50
	00		 cmp	 QWORD PTR s_buffer$[rsp], 0
  00048	75 07		 jne	 SHORT $LN16@PyFloat_Fr@2

; 144  :             return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 8d 01 00 00	 jmp	 $LN18@PyFloat_Fr@2
$LN16@PyFloat_Fr@2:

; 145  :         s = PyUnicode_AsUTF8AndSize(s_buffer, &len);

  00051	48 8d 54 24 38	 lea	 rdx, QWORD PTR len$[rsp]
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s_buffer$[rsp]
  0005b	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  00060	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 146  :         if (s == NULL) {

  00065	48 83 7c 24 30
	00		 cmp	 QWORD PTR s$[rsp], 0
  0006b	75 11		 jne	 SHORT $LN15@PyFloat_Fr@2

; 147  :             Py_DECREF(s_buffer);

  0006d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s_buffer$[rsp]
  00072	e8 00 00 00 00	 call	 _Py_DecRef

; 148  :             return NULL;

  00077	33 c0		 xor	 eax, eax
  00079	e9 60 01 00 00	 jmp	 $LN18@PyFloat_Fr@2
$LN15@PyFloat_Fr@2:

; 149  :         }

  0007e	eb 32		 jmp	 SHORT $LN14@PyFloat_Fr@2
$LN17@PyFloat_Fr@2:

; 150  :     }
; 151  :     else if (PyObject_AsCharBuffer(v, &s, &len)) {

  00080	4c 8d 44 24 38	 lea	 r8, QWORD PTR len$[rsp]
  00085	48 8d 54 24 30	 lea	 rdx, QWORD PTR s$[rsp]
  0008a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR v$[rsp]
  0008f	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  00094	85 c0		 test	 eax, eax
  00096	74 1a		 je	 SHORT $LN13@PyFloat_Fr@2

; 152  :         PyErr_SetString(PyExc_TypeError,
; 153  :             "float() argument must be a string or a number");

  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@KCGIELOE@float?$CI?$CJ?5argument?5must?5be?5a?5strin@
  0009f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000a6	e8 00 00 00 00	 call	 PyErr_SetString

; 154  :         return NULL;

  000ab	33 c0		 xor	 eax, eax
  000ad	e9 2c 01 00 00	 jmp	 $LN18@PyFloat_Fr@2
$LN13@PyFloat_Fr@2:
$LN14@PyFloat_Fr@2:

; 155  :     }
; 156  :     last = s + len;

  000b2	48 8b 44 24 38	 mov	 rax, QWORD PTR len$[rsp]
  000b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000bc	48 03 c8	 add	 rcx, rax
  000bf	48 8b c1	 mov	 rax, rcx
  000c2	48 89 44 24 28	 mov	 QWORD PTR last$[rsp], rax
$LN12@PyFloat_Fr@2:

; 157  :     /* strip space */
; 158  :     while (s < last && Py_ISSPACE(*s))

  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR last$[rsp]
  000cc	48 39 44 24 30	 cmp	 QWORD PTR s$[rsp], rax
  000d1	73 30		 jae	 SHORT $LN11@PyFloat_Fr@2
  000d3	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000d8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000db	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000e0	0f b6 c0	 movzx	 eax, al
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000ea	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000ed	83 e0 08	 and	 eax, 8
  000f0	85 c0		 test	 eax, eax
  000f2	74 0f		 je	 SHORT $LN11@PyFloat_Fr@2

; 159  :         s++;

  000f4	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000f9	48 ff c0	 inc	 rax
  000fc	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax
  00101	eb c4		 jmp	 SHORT $LN12@PyFloat_Fr@2
$LN11@PyFloat_Fr@2:
$LN10@PyFloat_Fr@2:

; 160  :     while (s < last - 1 && Py_ISSPACE(last[-1]))

  00103	48 8b 44 24 28	 mov	 rax, QWORD PTR last$[rsp]
  00108	48 ff c8	 dec	 rax
  0010b	48 39 44 24 30	 cmp	 QWORD PTR s$[rsp], rax
  00110	73 31		 jae	 SHORT $LN9@PyFloat_Fr@2
  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR last$[rsp]
  00117	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  0011b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00120	0f b6 c0	 movzx	 eax, al
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0012a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0012d	83 e0 08	 and	 eax, 8
  00130	85 c0		 test	 eax, eax
  00132	74 0f		 je	 SHORT $LN9@PyFloat_Fr@2

; 161  :         last--;

  00134	48 8b 44 24 28	 mov	 rax, QWORD PTR last$[rsp]
  00139	48 ff c8	 dec	 rax
  0013c	48 89 44 24 28	 mov	 QWORD PTR last$[rsp], rax
  00141	eb c0		 jmp	 SHORT $LN10@PyFloat_Fr@2
$LN9@PyFloat_Fr@2:

; 162  :     /* We don't care about overflow or underflow.  If the platform
; 163  :      * supports them, infinities and signed zeroes (on underflow) are
; 164  :      * fine. */
; 165  :     x = PyOS_string_to_double(s, (char **)&end, NULL);

  00143	45 33 c0	 xor	 r8d, r8d
  00146	48 8d 54 24 40	 lea	 rdx, QWORD PTR end$[rsp]
  0014b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00150	e8 00 00 00 00	 call	 PyOS_string_to_double
  00155	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 166  :     if (end != last) {

  0015b	48 8b 44 24 28	 mov	 rax, QWORD PTR last$[rsp]
  00160	48 39 44 24 40	 cmp	 QWORD PTR end$[rsp], rax
  00165	74 23		 je	 SHORT $LN8@PyFloat_Fr@2

; 167  :         PyErr_Format(PyExc_ValueError,
; 168  :                      "could not convert string to float: "
; 169  :                      "%R", v);

  00167	4c 8b 44 24 70	 mov	 r8, QWORD PTR v$[rsp]
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@CENPHJMO@could?5not?5convert?5string?5to?5floa@
  00173	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0017a	e8 00 00 00 00	 call	 PyErr_Format

; 170  :         result = NULL;

  0017f	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0
  00188	eb 37		 jmp	 SHORT $LN7@PyFloat_Fr@2
$LN8@PyFloat_Fr@2:

; 171  :     }
; 172  :     else if (x == -1.0 && PyErr_Occurred())

  0018a	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00190	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00198	7a 17		 jp	 SHORT $LN6@PyFloat_Fr@2
  0019a	75 15		 jne	 SHORT $LN6@PyFloat_Fr@2
  0019c	e8 00 00 00 00	 call	 PyErr_Occurred
  001a1	48 85 c0	 test	 rax, rax
  001a4	74 0b		 je	 SHORT $LN6@PyFloat_Fr@2

; 173  :         result = NULL;

  001a6	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 174  :     else

  001af	eb 10		 jmp	 SHORT $LN5@PyFloat_Fr@2
$LN6@PyFloat_Fr@2:

; 175  :         result = PyFloat_FromDouble(x);

  001b1	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  001b7	e8 00 00 00 00	 call	 PyFloat_FromDouble
  001bc	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax
$LN5@PyFloat_Fr@2:
$LN7@PyFloat_Fr@2:
$LN4@PyFloat_Fr@2:

; 176  : 
; 177  :     Py_XDECREF(s_buffer);

  001c1	48 83 7c 24 50
	00		 cmp	 QWORD PTR s_buffer$[rsp], 0
  001c7	74 0a		 je	 SHORT $LN1@PyFloat_Fr@2
  001c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s_buffer$[rsp]
  001ce	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyFloat_Fr@2:
  001d3	33 c0		 xor	 eax, eax
  001d5	85 c0		 test	 eax, eax
  001d7	75 e8		 jne	 SHORT $LN4@PyFloat_Fr@2

; 178  :     return result;

  001d9	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
$LN18@PyFloat_Fr@2:

; 179  : }

  001de	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001e2	c3		 ret	 0
PyFloat_FromString ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@DJCJEHLE@float_dealloc?$AA@		; `string'
EXTRN	_PyObject_DebugFree:PROC
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_dealloc DD imagerel float_dealloc
	DD	imagerel float_dealloc+154
	DD	imagerel $unwind$float_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_dealloc DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0O@DJCJEHLE@float_dealloc?$AA@
CONST	SEGMENT
??_C@_0O@DJCJEHLE@float_dealloc?$AA@ DB 'float_dealloc', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_dealloc
_TEXT	SEGMENT
op$ = 48
float_dealloc PROC					; COMDAT

; 183  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 184  :     Py_GUARD

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN4@float_deal
  00012	45 33 c9	 xor	 r9d, r9d
  00015	41 b8 b8 00 00
	00		 mov	 r8d, 184		; 000000b8H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@BGCHDLFF@?4?4?2Objects?2floatobject?4c?$AA@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DJCJEHLE@float_dealloc?$AA@
  00029	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN4@float_deal:

; 185  :     if (PyFloat_CheckExact(op)) {

  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0003a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003e	75 41		 jne	 SHORT $LN3@float_deal

; 186  :         if (numfree >= PyFloat_MAXFREELIST)  {

  00040	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR numfree, 100	; 00000064H
  00047	7c 0c		 jl	 SHORT $LN2@float_deal

; 187  :             PyObject_FREE(op);

  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0004e	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 188  :             return;

  00053	eb 40		 jmp	 SHORT $LN5@float_deal
$LN2@float_deal:

; 189  :         }
; 190  :         numfree++;

  00055	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  0005b	ff c0		 inc	 eax
  0005d	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax

; 191  :         Py_TYPE(op) = (struct _typeobject *)free_list;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00068	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR free_list
  0006f	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 192  :         free_list = op;

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00078	48 89 05 00 00
	00 00		 mov	 QWORD PTR free_list, rax

; 193  :     }
; 194  :     else

  0007f	eb 14		 jmp	 SHORT $LN1@float_deal
$LN3@float_deal:

; 195  :         Py_TYPE(op)->tp_free((PyObject *)op);

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00086	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0008f	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]
$LN1@float_deal:
$LN5@float_deal:

; 196  : }

  00095	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00099	c3		 ret	 0
float_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@LMCDCGIG@nb_float?5should?5return?5float?5obj@ ; `string'
PUBLIC	??_C@_0BE@EPAFCIDD@a?5float?5is?5required?$AA@	; `string'
PUBLIC	PyFloat_AsDouble
EXTRN	PyErr_BadArgument:PROC
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFloat_AsDouble DD imagerel $LN10
	DD	imagerel $LN10+325
	DD	imagerel $unwind$PyFloat_AsDouble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_AsDouble DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0CE@LMCDCGIG@nb_float?5should?5return?5float?5obj@
CONST	SEGMENT
??_C@_0CE@LMCDCGIG@nb_float?5should?5return?5float?5obj@ DB 'nb_float sho'
	DB	'uld return float object', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EPAFCIDD@a?5float?5is?5required?$AA@
CONST	SEGMENT
??_C@_0BE@EPAFCIDD@a?5float?5is?5required?$AA@ DB 'a float is required', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyFloat_AsDouble
_TEXT	SEGMENT
fo$ = 32
val$ = 40
nb$ = 48
op$ = 80
PyFloat_AsDouble PROC					; COMDAT

; 200  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 201  :     PyNumberMethods *nb;
; 202  :     PyFloatObject *fo;
; 203  :     double val;
; 204  : 
; 205  :     if (op && PyFloat_Check(op))

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR op$[rsp], 0
  0000f	74 3a		 je	 SHORT $LN7@PyFloat_As
  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00018	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  0001d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00021	74 19		 je	 SHORT $LN6@PyFloat_As
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00033	e8 00 00 00 00	 call	 PyType_IsSubtype
  00038	85 c0		 test	 eax, eax
  0003a	74 0f		 je	 SHORT $LN7@PyFloat_As
$LN6@PyFloat_As:

; 206  :         return PyFloat_AS_DOUBLE((PyFloatObject*) op);

  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00041	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00046	e9 f5 00 00 00	 jmp	 $LN8@PyFloat_As
$LN7@PyFloat_As:

; 207  : 
; 208  :     if (op == NULL) {

  0004b	48 83 7c 24 50
	00		 cmp	 QWORD PTR op$[rsp], 0
  00051	75 12		 jne	 SHORT $LN5@PyFloat_As

; 209  :         PyErr_BadArgument();

  00053	e8 00 00 00 00	 call	 PyErr_BadArgument

; 210  :         return -1;

  00058	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  00060	e9 db 00 00 00	 jmp	 $LN8@PyFloat_As
$LN5@PyFloat_As:

; 211  :     }
; 212  : 
; 213  :     if ((nb = Py_TYPE(op)->tp_as_number) == NULL || nb->nb_float == NULL) {

  00065	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0006a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006e	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00075	48 89 44 24 30	 mov	 QWORD PTR nb$[rsp], rax
  0007a	48 83 7c 24 30
	00		 cmp	 QWORD PTR nb$[rsp], 0
  00080	74 0f		 je	 SHORT $LN3@PyFloat_As
  00082	48 8b 44 24 30	 mov	 rax, QWORD PTR nb$[rsp]
  00087	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  0008f	75 20		 jne	 SHORT $LN4@PyFloat_As
$LN3@PyFloat_As:

; 214  :         PyErr_SetString(PyExc_TypeError, "a float is required");

  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EPAFCIDD@a?5float?5is?5required?$AA@
  00098	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009f	e8 00 00 00 00	 call	 PyErr_SetString

; 215  :         return -1;

  000a4	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  000ac	e9 8f 00 00 00	 jmp	 $LN8@PyFloat_As
$LN4@PyFloat_As:

; 216  :     }
; 217  : 
; 218  :     fo = (PyFloatObject*) (*nb->nb_float) (op);

  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000b6	48 8b 44 24 30	 mov	 rax, QWORD PTR nb$[rsp]
  000bb	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  000c1	48 89 44 24 20	 mov	 QWORD PTR fo$[rsp], rax

; 219  :     if (fo == NULL)

  000c6	48 83 7c 24 20
	00		 cmp	 QWORD PTR fo$[rsp], 0
  000cc	75 0a		 jne	 SHORT $LN2@PyFloat_As

; 220  :         return -1;

  000ce	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  000d6	eb 68		 jmp	 SHORT $LN8@PyFloat_As
$LN2@PyFloat_As:

; 221  :     if (!PyFloat_Check(fo)) {

  000d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  000df	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fo$[rsp]
  000e4	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000e8	74 36		 je	 SHORT $LN1@PyFloat_As
  000ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR fo$[rsp]
  000f6	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000fa	e8 00 00 00 00	 call	 PyType_IsSubtype
  000ff	85 c0		 test	 eax, eax
  00101	75 1d		 jne	 SHORT $LN1@PyFloat_As

; 222  :         PyErr_SetString(PyExc_TypeError,
; 223  :                         "nb_float should return float object");

  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@LMCDCGIG@nb_float?5should?5return?5float?5obj@
  0010a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00111	e8 00 00 00 00	 call	 PyErr_SetString

; 224  :         return -1;

  00116	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  0011e	eb 20		 jmp	 SHORT $LN8@PyFloat_As
$LN1@PyFloat_As:

; 225  :     }
; 226  : 
; 227  :     val = PyFloat_AS_DOUBLE(fo);

  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR fo$[rsp]
  00125	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  0012a	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR val$[rsp], xmm0

; 228  :     Py_DECREF(fo);

  00130	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fo$[rsp]
  00135	e8 00 00 00 00	 call	 _Py_DecRef

; 229  : 
; 230  :     return val;

  0013a	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR val$[rsp]
$LN8@PyFloat_As:

; 231  : }

  00140	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00144	c3		 ret	 0
PyFloat_AsDouble ENDP
_TEXT	ENDS
EXTRN	PyMem_Free:PROC
EXTRN	_PyUnicode_FromASCII:PROC
EXTRN	strlen:PROC
EXTRN	PyOS_double_to_string:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_repr DD imagerel float_repr
	DD	imagerel float_repr+112
	DD	imagerel $unwind$float_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_repr DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_repr
_TEXT	SEGMENT
buf$ = 48
result$ = 56
v$ = 80
float_repr PROC						; COMDAT

; 269  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 270  :     PyObject *result;
; 271  :     char *buf;
; 272  : 
; 273  :     buf = PyOS_double_to_string(PyFloat_AS_DOUBLE(v),
; 274  :                                 'r', 0,
; 275  :                                 Py_DTSF_ADD_DOT_0,
; 276  :                                 NULL);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0000e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00013	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0001c	41 b9 02 00 00
	00		 mov	 r9d, 2
  00022	45 33 c0	 xor	 r8d, r8d
  00025	b2 72		 mov	 dl, 114			; 00000072H
  00027	e8 00 00 00 00	 call	 PyOS_double_to_string
  0002c	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax

; 277  :     if (!buf)

  00031	48 83 7c 24 30
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00037	75 07		 jne	 SHORT $LN1@float_repr

; 278  :         return PyErr_NoMemory();

  00039	e8 00 00 00 00	 call	 PyErr_NoMemory
  0003e	eb 2b		 jmp	 SHORT $LN2@float_repr
$LN1@float_repr:

; 279  :     result = _PyUnicode_FromASCII(buf, strlen(buf));

  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  00045	e8 00 00 00 00	 call	 strlen
  0004a	48 8b d0	 mov	 rdx, rax
  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  00052	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  00057	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 280  :     PyMem_Free(buf);

  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  00061	e8 00 00 00 00	 call	 PyMem_Free

; 281  :     return result;

  00066	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN2@float_repr:

; 282  : }

  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
float_repr ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_1BA@MABPGGHL@?$AAi?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AA?$AA@ ; `string'
PUBLIC	__mask@@NegDouble@
PUBLIC	??_C@_1BG@GDLNIOOD@?$AAv?$AAs?$AAi?$AAg?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@BBDMEPJF@?$AAj?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?4?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CB?$AA?5?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	__real@4000000000000000
PUBLIC	??_C@_1BG@HEJFOKCD@?$AAw?$AAs?$AAi?$AAg?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_1CC@EDEJAKFD@?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	PyBool_FromLong:PROC
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	PyNumber_Or:PROC
EXTRN	PyNumber_Lshift:PROC
EXTRN	PyLong_FromDouble:PROC
EXTRN	__imp_modf:PROC
EXTRN	PyNumber_Negative:PROC
EXTRN	__imp_frexp:PROC
EXTRN	_Py_SwappedOp:BYTE
EXTRN	PyLong_AsDouble:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	_PyLong_NumBits:PROC
EXTRN	_PyLong_Sign:PROC
EXTRN	__imp__finite:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_richcompare DD imagerel float_richcompare
	DD	imagerel float_richcompare+1888
	DD	imagerel $unwind$float_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_richcompare DD 021601H
	DD	0170116H
xdata	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_1BA@MABPGGHL@?$AAi?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@MABPGGHL@?$AAi?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AA?$AA@ DB 'i'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT ??_C@_1BG@GDLNIOOD@?$AAv?$AAs?$AAi?$AAg?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@GDLNIOOD@?$AAv?$AAs?$AAi?$AAg?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'v'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@BBDMEPJF@?$AAj?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?4?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CB?$AA?5?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@BBDMEPJF@?$AAj?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?4?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CB?$AA?5?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'j'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '-', 00H, '1', 00H
	DB	'.', 00H, '0', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, '!'
	DB	00H, ' ', 00H, 'P', 00H, 'y', 00H, 'E', 00H, 'r', 00H, 'r', 00H
	DB	'_', 00H, 'O', 00H, 'c', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'r'
	DB	00H, 'e', 00H, 'd', 00H, '(', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT ??_C@_1BG@HEJFOKCD@?$AAw?$AAs?$AAi?$AAg?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@HEJFOKCD@?$AAw?$AAs?$AAi?$AAg?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'w'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_1CC@EDEJAKFD@?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@EDEJAKFD@?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'F', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 't', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'v', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'f', 00H, 'l', 00H, 'o'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_richcompare
_TEXT	SEGMENT
i$ = 32
r$ = 40
j$ = 48
wsign$20514 = 56
exponent$20516 = 60
nbits$20515 = 64
vsign$20513 = 72
intpart$20542 = 80
vv$20547 = 88
fracpart$20541 = 96
one$20545 = 104
result$20543 = 112
ww$20549 = 120
temp$20559 = 128
tv132 = 136
tv131 = 140
tv234 = 144
tv236 = 148
tv238 = 152
tv240 = 156
tv242 = 160
tv244 = 164
tv246 = 168
v$ = 192
w$ = 200
op$ = 208
float_richcompare PROC					; COMDAT

; 301  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 302  :     double i, j;
; 303  :     int r = 0;

  00016	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR r$[rsp], 0

; 304  : 
; 305  :     assert(PyFloat_Check(v));

  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00025	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0002d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00031	74 38		 je	 SHORT $LN49@float_rich
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0003a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00042	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00046	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004b	85 c0		 test	 eax, eax
  0004d	75 1c		 jne	 SHORT $LN49@float_rich
  0004f	41 b8 31 01 00
	00		 mov	 r8d, 305		; 00000131H
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@EDEJAKFD@?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00069	33 c0		 xor	 eax, eax
$LN49@float_rich:

; 306  :     i = PyFloat_AS_DOUBLE(v);

  0006b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00073	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00078	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR i$[rsp], xmm0

; 307  : 
; 308  :     /* Switch on the type of w.  Set i and j to doubles to be compared,
; 309  :      * and op to the richcomp to use.
; 310  :      */
; 311  :     if (PyFloat_Check(w))

  0007e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00085	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  0008d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00091	74 1c		 je	 SHORT $LN45@float_rich
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0009a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000a2	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000a6	e8 00 00 00 00	 call	 PyType_IsSubtype
  000ab	85 c0		 test	 eax, eax
  000ad	74 18		 je	 SHORT $LN46@float_rich
$LN45@float_rich:

; 312  :         j = PyFloat_AS_DOUBLE(w);

  000af	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000b7	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  000bc	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR j$[rsp], xmm0
  000c2	e9 e7 04 00 00	 jmp	 $LN44@float_rich
$LN46@float_rich:

; 313  : 
; 314  :     else if (!Py_IS_FINITE(i)) {

  000c7	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR i$[rsp]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000d3	85 c0		 test	 eax, eax
  000d5	75 31		 jne	 SHORT $LN43@float_rich

; 315  :         if (PyLong_Check(w))

  000d7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000df	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000e3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000e9	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000ee	85 c0		 test	 eax, eax
  000f0	74 0c		 je	 SHORT $LN42@float_rich

; 316  :             /* If i is an infinity, its magnitude exceeds any
; 317  :              * finite integer, so it doesn't matter which int we
; 318  :              * compare i with.  If i is a NaN, similarly.
; 319  :              */
; 320  :             j = 0.0;

  000f2	66 0f 57 c0	 xorpd	 xmm0, xmm0
  000f6	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR j$[rsp], xmm0

; 321  :         else

  000fc	eb 05		 jmp	 SHORT $LN41@float_rich
$LN42@float_rich:

; 322  :             goto Unimplemented;

  000fe	e9 2a 06 00 00	 jmp	 $Unimplemented$20509
$LN41@float_rich:

; 323  :     }
; 324  : 
; 325  :     else if (PyLong_Check(w)) {

  00103	e9 a6 04 00 00	 jmp	 $LN40@float_rich
$LN43@float_rich:
  00108	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00110	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00114	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0011a	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0011f	85 c0		 test	 eax, eax
  00121	0f 84 82 04 00
	00		 je	 $LN39@float_rich

; 326  :         int vsign = i == 0.0 ? 0 : i < 0.0 ? -1 : 1;

  00127	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR i$[rsp]
  0012d	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00135	7a 0f		 jp	 SHORT $LN52@float_rich
  00137	75 0d		 jne	 SHORT $LN52@float_rich
  00139	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
  00144	eb 32		 jmp	 SHORT $LN53@float_rich
$LN52@float_rich:
  00146	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0014a	66 0f 2f 44 24
	20		 comisd	 xmm0, QWORD PTR i$[rsp]
  00150	76 0d		 jbe	 SHORT $LN50@float_rich
  00152	c7 84 24 8c 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv131[rsp], -1
  0015d	eb 0b		 jmp	 SHORT $LN51@float_rich
$LN50@float_rich:
  0015f	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv131[rsp], 1
$LN51@float_rich:
  0016a	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv131[rsp]
  00171	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv132[rsp], eax
$LN53@float_rich:
  00178	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv132[rsp]
  0017f	89 44 24 48	 mov	 DWORD PTR vsign$20513[rsp], eax

; 327  :         int wsign = _PyLong_Sign(w);

  00183	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  0018b	e8 00 00 00 00	 call	 _PyLong_Sign
  00190	89 44 24 38	 mov	 DWORD PTR wsign$20514[rsp], eax

; 328  :         size_t nbits;
; 329  :         int exponent;
; 330  : 
; 331  :         if (vsign != wsign) {

  00194	8b 44 24 38	 mov	 eax, DWORD PTR wsign$20514[rsp]
  00198	39 44 24 48	 cmp	 DWORD PTR vsign$20513[rsp], eax
  0019c	74 25		 je	 SHORT $LN38@float_rich

; 332  :             /* Magnitudes are irrelevant -- the signs alone
; 333  :              * determine the outcome.
; 334  :              */
; 335  :             i = (double)vsign;

  0019e	66 0f 6e 44 24
	48		 movd	 xmm0, DWORD PTR vsign$20513[rsp]
  001a4	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001a8	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR i$[rsp], xmm0

; 336  :             j = (double)wsign;

  001ae	66 0f 6e 44 24
	38		 movd	 xmm0, DWORD PTR wsign$20514[rsp]
  001b4	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001b8	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR j$[rsp], xmm0

; 337  :             goto Compare;

  001be	e9 eb 03 00 00	 jmp	 $Compare$20520
$LN38@float_rich:

; 338  :         }
; 339  :         /* The signs are the same. */
; 340  :         /* Convert w to a double if it fits.  In particular, 0 fits. */
; 341  :         nbits = _PyLong_NumBits(w);

  001c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  001cb	e8 00 00 00 00	 call	 _PyLong_NumBits
  001d0	48 89 44 24 40	 mov	 QWORD PTR nbits$20515[rsp], rax

; 342  :         if (nbits == (size_t)-1 && PyErr_Occurred()) {

  001d5	48 83 7c 24 40
	ff		 cmp	 QWORD PTR nbits$20515[rsp], -1
  001db	75 5f		 jne	 SHORT $LN37@float_rich
  001dd	e8 00 00 00 00	 call	 PyErr_Occurred
  001e2	48 85 c0	 test	 rax, rax
  001e5	74 55		 je	 SHORT $LN37@float_rich

; 343  :             /* This long is so large that size_t isn't big enough
; 344  :              * to hold the # of bits.  Replace with little doubles
; 345  :              * that give the same outcome -- w is so large that
; 346  :              * its magnitude must exceed the magnitude of any
; 347  :              * finite float.
; 348  :              */
; 349  :             PyErr_Clear();

  001e7	e8 00 00 00 00	 call	 PyErr_Clear

; 350  :             i = (double)vsign;

  001ec	66 0f 6e 44 24
	48		 movd	 xmm0, DWORD PTR vsign$20513[rsp]
  001f2	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001f6	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR i$[rsp], xmm0

; 351  :             assert(wsign != 0);

  001fc	83 7c 24 38 00	 cmp	 DWORD PTR wsign$20514[rsp], 0
  00201	75 1c		 jne	 SHORT $LN54@float_rich
  00203	41 b8 5f 01 00
	00		 mov	 r8d, 351		; 0000015fH
  00209	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@HEJFOKCD@?$AAw?$AAs?$AAi?$AAg?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0021d	33 c0		 xor	 eax, eax
$LN54@float_rich:

; 352  :             j = wsign * 2.0;

  0021f	66 0f 6e 44 24
	38		 movd	 xmm0, DWORD PTR wsign$20514[rsp]
  00225	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00229	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
  00231	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR j$[rsp], xmm0

; 353  :             goto Compare;

  00237	e9 72 03 00 00	 jmp	 $Compare$20520
$LN37@float_rich:

; 354  :         }
; 355  :         if (nbits <= 48) {

  0023c	48 83 7c 24 40
	30		 cmp	 QWORD PTR nbits$20515[rsp], 48 ; 00000030H
  00242	77 50		 ja	 SHORT $LN36@float_rich

; 356  :             j = PyLong_AsDouble(w);

  00244	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  0024c	e8 00 00 00 00	 call	 PyLong_AsDouble
  00251	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR j$[rsp], xmm0

; 357  :             /* It's impossible that <= 48 bits overflowed. */
; 358  :             assert(j != -1.0 || ! PyErr_Occurred());

  00257	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR j$[rsp]
  0025d	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00265	7a 28		 jp	 SHORT $LN55@float_rich
  00267	75 26		 jne	 SHORT $LN55@float_rich
  00269	e8 00 00 00 00	 call	 PyErr_Occurred
  0026e	48 85 c0	 test	 rax, rax
  00271	74 1c		 je	 SHORT $LN55@float_rich
  00273	41 b8 66 01 00
	00		 mov	 r8d, 358		; 00000166H
  00279	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@BBDMEPJF@?$AAj?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?4?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CB?$AA?5?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  00287	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0028d	33 c0		 xor	 eax, eax
$LN55@float_rich:

; 359  :             goto Compare;

  0028f	e9 1a 03 00 00	 jmp	 $Compare$20520
$LN36@float_rich:

; 360  :         }
; 361  :         assert(wsign != 0); /* else nbits was 0 */

  00294	83 7c 24 38 00	 cmp	 DWORD PTR wsign$20514[rsp], 0
  00299	75 1c		 jne	 SHORT $LN56@float_rich
  0029b	41 b8 69 01 00
	00		 mov	 r8d, 361		; 00000169H
  002a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@HEJFOKCD@?$AAw?$AAs?$AAi?$AAg?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002b5	33 c0		 xor	 eax, eax
$LN56@float_rich:

; 362  :         assert(vsign != 0); /* if vsign were 0, then since wsign is

  002b7	83 7c 24 48 00	 cmp	 DWORD PTR vsign$20513[rsp], 0
  002bc	75 1c		 jne	 SHORT $LN57@float_rich
  002be	41 b8 6a 01 00
	00		 mov	 r8d, 362		; 0000016aH
  002c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@GDLNIOOD@?$AAv?$AAs?$AAi?$AAg?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  002d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002d8	33 c0		 xor	 eax, eax
$LN57@float_rich:

; 363  :                              * not 0, we would have taken the
; 364  :                              * vsign != wsign branch at the start */
; 365  :         /* We want to work with non-negative numbers. */
; 366  :         if (vsign < 0) {

  002da	83 7c 24 48 00	 cmp	 DWORD PTR vsign$20513[rsp], 0
  002df	7d 2d		 jge	 SHORT $LN35@float_rich

; 367  :             /* "Multiply both sides" by -1; this also swaps the
; 368  :              * comparator.
; 369  :              */
; 370  :             i = -i;

  002e1	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR i$[rsp]
  002e7	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  002ef	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR i$[rsp], xmm0

; 371  :             op = _Py_SwappedOp[op];

  002f5	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR op$[rsp]
  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_SwappedOp
  00304	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00307	89 84 24 d0 00
	00 00		 mov	 DWORD PTR op$[rsp], eax
$LN35@float_rich:

; 372  :         }
; 373  :         assert(i > 0.0);

  0030e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR i$[rsp]
  00314	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  0031c	77 1c		 ja	 SHORT $LN58@float_rich
  0031e	41 b8 75 01 00
	00		 mov	 r8d, 373		; 00000175H
  00324	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0032b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BA@MABPGGHL@?$AAi?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AA?$AA@
  00332	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00338	33 c0		 xor	 eax, eax
$LN58@float_rich:

; 374  :         (void) frexp(i, &exponent);

  0033a	48 8d 54 24 3c	 lea	 rdx, QWORD PTR exponent$20516[rsp]
  0033f	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR i$[rsp]
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp

; 375  :         /* exponent is the # of bits in v before the radix point;
; 376  :          * we know that nbits (the # of bits in w) > 48 at this point
; 377  :          */
; 378  :         if (exponent < 0 || (size_t)exponent < nbits) {

  0034b	83 7c 24 3c 00	 cmp	 DWORD PTR exponent$20516[rsp], 0
  00350	7c 0c		 jl	 SHORT $LN33@float_rich
  00352	48 63 44 24 3c	 movsxd	 rax, DWORD PTR exponent$20516[rsp]
  00357	48 3b 44 24 40	 cmp	 rax, QWORD PTR nbits$20515[rsp]
  0035c	73 21		 jae	 SHORT $LN34@float_rich
$LN33@float_rich:

; 379  :             i = 1.0;

  0035e	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00366	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR i$[rsp], xmm0

; 380  :             j = 2.0;

  0036c	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  00374	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR j$[rsp], xmm0

; 381  :             goto Compare;

  0037a	e9 2f 02 00 00	 jmp	 $Compare$20520
$LN34@float_rich:

; 382  :         }
; 383  :         if ((size_t)exponent > nbits) {

  0037f	48 63 44 24 3c	 movsxd	 rax, DWORD PTR exponent$20516[rsp]
  00384	48 3b 44 24 40	 cmp	 rax, QWORD PTR nbits$20515[rsp]
  00389	76 21		 jbe	 SHORT $LN32@float_rich

; 384  :             i = 2.0;

  0038b	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  00393	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR i$[rsp], xmm0

; 385  :             j = 1.0;

  00399	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  003a1	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR j$[rsp], xmm0

; 386  :             goto Compare;

  003a7	e9 02 02 00 00	 jmp	 $Compare$20520
$LN32@float_rich:

; 387  :         }
; 388  :         /* v and w have the same number of bits before the radix
; 389  :          * point.  Construct two ints that have the same comparison
; 390  :          * outcome.
; 391  :          */
; 392  :         {
; 393  :             double fracpart;
; 394  :             double intpart;
; 395  :             PyObject *result = NULL;

  003ac	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR result$20543[rsp], 0

; 396  :             PyObject *one = NULL;

  003b5	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR one$20545[rsp], 0

; 397  :             PyObject *vv = NULL;

  003be	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR vv$20547[rsp], 0

; 398  :             PyObject *ww = w;

  003c7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  003cf	48 89 44 24 78	 mov	 QWORD PTR ww$20549[rsp], rax

; 399  : 
; 400  :             if (wsign < 0) {

  003d4	83 7c 24 38 00	 cmp	 DWORD PTR wsign$20514[rsp], 0
  003d9	7d 21		 jge	 SHORT $LN31@float_rich

; 401  :                 ww = PyNumber_Negative(w);

  003db	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  003e3	e8 00 00 00 00	 call	 PyNumber_Negative
  003e8	48 89 44 24 78	 mov	 QWORD PTR ww$20549[rsp], rax

; 402  :                 if (ww == NULL)

  003ed	48 83 7c 24 78
	00		 cmp	 QWORD PTR ww$20549[rsp], 0
  003f3	75 05		 jne	 SHORT $LN30@float_rich

; 403  :                     goto Error;

  003f5	e9 5b 01 00 00	 jmp	 $Error$20553
$LN30@float_rich:

; 404  :             }
; 405  :             else

  003fa	eb 0a		 jmp	 SHORT $LN29@float_rich
$LN31@float_rich:

; 406  :                 Py_INCREF(ww);

  003fc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ww$20549[rsp]
  00401	e8 00 00 00 00	 call	 _Py_IncRef
$LN29@float_rich:

; 407  : 
; 408  :             fracpart = modf(i, &intpart);

  00406	48 8d 54 24 50	 lea	 rdx, QWORD PTR intpart$20542[rsp]
  0040b	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR i$[rsp]
  00411	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf
  00417	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR fracpart$20541[rsp], xmm0

; 409  :             vv = PyLong_FromDouble(intpart);

  0041d	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR intpart$20542[rsp]
  00423	e8 00 00 00 00	 call	 PyLong_FromDouble
  00428	48 89 44 24 58	 mov	 QWORD PTR vv$20547[rsp], rax

; 410  :             if (vv == NULL)

  0042d	48 83 7c 24 58
	00		 cmp	 QWORD PTR vv$20547[rsp], 0
  00433	75 05		 jne	 SHORT $LN28@float_rich

; 411  :                 goto Error;

  00435	e9 1b 01 00 00	 jmp	 $Error$20553
$LN28@float_rich:

; 412  : 
; 413  :             if (fracpart != 0.0) {

  0043a	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR fracpart$20541[rsp]
  00440	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00448	7a 06		 jp	 SHORT $LN73@float_rich
  0044a	0f 84 d3 00 00
	00		 je	 $LN27@float_rich
$LN73@float_rich:

; 414  :                 /* Shift left, and or a 1 bit into vv
; 415  :                  * to represent the lost fraction.
; 416  :                  */
; 417  :                 PyObject *temp;
; 418  : 
; 419  :                 one = PyLong_FromLong(1);

  00450	b9 01 00 00 00	 mov	 ecx, 1
  00455	e8 00 00 00 00	 call	 PyLong_FromLong
  0045a	48 89 44 24 68	 mov	 QWORD PTR one$20545[rsp], rax

; 420  :                 if (one == NULL)

  0045f	48 83 7c 24 68
	00		 cmp	 QWORD PTR one$20545[rsp], 0
  00465	75 05		 jne	 SHORT $LN26@float_rich

; 421  :                     goto Error;

  00467	e9 e9 00 00 00	 jmp	 $Error$20553
$LN26@float_rich:

; 422  : 
; 423  :                 temp = PyNumber_Lshift(ww, one);

  0046c	48 8b 54 24 68	 mov	 rdx, QWORD PTR one$20545[rsp]
  00471	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ww$20549[rsp]
  00476	e8 00 00 00 00	 call	 PyNumber_Lshift
  0047b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR temp$20559[rsp], rax

; 424  :                 if (temp == NULL)

  00483	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR temp$20559[rsp], 0
  0048c	75 05		 jne	 SHORT $LN25@float_rich

; 425  :                     goto Error;

  0048e	e9 c2 00 00 00	 jmp	 $Error$20553
$LN25@float_rich:

; 426  :                 Py_DECREF(ww);

  00493	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ww$20549[rsp]
  00498	e8 00 00 00 00	 call	 _Py_DecRef

; 427  :                 ww = temp;

  0049d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR temp$20559[rsp]
  004a5	48 89 44 24 78	 mov	 QWORD PTR ww$20549[rsp], rax

; 428  : 
; 429  :                 temp = PyNumber_Lshift(vv, one);

  004aa	48 8b 54 24 68	 mov	 rdx, QWORD PTR one$20545[rsp]
  004af	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vv$20547[rsp]
  004b4	e8 00 00 00 00	 call	 PyNumber_Lshift
  004b9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR temp$20559[rsp], rax

; 430  :                 if (temp == NULL)

  004c1	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR temp$20559[rsp], 0
  004ca	75 05		 jne	 SHORT $LN24@float_rich

; 431  :                     goto Error;

  004cc	e9 84 00 00 00	 jmp	 $Error$20553
$LN24@float_rich:

; 432  :                 Py_DECREF(vv);

  004d1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vv$20547[rsp]
  004d6	e8 00 00 00 00	 call	 _Py_DecRef

; 433  :                 vv = temp;

  004db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR temp$20559[rsp]
  004e3	48 89 44 24 58	 mov	 QWORD PTR vv$20547[rsp], rax

; 434  : 
; 435  :                 temp = PyNumber_Or(vv, one);

  004e8	48 8b 54 24 68	 mov	 rdx, QWORD PTR one$20545[rsp]
  004ed	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vv$20547[rsp]
  004f2	e8 00 00 00 00	 call	 PyNumber_Or
  004f7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR temp$20559[rsp], rax

; 436  :                 if (temp == NULL)

  004ff	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR temp$20559[rsp], 0
  00508	75 02		 jne	 SHORT $LN23@float_rich

; 437  :                     goto Error;

  0050a	eb 49		 jmp	 SHORT $Error$20553
$LN23@float_rich:

; 438  :                 Py_DECREF(vv);

  0050c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vv$20547[rsp]
  00511	e8 00 00 00 00	 call	 _Py_DecRef

; 439  :                 vv = temp;

  00516	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR temp$20559[rsp]
  0051e	48 89 44 24 58	 mov	 QWORD PTR vv$20547[rsp], rax
$LN27@float_rich:

; 440  :             }
; 441  : 
; 442  :             r = PyObject_RichCompareBool(vv, ww, op);

  00523	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR op$[rsp]
  0052b	48 8b 54 24 78	 mov	 rdx, QWORD PTR ww$20549[rsp]
  00530	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vv$20547[rsp]
  00535	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0053a	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 443  :             if (r < 0)

  0053e	83 7c 24 28 00	 cmp	 DWORD PTR r$[rsp], 0
  00543	7d 02		 jge	 SHORT $LN22@float_rich

; 444  :                 goto Error;

  00545	eb 0e		 jmp	 SHORT $Error$20553
$LN22@float_rich:

; 445  :             result = PyBool_FromLong(r);

  00547	8b 4c 24 28	 mov	 ecx, DWORD PTR r$[rsp]
  0054b	e8 00 00 00 00	 call	 PyBool_FromLong
  00550	48 89 44 24 70	 mov	 QWORD PTR result$20543[rsp], rax
$Error$20553:
$LN21@float_rich:

; 446  :          Error:
; 447  :             Py_XDECREF(vv);

  00555	48 83 7c 24 58
	00		 cmp	 QWORD PTR vv$20547[rsp], 0
  0055b	74 0a		 je	 SHORT $LN18@float_rich
  0055d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vv$20547[rsp]
  00562	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@float_rich:
  00567	33 c0		 xor	 eax, eax
  00569	85 c0		 test	 eax, eax
  0056b	75 e8		 jne	 SHORT $LN21@float_rich
$LN17@float_rich:

; 448  :             Py_XDECREF(ww);

  0056d	48 83 7c 24 78
	00		 cmp	 QWORD PTR ww$20549[rsp], 0
  00573	74 0a		 je	 SHORT $LN14@float_rich
  00575	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ww$20549[rsp]
  0057a	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@float_rich:
  0057f	33 c0		 xor	 eax, eax
  00581	85 c0		 test	 eax, eax
  00583	75 e8		 jne	 SHORT $LN17@float_rich
$LN13@float_rich:

; 449  :             Py_XDECREF(one);

  00585	48 83 7c 24 68
	00		 cmp	 QWORD PTR one$20545[rsp], 0
  0058b	74 0a		 je	 SHORT $LN10@float_rich
  0058d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR one$20545[rsp]
  00592	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@float_rich:
  00597	33 c0		 xor	 eax, eax
  00599	85 c0		 test	 eax, eax
  0059b	75 e8		 jne	 SHORT $LN13@float_rich

; 450  :             return result;

  0059d	48 8b 44 24 70	 mov	 rax, QWORD PTR result$20543[rsp]
  005a2	e9 99 01 00 00	 jmp	 $LN47@float_rich

; 451  :         }
; 452  :     } /* else if (PyLong_Check(w)) */
; 453  : 
; 454  :     else        /* w isn't float or int */

  005a7	eb 05		 jmp	 SHORT $LN9@float_rich
$LN39@float_rich:

; 455  :         goto Unimplemented;

  005a9	e9 7f 01 00 00	 jmp	 $Unimplemented$20509
$LN9@float_rich:
$LN40@float_rich:
$LN44@float_rich:
$Compare$20520:

; 456  : 
; 457  :  Compare:
; 458  :     PyFPE_START_PROTECT("richcompare", return NULL)
; 459  :     switch (op) {

  005ae	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  005b5	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv234[rsp], eax
  005bc	83 bc 24 90 00
	00 00 05	 cmp	 DWORD PTR tv234[rsp], 5
  005c4	0f 87 58 01 00
	00		 ja	 $LN7@float_rich
  005ca	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR tv234[rsp]
  005d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  005d9	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN72@float_rich[rcx+rax*4]
  005e0	48 03 c1	 add	 rax, rcx
  005e3	ff e0		 jmp	 rax
$LN6@float_rich:

; 460  :     case Py_EQ:
; 461  :         r = i == j;

  005e5	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR i$[rsp]
  005eb	66 0f 2e 44 24
	30		 ucomisd xmm0, QWORD PTR j$[rsp]
  005f1	7a 0f		 jp	 SHORT $LN59@float_rich
  005f3	75 0d		 jne	 SHORT $LN59@float_rich
  005f5	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv236[rsp], 1
  00600	eb 0b		 jmp	 SHORT $LN60@float_rich
$LN59@float_rich:
  00602	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv236[rsp], 0
$LN60@float_rich:
  0060d	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv236[rsp]
  00614	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 462  :         break;

  00618	e9 05 01 00 00	 jmp	 $LN7@float_rich
$LN5@float_rich:

; 463  :     case Py_NE:
; 464  :         r = i != j;

  0061d	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR i$[rsp]
  00623	66 0f 2e 44 24
	30		 ucomisd xmm0, QWORD PTR j$[rsp]
  00629	7a 02		 jp	 SHORT $LN71@float_rich
  0062b	74 0d		 je	 SHORT $LN61@float_rich
$LN71@float_rich:
  0062d	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv238[rsp], 1
  00638	eb 0b		 jmp	 SHORT $LN62@float_rich
$LN61@float_rich:
  0063a	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv238[rsp], 0
$LN62@float_rich:
  00645	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv238[rsp]
  0064c	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 465  :         break;

  00650	e9 cd 00 00 00	 jmp	 $LN7@float_rich
$LN4@float_rich:

; 466  :     case Py_LE:
; 467  :         r = i <= j;

  00655	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR j$[rsp]
  0065b	66 0f 2f 44 24
	20		 comisd	 xmm0, QWORD PTR i$[rsp]
  00661	72 0d		 jb	 SHORT $LN63@float_rich
  00663	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv240[rsp], 1
  0066e	eb 0b		 jmp	 SHORT $LN64@float_rich
$LN63@float_rich:
  00670	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv240[rsp], 0
$LN64@float_rich:
  0067b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv240[rsp]
  00682	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 468  :         break;

  00686	e9 97 00 00 00	 jmp	 $LN7@float_rich
$LN3@float_rich:

; 469  :     case Py_GE:
; 470  :         r = i >= j;

  0068b	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR i$[rsp]
  00691	66 0f 2f 44 24
	30		 comisd	 xmm0, QWORD PTR j$[rsp]
  00697	72 0d		 jb	 SHORT $LN65@float_rich
  00699	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv242[rsp], 1
  006a4	eb 0b		 jmp	 SHORT $LN66@float_rich
$LN65@float_rich:
  006a6	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv242[rsp], 0
$LN66@float_rich:
  006b1	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv242[rsp]
  006b8	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 471  :         break;

  006bc	eb 64		 jmp	 SHORT $LN7@float_rich
$LN2@float_rich:

; 472  :     case Py_LT:
; 473  :         r = i < j;

  006be	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR j$[rsp]
  006c4	66 0f 2f 44 24
	20		 comisd	 xmm0, QWORD PTR i$[rsp]
  006ca	76 0d		 jbe	 SHORT $LN67@float_rich
  006cc	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv244[rsp], 1
  006d7	eb 0b		 jmp	 SHORT $LN68@float_rich
$LN67@float_rich:
  006d9	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv244[rsp], 0
$LN68@float_rich:
  006e4	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv244[rsp]
  006eb	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 474  :         break;

  006ef	eb 31		 jmp	 SHORT $LN7@float_rich
$LN1@float_rich:

; 475  :     case Py_GT:
; 476  :         r = i > j;

  006f1	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR i$[rsp]
  006f7	66 0f 2f 44 24
	30		 comisd	 xmm0, QWORD PTR j$[rsp]
  006fd	76 0d		 jbe	 SHORT $LN69@float_rich
  006ff	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv246[rsp], 1
  0070a	eb 0b		 jmp	 SHORT $LN70@float_rich
$LN69@float_rich:
  0070c	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv246[rsp], 0
$LN70@float_rich:
  00717	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv246[rsp]
  0071e	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax
$LN7@float_rich:

; 477  :         break;
; 478  :     }
; 479  :     PyFPE_END_PROTECT(r)
; 480  :     return PyBool_FromLong(r);

  00722	8b 4c 24 28	 mov	 ecx, DWORD PTR r$[rsp]
  00726	e8 00 00 00 00	 call	 PyBool_FromLong
  0072b	eb 13		 jmp	 SHORT $LN47@float_rich
$Unimplemented$20509:

; 481  : 
; 482  :  Unimplemented:
; 483  :     Py_RETURN_NOTIMPLEMENTED;

  0072d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00734	e8 00 00 00 00	 call	 _Py_IncRef
  00739	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN47@float_rich:

; 484  : }

  00740	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00747	c3		 ret	 0
$LN72@float_rich:
  00748	00 00 00 00	 DD	 $LN2@float_rich
  0074c	00 00 00 00	 DD	 $LN4@float_rich
  00750	00 00 00 00	 DD	 $LN6@float_rich
  00754	00 00 00 00	 DD	 $LN5@float_rich
  00758	00 00 00 00	 DD	 $LN1@float_rich
  0075c	00 00 00 00	 DD	 $LN3@float_rich
float_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
EXTRN	_Py_HashDouble:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\floatobject.c
pdata	SEGMENT
$pdata$float_hash DD imagerel float_hash
	DD	imagerel float_hash+29
	DD	imagerel $unwind$float_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_hash DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_hash
_TEXT	SEGMENT
v$ = 48
float_hash PROC						; COMDAT

; 488  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 489  :     return _Py_HashDouble(v->ob_fval);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0000e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00013	e8 00 00 00 00	 call	 _Py_HashDouble

; 490  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
float_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_add DD imagerel float_add
	DD	imagerel float_add+222
	DD	imagerel $unwind$float_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_add DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_add
_TEXT	SEGMENT
a$ = 32
b$ = 40
v$ = 64
w$ = 72
float_add PROC						; COMDAT

; 494  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 495  :     double a,b;
; 496  :     CONVERT_TO_DOUBLE(v, a);

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 19		 je	 SHORT $LN7@float_add
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	74 12		 je	 SHORT $LN8@float_add
$LN7@float_add:
  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0003e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00043	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR a$[rsp], xmm0
  00049	eb 1a		 jmp	 SHORT $LN6@float_add
$LN8@float_add:
  0004b	48 8d 54 24 20	 lea	 rdx, QWORD PTR a$[rsp]
  00050	48 8d 4c 24 40	 lea	 rcx, QWORD PTR v$[rsp]
  00055	e8 00 00 00 00	 call	 convert_to_double
  0005a	85 c0		 test	 eax, eax
  0005c	7d 07		 jge	 SHORT $LN5@float_add
  0005e	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00063	eb 74		 jmp	 SHORT $LN9@float_add
$LN5@float_add:
$LN6@float_add:

; 497  :     CONVERT_TO_DOUBLE(w, b);

  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0006c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR w$[rsp]
  00071	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00075	74 19		 je	 SHORT $LN3@float_add
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  00083	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00087	e8 00 00 00 00	 call	 PyType_IsSubtype
  0008c	85 c0		 test	 eax, eax
  0008e	74 12		 je	 SHORT $LN4@float_add
$LN3@float_add:
  00090	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  00095	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  0009a	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR b$[rsp], xmm0
  000a0	eb 1a		 jmp	 SHORT $LN2@float_add
$LN4@float_add:
  000a2	48 8d 54 24 28	 lea	 rdx, QWORD PTR b$[rsp]
  000a7	48 8d 4c 24 48	 lea	 rcx, QWORD PTR w$[rsp]
  000ac	e8 00 00 00 00	 call	 convert_to_double
  000b1	85 c0		 test	 eax, eax
  000b3	7d 07		 jge	 SHORT $LN1@float_add
  000b5	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  000ba	eb 1d		 jmp	 SHORT $LN9@float_add
$LN1@float_add:
$LN2@float_add:

; 498  :     PyFPE_START_PROTECT("add", return 0)
; 499  :     a = a + b;

  000bc	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR a$[rsp]
  000c2	f2 0f 58 44 24
	28		 addsd	 xmm0, QWORD PTR b$[rsp]
  000c8	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR a$[rsp], xmm0

; 500  :     PyFPE_END_PROTECT(a)
; 501  :     return PyFloat_FromDouble(a);

  000ce	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR a$[rsp]
  000d4	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN9@float_add:

; 502  : }

  000d9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dd	c3		 ret	 0
float_add ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$convert_to_double DD imagerel convert_to_double
	DD	imagerel convert_to_double+163
	DD	imagerel $unwind$convert_to_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convert_to_double DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT convert_to_double
_TEXT	SEGMENT
obj$ = 32
v$ = 64
dbl$ = 72
convert_to_double PROC					; COMDAT

; 249  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 250  :     register PyObject *obj = *v;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 20	 mov	 QWORD PTR obj$[rsp], rax

; 251  : 
; 252  :     if (PyLong_Check(obj)) {

  0001b	48 8b 44 24 20	 mov	 rax, QWORD PTR obj$[rsp]
  00020	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00024	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002a	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0002f	85 c0		 test	 eax, eax
  00031	74 47		 je	 SHORT $LN3@convert_to

; 253  :         *dbl = PyLong_AsDouble(obj);

  00033	48 8b 4c 24 20	 mov	 rcx, QWORD PTR obj$[rsp]
  00038	e8 00 00 00 00	 call	 PyLong_AsDouble
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR dbl$[rsp]
  00042	f2 0f 11 00	 movsdx	 QWORD PTR [rax], xmm0

; 254  :         if (*dbl == -1.0 && PyErr_Occurred()) {

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR dbl$[rsp]
  0004b	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0004f	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00057	7a 1f		 jp	 SHORT $LN2@convert_to
  00059	75 1d		 jne	 SHORT $LN2@convert_to
  0005b	e8 00 00 00 00	 call	 PyErr_Occurred
  00060	48 85 c0	 test	 rax, rax
  00063	74 13		 je	 SHORT $LN2@convert_to

; 255  :             *v = NULL;

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0006a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 256  :             return -1;

  00071	b8 ff ff ff ff	 mov	 eax, -1
  00076	eb 26		 jmp	 SHORT $LN4@convert_to
$LN2@convert_to:

; 257  :         }
; 258  :     }
; 259  :     else {

  00078	eb 22		 jmp	 SHORT $LN1@convert_to
$LN3@convert_to:

; 260  :         Py_INCREF(Py_NotImplemented);

  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00081	e8 00 00 00 00	 call	 _Py_IncRef

; 261  :         *v = Py_NotImplemented;

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00092	48 89 08	 mov	 QWORD PTR [rax], rcx

; 262  :         return -1;

  00095	b8 ff ff ff ff	 mov	 eax, -1
  0009a	eb 02		 jmp	 SHORT $LN4@convert_to
$LN1@convert_to:

; 263  :     }
; 264  :     return 0;

  0009c	33 c0		 xor	 eax, eax
$LN4@convert_to:

; 265  : }

  0009e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a2	c3		 ret	 0
convert_to_double ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_sub DD imagerel float_sub
	DD	imagerel float_sub+222
	DD	imagerel $unwind$float_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_sub DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_sub
_TEXT	SEGMENT
a$ = 32
b$ = 40
v$ = 64
w$ = 72
float_sub PROC						; COMDAT

; 506  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 507  :     double a,b;
; 508  :     CONVERT_TO_DOUBLE(v, a);

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 19		 je	 SHORT $LN7@float_sub
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	74 12		 je	 SHORT $LN8@float_sub
$LN7@float_sub:
  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0003e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00043	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR a$[rsp], xmm0
  00049	eb 1a		 jmp	 SHORT $LN6@float_sub
$LN8@float_sub:
  0004b	48 8d 54 24 20	 lea	 rdx, QWORD PTR a$[rsp]
  00050	48 8d 4c 24 40	 lea	 rcx, QWORD PTR v$[rsp]
  00055	e8 00 00 00 00	 call	 convert_to_double
  0005a	85 c0		 test	 eax, eax
  0005c	7d 07		 jge	 SHORT $LN5@float_sub
  0005e	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00063	eb 74		 jmp	 SHORT $LN9@float_sub
$LN5@float_sub:
$LN6@float_sub:

; 509  :     CONVERT_TO_DOUBLE(w, b);

  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0006c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR w$[rsp]
  00071	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00075	74 19		 je	 SHORT $LN3@float_sub
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  00083	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00087	e8 00 00 00 00	 call	 PyType_IsSubtype
  0008c	85 c0		 test	 eax, eax
  0008e	74 12		 je	 SHORT $LN4@float_sub
$LN3@float_sub:
  00090	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  00095	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  0009a	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR b$[rsp], xmm0
  000a0	eb 1a		 jmp	 SHORT $LN2@float_sub
$LN4@float_sub:
  000a2	48 8d 54 24 28	 lea	 rdx, QWORD PTR b$[rsp]
  000a7	48 8d 4c 24 48	 lea	 rcx, QWORD PTR w$[rsp]
  000ac	e8 00 00 00 00	 call	 convert_to_double
  000b1	85 c0		 test	 eax, eax
  000b3	7d 07		 jge	 SHORT $LN1@float_sub
  000b5	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  000ba	eb 1d		 jmp	 SHORT $LN9@float_sub
$LN1@float_sub:
$LN2@float_sub:

; 510  :     PyFPE_START_PROTECT("subtract", return 0)
; 511  :     a = a - b;

  000bc	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR a$[rsp]
  000c2	f2 0f 5c 44 24
	28		 subsd	 xmm0, QWORD PTR b$[rsp]
  000c8	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR a$[rsp], xmm0

; 512  :     PyFPE_END_PROTECT(a)
; 513  :     return PyFloat_FromDouble(a);

  000ce	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR a$[rsp]
  000d4	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN9@float_sub:

; 514  : }

  000d9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dd	c3		 ret	 0
float_sub ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_mul DD imagerel float_mul
	DD	imagerel float_mul+222
	DD	imagerel $unwind$float_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_mul DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_mul
_TEXT	SEGMENT
a$ = 32
b$ = 40
v$ = 64
w$ = 72
float_mul PROC						; COMDAT

; 518  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 519  :     double a,b;
; 520  :     CONVERT_TO_DOUBLE(v, a);

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 19		 je	 SHORT $LN7@float_mul
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	74 12		 je	 SHORT $LN8@float_mul
$LN7@float_mul:
  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0003e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00043	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR a$[rsp], xmm0
  00049	eb 1a		 jmp	 SHORT $LN6@float_mul
$LN8@float_mul:
  0004b	48 8d 54 24 20	 lea	 rdx, QWORD PTR a$[rsp]
  00050	48 8d 4c 24 40	 lea	 rcx, QWORD PTR v$[rsp]
  00055	e8 00 00 00 00	 call	 convert_to_double
  0005a	85 c0		 test	 eax, eax
  0005c	7d 07		 jge	 SHORT $LN5@float_mul
  0005e	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00063	eb 74		 jmp	 SHORT $LN9@float_mul
$LN5@float_mul:
$LN6@float_mul:

; 521  :     CONVERT_TO_DOUBLE(w, b);

  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0006c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR w$[rsp]
  00071	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00075	74 19		 je	 SHORT $LN3@float_mul
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  00083	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00087	e8 00 00 00 00	 call	 PyType_IsSubtype
  0008c	85 c0		 test	 eax, eax
  0008e	74 12		 je	 SHORT $LN4@float_mul
$LN3@float_mul:
  00090	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  00095	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  0009a	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR b$[rsp], xmm0
  000a0	eb 1a		 jmp	 SHORT $LN2@float_mul
$LN4@float_mul:
  000a2	48 8d 54 24 28	 lea	 rdx, QWORD PTR b$[rsp]
  000a7	48 8d 4c 24 48	 lea	 rcx, QWORD PTR w$[rsp]
  000ac	e8 00 00 00 00	 call	 convert_to_double
  000b1	85 c0		 test	 eax, eax
  000b3	7d 07		 jge	 SHORT $LN1@float_mul
  000b5	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  000ba	eb 1d		 jmp	 SHORT $LN9@float_mul
$LN1@float_mul:
$LN2@float_mul:

; 522  :     PyFPE_START_PROTECT("multiply", return 0)
; 523  :     a = a * b;

  000bc	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR a$[rsp]
  000c2	f2 0f 59 44 24
	28		 mulsd	 xmm0, QWORD PTR b$[rsp]
  000c8	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR a$[rsp], xmm0

; 524  :     PyFPE_END_PROTECT(a)
; 525  :     return PyFloat_FromDouble(a);

  000ce	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR a$[rsp]
  000d4	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN9@float_mul:

; 526  : }

  000d9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dd	c3		 ret	 0
float_mul ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@FBOCJMDG@float?5division?5by?5zero?$AA@ ; `string'
EXTRN	PyExc_ZeroDivisionError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_div DD imagerel float_div
	DD	imagerel float_div+266
	DD	imagerel $unwind$float_div
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_div DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BH@FBOCJMDG@float?5division?5by?5zero?$AA@
CONST	SEGMENT
??_C@_0BH@FBOCJMDG@float?5division?5by?5zero?$AA@ DB 'float division by z'
	DB	'ero', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_div
_TEXT	SEGMENT
a$ = 32
b$ = 40
v$ = 64
w$ = 72
float_div PROC						; COMDAT

; 530  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 531  :     double a,b;
; 532  :     CONVERT_TO_DOUBLE(v, a);

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 19		 je	 SHORT $LN8@float_div
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	74 12		 je	 SHORT $LN9@float_div
$LN8@float_div:
  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0003e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00043	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR a$[rsp], xmm0
  00049	eb 1d		 jmp	 SHORT $LN7@float_div
$LN9@float_div:
  0004b	48 8d 54 24 20	 lea	 rdx, QWORD PTR a$[rsp]
  00050	48 8d 4c 24 40	 lea	 rcx, QWORD PTR v$[rsp]
  00055	e8 00 00 00 00	 call	 convert_to_double
  0005a	85 c0		 test	 eax, eax
  0005c	7d 0a		 jge	 SHORT $LN6@float_div
  0005e	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00063	e9 9d 00 00 00	 jmp	 $LN10@float_div
$LN6@float_div:
$LN7@float_div:

; 533  :     CONVERT_TO_DOUBLE(w, b);

  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0006f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR w$[rsp]
  00074	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00078	74 19		 je	 SHORT $LN4@float_div
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00081	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  00086	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0008a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0008f	85 c0		 test	 eax, eax
  00091	74 12		 je	 SHORT $LN5@float_div
$LN4@float_div:
  00093	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  00098	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  0009d	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR b$[rsp], xmm0
  000a3	eb 1a		 jmp	 SHORT $LN3@float_div
$LN5@float_div:
  000a5	48 8d 54 24 28	 lea	 rdx, QWORD PTR b$[rsp]
  000aa	48 8d 4c 24 48	 lea	 rcx, QWORD PTR w$[rsp]
  000af	e8 00 00 00 00	 call	 convert_to_double
  000b4	85 c0		 test	 eax, eax
  000b6	7d 07		 jge	 SHORT $LN2@float_div
  000b8	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  000bd	eb 46		 jmp	 SHORT $LN10@float_div
$LN2@float_div:
$LN3@float_div:

; 534  :     if (b == 0.0) {

  000bf	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR b$[rsp]
  000c5	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000cd	7a 19		 jp	 SHORT $LN1@float_div
  000cf	75 17		 jne	 SHORT $LN1@float_div

; 535  :         PyErr_SetString(PyExc_ZeroDivisionError,
; 536  :                         "float division by zero");

  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@FBOCJMDG@float?5division?5by?5zero?$AA@
  000d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  000df	e8 00 00 00 00	 call	 PyErr_SetString

; 537  :         return NULL;

  000e4	33 c0		 xor	 eax, eax
  000e6	eb 1d		 jmp	 SHORT $LN10@float_div
$LN1@float_div:

; 538  :     }
; 539  :     PyFPE_START_PROTECT("divide", return 0)
; 540  :     a = a / b;

  000e8	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR a$[rsp]
  000ee	f2 0f 5e 44 24
	28		 divsd	 xmm0, QWORD PTR b$[rsp]
  000f4	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR a$[rsp], xmm0

; 541  :     PyFPE_END_PROTECT(a)
; 542  :     return PyFloat_FromDouble(a);

  000fa	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR a$[rsp]
  00100	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN10@float_div:

; 543  : }

  00105	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00109	c3		 ret	 0
float_div ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FKMNDEON@float?5modulo?$AA@		; `string'
EXTRN	__imp__copysign:PROC
EXTRN	fmod:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_rem DD imagerel float_rem
	DD	imagerel float_rem+407
	DD	imagerel $unwind$float_rem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_rem DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0N@FKMNDEON@float?5modulo?$AA@
CONST	SEGMENT
??_C@_0N@FKMNDEON@float?5modulo?$AA@ DB 'float modulo', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_rem
_TEXT	SEGMENT
vx$ = 32
wx$ = 40
mod$ = 48
tv132 = 56
tv131 = 60
v$ = 80
w$ = 88
float_rem PROC						; COMDAT

; 547  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 548  :     double vx, wx;
; 549  :     double mod;
; 550  :     CONVERT_TO_DOUBLE(v, vx);

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 19		 je	 SHORT $LN11@float_rem
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	74 12		 je	 SHORT $LN12@float_rem
$LN11@float_rem:
  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0003e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00043	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR vx$[rsp], xmm0
  00049	eb 1d		 jmp	 SHORT $LN10@float_rem
$LN12@float_rem:
  0004b	48 8d 54 24 20	 lea	 rdx, QWORD PTR vx$[rsp]
  00050	48 8d 4c 24 50	 lea	 rcx, QWORD PTR v$[rsp]
  00055	e8 00 00 00 00	 call	 convert_to_double
  0005a	85 c0		 test	 eax, eax
  0005c	7d 0a		 jge	 SHORT $LN9@float_rem
  0005e	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00063	e9 2a 01 00 00	 jmp	 $LN13@float_rem
$LN9@float_rem:
$LN10@float_rem:

; 551  :     CONVERT_TO_DOUBLE(w, wx);

  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR w$[rsp]
  00074	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00078	74 19		 je	 SHORT $LN7@float_rem
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00081	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  00086	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0008a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0008f	85 c0		 test	 eax, eax
  00091	74 12		 je	 SHORT $LN8@float_rem
$LN7@float_rem:
  00093	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  00098	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  0009d	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR wx$[rsp], xmm0
  000a3	eb 1d		 jmp	 SHORT $LN6@float_rem
$LN8@float_rem:
  000a5	48 8d 54 24 28	 lea	 rdx, QWORD PTR wx$[rsp]
  000aa	48 8d 4c 24 58	 lea	 rcx, QWORD PTR w$[rsp]
  000af	e8 00 00 00 00	 call	 convert_to_double
  000b4	85 c0		 test	 eax, eax
  000b6	7d 0a		 jge	 SHORT $LN5@float_rem
  000b8	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  000bd	e9 d0 00 00 00	 jmp	 $LN13@float_rem
$LN5@float_rem:
$LN6@float_rem:

; 552  :     if (wx == 0.0) {

  000c2	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR wx$[rsp]
  000c8	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000d0	7a 1c		 jp	 SHORT $LN4@float_rem
  000d2	75 1a		 jne	 SHORT $LN4@float_rem

; 553  :         PyErr_SetString(PyExc_ZeroDivisionError,
; 554  :                         "float modulo");

  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@FKMNDEON@float?5modulo?$AA@
  000db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  000e2	e8 00 00 00 00	 call	 PyErr_SetString

; 555  :         return NULL;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 a4 00 00 00	 jmp	 $LN13@float_rem
$LN4@float_rem:

; 556  :     }
; 557  :     PyFPE_START_PROTECT("modulo", return 0)
; 558  :     mod = fmod(vx, wx);

  000ee	f2 0f 10 4c 24
	28		 movsdx	 xmm1, QWORD PTR wx$[rsp]
  000f4	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR vx$[rsp]
  000fa	e8 00 00 00 00	 call	 fmod
  000ff	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR mod$[rsp], xmm0

; 559  :     if (mod) {

  00105	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR mod$[rsp]
  0010b	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00113	7a 02		 jp	 SHORT $LN19@float_rem
  00115	74 5a		 je	 SHORT $LN3@float_rem
$LN19@float_rem:

; 560  :         /* ensure the remainder has the same sign as the denominator */
; 561  :         if ((wx < 0) != (mod < 0)) {

  00117	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0011b	66 0f 2f 44 24
	28		 comisd	 xmm0, QWORD PTR wx$[rsp]
  00121	76 0a		 jbe	 SHORT $LN17@float_rem
  00123	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  0012b	eb 08		 jmp	 SHORT $LN18@float_rem
$LN17@float_rem:
  0012d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN18@float_rem:
  00135	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00139	66 0f 2f 44 24
	30		 comisd	 xmm0, QWORD PTR mod$[rsp]
  0013f	76 0a		 jbe	 SHORT $LN15@float_rem
  00141	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  00149	eb 08		 jmp	 SHORT $LN16@float_rem
$LN15@float_rem:
  0014b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@float_rem:
  00153	8b 44 24 3c	 mov	 eax, DWORD PTR tv131[rsp]
  00157	39 44 24 38	 cmp	 DWORD PTR tv132[rsp], eax
  0015b	74 12		 je	 SHORT $LN2@float_rem

; 562  :             mod += wx;

  0015d	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR mod$[rsp]
  00163	f2 0f 58 44 24
	28		 addsd	 xmm0, QWORD PTR wx$[rsp]
  00169	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR mod$[rsp], xmm0
$LN2@float_rem:

; 563  :         }
; 564  :     }
; 565  :     else {

  0016f	eb 16		 jmp	 SHORT $LN1@float_rem
$LN3@float_rem:

; 566  :         /* the remainder is zero, and in the presence of signed zeroes
; 567  :            fmod returns different results across platforms; ensure
; 568  :            it has the same sign as the denominator. */
; 569  :         mod = copysign(0.0, wx);

  00171	f2 0f 10 4c 24
	28		 movsdx	 xmm1, QWORD PTR wx$[rsp]
  00177	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00181	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR mod$[rsp], xmm0
$LN1@float_rem:

; 570  :     }
; 571  :     PyFPE_END_PROTECT(mod)
; 572  :     return PyFloat_FromDouble(mod);

  00187	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR mod$[rsp]
  0018d	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN13@float_rem:

; 573  : }

  00192	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00196	c3		 ret	 0
float_rem ENDP
_TEXT	ENDS
PUBLIC	??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@		; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0P@FNNFOEHG@float?5divmod?$CI?$CJ?$AA@	; `string'
EXTRN	Py_BuildValue:PROC
EXTRN	__imp_floor:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_divmod DD imagerel float_divmod
	DD	imagerel float_divmod+586
	DD	imagerel $unwind$float_divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_divmod DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
CONST	SEGMENT
??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@ DB '(dd)', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0P@FNNFOEHG@float?5divmod?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@FNNFOEHG@float?5divmod?$CI?$CJ?$AA@ DB 'float divmod()', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_divmod
_TEXT	SEGMENT
vx$ = 32
floordiv$ = 40
div$ = 48
wx$ = 56
mod$ = 64
tv135 = 72
tv134 = 76
v$ = 96
w$ = 104
float_divmod PROC					; COMDAT

; 577  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 578  :     double vx, wx;
; 579  :     double div, mod, floordiv;
; 580  :     CONVERT_TO_DOUBLE(v, vx);

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00015	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 19		 je	 SHORT $LN14@float_divm
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00027	48 8b 44 24 60	 mov	 rax, QWORD PTR v$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	74 12		 je	 SHORT $LN15@float_divm
$LN14@float_divm:
  00039	48 8b 44 24 60	 mov	 rax, QWORD PTR v$[rsp]
  0003e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00043	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR vx$[rsp], xmm0
  00049	eb 1d		 jmp	 SHORT $LN13@float_divm
$LN15@float_divm:
  0004b	48 8d 54 24 20	 lea	 rdx, QWORD PTR vx$[rsp]
  00050	48 8d 4c 24 60	 lea	 rcx, QWORD PTR v$[rsp]
  00055	e8 00 00 00 00	 call	 convert_to_double
  0005a	85 c0		 test	 eax, eax
  0005c	7d 0a		 jge	 SHORT $LN12@float_divm
  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR v$[rsp]
  00063	e9 dd 01 00 00	 jmp	 $LN16@float_divm
$LN12@float_divm:
$LN13@float_divm:

; 581  :     CONVERT_TO_DOUBLE(w, wx);

  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0006f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR w$[rsp]
  00074	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00078	74 19		 je	 SHORT $LN10@float_divm
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00081	48 8b 44 24 68	 mov	 rax, QWORD PTR w$[rsp]
  00086	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0008a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0008f	85 c0		 test	 eax, eax
  00091	74 12		 je	 SHORT $LN11@float_divm
$LN10@float_divm:
  00093	48 8b 44 24 68	 mov	 rax, QWORD PTR w$[rsp]
  00098	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  0009d	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR wx$[rsp], xmm0
  000a3	eb 1d		 jmp	 SHORT $LN9@float_divm
$LN11@float_divm:
  000a5	48 8d 54 24 38	 lea	 rdx, QWORD PTR wx$[rsp]
  000aa	48 8d 4c 24 68	 lea	 rcx, QWORD PTR w$[rsp]
  000af	e8 00 00 00 00	 call	 convert_to_double
  000b4	85 c0		 test	 eax, eax
  000b6	7d 0a		 jge	 SHORT $LN8@float_divm
  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR w$[rsp]
  000bd	e9 83 01 00 00	 jmp	 $LN16@float_divm
$LN8@float_divm:
$LN9@float_divm:

; 582  :     if (wx == 0.0) {

  000c2	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR wx$[rsp]
  000c8	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000d0	7a 1c		 jp	 SHORT $LN7@float_divm
  000d2	75 1a		 jne	 SHORT $LN7@float_divm

; 583  :         PyErr_SetString(PyExc_ZeroDivisionError, "float divmod()");

  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FNNFOEHG@float?5divmod?$CI?$CJ?$AA@
  000db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  000e2	e8 00 00 00 00	 call	 PyErr_SetString

; 584  :         return NULL;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 57 01 00 00	 jmp	 $LN16@float_divm
$LN7@float_divm:

; 585  :     }
; 586  :     PyFPE_START_PROTECT("divmod", return 0)
; 587  :     mod = fmod(vx, wx);

  000ee	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR wx$[rsp]
  000f4	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR vx$[rsp]
  000fa	e8 00 00 00 00	 call	 fmod
  000ff	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR mod$[rsp], xmm0

; 588  :     /* fmod is typically exact, so vx-mod is *mathematically* an
; 589  :        exact multiple of wx.  But this is fp arithmetic, and fp
; 590  :        vx - mod is an approximation; the result is that div may
; 591  :        not be an exact integral value after the division, although
; 592  :        it will always be very close to one.
; 593  :     */
; 594  :     div = (vx - mod) / wx;

  00105	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR vx$[rsp]
  0010b	f2 0f 5c 44 24
	40		 subsd	 xmm0, QWORD PTR mod$[rsp]
  00111	f2 0f 5e 44 24
	38		 divsd	 xmm0, QWORD PTR wx$[rsp]
  00117	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR div$[rsp], xmm0

; 595  :     if (mod) {

  0011d	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR mod$[rsp]
  00123	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0012b	7a 02		 jp	 SHORT $LN23@float_divm
  0012d	74 6e		 je	 SHORT $LN6@float_divm
$LN23@float_divm:

; 596  :         /* ensure the remainder has the same sign as the denominator */
; 597  :         if ((wx < 0) != (mod < 0)) {

  0012f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00133	66 0f 2f 44 24
	38		 comisd	 xmm0, QWORD PTR wx$[rsp]
  00139	76 0a		 jbe	 SHORT $LN20@float_divm
  0013b	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  00143	eb 08		 jmp	 SHORT $LN21@float_divm
$LN20@float_divm:
  00145	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN21@float_divm:
  0014d	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00151	66 0f 2f 44 24
	40		 comisd	 xmm0, QWORD PTR mod$[rsp]
  00157	76 0a		 jbe	 SHORT $LN18@float_divm
  00159	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  00161	eb 08		 jmp	 SHORT $LN19@float_divm
$LN18@float_divm:
  00163	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN19@float_divm:
  0016b	8b 44 24 4c	 mov	 eax, DWORD PTR tv134[rsp]
  0016f	39 44 24 48	 cmp	 DWORD PTR tv135[rsp], eax
  00173	74 26		 je	 SHORT $LN5@float_divm

; 598  :             mod += wx;

  00175	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR mod$[rsp]
  0017b	f2 0f 58 44 24
	38		 addsd	 xmm0, QWORD PTR wx$[rsp]
  00181	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR mod$[rsp], xmm0

; 599  :             div -= 1.0;

  00187	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR div$[rsp]
  0018d	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00195	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR div$[rsp], xmm0
$LN5@float_divm:

; 600  :         }
; 601  :     }
; 602  :     else {

  0019b	eb 16		 jmp	 SHORT $LN4@float_divm
$LN6@float_divm:

; 603  :         /* the remainder is zero, and in the presence of signed zeroes
; 604  :            fmod returns different results across platforms; ensure
; 605  :            it has the same sign as the denominator. */
; 606  :         mod = copysign(0.0, wx);

  0019d	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR wx$[rsp]
  001a3	66 0f 57 c0	 xorpd	 xmm0, xmm0
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  001ad	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR mod$[rsp], xmm0
$LN4@float_divm:

; 607  :     }
; 608  :     /* snap quotient to nearest integral value */
; 609  :     if (div) {

  001b3	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR div$[rsp]
  001b9	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  001c1	7a 02		 jp	 SHORT $LN22@float_divm
  001c3	74 3e		 je	 SHORT $LN3@float_divm
$LN22@float_divm:

; 610  :         floordiv = floor(div);

  001c5	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR div$[rsp]
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  001d1	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR floordiv$[rsp], xmm0

; 611  :         if (div - floordiv > 0.5)

  001d7	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR div$[rsp]
  001dd	f2 0f 5c 44 24
	28		 subsd	 xmm0, QWORD PTR floordiv$[rsp]
  001e3	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3fe0000000000000
  001eb	76 14		 jbe	 SHORT $LN2@float_divm

; 612  :             floordiv += 1.0;

  001ed	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR floordiv$[rsp]
  001f3	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  001fb	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR floordiv$[rsp], xmm0
$LN2@float_divm:

; 613  :     }
; 614  :     else {

  00201	eb 20		 jmp	 SHORT $LN1@float_divm
$LN3@float_divm:

; 615  :         /* div is zero - get the same sign as the true quotient */
; 616  :         floordiv = copysign(0.0, vx / wx); /* zero w/ sign of vx/wx */

  00203	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR vx$[rsp]
  00209	f2 0f 5e 44 24
	38		 divsd	 xmm0, QWORD PTR wx$[rsp]
  0020f	66 0f 28 c8	 movapd	 xmm1, xmm0
  00213	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  0021d	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR floordiv$[rsp], xmm0
$LN1@float_divm:

; 617  :     }
; 618  :     PyFPE_END_PROTECT(floordiv)
; 619  :     return Py_BuildValue("(dd)", floordiv, mod);

  00223	f2 0f 10 54 24
	40		 movsdx	 xmm2, QWORD PTR mod$[rsp]
  00229	66 49 0f 7e d0	 movd	 r8, xmm2
  0022e	f2 0f 10 4c 24
	28		 movsdx	 xmm1, QWORD PTR floordiv$[rsp]
  00234	66 48 0f 7e ca	 movd	 rdx, xmm1
  00239	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
  00240	e8 00 00 00 00	 call	 Py_BuildValue
$LN16@float_divm:

; 620  : }

  00245	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00249	c3		 ret	 0
float_divmod ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@JDDEIANF@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyTuple_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_floor_div DD imagerel float_floor_div
	DD	imagerel float_floor_div+153
	DD	imagerel $unwind$float_floor_div
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_floor_div DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1CM@JDDEIANF@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@JDDEIANF@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'T', 00H, 'u', 00H, 'p', 00H, 'l', 00H, 'e', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'E'
	DB	00H, 'x', 00H, 'a', 00H, 'c', 00H, 't', 00H, '(', 00H, 't', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_floor_div
_TEXT	SEGMENT
r$ = 32
t$ = 40
v$ = 64
w$ = 72
float_floor_div PROC					; COMDAT

; 624  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 625  :     PyObject *t, *r;
; 626  : 
; 627  :     t = float_divmod(v, w);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00018	e8 00 00 00 00	 call	 float_divmod
  0001d	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax

; 628  :     if (t == NULL || t == Py_NotImplemented)

  00022	48 83 7c 24 28
	00		 cmp	 QWORD PTR t$[rsp], 0
  00028	74 0e		 je	 SHORT $LN1@float_floo
  0002a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00031	48 39 44 24 28	 cmp	 QWORD PTR t$[rsp], rax
  00036	75 07		 jne	 SHORT $LN2@float_floo
$LN1@float_floo:

; 629  :         return t;

  00038	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  0003d	eb 55		 jmp	 SHORT $LN3@float_floo
$LN2@float_floo:

; 630  :     assert(PyTuple_CheckExact(t));

  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  00046	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  0004b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0004f	74 1c		 je	 SHORT $LN5@float_floo
  00051	41 b8 76 02 00
	00		 mov	 r8d, 630		; 00000276H
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@JDDEIANF@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AA?$CJ?$AA?$AA@
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006b	33 c0		 xor	 eax, eax
$LN5@float_floo:

; 631  :     r = PyTuple_GET_ITEM(t, 0);

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00072	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00076	48 89 44 24 20	 mov	 QWORD PTR r$[rsp], rax

; 632  :     Py_INCREF(r);

  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR r$[rsp]
  00080	e8 00 00 00 00	 call	 _Py_IncRef

; 633  :     Py_DECREF(t);

  00085	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  0008a	e8 00 00 00 00	 call	 _Py_DecRef

; 634  :     return r;

  0008f	48 8b 44 24 20	 mov	 rax, QWORD PTR r$[rsp]
$LN3@float_floo:

; 635  : }

  00094	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00098	c3		 ret	 0
float_floor_div ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@IINHJLK@0?40?5cannot?5be?5raised?5to?5a?5negati@ ; `string'
PUBLIC	??_C@_0EB@NKAGDCME@pow?$CI?$CJ?53rd?5argument?5not?5allowed?5u@ ; `string'
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	__imp__HUGE:QWORD
EXTRN	pow:PROC
EXTRN	__imp__errno:PROC
EXTRN	PyComplex_Type:BYTE
EXTRN	fabs:PROC
EXTRN	__imp__isnan:PROC
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_pow DD imagerel float_pow
	DD	imagerel float_pow+1573
	DD	imagerel $unwind$float_pow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_pow DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_0CJ@IINHJLK@0?40?5cannot?5be?5raised?5to?5a?5negati@
CONST	SEGMENT
??_C@_0CJ@IINHJLK@0?40?5cannot?5be?5raised?5to?5a?5negati@ DB '0.0 cannot'
	DB	' be raised to a negative power', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@NKAGDCME@pow?$CI?$CJ?53rd?5argument?5not?5allowed?5u@
CONST	SEGMENT
??_C@_0EB@NKAGDCME@pow?$CI?$CJ?53rd?5argument?5not?5allowed?5u@ DB 'pow()'
	DB	' 3rd argument not allowed unless all arguments are integers', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_pow
_TEXT	SEGMENT
negate_result$ = 32
ix$ = 40
iv$ = 48
iw$ = 56
iw_is_odd$20815 = 64
iw_is_odd$20819 = 68
tv138 = 72
tv154 = 80
tv153 = 84
tv174 = 88
tv180 = 96
tv187 = 104
tv196 = 112
tv202 = 120
tv220 = 128
tv224 = 136
tv248 = 144
v$ = 176
w$ = 184
z$ = 192
float_pow PROC						; COMDAT

; 643  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 644  :     double iv, iw, ix;
; 645  :     int negate_result = 0;

  00016	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR negate_result$[rsp], 0

; 646  : 
; 647  :     if ((PyObject *)z != Py_None) {

  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00025	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR z$[rsp], rax
  0002d	74 1a		 je	 SHORT $LN35@float_pow

; 648  :         PyErr_SetString(PyExc_TypeError, "pow() 3rd argument not "
; 649  :             "allowed unless all arguments are integers");

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@NKAGDCME@pow?$CI?$CJ?53rd?5argument?5not?5allowed?5u@
  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003d	e8 00 00 00 00	 call	 PyErr_SetString

; 650  :         return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	e9 d4 05 00 00	 jmp	 $LN36@float_pow
$LN35@float_pow:

; 651  :     }
; 652  : 
; 653  :     CONVERT_TO_DOUBLE(v, iv);

  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00050	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00058	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0005c	74 1c		 je	 SHORT $LN33@float_pow
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00065	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0006d	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00071	e8 00 00 00 00	 call	 PyType_IsSubtype
  00076	85 c0		 test	 eax, eax
  00078	74 15		 je	 SHORT $LN34@float_pow
$LN33@float_pow:
  0007a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00082	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00087	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR iv$[rsp], xmm0
  0008d	eb 23		 jmp	 SHORT $LN32@float_pow
$LN34@float_pow:
  0008f	48 8d 54 24 30	 lea	 rdx, QWORD PTR iv$[rsp]
  00094	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR v$[rsp]
  0009c	e8 00 00 00 00	 call	 convert_to_double
  000a1	85 c0		 test	 eax, eax
  000a3	7d 0d		 jge	 SHORT $LN31@float_pow
  000a5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  000ad	e9 6b 05 00 00	 jmp	 $LN36@float_pow
$LN31@float_pow:
$LN32@float_pow:

; 654  :     CONVERT_TO_DOUBLE(w, iw);

  000b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  000b9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  000c1	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000c5	74 1c		 je	 SHORT $LN29@float_pow
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  000ce	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000d6	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000da	e8 00 00 00 00	 call	 PyType_IsSubtype
  000df	85 c0		 test	 eax, eax
  000e1	74 15		 je	 SHORT $LN30@float_pow
$LN29@float_pow:
  000e3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000eb	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  000f0	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR iw$[rsp], xmm0
  000f6	eb 23		 jmp	 SHORT $LN28@float_pow
$LN30@float_pow:
  000f8	48 8d 54 24 38	 lea	 rdx, QWORD PTR iw$[rsp]
  000fd	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR w$[rsp]
  00105	e8 00 00 00 00	 call	 convert_to_double
  0010a	85 c0		 test	 eax, eax
  0010c	7d 0d		 jge	 SHORT $LN27@float_pow
  0010e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00116	e9 02 05 00 00	 jmp	 $LN36@float_pow
$LN27@float_pow:
$LN28@float_pow:

; 655  : 
; 656  :     /* Sort out special cases here instead of relying on pow() */
; 657  :     if (iw == 0) {              /* v**0 is 1, even 0**0 */

  0011b	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  00121	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00129	7a 14		 jp	 SHORT $LN26@float_pow
  0012b	75 12		 jne	 SHORT $LN26@float_pow

; 658  :         return PyFloat_FromDouble(1.0);

  0012d	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00135	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0013a	e9 de 04 00 00	 jmp	 $LN36@float_pow
$LN26@float_pow:

; 659  :     }
; 660  :     if (Py_IS_NAN(iv)) {        /* nan**w = nan, unless w == 0 */

  0013f	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0014b	85 c0		 test	 eax, eax
  0014d	74 10		 je	 SHORT $LN25@float_pow

; 661  :         return PyFloat_FromDouble(iv);

  0014f	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  00155	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0015a	e9 be 04 00 00	 jmp	 $LN36@float_pow
$LN25@float_pow:

; 662  :     }
; 663  :     if (Py_IS_NAN(iw)) {        /* v**nan = nan, unless v == 1; 1**nan = 1 */

  0015f	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0016b	85 c0		 test	 eax, eax
  0016d	74 3e		 je	 SHORT $LN24@float_pow

; 664  :         return PyFloat_FromDouble(iv == 1.0 ? 1.0 : iw);

  0016f	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  00175	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  0017d	7a 12		 jp	 SHORT $LN38@float_pow
  0017f	75 10		 jne	 SHORT $LN38@float_pow
  00181	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00189	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR tv138[rsp], xmm0
  0018f	eb 0c		 jmp	 SHORT $LN39@float_pow
$LN38@float_pow:
  00191	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  00197	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR tv138[rsp], xmm0
$LN39@float_pow:
  0019d	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR tv138[rsp]
  001a3	e8 00 00 00 00	 call	 PyFloat_FromDouble
  001a8	e9 70 04 00 00	 jmp	 $LN36@float_pow
$LN24@float_pow:

; 665  :     }
; 666  :     if (Py_IS_INFINITY(iw)) {

  001ad	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  001b9	85 c0		 test	 eax, eax
  001bb	0f 85 be 00 00
	00		 jne	 $LN23@float_pow
  001c1	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  001cd	85 c0		 test	 eax, eax
  001cf	0f 85 aa 00 00
	00		 jne	 $LN23@float_pow

; 667  :         /* v**inf is: 0.0 if abs(v) < 1; 1.0 if abs(v) == 1; inf if
; 668  :          *     abs(v) > 1 (including case where v infinite)
; 669  :          *
; 670  :          * v**-inf is: inf if abs(v) < 1; 1.0 if abs(v) == 1; 0.0 if
; 671  :          *     abs(v) > 1 (including case where v infinite)
; 672  :          */
; 673  :         iv = fabs(iv);

  001d5	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  001db	e8 00 00 00 00	 call	 fabs
  001e0	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR iv$[rsp], xmm0

; 674  :         if (iv == 1.0)

  001e6	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  001ec	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  001f4	7a 16		 jp	 SHORT $LN22@float_pow
  001f6	75 14		 jne	 SHORT $LN22@float_pow

; 675  :             return PyFloat_FromDouble(1.0);

  001f8	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00200	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00205	e9 13 04 00 00	 jmp	 $LN36@float_pow
  0020a	eb 73		 jmp	 SHORT $LN21@float_pow
$LN22@float_pow:

; 676  :         else if ((iw > 0.0) == (iv > 1.0))

  0020c	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  00212	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  0021a	76 0a		 jbe	 SHORT $LN42@float_pow
  0021c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  00224	eb 08		 jmp	 SHORT $LN43@float_pow
$LN42@float_pow:
  00226	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
$LN43@float_pow:
  0022e	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  00234	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  0023c	76 0a		 jbe	 SHORT $LN40@float_pow
  0023e	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  00246	eb 08		 jmp	 SHORT $LN41@float_pow
$LN40@float_pow:
  00248	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN41@float_pow:
  00250	8b 44 24 54	 mov	 eax, DWORD PTR tv153[rsp]
  00254	39 44 24 50	 cmp	 DWORD PTR tv154[rsp], eax
  00258	75 17		 jne	 SHORT $LN20@float_pow

; 677  :             return PyFloat_FromDouble(fabs(iw)); /* return inf */

  0025a	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  00260	e8 00 00 00 00	 call	 fabs
  00265	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0026a	e9 ae 03 00 00	 jmp	 $LN36@float_pow

; 678  :         else

  0026f	eb 0e		 jmp	 SHORT $LN19@float_pow
$LN20@float_pow:

; 679  :             return PyFloat_FromDouble(0.0);

  00271	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00275	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0027a	e9 9e 03 00 00	 jmp	 $LN36@float_pow
$LN19@float_pow:
$LN21@float_pow:
$LN23@float_pow:

; 680  :     }
; 681  :     if (Py_IS_INFINITY(iv)) {

  0027f	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  00285	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0028b	85 c0		 test	 eax, eax
  0028d	0f 85 d3 00 00
	00		 jne	 $LN18@float_pow
  00293	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  00299	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0029f	85 c0		 test	 eax, eax
  002a1	0f 85 bf 00 00
	00		 jne	 $LN18@float_pow

; 682  :         /* (+-inf)**w is: inf for w positive, 0 for w negative; in
; 683  :          *     both cases, we need to add the appropriate sign if w is
; 684  :          *     an odd integer.
; 685  :          */
; 686  :         int iw_is_odd = DOUBLE_IS_ODD_INTEGER(iw);

  002a7	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  002ad	e8 00 00 00 00	 call	 fabs
  002b2	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  002ba	e8 00 00 00 00	 call	 fmod
  002bf	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  002c7	7a 0c		 jp	 SHORT $LN44@float_pow
  002c9	75 0a		 jne	 SHORT $LN44@float_pow
  002cb	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  002d3	eb 08		 jmp	 SHORT $LN45@float_pow
$LN44@float_pow:
  002d5	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN45@float_pow:
  002dd	8b 44 24 58	 mov	 eax, DWORD PTR tv174[rsp]
  002e1	89 44 24 40	 mov	 DWORD PTR iw_is_odd$20815[rsp], eax

; 687  :         if (iw > 0.0)

  002e5	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  002eb	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  002f3	76 38		 jbe	 SHORT $LN17@float_pow

; 688  :             return PyFloat_FromDouble(iw_is_odd ? iv : fabs(iv));

  002f5	83 7c 24 40 00	 cmp	 DWORD PTR iw_is_odd$20815[rsp], 0
  002fa	74 0e		 je	 SHORT $LN46@float_pow
  002fc	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  00302	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR tv180[rsp], xmm0
  00308	eb 11		 jmp	 SHORT $LN47@float_pow
$LN46@float_pow:
  0030a	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  00310	e8 00 00 00 00	 call	 fabs
  00315	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR tv180[rsp], xmm0
$LN47@float_pow:
  0031b	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR tv180[rsp]
  00321	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00326	e9 f2 02 00 00	 jmp	 $LN36@float_pow

; 689  :         else

  0032b	eb 39		 jmp	 SHORT $LN16@float_pow
$LN17@float_pow:

; 690  :             return PyFloat_FromDouble(iw_is_odd ?
; 691  :                                       copysign(0.0, iv) : 0.0);

  0032d	83 7c 24 40 00	 cmp	 DWORD PTR iw_is_odd$20815[rsp], 0
  00332	74 18		 je	 SHORT $LN48@float_pow
  00334	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR iv$[rsp]
  0033a	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0033e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00344	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR tv187[rsp], xmm0
  0034a	eb 0a		 jmp	 SHORT $LN49@float_pow
$LN48@float_pow:
  0034c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00350	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR tv187[rsp], xmm0
$LN49@float_pow:
  00356	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR tv187[rsp]
  0035c	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00361	e9 b7 02 00 00	 jmp	 $LN36@float_pow
$LN16@float_pow:
$LN18@float_pow:

; 692  :     }
; 693  :     if (iv == 0.0) {  /* 0**w is: 0 for w positive, 1 for w zero

  00366	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  0036c	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00374	0f 8a 99 00 00
	00		 jp	 $LN15@float_pow
  0037a	0f 85 93 00 00
	00		 jne	 $LN15@float_pow

; 694  :                          (already dealt with above), and an error
; 695  :                          if w is negative. */
; 696  :         int iw_is_odd = DOUBLE_IS_ODD_INTEGER(iw);

  00380	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  00386	e8 00 00 00 00	 call	 fabs
  0038b	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  00393	e8 00 00 00 00	 call	 fmod
  00398	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  003a0	7a 0c		 jp	 SHORT $LN50@float_pow
  003a2	75 0a		 jne	 SHORT $LN50@float_pow
  003a4	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv196[rsp], 1
  003ac	eb 08		 jmp	 SHORT $LN51@float_pow
$LN50@float_pow:
  003ae	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv196[rsp], 0
$LN51@float_pow:
  003b6	8b 44 24 70	 mov	 eax, DWORD PTR tv196[rsp]
  003ba	89 44 24 44	 mov	 DWORD PTR iw_is_odd$20819[rsp], eax

; 697  :         if (iw < 0.0) {

  003be	66 0f 57 c0	 xorpd	 xmm0, xmm0
  003c2	66 0f 2f 44 24
	38		 comisd	 xmm0, QWORD PTR iw$[rsp]
  003c8	76 1a		 jbe	 SHORT $LN14@float_pow

; 698  :             PyErr_SetString(PyExc_ZeroDivisionError,
; 699  :                             "0.0 cannot be raised to a "
; 700  :                             "negative power");

  003ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@IINHJLK@0?40?5cannot?5be?5raised?5to?5a?5negati@
  003d1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  003d8	e8 00 00 00 00	 call	 PyErr_SetString

; 701  :             return NULL;

  003dd	33 c0		 xor	 eax, eax
  003df	e9 39 02 00 00	 jmp	 $LN36@float_pow
$LN14@float_pow:

; 702  :         }
; 703  :         /* use correct sign if iw is odd */
; 704  :         return PyFloat_FromDouble(iw_is_odd ? iv : 0.0);

  003e4	83 7c 24 44 00	 cmp	 DWORD PTR iw_is_odd$20819[rsp], 0
  003e9	74 0e		 je	 SHORT $LN52@float_pow
  003eb	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  003f1	f2 0f 11 44 24
	78		 movsdx	 QWORD PTR tv202[rsp], xmm0
  003f7	eb 0a		 jmp	 SHORT $LN53@float_pow
$LN52@float_pow:
  003f9	66 0f 57 c0	 xorpd	 xmm0, xmm0
  003fd	f2 0f 11 44 24
	78		 movsdx	 QWORD PTR tv202[rsp], xmm0
$LN53@float_pow:
  00403	f2 0f 10 44 24
	78		 movsdx	 xmm0, QWORD PTR tv202[rsp]
  00409	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0040e	e9 0a 02 00 00	 jmp	 $LN36@float_pow
$LN15@float_pow:

; 705  :     }
; 706  : 
; 707  :     if (iv < 0.0) {

  00413	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00417	66 0f 2f 44 24
	30		 comisd	 xmm0, QWORD PTR iv$[rsp]
  0041d	0f 86 9c 00 00
	00		 jbe	 $LN13@float_pow

; 708  :         /* Whether this is an error is a mess, and bumps into libm
; 709  :          * bugs so we have to figure it out ourselves.
; 710  :          */
; 711  :         if (iw != floor(iw)) {

  00423	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  00429	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  0042f	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR iw$[rsp]
  00435	66 0f 2e c8	 ucomisd xmm1, xmm0
  00439	7a 02		 jp	 SHORT $LN61@float_pow
  0043b	74 27		 je	 SHORT $LN12@float_pow
$LN61@float_pow:

; 712  :             /* Negative numbers raised to fractional powers
; 713  :              * become complex.
; 714  :              */
; 715  :             return PyComplex_Type.tp_as_number->nb_power(v, w, z);

  0043d	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00445	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR w$[rsp]
  0044d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00455	48 8b 05 b8 00
	00 00		 mov	 rax, QWORD PTR PyComplex_Type+184
  0045c	ff 50 28	 call	 QWORD PTR [rax+40]
  0045f	e9 b9 01 00 00	 jmp	 $LN36@float_pow
$LN12@float_pow:

; 716  :         }
; 717  :         /* iw is an exact integer, albeit perhaps a very large
; 718  :          * one.  Replace iv by its absolute value and remember
; 719  :          * to negate the pow result if iw is odd.
; 720  :          */
; 721  :         iv = -iv;

  00464	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  0046a	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00472	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR iv$[rsp], xmm0

; 722  :         negate_result = DOUBLE_IS_ODD_INTEGER(iw);

  00478	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR iw$[rsp]
  0047e	e8 00 00 00 00	 call	 fabs
  00483	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  0048b	e8 00 00 00 00	 call	 fmod
  00490	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  00498	7a 0f		 jp	 SHORT $LN54@float_pow
  0049a	75 0d		 jne	 SHORT $LN54@float_pow
  0049c	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv220[rsp], 1
  004a7	eb 0b		 jmp	 SHORT $LN55@float_pow
$LN54@float_pow:
  004a9	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv220[rsp], 0
$LN55@float_pow:
  004b4	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv220[rsp]
  004bb	89 44 24 20	 mov	 DWORD PTR negate_result$[rsp], eax
$LN13@float_pow:

; 723  :     }
; 724  : 
; 725  :     if (iv == 1.0) { /* 1**w is 1, even 1**inf and 1**nan */

  004bf	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  004c5	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  004cd	7a 40		 jp	 SHORT $LN11@float_pow
  004cf	75 3e		 jne	 SHORT $LN11@float_pow

; 726  :         /* (-1) ** large_integer also ends up here.  Here's an
; 727  :          * extract from the comments for the previous
; 728  :          * implementation explaining why this special case is
; 729  :          * necessary:
; 730  :          *
; 731  :          * -1 raised to an exact integer should never be exceptional.
; 732  :          * Alas, some libms (chiefly glibc as of early 2003) return
; 733  :          * NaN and set EDOM on pow(-1, large_int) if the int doesn't
; 734  :          * happen to be representable in a *C* integer.  That's a
; 735  :          * bug.
; 736  :          */
; 737  :         return PyFloat_FromDouble(negate_result ? -1.0 : 1.0);

  004d1	83 7c 24 20 00	 cmp	 DWORD PTR negate_result$[rsp], 0
  004d6	74 13		 je	 SHORT $LN56@float_pow
  004d8	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  004e0	f2 0f 11 84 24
	88 00 00 00	 movsdx	 QWORD PTR tv224[rsp], xmm0
  004e9	eb 11		 jmp	 SHORT $LN57@float_pow
$LN56@float_pow:
  004eb	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  004f3	f2 0f 11 84 24
	88 00 00 00	 movsdx	 QWORD PTR tv224[rsp], xmm0
$LN57@float_pow:
  004fc	f2 0f 10 84 24
	88 00 00 00	 movsdx	 xmm0, QWORD PTR tv224[rsp]
  00505	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0050a	e9 0e 01 00 00	 jmp	 $LN36@float_pow
$LN11@float_pow:

; 738  :     }
; 739  : 
; 740  :     /* Now iv and iw are finite, iw is nonzero, and iv is
; 741  :      * positive and not equal to 1.0.  We finally allow
; 742  :      * the platform pow to step in and do the rest.
; 743  :      */
; 744  :     errno = 0;

  0050f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00515	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 745  :     PyFPE_START_PROTECT("pow", return NULL)
; 746  :     ix = pow(iv, iw);

  0051b	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR iw$[rsp]
  00521	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR iv$[rsp]
  00527	e8 00 00 00 00	 call	 pow
  0052c	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR ix$[rsp], xmm0
$LN10@float_pow:

; 747  :     PyFPE_END_PROTECT(ix)
; 748  :     Py_ADJUST_ERANGE1(ix);

  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00538	83 38 00	 cmp	 DWORD PTR [rax], 0
  0053b	75 44		 jne	 SHORT $LN7@float_pow
  0053d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00544	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR ix$[rsp]
  0054a	66 0f 2e 00	 ucomisd xmm0, QWORD PTR [rax]
  0054e	7a 02		 jp	 SHORT $LN60@float_pow
  00550	74 21		 je	 SHORT $LN5@float_pow
$LN60@float_pow:
  00552	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00559	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0055d	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00565	f2 0f 10 4c 24
	28		 movsdx	 xmm1, QWORD PTR ix$[rsp]
  0056b	66 0f 2e c8	 ucomisd xmm1, xmm0
  0056f	7a 0e		 jp	 SHORT $LN6@float_pow
  00571	75 0c		 jne	 SHORT $LN6@float_pow
$LN5@float_pow:
  00573	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00579	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
$LN6@float_pow:
  0057f	eb 29		 jmp	 SHORT $LN4@float_pow
$LN7@float_pow:
  00581	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00587	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  0058a	75 1e		 jne	 SHORT $LN3@float_pow
  0058c	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR ix$[rsp]
  00592	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0059a	7a 0e		 jp	 SHORT $LN3@float_pow
  0059c	75 0c		 jne	 SHORT $LN3@float_pow
  0059e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005a4	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN3@float_pow:
$LN4@float_pow:
  005aa	33 c0		 xor	 eax, eax
  005ac	85 c0		 test	 eax, eax
  005ae	75 82		 jne	 SHORT $LN10@float_pow

; 749  :     if (negate_result)

  005b0	83 7c 24 20 00	 cmp	 DWORD PTR negate_result$[rsp], 0
  005b5	74 14		 je	 SHORT $LN2@float_pow

; 750  :         ix = -ix;

  005b7	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR ix$[rsp]
  005bd	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  005c5	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR ix$[rsp], xmm0
$LN2@float_pow:

; 751  : 
; 752  :     if (errno != 0) {

  005cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005d1	83 38 00	 cmp	 DWORD PTR [rax], 0
  005d4	74 3c		 je	 SHORT $LN1@float_pow

; 753  :         /* We don't expect any errno value other than ERANGE, but
; 754  :          * the range of libm bugs appears unbounded.
; 755  :          */
; 756  :         PyErr_SetFromErrno(errno == ERANGE ? PyExc_OverflowError :
; 757  :                              PyExc_ValueError);

  005d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005dc	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  005df	75 11		 jne	 SHORT $LN58@float_pow
  005e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyExc_OverflowError
  005e8	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv248[rsp], rax
  005f0	eb 0f		 jmp	 SHORT $LN59@float_pow
$LN58@float_pow:
  005f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyExc_ValueError
  005f9	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv248[rsp], rax
$LN59@float_pow:
  00601	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv248[rsp]
  00609	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 758  :         return NULL;

  0060e	33 c0		 xor	 eax, eax
  00610	eb 0b		 jmp	 SHORT $LN36@float_pow
$LN1@float_pow:

; 759  :     }
; 760  :     return PyFloat_FromDouble(ix);

  00612	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR ix$[rsp]
  00618	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN36@float_pow:

; 761  : }

  0061d	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00624	c3		 ret	 0
float_pow ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_neg DD imagerel float_neg
	DD	imagerel float_neg+37
	DD	imagerel $unwind$float_neg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_neg DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_neg
_TEXT	SEGMENT
v$ = 48
float_neg PROC						; COMDAT

; 767  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 768  :     return PyFloat_FromDouble(-v->ob_fval);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0000e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00013	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0001b	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 769  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
float_neg ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_abs DD imagerel float_abs
	DD	imagerel float_abs+34
	DD	imagerel $unwind$float_abs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_abs DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_abs
_TEXT	SEGMENT
v$ = 48
float_abs PROC						; COMDAT

; 773  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 774  :     return PyFloat_FromDouble(fabs(v->ob_fval));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0000e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00013	e8 00 00 00 00	 call	 fabs
  00018	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 775  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
float_abs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_bool DD imagerel float_bool
	DD	imagerel float_bool+55
	DD	imagerel $unwind$float_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_bool DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_bool
_TEXT	SEGMENT
tv66 = 0
v$ = 32
float_bool PROC						; COMDAT

; 779  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 780  :     return v->ob_fval != 0.0;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  0000e	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00013	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0001b	7a 02		 jp	 SHORT $LN5@float_bool
  0001d	74 09		 je	 SHORT $LN3@float_bool
$LN5@float_bool:
  0001f	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv66[rsp], 1
  00026	eb 07		 jmp	 SHORT $LN4@float_bool
$LN3@float_bool:
  00028	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv66[rsp], 0
$LN4@float_bool:
  0002f	8b 04 24	 mov	 eax, DWORD PTR tv66[rsp]

; 781  : }

  00032	48 83 c4 18	 add	 rsp, 24
  00036	c3		 ret	 0
float_bool ENDP
_TEXT	ENDS
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_is_integer DD imagerel float_is_integer
	DD	imagerel float_is_integer+252
	DD	imagerel $unwind$float_is_integer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_is_integer DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_is_integer
_TEXT	SEGMENT
x$ = 32
o$ = 40
tv77 = 48
tv83 = 56
v$ = 80
float_is_integer PROC					; COMDAT

; 785  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 786  :     double x = PyFloat_AsDouble(v);

  00009	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0000e	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00013	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 787  :     PyObject *o;
; 788  : 
; 789  :     if (x == -1.0 && PyErr_Occurred())

  00019	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0001f	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00027	7a 13		 jp	 SHORT $LN3@float_is_i
  00029	75 11		 jne	 SHORT $LN3@float_is_i
  0002b	e8 00 00 00 00	 call	 PyErr_Occurred
  00030	48 85 c0	 test	 rax, rax
  00033	74 07		 je	 SHORT $LN3@float_is_i

; 790  :         return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	e9 bb 00 00 00	 jmp	 $LN4@float_is_i
$LN3@float_is_i:

; 791  :     if (!Py_IS_FINITE(x))

  0003c	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00048	85 c0		 test	 eax, eax
  0004a	75 18		 jne	 SHORT $LN2@float_is_i

; 792  :         Py_RETURN_FALSE;

  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00053	e8 00 00 00 00	 call	 _Py_IncRef
  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0005f	e9 93 00 00 00	 jmp	 $LN4@float_is_i
$LN2@float_is_i:

; 793  :     errno = 0;

  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0006a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 794  :     PyFPE_START_PROTECT("is_integer", return NULL)
; 795  :     o = (floor(x) == x) ? Py_True : Py_False;

  00070	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  0007c	66 0f 2e 44 24
	20		 ucomisd xmm0, QWORD PTR x$[rsp]
  00082	7a 10		 jp	 SHORT $LN6@float_is_i
  00084	75 0e		 jne	 SHORT $LN6@float_is_i
  00086	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0008d	48 89 44 24 30	 mov	 QWORD PTR tv77[rsp], rax
  00092	eb 0c		 jmp	 SHORT $LN7@float_is_i
$LN6@float_is_i:
  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0009b	48 89 44 24 30	 mov	 QWORD PTR tv77[rsp], rax
$LN7@float_is_i:
  000a0	48 8b 44 24 30	 mov	 rax, QWORD PTR tv77[rsp]
  000a5	48 89 44 24 28	 mov	 QWORD PTR o$[rsp], rax

; 796  :     PyFPE_END_PROTECT(x)
; 797  :     if (errno != 0) {

  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b0	83 38 00	 cmp	 DWORD PTR [rax], 0
  000b3	74 33		 je	 SHORT $LN1@float_is_i

; 798  :         PyErr_SetFromErrno(errno == ERANGE ? PyExc_OverflowError :
; 799  :                              PyExc_ValueError);

  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000bb	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  000be	75 0e		 jne	 SHORT $LN8@float_is_i
  000c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyExc_OverflowError
  000c7	48 89 44 24 38	 mov	 QWORD PTR tv83[rsp], rax
  000cc	eb 0c		 jmp	 SHORT $LN9@float_is_i
$LN8@float_is_i:
  000ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyExc_ValueError
  000d5	48 89 44 24 38	 mov	 QWORD PTR tv83[rsp], rax
$LN9@float_is_i:
  000da	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv83[rsp]
  000df	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 800  :         return NULL;

  000e4	33 c0		 xor	 eax, eax
  000e6	eb 0f		 jmp	 SHORT $LN4@float_is_i
$LN1@float_is_i:

; 801  :     }
; 802  :     Py_INCREF(o);

  000e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR o$[rsp]
  000ed	e8 00 00 00 00	 call	 _Py_IncRef

; 803  :     return o;

  000f2	48 8b 44 24 28	 mov	 rax, QWORD PTR o$[rsp]
$LN4@float_is_i:

; 804  : }

  000f7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fb	c3		 ret	 0
float_is_integer ENDP
_TEXT	ENDS
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@c1e0000000000000
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_trunc DD imagerel float_trunc
	DD	imagerel float_trunc+111
	DD	imagerel $unwind$float_trunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_trunc DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+009
CONST	ENDS
;	COMDAT __real@c1e0000000000000
CONST	SEGMENT
__real@c1e0000000000000 DQ 0c1e0000000000000r	; -2.14748e+009
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_trunc
_TEXT	SEGMENT
wholepart$ = 32
x$ = 40
aslong$20874 = 48
v$ = 80
float_trunc PROC					; COMDAT

; 837  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 838  :     double x = PyFloat_AsDouble(v);

  00009	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0000e	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00013	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR x$[rsp], xmm0

; 839  :     double wholepart;           /* integral portion of x, rounded toward 0 */
; 840  : 
; 841  :     (void)modf(x, &wholepart);

  00019	48 8d 54 24 20	 lea	 rdx, QWORD PTR wholepart$[rsp]
  0001e	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf

; 842  :     /* Try to get out cheap if this fits in a Python int.  The attempt
; 843  :      * to cast to long must be protected, as C doesn't define what
; 844  :      * happens if the double is too big to fit in a long.  Some rare
; 845  :      * systems raise an exception then (RISCOS was mentioned as one,
; 846  :      * and someone using a non-default option on Sun also bumped into
; 847  :      * that).  Note that checking for >= and <= LONG_{MIN,MAX} would
; 848  :      * still be vulnerable:  if a long has more bits of precision than
; 849  :      * a double, casting MIN/MAX to double may yield an approximation,
; 850  :      * and if that's rounded up, then, e.g., wholepart=LONG_MAX+1 would
; 851  :      * yield true from the C expression wholepart<=LONG_MAX, despite
; 852  :      * that wholepart is actually greater than LONG_MAX.
; 853  :      */
; 854  :     if (LONG_MIN < wholepart && wholepart < LONG_MAX) {

  0002a	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR wholepart$[rsp]
  00030	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@c1e0000000000000
  00038	76 25		 jbe	 SHORT $LN1@float_trun
  0003a	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@41dfffffffc00000
  00042	66 0f 2f 44 24
	20		 comisd	 xmm0, QWORD PTR wholepart$[rsp]
  00048	76 15		 jbe	 SHORT $LN1@float_trun

; 855  :         const long aslong = (long)wholepart;

  0004a	f2 0f 2c 44 24
	20		 cvttsd2si eax, QWORD PTR wholepart$[rsp]
  00050	89 44 24 30	 mov	 DWORD PTR aslong$20874[rsp], eax

; 856  :         return PyLong_FromLong(aslong);

  00054	8b 4c 24 30	 mov	 ecx, DWORD PTR aslong$20874[rsp]
  00058	e8 00 00 00 00	 call	 PyLong_FromLong
  0005d	eb 0b		 jmp	 SHORT $LN2@float_trun
$LN1@float_trun:

; 857  :     }
; 858  :     return PyLong_FromDouble(wholepart);

  0005f	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR wholepart$[rsp]
  00065	e8 00 00 00 00	 call	 PyLong_FromDouble
$LN2@float_trun:

; 859  : }

  0006a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006e	c3		 ret	 0
float_trunc ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CKLEOEBD@?$HMO?$AA@			; `string'
EXTRN	PyNumber_AsSsize_t:PROC
EXTRN	round:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_round DD imagerel float_round
	DD	imagerel float_round+327
	DD	imagerel $unwind$float_round
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_round DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_02CKLEOEBD@?$HMO?$AA@
CONST	SEGMENT
??_C@_02CKLEOEBD@?$HMO?$AA@ DB '|O', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_round
_TEXT	SEGMENT
x$ = 32
rounded$ = 40
ndigits$ = 48
o_ndigits$ = 56
v$ = 80
args$ = 88
float_round PROC					; COMDAT

; 979  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 980  :     double x, rounded;
; 981  :     PyObject *o_ndigits = NULL;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR o_ndigits$[rsp], 0

; 982  :     Py_ssize_t ndigits;
; 983  : 
; 984  :     x = PyFloat_AsDouble(v);

  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0001c	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00021	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 985  :     if (!PyArg_ParseTuple(args, "|O", &o_ndigits))

  00027	4c 8d 44 24 38	 lea	 r8, QWORD PTR o_ndigits$[rsp]
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02CKLEOEBD@?$HMO?$AA@
  00033	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00038	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0003d	85 c0		 test	 eax, eax
  0003f	75 07		 jne	 SHORT $LN9@float_roun

; 986  :         return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	e9 fa 00 00 00	 jmp	 $LN10@float_roun
$LN9@float_roun:

; 987  :     if (o_ndigits == NULL) {

  00048	48 83 7c 24 38
	00		 cmp	 QWORD PTR o_ndigits$[rsp], 0
  0004e	75 67		 jne	 SHORT $LN8@float_roun

; 988  :         /* single-argument round: round to nearest integer */
; 989  :         rounded = round(x);

  00050	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00056	e8 00 00 00 00	 call	 round
  0005b	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR rounded$[rsp], xmm0

; 990  :         if (fabs(x-rounded) == 0.5)

  00061	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00067	f2 0f 5c 44 24
	28		 subsd	 xmm0, QWORD PTR rounded$[rsp]
  0006d	e8 00 00 00 00	 call	 fabs
  00072	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3fe0000000000000
  0007a	7a 2b		 jp	 SHORT $LN7@float_roun
  0007c	75 29		 jne	 SHORT $LN7@float_roun

; 991  :             /* halfway case: round to even */
; 992  :             rounded = 2.0*round(x/2.0);

  0007e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00084	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  0008c	e8 00 00 00 00	 call	 round
  00091	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  00099	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0009d	66 0f 28 c1	 movapd	 xmm0, xmm1
  000a1	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR rounded$[rsp], xmm0
$LN7@float_roun:

; 993  :         return PyLong_FromDouble(rounded);

  000a7	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR rounded$[rsp]
  000ad	e8 00 00 00 00	 call	 PyLong_FromDouble
  000b2	e9 8b 00 00 00	 jmp	 $LN10@float_roun
$LN8@float_roun:

; 994  :     }
; 995  : 
; 996  :     /* interpret second argument as a Py_ssize_t; clips on overflow */
; 997  :     ndigits = PyNumber_AsSsize_t(o_ndigits, NULL);

  000b7	33 d2		 xor	 edx, edx
  000b9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR o_ndigits$[rsp]
  000be	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  000c3	48 89 44 24 30	 mov	 QWORD PTR ndigits$[rsp], rax

; 998  :     if (ndigits == -1 && PyErr_Occurred())

  000c8	48 83 7c 24 30
	ff		 cmp	 QWORD PTR ndigits$[rsp], -1
  000ce	75 0e		 jne	 SHORT $LN6@float_roun
  000d0	e8 00 00 00 00	 call	 PyErr_Occurred
  000d5	48 85 c0	 test	 rax, rax
  000d8	74 04		 je	 SHORT $LN6@float_roun

; 999  :         return NULL;

  000da	33 c0		 xor	 eax, eax
  000dc	eb 64		 jmp	 SHORT $LN10@float_roun
$LN6@float_roun:

; 1000 : 
; 1001 :     /* nans and infinities round to themselves */
; 1002 :     if (!Py_IS_FINITE(x))

  000de	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000ea	85 c0		 test	 eax, eax
  000ec	75 0d		 jne	 SHORT $LN5@float_roun

; 1003 :         return PyFloat_FromDouble(x);

  000ee	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000f4	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000f9	eb 47		 jmp	 SHORT $LN10@float_roun
$LN5@float_roun:

; 1004 : 
; 1005 :     /* Deal with extreme values for ndigits. For ndigits > NDIGITS_MAX, x
; 1006 :        always rounds to itself.  For ndigits < NDIGITS_MIN, x always
; 1007 :        rounds to +-0.0.  Here 0.30103 is an upper bound for log10(2). */
; 1008 : #define NDIGITS_MAX ((int)((DBL_MANT_DIG-DBL_MIN_EXP) * 0.30103))
; 1009 : #define NDIGITS_MIN (-(int)((DBL_MAX_EXP + 1) * 0.30103))
; 1010 :     if (ndigits > NDIGITS_MAX)

  000fb	48 81 7c 24 30
	43 01 00 00	 cmp	 QWORD PTR ndigits$[rsp], 323 ; 00000143H
  00104	7e 0f		 jle	 SHORT $LN4@float_roun

; 1011 :         /* return x */
; 1012 :         return PyFloat_FromDouble(x);

  00106	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0010c	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00111	eb 2f		 jmp	 SHORT $LN10@float_roun
  00113	eb 2d		 jmp	 SHORT $LN3@float_roun
$LN4@float_roun:

; 1013 :     else if (ndigits < NDIGITS_MIN)

  00115	48 81 7c 24 30
	cc fe ff ff	 cmp	 QWORD PTR ndigits$[rsp], -308 ; fffffffffffffeccH
  0011e	7d 13		 jge	 SHORT $LN2@float_roun

; 1014 :         /* return 0.0, but with sign of x */
; 1015 :         return PyFloat_FromDouble(0.0*x);

  00120	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00124	f2 0f 59 44 24
	20		 mulsd	 xmm0, QWORD PTR x$[rsp]
  0012a	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0012f	eb 11		 jmp	 SHORT $LN10@float_roun

; 1016 :     else

  00131	eb 0f		 jmp	 SHORT $LN1@float_roun
$LN2@float_roun:

; 1017 :         /* finite x, and ndigits is not unreasonably large */
; 1018 :         return double_round(x, (int)ndigits);

  00133	8b 54 24 30	 mov	 edx, DWORD PTR ndigits$[rsp]
  00137	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0013d	e8 00 00 00 00	 call	 double_round
$LN1@float_roun:
$LN3@float_roun:
$LN10@float_roun:

; 1019 : #undef NDIGITS_MAX
; 1020 : #undef NDIGITS_MIN
; 1021 : }

  00142	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00146	c3		 ret	 0
float_round ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@EAFJGAOB@rounded?5value?5too?5large?5to?5repre@ ; `string'
PUBLIC	??_C@_08IBNADMJP@?$CFs0?$CFse?$CFd?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
EXTRN	_Py_dg_freedtoa:PROC
EXTRN	_Py_dg_strtod:PROC
EXTRN	PyOS_snprintf:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	_Py_dg_dtoa:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$double_round DD imagerel double_round
	DD	imagerel double_round+475
	DD	imagerel $unwind$double_round
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$double_round DD 021101H
	DD	0210111H
xdata	ENDS
;	COMDAT ??_C@_0CF@EAFJGAOB@rounded?5value?5too?5large?5to?5repre@
CONST	SEGMENT
??_C@_0CF@EAFJGAOB@rounded?5value?5too?5large?5to?5repre@ DB 'rounded val'
	DB	'ue too large to represent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBNADMJP@?$CFs0?$CFse?$CFd?$AA@
CONST	SEGMENT
??_C@_08IBNADMJP@?$CFs0?$CFse?$CFd?$AA@ DB '%s0%se%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT double_round
_TEXT	SEGMENT
decpt$ = 48
buf_end$ = 56
buflen$ = 64
mybuflen$ = 72
rounded$ = 80
sign$ = 88
buf$ = 96
shortbuf$ = 112
result$ = 224
mybuf$ = 232
tv84 = 240
x$ = 272
ndigits$ = 280
double_round PROC					; COMDAT

; 871  : double_round(double x, int ndigits) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 872  : 
; 873  :     double rounded;
; 874  :     Py_ssize_t buflen, mybuflen=100;

  00011	48 c7 44 24 48
	64 00 00 00	 mov	 QWORD PTR mybuflen$[rsp], 100 ; 00000064H

; 875  :     char *buf, *buf_end, shortbuf[100], *mybuf=shortbuf;

  0001a	48 8d 44 24 70	 lea	 rax, QWORD PTR shortbuf$[rsp]
  0001f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR mybuf$[rsp], rax

; 876  :     int decpt, sign;
; 877  :     PyObject *result = NULL;

  00027	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR result$[rsp], 0

; 878  :     _Py_SET_53BIT_PRECISION_HEADER;
; 879  : 
; 880  :     /* round to a decimal string */
; 881  :     _Py_SET_53BIT_PRECISION_START;
; 882  :     buf = _Py_dg_dtoa(x, 3, ndigits, &decpt, &sign, &buf_end);

  00033	48 8d 44 24 38	 lea	 rax, QWORD PTR buf_end$[rsp]
  00038	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003d	48 8d 44 24 58	 lea	 rax, QWORD PTR sign$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	4c 8d 4c 24 30	 lea	 r9, QWORD PTR decpt$[rsp]
  0004c	44 8b 84 24 18
	01 00 00	 mov	 r8d, DWORD PTR ndigits$[rsp]
  00054	ba 03 00 00 00	 mov	 edx, 3
  00059	f2 0f 10 84 24
	10 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00062	e8 00 00 00 00	 call	 _Py_dg_dtoa
  00067	48 89 44 24 60	 mov	 QWORD PTR buf$[rsp], rax

; 883  :     _Py_SET_53BIT_PRECISION_END;
; 884  :     if (buf == NULL) {

  0006c	48 83 7c 24 60
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00072	75 0c		 jne	 SHORT $LN6@double_rou

; 885  :         PyErr_NoMemory();

  00074	e8 00 00 00 00	 call	 PyErr_NoMemory

; 886  :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 53 01 00 00	 jmp	 $LN7@double_rou
$LN6@double_rou:

; 887  :     }
; 888  : 
; 889  :     /* Get new buffer if shortbuf is too small.  Space needed <= buf_end -
; 890  :     buf + 8: (1 extra for '0', 1 for sign, 5 for exp, 1 for '\0').  */
; 891  :     buflen = buf_end - buf;

  00080	48 8b 44 24 60	 mov	 rax, QWORD PTR buf$[rsp]
  00085	48 8b 4c 24 38	 mov	 rcx, QWORD PTR buf_end$[rsp]
  0008a	48 2b c8	 sub	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 89 44 24 40	 mov	 QWORD PTR buflen$[rsp], rax

; 892  :     if (buflen + 8 > mybuflen) {

  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR buflen$[rsp]
  0009a	48 83 c0 08	 add	 rax, 8
  0009e	48 3b 44 24 48	 cmp	 rax, QWORD PTR mybuflen$[rsp]
  000a3	7e 35		 jle	 SHORT $LN5@double_rou

; 893  :         mybuflen = buflen+8;

  000a5	48 8b 44 24 40	 mov	 rax, QWORD PTR buflen$[rsp]
  000aa	48 83 c0 08	 add	 rax, 8
  000ae	48 89 44 24 48	 mov	 QWORD PTR mybuflen$[rsp], rax

; 894  :         mybuf = (char *)PyMem_Malloc(mybuflen);

  000b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR mybuflen$[rsp]
  000b8	e8 00 00 00 00	 call	 PyMem_Malloc
  000bd	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR mybuf$[rsp], rax

; 895  :         if (mybuf == NULL) {

  000c5	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR mybuf$[rsp], 0
  000ce	75 0a		 jne	 SHORT $LN4@double_rou

; 896  :             PyErr_NoMemory();

  000d0	e8 00 00 00 00	 call	 PyErr_NoMemory

; 897  :             goto exit;

  000d5	e9 e7 00 00 00	 jmp	 $exit$20900
$LN4@double_rou:
$LN5@double_rou:

; 898  :         }
; 899  :     }
; 900  :     /* copy buf to mybuf, adding exponent, sign and leading 0 */
; 901  :     PyOS_snprintf(mybuf, mybuflen, "%s0%se%d", (sign ? "-" : ""),
; 902  :                   buf, decpt - (int)buflen);

  000da	83 7c 24 58 00	 cmp	 DWORD PTR sign$[rsp], 0
  000df	74 11		 je	 SHORT $LN9@double_rou
  000e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01JOAMLHOP@?9?$AA@
  000e8	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  000f0	eb 0f		 jmp	 SHORT $LN10@double_rou
$LN9@double_rou:
  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000f9	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
$LN10@double_rou:
  00101	8b 44 24 40	 mov	 eax, DWORD PTR buflen$[rsp]
  00105	8b 4c 24 30	 mov	 ecx, DWORD PTR decpt$[rsp]
  00109	2b c8		 sub	 ecx, eax
  0010b	8b c1		 mov	 eax, ecx
  0010d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00111	48 8b 44 24 60	 mov	 rax, QWORD PTR buf$[rsp]
  00116	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011b	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR tv84[rsp]
  00123	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08IBNADMJP@?$CFs0?$CFse?$CFd?$AA@
  0012a	48 8b 54 24 48	 mov	 rdx, QWORD PTR mybuflen$[rsp]
  0012f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR mybuf$[rsp]
  00137	e8 00 00 00 00	 call	 PyOS_snprintf

; 903  : 
; 904  :     /* and convert the resulting string back to a double */
; 905  :     errno = 0;

  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00142	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 906  :     _Py_SET_53BIT_PRECISION_START;
; 907  :     rounded = _Py_dg_strtod(mybuf, NULL);

  00148	33 d2		 xor	 edx, edx
  0014a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR mybuf$[rsp]
  00152	e8 00 00 00 00	 call	 _Py_dg_strtod
  00157	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR rounded$[rsp], xmm0

; 908  :     _Py_SET_53BIT_PRECISION_END;
; 909  :     if (errno == ERANGE && fabs(rounded) >= 1.)

  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00163	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  00166	75 2a		 jne	 SHORT $LN3@double_rou
  00168	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR rounded$[rsp]
  0016e	e8 00 00 00 00	 call	 fabs
  00173	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  0017b	72 15		 jb	 SHORT $LN3@double_rou

; 910  :         PyErr_SetString(PyExc_OverflowError,
; 911  :                         "rounded value too large to represent");

  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@EAFJGAOB@rounded?5value?5too?5large?5to?5repre@
  00184	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0018b	e8 00 00 00 00	 call	 PyErr_SetString

; 912  :     else

  00190	eb 13		 jmp	 SHORT $LN2@double_rou
$LN3@double_rou:

; 913  :         result = PyFloat_FromDouble(rounded);

  00192	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR rounded$[rsp]
  00198	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0019d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR result$[rsp], rax
$LN2@double_rou:

; 914  : 
; 915  :     /* done computing value;  now clean up */
; 916  :     if (mybuf != shortbuf)

  001a5	48 8d 44 24 70	 lea	 rax, QWORD PTR shortbuf$[rsp]
  001aa	48 39 84 24 e8
	00 00 00	 cmp	 QWORD PTR mybuf$[rsp], rax
  001b2	74 0d		 je	 SHORT $LN1@double_rou

; 917  :         PyMem_Free(mybuf);

  001b4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR mybuf$[rsp]
  001bc	e8 00 00 00 00	 call	 PyMem_Free
$LN1@double_rou:
$exit$20900:

; 918  :   exit:
; 919  :     _Py_dg_freedtoa(buf);

  001c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buf$[rsp]
  001c6	e8 00 00 00 00	 call	 _Py_dg_freedtoa

; 920  :     return result;

  001cb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN7@double_rou:

; 921  : }

  001d3	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  001da	c3		 ret	 0
double_round ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_float DD imagerel float_float
	DD	imagerel float_float+69
	DD	imagerel $unwind$float_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_float DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_float
_TEXT	SEGMENT
v$ = 48
float_float PROC					; COMDAT

; 1025 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1026 :     if (PyFloat_CheckExact(v))

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	75 0c		 jne	 SHORT $LN2@float_floa

; 1027 :         Py_INCREF(v);

  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00020	e8 00 00 00 00	 call	 _Py_IncRef

; 1028 :     else

  00025	eb 14		 jmp	 SHORT $LN1@float_floa
$LN2@float_floa:

; 1029 :         v = PyFloat_FromDouble(((PyFloatObject *)v)->ob_fval);

  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0002c	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00031	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00036	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax
$LN1@float_floa:

; 1030 :     return v;

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]

; 1031 : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
float_float ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EHGMANAI@0x?$CFsp?$CFc?$CFd?$AA@	; `string'
PUBLIC	??_C@_0L@ICGJBGEC@?90x?$CFsp?$CFc?$CFd?$AA@	; `string'
PUBLIC	__real@4030000000000000
PUBLIC	??_C@_08PMPHOHFK@0x0?40p?$CL0?$AA@		; `string'
PUBLIC	??_C@_09EDNHBDOC@?90x0?40p?$CL0?$AA@		; `string'
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	__imp_ldexp:PROC
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_hex DD imagerel float_hex
	DD	imagerel float_hex+692
	DD	imagerel $unwind$float_hex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_hex DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_09EHGMANAI@0x?$CFsp?$CFc?$CFd?$AA@
CONST	SEGMENT
??_C@_09EHGMANAI@0x?$CFsp?$CFc?$CFd?$AA@ DB '0x%sp%c%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICGJBGEC@?90x?$CFsp?$CFc?$CFd?$AA@
CONST	SEGMENT
??_C@_0L@ICGJBGEC@?90x?$CFsp?$CFc?$CFd?$AA@ DB '-0x%sp%c%d', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT ??_C@_08PMPHOHFK@0x0?40p?$CL0?$AA@
CONST	SEGMENT
??_C@_08PMPHOHFK@0x0?40p?$CL0?$AA@ DB '0x0.0p+0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EDNHBDOC@?90x0?40p?$CL0?$AA@
CONST	SEGMENT
??_C@_09EDNHBDOC@?90x0?40p?$CL0?$AA@ DB '-0x0.0p+0', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_hex
_TEXT	SEGMENT
x$ = 32
i$ = 40
s$ = 48
esign$ = 64
si$ = 68
e$ = 72
shift$ = 76
m$ = 80
tv137 = 88
v$ = 112
float_hex PROC						; COMDAT

; 1115 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1116 :     double x, m;
; 1117 :     int e, shift, i, si, esign;
; 1118 :     /* Space for 1+(TOHEX_NBITS-1)/4 digits, a decimal point, and the
; 1119 :        trailing NUL byte. */
; 1120 :     char s[(TOHEX_NBITS-1)/4+3];
; 1121 : 
; 1122 :     CONVERT_TO_DOUBLE(v, x);

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00010	48 8b 4c 24 70	 mov	 rcx, QWORD PTR v$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 19		 je	 SHORT $LN15@float_hex
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00022	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	74 12		 je	 SHORT $LN16@float_hex
$LN15@float_hex:
  00034	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  00039	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  0003e	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0
  00044	eb 1d		 jmp	 SHORT $LN14@float_hex
$LN16@float_hex:
  00046	48 8d 54 24 20	 lea	 rdx, QWORD PTR x$[rsp]
  0004b	48 8d 4c 24 70	 lea	 rcx, QWORD PTR v$[rsp]
  00050	e8 00 00 00 00	 call	 convert_to_double
  00055	85 c0		 test	 eax, eax
  00057	7d 0a		 jge	 SHORT $LN13@float_hex
  00059	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  0005e	e9 4c 02 00 00	 jmp	 $LN17@float_hex
$LN13@float_hex:
$LN14@float_hex:

; 1123 : 
; 1124 :     if (Py_IS_NAN(x) || Py_IS_INFINITY(x))

  00063	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0006f	85 c0		 test	 eax, eax
  00071	75 20		 jne	 SHORT $LN11@float_hex
  00073	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0007f	85 c0		 test	 eax, eax
  00081	75 1f		 jne	 SHORT $LN12@float_hex
  00083	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0008f	85 c0		 test	 eax, eax
  00091	75 0f		 jne	 SHORT $LN12@float_hex
$LN11@float_hex:

; 1125 :         return float_repr((PyFloatObject *)v);

  00093	48 8b 4c 24 70	 mov	 rcx, QWORD PTR v$[rsp]
  00098	e8 00 00 00 00	 call	 float_repr
  0009d	e9 0d 02 00 00	 jmp	 $LN17@float_hex
$LN12@float_hex:

; 1126 : 
; 1127 :     if (x == 0.0) {

  000a2	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000a8	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000b0	7a 46		 jp	 SHORT $LN10@float_hex
  000b2	75 44		 jne	 SHORT $LN10@float_hex

; 1128 :         if (copysign(1.0, x) == -1.0)

  000b4	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR x$[rsp]
  000ba	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000c8	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  000d0	7a 15		 jp	 SHORT $LN9@float_hex
  000d2	75 13		 jne	 SHORT $LN9@float_hex

; 1129 :             return PyUnicode_FromString("-0x0.0p+0");

  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09EDNHBDOC@?90x0?40p?$CL0?$AA@
  000db	e8 00 00 00 00	 call	 PyUnicode_FromString
  000e0	e9 ca 01 00 00	 jmp	 $LN17@float_hex

; 1130 :         else

  000e5	eb 11		 jmp	 SHORT $LN8@float_hex
$LN9@float_hex:

; 1131 :             return PyUnicode_FromString("0x0.0p+0");

  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08PMPHOHFK@0x0?40p?$CL0?$AA@
  000ee	e8 00 00 00 00	 call	 PyUnicode_FromString
  000f3	e9 b7 01 00 00	 jmp	 $LN17@float_hex
$LN8@float_hex:
$LN10@float_hex:

; 1132 :     }
; 1133 : 
; 1134 :     m = frexp(fabs(x), &e);

  000f8	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000fe	e8 00 00 00 00	 call	 fabs
  00103	48 8d 54 24 48	 lea	 rdx, QWORD PTR e$[rsp]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp
  0010e	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR m$[rsp], xmm0

; 1135 :     shift = 1 - MAX(DBL_MIN_EXP - e, 0);

  00114	b8 03 fc ff ff	 mov	 eax, -1021		; fffffffffffffc03H
  00119	2b 44 24 48	 sub	 eax, DWORD PTR e$[rsp]
  0011d	85 c0		 test	 eax, eax
  0011f	7d 0a		 jge	 SHORT $LN19@float_hex
  00121	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
  00129	eb 0d		 jmp	 SHORT $LN20@float_hex
$LN19@float_hex:
  0012b	b8 03 fc ff ff	 mov	 eax, -1021		; fffffffffffffc03H
  00130	2b 44 24 48	 sub	 eax, DWORD PTR e$[rsp]
  00134	89 44 24 58	 mov	 DWORD PTR tv137[rsp], eax
$LN20@float_hex:
  00138	b8 01 00 00 00	 mov	 eax, 1
  0013d	2b 44 24 58	 sub	 eax, DWORD PTR tv137[rsp]
  00141	89 44 24 4c	 mov	 DWORD PTR shift$[rsp], eax

; 1136 :     m = ldexp(m, shift);

  00145	8b 54 24 4c	 mov	 edx, DWORD PTR shift$[rsp]
  00149	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR m$[rsp]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00155	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR m$[rsp], xmm0

; 1137 :     e -= shift;

  0015b	8b 44 24 4c	 mov	 eax, DWORD PTR shift$[rsp]
  0015f	8b 4c 24 48	 mov	 ecx, DWORD PTR e$[rsp]
  00163	2b c8		 sub	 ecx, eax
  00165	8b c1		 mov	 eax, ecx
  00167	89 44 24 48	 mov	 DWORD PTR e$[rsp], eax

; 1138 : 
; 1139 :     si = 0;

  0016b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR si$[rsp], 0

; 1140 :     s[si] = char_from_hex((int)m);

  00173	f2 0f 2c 44 24
	50		 cvttsd2si eax, QWORD PTR m$[rsp]
  00179	8b c8		 mov	 ecx, eax
  0017b	e8 00 00 00 00	 call	 char_from_hex
  00180	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR si$[rsp]
  00185	88 44 0c 30	 mov	 BYTE PTR s$[rsp+rcx], al

; 1141 :     si++;

  00189	8b 44 24 44	 mov	 eax, DWORD PTR si$[rsp]
  0018d	ff c0		 inc	 eax
  0018f	89 44 24 44	 mov	 DWORD PTR si$[rsp], eax

; 1142 :     m -= (int)m;

  00193	f2 0f 2c 44 24
	50		 cvttsd2si eax, QWORD PTR m$[rsp]
  00199	66 0f 6e c0	 movd	 xmm0, eax
  0019d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001a1	f2 0f 10 4c 24
	50		 movsdx	 xmm1, QWORD PTR m$[rsp]
  001a7	f2 0f 5c c8	 subsd	 xmm1, xmm0
  001ab	66 0f 28 c1	 movapd	 xmm0, xmm1
  001af	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR m$[rsp], xmm0

; 1143 :     s[si] = '.';

  001b5	48 63 44 24 44	 movsxd	 rax, DWORD PTR si$[rsp]
  001ba	c6 44 04 30 2e	 mov	 BYTE PTR s$[rsp+rax], 46 ; 0000002eH

; 1144 :     si++;

  001bf	8b 44 24 44	 mov	 eax, DWORD PTR si$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	89 44 24 44	 mov	 DWORD PTR si$[rsp], eax

; 1145 :     for (i=0; i < (TOHEX_NBITS-1)/4; i++) {

  001c9	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001d1	eb 0a		 jmp	 SHORT $LN7@float_hex
$LN6@float_hex:
  001d3	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001d7	ff c0		 inc	 eax
  001d9	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN7@float_hex:
  001dd	83 7c 24 28 0d	 cmp	 DWORD PTR i$[rsp], 13
  001e2	7d 58		 jge	 SHORT $LN5@float_hex

; 1146 :         m *= 16.0;

  001e4	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR m$[rsp]
  001ea	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4030000000000000
  001f2	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR m$[rsp], xmm0

; 1147 :         s[si] = char_from_hex((int)m);

  001f8	f2 0f 2c 44 24
	50		 cvttsd2si eax, QWORD PTR m$[rsp]
  001fe	8b c8		 mov	 ecx, eax
  00200	e8 00 00 00 00	 call	 char_from_hex
  00205	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR si$[rsp]
  0020a	88 44 0c 30	 mov	 BYTE PTR s$[rsp+rcx], al

; 1148 :         si++;

  0020e	8b 44 24 44	 mov	 eax, DWORD PTR si$[rsp]
  00212	ff c0		 inc	 eax
  00214	89 44 24 44	 mov	 DWORD PTR si$[rsp], eax

; 1149 :         m -= (int)m;

  00218	f2 0f 2c 44 24
	50		 cvttsd2si eax, QWORD PTR m$[rsp]
  0021e	66 0f 6e c0	 movd	 xmm0, eax
  00222	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00226	f2 0f 10 4c 24
	50		 movsdx	 xmm1, QWORD PTR m$[rsp]
  0022c	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00230	66 0f 28 c1	 movapd	 xmm0, xmm1
  00234	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR m$[rsp], xmm0

; 1150 :     }

  0023a	eb 97		 jmp	 SHORT $LN6@float_hex
$LN5@float_hex:

; 1151 :     s[si] = '\0';

  0023c	48 63 44 24 44	 movsxd	 rax, DWORD PTR si$[rsp]
  00241	c6 44 04 30 00	 mov	 BYTE PTR s$[rsp+rax], 0

; 1152 : 
; 1153 :     if (e < 0) {

  00246	83 7c 24 48 00	 cmp	 DWORD PTR e$[rsp], 0
  0024b	7d 14		 jge	 SHORT $LN4@float_hex

; 1154 :         esign = (int)'-';

  0024d	c7 44 24 40 2d
	00 00 00	 mov	 DWORD PTR esign$[rsp], 45 ; 0000002dH

; 1155 :         e = -e;

  00255	8b 44 24 48	 mov	 eax, DWORD PTR e$[rsp]
  00259	f7 d8		 neg	 eax
  0025b	89 44 24 48	 mov	 DWORD PTR e$[rsp], eax

; 1156 :     }
; 1157 :     else

  0025f	eb 08		 jmp	 SHORT $LN3@float_hex
$LN4@float_hex:

; 1158 :         esign = (int)'+';

  00261	c7 44 24 40 2b
	00 00 00	 mov	 DWORD PTR esign$[rsp], 43 ; 0000002bH
$LN3@float_hex:

; 1159 : 
; 1160 :     if (x < 0.0)

  00269	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0026d	66 0f 2f 44 24
	20		 comisd	 xmm0, QWORD PTR x$[rsp]
  00273	76 1f		 jbe	 SHORT $LN2@float_hex

; 1161 :         return PyUnicode_FromFormat("-0x%sp%c%d", s, esign, e);

  00275	44 8b 4c 24 48	 mov	 r9d, DWORD PTR e$[rsp]
  0027a	44 8b 44 24 40	 mov	 r8d, DWORD PTR esign$[rsp]
  0027f	48 8d 54 24 30	 lea	 rdx, QWORD PTR s$[rsp]
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICGJBGEC@?90x?$CFsp?$CFc?$CFd?$AA@
  0028b	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00290	eb 1d		 jmp	 SHORT $LN17@float_hex

; 1162 :     else

  00292	eb 1b		 jmp	 SHORT $LN1@float_hex
$LN2@float_hex:

; 1163 :         return PyUnicode_FromFormat("0x%sp%c%d", s, esign, e);

  00294	44 8b 4c 24 48	 mov	 r9d, DWORD PTR e$[rsp]
  00299	44 8b 44 24 40	 mov	 r8d, DWORD PTR esign$[rsp]
  0029e	48 8d 54 24 30	 lea	 rdx, QWORD PTR s$[rsp]
  002a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09EHGMANAI@0x?$CFsp?$CFc?$CFd?$AA@
  002aa	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN1@float_hex:
$LN17@float_hex:

; 1164 : }

  002af	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b3	c3		 ret	 0
float_hex ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@GNCOPDAC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AA1?$AA6?$AA?$AA@ ; `string'
EXTRN	Py_hexdigits:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$char_from_hex DD imagerel char_from_hex
	DD	imagerel char_from_hex+71
	DD	imagerel $unwind$char_from_hex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$char_from_hex DD 010801H
	DD	04208H
xdata	ENDS
;	COMDAT ??_C@_1CC@GNCOPDAC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AA1?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@GNCOPDAC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AA1?$AA6?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'x', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, '1', 00H, '6', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT char_from_hex
_TEXT	SEGMENT
x$ = 48
char_from_hex PROC					; COMDAT

; 1037 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1038 :     assert(0 <= x && x < 16);

  00008	83 7c 24 30 00	 cmp	 DWORD PTR x$[rsp], 0
  0000d	7c 07		 jl	 SHORT $LN3@char_from_
  0000f	83 7c 24 30 10	 cmp	 DWORD PTR x$[rsp], 16
  00014	7c 1c		 jl	 SHORT $LN4@char_from_
$LN3@char_from_:
  00016	41 b8 0e 04 00
	00		 mov	 r8d, 1038		; 0000040eH
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@GNCOPDAC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AA1?$AA6?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN4@char_from_:

; 1039 :     return Py_hexdigits[x];

  00032	48 63 44 24 30	 movsxd	 rax, DWORD PTR x$[rsp]
  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Py_hexdigits
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]

; 1040 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
char_from_hex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@MAGDKHAN@hexadecimal?5string?5too?5long?5to?5c@ ; `string'
PUBLIC	??_C@_0CK@KHPMGGCN@invalid?5hexadecimal?5floating?9poi@ ; `string'
PUBLIC	??_C@_0DE@JIJECJKD@hexadecimal?5value?5too?5large?5to?5r@ ; `string'
PUBLIC	??_C@_03LAKFFLCF@?$CId?$CJ?$AA@			; `string'
EXTRN	PyObject_CallObject:PROC
EXTRN	__imp_strtol:PROC
EXTRN	_Py_parse_inf_or_nan:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_fromhex DD imagerel float_fromhex
	DD	imagerel float_fromhex+2639
	DD	imagerel $unwind$float_fromhex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_fromhex DD 021101H
	DD	0230111H
xdata	ENDS
;	COMDAT ??_C@_0CH@MAGDKHAN@hexadecimal?5string?5too?5long?5to?5c@
CONST	SEGMENT
??_C@_0CH@MAGDKHAN@hexadecimal?5string?5too?5long?5to?5c@ DB 'hexadecimal'
	DB	' string too long to convert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KHPMGGCN@invalid?5hexadecimal?5floating?9poi@
CONST	SEGMENT
??_C@_0CK@KHPMGGCN@invalid?5hexadecimal?5floating?9poi@ DB 'invalid hexad'
	DB	'ecimal floating-point string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JIJECJKD@hexadecimal?5value?5too?5large?5to?5r@
CONST	SEGMENT
??_C@_0DE@JIJECJKD@hexadecimal?5value?5too?5large?5to?5r@ DB 'hexadecimal'
	DB	' value too large to represent as a float', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LAKFFLCF@?$CId?$CJ?$AA@
CONST	SEGMENT
??_C@_03LAKFFLCF@?$CId?$CJ?$AA@ DB '(d)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_fromhex
_TEXT	SEGMENT
result_as_float$ = 32
fdigits$ = 40
digit$ = 48
length$ = 56
coeff_start$ = 64
x$ = 72
i$ = 80
s_end$ = 88
exp$ = 96
round_up$ = 100
s$ = 104
exp_start$ = 112
ndigits$ = 120
negate$ = 128
half_eps$ = 132
s_store$ = 136
top_exp$ = 144
result$ = 152
coeff_end$ = 160
key_digit$ = 168
lsb$ = 172
tv177 = 176
tv197 = 184
tv205 = 192
tv217 = 200
tv211 = 208
tv466 = 216
tv241 = 224
tv235 = 232
tv253 = 240
tv279 = 248
tv292 = 256
tv324 = 264
cls$ = 288
arg$ = 296
float_fromhex PROC					; COMDAT

; 1179 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 1180 :     PyObject *result_as_float, *result;
; 1181 :     double x;
; 1182 :     long exp, top_exp, lsb, key_digit;
; 1183 :     char *s, *coeff_start, *s_store, *coeff_end, *exp_start, *s_end;
; 1184 :     int half_eps, digit, round_up, negate=0;

  00011	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR negate$[rsp], 0

; 1185 :     Py_ssize_t length, ndigits, fdigits, i;
; 1186 : 
; 1187 :     /*
; 1188 :      * For the sake of simplicity and correctness, we impose an artificial
; 1189 :      * limit on ndigits, the total number of hex digits in the coefficient
; 1190 :      * The limit is chosen to ensure that, writing exp for the exponent,
; 1191 :      *
; 1192 :      *   (1) if exp > LONG_MAX/2 then the value of the hex string is
; 1193 :      *   guaranteed to overflow (provided it's nonzero)
; 1194 :      *
; 1195 :      *   (2) if exp < LONG_MIN/2 then the value of the hex string is
; 1196 :      *   guaranteed to underflow to 0.
; 1197 :      *
; 1198 :      *   (3) if LONG_MIN/2 <= exp <= LONG_MAX/2 then there's no danger of
; 1199 :      *   overflow in the calculation of exp and top_exp below.
; 1200 :      *
; 1201 :      * More specifically, ndigits is assumed to satisfy the following
; 1202 :      * inequalities:
; 1203 :      *
; 1204 :      *   4*ndigits <= DBL_MIN_EXP - DBL_MANT_DIG - LONG_MIN/2
; 1205 :      *   4*ndigits <= LONG_MAX/2 + 1 - DBL_MAX_EXP
; 1206 :      *
; 1207 :      * If either of these inequalities is not satisfied, a ValueError is
; 1208 :      * raised.  Otherwise, write x for the value of the hex string, and
; 1209 :      * assume x is nonzero.  Then
; 1210 :      *
; 1211 :      *   2**(exp-4*ndigits) <= |x| < 2**(exp+4*ndigits).
; 1212 :      *
; 1213 :      * Now if exp > LONG_MAX/2 then:
; 1214 :      *
; 1215 :      *   exp - 4*ndigits >= LONG_MAX/2 + 1 - (LONG_MAX/2 + 1 - DBL_MAX_EXP)
; 1216 :      *                    = DBL_MAX_EXP
; 1217 :      *
; 1218 :      * so |x| >= 2**DBL_MAX_EXP, which is too large to be stored in C
; 1219 :      * double, so overflows.  If exp < LONG_MIN/2, then
; 1220 :      *
; 1221 :      *   exp + 4*ndigits <= LONG_MIN/2 - 1 + (
; 1222 :      *                      DBL_MIN_EXP - DBL_MANT_DIG - LONG_MIN/2)
; 1223 :      *                    = DBL_MIN_EXP - DBL_MANT_DIG - 1
; 1224 :      *
; 1225 :      * and so |x| < 2**(DBL_MIN_EXP-DBL_MANT_DIG-1), hence underflows to 0
; 1226 :      * when converted to a C double.
; 1227 :      *
; 1228 :      * It's easy to show that if LONG_MIN/2 <= exp <= LONG_MAX/2 then both
; 1229 :      * exp+4*ndigits and exp-4*ndigits are within the range of a long.
; 1230 :      */
; 1231 : 
; 1232 :     s = _PyUnicode_AsStringAndSize(arg, &length);

  0001c	48 8d 54 24 38	 lea	 rdx, QWORD PTR length$[rsp]
  00021	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00029	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  0002e	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax

; 1233 :     if (s == NULL)

  00033	48 83 7c 24 68
	00		 cmp	 QWORD PTR s$[rsp], 0
  00039	75 07		 jne	 SHORT $LN59@float_from

; 1234 :         return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	e9 05 0a 00 00	 jmp	 $LN60@float_from
$LN59@float_from:

; 1235 :     s_end = s + length;

  00042	48 8b 44 24 38	 mov	 rax, QWORD PTR length$[rsp]
  00047	48 8b 4c 24 68	 mov	 rcx, QWORD PTR s$[rsp]
  0004c	48 03 c8	 add	 rcx, rax
  0004f	48 8b c1	 mov	 rax, rcx
  00052	48 89 44 24 58	 mov	 QWORD PTR s_end$[rsp], rax
$LN58@float_from:

; 1236 : 
; 1237 :     /********************
; 1238 :      * Parse the string *
; 1239 :      ********************/
; 1240 : 
; 1241 :     /* leading whitespace */
; 1242 :     while (Py_ISSPACE(*s))

  00057	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0005c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00064	0f b6 c0	 movzx	 eax, al
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0006e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00071	83 e0 08	 and	 eax, 8
  00074	85 c0		 test	 eax, eax
  00076	74 0f		 je	 SHORT $LN57@float_from

; 1243 :         s++;

  00078	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0007d	48 ff c0	 inc	 rax
  00080	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax
  00085	eb d0		 jmp	 SHORT $LN58@float_from
$LN57@float_from:

; 1244 : 
; 1245 :     /* infinities and nans */
; 1246 :     x = _Py_parse_inf_or_nan(s, &coeff_end);

  00087	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR coeff_end$[rsp]
  0008f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR s$[rsp]
  00094	e8 00 00 00 00	 call	 _Py_parse_inf_or_nan
  00099	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1247 :     if (coeff_end != s) {

  0009f	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000a4	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR coeff_end$[rsp], rax
  000ac	74 12		 je	 SHORT $LN56@float_from

; 1248 :         s = coeff_end;

  000ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coeff_end$[rsp]
  000b6	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax

; 1249 :         goto finished;

  000bb	e9 78 08 00 00	 jmp	 $finished$21060
$LN56@float_from:

; 1250 :     }
; 1251 : 
; 1252 :     /* optional sign */
; 1253 :     if (*s == '-') {

  000c0	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000c5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c8	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000cb	75 1a		 jne	 SHORT $LN55@float_from

; 1254 :         s++;

  000cd	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000d2	48 ff c0	 inc	 rax
  000d5	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax

; 1255 :         negate = 1;

  000da	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR negate$[rsp], 1
  000e5	eb 1a		 jmp	 SHORT $LN54@float_from
$LN55@float_from:

; 1256 :     }
; 1257 :     else if (*s == '+')

  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000ec	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ef	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  000f2	75 0d		 jne	 SHORT $LN53@float_from

; 1258 :         s++;

  000f4	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000f9	48 ff c0	 inc	 rax
  000fc	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax
$LN53@float_from:
$LN54@float_from:

; 1259 : 
; 1260 :     /* [0x] */
; 1261 :     s_store = s;

  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00106	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s_store$[rsp], rax

; 1262 :     if (*s == '0') {

  0010e	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00113	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00116	83 f8 30	 cmp	 eax, 48			; 00000030H
  00119	75 43		 jne	 SHORT $LN52@float_from

; 1263 :         s++;

  0011b	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00120	48 ff c0	 inc	 rax
  00123	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax

; 1264 :         if (*s == 'x' || *s == 'X')

  00128	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0012d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00130	83 f8 78	 cmp	 eax, 120		; 00000078H
  00133	74 0d		 je	 SHORT $LN50@float_from
  00135	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0013a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0013d	83 f8 58	 cmp	 eax, 88			; 00000058H
  00140	75 0f		 jne	 SHORT $LN51@float_from
$LN50@float_from:

; 1265 :             s++;

  00142	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00147	48 ff c0	 inc	 rax
  0014a	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax

; 1266 :         else

  0014f	eb 0d		 jmp	 SHORT $LN49@float_from
$LN51@float_from:

; 1267 :             s = s_store;

  00151	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s_store$[rsp]
  00159	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax
$LN49@float_from:
$LN52@float_from:

; 1268 :     }
; 1269 : 
; 1270 :     /* coefficient: <integer> [. <fraction>] */
; 1271 :     coeff_start = s;

  0015e	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00163	48 89 44 24 40	 mov	 QWORD PTR coeff_start$[rsp], rax
$LN48@float_from:

; 1272 :     while (hex_from_char(*s) >= 0)

  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0016d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00170	e8 00 00 00 00	 call	 hex_from_char
  00175	85 c0		 test	 eax, eax
  00177	7c 0f		 jl	 SHORT $LN47@float_from

; 1273 :         s++;

  00179	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0017e	48 ff c0	 inc	 rax
  00181	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax
  00186	eb e0		 jmp	 SHORT $LN48@float_from
$LN47@float_from:

; 1274 :     s_store = s;

  00188	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0018d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s_store$[rsp], rax

; 1275 :     if (*s == '.') {

  00195	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0019a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0019d	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001a0	75 3f		 jne	 SHORT $LN46@float_from

; 1276 :         s++;

  001a2	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  001a7	48 ff c0	 inc	 rax
  001aa	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax
$LN45@float_from:

; 1277 :         while (hex_from_char(*s) >= 0)

  001af	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  001b4	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001b7	e8 00 00 00 00	 call	 hex_from_char
  001bc	85 c0		 test	 eax, eax
  001be	7c 0f		 jl	 SHORT $LN44@float_from

; 1278 :             s++;

  001c0	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  001c5	48 ff c0	 inc	 rax
  001c8	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax
  001cd	eb e0		 jmp	 SHORT $LN45@float_from
$LN44@float_from:

; 1279 :         coeff_end = s-1;

  001cf	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  001d4	48 ff c8	 dec	 rax
  001d7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR coeff_end$[rsp], rax

; 1280 :     }
; 1281 :     else

  001df	eb 0d		 jmp	 SHORT $LN43@float_from
$LN46@float_from:

; 1282 :         coeff_end = s;

  001e1	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  001e6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR coeff_end$[rsp], rax
$LN43@float_from:

; 1283 : 
; 1284 :     /* ndigits = total # of hex digits; fdigits = # after point */
; 1285 :     ndigits = coeff_end - coeff_start;

  001ee	48 8b 44 24 40	 mov	 rax, QWORD PTR coeff_start$[rsp]
  001f3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coeff_end$[rsp]
  001fb	48 2b c8	 sub	 rcx, rax
  001fe	48 8b c1	 mov	 rax, rcx
  00201	48 89 44 24 78	 mov	 QWORD PTR ndigits$[rsp], rax

; 1286 :     fdigits = coeff_end - s_store;

  00206	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s_store$[rsp]
  0020e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coeff_end$[rsp]
  00216	48 2b c8	 sub	 rcx, rax
  00219	48 8b c1	 mov	 rax, rcx
  0021c	48 89 44 24 28	 mov	 QWORD PTR fdigits$[rsp], rax

; 1287 :     if (ndigits == 0)

  00221	48 83 7c 24 78
	00		 cmp	 QWORD PTR ndigits$[rsp], 0
  00227	75 05		 jne	 SHORT $LN42@float_from

; 1288 :         goto parse_error;

  00229	e9 ed 07 00 00	 jmp	 $parse_error$21077
$LN42@float_from:

; 1289 :     if (ndigits > MIN(DBL_MIN_EXP - DBL_MANT_DIG - LONG_MIN/2,
; 1290 :                       LONG_MAX/2 + 1 - DBL_MAX_EXP)/4)

  0022e	48 81 7c 24 78
	f3 fe ff 0f	 cmp	 QWORD PTR ndigits$[rsp], 268435187 ; 0ffffef3H
  00237	7e 05		 jle	 SHORT $LN41@float_from

; 1291 :         goto insane_length_error;

  00239	e9 f4 07 00 00	 jmp	 $insane_length_error$21079
$LN41@float_from:

; 1292 : 
; 1293 :     /* [p <exponent>] */
; 1294 :     if (*s == 'p' || *s == 'P') {

  0023e	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00243	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00246	83 f8 70	 cmp	 eax, 112		; 00000070H
  00249	74 11		 je	 SHORT $LN39@float_from
  0024b	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00250	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00253	83 f8 50	 cmp	 eax, 80			; 00000050H
  00256	0f 85 ac 00 00
	00		 jne	 $LN40@float_from
$LN39@float_from:

; 1295 :         s++;

  0025c	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00261	48 ff c0	 inc	 rax
  00264	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax

; 1296 :         exp_start = s;

  00269	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0026e	48 89 44 24 70	 mov	 QWORD PTR exp_start$[rsp], rax

; 1297 :         if (*s == '-' || *s == '+')

  00273	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00278	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0027b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0027e	74 0d		 je	 SHORT $LN37@float_from
  00280	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00285	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00288	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0028b	75 0d		 jne	 SHORT $LN38@float_from
$LN37@float_from:

; 1298 :             s++;

  0028d	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00292	48 ff c0	 inc	 rax
  00295	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax
$LN38@float_from:

; 1299 :         if (!('0' <= *s && *s <= '9'))

  0029a	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0029f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002a2	83 f8 30	 cmp	 eax, 48			; 00000030H
  002a5	7c 0d		 jl	 SHORT $LN35@float_from
  002a7	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  002ac	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002af	83 f8 39	 cmp	 eax, 57			; 00000039H
  002b2	7e 05		 jle	 SHORT $LN36@float_from
$LN35@float_from:

; 1300 :             goto parse_error;

  002b4	e9 62 07 00 00	 jmp	 $parse_error$21077
$LN36@float_from:

; 1301 :         s++;

  002b9	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  002be	48 ff c0	 inc	 rax
  002c1	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax
$LN34@float_from:

; 1302 :         while ('0' <= *s && *s <= '9')

  002c6	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  002cb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ce	83 f8 30	 cmp	 eax, 48			; 00000030H
  002d1	7c 1c		 jl	 SHORT $LN33@float_from
  002d3	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  002d8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002db	83 f8 39	 cmp	 eax, 57			; 00000039H
  002de	7f 0f		 jg	 SHORT $LN33@float_from

; 1303 :             s++;

  002e0	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  002e5	48 ff c0	 inc	 rax
  002e8	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax
  002ed	eb d7		 jmp	 SHORT $LN34@float_from
$LN33@float_from:

; 1304 :         exp = strtol(exp_start, NULL, 10);

  002ef	41 b8 0a 00 00
	00		 mov	 r8d, 10
  002f5	33 d2		 xor	 edx, edx
  002f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR exp_start$[rsp]
  002fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  00302	89 44 24 60	 mov	 DWORD PTR exp$[rsp], eax

; 1305 :     }
; 1306 :     else

  00306	eb 08		 jmp	 SHORT $LN32@float_from
$LN40@float_from:

; 1307 :         exp = 0;

  00308	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR exp$[rsp], 0
$LN32@float_from:
$LN31@float_from:

; 1308 : 
; 1309 : /* for 0 <= j < ndigits, HEX_DIGIT(j) gives the jth most significant digit */
; 1310 : #define HEX_DIGIT(j) hex_from_char(*((j) < fdigits ?            \
; 1311 :                      coeff_end-(j) :                                    \
; 1312 :                      coeff_end-1-(j)))
; 1313 : 
; 1314 :     /*******************************************
; 1315 :      * Compute rounded value of the hex string *
; 1316 :      *******************************************/
; 1317 : 
; 1318 :     /* Discard leading zeros, and catch extreme overflow and underflow */
; 1319 :     while (ndigits > 0 && HEX_DIGIT(ndigits-1) == 0)

  00310	48 83 7c 24 78
	00		 cmp	 QWORD PTR ndigits$[rsp], 0
  00316	7e 70		 jle	 SHORT $LN30@float_from
  00318	48 8b 44 24 78	 mov	 rax, QWORD PTR ndigits$[rsp]
  0031d	48 ff c8	 dec	 rax
  00320	48 3b 44 24 28	 cmp	 rax, QWORD PTR fdigits$[rsp]
  00325	7d 20		 jge	 SHORT $LN62@float_from
  00327	48 8b 44 24 78	 mov	 rax, QWORD PTR ndigits$[rsp]
  0032c	48 ff c8	 dec	 rax
  0032f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coeff_end$[rsp]
  00337	48 2b c8	 sub	 rcx, rax
  0033a	48 8b c1	 mov	 rax, rcx
  0033d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
  00345	eb 1e		 jmp	 SHORT $LN63@float_from
$LN62@float_from:
  00347	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coeff_end$[rsp]
  0034f	48 ff c8	 dec	 rax
  00352	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ndigits$[rsp]
  00357	48 ff c9	 dec	 rcx
  0035a	48 2b c1	 sub	 rax, rcx
  0035d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
$LN63@float_from:
  00365	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv177[rsp]
  0036d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00370	e8 00 00 00 00	 call	 hex_from_char
  00375	85 c0		 test	 eax, eax
  00377	75 0f		 jne	 SHORT $LN30@float_from

; 1320 :         ndigits--;

  00379	48 8b 44 24 78	 mov	 rax, QWORD PTR ndigits$[rsp]
  0037e	48 ff c8	 dec	 rax
  00381	48 89 44 24 78	 mov	 QWORD PTR ndigits$[rsp], rax
  00386	eb 88		 jmp	 SHORT $LN31@float_from
$LN30@float_from:

; 1321 :     if (ndigits == 0 || exp < LONG_MIN/2) {

  00388	48 83 7c 24 78
	00		 cmp	 QWORD PTR ndigits$[rsp], 0
  0038e	74 0a		 je	 SHORT $LN28@float_from
  00390	81 7c 24 60 00
	00 00 c0	 cmp	 DWORD PTR exp$[rsp], -1073741824 ; ffffffffc0000000H
  00398	7d 0f		 jge	 SHORT $LN29@float_from
$LN28@float_from:

; 1322 :         x = 0.0;

  0039a	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0039e	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1323 :         goto finished;

  003a4	e9 8f 05 00 00	 jmp	 $finished$21060
$LN29@float_from:

; 1324 :     }
; 1325 :     if (exp > LONG_MAX/2)

  003a9	81 7c 24 60 ff
	ff ff 3f	 cmp	 DWORD PTR exp$[rsp], 1073741823 ; 3fffffffH
  003b1	7e 05		 jle	 SHORT $LN27@float_from

; 1326 :         goto overflow_error;

  003b3	e9 4c 06 00 00	 jmp	 $overflow_error$21098
$LN27@float_from:

; 1327 : 
; 1328 :     /* Adjust exponent for fractional part. */
; 1329 :     exp = exp - 4*((long)fdigits);

  003b8	8b 44 24 28	 mov	 eax, DWORD PTR fdigits$[rsp]
  003bc	c1 e0 02	 shl	 eax, 2
  003bf	8b 4c 24 60	 mov	 ecx, DWORD PTR exp$[rsp]
  003c3	2b c8		 sub	 ecx, eax
  003c5	8b c1		 mov	 eax, ecx
  003c7	89 44 24 60	 mov	 DWORD PTR exp$[rsp], eax

; 1330 : 
; 1331 :     /* top_exp = 1 more than exponent of most sig. bit of coefficient */
; 1332 :     top_exp = exp + 4*((long)ndigits - 1);

  003cb	8b 44 24 60	 mov	 eax, DWORD PTR exp$[rsp]
  003cf	8b 4c 24 78	 mov	 ecx, DWORD PTR ndigits$[rsp]
  003d3	8d 44 88 fc	 lea	 eax, DWORD PTR [rax+rcx*4-4]
  003d7	89 84 24 90 00
	00 00		 mov	 DWORD PTR top_exp$[rsp], eax

; 1333 :     for (digit = HEX_DIGIT(ndigits-1); digit != 0; digit /= 2)

  003de	48 8b 44 24 78	 mov	 rax, QWORD PTR ndigits$[rsp]
  003e3	48 ff c8	 dec	 rax
  003e6	48 3b 44 24 28	 cmp	 rax, QWORD PTR fdigits$[rsp]
  003eb	7d 20		 jge	 SHORT $LN64@float_from
  003ed	48 8b 44 24 78	 mov	 rax, QWORD PTR ndigits$[rsp]
  003f2	48 ff c8	 dec	 rax
  003f5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coeff_end$[rsp]
  003fd	48 2b c8	 sub	 rcx, rax
  00400	48 8b c1	 mov	 rax, rcx
  00403	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv197[rsp], rax
  0040b	eb 1e		 jmp	 SHORT $LN65@float_from
$LN64@float_from:
  0040d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coeff_end$[rsp]
  00415	48 ff c8	 dec	 rax
  00418	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ndigits$[rsp]
  0041d	48 ff c9	 dec	 rcx
  00420	48 2b c1	 sub	 rax, rcx
  00423	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv197[rsp], rax
$LN65@float_from:
  0042b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv197[rsp]
  00433	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00436	e8 00 00 00 00	 call	 hex_from_char
  0043b	89 44 24 30	 mov	 DWORD PTR digit$[rsp], eax
  0043f	eb 0d		 jmp	 SHORT $LN26@float_from
$LN25@float_from:
  00441	8b 44 24 30	 mov	 eax, DWORD PTR digit$[rsp]
  00445	99		 cdq
  00446	2b c2		 sub	 eax, edx
  00448	d1 f8		 sar	 eax, 1
  0044a	89 44 24 30	 mov	 DWORD PTR digit$[rsp], eax
$LN26@float_from:
  0044e	83 7c 24 30 00	 cmp	 DWORD PTR digit$[rsp], 0
  00453	74 12		 je	 SHORT $LN24@float_from

; 1334 :         top_exp++;

  00455	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR top_exp$[rsp]
  0045c	ff c0		 inc	 eax
  0045e	89 84 24 90 00
	00 00		 mov	 DWORD PTR top_exp$[rsp], eax
  00465	eb da		 jmp	 SHORT $LN25@float_from
$LN24@float_from:

; 1335 : 
; 1336 :     /* catch almost all nonextreme cases of overflow and underflow here */
; 1337 :     if (top_exp < DBL_MIN_EXP - DBL_MANT_DIG) {

  00467	81 bc 24 90 00
	00 00 ce fb ff
	ff		 cmp	 DWORD PTR top_exp$[rsp], -1074 ; fffffffffffffbceH
  00472	7d 0f		 jge	 SHORT $LN23@float_from

; 1338 :         x = 0.0;

  00474	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00478	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1339 :         goto finished;

  0047e	e9 b5 04 00 00	 jmp	 $finished$21060
$LN23@float_from:

; 1340 :     }
; 1341 :     if (top_exp > DBL_MAX_EXP)

  00483	81 bc 24 90 00
	00 00 00 04 00
	00		 cmp	 DWORD PTR top_exp$[rsp], 1024 ; 00000400H
  0048e	7e 05		 jle	 SHORT $LN22@float_from

; 1342 :         goto overflow_error;

  00490	e9 6f 05 00 00	 jmp	 $overflow_error$21098
$LN22@float_from:

; 1343 : 
; 1344 :     /* lsb = exponent of least significant bit of the *rounded* value.
; 1345 :        This is top_exp - DBL_MANT_DIG unless result is subnormal. */
; 1346 :     lsb = MAX(top_exp, (long)DBL_MIN_EXP) - DBL_MANT_DIG;

  00495	81 bc 24 90 00
	00 00 03 fc ff
	ff		 cmp	 DWORD PTR top_exp$[rsp], -1021 ; fffffffffffffc03H
  004a0	7d 0d		 jge	 SHORT $LN66@float_from
  004a2	c7 84 24 c0 00
	00 00 03 fc ff
	ff		 mov	 DWORD PTR tv205[rsp], -1021 ; fffffffffffffc03H
  004ad	eb 0e		 jmp	 SHORT $LN67@float_from
$LN66@float_from:
  004af	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR top_exp$[rsp]
  004b6	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv205[rsp], eax
$LN67@float_from:
  004bd	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv205[rsp]
  004c4	83 e8 35	 sub	 eax, 53			; 00000035H
  004c7	89 84 24 ac 00
	00 00		 mov	 DWORD PTR lsb$[rsp], eax

; 1347 : 
; 1348 :     x = 0.0;

  004ce	66 0f 57 c0	 xorpd	 xmm0, xmm0
  004d2	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1349 :     if (exp >= lsb) {

  004d8	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR lsb$[rsp]
  004df	39 44 24 60	 cmp	 DWORD PTR exp$[rsp], eax
  004e3	0f 8c cf 00 00
	00		 jl	 $LN21@float_from

; 1350 :         /* no rounding required */
; 1351 :         for (i = ndigits-1; i >= 0; i--)

  004e9	48 8b 44 24 78	 mov	 rax, QWORD PTR ndigits$[rsp]
  004ee	48 ff c8	 dec	 rax
  004f1	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax
  004f6	eb 0d		 jmp	 SHORT $LN20@float_from
$LN19@float_from:
  004f8	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  004fd	48 ff c8	 dec	 rax
  00500	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax
$LN20@float_from:
  00505	48 83 7c 24 50
	00		 cmp	 QWORD PTR i$[rsp], 0
  0050b	0f 8c 8c 00 00
	00		 jl	 $LN18@float_from

; 1352 :             x = 16.0*x + HEX_DIGIT(i);

  00511	48 8b 44 24 28	 mov	 rax, QWORD PTR fdigits$[rsp]
  00516	48 39 44 24 50	 cmp	 QWORD PTR i$[rsp], rax
  0051b	7d 1d		 jge	 SHORT $LN68@float_from
  0051d	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  00522	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coeff_end$[rsp]
  0052a	48 2b c8	 sub	 rcx, rax
  0052d	48 8b c1	 mov	 rax, rcx
  00530	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
  00538	eb 18		 jmp	 SHORT $LN69@float_from
$LN68@float_from:
  0053a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coeff_end$[rsp]
  00542	48 ff c8	 dec	 rax
  00545	48 2b 44 24 50	 sub	 rax, QWORD PTR i$[rsp]
  0054a	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
$LN69@float_from:
  00552	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4030000000000000
  0055a	f2 0f 59 44 24
	48		 mulsd	 xmm0, QWORD PTR x$[rsp]
  00560	f2 0f 11 84 24
	d0 00 00 00	 movsdx	 QWORD PTR tv211[rsp], xmm0
  00569	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv217[rsp]
  00571	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00574	e8 00 00 00 00	 call	 hex_from_char
  00579	66 0f 6e c0	 movd	 xmm0, eax
  0057d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00581	f2 0f 10 8c 24
	d0 00 00 00	 movsdx	 xmm1, QWORD PTR tv211[rsp]
  0058a	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0058e	66 0f 28 c1	 movapd	 xmm0, xmm1
  00592	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0
  00598	e9 5b ff ff ff	 jmp	 $LN19@float_from
$LN18@float_from:

; 1353 :         x = ldexp(x, (int)(exp));

  0059d	8b 54 24 60	 mov	 edx, DWORD PTR exp$[rsp]
  005a1	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR x$[rsp]
  005a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  005ad	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1354 :         goto finished;

  005b3	e9 80 03 00 00	 jmp	 $finished$21060
$LN21@float_from:

; 1355 :     }
; 1356 :     /* rounding required.  key_digit is the index of the hex digit
; 1357 :        containing the first bit to be rounded away. */
; 1358 :     half_eps = 1 << (int)((lsb - exp - 1) % 4);

  005b8	8b 44 24 60	 mov	 eax, DWORD PTR exp$[rsp]
  005bc	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR lsb$[rsp]
  005c3	2b c8		 sub	 ecx, eax
  005c5	8b c1		 mov	 eax, ecx
  005c7	ff c8		 dec	 eax
  005c9	99		 cdq
  005ca	83 e2 03	 and	 edx, 3
  005cd	03 c2		 add	 eax, edx
  005cf	83 e0 03	 and	 eax, 3
  005d2	2b c2		 sub	 eax, edx
  005d4	b9 01 00 00 00	 mov	 ecx, 1
  005d9	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv466[rsp], ecx
  005e0	0f b6 c8	 movzx	 ecx, al
  005e3	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv466[rsp]
  005ea	d3 e0		 shl	 eax, cl
  005ec	89 84 24 84 00
	00 00		 mov	 DWORD PTR half_eps$[rsp], eax

; 1359 :     key_digit = (lsb - exp - 1) / 4;

  005f3	8b 44 24 60	 mov	 eax, DWORD PTR exp$[rsp]
  005f7	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR lsb$[rsp]
  005fe	2b c8		 sub	 ecx, eax
  00600	8b c1		 mov	 eax, ecx
  00602	ff c8		 dec	 eax
  00604	99		 cdq
  00605	83 e2 03	 and	 edx, 3
  00608	03 c2		 add	 eax, edx
  0060a	c1 f8 02	 sar	 eax, 2
  0060d	89 84 24 a8 00
	00 00		 mov	 DWORD PTR key_digit$[rsp], eax

; 1360 :     for (i = ndigits-1; i > key_digit; i--)

  00614	48 8b 44 24 78	 mov	 rax, QWORD PTR ndigits$[rsp]
  00619	48 ff c8	 dec	 rax
  0061c	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax
  00621	eb 0d		 jmp	 SHORT $LN17@float_from
$LN16@float_from:
  00623	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  00628	48 ff c8	 dec	 rax
  0062b	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax
$LN17@float_from:
  00630	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR key_digit$[rsp]
  00638	48 39 44 24 50	 cmp	 QWORD PTR i$[rsp], rax
  0063d	0f 8e 8c 00 00
	00		 jle	 $LN15@float_from

; 1361 :         x = 16.0*x + HEX_DIGIT(i);

  00643	48 8b 44 24 28	 mov	 rax, QWORD PTR fdigits$[rsp]
  00648	48 39 44 24 50	 cmp	 QWORD PTR i$[rsp], rax
  0064d	7d 1d		 jge	 SHORT $LN70@float_from
  0064f	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  00654	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coeff_end$[rsp]
  0065c	48 2b c8	 sub	 rcx, rax
  0065f	48 8b c1	 mov	 rax, rcx
  00662	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv241[rsp], rax
  0066a	eb 18		 jmp	 SHORT $LN71@float_from
$LN70@float_from:
  0066c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coeff_end$[rsp]
  00674	48 ff c8	 dec	 rax
  00677	48 2b 44 24 50	 sub	 rax, QWORD PTR i$[rsp]
  0067c	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv241[rsp], rax
$LN71@float_from:
  00684	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4030000000000000
  0068c	f2 0f 59 44 24
	48		 mulsd	 xmm0, QWORD PTR x$[rsp]
  00692	f2 0f 11 84 24
	e8 00 00 00	 movsdx	 QWORD PTR tv235[rsp], xmm0
  0069b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv241[rsp]
  006a3	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  006a6	e8 00 00 00 00	 call	 hex_from_char
  006ab	66 0f 6e c0	 movd	 xmm0, eax
  006af	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  006b3	f2 0f 10 8c 24
	e8 00 00 00	 movsdx	 xmm1, QWORD PTR tv235[rsp]
  006bc	f2 0f 58 c8	 addsd	 xmm1, xmm0
  006c0	66 0f 28 c1	 movapd	 xmm0, xmm1
  006c4	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0
  006ca	e9 54 ff ff ff	 jmp	 $LN16@float_from
$LN15@float_from:

; 1362 :     digit = HEX_DIGIT(key_digit);

  006cf	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR key_digit$[rsp]
  006d7	48 3b 44 24 28	 cmp	 rax, QWORD PTR fdigits$[rsp]
  006dc	7d 20		 jge	 SHORT $LN72@float_from
  006de	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR key_digit$[rsp]
  006e6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coeff_end$[rsp]
  006ee	48 2b c8	 sub	 rcx, rax
  006f1	48 8b c1	 mov	 rax, rcx
  006f4	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv253[rsp], rax
  006fc	eb 1e		 jmp	 SHORT $LN73@float_from
$LN72@float_from:
  006fe	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coeff_end$[rsp]
  00706	48 ff c8	 dec	 rax
  00709	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR key_digit$[rsp]
  00711	48 2b c1	 sub	 rax, rcx
  00714	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv253[rsp], rax
$LN73@float_from:
  0071c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv253[rsp]
  00724	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00727	e8 00 00 00 00	 call	 hex_from_char
  0072c	89 44 24 30	 mov	 DWORD PTR digit$[rsp], eax

; 1363 :     x = 16.0*x + (double)(digit & (16-2*half_eps));

  00730	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4030000000000000
  00738	f2 0f 59 44 24
	48		 mulsd	 xmm0, QWORD PTR x$[rsp]
  0073e	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR half_eps$[rsp]
  00745	d1 e0		 shl	 eax, 1
  00747	b9 10 00 00 00	 mov	 ecx, 16
  0074c	2b c8		 sub	 ecx, eax
  0074e	8b c1		 mov	 eax, ecx
  00750	8b 4c 24 30	 mov	 ecx, DWORD PTR digit$[rsp]
  00754	23 c8		 and	 ecx, eax
  00756	8b c1		 mov	 eax, ecx
  00758	66 0f 6e c8	 movd	 xmm1, eax
  0075c	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00760	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00764	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1364 : 
; 1365 :     /* round-half-even: round up if bit lsb-1 is 1 and at least one of
; 1366 :        bits lsb, lsb-2, lsb-3, lsb-4, ... is 1. */
; 1367 :     if ((digit & half_eps) != 0) {

  0076a	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR half_eps$[rsp]
  00771	8b 4c 24 30	 mov	 ecx, DWORD PTR digit$[rsp]
  00775	23 c8		 and	 ecx, eax
  00777	8b c1		 mov	 eax, ecx
  00779	85 c0		 test	 eax, eax
  0077b	0f 84 95 01 00
	00		 je	 $LN14@float_from

; 1368 :         round_up = 0;

  00781	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR round_up$[rsp], 0

; 1369 :         if ((digit & (3*half_eps-1)) != 0 ||
; 1370 :             (half_eps == 8 && (HEX_DIGIT(key_digit+1) & 1) != 0))

  00789	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR half_eps$[rsp]
  00790	6b c0 03	 imul	 eax, 3
  00793	ff c8		 dec	 eax
  00795	8b 4c 24 30	 mov	 ecx, DWORD PTR digit$[rsp]
  00799	23 c8		 and	 ecx, eax
  0079b	8b c1		 mov	 eax, ecx
  0079d	85 c0		 test	 eax, eax
  0079f	75 78		 jne	 SHORT $LN12@float_from
  007a1	83 bc 24 84 00
	00 00 08	 cmp	 DWORD PTR half_eps$[rsp], 8
  007a9	75 7b		 jne	 SHORT $LN13@float_from
  007ab	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR key_digit$[rsp]
  007b2	ff c0		 inc	 eax
  007b4	48 98		 cdqe
  007b6	48 3b 44 24 28	 cmp	 rax, QWORD PTR fdigits$[rsp]
  007bb	7d 23		 jge	 SHORT $LN74@float_from
  007bd	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR key_digit$[rsp]
  007c4	ff c0		 inc	 eax
  007c6	48 98		 cdqe
  007c8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coeff_end$[rsp]
  007d0	48 2b c8	 sub	 rcx, rax
  007d3	48 8b c1	 mov	 rax, rcx
  007d6	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
  007de	eb 22		 jmp	 SHORT $LN75@float_from
$LN74@float_from:
  007e0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coeff_end$[rsp]
  007e8	48 ff c8	 dec	 rax
  007eb	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR key_digit$[rsp]
  007f2	ff c1		 inc	 ecx
  007f4	48 63 c9	 movsxd	 rcx, ecx
  007f7	48 2b c1	 sub	 rax, rcx
  007fa	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
$LN75@float_from:
  00802	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv279[rsp]
  0080a	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0080d	e8 00 00 00 00	 call	 hex_from_char
  00812	83 e0 01	 and	 eax, 1
  00815	85 c0		 test	 eax, eax
  00817	74 0d		 je	 SHORT $LN13@float_from
$LN12@float_from:

; 1371 :             round_up = 1;

  00819	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR round_up$[rsp], 1

; 1372 :         else

  00821	e9 88 00 00 00	 jmp	 $LN11@float_from
$LN13@float_from:

; 1373 :             for (i = key_digit-1; i >= 0; i--)

  00826	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR key_digit$[rsp]
  0082d	ff c8		 dec	 eax
  0082f	48 98		 cdqe
  00831	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax
  00836	eb 0d		 jmp	 SHORT $LN10@float_from
$LN9@float_from:
  00838	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  0083d	48 ff c8	 dec	 rax
  00840	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax
$LN10@float_from:
  00845	48 83 7c 24 50
	00		 cmp	 QWORD PTR i$[rsp], 0
  0084b	7c 61		 jl	 SHORT $LN8@float_from

; 1374 :                 if (HEX_DIGIT(i) != 0) {

  0084d	48 8b 44 24 28	 mov	 rax, QWORD PTR fdigits$[rsp]
  00852	48 39 44 24 50	 cmp	 QWORD PTR i$[rsp], rax
  00857	7d 1d		 jge	 SHORT $LN76@float_from
  00859	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  0085e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR coeff_end$[rsp]
  00866	48 2b c8	 sub	 rcx, rax
  00869	48 8b c1	 mov	 rax, rcx
  0086c	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv292[rsp], rax
  00874	eb 18		 jmp	 SHORT $LN77@float_from
$LN76@float_from:
  00876	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR coeff_end$[rsp]
  0087e	48 ff c8	 dec	 rax
  00881	48 2b 44 24 50	 sub	 rax, QWORD PTR i$[rsp]
  00886	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv292[rsp], rax
$LN77@float_from:
  0088e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv292[rsp]
  00896	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00899	e8 00 00 00 00	 call	 hex_from_char
  0089e	85 c0		 test	 eax, eax
  008a0	74 0a		 je	 SHORT $LN7@float_from

; 1375 :                     round_up = 1;

  008a2	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR round_up$[rsp], 1

; 1376 :                     break;

  008aa	eb 02		 jmp	 SHORT $LN8@float_from
$LN7@float_from:

; 1377 :                 }

  008ac	eb 8a		 jmp	 SHORT $LN9@float_from
$LN8@float_from:
$LN11@float_from:

; 1378 :         if (round_up) {

  008ae	83 7c 24 64 00	 cmp	 DWORD PTR round_up$[rsp], 0
  008b3	74 61		 je	 SHORT $LN6@float_from

; 1379 :             x += 2*half_eps;

  008b5	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR half_eps$[rsp]
  008bc	d1 e0		 shl	 eax, 1
  008be	66 0f 6e c0	 movd	 xmm0, eax
  008c2	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  008c6	f2 0f 10 4c 24
	48		 movsdx	 xmm1, QWORD PTR x$[rsp]
  008cc	f2 0f 58 c8	 addsd	 xmm1, xmm0
  008d0	66 0f 28 c1	 movapd	 xmm0, xmm1
  008d4	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1380 :             if (top_exp == DBL_MAX_EXP &&
; 1381 :                 x == ldexp((double)(2*half_eps), DBL_MANT_DIG))

  008da	81 bc 24 90 00
	00 00 00 04 00
	00		 cmp	 DWORD PTR top_exp$[rsp], 1024 ; 00000400H
  008e5	75 2f		 jne	 SHORT $LN5@float_from
  008e7	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR half_eps$[rsp]
  008ee	d1 e0		 shl	 eax, 1
  008f0	66 0f 6e c0	 movd	 xmm0, eax
  008f4	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  008f8	ba 35 00 00 00	 mov	 edx, 53			; 00000035H
  008fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00903	f2 0f 10 4c 24
	48		 movsdx	 xmm1, QWORD PTR x$[rsp]
  00909	66 0f 2e c8	 ucomisd xmm1, xmm0
  0090d	7a 07		 jp	 SHORT $LN5@float_from
  0090f	75 05		 jne	 SHORT $LN5@float_from

; 1382 :                 /* overflow corner case: pre-rounded value <
; 1383 :                    2**DBL_MAX_EXP; rounded=2**DBL_MAX_EXP. */
; 1384 :                 goto overflow_error;

  00911	e9 ee 00 00 00	 jmp	 $overflow_error$21098
$LN5@float_from:
$LN6@float_from:
$LN14@float_from:

; 1385 :         }
; 1386 :     }
; 1387 :     x = ldexp(x, (int)(exp+4*key_digit));

  00916	8b 44 24 60	 mov	 eax, DWORD PTR exp$[rsp]
  0091a	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR key_digit$[rsp]
  00921	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  00924	8b d0		 mov	 edx, eax
  00926	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0092c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00932	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0
$finished$21060:
$LN4@float_from:

; 1388 : 
; 1389 :   finished:
; 1390 :     /* optional trailing whitespace leading to the end of the string */
; 1391 :     while (Py_ISSPACE(*s))

  00938	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0093d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00940	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00945	0f b6 c0	 movzx	 eax, al
  00948	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0094f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00952	83 e0 08	 and	 eax, 8
  00955	85 c0		 test	 eax, eax
  00957	74 0f		 je	 SHORT $LN3@float_from

; 1392 :         s++;

  00959	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0095e	48 ff c0	 inc	 rax
  00961	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax
  00966	eb d0		 jmp	 SHORT $LN4@float_from
$LN3@float_from:

; 1393 :     if (s != s_end)

  00968	48 8b 44 24 58	 mov	 rax, QWORD PTR s_end$[rsp]
  0096d	48 39 44 24 68	 cmp	 QWORD PTR s$[rsp], rax
  00972	74 05		 je	 SHORT $LN2@float_from

; 1394 :         goto parse_error;

  00974	e9 a2 00 00 00	 jmp	 $parse_error$21077
$LN2@float_from:

; 1395 :     result_as_float = Py_BuildValue("(d)", negate ? -x : x);

  00979	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR negate$[rsp], 0
  00981	74 19		 je	 SHORT $LN78@float_from
  00983	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00989	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00991	f2 0f 11 84 24
	08 01 00 00	 movsdx	 QWORD PTR tv324[rsp], xmm0
  0099a	eb 0f		 jmp	 SHORT $LN79@float_from
$LN78@float_from:
  0099c	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR x$[rsp]
  009a2	f2 0f 11 84 24
	08 01 00 00	 movsdx	 QWORD PTR tv324[rsp], xmm0
$LN79@float_from:
  009ab	f2 0f 10 8c 24
	08 01 00 00	 movsdx	 xmm1, QWORD PTR tv324[rsp]
  009b4	66 48 0f 7e ca	 movd	 rdx, xmm1
  009b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03LAKFFLCF@?$CId?$CJ?$AA@
  009c0	e8 00 00 00 00	 call	 Py_BuildValue
  009c5	48 89 44 24 20	 mov	 QWORD PTR result_as_float$[rsp], rax

; 1396 :     if (result_as_float == NULL)

  009ca	48 83 7c 24 20
	00		 cmp	 QWORD PTR result_as_float$[rsp], 0
  009d0	75 04		 jne	 SHORT $LN1@float_from

; 1397 :         return NULL;

  009d2	33 c0		 xor	 eax, eax
  009d4	eb 71		 jmp	 SHORT $LN60@float_from
$LN1@float_from:

; 1398 :     result = PyObject_CallObject(cls, result_as_float);

  009d6	48 8b 54 24 20	 mov	 rdx, QWORD PTR result_as_float$[rsp]
  009db	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR cls$[rsp]
  009e3	e8 00 00 00 00	 call	 PyObject_CallObject
  009e8	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR result$[rsp], rax

; 1399 :     Py_DECREF(result_as_float);

  009f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result_as_float$[rsp]
  009f5	e8 00 00 00 00	 call	 _Py_DecRef

; 1400 :     return result;

  009fa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00a02	eb 43		 jmp	 SHORT $LN60@float_from
$overflow_error$21098:

; 1401 : 
; 1402 :   overflow_error:
; 1403 :     PyErr_SetString(PyExc_OverflowError,
; 1404 :                     "hexadecimal value too large to represent as a float");

  00a04	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@JIJECJKD@hexadecimal?5value?5too?5large?5to?5r@
  00a0b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00a12	e8 00 00 00 00	 call	 PyErr_SetString

; 1405 :     return NULL;

  00a17	33 c0		 xor	 eax, eax
  00a19	eb 2c		 jmp	 SHORT $LN60@float_from
$parse_error$21077:

; 1406 : 
; 1407 :   parse_error:
; 1408 :     PyErr_SetString(PyExc_ValueError,
; 1409 :                     "invalid hexadecimal floating-point string");

  00a1b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@KHPMGGCN@invalid?5hexadecimal?5floating?9poi@
  00a22	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00a29	e8 00 00 00 00	 call	 PyErr_SetString

; 1410 :     return NULL;

  00a2e	33 c0		 xor	 eax, eax
  00a30	eb 15		 jmp	 SHORT $LN60@float_from
$insane_length_error$21079:

; 1411 : 
; 1412 :   insane_length_error:
; 1413 :     PyErr_SetString(PyExc_ValueError,
; 1414 :                     "hexadecimal string too long to convert");

  00a32	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@MAGDKHAN@hexadecimal?5string?5too?5long?5to?5c@
  00a39	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00a40	e8 00 00 00 00	 call	 PyErr_SetString

; 1415 :     return NULL;

  00a45	33 c0		 xor	 eax, eax
$LN60@float_from:

; 1416 : }

  00a47	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00a4e	c3		 ret	 0
float_fromhex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$hex_from_char DD imagerel hex_from_char
	DD	imagerel hex_from_char+359
	DD	imagerel $unwind$hex_from_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hex_from_char DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hex_from_char
_TEXT	SEGMENT
x$ = 0
tv65 = 4
c$ = 32
hex_from_char PROC					; COMDAT

; 1043 : hex_from_char(char c) {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 1044 :     int x;
; 1045 :     switch(c) {

  00008	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0000d	89 44 24 04	 mov	 DWORD PTR tv65[rsp], eax
  00011	8b 44 24 04	 mov	 eax, DWORD PTR tv65[rsp]
  00015	83 e8 30	 sub	 eax, 48			; 00000030H
  00018	89 44 24 04	 mov	 DWORD PTR tv65[rsp], eax
  0001c	83 7c 24 04 36	 cmp	 DWORD PTR tv65[rsp], 54	; 00000036H
  00021	0f 87 b6 00 00
	00		 ja	 $LN1@hex_from_c
  00027	48 63 44 24 04	 movsxd	 rax, DWORD PTR tv65[rsp]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00033	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN22@hex_from_c[rcx+rax]
  0003b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN23@hex_from_c[rcx+rax*4]
  00042	48 03 c1	 add	 rax, rcx
  00045	ff e0		 jmp	 rax
$LN17@hex_from_c:

; 1046 :     case '0':
; 1047 :         x = 0;

  00047	c7 04 24 00 00
	00 00		 mov	 DWORD PTR x$[rsp], 0

; 1048 :         break;

  0004e	e9 91 00 00 00	 jmp	 $LN18@hex_from_c
$LN16@hex_from_c:

; 1049 :     case '1':
; 1050 :         x = 1;

  00053	c7 04 24 01 00
	00 00		 mov	 DWORD PTR x$[rsp], 1

; 1051 :         break;

  0005a	e9 85 00 00 00	 jmp	 $LN18@hex_from_c
$LN15@hex_from_c:

; 1052 :     case '2':
; 1053 :         x = 2;

  0005f	c7 04 24 02 00
	00 00		 mov	 DWORD PTR x$[rsp], 2

; 1054 :         break;

  00066	eb 7c		 jmp	 SHORT $LN18@hex_from_c
$LN14@hex_from_c:

; 1055 :     case '3':
; 1056 :         x = 3;

  00068	c7 04 24 03 00
	00 00		 mov	 DWORD PTR x$[rsp], 3

; 1057 :         break;

  0006f	eb 73		 jmp	 SHORT $LN18@hex_from_c
$LN13@hex_from_c:

; 1058 :     case '4':
; 1059 :         x = 4;

  00071	c7 04 24 04 00
	00 00		 mov	 DWORD PTR x$[rsp], 4

; 1060 :         break;

  00078	eb 6a		 jmp	 SHORT $LN18@hex_from_c
$LN12@hex_from_c:

; 1061 :     case '5':
; 1062 :         x = 5;

  0007a	c7 04 24 05 00
	00 00		 mov	 DWORD PTR x$[rsp], 5

; 1063 :         break;

  00081	eb 61		 jmp	 SHORT $LN18@hex_from_c
$LN11@hex_from_c:

; 1064 :     case '6':
; 1065 :         x = 6;

  00083	c7 04 24 06 00
	00 00		 mov	 DWORD PTR x$[rsp], 6

; 1066 :         break;

  0008a	eb 58		 jmp	 SHORT $LN18@hex_from_c
$LN10@hex_from_c:

; 1067 :     case '7':
; 1068 :         x = 7;

  0008c	c7 04 24 07 00
	00 00		 mov	 DWORD PTR x$[rsp], 7

; 1069 :         break;

  00093	eb 4f		 jmp	 SHORT $LN18@hex_from_c
$LN9@hex_from_c:

; 1070 :     case '8':
; 1071 :         x = 8;

  00095	c7 04 24 08 00
	00 00		 mov	 DWORD PTR x$[rsp], 8

; 1072 :         break;

  0009c	eb 46		 jmp	 SHORT $LN18@hex_from_c
$LN8@hex_from_c:

; 1073 :     case '9':
; 1074 :         x = 9;

  0009e	c7 04 24 09 00
	00 00		 mov	 DWORD PTR x$[rsp], 9

; 1075 :         break;

  000a5	eb 3d		 jmp	 SHORT $LN18@hex_from_c
$LN7@hex_from_c:

; 1076 :     case 'a':
; 1077 :     case 'A':
; 1078 :         x = 10;

  000a7	c7 04 24 0a 00
	00 00		 mov	 DWORD PTR x$[rsp], 10

; 1079 :         break;

  000ae	eb 34		 jmp	 SHORT $LN18@hex_from_c
$LN6@hex_from_c:

; 1080 :     case 'b':
; 1081 :     case 'B':
; 1082 :         x = 11;

  000b0	c7 04 24 0b 00
	00 00		 mov	 DWORD PTR x$[rsp], 11

; 1083 :         break;

  000b7	eb 2b		 jmp	 SHORT $LN18@hex_from_c
$LN5@hex_from_c:

; 1084 :     case 'c':
; 1085 :     case 'C':
; 1086 :         x = 12;

  000b9	c7 04 24 0c 00
	00 00		 mov	 DWORD PTR x$[rsp], 12

; 1087 :         break;

  000c0	eb 22		 jmp	 SHORT $LN18@hex_from_c
$LN4@hex_from_c:

; 1088 :     case 'd':
; 1089 :     case 'D':
; 1090 :         x = 13;

  000c2	c7 04 24 0d 00
	00 00		 mov	 DWORD PTR x$[rsp], 13

; 1091 :         break;

  000c9	eb 19		 jmp	 SHORT $LN18@hex_from_c
$LN3@hex_from_c:

; 1092 :     case 'e':
; 1093 :     case 'E':
; 1094 :         x = 14;

  000cb	c7 04 24 0e 00
	00 00		 mov	 DWORD PTR x$[rsp], 14

; 1095 :         break;

  000d2	eb 10		 jmp	 SHORT $LN18@hex_from_c
$LN2@hex_from_c:

; 1096 :     case 'f':
; 1097 :     case 'F':
; 1098 :         x = 15;

  000d4	c7 04 24 0f 00
	00 00		 mov	 DWORD PTR x$[rsp], 15

; 1099 :         break;

  000db	eb 07		 jmp	 SHORT $LN18@hex_from_c
$LN1@hex_from_c:

; 1100 :     default:
; 1101 :         x = -1;

  000dd	c7 04 24 ff ff
	ff ff		 mov	 DWORD PTR x$[rsp], -1
$LN18@hex_from_c:

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;

  000e4	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]

; 1105 : }

  000e7	48 83 c4 18	 add	 rsp, 24
  000eb	c3		 ret	 0
$LN23@hex_from_c:
  000ec	00 00 00 00	 DD	 $LN17@hex_from_c
  000f0	00 00 00 00	 DD	 $LN16@hex_from_c
  000f4	00 00 00 00	 DD	 $LN15@hex_from_c
  000f8	00 00 00 00	 DD	 $LN14@hex_from_c
  000fc	00 00 00 00	 DD	 $LN13@hex_from_c
  00100	00 00 00 00	 DD	 $LN12@hex_from_c
  00104	00 00 00 00	 DD	 $LN11@hex_from_c
  00108	00 00 00 00	 DD	 $LN10@hex_from_c
  0010c	00 00 00 00	 DD	 $LN9@hex_from_c
  00110	00 00 00 00	 DD	 $LN8@hex_from_c
  00114	00 00 00 00	 DD	 $LN7@hex_from_c
  00118	00 00 00 00	 DD	 $LN6@hex_from_c
  0011c	00 00 00 00	 DD	 $LN5@hex_from_c
  00120	00 00 00 00	 DD	 $LN4@hex_from_c
  00124	00 00 00 00	 DD	 $LN3@hex_from_c
  00128	00 00 00 00	 DD	 $LN2@hex_from_c
  0012c	00 00 00 00	 DD	 $LN1@hex_from_c
$LN22@hex_from_c:
  00130	00		 DB	 0
  00131	01		 DB	 1
  00132	02		 DB	 2
  00133	03		 DB	 3
  00134	04		 DB	 4
  00135	05		 DB	 5
  00136	06		 DB	 6
  00137	07		 DB	 7
  00138	08		 DB	 8
  00139	09		 DB	 9
  0013a	10		 DB	 16
  0013b	10		 DB	 16
  0013c	10		 DB	 16
  0013d	10		 DB	 16
  0013e	10		 DB	 16
  0013f	10		 DB	 16
  00140	10		 DB	 16
  00141	0a		 DB	 10
  00142	0b		 DB	 11
  00143	0c		 DB	 12
  00144	0d		 DB	 13
  00145	0e		 DB	 14
  00146	0f		 DB	 15
  00147	10		 DB	 16
  00148	10		 DB	 16
  00149	10		 DB	 16
  0014a	10		 DB	 16
  0014b	10		 DB	 16
  0014c	10		 DB	 16
  0014d	10		 DB	 16
  0014e	10		 DB	 16
  0014f	10		 DB	 16
  00150	10		 DB	 16
  00151	10		 DB	 16
  00152	10		 DB	 16
  00153	10		 DB	 16
  00154	10		 DB	 16
  00155	10		 DB	 16
  00156	10		 DB	 16
  00157	10		 DB	 16
  00158	10		 DB	 16
  00159	10		 DB	 16
  0015a	10		 DB	 16
  0015b	10		 DB	 16
  0015c	10		 DB	 16
  0015d	10		 DB	 16
  0015e	10		 DB	 16
  0015f	10		 DB	 16
  00160	10		 DB	 16
  00161	0a		 DB	 10
  00162	0b		 DB	 11
  00163	0c		 DB	 12
  00164	0d		 DB	 13
  00165	0e		 DB	 14
  00166	0f		 DB	 15
hex_from_char ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@CODLHJPJ@Cannot?5pass?5NaN?5to?5float?4as_inte@ ; `string'
PUBLIC	??_C@_0DA@BPJCIOGG@Cannot?5pass?5infinity?5to?5float?4as@ ; `string'
EXTRN	PyTuple_Pack:PROC
EXTRN	labs:PROC
EXTRN	PyLong_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_as_integer_ratio DD imagerel float_as_integer_ratio
	DD	imagerel float_as_integer_ratio+707
	DD	imagerel $unwind$float_as_integer_ratio
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_as_integer_ratio DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0CL@CODLHJPJ@Cannot?5pass?5NaN?5to?5float?4as_inte@
CONST	SEGMENT
??_C@_0CL@CODLHJPJ@Cannot?5pass?5NaN?5to?5float?4as_inte@ DB 'Cannot pass'
	DB	' NaN to float.as_integer_ratio.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BPJCIOGG@Cannot?5pass?5infinity?5to?5float?4as@
CONST	SEGMENT
??_C@_0DA@BPJCIOGG@Cannot?5pass?5infinity?5to?5float?4as@ DB 'Cannot pass'
	DB	' infinity to float.as_integer_ratio.', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_as_integer_ratio
_TEXT	SEGMENT
float_part$ = 32
result_pair$ = 40
py_exponent$ = 48
long_methods$ = 56
numerator$ = 64
i$ = 72
prev$ = 80
denominator$ = 88
exponent$ = 96
self$ = 104
v$ = 128
unused$ = 136
float_as_integer_ratio PROC				; COMDAT

; 1430 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1431 :     double self;
; 1432 :     double float_part;
; 1433 :     int exponent;
; 1434 :     int i;
; 1435 : 
; 1436 :     PyObject *prev;
; 1437 :     PyObject *py_exponent = NULL;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR py_exponent$[rsp], 0

; 1438 :     PyObject *numerator = NULL;

  00017	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR numerator$[rsp], 0

; 1439 :     PyObject *denominator = NULL;

  00020	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR denominator$[rsp], 0

; 1440 :     PyObject *result_pair = NULL;

  00029	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR result_pair$[rsp], 0

; 1441 :     PyNumberMethods *long_methods = PyLong_Type.tp_as_number;

  00032	48 8b 05 b8 00
	00 00		 mov	 rax, QWORD PTR PyLong_Type+184
  00039	48 89 44 24 38	 mov	 QWORD PTR long_methods$[rsp], rax

; 1442 : 
; 1443 : #define INPLACE_UPDATE(obj, call) \
; 1444 :     prev = obj; \
; 1445 :     obj = call; \
; 1446 :     Py_DECREF(prev); \
; 1447 : 
; 1448 :     CONVERT_TO_DOUBLE(v, self);

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00045	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0004d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00051	74 1c		 je	 SHORT $LN26@float_as_i
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0005a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00062	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00066	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006b	85 c0		 test	 eax, eax
  0006d	74 15		 je	 SHORT $LN27@float_as_i
$LN26@float_as_i:
  0006f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00077	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  0007c	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR self$[rsp], xmm0
  00082	eb 23		 jmp	 SHORT $LN25@float_as_i
$LN27@float_as_i:
  00084	48 8d 54 24 68	 lea	 rdx, QWORD PTR self$[rsp]
  00089	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR v$[rsp]
  00091	e8 00 00 00 00	 call	 convert_to_double
  00096	85 c0		 test	 eax, eax
  00098	7d 0d		 jge	 SHORT $LN24@float_as_i
  0009a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  000a2	e9 17 02 00 00	 jmp	 $LN28@float_as_i
$LN24@float_as_i:
$LN25@float_as_i:

; 1449 : 
; 1450 :     if (Py_IS_INFINITY(self)) {

  000a7	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR self$[rsp]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000b3	85 c0		 test	 eax, eax
  000b5	75 2a		 jne	 SHORT $LN23@float_as_i
  000b7	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR self$[rsp]
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000c3	85 c0		 test	 eax, eax
  000c5	75 1a		 jne	 SHORT $LN23@float_as_i

; 1451 :       PyErr_SetString(PyExc_OverflowError,
; 1452 :                       "Cannot pass infinity to float.as_integer_ratio.");

  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@BPJCIOGG@Cannot?5pass?5infinity?5to?5float?4as@
  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000d5	e8 00 00 00 00	 call	 PyErr_SetString

; 1453 :       return NULL;

  000da	33 c0		 xor	 eax, eax
  000dc	e9 dd 01 00 00	 jmp	 $LN28@float_as_i
$LN23@float_as_i:

; 1454 :     }
; 1455 :     if (Py_IS_NAN(self)) {

  000e1	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR self$[rsp]
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000ed	85 c0		 test	 eax, eax
  000ef	74 1a		 je	 SHORT $LN22@float_as_i

; 1456 :       PyErr_SetString(PyExc_ValueError,
; 1457 :                       "Cannot pass NaN to float.as_integer_ratio.");

  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@CODLHJPJ@Cannot?5pass?5NaN?5to?5float?4as_inte@
  000f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ff	e8 00 00 00 00	 call	 PyErr_SetString

; 1458 :       return NULL;

  00104	33 c0		 xor	 eax, eax
  00106	e9 b3 01 00 00	 jmp	 $LN28@float_as_i
$LN22@float_as_i:

; 1459 :     }
; 1460 : 
; 1461 :     PyFPE_START_PROTECT("as_integer_ratio", goto error);
; 1462 :     float_part = frexp(self, &exponent);        /* self == float_part * 2**exponent exactly */

  0010b	48 8d 54 24 60	 lea	 rdx, QWORD PTR exponent$[rsp]
  00110	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR self$[rsp]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp
  0011c	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR float_part$[rsp], xmm0

; 1463 :     PyFPE_END_PROTECT(float_part);
; 1464 : 
; 1465 :     for (i=0; i<300 && float_part != floor(float_part) ; i++) {

  00122	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0012a	eb 0a		 jmp	 SHORT $LN21@float_as_i
$LN20@float_as_i:
  0012c	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00130	ff c0		 inc	 eax
  00132	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN21@float_as_i:
  00136	81 7c 24 48 2c
	01 00 00	 cmp	 DWORD PTR i$[rsp], 300	; 0000012cH
  0013e	7d 3a		 jge	 SHORT $LN19@float_as_i
  00140	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR float_part$[rsp]
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  0014c	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR float_part$[rsp]
  00152	66 0f 2e c8	 ucomisd xmm1, xmm0
  00156	7a 02		 jp	 SHORT $LN30@float_as_i
  00158	74 20		 je	 SHORT $LN19@float_as_i
$LN30@float_as_i:

; 1466 :         float_part *= 2.0;

  0015a	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR float_part$[rsp]
  00160	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
  00168	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR float_part$[rsp], xmm0

; 1467 :         exponent--;

  0016e	8b 44 24 60	 mov	 eax, DWORD PTR exponent$[rsp]
  00172	ff c8		 dec	 eax
  00174	89 44 24 60	 mov	 DWORD PTR exponent$[rsp], eax

; 1468 :     }

  00178	eb b2		 jmp	 SHORT $LN20@float_as_i
$LN19@float_as_i:

; 1469 :     /* self == float_part * 2**exponent exactly and float_part is integral.
; 1470 :        If FLT_RADIX != 2, the 300 steps may leave a tiny fractional part
; 1471 :        to be truncated by PyLong_FromDouble(). */
; 1472 : 
; 1473 :     numerator = PyLong_FromDouble(float_part);

  0017a	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR float_part$[rsp]
  00180	e8 00 00 00 00	 call	 PyLong_FromDouble
  00185	48 89 44 24 40	 mov	 QWORD PTR numerator$[rsp], rax

; 1474 :     if (numerator == NULL) goto error;

  0018a	48 83 7c 24 40
	00		 cmp	 QWORD PTR numerator$[rsp], 0
  00190	75 05		 jne	 SHORT $LN18@float_as_i
  00192	e9 da 00 00 00	 jmp	 $error$21186
$LN18@float_as_i:

; 1475 : 
; 1476 :     /* fold in 2**exponent */
; 1477 :     denominator = PyLong_FromLong(1);

  00197	b9 01 00 00 00	 mov	 ecx, 1
  0019c	e8 00 00 00 00	 call	 PyLong_FromLong
  001a1	48 89 44 24 58	 mov	 QWORD PTR denominator$[rsp], rax

; 1478 :     py_exponent = PyLong_FromLong(labs((long)exponent));

  001a6	8b 4c 24 60	 mov	 ecx, DWORD PTR exponent$[rsp]
  001aa	e8 00 00 00 00	 call	 labs
  001af	8b c8		 mov	 ecx, eax
  001b1	e8 00 00 00 00	 call	 PyLong_FromLong
  001b6	48 89 44 24 30	 mov	 QWORD PTR py_exponent$[rsp], rax

; 1479 :     if (py_exponent == NULL) goto error;

  001bb	48 83 7c 24 30
	00		 cmp	 QWORD PTR py_exponent$[rsp], 0
  001c1	75 05		 jne	 SHORT $LN17@float_as_i
  001c3	e9 a9 00 00 00	 jmp	 $error$21186
$LN17@float_as_i:

; 1480 :     INPLACE_UPDATE(py_exponent,
; 1481 :                    long_methods->nb_lshift(denominator, py_exponent));

  001c8	48 8b 44 24 30	 mov	 rax, QWORD PTR py_exponent$[rsp]
  001cd	48 89 44 24 50	 mov	 QWORD PTR prev$[rsp], rax
  001d2	48 8b 54 24 30	 mov	 rdx, QWORD PTR py_exponent$[rsp]
  001d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR denominator$[rsp]
  001dc	48 8b 44 24 38	 mov	 rax, QWORD PTR long_methods$[rsp]
  001e1	ff 50 58	 call	 QWORD PTR [rax+88]
  001e4	48 89 44 24 30	 mov	 QWORD PTR py_exponent$[rsp], rax
  001e9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prev$[rsp]
  001ee	e8 00 00 00 00	 call	 _Py_DecRef

; 1482 :     if (py_exponent == NULL) goto error;

  001f3	48 83 7c 24 30
	00		 cmp	 QWORD PTR py_exponent$[rsp], 0
  001f9	75 02		 jne	 SHORT $LN16@float_as_i
  001fb	eb 74		 jmp	 SHORT $error$21186
$LN16@float_as_i:

; 1483 :     if (exponent > 0) {

  001fd	83 7c 24 60 00	 cmp	 DWORD PTR exponent$[rsp], 0
  00202	7e 37		 jle	 SHORT $LN15@float_as_i

; 1484 :         INPLACE_UPDATE(numerator,
; 1485 :                        long_methods->nb_multiply(numerator, py_exponent));

  00204	48 8b 44 24 40	 mov	 rax, QWORD PTR numerator$[rsp]
  00209	48 89 44 24 50	 mov	 QWORD PTR prev$[rsp], rax
  0020e	48 8b 54 24 30	 mov	 rdx, QWORD PTR py_exponent$[rsp]
  00213	48 8b 4c 24 40	 mov	 rcx, QWORD PTR numerator$[rsp]
  00218	48 8b 44 24 38	 mov	 rax, QWORD PTR long_methods$[rsp]
  0021d	ff 50 10	 call	 QWORD PTR [rax+16]
  00220	48 89 44 24 40	 mov	 QWORD PTR numerator$[rsp], rax
  00225	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prev$[rsp]
  0022a	e8 00 00 00 00	 call	 _Py_DecRef

; 1486 :         if (numerator == NULL) goto error;

  0022f	48 83 7c 24 40
	00		 cmp	 QWORD PTR numerator$[rsp], 0
  00235	75 02		 jne	 SHORT $LN14@float_as_i
  00237	eb 38		 jmp	 SHORT $error$21186
$LN14@float_as_i:

; 1487 :     }
; 1488 :     else {

  00239	eb 1d		 jmp	 SHORT $LN13@float_as_i
$LN15@float_as_i:

; 1489 :         Py_DECREF(denominator);

  0023b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR denominator$[rsp]
  00240	e8 00 00 00 00	 call	 _Py_DecRef

; 1490 :         denominator = py_exponent;

  00245	48 8b 44 24 30	 mov	 rax, QWORD PTR py_exponent$[rsp]
  0024a	48 89 44 24 58	 mov	 QWORD PTR denominator$[rsp], rax

; 1491 :         py_exponent = NULL;

  0024f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR py_exponent$[rsp], 0
$LN13@float_as_i:

; 1492 :     }
; 1493 : 
; 1494 :     result_pair = PyTuple_Pack(2, numerator, denominator);

  00258	4c 8b 44 24 58	 mov	 r8, QWORD PTR denominator$[rsp]
  0025d	48 8b 54 24 40	 mov	 rdx, QWORD PTR numerator$[rsp]
  00262	b9 02 00 00 00	 mov	 ecx, 2
  00267	e8 00 00 00 00	 call	 PyTuple_Pack
  0026c	48 89 44 24 28	 mov	 QWORD PTR result_pair$[rsp], rax
$error$21186:
$LN12@float_as_i:

; 1495 : 
; 1496 : #undef INPLACE_UPDATE
; 1497 : error:
; 1498 :     Py_XDECREF(py_exponent);

  00271	48 83 7c 24 30
	00		 cmp	 QWORD PTR py_exponent$[rsp], 0
  00277	74 0a		 je	 SHORT $LN9@float_as_i
  00279	48 8b 4c 24 30	 mov	 rcx, QWORD PTR py_exponent$[rsp]
  0027e	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@float_as_i:
  00283	33 c0		 xor	 eax, eax
  00285	85 c0		 test	 eax, eax
  00287	75 e8		 jne	 SHORT $LN12@float_as_i
$LN8@float_as_i:

; 1499 :     Py_XDECREF(denominator);

  00289	48 83 7c 24 58
	00		 cmp	 QWORD PTR denominator$[rsp], 0
  0028f	74 0a		 je	 SHORT $LN5@float_as_i
  00291	48 8b 4c 24 58	 mov	 rcx, QWORD PTR denominator$[rsp]
  00296	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@float_as_i:
  0029b	33 c0		 xor	 eax, eax
  0029d	85 c0		 test	 eax, eax
  0029f	75 e8		 jne	 SHORT $LN8@float_as_i
$LN4@float_as_i:

; 1500 :     Py_XDECREF(numerator);

  002a1	48 83 7c 24 40
	00		 cmp	 QWORD PTR numerator$[rsp], 0
  002a7	74 0a		 je	 SHORT $LN1@float_as_i
  002a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR numerator$[rsp]
  002ae	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@float_as_i:
  002b3	33 c0		 xor	 eax, eax
  002b5	85 c0		 test	 eax, eax
  002b7	75 e8		 jne	 SHORT $LN4@float_as_i

; 1501 :     return result_pair;

  002b9	48 8b 44 24 28	 mov	 rax, QWORD PTR result_pair$[rsp]
$LN28@float_as_i:

; 1502 : }

  002be	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002c2	c3		 ret	 0
float_as_integer_ratio ENDP
_TEXT	ENDS
PUBLIC	??_C@_08BAKDHNHG@?$HMO?3float?$AA@		; `string'
EXTRN	PyNumber_Float:PROC
EXTRN	PyUnicode_Type:BYTE
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_new DD imagerel float_new
	DD	imagerel float_new+159
	DD	imagerel $unwind$float_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_new DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_08BAKDHNHG@?$HMO?3float?$AA@
CONST	SEGMENT
??_C@_08BAKDHNHG@?$HMO?3float?$AA@ DB '|O:float', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_new
_TEXT	SEGMENT
x$ = 48
type$ = 80
args$ = 88
kwds$ = 96
float_new PROC						; COMDAT

; 1524 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1525 :     PyObject *x = Py_False; /* Integer zero */

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0001a	48 89 44 24 30	 mov	 QWORD PTR x$[rsp], rax

; 1526 :     static char *kwlist[] = {"x", 0};
; 1527 : 
; 1528 :     if (type != &PyFloat_Type)

  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00026	48 39 44 24 50	 cmp	 QWORD PTR type$[rsp], rax
  0002b	74 16		 je	 SHORT $LN3@float_new

; 1529 :         return float_subtype_new(type, args, kwds); /* Wimp out */

  0002d	4c 8b 44 24 60	 mov	 r8, QWORD PTR kwds$[rsp]
  00032	48 8b 54 24 58	 mov	 rdx, QWORD PTR args$[rsp]
  00037	48 8b 4c 24 50	 mov	 rcx, QWORD PTR type$[rsp]
  0003c	e8 00 00 00 00	 call	 float_subtype_new
  00041	eb 57		 jmp	 SHORT $LN4@float_new
$LN3@float_new:

; 1530 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O:float", kwlist, &x))

  00043	48 8d 44 24 30	 lea	 rax, QWORD PTR x$[rsp]
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??float_new@@9@9
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08BAKDHNHG@?$HMO?3float?$AA@
  0005b	48 8b 54 24 60	 mov	 rdx, QWORD PTR kwds$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00065	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0006a	85 c0		 test	 eax, eax
  0006c	75 04		 jne	 SHORT $LN2@float_new

; 1531 :         return NULL;

  0006e	33 c0		 xor	 eax, eax
  00070	eb 28		 jmp	 SHORT $LN4@float_new
$LN2@float_new:

; 1532 :     /* If it's a string, but not a string subclass, use
; 1533 :        PyFloat_FromString. */
; 1534 :     if (PyUnicode_CheckExact(x))

  00072	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00079	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  0007e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00082	75 0c		 jne	 SHORT $LN1@float_new

; 1535 :         return PyFloat_FromString(x);

  00084	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  00089	e8 00 00 00 00	 call	 PyFloat_FromString
  0008e	eb 0a		 jmp	 SHORT $LN4@float_new
$LN1@float_new:

; 1536 :     return PyNumber_Float(x);

  00090	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  00095	e8 00 00 00 00	 call	 PyNumber_Float
$LN4@float_new:

; 1537 : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
float_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DA@BIEJFKPA@?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EM@PKNKPHMK@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_subtype_new DD imagerel float_subtype_new
	DD	imagerel float_subtype_new+238
	DD	imagerel $unwind$float_subtype_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_subtype_new DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1DA@BIEJFKPA@?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@BIEJFKPA@?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'F', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 't', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'E'
	DB	00H, 'x', 00H, 'a', 00H, 'c', 00H, 't', 00H, '(', 00H, 't', 00H
	DB	'm', 00H, 'p', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@PKNKPHMK@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_@
CONST	SEGMENT
??_C@_1EM@PKNKPHMK@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_@ DB 'P'
	DB	00H, 'y', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H
	DB	'I', 00H, 's', 00H, 'S', 00H, 'u', 00H, 'b', 00H, 't', 00H, 'y'
	DB	00H, 'p', 00H, 'e', 00H, '(', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, ',', 00H, ' ', 00H, '&', 00H, 'P', 00H, 'y', 00H, 'F'
	DB	00H, 'l', 00H, 'o', 00H, 'a', 00H, 't', 00H, '_', 00H, 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_subtype_new
_TEXT	SEGMENT
tmp$ = 32
newobj$ = 40
type$ = 64
args$ = 72
kwds$ = 80
float_subtype_new PROC					; COMDAT

; 1546 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1547 :     PyObject *tmp, *newobj;
; 1548 : 
; 1549 :     assert(PyType_IsSubtype(type, &PyFloat_Type));

  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0001a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  0001f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00024	85 c0		 test	 eax, eax
  00026	75 1c		 jne	 SHORT $LN5@float_subt
  00028	41 b8 0d 06 00
	00		 mov	 r8d, 1549		; 0000060dH
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@PKNKPHMK@?$AAP?$AAy?$AAT?$AAy?$AAp?$AAe?$AA_?$AAI?$AAs?$AAS?$AAu?$AAb?$AAt?$AAy?$AAp?$AAe?$AA?$CI?$AAt?$AAy?$AAp?$AAe?$AA?0?$AA?5?$AA?$CG?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00042	33 c0		 xor	 eax, eax
$LN5@float_subt:

; 1550 :     tmp = float_new(&PyFloat_Type, args, kwds);

  00044	4c 8b 44 24 50	 mov	 r8, QWORD PTR kwds$[rsp]
  00049	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFloat_Type
  00055	e8 00 00 00 00	 call	 float_new
  0005a	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 1551 :     if (tmp == NULL)

  0005f	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00065	75 04		 jne	 SHORT $LN2@float_subt

; 1552 :         return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	eb 7e		 jmp	 SHORT $LN3@float_subt
$LN2@float_subt:

; 1553 :     assert(PyFloat_CheckExact(tmp));

  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  00077	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0007b	74 1c		 je	 SHORT $LN6@float_subt
  0007d	41 b8 11 06 00
	00		 mov	 r8d, 1553		; 00000611H
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@BIEJFKPA@?$AAP?$AAy?$AAF?$AAl?$AAo?$AAa?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00097	33 c0		 xor	 eax, eax
$LN6@float_subt:

; 1554 :     newobj = type->tp_alloc(type, 0);

  00099	33 d2		 xor	 edx, edx
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  000a5	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000ab	48 89 44 24 28	 mov	 QWORD PTR newobj$[rsp], rax

; 1555 :     if (newobj == NULL) {

  000b0	48 83 7c 24 28
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  000b6	75 0e		 jne	 SHORT $LN1@float_subt

; 1556 :         Py_DECREF(tmp);

  000b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  000bd	e8 00 00 00 00	 call	 _Py_DecRef

; 1557 :         return NULL;

  000c2	33 c0		 xor	 eax, eax
  000c4	eb 23		 jmp	 SHORT $LN3@float_subt
$LN1@float_subt:

; 1558 :     }
; 1559 :     ((PyFloatObject *)newobj)->ob_fval = ((PyFloatObject *)tmp)->ob_fval;

  000c6	48 8b 44 24 28	 mov	 rax, QWORD PTR newobj$[rsp]
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  000d0	f2 0f 10 41 60	 movsdx	 xmm0, QWORD PTR [rcx+96]
  000d5	f2 0f 11 40 60	 movsdx	 QWORD PTR [rax+96], xmm0

; 1560 :     Py_DECREF(tmp);

  000da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  000df	e8 00 00 00 00	 call	 _Py_DecRef

; 1561 :     return newobj;

  000e4	48 8b 44 24 28	 mov	 rax, QWORD PTR newobj$[rsp]
$LN3@float_subt:

; 1562 : }

  000e9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ed	c3		 ret	 0
float_subtype_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_getnewargs DD imagerel float_getnewargs
	DD	imagerel float_getnewargs+41
	DD	imagerel $unwind$float_getnewargs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_getnewargs DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_getnewargs
_TEXT	SEGMENT
v$ = 48
float_getnewargs PROC					; COMDAT

; 1566 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1567 :     return Py_BuildValue("(d)", v->ob_fval);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR v$[rsp]
  0000e	f2 0f 10 48 60	 movsdx	 xmm1, QWORD PTR [rax+96]
  00013	66 48 0f 7e ca	 movd	 rdx, xmm1
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03LAKFFLCF@?$CId?$CJ?$AA@
  0001f	e8 00 00 00 00	 call	 Py_BuildValue

; 1568 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
float_getnewargs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@FLPIAOEG@insane?5float_format?5or?5double_fo@ ; `string'
PUBLIC	??_C@_0BB@FPOIKJOA@IEEE?0?5big?9endian?$AA@	; `string'
PUBLIC	??_C@_0BE@LIJMHFO@IEEE?0?5little?9endian?$AA@	; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown?$AA@			; `string'
PUBLIC	??_C@_0DH@KIONBECL@__getformat__?$CI?$CJ?5argument?51?5must?5@ ; `string'
PUBLIC	??_C@_06BNJCAIGJ@double?$AA@			; `string'
PUBLIC	??_C@_0DE@CBKIPEFG@__getformat__?$CI?$CJ?5argument?5must?5be@ ; `string'
EXTRN	Py_FatalError:PROC
EXTRN	strcmp:PROC
EXTRN	PyUnicode_AsUTF8:PROC
_BSS	SEGMENT
float_format DD	01H DUP (?)
double_format DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_getformat DD imagerel float_getformat
	DD	imagerel float_getformat+288
	DD	imagerel $unwind$float_getformat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_getformat DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CF@FLPIAOEG@insane?5float_format?5or?5double_fo@
CONST	SEGMENT
??_C@_0CF@FLPIAOEG@insane?5float_format?5or?5double_fo@ DB 'insane float_'
	DB	'format or double_format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FPOIKJOA@IEEE?0?5big?9endian?$AA@
CONST	SEGMENT
??_C@_0BB@FPOIKJOA@IEEE?0?5big?9endian?$AA@ DB 'IEEE, big-endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LIJMHFO@IEEE?0?5little?9endian?$AA@
CONST	SEGMENT
??_C@_0BE@LIJMHFO@IEEE?0?5little?9endian?$AA@ DB 'IEEE, little-endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown?$AA@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown?$AA@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KIONBECL@__getformat__?$CI?$CJ?5argument?51?5must?5@
CONST	SEGMENT
??_C@_0DH@KIONBECL@__getformat__?$CI?$CJ?5argument?51?5must?5@ DB '__getf'
	DB	'ormat__() argument 1 must be ''double'' or ''float''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNJCAIGJ@double?$AA@
CONST	SEGMENT
??_C@_06BNJCAIGJ@double?$AA@ DB 'double', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CBKIPEFG@__getformat__?$CI?$CJ?5argument?5must?5be@
CONST	SEGMENT
??_C@_0DE@CBKIPEFG@__getformat__?$CI?$CJ?5argument?5must?5be@ DB '__getfo'
	DB	'rmat__() argument must be string, not %.500s', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_getformat
_TEXT	SEGMENT
s$ = 32
r$ = 40
tv86 = 44
v$ = 64
arg$ = 72
float_getformat PROC					; COMDAT

; 1581 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1582 :     char* s;
; 1583 :     float_format_type r;
; 1584 : 
; 1585 :     if (!PyUnicode_Check(arg)) {

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00022	85 c0		 test	 eax, eax
  00024	75 27		 jne	 SHORT $LN12@float_getf

; 1586 :         PyErr_Format(PyExc_TypeError,
; 1587 :          "__getformat__() argument must be string, not %.500s",
; 1588 :                          Py_TYPE(arg)->tp_name);

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR arg$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@CBKIPEFG@__getformat__?$CI?$CJ?5argument?5must?5be@
  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00041	e8 00 00 00 00	 call	 PyErr_Format

; 1589 :         return NULL;

  00046	33 c0		 xor	 eax, eax
  00048	e9 ce 00 00 00	 jmp	 $LN13@float_getf
$LN12@float_getf:

; 1590 :     }
; 1591 :     s = _PyUnicode_AsString(arg);

  0004d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00052	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00057	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 1592 :     if (s == NULL)

  0005c	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00062	75 07		 jne	 SHORT $LN11@float_getf

; 1593 :         return NULL;

  00064	33 c0		 xor	 eax, eax
  00066	e9 b0 00 00 00	 jmp	 $LN13@float_getf
$LN11@float_getf:

; 1594 :     if (strcmp(s, "double") == 0) {

  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06BNJCAIGJ@double?$AA@
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00077	e8 00 00 00 00	 call	 strcmp
  0007c	85 c0		 test	 eax, eax
  0007e	75 0c		 jne	 SHORT $LN10@float_getf

; 1595 :         r = double_format;

  00080	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR double_format
  00086	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax
  0008a	eb 38		 jmp	 SHORT $LN9@float_getf
$LN10@float_getf:

; 1596 :     }
; 1597 :     else if (strcmp(s, "float") == 0) {

  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KNFBNCOH@float?$AA@
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00098	e8 00 00 00 00	 call	 strcmp
  0009d	85 c0		 test	 eax, eax
  0009f	75 0c		 jne	 SHORT $LN8@float_getf

; 1598 :         r = float_format;

  000a1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR float_format
  000a7	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 1599 :     }
; 1600 :     else {

  000ab	eb 17		 jmp	 SHORT $LN7@float_getf
$LN8@float_getf:

; 1601 :         PyErr_SetString(PyExc_ValueError,
; 1602 :                         "__getformat__() argument 1 must be "
; 1603 :                         "'double' or 'float'");

  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@KIONBECL@__getformat__?$CI?$CJ?5argument?51?5must?5@
  000b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000bb	e8 00 00 00 00	 call	 PyErr_SetString

; 1604 :         return NULL;

  000c0	33 c0		 xor	 eax, eax
  000c2	eb 57		 jmp	 SHORT $LN13@float_getf
$LN7@float_getf:
$LN9@float_getf:

; 1605 :     }
; 1606 : 
; 1607 :     switch (r) {

  000c4	8b 44 24 28	 mov	 eax, DWORD PTR r$[rsp]
  000c8	89 44 24 2c	 mov	 DWORD PTR tv86[rsp], eax
  000cc	83 7c 24 2c 00	 cmp	 DWORD PTR tv86[rsp], 0
  000d1	74 10		 je	 SHORT $LN4@float_getf
  000d3	83 7c 24 2c 01	 cmp	 DWORD PTR tv86[rsp], 1
  000d8	74 25		 je	 SHORT $LN2@float_getf
  000da	83 7c 24 2c 02	 cmp	 DWORD PTR tv86[rsp], 2
  000df	74 10		 je	 SHORT $LN3@float_getf
  000e1	eb 2a		 jmp	 SHORT $LN1@float_getf
$LN4@float_getf:

; 1608 :     case unknown_format:
; 1609 :         return PyUnicode_FromString("unknown");

  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07CIFAGBMG@unknown?$AA@
  000ea	e8 00 00 00 00	 call	 PyUnicode_FromString
  000ef	eb 2a		 jmp	 SHORT $LN13@float_getf
$LN3@float_getf:

; 1610 :     case ieee_little_endian_format:
; 1611 :         return PyUnicode_FromString("IEEE, little-endian");

  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LIJMHFO@IEEE?0?5little?9endian?$AA@
  000f8	e8 00 00 00 00	 call	 PyUnicode_FromString
  000fd	eb 1c		 jmp	 SHORT $LN13@float_getf
$LN2@float_getf:

; 1612 :     case ieee_big_endian_format:
; 1613 :         return PyUnicode_FromString("IEEE, big-endian");

  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FPOIKJOA@IEEE?0?5big?9endian?$AA@
  00106	e8 00 00 00 00	 call	 PyUnicode_FromString
  0010b	eb 0e		 jmp	 SHORT $LN13@float_getf
$LN1@float_getf:

; 1614 :     default:
; 1615 :         Py_FatalError("insane float_format or double_format");

  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@FLPIAOEG@insane?5float_format?5or?5double_fo@
  00114	e8 00 00 00 00	 call	 Py_FatalError

; 1616 :         return NULL;

  00119	33 c0		 xor	 eax, eax
$LN13@float_getf:

; 1617 :     }
; 1618 : }

  0011b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011f	c3		 ret	 0
float_getformat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@KOPFAODE@can?5only?5set?5?$CFs?5format?5to?5?8unkno@ ; `string'
PUBLIC	??_C@_0FK@HCEKLDKI@__setformat__?$CI?$CJ?5argument?52?5must?5@ ; `string'
PUBLIC	??_C@_0DH@ILBMOHK@__setformat__?$CI?$CJ?5argument?51?5must?5@ ; `string'
PUBLIC	??_C@_0BB@HNELEHLF@ss?3__setformat__?$AA@	; `string'
_BSS	SEGMENT
detected_float_format DD 01H DUP (?)
detected_double_format DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_setformat DD imagerel float_setformat
	DD	imagerel float_setformat+364
	DD	imagerel $unwind$float_setformat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_setformat DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0ED@KOPFAODE@can?5only?5set?5?$CFs?5format?5to?5?8unkno@
CONST	SEGMENT
??_C@_0ED@KOPFAODE@can?5only?5set?5?$CFs?5format?5to?5?8unkno@ DB 'can on'
	DB	'ly set %s format to ''unknown'' or the detected platform valu'
	DB	'e', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@HCEKLDKI@__setformat__?$CI?$CJ?5argument?52?5must?5@
CONST	SEGMENT
??_C@_0FK@HCEKLDKI@__setformat__?$CI?$CJ?5argument?52?5must?5@ DB '__setf'
	DB	'ormat__() argument 2 must be ''unknown'', ''IEEE, little-endi'
	DB	'an'' or ''IEEE, big-endian''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@ILBMOHK@__setformat__?$CI?$CJ?5argument?51?5must?5@
CONST	SEGMENT
??_C@_0DH@ILBMOHK@__setformat__?$CI?$CJ?5argument?51?5must?5@ DB '__setfo'
	DB	'rmat__() argument 1 must be ''double'' or ''float''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNELEHLF@ss?3__setformat__?$AA@
CONST	SEGMENT
??_C@_0BB@HNELEHLF@ss?3__setformat__?$AA@ DB 'ss:__setformat__', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float_setformat
_TEXT	SEGMENT
p$ = 32
f$ = 40
typestr$ = 48
format$ = 56
detected$ = 64
v$ = 96
args$ = 104
float_setformat PROC					; COMDAT

; 1632 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1633 :     char* typestr;
; 1634 :     char* format;
; 1635 :     float_format_type f;
; 1636 :     float_format_type detected;
; 1637 :     float_format_type *p;
; 1638 : 
; 1639 :     if (!PyArg_ParseTuple(args, "ss:__setformat__", &typestr, &format))

  0000e	4c 8d 4c 24 38	 lea	 r9, QWORD PTR format$[rsp]
  00013	4c 8d 44 24 30	 lea	 r8, QWORD PTR typestr$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@HNELEHLF@ss?3__setformat__?$AA@
  0001f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN12@float_setf

; 1640 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 33 01 00 00	 jmp	 $LN13@float_setf
$LN12@float_setf:

; 1641 : 
; 1642 :     if (strcmp(typestr, "double") == 0) {

  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06BNJCAIGJ@double?$AA@
  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR typestr$[rsp]
  00040	e8 00 00 00 00	 call	 strcmp
  00045	85 c0		 test	 eax, eax
  00047	75 18		 jne	 SHORT $LN11@float_setf

; 1643 :         p = &double_format;

  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:double_format
  00050	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1644 :         detected = detected_double_format;

  00055	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR detected_double_format
  0005b	89 44 24 40	 mov	 DWORD PTR detected$[rsp], eax
  0005f	eb 47		 jmp	 SHORT $LN10@float_setf
$LN11@float_setf:

; 1645 :     }
; 1646 :     else if (strcmp(typestr, "float") == 0) {

  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KNFBNCOH@float?$AA@
  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR typestr$[rsp]
  0006d	e8 00 00 00 00	 call	 strcmp
  00072	85 c0		 test	 eax, eax
  00074	75 18		 jne	 SHORT $LN9@float_setf

; 1647 :         p = &float_format;

  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:float_format
  0007d	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1648 :         detected = detected_float_format;

  00082	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR detected_float_format
  00088	89 44 24 40	 mov	 DWORD PTR detected$[rsp], eax

; 1649 :     }
; 1650 :     else {

  0008c	eb 1a		 jmp	 SHORT $LN8@float_setf
$LN9@float_setf:

; 1651 :         PyErr_SetString(PyExc_ValueError,
; 1652 :                         "__setformat__() argument 1 must "
; 1653 :                         "be 'double' or 'float'");

  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@ILBMOHK@__setformat__?$CI?$CJ?5argument?51?5must?5@
  00095	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0009c	e8 00 00 00 00	 call	 PyErr_SetString

; 1654 :         return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	e9 bf 00 00 00	 jmp	 $LN13@float_setf
$LN8@float_setf:
$LN10@float_setf:

; 1655 :     }
; 1656 : 
; 1657 :     if (strcmp(format, "unknown") == 0) {

  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07CIFAGBMG@unknown?$AA@
  000af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR format$[rsp]
  000b4	e8 00 00 00 00	 call	 strcmp
  000b9	85 c0		 test	 eax, eax
  000bb	75 0a		 jne	 SHORT $LN7@float_setf

; 1658 :         f = unknown_format;

  000bd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR f$[rsp], 0
  000c5	eb 55		 jmp	 SHORT $LN6@float_setf
$LN7@float_setf:

; 1659 :     }
; 1660 :     else if (strcmp(format, "IEEE, little-endian") == 0) {

  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@LIJMHFO@IEEE?0?5little?9endian?$AA@
  000ce	48 8b 4c 24 38	 mov	 rcx, QWORD PTR format$[rsp]
  000d3	e8 00 00 00 00	 call	 strcmp
  000d8	85 c0		 test	 eax, eax
  000da	75 0a		 jne	 SHORT $LN5@float_setf

; 1661 :         f = ieee_little_endian_format;

  000dc	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR f$[rsp], 2
  000e4	eb 36		 jmp	 SHORT $LN4@float_setf
$LN5@float_setf:

; 1662 :     }
; 1663 :     else if (strcmp(format, "IEEE, big-endian") == 0) {

  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@FPOIKJOA@IEEE?0?5big?9endian?$AA@
  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR format$[rsp]
  000f2	e8 00 00 00 00	 call	 strcmp
  000f7	85 c0		 test	 eax, eax
  000f9	75 0a		 jne	 SHORT $LN3@float_setf

; 1664 :         f = ieee_big_endian_format;

  000fb	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR f$[rsp], 1

; 1665 :     }
; 1666 :     else {

  00103	eb 17		 jmp	 SHORT $LN2@float_setf
$LN3@float_setf:

; 1667 :         PyErr_SetString(PyExc_ValueError,
; 1668 :                         "__setformat__() argument 2 must be "
; 1669 :                         "'unknown', 'IEEE, little-endian' or "
; 1670 :                         "'IEEE, big-endian'");

  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FK@HCEKLDKI@__setformat__?$CI?$CJ?5argument?52?5must?5@
  0010c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00113	e8 00 00 00 00	 call	 PyErr_SetString

; 1671 :         return NULL;

  00118	33 c0		 xor	 eax, eax
  0011a	eb 4b		 jmp	 SHORT $LN13@float_setf
$LN2@float_setf:
$LN4@float_setf:
$LN6@float_setf:

; 1672 : 
; 1673 :     }
; 1674 : 
; 1675 :     if (f != unknown_format && f != detected) {

  0011c	83 7c 24 28 00	 cmp	 DWORD PTR f$[rsp], 0
  00121	74 26		 je	 SHORT $LN1@float_setf
  00123	8b 44 24 40	 mov	 eax, DWORD PTR detected$[rsp]
  00127	39 44 24 28	 cmp	 DWORD PTR f$[rsp], eax
  0012b	74 1c		 je	 SHORT $LN1@float_setf

; 1676 :         PyErr_Format(PyExc_ValueError,
; 1677 :                      "can only set %s format to 'unknown' or the "
; 1678 :                      "detected platform value", typestr);

  0012d	4c 8b 44 24 30	 mov	 r8, QWORD PTR typestr$[rsp]
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@KOPFAODE@can?5only?5set?5?$CFs?5format?5to?5?8unkno@
  00139	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00140	e8 00 00 00 00	 call	 PyErr_Format

; 1679 :         return NULL;

  00145	33 c0		 xor	 eax, eax
  00147	eb 1e		 jmp	 SHORT $LN13@float_setf
$LN1@float_setf:

; 1680 :     }
; 1681 : 
; 1682 :     *p = f;

  00149	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0014e	8b 4c 24 28	 mov	 ecx, DWORD PTR f$[rsp]
  00152	89 08		 mov	 DWORD PTR [rax], ecx

; 1683 :     Py_RETURN_NONE;

  00154	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0015b	e8 00 00 00 00	 call	 _Py_IncRef
  00160	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN13@float_setf:

; 1684 : }

  00167	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0016b	c3		 ret	 0
float_setformat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_getzero DD imagerel float_getzero
	DD	imagerel float_getzero+28
	DD	imagerel $unwind$float_getzero
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_getzero DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT float_getzero
_TEXT	SEGMENT
v$ = 48
closure$ = 56
float_getzero PROC					; COMDAT

; 1701 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1702 :     return PyFloat_FromDouble(0.0);

  0000e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00012	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 1703 : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
float_getzero ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EA@DCIJOEKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@JLLBFDEO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0N@EKIKMBMC@U?3__format__?$AA@		; `string'
EXTRN	_PyUnicodeWriter_Finish:PROC
EXTRN	_PyUnicodeWriter_Dealloc:PROC
EXTRN	_PyFloat_FormatAdvancedWriter:PROC
EXTRN	_PyUnicodeWriter_Init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float__format__ DD imagerel float__format__
	DD	imagerel float__format__+246
	DD	imagerel $unwind$float__format__
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float__format__ DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_1EA@DCIJOEKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@DCIJOEKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'f', 00H
	DB	'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, '_', 00H, 's'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@JLLBFDEO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@JLLBFDEO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H
	DB	'a', 00H, 't', 00H, '_', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKIKMBMC@U?3__format__?$AA@
CONST	SEGMENT
??_C@_0N@EKIKMBMC@U?3__format__?$AA@ DB 'U:__format__', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT float__format__
_TEXT	SEGMENT
writer$ = 48
format_spec$ = 104
ret$ = 112
self$ = 144
args$ = 152
float__format__ PROC					; COMDAT

; 1707 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1708 :     PyObject *format_spec;
; 1709 :     _PyUnicodeWriter writer;
; 1710 :     int ret;
; 1711 : 
; 1712 :     if (!PyArg_ParseTuple(args, "U:__format__", &format_spec))

  00011	4c 8d 44 24 68	 lea	 r8, QWORD PTR format_spec$[rsp]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EKIKMBMC@U?3__format__?$AA@
  0001d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00025	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN2@float__for

; 1713 :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 b9 00 00 00	 jmp	 $LN3@float__for
$LN2@float__for:

; 1714 : 
; 1715 :     _PyUnicodeWriter_Init(&writer, 0);

  00035	33 d2		 xor	 edx, edx
  00037	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  0003c	e8 00 00 00 00	 call	 _PyUnicodeWriter_Init

; 1716 :     ret = _PyFloat_FormatAdvancedWriter(
; 1717 :         &writer,
; 1718 :         self,
; 1719 :         format_spec, 0, PyUnicode_GET_LENGTH(format_spec));

  00041	48 8b 44 24 68	 mov	 rax, QWORD PTR format_spec$[rsp]
  00046	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00050	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00055	85 c0		 test	 eax, eax
  00057	75 1c		 jne	 SHORT $LN5@float__for
  00059	41 b8 b7 06 00
	00		 mov	 r8d, 1719		; 000006b7H
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@JLLBFDEO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00073	33 c0		 xor	 eax, eax
$LN5@float__for:
  00075	48 8b 44 24 68	 mov	 rax, QWORD PTR format_spec$[rsp]
  0007a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0007d	c1 e8 07	 shr	 eax, 7
  00080	83 e0 01	 and	 eax, 1
  00083	85 c0		 test	 eax, eax
  00085	75 1c		 jne	 SHORT $LN6@float__for
  00087	41 b8 b7 06 00
	00		 mov	 r8d, 1719		; 000006b7H
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@DCIJOEKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA_?$AAs?$AAp?$AAe?$AAc?$AA?$CJ?$AA?$AA@
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a1	33 c0		 xor	 eax, eax
$LN6@float__for:
  000a3	48 8b 44 24 68	 mov	 rax, QWORD PTR format_spec$[rsp]
  000a8	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b1	45 33 c9	 xor	 r9d, r9d
  000b4	4c 8b 44 24 68	 mov	 r8, QWORD PTR format_spec$[rsp]
  000b9	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  000c1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  000c6	e8 00 00 00 00	 call	 _PyFloat_FormatAdvancedWriter
  000cb	89 44 24 70	 mov	 DWORD PTR ret$[rsp], eax

; 1720 :     if (ret == -1) {

  000cf	83 7c 24 70 ff	 cmp	 DWORD PTR ret$[rsp], -1
  000d4	75 0e		 jne	 SHORT $LN1@float__for

; 1721 :         _PyUnicodeWriter_Dealloc(&writer);

  000d6	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  000db	e8 00 00 00 00	 call	 _PyUnicodeWriter_Dealloc

; 1722 :         return NULL;

  000e0	33 c0		 xor	 eax, eax
  000e2	eb 0a		 jmp	 SHORT $LN3@float__for
$LN1@float__for:

; 1723 :     }
; 1724 :     return _PyUnicodeWriter_Finish(&writer);

  000e4	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  000e9	e8 00 00 00 00	 call	 _PyUnicodeWriter_Finish
$LN3@float__for:

; 1725 : }

  000ee	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000f5	c3		 ret	 0
float__format__ ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@		; `string'
PUBLIC	??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@		; `string'
PUBLIC	__real@4b7f0102
PUBLIC	??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@ ; `string'
PUBLIC	??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@ ; `string'
PUBLIC	__real@433fff0102030405
PUBLIC	_PyFloat_Init
EXTRN	PyStructSequence_InitType:PROC
EXTRN	memcmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_Init DD imagerel $LN12
	DD	imagerel $LN12+266
	DD	imagerel $unwind$_PyFloat_Init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_Init DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@
CONST	SEGMENT
??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@ DB 02H, 01H, 07fH, 'K', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@
CONST	SEGMENT
??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@ DB 'K', 07fH, 01H, 02H, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4b7f0102
CONST	SEGMENT
__real@4b7f0102 DD 04b7f0102r			; 1.67119e+007
CONST	ENDS
;	COMDAT ??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@
CONST	SEGMENT
??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@ DB 05H, 04H, 03H, 02H
	DB	01H, 0ffH, '?C', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@
CONST	SEGMENT
??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@ DB 'C?', 0ffH, 01H, 02H
	DB	03H, 04H, 05H, 00H				; `string'
CONST	ENDS
;	COMDAT __real@433fff0102030405
CONST	SEGMENT
__real@433fff0102030405 DQ 0433fff0102030405r	; 9.0061e+015
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyFloat_Init
_TEXT	SEGMENT
x$21446 = 32
y$21453 = 40
_PyFloat_Init PROC					; COMDAT

; 1864 : {

$LN12:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1865 :     /* We attempt to determine if this machine is using IEEE
; 1866 :        floating point formats by peering at the bits of some
; 1867 :        carefully chosen values.  If it looks like we are on an
; 1868 :        IEEE platform, the float packing/unpacking routines can
; 1869 :        just copy bits, if not they resort to arithmetic & shifts
; 1870 :        and masks.  The shifts & masks approach works on all finite
; 1871 :        values, but what happens to infinities, NaNs and signed
; 1872 :        zeroes on packing is an accident, and attempting to unpack
; 1873 :        a NaN or an infinity will raise an exception.
; 1874 : 
; 1875 :        Note that if we're on some whacked-out platform which uses
; 1876 :        IEEE formats but isn't strictly little-endian or big-
; 1877 :        endian, we will fall back to the portable shifts & masks
; 1878 :        method. */
; 1879 : 
; 1880 : #if SIZEOF_DOUBLE == 8
; 1881 :     {
; 1882 :         double x = 9006104071832581.0;

  00004	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@433fff0102030405
  0000c	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21446[rsp], xmm0

; 1883 :         if (memcmp(&x, "\x43\x3f\xff\x01\x02\x03\x04\x05", 8) == 0)

  00012	41 b8 08 00 00
	00		 mov	 r8d, 8
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@
  0001f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$21446[rsp]
  00024	e8 00 00 00 00	 call	 memcmp
  00029	85 c0		 test	 eax, eax
  0002b	75 0c		 jne	 SHORT $LN9@PyFloat_In

; 1884 :             detected_double_format = ieee_big_endian_format;

  0002d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR detected_double_format, 1
  00037	eb 31		 jmp	 SHORT $LN8@PyFloat_In
$LN9@PyFloat_In:

; 1885 :         else if (memcmp(&x, "\x05\x04\x03\x02\x01\xff\x3f\x43", 8) == 0)

  00039	41 b8 08 00 00
	00		 mov	 r8d, 8
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@
  00046	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x$21446[rsp]
  0004b	e8 00 00 00 00	 call	 memcmp
  00050	85 c0		 test	 eax, eax
  00052	75 0c		 jne	 SHORT $LN7@PyFloat_In

; 1886 :             detected_double_format = ieee_little_endian_format;

  00054	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR detected_double_format, 2

; 1887 :         else

  0005e	eb 0a		 jmp	 SHORT $LN6@PyFloat_In
$LN7@PyFloat_In:

; 1888 :             detected_double_format = unknown_format;

  00060	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR detected_double_format, 0
$LN6@PyFloat_In:
$LN8@PyFloat_In:

; 1889 :     }
; 1890 : #else
; 1891 :     detected_double_format = unknown_format;
; 1892 : #endif
; 1893 : 
; 1894 : #if SIZEOF_FLOAT == 4
; 1895 :     {
; 1896 :         float y = 16711938.0;

  0006a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@4b7f0102
  00072	f3 0f 11 44 24
	28		 movss	 DWORD PTR y$21453[rsp], xmm0

; 1897 :         if (memcmp(&y, "\x4b\x7f\x01\x02", 4) == 0)

  00078	41 b8 04 00 00
	00		 mov	 r8d, 4
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@
  00085	48 8d 4c 24 28	 lea	 rcx, QWORD PTR y$21453[rsp]
  0008a	e8 00 00 00 00	 call	 memcmp
  0008f	85 c0		 test	 eax, eax
  00091	75 0c		 jne	 SHORT $LN5@PyFloat_In

; 1898 :             detected_float_format = ieee_big_endian_format;

  00093	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR detected_float_format, 1
  0009d	eb 31		 jmp	 SHORT $LN4@PyFloat_In
$LN5@PyFloat_In:

; 1899 :         else if (memcmp(&y, "\x02\x01\x7f\x4b", 4) == 0)

  0009f	41 b8 04 00 00
	00		 mov	 r8d, 4
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@
  000ac	48 8d 4c 24 28	 lea	 rcx, QWORD PTR y$21453[rsp]
  000b1	e8 00 00 00 00	 call	 memcmp
  000b6	85 c0		 test	 eax, eax
  000b8	75 0c		 jne	 SHORT $LN3@PyFloat_In

; 1900 :             detected_float_format = ieee_little_endian_format;

  000ba	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR detected_float_format, 2

; 1901 :         else

  000c4	eb 0a		 jmp	 SHORT $LN2@PyFloat_In
$LN3@PyFloat_In:

; 1902 :             detected_float_format = unknown_format;

  000c6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR detected_float_format, 0
$LN2@PyFloat_In:
$LN4@PyFloat_In:

; 1903 :     }
; 1904 : #else
; 1905 :     detected_float_format = unknown_format;
; 1906 : #endif
; 1907 : 
; 1908 :     double_format = detected_double_format;

  000d0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR detected_double_format
  000d6	89 05 00 00 00
	00		 mov	 DWORD PTR double_format, eax

; 1909 :     float_format = detected_float_format;

  000dc	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR detected_float_format
  000e2	89 05 00 00 00
	00		 mov	 DWORD PTR float_format, eax

; 1910 : 
; 1911 :     /* Init float info */
; 1912 :     if (FloatInfoType.tp_name == 0)

  000e8	48 83 3d 70 00
	00 00 00	 cmp	 QWORD PTR FloatInfoType+112, 0
  000f0	75 13		 jne	 SHORT $LN1@PyFloat_In

; 1913 :         PyStructSequence_InitType(&FloatInfoType, &floatinfo_desc);

  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:floatinfo_desc
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:FloatInfoType
  00100	e8 00 00 00 00	 call	 PyStructSequence_InitType
$LN1@PyFloat_In:

; 1914 : }

  00105	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00109	c3		 ret	 0
_PyFloat_Init ENDP
_TEXT	ENDS
PUBLIC	PyFloat_ClearFreeList
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFloat_ClearFreeList DD imagerel $LN6
	DD	imagerel $LN6+113
	DD	imagerel $unwind$PyFloat_ClearFreeList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_ClearFreeList DD 010401H
	DD	08204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyFloat_ClearFreeList
_TEXT	SEGMENT
i$ = 32
f$ = 40
next$ = 48
PyFloat_ClearFreeList PROC				; COMDAT

; 1918 : {

$LN6:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1919 :     PyFloatObject *f = free_list, *next;

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR free_list
  0000b	48 89 44 24 28	 mov	 QWORD PTR f$[rsp], rax

; 1920 :     int i = numfree;

  00010	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  00016	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 1921 :     if (Py_PXCTX)

  0001a	e8 00 00 00 00	 call	 _Py_PXCTX
  0001f	85 c0		 test	 eax, eax
  00021	74 04		 je	 SHORT $LN3@PyFloat_Cl

; 1922 :         return 0;

  00023	33 c0		 xor	 eax, eax
  00025	eb 45		 jmp	 SHORT $LN4@PyFloat_Cl
$LN3@PyFloat_Cl:
$LN2@PyFloat_Cl:

; 1923 :     while (f) {

  00027	48 83 7c 24 28
	00		 cmp	 QWORD PTR f$[rsp], 0
  0002d	74 24		 je	 SHORT $LN1@PyFloat_Cl

; 1924 :         next = (PyFloatObject*) Py_TYPE(f);

  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR f$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	48 89 44 24 30	 mov	 QWORD PTR next$[rsp], rax

; 1925 :         PyObject_FREE(f);

  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00042	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 1926 :         f = next;

  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  0004c	48 89 44 24 28	 mov	 QWORD PTR f$[rsp], rax

; 1927 :     }

  00051	eb d4		 jmp	 SHORT $LN2@PyFloat_Cl
$LN1@PyFloat_Cl:

; 1928 :     free_list = NULL;

  00053	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR free_list, 0

; 1929 :     numfree = 0;

  0005e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR numfree, 0

; 1930 :     return i;

  00068	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
$LN4@PyFloat_Cl:

; 1931 : }

  0006c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00070	c3		 ret	 0
PyFloat_ClearFreeList ENDP
_TEXT	ENDS
PUBLIC	PyFloat_Fini
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFloat_Fini DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$PyFloat_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_Fini DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyFloat_Fini
_TEXT	SEGMENT
PyFloat_Fini PROC					; COMDAT

; 1935 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1936 :     (void)PyFloat_ClearFreeList();

  00004	e8 00 00 00 00	 call	 PyFloat_ClearFreeList

; 1937 : }

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
PyFloat_Fini ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@KGFOHJAA@free?5PyFloatObject?$AA@	; `string'
PUBLIC	_PyFloat_DebugMallocStats
EXTRN	_PyDebugAllocatorStats:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_DebugMallocStats DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$_PyFloat_DebugMallocStats
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_DebugMallocStats DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BD@KGFOHJAA@free?5PyFloatObject?$AA@
CONST	SEGMENT
??_C@_0BD@KGFOHJAA@free?5PyFloatObject?$AA@ DB 'free PyFloatObject', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyFloat_DebugMallocStats
_TEXT	SEGMENT
out$ = 48
_PyFloat_DebugMallocStats PROC				; COMDAT

; 1942 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1943 :     _PyDebugAllocatorStats(out,
; 1944 :                            "free PyFloatObject",
; 1945 :                            numfree, sizeof(PyFloatObject));

  00009	41 b9 70 00 00
	00		 mov	 r9d, 112		; 00000070H
  0000f	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR numfree
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@KGFOHJAA@free?5PyFloatObject?$AA@
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00022	e8 00 00 00 00	 call	 _PyDebugAllocatorStats

; 1946 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
_PyFloat_DebugMallocStats ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@KFOPKBPB@float?5too?5large?5to?5pack?5with?5f?5f@ ; `string'
PUBLIC	??_C@_1CC@CODPKHN@?$AAf?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA8?$AA3?$AA8?$AA8?$AA6?$AA0?$AA8?$AA?$AA@ ; `string'
PUBLIC	__real@4160000000000000
PUBLIC	??_C@_0BM@MPOILIGE@frexp?$CI?$CJ?5result?5out?5of?5range?$AA@ ; `string'
PUBLIC	_PyFloat_Pack4
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_Pack4 DD imagerel $LN30
	DD	imagerel $LN30+938
	DD	imagerel $unwind$_PyFloat_Pack4
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_Pack4 DD 011401H
	DD	0c214H
xdata	ENDS
;	COMDAT ??_C@_0CG@KFOPKBPB@float?5too?5large?5to?5pack?5with?5f?5f@
CONST	SEGMENT
??_C@_0CG@KFOPKBPB@float?5too?5large?5to?5pack?5with?5f?5f@ DB 'float too'
	DB	' large to pack with f format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@CODPKHN@?$AAf?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA8?$AA3?$AA8?$AA8?$AA6?$AA0?$AA8?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@CODPKHN@?$AAf?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA8?$AA3?$AA8?$AA8?$AA6?$AA0?$AA8?$AA?$AA@ DB 'f'
	DB	00H, 'b', 00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '8', 00H, '3', 00H, '8', 00H, '8', 00H, '6'
	DB	00H, '0', 00H, '8', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT __real@4160000000000000
CONST	SEGMENT
__real@4160000000000000 DQ 04160000000000000r	; 8.38861e+006
CONST	ENDS
;	COMDAT ??_C@_0BM@MPOILIGE@frexp?$CI?$CJ?5result?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BM@MPOILIGE@frexp?$CI?$CJ?5result?5out?5of?5range?$AA@ DB 'frexp()'
	DB	' result out of range', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyFloat_Pack4
_TEXT	SEGMENT
fbits$21492 = 32
f$21491 = 40
incr$21493 = 48
sign$21489 = 52
e$21490 = 56
y$21516 = 60
i$21520 = 64
s$21518 = 72
incr$21521 = 80
x$ = 112
p$ = 120
le$ = 128
_PyFloat_Pack4 PROC					; COMDAT

; 1954 : {

$LN30:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00010	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1955 :     if (float_format == unknown_format) {

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR float_format, 0
  0001b	0f 85 75 02 00
	00		 jne	 $LN25@PyFloat_Pa

; 1956 :         unsigned char sign;
; 1957 :         int e;
; 1958 :         double f;
; 1959 :         unsigned int fbits;
; 1960 :         int incr = 1;

  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR incr$21493[rsp], 1

; 1961 : 
; 1962 :         if (le) {

  00029	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR le$[rsp], 0
  00031	74 16		 je	 SHORT $LN24@PyFloat_Pa

; 1963 :             p += 3;

  00033	48 8b 44 24 78	 mov	 rax, QWORD PTR p$[rsp]
  00038	48 83 c0 03	 add	 rax, 3
  0003c	48 89 44 24 78	 mov	 QWORD PTR p$[rsp], rax

; 1964 :             incr = -1;

  00041	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR incr$21493[rsp], -1
$LN24@PyFloat_Pa:

; 1965 :         }
; 1966 : 
; 1967 :         if (x < 0) {

  00049	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0004d	66 0f 2f 44 24
	70		 comisd	 xmm0, QWORD PTR x$[rsp]
  00053	76 1b		 jbe	 SHORT $LN23@PyFloat_Pa

; 1968 :             sign = 1;

  00055	c6 44 24 34 01	 mov	 BYTE PTR sign$21489[rsp], 1

; 1969 :             x = -x;

  0005a	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00060	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00068	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1970 :         }
; 1971 :         else

  0006e	eb 05		 jmp	 SHORT $LN22@PyFloat_Pa
$LN23@PyFloat_Pa:

; 1972 :             sign = 0;

  00070	c6 44 24 34 00	 mov	 BYTE PTR sign$21489[rsp], 0
$LN22@PyFloat_Pa:

; 1973 : 
; 1974 :         f = frexp(x, &e);

  00075	48 8d 54 24 38	 lea	 rdx, QWORD PTR e$21490[rsp]
  0007a	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp
  00086	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR f$21491[rsp], xmm0

; 1975 : 
; 1976 :         /* Normalize f to be in the range [1.0, 2.0) */
; 1977 :         if (0.5 <= f && f < 1.0) {

  0008c	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR f$21491[rsp]
  00092	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3fe0000000000000
  0009a	72 30		 jb	 SHORT $LN21@PyFloat_Pa
  0009c	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  000a4	66 0f 2f 44 24
	28		 comisd	 xmm0, QWORD PTR f$21491[rsp]
  000aa	76 20		 jbe	 SHORT $LN21@PyFloat_Pa

; 1978 :             f *= 2.0;

  000ac	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR f$21491[rsp]
  000b2	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
  000ba	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR f$21491[rsp], xmm0

; 1979 :             e--;

  000c0	8b 44 24 38	 mov	 eax, DWORD PTR e$21490[rsp]
  000c4	ff c8		 dec	 eax
  000c6	89 44 24 38	 mov	 DWORD PTR e$21490[rsp], eax
  000ca	eb 39		 jmp	 SHORT $LN20@PyFloat_Pa
$LN21@PyFloat_Pa:

; 1980 :         }
; 1981 :         else if (f == 0.0)

  000cc	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR f$21491[rsp]
  000d2	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000da	7a 0c		 jp	 SHORT $LN19@PyFloat_Pa
  000dc	75 0a		 jne	 SHORT $LN19@PyFloat_Pa

; 1982 :             e = 0;

  000de	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR e$21490[rsp], 0

; 1983 :         else {

  000e6	eb 1d		 jmp	 SHORT $LN18@PyFloat_Pa
$LN19@PyFloat_Pa:

; 1984 :             PyErr_SetString(PyExc_SystemError,
; 1985 :                             "frexp() result out of range");

  000e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@MPOILIGE@frexp?$CI?$CJ?5result?5out?5of?5range?$AA@
  000ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000f6	e8 00 00 00 00	 call	 PyErr_SetString

; 1986 :             return -1;

  000fb	b8 ff ff ff ff	 mov	 eax, -1
  00100	e9 a0 02 00 00	 jmp	 $LN26@PyFloat_Pa
$LN18@PyFloat_Pa:
$LN20@PyFloat_Pa:

; 1987 :         }
; 1988 : 
; 1989 :         if (e >= 128)

  00105	81 7c 24 38 80
	00 00 00	 cmp	 DWORD PTR e$21490[rsp], 128 ; 00000080H
  0010d	7c 07		 jl	 SHORT $LN17@PyFloat_Pa

; 1990 :             goto Overflow;

  0010f	e9 79 02 00 00	 jmp	 $Overflow$21503
  00114	eb 64		 jmp	 SHORT $LN16@PyFloat_Pa
$LN17@PyFloat_Pa:

; 1991 :         else if (e < -126) {

  00116	83 7c 24 38 82	 cmp	 DWORD PTR e$21490[rsp], -126 ; ffffffffffffff82H
  0011b	7d 25		 jge	 SHORT $LN15@PyFloat_Pa

; 1992 :             /* Gradual underflow */
; 1993 :             f = ldexp(f, 126 + e);

  0011d	8b 44 24 38	 mov	 eax, DWORD PTR e$21490[rsp]
  00121	83 c0 7e	 add	 eax, 126		; 0000007eH
  00124	8b d0		 mov	 edx, eax
  00126	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR f$21491[rsp]
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00132	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR f$21491[rsp], xmm0

; 1994 :             e = 0;

  00138	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR e$21490[rsp], 0
  00140	eb 38		 jmp	 SHORT $LN14@PyFloat_Pa
$LN15@PyFloat_Pa:

; 1995 :         }
; 1996 :         else if (!(e == 0 && f == 0.0)) {

  00142	83 7c 24 38 00	 cmp	 DWORD PTR e$21490[rsp], 0
  00147	75 12		 jne	 SHORT $LN12@PyFloat_Pa
  00149	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR f$21491[rsp]
  0014f	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00157	7a 02		 jp	 SHORT $LN29@PyFloat_Pa
  00159	74 1f		 je	 SHORT $LN13@PyFloat_Pa
$LN29@PyFloat_Pa:
$LN12@PyFloat_Pa:

; 1997 :             e += 127;

  0015b	8b 44 24 38	 mov	 eax, DWORD PTR e$21490[rsp]
  0015f	83 c0 7f	 add	 eax, 127		; 0000007fH
  00162	89 44 24 38	 mov	 DWORD PTR e$21490[rsp], eax

; 1998 :             f -= 1.0; /* Get rid of leading 1 */

  00166	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR f$21491[rsp]
  0016c	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00174	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR f$21491[rsp], xmm0
$LN13@PyFloat_Pa:
$LN14@PyFloat_Pa:
$LN16@PyFloat_Pa:

; 1999 :         }
; 2000 : 
; 2001 :         f *= 8388608.0; /* 2**23 */

  0017a	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR f$21491[rsp]
  00180	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4160000000000000
  00188	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR f$21491[rsp], xmm0

; 2002 :         fbits = (unsigned int)(f + 0.5); /* Round */

  0018e	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR f$21491[rsp]
  00194	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0019c	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  001a1	89 44 24 20	 mov	 DWORD PTR fbits$21492[rsp], eax

; 2003 :         assert(fbits <= 8388608);

  001a5	81 7c 24 20 00
	00 80 00	 cmp	 DWORD PTR fbits$21492[rsp], 8388608 ; 00800000H
  001ad	76 1c		 jbe	 SHORT $LN28@PyFloat_Pa
  001af	41 b8 d3 07 00
	00		 mov	 r8d, 2003		; 000007d3H
  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CODPKHN@?$AAf?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA8?$AA3?$AA8?$AA8?$AA6?$AA0?$AA8?$AA?$AA@
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001c9	33 c0		 xor	 eax, eax
$LN28@PyFloat_Pa:

; 2004 :         if (fbits >> 23) {

  001cb	8b 44 24 20	 mov	 eax, DWORD PTR fbits$21492[rsp]
  001cf	c1 e8 17	 shr	 eax, 23
  001d2	85 c0		 test	 eax, eax
  001d4	74 21		 je	 SHORT $LN11@PyFloat_Pa

; 2005 :             /* The carry propagated out of a string of 23 1 bits. */
; 2006 :             fbits = 0;

  001d6	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR fbits$21492[rsp], 0

; 2007 :             ++e;

  001de	8b 44 24 38	 mov	 eax, DWORD PTR e$21490[rsp]
  001e2	ff c0		 inc	 eax
  001e4	89 44 24 38	 mov	 DWORD PTR e$21490[rsp], eax

; 2008 :             if (e >= 255)

  001e8	81 7c 24 38 ff
	00 00 00	 cmp	 DWORD PTR e$21490[rsp], 255 ; 000000ffH
  001f0	7c 05		 jl	 SHORT $LN10@PyFloat_Pa

; 2009 :                 goto Overflow;

  001f2	e9 96 01 00 00	 jmp	 $Overflow$21503
$LN10@PyFloat_Pa:
$LN11@PyFloat_Pa:

; 2010 :         }
; 2011 : 
; 2012 :         /* First byte */
; 2013 :         *p = (sign << 7) | (e >> 1);

  001f7	0f b6 44 24 34	 movzx	 eax, BYTE PTR sign$21489[rsp]
  001fc	c1 e0 07	 shl	 eax, 7
  001ff	8b 4c 24 38	 mov	 ecx, DWORD PTR e$21490[rsp]
  00203	d1 f9		 sar	 ecx, 1
  00205	0b c1		 or	 eax, ecx
  00207	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  0020c	88 01		 mov	 BYTE PTR [rcx], al

; 2014 :         p += incr;

  0020e	48 63 44 24 30	 movsxd	 rax, DWORD PTR incr$21493[rsp]
  00213	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  00218	48 03 c8	 add	 rcx, rax
  0021b	48 8b c1	 mov	 rax, rcx
  0021e	48 89 44 24 78	 mov	 QWORD PTR p$[rsp], rax

; 2015 : 
; 2016 :         /* Second byte */
; 2017 :         *p = (char) (((e & 1) << 7) | (fbits >> 16));

  00223	8b 44 24 38	 mov	 eax, DWORD PTR e$21490[rsp]
  00227	83 e0 01	 and	 eax, 1
  0022a	c1 e0 07	 shl	 eax, 7
  0022d	8b 4c 24 20	 mov	 ecx, DWORD PTR fbits$21492[rsp]
  00231	c1 e9 10	 shr	 ecx, 16
  00234	0b c1		 or	 eax, ecx
  00236	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  0023b	88 01		 mov	 BYTE PTR [rcx], al

; 2018 :         p += incr;

  0023d	48 63 44 24 30	 movsxd	 rax, DWORD PTR incr$21493[rsp]
  00242	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  00247	48 03 c8	 add	 rcx, rax
  0024a	48 8b c1	 mov	 rax, rcx
  0024d	48 89 44 24 78	 mov	 QWORD PTR p$[rsp], rax

; 2019 : 
; 2020 :         /* Third byte */
; 2021 :         *p = (fbits >> 8) & 0xFF;

  00252	8b 44 24 20	 mov	 eax, DWORD PTR fbits$21492[rsp]
  00256	c1 e8 08	 shr	 eax, 8
  00259	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0025e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  00263	88 01		 mov	 BYTE PTR [rcx], al

; 2022 :         p += incr;

  00265	48 63 44 24 30	 movsxd	 rax, DWORD PTR incr$21493[rsp]
  0026a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  0026f	48 03 c8	 add	 rcx, rax
  00272	48 8b c1	 mov	 rax, rcx
  00275	48 89 44 24 78	 mov	 QWORD PTR p$[rsp], rax

; 2023 : 
; 2024 :         /* Fourth byte */
; 2025 :         *p = fbits & 0xFF;

  0027a	8b 44 24 20	 mov	 eax, DWORD PTR fbits$21492[rsp]
  0027e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00283	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  00288	88 01		 mov	 BYTE PTR [rcx], al

; 2026 : 
; 2027 :         /* Done */
; 2028 :         return 0;

  0028a	33 c0		 xor	 eax, eax
  0028c	e9 14 01 00 00	 jmp	 $LN26@PyFloat_Pa

; 2029 : 
; 2030 :     }
; 2031 :     else {

  00291	e9 f7 00 00 00	 jmp	 $LN9@PyFloat_Pa
$LN25@PyFloat_Pa:

; 2032 :         float y = (float)x;

  00296	f2 0f 5a 44 24
	70		 cvtsd2ss xmm0, QWORD PTR x$[rsp]
  0029c	f3 0f 11 44 24
	3c		 movss	 DWORD PTR y$21516[rsp], xmm0

; 2033 :         const char *s = (char*)&y;

  002a2	48 8d 44 24 3c	 lea	 rax, QWORD PTR y$21516[rsp]
  002a7	48 89 44 24 48	 mov	 QWORD PTR s$21518[rsp], rax

; 2034 :         int i, incr = 1;

  002ac	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR incr$21521[rsp], 1

; 2035 : 
; 2036 :         if (Py_IS_INFINITY(y) && !Py_IS_INFINITY(x))

  002b4	66 0f 6e 44 24
	3c		 movd	 xmm0, DWORD PTR y$21516[rsp]
  002ba	0f 5a c0	 cvtps2pd xmm0, xmm0
  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  002c3	85 c0		 test	 eax, eax
  002c5	75 38		 jne	 SHORT $LN8@PyFloat_Pa
  002c7	66 0f 6e 44 24
	3c		 movd	 xmm0, DWORD PTR y$21516[rsp]
  002cd	0f 5a c0	 cvtps2pd xmm0, xmm0
  002d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  002d6	85 c0		 test	 eax, eax
  002d8	75 25		 jne	 SHORT $LN8@PyFloat_Pa
  002da	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR x$[rsp]
  002e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  002e6	85 c0		 test	 eax, eax
  002e8	75 10		 jne	 SHORT $LN7@PyFloat_Pa
  002ea	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR x$[rsp]
  002f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  002f6	85 c0		 test	 eax, eax
  002f8	74 05		 je	 SHORT $LN8@PyFloat_Pa
$LN7@PyFloat_Pa:

; 2037 :             goto Overflow;

  002fa	e9 8e 00 00 00	 jmp	 $Overflow$21503
$LN8@PyFloat_Pa:

; 2038 : 
; 2039 :         if ((float_format == ieee_little_endian_format && !le)
; 2040 :             || (float_format == ieee_big_endian_format && le)) {

  002ff	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR float_format, 2
  00306	75 0a		 jne	 SHORT $LN4@PyFloat_Pa
  00308	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR le$[rsp], 0
  00310	74 13		 je	 SHORT $LN5@PyFloat_Pa
$LN4@PyFloat_Pa:
  00312	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR float_format, 1
  00319	75 20		 jne	 SHORT $LN6@PyFloat_Pa
  0031b	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR le$[rsp], 0
  00323	74 16		 je	 SHORT $LN6@PyFloat_Pa
$LN5@PyFloat_Pa:

; 2041 :             p += 3;

  00325	48 8b 44 24 78	 mov	 rax, QWORD PTR p$[rsp]
  0032a	48 83 c0 03	 add	 rax, 3
  0032e	48 89 44 24 78	 mov	 QWORD PTR p$[rsp], rax

; 2042 :             incr = -1;

  00333	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR incr$21521[rsp], -1
$LN6@PyFloat_Pa:

; 2043 :         }
; 2044 : 
; 2045 :         for (i = 0; i < 4; i++) {

  0033b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$21520[rsp], 0
  00343	eb 0a		 jmp	 SHORT $LN3@PyFloat_Pa
$LN2@PyFloat_Pa:
  00345	8b 44 24 40	 mov	 eax, DWORD PTR i$21520[rsp]
  00349	ff c0		 inc	 eax
  0034b	89 44 24 40	 mov	 DWORD PTR i$21520[rsp], eax
$LN3@PyFloat_Pa:
  0034f	83 7c 24 40 04	 cmp	 DWORD PTR i$21520[rsp], 4
  00354	7d 33		 jge	 SHORT $LN1@PyFloat_Pa

; 2046 :             *p = *s++;

  00356	48 8b 44 24 78	 mov	 rax, QWORD PTR p$[rsp]
  0035b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$21518[rsp]
  00360	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00363	88 08		 mov	 BYTE PTR [rax], cl
  00365	48 8b 44 24 48	 mov	 rax, QWORD PTR s$21518[rsp]
  0036a	48 ff c0	 inc	 rax
  0036d	48 89 44 24 48	 mov	 QWORD PTR s$21518[rsp], rax

; 2047 :             p += incr;

  00372	48 63 44 24 50	 movsxd	 rax, DWORD PTR incr$21521[rsp]
  00377	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  0037c	48 03 c8	 add	 rcx, rax
  0037f	48 8b c1	 mov	 rax, rcx
  00382	48 89 44 24 78	 mov	 QWORD PTR p$[rsp], rax

; 2048 :         }

  00387	eb bc		 jmp	 SHORT $LN2@PyFloat_Pa
$LN1@PyFloat_Pa:

; 2049 :         return 0;

  00389	33 c0		 xor	 eax, eax
  0038b	eb 18		 jmp	 SHORT $LN26@PyFloat_Pa
$LN9@PyFloat_Pa:
$Overflow$21503:

; 2050 :     }
; 2051 :   Overflow:
; 2052 :     PyErr_SetString(PyExc_OverflowError,
; 2053 :                     "float too large to pack with f format");

  0038d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@KFOPKBPB@float?5too?5large?5to?5pack?5with?5f?5f@
  00394	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0039b	e8 00 00 00 00	 call	 PyErr_SetString

; 2054 :     return -1;

  003a0	b8 ff ff ff ff	 mov	 eax, -1
$LN26@PyFloat_Pa:

; 2055 : }

  003a5	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003a9	c3		 ret	 0
_PyFloat_Pack4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@ILBJIJHH@float?5too?5large?5to?5pack?5with?5d?5f@ ; `string'
PUBLIC	??_C@_1CA@DJOPADHH@?$AAf?$AAl?$AAo?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6?$AA7?$AA7?$AA7?$AA2?$AA1?$AA6?$AA?$AA@ ; `string'
PUBLIC	__real@4170000000000000
PUBLIC	??_C@_1CA@FLCFLOPG@?$AAf?$AAh?$AAi?$AA?5?$AA?$DM?$AA?5?$AA2?$AA6?$AA8?$AA4?$AA3?$AA5?$AA4?$AA5?$AA6?$AA?$AA@ ; `string'
PUBLIC	__real@41b0000000000000
PUBLIC	_PyFloat_Pack8
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_Pack8 DD imagerel $LN30
	DD	imagerel $LN30+1141
	DD	imagerel $unwind$_PyFloat_Pack8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_Pack8 DD 011401H
	DD	0a214H
xdata	ENDS
;	COMDAT ??_C@_0CG@ILBJIJHH@float?5too?5large?5to?5pack?5with?5d?5f@
CONST	SEGMENT
??_C@_0CG@ILBJIJHH@float?5too?5large?5to?5pack?5with?5d?5f@ DB 'float too'
	DB	' large to pack with d format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@DJOPADHH@?$AAf?$AAl?$AAo?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6?$AA7?$AA7?$AA7?$AA2?$AA1?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@DJOPADHH@?$AAf?$AAl?$AAo?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6?$AA7?$AA7?$AA7?$AA2?$AA1?$AA6?$AA?$AA@ DB 'f'
	DB	00H, 'l', 00H, 'o', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	'1', 00H, '6', 00H, '7', 00H, '7', 00H, '7', 00H, '2', 00H, '1'
	DB	00H, '6', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT __real@4170000000000000
CONST	SEGMENT
__real@4170000000000000 DQ 04170000000000000r	; 1.67772e+007
CONST	ENDS
;	COMDAT ??_C@_1CA@FLCFLOPG@?$AAf?$AAh?$AAi?$AA?5?$AA?$DM?$AA?5?$AA2?$AA6?$AA8?$AA4?$AA3?$AA5?$AA4?$AA5?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@FLCFLOPG@?$AAf?$AAh?$AAi?$AA?5?$AA?$DM?$AA?5?$AA2?$AA6?$AA8?$AA4?$AA3?$AA5?$AA4?$AA5?$AA6?$AA?$AA@ DB 'f'
	DB	00H, 'h', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H, '2', 00H
	DB	'6', 00H, '8', 00H, '4', 00H, '3', 00H, '5', 00H, '4', 00H, '5'
	DB	00H, '6', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT __real@41b0000000000000
CONST	SEGMENT
__real@41b0000000000000 DQ 041b0000000000000r	; 2.68435e+008
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyFloat_Pack8
_TEXT	SEGMENT
f$21541 = 32
flo$21543 = 40
incr$21544 = 44
sign$21539 = 48
fhi$21542 = 52
e$21540 = 56
i$21574 = 60
s$21572 = 64
incr$21575 = 72
x$ = 96
p$ = 104
le$ = 112
_PyFloat_Pack8 PROC					; COMDAT

; 2059 : {

$LN30:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2060 :     if (double_format == unknown_format) {

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR double_format, 0
  0001b	0f 85 b7 03 00
	00		 jne	 $LN24@PyFloat_Pa@2

; 2061 :         unsigned char sign;
; 2062 :         int e;
; 2063 :         double f;
; 2064 :         unsigned int fhi, flo;
; 2065 :         int incr = 1;

  00021	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR incr$21544[rsp], 1

; 2066 : 
; 2067 :         if (le) {

  00029	83 7c 24 70 00	 cmp	 DWORD PTR le$[rsp], 0
  0002e	74 16		 je	 SHORT $LN23@PyFloat_Pa@2

; 2068 :             p += 7;

  00030	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]
  00035	48 83 c0 07	 add	 rax, 7
  00039	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax

; 2069 :             incr = -1;

  0003e	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR incr$21544[rsp], -1
$LN23@PyFloat_Pa@2:

; 2070 :         }
; 2071 : 
; 2072 :         if (x < 0) {

  00046	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0004a	66 0f 2f 44 24
	60		 comisd	 xmm0, QWORD PTR x$[rsp]
  00050	76 1b		 jbe	 SHORT $LN22@PyFloat_Pa@2

; 2073 :             sign = 1;

  00052	c6 44 24 30 01	 mov	 BYTE PTR sign$21539[rsp], 1

; 2074 :             x = -x;

  00057	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0005d	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00065	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR x$[rsp], xmm0

; 2075 :         }
; 2076 :         else

  0006b	eb 05		 jmp	 SHORT $LN21@PyFloat_Pa@2
$LN22@PyFloat_Pa@2:

; 2077 :             sign = 0;

  0006d	c6 44 24 30 00	 mov	 BYTE PTR sign$21539[rsp], 0
$LN21@PyFloat_Pa@2:

; 2078 : 
; 2079 :         f = frexp(x, &e);

  00072	48 8d 54 24 38	 lea	 rdx, QWORD PTR e$21540[rsp]
  00077	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp
  00083	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR f$21541[rsp], xmm0

; 2080 : 
; 2081 :         /* Normalize f to be in the range [1.0, 2.0) */
; 2082 :         if (0.5 <= f && f < 1.0) {

  00089	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR f$21541[rsp]
  0008f	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3fe0000000000000
  00097	72 30		 jb	 SHORT $LN20@PyFloat_Pa@2
  00099	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  000a1	66 0f 2f 44 24
	20		 comisd	 xmm0, QWORD PTR f$21541[rsp]
  000a7	76 20		 jbe	 SHORT $LN20@PyFloat_Pa@2

; 2083 :             f *= 2.0;

  000a9	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR f$21541[rsp]
  000af	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
  000b7	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR f$21541[rsp], xmm0

; 2084 :             e--;

  000bd	8b 44 24 38	 mov	 eax, DWORD PTR e$21540[rsp]
  000c1	ff c8		 dec	 eax
  000c3	89 44 24 38	 mov	 DWORD PTR e$21540[rsp], eax
  000c7	eb 39		 jmp	 SHORT $LN19@PyFloat_Pa@2
$LN20@PyFloat_Pa@2:

; 2085 :         }
; 2086 :         else if (f == 0.0)

  000c9	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR f$21541[rsp]
  000cf	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000d7	7a 0c		 jp	 SHORT $LN18@PyFloat_Pa@2
  000d9	75 0a		 jne	 SHORT $LN18@PyFloat_Pa@2

; 2087 :             e = 0;

  000db	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR e$21540[rsp], 0

; 2088 :         else {

  000e3	eb 1d		 jmp	 SHORT $LN17@PyFloat_Pa@2
$LN18@PyFloat_Pa@2:

; 2089 :             PyErr_SetString(PyExc_SystemError,
; 2090 :                             "frexp() result out of range");

  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@MPOILIGE@frexp?$CI?$CJ?5result?5out?5of?5range?$AA@
  000ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000f3	e8 00 00 00 00	 call	 PyErr_SetString

; 2091 :             return -1;

  000f8	b8 ff ff ff ff	 mov	 eax, -1
  000fd	e9 6e 03 00 00	 jmp	 $LN25@PyFloat_Pa@2
$LN17@PyFloat_Pa@2:
$LN19@PyFloat_Pa@2:

; 2092 :         }
; 2093 : 
; 2094 :         if (e >= 1024)

  00102	81 7c 24 38 00
	04 00 00	 cmp	 DWORD PTR e$21540[rsp], 1024 ; 00000400H
  0010a	7c 07		 jl	 SHORT $LN16@PyFloat_Pa@2

; 2095 :             goto Overflow;

  0010c	e9 a5 02 00 00	 jmp	 $Overflow$21553
  00111	eb 6b		 jmp	 SHORT $LN15@PyFloat_Pa@2
$LN16@PyFloat_Pa@2:

; 2096 :         else if (e < -1022) {

  00113	81 7c 24 38 02
	fc ff ff	 cmp	 DWORD PTR e$21540[rsp], -1022 ; fffffffffffffc02H
  0011b	7d 27		 jge	 SHORT $LN14@PyFloat_Pa@2

; 2097 :             /* Gradual underflow */
; 2098 :             f = ldexp(f, 1022 + e);

  0011d	8b 44 24 38	 mov	 eax, DWORD PTR e$21540[rsp]
  00121	05 fe 03 00 00	 add	 eax, 1022		; 000003feH
  00126	8b d0		 mov	 edx, eax
  00128	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR f$21541[rsp]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00134	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR f$21541[rsp], xmm0

; 2099 :             e = 0;

  0013a	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR e$21540[rsp], 0
  00142	eb 3a		 jmp	 SHORT $LN13@PyFloat_Pa@2
$LN14@PyFloat_Pa@2:

; 2100 :         }
; 2101 :         else if (!(e == 0 && f == 0.0)) {

  00144	83 7c 24 38 00	 cmp	 DWORD PTR e$21540[rsp], 0
  00149	75 12		 jne	 SHORT $LN11@PyFloat_Pa@2
  0014b	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR f$21541[rsp]
  00151	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00159	7a 02		 jp	 SHORT $LN29@PyFloat_Pa@2
  0015b	74 21		 je	 SHORT $LN12@PyFloat_Pa@2
$LN29@PyFloat_Pa@2:
$LN11@PyFloat_Pa@2:

; 2102 :             e += 1023;

  0015d	8b 44 24 38	 mov	 eax, DWORD PTR e$21540[rsp]
  00161	05 ff 03 00 00	 add	 eax, 1023		; 000003ffH
  00166	89 44 24 38	 mov	 DWORD PTR e$21540[rsp], eax

; 2103 :             f -= 1.0; /* Get rid of leading 1 */

  0016a	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR f$21541[rsp]
  00170	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00178	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR f$21541[rsp], xmm0
$LN12@PyFloat_Pa@2:
$LN13@PyFloat_Pa@2:
$LN15@PyFloat_Pa@2:

; 2104 :         }
; 2105 : 
; 2106 :         /* fhi receives the high 28 bits; flo the low 24 bits (== 52 bits) */
; 2107 :         f *= 268435456.0; /* 2**28 */

  0017e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR f$21541[rsp]
  00184	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41b0000000000000
  0018c	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR f$21541[rsp], xmm0

; 2108 :         fhi = (unsigned int)f; /* Truncate */

  00192	f2 48 0f 2c 44
	24 20		 cvttsd2si rax, QWORD PTR f$21541[rsp]
  00199	89 44 24 34	 mov	 DWORD PTR fhi$21542[rsp], eax

; 2109 :         assert(fhi < 268435456);

  0019d	81 7c 24 34 00
	00 00 10	 cmp	 DWORD PTR fhi$21542[rsp], 268435456 ; 10000000H
  001a5	72 1c		 jb	 SHORT $LN27@PyFloat_Pa@2
  001a7	41 b8 3d 08 00
	00		 mov	 r8d, 2109		; 0000083dH
  001ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@FLCFLOPG@?$AAf?$AAh?$AAi?$AA?5?$AA?$DM?$AA?5?$AA2?$AA6?$AA8?$AA4?$AA3?$AA5?$AA4?$AA5?$AA6?$AA?$AA@
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001c1	33 c0		 xor	 eax, eax
$LN27@PyFloat_Pa@2:

; 2110 : 
; 2111 :         f -= (double)fhi;

  001c3	8b 44 24 34	 mov	 eax, DWORD PTR fhi$21542[rsp]
  001c7	66 0f ef c0	 pxor	 xmm0, xmm0
  001cb	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  001d0	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR f$21541[rsp]
  001d6	f2 0f 5c c8	 subsd	 xmm1, xmm0
  001da	66 0f 28 c1	 movapd	 xmm0, xmm1
  001de	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR f$21541[rsp], xmm0

; 2112 :         f *= 16777216.0; /* 2**24 */

  001e4	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR f$21541[rsp]
  001ea	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4170000000000000
  001f2	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR f$21541[rsp], xmm0

; 2113 :         flo = (unsigned int)(f + 0.5); /* Round */

  001f8	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR f$21541[rsp]
  001fe	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00206	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  0020b	89 44 24 28	 mov	 DWORD PTR flo$21543[rsp], eax

; 2114 :         assert(flo <= 16777216);

  0020f	81 7c 24 28 00
	00 00 01	 cmp	 DWORD PTR flo$21543[rsp], 16777216 ; 01000000H
  00217	76 1c		 jbe	 SHORT $LN28@PyFloat_Pa@2
  00219	41 b8 42 08 00
	00		 mov	 r8d, 2114		; 00000842H
  0021f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@NBOIMECB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAf?$AAl?$AAo?$AAa?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@DJOPADHH@?$AAf?$AAl?$AAo?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6?$AA7?$AA7?$AA7?$AA2?$AA1?$AA6?$AA?$AA@
  0022d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00233	33 c0		 xor	 eax, eax
$LN28@PyFloat_Pa@2:

; 2115 :         if (flo >> 24) {

  00235	8b 44 24 28	 mov	 eax, DWORD PTR flo$21543[rsp]
  00239	c1 e8 18	 shr	 eax, 24
  0023c	85 c0		 test	 eax, eax
  0023e	74 3e		 je	 SHORT $LN10@PyFloat_Pa@2

; 2116 :             /* The carry propagated out of a string of 24 1 bits. */
; 2117 :             flo = 0;

  00240	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR flo$21543[rsp], 0

; 2118 :             ++fhi;

  00248	8b 44 24 34	 mov	 eax, DWORD PTR fhi$21542[rsp]
  0024c	ff c0		 inc	 eax
  0024e	89 44 24 34	 mov	 DWORD PTR fhi$21542[rsp], eax

; 2119 :             if (fhi >> 28) {

  00252	8b 44 24 34	 mov	 eax, DWORD PTR fhi$21542[rsp]
  00256	c1 e8 1c	 shr	 eax, 28
  00259	85 c0		 test	 eax, eax
  0025b	74 21		 je	 SHORT $LN9@PyFloat_Pa@2

; 2120 :                 /* And it also progagated out of the next 28 bits. */
; 2121 :                 fhi = 0;

  0025d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR fhi$21542[rsp], 0

; 2122 :                 ++e;

  00265	8b 44 24 38	 mov	 eax, DWORD PTR e$21540[rsp]
  00269	ff c0		 inc	 eax
  0026b	89 44 24 38	 mov	 DWORD PTR e$21540[rsp], eax

; 2123 :                 if (e >= 2047)

  0026f	81 7c 24 38 ff
	07 00 00	 cmp	 DWORD PTR e$21540[rsp], 2047 ; 000007ffH
  00277	7c 05		 jl	 SHORT $LN8@PyFloat_Pa@2

; 2124 :                     goto Overflow;

  00279	e9 38 01 00 00	 jmp	 $Overflow$21553
$LN8@PyFloat_Pa@2:
$LN9@PyFloat_Pa@2:
$LN10@PyFloat_Pa@2:

; 2125 :             }
; 2126 :         }
; 2127 : 
; 2128 :         /* First byte */
; 2129 :         *p = (sign << 7) | (e >> 4);

  0027e	0f b6 44 24 30	 movzx	 eax, BYTE PTR sign$21539[rsp]
  00283	c1 e0 07	 shl	 eax, 7
  00286	8b 4c 24 38	 mov	 ecx, DWORD PTR e$21540[rsp]
  0028a	c1 f9 04	 sar	 ecx, 4
  0028d	0b c1		 or	 eax, ecx
  0028f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  00294	88 01		 mov	 BYTE PTR [rcx], al

; 2130 :         p += incr;

  00296	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21544[rsp]
  0029b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  002a0	48 03 c8	 add	 rcx, rax
  002a3	48 8b c1	 mov	 rax, rcx
  002a6	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax

; 2131 : 
; 2132 :         /* Second byte */
; 2133 :         *p = (unsigned char) (((e & 0xF) << 4) | (fhi >> 24));

  002ab	8b 44 24 38	 mov	 eax, DWORD PTR e$21540[rsp]
  002af	83 e0 0f	 and	 eax, 15
  002b2	c1 e0 04	 shl	 eax, 4
  002b5	8b 4c 24 34	 mov	 ecx, DWORD PTR fhi$21542[rsp]
  002b9	c1 e9 18	 shr	 ecx, 24
  002bc	0b c1		 or	 eax, ecx
  002be	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  002c3	88 01		 mov	 BYTE PTR [rcx], al

; 2134 :         p += incr;

  002c5	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21544[rsp]
  002ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  002cf	48 03 c8	 add	 rcx, rax
  002d2	48 8b c1	 mov	 rax, rcx
  002d5	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax

; 2135 : 
; 2136 :         /* Third byte */
; 2137 :         *p = (fhi >> 16) & 0xFF;

  002da	8b 44 24 34	 mov	 eax, DWORD PTR fhi$21542[rsp]
  002de	c1 e8 10	 shr	 eax, 16
  002e1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002e6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  002eb	88 01		 mov	 BYTE PTR [rcx], al

; 2138 :         p += incr;

  002ed	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21544[rsp]
  002f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  002f7	48 03 c8	 add	 rcx, rax
  002fa	48 8b c1	 mov	 rax, rcx
  002fd	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax

; 2139 : 
; 2140 :         /* Fourth byte */
; 2141 :         *p = (fhi >> 8) & 0xFF;

  00302	8b 44 24 34	 mov	 eax, DWORD PTR fhi$21542[rsp]
  00306	c1 e8 08	 shr	 eax, 8
  00309	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0030e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  00313	88 01		 mov	 BYTE PTR [rcx], al

; 2142 :         p += incr;

  00315	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21544[rsp]
  0031a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  0031f	48 03 c8	 add	 rcx, rax
  00322	48 8b c1	 mov	 rax, rcx
  00325	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax

; 2143 : 
; 2144 :         /* Fifth byte */
; 2145 :         *p = fhi & 0xFF;

  0032a	8b 44 24 34	 mov	 eax, DWORD PTR fhi$21542[rsp]
  0032e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00333	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  00338	88 01		 mov	 BYTE PTR [rcx], al

; 2146 :         p += incr;

  0033a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21544[rsp]
  0033f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  00344	48 03 c8	 add	 rcx, rax
  00347	48 8b c1	 mov	 rax, rcx
  0034a	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax

; 2147 : 
; 2148 :         /* Sixth byte */
; 2149 :         *p = (flo >> 16) & 0xFF;

  0034f	8b 44 24 28	 mov	 eax, DWORD PTR flo$21543[rsp]
  00353	c1 e8 10	 shr	 eax, 16
  00356	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0035b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  00360	88 01		 mov	 BYTE PTR [rcx], al

; 2150 :         p += incr;

  00362	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21544[rsp]
  00367	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  0036c	48 03 c8	 add	 rcx, rax
  0036f	48 8b c1	 mov	 rax, rcx
  00372	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax

; 2151 : 
; 2152 :         /* Seventh byte */
; 2153 :         *p = (flo >> 8) & 0xFF;

  00377	8b 44 24 28	 mov	 eax, DWORD PTR flo$21543[rsp]
  0037b	c1 e8 08	 shr	 eax, 8
  0037e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00383	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  00388	88 01		 mov	 BYTE PTR [rcx], al

; 2154 :         p += incr;

  0038a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21544[rsp]
  0038f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  00394	48 03 c8	 add	 rcx, rax
  00397	48 8b c1	 mov	 rax, rcx
  0039a	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax

; 2155 : 
; 2156 :         /* Eighth byte */
; 2157 :         *p = flo & 0xFF;

  0039f	8b 44 24 28	 mov	 eax, DWORD PTR flo$21543[rsp]
  003a3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003a8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  003ad	88 01		 mov	 BYTE PTR [rcx], al

; 2158 :         /* p += incr; */
; 2159 : 
; 2160 :         /* Done */
; 2161 :         return 0;

  003af	33 c0		 xor	 eax, eax
  003b1	e9 ba 00 00 00	 jmp	 $LN25@PyFloat_Pa@2
$Overflow$21553:

; 2162 : 
; 2163 :       Overflow:
; 2164 :         PyErr_SetString(PyExc_OverflowError,
; 2165 :                         "float too large to pack with d format");

  003b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@ILBJIJHH@float?5too?5large?5to?5pack?5with?5d?5f@
  003bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  003c4	e8 00 00 00 00	 call	 PyErr_SetString

; 2166 :         return -1;

  003c9	b8 ff ff ff ff	 mov	 eax, -1
  003ce	e9 9d 00 00 00	 jmp	 $LN25@PyFloat_Pa@2

; 2167 :     }
; 2168 :     else {

  003d3	e9 98 00 00 00	 jmp	 $LN7@PyFloat_Pa@2
$LN24@PyFloat_Pa@2:

; 2169 :         const char *s = (char*)&x;

  003d8	48 8d 44 24 60	 lea	 rax, QWORD PTR x$[rsp]
  003dd	48 89 44 24 40	 mov	 QWORD PTR s$21572[rsp], rax

; 2170 :         int i, incr = 1;

  003e2	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR incr$21575[rsp], 1

; 2171 : 
; 2172 :         if ((double_format == ieee_little_endian_format && !le)
; 2173 :             || (double_format == ieee_big_endian_format && le)) {

  003ea	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR double_format, 2
  003f1	75 07		 jne	 SHORT $LN4@PyFloat_Pa@2
  003f3	83 7c 24 70 00	 cmp	 DWORD PTR le$[rsp], 0
  003f8	74 10		 je	 SHORT $LN5@PyFloat_Pa@2
$LN4@PyFloat_Pa@2:
  003fa	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR double_format, 1
  00401	75 1d		 jne	 SHORT $LN6@PyFloat_Pa@2
  00403	83 7c 24 70 00	 cmp	 DWORD PTR le$[rsp], 0
  00408	74 16		 je	 SHORT $LN6@PyFloat_Pa@2
$LN5@PyFloat_Pa@2:

; 2174 :             p += 7;

  0040a	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]
  0040f	48 83 c0 07	 add	 rax, 7
  00413	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax

; 2175 :             incr = -1;

  00418	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR incr$21575[rsp], -1
$LN6@PyFloat_Pa@2:

; 2176 :         }
; 2177 : 
; 2178 :         for (i = 0; i < 8; i++) {

  00420	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$21574[rsp], 0
  00428	eb 0a		 jmp	 SHORT $LN3@PyFloat_Pa@2
$LN2@PyFloat_Pa@2:
  0042a	8b 44 24 3c	 mov	 eax, DWORD PTR i$21574[rsp]
  0042e	ff c0		 inc	 eax
  00430	89 44 24 3c	 mov	 DWORD PTR i$21574[rsp], eax
$LN3@PyFloat_Pa@2:
  00434	83 7c 24 3c 08	 cmp	 DWORD PTR i$21574[rsp], 8
  00439	7d 33		 jge	 SHORT $LN1@PyFloat_Pa@2

; 2179 :             *p = *s++;

  0043b	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]
  00440	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$21572[rsp]
  00445	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00448	88 08		 mov	 BYTE PTR [rax], cl
  0044a	48 8b 44 24 40	 mov	 rax, QWORD PTR s$21572[rsp]
  0044f	48 ff c0	 inc	 rax
  00452	48 89 44 24 40	 mov	 QWORD PTR s$21572[rsp], rax

; 2180 :             p += incr;

  00457	48 63 44 24 48	 movsxd	 rax, DWORD PTR incr$21575[rsp]
  0045c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p$[rsp]
  00461	48 03 c8	 add	 rcx, rax
  00464	48 8b c1	 mov	 rax, rcx
  00467	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax

; 2181 :         }

  0046c	eb bc		 jmp	 SHORT $LN2@PyFloat_Pa@2
$LN1@PyFloat_Pa@2:

; 2182 :         return 0;

  0046e	33 c0		 xor	 eax, eax
$LN7@PyFloat_Pa@2:
$LN25@PyFloat_Pa@2:

; 2183 :     }
; 2184 : }

  00470	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00474	c3		 ret	 0
_PyFloat_Pack8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DJ@IOEAIBOI@can?8t?5unpack?5IEEE?5754?5special?5va@ ; `string'
PUBLIC	_PyFloat_Unpack4
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_Unpack4 DD imagerel $LN17
	DD	imagerel $LN17+602
	DD	imagerel $unwind$_PyFloat_Unpack4
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_Unpack4 DD 010d01H
	DD	0a20dH
xdata	ENDS
;	COMDAT ??_C@_0DJ@IOEAIBOI@can?8t?5unpack?5IEEE?5754?5special?5va@
CONST	SEGMENT
??_C@_0DJ@IOEAIBOI@can?8t?5unpack?5IEEE?5754?5special?5va@ DB 'can''t unp'
	DB	'ack IEEE 754 special value on non-IEEE platform', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyFloat_Unpack4
_TEXT	SEGMENT
x$21591 = 32
f$21590 = 40
incr$21592 = 44
sign$21588 = 48
e$21589 = 52
x$21601 = 56
i$21607 = 60
buf$21605 = 64
d$21606 = 72
p$ = 96
le$ = 104
_PyFloat_Unpack4 PROC					; COMDAT

; 2188 : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2189 :     if (float_format == unknown_format) {

  0000d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR float_format, 0
  00014	0f 85 96 01 00
	00		 jne	 $LN14@PyFloat_Un

; 2190 :         unsigned char sign;
; 2191 :         int e;
; 2192 :         unsigned int f;
; 2193 :         double x;
; 2194 :         int incr = 1;

  0001a	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR incr$21592[rsp], 1

; 2195 : 
; 2196 :         if (le) {

  00022	83 7c 24 68 00	 cmp	 DWORD PTR le$[rsp], 0
  00027	74 16		 je	 SHORT $LN13@PyFloat_Un

; 2197 :             p += 3;

  00029	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0002e	48 83 c0 03	 add	 rax, 3
  00032	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax

; 2198 :             incr = -1;

  00037	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR incr$21592[rsp], -1
$LN13@PyFloat_Un:

; 2199 :         }
; 2200 : 
; 2201 :         /* First byte */
; 2202 :         sign = (*p >> 7) & 1;

  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00044	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00047	c1 f8 07	 sar	 eax, 7
  0004a	83 e0 01	 and	 eax, 1
  0004d	88 44 24 30	 mov	 BYTE PTR sign$21588[rsp], al

; 2203 :         e = (*p & 0x7F) << 1;

  00051	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00056	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00059	83 e0 7f	 and	 eax, 127		; 0000007fH
  0005c	d1 e0		 shl	 eax, 1
  0005e	89 44 24 34	 mov	 DWORD PTR e$21589[rsp], eax

; 2204 :         p += incr;

  00062	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21592[rsp]
  00067	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  0006c	48 03 c8	 add	 rcx, rax
  0006f	48 8b c1	 mov	 rax, rcx
  00072	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax

; 2205 : 
; 2206 :         /* Second byte */
; 2207 :         e |= (*p >> 7) & 1;

  00077	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0007c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007f	c1 f8 07	 sar	 eax, 7
  00082	83 e0 01	 and	 eax, 1
  00085	8b 4c 24 34	 mov	 ecx, DWORD PTR e$21589[rsp]
  00089	0b c8		 or	 ecx, eax
  0008b	8b c1		 mov	 eax, ecx
  0008d	89 44 24 34	 mov	 DWORD PTR e$21589[rsp], eax

; 2208 :         f = (*p & 0x7F) << 16;

  00091	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00096	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00099	83 e0 7f	 and	 eax, 127		; 0000007fH
  0009c	c1 e0 10	 shl	 eax, 16
  0009f	89 44 24 28	 mov	 DWORD PTR f$21590[rsp], eax

; 2209 :         p += incr;

  000a3	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21592[rsp]
  000a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax

; 2210 : 
; 2211 :         if (e == 255) {

  000b8	81 7c 24 34 ff
	00 00 00	 cmp	 DWORD PTR e$21589[rsp], 255 ; 000000ffH
  000c0	75 20		 jne	 SHORT $LN12@PyFloat_Un

; 2212 :             PyErr_SetString(
; 2213 :                 PyExc_ValueError,
; 2214 :                 "can't unpack IEEE 754 special value "
; 2215 :                 "on non-IEEE platform");

  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@IOEAIBOI@can?8t?5unpack?5IEEE?5754?5special?5va@
  000c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000d0	e8 00 00 00 00	 call	 PyErr_SetString

; 2216 :             return -1;

  000d5	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  000dd	e9 73 01 00 00	 jmp	 $LN15@PyFloat_Un
$LN12@PyFloat_Un:

; 2217 :         }
; 2218 : 
; 2219 :         /* Third byte */
; 2220 :         f |= *p << 8;

  000e2	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  000e7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ea	c1 e0 08	 shl	 eax, 8
  000ed	8b 4c 24 28	 mov	 ecx, DWORD PTR f$21590[rsp]
  000f1	0b c8		 or	 ecx, eax
  000f3	8b c1		 mov	 eax, ecx
  000f5	89 44 24 28	 mov	 DWORD PTR f$21590[rsp], eax

; 2221 :         p += incr;

  000f9	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21592[rsp]
  000fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  00103	48 03 c8	 add	 rcx, rax
  00106	48 8b c1	 mov	 rax, rcx
  00109	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax

; 2222 : 
; 2223 :         /* Fourth byte */
; 2224 :         f |= *p;

  0010e	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00113	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00116	8b 4c 24 28	 mov	 ecx, DWORD PTR f$21590[rsp]
  0011a	0b c8		 or	 ecx, eax
  0011c	8b c1		 mov	 eax, ecx
  0011e	89 44 24 28	 mov	 DWORD PTR f$21590[rsp], eax

; 2225 : 
; 2226 :         x = (double)f / 8388608.0;

  00122	8b 44 24 28	 mov	 eax, DWORD PTR f$21590[rsp]
  00126	66 0f ef c0	 pxor	 xmm0, xmm0
  0012a	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0012f	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4160000000000000
  00137	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21591[rsp], xmm0

; 2227 : 
; 2228 :         /* XXX This sadly ignores Inf/NaN issues */
; 2229 :         if (e == 0)

  0013d	83 7c 24 34 00	 cmp	 DWORD PTR e$21589[rsp], 0
  00142	75 0a		 jne	 SHORT $LN11@PyFloat_Un

; 2230 :             e = -126;

  00144	c7 44 24 34 82
	ff ff ff	 mov	 DWORD PTR e$21589[rsp], -126 ; ffffffffffffff82H

; 2231 :         else {

  0014c	eb 1f		 jmp	 SHORT $LN10@PyFloat_Un
$LN11@PyFloat_Un:

; 2232 :             x += 1.0;

  0014e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21591[rsp]
  00154	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0015c	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21591[rsp], xmm0

; 2233 :             e -= 127;

  00162	8b 44 24 34	 mov	 eax, DWORD PTR e$21589[rsp]
  00166	83 e8 7f	 sub	 eax, 127		; 0000007fH
  00169	89 44 24 34	 mov	 DWORD PTR e$21589[rsp], eax
$LN10@PyFloat_Un:

; 2234 :         }
; 2235 :         x = ldexp(x, e);

  0016d	8b 54 24 34	 mov	 edx, DWORD PTR e$21589[rsp]
  00171	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21591[rsp]
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  0017d	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21591[rsp], xmm0

; 2236 : 
; 2237 :         if (sign)

  00183	0f b6 44 24 30	 movzx	 eax, BYTE PTR sign$21588[rsp]
  00188	85 c0		 test	 eax, eax
  0018a	74 14		 je	 SHORT $LN9@PyFloat_Un

; 2238 :             x = -x;

  0018c	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21591[rsp]
  00192	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0019a	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21591[rsp], xmm0
$LN9@PyFloat_Un:

; 2239 : 
; 2240 :         return x;

  001a0	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21591[rsp]
  001a6	e9 aa 00 00 00	 jmp	 $LN15@PyFloat_Un

; 2241 :     }
; 2242 :     else {

  001ab	e9 a5 00 00 00	 jmp	 $LN8@PyFloat_Un
$LN14@PyFloat_Un:

; 2243 :         float x;
; 2244 : 
; 2245 :         if ((float_format == ieee_little_endian_format && !le)
; 2246 :             || (float_format == ieee_big_endian_format && le)) {

  001b0	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR float_format, 2
  001b7	75 07		 jne	 SHORT $LN5@PyFloat_Un
  001b9	83 7c 24 68 00	 cmp	 DWORD PTR le$[rsp], 0
  001be	74 10		 je	 SHORT $LN6@PyFloat_Un
$LN5@PyFloat_Un:
  001c0	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR float_format, 1
  001c7	75 6e		 jne	 SHORT $LN7@PyFloat_Un
  001c9	83 7c 24 68 00	 cmp	 DWORD PTR le$[rsp], 0
  001ce	74 67		 je	 SHORT $LN7@PyFloat_Un
$LN6@PyFloat_Un:

; 2247 :             char buf[4];
; 2248 :             char *d = &buf[3];

  001d0	48 8d 44 24 43	 lea	 rax, QWORD PTR buf$21605[rsp+3]
  001d5	48 89 44 24 48	 mov	 QWORD PTR d$21606[rsp], rax

; 2249 :             int i;
; 2250 : 
; 2251 :             for (i = 0; i < 4; i++) {

  001da	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$21607[rsp], 0
  001e2	eb 0a		 jmp	 SHORT $LN4@PyFloat_Un
$LN3@PyFloat_Un:
  001e4	8b 44 24 3c	 mov	 eax, DWORD PTR i$21607[rsp]
  001e8	ff c0		 inc	 eax
  001ea	89 44 24 3c	 mov	 DWORD PTR i$21607[rsp], eax
$LN4@PyFloat_Un:
  001ee	83 7c 24 3c 04	 cmp	 DWORD PTR i$21607[rsp], 4
  001f3	7d 2b		 jge	 SHORT $LN2@PyFloat_Un

; 2252 :                 *d-- = *p++;

  001f5	48 8b 44 24 48	 mov	 rax, QWORD PTR d$21606[rsp]
  001fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  001ff	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00202	88 08		 mov	 BYTE PTR [rax], cl
  00204	48 8b 44 24 48	 mov	 rax, QWORD PTR d$21606[rsp]
  00209	48 ff c8	 dec	 rax
  0020c	48 89 44 24 48	 mov	 QWORD PTR d$21606[rsp], rax
  00211	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00216	48 ff c0	 inc	 rax
  00219	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax

; 2253 :             }

  0021e	eb c4		 jmp	 SHORT $LN3@PyFloat_Un
$LN2@PyFloat_Un:

; 2254 :             memcpy(&x, buf, 4);

  00220	41 b8 04 00 00
	00		 mov	 r8d, 4
  00226	48 8d 54 24 40	 lea	 rdx, QWORD PTR buf$21605[rsp]
  0022b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x$21601[rsp]
  00230	e8 00 00 00 00	 call	 memcpy

; 2255 :         }
; 2256 :         else {

  00235	eb 15		 jmp	 SHORT $LN1@PyFloat_Un
$LN7@PyFloat_Un:

; 2257 :             memcpy(&x, p, 4);

  00237	41 b8 04 00 00
	00		 mov	 r8d, 4
  0023d	48 8b 54 24 60	 mov	 rdx, QWORD PTR p$[rsp]
  00242	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x$21601[rsp]
  00247	e8 00 00 00 00	 call	 memcpy
$LN1@PyFloat_Un:

; 2258 :         }
; 2259 : 
; 2260 :         return x;

  0024c	66 0f 6e 44 24
	38		 movd	 xmm0, DWORD PTR x$21601[rsp]
  00252	0f 5a c0	 cvtps2pd xmm0, xmm0
$LN8@PyFloat_Un:
$LN15@PyFloat_Un:

; 2261 :     }
; 2262 : }

  00255	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00259	c3		 ret	 0
_PyFloat_Unpack4 ENDP
_TEXT	ENDS
PUBLIC	_PyFloat_Unpack8
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_Unpack8 DD imagerel $LN17
	DD	imagerel $LN17+804
	DD	imagerel $unwind$_PyFloat_Unpack8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_Unpack8 DD 010d01H
	DD	0c20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyFloat_Unpack8
_TEXT	SEGMENT
x$21622 = 32
flo$21621 = 40
incr$21623 = 44
sign$21618 = 48
fhi$21620 = 52
e$21619 = 56
x$21632 = 64
i$21638 = 72
buf$21636 = 80
d$21637 = 88
p$ = 112
le$ = 120
_PyFloat_Unpack8 PROC					; COMDAT

; 2266 : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2267 :     if (double_format == unknown_format) {

  0000d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR double_format, 0
  00014	0f 85 63 02 00
	00		 jne	 $LN14@PyFloat_Un@2

; 2268 :         unsigned char sign;
; 2269 :         int e;
; 2270 :         unsigned int fhi, flo;
; 2271 :         double x;
; 2272 :         int incr = 1;

  0001a	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR incr$21623[rsp], 1

; 2273 : 
; 2274 :         if (le) {

  00022	83 7c 24 78 00	 cmp	 DWORD PTR le$[rsp], 0
  00027	74 16		 je	 SHORT $LN13@PyFloat_Un@2

; 2275 :             p += 7;

  00029	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  0002e	48 83 c0 07	 add	 rax, 7
  00032	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 2276 :             incr = -1;

  00037	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR incr$21623[rsp], -1
$LN13@PyFloat_Un@2:

; 2277 :         }
; 2278 : 
; 2279 :         /* First byte */
; 2280 :         sign = (*p >> 7) & 1;

  0003f	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00044	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00047	c1 f8 07	 sar	 eax, 7
  0004a	83 e0 01	 and	 eax, 1
  0004d	88 44 24 30	 mov	 BYTE PTR sign$21618[rsp], al

; 2281 :         e = (*p & 0x7F) << 4;

  00051	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00056	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00059	83 e0 7f	 and	 eax, 127		; 0000007fH
  0005c	c1 e0 04	 shl	 eax, 4
  0005f	89 44 24 38	 mov	 DWORD PTR e$21619[rsp], eax

; 2282 : 
; 2283 :         p += incr;

  00063	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21623[rsp]
  00068	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 2284 : 
; 2285 :         /* Second byte */
; 2286 :         e |= (*p >> 4) & 0xF;

  00078	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  0007d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00080	c1 f8 04	 sar	 eax, 4
  00083	83 e0 0f	 and	 eax, 15
  00086	8b 4c 24 38	 mov	 ecx, DWORD PTR e$21619[rsp]
  0008a	0b c8		 or	 ecx, eax
  0008c	8b c1		 mov	 eax, ecx
  0008e	89 44 24 38	 mov	 DWORD PTR e$21619[rsp], eax

; 2287 :         fhi = (*p & 0xF) << 24;

  00092	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00097	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009a	83 e0 0f	 and	 eax, 15
  0009d	c1 e0 18	 shl	 eax, 24
  000a0	89 44 24 34	 mov	 DWORD PTR fhi$21620[rsp], eax

; 2288 :         p += incr;

  000a4	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21623[rsp]
  000a9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  000ae	48 03 c8	 add	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 2289 : 
; 2290 :         if (e == 2047) {

  000b9	81 7c 24 38 ff
	07 00 00	 cmp	 DWORD PTR e$21619[rsp], 2047 ; 000007ffH
  000c1	75 20		 jne	 SHORT $LN12@PyFloat_Un@2

; 2291 :             PyErr_SetString(
; 2292 :                 PyExc_ValueError,
; 2293 :                 "can't unpack IEEE 754 special value "
; 2294 :                 "on non-IEEE platform");

  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@IOEAIBOI@can?8t?5unpack?5IEEE?5754?5special?5va@
  000ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000d1	e8 00 00 00 00	 call	 PyErr_SetString

; 2295 :             return -1.0;

  000d6	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  000de	e9 3c 02 00 00	 jmp	 $LN15@PyFloat_Un@2
$LN12@PyFloat_Un@2:

; 2296 :         }
; 2297 : 
; 2298 :         /* Third byte */
; 2299 :         fhi |= *p << 16;

  000e3	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  000e8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000eb	c1 e0 10	 shl	 eax, 16
  000ee	8b 4c 24 34	 mov	 ecx, DWORD PTR fhi$21620[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 34	 mov	 DWORD PTR fhi$21620[rsp], eax

; 2300 :         p += incr;

  000fa	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21623[rsp]
  000ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  00104	48 03 c8	 add	 rcx, rax
  00107	48 8b c1	 mov	 rax, rcx
  0010a	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 2301 : 
; 2302 :         /* Fourth byte */
; 2303 :         fhi |= *p  << 8;

  0010f	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00114	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00117	c1 e0 08	 shl	 eax, 8
  0011a	8b 4c 24 34	 mov	 ecx, DWORD PTR fhi$21620[rsp]
  0011e	0b c8		 or	 ecx, eax
  00120	8b c1		 mov	 eax, ecx
  00122	89 44 24 34	 mov	 DWORD PTR fhi$21620[rsp], eax

; 2304 :         p += incr;

  00126	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21623[rsp]
  0012b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  00130	48 03 c8	 add	 rcx, rax
  00133	48 8b c1	 mov	 rax, rcx
  00136	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 2305 : 
; 2306 :         /* Fifth byte */
; 2307 :         fhi |= *p;

  0013b	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00140	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00143	8b 4c 24 34	 mov	 ecx, DWORD PTR fhi$21620[rsp]
  00147	0b c8		 or	 ecx, eax
  00149	8b c1		 mov	 eax, ecx
  0014b	89 44 24 34	 mov	 DWORD PTR fhi$21620[rsp], eax

; 2308 :         p += incr;

  0014f	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21623[rsp]
  00154	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  00159	48 03 c8	 add	 rcx, rax
  0015c	48 8b c1	 mov	 rax, rcx
  0015f	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 2309 : 
; 2310 :         /* Sixth byte */
; 2311 :         flo = *p << 16;

  00164	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00169	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0016c	c1 e0 10	 shl	 eax, 16
  0016f	89 44 24 28	 mov	 DWORD PTR flo$21621[rsp], eax

; 2312 :         p += incr;

  00173	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21623[rsp]
  00178	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  0017d	48 03 c8	 add	 rcx, rax
  00180	48 8b c1	 mov	 rax, rcx
  00183	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 2313 : 
; 2314 :         /* Seventh byte */
; 2315 :         flo |= *p << 8;

  00188	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  0018d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00190	c1 e0 08	 shl	 eax, 8
  00193	8b 4c 24 28	 mov	 ecx, DWORD PTR flo$21621[rsp]
  00197	0b c8		 or	 ecx, eax
  00199	8b c1		 mov	 eax, ecx
  0019b	89 44 24 28	 mov	 DWORD PTR flo$21621[rsp], eax

; 2316 :         p += incr;

  0019f	48 63 44 24 2c	 movsxd	 rax, DWORD PTR incr$21623[rsp]
  001a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  001a9	48 03 c8	 add	 rcx, rax
  001ac	48 8b c1	 mov	 rax, rcx
  001af	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 2317 : 
; 2318 :         /* Eighth byte */
; 2319 :         flo |= *p;

  001b4	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  001b9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001bc	8b 4c 24 28	 mov	 ecx, DWORD PTR flo$21621[rsp]
  001c0	0b c8		 or	 ecx, eax
  001c2	8b c1		 mov	 eax, ecx
  001c4	89 44 24 28	 mov	 DWORD PTR flo$21621[rsp], eax

; 2320 : 
; 2321 :         x = (double)fhi + (double)flo / 16777216.0; /* 2**24 */

  001c8	8b 44 24 34	 mov	 eax, DWORD PTR fhi$21620[rsp]
  001cc	66 0f ef c0	 pxor	 xmm0, xmm0
  001d0	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  001d5	8b 44 24 28	 mov	 eax, DWORD PTR flo$21621[rsp]
  001d9	66 0f ef c9	 pxor	 xmm1, xmm1
  001dd	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  001e2	f2 0f 5e 0d 00
	00 00 00	 divsd	 xmm1, QWORD PTR __real@4170000000000000
  001ea	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001ee	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21622[rsp], xmm0

; 2322 :         x /= 268435456.0; /* 2**28 */

  001f4	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21622[rsp]
  001fa	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41b0000000000000
  00202	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21622[rsp], xmm0

; 2323 : 
; 2324 :         if (e == 0)

  00208	83 7c 24 38 00	 cmp	 DWORD PTR e$21619[rsp], 0
  0020d	75 0a		 jne	 SHORT $LN11@PyFloat_Un@2

; 2325 :             e = -1022;

  0020f	c7 44 24 38 02
	fc ff ff	 mov	 DWORD PTR e$21619[rsp], -1022 ; fffffffffffffc02H

; 2326 :         else {

  00217	eb 21		 jmp	 SHORT $LN10@PyFloat_Un@2
$LN11@PyFloat_Un@2:

; 2327 :             x += 1.0;

  00219	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21622[rsp]
  0021f	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00227	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21622[rsp], xmm0

; 2328 :             e -= 1023;

  0022d	8b 44 24 38	 mov	 eax, DWORD PTR e$21619[rsp]
  00231	2d ff 03 00 00	 sub	 eax, 1023		; 000003ffH
  00236	89 44 24 38	 mov	 DWORD PTR e$21619[rsp], eax
$LN10@PyFloat_Un@2:

; 2329 :         }
; 2330 :         x = ldexp(x, e);

  0023a	8b 54 24 38	 mov	 edx, DWORD PTR e$21619[rsp]
  0023e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21622[rsp]
  00244	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  0024a	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21622[rsp], xmm0

; 2331 : 
; 2332 :         if (sign)

  00250	0f b6 44 24 30	 movzx	 eax, BYTE PTR sign$21618[rsp]
  00255	85 c0		 test	 eax, eax
  00257	74 14		 je	 SHORT $LN9@PyFloat_Un@2

; 2333 :             x = -x;

  00259	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21622[rsp]
  0025f	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00267	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21622[rsp], xmm0
$LN9@PyFloat_Un@2:

; 2334 : 
; 2335 :         return x;

  0026d	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21622[rsp]
  00273	e9 a7 00 00 00	 jmp	 $LN15@PyFloat_Un@2

; 2336 :     }
; 2337 :     else {

  00278	e9 a2 00 00 00	 jmp	 $LN8@PyFloat_Un@2
$LN14@PyFloat_Un@2:

; 2338 :         double x;
; 2339 : 
; 2340 :         if ((double_format == ieee_little_endian_format && !le)
; 2341 :             || (double_format == ieee_big_endian_format && le)) {

  0027d	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR double_format, 2
  00284	75 07		 jne	 SHORT $LN5@PyFloat_Un@2
  00286	83 7c 24 78 00	 cmp	 DWORD PTR le$[rsp], 0
  0028b	74 10		 je	 SHORT $LN6@PyFloat_Un@2
$LN5@PyFloat_Un@2:
  0028d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR double_format, 1
  00294	75 6e		 jne	 SHORT $LN7@PyFloat_Un@2
  00296	83 7c 24 78 00	 cmp	 DWORD PTR le$[rsp], 0
  0029b	74 67		 je	 SHORT $LN7@PyFloat_Un@2
$LN6@PyFloat_Un@2:

; 2342 :             char buf[8];
; 2343 :             char *d = &buf[7];

  0029d	48 8d 44 24 57	 lea	 rax, QWORD PTR buf$21636[rsp+7]
  002a2	48 89 44 24 58	 mov	 QWORD PTR d$21637[rsp], rax

; 2344 :             int i;
; 2345 : 
; 2346 :             for (i = 0; i < 8; i++) {

  002a7	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$21638[rsp], 0
  002af	eb 0a		 jmp	 SHORT $LN4@PyFloat_Un@2
$LN3@PyFloat_Un@2:
  002b1	8b 44 24 48	 mov	 eax, DWORD PTR i$21638[rsp]
  002b5	ff c0		 inc	 eax
  002b7	89 44 24 48	 mov	 DWORD PTR i$21638[rsp], eax
$LN4@PyFloat_Un@2:
  002bb	83 7c 24 48 08	 cmp	 DWORD PTR i$21638[rsp], 8
  002c0	7d 2b		 jge	 SHORT $LN2@PyFloat_Un@2

; 2347 :                 *d-- = *p++;

  002c2	48 8b 44 24 58	 mov	 rax, QWORD PTR d$21637[rsp]
  002c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  002cc	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002cf	88 08		 mov	 BYTE PTR [rax], cl
  002d1	48 8b 44 24 58	 mov	 rax, QWORD PTR d$21637[rsp]
  002d6	48 ff c8	 dec	 rax
  002d9	48 89 44 24 58	 mov	 QWORD PTR d$21637[rsp], rax
  002de	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  002e3	48 ff c0	 inc	 rax
  002e6	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 2348 :             }

  002eb	eb c4		 jmp	 SHORT $LN3@PyFloat_Un@2
$LN2@PyFloat_Un@2:

; 2349 :             memcpy(&x, buf, 8);

  002ed	41 b8 08 00 00
	00		 mov	 r8d, 8
  002f3	48 8d 54 24 50	 lea	 rdx, QWORD PTR buf$21636[rsp]
  002f8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x$21632[rsp]
  002fd	e8 00 00 00 00	 call	 memcpy

; 2350 :         }
; 2351 :         else {

  00302	eb 15		 jmp	 SHORT $LN1@PyFloat_Un@2
$LN7@PyFloat_Un@2:

; 2352 :             memcpy(&x, p, 8);

  00304	41 b8 08 00 00
	00		 mov	 r8d, 8
  0030a	48 8b 54 24 70	 mov	 rdx, QWORD PTR p$[rsp]
  0030f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x$21632[rsp]
  00314	e8 00 00 00 00	 call	 memcpy
$LN1@PyFloat_Un@2:

; 2353 :         }
; 2354 : 
; 2355 :         return x;

  00319	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR x$21632[rsp]
$LN8@PyFloat_Un@2:
$LN15@PyFloat_Un@2:

; 2356 :     }
; 2357 : }

  0031f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00323	c3		 ret	 0
_PyFloat_Unpack8 ENDP
_TEXT	ENDS
END
