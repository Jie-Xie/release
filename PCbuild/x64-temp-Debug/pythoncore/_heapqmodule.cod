; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06ODDEHMFE@_heapq?$AA@			; `string'
PUBLIC	??_C@_09EOLCJGMG@nsmallest?$AA@			; `string'
PUBLIC	??_C@_08FLDGCJJP@nlargest?$AA@			; `string'
PUBLIC	??_C@_07IOKOAJEO@heapify?$AA@			; `string'
PUBLIC	??_C@_0M@PEOLKNFI@heapreplace?$AA@		; `string'
PUBLIC	??_C@_07HNKMJBJN@heappop?$AA@			; `string'
PUBLIC	??_C@_0M@HEAOMNAP@heappushpop?$AA@		; `string'
PUBLIC	??_C@_08BOAFKLGF@heappush?$AA@			; `string'
;	COMDAT ??_C@_06ODDEHMFE@_heapq?$AA@
CONST	SEGMENT
??_C@_06ODDEHMFE@_heapq?$AA@ DB '_heapq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOLCJGMG@nsmallest?$AA@
CONST	SEGMENT
??_C@_09EOLCJGMG@nsmallest?$AA@ DB 'nsmallest', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FLDGCJJP@nlargest?$AA@
CONST	SEGMENT
??_C@_08FLDGCJJP@nlargest?$AA@ DB 'nlargest', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IOKOAJEO@heapify?$AA@
CONST	SEGMENT
??_C@_07IOKOAJEO@heapify?$AA@ DB 'heapify', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PEOLKNFI@heapreplace?$AA@
CONST	SEGMENT
??_C@_0M@PEOLKNFI@heapreplace?$AA@ DB 'heapreplace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HNKMJBJN@heappop?$AA@
CONST	SEGMENT
??_C@_07HNKMJBJN@heappop?$AA@ DB 'heappop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HEAOMNAP@heappushpop?$AA@
CONST	SEGMENT
??_C@_0M@HEAOMNAP@heappushpop?$AA@ DB 'heappushpop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOAFKLGF@heappush?$AA@
CONST	SEGMENT
??_C@_08BOAFKLGF@heappush?$AA@ DB 'heappush', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
heappush_doc DB	'heappush(heap, item) -> None. Push item onto heap, maint'
	DB	'aining the heap invariant.', 00H
	ORG $+13
heappop_doc DB	'Pop the smallest item off the heap, maintaining the heap'
	DB	' invariant.', 00H
	ORG $+12
heapreplace_doc DB 'heapreplace(heap, item) -> value. Pop and return the '
	DB	'current smallest value, and add the new item.', 0aH, 0aH, 'Th'
	DB	'is is more efficient than heappop() followed by heappush(), a'
	DB	'nd can be', 0aH, 'more appropriate when using a fixed-size he'
	DB	'ap.  Note that the value', 0aH, 'returned may be larger than '
	DB	'item!  That constrains reasonable uses of', 0aH, 'this routin'
	DB	'e unless written as part of a conditional replacement:', 0aH, 0aH
	DB	'    if item > heap[0]:', 0aH, '        item = heapreplace(hea'
	DB	'p, item)', 0aH, 00H
	ORG $+7
heappushpop_doc DB 'heappushpop(heap, item) -> value. Push item on the he'
	DB	'ap, then pop and return the smallest item', 0aH, 'from the he'
	DB	'ap. The combined action runs more efficiently than', 0aH, 'he'
	DB	'appush() followed by a separate call to heappop().', 00H
	ORG $+6
heapify_doc DB	'Transform list into a heap, in-place, in O(len(heap)) ti'
	DB	'me.', 00H
	ORG $+12
nlargest_doc DB	'Find the n largest elements in a dataset.', 0aH, 0aH, 'E'
	DB	'quivalent to:  sorted(iterable, reverse=True)[:n]', 0aH, 00H
	ORG $+1
nsmallest_doc DB 'Find the n smallest elements in a dataset.', 0aH, 0aH, 'E'
	DB	'quivalent to:  sorted(iterable)[:n]', 0aH, 00H
	ORG $+14
heapq_methods DQ FLAT:??_C@_08BOAFKLGF@heappush?$AA@
	DQ	FLAT:heappush
	DD	01H
	ORG $+4
	DQ	FLAT:heappush_doc
	DQ	FLAT:??_C@_0M@HEAOMNAP@heappushpop?$AA@
	DQ	FLAT:heappushpop
	DD	01H
	ORG $+4
	DQ	FLAT:heappushpop_doc
	DQ	FLAT:??_C@_07HNKMJBJN@heappop?$AA@
	DQ	FLAT:heappop
	DD	08H
	ORG $+4
	DQ	FLAT:heappop_doc
	DQ	FLAT:??_C@_0M@PEOLKNFI@heapreplace?$AA@
	DQ	FLAT:heapreplace
	DD	01H
	ORG $+4
	DQ	FLAT:heapreplace_doc
	DQ	FLAT:??_C@_07IOKOAJEO@heapify?$AA@
	DQ	FLAT:heapify
	DD	08H
	ORG $+4
	DQ	FLAT:heapify_doc
	DQ	FLAT:??_C@_08FLDGCJJP@nlargest?$AA@
	DQ	FLAT:nlargest
	DD	01H
	ORG $+4
	DQ	FLAT:nlargest_doc
	DQ	FLAT:??_C@_09EOLCJGMG@nsmallest?$AA@
	DQ	FLAT:nsmallest
	DD	01H
	ORG $+4
	DQ	FLAT:nsmallest_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_doc DB	'Heap queue algorithm (a.k.a. priority queue).', 0aH, 0aH
	DB	'Heaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k'
	DB	'+2] for', 0aH, 'all k, counting elements from 0.  For the sak'
	DB	'e of comparison,', 0aH, 'non-existing elements are considered'
	DB	' to be infinite.  The interesting', 0aH, 'property of a heap '
	DB	'is that a[0] is always its smallest element.', 0aH, 0aH, 'Usa'
	DB	'ge:', 0aH, 0aH, 'heap = []            # creates an empty heap'
	DB	0aH, 'heappush(heap, item) # pushes a new item on the heap', 0aH
	DB	'item = heappop(heap) # pops the smallest item from the heap', 0aH
	DB	'item = heap[0]       # smallest item on the heap without popp'
	DB	'ing it', 0aH, 'heapify(x)           # transforms list into a '
	DB	'heap, in-place, in linear time', 0aH, 'item = heapreplace(hea'
	DB	'p, item) # pops and returns smallest item, and adds', 0aH, ' '
	DB	'                              # new item; the heap size is un'
	DB	'changed', 0aH, 0aH, 'Our API differs from textbook heap algor'
	DB	'ithms as follows:', 0aH, 0aH, '- We use 0-based indexing.  Th'
	DB	'is makes the relationship between the', 0aH, '  index for a n'
	DB	'ode and the indexes for its children slightly less', 0aH, '  '
	DB	'obvious, but is more suitable since Python uses 0-based index'
	DB	'ing.', 0aH, 0aH, '- Our heappop() method returns the smallest'
	DB	' item, not the largest.', 0aH, 0aH, 'These two make it possib'
	DB	'le to view the heap as a regular Python list', 0aH, 'without '
	DB	'surprises: heap[0] is the smallest item, and heap.sort()', 0aH
	DB	'maintains the heap invariant!', 0aH, 00H
__about__ DB	'Heap queues', 0aH, 0aH, '[explanation by Fran', 0c3H, 0a7H
	DB	'ois Pinard]', 0aH, 0aH, 'Heaps are arrays for which a[k] <= a'
	DB	'[2*k+1] and a[k] <= a[2*k+2] for', 0aH, 'all k, counting elem'
	DB	'ents from 0.  For the sake of comparison,', 0aH, 'non-existin'
	DB	'g elements are considered to be infinite.  The interesting', 0aH
	DB	'property of a heap is that a[0] is always its smallest elemen'
	DB	't.', 0aH, 0aH, 'The strange invariant above is meant to be an'
	DB	' efficient memory', 0aH, 'representation for a tournament.  T'
	DB	'he numbers below are `k'', not a[k]:', 0aH, 0aH, '           '
	DB	'                        0', 0aH, 0aH, '                  1   '
	DB	'                              2', 0aH, 0aH, '          3     '
	DB	'          4                5               6', 0aH, 0aH, '   '
	DB	'   7       8       9       10      11      12      13      14'
	DB	0aH, 0aH, '    15 16   17 18   19 20   21 22   23 24   25 26  '
	DB	' 27 28   29 30', 0aH, 0aH, 0aH, 'In the tree above, each cell'
	DB	' `k'' is topping `2*k+1'' and `2*k+2''.  In', 0aH, 'an usual '
	DB	'binary tournament we see in sports, each cell is the winner', 0aH
	DB	'over the two cells it tops, and we can trace the winner down '
	DB	'the tree', 0aH, 'to see all opponents s/he had.  However, in '
	DB	'many computer applications', 0aH, 'of such tournaments, we do'
	DB	' not need to trace the history of a winner.', 0aH, 'To be mor'
	DB	'e memory efficient, when a winner is promoted, we try to', 0aH
	DB	'replace it by something else at a lower level, and the rule b'
	DB	'ecomes', 0aH, 'that a cell and the two cells it tops contain '
	DB	'three different items,', 0aH, 'but the top cell "wins" over t'
	DB	'he two topped cells.', 0aH, 0aH, 'If this heap invariant is p'
	DB	'rotected at all time, index 0 is clearly', 0aH, 'the overall '
	DB	'winner.  The simplest algorithmic way to remove it and', 0aH, 'f'
	DB	'ind the "next" winner is to move some loser (let''s say cell '
	DB	'30 in the', 0aH, 'diagram above) into the 0 position, and the'
	DB	'n percolate this new 0 down', 0aH, 'the tree, exchanging valu'
	DB	'es, until the invariant is re-established.', 0aH, 'This is cl'
	DB	'early logarithmic on the total number of items in the tree.', 0aH
	DB	'By iterating over all items, you get an O(n ln n) sort.', 0aH
	DB	0aH, 'A nice feature of this sort is that you can efficiently '
	DB	'insert new', 0aH, 'items while the sort is going on, provided'
	DB	' that the inserted items are', 0aH, 'not "better" than the la'
	DB	'st 0''th element you extracted.  This is', 0aH, 'especially u'
	DB	'seful in simulation contexts, where the tree holds all', 0aH, 'i'
	DB	'ncoming events, and the "win" condition means the smallest sc'
	DB	'heduled', 0aH, 'time.  When an event schedule other events fo'
	DB	'r execution, they are', 0aH, 'scheduled into the future, so t'
	DB	'hey can easily go into the heap.  So, a', 0aH, 'heap is a goo'
	DB	'd structure for implementing schedulers (this is what I', 0aH
	DB	'used for my MIDI sequencer :-).', 0aH, 0aH, 'Various structur'
	DB	'es for implementing schedulers have been extensively', 0aH, 's'
	DB	'tudied, and heaps are good for this, as they are reasonably s'
	DB	'peedy,', 0aH, 'the speed is almost constant, and the worst ca'
	DB	'se is not much different', 0aH, 'than the average case.  Howe'
	DB	'ver, there are other representations which', 0aH, 'are more e'
	DB	'fficient overall, yet the worst cases might be terrible.', 0aH
	DB	0aH, 'Heaps are also very useful in big disk sorts.  You most '
	DB	'probably all', 0aH, 'know that a big sort implies producing "'
	DB	'runs" (which are pre-sorted', 0aH, 'sequences, which size is '
	DB	'usually related to the amount of CPU memory),', 0aH, 'followe'
	DB	'd by a merging passes for these runs, which merging is often', 0aH
	DB	'very cleverly organised[1].  It is very important that the in'
	DB	'itial', 0aH, 'sort produces the longest runs possible.  Tourn'
	DB	'aments are a good way', 0aH, 'to that.  If, using all the mem'
	DB	'ory available to hold a tournament, you', 0aH, 'replace and p'
	DB	'ercolate items that happen to fit the current run, you''ll', 0aH
	DB	'produce runs which are twice the size of the memory for rando'
	DB	'm input,', 0aH, 'and much better for input fuzzily ordered.', 0aH
	DB	0aH, 'Moreover, if you output the 0''th item on disk and get a'
	DB	'n input which', 0aH, 'may not fit in the current tournament ('
	DB	'because the value "wins" over', 0aH, 'the last output value),'
	DB	' it cannot fit in the heap, so the size of the', 0aH, 'heap d'
	DB	'ecreases.  The freed memory could be cleverly reused immediat'
	DB	'ely', 0aH, 'for progressively building a second heap, which g'
	DB	'rows at exactly the', 0aH, 'same rate the first heap is melti'
	DB	'ng.  When the first heap completely', 0aH, 'vanishes, you swi'
	DB	'tch heaps and start a new run.  Clever and quite', 0aH, 'effe'
	DB	'ctive!', 0aH, 0aH, 'In a word, heaps are useful memory struct'
	DB	'ures to know.  I use them in', 0aH, 'a few applications, and '
	DB	'I think it is good to keep a `heap'' module', 0aH, 'around. :'
	DB	'-)', 0aH, 0aH, '--------------------', 0aH, '[1] The disk bal'
	DB	'ancing algorithms which are current, nowadays, are', 0aH, 'mo'
	DB	're annoying than clever, and this is a consequence of the see'
	DB	'king', 0aH, 'capabilities of the disks.  On devices which can'
	DB	'not seek, like big', 0aH, 'tape drives, the story was quite d'
	DB	'ifferent, and one had to be very', 0aH, 'clever to ensure (fa'
	DB	'r in advance) that each tape movement will be the', 0aH, 'mos'
	DB	't effective possible (that is, will best participate at', 0aH
	DB	'"progressing" the merge).  Some tapes were even able to read', 0aH
	DB	'backwards, and this was also used to avoid the rewinding time'
	DB	'.', 0aH, 'Believe me, real good tape sorts were quite spectac'
	DB	'ular to watch!', 0aH, 'From all times, sorting has always bee'
	DB	'n a Great Art! :-)', 0aH, 00H
	ORG $+15
_heapqmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06ODDEHMFE@_heapq?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:heapq_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@ ; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyList_Append:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_heapqmodule.c
pdata	SEGMENT
$pdata$heappush DD imagerel heappush
	DD	imagerel heappush+202
	DD	imagerel $unwind$heappush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$heappush DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
CONST	SEGMENT
??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@ DB 'heap argume'
	DB	'nt must be a list', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT heappush
_TEXT	SEGMENT
heap$ = 48
item$ = 56
self$ = 80
args$ = 88
heappush PROC						; COMDAT

; 128  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 129  :     PyObject *heap, *item;
; 130  : 
; 131  :     if (!PyArg_UnpackTuple(args, "heappush", 2, 2, &heap, &item))

  0000e	48 8d 44 24 38	 lea	 rax, QWORD PTR item$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00018	48 8d 44 24 30	 lea	 rax, QWORD PTR heap$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	41 b9 02 00 00
	00		 mov	 r9d, 2
  00028	41 b8 02 00 00
	00		 mov	 r8d, 2
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08BOAFKLGF@heappush?$AA@
  00035	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0003a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003f	85 c0		 test	 eax, eax
  00041	75 04		 jne	 SHORT $LN4@heappush

; 132  :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	eb 7e		 jmp	 SHORT $LN5@heappush
$LN4@heappush:

; 133  : 
; 134  :     if (!PyList_Check(heap)) {

  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR heap$[rsp]
  0004c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00050	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00056	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0005b	85 c0		 test	 eax, eax
  0005d	75 17		 jne	 SHORT $LN3@heappush

; 135  :         PyErr_SetString(PyExc_TypeError, "heap argument must be a list");

  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
  00066	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0006d	e8 00 00 00 00	 call	 PyErr_SetString

; 136  :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	eb 4f		 jmp	 SHORT $LN5@heappush
$LN3@heappush:

; 137  :     }
; 138  : 
; 139  :     if (PyList_Append(heap, item) == -1)

  00076	48 8b 54 24 38	 mov	 rdx, QWORD PTR item$[rsp]
  0007b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR heap$[rsp]
  00080	e8 00 00 00 00	 call	 PyList_Append
  00085	83 f8 ff	 cmp	 eax, -1
  00088	75 04		 jne	 SHORT $LN2@heappush

; 140  :         return NULL;

  0008a	33 c0		 xor	 eax, eax
  0008c	eb 37		 jmp	 SHORT $LN5@heappush
$LN2@heappush:

; 141  : 
; 142  :     if (_siftdown((PyListObject *)heap, 0, PyList_GET_SIZE(heap)-1) == -1)

  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR heap$[rsp]
  00093	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00097	48 ff c8	 dec	 rax
  0009a	4c 8b c0	 mov	 r8, rax
  0009d	33 d2		 xor	 edx, edx
  0009f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR heap$[rsp]
  000a4	e8 00 00 00 00	 call	 _siftdown
  000a9	83 f8 ff	 cmp	 eax, -1
  000ac	75 04		 jne	 SHORT $LN1@heappush

; 143  :         return NULL;

  000ae	33 c0		 xor	 eax, eax
  000b0	eb 13		 jmp	 SHORT $LN5@heappush
$LN1@heappush:

; 144  :     Py_INCREF(Py_None);

  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000b9	e8 00 00 00 00	 call	 _Py_IncRef

; 145  :     return Py_None;

  000be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN5@heappush:

; 146  : }

  000c5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c9	c3		 ret	 0
heappush ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@ ; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@	; `string'
PUBLIC	??_C@_1CG@ELEBHPKK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAa?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@OBGAKPOF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAh?$AAe?$AAa?$AAp?$AAq?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	PyExc_IndexError:QWORD
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_heapqmodule.c
pdata	SEGMENT
$pdata$_siftdown DD imagerel _siftdown
	DD	imagerel _siftdown+503
	DD	imagerel $unwind$_siftdown
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_siftdown DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@
CONST	SEGMENT
??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@ DB 'list changed'
	DB	' size during iteration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@ DB 'index out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@ELEBHPKK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAa?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@ELEBHPKK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAa?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'h'
	DB	00H, 'e', 00H, 'a', 00H, 'p', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@OBGAKPOF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAh?$AAe?$AAa?$AAp?$AAq?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@OBGAKPOF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAh?$AAe?$AAa?$AAp?$AAq?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, '_', 00H, 'h', 00H, 'e'
	DB	00H, 'a', 00H, 'p', 00H, 'q', 00H, 'm', 00H, 'o', 00H, 'd', 00H
	DB	'u', 00H, 'l', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _siftdown
_TEXT	SEGMENT
parentpos$ = 32
parent$ = 40
size$ = 48
olditem$ = 56
newitem$ = 64
cmp$ = 72
heap$ = 96
startpos$ = 104
pos$ = 112
_siftdown PROC						; COMDAT

; 13   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 14   :     PyObject *newitem, *parent, *olditem;
; 15   :     int cmp;
; 16   :     Py_ssize_t parentpos;
; 17   :     Py_ssize_t size;
; 18   : 
; 19   :     assert(PyList_Check(heap));

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR heap$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00027	85 c0		 test	 eax, eax
  00029	75 1c		 jne	 SHORT $LN10@siftdown
  0002b	41 b8 13 00 00
	00		 mov	 r8d, 19
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@OBGAKPOF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAh?$AAe?$AAa?$AAp?$AAq?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@ELEBHPKK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAa?$AAp?$AA?$CJ?$AA?$AA@
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00045	33 c0		 xor	 eax, eax
$LN10@siftdown:

; 20   :     size = PyList_GET_SIZE(heap);

  00047	48 8b 44 24 60	 mov	 rax, QWORD PTR heap$[rsp]
  0004c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00050	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 21   :     if (pos >= size) {

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  0005a	48 39 44 24 70	 cmp	 QWORD PTR pos$[rsp], rax
  0005f	7c 1d		 jl	 SHORT $LN7@siftdown

; 22   :         PyErr_SetString(PyExc_IndexError, "index out of range");

  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  00068	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0006f	e8 00 00 00 00	 call	 PyErr_SetString

; 23   :         return -1;

  00074	b8 ff ff ff ff	 mov	 eax, -1
  00079	e9 74 01 00 00	 jmp	 $LN8@siftdown
$LN7@siftdown:

; 24   :     }
; 25   : 
; 26   :     newitem = PyList_GET_ITEM(heap, pos);

  0007e	48 8b 44 24 60	 mov	 rax, QWORD PTR heap$[rsp]
  00083	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00087	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pos$[rsp]
  0008c	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00090	48 89 44 24 40	 mov	 QWORD PTR newitem$[rsp], rax

; 27   :     Py_INCREF(newitem);

  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newitem$[rsp]
  0009a	e8 00 00 00 00	 call	 _Py_IncRef
$LN6@siftdown:

; 28   :     /* Follow the path to the root, moving parents down until finding
; 29   :        a place newitem fits. */
; 30   :     while (pos > startpos){

  0009f	48 8b 44 24 68	 mov	 rax, QWORD PTR startpos$[rsp]
  000a4	48 39 44 24 70	 cmp	 QWORD PTR pos$[rsp], rax
  000a9	0f 8e 13 01 00
	00		 jle	 $LN5@siftdown

; 31   :         parentpos = (pos - 1) >> 1;

  000af	48 8b 44 24 70	 mov	 rax, QWORD PTR pos$[rsp]
  000b4	48 ff c8	 dec	 rax
  000b7	48 d1 f8	 sar	 rax, 1
  000ba	48 89 44 24 20	 mov	 QWORD PTR parentpos$[rsp], rax

; 32   :         parent = PyList_GET_ITEM(heap, parentpos);

  000bf	48 8b 44 24 60	 mov	 rax, QWORD PTR heap$[rsp]
  000c4	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR parentpos$[rsp]
  000cd	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000d1	48 89 44 24 28	 mov	 QWORD PTR parent$[rsp], rax

; 33   :         cmp = PyObject_RichCompareBool(newitem, parent, Py_LT);

  000d6	45 33 c0	 xor	 r8d, r8d
  000d9	48 8b 54 24 28	 mov	 rdx, QWORD PTR parent$[rsp]
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newitem$[rsp]
  000e3	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000e8	89 44 24 48	 mov	 DWORD PTR cmp$[rsp], eax

; 34   :         if (cmp == -1) {

  000ec	83 7c 24 48 ff	 cmp	 DWORD PTR cmp$[rsp], -1
  000f1	75 14		 jne	 SHORT $LN4@siftdown

; 35   :             Py_DECREF(newitem);

  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newitem$[rsp]
  000f8	e8 00 00 00 00	 call	 _Py_DecRef

; 36   :             return -1;

  000fd	b8 ff ff ff ff	 mov	 eax, -1
  00102	e9 eb 00 00 00	 jmp	 $LN8@siftdown
$LN4@siftdown:

; 37   :         }
; 38   :         if (size != PyList_GET_SIZE(heap)) {

  00107	48 8b 44 24 60	 mov	 rax, QWORD PTR heap$[rsp]
  0010c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00110	48 39 44 24 30	 cmp	 QWORD PTR size$[rsp], rax
  00115	74 27		 je	 SHORT $LN3@siftdown

; 39   :             Py_DECREF(newitem);

  00117	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newitem$[rsp]
  0011c	e8 00 00 00 00	 call	 _Py_DecRef

; 40   :             PyErr_SetString(PyExc_RuntimeError,
; 41   :                             "list changed size during iteration");

  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@
  00128	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0012f	e8 00 00 00 00	 call	 PyErr_SetString

; 42   :             return -1;

  00134	b8 ff ff ff ff	 mov	 eax, -1
  00139	e9 b4 00 00 00	 jmp	 $LN8@siftdown
$LN3@siftdown:

; 43   :         }
; 44   :         if (cmp == 0)

  0013e	83 7c 24 48 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00143	75 02		 jne	 SHORT $LN2@siftdown

; 45   :             break;

  00145	eb 7b		 jmp	 SHORT $LN5@siftdown
$LN2@siftdown:

; 46   :         Py_INCREF(parent);

  00147	48 8b 4c 24 28	 mov	 rcx, QWORD PTR parent$[rsp]
  0014c	e8 00 00 00 00	 call	 _Py_IncRef

; 47   :         olditem = PyList_GET_ITEM(heap, pos);

  00151	48 8b 44 24 60	 mov	 rax, QWORD PTR heap$[rsp]
  00156	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0015a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pos$[rsp]
  0015f	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00163	48 89 44 24 38	 mov	 QWORD PTR olditem$[rsp], rax

; 48   :         PyList_SET_ITEM(heap, pos, parent);

  00168	48 8b 44 24 60	 mov	 rax, QWORD PTR heap$[rsp]
  0016d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00171	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pos$[rsp]
  00176	48 8b 54 24 28	 mov	 rdx, QWORD PTR parent$[rsp]
  0017b	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 49   :         Py_DECREF(olditem);

  0017f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR olditem$[rsp]
  00184	e8 00 00 00 00	 call	 _Py_DecRef

; 50   :         pos = parentpos;

  00189	48 8b 44 24 20	 mov	 rax, QWORD PTR parentpos$[rsp]
  0018e	48 89 44 24 70	 mov	 QWORD PTR pos$[rsp], rax

; 51   :         if (size != PyList_GET_SIZE(heap)) {

  00193	48 8b 44 24 60	 mov	 rax, QWORD PTR heap$[rsp]
  00198	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0019c	48 39 44 24 30	 cmp	 QWORD PTR size$[rsp], rax
  001a1	74 1a		 je	 SHORT $LN1@siftdown

; 52   :             PyErr_SetString(PyExc_RuntimeError,
; 53   :                             "list changed size during iteration");

  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@
  001aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  001b1	e8 00 00 00 00	 call	 PyErr_SetString

; 54   :             return -1;

  001b6	b8 ff ff ff ff	 mov	 eax, -1
  001bb	eb 35		 jmp	 SHORT $LN8@siftdown
$LN1@siftdown:

; 55   :         }
; 56   :     }

  001bd	e9 dd fe ff ff	 jmp	 $LN6@siftdown
$LN5@siftdown:

; 57   :     Py_DECREF(PyList_GET_ITEM(heap, pos));

  001c2	48 8b 44 24 60	 mov	 rax, QWORD PTR heap$[rsp]
  001c7	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001cb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pos$[rsp]
  001d0	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  001d4	e8 00 00 00 00	 call	 _Py_DecRef

; 58   :     PyList_SET_ITEM(heap, pos, newitem);

  001d9	48 8b 44 24 60	 mov	 rax, QWORD PTR heap$[rsp]
  001de	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001e2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pos$[rsp]
  001e7	48 8b 54 24 40	 mov	 rdx, QWORD PTR newitem$[rsp]
  001ec	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 59   :     return 0;

  001f0	33 c0		 xor	 eax, eax
$LN8@siftdown:

; 60   : }

  001f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f6	c3		 ret	 0
_siftdown ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyList_SetSlice:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_heapqmodule.c
pdata	SEGMENT
$pdata$heappop DD imagerel heappop
	DD	imagerel heappop+278
	DD	imagerel $unwind$heappop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$heappop DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT heappop
_TEXT	SEGMENT
n$ = 32
lastelt$ = 40
returnitem$ = 48
self$ = 80
heap$ = 88
heappop	PROC						; COMDAT

; 153  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 154  :     PyObject *lastelt, *returnitem;
; 155  :     Py_ssize_t n;
; 156  : 
; 157  :     if (!PyList_Check(heap)) {

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR heap$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00022	85 c0		 test	 eax, eax
  00024	75 1a		 jne	 SHORT $LN4@heappop

; 158  :         PyErr_SetString(PyExc_TypeError, "heap argument must be a list");

  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00034	e8 00 00 00 00	 call	 PyErr_SetString

; 159  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 d1 00 00 00	 jmp	 $LN5@heappop
$LN4@heappop:

; 160  :     }
; 161  : 
; 162  :     /* # raises appropriate IndexError if heap is empty */
; 163  :     n = PyList_GET_SIZE(heap);

  00040	48 8b 44 24 58	 mov	 rax, QWORD PTR heap$[rsp]
  00045	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00049	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 164  :     if (n == 0) {

  0004e	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  00054	75 1a		 jne	 SHORT $LN3@heappop

; 165  :         PyErr_SetString(PyExc_IndexError, "index out of range");

  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  0005d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00064	e8 00 00 00 00	 call	 PyErr_SetString

; 166  :         return NULL;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 a1 00 00 00	 jmp	 $LN5@heappop
$LN3@heappop:

; 167  :     }
; 168  : 
; 169  :     lastelt = PyList_GET_ITEM(heap, n-1) ;

  00070	48 8b 44 24 58	 mov	 rax, QWORD PTR heap$[rsp]
  00075	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  0007e	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  00083	48 89 44 24 28	 mov	 QWORD PTR lastelt$[rsp], rax

; 170  :     Py_INCREF(lastelt);

  00088	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lastelt$[rsp]
  0008d	e8 00 00 00 00	 call	 _Py_IncRef

; 171  :     PyList_SetSlice(heap, n-1, n, NULL);

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00097	48 ff c8	 dec	 rax
  0009a	45 33 c9	 xor	 r9d, r9d
  0009d	4c 8b 44 24 20	 mov	 r8, QWORD PTR n$[rsp]
  000a2	48 8b d0	 mov	 rdx, rax
  000a5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR heap$[rsp]
  000aa	e8 00 00 00 00	 call	 PyList_SetSlice

; 172  :     n--;

  000af	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000b4	48 ff c8	 dec	 rax
  000b7	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 173  : 
; 174  :     if (!n)

  000bc	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  000c2	75 07		 jne	 SHORT $LN2@heappop

; 175  :         return lastelt;

  000c4	48 8b 44 24 28	 mov	 rax, QWORD PTR lastelt$[rsp]
  000c9	eb 46		 jmp	 SHORT $LN5@heappop
$LN2@heappop:

; 176  :     returnitem = PyList_GET_ITEM(heap, 0);

  000cb	48 8b 44 24 58	 mov	 rax, QWORD PTR heap$[rsp]
  000d0	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000d4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d7	48 89 44 24 30	 mov	 QWORD PTR returnitem$[rsp], rax

; 177  :     PyList_SET_ITEM(heap, 0, lastelt);

  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR heap$[rsp]
  000e1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000e5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lastelt$[rsp]
  000ea	48 89 08	 mov	 QWORD PTR [rax], rcx

; 178  :     if (_siftup((PyListObject *)heap, 0) == -1) {

  000ed	33 d2		 xor	 edx, edx
  000ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR heap$[rsp]
  000f4	e8 00 00 00 00	 call	 _siftup
  000f9	83 f8 ff	 cmp	 eax, -1
  000fc	75 0e		 jne	 SHORT $LN1@heappop

; 179  :         Py_DECREF(returnitem);

  000fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR returnitem$[rsp]
  00103	e8 00 00 00 00	 call	 _Py_DecRef

; 180  :         return NULL;

  00108	33 c0		 xor	 eax, eax
  0010a	eb 05		 jmp	 SHORT $LN5@heappop
$LN1@heappop:

; 181  :     }
; 182  :     return returnitem;

  0010c	48 8b 44 24 30	 mov	 rax, QWORD PTR returnitem$[rsp]
$LN5@heappop:

; 183  : }

  00111	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00115	c3		 ret	 0
heappop	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_siftup DD imagerel _siftup
	DD	imagerel _siftup+681
	DD	imagerel $unwind$_siftup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_siftup DD 010e01H
	DD	0e20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _siftup
_TEXT	SEGMENT
tmp$ = 32
endpos$ = 40
size$ = 48
rightpos$ = 56
olditem$ = 64
newitem$ = 72
startpos$ = 80
cmp$ = 88
childpos$ = 96
heap$ = 128
pos$ = 136
_siftup	PROC						; COMDAT

; 64   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 65   :     Py_ssize_t startpos, endpos, childpos, rightpos;
; 66   :     int cmp;
; 67   :     PyObject *newitem, *tmp, *olditem;
; 68   :     Py_ssize_t size;
; 69   : 
; 70   :     assert(PyList_Check(heap));

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  00016	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00020	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00025	85 c0		 test	 eax, eax
  00027	75 1c		 jne	 SHORT $LN11@siftup
  00029	41 b8 46 00 00
	00		 mov	 r8d, 70			; 00000046H
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@OBGAKPOF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAh?$AAe?$AAa?$AAp?$AAq?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@ELEBHPKK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAa?$AAp?$AA?$CJ?$AA?$AA@
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00043	33 c0		 xor	 eax, eax
$LN11@siftup:

; 71   :     size = PyList_GET_SIZE(heap);

  00045	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  0004d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00051	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 72   :     endpos = size;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  0005b	48 89 44 24 28	 mov	 QWORD PTR endpos$[rsp], rax

; 73   :     startpos = pos;

  00060	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pos$[rsp]
  00068	48 89 44 24 50	 mov	 QWORD PTR startpos$[rsp], rax

; 74   :     if (pos >= endpos) {

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR endpos$[rsp]
  00072	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR pos$[rsp], rax
  0007a	7c 1d		 jl	 SHORT $LN8@siftup

; 75   :         PyErr_SetString(PyExc_IndexError, "index out of range");

  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  00083	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0008a	e8 00 00 00 00	 call	 PyErr_SetString

; 76   :         return -1;

  0008f	b8 ff ff ff ff	 mov	 eax, -1
  00094	e9 0b 02 00 00	 jmp	 $LN9@siftup
$LN8@siftup:

; 77   :     }
; 78   :     newitem = PyList_GET_ITEM(heap, pos);

  00099	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  000a1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000a5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pos$[rsp]
  000ad	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000b1	48 89 44 24 48	 mov	 QWORD PTR newitem$[rsp], rax

; 79   :     Py_INCREF(newitem);

  000b6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newitem$[rsp]
  000bb	e8 00 00 00 00	 call	 _Py_IncRef

; 80   : 
; 81   :     /* Bubble up the smaller child until hitting a leaf. */
; 82   :     childpos = 2*pos + 1;    /* leftmost child position  */

  000c0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pos$[rsp]
  000c8	48 8d 44 00 01	 lea	 rax, QWORD PTR [rax+rax+1]
  000cd	48 89 44 24 60	 mov	 QWORD PTR childpos$[rsp], rax
$LN7@siftup:

; 83   :     while (childpos < endpos) {

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR endpos$[rsp]
  000d7	48 39 44 24 60	 cmp	 QWORD PTR childpos$[rsp], rax
  000dc	0f 8d 6e 01 00
	00		 jge	 $LN6@siftup

; 84   :         /* Set childpos to index of smaller child.   */
; 85   :         rightpos = childpos + 1;

  000e2	48 8b 44 24 60	 mov	 rax, QWORD PTR childpos$[rsp]
  000e7	48 ff c0	 inc	 rax
  000ea	48 89 44 24 38	 mov	 QWORD PTR rightpos$[rsp], rax

; 86   :         if (rightpos < endpos) {

  000ef	48 8b 44 24 28	 mov	 rax, QWORD PTR endpos$[rsp]
  000f4	48 39 44 24 38	 cmp	 QWORD PTR rightpos$[rsp], rax
  000f9	7d 62		 jge	 SHORT $LN5@siftup

; 87   :             cmp = PyObject_RichCompareBool(
; 88   :                 PyList_GET_ITEM(heap, childpos),
; 89   :                 PyList_GET_ITEM(heap, rightpos),
; 90   :                 Py_LT);

  000fb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  00103	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00107	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR heap$[rsp]
  0010f	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00113	45 33 c0	 xor	 r8d, r8d
  00116	48 8b 54 24 38	 mov	 rdx, QWORD PTR rightpos$[rsp]
  0011b	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]
  0011f	48 8b 44 24 60	 mov	 rax, QWORD PTR childpos$[rsp]
  00124	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00128	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0012d	89 44 24 58	 mov	 DWORD PTR cmp$[rsp], eax

; 91   :             if (cmp == -1) {

  00131	83 7c 24 58 ff	 cmp	 DWORD PTR cmp$[rsp], -1
  00136	75 14		 jne	 SHORT $LN4@siftup

; 92   :                 Py_DECREF(newitem);

  00138	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newitem$[rsp]
  0013d	e8 00 00 00 00	 call	 _Py_DecRef

; 93   :                 return -1;

  00142	b8 ff ff ff ff	 mov	 eax, -1
  00147	e9 58 01 00 00	 jmp	 $LN9@siftup
$LN4@siftup:

; 94   :             }
; 95   :             if (cmp == 0)

  0014c	83 7c 24 58 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00151	75 0a		 jne	 SHORT $LN3@siftup

; 96   :                 childpos = rightpos;

  00153	48 8b 44 24 38	 mov	 rax, QWORD PTR rightpos$[rsp]
  00158	48 89 44 24 60	 mov	 QWORD PTR childpos$[rsp], rax
$LN3@siftup:
$LN5@siftup:

; 97   :         }
; 98   :         if (size != PyList_GET_SIZE(heap)) {

  0015d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  00165	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00169	48 39 44 24 30	 cmp	 QWORD PTR size$[rsp], rax
  0016e	74 27		 je	 SHORT $LN2@siftup

; 99   :             Py_DECREF(newitem);

  00170	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newitem$[rsp]
  00175	e8 00 00 00 00	 call	 _Py_DecRef

; 100  :             PyErr_SetString(PyExc_RuntimeError,
; 101  :                             "list changed size during iteration");

  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@
  00181	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00188	e8 00 00 00 00	 call	 PyErr_SetString

; 102  :             return -1;

  0018d	b8 ff ff ff ff	 mov	 eax, -1
  00192	e9 0d 01 00 00	 jmp	 $LN9@siftup
$LN2@siftup:

; 103  :         }
; 104  :         /* Move the smaller child up. */
; 105  :         tmp = PyList_GET_ITEM(heap, childpos);

  00197	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  0019f	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR childpos$[rsp]
  001a8	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  001ac	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 106  :         Py_INCREF(tmp);

  001b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  001b6	e8 00 00 00 00	 call	 _Py_IncRef

; 107  :         olditem = PyList_GET_ITEM(heap, pos);

  001bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  001c3	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001c7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pos$[rsp]
  001cf	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  001d3	48 89 44 24 40	 mov	 QWORD PTR olditem$[rsp], rax

; 108  :         PyList_SET_ITEM(heap, pos, tmp);

  001d8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  001e0	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001e4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pos$[rsp]
  001ec	48 8b 54 24 20	 mov	 rdx, QWORD PTR tmp$[rsp]
  001f1	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 109  :         Py_DECREF(olditem);

  001f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR olditem$[rsp]
  001fa	e8 00 00 00 00	 call	 _Py_DecRef

; 110  :         pos = childpos;

  001ff	48 8b 44 24 60	 mov	 rax, QWORD PTR childpos$[rsp]
  00204	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 111  :         childpos = 2*pos + 1;

  0020c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pos$[rsp]
  00214	48 8d 44 00 01	 lea	 rax, QWORD PTR [rax+rax+1]
  00219	48 89 44 24 60	 mov	 QWORD PTR childpos$[rsp], rax

; 112  :         if (size != PyList_GET_SIZE(heap)) {

  0021e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  00226	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0022a	48 39 44 24 30	 cmp	 QWORD PTR size$[rsp], rax
  0022f	74 1a		 je	 SHORT $LN1@siftup

; 113  :             PyErr_SetString(PyExc_RuntimeError,
; 114  :                             "list changed size during iteration");

  00231	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@
  00238	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0023f	e8 00 00 00 00	 call	 PyErr_SetString

; 115  :             return -1;

  00244	b8 ff ff ff ff	 mov	 eax, -1
  00249	eb 59		 jmp	 SHORT $LN9@siftup
$LN1@siftup:

; 116  :         }
; 117  :     }

  0024b	e9 82 fe ff ff	 jmp	 $LN7@siftup
$LN6@siftup:

; 118  : 
; 119  :     /* The leaf at pos is empty now.  Put newitem there, and bubble
; 120  :        it up to its final resting place (by sifting its parents down). */
; 121  :     Py_DECREF(PyList_GET_ITEM(heap, pos));

  00250	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  00258	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0025c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pos$[rsp]
  00264	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00268	e8 00 00 00 00	 call	 _Py_DecRef

; 122  :     PyList_SET_ITEM(heap, pos, newitem);

  0026d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR heap$[rsp]
  00275	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00279	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pos$[rsp]
  00281	48 8b 54 24 48	 mov	 rdx, QWORD PTR newitem$[rsp]
  00286	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 123  :     return _siftdown(heap, startpos, pos);

  0028a	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  00292	48 8b 54 24 50	 mov	 rdx, QWORD PTR startpos$[rsp]
  00297	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR heap$[rsp]
  0029f	e8 00 00 00 00	 call	 _siftdown
$LN9@siftup:

; 124  : }

  002a4	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002a8	c3		 ret	 0
_siftup	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$heapreplace DD imagerel heapreplace
	DD	imagerel heapreplace+241
	DD	imagerel $unwind$heapreplace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$heapreplace DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT heapreplace
_TEXT	SEGMENT
returnitem$ = 48
heap$ = 56
item$ = 64
self$ = 96
args$ = 104
heapreplace PROC					; COMDAT

; 190  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 191  :     PyObject *heap, *item, *returnitem;
; 192  : 
; 193  :     if (!PyArg_UnpackTuple(args, "heapreplace", 2, 2, &heap, &item))

  0000e	48 8d 44 24 40	 lea	 rax, QWORD PTR item$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00018	48 8d 44 24 38	 lea	 rax, QWORD PTR heap$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	41 b9 02 00 00
	00		 mov	 r9d, 2
  00028	41 b8 02 00 00
	00		 mov	 r8d, 2
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@PEOLKNFI@heapreplace?$AA@
  00035	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0003a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003f	85 c0		 test	 eax, eax
  00041	75 07		 jne	 SHORT $LN4@heapreplac

; 194  :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 a2 00 00 00	 jmp	 $LN5@heapreplac
$LN4@heapreplac:

; 195  : 
; 196  :     if (!PyList_Check(heap)) {

  0004a	48 8b 44 24 38	 mov	 rax, QWORD PTR heap$[rsp]
  0004f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00053	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00059	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0005e	85 c0		 test	 eax, eax
  00060	75 17		 jne	 SHORT $LN3@heapreplac

; 197  :         PyErr_SetString(PyExc_TypeError, "heap argument must be a list");

  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
  00069	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00070	e8 00 00 00 00	 call	 PyErr_SetString

; 198  :         return NULL;

  00075	33 c0		 xor	 eax, eax
  00077	eb 73		 jmp	 SHORT $LN5@heapreplac
$LN3@heapreplac:

; 199  :     }
; 200  : 
; 201  :     if (PyList_GET_SIZE(heap) < 1) {

  00079	48 8b 44 24 38	 mov	 rax, QWORD PTR heap$[rsp]
  0007e	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  00083	7d 17		 jge	 SHORT $LN2@heapreplac

; 202  :         PyErr_SetString(PyExc_IndexError, "index out of range");

  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  0008c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00093	e8 00 00 00 00	 call	 PyErr_SetString

; 203  :         return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	eb 50		 jmp	 SHORT $LN5@heapreplac
$LN2@heapreplac:

; 204  :     }
; 205  : 
; 206  :     returnitem = PyList_GET_ITEM(heap, 0);

  0009c	48 8b 44 24 38	 mov	 rax, QWORD PTR heap$[rsp]
  000a1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000a5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a8	48 89 44 24 30	 mov	 QWORD PTR returnitem$[rsp], rax

; 207  :     Py_INCREF(item);

  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  000b2	e8 00 00 00 00	 call	 _Py_IncRef

; 208  :     PyList_SET_ITEM(heap, 0, item);

  000b7	48 8b 44 24 38	 mov	 rax, QWORD PTR heap$[rsp]
  000bc	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  000c5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 209  :     if (_siftup((PyListObject *)heap, 0) == -1) {

  000c8	33 d2		 xor	 edx, edx
  000ca	48 8b 4c 24 38	 mov	 rcx, QWORD PTR heap$[rsp]
  000cf	e8 00 00 00 00	 call	 _siftup
  000d4	83 f8 ff	 cmp	 eax, -1
  000d7	75 0e		 jne	 SHORT $LN1@heapreplac

; 210  :         Py_DECREF(returnitem);

  000d9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR returnitem$[rsp]
  000de	e8 00 00 00 00	 call	 _Py_DecRef

; 211  :         return NULL;

  000e3	33 c0		 xor	 eax, eax
  000e5	eb 05		 jmp	 SHORT $LN5@heapreplac
$LN1@heapreplac:

; 212  :     }
; 213  :     return returnitem;

  000e7	48 8b 44 24 30	 mov	 rax, QWORD PTR returnitem$[rsp]
$LN5@heapreplac:

; 214  : }

  000ec	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f0	c3		 ret	 0
heapreplace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$heappushpop DD imagerel heappushpop
	DD	imagerel heappushpop+305
	DD	imagerel $unwind$heappushpop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$heappushpop DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT heappushpop
_TEXT	SEGMENT
returnitem$ = 48
heap$ = 56
item$ = 64
cmp$ = 72
self$ = 96
args$ = 104
heappushpop PROC					; COMDAT

; 228  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 229  :     PyObject *heap, *item, *returnitem;
; 230  :     int cmp;
; 231  : 
; 232  :     if (!PyArg_UnpackTuple(args, "heappushpop", 2, 2, &heap, &item))

  0000e	48 8d 44 24 40	 lea	 rax, QWORD PTR item$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00018	48 8d 44 24 38	 lea	 rax, QWORD PTR heap$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	41 b9 02 00 00
	00		 mov	 r9d, 2
  00028	41 b8 02 00 00
	00		 mov	 r8d, 2
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@HEAOMNAP@heappushpop?$AA@
  00035	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0003a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003f	85 c0		 test	 eax, eax
  00041	75 07		 jne	 SHORT $LN6@heappushpo

; 233  :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 e2 00 00 00	 jmp	 $LN7@heappushpo
$LN6@heappushpo:

; 234  : 
; 235  :     if (!PyList_Check(heap)) {

  0004a	48 8b 44 24 38	 mov	 rax, QWORD PTR heap$[rsp]
  0004f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00053	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00059	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0005e	85 c0		 test	 eax, eax
  00060	75 1a		 jne	 SHORT $LN5@heappushpo

; 236  :         PyErr_SetString(PyExc_TypeError, "heap argument must be a list");

  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
  00069	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00070	e8 00 00 00 00	 call	 PyErr_SetString

; 237  :         return NULL;

  00075	33 c0		 xor	 eax, eax
  00077	e9 b0 00 00 00	 jmp	 $LN7@heappushpo
$LN5@heappushpo:

; 238  :     }
; 239  : 
; 240  :     if (PyList_GET_SIZE(heap) < 1) {

  0007c	48 8b 44 24 38	 mov	 rax, QWORD PTR heap$[rsp]
  00081	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  00086	7d 14		 jge	 SHORT $LN4@heappushpo

; 241  :         Py_INCREF(item);

  00088	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  0008d	e8 00 00 00 00	 call	 _Py_IncRef

; 242  :         return item;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
  00097	e9 90 00 00 00	 jmp	 $LN7@heappushpo
$LN4@heappushpo:

; 243  :     }
; 244  : 
; 245  :     cmp = PyObject_RichCompareBool(PyList_GET_ITEM(heap, 0), item, Py_LT);

  0009c	48 8b 44 24 38	 mov	 rax, QWORD PTR heap$[rsp]
  000a1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000a5	45 33 c0	 xor	 r8d, r8d
  000a8	48 8b 54 24 40	 mov	 rdx, QWORD PTR item$[rsp]
  000ad	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000b0	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000b5	89 44 24 48	 mov	 DWORD PTR cmp$[rsp], eax

; 246  :     if (cmp == -1)

  000b9	83 7c 24 48 ff	 cmp	 DWORD PTR cmp$[rsp], -1
  000be	75 04		 jne	 SHORT $LN3@heappushpo

; 247  :         return NULL;

  000c0	33 c0		 xor	 eax, eax
  000c2	eb 68		 jmp	 SHORT $LN7@heappushpo
$LN3@heappushpo:

; 248  :     if (cmp == 0) {

  000c4	83 7c 24 48 00	 cmp	 DWORD PTR cmp$[rsp], 0
  000c9	75 11		 jne	 SHORT $LN2@heappushpo

; 249  :         Py_INCREF(item);

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_IncRef

; 250  :         return item;

  000d5	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
  000da	eb 50		 jmp	 SHORT $LN7@heappushpo
$LN2@heappushpo:

; 251  :     }
; 252  : 
; 253  :     returnitem = PyList_GET_ITEM(heap, 0);

  000dc	48 8b 44 24 38	 mov	 rax, QWORD PTR heap$[rsp]
  000e1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000e5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e8	48 89 44 24 30	 mov	 QWORD PTR returnitem$[rsp], rax

; 254  :     Py_INCREF(item);

  000ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  000f2	e8 00 00 00 00	 call	 _Py_IncRef

; 255  :     PyList_SET_ITEM(heap, 0, item);

  000f7	48 8b 44 24 38	 mov	 rax, QWORD PTR heap$[rsp]
  000fc	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00100	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  00105	48 89 08	 mov	 QWORD PTR [rax], rcx

; 256  :     if (_siftup((PyListObject *)heap, 0) == -1) {

  00108	33 d2		 xor	 edx, edx
  0010a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR heap$[rsp]
  0010f	e8 00 00 00 00	 call	 _siftup
  00114	83 f8 ff	 cmp	 eax, -1
  00117	75 0e		 jne	 SHORT $LN1@heappushpo

; 257  :         Py_DECREF(returnitem);

  00119	48 8b 4c 24 30	 mov	 rcx, QWORD PTR returnitem$[rsp]
  0011e	e8 00 00 00 00	 call	 _Py_DecRef

; 258  :         return NULL;

  00123	33 c0		 xor	 eax, eax
  00125	eb 05		 jmp	 SHORT $LN7@heappushpo
$LN1@heappushpo:

; 259  :     }
; 260  :     return returnitem;

  00127	48 8b 44 24 30	 mov	 rax, QWORD PTR returnitem$[rsp]
$LN7@heappushpo:

; 261  : }

  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	c3		 ret	 0
heappushpop ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$heapify DD imagerel heapify
	DD	imagerel heapify+169
	DD	imagerel $unwind$heapify
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$heapify DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT heapify
_TEXT	SEGMENT
n$ = 32
i$ = 40
self$ = 64
heap$ = 72
heapify	PROC						; COMDAT

; 270  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 271  :     Py_ssize_t i, n;
; 272  : 
; 273  :     if (!PyList_Check(heap)) {

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR heap$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00022	85 c0		 test	 eax, eax
  00024	75 17		 jne	 SHORT $LN5@heapify

; 274  :         PyErr_SetString(PyExc_TypeError, "heap argument must be a list");

  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00034	e8 00 00 00 00	 call	 PyErr_SetString

; 275  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 67		 jmp	 SHORT $LN6@heapify
$LN5@heapify:

; 276  :     }
; 277  : 
; 278  :     n = PyList_GET_SIZE(heap);

  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR heap$[rsp]
  00042	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00046	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 279  :     /* Transform bottom-up.  The largest index there's any point to
; 280  :        looking at is the largest with a child index in-range, so must
; 281  :        have 2*i + 1 < n, or i < (n-1)/2.  If n is even = 2*j, this is
; 282  :        (2*j-1)/2 = j-1/2 so j-1 is the largest, which is n//2 - 1.  If
; 283  :        n is odd = 2*j+1, this is (2*j+1-1)/2 = j so j-1 is the largest,
; 284  :        and that's again n//2-1.
; 285  :     */
; 286  :     for (i=n/2-1 ; i>=0 ; i--)

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00050	48 99		 cdq
  00052	48 2b c2	 sub	 rax, rdx
  00055	48 d1 f8	 sar	 rax, 1
  00058	48 ff c8	 dec	 rax
  0005b	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00060	eb 0d		 jmp	 SHORT $LN4@heapify
$LN3@heapify:
  00062	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00067	48 ff c8	 dec	 rax
  0006a	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN4@heapify:
  0006f	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00075	7c 1a		 jl	 SHORT $LN2@heapify

; 287  :         if(_siftup((PyListObject *)heap, i) == -1)

  00077	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0007c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR heap$[rsp]
  00081	e8 00 00 00 00	 call	 _siftup
  00086	83 f8 ff	 cmp	 eax, -1
  00089	75 04		 jne	 SHORT $LN1@heapify

; 288  :             return NULL;

  0008b	33 c0		 xor	 eax, eax
  0008d	eb 15		 jmp	 SHORT $LN6@heapify
$LN1@heapify:

; 289  :     Py_INCREF(Py_None);

  0008f	eb d1		 jmp	 SHORT $LN3@heapify
$LN2@heapify:
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00098	e8 00 00 00 00	 call	 _Py_IncRef

; 290  :     return Py_None;

  0009d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN6@heapify:

; 291  : }

  000a4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a8	c3		 ret	 0
heapify	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@DNOILLJA@nO?3nlargest?$AA@		; `string'
EXTRN	PyList_Reverse:PROC
EXTRN	PyList_Sort:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyIter_Next:PROC
EXTRN	PyList_New:PROC
EXTRN	PyObject_GetIter:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$nlargest DD imagerel nlargest
	DD	imagerel nlargest+648
	DD	imagerel $unwind$nlargest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nlargest DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0M@DNOILLJA@nO?3nlargest?$AA@
CONST	SEGMENT
??_C@_0M@DNOILLJA@nO?3nlargest?$AA@ DB 'nO:nlargest', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT nlargest
_TEXT	SEGMENT
it$ = 32
elem$ = 40
n$ = 48
i$ = 56
oldelem$ = 64
heap$ = 72
iterable$ = 80
sol$ = 88
cmp$ = 96
self$ = 128
args$ = 136
nlargest PROC						; COMDAT

; 298  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 299  :     PyObject *heap=NULL, *elem, *iterable, *sol, *it, *oldelem;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR heap$[rsp], 0

; 300  :     Py_ssize_t i, n;
; 301  :     int cmp;
; 302  : 
; 303  :     if (!PyArg_ParseTuple(args, "nO:nlargest", &n, &iterable))

  00017	4c 8d 4c 24 50	 lea	 r9, QWORD PTR iterable$[rsp]
  0001c	4c 8d 44 24 30	 lea	 r8, QWORD PTR n$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@DNOILLJA@nO?3nlargest?$AA@
  00028	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00030	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN29@nlargest

; 304  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 43 02 00 00	 jmp	 $LN30@nlargest
$LN29@nlargest:

; 305  : 
; 306  :     it = PyObject_GetIter(iterable);

  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR iterable$[rsp]
  00045	e8 00 00 00 00	 call	 PyObject_GetIter
  0004a	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 307  :     if (it == NULL)

  0004f	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00055	75 07		 jne	 SHORT $LN28@nlargest

; 308  :         return NULL;

  00057	33 c0		 xor	 eax, eax
  00059	e9 25 02 00 00	 jmp	 $LN30@nlargest
$LN28@nlargest:

; 309  : 
; 310  :     heap = PyList_New(0);

  0005e	33 c9		 xor	 ecx, ecx
  00060	e8 00 00 00 00	 call	 PyList_New
  00065	48 89 44 24 48	 mov	 QWORD PTR heap$[rsp], rax

; 311  :     if (heap == NULL)

  0006a	48 83 7c 24 48
	00		 cmp	 QWORD PTR heap$[rsp], 0
  00070	75 05		 jne	 SHORT $LN27@nlargest

; 312  :         goto fail;

  00072	e9 e8 01 00 00	 jmp	 $fail$20524
$LN27@nlargest:

; 313  : 
; 314  :     for (i=0 ; i<n ; i++ ){

  00077	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00080	eb 0d		 jmp	 SHORT $LN26@nlargest
$LN25@nlargest:
  00082	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00087	48 ff c0	 inc	 rax
  0008a	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN26@nlargest:
  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00094	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00099	7d 5c		 jge	 SHORT $LN24@nlargest

; 315  :         elem = PyIter_Next(it);

  0009b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000a0	e8 00 00 00 00	 call	 PyIter_Next
  000a5	48 89 44 24 28	 mov	 QWORD PTR elem$[rsp], rax

; 316  :         if (elem == NULL) {

  000aa	48 83 7c 24 28
	00		 cmp	 QWORD PTR elem$[rsp], 0
  000b0	75 16		 jne	 SHORT $LN23@nlargest

; 317  :             if (PyErr_Occurred())

  000b2	e8 00 00 00 00	 call	 PyErr_Occurred
  000b7	48 85 c0	 test	 rax, rax
  000ba	74 07		 je	 SHORT $LN22@nlargest

; 318  :                 goto fail;

  000bc	e9 9e 01 00 00	 jmp	 $fail$20524

; 319  :             else

  000c1	eb 05		 jmp	 SHORT $LN21@nlargest
$LN22@nlargest:

; 320  :                 goto sortit;

  000c3	e9 64 01 00 00	 jmp	 $sortit$20532
$LN21@nlargest:
$LN23@nlargest:

; 321  :         }
; 322  :         if (PyList_Append(heap, elem) == -1) {

  000c8	48 8b 54 24 28	 mov	 rdx, QWORD PTR elem$[rsp]
  000cd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR heap$[rsp]
  000d2	e8 00 00 00 00	 call	 PyList_Append
  000d7	83 f8 ff	 cmp	 eax, -1
  000da	75 0f		 jne	 SHORT $LN20@nlargest

; 323  :             Py_DECREF(elem);

  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  000e1	e8 00 00 00 00	 call	 _Py_DecRef

; 324  :             goto fail;

  000e6	e9 74 01 00 00	 jmp	 $fail$20524
$LN20@nlargest:

; 325  :         }
; 326  :         Py_DECREF(elem);

  000eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  000f0	e8 00 00 00 00	 call	 _Py_DecRef

; 327  :     }

  000f5	eb 8b		 jmp	 SHORT $LN25@nlargest
$LN24@nlargest:

; 328  :     if (PyList_GET_SIZE(heap) == 0)

  000f7	48 8b 44 24 48	 mov	 rax, QWORD PTR heap$[rsp]
  000fc	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00101	75 05		 jne	 SHORT $LN19@nlargest

; 329  :         goto sortit;

  00103	e9 24 01 00 00	 jmp	 $sortit$20532
$LN19@nlargest:

; 330  : 
; 331  :     for (i=n/2-1 ; i>=0 ; i--)

  00108	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0010d	48 99		 cdq
  0010f	48 2b c2	 sub	 rax, rdx
  00112	48 d1 f8	 sar	 rax, 1
  00115	48 ff c8	 dec	 rax
  00118	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
  0011d	eb 0d		 jmp	 SHORT $LN18@nlargest
$LN17@nlargest:
  0011f	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00124	48 ff c8	 dec	 rax
  00127	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN18@nlargest:
  0012c	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  00132	7c 1b		 jl	 SHORT $LN16@nlargest

; 332  :         if(_siftup((PyListObject *)heap, i) == -1)

  00134	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  00139	48 8b 4c 24 48	 mov	 rcx, QWORD PTR heap$[rsp]
  0013e	e8 00 00 00 00	 call	 _siftup
  00143	83 f8 ff	 cmp	 eax, -1
  00146	75 05		 jne	 SHORT $LN15@nlargest

; 333  :             goto fail;

  00148	e9 12 01 00 00	 jmp	 $fail$20524
$LN15@nlargest:

; 334  : 
; 335  :     sol = PyList_GET_ITEM(heap, 0);

  0014d	eb d0		 jmp	 SHORT $LN17@nlargest
$LN16@nlargest:
  0014f	48 8b 44 24 48	 mov	 rax, QWORD PTR heap$[rsp]
  00154	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00158	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0015b	48 89 44 24 58	 mov	 QWORD PTR sol$[rsp], rax
$LN32@nlargest:
$LN14@nlargest:

; 336  :     while (1) {

  00160	33 c0		 xor	 eax, eax
  00162	83 f8 01	 cmp	 eax, 1
  00165	0f 84 c1 00 00
	00		 je	 $LN13@nlargest

; 337  :         elem = PyIter_Next(it);

  0016b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00170	e8 00 00 00 00	 call	 PyIter_Next
  00175	48 89 44 24 28	 mov	 QWORD PTR elem$[rsp], rax

; 338  :         if (elem == NULL) {

  0017a	48 83 7c 24 28
	00		 cmp	 QWORD PTR elem$[rsp], 0
  00180	75 16		 jne	 SHORT $LN12@nlargest

; 339  :             if (PyErr_Occurred())

  00182	e8 00 00 00 00	 call	 PyErr_Occurred
  00187	48 85 c0	 test	 rax, rax
  0018a	74 07		 je	 SHORT $LN11@nlargest

; 340  :                 goto fail;

  0018c	e9 ce 00 00 00	 jmp	 $fail$20524

; 341  :             else

  00191	eb 05		 jmp	 SHORT $LN10@nlargest
$LN11@nlargest:

; 342  :                 goto sortit;

  00193	e9 94 00 00 00	 jmp	 $sortit$20532
$LN10@nlargest:
$LN12@nlargest:

; 343  :         }
; 344  :         cmp = PyObject_RichCompareBool(sol, elem, Py_LT);

  00198	45 33 c0	 xor	 r8d, r8d
  0019b	48 8b 54 24 28	 mov	 rdx, QWORD PTR elem$[rsp]
  001a0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sol$[rsp]
  001a5	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  001aa	89 44 24 60	 mov	 DWORD PTR cmp$[rsp], eax

; 345  :         if (cmp == -1) {

  001ae	83 7c 24 60 ff	 cmp	 DWORD PTR cmp$[rsp], -1
  001b3	75 0f		 jne	 SHORT $LN9@nlargest

; 346  :             Py_DECREF(elem);

  001b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  001ba	e8 00 00 00 00	 call	 _Py_DecRef

; 347  :             goto fail;

  001bf	e9 9b 00 00 00	 jmp	 $fail$20524
$LN9@nlargest:

; 348  :         }
; 349  :         if (cmp == 0) {

  001c4	83 7c 24 60 00	 cmp	 DWORD PTR cmp$[rsp], 0
  001c9	75 0c		 jne	 SHORT $LN8@nlargest

; 350  :             Py_DECREF(elem);

  001cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  001d0	e8 00 00 00 00	 call	 _Py_DecRef

; 351  :             continue;

  001d5	eb 89		 jmp	 SHORT $LN14@nlargest
$LN8@nlargest:

; 352  :         }
; 353  :         oldelem = PyList_GET_ITEM(heap, 0);

  001d7	48 8b 44 24 48	 mov	 rax, QWORD PTR heap$[rsp]
  001dc	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001e0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e3	48 89 44 24 40	 mov	 QWORD PTR oldelem$[rsp], rax

; 354  :         PyList_SET_ITEM(heap, 0, elem);

  001e8	48 8b 44 24 48	 mov	 rax, QWORD PTR heap$[rsp]
  001ed	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  001f6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 355  :         Py_DECREF(oldelem);

  001f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR oldelem$[rsp]
  001fe	e8 00 00 00 00	 call	 _Py_DecRef

; 356  :         if (_siftup((PyListObject *)heap, 0) == -1)

  00203	33 d2		 xor	 edx, edx
  00205	48 8b 4c 24 48	 mov	 rcx, QWORD PTR heap$[rsp]
  0020a	e8 00 00 00 00	 call	 _siftup
  0020f	83 f8 ff	 cmp	 eax, -1
  00212	75 02		 jne	 SHORT $LN7@nlargest

; 357  :             goto fail;

  00214	eb 49		 jmp	 SHORT $fail$20524
$LN7@nlargest:

; 358  :         sol = PyList_GET_ITEM(heap, 0);

  00216	48 8b 44 24 48	 mov	 rax, QWORD PTR heap$[rsp]
  0021b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0021f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00222	48 89 44 24 58	 mov	 QWORD PTR sol$[rsp], rax

; 359  :     }

  00227	e9 34 ff ff ff	 jmp	 $LN32@nlargest
$LN13@nlargest:
$sortit$20532:

; 360  : sortit:
; 361  :     if (PyList_Sort(heap) == -1)

  0022c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR heap$[rsp]
  00231	e8 00 00 00 00	 call	 PyList_Sort
  00236	83 f8 ff	 cmp	 eax, -1
  00239	75 02		 jne	 SHORT $LN6@nlargest

; 362  :         goto fail;

  0023b	eb 22		 jmp	 SHORT $fail$20524
$LN6@nlargest:

; 363  :     if (PyList_Reverse(heap) == -1)

  0023d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR heap$[rsp]
  00242	e8 00 00 00 00	 call	 PyList_Reverse
  00247	83 f8 ff	 cmp	 eax, -1
  0024a	75 02		 jne	 SHORT $LN5@nlargest

; 364  :         goto fail;

  0024c	eb 11		 jmp	 SHORT $fail$20524
$LN5@nlargest:

; 365  :     Py_DECREF(it);

  0024e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00253	e8 00 00 00 00	 call	 _Py_DecRef

; 366  :     return heap;

  00258	48 8b 44 24 48	 mov	 rax, QWORD PTR heap$[rsp]
  0025d	eb 24		 jmp	 SHORT $LN30@nlargest
$fail$20524:

; 367  : 
; 368  : fail:
; 369  :     Py_DECREF(it);

  0025f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00264	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@nlargest:

; 370  :     Py_XDECREF(heap);

  00269	48 83 7c 24 48
	00		 cmp	 QWORD PTR heap$[rsp], 0
  0026f	74 0a		 je	 SHORT $LN1@nlargest
  00271	48 8b 4c 24 48	 mov	 rcx, QWORD PTR heap$[rsp]
  00276	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@nlargest:
  0027b	33 c0		 xor	 eax, eax
  0027d	85 c0		 test	 eax, eax
  0027f	75 e8		 jne	 SHORT $LN4@nlargest

; 371  :     return NULL;

  00281	33 c0		 xor	 eax, eax
$LN30@nlargest:

; 372  : }

  00283	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00287	c3		 ret	 0
nlargest ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NOGLFFMF@nO?3nsmallest?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$nsmallest DD imagerel nsmallest
	DD	imagerel nsmallest+641
	DD	imagerel $unwind$nsmallest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nsmallest DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0N@NOGLFFMF@nO?3nsmallest?$AA@
CONST	SEGMENT
??_C@_0N@NOGLFFMF@nO?3nsmallest?$AA@ DB 'nO:nsmallest', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT nsmallest
_TEXT	SEGMENT
it$ = 32
elem$ = 40
n$ = 48
i$ = 56
oldelem$ = 64
los$ = 72
heap$ = 80
iterable$ = 88
cmp$ = 96
self$ = 128
args$ = 136
nsmallest PROC						; COMDAT

; 468  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 469  :     PyObject *heap=NULL, *elem, *iterable, *los, *it, *oldelem;

  0000e	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR heap$[rsp], 0

; 470  :     Py_ssize_t i, n;
; 471  :     int cmp;
; 472  : 
; 473  :     if (!PyArg_ParseTuple(args, "nO:nsmallest", &n, &iterable))

  00017	4c 8d 4c 24 58	 lea	 r9, QWORD PTR iterable$[rsp]
  0001c	4c 8d 44 24 30	 lea	 r8, QWORD PTR n$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NOGLFFMF@nO?3nsmallest?$AA@
  00028	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00030	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN28@nsmallest

; 474  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 3c 02 00 00	 jmp	 $LN29@nsmallest
$LN28@nsmallest:

; 475  : 
; 476  :     it = PyObject_GetIter(iterable);

  00040	48 8b 4c 24 58	 mov	 rcx, QWORD PTR iterable$[rsp]
  00045	e8 00 00 00 00	 call	 PyObject_GetIter
  0004a	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 477  :     if (it == NULL)

  0004f	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00055	75 07		 jne	 SHORT $LN27@nsmallest

; 478  :         return NULL;

  00057	33 c0		 xor	 eax, eax
  00059	e9 1e 02 00 00	 jmp	 $LN29@nsmallest
$LN27@nsmallest:

; 479  : 
; 480  :     heap = PyList_New(0);

  0005e	33 c9		 xor	 ecx, ecx
  00060	e8 00 00 00 00	 call	 PyList_New
  00065	48 89 44 24 50	 mov	 QWORD PTR heap$[rsp], rax

; 481  :     if (heap == NULL)

  0006a	48 83 7c 24 50
	00		 cmp	 QWORD PTR heap$[rsp], 0
  00070	75 05		 jne	 SHORT $LN26@nsmallest

; 482  :         goto fail;

  00072	e9 e1 01 00 00	 jmp	 $fail$20664
$LN26@nsmallest:

; 483  : 
; 484  :     for (i=0 ; i<n ; i++ ){

  00077	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00080	eb 0d		 jmp	 SHORT $LN25@nsmallest
$LN24@nsmallest:
  00082	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00087	48 ff c0	 inc	 rax
  0008a	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN25@nsmallest:
  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00094	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00099	7d 5c		 jge	 SHORT $LN23@nsmallest

; 485  :         elem = PyIter_Next(it);

  0009b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000a0	e8 00 00 00 00	 call	 PyIter_Next
  000a5	48 89 44 24 28	 mov	 QWORD PTR elem$[rsp], rax

; 486  :         if (elem == NULL) {

  000aa	48 83 7c 24 28
	00		 cmp	 QWORD PTR elem$[rsp], 0
  000b0	75 16		 jne	 SHORT $LN22@nsmallest

; 487  :             if (PyErr_Occurred())

  000b2	e8 00 00 00 00	 call	 PyErr_Occurred
  000b7	48 85 c0	 test	 rax, rax
  000ba	74 07		 je	 SHORT $LN21@nsmallest

; 488  :                 goto fail;

  000bc	e9 97 01 00 00	 jmp	 $fail$20664

; 489  :             else

  000c1	eb 05		 jmp	 SHORT $LN20@nsmallest
$LN21@nsmallest:

; 490  :                 goto sortit;

  000c3	e9 6e 01 00 00	 jmp	 $sortit$20672
$LN20@nsmallest:
$LN22@nsmallest:

; 491  :         }
; 492  :         if (PyList_Append(heap, elem) == -1) {

  000c8	48 8b 54 24 28	 mov	 rdx, QWORD PTR elem$[rsp]
  000cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR heap$[rsp]
  000d2	e8 00 00 00 00	 call	 PyList_Append
  000d7	83 f8 ff	 cmp	 eax, -1
  000da	75 0f		 jne	 SHORT $LN19@nsmallest

; 493  :             Py_DECREF(elem);

  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  000e1	e8 00 00 00 00	 call	 _Py_DecRef

; 494  :             goto fail;

  000e6	e9 6d 01 00 00	 jmp	 $fail$20664
$LN19@nsmallest:

; 495  :         }
; 496  :         Py_DECREF(elem);

  000eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  000f0	e8 00 00 00 00	 call	 _Py_DecRef

; 497  :     }

  000f5	eb 8b		 jmp	 SHORT $LN24@nsmallest
$LN23@nsmallest:

; 498  :     n = PyList_GET_SIZE(heap);

  000f7	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  000fc	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00100	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 499  :     if (n == 0)

  00105	48 83 7c 24 30
	00		 cmp	 QWORD PTR n$[rsp], 0
  0010b	75 05		 jne	 SHORT $LN18@nsmallest

; 500  :         goto sortit;

  0010d	e9 24 01 00 00	 jmp	 $sortit$20672
$LN18@nsmallest:

; 501  : 
; 502  :     for (i=n/2-1 ; i>=0 ; i--)

  00112	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00117	48 99		 cdq
  00119	48 2b c2	 sub	 rax, rdx
  0011c	48 d1 f8	 sar	 rax, 1
  0011f	48 ff c8	 dec	 rax
  00122	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
  00127	eb 0d		 jmp	 SHORT $LN17@nsmallest
$LN16@nsmallest:
  00129	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0012e	48 ff c8	 dec	 rax
  00131	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN17@nsmallest:
  00136	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  0013c	7c 1b		 jl	 SHORT $LN15@nsmallest

; 503  :         if(_siftupmax((PyListObject *)heap, i) == -1)

  0013e	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  00143	48 8b 4c 24 50	 mov	 rcx, QWORD PTR heap$[rsp]
  00148	e8 00 00 00 00	 call	 _siftupmax
  0014d	83 f8 ff	 cmp	 eax, -1
  00150	75 05		 jne	 SHORT $LN14@nsmallest

; 504  :             goto fail;

  00152	e9 01 01 00 00	 jmp	 $fail$20664
$LN14@nsmallest:

; 505  : 
; 506  :     los = PyList_GET_ITEM(heap, 0);

  00157	eb d0		 jmp	 SHORT $LN16@nsmallest
$LN15@nsmallest:
  00159	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  0015e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00162	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00165	48 89 44 24 48	 mov	 QWORD PTR los$[rsp], rax
$LN31@nsmallest:
$LN13@nsmallest:

; 507  :     while (1) {

  0016a	33 c0		 xor	 eax, eax
  0016c	83 f8 01	 cmp	 eax, 1
  0016f	0f 84 c1 00 00
	00		 je	 $LN12@nsmallest

; 508  :         elem = PyIter_Next(it);

  00175	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0017a	e8 00 00 00 00	 call	 PyIter_Next
  0017f	48 89 44 24 28	 mov	 QWORD PTR elem$[rsp], rax

; 509  :         if (elem == NULL) {

  00184	48 83 7c 24 28
	00		 cmp	 QWORD PTR elem$[rsp], 0
  0018a	75 16		 jne	 SHORT $LN11@nsmallest

; 510  :             if (PyErr_Occurred())

  0018c	e8 00 00 00 00	 call	 PyErr_Occurred
  00191	48 85 c0	 test	 rax, rax
  00194	74 07		 je	 SHORT $LN10@nsmallest

; 511  :                 goto fail;

  00196	e9 bd 00 00 00	 jmp	 $fail$20664

; 512  :             else

  0019b	eb 05		 jmp	 SHORT $LN9@nsmallest
$LN10@nsmallest:

; 513  :                 goto sortit;

  0019d	e9 94 00 00 00	 jmp	 $sortit$20672
$LN9@nsmallest:
$LN11@nsmallest:

; 514  :         }
; 515  :         cmp = PyObject_RichCompareBool(elem, los, Py_LT);

  001a2	45 33 c0	 xor	 r8d, r8d
  001a5	48 8b 54 24 48	 mov	 rdx, QWORD PTR los$[rsp]
  001aa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  001af	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  001b4	89 44 24 60	 mov	 DWORD PTR cmp$[rsp], eax

; 516  :         if (cmp == -1) {

  001b8	83 7c 24 60 ff	 cmp	 DWORD PTR cmp$[rsp], -1
  001bd	75 0f		 jne	 SHORT $LN8@nsmallest

; 517  :             Py_DECREF(elem);

  001bf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  001c4	e8 00 00 00 00	 call	 _Py_DecRef

; 518  :             goto fail;

  001c9	e9 8a 00 00 00	 jmp	 $fail$20664
$LN8@nsmallest:

; 519  :         }
; 520  :         if (cmp == 0) {

  001ce	83 7c 24 60 00	 cmp	 DWORD PTR cmp$[rsp], 0
  001d3	75 0c		 jne	 SHORT $LN7@nsmallest

; 521  :             Py_DECREF(elem);

  001d5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  001da	e8 00 00 00 00	 call	 _Py_DecRef

; 522  :             continue;

  001df	eb 89		 jmp	 SHORT $LN13@nsmallest
$LN7@nsmallest:

; 523  :         }
; 524  : 
; 525  :         oldelem = PyList_GET_ITEM(heap, 0);

  001e1	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  001e6	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001ea	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ed	48 89 44 24 40	 mov	 QWORD PTR oldelem$[rsp], rax

; 526  :         PyList_SET_ITEM(heap, 0, elem);

  001f2	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  001f7	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR elem$[rsp]
  00200	48 89 08	 mov	 QWORD PTR [rax], rcx

; 527  :         Py_DECREF(oldelem);

  00203	48 8b 4c 24 40	 mov	 rcx, QWORD PTR oldelem$[rsp]
  00208	e8 00 00 00 00	 call	 _Py_DecRef

; 528  :         if (_siftupmax((PyListObject *)heap, 0) == -1)

  0020d	33 d2		 xor	 edx, edx
  0020f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR heap$[rsp]
  00214	e8 00 00 00 00	 call	 _siftupmax
  00219	83 f8 ff	 cmp	 eax, -1
  0021c	75 02		 jne	 SHORT $LN6@nsmallest

; 529  :             goto fail;

  0021e	eb 38		 jmp	 SHORT $fail$20664
$LN6@nsmallest:

; 530  :         los = PyList_GET_ITEM(heap, 0);

  00220	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  00225	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00229	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0022c	48 89 44 24 48	 mov	 QWORD PTR los$[rsp], rax

; 531  :     }

  00231	e9 34 ff ff ff	 jmp	 $LN31@nsmallest
$LN12@nsmallest:
$sortit$20672:

; 532  : 
; 533  : sortit:
; 534  :     if (PyList_Sort(heap) == -1)

  00236	48 8b 4c 24 50	 mov	 rcx, QWORD PTR heap$[rsp]
  0023b	e8 00 00 00 00	 call	 PyList_Sort
  00240	83 f8 ff	 cmp	 eax, -1
  00243	75 02		 jne	 SHORT $LN5@nsmallest

; 535  :         goto fail;

  00245	eb 11		 jmp	 SHORT $fail$20664
$LN5@nsmallest:

; 536  :     Py_DECREF(it);

  00247	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0024c	e8 00 00 00 00	 call	 _Py_DecRef

; 537  :     return heap;

  00251	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  00256	eb 24		 jmp	 SHORT $LN29@nsmallest
$fail$20664:

; 538  : 
; 539  : fail:
; 540  :     Py_DECREF(it);

  00258	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0025d	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@nsmallest:

; 541  :     Py_XDECREF(heap);

  00262	48 83 7c 24 50
	00		 cmp	 QWORD PTR heap$[rsp], 0
  00268	74 0a		 je	 SHORT $LN1@nsmallest
  0026a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR heap$[rsp]
  0026f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@nsmallest:
  00274	33 c0		 xor	 eax, eax
  00276	85 c0		 test	 eax, eax
  00278	75 e8		 jne	 SHORT $LN4@nsmallest

; 542  :     return NULL;

  0027a	33 c0		 xor	 eax, eax
$LN29@nsmallest:

; 543  : }

  0027c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00280	c3		 ret	 0
nsmallest ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_siftupmax DD imagerel _siftupmax
	DD	imagerel _siftupmax+492
	DD	imagerel $unwind$_siftupmax
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_siftupmax DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _siftupmax
_TEXT	SEGMENT
tmp$ = 32
endpos$ = 40
rightpos$ = 48
newitem$ = 56
startpos$ = 64
cmp$ = 72
childpos$ = 80
heap$ = 112
pos$ = 120
_siftupmax PROC						; COMDAT

; 418  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 419  :     Py_ssize_t startpos, endpos, childpos, rightpos;
; 420  :     int cmp;
; 421  :     PyObject *newitem, *tmp;
; 422  : 
; 423  :     assert(PyList_Check(heap));

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR heap$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00022	85 c0		 test	 eax, eax
  00024	75 1c		 jne	 SHORT $LN9@siftupmax
  00026	41 b8 a7 01 00
	00		 mov	 r8d, 423		; 000001a7H
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@OBGAKPOF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAh?$AAe?$AAa?$AAp?$AAq?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@ELEBHPKK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAa?$AAp?$AA?$CJ?$AA?$AA@
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00040	33 c0		 xor	 eax, eax
$LN9@siftupmax:

; 424  :     endpos = PyList_GET_SIZE(heap);

  00042	48 8b 44 24 70	 mov	 rax, QWORD PTR heap$[rsp]
  00047	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004b	48 89 44 24 28	 mov	 QWORD PTR endpos$[rsp], rax

; 425  :     startpos = pos;

  00050	48 8b 44 24 78	 mov	 rax, QWORD PTR pos$[rsp]
  00055	48 89 44 24 40	 mov	 QWORD PTR startpos$[rsp], rax

; 426  :     if (pos >= endpos) {

  0005a	48 8b 44 24 28	 mov	 rax, QWORD PTR endpos$[rsp]
  0005f	48 39 44 24 78	 cmp	 QWORD PTR pos$[rsp], rax
  00064	7c 1d		 jl	 SHORT $LN6@siftupmax

; 427  :         PyErr_SetString(PyExc_IndexError, "index out of range");

  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00074	e8 00 00 00 00	 call	 PyErr_SetString

; 428  :         return -1;

  00079	b8 ff ff ff ff	 mov	 eax, -1
  0007e	e9 64 01 00 00	 jmp	 $LN7@siftupmax
$LN6@siftupmax:

; 429  :     }
; 430  :     newitem = PyList_GET_ITEM(heap, pos);

  00083	48 8b 44 24 70	 mov	 rax, QWORD PTR heap$[rsp]
  00088	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0008c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pos$[rsp]
  00091	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00095	48 89 44 24 38	 mov	 QWORD PTR newitem$[rsp], rax

; 431  :     Py_INCREF(newitem);

  0009a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR newitem$[rsp]
  0009f	e8 00 00 00 00	 call	 _Py_IncRef

; 432  : 
; 433  :     /* Bubble up the smaller child until hitting a leaf. */
; 434  :     childpos = 2*pos + 1;    /* leftmost child position  */

  000a4	48 8b 44 24 78	 mov	 rax, QWORD PTR pos$[rsp]
  000a9	48 8d 44 00 01	 lea	 rax, QWORD PTR [rax+rax+1]
  000ae	48 89 44 24 50	 mov	 QWORD PTR childpos$[rsp], rax
$LN5@siftupmax:

; 435  :     while (childpos < endpos) {

  000b3	48 8b 44 24 28	 mov	 rax, QWORD PTR endpos$[rsp]
  000b8	48 39 44 24 50	 cmp	 QWORD PTR childpos$[rsp], rax
  000bd	0f 8d e2 00 00
	00		 jge	 $LN4@siftupmax

; 436  :         /* Set childpos to index of smaller child.   */
; 437  :         rightpos = childpos + 1;

  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR childpos$[rsp]
  000c8	48 ff c0	 inc	 rax
  000cb	48 89 44 24 30	 mov	 QWORD PTR rightpos$[rsp], rax

; 438  :         if (rightpos < endpos) {

  000d0	48 8b 44 24 28	 mov	 rax, QWORD PTR endpos$[rsp]
  000d5	48 39 44 24 30	 cmp	 QWORD PTR rightpos$[rsp], rax
  000da	7d 5c		 jge	 SHORT $LN3@siftupmax

; 439  :             cmp = PyObject_RichCompareBool(
; 440  :                 PyList_GET_ITEM(heap, rightpos),
; 441  :                 PyList_GET_ITEM(heap, childpos),
; 442  :                 Py_LT);

  000dc	48 8b 44 24 70	 mov	 rax, QWORD PTR heap$[rsp]
  000e1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR heap$[rsp]
  000ea	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000ee	45 33 c0	 xor	 r8d, r8d
  000f1	48 8b 54 24 50	 mov	 rdx, QWORD PTR childpos$[rsp]
  000f6	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]
  000fa	48 8b 44 24 30	 mov	 rax, QWORD PTR rightpos$[rsp]
  000ff	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00103	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00108	89 44 24 48	 mov	 DWORD PTR cmp$[rsp], eax

; 443  :             if (cmp == -1) {

  0010c	83 7c 24 48 ff	 cmp	 DWORD PTR cmp$[rsp], -1
  00111	75 14		 jne	 SHORT $LN2@siftupmax

; 444  :                 Py_DECREF(newitem);

  00113	48 8b 4c 24 38	 mov	 rcx, QWORD PTR newitem$[rsp]
  00118	e8 00 00 00 00	 call	 _Py_DecRef

; 445  :                 return -1;

  0011d	b8 ff ff ff ff	 mov	 eax, -1
  00122	e9 c0 00 00 00	 jmp	 $LN7@siftupmax
$LN2@siftupmax:

; 446  :             }
; 447  :             if (cmp == 0)

  00127	83 7c 24 48 00	 cmp	 DWORD PTR cmp$[rsp], 0
  0012c	75 0a		 jne	 SHORT $LN1@siftupmax

; 448  :                 childpos = rightpos;

  0012e	48 8b 44 24 30	 mov	 rax, QWORD PTR rightpos$[rsp]
  00133	48 89 44 24 50	 mov	 QWORD PTR childpos$[rsp], rax
$LN1@siftupmax:
$LN3@siftupmax:

; 449  :         }
; 450  :         /* Move the smaller child up. */
; 451  :         tmp = PyList_GET_ITEM(heap, childpos);

  00138	48 8b 44 24 70	 mov	 rax, QWORD PTR heap$[rsp]
  0013d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00141	48 8b 4c 24 50	 mov	 rcx, QWORD PTR childpos$[rsp]
  00146	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0014a	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 452  :         Py_INCREF(tmp);

  0014f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  00154	e8 00 00 00 00	 call	 _Py_IncRef

; 453  :         Py_DECREF(PyList_GET_ITEM(heap, pos));

  00159	48 8b 44 24 70	 mov	 rax, QWORD PTR heap$[rsp]
  0015e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00162	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pos$[rsp]
  00167	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0016b	e8 00 00 00 00	 call	 _Py_DecRef

; 454  :         PyList_SET_ITEM(heap, pos, tmp);

  00170	48 8b 44 24 70	 mov	 rax, QWORD PTR heap$[rsp]
  00175	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00179	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pos$[rsp]
  0017e	48 8b 54 24 20	 mov	 rdx, QWORD PTR tmp$[rsp]
  00183	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 455  :         pos = childpos;

  00187	48 8b 44 24 50	 mov	 rax, QWORD PTR childpos$[rsp]
  0018c	48 89 44 24 78	 mov	 QWORD PTR pos$[rsp], rax

; 456  :         childpos = 2*pos + 1;

  00191	48 8b 44 24 78	 mov	 rax, QWORD PTR pos$[rsp]
  00196	48 8d 44 00 01	 lea	 rax, QWORD PTR [rax+rax+1]
  0019b	48 89 44 24 50	 mov	 QWORD PTR childpos$[rsp], rax

; 457  :     }

  001a0	e9 0e ff ff ff	 jmp	 $LN5@siftupmax
$LN4@siftupmax:

; 458  : 
; 459  :     /* The leaf at pos is empty now.  Put newitem there, and bubble
; 460  :        it up to its final resting place (by sifting its parents down). */
; 461  :     Py_DECREF(PyList_GET_ITEM(heap, pos));

  001a5	48 8b 44 24 70	 mov	 rax, QWORD PTR heap$[rsp]
  001aa	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pos$[rsp]
  001b3	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  001b7	e8 00 00 00 00	 call	 _Py_DecRef

; 462  :     PyList_SET_ITEM(heap, pos, newitem);

  001bc	48 8b 44 24 70	 mov	 rax, QWORD PTR heap$[rsp]
  001c1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001c5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pos$[rsp]
  001ca	48 8b 54 24 38	 mov	 rdx, QWORD PTR newitem$[rsp]
  001cf	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 463  :     return _siftdownmax(heap, startpos, pos);

  001d3	4c 8b 44 24 78	 mov	 r8, QWORD PTR pos$[rsp]
  001d8	48 8b 54 24 40	 mov	 rdx, QWORD PTR startpos$[rsp]
  001dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR heap$[rsp]
  001e2	e8 00 00 00 00	 call	 _siftdownmax
$LN7@siftupmax:

; 464  : }

  001e7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001eb	c3		 ret	 0
_siftupmax ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_siftdownmax DD imagerel _siftdownmax
	DD	imagerel _siftdownmax+386
	DD	imagerel $unwind$_siftdownmax
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_siftdownmax DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _siftdownmax
_TEXT	SEGMENT
parentpos$ = 32
parent$ = 40
newitem$ = 48
cmp$ = 56
heap$ = 80
startpos$ = 88
pos$ = 96
_siftdownmax PROC					; COMDAT

; 381  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 382  :     PyObject *newitem, *parent;
; 383  :     int cmp;
; 384  :     Py_ssize_t parentpos;
; 385  : 
; 386  :     assert(PyList_Check(heap));

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00027	85 c0		 test	 eax, eax
  00029	75 1c		 jne	 SHORT $LN8@siftdownma
  0002b	41 b8 82 01 00
	00		 mov	 r8d, 386		; 00000182H
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@OBGAKPOF@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAh?$AAe?$AAa?$AAp?$AAq?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@ELEBHPKK@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAa?$AAp?$AA?$CJ?$AA?$AA@
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00045	33 c0		 xor	 eax, eax
$LN8@siftdownma:

; 387  :     if (pos >= PyList_GET_SIZE(heap)) {

  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  0004c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00050	48 39 44 24 60	 cmp	 QWORD PTR pos$[rsp], rax
  00055	7c 1d		 jl	 SHORT $LN5@siftdownma

; 388  :         PyErr_SetString(PyExc_IndexError, "index out of range");

  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00065	e8 00 00 00 00	 call	 PyErr_SetString

; 389  :         return -1;

  0006a	b8 ff ff ff ff	 mov	 eax, -1
  0006f	e9 09 01 00 00	 jmp	 $LN6@siftdownma
$LN5@siftdownma:

; 390  :     }
; 391  : 
; 392  :     newitem = PyList_GET_ITEM(heap, pos);

  00074	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  00079	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0007d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pos$[rsp]
  00082	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00086	48 89 44 24 30	 mov	 QWORD PTR newitem$[rsp], rax

; 393  :     Py_INCREF(newitem);

  0008b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newitem$[rsp]
  00090	e8 00 00 00 00	 call	 _Py_IncRef
$LN4@siftdownma:

; 394  :     /* Follow the path to the root, moving parents down until finding
; 395  :        a place newitem fits. */
; 396  :     while (pos > startpos){

  00095	48 8b 44 24 58	 mov	 rax, QWORD PTR startpos$[rsp]
  0009a	48 39 44 24 60	 cmp	 QWORD PTR pos$[rsp], rax
  0009f	0f 8e a8 00 00
	00		 jle	 $LN3@siftdownma

; 397  :         parentpos = (pos - 1) >> 1;

  000a5	48 8b 44 24 60	 mov	 rax, QWORD PTR pos$[rsp]
  000aa	48 ff c8	 dec	 rax
  000ad	48 d1 f8	 sar	 rax, 1
  000b0	48 89 44 24 20	 mov	 QWORD PTR parentpos$[rsp], rax

; 398  :         parent = PyList_GET_ITEM(heap, parentpos);

  000b5	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  000ba	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR parentpos$[rsp]
  000c3	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000c7	48 89 44 24 28	 mov	 QWORD PTR parent$[rsp], rax

; 399  :         cmp = PyObject_RichCompareBool(parent, newitem, Py_LT);

  000cc	45 33 c0	 xor	 r8d, r8d
  000cf	48 8b 54 24 30	 mov	 rdx, QWORD PTR newitem$[rsp]
  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR parent$[rsp]
  000d9	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000de	89 44 24 38	 mov	 DWORD PTR cmp$[rsp], eax

; 400  :         if (cmp == -1) {

  000e2	83 7c 24 38 ff	 cmp	 DWORD PTR cmp$[rsp], -1
  000e7	75 14		 jne	 SHORT $LN2@siftdownma

; 401  :             Py_DECREF(newitem);

  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newitem$[rsp]
  000ee	e8 00 00 00 00	 call	 _Py_DecRef

; 402  :             return -1;

  000f3	b8 ff ff ff ff	 mov	 eax, -1
  000f8	e9 80 00 00 00	 jmp	 $LN6@siftdownma
$LN2@siftdownma:

; 403  :         }
; 404  :         if (cmp == 0)

  000fd	83 7c 24 38 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00102	75 02		 jne	 SHORT $LN1@siftdownma

; 405  :             break;

  00104	eb 47		 jmp	 SHORT $LN3@siftdownma
$LN1@siftdownma:

; 406  :         Py_INCREF(parent);

  00106	48 8b 4c 24 28	 mov	 rcx, QWORD PTR parent$[rsp]
  0010b	e8 00 00 00 00	 call	 _Py_IncRef

; 407  :         Py_DECREF(PyList_GET_ITEM(heap, pos));

  00110	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  00115	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00119	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pos$[rsp]
  0011e	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00122	e8 00 00 00 00	 call	 _Py_DecRef

; 408  :         PyList_SET_ITEM(heap, pos, parent);

  00127	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  0012c	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00130	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pos$[rsp]
  00135	48 8b 54 24 28	 mov	 rdx, QWORD PTR parent$[rsp]
  0013a	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 409  :         pos = parentpos;

  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR parentpos$[rsp]
  00143	48 89 44 24 60	 mov	 QWORD PTR pos$[rsp], rax

; 410  :     }

  00148	e9 48 ff ff ff	 jmp	 $LN4@siftdownma
$LN3@siftdownma:

; 411  :     Py_DECREF(PyList_GET_ITEM(heap, pos));

  0014d	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  00152	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pos$[rsp]
  0015b	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0015f	e8 00 00 00 00	 call	 _Py_DecRef

; 412  :     PyList_SET_ITEM(heap, pos, newitem);

  00164	48 8b 44 24 50	 mov	 rax, QWORD PTR heap$[rsp]
  00169	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0016d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pos$[rsp]
  00172	48 8b 54 24 30	 mov	 rdx, QWORD PTR newitem$[rsp]
  00177	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 413  :     return 0;

  0017b	33 c0		 xor	 eax, eax
$LN6@siftdownma:

; 414  : }

  0017d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00181	c3		 ret	 0
_siftdownmax ENDP
_TEXT	ENDS
PUBLIC	??_C@_09IPOHPEOP@__about__?$AA@			; `string'
PUBLIC	PyInit__heapq
EXTRN	PyModule_AddObject:PROC
EXTRN	PyUnicode_DecodeUTF8:PROC
EXTRN	strlen:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__heapq DD imagerel $LN4
	DD	imagerel $LN4+105
	DD	imagerel $unwind$PyInit__heapq
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__heapq DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_09IPOHPEOP@__about__?$AA@
CONST	SEGMENT
??_C@_09IPOHPEOP@__about__?$AA@ DB '__about__', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit__heapq
_TEXT	SEGMENT
about$ = 32
m$ = 40
PyInit__heapq PROC					; COMDAT

; 708  : {

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 709  :     PyObject *m, *about;
; 710  : 
; 711  :     m = PyModule_Create(&_heapqmodule);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_heapqmodule
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 28	 mov	 QWORD PTR m$[rsp], rax

; 712  :     if (m == NULL)

  0001a	48 83 7c 24 28
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	75 04		 jne	 SHORT $LN1@PyInit__he

; 713  :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	eb 3e		 jmp	 SHORT $LN2@PyInit__he
$LN1@PyInit__he:

; 714  :     about = PyUnicode_DecodeUTF8(__about__, strlen(__about__), NULL);

  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__about__
  0002d	e8 00 00 00 00	 call	 strlen
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b d0	 mov	 rdx, rax
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__about__
  0003f	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  00044	48 89 44 24 20	 mov	 QWORD PTR about$[rsp], rax

; 715  :     PyModule_AddObject(m, "__about__", about);

  00049	4c 8b 44 24 20	 mov	 r8, QWORD PTR about$[rsp]
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09IPOHPEOP@__about__?$AA@
  00055	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  0005a	e8 00 00 00 00	 call	 PyModule_AddObject

; 716  :     return m;

  0005f	48 8b 44 24 28	 mov	 rax, QWORD PTR m$[rsp]
$LN2@PyInit__he:

; 717  : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
PyInit__heapq ENDP
_TEXT	ENDS
END
