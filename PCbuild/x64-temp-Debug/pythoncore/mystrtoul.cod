; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
smallmax DD	00H
	DD	00H
	DD	07fffffffH
	DD	055555555H
	DD	03fffffffH
	DD	033333333H
	DD	02aaaaaaaH
	DD	024924924H
	DD	01fffffffH
	DD	01c71c71cH
	DD	019999999H
	DD	01745d174H
	DD	015555555H
	DD	013b13b13H
	DD	012492492H
	DD	011111111H
	DD	0fffffffH
	DD	0f0f0f0fH
	DD	0e38e38eH
	DD	0d79435eH
	DD	0cccccccH
	DD	0c30c30cH
	DD	0ba2e8baH
	DD	0b21642cH
	DD	0aaaaaaaH
	DD	0a3d70a3H
	DD	09d89d89H
	DD	097b425eH
	DD	09249249H
	DD	08d3dcb0H
	DD	08888888H
	DD	08421084H
	DD	07ffffffH
	DD	07c1f07cH
	DD	07878787H
	DD	07507507H
	DD	071c71c7H
	ORG $+12
digitlimit DD	00H
	DD	00H
	DD	020H
	DD	014H
	DD	010H
	DD	0dH
	DD	0cH
	DD	0bH
	DD	0aH
	DD	0aH
	DD	09H
	DD	09H
	DD	08H
	DD	08H
	DD	08H
	DD	08H
	DD	08H
	DD	07H
	DD	07H
	DD	07H
	DD	07H
	DD	07H
	DD	07H
	DD	07H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
_DATA	ENDS
PUBLIC	PyOS_strtoul
EXTRN	__imp__errno:PROC
EXTRN	_PyLong_DigitValue:BYTE
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\python\mystrtoul.c
pdata	SEGMENT
$pdata$PyOS_strtoul DD imagerel $LN64
	DD	imagerel $LN64+1413
	DD	imagerel $unwind$PyOS_strtoul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_strtoul DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyOS_strtoul
_TEXT	SEGMENT
ovlimit$ = 32
c$ = 36
result$ = 40
temp_result$20371 = 44
tv78 = 48
str$ = 80
ptr$ = 88
base$ = 96
PyOS_strtoul PROC					; COMDAT

; 96   : {

$LN64:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 97   :     register unsigned long result = 0; /* return value of the function */

  00013	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0
$LN61@PyOS_strto:

; 98   :     register int c;             /* current input character */
; 99   :     register int ovlimit;       /* required digits to overflow */
; 100  : 
; 101  :     /* skip leading white space */
; 102  :     while (*str && Py_ISSPACE(Py_CHARMASK(*str)))

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00020	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00023	85 c0		 test	 eax, eax
  00025	74 38		 je	 SHORT $LN60@PyOS_strto
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  0002c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00034	0f b6 c0	 movzx	 eax, al
  00037	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00046	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00049	83 e0 08	 and	 eax, 8
  0004c	85 c0		 test	 eax, eax
  0004e	74 0f		 je	 SHORT $LN60@PyOS_strto

; 103  :         ++str;

  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00055	48 ff c0	 inc	 rax
  00058	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax
  0005d	eb bc		 jmp	 SHORT $LN61@PyOS_strto
$LN60@PyOS_strto:

; 104  : 
; 105  :     /* check for leading 0b, 0o or 0x for auto-base or base 16 */
; 106  :     switch (base) {

  0005f	8b 44 24 60	 mov	 eax, DWORD PTR base$[rsp]
  00063	89 44 24 30	 mov	 DWORD PTR tv78[rsp], eax
  00067	83 7c 24 30 00	 cmp	 DWORD PTR tv78[rsp], 0
  0006c	74 26		 je	 SHORT $LN57@PyOS_strto
  0006e	83 7c 24 30 02	 cmp	 DWORD PTR tv78[rsp], 2
  00073	0f 84 0b 03 00
	00		 je	 $LN22@PyOS_strto
  00079	83 7c 24 30 08	 cmp	 DWORD PTR tv78[rsp], 8
  0007e	0f 84 80 02 00
	00		 je	 $LN28@PyOS_strto
  00084	83 7c 24 30 10	 cmp	 DWORD PTR tv78[rsp], 16
  00089	0f 84 f2 01 00
	00		 je	 $LN34@PyOS_strto
  0008f	e9 6e 03 00 00	 jmp	 $LN58@PyOS_strto
$LN57@PyOS_strto:

; 107  :     case 0:             /* look for leading 0b, 0o or 0x */
; 108  :         if (*str == '0') {

  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00099	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009c	83 f8 30	 cmp	 eax, 48			; 00000030H
  0009f	0f 85 cf 01 00
	00		 jne	 $LN56@PyOS_strto

; 109  :             ++str;

  000a5	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  000aa	48 ff c0	 inc	 rax
  000ad	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax

; 110  :             if (*str == 'x' || *str == 'X') {

  000b2	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  000b7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ba	83 f8 78	 cmp	 eax, 120		; 00000078H
  000bd	74 0d		 je	 SHORT $LN54@PyOS_strto
  000bf	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  000c4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c7	83 f8 58	 cmp	 eax, 88			; 00000058H
  000ca	75 57		 jne	 SHORT $LN55@PyOS_strto
$LN54@PyOS_strto:

; 111  :                 /* there must be at least one digit after 0x */
; 112  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 16) {

  000cc	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  000d1	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000d5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000da	0f b6 c0	 movzx	 eax, al
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  000e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e8	83 f8 10	 cmp	 eax, 16
  000eb	7c 1c		 jl	 SHORT $LN53@PyOS_strto

; 113  :                     if (ptr)

  000ed	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  000f3	74 0d		 je	 SHORT $LN52@PyOS_strto

; 114  :                         *ptr = str;

  000f5	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  000fa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  000ff	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN52@PyOS_strto:

; 115  :                     return 0;

  00102	33 c0		 xor	 eax, eax
  00104	e9 77 04 00 00	 jmp	 $LN62@PyOS_strto
$LN53@PyOS_strto:

; 116  :                 }
; 117  :                 ++str;

  00109	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  0010e	48 ff c0	 inc	 rax
  00111	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax

; 118  :                 base = 16;

  00116	c7 44 24 60 10
	00 00 00	 mov	 DWORD PTR base$[rsp], 16
  0011e	e9 4f 01 00 00	 jmp	 $LN51@PyOS_strto
$LN55@PyOS_strto:

; 119  :             } else if (*str == 'o' || *str == 'O') {

  00123	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00128	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0012b	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  0012e	74 0d		 je	 SHORT $LN49@PyOS_strto
  00130	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00135	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00138	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  0013b	75 57		 jne	 SHORT $LN50@PyOS_strto
$LN49@PyOS_strto:

; 120  :                 /* there must be at least one digit after 0o */
; 121  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 8) {

  0013d	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00142	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00146	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0014b	0f b6 c0	 movzx	 eax, al
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  00155	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00159	83 f8 08	 cmp	 eax, 8
  0015c	7c 1c		 jl	 SHORT $LN48@PyOS_strto

; 122  :                     if (ptr)

  0015e	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  00164	74 0d		 je	 SHORT $LN47@PyOS_strto

; 123  :                         *ptr = str;

  00166	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  0016b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  00170	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN47@PyOS_strto:

; 124  :                     return 0;

  00173	33 c0		 xor	 eax, eax
  00175	e9 06 04 00 00	 jmp	 $LN62@PyOS_strto
$LN48@PyOS_strto:

; 125  :                 }
; 126  :                 ++str;

  0017a	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  0017f	48 ff c0	 inc	 rax
  00182	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax

; 127  :                 base = 8;

  00187	c7 44 24 60 08
	00 00 00	 mov	 DWORD PTR base$[rsp], 8
  0018f	e9 de 00 00 00	 jmp	 $LN46@PyOS_strto
$LN50@PyOS_strto:

; 128  :             } else if (*str == 'b' || *str == 'B') {

  00194	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00199	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0019c	83 f8 62	 cmp	 eax, 98			; 00000062H
  0019f	74 0d		 je	 SHORT $LN44@PyOS_strto
  001a1	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  001a6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001a9	83 f8 42	 cmp	 eax, 66			; 00000042H
  001ac	75 54		 jne	 SHORT $LN45@PyOS_strto
$LN44@PyOS_strto:

; 129  :                 /* there must be at least one digit after 0b */
; 130  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 2) {

  001ae	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  001b3	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  001b7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001bc	0f b6 c0	 movzx	 eax, al
  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  001c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ca	83 f8 02	 cmp	 eax, 2
  001cd	7c 1c		 jl	 SHORT $LN43@PyOS_strto

; 131  :                     if (ptr)

  001cf	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  001d5	74 0d		 je	 SHORT $LN42@PyOS_strto

; 132  :                         *ptr = str;

  001d7	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  001dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  001e1	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN42@PyOS_strto:

; 133  :                     return 0;

  001e4	33 c0		 xor	 eax, eax
  001e6	e9 95 03 00 00	 jmp	 $LN62@PyOS_strto
$LN43@PyOS_strto:

; 134  :                 }
; 135  :                 ++str;

  001eb	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  001f0	48 ff c0	 inc	 rax
  001f3	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax

; 136  :                 base = 2;

  001f8	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR base$[rsp], 2

; 137  :             } else {

  00200	eb 70		 jmp	 SHORT $LN41@PyOS_strto
$LN45@PyOS_strto:
$LN40@PyOS_strto:

; 138  :                 /* skip all zeroes... */
; 139  :                 while (*str == '0')

  00202	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00207	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0020a	83 f8 30	 cmp	 eax, 48			; 00000030H
  0020d	75 0f		 jne	 SHORT $LN39@PyOS_strto

; 140  :                     ++str;

  0020f	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00214	48 ff c0	 inc	 rax
  00217	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax
  0021c	eb e4		 jmp	 SHORT $LN40@PyOS_strto
$LN39@PyOS_strto:
$LN38@PyOS_strto:

; 141  :                 while (Py_ISSPACE(Py_CHARMASK(*str)))

  0021e	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00223	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00226	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0022b	0f b6 c0	 movzx	 eax, al
  0022e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00233	0f b6 c0	 movzx	 eax, al
  00236	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0023d	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00240	83 e0 08	 and	 eax, 8
  00243	85 c0		 test	 eax, eax
  00245	74 0f		 je	 SHORT $LN37@PyOS_strto

; 142  :                     ++str;

  00247	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  0024c	48 ff c0	 inc	 rax
  0024f	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax
  00254	eb c8		 jmp	 SHORT $LN38@PyOS_strto
$LN37@PyOS_strto:

; 143  :                 if (ptr)

  00256	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  0025c	74 0d		 je	 SHORT $LN36@PyOS_strto

; 144  :                     *ptr = str;

  0025e	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  00263	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  00268	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN36@PyOS_strto:

; 145  :                 return 0;

  0026b	33 c0		 xor	 eax, eax
  0026d	e9 0e 03 00 00	 jmp	 $LN62@PyOS_strto
$LN41@PyOS_strto:
$LN46@PyOS_strto:
$LN51@PyOS_strto:

; 146  :             }
; 147  :         }
; 148  :         else

  00272	eb 08		 jmp	 SHORT $LN35@PyOS_strto
$LN56@PyOS_strto:

; 149  :             base = 10;

  00274	c7 44 24 60 0a
	00 00 00	 mov	 DWORD PTR base$[rsp], 10
$LN35@PyOS_strto:

; 150  :         break;

  0027c	e9 81 01 00 00	 jmp	 $LN58@PyOS_strto
$LN34@PyOS_strto:

; 151  : 
; 152  :     /* even with explicit base, skip leading 0? prefix */
; 153  :     case 16:
; 154  :         if (*str == '0') {

  00281	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00286	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00289	83 f8 30	 cmp	 eax, 48			; 00000030H
  0028c	75 71		 jne	 SHORT $LN33@PyOS_strto

; 155  :             ++str;

  0028e	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00293	48 ff c0	 inc	 rax
  00296	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax

; 156  :             if (*str == 'x' || *str == 'X') {

  0029b	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  002a0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002a3	83 f8 78	 cmp	 eax, 120		; 00000078H
  002a6	74 0d		 je	 SHORT $LN31@PyOS_strto
  002a8	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  002ad	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002b0	83 f8 58	 cmp	 eax, 88			; 00000058H
  002b3	75 4a		 jne	 SHORT $LN32@PyOS_strto
$LN31@PyOS_strto:

; 157  :                 /* there must be at least one digit after 0x */
; 158  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 16) {

  002b5	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  002ba	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  002be	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002c3	0f b6 c0	 movzx	 eax, al
  002c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  002cd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d1	83 f8 10	 cmp	 eax, 16
  002d4	7c 1c		 jl	 SHORT $LN30@PyOS_strto

; 159  :                     if (ptr)

  002d6	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  002dc	74 0d		 je	 SHORT $LN29@PyOS_strto

; 160  :                         *ptr = str;

  002de	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  002e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  002e8	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN29@PyOS_strto:

; 161  :                     return 0;

  002eb	33 c0		 xor	 eax, eax
  002ed	e9 8e 02 00 00	 jmp	 $LN62@PyOS_strto
$LN30@PyOS_strto:

; 162  :                 }
; 163  :                 ++str;

  002f2	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  002f7	48 ff c0	 inc	 rax
  002fa	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax
$LN32@PyOS_strto:
$LN33@PyOS_strto:

; 164  :             }
; 165  :         }
; 166  :         break;

  002ff	e9 fe 00 00 00	 jmp	 $LN58@PyOS_strto
$LN28@PyOS_strto:

; 167  :     case 8:
; 168  :         if (*str == '0') {

  00304	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00309	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0030c	83 f8 30	 cmp	 eax, 48			; 00000030H
  0030f	75 71		 jne	 SHORT $LN27@PyOS_strto

; 169  :             ++str;

  00311	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00316	48 ff c0	 inc	 rax
  00319	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax

; 170  :             if (*str == 'o' || *str == 'O') {

  0031e	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00323	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00326	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  00329	74 0d		 je	 SHORT $LN25@PyOS_strto
  0032b	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00330	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00333	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  00336	75 4a		 jne	 SHORT $LN26@PyOS_strto
$LN25@PyOS_strto:

; 171  :                 /* there must be at least one digit after 0o */
; 172  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 8) {

  00338	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  0033d	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00341	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00346	0f b6 c0	 movzx	 eax, al
  00349	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  00350	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00354	83 f8 08	 cmp	 eax, 8
  00357	7c 1c		 jl	 SHORT $LN24@PyOS_strto

; 173  :                     if (ptr)

  00359	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  0035f	74 0d		 je	 SHORT $LN23@PyOS_strto

; 174  :                         *ptr = str;

  00361	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  00366	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  0036b	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN23@PyOS_strto:

; 175  :                     return 0;

  0036e	33 c0		 xor	 eax, eax
  00370	e9 0b 02 00 00	 jmp	 $LN62@PyOS_strto
$LN24@PyOS_strto:

; 176  :                 }
; 177  :                 ++str;

  00375	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  0037a	48 ff c0	 inc	 rax
  0037d	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax
$LN26@PyOS_strto:
$LN27@PyOS_strto:

; 178  :             }
; 179  :         }
; 180  :         break;

  00382	eb 7e		 jmp	 SHORT $LN58@PyOS_strto
$LN22@PyOS_strto:

; 181  :     case 2:
; 182  :         if(*str == '0') {

  00384	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00389	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0038c	83 f8 30	 cmp	 eax, 48			; 00000030H
  0038f	75 71		 jne	 SHORT $LN21@PyOS_strto

; 183  :             ++str;

  00391	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00396	48 ff c0	 inc	 rax
  00399	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax

; 184  :             if (*str == 'b' || *str == 'B') {

  0039e	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  003a3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003a6	83 f8 62	 cmp	 eax, 98			; 00000062H
  003a9	74 0d		 je	 SHORT $LN19@PyOS_strto
  003ab	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  003b0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003b3	83 f8 42	 cmp	 eax, 66			; 00000042H
  003b6	75 4a		 jne	 SHORT $LN20@PyOS_strto
$LN19@PyOS_strto:

; 185  :                 /* there must be at least one digit after 0b */
; 186  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 2) {

  003b8	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  003bd	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  003c1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003c6	0f b6 c0	 movzx	 eax, al
  003c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  003d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003d4	83 f8 02	 cmp	 eax, 2
  003d7	7c 1c		 jl	 SHORT $LN18@PyOS_strto

; 187  :                     if (ptr)

  003d9	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  003df	74 0d		 je	 SHORT $LN17@PyOS_strto

; 188  :                         *ptr = str;

  003e1	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  003e6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  003eb	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN17@PyOS_strto:

; 189  :                     return 0;

  003ee	33 c0		 xor	 eax, eax
  003f0	e9 8b 01 00 00	 jmp	 $LN62@PyOS_strto
$LN18@PyOS_strto:

; 190  :                 }
; 191  :                 ++str;

  003f5	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  003fa	48 ff c0	 inc	 rax
  003fd	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax
$LN20@PyOS_strto:
$LN21@PyOS_strto:
$LN58@PyOS_strto:

; 192  :             }
; 193  :         }
; 194  :         break;
; 195  :     }
; 196  : 
; 197  :     /* catch silly bases */
; 198  :     if (base < 2 || base > 36) {

  00402	83 7c 24 60 02	 cmp	 DWORD PTR base$[rsp], 2
  00407	7c 07		 jl	 SHORT $LN15@PyOS_strto
  00409	83 7c 24 60 24	 cmp	 DWORD PTR base$[rsp], 36 ; 00000024H
  0040e	7e 1c		 jle	 SHORT $LN16@PyOS_strto
$LN15@PyOS_strto:

; 199  :         if (ptr)

  00410	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  00416	74 0d		 je	 SHORT $LN14@PyOS_strto

; 200  :             *ptr = str;

  00418	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  0041d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  00422	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN14@PyOS_strto:

; 201  :         return 0;

  00425	33 c0		 xor	 eax, eax
  00427	e9 54 01 00 00	 jmp	 $LN62@PyOS_strto
$LN16@PyOS_strto:
$LN13@PyOS_strto:

; 202  :     }
; 203  : 
; 204  :     /* skip leading zeroes */
; 205  :     while (*str == '0')

  0042c	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00431	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00434	83 f8 30	 cmp	 eax, 48			; 00000030H
  00437	75 0f		 jne	 SHORT $LN12@PyOS_strto

; 206  :         ++str;

  00439	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  0043e	48 ff c0	 inc	 rax
  00441	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax
  00446	eb e4		 jmp	 SHORT $LN13@PyOS_strto
$LN12@PyOS_strto:

; 207  : 
; 208  :     /* base is guaranteed to be in [2, 36] at this point */
; 209  :     ovlimit = digitlimit[base];

  00448	48 63 44 24 60	 movsxd	 rax, DWORD PTR base$[rsp]
  0044d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:digitlimit
  00454	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00457	89 44 24 20	 mov	 DWORD PTR ovlimit$[rsp], eax
$LN11@PyOS_strto:

; 210  : 
; 211  :     /* do the conversion until non-digit character encountered */
; 212  :     while ((c = _PyLong_DigitValue[Py_CHARMASK(*str)]) < base) {

  0045b	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00460	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00463	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00468	0f b6 c0	 movzx	 eax, al
  0046b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  00472	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00476	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax
  0047a	8b 44 24 60	 mov	 eax, DWORD PTR base$[rsp]
  0047e	39 44 24 24	 cmp	 DWORD PTR c$[rsp], eax
  00482	0f 8d 87 00 00
	00		 jge	 $LN10@PyOS_strto

; 213  :         if (ovlimit > 0) /* no overflow check required */

  00488	83 7c 24 20 00	 cmp	 DWORD PTR ovlimit$[rsp], 0
  0048d	7e 13		 jle	 SHORT $LN9@PyOS_strto

; 214  :             result = result * base + c;

  0048f	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]
  00493	0f af 44 24 60	 imul	 eax, DWORD PTR base$[rsp]
  00498	03 44 24 24	 add	 eax, DWORD PTR c$[rsp]
  0049c	89 44 24 28	 mov	 DWORD PTR result$[rsp], eax

; 215  :         else { /* requires overflow check */

  004a0	eb 51		 jmp	 SHORT $LN8@PyOS_strto
$LN9@PyOS_strto:

; 216  :             register unsigned long temp_result;
; 217  : 
; 218  :             if (ovlimit < 0) /* guaranteed overflow */

  004a2	83 7c 24 20 00	 cmp	 DWORD PTR ovlimit$[rsp], 0
  004a7	7d 02		 jge	 SHORT $LN7@PyOS_strto

; 219  :                 goto overflowed;

  004a9	eb 7f		 jmp	 SHORT $overflowed$20373
$LN7@PyOS_strto:

; 220  : 
; 221  :             /* there could be an overflow */
; 222  :             /* check overflow just from shifting */
; 223  :             if (result > smallmax[base])

  004ab	48 63 44 24 60	 movsxd	 rax, DWORD PTR base$[rsp]
  004b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:smallmax
  004b7	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  004ba	39 44 24 28	 cmp	 DWORD PTR result$[rsp], eax
  004be	76 02		 jbe	 SHORT $LN6@PyOS_strto

; 224  :                 goto overflowed;

  004c0	eb 68		 jmp	 SHORT $overflowed$20373
$LN6@PyOS_strto:

; 225  : 
; 226  :             result *= base;

  004c2	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]
  004c6	0f af 44 24 60	 imul	 eax, DWORD PTR base$[rsp]
  004cb	89 44 24 28	 mov	 DWORD PTR result$[rsp], eax

; 227  : 
; 228  :             /* check overflow from the digit's value */
; 229  :             temp_result = result + c;

  004cf	8b 44 24 24	 mov	 eax, DWORD PTR c$[rsp]
  004d3	8b 4c 24 28	 mov	 ecx, DWORD PTR result$[rsp]
  004d7	03 c8		 add	 ecx, eax
  004d9	8b c1		 mov	 eax, ecx
  004db	89 44 24 2c	 mov	 DWORD PTR temp_result$20371[rsp], eax

; 230  :             if (temp_result < result)

  004df	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]
  004e3	39 44 24 2c	 cmp	 DWORD PTR temp_result$20371[rsp], eax
  004e7	73 02		 jae	 SHORT $LN5@PyOS_strto

; 231  :                 goto overflowed;

  004e9	eb 3f		 jmp	 SHORT $overflowed$20373
$LN5@PyOS_strto:

; 232  : 
; 233  :             result = temp_result;

  004eb	8b 44 24 2c	 mov	 eax, DWORD PTR temp_result$20371[rsp]
  004ef	89 44 24 28	 mov	 DWORD PTR result$[rsp], eax
$LN8@PyOS_strto:

; 234  :         }
; 235  : 
; 236  :         ++str;

  004f3	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  004f8	48 ff c0	 inc	 rax
  004fb	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax

; 237  :         --ovlimit;

  00500	8b 44 24 20	 mov	 eax, DWORD PTR ovlimit$[rsp]
  00504	ff c8		 dec	 eax
  00506	89 44 24 20	 mov	 DWORD PTR ovlimit$[rsp], eax

; 238  :     }

  0050a	e9 4c ff ff ff	 jmp	 $LN11@PyOS_strto
$LN10@PyOS_strto:

; 239  : 
; 240  :     /* set pointer to point to the last character scanned */
; 241  :     if (ptr)

  0050f	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  00515	74 0d		 je	 SHORT $LN4@PyOS_strto

; 242  :         *ptr = str;

  00517	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  0051c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  00521	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN4@PyOS_strto:

; 243  : 
; 244  :     return result;

  00524	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]
  00528	eb 56		 jmp	 SHORT $LN62@PyOS_strto
$overflowed$20373:

; 245  : 
; 246  : overflowed:
; 247  :     if (ptr) {

  0052a	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  00530	74 3d		 je	 SHORT $LN3@PyOS_strto
$LN2@PyOS_strto:

; 248  :         /* spool through remaining digit characters */
; 249  :         while (_PyLong_DigitValue[Py_CHARMASK(*str)] < base)

  00532	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00537	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0053a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0053f	0f b6 c0	 movzx	 eax, al
  00542	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyLong_DigitValue
  00549	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0054d	3b 44 24 60	 cmp	 eax, DWORD PTR base$[rsp]
  00551	7d 0f		 jge	 SHORT $LN1@PyOS_strto

; 250  :             ++str;

  00553	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00558	48 ff c0	 inc	 rax
  0055b	48 89 44 24 50	 mov	 QWORD PTR str$[rsp], rax
  00560	eb d0		 jmp	 SHORT $LN2@PyOS_strto
$LN1@PyOS_strto:

; 251  :         *ptr = str;

  00562	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  00567	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  0056c	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@PyOS_strto:

; 252  :     }
; 253  :     errno = ERANGE;

  0056f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00575	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 254  :     return (unsigned long)-1;

  0057b	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
$LN62@PyOS_strto:

; 255  : }

  00580	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00584	c3		 ret	 0
PyOS_strtoul ENDP
_TEXT	ENDS
PUBLIC	PyOS_strtol
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_strtol DD imagerel $LN12
	DD	imagerel $LN12+255
	DD	imagerel $unwind$PyOS_strtol
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_strtol DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyOS_strtol
_TEXT	SEGMENT
sign$ = 32
uresult$ = 36
result$ = 40
str$ = 64
ptr$ = 72
base$ = 80
PyOS_strtol PROC					; COMDAT

; 264  : {

$LN12:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN9@PyOS_strto@2:

; 265  :     long result;
; 266  :     unsigned long uresult;
; 267  :     char sign;
; 268  : 
; 269  :     while (*str && Py_ISSPACE(Py_CHARMASK(*str)))

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR str$[rsp]
  00018	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0001b	85 c0		 test	 eax, eax
  0001d	74 38		 je	 SHORT $LN8@PyOS_strto@2
  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR str$[rsp]
  00024	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00027	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00034	0f b6 c0	 movzx	 eax, al
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0003e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00041	83 e0 08	 and	 eax, 8
  00044	85 c0		 test	 eax, eax
  00046	74 0f		 je	 SHORT $LN8@PyOS_strto@2

; 270  :         str++;

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR str$[rsp]
  0004d	48 ff c0	 inc	 rax
  00050	48 89 44 24 40	 mov	 QWORD PTR str$[rsp], rax
  00055	eb bc		 jmp	 SHORT $LN9@PyOS_strto@2
$LN8@PyOS_strto@2:

; 271  : 
; 272  :     sign = *str;

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR str$[rsp]
  0005c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005f	88 44 24 20	 mov	 BYTE PTR sign$[rsp], al

; 273  :     if (sign == '+' || sign == '-')

  00063	0f be 44 24 20	 movsx	 eax, BYTE PTR sign$[rsp]
  00068	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0006b	74 0a		 je	 SHORT $LN6@PyOS_strto@2
  0006d	0f be 44 24 20	 movsx	 eax, BYTE PTR sign$[rsp]
  00072	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00075	75 0d		 jne	 SHORT $LN7@PyOS_strto@2
$LN6@PyOS_strto@2:

; 274  :         str++;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR str$[rsp]
  0007c	48 ff c0	 inc	 rax
  0007f	48 89 44 24 40	 mov	 QWORD PTR str$[rsp], rax
$LN7@PyOS_strto@2:

; 275  : 
; 276  :     uresult = PyOS_strtoul(str, ptr, base);

  00084	44 8b 44 24 50	 mov	 r8d, DWORD PTR base$[rsp]
  00089	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptr$[rsp]
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00093	e8 00 00 00 00	 call	 PyOS_strtoul
  00098	89 44 24 24	 mov	 DWORD PTR uresult$[rsp], eax

; 277  : 
; 278  :     if (uresult <= (unsigned long)LONG_MAX) {

  0009c	81 7c 24 24 ff
	ff ff 7f	 cmp	 DWORD PTR uresult$[rsp], 2147483647 ; 7fffffffH
  000a4	77 1e		 ja	 SHORT $LN5@PyOS_strto@2

; 279  :         result = (long)uresult;

  000a6	8b 44 24 24	 mov	 eax, DWORD PTR uresult$[rsp]
  000aa	89 44 24 28	 mov	 DWORD PTR result$[rsp], eax

; 280  :         if (sign == '-')

  000ae	0f be 44 24 20	 movsx	 eax, BYTE PTR sign$[rsp]
  000b3	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000b6	75 0a		 jne	 SHORT $LN4@PyOS_strto@2

; 281  :             result = -result;

  000b8	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]
  000bc	f7 d8		 neg	 eax
  000be	89 44 24 28	 mov	 DWORD PTR result$[rsp], eax
$LN4@PyOS_strto@2:

; 282  :     }
; 283  :     else if (sign == '-' && uresult == PY_ABS_LONG_MIN) {

  000c2	eb 32		 jmp	 SHORT $LN3@PyOS_strto@2
$LN5@PyOS_strto@2:
  000c4	0f be 44 24 20	 movsx	 eax, BYTE PTR sign$[rsp]
  000c9	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000cc	75 14		 jne	 SHORT $LN2@PyOS_strto@2
  000ce	81 7c 24 24 00
	00 00 80	 cmp	 DWORD PTR uresult$[rsp], -2147483648 ; 80000000H
  000d6	75 0a		 jne	 SHORT $LN2@PyOS_strto@2

; 284  :         result = LONG_MIN;

  000d8	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR result$[rsp], -2147483648 ; ffffffff80000000H

; 285  :     }
; 286  :     else {

  000e0	eb 14		 jmp	 SHORT $LN1@PyOS_strto@2
$LN2@PyOS_strto@2:

; 287  :         errno = ERANGE;

  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e8	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 288  :         result = LONG_MAX;

  000ee	c7 44 24 28 ff
	ff ff 7f	 mov	 DWORD PTR result$[rsp], 2147483647 ; 7fffffffH
$LN1@PyOS_strto@2:
$LN3@PyOS_strto@2:

; 289  :     }
; 290  :     return result;

  000f6	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]

; 291  : }

  000fa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fe	c3		 ret	 0
PyOS_strtol ENDP
_TEXT	ENDS
END
