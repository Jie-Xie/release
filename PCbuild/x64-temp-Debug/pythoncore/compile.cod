; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_08GHPJPHKJ@?$DMlocals?$DO?$AA@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	Py_OptimizeFlag
_BSS	SEGMENT
Py_OptimizeFlag DD 01H DUP (?)
	ALIGN	8

?assertion_error@?1??compiler_assert@@9@9 DQ 01H DUP (?) ; `compiler_assert'::`2'::assertion_error
_BSS	ENDS
CONST	SEGMENT
?LOOP_ERROR_MSG@?1??compiler_continue@@9@9 DB '''continue'' not properly '
	DB	'in loop', 00H				; `compiler_continue'::`2'::LOOP_ERROR_MSG
?IN_FINALLY_ERROR_MSG@?1??compiler_continue@@9@9 DB '''continue'' not sup'
	DB	'ported inside ''finally'' clause', 00H	; `compiler_continue'::`2'::IN_FINALLY_ERROR_MSG
CONST	ENDS
;	COMDAT ??_C@_08GHPJPHKJ@?$DMlocals?$DO?$AA@
CONST	SEGMENT
??_C@_08GHPJPHKJ@?$DMlocals?$DO?$AA@ DB '<locals>', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?locals@?1??compiler_scope_qualname@@9@9 DQ 0000000000000000H ; `compiler_scope_qualname'::`2'::locals
	DQ	FLAT:??_C@_08GHPJPHKJ@?$DMlocals?$DO?$AA@
	DQ	0000000000000000H
?dot@?1??compiler_scope_qualname@@9@9 DQ 0000000000000000H ; `compiler_scope_qualname'::`2'::dot
	DQ	FLAT:??_C@_01LFCBOECM@?4?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
PUBLIC	??_C@_1EO@GMKAAHMG@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAr?$AAe?$AAs?$AAu@ ; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_1CNI@HNMDOJBP@?$AA?$CI?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?$CJ?$AA?$CI?$AA?5?$AA?$CI?$AA?$CB?$AA?$CB?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr@ ; `string'
PUBLIC	??_C@_1EO@GFECEDJG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ ; `string'
PUBLIC	??_C@_1DG@CHIDEPLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CL@FMJEBAFL@private?5identifier?5too?5large?5to?5@ ; `string'
PUBLIC	??_C@_1FK@BPBJMPEL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1EC@GDEJHALP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	_Py_IncRef
PUBLIC	??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@ ; `string'
PUBLIC	??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	_Py_Mangle
EXTRN	_PyUnicode_CheckConsistency:PROC
EXTRN	PyUnicode_CopyCharacters:PROC
EXTRN	PyUnicode_New:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyUnicode_FindChar:PROC
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\compile.c
pdata	SEGMENT
$pdata$_Py_Mangle DD imagerel $LN267
	DD	imagerel $LN267+10987
	DD	imagerel $unwind$_Py_Mangle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_Mangle DD 021101H
	DD	03f0111H
xdata	ENDS
;	COMDAT ??_C@_1EO@GMKAAHMG@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAr?$AAe?$AAs?$AAu@
CONST	SEGMENT
??_C@_1EO@GMKAAHMG@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAr?$AAe?$AAs?$AAu@ DB '_'
	DB	00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e'
	DB	00H, 'c', 00H, 'k', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 's', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'y'
	DB	00H, '(', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, ',', 00H, ' ', 00H, '1', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CNI@HNMDOJBP@?$AA?$CI?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?$CJ?$AA?$CI?$AA?5?$AA?$CI?$AA?$CB?$AA?$CB?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr@
CONST	SEGMENT
??_C@_1CNI@HNMDOJBP@?$AA?$CI?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?$CJ?$AA?$CI?$AA?5?$AA?$CI?$AA?$CB?$AA?$CB?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr@ DB '('
	DB	00H, '(', 00H, '(', 00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H
	DB	')', 00H, '(', 00H, ' ', 00H, '(', 00H, '!', 00H, '!', 00H, '('
	DB	00H, '(', 00H, '(', 00H, '(', 00H, '(', 00H, '(', 00H, '(', 00H
	DB	'P', 00H, 'y', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ')', 00H, ')', 00H, '-'
	DB	00H, '>', 00H, 'o', 00H, 'b', 00H, '_', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, ')', 00H, ')', 00H, '-', 00H, '>', 00H, 't'
	DB	00H, 'p', 00H, '_', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H
	DB	's', 00H, ' ', 00H, '&', 00H, ' ', 00H, '(', 00H, '(', 00H, '1'
	DB	00H, 'L', 00H, '<', 00H, '<', 00H, '2', 00H, '8', 00H, ')', 00H
	DB	')', 00H, ')', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, ')', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, '_', 00H, 'w', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, 'e', 00H, 'r', 00H, 't', 00H, '(', 00H, 'L', 00H, '"', 00H
	DB	'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o'
	DB	00H, 'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H
	DB	'c', 00H, 'k', 00H, '(', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u'
	DB	00H, 'l', 00H, 't', 00H, ')', 00H, '"', 00H, ',', 00H, ' ', 00H
	DB	'L', 00H, '"', 00H, '.', 00H, '.', 00H, '\', 00H, '\', 00H, 'P'
	DB	00H, 'y', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, '\', 00H
	DB	'\', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, '.', 00H, 'c', 00H, '"', 00H, ',', 00H, ' ', 00H
	DB	'2', 00H, '6', 00H, '5', 00H, ')', 00H, ',', 00H, ' ', 00H, '0'
	DB	00H, ')', 00H, ' ', 00H, ')', 00H, ',', 00H, ' ', 00H, '(', 00H
	DB	'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, ')', 00H, '(', 00H, ' '
	DB	00H, '(', 00H, '!', 00H, '!', 00H, '(', 00H, '(', 00H, '(', 00H
	DB	'(', 00H, 'P', 00H, 'y', 00H, 'A', 00H, 'S', 00H, 'C', 00H, 'I'
	DB	00H, 'I', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, '*', 00H, ')', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u'
	DB	00H, 'l', 00H, 't', 00H, ')', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, 'y', 00H, ')', 00H, ')', 00H, ')', 00H
	DB	' ', 00H, '|', 00H, '|', 00H, ' ', 00H, '(', 00H, '_', 00H, 'w'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'(', 00H, 'L', 00H, '"', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n'
	DB	00H, 'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H
	DB	'I', 00H, 'S', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'D'
	DB	00H, 'Y', 00H, '(', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H
	DB	'l', 00H, 't', 00H, ')', 00H, '"', 00H, ',', 00H, ' ', 00H, 'L'
	DB	00H, '"', 00H, '.', 00H, '.', 00H, '\', 00H, '\', 00H, 'P', 00H
	DB	'y', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, '\', 00H, '\'
	DB	00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, 'c', 00H, '"', 00H, ',', 00H, ' ', 00H, '2'
	DB	00H, '6', 00H, '5', 00H, ')', 00H, ',', 00H, ' ', 00H, '0', 00H
	DB	')', 00H, ' ', 00H, ')', 00H, ',', 00H, ' ', 00H, '(', 00H, '('
	DB	00H, 'P', 00H, 'y', 00H, 'A', 00H, 'S', 00H, 'C', 00H, 'I', 00H
	DB	'I', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, ' ', 00H, '*', 00H, ')', 00H, '(', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ')', 00H, ')', 00H, '-'
	DB	00H, '>', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'.', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H, ')', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'y', 00H
	DB	'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, '_', 00H, '4', 00H, 'B', 00H, 'Y', 00H, 'T', 00H, 'E', 00H
	DB	'_', 00H, 'K', 00H, 'I', 00H, 'N', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@GFECEDJG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
CONST	SEGMENT
??_C@_1EO@GFECEDJG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ')'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@CHIDEPLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@CHIDEPLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H
	DB	'l', 00H, 't', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FMJEBAFL@private?5identifier?5too?5large?5to?5@
CONST	SEGMENT
??_C@_0CL@FMJEBAFL@private?5identifier?5too?5large?5to?5@ DB 'private ide'
	DB	'ntifier too large to be mangled', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@BPBJMPEL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ@
CONST	SEGMENT
??_C@_1FK@BPBJMPEL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'(', 00H, 'p', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, ')', 00H
	DB	')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a'
	DB	00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@GDEJHALP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@GDEJHALP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, '(', 00H
	DB	'p', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, '(', 00H, 'p', 00H, 'r', 00H, 'i', 00H
	DB	'v', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'o', 00H, 'b', 00H, 'j'
	DB	00H, ')', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'p', 00H
	DB	'r', 00H, 'i', 00H, 'v', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'o'
	DB	00H, 'b', 00H, 'j', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'p', 00H, 'r', 00H, 'i', 00H, 'v', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
CONST	SEGMENT
??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'(', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'n', 00H, 't', 00H, ')'
	DB	00H, ')', 00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H
	DB	't', 00H, 'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, '(', 00H
	DB	'i', 00H, 'd', 00H, 'e', 00H, 'n', 00H, 't', 00H, ')', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, '(', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ')', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'i', 00H
	DB	'd', 00H, 'e', 00H, 'n', 00H, 't', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'y', 00H, 't', 00H, 'h', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_Mangle
_TEXT	SEGMENT
maxchar$ = 48
ipriv$ = 56
plen$ = 64
nlen$ = 72
result$ = 80
tv170 = 88
tv179 = 96
tv289 = 104
tv234 = 112
tv243 = 120
tv288 = 128
tv278 = 136
tv287 = 144
tv360 = 152
tv369 = 160
tv482 = 168
tv425 = 176
tv434 = 184
tv481 = 192
tv470 = 200
tv479 = 208
tv588 = 216
tv597 = 224
tv715 = 232
tv654 = 240
tv663 = 248
tv714 = 256
tv701 = 264
tv710 = 272
tv786 = 280
tv795 = 288
tv913 = 296
tv852 = 304
tv861 = 312
tv912 = 320
tv899 = 328
tv908 = 336
tv992 = 344
tv1001 = 352
tv1116 = 360
tv1057 = 368
tv1066 = 376
tv1115 = 384
tv1103 = 392
tv1112 = 400
tv1196 = 408
tv1194 = 412
tv1193 = 416
tv1267 = 420
tv1265 = 424
tv1264 = 428
tv1339 = 432
tv1337 = 436
tv1336 = 440
tv1365 = 444
tv1399 = 448
tv1408 = 456
tv1442 = 464
tv1451 = 472
tv1509 = 480
tv1518 = 488
privateobj$ = 512
ident$ = 520
_Py_Mangle PROC						; COMDAT

; 212  : {

$LN267:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H

; 213  :     /* Name mangling: __private becomes _classname__private.
; 214  :        This is independent from how the name is used. */
; 215  :     PyObject *result;
; 216  :     size_t nlen, plen, ipriv;
; 217  :     Py_UCS4 maxchar;
; 218  :     if (privateobj == NULL || !PyUnicode_Check(privateobj) ||
; 219  :         PyUnicode_READ_CHAR(ident, 0) != '_' ||
; 220  :         PyUnicode_READ_CHAR(ident, 1) != '_') {

  00011	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR privateobj$[rsp], 0
  0001a	0f 84 6b 0b 00
	00		 je	 $LN20@Py_Mangle
  00020	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  00028	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00032	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00037	85 c0		 test	 eax, eax
  00039	0f 84 4c 0b 00
	00		 je	 $LN20@Py_Mangle
  0003f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00047	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00051	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00056	85 c0		 test	 eax, eax
  00058	75 1c		 jne	 SHORT $LN24@Py_Mangle
  0005a	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00074	33 c0		 xor	 eax, eax
$LN24@Py_Mangle:
  00076	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0007e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00081	c1 e8 07	 shr	 eax, 7
  00084	83 e0 01	 and	 eax, 1
  00087	85 c0		 test	 eax, eax
  00089	75 1c		 jne	 SHORT $LN25@Py_Mangle
  0008b	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a5	33 c0		 xor	 eax, eax
$LN25@Py_Mangle:
  000a7	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  000af	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000b3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000b9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000be	85 c0		 test	 eax, eax
  000c0	75 1c		 jne	 SHORT $LN26@Py_Mangle
  000c2	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000dc	33 c0		 xor	 eax, eax
$LN26@Py_Mangle:
  000de	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  000e6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000e9	c1 e8 07	 shr	 eax, 7
  000ec	83 e0 01	 and	 eax, 1
  000ef	85 c0		 test	 eax, eax
  000f1	75 1c		 jne	 SHORT $LN27@Py_Mangle
  000f3	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  000f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0010d	33 c0		 xor	 eax, eax
$LN27@Py_Mangle:
  0010f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00117	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0011a	c1 e8 02	 shr	 eax, 2
  0011d	83 e0 07	 and	 eax, 7
  00120	83 f8 01	 cmp	 eax, 1
  00123	0f 85 54 01 00
	00		 jne	 $LN56@Py_Mangle
  00129	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00131	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00135	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0013b	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00140	85 c0		 test	 eax, eax
  00142	75 1c		 jne	 SHORT $LN28@Py_Mangle
  00144	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  0014a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0015e	33 c0		 xor	 eax, eax
$LN28@Py_Mangle:
  00160	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00168	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0016b	c1 e8 05	 shr	 eax, 5
  0016e	83 e0 01	 and	 eax, 1
  00171	85 c0		 test	 eax, eax
  00173	0f 84 b1 00 00
	00		 je	 $LN34@Py_Mangle
  00179	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00181	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00185	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0018b	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00190	85 c0		 test	 eax, eax
  00192	75 1c		 jne	 SHORT $LN29@Py_Mangle
  00194	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001ae	33 c0		 xor	 eax, eax
$LN29@Py_Mangle:
  001b0	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  001b8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001bb	c1 e8 07	 shr	 eax, 7
  001be	83 e0 01	 and	 eax, 1
  001c1	85 c0		 test	 eax, eax
  001c3	75 1c		 jne	 SHORT $LN30@Py_Mangle
  001c5	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  001cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001df	33 c0		 xor	 eax, eax
$LN30@Py_Mangle:
  001e1	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  001e9	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001ec	c1 e8 06	 shr	 eax, 6
  001ef	83 e0 01	 and	 eax, 1
  001f2	85 c0		 test	 eax, eax
  001f4	74 15		 je	 SHORT $LN31@Py_Mangle
  001f6	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  001fe	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00204	48 89 44 24 58	 mov	 QWORD PTR tv170[rsp], rax
  00209	eb 13		 jmp	 SHORT $LN32@Py_Mangle
$LN31@Py_Mangle:
  0020b	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00213	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00219	48 89 44 24 58	 mov	 QWORD PTR tv170[rsp], rax
$LN32@Py_Mangle:
  0021e	48 8b 44 24 58	 mov	 rax, QWORD PTR tv170[rsp]
  00223	48 89 44 24 60	 mov	 QWORD PTR tv179[rsp], rax
  00228	eb 42		 jmp	 SHORT $LN35@Py_Mangle
$LN34@Py_Mangle:
  0022a	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00232	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  0023a	75 1c		 jne	 SHORT $LN33@Py_Mangle
  0023c	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  00242	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  00250	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00256	33 c0		 xor	 eax, eax
$LN33@Py_Mangle:
  00258	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00260	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00267	48 89 44 24 60	 mov	 QWORD PTR tv179[rsp], rax
$LN35@Py_Mangle:
  0026c	48 8b 44 24 60	 mov	 rax, QWORD PTR tv179[rsp]
  00271	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00274	89 44 24 68	 mov	 DWORD PTR tv289[rsp], eax
  00278	e9 47 03 00 00	 jmp	 $LN57@Py_Mangle
$LN56@Py_Mangle:
  0027d	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00285	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00289	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0028f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00294	85 c0		 test	 eax, eax
  00296	75 1c		 jne	 SHORT $LN36@Py_Mangle
  00298	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  0029e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  002ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002b2	33 c0		 xor	 eax, eax
$LN36@Py_Mangle:
  002b4	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  002bc	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002bf	c1 e8 07	 shr	 eax, 7
  002c2	83 e0 01	 and	 eax, 1
  002c5	85 c0		 test	 eax, eax
  002c7	75 1c		 jne	 SHORT $LN37@Py_Mangle
  002c9	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  002cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  002dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002e3	33 c0		 xor	 eax, eax
$LN37@Py_Mangle:
  002e5	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  002ed	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002f0	c1 e8 02	 shr	 eax, 2
  002f3	83 e0 07	 and	 eax, 7
  002f6	83 f8 02	 cmp	 eax, 2
  002f9	0f 85 57 01 00
	00		 jne	 $LN54@Py_Mangle
  002ff	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00307	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0030b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00311	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00316	85 c0		 test	 eax, eax
  00318	75 1c		 jne	 SHORT $LN38@Py_Mangle
  0031a	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  00320	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00327	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0032e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00334	33 c0		 xor	 eax, eax
$LN38@Py_Mangle:
  00336	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0033e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00341	c1 e8 05	 shr	 eax, 5
  00344	83 e0 01	 and	 eax, 1
  00347	85 c0		 test	 eax, eax
  00349	0f 84 b1 00 00
	00		 je	 $LN44@Py_Mangle
  0034f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00357	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0035b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00361	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00366	85 c0		 test	 eax, eax
  00368	75 1c		 jne	 SHORT $LN39@Py_Mangle
  0036a	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  00370	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00377	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0037e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00384	33 c0		 xor	 eax, eax
$LN39@Py_Mangle:
  00386	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0038e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00391	c1 e8 07	 shr	 eax, 7
  00394	83 e0 01	 and	 eax, 1
  00397	85 c0		 test	 eax, eax
  00399	75 1c		 jne	 SHORT $LN40@Py_Mangle
  0039b	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  003a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  003a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003b5	33 c0		 xor	 eax, eax
$LN40@Py_Mangle:
  003b7	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  003bf	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003c2	c1 e8 06	 shr	 eax, 6
  003c5	83 e0 01	 and	 eax, 1
  003c8	85 c0		 test	 eax, eax
  003ca	74 15		 je	 SHORT $LN41@Py_Mangle
  003cc	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  003d4	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  003da	48 89 44 24 70	 mov	 QWORD PTR tv234[rsp], rax
  003df	eb 13		 jmp	 SHORT $LN42@Py_Mangle
$LN41@Py_Mangle:
  003e1	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  003e9	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  003ef	48 89 44 24 70	 mov	 QWORD PTR tv234[rsp], rax
$LN42@Py_Mangle:
  003f4	48 8b 44 24 70	 mov	 rax, QWORD PTR tv234[rsp]
  003f9	48 89 44 24 78	 mov	 QWORD PTR tv243[rsp], rax
  003fe	eb 42		 jmp	 SHORT $LN45@Py_Mangle
$LN44@Py_Mangle:
  00400	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00408	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00410	75 1c		 jne	 SHORT $LN43@Py_Mangle
  00412	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  00418	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0041f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0042c	33 c0		 xor	 eax, eax
$LN43@Py_Mangle:
  0042e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00436	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0043d	48 89 44 24 78	 mov	 QWORD PTR tv243[rsp], rax
$LN45@Py_Mangle:
  00442	48 8b 44 24 78	 mov	 rax, QWORD PTR tv243[rsp]
  00447	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0044a	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv288[rsp], eax
  00451	e9 63 01 00 00	 jmp	 $LN55@Py_Mangle
$LN54@Py_Mangle:
  00456	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0045e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00462	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00468	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0046d	85 c0		 test	 eax, eax
  0046f	75 1c		 jne	 SHORT $LN46@Py_Mangle
  00471	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  00477	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0047e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00485	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0048b	33 c0		 xor	 eax, eax
$LN46@Py_Mangle:
  0048d	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00495	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00498	c1 e8 05	 shr	 eax, 5
  0049b	83 e0 01	 and	 eax, 1
  0049e	85 c0		 test	 eax, eax
  004a0	0f 84 bd 00 00
	00		 je	 $LN52@Py_Mangle
  004a6	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  004ae	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  004b2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  004b8	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  004bd	85 c0		 test	 eax, eax
  004bf	75 1c		 jne	 SHORT $LN47@Py_Mangle
  004c1	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  004c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  004ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  004d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004db	33 c0		 xor	 eax, eax
$LN47@Py_Mangle:
  004dd	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  004e5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004e8	c1 e8 07	 shr	 eax, 7
  004eb	83 e0 01	 and	 eax, 1
  004ee	85 c0		 test	 eax, eax
  004f0	75 1c		 jne	 SHORT $LN48@Py_Mangle
  004f2	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  004f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  004ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00506	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0050c	33 c0		 xor	 eax, eax
$LN48@Py_Mangle:
  0050e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00516	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00519	c1 e8 06	 shr	 eax, 6
  0051c	83 e0 01	 and	 eax, 1
  0051f	85 c0		 test	 eax, eax
  00521	74 18		 je	 SHORT $LN49@Py_Mangle
  00523	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0052b	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00531	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv278[rsp], rax
  00539	eb 16		 jmp	 SHORT $LN50@Py_Mangle
$LN49@Py_Mangle:
  0053b	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00543	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00549	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv278[rsp], rax
$LN50@Py_Mangle:
  00551	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv278[rsp]
  00559	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv287[rsp], rax
  00561	eb 45		 jmp	 SHORT $LN53@Py_Mangle
$LN52@Py_Mangle:
  00563	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0056b	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00573	75 1c		 jne	 SHORT $LN51@Py_Mangle
  00575	41 b8 db 00 00
	00		 mov	 r8d, 219		; 000000dbH
  0057b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00582	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  00589	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0058f	33 c0		 xor	 eax, eax
$LN51@Py_Mangle:
  00591	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00599	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  005a0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv287[rsp], rax
$LN53@Py_Mangle:
  005a8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv287[rsp]
  005b0	8b 00		 mov	 eax, DWORD PTR [rax]
  005b2	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv288[rsp], eax
$LN55@Py_Mangle:
  005b9	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv288[rsp]
  005c0	89 44 24 68	 mov	 DWORD PTR tv289[rsp], eax
$LN57@Py_Mangle:
  005c4	83 7c 24 68 5f	 cmp	 DWORD PTR tv289[rsp], 95 ; 0000005fH
  005c9	0f 85 bc 05 00
	00		 jne	 $LN20@Py_Mangle
  005cf	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  005d7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005db	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005e1	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  005e6	85 c0		 test	 eax, eax
  005e8	75 1c		 jne	 SHORT $LN58@Py_Mangle
  005ea	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  005f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  005f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  005fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00604	33 c0		 xor	 eax, eax
$LN58@Py_Mangle:
  00606	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0060e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00611	c1 e8 07	 shr	 eax, 7
  00614	83 e0 01	 and	 eax, 1
  00617	85 c0		 test	 eax, eax
  00619	75 1c		 jne	 SHORT $LN59@Py_Mangle
  0061b	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00621	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00628	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  0062f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00635	33 c0		 xor	 eax, eax
$LN59@Py_Mangle:
  00637	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0063f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00643	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00649	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0064e	85 c0		 test	 eax, eax
  00650	75 1c		 jne	 SHORT $LN60@Py_Mangle
  00652	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00658	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0065f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00666	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0066c	33 c0		 xor	 eax, eax
$LN60@Py_Mangle:
  0066e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00676	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00679	c1 e8 07	 shr	 eax, 7
  0067c	83 e0 01	 and	 eax, 1
  0067f	85 c0		 test	 eax, eax
  00681	75 1c		 jne	 SHORT $LN61@Py_Mangle
  00683	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00689	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00690	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00697	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0069d	33 c0		 xor	 eax, eax
$LN61@Py_Mangle:
  0069f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  006a7	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  006aa	c1 e8 02	 shr	 eax, 2
  006ad	83 e0 07	 and	 eax, 7
  006b0	83 f8 01	 cmp	 eax, 1
  006b3	0f 85 6a 01 00
	00		 jne	 $LN90@Py_Mangle
  006b9	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  006c1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  006c5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  006cb	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  006d0	85 c0		 test	 eax, eax
  006d2	75 1c		 jne	 SHORT $LN62@Py_Mangle
  006d4	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  006da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  006e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  006e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006ee	33 c0		 xor	 eax, eax
$LN62@Py_Mangle:
  006f0	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  006f8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  006fb	c1 e8 05	 shr	 eax, 5
  006fe	83 e0 01	 and	 eax, 1
  00701	85 c0		 test	 eax, eax
  00703	0f 84 bd 00 00
	00		 je	 $LN68@Py_Mangle
  00709	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00711	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00715	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0071b	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00720	85 c0		 test	 eax, eax
  00722	75 1c		 jne	 SHORT $LN63@Py_Mangle
  00724	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  0072a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00731	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00738	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0073e	33 c0		 xor	 eax, eax
$LN63@Py_Mangle:
  00740	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00748	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0074b	c1 e8 07	 shr	 eax, 7
  0074e	83 e0 01	 and	 eax, 1
  00751	85 c0		 test	 eax, eax
  00753	75 1c		 jne	 SHORT $LN64@Py_Mangle
  00755	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  0075b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00762	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00769	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0076f	33 c0		 xor	 eax, eax
$LN64@Py_Mangle:
  00771	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00779	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0077c	c1 e8 06	 shr	 eax, 6
  0077f	83 e0 01	 and	 eax, 1
  00782	85 c0		 test	 eax, eax
  00784	74 18		 je	 SHORT $LN65@Py_Mangle
  00786	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0078e	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00794	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv360[rsp], rax
  0079c	eb 16		 jmp	 SHORT $LN66@Py_Mangle
$LN65@Py_Mangle:
  0079e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  007a6	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  007ac	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv360[rsp], rax
$LN66@Py_Mangle:
  007b4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv360[rsp]
  007bc	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv369[rsp], rax
  007c4	eb 45		 jmp	 SHORT $LN69@Py_Mangle
$LN68@Py_Mangle:
  007c6	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  007ce	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  007d6	75 1c		 jne	 SHORT $LN67@Py_Mangle
  007d8	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  007de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  007e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  007ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  007f2	33 c0		 xor	 eax, eax
$LN67@Py_Mangle:
  007f4	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  007fc	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00803	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv369[rsp], rax
$LN69@Py_Mangle:
  0080b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv369[rsp]
  00813	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00817	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv482[rsp], eax
  0081e	e9 5e 03 00 00	 jmp	 $LN91@Py_Mangle
$LN90@Py_Mangle:
  00823	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0082b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0082f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00835	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0083a	85 c0		 test	 eax, eax
  0083c	75 1c		 jne	 SHORT $LN70@Py_Mangle
  0083e	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00844	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0084b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00852	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00858	33 c0		 xor	 eax, eax
$LN70@Py_Mangle:
  0085a	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00862	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00865	c1 e8 07	 shr	 eax, 7
  00868	83 e0 01	 and	 eax, 1
  0086b	85 c0		 test	 eax, eax
  0086d	75 1c		 jne	 SHORT $LN71@Py_Mangle
  0086f	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00875	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0087c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00883	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00889	33 c0		 xor	 eax, eax
$LN71@Py_Mangle:
  0088b	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00893	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00896	c1 e8 02	 shr	 eax, 2
  00899	83 e0 07	 and	 eax, 7
  0089c	83 f8 02	 cmp	 eax, 2
  0089f	0f 85 6a 01 00
	00		 jne	 $LN88@Py_Mangle
  008a5	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  008ad	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  008b1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  008b7	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  008bc	85 c0		 test	 eax, eax
  008be	75 1c		 jne	 SHORT $LN72@Py_Mangle
  008c0	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  008c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  008cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  008d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  008da	33 c0		 xor	 eax, eax
$LN72@Py_Mangle:
  008dc	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  008e4	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  008e7	c1 e8 05	 shr	 eax, 5
  008ea	83 e0 01	 and	 eax, 1
  008ed	85 c0		 test	 eax, eax
  008ef	0f 84 bd 00 00
	00		 je	 $LN78@Py_Mangle
  008f5	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  008fd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00901	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00907	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0090c	85 c0		 test	 eax, eax
  0090e	75 1c		 jne	 SHORT $LN73@Py_Mangle
  00910	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00916	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0091d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00924	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0092a	33 c0		 xor	 eax, eax
$LN73@Py_Mangle:
  0092c	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00934	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00937	c1 e8 07	 shr	 eax, 7
  0093a	83 e0 01	 and	 eax, 1
  0093d	85 c0		 test	 eax, eax
  0093f	75 1c		 jne	 SHORT $LN74@Py_Mangle
  00941	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00947	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0094e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00955	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0095b	33 c0		 xor	 eax, eax
$LN74@Py_Mangle:
  0095d	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00965	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00968	c1 e8 06	 shr	 eax, 6
  0096b	83 e0 01	 and	 eax, 1
  0096e	85 c0		 test	 eax, eax
  00970	74 18		 je	 SHORT $LN75@Py_Mangle
  00972	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0097a	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00980	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv425[rsp], rax
  00988	eb 16		 jmp	 SHORT $LN76@Py_Mangle
$LN75@Py_Mangle:
  0098a	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00992	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00998	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv425[rsp], rax
$LN76@Py_Mangle:
  009a0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv425[rsp]
  009a8	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv434[rsp], rax
  009b0	eb 45		 jmp	 SHORT $LN79@Py_Mangle
$LN78@Py_Mangle:
  009b2	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  009ba	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  009c2	75 1c		 jne	 SHORT $LN77@Py_Mangle
  009c4	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  009ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  009d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  009d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009de	33 c0		 xor	 eax, eax
$LN77@Py_Mangle:
  009e0	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  009e8	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  009ef	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv434[rsp], rax
$LN79@Py_Mangle:
  009f7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv434[rsp]
  009ff	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00a03	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv481[rsp], eax
  00a0a	e9 64 01 00 00	 jmp	 $LN89@Py_Mangle
$LN88@Py_Mangle:
  00a0f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00a17	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00a1b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00a21	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00a26	85 c0		 test	 eax, eax
  00a28	75 1c		 jne	 SHORT $LN80@Py_Mangle
  00a2a	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00a30	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00a37	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00a3e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a44	33 c0		 xor	 eax, eax
$LN80@Py_Mangle:
  00a46	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00a4e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00a51	c1 e8 05	 shr	 eax, 5
  00a54	83 e0 01	 and	 eax, 1
  00a57	85 c0		 test	 eax, eax
  00a59	0f 84 bd 00 00
	00		 je	 $LN86@Py_Mangle
  00a5f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00a67	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00a6b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00a71	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00a76	85 c0		 test	 eax, eax
  00a78	75 1c		 jne	 SHORT $LN81@Py_Mangle
  00a7a	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00a80	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00a87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00a8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a94	33 c0		 xor	 eax, eax
$LN81@Py_Mangle:
  00a96	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00a9e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00aa1	c1 e8 07	 shr	 eax, 7
  00aa4	83 e0 01	 and	 eax, 1
  00aa7	85 c0		 test	 eax, eax
  00aa9	75 1c		 jne	 SHORT $LN82@Py_Mangle
  00aab	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00ab1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00ab8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00abf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00ac5	33 c0		 xor	 eax, eax
$LN82@Py_Mangle:
  00ac7	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00acf	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00ad2	c1 e8 06	 shr	 eax, 6
  00ad5	83 e0 01	 and	 eax, 1
  00ad8	85 c0		 test	 eax, eax
  00ada	74 18		 je	 SHORT $LN83@Py_Mangle
  00adc	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00ae4	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00aea	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv470[rsp], rax
  00af2	eb 16		 jmp	 SHORT $LN84@Py_Mangle
$LN83@Py_Mangle:
  00af4	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00afc	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00b02	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv470[rsp], rax
$LN84@Py_Mangle:
  00b0a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv470[rsp]
  00b12	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv479[rsp], rax
  00b1a	eb 45		 jmp	 SHORT $LN87@Py_Mangle
$LN86@Py_Mangle:
  00b1c	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00b24	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00b2c	75 1c		 jne	 SHORT $LN85@Py_Mangle
  00b2e	41 b8 dc 00 00
	00		 mov	 r8d, 220		; 000000dcH
  00b34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00b3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  00b42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00b48	33 c0		 xor	 eax, eax
$LN85@Py_Mangle:
  00b4a	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00b52	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00b59	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv479[rsp], rax
$LN87@Py_Mangle:
  00b61	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv479[rsp]
  00b69	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00b6c	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv481[rsp], eax
$LN89@Py_Mangle:
  00b73	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv481[rsp]
  00b7a	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv482[rsp], eax
$LN91@Py_Mangle:
  00b81	83 bc 24 a8 00
	00 00 5f	 cmp	 DWORD PTR tv482[rsp], 95 ; 0000005fH
  00b89	74 1a		 je	 SHORT $LN21@Py_Mangle
$LN20@Py_Mangle:

; 221  :         Py_INCREF(ident);

  00b8b	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR ident$[rsp]
  00b93	e8 00 00 00 00	 call	 _Py_IncRef

; 222  :         return ident;

  00b98	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00ba0	e9 3e 1f 00 00	 jmp	 $LN22@Py_Mangle
$LN21@Py_Mangle:

; 223  :     }
; 224  :     nlen = PyUnicode_GET_LENGTH(ident);

  00ba5	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00bad	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00bb1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00bb7	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00bbc	85 c0		 test	 eax, eax
  00bbe	75 1c		 jne	 SHORT $LN92@Py_Mangle
  00bc0	41 b8 e0 00 00
	00		 mov	 r8d, 224		; 000000e0H
  00bc6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00bcd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  00bd4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00bda	33 c0		 xor	 eax, eax
$LN92@Py_Mangle:
  00bdc	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00be4	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00be7	c1 e8 07	 shr	 eax, 7
  00bea	83 e0 01	 and	 eax, 1
  00bed	85 c0		 test	 eax, eax
  00bef	75 1c		 jne	 SHORT $LN93@Py_Mangle
  00bf1	41 b8 e0 00 00
	00		 mov	 r8d, 224		; 000000e0H
  00bf7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00bfe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  00c05	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c0b	33 c0		 xor	 eax, eax
$LN93@Py_Mangle:
  00c0d	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00c15	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00c19	48 89 44 24 48	 mov	 QWORD PTR nlen$[rsp], rax

; 225  :     plen = PyUnicode_GET_LENGTH(privateobj);

  00c1e	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  00c26	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00c2a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00c30	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00c35	85 c0		 test	 eax, eax
  00c37	75 1c		 jne	 SHORT $LN94@Py_Mangle
  00c39	41 b8 e1 00 00
	00		 mov	 r8d, 225		; 000000e1H
  00c3f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00c46	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00c4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c53	33 c0		 xor	 eax, eax
$LN94@Py_Mangle:
  00c55	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  00c5d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00c60	c1 e8 07	 shr	 eax, 7
  00c63	83 e0 01	 and	 eax, 1
  00c66	85 c0		 test	 eax, eax
  00c68	75 1c		 jne	 SHORT $LN95@Py_Mangle
  00c6a	41 b8 e1 00 00
	00		 mov	 r8d, 225		; 000000e1H
  00c70	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00c77	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00c7e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c84	33 c0		 xor	 eax, eax
$LN95@Py_Mangle:
  00c86	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  00c8e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00c92	48 89 44 24 40	 mov	 QWORD PTR plen$[rsp], rax

; 226  :     /* Don't mangle __id__ or names with dots.
; 227  : 
; 228  :        The only time a name with a dot can occur is when
; 229  :        we are compiling an import statement that has a
; 230  :        package name.
; 231  : 
; 232  :        TODO(jhylton): Decide whether we want to support
; 233  :        mangling of the module name, e.g. __M.X.
; 234  :     */
; 235  :     if ((PyUnicode_READ_CHAR(ident, nlen-1) == '_' &&
; 236  :          PyUnicode_READ_CHAR(ident, nlen-2) == '_') ||
; 237  :         PyUnicode_FindChar(ident, '.', 0, nlen, 1) != -1) {

  00c97	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00c9f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00ca3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00ca9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00cae	85 c0		 test	 eax, eax
  00cb0	75 1c		 jne	 SHORT $LN96@Py_Mangle
  00cb2	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00cb8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00cbf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  00cc6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00ccc	33 c0		 xor	 eax, eax
$LN96@Py_Mangle:
  00cce	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00cd6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00cd9	c1 e8 07	 shr	 eax, 7
  00cdc	83 e0 01	 and	 eax, 1
  00cdf	85 c0		 test	 eax, eax
  00ce1	75 1c		 jne	 SHORT $LN97@Py_Mangle
  00ce3	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00ce9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00cf0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  00cf7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00cfd	33 c0		 xor	 eax, eax
$LN97@Py_Mangle:
  00cff	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00d07	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00d0b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00d11	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00d16	85 c0		 test	 eax, eax
  00d18	75 1c		 jne	 SHORT $LN98@Py_Mangle
  00d1a	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00d20	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00d27	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00d2e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00d34	33 c0		 xor	 eax, eax
$LN98@Py_Mangle:
  00d36	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00d3e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00d41	c1 e8 07	 shr	 eax, 7
  00d44	83 e0 01	 and	 eax, 1
  00d47	85 c0		 test	 eax, eax
  00d49	75 1c		 jne	 SHORT $LN99@Py_Mangle
  00d4b	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00d51	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00d58	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00d5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00d65	33 c0		 xor	 eax, eax
$LN99@Py_Mangle:
  00d67	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00d6f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00d72	c1 e8 02	 shr	 eax, 2
  00d75	83 e0 07	 and	 eax, 7
  00d78	83 f8 01	 cmp	 eax, 1
  00d7b	0f 85 75 01 00
	00		 jne	 $LN128@Py_Mangle
  00d81	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00d89	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00d8d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00d93	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00d98	85 c0		 test	 eax, eax
  00d9a	75 1c		 jne	 SHORT $LN100@Py_Mangle
  00d9c	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00da2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00da9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00db0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00db6	33 c0		 xor	 eax, eax
$LN100@Py_Mangle:
  00db8	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00dc0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00dc3	c1 e8 05	 shr	 eax, 5
  00dc6	83 e0 01	 and	 eax, 1
  00dc9	85 c0		 test	 eax, eax
  00dcb	0f 84 bd 00 00
	00		 je	 $LN106@Py_Mangle
  00dd1	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00dd9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00ddd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00de3	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00de8	85 c0		 test	 eax, eax
  00dea	75 1c		 jne	 SHORT $LN101@Py_Mangle
  00dec	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00df2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00df9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00e00	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e06	33 c0		 xor	 eax, eax
$LN101@Py_Mangle:
  00e08	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00e10	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00e13	c1 e8 07	 shr	 eax, 7
  00e16	83 e0 01	 and	 eax, 1
  00e19	85 c0		 test	 eax, eax
  00e1b	75 1c		 jne	 SHORT $LN102@Py_Mangle
  00e1d	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00e23	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00e2a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00e31	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e37	33 c0		 xor	 eax, eax
$LN102@Py_Mangle:
  00e39	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00e41	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00e44	c1 e8 06	 shr	 eax, 6
  00e47	83 e0 01	 and	 eax, 1
  00e4a	85 c0		 test	 eax, eax
  00e4c	74 18		 je	 SHORT $LN103@Py_Mangle
  00e4e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00e56	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00e5c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv588[rsp], rax
  00e64	eb 16		 jmp	 SHORT $LN104@Py_Mangle
$LN103@Py_Mangle:
  00e66	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00e6e	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00e74	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv588[rsp], rax
$LN104@Py_Mangle:
  00e7c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv588[rsp]
  00e84	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv597[rsp], rax
  00e8c	eb 45		 jmp	 SHORT $LN107@Py_Mangle
$LN106@Py_Mangle:
  00e8e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00e96	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00e9e	75 1c		 jne	 SHORT $LN105@Py_Mangle
  00ea0	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00ea6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00ead	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  00eb4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00eba	33 c0		 xor	 eax, eax
$LN105@Py_Mangle:
  00ebc	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00ec4	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00ecb	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv597[rsp], rax
$LN107@Py_Mangle:
  00ed3	48 8b 44 24 48	 mov	 rax, QWORD PTR nlen$[rsp]
  00ed8	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv597[rsp]
  00ee0	48 03 c8	 add	 rcx, rax
  00ee3	48 8b c1	 mov	 rax, rcx
  00ee6	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  00eea	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv715[rsp], eax
  00ef1	e9 6a 03 00 00	 jmp	 $LN129@Py_Mangle
$LN128@Py_Mangle:
  00ef6	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00efe	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00f02	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00f08	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00f0d	85 c0		 test	 eax, eax
  00f0f	75 1c		 jne	 SHORT $LN108@Py_Mangle
  00f11	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00f17	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00f1e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00f25	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00f2b	33 c0		 xor	 eax, eax
$LN108@Py_Mangle:
  00f2d	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00f35	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00f38	c1 e8 07	 shr	 eax, 7
  00f3b	83 e0 01	 and	 eax, 1
  00f3e	85 c0		 test	 eax, eax
  00f40	75 1c		 jne	 SHORT $LN109@Py_Mangle
  00f42	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00f48	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00f4f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00f56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00f5c	33 c0		 xor	 eax, eax
$LN109@Py_Mangle:
  00f5e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00f66	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00f69	c1 e8 02	 shr	 eax, 2
  00f6c	83 e0 07	 and	 eax, 7
  00f6f	83 f8 02	 cmp	 eax, 2
  00f72	0f 85 70 01 00
	00		 jne	 $LN126@Py_Mangle
  00f78	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00f80	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00f84	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00f8a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00f8f	85 c0		 test	 eax, eax
  00f91	75 1c		 jne	 SHORT $LN110@Py_Mangle
  00f93	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00f99	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00fa0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00fa7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00fad	33 c0		 xor	 eax, eax
$LN110@Py_Mangle:
  00faf	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00fb7	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00fba	c1 e8 05	 shr	 eax, 5
  00fbd	83 e0 01	 and	 eax, 1
  00fc0	85 c0		 test	 eax, eax
  00fc2	0f 84 bd 00 00
	00		 je	 $LN116@Py_Mangle
  00fc8	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  00fd0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00fd4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00fda	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00fdf	85 c0		 test	 eax, eax
  00fe1	75 1c		 jne	 SHORT $LN111@Py_Mangle
  00fe3	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  00fe9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00ff0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00ff7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00ffd	33 c0		 xor	 eax, eax
$LN111@Py_Mangle:
  00fff	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01007	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0100a	c1 e8 07	 shr	 eax, 7
  0100d	83 e0 01	 and	 eax, 1
  01010	85 c0		 test	 eax, eax
  01012	75 1c		 jne	 SHORT $LN112@Py_Mangle
  01014	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  0101a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0102e	33 c0		 xor	 eax, eax
$LN112@Py_Mangle:
  01030	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01038	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0103b	c1 e8 06	 shr	 eax, 6
  0103e	83 e0 01	 and	 eax, 1
  01041	85 c0		 test	 eax, eax
  01043	74 18		 je	 SHORT $LN113@Py_Mangle
  01045	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0104d	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01053	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv654[rsp], rax
  0105b	eb 16		 jmp	 SHORT $LN114@Py_Mangle
$LN113@Py_Mangle:
  0105d	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01065	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0106b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv654[rsp], rax
$LN114@Py_Mangle:
  01073	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv654[rsp]
  0107b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv663[rsp], rax
  01083	eb 45		 jmp	 SHORT $LN117@Py_Mangle
$LN116@Py_Mangle:
  01085	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0108d	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01095	75 1c		 jne	 SHORT $LN115@Py_Mangle
  01097	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  0109d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  010a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  010ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  010b1	33 c0		 xor	 eax, eax
$LN115@Py_Mangle:
  010b3	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  010bb	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  010c2	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv663[rsp], rax
$LN117@Py_Mangle:
  010ca	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv663[rsp]
  010d2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nlen$[rsp]
  010d7	0f b7 44 48 fe	 movzx	 eax, WORD PTR [rax+rcx*2-2]
  010dc	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv714[rsp], eax
  010e3	e9 6a 01 00 00	 jmp	 $LN127@Py_Mangle
$LN126@Py_Mangle:
  010e8	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  010f0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  010f4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  010fa	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  010ff	85 c0		 test	 eax, eax
  01101	75 1c		 jne	 SHORT $LN118@Py_Mangle
  01103	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  01109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0111d	33 c0		 xor	 eax, eax
$LN118@Py_Mangle:
  0111f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01127	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0112a	c1 e8 05	 shr	 eax, 5
  0112d	83 e0 01	 and	 eax, 1
  01130	85 c0		 test	 eax, eax
  01132	0f 84 bd 00 00
	00		 je	 $LN124@Py_Mangle
  01138	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01140	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01144	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0114a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0114f	85 c0		 test	 eax, eax
  01151	75 1c		 jne	 SHORT $LN119@Py_Mangle
  01153	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  01159	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0116d	33 c0		 xor	 eax, eax
$LN119@Py_Mangle:
  0116f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01177	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0117a	c1 e8 07	 shr	 eax, 7
  0117d	83 e0 01	 and	 eax, 1
  01180	85 c0		 test	 eax, eax
  01182	75 1c		 jne	 SHORT $LN120@Py_Mangle
  01184	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  0118a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0119e	33 c0		 xor	 eax, eax
$LN120@Py_Mangle:
  011a0	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  011a8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  011ab	c1 e8 06	 shr	 eax, 6
  011ae	83 e0 01	 and	 eax, 1
  011b1	85 c0		 test	 eax, eax
  011b3	74 18		 je	 SHORT $LN121@Py_Mangle
  011b5	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  011bd	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  011c3	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv701[rsp], rax
  011cb	eb 16		 jmp	 SHORT $LN122@Py_Mangle
$LN121@Py_Mangle:
  011cd	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  011d5	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  011db	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv701[rsp], rax
$LN122@Py_Mangle:
  011e3	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv701[rsp]
  011eb	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv710[rsp], rax
  011f3	eb 45		 jmp	 SHORT $LN125@Py_Mangle
$LN124@Py_Mangle:
  011f5	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  011fd	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01205	75 1c		 jne	 SHORT $LN123@Py_Mangle
  01207	41 b8 eb 00 00
	00		 mov	 r8d, 235		; 000000ebH
  0120d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  0121b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01221	33 c0		 xor	 eax, eax
$LN123@Py_Mangle:
  01223	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0122b	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01232	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv710[rsp], rax
$LN125@Py_Mangle:
  0123a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv710[rsp]
  01242	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nlen$[rsp]
  01247	8b 44 88 fc	 mov	 eax, DWORD PTR [rax+rcx*4-4]
  0124b	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv714[rsp], eax
$LN127@Py_Mangle:
  01252	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR tv714[rsp]
  01259	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv715[rsp], eax
$LN129@Py_Mangle:
  01260	83 bc 24 e8 00
	00 00 5f	 cmp	 DWORD PTR tv715[rsp], 95 ; 0000005fH
  01268	0f 85 d3 05 00
	00		 jne	 $LN17@Py_Mangle
  0126e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01276	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0127a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01280	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01285	85 c0		 test	 eax, eax
  01287	75 1c		 jne	 SHORT $LN130@Py_Mangle
  01289	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  0128f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  0129d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  012a3	33 c0		 xor	 eax, eax
$LN130@Py_Mangle:
  012a5	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  012ad	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  012b0	c1 e8 07	 shr	 eax, 7
  012b3	83 e0 01	 and	 eax, 1
  012b6	85 c0		 test	 eax, eax
  012b8	75 1c		 jne	 SHORT $LN131@Py_Mangle
  012ba	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  012c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  012c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  012ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  012d4	33 c0		 xor	 eax, eax
$LN131@Py_Mangle:
  012d6	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  012de	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  012e2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  012e8	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  012ed	85 c0		 test	 eax, eax
  012ef	75 1c		 jne	 SHORT $LN132@Py_Mangle
  012f1	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  012f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  012fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0130b	33 c0		 xor	 eax, eax
$LN132@Py_Mangle:
  0130d	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01315	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01318	c1 e8 07	 shr	 eax, 7
  0131b	83 e0 01	 and	 eax, 1
  0131e	85 c0		 test	 eax, eax
  01320	75 1c		 jne	 SHORT $LN133@Py_Mangle
  01322	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  01328	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0132f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0133c	33 c0		 xor	 eax, eax
$LN133@Py_Mangle:
  0133e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01346	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01349	c1 e8 02	 shr	 eax, 2
  0134c	83 e0 07	 and	 eax, 7
  0134f	83 f8 01	 cmp	 eax, 1
  01352	0f 85 75 01 00
	00		 jne	 $LN162@Py_Mangle
  01358	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01360	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01364	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0136a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0136f	85 c0		 test	 eax, eax
  01371	75 1c		 jne	 SHORT $LN134@Py_Mangle
  01373	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  01379	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01380	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01387	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0138d	33 c0		 xor	 eax, eax
$LN134@Py_Mangle:
  0138f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01397	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0139a	c1 e8 05	 shr	 eax, 5
  0139d	83 e0 01	 and	 eax, 1
  013a0	85 c0		 test	 eax, eax
  013a2	0f 84 bd 00 00
	00		 je	 $LN140@Py_Mangle
  013a8	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  013b0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  013b4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  013ba	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  013bf	85 c0		 test	 eax, eax
  013c1	75 1c		 jne	 SHORT $LN135@Py_Mangle
  013c3	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  013c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  013d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  013d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  013dd	33 c0		 xor	 eax, eax
$LN135@Py_Mangle:
  013df	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  013e7	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  013ea	c1 e8 07	 shr	 eax, 7
  013ed	83 e0 01	 and	 eax, 1
  013f0	85 c0		 test	 eax, eax
  013f2	75 1c		 jne	 SHORT $LN136@Py_Mangle
  013f4	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  013fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01401	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01408	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0140e	33 c0		 xor	 eax, eax
$LN136@Py_Mangle:
  01410	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01418	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0141b	c1 e8 06	 shr	 eax, 6
  0141e	83 e0 01	 and	 eax, 1
  01421	85 c0		 test	 eax, eax
  01423	74 18		 je	 SHORT $LN137@Py_Mangle
  01425	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0142d	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01433	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv786[rsp], rax
  0143b	eb 16		 jmp	 SHORT $LN138@Py_Mangle
$LN137@Py_Mangle:
  0143d	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01445	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0144b	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv786[rsp], rax
$LN138@Py_Mangle:
  01453	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv786[rsp]
  0145b	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv795[rsp], rax
  01463	eb 45		 jmp	 SHORT $LN141@Py_Mangle
$LN140@Py_Mangle:
  01465	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0146d	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01475	75 1c		 jne	 SHORT $LN139@Py_Mangle
  01477	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  0147d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01484	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  0148b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01491	33 c0		 xor	 eax, eax
$LN139@Py_Mangle:
  01493	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0149b	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  014a2	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv795[rsp], rax
$LN141@Py_Mangle:
  014aa	48 8b 44 24 48	 mov	 rax, QWORD PTR nlen$[rsp]
  014af	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv795[rsp]
  014b7	48 03 c8	 add	 rcx, rax
  014ba	48 8b c1	 mov	 rax, rcx
  014bd	0f b6 40 fe	 movzx	 eax, BYTE PTR [rax-2]
  014c1	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv913[rsp], eax
  014c8	e9 6a 03 00 00	 jmp	 $LN163@Py_Mangle
$LN162@Py_Mangle:
  014cd	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  014d5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  014d9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  014df	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  014e4	85 c0		 test	 eax, eax
  014e6	75 1c		 jne	 SHORT $LN142@Py_Mangle
  014e8	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  014ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  014f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  014fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01502	33 c0		 xor	 eax, eax
$LN142@Py_Mangle:
  01504	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0150c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0150f	c1 e8 07	 shr	 eax, 7
  01512	83 e0 01	 and	 eax, 1
  01515	85 c0		 test	 eax, eax
  01517	75 1c		 jne	 SHORT $LN143@Py_Mangle
  01519	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  0151f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01526	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0152d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01533	33 c0		 xor	 eax, eax
$LN143@Py_Mangle:
  01535	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0153d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01540	c1 e8 02	 shr	 eax, 2
  01543	83 e0 07	 and	 eax, 7
  01546	83 f8 02	 cmp	 eax, 2
  01549	0f 85 70 01 00
	00		 jne	 $LN160@Py_Mangle
  0154f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01557	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0155b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01561	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01566	85 c0		 test	 eax, eax
  01568	75 1c		 jne	 SHORT $LN144@Py_Mangle
  0156a	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  01570	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01577	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0157e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01584	33 c0		 xor	 eax, eax
$LN144@Py_Mangle:
  01586	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0158e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01591	c1 e8 05	 shr	 eax, 5
  01594	83 e0 01	 and	 eax, 1
  01597	85 c0		 test	 eax, eax
  01599	0f 84 bd 00 00
	00		 je	 $LN150@Py_Mangle
  0159f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  015a7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  015ab	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  015b1	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  015b6	85 c0		 test	 eax, eax
  015b8	75 1c		 jne	 SHORT $LN145@Py_Mangle
  015ba	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  015c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  015c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  015ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  015d4	33 c0		 xor	 eax, eax
$LN145@Py_Mangle:
  015d6	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  015de	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  015e1	c1 e8 07	 shr	 eax, 7
  015e4	83 e0 01	 and	 eax, 1
  015e7	85 c0		 test	 eax, eax
  015e9	75 1c		 jne	 SHORT $LN146@Py_Mangle
  015eb	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  015f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  015f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  015ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01605	33 c0		 xor	 eax, eax
$LN146@Py_Mangle:
  01607	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0160f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01612	c1 e8 06	 shr	 eax, 6
  01615	83 e0 01	 and	 eax, 1
  01618	85 c0		 test	 eax, eax
  0161a	74 18		 je	 SHORT $LN147@Py_Mangle
  0161c	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01624	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0162a	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv852[rsp], rax
  01632	eb 16		 jmp	 SHORT $LN148@Py_Mangle
$LN147@Py_Mangle:
  01634	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0163c	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01642	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv852[rsp], rax
$LN148@Py_Mangle:
  0164a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv852[rsp]
  01652	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv861[rsp], rax
  0165a	eb 45		 jmp	 SHORT $LN151@Py_Mangle
$LN150@Py_Mangle:
  0165c	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01664	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  0166c	75 1c		 jne	 SHORT $LN149@Py_Mangle
  0166e	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  01674	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0167b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  01682	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01688	33 c0		 xor	 eax, eax
$LN149@Py_Mangle:
  0168a	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01692	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01699	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv861[rsp], rax
$LN151@Py_Mangle:
  016a1	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR tv861[rsp]
  016a9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nlen$[rsp]
  016ae	0f b7 44 48 fc	 movzx	 eax, WORD PTR [rax+rcx*2-4]
  016b3	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv912[rsp], eax
  016ba	e9 6a 01 00 00	 jmp	 $LN161@Py_Mangle
$LN160@Py_Mangle:
  016bf	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  016c7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  016cb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  016d1	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  016d6	85 c0		 test	 eax, eax
  016d8	75 1c		 jne	 SHORT $LN152@Py_Mangle
  016da	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  016e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  016e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  016ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  016f4	33 c0		 xor	 eax, eax
$LN152@Py_Mangle:
  016f6	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  016fe	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01701	c1 e8 05	 shr	 eax, 5
  01704	83 e0 01	 and	 eax, 1
  01707	85 c0		 test	 eax, eax
  01709	0f 84 bd 00 00
	00		 je	 $LN158@Py_Mangle
  0170f	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01717	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0171b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01721	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01726	85 c0		 test	 eax, eax
  01728	75 1c		 jne	 SHORT $LN153@Py_Mangle
  0172a	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  01730	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01737	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HLLBNIDD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0173e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01744	33 c0		 xor	 eax, eax
$LN153@Py_Mangle:
  01746	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0174e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01751	c1 e8 07	 shr	 eax, 7
  01754	83 e0 01	 and	 eax, 1
  01757	85 c0		 test	 eax, eax
  01759	75 1c		 jne	 SHORT $LN154@Py_Mangle
  0175b	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  01761	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01768	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@MHLBMGFO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0176f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01775	33 c0		 xor	 eax, eax
$LN154@Py_Mangle:
  01777	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0177f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01782	c1 e8 06	 shr	 eax, 6
  01785	83 e0 01	 and	 eax, 1
  01788	85 c0		 test	 eax, eax
  0178a	74 18		 je	 SHORT $LN155@Py_Mangle
  0178c	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01794	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0179a	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv899[rsp], rax
  017a2	eb 16		 jmp	 SHORT $LN156@Py_Mangle
$LN155@Py_Mangle:
  017a4	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  017ac	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  017b2	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv899[rsp], rax
$LN156@Py_Mangle:
  017ba	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR tv899[rsp]
  017c2	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv908[rsp], rax
  017ca	eb 45		 jmp	 SHORT $LN159@Py_Mangle
$LN158@Py_Mangle:
  017cc	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  017d4	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  017dc	75 1c		 jne	 SHORT $LN157@Py_Mangle
  017de	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  017e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  017eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@PHDKBABG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd@
  017f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  017f8	33 c0		 xor	 eax, eax
$LN157@Py_Mangle:
  017fa	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01802	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01809	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv908[rsp], rax
$LN159@Py_Mangle:
  01811	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR tv908[rsp]
  01819	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nlen$[rsp]
  0181e	8b 44 88 f8	 mov	 eax, DWORD PTR [rax+rcx*4-8]
  01822	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv912[rsp], eax
$LN161@Py_Mangle:
  01829	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR tv912[rsp]
  01830	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv913[rsp], eax
$LN163@Py_Mangle:
  01837	83 bc 24 28 01
	00 00 5f	 cmp	 DWORD PTR tv913[rsp], 95 ; 0000005fH
  0183f	74 28		 je	 SHORT $LN18@Py_Mangle
$LN17@Py_Mangle:
  01841	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  01849	4c 8b 4c 24 48	 mov	 r9, QWORD PTR nlen$[rsp]
  0184e	45 33 c0	 xor	 r8d, r8d
  01851	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  01856	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR ident$[rsp]
  0185e	e8 00 00 00 00	 call	 PyUnicode_FindChar
  01863	48 83 f8 ff	 cmp	 rax, -1
  01867	74 1a		 je	 SHORT $LN19@Py_Mangle
$LN18@Py_Mangle:

; 238  :         Py_INCREF(ident);

  01869	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR ident$[rsp]
  01871	e8 00 00 00 00	 call	 _Py_IncRef

; 239  :         return ident; /* Don't mangle __whatever__ */

  01876	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0187e	e9 60 12 00 00	 jmp	 $LN22@Py_Mangle
$LN19@Py_Mangle:

; 240  :     }
; 241  :     /* Strip leading underscores from class name */
; 242  :     ipriv = 0;

  01883	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR ipriv$[rsp], 0
$LN16@Py_Mangle:

; 243  :     while (PyUnicode_READ_CHAR(privateobj, ipriv) == '_')

  0188c	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01894	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01898	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0189e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  018a3	85 c0		 test	 eax, eax
  018a5	75 1c		 jne	 SHORT $LN164@Py_Mangle
  018a7	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  018ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  018b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  018bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  018c1	33 c0		 xor	 eax, eax
$LN164@Py_Mangle:
  018c3	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  018cb	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  018ce	c1 e8 07	 shr	 eax, 7
  018d1	83 e0 01	 and	 eax, 1
  018d4	85 c0		 test	 eax, eax
  018d6	75 1c		 jne	 SHORT $LN165@Py_Mangle
  018d8	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  018de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  018e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  018ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  018f2	33 c0		 xor	 eax, eax
$LN165@Py_Mangle:
  018f4	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  018fc	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01900	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01906	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0190b	85 c0		 test	 eax, eax
  0190d	75 1c		 jne	 SHORT $LN166@Py_Mangle
  0190f	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01915	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0191c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01923	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01929	33 c0		 xor	 eax, eax
$LN166@Py_Mangle:
  0192b	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01933	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01936	c1 e8 07	 shr	 eax, 7
  01939	83 e0 01	 and	 eax, 1
  0193c	85 c0		 test	 eax, eax
  0193e	75 1c		 jne	 SHORT $LN167@Py_Mangle
  01940	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01946	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0194d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@GDEJHALP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ@
  01954	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0195a	33 c0		 xor	 eax, eax
$LN167@Py_Mangle:
  0195c	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01964	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01967	c1 e8 02	 shr	 eax, 2
  0196a	83 e0 07	 and	 eax, 7
  0196d	83 f8 01	 cmp	 eax, 1
  01970	0f 85 74 01 00
	00		 jne	 $LN196@Py_Mangle
  01976	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  0197e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01982	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01988	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0198d	85 c0		 test	 eax, eax
  0198f	75 1c		 jne	 SHORT $LN168@Py_Mangle
  01991	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01997	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0199e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@
  019a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  019ab	33 c0		 xor	 eax, eax
$LN168@Py_Mangle:
  019ad	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  019b5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  019b8	c1 e8 05	 shr	 eax, 5
  019bb	83 e0 01	 and	 eax, 1
  019be	85 c0		 test	 eax, eax
  019c0	0f 84 bd 00 00
	00		 je	 $LN174@Py_Mangle
  019c6	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  019ce	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  019d2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  019d8	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  019dd	85 c0		 test	 eax, eax
  019df	75 1c		 jne	 SHORT $LN169@Py_Mangle
  019e1	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  019e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  019ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@
  019f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  019fb	33 c0		 xor	 eax, eax
$LN169@Py_Mangle:
  019fd	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01a05	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01a08	c1 e8 07	 shr	 eax, 7
  01a0b	83 e0 01	 and	 eax, 1
  01a0e	85 c0		 test	 eax, eax
  01a10	75 1c		 jne	 SHORT $LN170@Py_Mangle
  01a12	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01a18	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01a1f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@GDEJHALP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ@
  01a26	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01a2c	33 c0		 xor	 eax, eax
$LN170@Py_Mangle:
  01a2e	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01a36	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01a39	c1 e8 06	 shr	 eax, 6
  01a3c	83 e0 01	 and	 eax, 1
  01a3f	85 c0		 test	 eax, eax
  01a41	74 18		 je	 SHORT $LN171@Py_Mangle
  01a43	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01a4b	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01a51	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv992[rsp], rax
  01a59	eb 16		 jmp	 SHORT $LN172@Py_Mangle
$LN171@Py_Mangle:
  01a5b	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01a63	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01a69	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv992[rsp], rax
$LN172@Py_Mangle:
  01a71	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR tv992[rsp]
  01a79	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv1001[rsp], rax
  01a81	eb 45		 jmp	 SHORT $LN175@Py_Mangle
$LN174@Py_Mangle:
  01a83	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01a8b	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01a93	75 1c		 jne	 SHORT $LN173@Py_Mangle
  01a95	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01a9b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01aa2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@BPBJMPEL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ@
  01aa9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01aaf	33 c0		 xor	 eax, eax
$LN173@Py_Mangle:
  01ab1	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01ab9	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01ac0	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv1001[rsp], rax
$LN175@Py_Mangle:
  01ac8	48 8b 44 24 38	 mov	 rax, QWORD PTR ipriv$[rsp]
  01acd	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv1001[rsp]
  01ad5	48 03 c8	 add	 rcx, rax
  01ad8	48 8b c1	 mov	 rax, rcx
  01adb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01ade	89 84 24 68 01
	00 00		 mov	 DWORD PTR tv1116[rsp], eax
  01ae5	e9 68 03 00 00	 jmp	 $LN197@Py_Mangle
$LN196@Py_Mangle:
  01aea	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01af2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01af6	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01afc	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01b01	85 c0		 test	 eax, eax
  01b03	75 1c		 jne	 SHORT $LN176@Py_Mangle
  01b05	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01b0b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01b12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01b19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01b1f	33 c0		 xor	 eax, eax
$LN176@Py_Mangle:
  01b21	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01b29	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01b2c	c1 e8 07	 shr	 eax, 7
  01b2f	83 e0 01	 and	 eax, 1
  01b32	85 c0		 test	 eax, eax
  01b34	75 1c		 jne	 SHORT $LN177@Py_Mangle
  01b36	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01b3c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01b43	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@GDEJHALP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ@
  01b4a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01b50	33 c0		 xor	 eax, eax
$LN177@Py_Mangle:
  01b52	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01b5a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01b5d	c1 e8 02	 shr	 eax, 2
  01b60	83 e0 07	 and	 eax, 7
  01b63	83 f8 02	 cmp	 eax, 2
  01b66	0f 85 6f 01 00
	00		 jne	 $LN194@Py_Mangle
  01b6c	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01b74	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01b78	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01b7e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01b83	85 c0		 test	 eax, eax
  01b85	75 1c		 jne	 SHORT $LN178@Py_Mangle
  01b87	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01b8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01b94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01b9b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01ba1	33 c0		 xor	 eax, eax
$LN178@Py_Mangle:
  01ba3	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01bab	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01bae	c1 e8 05	 shr	 eax, 5
  01bb1	83 e0 01	 and	 eax, 1
  01bb4	85 c0		 test	 eax, eax
  01bb6	0f 84 bd 00 00
	00		 je	 $LN184@Py_Mangle
  01bbc	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01bc4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01bc8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01bce	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01bd3	85 c0		 test	 eax, eax
  01bd5	75 1c		 jne	 SHORT $LN179@Py_Mangle
  01bd7	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01bdd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01be4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01beb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01bf1	33 c0		 xor	 eax, eax
$LN179@Py_Mangle:
  01bf3	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01bfb	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01bfe	c1 e8 07	 shr	 eax, 7
  01c01	83 e0 01	 and	 eax, 1
  01c04	85 c0		 test	 eax, eax
  01c06	75 1c		 jne	 SHORT $LN180@Py_Mangle
  01c08	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01c0e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01c15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@GDEJHALP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ@
  01c1c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01c22	33 c0		 xor	 eax, eax
$LN180@Py_Mangle:
  01c24	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01c2c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01c2f	c1 e8 06	 shr	 eax, 6
  01c32	83 e0 01	 and	 eax, 1
  01c35	85 c0		 test	 eax, eax
  01c37	74 18		 je	 SHORT $LN181@Py_Mangle
  01c39	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01c41	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01c47	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv1057[rsp], rax
  01c4f	eb 16		 jmp	 SHORT $LN182@Py_Mangle
$LN181@Py_Mangle:
  01c51	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01c59	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01c5f	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv1057[rsp], rax
$LN182@Py_Mangle:
  01c67	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR tv1057[rsp]
  01c6f	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv1066[rsp], rax
  01c77	eb 45		 jmp	 SHORT $LN185@Py_Mangle
$LN184@Py_Mangle:
  01c79	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01c81	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01c89	75 1c		 jne	 SHORT $LN183@Py_Mangle
  01c8b	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01c91	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01c98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@BPBJMPEL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ@
  01c9f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01ca5	33 c0		 xor	 eax, eax
$LN183@Py_Mangle:
  01ca7	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01caf	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01cb6	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv1066[rsp], rax
$LN185@Py_Mangle:
  01cbe	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR tv1066[rsp]
  01cc6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ipriv$[rsp]
  01ccb	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  01ccf	89 84 24 80 01
	00 00		 mov	 DWORD PTR tv1115[rsp], eax
  01cd6	e9 69 01 00 00	 jmp	 $LN195@Py_Mangle
$LN194@Py_Mangle:
  01cdb	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01ce3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01ce7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01ced	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01cf2	85 c0		 test	 eax, eax
  01cf4	75 1c		 jne	 SHORT $LN186@Py_Mangle
  01cf6	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01cfc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01d03	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01d0a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01d10	33 c0		 xor	 eax, eax
$LN186@Py_Mangle:
  01d12	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01d1a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01d1d	c1 e8 05	 shr	 eax, 5
  01d20	83 e0 01	 and	 eax, 1
  01d23	85 c0		 test	 eax, eax
  01d25	0f 84 bd 00 00
	00		 je	 $LN192@Py_Mangle
  01d2b	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01d33	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01d37	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01d3d	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01d42	85 c0		 test	 eax, eax
  01d44	75 1c		 jne	 SHORT $LN187@Py_Mangle
  01d46	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01d4c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01d53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@MEIHEDEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?$AA@
  01d5a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01d60	33 c0		 xor	 eax, eax
$LN187@Py_Mangle:
  01d62	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01d6a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01d6d	c1 e8 07	 shr	 eax, 7
  01d70	83 e0 01	 and	 eax, 1
  01d73	85 c0		 test	 eax, eax
  01d75	75 1c		 jne	 SHORT $LN188@Py_Mangle
  01d77	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01d7d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01d84	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@GDEJHALP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ@
  01d8b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01d91	33 c0		 xor	 eax, eax
$LN188@Py_Mangle:
  01d93	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01d9b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01d9e	c1 e8 06	 shr	 eax, 6
  01da1	83 e0 01	 and	 eax, 1
  01da4	85 c0		 test	 eax, eax
  01da6	74 18		 je	 SHORT $LN189@Py_Mangle
  01da8	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01db0	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  01db6	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv1103[rsp], rax
  01dbe	eb 16		 jmp	 SHORT $LN190@Py_Mangle
$LN189@Py_Mangle:
  01dc0	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01dc8	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  01dce	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv1103[rsp], rax
$LN190@Py_Mangle:
  01dd6	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR tv1103[rsp]
  01dde	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv1112[rsp], rax
  01de6	eb 45		 jmp	 SHORT $LN193@Py_Mangle
$LN192@Py_Mangle:
  01de8	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01df0	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01df8	75 1c		 jne	 SHORT $LN191@Py_Mangle
  01dfa	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  01e00	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01e07	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@BPBJMPEL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ@
  01e0e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01e14	33 c0		 xor	 eax, eax
$LN191@Py_Mangle:
  01e16	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  01e1e	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01e25	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv1112[rsp], rax
$LN193@Py_Mangle:
  01e2d	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR tv1112[rsp]
  01e35	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ipriv$[rsp]
  01e3a	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01e3d	89 84 24 80 01
	00 00		 mov	 DWORD PTR tv1115[rsp], eax
$LN195@Py_Mangle:
  01e44	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR tv1115[rsp]
  01e4b	89 84 24 68 01
	00 00		 mov	 DWORD PTR tv1116[rsp], eax
$LN197@Py_Mangle:
  01e52	83 bc 24 68 01
	00 00 5f	 cmp	 DWORD PTR tv1116[rsp], 95 ; 0000005fH
  01e5a	75 12		 jne	 SHORT $LN15@Py_Mangle

; 244  :         ipriv++;

  01e5c	48 8b 44 24 38	 mov	 rax, QWORD PTR ipriv$[rsp]
  01e61	48 ff c0	 inc	 rax
  01e64	48 89 44 24 38	 mov	 QWORD PTR ipriv$[rsp], rax
  01e69	e9 1e fa ff ff	 jmp	 $LN16@Py_Mangle
$LN15@Py_Mangle:

; 245  :     if (ipriv == plen) {

  01e6e	48 8b 44 24 40	 mov	 rax, QWORD PTR plen$[rsp]
  01e73	48 39 44 24 38	 cmp	 QWORD PTR ipriv$[rsp], rax
  01e78	75 1a		 jne	 SHORT $LN14@Py_Mangle

; 246  :         Py_INCREF(ident);

  01e7a	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR ident$[rsp]
  01e82	e8 00 00 00 00	 call	 _Py_IncRef

; 247  :         return ident; /* Don't mangle if class is just underscores */

  01e87	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01e8f	e9 4f 0c 00 00	 jmp	 $LN22@Py_Mangle
$LN14@Py_Mangle:

; 248  :     }
; 249  :     plen -= ipriv;

  01e94	48 8b 44 24 38	 mov	 rax, QWORD PTR ipriv$[rsp]
  01e99	48 8b 4c 24 40	 mov	 rcx, QWORD PTR plen$[rsp]
  01e9e	48 2b c8	 sub	 rcx, rax
  01ea1	48 8b c1	 mov	 rax, rcx
  01ea4	48 89 44 24 40	 mov	 QWORD PTR plen$[rsp], rax

; 250  : 
; 251  :     if (plen + nlen >= PY_SSIZE_T_MAX - 1) {

  01ea9	48 8b 44 24 48	 mov	 rax, QWORD PTR nlen$[rsp]
  01eae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR plen$[rsp]
  01eb3	48 03 c8	 add	 rcx, rax
  01eb6	48 8b c1	 mov	 rax, rcx
  01eb9	48 b9 fe ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775806 ; 7ffffffffffffffeH
  01ec3	48 3b c1	 cmp	 rax, rcx
  01ec6	72 1a		 jb	 SHORT $LN13@Py_Mangle

; 252  :         PyErr_SetString(PyExc_OverflowError,
; 253  :                         "private identifier too large to be mangled");

  01ec8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@FMJEBAFL@private?5identifier?5too?5large?5to?5@
  01ecf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  01ed6	e8 00 00 00 00	 call	 PyErr_SetString

; 254  :         return NULL;

  01edb	33 c0		 xor	 eax, eax
  01edd	e9 01 0c 00 00	 jmp	 $LN22@Py_Mangle
$LN13@Py_Mangle:

; 255  :     }
; 256  : 
; 257  :     maxchar = PyUnicode_MAX_CHAR_VALUE(ident);

  01ee2	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01eea	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01eed	c1 e8 07	 shr	 eax, 7
  01ef0	83 e0 01	 and	 eax, 1
  01ef3	85 c0		 test	 eax, eax
  01ef5	75 1c		 jne	 SHORT $LN198@Py_Mangle
  01ef7	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  01efd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01f04	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  01f0b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01f11	33 c0		 xor	 eax, eax
$LN198@Py_Mangle:
  01f13	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01f1b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01f1f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01f25	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01f2a	85 c0		 test	 eax, eax
  01f2c	75 1c		 jne	 SHORT $LN199@Py_Mangle
  01f2e	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  01f34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01f3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  01f42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01f48	33 c0		 xor	 eax, eax
$LN199@Py_Mangle:
  01f4a	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01f52	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01f55	c1 e8 07	 shr	 eax, 7
  01f58	83 e0 01	 and	 eax, 1
  01f5b	85 c0		 test	 eax, eax
  01f5d	75 1c		 jne	 SHORT $LN200@Py_Mangle
  01f5f	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  01f65	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01f6c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  01f73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01f79	33 c0		 xor	 eax, eax
$LN200@Py_Mangle:
  01f7b	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01f83	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01f86	c1 e8 06	 shr	 eax, 6
  01f89	83 e0 01	 and	 eax, 1
  01f8c	85 c0		 test	 eax, eax
  01f8e	74 10		 je	 SHORT $LN209@Py_Mangle
  01f90	c7 84 24 98 01
	00 00 7f 00 00
	00		 mov	 DWORD PTR tv1196[rsp], 127 ; 0000007fH
  01f9b	e9 40 01 00 00	 jmp	 $LN210@Py_Mangle
$LN209@Py_Mangle:
  01fa0	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01fa8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01fac	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01fb2	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  01fb7	85 c0		 test	 eax, eax
  01fb9	75 1c		 jne	 SHORT $LN201@Py_Mangle
  01fbb	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  01fc1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01fc8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  01fcf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  01fd5	33 c0		 xor	 eax, eax
$LN201@Py_Mangle:
  01fd7	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  01fdf	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01fe2	c1 e8 07	 shr	 eax, 7
  01fe5	83 e0 01	 and	 eax, 1
  01fe8	85 c0		 test	 eax, eax
  01fea	75 1c		 jne	 SHORT $LN202@Py_Mangle
  01fec	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  01ff2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  01ff9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  02000	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02006	33 c0		 xor	 eax, eax
$LN202@Py_Mangle:
  02008	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  02010	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02013	c1 e8 02	 shr	 eax, 2
  02016	83 e0 07	 and	 eax, 7
  02019	83 f8 01	 cmp	 eax, 1
  0201c	75 10		 jne	 SHORT $LN207@Py_Mangle
  0201e	c7 84 24 9c 01
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv1194[rsp], 255 ; 000000ffH
  02029	e9 a4 00 00 00	 jmp	 $LN208@Py_Mangle
$LN207@Py_Mangle:
  0202e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  02036	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0203a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  02040	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  02045	85 c0		 test	 eax, eax
  02047	75 1c		 jne	 SHORT $LN203@Py_Mangle
  02049	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  0204f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@CADGLNLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  0205d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02063	33 c0		 xor	 eax, eax
$LN203@Py_Mangle:
  02065	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0206d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02070	c1 e8 07	 shr	 eax, 7
  02073	83 e0 01	 and	 eax, 1
  02076	85 c0		 test	 eax, eax
  02078	75 1c		 jne	 SHORT $LN204@Py_Mangle
  0207a	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  02080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@JLOEODIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  0208e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02094	33 c0		 xor	 eax, eax
$LN204@Py_Mangle:
  02096	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR ident$[rsp]
  0209e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  020a1	c1 e8 02	 shr	 eax, 2
  020a4	83 e0 07	 and	 eax, 7
  020a7	83 f8 02	 cmp	 eax, 2
  020aa	75 0d		 jne	 SHORT $LN205@Py_Mangle
  020ac	c7 84 24 a0 01
	00 00 ff ff 00
	00		 mov	 DWORD PTR tv1193[rsp], 65535 ; 0000ffffH
  020b7	eb 0b		 jmp	 SHORT $LN206@Py_Mangle
$LN205@Py_Mangle:
  020b9	c7 84 24 a0 01
	00 00 ff ff 10
	00		 mov	 DWORD PTR tv1193[rsp], 1114111 ; 0010ffffH
$LN206@Py_Mangle:
  020c4	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR tv1193[rsp]
  020cb	89 84 24 9c 01
	00 00		 mov	 DWORD PTR tv1194[rsp], eax
$LN208@Py_Mangle:
  020d2	8b 84 24 9c 01
	00 00		 mov	 eax, DWORD PTR tv1194[rsp]
  020d9	89 84 24 98 01
	00 00		 mov	 DWORD PTR tv1196[rsp], eax
$LN210@Py_Mangle:
  020e0	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR tv1196[rsp]
  020e7	89 44 24 30	 mov	 DWORD PTR maxchar$[rsp], eax

; 258  :     if (PyUnicode_MAX_CHAR_VALUE(privateobj) > maxchar)

  020eb	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  020f3	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  020f6	c1 e8 07	 shr	 eax, 7
  020f9	83 e0 01	 and	 eax, 1
  020fc	85 c0		 test	 eax, eax
  020fe	75 1c		 jne	 SHORT $LN211@Py_Mangle
  02100	41 b8 02 01 00
	00		 mov	 r8d, 258		; 00000102H
  02106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0210d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  02114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0211a	33 c0		 xor	 eax, eax
$LN211@Py_Mangle:
  0211c	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  02124	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02128	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0212e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  02133	85 c0		 test	 eax, eax
  02135	75 1c		 jne	 SHORT $LN212@Py_Mangle
  02137	41 b8 02 01 00
	00		 mov	 r8d, 258		; 00000102H
  0213d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0214b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02151	33 c0		 xor	 eax, eax
$LN212@Py_Mangle:
  02153	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  0215b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0215e	c1 e8 07	 shr	 eax, 7
  02161	83 e0 01	 and	 eax, 1
  02164	85 c0		 test	 eax, eax
  02166	75 1c		 jne	 SHORT $LN213@Py_Mangle
  02168	41 b8 02 01 00
	00		 mov	 r8d, 258		; 00000102H
  0216e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0217c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02182	33 c0		 xor	 eax, eax
$LN213@Py_Mangle:
  02184	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  0218c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0218f	c1 e8 06	 shr	 eax, 6
  02192	83 e0 01	 and	 eax, 1
  02195	85 c0		 test	 eax, eax
  02197	74 10		 je	 SHORT $LN222@Py_Mangle
  02199	c7 84 24 a4 01
	00 00 7f 00 00
	00		 mov	 DWORD PTR tv1267[rsp], 127 ; 0000007fH
  021a4	e9 40 01 00 00	 jmp	 $LN223@Py_Mangle
$LN222@Py_Mangle:
  021a9	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  021b1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  021b5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  021bb	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  021c0	85 c0		 test	 eax, eax
  021c2	75 1c		 jne	 SHORT $LN214@Py_Mangle
  021c4	41 b8 02 01 00
	00		 mov	 r8d, 258		; 00000102H
  021ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  021d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  021d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  021de	33 c0		 xor	 eax, eax
$LN214@Py_Mangle:
  021e0	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  021e8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  021eb	c1 e8 07	 shr	 eax, 7
  021ee	83 e0 01	 and	 eax, 1
  021f1	85 c0		 test	 eax, eax
  021f3	75 1c		 jne	 SHORT $LN215@Py_Mangle
  021f5	41 b8 02 01 00
	00		 mov	 r8d, 258		; 00000102H
  021fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  02209	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0220f	33 c0		 xor	 eax, eax
$LN215@Py_Mangle:
  02211	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  02219	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0221c	c1 e8 02	 shr	 eax, 2
  0221f	83 e0 07	 and	 eax, 7
  02222	83 f8 01	 cmp	 eax, 1
  02225	75 10		 jne	 SHORT $LN220@Py_Mangle
  02227	c7 84 24 a8 01
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv1265[rsp], 255 ; 000000ffH
  02232	e9 a4 00 00 00	 jmp	 $LN221@Py_Mangle
$LN220@Py_Mangle:
  02237	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  0223f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02243	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  02249	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0224e	85 c0		 test	 eax, eax
  02250	75 1c		 jne	 SHORT $LN216@Py_Mangle
  02252	41 b8 02 01 00
	00		 mov	 r8d, 258		; 00000102H
  02258	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0225f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  02266	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0226c	33 c0		 xor	 eax, eax
$LN216@Py_Mangle:
  0226e	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  02276	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02279	c1 e8 07	 shr	 eax, 7
  0227c	83 e0 01	 and	 eax, 1
  0227f	85 c0		 test	 eax, eax
  02281	75 1c		 jne	 SHORT $LN217@Py_Mangle
  02283	41 b8 02 01 00
	00		 mov	 r8d, 258		; 00000102H
  02289	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  02297	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0229d	33 c0		 xor	 eax, eax
$LN217@Py_Mangle:
  0229f	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  022a7	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  022aa	c1 e8 02	 shr	 eax, 2
  022ad	83 e0 07	 and	 eax, 7
  022b0	83 f8 02	 cmp	 eax, 2
  022b3	75 0d		 jne	 SHORT $LN218@Py_Mangle
  022b5	c7 84 24 ac 01
	00 00 ff ff 00
	00		 mov	 DWORD PTR tv1264[rsp], 65535 ; 0000ffffH
  022c0	eb 0b		 jmp	 SHORT $LN219@Py_Mangle
$LN218@Py_Mangle:
  022c2	c7 84 24 ac 01
	00 00 ff ff 10
	00		 mov	 DWORD PTR tv1264[rsp], 1114111 ; 0010ffffH
$LN219@Py_Mangle:
  022cd	8b 84 24 ac 01
	00 00		 mov	 eax, DWORD PTR tv1264[rsp]
  022d4	89 84 24 a8 01
	00 00		 mov	 DWORD PTR tv1265[rsp], eax
$LN221@Py_Mangle:
  022db	8b 84 24 a8 01
	00 00		 mov	 eax, DWORD PTR tv1265[rsp]
  022e2	89 84 24 a4 01
	00 00		 mov	 DWORD PTR tv1267[rsp], eax
$LN223@Py_Mangle:
  022e9	8b 44 24 30	 mov	 eax, DWORD PTR maxchar$[rsp]
  022ed	39 84 24 a4 01
	00 00		 cmp	 DWORD PTR tv1267[rsp], eax
  022f4	0f 86 09 02 00
	00		 jbe	 $LN12@Py_Mangle

; 259  :         maxchar = PyUnicode_MAX_CHAR_VALUE(privateobj);

  022fa	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  02302	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02305	c1 e8 07	 shr	 eax, 7
  02308	83 e0 01	 and	 eax, 1
  0230b	85 c0		 test	 eax, eax
  0230d	75 1c		 jne	 SHORT $LN224@Py_Mangle
  0230f	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  02315	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0231c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  02323	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02329	33 c0		 xor	 eax, eax
$LN224@Py_Mangle:
  0232b	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  02333	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02337	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0233d	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  02342	85 c0		 test	 eax, eax
  02344	75 1c		 jne	 SHORT $LN225@Py_Mangle
  02346	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  0234c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02353	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0235a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02360	33 c0		 xor	 eax, eax
$LN225@Py_Mangle:
  02362	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  0236a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0236d	c1 e8 07	 shr	 eax, 7
  02370	83 e0 01	 and	 eax, 1
  02373	85 c0		 test	 eax, eax
  02375	75 1c		 jne	 SHORT $LN226@Py_Mangle
  02377	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  0237d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02384	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0238b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02391	33 c0		 xor	 eax, eax
$LN226@Py_Mangle:
  02393	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  0239b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0239e	c1 e8 06	 shr	 eax, 6
  023a1	83 e0 01	 and	 eax, 1
  023a4	85 c0		 test	 eax, eax
  023a6	74 10		 je	 SHORT $LN235@Py_Mangle
  023a8	c7 84 24 b0 01
	00 00 7f 00 00
	00		 mov	 DWORD PTR tv1339[rsp], 127 ; 0000007fH
  023b3	e9 40 01 00 00	 jmp	 $LN236@Py_Mangle
$LN235@Py_Mangle:
  023b8	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  023c0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  023c4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  023ca	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  023cf	85 c0		 test	 eax, eax
  023d1	75 1c		 jne	 SHORT $LN227@Py_Mangle
  023d3	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  023d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  023e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  023e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  023ed	33 c0		 xor	 eax, eax
$LN227@Py_Mangle:
  023ef	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  023f7	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  023fa	c1 e8 07	 shr	 eax, 7
  023fd	83 e0 01	 and	 eax, 1
  02400	85 c0		 test	 eax, eax
  02402	75 1c		 jne	 SHORT $LN228@Py_Mangle
  02404	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  0240a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02411	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  02418	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0241e	33 c0		 xor	 eax, eax
$LN228@Py_Mangle:
  02420	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  02428	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0242b	c1 e8 02	 shr	 eax, 2
  0242e	83 e0 07	 and	 eax, 7
  02431	83 f8 01	 cmp	 eax, 1
  02434	75 10		 jne	 SHORT $LN233@Py_Mangle
  02436	c7 84 24 b4 01
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv1337[rsp], 255 ; 000000ffH
  02441	e9 a4 00 00 00	 jmp	 $LN234@Py_Mangle
$LN233@Py_Mangle:
  02446	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  0244e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02452	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  02458	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0245d	85 c0		 test	 eax, eax
  0245f	75 1c		 jne	 SHORT $LN229@Py_Mangle
  02461	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  02467	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0246e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@NILPJBNH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  02475	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0247b	33 c0		 xor	 eax, eax
$LN229@Py_Mangle:
  0247d	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  02485	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02488	c1 e8 07	 shr	 eax, 7
  0248b	83 e0 01	 and	 eax, 1
  0248e	85 c0		 test	 eax, eax
  02490	75 1c		 jne	 SHORT $LN230@Py_Mangle
  02492	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  02498	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0249f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HPEBKDME@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAp?$AAr?$AAi?$AAv?$AAa?$AAt?$AAe?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  024a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  024ac	33 c0		 xor	 eax, eax
$LN230@Py_Mangle:
  024ae	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR privateobj$[rsp]
  024b6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  024b9	c1 e8 02	 shr	 eax, 2
  024bc	83 e0 07	 and	 eax, 7
  024bf	83 f8 02	 cmp	 eax, 2
  024c2	75 0d		 jne	 SHORT $LN231@Py_Mangle
  024c4	c7 84 24 b8 01
	00 00 ff ff 00
	00		 mov	 DWORD PTR tv1336[rsp], 65535 ; 0000ffffH
  024cf	eb 0b		 jmp	 SHORT $LN232@Py_Mangle
$LN231@Py_Mangle:
  024d1	c7 84 24 b8 01
	00 00 ff ff 10
	00		 mov	 DWORD PTR tv1336[rsp], 1114111 ; 0010ffffH
$LN232@Py_Mangle:
  024dc	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR tv1336[rsp]
  024e3	89 84 24 b4 01
	00 00		 mov	 DWORD PTR tv1337[rsp], eax
$LN234@Py_Mangle:
  024ea	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR tv1337[rsp]
  024f1	89 84 24 b0 01
	00 00		 mov	 DWORD PTR tv1339[rsp], eax
$LN236@Py_Mangle:
  024f8	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR tv1339[rsp]
  024ff	89 44 24 30	 mov	 DWORD PTR maxchar$[rsp], eax
$LN12@Py_Mangle:

; 260  : 
; 261  :     result = PyUnicode_New(1 + nlen + plen, maxchar);

  02503	48 8b 44 24 48	 mov	 rax, QWORD PTR nlen$[rsp]
  02508	48 8b 4c 24 40	 mov	 rcx, QWORD PTR plen$[rsp]
  0250d	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  02512	8b 54 24 30	 mov	 edx, DWORD PTR maxchar$[rsp]
  02516	48 8b c8	 mov	 rcx, rax
  02519	e8 00 00 00 00	 call	 PyUnicode_New
  0251e	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 262  :     if (!result)

  02523	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  02529	75 07		 jne	 SHORT $LN11@Py_Mangle

; 263  :         return 0;

  0252b	33 c0		 xor	 eax, eax
  0252d	e9 b1 05 00 00	 jmp	 $LN22@Py_Mangle
$LN11@Py_Mangle:
$LN10@Py_Mangle:

; 264  :     /* ident = "_" + priv[ipriv:] + ident # i.e. 1+plen+nlen bytes */
; 265  :     PyUnicode_WRITE(PyUnicode_KIND(result), PyUnicode_DATA(result), 0, '_');

  02532	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02537	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0253b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  02541	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  02546	85 c0		 test	 eax, eax
  02548	75 1c		 jne	 SHORT $LN237@Py_Mangle
  0254a	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  02550	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02557	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  0255e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02564	33 c0		 xor	 eax, eax
$LN237@Py_Mangle:
  02566	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  0256b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0256e	c1 e8 07	 shr	 eax, 7
  02571	83 e0 01	 and	 eax, 1
  02574	85 c0		 test	 eax, eax
  02576	75 1c		 jne	 SHORT $LN238@Py_Mangle
  02578	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  0257e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02585	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CHIDEPLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  0258c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02592	33 c0		 xor	 eax, eax
$LN238@Py_Mangle:
  02594	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02599	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0259c	c1 e8 02	 shr	 eax, 2
  0259f	83 e0 07	 and	 eax, 7
  025a2	89 84 24 bc 01
	00 00		 mov	 DWORD PTR tv1365[rsp], eax
  025a9	83 bc 24 bc 01
	00 00 01	 cmp	 DWORD PTR tv1365[rsp], 1
  025b1	74 13		 je	 SHORT $LN5@Py_Mangle
  025b3	83 bc 24 bc 01
	00 00 02	 cmp	 DWORD PTR tv1365[rsp], 2
  025bb	0f 84 4c 01 00
	00		 je	 $LN4@Py_Mangle
  025c1	e9 93 02 00 00	 jmp	 $LN3@Py_Mangle
$LN5@Py_Mangle:
  025c6	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  025cb	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  025cf	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  025d5	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  025da	85 c0		 test	 eax, eax
  025dc	75 1c		 jne	 SHORT $LN239@Py_Mangle
  025de	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  025e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  025eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  025f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  025f8	33 c0		 xor	 eax, eax
$LN239@Py_Mangle:
  025fa	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  025ff	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02602	c1 e8 05	 shr	 eax, 5
  02605	83 e0 01	 and	 eax, 1
  02608	85 c0		 test	 eax, eax
  0260a	0f 84 ae 00 00
	00		 je	 $LN245@Py_Mangle
  02610	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02615	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02619	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0261f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  02624	85 c0		 test	 eax, eax
  02626	75 1c		 jne	 SHORT $LN240@Py_Mangle
  02628	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  0262e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02635	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  0263c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02642	33 c0		 xor	 eax, eax
$LN240@Py_Mangle:
  02644	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02649	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0264c	c1 e8 07	 shr	 eax, 7
  0264f	83 e0 01	 and	 eax, 1
  02652	85 c0		 test	 eax, eax
  02654	75 1c		 jne	 SHORT $LN241@Py_Mangle
  02656	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  0265c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02663	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CHIDEPLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  0266a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02670	33 c0		 xor	 eax, eax
$LN241@Py_Mangle:
  02672	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02677	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0267a	c1 e8 06	 shr	 eax, 6
  0267d	83 e0 01	 and	 eax, 1
  02680	85 c0		 test	 eax, eax
  02682	74 15		 je	 SHORT $LN242@Py_Mangle
  02684	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02689	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0268f	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv1399[rsp], rax
  02697	eb 13		 jmp	 SHORT $LN243@Py_Mangle
$LN242@Py_Mangle:
  02699	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  0269e	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  026a4	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv1399[rsp], rax
$LN243@Py_Mangle:
  026ac	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR tv1399[rsp]
  026b4	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv1408[rsp], rax
  026bc	eb 3f		 jmp	 SHORT $LN246@Py_Mangle
$LN245@Py_Mangle:
  026be	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  026c3	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  026cb	75 1c		 jne	 SHORT $LN244@Py_Mangle
  026cd	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  026d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  026da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@GFECEDJG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  026e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  026e7	33 c0		 xor	 eax, eax
$LN244@Py_Mangle:
  026e9	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  026ee	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  026f5	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv1408[rsp], rax
$LN246@Py_Mangle:
  026fd	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR tv1408[rsp]
  02705	c6 00 5f	 mov	 BYTE PTR [rax], 95	; 0000005fH
  02708	e9 22 03 00 00	 jmp	 $LN6@Py_Mangle
$LN4@Py_Mangle:
  0270d	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02712	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02716	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0271c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  02721	85 c0		 test	 eax, eax
  02723	75 1c		 jne	 SHORT $LN247@Py_Mangle
  02725	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  0272b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02732	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  02739	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0273f	33 c0		 xor	 eax, eax
$LN247@Py_Mangle:
  02741	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02746	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02749	c1 e8 05	 shr	 eax, 5
  0274c	83 e0 01	 and	 eax, 1
  0274f	85 c0		 test	 eax, eax
  02751	0f 84 ae 00 00
	00		 je	 $LN253@Py_Mangle
  02757	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  0275c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02760	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  02766	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0276b	85 c0		 test	 eax, eax
  0276d	75 1c		 jne	 SHORT $LN248@Py_Mangle
  0276f	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  02775	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0277c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  02783	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02789	33 c0		 xor	 eax, eax
$LN248@Py_Mangle:
  0278b	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02790	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02793	c1 e8 07	 shr	 eax, 7
  02796	83 e0 01	 and	 eax, 1
  02799	85 c0		 test	 eax, eax
  0279b	75 1c		 jne	 SHORT $LN249@Py_Mangle
  0279d	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  027a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  027aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CHIDEPLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  027b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  027b7	33 c0		 xor	 eax, eax
$LN249@Py_Mangle:
  027b9	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  027be	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  027c1	c1 e8 06	 shr	 eax, 6
  027c4	83 e0 01	 and	 eax, 1
  027c7	85 c0		 test	 eax, eax
  027c9	74 15		 je	 SHORT $LN250@Py_Mangle
  027cb	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  027d0	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  027d6	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv1442[rsp], rax
  027de	eb 13		 jmp	 SHORT $LN251@Py_Mangle
$LN250@Py_Mangle:
  027e0	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  027e5	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  027eb	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv1442[rsp], rax
$LN251@Py_Mangle:
  027f3	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR tv1442[rsp]
  027fb	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR tv1451[rsp], rax
  02803	eb 3f		 jmp	 SHORT $LN254@Py_Mangle
$LN253@Py_Mangle:
  02805	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  0280a	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  02812	75 1c		 jne	 SHORT $LN252@Py_Mangle
  02814	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  0281a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02821	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@GFECEDJG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  02828	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0282e	33 c0		 xor	 eax, eax
$LN252@Py_Mangle:
  02830	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02835	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0283c	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR tv1451[rsp], rax
$LN254@Py_Mangle:
  02844	b8 5f 00 00 00	 mov	 eax, 95			; 0000005fH
  02849	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR tv1451[rsp]
  02851	66 89 01	 mov	 WORD PTR [rcx], ax
  02854	e9 d6 01 00 00	 jmp	 $LN6@Py_Mangle
$LN3@Py_Mangle:
  02859	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  0285e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02862	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  02868	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0286d	85 c0		 test	 eax, eax
  0286f	75 1c		 jne	 SHORT $LN255@Py_Mangle
  02871	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  02877	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0287e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  02885	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0288b	33 c0		 xor	 eax, eax
$LN255@Py_Mangle:
  0288d	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02892	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02895	c1 e8 07	 shr	 eax, 7
  02898	83 e0 01	 and	 eax, 1
  0289b	85 c0		 test	 eax, eax
  0289d	75 1c		 jne	 SHORT $LN256@Py_Mangle
  0289f	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  028a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  028ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CHIDEPLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  028b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  028b9	33 c0		 xor	 eax, eax
$LN256@Py_Mangle:
  028bb	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  028c0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  028c3	c1 e8 02	 shr	 eax, 2
  028c6	83 e0 07	 and	 eax, 7
  028c9	83 f8 04	 cmp	 eax, 4
  028cc	74 1c		 je	 SHORT $LN257@Py_Mangle
  028ce	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  028d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  028db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CNI@HNMDOJBP@?$AA?$CI?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?$CJ?$AA?$CI?$AA?5?$AA?$CI?$AA?$CB?$AA?$CB?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr@
  028e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  028e8	33 c0		 xor	 eax, eax
$LN257@Py_Mangle:
  028ea	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  028ef	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  028f3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  028f9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  028fe	85 c0		 test	 eax, eax
  02900	75 1c		 jne	 SHORT $LN258@Py_Mangle
  02902	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  02908	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0290f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  02916	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0291c	33 c0		 xor	 eax, eax
$LN258@Py_Mangle:
  0291e	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02923	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02926	c1 e8 05	 shr	 eax, 5
  02929	83 e0 01	 and	 eax, 1
  0292c	85 c0		 test	 eax, eax
  0292e	0f 84 ae 00 00
	00		 je	 $LN264@Py_Mangle
  02934	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02939	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0293d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  02943	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  02948	85 c0		 test	 eax, eax
  0294a	75 1c		 jne	 SHORT $LN259@Py_Mangle
  0294c	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  02952	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02959	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LMMPDEGI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  02960	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02966	33 c0		 xor	 eax, eax
$LN259@Py_Mangle:
  02968	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  0296d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  02970	c1 e8 07	 shr	 eax, 7
  02973	83 e0 01	 and	 eax, 1
  02976	85 c0		 test	 eax, eax
  02978	75 1c		 jne	 SHORT $LN260@Py_Mangle
  0297a	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  02980	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02987	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CHIDEPLC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  0298e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02994	33 c0		 xor	 eax, eax
$LN260@Py_Mangle:
  02996	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  0299b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0299e	c1 e8 06	 shr	 eax, 6
  029a1	83 e0 01	 and	 eax, 1
  029a4	85 c0		 test	 eax, eax
  029a6	74 15		 je	 SHORT $LN261@Py_Mangle
  029a8	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  029ad	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  029b3	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv1509[rsp], rax
  029bb	eb 13		 jmp	 SHORT $LN262@Py_Mangle
$LN261@Py_Mangle:
  029bd	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  029c2	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  029c8	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv1509[rsp], rax
$LN262@Py_Mangle:
  029d0	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR tv1509[rsp]
  029d8	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv1518[rsp], rax
  029e0	eb 3f		 jmp	 SHORT $LN265@Py_Mangle
$LN264@Py_Mangle:
  029e2	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  029e7	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  029ef	75 1c		 jne	 SHORT $LN263@Py_Mangle
  029f1	41 b8 09 01 00
	00		 mov	 r8d, 265		; 00000109H
  029f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  029fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@GFECEDJG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  02a05	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02a0b	33 c0		 xor	 eax, eax
$LN263@Py_Mangle:
  02a0d	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  02a12	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  02a19	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv1518[rsp], rax
$LN265@Py_Mangle:
  02a21	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR tv1518[rsp]
  02a29	c7 00 5f 00 00
	00		 mov	 DWORD PTR [rax], 95	; 0000005fH
$LN6@Py_Mangle:
  02a2f	33 c0		 xor	 eax, eax
  02a31	85 c0		 test	 eax, eax
  02a33	0f 85 f9 fa ff
	ff		 jne	 $LN10@Py_Mangle

; 266  :     if (PyUnicode_CopyCharacters(result, 1, privateobj, ipriv, plen) < 0) {

  02a39	48 8b 44 24 40	 mov	 rax, QWORD PTR plen$[rsp]
  02a3e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02a43	4c 8b 4c 24 38	 mov	 r9, QWORD PTR ipriv$[rsp]
  02a48	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR privateobj$[rsp]
  02a50	ba 01 00 00 00	 mov	 edx, 1
  02a55	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  02a5a	e8 00 00 00 00	 call	 PyUnicode_CopyCharacters
  02a5f	48 85 c0	 test	 rax, rax
  02a62	7d 0e		 jge	 SHORT $LN2@Py_Mangle

; 267  :         Py_DECREF(result);

  02a64	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  02a69	e8 00 00 00 00	 call	 _Py_DecRef

; 268  :         return NULL;

  02a6e	33 c0		 xor	 eax, eax
  02a70	eb 71		 jmp	 SHORT $LN22@Py_Mangle
$LN2@Py_Mangle:

; 269  :     }
; 270  :     if (PyUnicode_CopyCharacters(result, plen+1, ident, 0, nlen) < 0) {

  02a72	48 8b 44 24 40	 mov	 rax, QWORD PTR plen$[rsp]
  02a77	48 ff c0	 inc	 rax
  02a7a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nlen$[rsp]
  02a7f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02a84	45 33 c9	 xor	 r9d, r9d
  02a87	4c 8b 84 24 08
	02 00 00	 mov	 r8, QWORD PTR ident$[rsp]
  02a8f	48 8b d0	 mov	 rdx, rax
  02a92	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  02a97	e8 00 00 00 00	 call	 PyUnicode_CopyCharacters
  02a9c	48 85 c0	 test	 rax, rax
  02a9f	7d 0e		 jge	 SHORT $LN1@Py_Mangle

; 271  :         Py_DECREF(result);

  02aa1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  02aa6	e8 00 00 00 00	 call	 _Py_DecRef

; 272  :         return NULL;

  02aab	33 c0		 xor	 eax, eax
  02aad	eb 34		 jmp	 SHORT $LN22@Py_Mangle
$LN1@Py_Mangle:

; 273  :     }
; 274  :     assert(_PyUnicode_CheckConsistency(result, 1));

  02aaf	ba 01 00 00 00	 mov	 edx, 1
  02ab4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  02ab9	e8 00 00 00 00	 call	 _PyUnicode_CheckConsistency
  02abe	85 c0		 test	 eax, eax
  02ac0	75 1c		 jne	 SHORT $LN266@Py_Mangle
  02ac2	41 b8 12 01 00
	00		 mov	 r8d, 274		; 00000112H
  02ac8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  02acf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@GMKAAHMG@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAr?$AAe?$AAs?$AAu@
  02ad6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  02adc	33 c0		 xor	 eax, eax
$LN266@Py_Mangle:

; 275  :     return result;

  02ade	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
$LN22@Py_Mangle:

; 276  : }

  02ae3	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  02aea	c3		 ret	 0
_Py_Mangle ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CO@NJBFBBJI@?$AAc?$AAo?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0M@KFOBDMCC@no?5symtable?$AA@		; `string'
PUBLIC	??_C@_07DIBBIFIJ@__doc__?$AA@			; `string'
PUBLIC	PyAST_CompileEx
EXTRN	PyExc_SystemError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	PySymtable_Build:PROC
EXTRN	PyFuture_FromAST:PROC
EXTRN	PyUnicode_DecodeFSDefault:PROC
EXTRN	PyUnicode_InternFromString:PROC
_BSS	SEGMENT
__doc__	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\python\compile.c
pdata	SEGMENT
$pdata$PyAST_CompileEx DD imagerel $LN14
	DD	imagerel $LN14+512
	DD	imagerel $unwind$PyAST_CompileEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyAST_CompileEx DD 021b01H
	DD	013011bH
xdata	ENDS
;	COMDAT ??_C@_1CO@NJBFBBJI@?$AAc?$AAo?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@NJBFBBJI@?$AAc?$AAo?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'P', 00H
	DB	'y', 00H, 'E', 00H, 'r', 00H, 'r', 00H, '_', 00H, 'O', 00H, 'c'
	DB	00H, 'c', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'd', 00H
	DB	'(', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KFOBDMCC@no?5symtable?$AA@
CONST	SEGMENT
??_C@_0M@KFOBDMCC@no?5symtable?$AA@ DB 'no symtable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIBBIFIJ@__doc__?$AA@
CONST	SEGMENT
??_C@_07DIBBIFIJ@__doc__?$AA@ DB '__doc__', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyAST_CompileEx
_TEXT	SEGMENT
local_flags$ = 32
merged$ = 36
co$ = 40
c$ = 48
tv81 = 128
mod$ = 160
filename$ = 168
flags$ = 176
optimize$ = 184
arena$ = 192
PyAST_CompileEx PROC					; COMDAT

; 293  : {

$LN14:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 294  :     struct compiler c;
; 295  :     PyCodeObject *co = NULL;

  0001b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR co$[rsp], 0

; 296  :     PyCompilerFlags local_flags;
; 297  :     int merged;
; 298  : 
; 299  :     if (!__doc__) {

  00024	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR __doc__, 0
  0002c	75 24		 jne	 SHORT $LN8@PyAST_Comp

; 300  :         __doc__ = PyUnicode_InternFromString("__doc__");

  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DIBBIFIJ@__doc__?$AA@
  00035	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0003a	48 89 05 00 00
	00 00		 mov	 QWORD PTR __doc__, rax

; 301  :         if (!__doc__)

  00041	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR __doc__, 0
  00049	75 07		 jne	 SHORT $LN7@PyAST_Comp

; 302  :             return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	e9 a6 01 00 00	 jmp	 $LN9@PyAST_Comp
$LN7@PyAST_Comp:
$LN8@PyAST_Comp:

; 303  :     }
; 304  : 
; 305  :     if (!compiler_init(&c))

  00052	48 8d 4c 24 30	 lea	 rcx, QWORD PTR c$[rsp]
  00057	e8 00 00 00 00	 call	 compiler_init
  0005c	85 c0		 test	 eax, eax
  0005e	75 07		 jne	 SHORT $LN6@PyAST_Comp

; 306  :         return NULL;

  00060	33 c0		 xor	 eax, eax
  00062	e9 91 01 00 00	 jmp	 $LN9@PyAST_Comp
$LN6@PyAST_Comp:

; 307  :     c.c_filename = filename;

  00067	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR filename$[rsp]
  0006f	48 89 44 24 30	 mov	 QWORD PTR c$[rsp], rax

; 308  :     c.c_filename_obj = PyUnicode_DecodeFSDefault(filename);

  00074	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  0007c	e8 00 00 00 00	 call	 PyUnicode_DecodeFSDefault
  00081	48 89 44 24 38	 mov	 QWORD PTR c$[rsp+8], rax

; 309  :     if (!c.c_filename_obj)

  00086	48 83 7c 24 38
	00		 cmp	 QWORD PTR c$[rsp+8], 0
  0008c	75 05		 jne	 SHORT $LN5@PyAST_Comp

; 310  :         goto finally;

  0008e	e9 28 01 00 00	 jmp	 $finally$22337
$LN5@PyAST_Comp:

; 311  :     c.c_arena = arena;

  00093	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR arena$[rsp]
  0009b	48 89 44 24 78	 mov	 QWORD PTR c$[rsp+72], rax

; 312  :     c.c_future = PyFuture_FromAST(mod, filename);

  000a0	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  000a8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR mod$[rsp]
  000b0	e8 00 00 00 00	 call	 PyFuture_FromAST
  000b5	48 89 44 24 48	 mov	 QWORD PTR c$[rsp+24], rax

; 313  :     if (c.c_future == NULL)

  000ba	48 83 7c 24 48
	00		 cmp	 QWORD PTR c$[rsp+24], 0
  000c0	75 05		 jne	 SHORT $LN4@PyAST_Comp

; 314  :         goto finally;

  000c2	e9 f4 00 00 00	 jmp	 $finally$22337
$LN4@PyAST_Comp:

; 315  :     if (!flags) {

  000c7	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR flags$[rsp], 0
  000d0	75 15		 jne	 SHORT $LN3@PyAST_Comp

; 316  :         local_flags.cf_flags = 0;

  000d2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR local_flags$[rsp], 0

; 317  :         flags = &local_flags;

  000da	48 8d 44 24 20	 lea	 rax, QWORD PTR local_flags$[rsp]
  000df	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR flags$[rsp], rax
$LN3@PyAST_Comp:

; 318  :     }
; 319  :     merged = c.c_future->ff_features | flags->cf_flags;

  000e7	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp+24]
  000ec	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR flags$[rsp]
  000f4	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000f6	8b 00		 mov	 eax, DWORD PTR [rax]
  000f8	0b c1		 or	 eax, ecx
  000fa	89 44 24 24	 mov	 DWORD PTR merged$[rsp], eax

; 320  :     c.c_future->ff_features = merged;

  000fe	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp+24]
  00103	8b 4c 24 24	 mov	 ecx, DWORD PTR merged$[rsp]
  00107	89 08		 mov	 DWORD PTR [rax], ecx

; 321  :     flags->cf_flags = merged;

  00109	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  00111	8b 4c 24 24	 mov	 ecx, DWORD PTR merged$[rsp]
  00115	89 08		 mov	 DWORD PTR [rax], ecx

; 322  :     c.c_flags = flags;

  00117	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  0011f	48 89 44 24 50	 mov	 QWORD PTR c$[rsp+32], rax

; 323  :     c.c_optimize = (optimize == -1) ? Py_OptimizeFlag : optimize;

  00124	83 bc 24 b8 00
	00 00 ff	 cmp	 DWORD PTR optimize$[rsp], -1
  0012c	75 0f		 jne	 SHORT $LN11@PyAST_Comp
  0012e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Py_OptimizeFlag
  00134	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv81[rsp], eax
  0013b	eb 0e		 jmp	 SHORT $LN12@PyAST_Comp
$LN11@PyAST_Comp:
  0013d	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR optimize$[rsp]
  00144	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv81[rsp], eax
$LN12@PyAST_Comp:
  0014b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv81[rsp]
  00152	89 44 24 58	 mov	 DWORD PTR c$[rsp+40], eax

; 324  :     c.c_nestlevel = 0;

  00156	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR c$[rsp+48], 0

; 325  : 
; 326  :     c.c_st = PySymtable_Build(mod, filename, c.c_future);

  0015e	4c 8b 44 24 48	 mov	 r8, QWORD PTR c$[rsp+24]
  00163	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  0016b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR mod$[rsp]
  00173	e8 00 00 00 00	 call	 PySymtable_Build
  00178	48 89 44 24 40	 mov	 QWORD PTR c$[rsp+16], rax

; 327  :     if (c.c_st == NULL) {

  0017d	48 83 7c 24 40
	00		 cmp	 QWORD PTR c$[rsp+16], 0
  00183	75 1f		 jne	 SHORT $LN2@PyAST_Comp

; 328  :         if (!PyErr_Occurred())

  00185	e8 00 00 00 00	 call	 PyErr_Occurred
  0018a	48 85 c0	 test	 rax, rax
  0018d	75 13		 jne	 SHORT $LN1@PyAST_Comp

; 329  :             PyErr_SetString(PyExc_SystemError, "no symtable");

  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@KFOBDMCC@no?5symtable?$AA@
  00196	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0019d	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@PyAST_Comp:

; 330  :         goto finally;

  001a2	eb 17		 jmp	 SHORT $finally$22337
$LN2@PyAST_Comp:

; 331  :     }
; 332  : 
; 333  :     co = compiler_mod(&c, mod);

  001a4	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR mod$[rsp]
  001ac	48 8d 4c 24 30	 lea	 rcx, QWORD PTR c$[rsp]
  001b1	e8 00 00 00 00	 call	 compiler_mod
  001b6	48 89 44 24 28	 mov	 QWORD PTR co$[rsp], rax
$finally$22337:

; 334  : 
; 335  :  finally:
; 336  :     compiler_free(&c);

  001bb	48 8d 4c 24 30	 lea	 rcx, QWORD PTR c$[rsp]
  001c0	e8 00 00 00 00	 call	 compiler_free

; 337  :     assert(co || PyErr_Occurred());

  001c5	48 83 7c 24 28
	00		 cmp	 QWORD PTR co$[rsp], 0
  001cb	75 26		 jne	 SHORT $LN13@PyAST_Comp
  001cd	e8 00 00 00 00	 call	 PyErr_Occurred
  001d2	48 85 c0	 test	 rax, rax
  001d5	75 1c		 jne	 SHORT $LN13@PyAST_Comp
  001d7	41 b8 51 01 00
	00		 mov	 r8d, 337		; 00000151H
  001dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@NJBFBBJI@?$AAc?$AAo?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f1	33 c0		 xor	 eax, eax
$LN13@PyAST_Comp:

; 338  :     return co;

  001f3	48 8b 44 24 28	 mov	 rax, QWORD PTR co$[rsp]
$LN9@PyAST_Comp:

; 339  : }

  001f8	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001ff	c3		 ret	 0
PyAST_CompileEx ENDP
_TEXT	ENDS
EXTRN	PyList_New:PROC
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_init DD imagerel compiler_init
	DD	imagerel compiler_init+69
	DD	imagerel $unwind$compiler_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_init DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_init
_TEXT	SEGMENT
c$ = 48
compiler_init PROC					; COMDAT

; 280  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 281  :     memset(c, 0, sizeof(struct compiler));

  00009	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  0000f	33 d2		 xor	 edx, edx
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$[rsp]
  00016	e8 00 00 00 00	 call	 memset

; 282  : 
; 283  :     c->c_stack = PyList_New(0);

  0001b	33 c9		 xor	 ecx, ecx
  0001d	e8 00 00 00 00	 call	 PyList_New
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$[rsp]
  00027	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 284  :     if (!c->c_stack)

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  00030	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00035	75 04		 jne	 SHORT $LN1@compiler_i

; 285  :         return 0;

  00037	33 c0		 xor	 eax, eax
  00039	eb 05		 jmp	 SHORT $LN2@compiler_i
$LN1@compiler_i:

; 286  : 
; 287  :     return 1;

  0003b	b8 01 00 00 00	 mov	 eax, 1
$LN2@compiler_i:

; 288  : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
compiler_init ENDP
_TEXT	ENDS
PUBLIC	PyNode_Compile
EXTRN	PyArena_Free:PROC
EXTRN	PyAST_FromNode:PROC
EXTRN	PyArena_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNode_Compile DD imagerel $LN5
	DD	imagerel $LN5+139
	DD	imagerel $unwind$PyNode_Compile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNode_Compile DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyNode_Compile
_TEXT	SEGMENT
arena$ = 48
co$ = 56
mod$ = 64
n$ = 96
filename$ = 104
PyNode_Compile PROC					; COMDAT

; 343  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 344  :     PyCodeObject *co = NULL;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR co$[rsp], 0

; 345  :     mod_ty mod;
; 346  :     PyArena *arena = PyArena_New();

  00017	e8 00 00 00 00	 call	 PyArena_New
  0001c	48 89 44 24 30	 mov	 QWORD PTR arena$[rsp], rax

; 347  :     if (!arena)

  00021	48 83 7c 24 30
	00		 cmp	 QWORD PTR arena$[rsp], 0
  00027	75 04		 jne	 SHORT $LN2@PyNode_Com

; 348  :         return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 59		 jmp	 SHORT $LN3@PyNode_Com
$LN2@PyNode_Com:

; 349  :     mod = PyAST_FromNode(n, NULL, filename, arena);

  0002d	4c 8b 4c 24 30	 mov	 r9, QWORD PTR arena$[rsp]
  00032	4c 8b 44 24 68	 mov	 r8, QWORD PTR filename$[rsp]
  00037	33 d2		 xor	 edx, edx
  00039	48 8b 4c 24 60	 mov	 rcx, QWORD PTR n$[rsp]
  0003e	e8 00 00 00 00	 call	 PyAST_FromNode
  00043	48 89 44 24 40	 mov	 QWORD PTR mod$[rsp], rax

; 350  :     if (mod)

  00048	48 83 7c 24 40
	00		 cmp	 QWORD PTR mod$[rsp], 0
  0004e	74 27		 je	 SHORT $LN1@PyNode_Com

; 351  :         co = PyAST_Compile(mod, filename, NULL, arena);

  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR arena$[rsp]
  00055	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005a	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  00060	45 33 c0	 xor	 r8d, r8d
  00063	48 8b 54 24 68	 mov	 rdx, QWORD PTR filename$[rsp]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mod$[rsp]
  0006d	e8 00 00 00 00	 call	 PyAST_CompileEx
  00072	48 89 44 24 38	 mov	 QWORD PTR co$[rsp], rax
$LN1@PyNode_Com:

; 352  :     PyArena_Free(arena);

  00077	48 8b 4c 24 30	 mov	 rcx, QWORD PTR arena$[rsp]
  0007c	e8 00 00 00 00	 call	 PyArena_Free

; 353  :     return co;

  00081	48 8b 44 24 38	 mov	 rax, QWORD PTR co$[rsp]
$LN3@PyNode_Com:

; 354  : }

  00086	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0008a	c3		 ret	 0
PyNode_Compile ENDP
_TEXT	ENDS
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PySymtable_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_free DD imagerel compiler_free
	DD	imagerel compiler_free+106
	DD	imagerel $unwind$compiler_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_free DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_free
_TEXT	SEGMENT
c$ = 48
compiler_free PROC					; COMDAT

; 358  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 359  :     if (c->c_st)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  0000e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00013	74 0e		 je	 SHORT $LN3@compiler_f

; 360  :         PySymtable_Free(c->c_st);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  0001a	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0001e	e8 00 00 00 00	 call	 PySymtable_Free
$LN3@compiler_f:

; 361  :     if (c->c_future)

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  00028	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0002d	74 0e		 je	 SHORT $LN2@compiler_f

; 362  :         PyObject_Free(c->c_future);

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  00034	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00038	e8 00 00 00 00	 call	 _PyObject_DebugFree
$LN2@compiler_f:

; 363  :     if (c->c_filename_obj)

  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  00042	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00047	74 0e		 je	 SHORT $LN1@compiler_f

; 364  :         Py_DECREF(c->c_filename_obj);

  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  0004e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00052	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@compiler_f:

; 365  :     Py_DECREF(c->c_stack);

  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  0005c	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00060	e8 00 00 00 00	 call	 _Py_DecRef

; 366  : }

  00065	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00069	c3		 ret	 0
compiler_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@HHMOOPMI@module?5kind?5?$CFd?5should?5not?5be?5pos@ ; `string'
PUBLIC	??_C@_0BN@PLBJONFI@suite?5should?5not?5be?5possible?$AA@ ; `string'
PUBLIC	??_C@_08DLJNCJAP@?$DMmodule?$DO?$AA@		; `string'
EXTRN	PyErr_Format:PROC
_BSS	SEGMENT
?module@?1??compiler_mod@@9@9 DQ 01H DUP (?)		; `compiler_mod'::`2'::module
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_mod DD imagerel compiler_mod
	DD	imagerel compiler_mod+547
	DD	imagerel $unwind$compiler_mod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_mod DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0CG@HHMOOPMI@module?5kind?5?$CFd?5should?5not?5be?5pos@
CONST	SEGMENT
??_C@_0CG@HHMOOPMI@module?5kind?5?$CFd?5should?5not?5be?5pos@ DB 'module '
	DB	'kind %d should not be possible', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PLBJONFI@suite?5should?5not?5be?5possible?$AA@
CONST	SEGMENT
??_C@_0BN@PLBJONFI@suite?5should?5not?5be?5possible?$AA@ DB 'suite should'
	DB	' not be possible', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DLJNCJAP@?$DMmodule?$DO?$AA@
CONST	SEGMENT
??_C@_08DLJNCJAP@?$DMmodule?$DO?$AA@ DB '<module>', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_mod
_TEXT	SEGMENT
addNone$ = 48
co$ = 56
_i$23021 = 64
seq$23022 = 72
elt$23027 = 80
tv75 = 88
tv87 = 96
c$ = 128
mod$ = 136
compiler_mod PROC					; COMDAT

; 1282 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1283 :     PyCodeObject *co;
; 1284 :     int addNone = 1;

  0000e	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR addNone$[rsp], 1

; 1285 :     static PyObject *module;
; 1286 :     if (!module) {

  00016	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?module@?1??compiler_mod@@9@9, 0
  0001e	75 24		 jne	 SHORT $LN16@compiler_m

; 1287 :         module = PyUnicode_InternFromString("<module>");

  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DLJNCJAP@?$DMmodule?$DO?$AA@
  00027	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0002c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?module@?1??compiler_mod@@9@9, rax

; 1288 :         if (!module)

  00033	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?module@?1??compiler_mod@@9@9, 0
  0003b	75 07		 jne	 SHORT $LN15@compiler_m

; 1289 :             return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 da 01 00 00	 jmp	 $LN17@compiler_m
$LN15@compiler_m:
$LN16@compiler_m:

; 1290 :     }
; 1291 :     /* Use 0 for firstlineno initially, will fixup in assemble(). */
; 1292 :     if (!compiler_enter_scope(c, module, COMPILER_SCOPE_MODULE, mod, 0))

  00044	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0004c	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR mod$[rsp]
  00054	45 33 c0	 xor	 r8d, r8d
  00057	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?module@?1??compiler_mod@@9@9
  0005e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00066	e8 00 00 00 00	 call	 compiler_enter_scope
  0006b	85 c0		 test	 eax, eax
  0006d	75 07		 jne	 SHORT $LN14@compiler_m

; 1293 :         return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	e9 a8 01 00 00	 jmp	 $LN17@compiler_m
$LN14@compiler_m:

; 1294 :     switch (mod->kind) {

  00076	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mod$[rsp]
  0007e	8b 00		 mov	 eax, DWORD PTR [rax]
  00080	89 44 24 58	 mov	 DWORD PTR tv75[rsp], eax
  00084	83 7c 24 58 01	 cmp	 DWORD PTR tv75[rsp], 1
  00089	74 22		 je	 SHORT $LN11@compiler_m
  0008b	83 7c 24 58 02	 cmp	 DWORD PTR tv75[rsp], 2
  00090	74 51		 je	 SHORT $LN9@compiler_m
  00092	83 7c 24 58 03	 cmp	 DWORD PTR tv75[rsp], 3
  00097	0f 84 e8 00 00
	00		 je	 $LN4@compiler_m
  0009d	83 7c 24 58 04	 cmp	 DWORD PTR tv75[rsp], 4
  000a2	0f 84 15 01 00
	00		 je	 $LN2@compiler_m
  000a8	e9 27 01 00 00	 jmp	 $LN1@compiler_m
$LN11@compiler_m:

; 1295 :     case Module_kind:
; 1296 :         if (!compiler_body(c, mod->v.Module.body)) {

  000ad	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mod$[rsp]
  000b5	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000b9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000c1	e8 00 00 00 00	 call	 compiler_body
  000c6	85 c0		 test	 eax, eax
  000c8	75 14		 jne	 SHORT $LN10@compiler_m

; 1297 :             compiler_exit_scope(c);

  000ca	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000d2	e8 00 00 00 00	 call	 compiler_exit_scope

; 1298 :             return 0;

  000d7	33 c0		 xor	 eax, eax
  000d9	e9 40 01 00 00	 jmp	 $LN17@compiler_m
$LN10@compiler_m:

; 1299 :         }
; 1300 :         break;

  000de	e9 13 01 00 00	 jmp	 $LN12@compiler_m
$LN9@compiler_m:

; 1301 :     case Interactive_kind:
; 1302 :         c->c_interactive = 1;

  000e3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000eb	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [rax+44], 1

; 1303 :         VISIT_SEQ_IN_SCOPE(c, stmt,
; 1304 :                                 mod->v.Interactive.body);

  000f2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mod$[rsp]
  000fa	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000fe	48 89 44 24 48	 mov	 QWORD PTR seq$23022[rsp], rax
  00103	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR _i$23021[rsp], 0
  0010b	eb 0a		 jmp	 SHORT $LN8@compiler_m
$LN7@compiler_m:
  0010d	8b 44 24 40	 mov	 eax, DWORD PTR _i$23021[rsp]
  00111	ff c0		 inc	 eax
  00113	89 44 24 40	 mov	 DWORD PTR _i$23021[rsp], eax
$LN8@compiler_m:
  00117	48 83 7c 24 48
	00		 cmp	 QWORD PTR seq$23022[rsp], 0
  0011d	75 0b		 jne	 SHORT $LN19@compiler_m
  0011f	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv87[rsp], 0
  00128	eb 0d		 jmp	 SHORT $LN20@compiler_m
$LN19@compiler_m:
  0012a	48 8b 44 24 48	 mov	 rax, QWORD PTR seq$23022[rsp]
  0012f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00132	48 89 44 24 60	 mov	 QWORD PTR tv87[rsp], rax
$LN20@compiler_m:
  00137	48 63 44 24 40	 movsxd	 rax, DWORD PTR _i$23021[rsp]
  0013c	48 3b 44 24 60	 cmp	 rax, QWORD PTR tv87[rsp]
  00141	7d 40		 jge	 SHORT $LN6@compiler_m
  00143	48 63 44 24 40	 movsxd	 rax, DWORD PTR _i$23021[rsp]
  00148	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seq$23022[rsp]
  0014d	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00152	48 89 44 24 50	 mov	 QWORD PTR elt$23027[rsp], rax
  00157	48 8b 54 24 50	 mov	 rdx, QWORD PTR elt$23027[rsp]
  0015c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00164	e8 00 00 00 00	 call	 compiler_visit_stmt
  00169	85 c0		 test	 eax, eax
  0016b	75 14		 jne	 SHORT $LN5@compiler_m
  0016d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00175	e8 00 00 00 00	 call	 compiler_exit_scope
  0017a	33 c0		 xor	 eax, eax
  0017c	e9 9d 00 00 00	 jmp	 $LN17@compiler_m
$LN5@compiler_m:
  00181	eb 8a		 jmp	 SHORT $LN7@compiler_m
$LN6@compiler_m:

; 1305 :         break;

  00183	eb 71		 jmp	 SHORT $LN12@compiler_m
$LN4@compiler_m:

; 1306 :     case Expression_kind:
; 1307 :         VISIT_IN_SCOPE(c, expr, mod->v.Expression.body);

  00185	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mod$[rsp]
  0018d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00191	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00199	e8 00 00 00 00	 call	 compiler_visit_expr
  0019e	85 c0		 test	 eax, eax
  001a0	75 11		 jne	 SHORT $LN3@compiler_m
  001a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001aa	e8 00 00 00 00	 call	 compiler_exit_scope
  001af	33 c0		 xor	 eax, eax
  001b1	eb 6b		 jmp	 SHORT $LN17@compiler_m
$LN3@compiler_m:

; 1308 :         addNone = 0;

  001b3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR addNone$[rsp], 0

; 1309 :         break;

  001bb	eb 39		 jmp	 SHORT $LN12@compiler_m
$LN2@compiler_m:

; 1310 :     case Suite_kind:
; 1311 :         PyErr_SetString(PyExc_SystemError,
; 1312 :                         "suite should not be possible");

  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PLBJONFI@suite?5should?5not?5be?5possible?$AA@
  001c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  001cb	e8 00 00 00 00	 call	 PyErr_SetString

; 1313 :         return 0;

  001d0	33 c0		 xor	 eax, eax
  001d2	eb 4a		 jmp	 SHORT $LN17@compiler_m
$LN1@compiler_m:

; 1314 :     default:
; 1315 :         PyErr_Format(PyExc_SystemError,
; 1316 :                      "module kind %d should not be possible",
; 1317 :                      mod->kind);

  001d4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mod$[rsp]
  001dc	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@HHMOOPMI@module?5kind?5?$CFd?5should?5not?5be?5pos@
  001e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  001ed	e8 00 00 00 00	 call	 PyErr_Format

; 1318 :         return 0;

  001f2	33 c0		 xor	 eax, eax
  001f4	eb 28		 jmp	 SHORT $LN17@compiler_m
$LN12@compiler_m:

; 1319 :     }
; 1320 :     co = assemble(c, addNone);

  001f6	8b 54 24 30	 mov	 edx, DWORD PTR addNone$[rsp]
  001fa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00202	e8 00 00 00 00	 call	 assemble
  00207	48 89 44 24 38	 mov	 QWORD PTR co$[rsp], rax

; 1321 :     compiler_exit_scope(c);

  0020c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00214	e8 00 00 00 00	 call	 compiler_exit_scope

; 1322 :     return co;

  00219	48 8b 44 24 38	 mov	 rax, QWORD PTR co$[rsp]
$LN17@compiler_m:

; 1323 : }

  0021e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00222	c3		 ret	 0
compiler_mod ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@ ; `string'
EXTRN	PyList_Append:PROC
EXTRN	PyCapsule_New:PROC
EXTRN	PyDict_New:PROC
EXTRN	PyDict_Size:PROC
EXTRN	PySymtable_Lookup:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyObject_DebugMalloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_enter_scope DD imagerel compiler_enter_scope
	DD	imagerel compiler_enter_scope+802
	DD	imagerel $unwind$compiler_enter_scope
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_enter_scope DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT ??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@
CONST	SEGMENT
??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@ DB 'compile.c compiler'
	DB	' unit', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_enter_scope
_TEXT	SEGMENT
u$ = 32
capsule$22608 = 40
c$ = 64
name$ = 72
scope_type$ = 80
key$ = 88
lineno$ = 96
compiler_enter_scope PROC				; COMDAT

; 512  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 513  :     struct compiler_unit *u;
; 514  : 
; 515  :     u = (struct compiler_unit *)PyObject_Malloc(sizeof(
; 516  :                                             struct compiler_unit));

  00018	b9 c0 01 00 00	 mov	 ecx, 448		; 000001c0H
  0001d	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00022	48 89 44 24 20	 mov	 QWORD PTR u$[rsp], rax

; 517  :     if (!u) {

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR u$[rsp], 0
  0002d	75 0c		 jne	 SHORT $LN19@compiler_e

; 518  :         PyErr_NoMemory();

  0002f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 519  :         return 0;

  00034	33 c0		 xor	 eax, eax
  00036	e9 e2 02 00 00	 jmp	 $LN20@compiler_e
$LN19@compiler_e:

; 520  :     }
; 521  :     memset(u, 0, sizeof(struct compiler_unit));

  0003b	41 b8 c0 01 00
	00		 mov	 r8d, 448		; 000001c0H
  00041	33 d2		 xor	 edx, edx
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  00048	e8 00 00 00 00	 call	 memset

; 522  :     u->u_scope_type = scope_type;

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00052	8b 4c 24 50	 mov	 ecx, DWORD PTR scope_type$[rsp]
  00056	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 523  :     u->u_argcount = 0;

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0005e	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [rax+80], 0

; 524  :     u->u_kwonlyargcount = 0;

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0006a	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [rax+84], 0

; 525  :     u->u_ste = PySymtable_Lookup(c->c_st, key);

  00071	48 8b 54 24 58	 mov	 rdx, QWORD PTR key$[rsp]
  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0007b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0007f	e8 00 00 00 00	 call	 PySymtable_Lookup
  00084	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  00089	48 89 01	 mov	 QWORD PTR [rcx], rax

; 526  :     if (!u->u_ste) {

  0008c	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00091	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00095	75 11		 jne	 SHORT $LN18@compiler_e

; 527  :         compiler_unit_free(u);

  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  0009c	e8 00 00 00 00	 call	 compiler_unit_free

; 528  :         return 0;

  000a1	33 c0		 xor	 eax, eax
  000a3	e9 75 02 00 00	 jmp	 $LN20@compiler_e
$LN18@compiler_e:

; 529  :     }
; 530  :     Py_INCREF(name);

  000a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  000ad	e8 00 00 00 00	 call	 _Py_IncRef

; 531  :     u->u_name = name;

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  000b7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  000bc	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 532  :     u->u_varnames = list2dict(u->u_ste->ste_varnames);

  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  000c5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c8	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  000cc	e8 00 00 00 00	 call	 list2dict
  000d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  000d6	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 533  :     u->u_cellvars = dictbytype(u->u_ste->ste_symbols, CELL, 0, 0);

  000da	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  000df	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e2	45 33 c9	 xor	 r9d, r9d
  000e5	45 33 c0	 xor	 r8d, r8d
  000e8	ba 05 00 00 00	 mov	 edx, 5
  000ed	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000f1	e8 00 00 00 00	 call	 dictbytype
  000f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  000fb	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 534  :     if (!u->u_varnames || !u->u_cellvars) {

  000ff	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00104	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00109	74 0c		 je	 SHORT $LN16@compiler_e
  0010b	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00110	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00115	75 11		 jne	 SHORT $LN17@compiler_e
$LN16@compiler_e:

; 535  :         compiler_unit_free(u);

  00117	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  0011c	e8 00 00 00 00	 call	 compiler_unit_free

; 536  :         return 0;

  00121	33 c0		 xor	 eax, eax
  00123	e9 f5 01 00 00	 jmp	 $LN20@compiler_e
$LN17@compiler_e:

; 537  :     }
; 538  : 
; 539  :     u->u_freevars = dictbytype(u->u_ste->ste_symbols, FREE, DEF_FREE_CLASS,
; 540  :                                PyDict_Size(u->u_cellvars));

  00128	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0012d	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00131	e8 00 00 00 00	 call	 PyDict_Size
  00136	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  0013b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0013e	44 8b c8	 mov	 r9d, eax
  00141	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00147	ba 04 00 00 00	 mov	 edx, 4
  0014c	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00150	e8 00 00 00 00	 call	 dictbytype
  00155	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  0015a	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 541  :     if (!u->u_freevars) {

  0015e	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00163	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00168	75 11		 jne	 SHORT $LN15@compiler_e

; 542  :         compiler_unit_free(u);

  0016a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  0016f	e8 00 00 00 00	 call	 compiler_unit_free

; 543  :         return 0;

  00174	33 c0		 xor	 eax, eax
  00176	e9 a2 01 00 00	 jmp	 $LN20@compiler_e
$LN15@compiler_e:

; 544  :     }
; 545  : 
; 546  :     u->u_blocks = NULL;

  0017b	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00180	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 547  :     u->u_nfblocks = 0;

  00188	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0018d	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 548  :     u->u_firstlineno = lineno;

  00194	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00199	8b 4c 24 60	 mov	 ecx, DWORD PTR lineno$[rsp]
  0019d	89 88 b0 01 00
	00		 mov	 DWORD PTR [rax+432], ecx

; 549  :     u->u_lineno = 0;

  001a3	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  001a8	c7 80 b4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+436], 0

; 550  :     u->u_col_offset = 0;

  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  001b7	c7 80 b8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+440], 0

; 551  :     u->u_lineno_set = 0;

  001c1	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  001c6	c7 80 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+444], 0

; 552  :     u->u_consts = PyDict_New();

  001d0	e8 00 00 00 00	 call	 PyDict_New
  001d5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  001da	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 553  :     if (!u->u_consts) {

  001de	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  001e3	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  001e8	75 11		 jne	 SHORT $LN14@compiler_e

; 554  :         compiler_unit_free(u);

  001ea	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  001ef	e8 00 00 00 00	 call	 compiler_unit_free

; 555  :         return 0;

  001f4	33 c0		 xor	 eax, eax
  001f6	e9 22 01 00 00	 jmp	 $LN20@compiler_e
$LN14@compiler_e:

; 556  :     }
; 557  :     u->u_names = PyDict_New();

  001fb	e8 00 00 00 00	 call	 PyDict_New
  00200	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  00205	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 558  :     if (!u->u_names) {

  00209	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0020e	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00213	75 11		 jne	 SHORT $LN13@compiler_e

; 559  :         compiler_unit_free(u);

  00215	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  0021a	e8 00 00 00 00	 call	 compiler_unit_free

; 560  :         return 0;

  0021f	33 c0		 xor	 eax, eax
  00221	e9 f7 00 00 00	 jmp	 $LN20@compiler_e
$LN13@compiler_e:

; 561  :     }
; 562  : 
; 563  :     u->u_private = NULL;

  00226	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0022b	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 564  : 
; 565  :     /* Push the old compiler_unit on the stack. */
; 566  :     if (c->u) {

  00233	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00238	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0023d	0f 84 a2 00 00
	00		 je	 $LN12@compiler_e

; 567  :         PyObject *capsule = PyCapsule_New(c->u, COMPILER_CAPSULE_NAME_COMPILER_UNIT, NULL);

  00243	45 33 c0	 xor	 r8d, r8d
  00246	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@
  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00252	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00256	e8 00 00 00 00	 call	 PyCapsule_New
  0025b	48 89 44 24 28	 mov	 QWORD PTR capsule$22608[rsp], rax

; 568  :         if (!capsule || PyList_Append(c->c_stack, capsule) < 0) {

  00260	48 83 7c 24 28
	00		 cmp	 QWORD PTR capsule$22608[rsp], 0
  00266	74 17		 je	 SHORT $LN10@compiler_e
  00268	48 8b 54 24 28	 mov	 rdx, QWORD PTR capsule$22608[rsp]
  0026d	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00272	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00276	e8 00 00 00 00	 call	 PyList_Append
  0027b	85 c0		 test	 eax, eax
  0027d	7d 26		 jge	 SHORT $LN11@compiler_e
$LN10@compiler_e:
$LN9@compiler_e:

; 569  :             Py_XDECREF(capsule);

  0027f	48 83 7c 24 28
	00		 cmp	 QWORD PTR capsule$22608[rsp], 0
  00285	74 0a		 je	 SHORT $LN6@compiler_e
  00287	48 8b 4c 24 28	 mov	 rcx, QWORD PTR capsule$22608[rsp]
  0028c	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@compiler_e:
  00291	33 c0		 xor	 eax, eax
  00293	85 c0		 test	 eax, eax
  00295	75 e8		 jne	 SHORT $LN9@compiler_e

; 570  :             compiler_unit_free(u);

  00297	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  0029c	e8 00 00 00 00	 call	 compiler_unit_free

; 571  :             return 0;

  002a1	33 c0		 xor	 eax, eax
  002a3	eb 78		 jmp	 SHORT $LN20@compiler_e
$LN11@compiler_e:

; 572  :         }
; 573  :         Py_DECREF(capsule);

  002a5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR capsule$22608[rsp]
  002aa	e8 00 00 00 00	 call	 _Py_DecRef

; 574  :         u->u_private = c->u->u_private;

  002af	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  002b4	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  002b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  002bd	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  002c1	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax
$LN5@compiler_e:

; 575  :         Py_XINCREF(u->u_private);

  002c5	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  002ca	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  002cf	74 0e		 je	 SHORT $LN2@compiler_e
  002d1	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  002d6	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  002da	e8 00 00 00 00	 call	 _Py_IncRef
$LN2@compiler_e:
  002df	33 c0		 xor	 eax, eax
  002e1	85 c0		 test	 eax, eax
  002e3	75 e0		 jne	 SHORT $LN5@compiler_e
$LN12@compiler_e:

; 576  :     }
; 577  :     c->u = u;

  002e5	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  002ea	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  002ef	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 578  : 
; 579  :     c->c_nestlevel++;

  002f3	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  002f8	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  002fb	ff c0		 inc	 eax
  002fd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00302	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 580  :     if (compiler_use_new_block(c) == NULL)

  00305	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0030a	e8 00 00 00 00	 call	 compiler_use_new_block
  0030f	48 85 c0	 test	 rax, rax
  00312	75 04		 jne	 SHORT $LN1@compiler_e

; 581  :         return 0;

  00314	33 c0		 xor	 eax, eax
  00316	eb 05		 jmp	 SHORT $LN20@compiler_e
$LN1@compiler_e:

; 582  : 
; 583  :     return 1;

  00318	b8 01 00 00 00	 mov	 eax, 1
$LN20@compiler_e:

; 584  : }

  0031d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00321	c3		 ret	 0
compiler_enter_scope ENDP
_TEXT	ENDS
EXTRN	PyDict_SetItem:PROC
EXTRN	PyTuple_Pack:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyList_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$list2dict DD imagerel list2dict
	DD	imagerel list2dict+295
	DD	imagerel $unwind$list2dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list2dict DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT list2dict
_TEXT	SEGMENT
v$ = 32
n$ = 40
i$ = 48
dict$ = 56
k$ = 64
list$ = 96
list2dict PROC						; COMDAT

; 370  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 371  :     Py_ssize_t i, n;
; 372  :     PyObject *v, *k;
; 373  :     PyObject *dict = PyDict_New();

  00009	e8 00 00 00 00	 call	 PyDict_New
  0000e	48 89 44 24 38	 mov	 QWORD PTR dict$[rsp], rax

; 374  :     if (!dict) return NULL;

  00013	48 83 7c 24 38
	00		 cmp	 QWORD PTR dict$[rsp], 0
  00019	75 07		 jne	 SHORT $LN11@list2dict
  0001b	33 c0		 xor	 eax, eax
  0001d	e9 00 01 00 00	 jmp	 $LN12@list2dict
$LN11@list2dict:

; 375  : 
; 376  :     n = PyList_Size(list);

  00022	48 8b 4c 24 60	 mov	 rcx, QWORD PTR list$[rsp]
  00027	e8 00 00 00 00	 call	 PyList_Size
  0002c	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 377  :     for (i = 0; i < n; i++) {

  00031	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0003a	eb 0d		 jmp	 SHORT $LN10@list2dict
$LN9@list2dict:
  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00041	48 ff c0	 inc	 rax
  00044	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN10@list2dict:
  00049	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0004e	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00053	0f 8d c4 00 00
	00		 jge	 $LN8@list2dict

; 378  :         v = PyLong_FromLong(i);

  00059	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  0005d	e8 00 00 00 00	 call	 PyLong_FromLong
  00062	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 379  :         if (!v) {

  00067	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  0006d	75 11		 jne	 SHORT $LN7@list2dict

; 380  :             Py_DECREF(dict);

  0006f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dict$[rsp]
  00074	e8 00 00 00 00	 call	 _Py_DecRef

; 381  :             return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 a2 00 00 00	 jmp	 $LN12@list2dict
$LN7@list2dict:

; 382  :         }
; 383  :         k = PyList_GET_ITEM(list, i);

  00080	48 8b 44 24 60	 mov	 rax, QWORD PTR list$[rsp]
  00085	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00089	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0008e	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00092	48 89 44 24 40	 mov	 QWORD PTR k$[rsp], rax

; 384  :         k = PyTuple_Pack(2, k, k->ob_type);

  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR k$[rsp]
  0009c	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  000a0	48 8b 54 24 40	 mov	 rdx, QWORD PTR k$[rsp]
  000a5	b9 02 00 00 00	 mov	 ecx, 2
  000aa	e8 00 00 00 00	 call	 PyTuple_Pack
  000af	48 89 44 24 40	 mov	 QWORD PTR k$[rsp], rax

; 385  :         if (k == NULL || PyDict_SetItem(dict, k, v) < 0) {

  000b4	48 83 7c 24 40
	00		 cmp	 QWORD PTR k$[rsp], 0
  000ba	74 18		 je	 SHORT $LN5@list2dict
  000bc	4c 8b 44 24 20	 mov	 r8, QWORD PTR v$[rsp]
  000c1	48 8b 54 24 40	 mov	 rdx, QWORD PTR k$[rsp]
  000c6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dict$[rsp]
  000cb	e8 00 00 00 00	 call	 PyDict_SetItem
  000d0	85 c0		 test	 eax, eax
  000d2	7d 30		 jge	 SHORT $LN6@list2dict
$LN5@list2dict:
$LN4@list2dict:

; 386  :             Py_XDECREF(k);

  000d4	48 83 7c 24 40
	00		 cmp	 QWORD PTR k$[rsp], 0
  000da	74 0a		 je	 SHORT $LN1@list2dict
  000dc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR k$[rsp]
  000e1	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@list2dict:
  000e6	33 c0		 xor	 eax, eax
  000e8	85 c0		 test	 eax, eax
  000ea	75 e8		 jne	 SHORT $LN4@list2dict

; 387  :             Py_DECREF(v);

  000ec	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  000f1	e8 00 00 00 00	 call	 _Py_DecRef

; 388  :             Py_DECREF(dict);

  000f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dict$[rsp]
  000fb	e8 00 00 00 00	 call	 _Py_DecRef

; 389  :             return NULL;

  00100	33 c0		 xor	 eax, eax
  00102	eb 1e		 jmp	 SHORT $LN12@list2dict
$LN6@list2dict:

; 390  :         }
; 391  :         Py_DECREF(k);

  00104	48 8b 4c 24 40	 mov	 rcx, QWORD PTR k$[rsp]
  00109	e8 00 00 00 00	 call	 _Py_DecRef

; 392  :         Py_DECREF(v);

  0010e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00113	e8 00 00 00 00	 call	 _Py_DecRef

; 393  :     }

  00118	e9 1f ff ff ff	 jmp	 $LN9@list2dict
$LN8@list2dict:

; 394  :     return dict;

  0011d	48 8b 44 24 38	 mov	 rax, QWORD PTR dict$[rsp]
$LN12@list2dict:

; 395  : }

  00122	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00126	c3		 ret	 0
list2dict ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@OIFHELDI@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
EXTRN	PyLong_AsLong:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyList_Sort:PROC
EXTRN	PyDict_Keys:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$dictbytype DD imagerel dictbytype
	DD	imagerel dictbytype+616
	DD	imagerel $unwind$dictbytype
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dictbytype DD 021a01H
	DD	011011aH
xdata	ENDS
;	COMDAT ??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'v'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@OIFHELDI@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@OIFHELDI@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'o'
	DB	00H, 'f', 00H, 'f', 00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT dictbytype
_TEXT	SEGMENT
v$ = 32
i$ = 40
sorted_keys$ = 48
key_i$ = 56
dest$ = 64
scope$ = 72
k$ = 80
num_keys$ = 88
vi$22433 = 96
tuple$22440 = 104
item$22441 = 112
src$ = 144
scope_type$ = 152
flag$ = 160
offset$ = 168
dictbytype PROC						; COMDAT

; 407  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 408  :     Py_ssize_t i = offset, scope, num_keys, key_i;

  0001a	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR offset$[rsp]
  00022	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 409  :     PyObject *k, *v, *dest = PyDict_New();

  00027	e8 00 00 00 00	 call	 PyDict_New
  0002c	48 89 44 24 40	 mov	 QWORD PTR dest$[rsp], rax

; 410  :     PyObject *sorted_keys;
; 411  : 
; 412  :     assert(offset >= 0);

  00031	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR offset$[rsp], 0
  00039	7d 1c		 jge	 SHORT $LN18@dictbytype
  0003b	41 b8 9c 01 00
	00		 mov	 r8d, 412		; 0000019cH
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@OIFHELDI@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00055	33 c0		 xor	 eax, eax
$LN18@dictbytype:

; 413  :     if (dest == NULL)

  00057	48 83 7c 24 40
	00		 cmp	 QWORD PTR dest$[rsp], 0
  0005d	75 07		 jne	 SHORT $LN15@dictbytype

; 414  :         return NULL;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 fa 01 00 00	 jmp	 $LN16@dictbytype
$LN15@dictbytype:

; 415  : 
; 416  :     /* Sort the keys so that we have a deterministic order on the indexes
; 417  :        saved in the returned dictionary.  These indexes are used as indexes
; 418  :        into the free and cell var storage.  Therefore if they aren't
; 419  :        deterministic, then the generated bytecode is not deterministic.
; 420  :     */
; 421  :     sorted_keys = PyDict_Keys(src);

  00066	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp]
  0006e	e8 00 00 00 00	 call	 PyDict_Keys
  00073	48 89 44 24 30	 mov	 QWORD PTR sorted_keys$[rsp], rax

; 422  :     if (sorted_keys == NULL)

  00078	48 83 7c 24 30
	00		 cmp	 QWORD PTR sorted_keys$[rsp], 0
  0007e	75 07		 jne	 SHORT $LN14@dictbytype

; 423  :         return NULL;

  00080	33 c0		 xor	 eax, eax
  00082	e9 d9 01 00 00	 jmp	 $LN16@dictbytype
$LN14@dictbytype:

; 424  :     if (PyList_Sort(sorted_keys) != 0) {

  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sorted_keys$[rsp]
  0008c	e8 00 00 00 00	 call	 PyList_Sort
  00091	85 c0		 test	 eax, eax
  00093	74 11		 je	 SHORT $LN13@dictbytype

; 425  :         Py_DECREF(sorted_keys);

  00095	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sorted_keys$[rsp]
  0009a	e8 00 00 00 00	 call	 _Py_DecRef

; 426  :         return NULL;

  0009f	33 c0		 xor	 eax, eax
  000a1	e9 ba 01 00 00	 jmp	 $LN16@dictbytype
$LN13@dictbytype:

; 427  :     }
; 428  :     num_keys = PyList_GET_SIZE(sorted_keys);

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR sorted_keys$[rsp]
  000ab	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000af	48 89 44 24 58	 mov	 QWORD PTR num_keys$[rsp], rax

; 429  : 
; 430  :     for (key_i = 0; key_i < num_keys; key_i++) {

  000b4	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR key_i$[rsp], 0
  000bd	eb 0d		 jmp	 SHORT $LN12@dictbytype
$LN11@dictbytype:
  000bf	48 8b 44 24 38	 mov	 rax, QWORD PTR key_i$[rsp]
  000c4	48 ff c0	 inc	 rax
  000c7	48 89 44 24 38	 mov	 QWORD PTR key_i$[rsp], rax
$LN12@dictbytype:
  000cc	48 8b 44 24 58	 mov	 rax, QWORD PTR num_keys$[rsp]
  000d1	48 39 44 24 38	 cmp	 QWORD PTR key_i$[rsp], rax
  000d6	0f 8d 75 01 00
	00		 jge	 $LN10@dictbytype

; 431  :         /* XXX this should probably be a macro in symtable.h */
; 432  :         long vi;
; 433  :         k = PyList_GET_ITEM(sorted_keys, key_i);

  000dc	48 8b 44 24 30	 mov	 rax, QWORD PTR sorted_keys$[rsp]
  000e1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key_i$[rsp]
  000ea	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000ee	48 89 44 24 50	 mov	 QWORD PTR k$[rsp], rax

; 434  :         v = PyDict_GetItem(src, k);

  000f3	48 8b 54 24 50	 mov	 rdx, QWORD PTR k$[rsp]
  000f8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp]
  00100	e8 00 00 00 00	 call	 PyDict_GetItem
  00105	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 435  :         assert(PyLong_Check(v));

  0010a	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  0010f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00113	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00119	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0011e	85 c0		 test	 eax, eax
  00120	75 1c		 jne	 SHORT $LN19@dictbytype
  00122	41 b8 b3 01 00
	00		 mov	 r8d, 435		; 000001b3H
  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@NJGFBMIA@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0013c	33 c0		 xor	 eax, eax
$LN19@dictbytype:

; 436  :         vi = PyLong_AS_LONG(v);

  0013e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00143	e8 00 00 00 00	 call	 PyLong_AsLong
  00148	89 44 24 60	 mov	 DWORD PTR vi$22433[rsp], eax

; 437  :         scope = (vi >> SCOPE_OFFSET) & SCOPE_MASK;

  0014c	8b 44 24 60	 mov	 eax, DWORD PTR vi$22433[rsp]
  00150	c1 f8 0b	 sar	 eax, 11
  00153	83 e0 0f	 and	 eax, 15
  00156	48 98		 cdqe
  00158	48 89 44 24 48	 mov	 QWORD PTR scope$[rsp], rax

; 438  : 
; 439  :         if (scope == scope_type || vi & flag) {

  0015d	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR scope_type$[rsp]
  00165	48 39 44 24 48	 cmp	 QWORD PTR scope$[rsp], rax
  0016a	74 17		 je	 SHORT $LN8@dictbytype
  0016c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR flag$[rsp]
  00173	8b 4c 24 60	 mov	 ecx, DWORD PTR vi$22433[rsp]
  00177	23 c8		 and	 ecx, eax
  00179	8b c1		 mov	 eax, ecx
  0017b	85 c0		 test	 eax, eax
  0017d	0f 84 c9 00 00
	00		 je	 $LN9@dictbytype
$LN8@dictbytype:

; 440  :             PyObject *tuple, *item = PyLong_FromLong(i);

  00183	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  00187	e8 00 00 00 00	 call	 PyLong_FromLong
  0018c	48 89 44 24 70	 mov	 QWORD PTR item$22441[rsp], rax

; 441  :             if (item == NULL) {

  00191	48 83 7c 24 70
	00		 cmp	 QWORD PTR item$22441[rsp], 0
  00197	75 1b		 jne	 SHORT $LN7@dictbytype

; 442  :                 Py_DECREF(sorted_keys);

  00199	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sorted_keys$[rsp]
  0019e	e8 00 00 00 00	 call	 _Py_DecRef

; 443  :                 Py_DECREF(dest);

  001a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  001a8	e8 00 00 00 00	 call	 _Py_DecRef

; 444  :                 return NULL;

  001ad	33 c0		 xor	 eax, eax
  001af	e9 ac 00 00 00	 jmp	 $LN16@dictbytype
$LN7@dictbytype:

; 445  :             }
; 446  :             i++;

  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  001b9	48 ff c0	 inc	 rax
  001bc	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 447  :             tuple = PyTuple_Pack(2, k, k->ob_type);

  001c1	48 8b 44 24 50	 mov	 rax, QWORD PTR k$[rsp]
  001c6	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  001ca	48 8b 54 24 50	 mov	 rdx, QWORD PTR k$[rsp]
  001cf	b9 02 00 00 00	 mov	 ecx, 2
  001d4	e8 00 00 00 00	 call	 PyTuple_Pack
  001d9	48 89 44 24 68	 mov	 QWORD PTR tuple$22440[rsp], rax

; 448  :             if (!tuple || PyDict_SetItem(dest, tuple, item) < 0) {

  001de	48 83 7c 24 68
	00		 cmp	 QWORD PTR tuple$22440[rsp], 0
  001e4	74 18		 je	 SHORT $LN5@dictbytype
  001e6	4c 8b 44 24 70	 mov	 r8, QWORD PTR item$22441[rsp]
  001eb	48 8b 54 24 68	 mov	 rdx, QWORD PTR tuple$22440[rsp]
  001f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  001f5	e8 00 00 00 00	 call	 PyDict_SetItem
  001fa	85 c0		 test	 eax, eax
  001fc	7d 3a		 jge	 SHORT $LN6@dictbytype
$LN5@dictbytype:

; 449  :                 Py_DECREF(sorted_keys);

  001fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sorted_keys$[rsp]
  00203	e8 00 00 00 00	 call	 _Py_DecRef

; 450  :                 Py_DECREF(item);

  00208	48 8b 4c 24 70	 mov	 rcx, QWORD PTR item$22441[rsp]
  0020d	e8 00 00 00 00	 call	 _Py_DecRef

; 451  :                 Py_DECREF(dest);

  00212	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  00217	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@dictbytype:

; 452  :                 Py_XDECREF(tuple);

  0021c	48 83 7c 24 68
	00		 cmp	 QWORD PTR tuple$22440[rsp], 0
  00222	74 0a		 je	 SHORT $LN1@dictbytype
  00224	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tuple$22440[rsp]
  00229	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@dictbytype:
  0022e	33 c0		 xor	 eax, eax
  00230	85 c0		 test	 eax, eax
  00232	75 e8		 jne	 SHORT $LN4@dictbytype

; 453  :                 return NULL;

  00234	33 c0		 xor	 eax, eax
  00236	eb 28		 jmp	 SHORT $LN16@dictbytype
$LN6@dictbytype:

; 454  :             }
; 455  :             Py_DECREF(item);

  00238	48 8b 4c 24 70	 mov	 rcx, QWORD PTR item$22441[rsp]
  0023d	e8 00 00 00 00	 call	 _Py_DecRef

; 456  :             Py_DECREF(tuple);

  00242	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tuple$22440[rsp]
  00247	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@dictbytype:

; 457  :         }
; 458  :     }

  0024c	e9 6e fe ff ff	 jmp	 $LN11@dictbytype
$LN10@dictbytype:

; 459  :     Py_DECREF(sorted_keys);

  00251	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sorted_keys$[rsp]
  00256	e8 00 00 00 00	 call	 _Py_DecRef

; 460  :     return dest;

  0025b	48 8b 44 24 40	 mov	 rax, QWORD PTR dest$[rsp]
$LN16@dictbytype:

; 461  : }

  00260	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00267	c3		 ret	 0
dictbytype ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@	; `string'
PUBLIC	??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_unit_free DD imagerel compiler_unit_free
	DD	imagerel compiler_unit_free+1151
	DD	imagerel $unwind$compiler_unit_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_unit_free DD 020c01H
	DD	013010cH
xdata	ENDS
;	COMDAT ??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
CONST	SEGMENT
??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@ DB 'compiler_unit_free', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
CONST	SEGMENT
??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@ DB '..\Python\compile.c', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_unit_free
_TEXT	SEGMENT
next$ = 48
b$ = 56
_py_tmp$22514 = 64
_py_tmp$22522 = 72
_py_tmp$22530 = 80
_py_tmp$22538 = 88
_py_tmp$22546 = 96
_py_tmp$22554 = 104
_py_tmp$22562 = 112
_py_tmp$22570 = 120
_py_tmp$22578 = 128
u$ = 160
compiler_unit_free PROC					; COMDAT

; 485  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 486  :     basicblock *b, *next;
; 487  : 
; 488  :     compiler_unit_check(u);

  0000c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR u$[rsp]
  00014	e8 00 00 00 00	 call	 compiler_unit_check

; 489  :     b = u->u_blocks;

  00019	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00021	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00025	48 89 44 24 38	 mov	 QWORD PTR b$[rsp], rax
$LN39@compiler_u:

; 490  :     while (b != NULL) {

  0002a	48 83 7c 24 38
	00		 cmp	 QWORD PTR b$[rsp], 0
  00030	74 3d		 je	 SHORT $LN38@compiler_u

; 491  :         if (b->b_instr)

  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00037	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0003c	74 0e		 je	 SHORT $LN37@compiler_u

; 492  :             PyObject_Free((void *)b->b_instr);

  0003e	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00043	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00047	e8 00 00 00 00	 call	 _PyObject_DebugFree
$LN37@compiler_u:

; 493  :         next = b->b_list;

  0004c	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00051	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00054	48 89 44 24 30	 mov	 QWORD PTR next$[rsp], rax

; 494  :         PyObject_Free((void *)b);

  00059	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$[rsp]
  0005e	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 495  :         b = next;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  00068	48 89 44 24 38	 mov	 QWORD PTR b$[rsp], rax

; 496  :     }

  0006d	eb bb		 jmp	 SHORT $LN39@compiler_u
$LN38@compiler_u:
$LN36@compiler_u:

; 497  :     Py_CLEAR(u->u_ste);

  0006f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00077	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0007b	74 59		 je	 SHORT $LN33@compiler_u
  0007d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00085	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0008d	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  00090	41 b8 f1 01 00
	00		 mov	 r8d, 497		; 000001f1H
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  000a4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a9	85 c0		 test	 eax, eax
  000ab	75 29		 jne	 SHORT $LN33@compiler_u
  000ad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  000b5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b8	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$22514[rsp], rax
  000bd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  000c5	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$22514[rsp]
  000d1	e8 00 00 00 00	 call	 _Py_DecRef
$LN33@compiler_u:
  000d6	33 c0		 xor	 eax, eax
  000d8	85 c0		 test	 eax, eax
  000da	75 93		 jne	 SHORT $LN36@compiler_u
$LN32@compiler_u:

; 498  :     Py_CLEAR(u->u_name);

  000dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  000e4	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000e9	74 5c		 je	 SHORT $LN29@compiler_u
  000eb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000f3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  000fb	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  000ff	41 b8 f2 01 00
	00		 mov	 r8d, 498		; 000001f2H
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  00113	e8 00 00 00 00	 call	 _PyParallel_Guard
  00118	85 c0		 test	 eax, eax
  0011a	75 2b		 jne	 SHORT $LN29@compiler_u
  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00124	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00128	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$22522[rsp], rax
  0012d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00135	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0013d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$22522[rsp]
  00142	e8 00 00 00 00	 call	 _Py_DecRef
$LN29@compiler_u:
  00147	33 c0		 xor	 eax, eax
  00149	85 c0		 test	 eax, eax
  0014b	75 8f		 jne	 SHORT $LN32@compiler_u
$LN28@compiler_u:

; 499  :     Py_CLEAR(u->u_qualname);

  0014d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00155	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0015a	74 5c		 je	 SHORT $LN25@compiler_u
  0015c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00164	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0016c	4c 8b 48 10	 mov	 r9, QWORD PTR [rax+16]
  00170	41 b8 f3 01 00
	00		 mov	 r8d, 499		; 000001f3H
  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  00184	e8 00 00 00 00	 call	 _PyParallel_Guard
  00189	85 c0		 test	 eax, eax
  0018b	75 2b		 jne	 SHORT $LN25@compiler_u
  0018d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00195	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00199	48 89 44 24 50	 mov	 QWORD PTR _py_tmp$22530[rsp], rax
  0019e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  001a6	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  001ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _py_tmp$22530[rsp]
  001b3	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@compiler_u:
  001b8	33 c0		 xor	 eax, eax
  001ba	85 c0		 test	 eax, eax
  001bc	75 8f		 jne	 SHORT $LN28@compiler_u
$LN24@compiler_u:

; 500  :     Py_CLEAR(u->u_consts);

  001be	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  001c6	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  001cb	74 5c		 je	 SHORT $LN21@compiler_u
  001cd	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  001dd	4c 8b 48 20	 mov	 r9, QWORD PTR [rax+32]
  001e1	41 b8 f4 01 00
	00		 mov	 r8d, 500		; 000001f4H
  001e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  001ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  001f5	e8 00 00 00 00	 call	 _PyParallel_Guard
  001fa	85 c0		 test	 eax, eax
  001fc	75 2b		 jne	 SHORT $LN21@compiler_u
  001fe	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00206	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0020a	48 89 44 24 58	 mov	 QWORD PTR _py_tmp$22538[rsp], rax
  0020f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00217	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
  0021f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _py_tmp$22538[rsp]
  00224	e8 00 00 00 00	 call	 _Py_DecRef
$LN21@compiler_u:
  00229	33 c0		 xor	 eax, eax
  0022b	85 c0		 test	 eax, eax
  0022d	75 8f		 jne	 SHORT $LN24@compiler_u
$LN20@compiler_u:

; 501  :     Py_CLEAR(u->u_names);

  0022f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00237	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0023c	74 5c		 je	 SHORT $LN17@compiler_u
  0023e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00246	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0024e	4c 8b 48 28	 mov	 r9, QWORD PTR [rax+40]
  00252	41 b8 f5 01 00
	00		 mov	 r8d, 501		; 000001f5H
  00258	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  0025f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  00266	e8 00 00 00 00	 call	 _PyParallel_Guard
  0026b	85 c0		 test	 eax, eax
  0026d	75 2b		 jne	 SHORT $LN17@compiler_u
  0026f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00277	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0027b	48 89 44 24 60	 mov	 QWORD PTR _py_tmp$22546[rsp], rax
  00280	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00288	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
  00290	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _py_tmp$22546[rsp]
  00295	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@compiler_u:
  0029a	33 c0		 xor	 eax, eax
  0029c	85 c0		 test	 eax, eax
  0029e	75 8f		 jne	 SHORT $LN20@compiler_u
$LN16@compiler_u:

; 502  :     Py_CLEAR(u->u_varnames);

  002a0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  002a8	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  002ad	74 5c		 je	 SHORT $LN13@compiler_u
  002af	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002b7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  002bf	4c 8b 48 30	 mov	 r9, QWORD PTR [rax+48]
  002c3	41 b8 f6 01 00
	00		 mov	 r8d, 502		; 000001f6H
  002c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  002d7	e8 00 00 00 00	 call	 _PyParallel_Guard
  002dc	85 c0		 test	 eax, eax
  002de	75 2b		 jne	 SHORT $LN13@compiler_u
  002e0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  002e8	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  002ec	48 89 44 24 68	 mov	 QWORD PTR _py_tmp$22554[rsp], rax
  002f1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  002f9	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0
  00301	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _py_tmp$22554[rsp]
  00306	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@compiler_u:
  0030b	33 c0		 xor	 eax, eax
  0030d	85 c0		 test	 eax, eax
  0030f	75 8f		 jne	 SHORT $LN16@compiler_u
$LN12@compiler_u:

; 503  :     Py_CLEAR(u->u_freevars);

  00311	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00319	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  0031e	74 5c		 je	 SHORT $LN9@compiler_u
  00320	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00328	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00330	4c 8b 48 40	 mov	 r9, QWORD PTR [rax+64]
  00334	41 b8 f7 01 00
	00		 mov	 r8d, 503		; 000001f7H
  0033a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  00341	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  00348	e8 00 00 00 00	 call	 _PyParallel_Guard
  0034d	85 c0		 test	 eax, eax
  0034f	75 2b		 jne	 SHORT $LN9@compiler_u
  00351	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00359	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0035d	48 89 44 24 70	 mov	 QWORD PTR _py_tmp$22562[rsp], rax
  00362	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0036a	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
  00372	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _py_tmp$22562[rsp]
  00377	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@compiler_u:
  0037c	33 c0		 xor	 eax, eax
  0037e	85 c0		 test	 eax, eax
  00380	75 8f		 jne	 SHORT $LN12@compiler_u
$LN8@compiler_u:

; 504  :     Py_CLEAR(u->u_cellvars);

  00382	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0038a	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0038f	74 5c		 je	 SHORT $LN5@compiler_u
  00391	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00399	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  003a1	4c 8b 48 38	 mov	 r9, QWORD PTR [rax+56]
  003a5	41 b8 f8 01 00
	00		 mov	 r8d, 504		; 000001f8H
  003ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  003b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  003b9	e8 00 00 00 00	 call	 _PyParallel_Guard
  003be	85 c0		 test	 eax, eax
  003c0	75 2b		 jne	 SHORT $LN5@compiler_u
  003c2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  003ca	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  003ce	48 89 44 24 78	 mov	 QWORD PTR _py_tmp$22570[rsp], rax
  003d3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  003db	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
  003e3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _py_tmp$22570[rsp]
  003e8	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@compiler_u:
  003ed	33 c0		 xor	 eax, eax
  003ef	85 c0		 test	 eax, eax
  003f1	75 8f		 jne	 SHORT $LN8@compiler_u
$LN4@compiler_u:

; 505  :     Py_CLEAR(u->u_private);

  003f3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  003fb	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00400	74 62		 je	 SHORT $LN1@compiler_u
  00402	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0040a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  00412	4c 8b 48 48	 mov	 r9, QWORD PTR [rax+72]
  00416	41 b8 f9 01 00
	00		 mov	 r8d, 505		; 000001f9H
  0041c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  00423	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  0042a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0042f	85 c0		 test	 eax, eax
  00431	75 31		 jne	 SHORT $LN1@compiler_u
  00433	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0043b	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0043f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR _py_tmp$22578[rsp], rax
  00447	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR u$[rsp]
  0044f	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0
  00457	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$22578[rsp]
  0045f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@compiler_u:
  00464	33 c0		 xor	 eax, eax
  00466	85 c0		 test	 eax, eax
  00468	75 89		 jne	 SHORT $LN4@compiler_u

; 506  :     PyObject_Free(u);

  0046a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR u$[rsp]
  00472	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 507  : }

  00477	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0047e	c3		 ret	 0
compiler_unit_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@IOEEBFMI@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@LEACGMFA@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EE@KOKHIGKE@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe@ ; `string'
PUBLIC	??_C@_1CG@NKLDKAMG@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@ELJEIJNE@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@EOHIJCEB@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAd?$AAb?$AAd?$AAb?$AAd@ ; `string'
PUBLIC	??_C@_1EI@ODPPEMFJ@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAf?$AAb?$AAf?$AAb?$AAf@ ; `string'
PUBLIC	??_C@_1EI@DFECBJCE@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAc?$AAb?$AAc?$AAb?$AAc@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_unit_check DD imagerel compiler_unit_check
	DD	imagerel compiler_unit_check+396
	DD	imagerel $unwind$compiler_unit_check
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_unit_check DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1CK@IOEEBFMI@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@IOEEBFMI@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '-', 00H, '>', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@LEACGMFA@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@LEACGMFA@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '-', 00H, '>', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@KOKHIGKE@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe@
CONST	SEGMENT
??_C@_1EE@KOKHIGKE@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '-', 00H, '>', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '-', 00H, '>', 00H, 'b'
	DB	00H, '_', 00H, 'i', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@NKLDKAMG@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@NKLDKAMG@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '-', 00H, '>', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@ELJEIJNE@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@ELJEIJNE@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '-', 00H, '>', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@EOHIJCEB@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAd?$AAb?$AAd?$AAb?$AAd@
CONST	SEGMENT
??_C@_1EI@EOHIJCEB@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAd?$AAb?$AAd?$AAb?$AAd@ DB '('
	DB	00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '*', 00H
	DB	')', 00H, 'b', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '(', 00H, 'v', 00H, 'o', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, '*', 00H, ')', 00H, '0', 00H, 'x'
	DB	00H, 'd', 00H, 'b', 00H, 'd', 00H, 'b', 00H, 'd', 00H, 'b', 00H
	DB	'd', 00H, 'b', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@ODPPEMFJ@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAf?$AAb?$AAf?$AAb?$AAf@
CONST	SEGMENT
??_C@_1EI@ODPPEMFJ@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAf?$AAb?$AAf?$AAb?$AAf@ DB '('
	DB	00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '*', 00H
	DB	')', 00H, 'b', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '(', 00H, 'v', 00H, 'o', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, '*', 00H, ')', 00H, '0', 00H, 'x'
	DB	00H, 'f', 00H, 'b', 00H, 'f', 00H, 'b', 00H, 'f', 00H, 'b', 00H
	DB	'f', 00H, 'b', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@DFECBJCE@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAc?$AAb?$AAc?$AAb?$AAc@
CONST	SEGMENT
??_C@_1EI@DFECBJCE@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAc?$AAb?$AAc?$AAb?$AAc@ DB '('
	DB	00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '*', 00H
	DB	')', 00H, 'b', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '(', 00H, 'v', 00H, 'o', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, '*', 00H, ')', 00H, '0', 00H, 'x'
	DB	00H, 'c', 00H, 'b', 00H, 'c', 00H, 'b', 00H, 'c', 00H, 'b', 00H
	DB	'c', 00H, 'b', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_unit_check
_TEXT	SEGMENT
block$ = 32
u$ = 64
compiler_unit_check PROC				; COMDAT

; 465  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 466  :     basicblock *block;
; 467  :     for (block = u->u_blocks; block != NULL; block = block->b_list) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR u$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	48 89 44 24 20	 mov	 QWORD PTR block$[rsp], rax
  00017	eb 0d		 jmp	 SHORT $LN5@compiler_u@2
$LN4@compiler_u@2:
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR block$[rsp]
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 89 44 24 20	 mov	 QWORD PTR block$[rsp], rax
$LN5@compiler_u@2:
  00026	48 83 7c 24 20
	00		 cmp	 QWORD PTR block$[rsp], 0
  0002c	0f 84 55 01 00
	00		 je	 $LN3@compiler_u@2

; 468  :         assert((void *)block != (void *)0xcbcbcbcb);

  00032	b8 cb cb cb cb	 mov	 eax, -875836469		; cbcbcbcbH
  00037	48 39 44 24 20	 cmp	 QWORD PTR block$[rsp], rax
  0003c	75 1c		 jne	 SHORT $LN8@compiler_u@2
  0003e	41 b8 d4 01 00
	00		 mov	 r8d, 468		; 000001d4H
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@DFECBJCE@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAc?$AAb?$AAc?$AAb?$AAc@
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00058	33 c0		 xor	 eax, eax
$LN8@compiler_u@2:

; 469  :         assert((void *)block != (void *)0xfbfbfbfb);

  0005a	b8 fb fb fb fb	 mov	 eax, -67372037		; fbfbfbfbH
  0005f	48 39 44 24 20	 cmp	 QWORD PTR block$[rsp], rax
  00064	75 1c		 jne	 SHORT $LN9@compiler_u@2
  00066	41 b8 d5 01 00
	00		 mov	 r8d, 469		; 000001d5H
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@ODPPEMFJ@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAf?$AAb?$AAf?$AAb?$AAf@
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00080	33 c0		 xor	 eax, eax
$LN9@compiler_u@2:

; 470  :         assert((void *)block != (void *)0xdbdbdbdb);

  00082	b8 db db db db	 mov	 eax, -606348325		; dbdbdbdbH
  00087	48 39 44 24 20	 cmp	 QWORD PTR block$[rsp], rax
  0008c	75 1c		 jne	 SHORT $LN10@compiler_u@2
  0008e	41 b8 d6 01 00
	00		 mov	 r8d, 470		; 000001d6H
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@EOHIJCEB@?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AAx?$AAd?$AAb?$AAd?$AAb?$AAd@
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a8	33 c0		 xor	 eax, eax
$LN10@compiler_u@2:

; 471  :         if (block->b_instr != NULL) {

  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR block$[rsp]
  000af	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000b4	74 7e		 je	 SHORT $LN2@compiler_u@2

; 472  :             assert(block->b_ialloc > 0);

  000b6	48 8b 44 24 20	 mov	 rax, QWORD PTR block$[rsp]
  000bb	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  000bf	7f 1c		 jg	 SHORT $LN11@compiler_u@2
  000c1	41 b8 d8 01 00
	00		 mov	 r8d, 472		; 000001d8H
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@ELJEIJNE@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000db	33 c0		 xor	 eax, eax
$LN11@compiler_u@2:

; 473  :             assert(block->b_iused > 0);

  000dd	48 8b 44 24 20	 mov	 rax, QWORD PTR block$[rsp]
  000e2	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000e6	7f 1c		 jg	 SHORT $LN12@compiler_u@2
  000e8	41 b8 d9 01 00
	00		 mov	 r8d, 473		; 000001d9H
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@NKLDKAMG@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00102	33 c0		 xor	 eax, eax
$LN12@compiler_u@2:

; 474  :             assert(block->b_ialloc >= block->b_iused);

  00104	48 8b 44 24 20	 mov	 rax, QWORD PTR block$[rsp]
  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR block$[rsp]
  0010e	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00111	39 48 0c	 cmp	 DWORD PTR [rax+12], ecx
  00114	7d 1c		 jge	 SHORT $LN13@compiler_u@2
  00116	41 b8 da 01 00
	00		 mov	 r8d, 474		; 000001daH
  0011c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@KOKHIGKE@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe@
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00130	33 c0		 xor	 eax, eax
$LN13@compiler_u@2:

; 475  :         }
; 476  :         else {

  00132	eb 4e		 jmp	 SHORT $LN1@compiler_u@2
$LN2@compiler_u@2:

; 477  :             assert (block->b_iused == 0);

  00134	48 8b 44 24 20	 mov	 rax, QWORD PTR block$[rsp]
  00139	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0013d	74 1c		 je	 SHORT $LN14@compiler_u@2
  0013f	41 b8 dd 01 00
	00		 mov	 r8d, 477		; 000001ddH
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@LEACGMFA@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00159	33 c0		 xor	 eax, eax
$LN14@compiler_u@2:

; 478  :             assert (block->b_ialloc == 0);

  0015b	48 8b 44 24 20	 mov	 rax, QWORD PTR block$[rsp]
  00160	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  00164	74 1c		 je	 SHORT $LN15@compiler_u@2
  00166	41 b8 de 01 00
	00		 mov	 r8d, 478		; 000001deH
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@IOEEBFMI@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAi?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00180	33 c0		 xor	 eax, eax
$LN15@compiler_u@2:
$LN1@compiler_u@2:

; 479  :         }
; 480  :     }

  00182	e9 92 fe ff ff	 jmp	 $LN4@compiler_u@2
$LN3@compiler_u@2:

; 481  : }

  00187	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0018b	c3		 ret	 0
compiler_unit_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@CJOLMGIJ@compiler_exit_scope?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_19CGEHGJAO@?$AAc?$AA?9?$AA?$DO?$AAu?$AA?$AA@ ; `string'
EXTRN	Py_FatalError:PROC
EXTRN	PySequence_DelItem:PROC
EXTRN	PyCapsule_GetPointer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_exit_scope DD imagerel compiler_exit_scope
	DD	imagerel compiler_exit_scope+237
	DD	imagerel $unwind$compiler_exit_scope
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_exit_scope DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BG@CJOLMGIJ@compiler_exit_scope?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@CJOLMGIJ@compiler_exit_scope?$CI?$CJ?$AA@ DB 'compiler_exit_sco'
	DB	'pe()', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_19CGEHGJAO@?$AAc?$AA?9?$AA?$DO?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_19CGEHGJAO@?$AAc?$AA?9?$AA?$DO?$AAu?$AA?$AA@ DB 'c', 00H, '-', 00H, '>'
	DB	00H, 'u', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_exit_scope
_TEXT	SEGMENT
n$ = 32
capsule$ = 40
c$ = 64
compiler_exit_scope PROC				; COMDAT

; 588  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 589  :     int n;
; 590  :     PyObject *capsule;
; 591  : 
; 592  :     c->c_nestlevel--;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0000e	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00011	ff c8		 dec	 eax
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00018	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 593  :     compiler_unit_free(c->u);

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00020	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00024	e8 00 00 00 00	 call	 compiler_unit_free

; 594  :     /* Restore c->u to the parent unit. */
; 595  :     n = PyList_GET_SIZE(c->c_stack) - 1;

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0002e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00032	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00036	48 ff c8	 dec	 rax
  00039	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 596  :     if (n >= 0) {

  0003d	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00042	0f 8c 93 00 00
	00		 jl	 $LN3@compiler_e@2

; 597  :         capsule = PyList_GET_ITEM(c->c_stack, n);

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0004d	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00051	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR n$[rsp]
  00056	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0005a	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0005e	48 89 44 24 28	 mov	 QWORD PTR capsule$[rsp], rax

; 598  :         c->u = (struct compiler_unit *)PyCapsule_GetPointer(capsule, COMPILER_CAPSULE_NAME_COMPILER_UNIT);

  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@
  0006a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR capsule$[rsp]
  0006f	e8 00 00 00 00	 call	 PyCapsule_GetPointer
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00079	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 599  :         assert(c->u);

  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00082	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00087	75 1c		 jne	 SHORT $LN6@compiler_e@2
  00089	41 b8 57 02 00
	00		 mov	 r8d, 599		; 00000257H
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_19CGEHGJAO@?$AAc?$AA?9?$AA?$DO?$AAu?$AA?$AA@
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a3	33 c0		 xor	 eax, eax
$LN6@compiler_e@2:

; 600  :         /* we are deleting from a list so this really shouldn't fail */
; 601  :         if (PySequence_DelItem(c->c_stack, n) < 0)

  000a5	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$[rsp]
  000aa	48 8b d0	 mov	 rdx, rax
  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000b2	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000b6	e8 00 00 00 00	 call	 PySequence_DelItem
  000bb	85 c0		 test	 eax, eax
  000bd	7d 0c		 jge	 SHORT $LN2@compiler_e@2

; 602  :             Py_FatalError("compiler_exit_scope()");

  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@CJOLMGIJ@compiler_exit_scope?$CI?$CJ?$AA@
  000c6	e8 00 00 00 00	 call	 Py_FatalError
$LN2@compiler_e@2:

; 603  :         compiler_unit_check(c->u);

  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000d0	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  000d4	e8 00 00 00 00	 call	 compiler_unit_check

; 604  :     }
; 605  :     else

  000d9	eb 0d		 jmp	 SHORT $LN1@compiler_e@2
$LN3@compiler_e@2:

; 606  :         c->u = NULL;

  000db	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000e0	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN1@compiler_e@2:

; 607  : 
; 608  : }

  000e8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ec	c3		 ret	 0
compiler_exit_scope ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_use_new_block DD imagerel compiler_use_new_block
	DD	imagerel compiler_use_new_block+64
	DD	imagerel $unwind$compiler_use_new_block
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_use_new_block DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_use_new_block
_TEXT	SEGMENT
block$ = 32
c$ = 64
compiler_use_new_block PROC				; COMDAT

; 688  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 689  :     basicblock *block = compiler_new_block(c);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0000e	e8 00 00 00 00	 call	 compiler_new_block
  00013	48 89 44 24 20	 mov	 QWORD PTR block$[rsp], rax

; 690  :     if (block == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR block$[rsp], 0
  0001e	75 04		 jne	 SHORT $LN1@compiler_u@3

; 691  :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	eb 17		 jmp	 SHORT $LN2@compiler_u@3
$LN1@compiler_u@3:

; 692  :     c->u->u_curblock = block;

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00029	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0002d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR block$[rsp]
  00032	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 693  :     return block;

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR block$[rsp]
$LN2@compiler_u@3:

; 694  : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
compiler_use_new_block ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_new_block DD imagerel compiler_new_block
	DD	imagerel compiler_new_block+114
	DD	imagerel $unwind$compiler_new_block
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_new_block DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_new_block
_TEXT	SEGMENT
u$ = 32
b$ = 40
c$ = 64
compiler_new_block PROC					; COMDAT

; 669  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 670  :     basicblock *b;
; 671  :     struct compiler_unit *u;
; 672  : 
; 673  :     u = c->u;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0000e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00012	48 89 44 24 20	 mov	 QWORD PTR u$[rsp], rax

; 674  :     b = (basicblock *)PyObject_Malloc(sizeof(basicblock));

  00017	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  0001c	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00021	48 89 44 24 28	 mov	 QWORD PTR b$[rsp], rax

; 675  :     if (b == NULL) {

  00026	48 83 7c 24 28
	00		 cmp	 QWORD PTR b$[rsp], 0
  0002c	75 09		 jne	 SHORT $LN1@compiler_n

; 676  :         PyErr_NoMemory();

  0002e	e8 00 00 00 00	 call	 PyErr_NoMemory

; 677  :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	eb 36		 jmp	 SHORT $LN2@compiler_n
$LN1@compiler_n:

; 678  :     }
; 679  :     memset((void *)b, 0, sizeof(basicblock));

  00037	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  0003d	33 d2		 xor	 edx, edx
  0003f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR b$[rsp]
  00044	e8 00 00 00 00	 call	 memset

; 680  :     /* Extend the singly linked list of blocks with new block. */
; 681  :     b->b_list = u->u_blocks;

  00049	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  00053	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00057	48 89 08	 mov	 QWORD PTR [rax], rcx

; 682  :     u->u_blocks = b;

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR b$[rsp]
  00064	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 683  :     return b;

  00068	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
$LN2@compiler_n:

; 684  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
compiler_new_block ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_body DD imagerel compiler_body
	DD	imagerel compiler_body+278
	DD	imagerel $unwind$compiler_body
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_body DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_body
_TEXT	SEGMENT
i$ = 32
st$ = 40
tv65 = 48
tv87 = 56
c$ = 80
stmts$ = 88
compiler_body PROC					; COMDAT

; 1261 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1262 :     int i = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 1263 :     stmt_ty st;
; 1264 : 
; 1265 :     if (!asdl_seq_LEN(stmts))

  00016	48 83 7c 24 58
	00		 cmp	 QWORD PTR stmts$[rsp], 0
  0001c	75 0b		 jne	 SHORT $LN11@compiler_b
  0001e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv65[rsp], 0
  00027	eb 0d		 jmp	 SHORT $LN12@compiler_b
$LN11@compiler_b:
  00029	48 8b 44 24 58	 mov	 rax, QWORD PTR stmts$[rsp]
  0002e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00031	48 89 44 24 30	 mov	 QWORD PTR tv65[rsp], rax
$LN12@compiler_b:
  00036	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv65[rsp], 0
  0003c	75 0a		 jne	 SHORT $LN8@compiler_b

; 1266 :         return 1;

  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	e9 c9 00 00 00	 jmp	 $LN9@compiler_b
$LN8@compiler_b:

; 1267 :     st = (stmt_ty)asdl_seq_GET(stmts, 0);

  00048	48 8b 44 24 58	 mov	 rax, QWORD PTR stmts$[rsp]
  0004d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00051	48 89 44 24 28	 mov	 QWORD PTR st$[rsp], rax

; 1268 :     if (compiler_isdocstring(st) && c->c_optimize < 2) {

  00056	48 8b 4c 24 28	 mov	 rcx, QWORD PTR st$[rsp]
  0005b	e8 00 00 00 00	 call	 compiler_isdocstring
  00060	85 c0		 test	 eax, eax
  00062	74 4d		 je	 SHORT $LN7@compiler_b
  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  00069	83 78 28 02	 cmp	 DWORD PTR [rax+40], 2
  0006d	7d 42		 jge	 SHORT $LN7@compiler_b

; 1269 :         /* don't generate docstrings if -OO */
; 1270 :         i = 1;

  0006f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1

; 1271 :         VISIT(c, expr, st->v.Expr.value);

  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR st$[rsp]
  0007c	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00080	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00085	e8 00 00 00 00	 call	 compiler_visit_expr
  0008a	85 c0		 test	 eax, eax
  0008c	75 04		 jne	 SHORT $LN6@compiler_b
  0008e	33 c0		 xor	 eax, eax
  00090	eb 7f		 jmp	 SHORT $LN9@compiler_b
$LN6@compiler_b:

; 1272 :         if (!compiler_nameop(c, __doc__, Store))

  00092	41 b8 02 00 00
	00		 mov	 r8d, 2
  00098	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __doc__
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000a4	e8 00 00 00 00	 call	 compiler_nameop
  000a9	85 c0		 test	 eax, eax
  000ab	75 04		 jne	 SHORT $LN5@compiler_b

; 1273 :             return 0;

  000ad	33 c0		 xor	 eax, eax
  000af	eb 60		 jmp	 SHORT $LN9@compiler_b
$LN5@compiler_b:
$LN7@compiler_b:

; 1274 :     }
; 1275 :     for (; i < asdl_seq_LEN(stmts); i++)

  000b1	eb 0a		 jmp	 SHORT $LN4@compiler_b
$LN3@compiler_b:
  000b3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000b7	ff c0		 inc	 eax
  000b9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@compiler_b:
  000bd	48 83 7c 24 58
	00		 cmp	 QWORD PTR stmts$[rsp], 0
  000c3	75 0b		 jne	 SHORT $LN13@compiler_b
  000c5	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv87[rsp], 0
  000ce	eb 0d		 jmp	 SHORT $LN14@compiler_b
$LN13@compiler_b:
  000d0	48 8b 44 24 58	 mov	 rax, QWORD PTR stmts$[rsp]
  000d5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d8	48 89 44 24 38	 mov	 QWORD PTR tv87[rsp], rax
$LN14@compiler_b:
  000dd	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000e2	48 3b 44 24 38	 cmp	 rax, QWORD PTR tv87[rsp]
  000e7	7d 23		 jge	 SHORT $LN2@compiler_b

; 1276 :         VISIT(c, stmt, (stmt_ty)asdl_seq_GET(stmts, i));

  000e9	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ee	48 8b 4c 24 58	 mov	 rcx, QWORD PTR stmts$[rsp]
  000f3	48 8b 54 c1 08	 mov	 rdx, QWORD PTR [rcx+rax*8+8]
  000f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000fd	e8 00 00 00 00	 call	 compiler_visit_stmt
  00102	85 c0		 test	 eax, eax
  00104	75 04		 jne	 SHORT $LN1@compiler_b
  00106	33 c0		 xor	 eax, eax
  00108	eb 07		 jmp	 SHORT $LN9@compiler_b
$LN1@compiler_b:
  0010a	eb a7		 jmp	 SHORT $LN3@compiler_b
$LN2@compiler_b:

; 1277 :     return 1;

  0010c	b8 01 00 00 00	 mov	 eax, 1
$LN9@compiler_b:

; 1278 : }

  00111	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00115	c3		 ret	 0
compiler_body ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_isdocstring DD imagerel compiler_isdocstring
	DD	imagerel compiler_isdocstring+61
	DD	imagerel $unwind$compiler_isdocstring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_isdocstring DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_isdocstring
_TEXT	SEGMENT
tv68 = 0
s$ = 32
compiler_isdocstring PROC				; COMDAT

; 1251 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1252 :     if (s->kind != Expr_kind)

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0000e	83 38 12	 cmp	 DWORD PTR [rax], 18
  00011	74 04		 je	 SHORT $LN1@compiler_i@2

; 1253 :         return 0;

  00013	33 c0		 xor	 eax, eax
  00015	eb 21		 jmp	 SHORT $LN2@compiler_i@2
$LN1@compiler_i@2:

; 1254 :     return s->v.Expr.value->kind == Str_kind;

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0001c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00020	83 38 11	 cmp	 DWORD PTR [rax], 17
  00023	75 09		 jne	 SHORT $LN4@compiler_i@2
  00025	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv68[rsp], 1
  0002c	eb 07		 jmp	 SHORT $LN5@compiler_i@2
$LN4@compiler_i@2:
  0002e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN5@compiler_i@2:
  00035	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
$LN2@compiler_i@2:

; 1255 : }

  00038	48 83 c4 18	 add	 rsp, 24
  0003c	c3		 ret	 0
compiler_isdocstring ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MLDPDGD@?8break?8?5outside?5loop?$AA@	; `string'
PUBLIC	??_C@_0BK@DDMKJOGO@?8return?8?5outside?5function?$AA@ ; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_stmt DD imagerel compiler_visit_stmt
	DD	imagerel compiler_visit_stmt+1324
	DD	imagerel $unwind$compiler_visit_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_stmt DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0BF@MLDPDGD@?8break?8?5outside?5loop?$AA@
CONST	SEGMENT
??_C@_0BF@MLDPDGD@?8break?8?5outside?5loop?$AA@ DB '''break'' outside loo'
	DB	'p', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DDMKJOGO@?8return?8?5outside?5function?$AA@
CONST	SEGMENT
??_C@_0BK@DDMKJOGO@?8return?8?5outside?5function?$AA@ DB '''return'' outs'
	DB	'ide function', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_visit_stmt
_TEXT	SEGMENT
n$ = 32
i$ = 36
_i$24010 = 40
seq$24011 = 48
elt$24016 = 56
tv72 = 64
tv141 = 72
tv155 = 80
c$ = 112
s$ = 120
compiler_visit_stmt PROC				; COMDAT

; 2416 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2417 :     int i, n;
; 2418 : 
; 2419 :     /* Always assign a lineno to the next instruction for a stmt. */
; 2420 :     c->u->u_lineno = s->lineno;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00013	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00017	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	8b 49 40	 mov	 ecx, DWORD PTR [rcx+64]
  0001f	89 88 b4 01 00
	00		 mov	 DWORD PTR [rax+436], ecx

; 2421 :     c->u->u_col_offset = s->col_offset;

  00025	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0002a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0002e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  00033	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  00036	89 88 b8 01 00
	00		 mov	 DWORD PTR [rax+440], ecx

; 2422 :     c->u->u_lineno_set = 0;

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00041	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00045	c7 80 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+444], 0

; 2423 : 
; 2424 :     switch (s->kind) {

  0004f	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00054	8b 00		 mov	 eax, DWORD PTR [rax]
  00056	89 44 24 40	 mov	 DWORD PTR tv72[rsp], eax
  0005a	8b 44 24 40	 mov	 eax, DWORD PTR tv72[rsp]
  0005e	ff c8		 dec	 eax
  00060	89 44 24 40	 mov	 DWORD PTR tv72[rsp], eax
  00064	83 7c 24 40 14	 cmp	 DWORD PTR tv72[rsp], 20
  00069	0f 87 5d 04 00
	00		 ja	 $LN52@compiler_v
  0006f	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv72[rsp]
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0007b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN60@compiler_v[rcx+rax*4]
  00082	48 03 c1	 add	 rax, rcx
  00085	ff e0		 jmp	 rax
$LN51@compiler_v:

; 2425 :     case FunctionDef_kind:
; 2426 :         return compiler_function(c, s);

  00087	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  0008c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00091	e8 00 00 00 00	 call	 compiler_function
  00096	e9 36 04 00 00	 jmp	 $LN54@compiler_v
$LN50@compiler_v:

; 2427 :     case ClassDef_kind:
; 2428 :         return compiler_class(c, s);

  0009b	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  000a0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000a5	e8 00 00 00 00	 call	 compiler_class
  000aa	e9 22 04 00 00	 jmp	 $LN54@compiler_v
$LN49@compiler_v:

; 2429 :     case Return_kind:
; 2430 :         if (c->u->u_ste->ste_type != FunctionBlock)

  000af	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  000b4	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bb	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  000c2	74 16		 je	 SHORT $LN48@compiler_v

; 2431 :             return compiler_error(c, "'return' outside function");

  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DDMKJOGO@?8return?8?5outside?5function?$AA@
  000cb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000d0	e8 00 00 00 00	 call	 compiler_error
  000d5	e9 f7 03 00 00	 jmp	 $LN54@compiler_v
$LN48@compiler_v:

; 2432 :         if (s->v.Return.value) {

  000da	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  000df	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000e4	74 20		 je	 SHORT $LN47@compiler_v

; 2433 :             VISIT(c, expr, s->v.Return.value);

  000e6	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  000eb	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000ef	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000f4	e8 00 00 00 00	 call	 compiler_visit_expr
  000f9	85 c0		 test	 eax, eax
  000fb	75 07		 jne	 SHORT $LN46@compiler_v
  000fd	33 c0		 xor	 eax, eax
  000ff	e9 cd 03 00 00	 jmp	 $LN54@compiler_v
$LN46@compiler_v:

; 2434 :         }
; 2435 :         else

  00104	eb 2e		 jmp	 SHORT $LN45@compiler_v
$LN47@compiler_v:

; 2436 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00106	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0010b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0010f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00116	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  0011a	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0011f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00124	e8 00 00 00 00	 call	 compiler_addop_o
  00129	85 c0		 test	 eax, eax
  0012b	75 07		 jne	 SHORT $LN44@compiler_v
  0012d	33 c0		 xor	 eax, eax
  0012f	e9 9d 03 00 00	 jmp	 $LN54@compiler_v
$LN44@compiler_v:
$LN45@compiler_v:

; 2437 :         ADDOP(c, RETURN_VALUE);

  00134	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  00139	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0013e	e8 00 00 00 00	 call	 compiler_addop
  00143	85 c0		 test	 eax, eax
  00145	75 07		 jne	 SHORT $LN43@compiler_v
  00147	33 c0		 xor	 eax, eax
  00149	e9 83 03 00 00	 jmp	 $LN54@compiler_v
$LN43@compiler_v:

; 2438 :         break;

  0014e	e9 79 03 00 00	 jmp	 $LN52@compiler_v
$LN42@compiler_v:

; 2439 :     case Delete_kind:
; 2440 :         VISIT_SEQ(c, expr, s->v.Delete.targets)

  00153	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00158	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0015c	48 89 44 24 30	 mov	 QWORD PTR seq$24011[rsp], rax
  00161	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _i$24010[rsp], 0
  00169	eb 0a		 jmp	 SHORT $LN41@compiler_v
$LN40@compiler_v:
  0016b	8b 44 24 28	 mov	 eax, DWORD PTR _i$24010[rsp]
  0016f	ff c0		 inc	 eax
  00171	89 44 24 28	 mov	 DWORD PTR _i$24010[rsp], eax
$LN41@compiler_v:
  00175	48 83 7c 24 30
	00		 cmp	 QWORD PTR seq$24011[rsp], 0
  0017b	75 0b		 jne	 SHORT $LN56@compiler_v
  0017d	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv141[rsp], 0
  00186	eb 0d		 jmp	 SHORT $LN57@compiler_v
$LN56@compiler_v:
  00188	48 8b 44 24 30	 mov	 rax, QWORD PTR seq$24011[rsp]
  0018d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00190	48 89 44 24 48	 mov	 QWORD PTR tv141[rsp], rax
$LN57@compiler_v:
  00195	48 63 44 24 28	 movsxd	 rax, DWORD PTR _i$24010[rsp]
  0019a	48 3b 44 24 48	 cmp	 rax, QWORD PTR tv141[rsp]
  0019f	7d 30		 jge	 SHORT $LN39@compiler_v
  001a1	48 63 44 24 28	 movsxd	 rax, DWORD PTR _i$24010[rsp]
  001a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR seq$24011[rsp]
  001ab	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  001b0	48 89 44 24 38	 mov	 QWORD PTR elt$24016[rsp], rax
  001b5	48 8b 54 24 38	 mov	 rdx, QWORD PTR elt$24016[rsp]
  001ba	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  001bf	e8 00 00 00 00	 call	 compiler_visit_expr
  001c4	85 c0		 test	 eax, eax
  001c6	75 07		 jne	 SHORT $LN38@compiler_v
  001c8	33 c0		 xor	 eax, eax
  001ca	e9 02 03 00 00	 jmp	 $LN54@compiler_v
$LN38@compiler_v:
  001cf	eb 9a		 jmp	 SHORT $LN40@compiler_v
$LN39@compiler_v:

; 2441 :         break;

  001d1	e9 f6 02 00 00	 jmp	 $LN52@compiler_v
$LN37@compiler_v:

; 2442 :     case Assign_kind:
; 2443 :         n = asdl_seq_LEN(s->v.Assign.targets);

  001d6	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  001db	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  001e0	75 0b		 jne	 SHORT $LN58@compiler_v
  001e2	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv155[rsp], 0
  001eb	eb 11		 jmp	 SHORT $LN59@compiler_v
$LN58@compiler_v:
  001ed	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  001f2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001f6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f9	48 89 44 24 50	 mov	 QWORD PTR tv155[rsp], rax
$LN59@compiler_v:
  001fe	8b 44 24 50	 mov	 eax, DWORD PTR tv155[rsp]
  00202	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 2444 :         VISIT(c, expr, s->v.Assign.value);

  00206	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  0020b	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0020f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00214	e8 00 00 00 00	 call	 compiler_visit_expr
  00219	85 c0		 test	 eax, eax
  0021b	75 07		 jne	 SHORT $LN36@compiler_v
  0021d	33 c0		 xor	 eax, eax
  0021f	e9 ad 02 00 00	 jmp	 $LN54@compiler_v
$LN36@compiler_v:

; 2445 :         for (i = 0; i < n; i++) {

  00224	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0022c	eb 0a		 jmp	 SHORT $LN35@compiler_v
$LN34@compiler_v:
  0022e	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00232	ff c0		 inc	 eax
  00234	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN35@compiler_v:
  00238	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0023c	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00240	7d 50		 jge	 SHORT $LN33@compiler_v

; 2446 :             if (i < n - 1)

  00242	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00246	ff c8		 dec	 eax
  00248	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0024c	7d 1a		 jge	 SHORT $LN32@compiler_v

; 2447 :                 ADDOP(c, DUP_TOP);

  0024e	ba 04 00 00 00	 mov	 edx, 4
  00253	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00258	e8 00 00 00 00	 call	 compiler_addop
  0025d	85 c0		 test	 eax, eax
  0025f	75 07		 jne	 SHORT $LN31@compiler_v
  00261	33 c0		 xor	 eax, eax
  00263	e9 69 02 00 00	 jmp	 $LN54@compiler_v
$LN31@compiler_v:
$LN32@compiler_v:

; 2448 :             VISIT(c, expr,
; 2449 :                   (expr_ty)asdl_seq_GET(s->v.Assign.targets, i));

  00268	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  0026d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00271	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00276	48 8b 54 c8 08	 mov	 rdx, QWORD PTR [rax+rcx*8+8]
  0027b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00280	e8 00 00 00 00	 call	 compiler_visit_expr
  00285	85 c0		 test	 eax, eax
  00287	75 07		 jne	 SHORT $LN30@compiler_v
  00289	33 c0		 xor	 eax, eax
  0028b	e9 41 02 00 00	 jmp	 $LN54@compiler_v
$LN30@compiler_v:

; 2450 :         }

  00290	eb 9c		 jmp	 SHORT $LN34@compiler_v
$LN33@compiler_v:

; 2451 :         break;

  00292	e9 35 02 00 00	 jmp	 $LN52@compiler_v
$LN29@compiler_v:

; 2452 :     case AugAssign_kind:
; 2453 :         return compiler_augassign(c, s);

  00297	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  0029c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002a1	e8 00 00 00 00	 call	 compiler_augassign
  002a6	e9 26 02 00 00	 jmp	 $LN54@compiler_v
$LN28@compiler_v:

; 2454 :     case For_kind:
; 2455 :         return compiler_for(c, s);

  002ab	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  002b0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002b5	e8 00 00 00 00	 call	 compiler_for
  002ba	e9 12 02 00 00	 jmp	 $LN54@compiler_v
$LN27@compiler_v:

; 2456 :     case While_kind:
; 2457 :         return compiler_while(c, s);

  002bf	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  002c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002c9	e8 00 00 00 00	 call	 compiler_while
  002ce	e9 fe 01 00 00	 jmp	 $LN54@compiler_v
$LN26@compiler_v:

; 2458 :     case If_kind:
; 2459 :         return compiler_if(c, s);

  002d3	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  002d8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002dd	e8 00 00 00 00	 call	 compiler_if
  002e2	e9 ea 01 00 00	 jmp	 $LN54@compiler_v
$LN25@compiler_v:

; 2460 :     case Raise_kind:
; 2461 :         n = 0;

  002e7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 2462 :         if (s->v.Raise.exc) {

  002ef	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  002f4	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  002f9	74 5c		 je	 SHORT $LN24@compiler_v

; 2463 :             VISIT(c, expr, s->v.Raise.exc);

  002fb	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00300	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00304	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00309	e8 00 00 00 00	 call	 compiler_visit_expr
  0030e	85 c0		 test	 eax, eax
  00310	75 07		 jne	 SHORT $LN23@compiler_v
  00312	33 c0		 xor	 eax, eax
  00314	e9 b8 01 00 00	 jmp	 $LN54@compiler_v
$LN23@compiler_v:

; 2464 :             n++;

  00319	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0031d	ff c0		 inc	 eax
  0031f	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 2465 :         if (s->v.Raise.cause) {

  00323	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00328	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0032d	74 28		 je	 SHORT $LN22@compiler_v

; 2466 :         VISIT(c, expr, s->v.Raise.cause);

  0032f	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00334	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00338	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0033d	e8 00 00 00 00	 call	 compiler_visit_expr
  00342	85 c0		 test	 eax, eax
  00344	75 07		 jne	 SHORT $LN21@compiler_v
  00346	33 c0		 xor	 eax, eax
  00348	e9 84 01 00 00	 jmp	 $LN54@compiler_v
$LN21@compiler_v:

; 2467 :         n++;

  0034d	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00351	ff c0		 inc	 eax
  00353	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN22@compiler_v:
$LN24@compiler_v:

; 2468 :         }
; 2469 :         }
; 2470 :         ADDOP_I(c, RAISE_VARARGS, n);

  00357	44 8b 44 24 20	 mov	 r8d, DWORD PTR n$[rsp]
  0035c	ba 82 00 00 00	 mov	 edx, 130		; 00000082H
  00361	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00366	e8 00 00 00 00	 call	 compiler_addop_i
  0036b	85 c0		 test	 eax, eax
  0036d	75 07		 jne	 SHORT $LN20@compiler_v
  0036f	33 c0		 xor	 eax, eax
  00371	e9 5b 01 00 00	 jmp	 $LN54@compiler_v
$LN20@compiler_v:

; 2471 :         break;

  00376	e9 51 01 00 00	 jmp	 $LN52@compiler_v
$LN19@compiler_v:

; 2472 :     case Try_kind:
; 2473 :         return compiler_try(c, s);

  0037b	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  00380	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00385	e8 00 00 00 00	 call	 compiler_try
  0038a	e9 42 01 00 00	 jmp	 $LN54@compiler_v
$LN18@compiler_v:

; 2474 :     case Assert_kind:
; 2475 :         return compiler_assert(c, s);

  0038f	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  00394	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00399	e8 00 00 00 00	 call	 compiler_assert
  0039e	e9 2e 01 00 00	 jmp	 $LN54@compiler_v
$LN17@compiler_v:

; 2476 :     case Import_kind:
; 2477 :         return compiler_import(c, s);

  003a3	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  003a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  003ad	e8 00 00 00 00	 call	 compiler_import
  003b2	e9 1a 01 00 00	 jmp	 $LN54@compiler_v
$LN16@compiler_v:

; 2478 :     case ImportFrom_kind:
; 2479 :         return compiler_from_import(c, s);

  003b7	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  003bc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  003c1	e8 00 00 00 00	 call	 compiler_from_import
  003c6	e9 06 01 00 00	 jmp	 $LN54@compiler_v

; 2480 :     case Global_kind:
; 2481 :     case Nonlocal_kind:
; 2482 :         break;

  003cb	e9 fc 00 00 00	 jmp	 $LN52@compiler_v
$LN14@compiler_v:

; 2483 :     case Expr_kind:
; 2484 :         if (c->c_interactive && c->c_nestlevel <= 1) {

  003d0	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  003d5	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  003d9	74 45		 je	 SHORT $LN13@compiler_v
  003db	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  003e0	83 78 30 01	 cmp	 DWORD PTR [rax+48], 1
  003e4	7f 3a		 jg	 SHORT $LN13@compiler_v

; 2485 :             VISIT(c, expr, s->v.Expr.value);

  003e6	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  003eb	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  003ef	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  003f4	e8 00 00 00 00	 call	 compiler_visit_expr
  003f9	85 c0		 test	 eax, eax
  003fb	75 07		 jne	 SHORT $LN12@compiler_v
  003fd	33 c0		 xor	 eax, eax
  003ff	e9 cd 00 00 00	 jmp	 $LN54@compiler_v
$LN12@compiler_v:

; 2486 :             ADDOP(c, PRINT_EXPR);

  00404	ba 46 00 00 00	 mov	 edx, 70			; 00000046H
  00409	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0040e	e8 00 00 00 00	 call	 compiler_addop
  00413	85 c0		 test	 eax, eax
  00415	75 07		 jne	 SHORT $LN11@compiler_v
  00417	33 c0		 xor	 eax, eax
  00419	e9 b3 00 00 00	 jmp	 $LN54@compiler_v
$LN11@compiler_v:

; 2487 :         }
; 2488 :         else if (s->v.Expr.value->kind != Str_kind &&

  0041e	eb 4e		 jmp	 SHORT $LN10@compiler_v
$LN13@compiler_v:

; 2489 :                  s->v.Expr.value->kind != Num_kind) {

  00420	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00425	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00429	83 38 11	 cmp	 DWORD PTR [rax], 17
  0042c	74 40		 je	 SHORT $LN9@compiler_v
  0042e	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00433	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00437	83 38 10	 cmp	 DWORD PTR [rax], 16
  0043a	74 32		 je	 SHORT $LN9@compiler_v

; 2490 :             VISIT(c, expr, s->v.Expr.value);

  0043c	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00441	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00445	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0044a	e8 00 00 00 00	 call	 compiler_visit_expr
  0044f	85 c0		 test	 eax, eax
  00451	75 04		 jne	 SHORT $LN8@compiler_v
  00453	33 c0		 xor	 eax, eax
  00455	eb 7a		 jmp	 SHORT $LN54@compiler_v
$LN8@compiler_v:

; 2491 :             ADDOP(c, POP_TOP);

  00457	ba 01 00 00 00	 mov	 edx, 1
  0045c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00461	e8 00 00 00 00	 call	 compiler_addop
  00466	85 c0		 test	 eax, eax
  00468	75 04		 jne	 SHORT $LN7@compiler_v
  0046a	33 c0		 xor	 eax, eax
  0046c	eb 63		 jmp	 SHORT $LN54@compiler_v
$LN7@compiler_v:
$LN9@compiler_v:
$LN10@compiler_v:

; 2492 :         }
; 2493 :         break;

  0046e	eb 5c		 jmp	 SHORT $LN52@compiler_v

; 2494 :     case Pass_kind:
; 2495 :         break;

  00470	eb 5a		 jmp	 SHORT $LN52@compiler_v
$LN5@compiler_v:

; 2496 :     case Break_kind:
; 2497 :         if (!compiler_in_loop(c))

  00472	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00477	e8 00 00 00 00	 call	 compiler_in_loop
  0047c	85 c0		 test	 eax, eax
  0047e	75 13		 jne	 SHORT $LN4@compiler_v

; 2498 :             return compiler_error(c, "'break' outside loop");

  00480	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MLDPDGD@?8break?8?5outside?5loop?$AA@
  00487	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0048c	e8 00 00 00 00	 call	 compiler_error
  00491	eb 3e		 jmp	 SHORT $LN54@compiler_v
$LN4@compiler_v:

; 2499 :         ADDOP(c, BREAK_LOOP);

  00493	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00498	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0049d	e8 00 00 00 00	 call	 compiler_addop
  004a2	85 c0		 test	 eax, eax
  004a4	75 04		 jne	 SHORT $LN3@compiler_v
  004a6	33 c0		 xor	 eax, eax
  004a8	eb 27		 jmp	 SHORT $LN54@compiler_v
$LN3@compiler_v:

; 2500 :         break;

  004aa	eb 20		 jmp	 SHORT $LN52@compiler_v
$LN2@compiler_v:

; 2501 :     case Continue_kind:
; 2502 :         return compiler_continue(c);

  004ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  004b1	e8 00 00 00 00	 call	 compiler_continue
  004b6	eb 19		 jmp	 SHORT $LN54@compiler_v
$LN1@compiler_v:

; 2503 :     case With_kind:
; 2504 :         return compiler_with(c, s, 0);

  004b8	45 33 c0	 xor	 r8d, r8d
  004bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  004c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  004c5	e8 00 00 00 00	 call	 compiler_with
  004ca	eb 05		 jmp	 SHORT $LN54@compiler_v
$LN52@compiler_v:

; 2505 :     }
; 2506 :     return 1;

  004cc	b8 01 00 00 00	 mov	 eax, 1
$LN54@compiler_v:

; 2507 : }

  004d1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004d5	c3		 ret	 0
  004d6	66 90		 npad	 2
$LN60@compiler_v:
  004d8	00 00 00 00	 DD	 $LN51@compiler_v
  004dc	00 00 00 00	 DD	 $LN50@compiler_v
  004e0	00 00 00 00	 DD	 $LN49@compiler_v
  004e4	00 00 00 00	 DD	 $LN42@compiler_v
  004e8	00 00 00 00	 DD	 $LN37@compiler_v
  004ec	00 00 00 00	 DD	 $LN29@compiler_v
  004f0	00 00 00 00	 DD	 $LN28@compiler_v
  004f4	00 00 00 00	 DD	 $LN27@compiler_v
  004f8	00 00 00 00	 DD	 $LN26@compiler_v
  004fc	00 00 00 00	 DD	 $LN1@compiler_v
  00500	00 00 00 00	 DD	 $LN25@compiler_v
  00504	00 00 00 00	 DD	 $LN19@compiler_v
  00508	00 00 00 00	 DD	 $LN18@compiler_v
  0050c	00 00 00 00	 DD	 $LN17@compiler_v
  00510	00 00 00 00	 DD	 $LN16@compiler_v
  00514	00 00 00 00	 DD	 $LN52@compiler_v
  00518	00 00 00 00	 DD	 $LN52@compiler_v
  0051c	00 00 00 00	 DD	 $LN14@compiler_v
  00520	00 00 00 00	 DD	 $LN52@compiler_v
  00524	00 00 00 00	 DD	 $LN5@compiler_v
  00528	00 00 00 00	 DD	 $LN2@compiler_v
compiler_visit_stmt ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_addop DD imagerel compiler_addop
	DD	imagerel compiler_addop+172
	DD	imagerel $unwind$compiler_addop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_addop DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_addop
_TEXT	SEGMENT
i$ = 32
off$ = 40
b$ = 48
c$ = 80
opcode$ = 88
compiler_addop PROC					; COMDAT

; 992  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 993  :     basicblock *b;
; 994  :     struct instr *i;
; 995  :     int off;
; 996  :     off = compiler_next_instr(c, c->u->u_curblock);

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  00012	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00016	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0001f	e8 00 00 00 00	 call	 compiler_next_instr
  00024	89 44 24 28	 mov	 DWORD PTR off$[rsp], eax

; 997  :     if (off < 0)

  00028	83 7c 24 28 00	 cmp	 DWORD PTR off$[rsp], 0
  0002d	7d 04		 jge	 SHORT $LN2@compiler_a

; 998  :         return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 74		 jmp	 SHORT $LN3@compiler_a
$LN2@compiler_a:

; 999  :     b = c->u->u_curblock;

  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  00038	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0003c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00040	48 89 44 24 30	 mov	 QWORD PTR b$[rsp], rax

; 1000 :     i = &b->b_instr[off];

  00045	48 63 44 24 28	 movsxd	 rax, DWORD PTR off$[rsp]
  0004a	48 6b c0 20	 imul	 rax, 32			; 00000020H
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00053	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00057	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 1001 :     i->i_opcode = opcode;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00061	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR opcode$[rsp]
  00066	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1002 :     i->i_hasarg = 0;

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0006e	8b 00		 mov	 eax, DWORD PTR [rax]
  00070	83 e0 fb	 and	 eax, -5			; fffffffbH
  00073	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00078	89 01		 mov	 DWORD PTR [rcx], eax

; 1003 :     if (opcode == RETURN_VALUE)

  0007a	83 7c 24 58 53	 cmp	 DWORD PTR opcode$[rsp], 83 ; 00000053H
  0007f	75 13		 jne	 SHORT $LN1@compiler_a

; 1004 :         b->b_return = 1;

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  00086	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00089	83 c8 02	 or	 eax, 2
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00091	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN1@compiler_a:

; 1005 :     compiler_set_lineno(c, off);

  00094	8b 54 24 28	 mov	 edx, DWORD PTR off$[rsp]
  00098	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0009d	e8 00 00 00 00	 call	 compiler_set_lineno

; 1006 :     return 1;

  000a2	b8 01 00 00 00	 mov	 eax, 1
$LN3@compiler_a:

; 1007 : }

  000a7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ab	c3		 ret	 0
compiler_addop ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@MBABLIAL@?$AAb?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	_PyObject_DebugRealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_next_instr DD imagerel compiler_next_instr
	DD	imagerel compiler_next_instr+410
	DD	imagerel $unwind$compiler_next_instr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_next_instr DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1BE@MBABLIAL@?$AAb?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@MBABLIAL@?$AAb?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'b'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_next_instr
_TEXT	SEGMENT
oldsize$22751 = 32
newsize$22752 = 40
tmp$22750 = 48
tv141 = 56
c$ = 80
b$ = 88
compiler_next_instr PROC				; COMDAT

; 723  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 724  :     assert(b != NULL);

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR b$[rsp], 0
  00014	75 1c		 jne	 SHORT $LN10@compiler_n@2
  00016	41 b8 d4 02 00
	00		 mov	 r8d, 724		; 000002d4H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@MBABLIAL@?$AAb?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN10@compiler_n@2:

; 725  :     if (b->b_instr == NULL) {

  00032	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00037	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0003c	75 55		 jne	 SHORT $LN7@compiler_n@2

; 726  :         b->b_instr = (struct instr *)PyObject_Malloc(
; 727  :                          sizeof(struct instr) * DEFAULT_BLOCK_SIZE);

  0003e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00043	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00048	48 8b 4c 24 58	 mov	 rcx, QWORD PTR b$[rsp]
  0004d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 728  :         if (b->b_instr == NULL) {

  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00056	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0005b	75 0f		 jne	 SHORT $LN6@compiler_n@2

; 729  :             PyErr_NoMemory();

  0005d	e8 00 00 00 00	 call	 PyErr_NoMemory

; 730  :             return -1;

  00062	b8 ff ff ff ff	 mov	 eax, -1
  00067	e9 29 01 00 00	 jmp	 $LN8@compiler_n@2
$LN6@compiler_n@2:

; 731  :         }
; 732  :         b->b_ialloc = DEFAULT_BLOCK_SIZE;

  0006c	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00071	c7 40 0c 10 00
	00 00		 mov	 DWORD PTR [rax+12], 16

; 733  :         memset((char *)b->b_instr, 0,
; 734  :                sizeof(struct instr) * DEFAULT_BLOCK_SIZE);

  00078	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0007e	33 d2		 xor	 edx, edx
  00080	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00085	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00089	e8 00 00 00 00	 call	 memset
  0008e	e9 e0 00 00 00	 jmp	 $LN5@compiler_n@2
$LN7@compiler_n@2:

; 735  :     }
; 736  :     else if (b->b_iused == b->b_ialloc) {

  00093	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR b$[rsp]
  0009d	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  000a0	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  000a3	0f 85 ca 00 00
	00		 jne	 $LN4@compiler_n@2

; 737  :         struct instr *tmp;
; 738  :         size_t oldsize, newsize;
; 739  :         oldsize = b->b_ialloc * sizeof(struct instr);

  000a9	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  000ae	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  000b2	48 6b c0 20	 imul	 rax, 32			; 00000020H
  000b6	48 89 44 24 20	 mov	 QWORD PTR oldsize$22751[rsp], rax

; 740  :         newsize = oldsize << 1;

  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR oldsize$22751[rsp]
  000c0	48 d1 e0	 shl	 rax, 1
  000c3	48 89 44 24 28	 mov	 QWORD PTR newsize$22752[rsp], rax

; 741  : 
; 742  :         if (oldsize > (PY_SIZE_MAX >> 1)) {

  000c8	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000d2	48 39 44 24 20	 cmp	 QWORD PTR oldsize$22751[rsp], rax
  000d7	76 0f		 jbe	 SHORT $LN3@compiler_n@2

; 743  :             PyErr_NoMemory();

  000d9	e8 00 00 00 00	 call	 PyErr_NoMemory

; 744  :             return -1;

  000de	b8 ff ff ff ff	 mov	 eax, -1
  000e3	e9 ad 00 00 00	 jmp	 $LN8@compiler_n@2
$LN3@compiler_n@2:

; 745  :         }
; 746  : 
; 747  :         if (newsize == 0) {

  000e8	48 83 7c 24 28
	00		 cmp	 QWORD PTR newsize$22752[rsp], 0
  000ee	75 0f		 jne	 SHORT $LN2@compiler_n@2

; 748  :             PyErr_NoMemory();

  000f0	e8 00 00 00 00	 call	 PyErr_NoMemory

; 749  :             return -1;

  000f5	b8 ff ff ff ff	 mov	 eax, -1
  000fa	e9 96 00 00 00	 jmp	 $LN8@compiler_n@2
$LN2@compiler_n@2:

; 750  :         }
; 751  :         b->b_ialloc <<= 1;

  000ff	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00104	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00107	d1 e0		 shl	 eax, 1
  00109	48 8b 4c 24 58	 mov	 rcx, QWORD PTR b$[rsp]
  0010e	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 752  :         tmp = (struct instr *)PyObject_Realloc(
; 753  :                                         (void *)b->b_instr, newsize);

  00111	48 8b 54 24 28	 mov	 rdx, QWORD PTR newsize$22752[rsp]
  00116	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  0011b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0011f	e8 00 00 00 00	 call	 _PyObject_DebugRealloc
  00124	48 89 44 24 30	 mov	 QWORD PTR tmp$22750[rsp], rax

; 754  :         if (tmp == NULL) {

  00129	48 83 7c 24 30
	00		 cmp	 QWORD PTR tmp$22750[rsp], 0
  0012f	75 0c		 jne	 SHORT $LN1@compiler_n@2

; 755  :             PyErr_NoMemory();

  00131	e8 00 00 00 00	 call	 PyErr_NoMemory

; 756  :             return -1;

  00136	b8 ff ff ff ff	 mov	 eax, -1
  0013b	eb 58		 jmp	 SHORT $LN8@compiler_n@2
$LN1@compiler_n@2:

; 757  :         }
; 758  :         b->b_instr = tmp;

  0013d	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00142	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp$22750[rsp]
  00147	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 759  :         memset((char *)b->b_instr + oldsize, 0, newsize - oldsize);

  0014b	48 8b 44 24 20	 mov	 rax, QWORD PTR oldsize$22751[rsp]
  00150	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newsize$22752[rsp]
  00155	48 2b c8	 sub	 rcx, rax
  00158	48 8b c1	 mov	 rax, rcx
  0015b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR b$[rsp]
  00160	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00164	48 03 4c 24 20	 add	 rcx, QWORD PTR oldsize$22751[rsp]
  00169	4c 8b c0	 mov	 r8, rax
  0016c	33 d2		 xor	 edx, edx
  0016e	e8 00 00 00 00	 call	 memset
$LN4@compiler_n@2:
$LN5@compiler_n@2:

; 760  :     }
; 761  :     return b->b_iused++;

  00173	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00178	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0017b	89 44 24 38	 mov	 DWORD PTR tv141[rsp], eax
  0017f	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00184	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00187	ff c0		 inc	 eax
  00189	48 8b 4c 24 58	 mov	 rcx, QWORD PTR b$[rsp]
  0018e	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00191	8b 44 24 38	 mov	 eax, DWORD PTR tv141[rsp]
$LN8@compiler_n@2:

; 762  : }

  00195	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00199	c3		 ret	 0
compiler_next_instr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_set_lineno DD imagerel compiler_set_lineno
	DD	imagerel compiler_set_lineno+110
	DD	imagerel $unwind$compiler_set_lineno
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_set_lineno DD 010d01H
	DD	0220dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_set_lineno
_TEXT	SEGMENT
b$ = 0
c$ = 32
off$ = 40
compiler_set_lineno PROC				; COMDAT

; 778  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 779  :     basicblock *b;
; 780  :     if (c->u->u_lineno_set)

  0000d	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]
  00012	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00016	83 b8 bc 01 00
	00 00		 cmp	 DWORD PTR [rax+444], 0
  0001d	74 02		 je	 SHORT $LN1@compiler_s

; 781  :         return;

  0001f	eb 48		 jmp	 SHORT $LN2@compiler_s
$LN1@compiler_s:

; 782  :     c->u->u_lineno_set = 1;

  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]
  00026	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0002a	c7 80 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+444], 1

; 783  :     b = c->u->u_curblock;

  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]
  00039	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0003d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00041	48 89 04 24	 mov	 QWORD PTR b$[rsp], rax

; 784  :     b->b_instr[off].i_lineno = c->u->u_lineno;

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]
  0004a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0004e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR off$[rsp]
  00053	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  00057	48 8b 14 24	 mov	 rdx, QWORD PTR b$[rsp]
  0005b	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0005f	8b 80 b4 01 00
	00		 mov	 eax, DWORD PTR [rax+436]
  00065	89 44 0a 18	 mov	 DWORD PTR [rdx+rcx+24], eax
$LN2@compiler_s:

; 785  : }

  00069	48 83 c4 18	 add	 rsp, 24
  0006d	c3		 ret	 0
compiler_set_lineno ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_addop_o DD imagerel compiler_addop_o
	DD	imagerel compiler_addop_o+82
	DD	imagerel $unwind$compiler_addop_o
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_addop_o DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_addop_o
_TEXT	SEGMENT
arg$ = 32
c$ = 64
opcode$ = 72
dict$ = 80
o$ = 88
compiler_addop_o PROC					; COMDAT

; 1084 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1085 :     int arg = compiler_add_o(c, dict, o);

  00017	4c 8b 44 24 58	 mov	 r8, QWORD PTR o$[rsp]
  0001c	48 8b 54 24 50	 mov	 rdx, QWORD PTR dict$[rsp]
  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00026	e8 00 00 00 00	 call	 compiler_add_o
  0002b	89 44 24 20	 mov	 DWORD PTR arg$[rsp], eax

; 1086 :     if (arg < 0)

  0002f	83 7c 24 20 00	 cmp	 DWORD PTR arg$[rsp], 0
  00034	7d 04		 jge	 SHORT $LN1@compiler_a@2

; 1087 :         return 0;

  00036	33 c0		 xor	 eax, eax
  00038	eb 13		 jmp	 SHORT $LN2@compiler_a@2
$LN1@compiler_a@2:

; 1088 :     return compiler_addop_i(c, opcode, arg);

  0003a	44 8b 44 24 20	 mov	 r8d, DWORD PTR arg$[rsp]
  0003f	8b 54 24 48	 mov	 edx, DWORD PTR opcode$[rsp]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00048	e8 00 00 00 00	 call	 compiler_addop_i
$LN2@compiler_a@2:

; 1089 : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
compiler_addop_o ENDP
_TEXT	ENDS
PUBLIC	$T26397
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
EXTRN	PyComplex_AsCComplex:PROC
EXTRN	PyComplex_Type:BYTE
EXTRN	__imp__copysign:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyFloat_Type:BYTE
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_add_o DD imagerel compiler_add_o
	DD	imagerel compiler_add_o+1014
	DD	imagerel $unwind$compiler_add_o
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_add_o DD 041801H
	DD	0130118H
	DD	060107011H
xdata	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_add_o
_TEXT	SEGMENT
v$ = 48
arg$ = 56
d$ = 64
t$ = 72
z$22886 = 80
real_negzero$22887 = 96
imag_negzero$22888 = 100
$T26392 = 104
$T26397 = 120
tv137 = 136
tv143 = 140
c$ = 176
dict$ = 184
o$ = 192
compiler_add_o PROC					; COMDAT

; 1011 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1012 :     PyObject *t, *v;
; 1013 :     Py_ssize_t arg;
; 1014 :     double d;
; 1015 : 
; 1016 :     /* necessary to make sure types aren't coerced (e.g., float and complex) */
; 1017 :     /* _and_ to distinguish 0.0 from -0.0 e.g. on IEEE platforms */
; 1018 :     if (PyFloat_Check(o)) {

  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0001f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR o$[rsp]
  00027	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002b	74 20		 je	 SHORT $LN19@compiler_a@3
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00034	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR o$[rsp]
  0003c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00040	e8 00 00 00 00	 call	 PyType_IsSubtype
  00045	85 c0		 test	 eax, eax
  00047	0f 84 97 00 00
	00		 je	 $LN20@compiler_a@3
$LN19@compiler_a@3:

; 1019 :         d = PyFloat_AS_DOUBLE(o);

  0004d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR o$[rsp]
  00055	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  0005a	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR d$[rsp], xmm0

; 1020 :         /* all we need is to make the tuple different in either the 0.0
; 1021 :          * or -0.0 case from all others, just to avoid the "coercion".
; 1022 :          */
; 1023 :         if (d == 0.0 && copysign(1.0, d) < 0.0)

  00060	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR d$[rsp]
  00066	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0006e	7a 4c		 jp	 SHORT $LN18@compiler_a@3
  00070	75 4a		 jne	 SHORT $LN18@compiler_a@3
  00072	f2 0f 10 4c 24
	40		 movsdx	 xmm1, QWORD PTR d$[rsp]
  00078	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00086	66 0f 57 c9	 xorpd	 xmm1, xmm1
  0008a	66 0f 2f c8	 comisd	 xmm1, xmm0
  0008e	76 2c		 jbe	 SHORT $LN18@compiler_a@3

; 1024 :             t = PyTuple_Pack(3, o, o->ob_type, Py_None);

  00090	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00097	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR o$[rsp]
  0009f	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  000a3	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  000ab	b9 03 00 00 00	 mov	 ecx, 3
  000b0	e8 00 00 00 00	 call	 PyTuple_Pack
  000b5	48 89 44 24 48	 mov	 QWORD PTR t$[rsp], rax

; 1025 :         else

  000ba	eb 23		 jmp	 SHORT $LN17@compiler_a@3
$LN18@compiler_a@3:

; 1026 :             t = PyTuple_Pack(2, o, o->ob_type);

  000bc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR o$[rsp]
  000c4	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  000c8	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  000d0	b9 02 00 00 00	 mov	 ecx, 2
  000d5	e8 00 00 00 00	 call	 PyTuple_Pack
  000da	48 89 44 24 48	 mov	 QWORD PTR t$[rsp], rax
$LN17@compiler_a@3:

; 1027 :     }
; 1028 :     else if (PyComplex_Check(o)) {

  000df	e9 25 02 00 00	 jmp	 $LN16@compiler_a@3
$LN20@compiler_a@3:
  000e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyComplex_Type
  000eb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR o$[rsp]
  000f3	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f7	74 20		 je	 SHORT $LN14@compiler_a@3
  000f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyComplex_Type
  00100	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR o$[rsp]
  00108	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0010c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00111	85 c0		 test	 eax, eax
  00113	0f 84 cd 01 00
	00		 je	 $LN15@compiler_a@3
$LN14@compiler_a@3:

; 1029 :         Py_complex z;
; 1030 :         int real_negzero, imag_negzero;
; 1031 :         /* For the complex case we must make complex(x, 0.)
; 1032 :            different from complex(x, -0.) and complex(0., y)
; 1033 :            different from complex(-0., y), for any x and y.
; 1034 :            All four complex zeros must be distinguished.*/
; 1035 :         z = PyComplex_AsCComplex(o);

  00119	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  00121	48 8d 4c 24 68	 lea	 rcx, QWORD PTR $T26392[rsp]
  00126	e8 00 00 00 00	 call	 PyComplex_AsCComplex
  0012b	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T26397[rsp]
  00130	48 8b f9	 mov	 rdi, rcx
  00133	48 8b f0	 mov	 rsi, rax
  00136	b9 10 00 00 00	 mov	 ecx, 16
  0013b	f3 a4		 rep movsb
  0013d	48 8d 44 24 50	 lea	 rax, QWORD PTR z$22886[rsp]
  00142	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T26397[rsp]
  00147	48 8b f8	 mov	 rdi, rax
  0014a	48 8b f1	 mov	 rsi, rcx
  0014d	b9 10 00 00 00	 mov	 ecx, 16
  00152	f3 a4		 rep movsb

; 1036 :         real_negzero = z.real == 0.0 && copysign(1.0, z.real) < 0.0;

  00154	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR z$22886[rsp]
  0015a	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00162	7a 2d		 jp	 SHORT $LN23@compiler_a@3
  00164	75 2b		 jne	 SHORT $LN23@compiler_a@3
  00166	f2 0f 10 4c 24
	50		 movsdx	 xmm1, QWORD PTR z$22886[rsp]
  0016c	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  0017a	66 0f 57 c9	 xorpd	 xmm1, xmm1
  0017e	66 0f 2f c8	 comisd	 xmm1, xmm0
  00182	76 0d		 jbe	 SHORT $LN23@compiler_a@3
  00184	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv137[rsp], 1
  0018f	eb 0b		 jmp	 SHORT $LN24@compiler_a@3
$LN23@compiler_a@3:
  00191	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv137[rsp], 0
$LN24@compiler_a@3:
  0019c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv137[rsp]
  001a3	89 44 24 60	 mov	 DWORD PTR real_negzero$22887[rsp], eax

; 1037 :         imag_negzero = z.imag == 0.0 && copysign(1.0, z.imag) < 0.0;

  001a7	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR z$22886[rsp+8]
  001ad	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  001b5	7a 2d		 jp	 SHORT $LN25@compiler_a@3
  001b7	75 2b		 jne	 SHORT $LN25@compiler_a@3
  001b9	f2 0f 10 4c 24
	58		 movsdx	 xmm1, QWORD PTR z$22886[rsp+8]
  001bf	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  001cd	66 0f 57 c9	 xorpd	 xmm1, xmm1
  001d1	66 0f 2f c8	 comisd	 xmm1, xmm0
  001d5	76 0d		 jbe	 SHORT $LN25@compiler_a@3
  001d7	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv143[rsp], 1
  001e2	eb 0b		 jmp	 SHORT $LN26@compiler_a@3
$LN25@compiler_a@3:
  001e4	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv143[rsp], 0
$LN26@compiler_a@3:
  001ef	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv143[rsp]
  001f6	89 44 24 64	 mov	 DWORD PTR imag_negzero$22888[rsp], eax

; 1038 :         if (real_negzero && imag_negzero) {

  001fa	83 7c 24 60 00	 cmp	 DWORD PTR real_negzero$22887[rsp], 0
  001ff	74 4e		 je	 SHORT $LN13@compiler_a@3
  00201	83 7c 24 64 00	 cmp	 DWORD PTR imag_negzero$22888[rsp], 0
  00206	74 47		 je	 SHORT $LN13@compiler_a@3

; 1039 :             t = PyTuple_Pack(5, o, o->ob_type,
; 1040 :                              Py_None, Py_None, Py_None);

  00208	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0020f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00214	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0021b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00220	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00227	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR o$[rsp]
  0022f	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00233	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  0023b	b9 05 00 00 00	 mov	 ecx, 5
  00240	e8 00 00 00 00	 call	 PyTuple_Pack
  00245	48 89 44 24 48	 mov	 QWORD PTR t$[rsp], rax
  0024a	e9 95 00 00 00	 jmp	 $LN12@compiler_a@3
$LN13@compiler_a@3:

; 1041 :         }
; 1042 :         else if (imag_negzero) {

  0024f	83 7c 24 64 00	 cmp	 DWORD PTR imag_negzero$22888[rsp], 0
  00254	74 38		 je	 SHORT $LN11@compiler_a@3

; 1043 :             t = PyTuple_Pack(4, o, o->ob_type, Py_None, Py_None);

  00256	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0025d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00262	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00269	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR o$[rsp]
  00271	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00275	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  0027d	b9 04 00 00 00	 mov	 ecx, 4
  00282	e8 00 00 00 00	 call	 PyTuple_Pack
  00287	48 89 44 24 48	 mov	 QWORD PTR t$[rsp], rax
  0028c	eb 56		 jmp	 SHORT $LN10@compiler_a@3
$LN11@compiler_a@3:

; 1044 :         }
; 1045 :         else if (real_negzero) {

  0028e	83 7c 24 60 00	 cmp	 DWORD PTR real_negzero$22887[rsp], 0
  00293	74 2c		 je	 SHORT $LN9@compiler_a@3

; 1046 :             t = PyTuple_Pack(3, o, o->ob_type, Py_None);

  00295	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0029c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR o$[rsp]
  002a4	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  002a8	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  002b0	b9 03 00 00 00	 mov	 ecx, 3
  002b5	e8 00 00 00 00	 call	 PyTuple_Pack
  002ba	48 89 44 24 48	 mov	 QWORD PTR t$[rsp], rax

; 1047 :         }
; 1048 :         else {

  002bf	eb 23		 jmp	 SHORT $LN8@compiler_a@3
$LN9@compiler_a@3:

; 1049 :             t = PyTuple_Pack(2, o, o->ob_type);

  002c1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR o$[rsp]
  002c9	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  002cd	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  002d5	b9 02 00 00 00	 mov	 ecx, 2
  002da	e8 00 00 00 00	 call	 PyTuple_Pack
  002df	48 89 44 24 48	 mov	 QWORD PTR t$[rsp], rax
$LN8@compiler_a@3:
$LN10@compiler_a@3:
$LN12@compiler_a@3:

; 1050 :         }
; 1051 :     }
; 1052 :     else {

  002e4	eb 23		 jmp	 SHORT $LN7@compiler_a@3
$LN15@compiler_a@3:

; 1053 :         t = PyTuple_Pack(2, o, o->ob_type);

  002e6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR o$[rsp]
  002ee	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  002f2	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  002fa	b9 02 00 00 00	 mov	 ecx, 2
  002ff	e8 00 00 00 00	 call	 PyTuple_Pack
  00304	48 89 44 24 48	 mov	 QWORD PTR t$[rsp], rax
$LN7@compiler_a@3:
$LN16@compiler_a@3:

; 1054 :     }
; 1055 :     if (t == NULL)

  00309	48 83 7c 24 48
	00		 cmp	 QWORD PTR t$[rsp], 0
  0030f	75 0a		 jne	 SHORT $LN6@compiler_a@3

; 1056 :         return -1;

  00311	b8 ff ff ff ff	 mov	 eax, -1
  00316	e9 d1 00 00 00	 jmp	 $LN21@compiler_a@3
$LN6@compiler_a@3:

; 1057 : 
; 1058 :     v = PyDict_GetItem(dict, t);

  0031b	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00320	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR dict$[rsp]
  00328	e8 00 00 00 00	 call	 PyDict_GetItem
  0032d	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax

; 1059 :     if (!v) {

  00332	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  00338	0f 85 8f 00 00
	00		 jne	 $LN5@compiler_a@3

; 1060 :         if (PyErr_Occurred())

  0033e	e8 00 00 00 00	 call	 PyErr_Occurred
  00343	48 85 c0	 test	 rax, rax
  00346	74 0a		 je	 SHORT $LN4@compiler_a@3

; 1061 :             return -1;

  00348	b8 ff ff ff ff	 mov	 eax, -1
  0034d	e9 9a 00 00 00	 jmp	 $LN21@compiler_a@3
$LN4@compiler_a@3:

; 1062 :         arg = PyDict_Size(dict);

  00352	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR dict$[rsp]
  0035a	e8 00 00 00 00	 call	 PyDict_Size
  0035f	48 89 44 24 38	 mov	 QWORD PTR arg$[rsp], rax

; 1063 :         v = PyLong_FromLong(arg);

  00364	8b 4c 24 38	 mov	 ecx, DWORD PTR arg$[rsp]
  00368	e8 00 00 00 00	 call	 PyLong_FromLong
  0036d	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax

; 1064 :         if (!v) {

  00372	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  00378	75 11		 jne	 SHORT $LN3@compiler_a@3

; 1065 :             Py_DECREF(t);

  0037a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR t$[rsp]
  0037f	e8 00 00 00 00	 call	 _Py_DecRef

; 1066 :             return -1;

  00384	b8 ff ff ff ff	 mov	 eax, -1
  00389	eb 61		 jmp	 SHORT $LN21@compiler_a@3
$LN3@compiler_a@3:

; 1067 :         }
; 1068 :         if (PyDict_SetItem(dict, t, v) < 0) {

  0038b	4c 8b 44 24 30	 mov	 r8, QWORD PTR v$[rsp]
  00390	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00395	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR dict$[rsp]
  0039d	e8 00 00 00 00	 call	 PyDict_SetItem
  003a2	85 c0		 test	 eax, eax
  003a4	7d 1b		 jge	 SHORT $LN2@compiler_a@3

; 1069 :             Py_DECREF(t);

  003a6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR t$[rsp]
  003ab	e8 00 00 00 00	 call	 _Py_DecRef

; 1070 :             Py_DECREF(v);

  003b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  003b5	e8 00 00 00 00	 call	 _Py_DecRef

; 1071 :             return -1;

  003ba	b8 ff ff ff ff	 mov	 eax, -1
  003bf	eb 2b		 jmp	 SHORT $LN21@compiler_a@3
$LN2@compiler_a@3:

; 1072 :         }
; 1073 :         Py_DECREF(v);

  003c1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  003c6	e8 00 00 00 00	 call	 _Py_DecRef

; 1074 :     }
; 1075 :     else

  003cb	eb 11		 jmp	 SHORT $LN1@compiler_a@3
$LN5@compiler_a@3:

; 1076 :         arg = PyLong_AsLong(v);

  003cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  003d2	e8 00 00 00 00	 call	 PyLong_AsLong
  003d7	48 98		 cdqe
  003d9	48 89 44 24 38	 mov	 QWORD PTR arg$[rsp], rax
$LN1@compiler_a@3:

; 1077 :     Py_DECREF(t);

  003de	48 8b 4c 24 48	 mov	 rcx, QWORD PTR t$[rsp]
  003e3	e8 00 00 00 00	 call	 _Py_DecRef

; 1078 :     return arg;

  003e8	8b 44 24 38	 mov	 eax, DWORD PTR arg$[rsp]
$LN21@compiler_a@3:

; 1079 : }

  003ec	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  003f3	5f		 pop	 rdi
  003f4	5e		 pop	 rsi
  003f5	c3		 ret	 0
compiler_add_o ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_addop_i DD imagerel compiler_addop_i
	DD	imagerel compiler_addop_i+156
	DD	imagerel $unwind$compiler_addop_i
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_addop_i DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_addop_i
_TEXT	SEGMENT
i$ = 32
off$ = 40
c$ = 64
opcode$ = 72
oparg$ = 80
compiler_addop_i PROC					; COMDAT

; 1112 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1113 :     struct instr *i;
; 1114 :     int off;
; 1115 :     off = compiler_next_instr(c, c->u->u_curblock);

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00017	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0001b	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00024	e8 00 00 00 00	 call	 compiler_next_instr
  00029	89 44 24 28	 mov	 DWORD PTR off$[rsp], eax

; 1116 :     if (off < 0)

  0002d	83 7c 24 28 00	 cmp	 DWORD PTR off$[rsp], 0
  00032	7d 04		 jge	 SHORT $LN1@compiler_a@4

; 1117 :         return 0;

  00034	33 c0		 xor	 eax, eax
  00036	eb 5f		 jmp	 SHORT $LN2@compiler_a@4
$LN1@compiler_a@4:

; 1118 :     i = &c->u->u_curblock->b_instr[off];

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0003d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00041	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00045	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR off$[rsp]
  0004a	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  0004e	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  00052	48 8b c1	 mov	 rax, rcx
  00055	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 1119 :     i->i_opcode = opcode;

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0005f	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR opcode$[rsp]
  00064	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1120 :     i->i_oparg = oparg;

  00067	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0006c	8b 4c 24 50	 mov	 ecx, DWORD PTR oparg$[rsp]
  00070	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 1121 :     i->i_hasarg = 1;

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00078	8b 00		 mov	 eax, DWORD PTR [rax]
  0007a	83 c8 04	 or	 eax, 4
  0007d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00082	89 01		 mov	 DWORD PTR [rcx], eax

; 1122 :     compiler_set_lineno(c, off);

  00084	8b 54 24 28	 mov	 edx, DWORD PTR off$[rsp]
  00088	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0008d	e8 00 00 00 00	 call	 compiler_set_lineno

; 1123 :     return 1;

  00092	b8 01 00 00 00	 mov	 eax, 1
$LN2@compiler_a@4:

; 1124 : }

  00097	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009b	c3		 ret	 0
compiler_addop_i ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FM@KFLBHJIC@?$AA?$CI?$AAn?$AAu?$AAm?$AA_?$AAa?$AAn?$AAn?$AAo?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AAF?$AAF?$AAF?$AAF?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAu@ ; `string'
PUBLIC	??_C@_1DI@JFGKABCA@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAe?$AAf?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_function DD imagerel compiler_function
	DD	imagerel compiler_function+1437
	DD	imagerel $unwind$compiler_function
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_function DD 021101H
	DD	01d0111H
xdata	ENDS
;	COMDAT ??_C@_1FM@KFLBHJIC@?$AA?$CI?$AAn?$AAu?$AAm?$AA_?$AAa?$AAn?$AAn?$AAo?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AAF?$AAF?$AAF?$AAF?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAu@
CONST	SEGMENT
??_C@_1FM@KFLBHJIC@?$AA?$CI?$AAn?$AAu?$AAm?$AA_?$AAa?$AAn?$AAn?$AAo?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AAF?$AAF?$AAF?$AAF?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAu@ DB '('
	DB	00H, 'n', 00H, 'u', 00H, 'm', 00H, '_', 00H, 'a', 00H, 'n', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, ' ', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	'x', 00H, 'F', 00H, 'F', 00H, 'F', 00H, 'F', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'n', 00H, 'u', 00H, 'm', 00H
	DB	'_', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@JFGKABCA@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAe?$AAf?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@JFGKABCA@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAe?$AAf?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 's'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'F', 00H, 'u', 00H, 'n'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'D', 00H
	DB	'e', 00H, 'f', 00H, '_', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_function
_TEXT	SEGMENT
args$ = 48
kw_default_count$ = 56
n$ = 60
i$ = 64
decos$ = 72
arglength$ = 80
st$ = 88
returns$ = 96
num_annotations$ = 104
co$ = 112
qualname$ = 120
first_const$ = 128
docstring$ = 136
res$23237 = 140
_i$23240 = 144
seq$23241 = 152
elt$23246 = 160
tv91 = 168
tv175 = 176
tv183 = 184
tv189 = 192
tv221 = 200
tv236 = 208
c$ = 240
s$ = 248
compiler_function PROC					; COMDAT

; 1557 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 1558 :     PyCodeObject *co;
; 1559 :     PyObject *qualname, *first_const = Py_None;

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00018	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR first_const$[rsp], rax

; 1560 :     arguments_ty args = s->v.FunctionDef.args;

  00020	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	48 89 44 24 30	 mov	 QWORD PTR args$[rsp], rax

; 1561 :     expr_ty returns = s->v.FunctionDef.returns;

  00031	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00039	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003d	48 89 44 24 60	 mov	 QWORD PTR returns$[rsp], rax

; 1562 :     asdl_seq* decos = s->v.FunctionDef.decorator_list;

  00042	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0004a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004e	48 89 44 24 48	 mov	 QWORD PTR decos$[rsp], rax

; 1563 :     stmt_ty st;
; 1564 :     int i, n, docstring, kw_default_count = 0, arglength;

  00053	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR kw_default_count$[rsp], 0

; 1565 :     int num_annotations;
; 1566 : 
; 1567 :     assert(s->kind == FunctionDef_kind);

  0005b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00063	83 38 01	 cmp	 DWORD PTR [rax], 1
  00066	74 1c		 je	 SHORT $LN33@compiler_f@2
  00068	41 b8 1f 06 00
	00		 mov	 r8d, 1567		; 0000061fH
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@JFGKABCA@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAe?$AAf?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00082	33 c0		 xor	 eax, eax
$LN33@compiler_f@2:

; 1568 : 
; 1569 :     if (!compiler_decorators(c, decos))

  00084	48 8b 54 24 48	 mov	 rdx, QWORD PTR decos$[rsp]
  00089	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00091	e8 00 00 00 00	 call	 compiler_decorators
  00096	85 c0		 test	 eax, eax
  00098	75 07		 jne	 SHORT $LN30@compiler_f@2

; 1570 :         return 0;

  0009a	33 c0		 xor	 eax, eax
  0009c	e9 f4 04 00 00	 jmp	 $LN31@compiler_f@2
$LN30@compiler_f@2:

; 1571 :     if (args->kwonlyargs) {

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  000a6	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000ab	74 42		 je	 SHORT $LN29@compiler_f@2

; 1572 :         int res = compiler_visit_kwonlydefaults(c, args->kwonlyargs,
; 1573 :                                                 args->kw_defaults);

  000ad	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  000b2	4c 8b 40 38	 mov	 r8, QWORD PTR [rax+56]
  000b6	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  000bb	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  000bf	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000c7	e8 00 00 00 00	 call	 compiler_visit_kwonlydefaults
  000cc	89 84 24 8c 00
	00 00		 mov	 DWORD PTR res$23237[rsp], eax

; 1574 :         if (res < 0)

  000d3	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR res$23237[rsp], 0
  000db	7d 07		 jge	 SHORT $LN28@compiler_f@2

; 1575 :             return 0;

  000dd	33 c0		 xor	 eax, eax
  000df	e9 b1 04 00 00	 jmp	 $LN31@compiler_f@2
$LN28@compiler_f@2:

; 1576 :         kw_default_count = res;

  000e4	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR res$23237[rsp]
  000eb	89 44 24 38	 mov	 DWORD PTR kw_default_count$[rsp], eax
$LN29@compiler_f@2:

; 1577 :     }
; 1578 :     if (args->defaults)

  000ef	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  000f4	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000f9	0f 84 ae 00 00
	00		 je	 $LN27@compiler_f@2

; 1579 :         VISIT_SEQ(c, expr, args->defaults);

  000ff	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  00104	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00108	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR seq$23241[rsp], rax
  00110	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _i$23240[rsp], 0
  0011b	eb 10		 jmp	 SHORT $LN26@compiler_f@2
$LN25@compiler_f@2:
  0011d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _i$23240[rsp]
  00124	ff c0		 inc	 eax
  00126	89 84 24 90 00
	00 00		 mov	 DWORD PTR _i$23240[rsp], eax
$LN26@compiler_f@2:
  0012d	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR seq$23241[rsp], 0
  00136	75 0e		 jne	 SHORT $LN34@compiler_f@2
  00138	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv91[rsp], 0
  00144	eb 13		 jmp	 SHORT $LN35@compiler_f@2
$LN34@compiler_f@2:
  00146	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR seq$23241[rsp]
  0014e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00151	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv91[rsp], rax
$LN35@compiler_f@2:
  00159	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR _i$23240[rsp]
  00161	48 3b 84 24 a8
	00 00 00	 cmp	 rax, QWORD PTR tv91[rsp]
  00169	7d 42		 jge	 SHORT $LN24@compiler_f@2
  0016b	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR _i$23240[rsp]
  00173	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR seq$23241[rsp]
  0017b	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00180	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR elt$23246[rsp], rax
  00188	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR elt$23246[rsp]
  00190	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00198	e8 00 00 00 00	 call	 compiler_visit_expr
  0019d	85 c0		 test	 eax, eax
  0019f	75 07		 jne	 SHORT $LN23@compiler_f@2
  001a1	33 c0		 xor	 eax, eax
  001a3	e9 ed 03 00 00	 jmp	 $LN31@compiler_f@2
$LN23@compiler_f@2:
  001a8	e9 70 ff ff ff	 jmp	 $LN25@compiler_f@2
$LN24@compiler_f@2:
$LN27@compiler_f@2:

; 1580 :     num_annotations = compiler_visit_annotations(c, args, returns);

  001ad	4c 8b 44 24 60	 mov	 r8, QWORD PTR returns$[rsp]
  001b2	48 8b 54 24 30	 mov	 rdx, QWORD PTR args$[rsp]
  001b7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001bf	e8 00 00 00 00	 call	 compiler_visit_annotations
  001c4	89 44 24 68	 mov	 DWORD PTR num_annotations$[rsp], eax

; 1581 :     if (num_annotations < 0)

  001c8	83 7c 24 68 00	 cmp	 DWORD PTR num_annotations$[rsp], 0
  001cd	7d 07		 jge	 SHORT $LN22@compiler_f@2

; 1582 :         return 0;

  001cf	33 c0		 xor	 eax, eax
  001d1	e9 bf 03 00 00	 jmp	 $LN31@compiler_f@2
$LN22@compiler_f@2:

; 1583 :     assert((num_annotations & 0xFFFF) == num_annotations);

  001d6	8b 44 24 68	 mov	 eax, DWORD PTR num_annotations$[rsp]
  001da	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001df	3b 44 24 68	 cmp	 eax, DWORD PTR num_annotations$[rsp]
  001e3	74 1c		 je	 SHORT $LN36@compiler_f@2
  001e5	41 b8 2f 06 00
	00		 mov	 r8d, 1583		; 0000062fH
  001eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@KFLBHJIC@?$AA?$CI?$AAn?$AAu?$AAm?$AA_?$AAa?$AAn?$AAn?$AAo?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AAF?$AAF?$AAF?$AAF?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAu@
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001ff	33 c0		 xor	 eax, eax
$LN36@compiler_f@2:

; 1584 : 
; 1585 :     if (!compiler_enter_scope(c, s->v.FunctionDef.name,
; 1586 :                               COMPILER_SCOPE_FUNCTION, (void *)s,
; 1587 :                               s->lineno))

  00201	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00209	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0020c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00210	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR s$[rsp]
  00218	41 b8 02 00 00
	00		 mov	 r8d, 2
  0021e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00226	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0022a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00232	e8 00 00 00 00	 call	 compiler_enter_scope
  00237	85 c0		 test	 eax, eax
  00239	75 07		 jne	 SHORT $LN21@compiler_f@2

; 1588 :         return 0;

  0023b	33 c0		 xor	 eax, eax
  0023d	e9 53 03 00 00	 jmp	 $LN31@compiler_f@2
$LN21@compiler_f@2:

; 1589 : 
; 1590 :     st = (stmt_ty)asdl_seq_GET(s->v.FunctionDef.body, 0);

  00242	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0024a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0024e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00252	48 89 44 24 58	 mov	 QWORD PTR st$[rsp], rax

; 1591 :     docstring = compiler_isdocstring(st);

  00257	48 8b 4c 24 58	 mov	 rcx, QWORD PTR st$[rsp]
  0025c	e8 00 00 00 00	 call	 compiler_isdocstring
  00261	89 84 24 88 00
	00 00		 mov	 DWORD PTR docstring$[rsp], eax

; 1592 :     if (docstring && c->c_optimize < 2)

  00268	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR docstring$[rsp], 0
  00270	74 23		 je	 SHORT $LN20@compiler_f@2
  00272	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0027a	83 78 28 02	 cmp	 DWORD PTR [rax+40], 2
  0027e	7d 15		 jge	 SHORT $LN20@compiler_f@2

; 1593 :         first_const = st->v.Expr.value->v.Str.s;

  00280	48 8b 44 24 58	 mov	 rax, QWORD PTR st$[rsp]
  00285	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00289	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0028d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR first_const$[rsp], rax
$LN20@compiler_f@2:

; 1594 :     if (compiler_add_o(c, c->u->u_consts, first_const) < 0)      {

  00295	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0029d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  002a1	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR first_const$[rsp]
  002a9	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  002ad	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002b5	e8 00 00 00 00	 call	 compiler_add_o
  002ba	85 c0		 test	 eax, eax
  002bc	7d 14		 jge	 SHORT $LN19@compiler_f@2

; 1595 :         compiler_exit_scope(c);

  002be	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002c6	e8 00 00 00 00	 call	 compiler_exit_scope

; 1596 :         return 0;

  002cb	33 c0		 xor	 eax, eax
  002cd	e9 c3 02 00 00	 jmp	 $LN31@compiler_f@2
$LN19@compiler_f@2:

; 1597 :     }
; 1598 : 
; 1599 :     c->u->u_argcount = asdl_seq_LEN(args->args);

  002d2	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  002d7	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  002db	75 0e		 jne	 SHORT $LN37@compiler_f@2
  002dd	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv175[rsp], 0
  002e9	eb 13		 jmp	 SHORT $LN38@compiler_f@2
$LN37@compiler_f@2:
  002eb	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  002f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002f3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002f6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv175[rsp], rax
$LN38@compiler_f@2:
  002fe	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00306	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0030a	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv175[rsp]
  00311	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 1600 :     c->u->u_kwonlyargcount = asdl_seq_LEN(args->kwonlyargs);

  00314	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  00319	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0031e	75 0e		 jne	 SHORT $LN39@compiler_f@2
  00320	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv183[rsp], 0
  0032c	eb 14		 jmp	 SHORT $LN40@compiler_f@2
$LN39@compiler_f@2:
  0032e	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  00333	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00337	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0033a	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv183[rsp], rax
$LN40@compiler_f@2:
  00342	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0034a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0034e	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv183[rsp]
  00355	89 48 54	 mov	 DWORD PTR [rax+84], ecx

; 1601 :     n = asdl_seq_LEN(s->v.FunctionDef.body);

  00358	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00360	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00365	75 0e		 jne	 SHORT $LN41@compiler_f@2
  00367	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv189[rsp], 0
  00373	eb 17		 jmp	 SHORT $LN42@compiler_f@2
$LN41@compiler_f@2:
  00375	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0037d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00381	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00384	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv189[rsp], rax
$LN42@compiler_f@2:
  0038c	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv189[rsp]
  00393	89 44 24 3c	 mov	 DWORD PTR n$[rsp], eax

; 1602 :     /* if there was a docstring, we need to skip the first statement */
; 1603 :     for (i = docstring; i < n; i++) {

  00397	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR docstring$[rsp]
  0039e	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  003a2	eb 0a		 jmp	 SHORT $LN18@compiler_f@2
$LN17@compiler_f@2:
  003a4	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  003a8	ff c0		 inc	 eax
  003aa	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN18@compiler_f@2:
  003ae	8b 44 24 3c	 mov	 eax, DWORD PTR n$[rsp]
  003b2	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  003b6	7d 47		 jge	 SHORT $LN16@compiler_f@2

; 1604 :         st = (stmt_ty)asdl_seq_GET(s->v.FunctionDef.body, i);

  003b8	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003c0	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  003c4	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  003c9	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  003ce	48 89 44 24 58	 mov	 QWORD PTR st$[rsp], rax

; 1605 :         VISIT_IN_SCOPE(c, stmt, st);

  003d3	48 8b 54 24 58	 mov	 rdx, QWORD PTR st$[rsp]
  003d8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003e0	e8 00 00 00 00	 call	 compiler_visit_stmt
  003e5	85 c0		 test	 eax, eax
  003e7	75 14		 jne	 SHORT $LN15@compiler_f@2
  003e9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003f1	e8 00 00 00 00	 call	 compiler_exit_scope
  003f6	33 c0		 xor	 eax, eax
  003f8	e9 98 01 00 00	 jmp	 $LN31@compiler_f@2
$LN15@compiler_f@2:

; 1606 :     }

  003fd	eb a5		 jmp	 SHORT $LN17@compiler_f@2
$LN16@compiler_f@2:

; 1607 :     co = assemble(c, 1);

  003ff	ba 01 00 00 00	 mov	 edx, 1
  00404	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0040c	e8 00 00 00 00	 call	 assemble
  00411	48 89 44 24 70	 mov	 QWORD PTR co$[rsp], rax

; 1608 :     qualname = compiler_scope_qualname(c);

  00416	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0041e	e8 00 00 00 00	 call	 compiler_scope_qualname
  00423	48 89 44 24 78	 mov	 QWORD PTR qualname$[rsp], rax

; 1609 :     compiler_exit_scope(c);

  00428	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00430	e8 00 00 00 00	 call	 compiler_exit_scope

; 1610 :     if (qualname == NULL || co == NULL) {

  00435	48 83 7c 24 78
	00		 cmp	 QWORD PTR qualname$[rsp], 0
  0043b	74 08		 je	 SHORT $LN13@compiler_f@2
  0043d	48 83 7c 24 70
	00		 cmp	 QWORD PTR co$[rsp], 0
  00443	75 37		 jne	 SHORT $LN14@compiler_f@2
$LN13@compiler_f@2:
$LN12@compiler_f@2:

; 1611 :         Py_XDECREF(qualname);

  00445	48 83 7c 24 78
	00		 cmp	 QWORD PTR qualname$[rsp], 0
  0044b	74 0a		 je	 SHORT $LN9@compiler_f@2
  0044d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR qualname$[rsp]
  00452	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@compiler_f@2:
  00457	33 c0		 xor	 eax, eax
  00459	85 c0		 test	 eax, eax
  0045b	75 e8		 jne	 SHORT $LN12@compiler_f@2
$LN8@compiler_f@2:

; 1612 :         Py_XDECREF(co);

  0045d	48 83 7c 24 70
	00		 cmp	 QWORD PTR co$[rsp], 0
  00463	74 0a		 je	 SHORT $LN5@compiler_f@2
  00465	48 8b 4c 24 70	 mov	 rcx, QWORD PTR co$[rsp]
  0046a	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@compiler_f@2:
  0046f	33 c0		 xor	 eax, eax
  00471	85 c0		 test	 eax, eax
  00473	75 e8		 jne	 SHORT $LN8@compiler_f@2

; 1613 :         return 0;

  00475	33 c0		 xor	 eax, eax
  00477	e9 19 01 00 00	 jmp	 $LN31@compiler_f@2
$LN14@compiler_f@2:

; 1614 :     }
; 1615 : 
; 1616 :     arglength = asdl_seq_LEN(args->defaults);

  0047c	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  00481	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00486	75 0e		 jne	 SHORT $LN43@compiler_f@2
  00488	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv221[rsp], 0
  00494	eb 14		 jmp	 SHORT $LN44@compiler_f@2
$LN43@compiler_f@2:
  00496	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  0049b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0049f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004a2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv221[rsp], rax
$LN44@compiler_f@2:
  004aa	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv221[rsp]
  004b1	89 44 24 50	 mov	 DWORD PTR arglength$[rsp], eax

; 1617 :     arglength |= kw_default_count << 8;

  004b5	8b 44 24 38	 mov	 eax, DWORD PTR kw_default_count$[rsp]
  004b9	c1 e0 08	 shl	 eax, 8
  004bc	8b 4c 24 50	 mov	 ecx, DWORD PTR arglength$[rsp]
  004c0	0b c8		 or	 ecx, eax
  004c2	8b c1		 mov	 eax, ecx
  004c4	89 44 24 50	 mov	 DWORD PTR arglength$[rsp], eax

; 1618 :     arglength |= num_annotations << 16;

  004c8	8b 44 24 68	 mov	 eax, DWORD PTR num_annotations$[rsp]
  004cc	c1 e0 10	 shl	 eax, 16
  004cf	8b 4c 24 50	 mov	 ecx, DWORD PTR arglength$[rsp]
  004d3	0b c8		 or	 ecx, eax
  004d5	8b c1		 mov	 eax, ecx
  004d7	89 44 24 50	 mov	 DWORD PTR arglength$[rsp], eax

; 1619 :     compiler_make_closure(c, co, arglength, qualname);

  004db	4c 8b 4c 24 78	 mov	 r9, QWORD PTR qualname$[rsp]
  004e0	44 8b 44 24 50	 mov	 r8d, DWORD PTR arglength$[rsp]
  004e5	48 8b 54 24 70	 mov	 rdx, QWORD PTR co$[rsp]
  004ea	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  004f2	e8 00 00 00 00	 call	 compiler_make_closure

; 1620 :     Py_DECREF(qualname);

  004f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR qualname$[rsp]
  004fc	e8 00 00 00 00	 call	 _Py_DecRef

; 1621 :     Py_DECREF(co);

  00501	48 8b 4c 24 70	 mov	 rcx, QWORD PTR co$[rsp]
  00506	e8 00 00 00 00	 call	 _Py_DecRef

; 1622 : 
; 1623 :     /* decorators */
; 1624 :     for (i = 0; i < asdl_seq_LEN(decos); i++) {

  0050b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00513	eb 0a		 jmp	 SHORT $LN4@compiler_f@2
$LN3@compiler_f@2:
  00515	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00519	ff c0		 inc	 eax
  0051b	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@compiler_f@2:
  0051f	48 83 7c 24 48
	00		 cmp	 QWORD PTR decos$[rsp], 0
  00525	75 0e		 jne	 SHORT $LN45@compiler_f@2
  00527	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv236[rsp], 0
  00533	eb 10		 jmp	 SHORT $LN46@compiler_f@2
$LN45@compiler_f@2:
  00535	48 8b 44 24 48	 mov	 rax, QWORD PTR decos$[rsp]
  0053a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0053d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv236[rsp], rax
$LN46@compiler_f@2:
  00545	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0054a	48 3b 84 24 d0
	00 00 00	 cmp	 rax, QWORD PTR tv236[rsp]
  00552	7d 22		 jge	 SHORT $LN2@compiler_f@2

; 1625 :         ADDOP_I(c, CALL_FUNCTION, 1);

  00554	41 b8 01 00 00
	00		 mov	 r8d, 1
  0055a	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  0055f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00567	e8 00 00 00 00	 call	 compiler_addop_i
  0056c	85 c0		 test	 eax, eax
  0056e	75 04		 jne	 SHORT $LN1@compiler_f@2
  00570	33 c0		 xor	 eax, eax
  00572	eb 21		 jmp	 SHORT $LN31@compiler_f@2
$LN1@compiler_f@2:

; 1626 :     }

  00574	eb 9f		 jmp	 SHORT $LN3@compiler_f@2
$LN2@compiler_f@2:

; 1627 : 
; 1628 :     return compiler_nameop(c, s->v.FunctionDef.name, Store);

  00576	41 b8 02 00 00
	00		 mov	 r8d, 2
  0057c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00584	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00588	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00590	e8 00 00 00 00	 call	 compiler_nameop
$LN31@compiler_f@2:

; 1629 : }

  00595	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0059c	c3		 ret	 0
compiler_function ENDP
_TEXT	ENDS
PUBLIC	??_C@_13ICFKHAEN@?$AAu?$AA?$AA@			; `string'
EXTRN	PyUnicode_Join:PROC
EXTRN	_PyUnicode_FromId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_scope_qualname DD imagerel compiler_scope_qualname
	DD	imagerel compiler_scope_qualname+560
	DD	imagerel $unwind$compiler_scope_qualname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_scope_qualname DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_13ICFKHAEN@?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_13ICFKHAEN@?$AAu?$AA?$AA@ DB 'u', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_scope_qualname
_TEXT	SEGMENT
locals_str$ = 32
i$ = 40
u$ = 48
dot_str$ = 56
name$ = 64
capsule$ = 72
seq$ = 80
stack_size$ = 88
c$ = 112
compiler_scope_qualname PROC				; COMDAT

; 612  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 613  :     Py_ssize_t stack_size, i;
; 614  :     _Py_static_string(dot, ".");
; 615  :     _Py_static_string(locals, "<locals>");
; 616  :     struct compiler_unit *u;
; 617  :     PyObject *capsule, *name, *seq, *dot_str, *locals_str;
; 618  : 
; 619  :     u = c->u;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0000e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00012	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax

; 620  :     if (u->u_qualname != NULL) {

  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  0001c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00021	74 1c		 je	 SHORT $LN20@compiler_s@2

; 621  :         Py_INCREF(u->u_qualname);

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  00028	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0002c	e8 00 00 00 00	 call	 _Py_IncRef

; 622  :         return u->u_qualname;

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  00036	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003a	e9 ec 01 00 00	 jmp	 $LN21@compiler_s@2
$LN20@compiler_s@2:

; 623  :     }
; 624  : 
; 625  :     seq = PyList_New(0);

  0003f	33 c9		 xor	 ecx, ecx
  00041	e8 00 00 00 00	 call	 PyList_New
  00046	48 89 44 24 50	 mov	 QWORD PTR seq$[rsp], rax

; 626  :     if (seq == NULL)

  0004b	48 83 7c 24 50
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00051	75 07		 jne	 SHORT $LN19@compiler_s@2

; 627  :         return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	e9 d1 01 00 00	 jmp	 $LN21@compiler_s@2
$LN19@compiler_s@2:

; 628  : 
; 629  :     stack_size = PyList_GET_SIZE(c->c_stack);

  0005a	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0005f	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00063	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00067	48 89 44 24 58	 mov	 QWORD PTR stack_size$[rsp], rax

; 630  :     for (i = 0; i < stack_size; i++) {

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00075	eb 0d		 jmp	 SHORT $LN18@compiler_s@2
$LN17@compiler_s@2:
  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0007c	48 ff c0	 inc	 rax
  0007f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN18@compiler_s@2:
  00084	48 8b 44 24 58	 mov	 rax, QWORD PTR stack_size$[rsp]
  00089	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0008e	0f 8d da 00 00
	00		 jge	 $LN16@compiler_s@2

; 631  :         capsule = PyList_GET_ITEM(c->c_stack, i);

  00094	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00099	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0009d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000a6	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000aa	48 89 44 24 48	 mov	 QWORD PTR capsule$[rsp], rax

; 632  :         u = (struct compiler_unit *)PyCapsule_GetPointer(capsule, COMPILER_CAPSULE_NAME_COMPILER_UNIT);

  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@
  000b6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR capsule$[rsp]
  000bb	e8 00 00 00 00	 call	 PyCapsule_GetPointer
  000c0	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax

; 633  :         assert(u);

  000c5	48 83 7c 24 30
	00		 cmp	 QWORD PTR u$[rsp], 0
  000cb	75 1c		 jne	 SHORT $LN23@compiler_s@2
  000cd	41 b8 79 02 00
	00		 mov	 r8d, 633		; 00000279H
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13ICFKHAEN@?$AAu?$AA?$AA@
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e7	33 c0		 xor	 eax, eax
$LN23@compiler_s@2:

; 634  :         if (u->u_scope_type == COMPILER_SCOPE_MODULE)

  000e9	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  000ee	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000f2	75 02		 jne	 SHORT $LN15@compiler_s@2

; 635  :             continue;

  000f4	eb 81		 jmp	 SHORT $LN17@compiler_s@2
$LN15@compiler_s@2:

; 636  :         if (PyList_Append(seq, u->u_name))

  000f6	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  000fb	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq$[rsp]
  00104	e8 00 00 00 00	 call	 PyList_Append
  00109	85 c0		 test	 eax, eax
  0010b	74 05		 je	 SHORT $LN14@compiler_s@2

; 637  :             goto _error;

  0010d	e9 ff 00 00 00	 jmp	 $_error$22676
$LN14@compiler_s@2:

; 638  :         if (u->u_scope_type == COMPILER_SCOPE_FUNCTION) {

  00112	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  00117	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  0011b	75 4c		 jne	 SHORT $LN13@compiler_s@2

; 639  :             locals_str = _PyUnicode_FromId(&locals);

  0011d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?locals@?1??compiler_scope_qualname@@9@9
  00122	8b c0		 mov	 eax, eax
  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0012a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00133	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00137	48 8b c8	 mov	 rcx, rax
  0013a	e8 00 00 00 00	 call	 _PyUnicode_FromId
  0013f	48 89 44 24 20	 mov	 QWORD PTR locals_str$[rsp], rax

; 640  :             if (locals_str == NULL)

  00144	48 83 7c 24 20
	00		 cmp	 QWORD PTR locals_str$[rsp], 0
  0014a	75 05		 jne	 SHORT $LN12@compiler_s@2

; 641  :                 goto _error;

  0014c	e9 c0 00 00 00	 jmp	 $_error$22676
$LN12@compiler_s@2:

; 642  :             if (PyList_Append(seq, locals_str))

  00151	48 8b 54 24 20	 mov	 rdx, QWORD PTR locals_str$[rsp]
  00156	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq$[rsp]
  0015b	e8 00 00 00 00	 call	 PyList_Append
  00160	85 c0		 test	 eax, eax
  00162	74 05		 je	 SHORT $LN11@compiler_s@2

; 643  :                 goto _error;

  00164	e9 a8 00 00 00	 jmp	 $_error$22676
$LN11@compiler_s@2:
$LN13@compiler_s@2:

; 644  :         }
; 645  :     }

  00169	e9 09 ff ff ff	 jmp	 $LN17@compiler_s@2
$LN16@compiler_s@2:

; 646  :     u = c->u;

  0016e	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00173	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00177	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax

; 647  :     if (PyList_Append(seq, u->u_name))

  0017c	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  00181	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00185	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq$[rsp]
  0018a	e8 00 00 00 00	 call	 PyList_Append
  0018f	85 c0		 test	 eax, eax
  00191	74 02		 je	 SHORT $LN10@compiler_s@2

; 648  :         goto _error;

  00193	eb 7c		 jmp	 SHORT $_error$22676
$LN10@compiler_s@2:

; 649  :     dot_str = _PyUnicode_FromId(&dot);

  00195	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?dot@?1??compiler_scope_qualname@@9@9
  0019a	8b c0		 mov	 eax, eax
  0019c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001a2	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001ab	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  001af	48 8b c8	 mov	 rcx, rax
  001b2	e8 00 00 00 00	 call	 _PyUnicode_FromId
  001b7	48 89 44 24 38	 mov	 QWORD PTR dot_str$[rsp], rax

; 650  :     if (dot_str == NULL)

  001bc	48 83 7c 24 38
	00		 cmp	 QWORD PTR dot_str$[rsp], 0
  001c2	75 02		 jne	 SHORT $LN9@compiler_s@2

; 651  :         goto _error;

  001c4	eb 4b		 jmp	 SHORT $_error$22676
$LN9@compiler_s@2:

; 652  :     name = PyUnicode_Join(dot_str, seq);

  001c6	48 8b 54 24 50	 mov	 rdx, QWORD PTR seq$[rsp]
  001cb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dot_str$[rsp]
  001d0	e8 00 00 00 00	 call	 PyUnicode_Join
  001d5	48 89 44 24 40	 mov	 QWORD PTR name$[rsp], rax

; 653  :     Py_DECREF(seq);

  001da	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq$[rsp]
  001df	e8 00 00 00 00	 call	 _Py_DecRef

; 654  :     u->u_qualname = name;

  001e4	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  001e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name$[rsp]
  001ee	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN8@compiler_s@2:

; 655  :     Py_XINCREF(name);

  001f2	48 83 7c 24 40
	00		 cmp	 QWORD PTR name$[rsp], 0
  001f8	74 0a		 je	 SHORT $LN5@compiler_s@2
  001fa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name$[rsp]
  001ff	e8 00 00 00 00	 call	 _Py_IncRef
$LN5@compiler_s@2:
  00204	33 c0		 xor	 eax, eax
  00206	85 c0		 test	 eax, eax
  00208	75 e8		 jne	 SHORT $LN8@compiler_s@2

; 656  :     return name;

  0020a	48 8b 44 24 40	 mov	 rax, QWORD PTR name$[rsp]
  0020f	eb 1a		 jmp	 SHORT $LN21@compiler_s@2
$_error$22676:
$LN4@compiler_s@2:

; 657  : 
; 658  : _error:
; 659  :     Py_XDECREF(seq);

  00211	48 83 7c 24 50
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00217	74 0a		 je	 SHORT $LN1@compiler_s@2
  00219	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq$[rsp]
  0021e	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@compiler_s@2:
  00223	33 c0		 xor	 eax, eax
  00225	85 c0		 test	 eax, eax
  00227	75 e8		 jne	 SHORT $LN4@compiler_s@2

; 660  :     return NULL;

  00229	33 c0		 xor	 eax, eax
$LN21@compiler_s@2:

; 661  : }

  0022b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0022f	c3		 ret	 0
compiler_scope_qualname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@HDJKJIHM@compiler_make_closure?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CK@EEBFFKMB@lookup?5?$CFs?5in?5?$CFs?5?$CFd?5?$CFd?6freevars?5o@ ; `string'
PUBLIC	??_C@_1DI@KKFPIJJD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAc?$AA?9?$AA?$DO?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyObject_Repr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_make_closure DD imagerel compiler_make_closure
	DD	imagerel compiler_make_closure+892
	DD	imagerel $unwind$compiler_make_closure
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_make_closure DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT ??_C@_0BI@HDJKJIHM@compiler_make_closure?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@HDJKJIHM@compiler_make_closure?$CI?$CJ?$AA@ DB 'compiler_make_c'
	DB	'losure()', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EEBFFKMB@lookup?5?$CFs?5in?5?$CFs?5?$CFd?5?$CFd?6freevars?5o@
CONST	SEGMENT
??_C@_0CK@EEBFFKMB@lookup?5?$CFs?5in?5?$CFs?5?$CFd?5?$CFd?6freevars?5o@ DB 'l'
	DB	'ookup %s in %s %d %d', 0aH, 'freevars of %s: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@KKFPIJJD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAc?$AA?9?$AA?$DO?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@KKFPIJJD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAc?$AA?9?$AA?$DO?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'c', 00H, '-', 00H, '>', 00H, 'u', 00H, '-', 00H, '>', 00H
	DB	'u', 00H, '_', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ')'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_make_closure
_TEXT	SEGMENT
free$ = 64
i$ = 68
reftype$23093 = 72
arg$23092 = 76
name$23090 = 80
tv145 = 88
tv151 = 96
tv169 = 104
tv171 = 112
c$ = 144
co$ = 152
args$ = 160
qualname$ = 168
compiler_make_closure PROC				; COMDAT

; 1369 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1370 :     int i, free = PyCode_GetNumFree(co);

  0001b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00023	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0002a	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0002d	89 44 24 40	 mov	 DWORD PTR free$[rsp], eax

; 1371 :     if (qualname == NULL)

  00031	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR qualname$[rsp], 0
  0003a	75 17		 jne	 SHORT $LN16@compiler_m@2

; 1372 :         qualname = co->co_name;

  0003c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00044	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0004b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR qualname$[rsp], rax
$LN16@compiler_m@2:

; 1373 : 
; 1374 :     if (free == 0) {

  00053	83 7c 24 40 00	 cmp	 DWORD PTR free$[rsp], 0
  00058	0f 85 99 00 00
	00		 jne	 $LN15@compiler_m@2

; 1375 :         ADDOP_O(c, LOAD_CONST, (PyObject*)co, consts);

  0005e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00066	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0006a	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR co$[rsp]
  00072	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00076	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0007b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00083	e8 00 00 00 00	 call	 compiler_addop_o
  00088	85 c0		 test	 eax, eax
  0008a	75 07		 jne	 SHORT $LN14@compiler_m@2
  0008c	33 c0		 xor	 eax, eax
  0008e	e9 e1 02 00 00	 jmp	 $LN17@compiler_m@2
$LN14@compiler_m@2:

; 1376 :         ADDOP_O(c, LOAD_CONST, qualname, consts);

  00093	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0009b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0009f	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR qualname$[rsp]
  000a7	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  000ab	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000b0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000b8	e8 00 00 00 00	 call	 compiler_addop_o
  000bd	85 c0		 test	 eax, eax
  000bf	75 07		 jne	 SHORT $LN13@compiler_m@2
  000c1	33 c0		 xor	 eax, eax
  000c3	e9 ac 02 00 00	 jmp	 $LN17@compiler_m@2
$LN13@compiler_m@2:

; 1377 :         ADDOP_I(c, MAKE_FUNCTION, args);

  000c8	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR args$[rsp]
  000d0	ba 84 00 00 00	 mov	 edx, 132		; 00000084H
  000d5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000dd	e8 00 00 00 00	 call	 compiler_addop_i
  000e2	85 c0		 test	 eax, eax
  000e4	75 07		 jne	 SHORT $LN12@compiler_m@2
  000e6	33 c0		 xor	 eax, eax
  000e8	e9 87 02 00 00	 jmp	 $LN17@compiler_m@2
$LN12@compiler_m@2:

; 1378 :         return 1;

  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	e9 7d 02 00 00	 jmp	 $LN17@compiler_m@2
$LN15@compiler_m@2:

; 1379 :     }
; 1380 :     for (i = 0; i < free; ++i) {

  000f7	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ff	eb 0a		 jmp	 SHORT $LN11@compiler_m@2
$LN10@compiler_m@2:
  00101	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00105	ff c0		 inc	 eax
  00107	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN11@compiler_m@2:
  0010b	8b 44 24 40	 mov	 eax, DWORD PTR free$[rsp]
  0010f	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  00113	0f 8d ae 01 00
	00		 jge	 $LN9@compiler_m@2

; 1381 :         /* Bypass com_addop_varname because it will generate
; 1382 :            LOAD_DEREF but LOAD_CLOSURE is needed.
; 1383 :         */
; 1384 :         PyObject *name = PyTuple_GET_ITEM(co->co_freevars, i);

  00119	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00121	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00128	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR i$[rsp]
  0012d	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00132	48 89 44 24 50	 mov	 QWORD PTR name$23090[rsp], rax

; 1385 :         int arg, reftype;
; 1386 : 
; 1387 :         /* Special case: If a class contains a method with a
; 1388 :            free variable that has the same name as a method,
; 1389 :            the name will be considered free *and* local in the
; 1390 :            class.  It should be handled by the closure, as
; 1391 :            well as by the normal name loookup logic.
; 1392 :         */
; 1393 :         reftype = get_ref_type(c, name);

  00137	48 8b 54 24 50	 mov	 rdx, QWORD PTR name$23090[rsp]
  0013c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00144	e8 00 00 00 00	 call	 get_ref_type
  00149	89 44 24 48	 mov	 DWORD PTR reftype$23093[rsp], eax

; 1394 :         if (reftype == CELL)

  0014d	83 7c 24 48 05	 cmp	 DWORD PTR reftype$23093[rsp], 5
  00152	75 20		 jne	 SHORT $LN8@compiler_m@2

; 1395 :             arg = compiler_lookup_arg(c->u->u_cellvars, name);

  00154	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0015c	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00160	48 8b 54 24 50	 mov	 rdx, QWORD PTR name$23090[rsp]
  00165	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00169	e8 00 00 00 00	 call	 compiler_lookup_arg
  0016e	89 44 24 4c	 mov	 DWORD PTR arg$23092[rsp], eax

; 1396 :         else /* (reftype == FREE) */

  00172	eb 1e		 jmp	 SHORT $LN7@compiler_m@2
$LN8@compiler_m@2:

; 1397 :             arg = compiler_lookup_arg(c->u->u_freevars, name);

  00174	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0017c	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00180	48 8b 54 24 50	 mov	 rdx, QWORD PTR name$23090[rsp]
  00185	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00189	e8 00 00 00 00	 call	 compiler_lookup_arg
  0018e	89 44 24 4c	 mov	 DWORD PTR arg$23092[rsp], eax
$LN7@compiler_m@2:

; 1398 :         if (arg == -1) {

  00192	83 7c 24 4c ff	 cmp	 DWORD PTR arg$23092[rsp], -1
  00197	0f 85 03 01 00
	00		 jne	 $LN6@compiler_m@2

; 1399 :             fprintf(stderr,
; 1400 :                 "lookup %s in %s %d %d\n"
; 1401 :                 "freevars of %s: %s\n",
; 1402 :                 PyObject_REPR(name),
; 1403 :                 PyBytes_AS_STRING(c->u->u_name),
; 1404 :                 reftype, arg,
; 1405 :                 _PyUnicode_AsString(co->co_name),
; 1406 :                 PyObject_REPR(co->co_freevars));

  0019d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  001a5	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001a9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001ad	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001b1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001b7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001bc	85 c0		 test	 eax, eax
  001be	75 1c		 jne	 SHORT $LN19@compiler_m@2
  001c0	41 b8 7b 05 00
	00		 mov	 r8d, 1403		; 0000057bH
  001c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@KKFPIJJD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAc?$AA?9?$AA?$DO?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001da	33 c0		 xor	 eax, eax
$LN19@compiler_m@2:
  001dc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  001e4	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  001eb	e8 00 00 00 00	 call	 PyObject_Repr
  001f0	48 8b c8	 mov	 rcx, rax
  001f3	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  001f8	48 89 44 24 58	 mov	 QWORD PTR tv145[rsp], rax
  001fd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR co$[rsp]
  00205	48 8b 89 b8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+184]
  0020c	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00211	48 89 44 24 60	 mov	 QWORD PTR tv151[rsp], rax
  00216	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0021e	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00222	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00226	48 83 c1 78	 add	 rcx, 120		; 00000078H
  0022a	48 89 4c 24 68	 mov	 QWORD PTR tv169[rsp], rcx
  0022f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$23090[rsp]
  00234	e8 00 00 00 00	 call	 PyObject_Repr
  00239	48 8b c8	 mov	 rcx, rax
  0023c	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00241	48 89 44 24 70	 mov	 QWORD PTR tv171[rsp], rax
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0024c	48 83 c0 60	 add	 rax, 96			; 00000060H
  00250	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv145[rsp]
  00255	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0025a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv151[rsp]
  0025f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00264	8b 4c 24 4c	 mov	 ecx, DWORD PTR arg$23092[rsp]
  00268	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0026c	8b 4c 24 48	 mov	 ecx, DWORD PTR reftype$23093[rsp]
  00270	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00274	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv169[rsp]
  00279	4c 8b c9	 mov	 r9, rcx
  0027c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv171[rsp]
  00281	4c 8b c1	 mov	 r8, rcx
  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@EEBFFKMB@lookup?5?$CFs?5in?5?$CFs?5?$CFd?5?$CFd?6freevars?5o@
  0028b	48 8b c8	 mov	 rcx, rax
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1407 :             Py_FatalError("compiler_make_closure()");

  00294	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@HDJKJIHM@compiler_make_closure?$CI?$CJ?$AA@
  0029b	e8 00 00 00 00	 call	 Py_FatalError
$LN6@compiler_m@2:

; 1408 :         }
; 1409 :         ADDOP_I(c, LOAD_CLOSURE, arg);

  002a0	44 8b 44 24 4c	 mov	 r8d, DWORD PTR arg$23092[rsp]
  002a5	ba 87 00 00 00	 mov	 edx, 135		; 00000087H
  002aa	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002b2	e8 00 00 00 00	 call	 compiler_addop_i
  002b7	85 c0		 test	 eax, eax
  002b9	75 07		 jne	 SHORT $LN5@compiler_m@2
  002bb	33 c0		 xor	 eax, eax
  002bd	e9 b2 00 00 00	 jmp	 $LN17@compiler_m@2
$LN5@compiler_m@2:

; 1410 :     }

  002c2	e9 3a fe ff ff	 jmp	 $LN10@compiler_m@2
$LN9@compiler_m@2:

; 1411 :     ADDOP_I(c, BUILD_TUPLE, free);

  002c7	44 8b 44 24 40	 mov	 r8d, DWORD PTR free$[rsp]
  002cc	ba 66 00 00 00	 mov	 edx, 102		; 00000066H
  002d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002d9	e8 00 00 00 00	 call	 compiler_addop_i
  002de	85 c0		 test	 eax, eax
  002e0	75 07		 jne	 SHORT $LN4@compiler_m@2
  002e2	33 c0		 xor	 eax, eax
  002e4	e9 8b 00 00 00	 jmp	 $LN17@compiler_m@2
$LN4@compiler_m@2:

; 1412 :     ADDOP_O(c, LOAD_CONST, (PyObject*)co, consts);

  002e9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  002f1	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  002f5	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR co$[rsp]
  002fd	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00301	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00306	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0030e	e8 00 00 00 00	 call	 compiler_addop_o
  00313	85 c0		 test	 eax, eax
  00315	75 04		 jne	 SHORT $LN3@compiler_m@2
  00317	33 c0		 xor	 eax, eax
  00319	eb 59		 jmp	 SHORT $LN17@compiler_m@2
$LN3@compiler_m@2:

; 1413 :     ADDOP_O(c, LOAD_CONST, qualname, consts);

  0031b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00323	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00327	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR qualname$[rsp]
  0032f	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00333	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00338	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00340	e8 00 00 00 00	 call	 compiler_addop_o
  00345	85 c0		 test	 eax, eax
  00347	75 04		 jne	 SHORT $LN2@compiler_m@2
  00349	33 c0		 xor	 eax, eax
  0034b	eb 27		 jmp	 SHORT $LN17@compiler_m@2
$LN2@compiler_m@2:

; 1414 :     ADDOP_I(c, MAKE_CLOSURE, args);

  0034d	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR args$[rsp]
  00355	ba 86 00 00 00	 mov	 edx, 134		; 00000086H
  0035a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00362	e8 00 00 00 00	 call	 compiler_addop_i
  00367	85 c0		 test	 eax, eax
  00369	75 04		 jne	 SHORT $LN1@compiler_m@2
  0036b	33 c0		 xor	 eax, eax
  0036d	eb 05		 jmp	 SHORT $LN17@compiler_m@2
$LN1@compiler_m@2:

; 1415 :     return 1;

  0036f	b8 01 00 00 00	 mov	 eax, 1
$LN17@compiler_m@2:

; 1416 : }

  00374	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0037b	c3		 ret	 0
compiler_make_closure ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FA@EGMNBIBK@unknown?5scope?5for?5?$CF?4100s?5in?5?$CF?410@ ; `string'
PUBLIC	??_C@_1CI@HEELCIBM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyOS_snprintf:PROC
EXTRN	PyST_GetScope:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_ref_type DD imagerel get_ref_type
	DD	imagerel get_ref_type+468
	DD	imagerel $unwind$get_ref_type
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_ref_type DD 021101H
	DD	03d0111H
xdata	ENDS
;	COMDAT ??_C@_0FA@EGMNBIBK@unknown?5scope?5for?5?$CF?4100s?5in?5?$CF?410@
CONST	SEGMENT
??_C@_0FA@EGMNBIBK@unknown?5scope?5for?5?$CF?4100s?5in?5?$CF?410@ DB 'unk'
	DB	'nown scope for %.100s in %.100s(%s) in %s', 0aH, 'symbols: %s'
	DB	0aH, 'locals: %s', 0aH, 'globals: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@HEELCIBM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@HEELCIBM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT get_ref_type
_TEXT	SEGMENT
scope$ = 80
buf$23044 = 96
tv71 = 448
tv78 = 456
tv85 = 464
c$ = 496
name$ = 504
get_ref_type PROC					; COMDAT

; 1332 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H

; 1333 :     int scope = PyST_GetScope(c->u->u_ste, name);

  00011	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00019	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0001d	48 8b 94 24 f8
	01 00 00	 mov	 rdx, QWORD PTR name$[rsp]
  00025	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00028	e8 00 00 00 00	 call	 PyST_GetScope
  0002d	89 44 24 50	 mov	 DWORD PTR scope$[rsp], eax

; 1334 :     if (scope == 0) {

  00031	83 7c 24 50 00	 cmp	 DWORD PTR scope$[rsp], 0
  00036	0f 85 8c 01 00
	00		 jne	 $LN1@get_ref_ty

; 1335 :         char buf[350];
; 1336 :         PyOS_snprintf(buf, sizeof(buf),
; 1337 :                       "unknown scope for %.100s in %.100s(%s) in %s\n"
; 1338 :                       "symbols: %s\nlocals: %s\nglobals: %s",
; 1339 :                       PyBytes_AS_STRING(name),
; 1340 :                       PyBytes_AS_STRING(c->u->u_name),
; 1341 :                       PyObject_REPR(c->u->u_ste->ste_id),
; 1342 :                       c->c_filename,
; 1343 :                       PyObject_REPR(c->u->u_ste->ste_symbols),
; 1344 :                       PyObject_REPR(c->u->u_varnames),
; 1345 :                       PyObject_REPR(c->u->u_names)
; 1346 :         );

  0003c	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00044	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00048	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00050	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00056	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0005b	85 c0		 test	 eax, eax
  0005d	75 1c		 jne	 SHORT $LN4@get_ref_ty
  0005f	41 b8 3c 05 00
	00		 mov	 r8d, 1340		; 0000053cH
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@KKFPIJJD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAc?$AA?9?$AA?$DO?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00079	33 c0		 xor	 eax, eax
$LN4@get_ref_ty:
  0007b	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00083	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00087	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0008d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00092	85 c0		 test	 eax, eax
  00094	75 1c		 jne	 SHORT $LN5@get_ref_ty
  00096	41 b8 3b 05 00
	00		 mov	 r8d, 1339		; 0000053bH
  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@HEELCIBM@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b0	33 c0		 xor	 eax, eax
$LN5@get_ref_ty:
  000b2	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000ba	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000be	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000c2	e8 00 00 00 00	 call	 PyObject_Repr
  000c7	48 8b c8	 mov	 rcx, rax
  000ca	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  000cf	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv71[rsp], rax
  000d7	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000df	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000e3	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000e7	e8 00 00 00 00	 call	 PyObject_Repr
  000ec	48 8b c8	 mov	 rcx, rax
  000ef	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  000f4	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv78[rsp], rax
  000fc	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00104	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00108	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0010b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0010f	e8 00 00 00 00	 call	 PyObject_Repr
  00114	48 8b c8	 mov	 rcx, rax
  00117	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  0011c	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv85[rsp], rax
  00124	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0012c	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00130	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00133	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00137	e8 00 00 00 00	 call	 PyObject_Repr
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00144	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0014c	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00150	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00154	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00158	48 8b 94 24 f8
	01 00 00	 mov	 rdx, QWORD PTR name$[rsp]
  00160	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00164	4c 8b 84 24 c0
	01 00 00	 mov	 r8, QWORD PTR tv71[rsp]
  0016c	4c 89 44 24 48	 mov	 QWORD PTR [rsp+72], r8
  00171	4c 8b 84 24 c8
	01 00 00	 mov	 r8, QWORD PTR tv78[rsp]
  00179	4c 89 44 24 40	 mov	 QWORD PTR [rsp+64], r8
  0017e	4c 8b 84 24 d0
	01 00 00	 mov	 r8, QWORD PTR tv85[rsp]
  00186	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  0018b	4c 8b 84 24 f0
	01 00 00	 mov	 r8, QWORD PTR c$[rsp]
  00193	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00196	4c 89 44 24 30	 mov	 QWORD PTR [rsp+48], r8
  0019b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001a5	4c 8b ca	 mov	 r9, rdx
  001a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0FA@EGMNBIBK@unknown?5scope?5for?5?$CF?4100s?5in?5?$CF?410@
  001af	ba 5e 01 00 00	 mov	 edx, 350		; 0000015eH
  001b4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$23044[rsp]
  001b9	e8 00 00 00 00	 call	 PyOS_snprintf

; 1347 :         Py_FatalError(buf);

  001be	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$23044[rsp]
  001c3	e8 00 00 00 00	 call	 Py_FatalError
$LN1@get_ref_ty:

; 1348 :     }
; 1349 : 
; 1350 :     return scope;

  001c8	8b 44 24 50	 mov	 eax, DWORD PTR scope$[rsp]

; 1351 : }

  001cc	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  001d3	c3		 ret	 0
get_ref_type ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_lookup_arg DD imagerel compiler_lookup_arg
	DD	imagerel compiler_lookup_arg+118
	DD	imagerel $unwind$compiler_lookup_arg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_lookup_arg DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_lookup_arg
_TEXT	SEGMENT
v$ = 32
k$ = 40
dict$ = 64
name$ = 72
compiler_lookup_arg PROC				; COMDAT

; 1355 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1356 :     PyObject *k, *v;
; 1357 :     k = PyTuple_Pack(2, name, name->ob_type);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR name$[rsp]
  00013	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00017	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  0001c	b9 02 00 00 00	 mov	 ecx, 2
  00021	e8 00 00 00 00	 call	 PyTuple_Pack
  00026	48 89 44 24 28	 mov	 QWORD PTR k$[rsp], rax

; 1358 :     if (k == NULL)

  0002b	48 83 7c 24 28
	00		 cmp	 QWORD PTR k$[rsp], 0
  00031	75 07		 jne	 SHORT $LN2@compiler_l

; 1359 :         return -1;

  00033	b8 ff ff ff ff	 mov	 eax, -1
  00038	eb 37		 jmp	 SHORT $LN3@compiler_l
$LN2@compiler_l:

; 1360 :     v = PyDict_GetItem(dict, k);

  0003a	48 8b 54 24 28	 mov	 rdx, QWORD PTR k$[rsp]
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dict$[rsp]
  00044	e8 00 00 00 00	 call	 PyDict_GetItem
  00049	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1361 :     Py_DECREF(k);

  0004e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR k$[rsp]
  00053	e8 00 00 00 00	 call	 _Py_DecRef

; 1362 :     if (v == NULL)

  00058	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  0005e	75 07		 jne	 SHORT $LN1@compiler_l

; 1363 :         return -1;

  00060	b8 ff ff ff ff	 mov	 eax, -1
  00065	eb 0a		 jmp	 SHORT $LN3@compiler_l
$LN1@compiler_l:

; 1364 :     return PyLong_AS_LONG(v);

  00067	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0006c	e8 00 00 00 00	 call	 PyLong_AsLong
$LN3@compiler_l:

; 1365 : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
compiler_lookup_arg ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_decorators DD imagerel compiler_decorators
	DD	imagerel compiler_decorators+138
	DD	imagerel $unwind$compiler_decorators
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_decorators DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_decorators
_TEXT	SEGMENT
i$ = 32
tv68 = 40
c$ = 64
decos$ = 72
compiler_decorators PROC				; COMDAT

; 1420 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1421 :     int i;
; 1422 : 
; 1423 :     if (!decos)

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR decos$[rsp], 0
  00014	75 07		 jne	 SHORT $LN5@compiler_d

; 1424 :         return 1;

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	eb 68		 jmp	 SHORT $LN6@compiler_d
$LN5@compiler_d:

; 1425 : 
; 1426 :     for (i = 0; i < asdl_seq_LEN(decos); i++) {

  0001d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00025	eb 0a		 jmp	 SHORT $LN4@compiler_d
$LN3@compiler_d:
  00027	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002b	ff c0		 inc	 eax
  0002d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@compiler_d:
  00031	48 83 7c 24 48
	00		 cmp	 QWORD PTR decos$[rsp], 0
  00037	75 0b		 jne	 SHORT $LN8@compiler_d
  00039	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
  00042	eb 0d		 jmp	 SHORT $LN9@compiler_d
$LN8@compiler_d:
  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR decos$[rsp]
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 89 44 24 28	 mov	 QWORD PTR tv68[rsp], rax
$LN9@compiler_d:
  00051	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00056	48 3b 44 24 28	 cmp	 rax, QWORD PTR tv68[rsp]
  0005b	7d 23		 jge	 SHORT $LN2@compiler_d

; 1427 :         VISIT(c, expr, (expr_ty)asdl_seq_GET(decos, i));

  0005d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00062	48 8b 4c 24 48	 mov	 rcx, QWORD PTR decos$[rsp]
  00067	48 8b 54 c1 08	 mov	 rdx, QWORD PTR [rcx+rax*8+8]
  0006c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00071	e8 00 00 00 00	 call	 compiler_visit_expr
  00076	85 c0		 test	 eax, eax
  00078	75 04		 jne	 SHORT $LN1@compiler_d
  0007a	33 c0		 xor	 eax, eax
  0007c	eb 07		 jmp	 SHORT $LN6@compiler_d
$LN1@compiler_d:

; 1428 :     }

  0007e	eb a7		 jmp	 SHORT $LN3@compiler_d
$LN2@compiler_d:

; 1429 :     return 1;

  00080	b8 01 00 00 00	 mov	 eax, 1
$LN6@compiler_d:

; 1430 : }

  00085	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00089	c3		 ret	 0
compiler_decorators ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_kwonlydefaults DD imagerel compiler_visit_kwonlydefaults
	DD	imagerel compiler_visit_kwonlydefaults+294
	DD	imagerel $unwind$compiler_visit_kwonlydefaults
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_kwonlydefaults DD 011301H
	DD	0a213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_visit_kwonlydefaults
_TEXT	SEGMENT
i$ = 32
default_count$ = 36
arg$23136 = 40
default_$23137 = 48
mangled$23139 = 56
tv67 = 64
c$ = 96
kwonlyargs$ = 104
kw_defaults$ = 112
compiler_visit_kwonlydefaults PROC			; COMDAT

; 1435 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1436 :     int i, default_count = 0;

  00013	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR default_count$[rsp], 0

; 1437 :     for (i = 0; i < asdl_seq_LEN(kwonlyargs); i++) {

  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00023	eb 0a		 jmp	 SHORT $LN7@compiler_v@2
$LN6@compiler_v@2:
  00025	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@compiler_v@2:
  0002f	48 83 7c 24 68
	00		 cmp	 QWORD PTR kwonlyargs$[rsp], 0
  00035	75 0b		 jne	 SHORT $LN10@compiler_v@2
  00037	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
  00040	eb 0d		 jmp	 SHORT $LN11@compiler_v@2
$LN10@compiler_v@2:
  00042	48 8b 44 24 68	 mov	 rax, QWORD PTR kwonlyargs$[rsp]
  00047	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004a	48 89 44 24 40	 mov	 QWORD PTR tv67[rsp], rax
$LN11@compiler_v@2:
  0004f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00054	48 3b 44 24 40	 cmp	 rax, QWORD PTR tv67[rsp]
  00059	0f 8d be 00 00
	00		 jge	 $LN5@compiler_v@2

; 1438 :         arg_ty arg = asdl_seq_GET(kwonlyargs, i);

  0005f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00064	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kwonlyargs$[rsp]
  00069	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  0006e	48 89 44 24 28	 mov	 QWORD PTR arg$23136[rsp], rax

; 1439 :         expr_ty default_ = asdl_seq_GET(kw_defaults, i);

  00073	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00078	48 8b 4c 24 70	 mov	 rcx, QWORD PTR kw_defaults$[rsp]
  0007d	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00082	48 89 44 24 30	 mov	 QWORD PTR default_$23137[rsp], rax

; 1440 :         if (default_) {

  00087	48 83 7c 24 30
	00		 cmp	 QWORD PTR default_$23137[rsp], 0
  0008d	0f 84 85 00 00
	00		 je	 $LN4@compiler_v@2

; 1441 :             PyObject *mangled = _Py_Mangle(c->u->u_private, arg->arg);

  00093	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00098	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0009c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR arg$23136[rsp]
  000a1	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  000a4	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  000a8	e8 00 00 00 00	 call	 _Py_Mangle
  000ad	48 89 44 24 38	 mov	 QWORD PTR mangled$23139[rsp], rax

; 1442 :             if (!mangled)

  000b2	48 83 7c 24 38
	00		 cmp	 QWORD PTR mangled$23139[rsp], 0
  000b8	75 07		 jne	 SHORT $LN3@compiler_v@2

; 1443 :                 return -1;

  000ba	b8 ff ff ff ff	 mov	 eax, -1
  000bf	eb 60		 jmp	 SHORT $LN8@compiler_v@2
$LN3@compiler_v@2:

; 1444 :             ADDOP_O(c, LOAD_CONST, mangled, consts);

  000c1	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  000c6	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000ca	4c 8b 4c 24 38	 mov	 r9, QWORD PTR mangled$23139[rsp]
  000cf	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  000d3	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000dd	e8 00 00 00 00	 call	 compiler_addop_o
  000e2	85 c0		 test	 eax, eax
  000e4	75 04		 jne	 SHORT $LN2@compiler_v@2
  000e6	33 c0		 xor	 eax, eax
  000e8	eb 37		 jmp	 SHORT $LN8@compiler_v@2
$LN2@compiler_v@2:

; 1445 :             Py_DECREF(mangled);

  000ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mangled$23139[rsp]
  000ef	e8 00 00 00 00	 call	 _Py_DecRef

; 1446 :             if (!compiler_visit_expr(c, default_)) {

  000f4	48 8b 54 24 30	 mov	 rdx, QWORD PTR default_$23137[rsp]
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000fe	e8 00 00 00 00	 call	 compiler_visit_expr
  00103	85 c0		 test	 eax, eax
  00105	75 07		 jne	 SHORT $LN1@compiler_v@2

; 1447 :                 return -1;

  00107	b8 ff ff ff ff	 mov	 eax, -1
  0010c	eb 13		 jmp	 SHORT $LN8@compiler_v@2
$LN1@compiler_v@2:

; 1448 :             }
; 1449 :             default_count++;

  0010e	8b 44 24 24	 mov	 eax, DWORD PTR default_count$[rsp]
  00112	ff c0		 inc	 eax
  00114	89 44 24 24	 mov	 DWORD PTR default_count$[rsp], eax
$LN4@compiler_v@2:

; 1450 :         }
; 1451 :     }

  00118	e9 08 ff ff ff	 jmp	 $LN6@compiler_v@2
$LN5@compiler_v@2:

; 1452 :     return default_count;

  0011d	8b 44 24 24	 mov	 eax, DWORD PTR default_count$[rsp]
$LN8@compiler_v@2:

; 1453 : }

  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	c3		 ret	 0
compiler_visit_kwonlydefaults ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NFIMIMON@too?5many?5annotations?$AA@	; `string'
PUBLIC	??_C@_06LNOFJDNM@return?$AA@			; `string'
EXTRN	PyTuple_New:PROC
EXTRN	PyExc_SyntaxError:QWORD
_BSS	SEGMENT
?return_str@?1??compiler_visit_annotations@@9@9 DQ 01H DUP (?) ; `compiler_visit_annotations'::`2'::return_str
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_annotations DD imagerel compiler_visit_annotations
	DD	imagerel compiler_visit_annotations+572
	DD	imagerel $unwind$compiler_visit_annotations
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_annotations DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0BF@NFIMIMON@too?5many?5annotations?$AA@
CONST	SEGMENT
??_C@_0BF@NFIMIMON@too?5many?5annotations?$AA@ DB 'too many annotations', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNOFJDNM@return?$AA@
CONST	SEGMENT
??_C@_06LNOFJDNM@return?$AA@ DB 'return', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_visit_annotations
_TEXT	SEGMENT
names$ = 32
len$ = 40
i$23201 = 44
s$23202 = 48
elt$23200 = 56
c$ = 80
args$ = 88
returns$ = 96
compiler_visit_annotations PROC				; COMDAT

; 1488 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1489 :     /* Push arg annotations and a list of the argument names. Return the #
; 1490 :        of items pushed. The expressions are evaluated out-of-order wrt the
; 1491 :        source code.
; 1492 : 
; 1493 :        More than 2^16-1 annotations is a SyntaxError. Returns -1 on error.
; 1494 :        */
; 1495 :     static identifier return_str;
; 1496 :     PyObject *names;
; 1497 :     int len;
; 1498 :     names = PyList_New(0);

  00013	33 c9		 xor	 ecx, ecx
  00015	e8 00 00 00 00	 call	 PyList_New
  0001a	48 89 44 24 20	 mov	 QWORD PTR names$[rsp], rax

; 1499 :     if (!names)

  0001f	48 83 7c 24 20
	00		 cmp	 QWORD PTR names$[rsp], 0
  00025	75 0a		 jne	 SHORT $LN15@compiler_v@3

; 1500 :         return -1;

  00027	b8 ff ff ff ff	 mov	 eax, -1
  0002c	e9 06 02 00 00	 jmp	 $LN16@compiler_v@3
$LN15@compiler_v@3:

; 1501 : 
; 1502 :     if (compiler_visit_argannotations(c, args->args, names))

  00031	4c 8b 44 24 20	 mov	 r8, QWORD PTR names$[rsp]
  00036	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  0003b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00043	e8 00 00 00 00	 call	 compiler_visit_argannotations
  00048	85 c0		 test	 eax, eax
  0004a	74 05		 je	 SHORT $LN14@compiler_v@3

; 1503 :         goto error;

  0004c	e9 d7 01 00 00	 jmp	 $error$23188
$LN14@compiler_v@3:

; 1504 :     if (args->varargannotation &&
; 1505 :         compiler_visit_argannotation(c, args->vararg,
; 1506 :                                      args->varargannotation, names))

  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00056	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0005b	74 2a		 je	 SHORT $LN13@compiler_v@3
  0005d	4c 8b 4c 24 20	 mov	 r9, QWORD PTR names$[rsp]
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00067	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  0006b	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00070	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00079	e8 00 00 00 00	 call	 compiler_visit_argannotation
  0007e	85 c0		 test	 eax, eax
  00080	74 05		 je	 SHORT $LN13@compiler_v@3

; 1507 :         goto error;

  00082	e9 a1 01 00 00	 jmp	 $error$23188
$LN13@compiler_v@3:

; 1508 :     if (compiler_visit_argannotations(c, args->kwonlyargs, names))

  00087	4c 8b 44 24 20	 mov	 r8, QWORD PTR names$[rsp]
  0008c	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00091	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0009a	e8 00 00 00 00	 call	 compiler_visit_argannotations
  0009f	85 c0		 test	 eax, eax
  000a1	74 05		 je	 SHORT $LN12@compiler_v@3

; 1509 :         goto error;

  000a3	e9 80 01 00 00	 jmp	 $error$23188
$LN12@compiler_v@3:

; 1510 :     if (args->kwargannotation &&
; 1511 :         compiler_visit_argannotation(c, args->kwarg,
; 1512 :                                      args->kwargannotation, names))

  000a8	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  000ad	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  000b2	74 2a		 je	 SHORT $LN11@compiler_v@3
  000b4	4c 8b 4c 24 20	 mov	 r9, QWORD PTR names$[rsp]
  000b9	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  000be	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  000c2	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  000c7	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  000cb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000d0	e8 00 00 00 00	 call	 compiler_visit_argannotation
  000d5	85 c0		 test	 eax, eax
  000d7	74 05		 je	 SHORT $LN11@compiler_v@3

; 1513 :         goto error;

  000d9	e9 4a 01 00 00	 jmp	 $error$23188
$LN11@compiler_v@3:

; 1514 : 
; 1515 :     if (!return_str) {

  000de	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?return_str@?1??compiler_visit_annotations@@9@9, 0
  000e6	75 22		 jne	 SHORT $LN10@compiler_v@3

; 1516 :         return_str = PyUnicode_InternFromString("return");

  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06LNOFJDNM@return?$AA@
  000ef	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  000f4	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?return_str@?1??compiler_visit_annotations@@9@9, rax

; 1517 :         if (!return_str)

  000fb	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?return_str@?1??compiler_visit_annotations@@9@9, 0
  00103	75 05		 jne	 SHORT $LN9@compiler_v@3

; 1518 :             goto error;

  00105	e9 1e 01 00 00	 jmp	 $error$23188
$LN9@compiler_v@3:
$LN10@compiler_v@3:

; 1519 :     }
; 1520 :     if (compiler_visit_argannotation(c, return_str, returns, names)) {

  0010a	4c 8b 4c 24 20	 mov	 r9, QWORD PTR names$[rsp]
  0010f	4c 8b 44 24 60	 mov	 r8, QWORD PTR returns$[rsp]
  00114	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?return_str@?1??compiler_visit_annotations@@9@9
  0011b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00120	e8 00 00 00 00	 call	 compiler_visit_argannotation
  00125	85 c0		 test	 eax, eax
  00127	74 05		 je	 SHORT $LN8@compiler_v@3

; 1521 :         goto error;

  00129	e9 fa 00 00 00	 jmp	 $error$23188
$LN8@compiler_v@3:

; 1522 :     }
; 1523 : 
; 1524 :     len = PyList_GET_SIZE(names);

  0012e	48 8b 44 24 20	 mov	 rax, QWORD PTR names$[rsp]
  00133	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00136	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 1525 :     if (len > 65534) {

  0013a	81 7c 24 28 fe
	ff 00 00	 cmp	 DWORD PTR len$[rsp], 65534 ; 0000fffeH
  00142	7e 18		 jle	 SHORT $LN7@compiler_v@3

; 1526 :         /* len must fit in 16 bits, and len is incremented below */
; 1527 :         PyErr_SetString(PyExc_SyntaxError,
; 1528 :                         "too many annotations");

  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@NFIMIMON@too?5many?5annotations?$AA@
  0014b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  00152	e8 00 00 00 00	 call	 PyErr_SetString

; 1529 :         goto error;

  00157	e9 cc 00 00 00	 jmp	 $error$23188
$LN7@compiler_v@3:

; 1530 :     }
; 1531 :     if (len) {

  0015c	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  00161	0f 84 b1 00 00
	00		 je	 $LN6@compiler_v@3

; 1532 :         /* convert names to a tuple and place on stack */
; 1533 :         PyObject *elt;
; 1534 :         int i;
; 1535 :         PyObject *s = PyTuple_New(len);

  00167	48 63 44 24 28	 movsxd	 rax, DWORD PTR len$[rsp]
  0016c	48 8b c8	 mov	 rcx, rax
  0016f	e8 00 00 00 00	 call	 PyTuple_New
  00174	48 89 44 24 30	 mov	 QWORD PTR s$23202[rsp], rax

; 1536 :         if (!s)

  00179	48 83 7c 24 30
	00		 cmp	 QWORD PTR s$23202[rsp], 0
  0017f	75 05		 jne	 SHORT $LN5@compiler_v@3

; 1537 :             goto error;

  00181	e9 a2 00 00 00	 jmp	 $error$23188
$LN5@compiler_v@3:

; 1538 :         for (i = 0; i < len; i++) {

  00186	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$23201[rsp], 0
  0018e	eb 0a		 jmp	 SHORT $LN4@compiler_v@3
$LN3@compiler_v@3:
  00190	8b 44 24 2c	 mov	 eax, DWORD PTR i$23201[rsp]
  00194	ff c0		 inc	 eax
  00196	89 44 24 2c	 mov	 DWORD PTR i$23201[rsp], eax
$LN4@compiler_v@3:
  0019a	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  0019e	39 44 24 2c	 cmp	 DWORD PTR i$23201[rsp], eax
  001a2	7d 37		 jge	 SHORT $LN2@compiler_v@3

; 1539 :             elt = PyList_GET_ITEM(names, i);

  001a4	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i$23201[rsp]
  001a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR names$[rsp]
  001ae	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001b2	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  001b6	48 89 44 24 38	 mov	 QWORD PTR elt$23200[rsp], rax

; 1540 :             Py_INCREF(elt);

  001bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR elt$23200[rsp]
  001c0	e8 00 00 00 00	 call	 _Py_IncRef

; 1541 :             PyTuple_SET_ITEM(s, i, elt);

  001c5	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i$23201[rsp]
  001ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$23202[rsp]
  001cf	48 8b 54 24 38	 mov	 rdx, QWORD PTR elt$23200[rsp]
  001d4	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 1542 :         }

  001d9	eb b5		 jmp	 SHORT $LN3@compiler_v@3
$LN2@compiler_v@3:

; 1543 :         ADDOP_O(c, LOAD_CONST, s, consts);

  001db	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  001e0	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001e4	4c 8b 4c 24 30	 mov	 r9, QWORD PTR s$23202[rsp]
  001e9	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  001ed	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  001f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  001f7	e8 00 00 00 00	 call	 compiler_addop_o
  001fc	85 c0		 test	 eax, eax
  001fe	75 04		 jne	 SHORT $LN1@compiler_v@3
  00200	33 c0		 xor	 eax, eax
  00202	eb 33		 jmp	 SHORT $LN16@compiler_v@3
$LN1@compiler_v@3:

; 1544 :         Py_DECREF(s);

  00204	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$23202[rsp]
  00209	e8 00 00 00 00	 call	 _Py_DecRef

; 1545 :         len++; /* include the just-pushed tuple */

  0020e	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  00212	ff c0		 inc	 eax
  00214	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax
$LN6@compiler_v@3:

; 1546 :     }
; 1547 :     Py_DECREF(names);

  00218	48 8b 4c 24 20	 mov	 rcx, QWORD PTR names$[rsp]
  0021d	e8 00 00 00 00	 call	 _Py_DecRef

; 1548 :     return len;

  00222	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  00226	eb 0f		 jmp	 SHORT $LN16@compiler_v@3
$error$23188:

; 1549 : 
; 1550 : error:
; 1551 :     Py_DECREF(names);

  00228	48 8b 4c 24 20	 mov	 rcx, QWORD PTR names$[rsp]
  0022d	e8 00 00 00 00	 call	 _Py_DecRef

; 1552 :     return -1;

  00232	b8 ff ff ff ff	 mov	 eax, -1
$LN16@compiler_v@3:

; 1553 : }

  00237	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0023b	c3		 ret	 0
compiler_visit_annotations ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_argannotation DD imagerel compiler_visit_argannotation
	DD	imagerel compiler_visit_argannotation+88
	DD	imagerel $unwind$compiler_visit_argannotation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_argannotation DD 011801H
	DD	04218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_visit_argannotation
_TEXT	SEGMENT
c$ = 48
id$ = 56
annotation$ = 64
names$ = 72
compiler_visit_argannotation PROC			; COMDAT

; 1458 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1459 :     if (annotation) {

  00018	48 83 7c 24 40
	00		 cmp	 QWORD PTR annotation$[rsp], 0
  0001e	74 31		 je	 SHORT $LN3@compiler_v@4

; 1460 :         VISIT(c, expr, annotation);

  00020	48 8b 54 24 40	 mov	 rdx, QWORD PTR annotation$[rsp]
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$[rsp]
  0002a	e8 00 00 00 00	 call	 compiler_visit_expr
  0002f	85 c0		 test	 eax, eax
  00031	75 04		 jne	 SHORT $LN2@compiler_v@4
  00033	33 c0		 xor	 eax, eax
  00035	eb 1c		 jmp	 SHORT $LN4@compiler_v@4
$LN2@compiler_v@4:

; 1461 :         if (PyList_Append(names, id))

  00037	48 8b 54 24 38	 mov	 rdx, QWORD PTR id$[rsp]
  0003c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR names$[rsp]
  00041	e8 00 00 00 00	 call	 PyList_Append
  00046	85 c0		 test	 eax, eax
  00048	74 07		 je	 SHORT $LN1@compiler_v@4

; 1462 :             return -1;

  0004a	b8 ff ff ff ff	 mov	 eax, -1
  0004f	eb 02		 jmp	 SHORT $LN4@compiler_v@4
$LN1@compiler_v@4:
$LN3@compiler_v@4:

; 1463 :     }
; 1464 :     return 0;

  00051	33 c0		 xor	 eax, eax
$LN4@compiler_v@4:

; 1465 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
compiler_visit_argannotation ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_argannotations DD imagerel compiler_visit_argannotations
	DD	imagerel compiler_visit_argannotations+161
	DD	imagerel $unwind$compiler_visit_argannotations
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_argannotations DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_visit_argannotations
_TEXT	SEGMENT
i$ = 32
error$ = 36
arg$23171 = 40
tv67 = 48
c$ = 80
args$ = 88
names$ = 96
compiler_visit_argannotations PROC			; COMDAT

; 1470 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1471 :     int i, error;
; 1472 :     for (i = 0; i < asdl_seq_LEN(args); i++) {

  00013	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001b	eb 0a		 jmp	 SHORT $LN4@compiler_v@5
$LN3@compiler_v@5:
  0001d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00021	ff c0		 inc	 eax
  00023	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@compiler_v@5:
  00027	48 83 7c 24 58
	00		 cmp	 QWORD PTR args$[rsp], 0
  0002d	75 0b		 jne	 SHORT $LN7@compiler_v@5
  0002f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
  00038	eb 0d		 jmp	 SHORT $LN8@compiler_v@5
$LN7@compiler_v@5:
  0003a	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  0003f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00042	48 89 44 24 30	 mov	 QWORD PTR tv67[rsp], rax
$LN8@compiler_v@5:
  00047	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004c	48 3b 44 24 30	 cmp	 rax, QWORD PTR tv67[rsp]
  00051	7d 47		 jge	 SHORT $LN2@compiler_v@5

; 1473 :         arg_ty arg = (arg_ty)asdl_seq_GET(args, i);

  00053	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0005d	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00062	48 89 44 24 28	 mov	 QWORD PTR arg$23171[rsp], rax

; 1474 :         error = compiler_visit_argannotation(
; 1475 :                         c,
; 1476 :                         arg->arg,
; 1477 :                         arg->annotation,
; 1478 :                         names);

  00067	4c 8b 4c 24 60	 mov	 r9, QWORD PTR names$[rsp]
  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR arg$23171[rsp]
  00071	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR arg$23171[rsp]
  0007a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0007d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00082	e8 00 00 00 00	 call	 compiler_visit_argannotation
  00087	89 44 24 24	 mov	 DWORD PTR error$[rsp], eax

; 1479 :         if (error)

  0008b	83 7c 24 24 00	 cmp	 DWORD PTR error$[rsp], 0
  00090	74 06		 je	 SHORT $LN1@compiler_v@5

; 1480 :             return error;

  00092	8b 44 24 24	 mov	 eax, DWORD PTR error$[rsp]
  00096	eb 04		 jmp	 SHORT $LN5@compiler_v@5
$LN1@compiler_v@5:

; 1481 :     }

  00098	eb 83		 jmp	 SHORT $LN3@compiler_v@5
$LN2@compiler_v@5:

; 1482 :     return 0;

  0009a	33 c0		 xor	 eax, eax
$LN5@compiler_v@5:

; 1483 : }

  0009c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a0	c3		 ret	 0
compiler_visit_argannotations ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LFGACEKG@__class__?$AA@			; `string'
PUBLIC	??_C@_0N@FMLGAKCE@__qualname__?$AA@		; `string'
PUBLIC	??_C@_0L@LNCJCPDP@__module__?$AA@		; `string'
PUBLIC	??_C@_08BHKDPDAA@__name__?$AA@			; `string'
EXTRN	PyErr_Clear:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_class DD imagerel compiler_class
	DD	imagerel compiler_class+1267
	DD	imagerel $unwind$compiler_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_class DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_09LFGACEKG@__class__?$AA@
CONST	SEGMENT
??_C@_09LFGACEKG@__class__?$AA@ DB '__class__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMLGAKCE@__qualname__?$AA@
CONST	SEGMENT
??_C@_0N@FMLGAKCE@__qualname__?$AA@ DB '__qualname__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LNCJCPDP@__module__?$AA@
CONST	SEGMENT
??_C@_0L@LNCJCPDP@__module__?$AA@ DB '__module__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BHKDPDAA@__name__?$AA@
CONST	SEGMENT
??_C@_08BHKDPDAA@__name__?$AA@ DB '__name__', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_class
_TEXT	SEGMENT
i$ = 48
decos$ = 56
co$ = 64
str$ = 72
tv259 = 80
c$ = 112
s$ = 120
compiler_class PROC					; COMDAT

; 1633 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1634 :     PyCodeObject *co;
; 1635 :     PyObject *str;
; 1636 :     int i;
; 1637 :     asdl_seq* decos = s->v.ClassDef.decorator_list;

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00013	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00017	48 89 44 24 38	 mov	 QWORD PTR decos$[rsp], rax

; 1638 : 
; 1639 :     if (!compiler_decorators(c, decos))

  0001c	48 8b 54 24 38	 mov	 rdx, QWORD PTR decos$[rsp]
  00021	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00026	e8 00 00 00 00	 call	 compiler_decorators
  0002b	85 c0		 test	 eax, eax
  0002d	75 07		 jne	 SHORT $LN44@compiler_c

; 1640 :         return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 b8 04 00 00	 jmp	 $LN45@compiler_c
$LN44@compiler_c:

; 1641 : 
; 1642 :     /* ultimately generate code for:
; 1643 :          <name> = __build_class__(<func>, <name>, *<bases>, **<keywords>)
; 1644 :        where:
; 1645 :          <func> is a function/closure created from the class body;
; 1646 :             it has a single argument (__locals__) where the dict
; 1647 :             (or MutableSequence) representing the locals is passed
; 1648 :          <name> is the class name
; 1649 :          <bases> is the positional arguments and *varargs argument
; 1650 :          <keywords> is the keyword arguments and **kwds argument
; 1651 :        This borrows from compiler_call.
; 1652 :     */
; 1653 : 
; 1654 :     /* 1. compile the class body into a code object */
; 1655 :     if (!compiler_enter_scope(c, s->v.ClassDef.name,
; 1656 :                               COMPILER_SCOPE_CLASS, (void *)s, s->lineno))

  00036	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  0003b	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0003e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00042	4c 8b 4c 24 78	 mov	 r9, QWORD PTR s$[rsp]
  00047	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004d	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00052	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00056	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0005b	e8 00 00 00 00	 call	 compiler_enter_scope
  00060	85 c0		 test	 eax, eax
  00062	75 07		 jne	 SHORT $LN43@compiler_c

; 1657 :         return 0;

  00064	33 c0		 xor	 eax, eax
  00066	e9 83 04 00 00	 jmp	 $LN45@compiler_c
$LN43@compiler_c:

; 1658 :     /* this block represents what we do in the new scope */
; 1659 :     {
; 1660 :         /* use the class name for name mangling */
; 1661 :         Py_INCREF(s->v.ClassDef.name);

  0006b	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00070	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00074	e8 00 00 00 00	 call	 _Py_IncRef
$LN42@compiler_c:

; 1662 :         Py_XDECREF(c->u->u_private);

  00079	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0007e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00082	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00087	74 12		 je	 SHORT $LN39@compiler_c
  00089	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0008e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00092	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  00096	e8 00 00 00 00	 call	 _Py_DecRef
$LN39@compiler_c:
  0009b	33 c0		 xor	 eax, eax
  0009d	85 c0		 test	 eax, eax
  0009f	75 d8		 jne	 SHORT $LN42@compiler_c

; 1663 :         c->u->u_private = s->v.ClassDef.name;

  000a1	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  000a6	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000aa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  000af	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b3	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 1664 :         /* force it to have one mandatory argument */
; 1665 :         c->u->u_argcount = 1;

  000b7	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  000bc	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000c0	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [rax+80], 1

; 1666 :         /* load the first argument (__locals__) ... */
; 1667 :         ADDOP_I(c, LOAD_FAST, 0);

  000c7	45 33 c0	 xor	 r8d, r8d
  000ca	ba 7c 00 00 00	 mov	 edx, 124		; 0000007cH
  000cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000d4	e8 00 00 00 00	 call	 compiler_addop_i
  000d9	85 c0		 test	 eax, eax
  000db	75 07		 jne	 SHORT $LN38@compiler_c
  000dd	33 c0		 xor	 eax, eax
  000df	e9 0a 04 00 00	 jmp	 $LN45@compiler_c
$LN38@compiler_c:

; 1668 :         /* ... and store it into f_locals */
; 1669 :         ADDOP_IN_SCOPE(c, STORE_LOCALS);

  000e4	ba 45 00 00 00	 mov	 edx, 69			; 00000045H
  000e9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000ee	e8 00 00 00 00	 call	 compiler_addop
  000f3	85 c0		 test	 eax, eax
  000f5	75 11		 jne	 SHORT $LN37@compiler_c
  000f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000fc	e8 00 00 00 00	 call	 compiler_exit_scope
  00101	33 c0		 xor	 eax, eax
  00103	e9 e6 03 00 00	 jmp	 $LN45@compiler_c
$LN37@compiler_c:

; 1670 :         /* load (global) __name__ ... */
; 1671 :         str = PyUnicode_InternFromString("__name__");

  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08BHKDPDAA@__name__?$AA@
  0010f	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00114	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax

; 1672 :         if (!str || !compiler_nameop(c, str, Load)) {

  00119	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$[rsp], 0
  0011f	74 19		 je	 SHORT $LN35@compiler_c
  00121	41 b8 01 00 00
	00		 mov	 r8d, 1
  00127	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$[rsp]
  0012c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00131	e8 00 00 00 00	 call	 compiler_nameop
  00136	85 c0		 test	 eax, eax
  00138	75 29		 jne	 SHORT $LN36@compiler_c
$LN35@compiler_c:
$LN34@compiler_c:

; 1673 :             Py_XDECREF(str);

  0013a	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$[rsp], 0
  00140	74 0a		 je	 SHORT $LN31@compiler_c
  00142	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  00147	e8 00 00 00 00	 call	 _Py_DecRef
$LN31@compiler_c:
  0014c	33 c0		 xor	 eax, eax
  0014e	85 c0		 test	 eax, eax
  00150	75 e8		 jne	 SHORT $LN34@compiler_c

; 1674 :             compiler_exit_scope(c);

  00152	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00157	e8 00 00 00 00	 call	 compiler_exit_scope

; 1675 :             return 0;

  0015c	33 c0		 xor	 eax, eax
  0015e	e9 8b 03 00 00	 jmp	 $LN45@compiler_c
$LN36@compiler_c:

; 1676 :         }
; 1677 :         Py_DECREF(str);

  00163	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  00168	e8 00 00 00 00	 call	 _Py_DecRef

; 1678 :         /* ... and store it as __module__ */
; 1679 :         str = PyUnicode_InternFromString("__module__");

  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LNCJCPDP@__module__?$AA@
  00174	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00179	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax

; 1680 :         if (!str || !compiler_nameop(c, str, Store)) {

  0017e	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$[rsp], 0
  00184	74 19		 je	 SHORT $LN29@compiler_c
  00186	41 b8 02 00 00
	00		 mov	 r8d, 2
  0018c	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$[rsp]
  00191	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00196	e8 00 00 00 00	 call	 compiler_nameop
  0019b	85 c0		 test	 eax, eax
  0019d	75 29		 jne	 SHORT $LN30@compiler_c
$LN29@compiler_c:
$LN28@compiler_c:

; 1681 :             Py_XDECREF(str);

  0019f	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$[rsp], 0
  001a5	74 0a		 je	 SHORT $LN25@compiler_c
  001a7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  001ac	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@compiler_c:
  001b1	33 c0		 xor	 eax, eax
  001b3	85 c0		 test	 eax, eax
  001b5	75 e8		 jne	 SHORT $LN28@compiler_c

; 1682 :             compiler_exit_scope(c);

  001b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  001bc	e8 00 00 00 00	 call	 compiler_exit_scope

; 1683 :             return 0;

  001c1	33 c0		 xor	 eax, eax
  001c3	e9 26 03 00 00	 jmp	 $LN45@compiler_c
$LN30@compiler_c:

; 1684 :         }
; 1685 :         Py_DECREF(str);

  001c8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  001cd	e8 00 00 00 00	 call	 _Py_DecRef

; 1686 :         /* store the __qualname__ */
; 1687 :         str = compiler_scope_qualname(c);

  001d2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  001d7	e8 00 00 00 00	 call	 compiler_scope_qualname
  001dc	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax

; 1688 :         if (!str) {

  001e1	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$[rsp], 0
  001e7	75 11		 jne	 SHORT $LN24@compiler_c

; 1689 :             compiler_exit_scope(c);

  001e9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  001ee	e8 00 00 00 00	 call	 compiler_exit_scope

; 1690 :             return 0;

  001f3	33 c0		 xor	 eax, eax
  001f5	e9 f4 02 00 00	 jmp	 $LN45@compiler_c
$LN24@compiler_c:

; 1691 :         }
; 1692 :         ADDOP_O(c, LOAD_CONST, str, consts);

  001fa	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  001ff	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00203	4c 8b 4c 24 48	 mov	 r9, QWORD PTR str$[rsp]
  00208	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  0020c	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00211	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00216	e8 00 00 00 00	 call	 compiler_addop_o
  0021b	85 c0		 test	 eax, eax
  0021d	75 07		 jne	 SHORT $LN23@compiler_c
  0021f	33 c0		 xor	 eax, eax
  00221	e9 c8 02 00 00	 jmp	 $LN45@compiler_c
$LN23@compiler_c:

; 1693 :         Py_DECREF(str);

  00226	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  0022b	e8 00 00 00 00	 call	 _Py_DecRef

; 1694 :         str = PyUnicode_InternFromString("__qualname__");

  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FMLGAKCE@__qualname__?$AA@
  00237	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0023c	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax

; 1695 :         if (!str || !compiler_nameop(c, str, Store)) {

  00241	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$[rsp], 0
  00247	74 19		 je	 SHORT $LN21@compiler_c
  00249	41 b8 02 00 00
	00		 mov	 r8d, 2
  0024f	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$[rsp]
  00254	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00259	e8 00 00 00 00	 call	 compiler_nameop
  0025e	85 c0		 test	 eax, eax
  00260	75 29		 jne	 SHORT $LN22@compiler_c
$LN21@compiler_c:
$LN20@compiler_c:

; 1696 :             Py_XDECREF(str);

  00262	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$[rsp], 0
  00268	74 0a		 je	 SHORT $LN17@compiler_c
  0026a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  0026f	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@compiler_c:
  00274	33 c0		 xor	 eax, eax
  00276	85 c0		 test	 eax, eax
  00278	75 e8		 jne	 SHORT $LN20@compiler_c

; 1697 :             compiler_exit_scope(c);

  0027a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0027f	e8 00 00 00 00	 call	 compiler_exit_scope

; 1698 :             return 0;

  00284	33 c0		 xor	 eax, eax
  00286	e9 63 02 00 00	 jmp	 $LN45@compiler_c
$LN22@compiler_c:

; 1699 :         }
; 1700 :         Py_DECREF(str);

  0028b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  00290	e8 00 00 00 00	 call	 _Py_DecRef

; 1701 :         /* compile the body proper */
; 1702 :         if (!compiler_body(c, s->v.ClassDef.body)) {

  00295	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  0029a	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  0029e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002a3	e8 00 00 00 00	 call	 compiler_body
  002a8	85 c0		 test	 eax, eax
  002aa	75 11		 jne	 SHORT $LN16@compiler_c

; 1703 :             compiler_exit_scope(c);

  002ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002b1	e8 00 00 00 00	 call	 compiler_exit_scope

; 1704 :             return 0;

  002b6	33 c0		 xor	 eax, eax
  002b8	e9 31 02 00 00	 jmp	 $LN45@compiler_c
$LN16@compiler_c:

; 1705 :         }
; 1706 :         /* return the (empty) __class__ cell */
; 1707 :         str = PyUnicode_InternFromString("__class__");

  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09LFGACEKG@__class__?$AA@
  002c4	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  002c9	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax

; 1708 :         if (str == NULL) {

  002ce	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$[rsp], 0
  002d4	75 11		 jne	 SHORT $LN15@compiler_c

; 1709 :             compiler_exit_scope(c);

  002d6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002db	e8 00 00 00 00	 call	 compiler_exit_scope

; 1710 :             return 0;

  002e0	33 c0		 xor	 eax, eax
  002e2	e9 07 02 00 00	 jmp	 $LN45@compiler_c
$LN15@compiler_c:

; 1711 :         }
; 1712 :         i = compiler_lookup_arg(c->u->u_cellvars, str);

  002e7	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  002ec	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  002f0	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$[rsp]
  002f5	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  002f9	e8 00 00 00 00	 call	 compiler_lookup_arg
  002fe	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax

; 1713 :         Py_DECREF(str);

  00302	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  00307	e8 00 00 00 00	 call	 _Py_DecRef

; 1714 :         if (i == -1) {

  0030c	83 7c 24 30 ff	 cmp	 DWORD PTR i$[rsp], -1
  00311	75 35		 jne	 SHORT $LN14@compiler_c

; 1715 :             /* This happens when nobody references the cell */
; 1716 :             PyErr_Clear();

  00313	e8 00 00 00 00	 call	 PyErr_Clear

; 1717 :             /* Return None */
; 1718 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00318	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0031d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00321	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00328	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  0032c	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00331	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00336	e8 00 00 00 00	 call	 compiler_addop_o
  0033b	85 c0		 test	 eax, eax
  0033d	75 07		 jne	 SHORT $LN13@compiler_c
  0033f	33 c0		 xor	 eax, eax
  00341	e9 a8 01 00 00	 jmp	 $LN45@compiler_c
$LN13@compiler_c:

; 1719 :         }
; 1720 :         else {

  00346	eb 1f		 jmp	 SHORT $LN12@compiler_c
$LN14@compiler_c:

; 1721 :             /* Return the cell where to store __class__ */
; 1722 :             ADDOP_I(c, LOAD_CLOSURE, i);

  00348	44 8b 44 24 30	 mov	 r8d, DWORD PTR i$[rsp]
  0034d	ba 87 00 00 00	 mov	 edx, 135		; 00000087H
  00352	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00357	e8 00 00 00 00	 call	 compiler_addop_i
  0035c	85 c0		 test	 eax, eax
  0035e	75 07		 jne	 SHORT $LN11@compiler_c
  00360	33 c0		 xor	 eax, eax
  00362	e9 87 01 00 00	 jmp	 $LN45@compiler_c
$LN11@compiler_c:
$LN12@compiler_c:

; 1723 :         }
; 1724 :         ADDOP_IN_SCOPE(c, RETURN_VALUE);

  00367	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  0036c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00371	e8 00 00 00 00	 call	 compiler_addop
  00376	85 c0		 test	 eax, eax
  00378	75 11		 jne	 SHORT $LN10@compiler_c
  0037a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0037f	e8 00 00 00 00	 call	 compiler_exit_scope
  00384	33 c0		 xor	 eax, eax
  00386	e9 63 01 00 00	 jmp	 $LN45@compiler_c
$LN10@compiler_c:

; 1725 :         /* create the code object */
; 1726 :         co = assemble(c, 1);

  0038b	ba 01 00 00 00	 mov	 edx, 1
  00390	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00395	e8 00 00 00 00	 call	 assemble
  0039a	48 89 44 24 40	 mov	 QWORD PTR co$[rsp], rax

; 1727 :     }
; 1728 :     /* leave the new scope */
; 1729 :     compiler_exit_scope(c);

  0039f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  003a4	e8 00 00 00 00	 call	 compiler_exit_scope

; 1730 :     if (co == NULL)

  003a9	48 83 7c 24 40
	00		 cmp	 QWORD PTR co$[rsp], 0
  003af	75 07		 jne	 SHORT $LN9@compiler_c

; 1731 :         return 0;

  003b1	33 c0		 xor	 eax, eax
  003b3	e9 36 01 00 00	 jmp	 $LN45@compiler_c
$LN9@compiler_c:

; 1732 : 
; 1733 :     /* 2. load the 'build_class' function */
; 1734 :     ADDOP(c, LOAD_BUILD_CLASS);

  003b8	ba 47 00 00 00	 mov	 edx, 71			; 00000047H
  003bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  003c2	e8 00 00 00 00	 call	 compiler_addop
  003c7	85 c0		 test	 eax, eax
  003c9	75 07		 jne	 SHORT $LN8@compiler_c
  003cb	33 c0		 xor	 eax, eax
  003cd	e9 1c 01 00 00	 jmp	 $LN45@compiler_c
$LN8@compiler_c:

; 1735 : 
; 1736 :     /* 3. load a function (or closure) made from the code object */
; 1737 :     compiler_make_closure(c, co, 0, NULL);

  003d2	45 33 c9	 xor	 r9d, r9d
  003d5	45 33 c0	 xor	 r8d, r8d
  003d8	48 8b 54 24 40	 mov	 rdx, QWORD PTR co$[rsp]
  003dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  003e2	e8 00 00 00 00	 call	 compiler_make_closure

; 1738 :     Py_DECREF(co);

  003e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR co$[rsp]
  003ec	e8 00 00 00 00	 call	 _Py_DecRef

; 1739 : 
; 1740 :     /* 4. load class name */
; 1741 :     ADDOP_O(c, LOAD_CONST, s->v.ClassDef.name, consts);

  003f1	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  003f6	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  003fa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  003ff	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]
  00403	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00407	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0040c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00411	e8 00 00 00 00	 call	 compiler_addop_o
  00416	85 c0		 test	 eax, eax
  00418	75 07		 jne	 SHORT $LN7@compiler_c
  0041a	33 c0		 xor	 eax, eax
  0041c	e9 cd 00 00 00	 jmp	 $LN45@compiler_c
$LN7@compiler_c:

; 1742 : 
; 1743 :     /* 5. generate the rest of the code for the call */
; 1744 :     if (!compiler_call_helper(c, 2,
; 1745 :                               s->v.ClassDef.bases,
; 1746 :                               s->v.ClassDef.keywords,
; 1747 :                               s->v.ClassDef.starargs,
; 1748 :                               s->v.ClassDef.kwargs))

  00421	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00426	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0042a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0042f	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00434	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00438	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043d	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00442	4c 8b 48 18	 mov	 r9, QWORD PTR [rax+24]
  00446	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  0044b	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  0044f	ba 02 00 00 00	 mov	 edx, 2
  00454	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00459	e8 00 00 00 00	 call	 compiler_call_helper
  0045e	85 c0		 test	 eax, eax
  00460	75 07		 jne	 SHORT $LN6@compiler_c

; 1749 :         return 0;

  00462	33 c0		 xor	 eax, eax
  00464	e9 85 00 00 00	 jmp	 $LN45@compiler_c
$LN6@compiler_c:

; 1750 : 
; 1751 :     /* 6. apply decorators */
; 1752 :     for (i = 0; i < asdl_seq_LEN(decos); i++) {

  00469	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00471	eb 0a		 jmp	 SHORT $LN5@compiler_c
$LN4@compiler_c:
  00473	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00477	ff c0		 inc	 eax
  00479	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN5@compiler_c:
  0047d	48 83 7c 24 38
	00		 cmp	 QWORD PTR decos$[rsp], 0
  00483	75 0b		 jne	 SHORT $LN47@compiler_c
  00485	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv259[rsp], 0
  0048e	eb 0d		 jmp	 SHORT $LN48@compiler_c
$LN47@compiler_c:
  00490	48 8b 44 24 38	 mov	 rax, QWORD PTR decos$[rsp]
  00495	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00498	48 89 44 24 50	 mov	 QWORD PTR tv259[rsp], rax
$LN48@compiler_c:
  0049d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004a2	48 3b 44 24 50	 cmp	 rax, QWORD PTR tv259[rsp]
  004a7	7d 1f		 jge	 SHORT $LN3@compiler_c

; 1753 :         ADDOP_I(c, CALL_FUNCTION, 1);

  004a9	41 b8 01 00 00
	00		 mov	 r8d, 1
  004af	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  004b4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  004b9	e8 00 00 00 00	 call	 compiler_addop_i
  004be	85 c0		 test	 eax, eax
  004c0	75 04		 jne	 SHORT $LN2@compiler_c
  004c2	33 c0		 xor	 eax, eax
  004c4	eb 28		 jmp	 SHORT $LN45@compiler_c
$LN2@compiler_c:

; 1754 :     }

  004c6	eb ab		 jmp	 SHORT $LN4@compiler_c
$LN3@compiler_c:

; 1755 : 
; 1756 :     /* 7. store into <name> */
; 1757 :     if (!compiler_nameop(c, s->v.ClassDef.name, Store))

  004c8	41 b8 02 00 00
	00		 mov	 r8d, 2
  004ce	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  004d3	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  004d7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  004dc	e8 00 00 00 00	 call	 compiler_nameop
  004e1	85 c0		 test	 eax, eax
  004e3	75 04		 jne	 SHORT $LN1@compiler_c

; 1758 :         return 0;

  004e5	33 c0		 xor	 eax, eax
  004e7	eb 05		 jmp	 SHORT $LN45@compiler_c
$LN1@compiler_c:

; 1759 :     return 1;

  004e9	b8 01 00 00 00	 mov	 eax, 1
$LN45@compiler_c:

; 1760 : }

  004ee	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004f2	c3		 ret	 0
compiler_class ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CG@CFPJGHCI@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAf?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_if DD imagerel compiler_if
	DD	imagerel compiler_if+991
	DD	imagerel $unwind$compiler_if
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_if DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_1CG@CFPJGHCI@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAf?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@CFPJGHCI@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAf?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 's'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'f', 00H, '_'
	DB	00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_if
_TEXT	SEGMENT
next$ = 32
end$ = 40
constant$ = 48
_i$23443 = 52
seq$23444 = 56
elt$23449 = 64
_i$23454 = 72
seq$23455 = 80
elt$23460 = 88
_i$23470 = 96
seq$23471 = 104
elt$23476 = 112
_i$23481 = 120
seq$23482 = 128
elt$23487 = 136
tv83 = 144
tv130 = 152
tv160 = 160
tv184 = 168
c$ = 192
s$ = 200
compiler_if PROC					; COMDAT

; 1843 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1844 :     basicblock *end, *next;
; 1845 :     int constant;
; 1846 :     assert(s->kind == If_kind);

  00011	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00019	83 38 09	 cmp	 DWORD PTR [rax], 9
  0001c	74 1c		 je	 SHORT $LN32@compiler_i@3
  0001e	41 b8 36 07 00
	00		 mov	 r8d, 1846		; 00000736H
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@CFPJGHCI@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAf?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00038	33 c0		 xor	 eax, eax
$LN32@compiler_i@3:

; 1847 :     end = compiler_new_block(c);

  0003a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00042	e8 00 00 00 00	 call	 compiler_new_block
  00047	48 89 44 24 28	 mov	 QWORD PTR end$[rsp], rax

; 1848 :     if (end == NULL)

  0004c	48 83 7c 24 28
	00		 cmp	 QWORD PTR end$[rsp], 0
  00052	75 07		 jne	 SHORT $LN29@compiler_i@3

; 1849 :         return 0;

  00054	33 c0		 xor	 eax, eax
  00056	e9 7c 03 00 00	 jmp	 $LN30@compiler_i@3
$LN29@compiler_i@3:

; 1850 : 
; 1851 :     constant = expr_constant(c, s->v.If.test);

  0005b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00063	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00067	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0006f	e8 00 00 00 00	 call	 expr_constant
  00074	89 44 24 30	 mov	 DWORD PTR constant$[rsp], eax

; 1852 :     /* constant = 0: "if 0"
; 1853 :      * constant = 1: "if 1", "if 2", ...
; 1854 :      * constant = -1: rest */
; 1855 :     if (constant == 0) {

  00078	83 7c 24 30 00	 cmp	 DWORD PTR constant$[rsp], 0
  0007d	0f 85 a5 00 00
	00		 jne	 $LN28@compiler_i@3

; 1856 :         if (s->v.If.orelse)

  00083	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0008b	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00090	0f 84 8d 00 00
	00		 je	 $LN27@compiler_i@3

; 1857 :             VISIT_SEQ(c, stmt, s->v.If.orelse);

  00096	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0009e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a2	48 89 44 24 38	 mov	 QWORD PTR seq$23444[rsp], rax
  000a7	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _i$23443[rsp], 0
  000af	eb 0a		 jmp	 SHORT $LN26@compiler_i@3
$LN25@compiler_i@3:
  000b1	8b 44 24 34	 mov	 eax, DWORD PTR _i$23443[rsp]
  000b5	ff c0		 inc	 eax
  000b7	89 44 24 34	 mov	 DWORD PTR _i$23443[rsp], eax
$LN26@compiler_i@3:
  000bb	48 83 7c 24 38
	00		 cmp	 QWORD PTR seq$23444[rsp], 0
  000c1	75 0e		 jne	 SHORT $LN33@compiler_i@3
  000c3	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv83[rsp], 0
  000cf	eb 10		 jmp	 SHORT $LN34@compiler_i@3
$LN33@compiler_i@3:
  000d1	48 8b 44 24 38	 mov	 rax, QWORD PTR seq$23444[rsp]
  000d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d9	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv83[rsp], rax
$LN34@compiler_i@3:
  000e1	48 63 44 24 34	 movsxd	 rax, DWORD PTR _i$23443[rsp]
  000e6	48 3b 84 24 90
	00 00 00	 cmp	 rax, QWORD PTR tv83[rsp]
  000ee	7d 33		 jge	 SHORT $LN24@compiler_i@3
  000f0	48 63 44 24 34	 movsxd	 rax, DWORD PTR _i$23443[rsp]
  000f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$23444[rsp]
  000fa	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  000ff	48 89 44 24 40	 mov	 QWORD PTR elt$23449[rsp], rax
  00104	48 8b 54 24 40	 mov	 rdx, QWORD PTR elt$23449[rsp]
  00109	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00111	e8 00 00 00 00	 call	 compiler_visit_stmt
  00116	85 c0		 test	 eax, eax
  00118	75 07		 jne	 SHORT $LN23@compiler_i@3
  0011a	33 c0		 xor	 eax, eax
  0011c	e9 b6 02 00 00	 jmp	 $LN30@compiler_i@3
$LN23@compiler_i@3:
  00121	eb 8e		 jmp	 SHORT $LN25@compiler_i@3
$LN24@compiler_i@3:
$LN27@compiler_i@3:
  00123	e9 98 02 00 00	 jmp	 $LN22@compiler_i@3
$LN28@compiler_i@3:

; 1858 :     } else if (constant == 1) {

  00128	83 7c 24 30 01	 cmp	 DWORD PTR constant$[rsp], 1
  0012d	0f 85 92 00 00
	00		 jne	 $LN21@compiler_i@3

; 1859 :         VISIT_SEQ(c, stmt, s->v.If.body);

  00133	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0013b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0013f	48 89 44 24 50	 mov	 QWORD PTR seq$23455[rsp], rax
  00144	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR _i$23454[rsp], 0
  0014c	eb 0a		 jmp	 SHORT $LN20@compiler_i@3
$LN19@compiler_i@3:
  0014e	8b 44 24 48	 mov	 eax, DWORD PTR _i$23454[rsp]
  00152	ff c0		 inc	 eax
  00154	89 44 24 48	 mov	 DWORD PTR _i$23454[rsp], eax
$LN20@compiler_i@3:
  00158	48 83 7c 24 50
	00		 cmp	 QWORD PTR seq$23455[rsp], 0
  0015e	75 0e		 jne	 SHORT $LN35@compiler_i@3
  00160	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv130[rsp], 0
  0016c	eb 10		 jmp	 SHORT $LN36@compiler_i@3
$LN35@compiler_i@3:
  0016e	48 8b 44 24 50	 mov	 rax, QWORD PTR seq$23455[rsp]
  00173	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00176	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv130[rsp], rax
$LN36@compiler_i@3:
  0017e	48 63 44 24 48	 movsxd	 rax, DWORD PTR _i$23454[rsp]
  00183	48 3b 84 24 98
	00 00 00	 cmp	 rax, QWORD PTR tv130[rsp]
  0018b	7d 33		 jge	 SHORT $LN18@compiler_i@3
  0018d	48 63 44 24 48	 movsxd	 rax, DWORD PTR _i$23454[rsp]
  00192	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq$23455[rsp]
  00197	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  0019c	48 89 44 24 58	 mov	 QWORD PTR elt$23460[rsp], rax
  001a1	48 8b 54 24 58	 mov	 rdx, QWORD PTR elt$23460[rsp]
  001a6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001ae	e8 00 00 00 00	 call	 compiler_visit_stmt
  001b3	85 c0		 test	 eax, eax
  001b5	75 07		 jne	 SHORT $LN17@compiler_i@3
  001b7	33 c0		 xor	 eax, eax
  001b9	e9 19 02 00 00	 jmp	 $LN30@compiler_i@3
$LN17@compiler_i@3:
  001be	eb 8e		 jmp	 SHORT $LN19@compiler_i@3
$LN18@compiler_i@3:

; 1860 :     } else {

  001c0	e9 fb 01 00 00	 jmp	 $LN16@compiler_i@3
$LN21@compiler_i@3:

; 1861 :         if (s->v.If.orelse) {

  001c5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001cd	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  001d2	74 23		 je	 SHORT $LN15@compiler_i@3

; 1862 :             next = compiler_new_block(c);

  001d4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001dc	e8 00 00 00 00	 call	 compiler_new_block
  001e1	48 89 44 24 20	 mov	 QWORD PTR next$[rsp], rax

; 1863 :             if (next == NULL)

  001e6	48 83 7c 24 20
	00		 cmp	 QWORD PTR next$[rsp], 0
  001ec	75 07		 jne	 SHORT $LN14@compiler_i@3

; 1864 :                 return 0;

  001ee	33 c0		 xor	 eax, eax
  001f0	e9 e2 01 00 00	 jmp	 $LN30@compiler_i@3
$LN14@compiler_i@3:

; 1865 :         }
; 1866 :         else

  001f5	eb 0a		 jmp	 SHORT $LN13@compiler_i@3
$LN15@compiler_i@3:

; 1867 :             next = end;

  001f7	48 8b 44 24 28	 mov	 rax, QWORD PTR end$[rsp]
  001fc	48 89 44 24 20	 mov	 QWORD PTR next$[rsp], rax
$LN13@compiler_i@3:

; 1868 :         VISIT(c, expr, s->v.If.test);

  00201	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00209	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0020d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00215	e8 00 00 00 00	 call	 compiler_visit_expr
  0021a	85 c0		 test	 eax, eax
  0021c	75 07		 jne	 SHORT $LN12@compiler_i@3
  0021e	33 c0		 xor	 eax, eax
  00220	e9 b2 01 00 00	 jmp	 $LN30@compiler_i@3
$LN12@compiler_i@3:

; 1869 :         ADDOP_JABS(c, POP_JUMP_IF_FALSE, next);

  00225	41 b9 01 00 00
	00		 mov	 r9d, 1
  0022b	4c 8b 44 24 20	 mov	 r8, QWORD PTR next$[rsp]
  00230	ba 72 00 00 00	 mov	 edx, 114		; 00000072H
  00235	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0023d	e8 00 00 00 00	 call	 compiler_addop_j
  00242	85 c0		 test	 eax, eax
  00244	75 07		 jne	 SHORT $LN11@compiler_i@3
  00246	33 c0		 xor	 eax, eax
  00248	e9 8a 01 00 00	 jmp	 $LN30@compiler_i@3
$LN11@compiler_i@3:

; 1870 :         VISIT_SEQ(c, stmt, s->v.If.body);

  0024d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00255	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00259	48 89 44 24 68	 mov	 QWORD PTR seq$23471[rsp], rax
  0025e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR _i$23470[rsp], 0
  00266	eb 0a		 jmp	 SHORT $LN10@compiler_i@3
$LN9@compiler_i@3:
  00268	8b 44 24 60	 mov	 eax, DWORD PTR _i$23470[rsp]
  0026c	ff c0		 inc	 eax
  0026e	89 44 24 60	 mov	 DWORD PTR _i$23470[rsp], eax
$LN10@compiler_i@3:
  00272	48 83 7c 24 68
	00		 cmp	 QWORD PTR seq$23471[rsp], 0
  00278	75 0e		 jne	 SHORT $LN37@compiler_i@3
  0027a	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv160[rsp], 0
  00286	eb 10		 jmp	 SHORT $LN38@compiler_i@3
$LN37@compiler_i@3:
  00288	48 8b 44 24 68	 mov	 rax, QWORD PTR seq$23471[rsp]
  0028d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00290	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
$LN38@compiler_i@3:
  00298	48 63 44 24 60	 movsxd	 rax, DWORD PTR _i$23470[rsp]
  0029d	48 3b 84 24 a0
	00 00 00	 cmp	 rax, QWORD PTR tv160[rsp]
  002a5	7d 33		 jge	 SHORT $LN8@compiler_i@3
  002a7	48 63 44 24 60	 movsxd	 rax, DWORD PTR _i$23470[rsp]
  002ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR seq$23471[rsp]
  002b1	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  002b6	48 89 44 24 70	 mov	 QWORD PTR elt$23476[rsp], rax
  002bb	48 8b 54 24 70	 mov	 rdx, QWORD PTR elt$23476[rsp]
  002c0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002c8	e8 00 00 00 00	 call	 compiler_visit_stmt
  002cd	85 c0		 test	 eax, eax
  002cf	75 07		 jne	 SHORT $LN7@compiler_i@3
  002d1	33 c0		 xor	 eax, eax
  002d3	e9 ff 00 00 00	 jmp	 $LN30@compiler_i@3
$LN7@compiler_i@3:
  002d8	eb 8e		 jmp	 SHORT $LN9@compiler_i@3
$LN8@compiler_i@3:

; 1871 :         ADDOP_JREL(c, JUMP_FORWARD, end);

  002da	45 33 c9	 xor	 r9d, r9d
  002dd	4c 8b 44 24 28	 mov	 r8, QWORD PTR end$[rsp]
  002e2	ba 6e 00 00 00	 mov	 edx, 110		; 0000006eH
  002e7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002ef	e8 00 00 00 00	 call	 compiler_addop_j
  002f4	85 c0		 test	 eax, eax
  002f6	75 07		 jne	 SHORT $LN6@compiler_i@3
  002f8	33 c0		 xor	 eax, eax
  002fa	e9 d8 00 00 00	 jmp	 $LN30@compiler_i@3
$LN6@compiler_i@3:

; 1872 :         if (s->v.If.orelse) {

  002ff	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00307	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0030c	0f 84 ae 00 00
	00		 je	 $LN5@compiler_i@3

; 1873 :             compiler_use_next_block(c, next);

  00312	48 8b 54 24 20	 mov	 rdx, QWORD PTR next$[rsp]
  00317	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0031f	e8 00 00 00 00	 call	 compiler_use_next_block

; 1874 :             VISIT_SEQ(c, stmt, s->v.If.orelse);

  00324	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0032c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00330	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR seq$23482[rsp], rax
  00338	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR _i$23481[rsp], 0
  00340	eb 0a		 jmp	 SHORT $LN4@compiler_i@3
$LN3@compiler_i@3:
  00342	8b 44 24 78	 mov	 eax, DWORD PTR _i$23481[rsp]
  00346	ff c0		 inc	 eax
  00348	89 44 24 78	 mov	 DWORD PTR _i$23481[rsp], eax
$LN4@compiler_i@3:
  0034c	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR seq$23482[rsp], 0
  00355	75 0e		 jne	 SHORT $LN39@compiler_i@3
  00357	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv184[rsp], 0
  00363	eb 13		 jmp	 SHORT $LN40@compiler_i@3
$LN39@compiler_i@3:
  00365	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR seq$23482[rsp]
  0036d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00370	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv184[rsp], rax
$LN40@compiler_i@3:
  00378	48 63 44 24 78	 movsxd	 rax, DWORD PTR _i$23481[rsp]
  0037d	48 3b 84 24 a8
	00 00 00	 cmp	 rax, QWORD PTR tv184[rsp]
  00385	7d 39		 jge	 SHORT $LN2@compiler_i@3
  00387	48 63 44 24 78	 movsxd	 rax, DWORD PTR _i$23481[rsp]
  0038c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR seq$23482[rsp]
  00394	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00399	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR elt$23487[rsp], rax
  003a1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR elt$23487[rsp]
  003a9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003b1	e8 00 00 00 00	 call	 compiler_visit_stmt
  003b6	85 c0		 test	 eax, eax
  003b8	75 04		 jne	 SHORT $LN1@compiler_i@3
  003ba	33 c0		 xor	 eax, eax
  003bc	eb 19		 jmp	 SHORT $LN30@compiler_i@3
$LN1@compiler_i@3:
  003be	eb 82		 jmp	 SHORT $LN3@compiler_i@3
$LN2@compiler_i@3:
$LN5@compiler_i@3:
$LN16@compiler_i@3:
$LN22@compiler_i@3:

; 1875 :         }
; 1876 :     }
; 1877 :     compiler_use_next_block(c, end);

  003c0	48 8b 54 24 28	 mov	 rdx, QWORD PTR end$[rsp]
  003c5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003cd	e8 00 00 00 00	 call	 compiler_use_next_block

; 1878 :     return 1;

  003d2	b8 01 00 00 00	 mov	 eax, 1
$LN30@compiler_i@3:

; 1879 : }

  003d7	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003de	c3		 ret	 0
compiler_if ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BM@JKLHNIPD@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_use_next_block DD imagerel compiler_use_next_block
	DD	imagerel compiler_use_next_block+100
	DD	imagerel $unwind$compiler_use_next_block
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_use_next_block DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_1BM@JKLHNIPD@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@JKLHNIPD@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_use_next_block
_TEXT	SEGMENT
c$ = 48
block$ = 56
compiler_use_next_block PROC				; COMDAT

; 709  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 710  :     assert(block != NULL);

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR block$[rsp], 0
  00014	75 1c		 jne	 SHORT $LN3@compiler_u@4
  00016	41 b8 c6 02 00
	00		 mov	 r8d, 710		; 000002c6H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@JKLHNIPD@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN3@compiler_u@4:

; 711  :     c->u->u_curblock->b_next = block;

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  00037	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0003b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR block$[rsp]
  00044	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 712  :     c->u->u_curblock = block;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  0004d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00051	48 8b 4c 24 38	 mov	 rcx, QWORD PTR block$[rsp]
  00056	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 713  :     return block;

  0005a	48 8b 44 24 38	 mov	 rax, QWORD PTR block$[rsp]

; 714  : }

  0005f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00063	c3		 ret	 0
compiler_use_next_block ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_addop_j DD imagerel compiler_addop_j
	DD	imagerel compiler_addop_j+245
	DD	imagerel $unwind$compiler_addop_j
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_addop_j DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_addop_j
_TEXT	SEGMENT
i$ = 32
off$ = 40
c$ = 64
opcode$ = 72
b$ = 80
absolute$ = 88
compiler_addop_j PROC					; COMDAT

; 1128 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1129 :     struct instr *i;
; 1130 :     int off;
; 1131 : 
; 1132 :     assert(b != NULL);

  00017	48 83 7c 24 50
	00		 cmp	 QWORD PTR b$[rsp], 0
  0001d	75 1c		 jne	 SHORT $LN6@compiler_a@5
  0001f	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@MBABLIAL@?$AAb?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00039	33 c0		 xor	 eax, eax
$LN6@compiler_a@5:

; 1133 :     off = compiler_next_instr(c, c->u->u_curblock);

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00040	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00044	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0004d	e8 00 00 00 00	 call	 compiler_next_instr
  00052	89 44 24 28	 mov	 DWORD PTR off$[rsp], eax

; 1134 :     if (off < 0)

  00056	83 7c 24 28 00	 cmp	 DWORD PTR off$[rsp], 0
  0005b	7d 07		 jge	 SHORT $LN3@compiler_a@5

; 1135 :         return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	e9 8c 00 00 00	 jmp	 $LN4@compiler_a@5
$LN3@compiler_a@5:

; 1136 :     i = &c->u->u_curblock->b_instr[off];

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00069	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0006d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00071	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR off$[rsp]
  00076	48 6b c9 20	 imul	 rcx, 32			; 00000020H
  0007a	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 1137 :     i->i_opcode = opcode;

  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0008b	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR opcode$[rsp]
  00090	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1138 :     i->i_target = b;

  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00098	48 8b 4c 24 50	 mov	 rcx, QWORD PTR b$[rsp]
  0009d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1139 :     i->i_hasarg = 1;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000a6	8b 00		 mov	 eax, DWORD PTR [rax]
  000a8	83 c8 04	 or	 eax, 4
  000ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000b0	89 01		 mov	 DWORD PTR [rcx], eax

; 1140 :     if (absolute)

  000b2	83 7c 24 58 00	 cmp	 DWORD PTR absolute$[rsp], 0
  000b7	74 13		 je	 SHORT $LN2@compiler_a@5

; 1141 :         i->i_jabs = 1;

  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000be	8b 00		 mov	 eax, DWORD PTR [rax]
  000c0	83 c8 01	 or	 eax, 1
  000c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000c8	89 01		 mov	 DWORD PTR [rcx], eax

; 1142 :     else

  000ca	eb 11		 jmp	 SHORT $LN1@compiler_a@5
$LN2@compiler_a@5:

; 1143 :         i->i_jrel = 1;

  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000d1	8b 00		 mov	 eax, DWORD PTR [rax]
  000d3	83 c8 02	 or	 eax, 2
  000d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000db	89 01		 mov	 DWORD PTR [rcx], eax
$LN1@compiler_a@5:

; 1144 :     compiler_set_lineno(c, off);

  000dd	8b 54 24 28	 mov	 edx, DWORD PTR off$[rsp]
  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000e6	e8 00 00 00 00	 call	 compiler_set_lineno

; 1145 :     return 1;

  000eb	b8 01 00 00 00	 mov	 eax, 1
$LN4@compiler_a@5:

; 1146 : }

  000f0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f4	c3		 ret	 0
compiler_addop_j ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_for DD imagerel compiler_for
	DD	imagerel compiler_for+725
	DD	imagerel $unwind$compiler_for
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_for DD 021101H
	DD	0110111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_for
_TEXT	SEGMENT
cleanup$ = 32
end$ = 40
start$ = 48
_i$23510 = 56
seq$23511 = 64
elt$23516 = 72
_i$23521 = 80
seq$23522 = 88
elt$23527 = 96
tv142 = 104
tv171 = 112
c$ = 144
s$ = 152
compiler_for PROC					; COMDAT

; 1883 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1884 :     basicblock *start, *cleanup, *end;
; 1885 : 
; 1886 :     start = compiler_new_block(c);

  00011	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00019	e8 00 00 00 00	 call	 compiler_new_block
  0001e	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax

; 1887 :     cleanup = compiler_new_block(c);

  00023	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0002b	e8 00 00 00 00	 call	 compiler_new_block
  00030	48 89 44 24 20	 mov	 QWORD PTR cleanup$[rsp], rax

; 1888 :     end = compiler_new_block(c);

  00035	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0003d	e8 00 00 00 00	 call	 compiler_new_block
  00042	48 89 44 24 28	 mov	 QWORD PTR end$[rsp], rax

; 1889 :     if (start == NULL || end == NULL || cleanup == NULL)

  00047	48 83 7c 24 30
	00		 cmp	 QWORD PTR start$[rsp], 0
  0004d	74 10		 je	 SHORT $LN17@compiler_f@3
  0004f	48 83 7c 24 28
	00		 cmp	 QWORD PTR end$[rsp], 0
  00055	74 08		 je	 SHORT $LN17@compiler_f@3
  00057	48 83 7c 24 20
	00		 cmp	 QWORD PTR cleanup$[rsp], 0
  0005d	75 07		 jne	 SHORT $LN18@compiler_f@3
$LN17@compiler_f@3:

; 1890 :         return 0;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 67 02 00 00	 jmp	 $LN19@compiler_f@3
$LN18@compiler_f@3:

; 1891 :     ADDOP_JREL(c, SETUP_LOOP, end);

  00066	45 33 c9	 xor	 r9d, r9d
  00069	4c 8b 44 24 28	 mov	 r8, QWORD PTR end$[rsp]
  0006e	ba 78 00 00 00	 mov	 edx, 120		; 00000078H
  00073	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0007b	e8 00 00 00 00	 call	 compiler_addop_j
  00080	85 c0		 test	 eax, eax
  00082	75 07		 jne	 SHORT $LN16@compiler_f@3
  00084	33 c0		 xor	 eax, eax
  00086	e9 42 02 00 00	 jmp	 $LN19@compiler_f@3
$LN16@compiler_f@3:

; 1892 :     if (!compiler_push_fblock(c, LOOP, start))

  0008b	4c 8b 44 24 30	 mov	 r8, QWORD PTR start$[rsp]
  00090	33 d2		 xor	 edx, edx
  00092	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0009a	e8 00 00 00 00	 call	 compiler_push_fblock
  0009f	85 c0		 test	 eax, eax
  000a1	75 07		 jne	 SHORT $LN15@compiler_f@3

; 1893 :         return 0;

  000a3	33 c0		 xor	 eax, eax
  000a5	e9 23 02 00 00	 jmp	 $LN19@compiler_f@3
$LN15@compiler_f@3:

; 1894 :     VISIT(c, expr, s->v.For.iter);

  000aa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b2	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000b6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000be	e8 00 00 00 00	 call	 compiler_visit_expr
  000c3	85 c0		 test	 eax, eax
  000c5	75 07		 jne	 SHORT $LN14@compiler_f@3
  000c7	33 c0		 xor	 eax, eax
  000c9	e9 ff 01 00 00	 jmp	 $LN19@compiler_f@3
$LN14@compiler_f@3:

; 1895 :     ADDOP(c, GET_ITER);

  000ce	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  000d3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000db	e8 00 00 00 00	 call	 compiler_addop
  000e0	85 c0		 test	 eax, eax
  000e2	75 07		 jne	 SHORT $LN13@compiler_f@3
  000e4	33 c0		 xor	 eax, eax
  000e6	e9 e2 01 00 00	 jmp	 $LN19@compiler_f@3
$LN13@compiler_f@3:

; 1896 :     compiler_use_next_block(c, start);

  000eb	48 8b 54 24 30	 mov	 rdx, QWORD PTR start$[rsp]
  000f0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000f8	e8 00 00 00 00	 call	 compiler_use_next_block

; 1897 :     ADDOP_JREL(c, FOR_ITER, cleanup);

  000fd	45 33 c9	 xor	 r9d, r9d
  00100	4c 8b 44 24 20	 mov	 r8, QWORD PTR cleanup$[rsp]
  00105	ba 5d 00 00 00	 mov	 edx, 93			; 0000005dH
  0010a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00112	e8 00 00 00 00	 call	 compiler_addop_j
  00117	85 c0		 test	 eax, eax
  00119	75 07		 jne	 SHORT $LN12@compiler_f@3
  0011b	33 c0		 xor	 eax, eax
  0011d	e9 ab 01 00 00	 jmp	 $LN19@compiler_f@3
$LN12@compiler_f@3:

; 1898 :     VISIT(c, expr, s->v.For.target);

  00122	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0012a	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0012e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00136	e8 00 00 00 00	 call	 compiler_visit_expr
  0013b	85 c0		 test	 eax, eax
  0013d	75 07		 jne	 SHORT $LN11@compiler_f@3
  0013f	33 c0		 xor	 eax, eax
  00141	e9 87 01 00 00	 jmp	 $LN19@compiler_f@3
$LN11@compiler_f@3:

; 1899 :     VISIT_SEQ(c, stmt, s->v.For.body);

  00146	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0014e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00152	48 89 44 24 40	 mov	 QWORD PTR seq$23511[rsp], rax
  00157	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _i$23510[rsp], 0
  0015f	eb 0a		 jmp	 SHORT $LN10@compiler_f@3
$LN9@compiler_f@3:
  00161	8b 44 24 38	 mov	 eax, DWORD PTR _i$23510[rsp]
  00165	ff c0		 inc	 eax
  00167	89 44 24 38	 mov	 DWORD PTR _i$23510[rsp], eax
$LN10@compiler_f@3:
  0016b	48 83 7c 24 40
	00		 cmp	 QWORD PTR seq$23511[rsp], 0
  00171	75 0b		 jne	 SHORT $LN21@compiler_f@3
  00173	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv142[rsp], 0
  0017c	eb 0d		 jmp	 SHORT $LN22@compiler_f@3
$LN21@compiler_f@3:
  0017e	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$23511[rsp]
  00183	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00186	48 89 44 24 68	 mov	 QWORD PTR tv142[rsp], rax
$LN22@compiler_f@3:
  0018b	48 63 44 24 38	 movsxd	 rax, DWORD PTR _i$23510[rsp]
  00190	48 3b 44 24 68	 cmp	 rax, QWORD PTR tv142[rsp]
  00195	7d 33		 jge	 SHORT $LN8@compiler_f@3
  00197	48 63 44 24 38	 movsxd	 rax, DWORD PTR _i$23510[rsp]
  0019c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$23511[rsp]
  001a1	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  001a6	48 89 44 24 48	 mov	 QWORD PTR elt$23516[rsp], rax
  001ab	48 8b 54 24 48	 mov	 rdx, QWORD PTR elt$23516[rsp]
  001b0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001b8	e8 00 00 00 00	 call	 compiler_visit_stmt
  001bd	85 c0		 test	 eax, eax
  001bf	75 07		 jne	 SHORT $LN7@compiler_f@3
  001c1	33 c0		 xor	 eax, eax
  001c3	e9 05 01 00 00	 jmp	 $LN19@compiler_f@3
$LN7@compiler_f@3:
  001c8	eb 97		 jmp	 SHORT $LN9@compiler_f@3
$LN8@compiler_f@3:

; 1900 :     ADDOP_JABS(c, JUMP_ABSOLUTE, start);

  001ca	41 b9 01 00 00
	00		 mov	 r9d, 1
  001d0	4c 8b 44 24 30	 mov	 r8, QWORD PTR start$[rsp]
  001d5	ba 71 00 00 00	 mov	 edx, 113		; 00000071H
  001da	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001e2	e8 00 00 00 00	 call	 compiler_addop_j
  001e7	85 c0		 test	 eax, eax
  001e9	75 07		 jne	 SHORT $LN6@compiler_f@3
  001eb	33 c0		 xor	 eax, eax
  001ed	e9 db 00 00 00	 jmp	 $LN19@compiler_f@3
$LN6@compiler_f@3:

; 1901 :     compiler_use_next_block(c, cleanup);

  001f2	48 8b 54 24 20	 mov	 rdx, QWORD PTR cleanup$[rsp]
  001f7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001ff	e8 00 00 00 00	 call	 compiler_use_next_block

; 1902 :     ADDOP(c, POP_BLOCK);

  00204	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  00209	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00211	e8 00 00 00 00	 call	 compiler_addop
  00216	85 c0		 test	 eax, eax
  00218	75 07		 jne	 SHORT $LN5@compiler_f@3
  0021a	33 c0		 xor	 eax, eax
  0021c	e9 ac 00 00 00	 jmp	 $LN19@compiler_f@3
$LN5@compiler_f@3:

; 1903 :     compiler_pop_fblock(c, LOOP, start);

  00221	4c 8b 44 24 30	 mov	 r8, QWORD PTR start$[rsp]
  00226	33 d2		 xor	 edx, edx
  00228	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00230	e8 00 00 00 00	 call	 compiler_pop_fblock

; 1904 :     VISIT_SEQ(c, stmt, s->v.For.orelse);

  00235	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0023d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00241	48 89 44 24 58	 mov	 QWORD PTR seq$23522[rsp], rax
  00246	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _i$23521[rsp], 0
  0024e	eb 0a		 jmp	 SHORT $LN4@compiler_f@3
$LN3@compiler_f@3:
  00250	8b 44 24 50	 mov	 eax, DWORD PTR _i$23521[rsp]
  00254	ff c0		 inc	 eax
  00256	89 44 24 50	 mov	 DWORD PTR _i$23521[rsp], eax
$LN4@compiler_f@3:
  0025a	48 83 7c 24 58
	00		 cmp	 QWORD PTR seq$23522[rsp], 0
  00260	75 0b		 jne	 SHORT $LN23@compiler_f@3
  00262	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv171[rsp], 0
  0026b	eb 0d		 jmp	 SHORT $LN24@compiler_f@3
$LN23@compiler_f@3:
  0026d	48 8b 44 24 58	 mov	 rax, QWORD PTR seq$23522[rsp]
  00272	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00275	48 89 44 24 70	 mov	 QWORD PTR tv171[rsp], rax
$LN24@compiler_f@3:
  0027a	48 63 44 24 50	 movsxd	 rax, DWORD PTR _i$23521[rsp]
  0027f	48 3b 44 24 70	 cmp	 rax, QWORD PTR tv171[rsp]
  00284	7d 30		 jge	 SHORT $LN2@compiler_f@3
  00286	48 63 44 24 50	 movsxd	 rax, DWORD PTR _i$23521[rsp]
  0028b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR seq$23522[rsp]
  00290	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00295	48 89 44 24 60	 mov	 QWORD PTR elt$23527[rsp], rax
  0029a	48 8b 54 24 60	 mov	 rdx, QWORD PTR elt$23527[rsp]
  0029f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002a7	e8 00 00 00 00	 call	 compiler_visit_stmt
  002ac	85 c0		 test	 eax, eax
  002ae	75 04		 jne	 SHORT $LN1@compiler_f@3
  002b0	33 c0		 xor	 eax, eax
  002b2	eb 19		 jmp	 SHORT $LN19@compiler_f@3
$LN1@compiler_f@3:
  002b4	eb 9a		 jmp	 SHORT $LN3@compiler_f@3
$LN2@compiler_f@3:

; 1905 :     compiler_use_next_block(c, end);

  002b6	48 8b 54 24 28	 mov	 rdx, QWORD PTR end$[rsp]
  002bb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002c3	e8 00 00 00 00	 call	 compiler_use_next_block

; 1906 :     return 1;

  002c8	b8 01 00 00 00	 mov	 eax, 1
$LN19@compiler_f@3:

; 1907 : }

  002cd	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002d4	c3		 ret	 0
compiler_for ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_while DD imagerel compiler_while
	DD	imagerel compiler_while+1017
	DD	imagerel $unwind$compiler_while
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_while DD 021101H
	DD	0170111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_while
_TEXT	SEGMENT
anchor$ = 32
loop$ = 40
end$ = 48
constant$ = 56
orelse$ = 64
_i$23544 = 72
seq$23545 = 80
elt$23550 = 88
_i$23570 = 96
seq$23571 = 104
elt$23576 = 112
_i$23584 = 120
seq$23585 = 128
elt$23590 = 136
tv75 = 144
tv161 = 152
tv192 = 160
c$ = 192
s$ = 200
compiler_while PROC					; COMDAT

; 1911 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1912 :     basicblock *loop, *orelse, *end, *anchor = NULL;

  00011	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR anchor$[rsp], 0

; 1913 :     int constant = expr_constant(c, s->v.While.test);

  0001a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00022	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00026	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0002e	e8 00 00 00 00	 call	 expr_constant
  00033	89 44 24 38	 mov	 DWORD PTR constant$[rsp], eax

; 1914 : 
; 1915 :     if (constant == 0) {

  00037	83 7c 24 38 00	 cmp	 DWORD PTR constant$[rsp], 0
  0003c	0f 85 aa 00 00
	00		 jne	 $LN30@compiler_w

; 1916 :         if (s->v.While.orelse)

  00042	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0004a	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0004f	0f 84 8d 00 00
	00		 je	 $LN29@compiler_w

; 1917 :             VISIT_SEQ(c, stmt, s->v.While.orelse);

  00055	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00061	48 89 44 24 50	 mov	 QWORD PTR seq$23545[rsp], rax
  00066	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR _i$23544[rsp], 0
  0006e	eb 0a		 jmp	 SHORT $LN28@compiler_w
$LN27@compiler_w:
  00070	8b 44 24 48	 mov	 eax, DWORD PTR _i$23544[rsp]
  00074	ff c0		 inc	 eax
  00076	89 44 24 48	 mov	 DWORD PTR _i$23544[rsp], eax
$LN28@compiler_w:
  0007a	48 83 7c 24 50
	00		 cmp	 QWORD PTR seq$23545[rsp], 0
  00080	75 0e		 jne	 SHORT $LN33@compiler_w
  00082	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv75[rsp], 0
  0008e	eb 10		 jmp	 SHORT $LN34@compiler_w
$LN33@compiler_w:
  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR seq$23545[rsp]
  00095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00098	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
$LN34@compiler_w:
  000a0	48 63 44 24 48	 movsxd	 rax, DWORD PTR _i$23544[rsp]
  000a5	48 3b 84 24 90
	00 00 00	 cmp	 rax, QWORD PTR tv75[rsp]
  000ad	7d 33		 jge	 SHORT $LN26@compiler_w
  000af	48 63 44 24 48	 movsxd	 rax, DWORD PTR _i$23544[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq$23545[rsp]
  000b9	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  000be	48 89 44 24 58	 mov	 QWORD PTR elt$23550[rsp], rax
  000c3	48 8b 54 24 58	 mov	 rdx, QWORD PTR elt$23550[rsp]
  000c8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000d0	e8 00 00 00 00	 call	 compiler_visit_stmt
  000d5	85 c0		 test	 eax, eax
  000d7	75 07		 jne	 SHORT $LN25@compiler_w
  000d9	33 c0		 xor	 eax, eax
  000db	e9 11 03 00 00	 jmp	 $LN31@compiler_w
$LN25@compiler_w:
  000e0	eb 8e		 jmp	 SHORT $LN27@compiler_w
$LN26@compiler_w:
$LN29@compiler_w:

; 1918 :         return 1;

  000e2	b8 01 00 00 00	 mov	 eax, 1
  000e7	e9 05 03 00 00	 jmp	 $LN31@compiler_w
$LN30@compiler_w:

; 1919 :     }
; 1920 :     loop = compiler_new_block(c);

  000ec	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000f4	e8 00 00 00 00	 call	 compiler_new_block
  000f9	48 89 44 24 28	 mov	 QWORD PTR loop$[rsp], rax

; 1921 :     end = compiler_new_block(c);

  000fe	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00106	e8 00 00 00 00	 call	 compiler_new_block
  0010b	48 89 44 24 30	 mov	 QWORD PTR end$[rsp], rax

; 1922 :     if (constant == -1) {

  00110	83 7c 24 38 ff	 cmp	 DWORD PTR constant$[rsp], -1
  00115	75 21		 jne	 SHORT $LN24@compiler_w

; 1923 :         anchor = compiler_new_block(c);

  00117	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0011f	e8 00 00 00 00	 call	 compiler_new_block
  00124	48 89 44 24 20	 mov	 QWORD PTR anchor$[rsp], rax

; 1924 :         if (anchor == NULL)

  00129	48 83 7c 24 20
	00		 cmp	 QWORD PTR anchor$[rsp], 0
  0012f	75 07		 jne	 SHORT $LN23@compiler_w

; 1925 :             return 0;

  00131	33 c0		 xor	 eax, eax
  00133	e9 b9 02 00 00	 jmp	 $LN31@compiler_w
$LN23@compiler_w:
$LN24@compiler_w:

; 1926 :     }
; 1927 :     if (loop == NULL || end == NULL)

  00138	48 83 7c 24 28
	00		 cmp	 QWORD PTR loop$[rsp], 0
  0013e	74 08		 je	 SHORT $LN21@compiler_w
  00140	48 83 7c 24 30
	00		 cmp	 QWORD PTR end$[rsp], 0
  00146	75 07		 jne	 SHORT $LN22@compiler_w
$LN21@compiler_w:

; 1928 :         return 0;

  00148	33 c0		 xor	 eax, eax
  0014a	e9 a2 02 00 00	 jmp	 $LN31@compiler_w
$LN22@compiler_w:

; 1929 :     if (s->v.While.orelse) {

  0014f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00157	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0015c	74 23		 je	 SHORT $LN20@compiler_w

; 1930 :         orelse = compiler_new_block(c);

  0015e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00166	e8 00 00 00 00	 call	 compiler_new_block
  0016b	48 89 44 24 40	 mov	 QWORD PTR orelse$[rsp], rax

; 1931 :         if (orelse == NULL)

  00170	48 83 7c 24 40
	00		 cmp	 QWORD PTR orelse$[rsp], 0
  00176	75 07		 jne	 SHORT $LN19@compiler_w

; 1932 :             return 0;

  00178	33 c0		 xor	 eax, eax
  0017a	e9 72 02 00 00	 jmp	 $LN31@compiler_w
$LN19@compiler_w:

; 1933 :     }
; 1934 :     else

  0017f	eb 09		 jmp	 SHORT $LN18@compiler_w
$LN20@compiler_w:

; 1935 :         orelse = NULL;

  00181	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR orelse$[rsp], 0
$LN18@compiler_w:

; 1936 : 
; 1937 :     ADDOP_JREL(c, SETUP_LOOP, end);

  0018a	45 33 c9	 xor	 r9d, r9d
  0018d	4c 8b 44 24 30	 mov	 r8, QWORD PTR end$[rsp]
  00192	ba 78 00 00 00	 mov	 edx, 120		; 00000078H
  00197	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0019f	e8 00 00 00 00	 call	 compiler_addop_j
  001a4	85 c0		 test	 eax, eax
  001a6	75 07		 jne	 SHORT $LN17@compiler_w
  001a8	33 c0		 xor	 eax, eax
  001aa	e9 42 02 00 00	 jmp	 $LN31@compiler_w
$LN17@compiler_w:

; 1938 :     compiler_use_next_block(c, loop);

  001af	48 8b 54 24 28	 mov	 rdx, QWORD PTR loop$[rsp]
  001b4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001bc	e8 00 00 00 00	 call	 compiler_use_next_block

; 1939 :     if (!compiler_push_fblock(c, LOOP, loop))

  001c1	4c 8b 44 24 28	 mov	 r8, QWORD PTR loop$[rsp]
  001c6	33 d2		 xor	 edx, edx
  001c8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001d0	e8 00 00 00 00	 call	 compiler_push_fblock
  001d5	85 c0		 test	 eax, eax
  001d7	75 07		 jne	 SHORT $LN16@compiler_w

; 1940 :         return 0;

  001d9	33 c0		 xor	 eax, eax
  001db	e9 11 02 00 00	 jmp	 $LN31@compiler_w
$LN16@compiler_w:

; 1941 :     if (constant == -1) {

  001e0	83 7c 24 38 ff	 cmp	 DWORD PTR constant$[rsp], -1
  001e5	75 4c		 jne	 SHORT $LN15@compiler_w

; 1942 :         VISIT(c, expr, s->v.While.test);

  001e7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001ef	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  001f3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001fb	e8 00 00 00 00	 call	 compiler_visit_expr
  00200	85 c0		 test	 eax, eax
  00202	75 07		 jne	 SHORT $LN14@compiler_w
  00204	33 c0		 xor	 eax, eax
  00206	e9 e6 01 00 00	 jmp	 $LN31@compiler_w
$LN14@compiler_w:

; 1943 :         ADDOP_JABS(c, POP_JUMP_IF_FALSE, anchor);

  0020b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00211	4c 8b 44 24 20	 mov	 r8, QWORD PTR anchor$[rsp]
  00216	ba 72 00 00 00	 mov	 edx, 114		; 00000072H
  0021b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00223	e8 00 00 00 00	 call	 compiler_addop_j
  00228	85 c0		 test	 eax, eax
  0022a	75 07		 jne	 SHORT $LN13@compiler_w
  0022c	33 c0		 xor	 eax, eax
  0022e	e9 be 01 00 00	 jmp	 $LN31@compiler_w
$LN13@compiler_w:
$LN15@compiler_w:

; 1944 :     }
; 1945 :     VISIT_SEQ(c, stmt, s->v.While.body);

  00233	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0023b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0023f	48 89 44 24 68	 mov	 QWORD PTR seq$23571[rsp], rax
  00244	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR _i$23570[rsp], 0
  0024c	eb 0a		 jmp	 SHORT $LN12@compiler_w
$LN11@compiler_w:
  0024e	8b 44 24 60	 mov	 eax, DWORD PTR _i$23570[rsp]
  00252	ff c0		 inc	 eax
  00254	89 44 24 60	 mov	 DWORD PTR _i$23570[rsp], eax
$LN12@compiler_w:
  00258	48 83 7c 24 68
	00		 cmp	 QWORD PTR seq$23571[rsp], 0
  0025e	75 0e		 jne	 SHORT $LN35@compiler_w
  00260	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv161[rsp], 0
  0026c	eb 10		 jmp	 SHORT $LN36@compiler_w
$LN35@compiler_w:
  0026e	48 8b 44 24 68	 mov	 rax, QWORD PTR seq$23571[rsp]
  00273	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00276	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv161[rsp], rax
$LN36@compiler_w:
  0027e	48 63 44 24 60	 movsxd	 rax, DWORD PTR _i$23570[rsp]
  00283	48 3b 84 24 98
	00 00 00	 cmp	 rax, QWORD PTR tv161[rsp]
  0028b	7d 33		 jge	 SHORT $LN10@compiler_w
  0028d	48 63 44 24 60	 movsxd	 rax, DWORD PTR _i$23570[rsp]
  00292	48 8b 4c 24 68	 mov	 rcx, QWORD PTR seq$23571[rsp]
  00297	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  0029c	48 89 44 24 70	 mov	 QWORD PTR elt$23576[rsp], rax
  002a1	48 8b 54 24 70	 mov	 rdx, QWORD PTR elt$23576[rsp]
  002a6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002ae	e8 00 00 00 00	 call	 compiler_visit_stmt
  002b3	85 c0		 test	 eax, eax
  002b5	75 07		 jne	 SHORT $LN9@compiler_w
  002b7	33 c0		 xor	 eax, eax
  002b9	e9 33 01 00 00	 jmp	 $LN31@compiler_w
$LN9@compiler_w:
  002be	eb 8e		 jmp	 SHORT $LN11@compiler_w
$LN10@compiler_w:

; 1946 :     ADDOP_JABS(c, JUMP_ABSOLUTE, loop);

  002c0	41 b9 01 00 00
	00		 mov	 r9d, 1
  002c6	4c 8b 44 24 28	 mov	 r8, QWORD PTR loop$[rsp]
  002cb	ba 71 00 00 00	 mov	 edx, 113		; 00000071H
  002d0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002d8	e8 00 00 00 00	 call	 compiler_addop_j
  002dd	85 c0		 test	 eax, eax
  002df	75 07		 jne	 SHORT $LN8@compiler_w
  002e1	33 c0		 xor	 eax, eax
  002e3	e9 09 01 00 00	 jmp	 $LN31@compiler_w
$LN8@compiler_w:

; 1947 : 
; 1948 :     /* XXX should the two POP instructions be in a separate block
; 1949 :        if there is no else clause ?
; 1950 :     */
; 1951 : 
; 1952 :     if (constant == -1) {

  002e8	83 7c 24 38 ff	 cmp	 DWORD PTR constant$[rsp], -1
  002ed	75 2f		 jne	 SHORT $LN7@compiler_w

; 1953 :         compiler_use_next_block(c, anchor);

  002ef	48 8b 54 24 20	 mov	 rdx, QWORD PTR anchor$[rsp]
  002f4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002fc	e8 00 00 00 00	 call	 compiler_use_next_block

; 1954 :         ADDOP(c, POP_BLOCK);

  00301	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  00306	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0030e	e8 00 00 00 00	 call	 compiler_addop
  00313	85 c0		 test	 eax, eax
  00315	75 07		 jne	 SHORT $LN6@compiler_w
  00317	33 c0		 xor	 eax, eax
  00319	e9 d3 00 00 00	 jmp	 $LN31@compiler_w
$LN6@compiler_w:
$LN7@compiler_w:

; 1955 :     }
; 1956 :     compiler_pop_fblock(c, LOOP, loop);

  0031e	4c 8b 44 24 28	 mov	 r8, QWORD PTR loop$[rsp]
  00323	33 d2		 xor	 edx, edx
  00325	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0032d	e8 00 00 00 00	 call	 compiler_pop_fblock

; 1957 :     if (orelse != NULL) /* what if orelse is just pass? */

  00332	48 83 7c 24 40
	00		 cmp	 QWORD PTR orelse$[rsp], 0
  00338	0f 84 9c 00 00
	00		 je	 $LN5@compiler_w

; 1958 :         VISIT_SEQ(c, stmt, s->v.While.orelse);

  0033e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00346	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0034a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR seq$23585[rsp], rax
  00352	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR _i$23584[rsp], 0
  0035a	eb 0a		 jmp	 SHORT $LN4@compiler_w
$LN3@compiler_w:
  0035c	8b 44 24 78	 mov	 eax, DWORD PTR _i$23584[rsp]
  00360	ff c0		 inc	 eax
  00362	89 44 24 78	 mov	 DWORD PTR _i$23584[rsp], eax
$LN4@compiler_w:
  00366	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR seq$23585[rsp], 0
  0036f	75 0e		 jne	 SHORT $LN37@compiler_w
  00371	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv192[rsp], 0
  0037d	eb 13		 jmp	 SHORT $LN38@compiler_w
$LN37@compiler_w:
  0037f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR seq$23585[rsp]
  00387	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0038a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv192[rsp], rax
$LN38@compiler_w:
  00392	48 63 44 24 78	 movsxd	 rax, DWORD PTR _i$23584[rsp]
  00397	48 3b 84 24 a0
	00 00 00	 cmp	 rax, QWORD PTR tv192[rsp]
  0039f	7d 39		 jge	 SHORT $LN2@compiler_w
  003a1	48 63 44 24 78	 movsxd	 rax, DWORD PTR _i$23584[rsp]
  003a6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR seq$23585[rsp]
  003ae	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  003b3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR elt$23590[rsp], rax
  003bb	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR elt$23590[rsp]
  003c3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003cb	e8 00 00 00 00	 call	 compiler_visit_stmt
  003d0	85 c0		 test	 eax, eax
  003d2	75 04		 jne	 SHORT $LN1@compiler_w
  003d4	33 c0		 xor	 eax, eax
  003d6	eb 19		 jmp	 SHORT $LN31@compiler_w
$LN1@compiler_w:
  003d8	eb 82		 jmp	 SHORT $LN3@compiler_w
$LN2@compiler_w:
$LN5@compiler_w:

; 1959 :     compiler_use_next_block(c, end);

  003da	48 8b 54 24 30	 mov	 rdx, QWORD PTR end$[rsp]
  003df	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003e7	e8 00 00 00 00	 call	 compiler_use_next_block

; 1960 : 
; 1961 :     return 1;

  003ec	b8 01 00 00 00	 mov	 eax, 1
$LN31@compiler_w:

; 1962 : }

  003f1	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003f8	c3		 ret	 0
compiler_while ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_continue DD imagerel compiler_continue
	DD	imagerel compiler_continue+388
	DD	imagerel $unwind$compiler_continue
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_continue DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_continue
_TEXT	SEGMENT
i$ = 32
tv78 = 36
c$ = 64
compiler_continue PROC					; COMDAT

; 1966 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1967 :     static const char LOOP_ERROR_MSG[] = "'continue' not properly in loop";
; 1968 :     static const char IN_FINALLY_ERROR_MSG[] =
; 1969 :                     "'continue' not supported inside 'finally' clause";
; 1970 :     int i;
; 1971 : 
; 1972 :     if (!c->u->u_nfblocks)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0000e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00012	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00016	75 16		 jne	 SHORT $LN12@compiler_c@2

; 1973 :         return compiler_error(c, LOOP_ERROR_MSG);

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?LOOP_ERROR_MSG@?1??compiler_continue@@9@9
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00024	e8 00 00 00 00	 call	 compiler_error
  00029	e9 51 01 00 00	 jmp	 $LN13@compiler_c@2
$LN12@compiler_c@2:

; 1974 :     i = c->u->u_nfblocks - 1;

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00033	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00037	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0003a	ff c8		 dec	 eax
  0003c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 1975 :     switch (c->u->u_fblock[i].fb_type) {

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00045	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00049	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0004e	48 6b c9 10	 imul	 rcx, 16
  00052	8b 44 08 70	 mov	 eax, DWORD PTR [rax+rcx+112]
  00056	89 44 24 24	 mov	 DWORD PTR tv78[rsp], eax
  0005a	83 7c 24 24 00	 cmp	 DWORD PTR tv78[rsp], 0
  0005f	74 22		 je	 SHORT $LN9@compiler_c@2
  00061	83 7c 24 24 00	 cmp	 DWORD PTR tv78[rsp], 0
  00066	0f 8e 0e 01 00
	00		 jle	 $LN10@compiler_c@2
  0006c	83 7c 24 24 02	 cmp	 DWORD PTR tv78[rsp], 2
  00071	7e 4c		 jle	 SHORT $LN7@compiler_c@2
  00073	83 7c 24 24 03	 cmp	 DWORD PTR tv78[rsp], 3
  00078	0f 84 e9 00 00
	00		 je	 $LN1@compiler_c@2
  0007e	e9 f7 00 00 00	 jmp	 $LN10@compiler_c@2
$LN9@compiler_c@2:

; 1976 :     case LOOP:
; 1977 :         ADDOP_JABS(c, JUMP_ABSOLUTE, c->u->u_fblock[i].fb_block);

  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00088	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0008c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00091	48 6b c9 10	 imul	 rcx, 16
  00095	41 b9 01 00 00
	00		 mov	 r9d, 1
  0009b	4c 8b 44 08 78	 mov	 r8, QWORD PTR [rax+rcx+120]
  000a0	ba 71 00 00 00	 mov	 edx, 113		; 00000071H
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000aa	e8 00 00 00 00	 call	 compiler_addop_j
  000af	85 c0		 test	 eax, eax
  000b1	75 07		 jne	 SHORT $LN8@compiler_c@2
  000b3	33 c0		 xor	 eax, eax
  000b5	e9 c5 00 00 00	 jmp	 $LN13@compiler_c@2
$LN8@compiler_c@2:

; 1978 :         break;

  000ba	e9 bb 00 00 00	 jmp	 $LN10@compiler_c@2
$LN7@compiler_c@2:
$LN6@compiler_c@2:

; 1979 :     case EXCEPT:
; 1980 :     case FINALLY_TRY:
; 1981 :         while (--i >= 0 && c->u->u_fblock[i].fb_type != LOOP) {

  000bf	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000c3	ff c8		 dec	 eax
  000c5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000c9	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  000ce	7c 47		 jl	 SHORT $LN5@compiler_c@2
  000d0	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000d5	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000d9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000de	48 6b c9 10	 imul	 rcx, 16
  000e2	83 7c 08 70 00	 cmp	 DWORD PTR [rax+rcx+112], 0
  000e7	74 2e		 je	 SHORT $LN5@compiler_c@2

; 1982 :             /* Prevent continue anywhere under a finally
; 1983 :                   even if hidden in a sub-try or except. */
; 1984 :             if (c->u->u_fblock[i].fb_type == FINALLY_END)

  000e9	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000ee	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000f2	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f7	48 6b c9 10	 imul	 rcx, 16
  000fb	83 7c 08 70 03	 cmp	 DWORD PTR [rax+rcx+112], 3
  00100	75 13		 jne	 SHORT $LN4@compiler_c@2

; 1985 :                 return compiler_error(c, IN_FINALLY_ERROR_MSG);

  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?IN_FINALLY_ERROR_MSG@?1??compiler_continue@@9@9
  00109	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0010e	e8 00 00 00 00	 call	 compiler_error
  00113	eb 6a		 jmp	 SHORT $LN13@compiler_c@2
$LN4@compiler_c@2:

; 1986 :         }

  00115	eb a8		 jmp	 SHORT $LN6@compiler_c@2
$LN5@compiler_c@2:

; 1987 :         if (i == -1)

  00117	83 7c 24 20 ff	 cmp	 DWORD PTR i$[rsp], -1
  0011c	75 13		 jne	 SHORT $LN3@compiler_c@2

; 1988 :             return compiler_error(c, LOOP_ERROR_MSG);

  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?LOOP_ERROR_MSG@?1??compiler_continue@@9@9
  00125	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0012a	e8 00 00 00 00	 call	 compiler_error
  0012f	eb 4e		 jmp	 SHORT $LN13@compiler_c@2
$LN3@compiler_c@2:

; 1989 :         ADDOP_JABS(c, CONTINUE_LOOP, c->u->u_fblock[i].fb_block);

  00131	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00136	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0013a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0013f	48 6b c9 10	 imul	 rcx, 16
  00143	41 b9 01 00 00
	00		 mov	 r9d, 1
  00149	4c 8b 44 08 78	 mov	 r8, QWORD PTR [rax+rcx+120]
  0014e	ba 77 00 00 00	 mov	 edx, 119		; 00000077H
  00153	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00158	e8 00 00 00 00	 call	 compiler_addop_j
  0015d	85 c0		 test	 eax, eax
  0015f	75 04		 jne	 SHORT $LN2@compiler_c@2
  00161	33 c0		 xor	 eax, eax
  00163	eb 1a		 jmp	 SHORT $LN13@compiler_c@2
$LN2@compiler_c@2:

; 1990 :         break;

  00165	eb 13		 jmp	 SHORT $LN10@compiler_c@2
$LN1@compiler_c@2:

; 1991 :     case FINALLY_END:
; 1992 :         return compiler_error(c, IN_FINALLY_ERROR_MSG);

  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?IN_FINALLY_ERROR_MSG@?1??compiler_continue@@9@9
  0016e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00173	e8 00 00 00 00	 call	 compiler_error
  00178	eb 05		 jmp	 SHORT $LN13@compiler_c@2
$LN10@compiler_c@2:

; 1993 :     }
; 1994 : 
; 1995 :     return 1;

  0017a	b8 01 00 00 00	 mov	 eax, 1
$LN13@compiler_c@2:

; 1996 : }

  0017f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00183	c3		 ret	 0
compiler_continue ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_try DD imagerel compiler_try
	DD	imagerel compiler_try+113
	DD	imagerel $unwind$compiler_try
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_try DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_try
_TEXT	SEGMENT
tv70 = 32
c$ = 64
s$ = 72
compiler_try PROC					; COMDAT

; 2213 : compiler_try(struct compiler *c, stmt_ty s) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2214 :     if (s->v.Try.finalbody && asdl_seq_LEN(s->v.Try.finalbody))

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00013	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00018	74 43		 je	 SHORT $LN2@compiler_t
  0001a	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0001f	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00024	75 0b		 jne	 SHORT $LN5@compiler_t
  00026	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv70[rsp], 0
  0002f	eb 11		 jmp	 SHORT $LN6@compiler_t
$LN5@compiler_t:
  00031	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00036	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003d	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
$LN6@compiler_t:
  00042	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv70[rsp], 0
  00048	74 13		 je	 SHORT $LN2@compiler_t

; 2215 :         return compiler_try_finally(c, s);

  0004a	48 8b 54 24 48	 mov	 rdx, QWORD PTR s$[rsp]
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00054	e8 00 00 00 00	 call	 compiler_try_finally
  00059	eb 11		 jmp	 SHORT $LN3@compiler_t

; 2216 :     else

  0005b	eb 0f		 jmp	 SHORT $LN1@compiler_t
$LN2@compiler_t:

; 2217 :         return compiler_try_except(c, s);

  0005d	48 8b 54 24 48	 mov	 rdx, QWORD PTR s$[rsp]
  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00067	e8 00 00 00 00	 call	 compiler_try_except
$LN1@compiler_t:
$LN3@compiler_t:

; 2218 : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
compiler_try ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_try_finally DD imagerel compiler_try_finally
	DD	imagerel compiler_try_finally+750
	DD	imagerel $unwind$compiler_try_finally
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_try_finally DD 021101H
	DD	0110111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_try_finally
_TEXT	SEGMENT
end$ = 32
body$ = 40
_i$23635 = 48
seq$23636 = 56
elt$23641 = 64
_i$23647 = 72
seq$23648 = 80
elt$23653 = 88
tv89 = 96
tv131 = 104
tv167 = 112
c$ = 144
s$ = 152
compiler_try_finally PROC				; COMDAT

; 2033 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2034 :     basicblock *body, *end;
; 2035 :     body = compiler_new_block(c);

  00011	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00019	e8 00 00 00 00	 call	 compiler_new_block
  0001e	48 89 44 24 28	 mov	 QWORD PTR body$[rsp], rax

; 2036 :     end = compiler_new_block(c);

  00023	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0002b	e8 00 00 00 00	 call	 compiler_new_block
  00030	48 89 44 24 20	 mov	 QWORD PTR end$[rsp], rax

; 2037 :     if (body == NULL || end == NULL)

  00035	48 83 7c 24 28
	00		 cmp	 QWORD PTR body$[rsp], 0
  0003b	74 08		 je	 SHORT $LN18@compiler_t@2
  0003d	48 83 7c 24 20
	00		 cmp	 QWORD PTR end$[rsp], 0
  00043	75 07		 jne	 SHORT $LN19@compiler_t@2
$LN18@compiler_t@2:

; 2038 :         return 0;

  00045	33 c0		 xor	 eax, eax
  00047	e9 9a 02 00 00	 jmp	 $LN20@compiler_t@2
$LN19@compiler_t@2:

; 2039 : 
; 2040 :     ADDOP_JREL(c, SETUP_FINALLY, end);

  0004c	45 33 c9	 xor	 r9d, r9d
  0004f	4c 8b 44 24 20	 mov	 r8, QWORD PTR end$[rsp]
  00054	ba 7a 00 00 00	 mov	 edx, 122		; 0000007aH
  00059	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00061	e8 00 00 00 00	 call	 compiler_addop_j
  00066	85 c0		 test	 eax, eax
  00068	75 07		 jne	 SHORT $LN17@compiler_t@2
  0006a	33 c0		 xor	 eax, eax
  0006c	e9 75 02 00 00	 jmp	 $LN20@compiler_t@2
$LN17@compiler_t@2:

; 2041 :     compiler_use_next_block(c, body);

  00071	48 8b 54 24 28	 mov	 rdx, QWORD PTR body$[rsp]
  00076	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0007e	e8 00 00 00 00	 call	 compiler_use_next_block

; 2042 :     if (!compiler_push_fblock(c, FINALLY_TRY, body))

  00083	4c 8b 44 24 28	 mov	 r8, QWORD PTR body$[rsp]
  00088	ba 02 00 00 00	 mov	 edx, 2
  0008d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00095	e8 00 00 00 00	 call	 compiler_push_fblock
  0009a	85 c0		 test	 eax, eax
  0009c	75 07		 jne	 SHORT $LN16@compiler_t@2

; 2043 :         return 0;

  0009e	33 c0		 xor	 eax, eax
  000a0	e9 41 02 00 00	 jmp	 $LN20@compiler_t@2
$LN16@compiler_t@2:

; 2044 :     if (s->v.Try.handlers && asdl_seq_LEN(s->v.Try.handlers)) {

  000a5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000ad	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000b2	74 5b		 je	 SHORT $LN15@compiler_t@2
  000b4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000bc	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000c1	75 0b		 jne	 SHORT $LN22@compiler_t@2
  000c3	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv89[rsp], 0
  000cc	eb 14		 jmp	 SHORT $LN23@compiler_t@2
$LN22@compiler_t@2:
  000ce	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000d6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000da	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000dd	48 89 44 24 60	 mov	 QWORD PTR tv89[rsp], rax
$LN23@compiler_t@2:
  000e2	48 83 7c 24 60
	00		 cmp	 QWORD PTR tv89[rsp], 0
  000e8	74 25		 je	 SHORT $LN15@compiler_t@2

; 2045 :         if (!compiler_try_except(c, s))

  000ea	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  000f2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000fa	e8 00 00 00 00	 call	 compiler_try_except
  000ff	85 c0		 test	 eax, eax
  00101	75 07		 jne	 SHORT $LN14@compiler_t@2

; 2046 :             return 0;

  00103	33 c0		 xor	 eax, eax
  00105	e9 dc 01 00 00	 jmp	 $LN20@compiler_t@2
$LN14@compiler_t@2:

; 2047 :     }
; 2048 :     else {

  0010a	e9 84 00 00 00	 jmp	 $LN13@compiler_t@2
$LN15@compiler_t@2:

; 2049 :         VISIT_SEQ(c, stmt, s->v.Try.body);

  0010f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00117	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0011b	48 89 44 24 38	 mov	 QWORD PTR seq$23636[rsp], rax
  00120	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _i$23635[rsp], 0
  00128	eb 0a		 jmp	 SHORT $LN12@compiler_t@2
$LN11@compiler_t@2:
  0012a	8b 44 24 30	 mov	 eax, DWORD PTR _i$23635[rsp]
  0012e	ff c0		 inc	 eax
  00130	89 44 24 30	 mov	 DWORD PTR _i$23635[rsp], eax
$LN12@compiler_t@2:
  00134	48 83 7c 24 38
	00		 cmp	 QWORD PTR seq$23636[rsp], 0
  0013a	75 0b		 jne	 SHORT $LN24@compiler_t@2
  0013c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv131[rsp], 0
  00145	eb 0d		 jmp	 SHORT $LN25@compiler_t@2
$LN24@compiler_t@2:
  00147	48 8b 44 24 38	 mov	 rax, QWORD PTR seq$23636[rsp]
  0014c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0014f	48 89 44 24 68	 mov	 QWORD PTR tv131[rsp], rax
$LN25@compiler_t@2:
  00154	48 63 44 24 30	 movsxd	 rax, DWORD PTR _i$23635[rsp]
  00159	48 3b 44 24 68	 cmp	 rax, QWORD PTR tv131[rsp]
  0015e	7d 33		 jge	 SHORT $LN10@compiler_t@2
  00160	48 63 44 24 30	 movsxd	 rax, DWORD PTR _i$23635[rsp]
  00165	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$23636[rsp]
  0016a	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  0016f	48 89 44 24 40	 mov	 QWORD PTR elt$23641[rsp], rax
  00174	48 8b 54 24 40	 mov	 rdx, QWORD PTR elt$23641[rsp]
  00179	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00181	e8 00 00 00 00	 call	 compiler_visit_stmt
  00186	85 c0		 test	 eax, eax
  00188	75 07		 jne	 SHORT $LN9@compiler_t@2
  0018a	33 c0		 xor	 eax, eax
  0018c	e9 55 01 00 00	 jmp	 $LN20@compiler_t@2
$LN9@compiler_t@2:
  00191	eb 97		 jmp	 SHORT $LN11@compiler_t@2
$LN10@compiler_t@2:
$LN13@compiler_t@2:

; 2050 :     }
; 2051 :     ADDOP(c, POP_BLOCK);

  00193	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  00198	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001a0	e8 00 00 00 00	 call	 compiler_addop
  001a5	85 c0		 test	 eax, eax
  001a7	75 07		 jne	 SHORT $LN8@compiler_t@2
  001a9	33 c0		 xor	 eax, eax
  001ab	e9 36 01 00 00	 jmp	 $LN20@compiler_t@2
$LN8@compiler_t@2:

; 2052 :     compiler_pop_fblock(c, FINALLY_TRY, body);

  001b0	4c 8b 44 24 28	 mov	 r8, QWORD PTR body$[rsp]
  001b5	ba 02 00 00 00	 mov	 edx, 2
  001ba	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001c2	e8 00 00 00 00	 call	 compiler_pop_fblock

; 2053 : 
; 2054 :     ADDOP_O(c, LOAD_CONST, Py_None, consts);

  001c7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  001cf	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  001da	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  001de	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  001e3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001eb	e8 00 00 00 00	 call	 compiler_addop_o
  001f0	85 c0		 test	 eax, eax
  001f2	75 07		 jne	 SHORT $LN7@compiler_t@2
  001f4	33 c0		 xor	 eax, eax
  001f6	e9 eb 00 00 00	 jmp	 $LN20@compiler_t@2
$LN7@compiler_t@2:

; 2055 :     compiler_use_next_block(c, end);

  001fb	48 8b 54 24 20	 mov	 rdx, QWORD PTR end$[rsp]
  00200	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00208	e8 00 00 00 00	 call	 compiler_use_next_block

; 2056 :     if (!compiler_push_fblock(c, FINALLY_END, end))

  0020d	4c 8b 44 24 20	 mov	 r8, QWORD PTR end$[rsp]
  00212	ba 03 00 00 00	 mov	 edx, 3
  00217	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0021f	e8 00 00 00 00	 call	 compiler_push_fblock
  00224	85 c0		 test	 eax, eax
  00226	75 07		 jne	 SHORT $LN6@compiler_t@2

; 2057 :         return 0;

  00228	33 c0		 xor	 eax, eax
  0022a	e9 b7 00 00 00	 jmp	 $LN20@compiler_t@2
$LN6@compiler_t@2:

; 2058 :     VISIT_SEQ(c, stmt, s->v.Try.finalbody);

  0022f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00237	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0023b	48 89 44 24 50	 mov	 QWORD PTR seq$23648[rsp], rax
  00240	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR _i$23647[rsp], 0
  00248	eb 0a		 jmp	 SHORT $LN5@compiler_t@2
$LN4@compiler_t@2:
  0024a	8b 44 24 48	 mov	 eax, DWORD PTR _i$23647[rsp]
  0024e	ff c0		 inc	 eax
  00250	89 44 24 48	 mov	 DWORD PTR _i$23647[rsp], eax
$LN5@compiler_t@2:
  00254	48 83 7c 24 50
	00		 cmp	 QWORD PTR seq$23648[rsp], 0
  0025a	75 0b		 jne	 SHORT $LN26@compiler_t@2
  0025c	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv167[rsp], 0
  00265	eb 0d		 jmp	 SHORT $LN27@compiler_t@2
$LN26@compiler_t@2:
  00267	48 8b 44 24 50	 mov	 rax, QWORD PTR seq$23648[rsp]
  0026c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0026f	48 89 44 24 70	 mov	 QWORD PTR tv167[rsp], rax
$LN27@compiler_t@2:
  00274	48 63 44 24 48	 movsxd	 rax, DWORD PTR _i$23647[rsp]
  00279	48 3b 44 24 70	 cmp	 rax, QWORD PTR tv167[rsp]
  0027e	7d 30		 jge	 SHORT $LN3@compiler_t@2
  00280	48 63 44 24 48	 movsxd	 rax, DWORD PTR _i$23647[rsp]
  00285	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq$23648[rsp]
  0028a	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  0028f	48 89 44 24 58	 mov	 QWORD PTR elt$23653[rsp], rax
  00294	48 8b 54 24 58	 mov	 rdx, QWORD PTR elt$23653[rsp]
  00299	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002a1	e8 00 00 00 00	 call	 compiler_visit_stmt
  002a6	85 c0		 test	 eax, eax
  002a8	75 04		 jne	 SHORT $LN2@compiler_t@2
  002aa	33 c0		 xor	 eax, eax
  002ac	eb 38		 jmp	 SHORT $LN20@compiler_t@2
$LN2@compiler_t@2:
  002ae	eb 9a		 jmp	 SHORT $LN4@compiler_t@2
$LN3@compiler_t@2:

; 2059 :     ADDOP(c, END_FINALLY);

  002b0	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  002b5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002bd	e8 00 00 00 00	 call	 compiler_addop
  002c2	85 c0		 test	 eax, eax
  002c4	75 04		 jne	 SHORT $LN1@compiler_t@2
  002c6	33 c0		 xor	 eax, eax
  002c8	eb 1c		 jmp	 SHORT $LN20@compiler_t@2
$LN1@compiler_t@2:

; 2060 :     compiler_pop_fblock(c, FINALLY_END, end);

  002ca	4c 8b 44 24 20	 mov	 r8, QWORD PTR end$[rsp]
  002cf	ba 03 00 00 00	 mov	 edx, 3
  002d4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002dc	e8 00 00 00 00	 call	 compiler_pop_fblock

; 2061 : 
; 2062 :     return 1;

  002e1	b8 01 00 00 00	 mov	 eax, 1
$LN20@compiler_t@2:

; 2063 : }

  002e6	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002ed	c3		 ret	 0
compiler_try_finally ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@BGMGGMIC@default?5?8except?3?8?5must?5be?5last?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_try_except DD imagerel compiler_try_except
	DD	imagerel compiler_try_except+2353
	DD	imagerel $unwind$compiler_try_except
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_try_except DD 021101H
	DD	01f0111H
xdata	ENDS
;	COMDAT ??_C@_0BP@BGMGGMIC@default?5?8except?3?8?5must?5be?5last?$AA@
CONST	SEGMENT
??_C@_0BP@BGMGGMIC@default?5?8except?3?8?5must?5be?5last?$AA@ DB 'default'
	DB	' ''except:'' must be last', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_try_except
_TEXT	SEGMENT
n$ = 32
i$ = 36
except$ = 40
end$ = 48
body$ = 56
orelse$ = 64
_i$23676 = 72
seq$23677 = 80
elt$23682 = 88
handler$23691 = 96
cleanup_body$23705 = 104
cleanup_end$23704 = 112
_i$23710 = 120
seq$23711 = 128
elt$23716 = 136
cleanup_body$23726 = 144
_i$23731 = 152
seq$23732 = 160
elt$23737 = 168
_i$23743 = 176
seq$23744 = 184
elt$23749 = 192
tv93 = 200
tv152 = 208
tv240 = 216
tv321 = 224
tv356 = 232
c$ = 256
s$ = 264
compiler_try_except PROC				; COMDAT

; 2098 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 2099 :     basicblock *body, *orelse, *except, *end;
; 2100 :     int i, n;
; 2101 : 
; 2102 :     body = compiler_new_block(c);

  00011	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00019	e8 00 00 00 00	 call	 compiler_new_block
  0001e	48 89 44 24 38	 mov	 QWORD PTR body$[rsp], rax

; 2103 :     except = compiler_new_block(c);

  00023	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0002b	e8 00 00 00 00	 call	 compiler_new_block
  00030	48 89 44 24 28	 mov	 QWORD PTR except$[rsp], rax

; 2104 :     orelse = compiler_new_block(c);

  00035	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0003d	e8 00 00 00 00	 call	 compiler_new_block
  00042	48 89 44 24 40	 mov	 QWORD PTR orelse$[rsp], rax

; 2105 :     end = compiler_new_block(c);

  00047	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0004f	e8 00 00 00 00	 call	 compiler_new_block
  00054	48 89 44 24 30	 mov	 QWORD PTR end$[rsp], rax

; 2106 :     if (body == NULL || except == NULL || orelse == NULL || end == NULL)

  00059	48 83 7c 24 38
	00		 cmp	 QWORD PTR body$[rsp], 0
  0005f	74 18		 je	 SHORT $LN51@compiler_t@3
  00061	48 83 7c 24 28
	00		 cmp	 QWORD PTR except$[rsp], 0
  00067	74 10		 je	 SHORT $LN51@compiler_t@3
  00069	48 83 7c 24 40
	00		 cmp	 QWORD PTR orelse$[rsp], 0
  0006f	74 08		 je	 SHORT $LN51@compiler_t@3
  00071	48 83 7c 24 30
	00		 cmp	 QWORD PTR end$[rsp], 0
  00077	75 07		 jne	 SHORT $LN52@compiler_t@3
$LN51@compiler_t@3:

; 2107 :         return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 a9 08 00 00	 jmp	 $LN53@compiler_t@3
$LN52@compiler_t@3:

; 2108 :     ADDOP_JREL(c, SETUP_EXCEPT, except);

  00080	45 33 c9	 xor	 r9d, r9d
  00083	4c 8b 44 24 28	 mov	 r8, QWORD PTR except$[rsp]
  00088	ba 79 00 00 00	 mov	 edx, 121		; 00000079H
  0008d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00095	e8 00 00 00 00	 call	 compiler_addop_j
  0009a	85 c0		 test	 eax, eax
  0009c	75 07		 jne	 SHORT $LN50@compiler_t@3
  0009e	33 c0		 xor	 eax, eax
  000a0	e9 84 08 00 00	 jmp	 $LN53@compiler_t@3
$LN50@compiler_t@3:

; 2109 :     compiler_use_next_block(c, body);

  000a5	48 8b 54 24 38	 mov	 rdx, QWORD PTR body$[rsp]
  000aa	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000b2	e8 00 00 00 00	 call	 compiler_use_next_block

; 2110 :     if (!compiler_push_fblock(c, EXCEPT, body))

  000b7	4c 8b 44 24 38	 mov	 r8, QWORD PTR body$[rsp]
  000bc	ba 01 00 00 00	 mov	 edx, 1
  000c1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000c9	e8 00 00 00 00	 call	 compiler_push_fblock
  000ce	85 c0		 test	 eax, eax
  000d0	75 07		 jne	 SHORT $LN49@compiler_t@3

; 2111 :         return 0;

  000d2	33 c0		 xor	 eax, eax
  000d4	e9 50 08 00 00	 jmp	 $LN53@compiler_t@3
$LN49@compiler_t@3:

; 2112 :     VISIT_SEQ(c, stmt, s->v.Try.body);

  000d9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000e1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000e5	48 89 44 24 50	 mov	 QWORD PTR seq$23677[rsp], rax
  000ea	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR _i$23676[rsp], 0
  000f2	eb 0a		 jmp	 SHORT $LN48@compiler_t@3
$LN47@compiler_t@3:
  000f4	8b 44 24 48	 mov	 eax, DWORD PTR _i$23676[rsp]
  000f8	ff c0		 inc	 eax
  000fa	89 44 24 48	 mov	 DWORD PTR _i$23676[rsp], eax
$LN48@compiler_t@3:
  000fe	48 83 7c 24 50
	00		 cmp	 QWORD PTR seq$23677[rsp], 0
  00104	75 0e		 jne	 SHORT $LN55@compiler_t@3
  00106	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv93[rsp], 0
  00112	eb 10		 jmp	 SHORT $LN56@compiler_t@3
$LN55@compiler_t@3:
  00114	48 8b 44 24 50	 mov	 rax, QWORD PTR seq$23677[rsp]
  00119	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv93[rsp], rax
$LN56@compiler_t@3:
  00124	48 63 44 24 48	 movsxd	 rax, DWORD PTR _i$23676[rsp]
  00129	48 3b 84 24 c8
	00 00 00	 cmp	 rax, QWORD PTR tv93[rsp]
  00131	7d 33		 jge	 SHORT $LN46@compiler_t@3
  00133	48 63 44 24 48	 movsxd	 rax, DWORD PTR _i$23676[rsp]
  00138	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq$23677[rsp]
  0013d	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00142	48 89 44 24 58	 mov	 QWORD PTR elt$23682[rsp], rax
  00147	48 8b 54 24 58	 mov	 rdx, QWORD PTR elt$23682[rsp]
  0014c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00154	e8 00 00 00 00	 call	 compiler_visit_stmt
  00159	85 c0		 test	 eax, eax
  0015b	75 07		 jne	 SHORT $LN45@compiler_t@3
  0015d	33 c0		 xor	 eax, eax
  0015f	e9 c5 07 00 00	 jmp	 $LN53@compiler_t@3
$LN45@compiler_t@3:
  00164	eb 8e		 jmp	 SHORT $LN47@compiler_t@3
$LN46@compiler_t@3:

; 2113 :     ADDOP(c, POP_BLOCK);

  00166	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  0016b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00173	e8 00 00 00 00	 call	 compiler_addop
  00178	85 c0		 test	 eax, eax
  0017a	75 07		 jne	 SHORT $LN44@compiler_t@3
  0017c	33 c0		 xor	 eax, eax
  0017e	e9 a6 07 00 00	 jmp	 $LN53@compiler_t@3
$LN44@compiler_t@3:

; 2114 :     compiler_pop_fblock(c, EXCEPT, body);

  00183	4c 8b 44 24 38	 mov	 r8, QWORD PTR body$[rsp]
  00188	ba 01 00 00 00	 mov	 edx, 1
  0018d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00195	e8 00 00 00 00	 call	 compiler_pop_fblock

; 2115 :     ADDOP_JREL(c, JUMP_FORWARD, orelse);

  0019a	45 33 c9	 xor	 r9d, r9d
  0019d	4c 8b 44 24 40	 mov	 r8, QWORD PTR orelse$[rsp]
  001a2	ba 6e 00 00 00	 mov	 edx, 110		; 0000006eH
  001a7	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001af	e8 00 00 00 00	 call	 compiler_addop_j
  001b4	85 c0		 test	 eax, eax
  001b6	75 07		 jne	 SHORT $LN43@compiler_t@3
  001b8	33 c0		 xor	 eax, eax
  001ba	e9 6a 07 00 00	 jmp	 $LN53@compiler_t@3
$LN43@compiler_t@3:

; 2116 :     n = asdl_seq_LEN(s->v.Try.handlers);

  001bf	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001c7	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  001cc	75 0e		 jne	 SHORT $LN57@compiler_t@3
  001ce	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv152[rsp], 0
  001da	eb 17		 jmp	 SHORT $LN58@compiler_t@3
$LN57@compiler_t@3:
  001dc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001e4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001e8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001eb	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv152[rsp], rax
$LN58@compiler_t@3:
  001f3	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv152[rsp]
  001fa	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 2117 :     compiler_use_next_block(c, except);

  001fe	48 8b 54 24 28	 mov	 rdx, QWORD PTR except$[rsp]
  00203	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0020b	e8 00 00 00 00	 call	 compiler_use_next_block

; 2118 :     for (i = 0; i < n; i++) {

  00210	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00218	eb 0a		 jmp	 SHORT $LN42@compiler_t@3
$LN41@compiler_t@3:
  0021a	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0021e	ff c0		 inc	 eax
  00220	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN42@compiler_t@3:
  00224	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00228	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0022c	0f 8d 03 06 00
	00		 jge	 $LN40@compiler_t@3

; 2119 :         excepthandler_ty handler = (excepthandler_ty)asdl_seq_GET(
; 2120 :             s->v.Try.handlers, i);

  00232	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0023a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0023e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00243	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  00248	48 89 44 24 60	 mov	 QWORD PTR handler$23691[rsp], rax

; 2121 :         if (!handler->v.ExceptHandler.type && i < n-1)

  0024d	48 8b 44 24 60	 mov	 rax, QWORD PTR handler$23691[rsp]
  00252	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00257	75 25		 jne	 SHORT $LN39@compiler_t@3
  00259	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0025d	ff c8		 dec	 eax
  0025f	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00263	7d 19		 jge	 SHORT $LN39@compiler_t@3

; 2122 :             return compiler_error(c, "default 'except:' must be last");

  00265	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@BGMGGMIC@default?5?8except?3?8?5must?5be?5last?$AA@
  0026c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00274	e8 00 00 00 00	 call	 compiler_error
  00279	e9 ab 06 00 00	 jmp	 $LN53@compiler_t@3
$LN39@compiler_t@3:

; 2123 :         c->u->u_lineno_set = 0;

  0027e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00286	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0028a	c7 80 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+444], 0

; 2124 :         c->u->u_lineno = handler->lineno;

  00294	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0029c	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  002a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR handler$23691[rsp]
  002a5	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  002a8	89 88 b4 01 00
	00		 mov	 DWORD PTR [rax+436], ecx

; 2125 :         c->u->u_col_offset = handler->col_offset;

  002ae	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  002b6	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  002ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR handler$23691[rsp]
  002bf	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  002c2	89 88 b8 01 00
	00		 mov	 DWORD PTR [rax+440], ecx

; 2126 :         except = compiler_new_block(c);

  002c8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002d0	e8 00 00 00 00	 call	 compiler_new_block
  002d5	48 89 44 24 28	 mov	 QWORD PTR except$[rsp], rax

; 2127 :         if (except == NULL)

  002da	48 83 7c 24 28
	00		 cmp	 QWORD PTR except$[rsp], 0
  002e0	75 07		 jne	 SHORT $LN38@compiler_t@3

; 2128 :             return 0;

  002e2	33 c0		 xor	 eax, eax
  002e4	e9 40 06 00 00	 jmp	 $LN53@compiler_t@3
$LN38@compiler_t@3:

; 2129 :         if (handler->v.ExceptHandler.type) {

  002e9	48 8b 44 24 60	 mov	 rax, QWORD PTR handler$23691[rsp]
  002ee	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  002f3	0f 84 89 00 00
	00		 je	 $LN37@compiler_t@3

; 2130 :             ADDOP(c, DUP_TOP);

  002f9	ba 04 00 00 00	 mov	 edx, 4
  002fe	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00306	e8 00 00 00 00	 call	 compiler_addop
  0030b	85 c0		 test	 eax, eax
  0030d	75 07		 jne	 SHORT $LN36@compiler_t@3
  0030f	33 c0		 xor	 eax, eax
  00311	e9 13 06 00 00	 jmp	 $LN53@compiler_t@3
$LN36@compiler_t@3:

; 2131 :             VISIT(c, expr, handler->v.ExceptHandler.type);

  00316	48 8b 44 24 60	 mov	 rax, QWORD PTR handler$23691[rsp]
  0031b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0031f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00327	e8 00 00 00 00	 call	 compiler_visit_expr
  0032c	85 c0		 test	 eax, eax
  0032e	75 07		 jne	 SHORT $LN35@compiler_t@3
  00330	33 c0		 xor	 eax, eax
  00332	e9 f2 05 00 00	 jmp	 $LN53@compiler_t@3
$LN35@compiler_t@3:

; 2132 :             ADDOP_I(c, COMPARE_OP, PyCmp_EXC_MATCH);

  00337	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0033d	ba 6b 00 00 00	 mov	 edx, 107		; 0000006bH
  00342	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0034a	e8 00 00 00 00	 call	 compiler_addop_i
  0034f	85 c0		 test	 eax, eax
  00351	75 07		 jne	 SHORT $LN34@compiler_t@3
  00353	33 c0		 xor	 eax, eax
  00355	e9 cf 05 00 00	 jmp	 $LN53@compiler_t@3
$LN34@compiler_t@3:

; 2133 :             ADDOP_JABS(c, POP_JUMP_IF_FALSE, except);

  0035a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00360	4c 8b 44 24 28	 mov	 r8, QWORD PTR except$[rsp]
  00365	ba 72 00 00 00	 mov	 edx, 114		; 00000072H
  0036a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00372	e8 00 00 00 00	 call	 compiler_addop_j
  00377	85 c0		 test	 eax, eax
  00379	75 07		 jne	 SHORT $LN33@compiler_t@3
  0037b	33 c0		 xor	 eax, eax
  0037d	e9 a7 05 00 00	 jmp	 $LN53@compiler_t@3
$LN33@compiler_t@3:
$LN37@compiler_t@3:

; 2134 :         }
; 2135 :         ADDOP(c, POP_TOP);

  00382	ba 01 00 00 00	 mov	 edx, 1
  00387	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0038f	e8 00 00 00 00	 call	 compiler_addop
  00394	85 c0		 test	 eax, eax
  00396	75 07		 jne	 SHORT $LN32@compiler_t@3
  00398	33 c0		 xor	 eax, eax
  0039a	e9 8a 05 00 00	 jmp	 $LN53@compiler_t@3
$LN32@compiler_t@3:

; 2136 :         if (handler->v.ExceptHandler.name) {

  0039f	48 8b 44 24 60	 mov	 rax, QWORD PTR handler$23691[rsp]
  003a4	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  003a9	0f 84 ca 02 00
	00		 je	 $LN31@compiler_t@3

; 2137 :             basicblock *cleanup_end, *cleanup_body;
; 2138 : 
; 2139 :             cleanup_end = compiler_new_block(c);

  003af	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003b7	e8 00 00 00 00	 call	 compiler_new_block
  003bc	48 89 44 24 70	 mov	 QWORD PTR cleanup_end$23704[rsp], rax

; 2140 :             cleanup_body = compiler_new_block(c);

  003c1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003c9	e8 00 00 00 00	 call	 compiler_new_block
  003ce	48 89 44 24 68	 mov	 QWORD PTR cleanup_body$23705[rsp], rax

; 2141 :             if (!(cleanup_end || cleanup_body))

  003d3	48 83 7c 24 70
	00		 cmp	 QWORD PTR cleanup_end$23704[rsp], 0
  003d9	75 0f		 jne	 SHORT $LN30@compiler_t@3
  003db	48 83 7c 24 68
	00		 cmp	 QWORD PTR cleanup_body$23705[rsp], 0
  003e1	75 07		 jne	 SHORT $LN30@compiler_t@3

; 2142 :                 return 0;

  003e3	33 c0		 xor	 eax, eax
  003e5	e9 3f 05 00 00	 jmp	 $LN53@compiler_t@3
$LN30@compiler_t@3:

; 2143 : 
; 2144 :             compiler_nameop(c, handler->v.ExceptHandler.name, Store);

  003ea	41 b8 02 00 00
	00		 mov	 r8d, 2
  003f0	48 8b 44 24 60	 mov	 rax, QWORD PTR handler$23691[rsp]
  003f5	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  003f9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00401	e8 00 00 00 00	 call	 compiler_nameop

; 2145 :             ADDOP(c, POP_TOP);

  00406	ba 01 00 00 00	 mov	 edx, 1
  0040b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00413	e8 00 00 00 00	 call	 compiler_addop
  00418	85 c0		 test	 eax, eax
  0041a	75 07		 jne	 SHORT $LN29@compiler_t@3
  0041c	33 c0		 xor	 eax, eax
  0041e	e9 06 05 00 00	 jmp	 $LN53@compiler_t@3
$LN29@compiler_t@3:

; 2146 : 
; 2147 :             /*
; 2148 :               try:
; 2149 :                   # body
; 2150 :               except type as name:
; 2151 :                   try:
; 2152 :                       # body
; 2153 :                   finally:
; 2154 :                       name = None
; 2155 :                       del name
; 2156 :             */
; 2157 : 
; 2158 :             /* second try: */
; 2159 :             ADDOP_JREL(c, SETUP_FINALLY, cleanup_end);

  00423	45 33 c9	 xor	 r9d, r9d
  00426	4c 8b 44 24 70	 mov	 r8, QWORD PTR cleanup_end$23704[rsp]
  0042b	ba 7a 00 00 00	 mov	 edx, 122		; 0000007aH
  00430	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00438	e8 00 00 00 00	 call	 compiler_addop_j
  0043d	85 c0		 test	 eax, eax
  0043f	75 07		 jne	 SHORT $LN28@compiler_t@3
  00441	33 c0		 xor	 eax, eax
  00443	e9 e1 04 00 00	 jmp	 $LN53@compiler_t@3
$LN28@compiler_t@3:

; 2160 :             compiler_use_next_block(c, cleanup_body);

  00448	48 8b 54 24 68	 mov	 rdx, QWORD PTR cleanup_body$23705[rsp]
  0044d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00455	e8 00 00 00 00	 call	 compiler_use_next_block

; 2161 :             if (!compiler_push_fblock(c, FINALLY_TRY, cleanup_body))

  0045a	4c 8b 44 24 68	 mov	 r8, QWORD PTR cleanup_body$23705[rsp]
  0045f	ba 02 00 00 00	 mov	 edx, 2
  00464	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0046c	e8 00 00 00 00	 call	 compiler_push_fblock
  00471	85 c0		 test	 eax, eax
  00473	75 07		 jne	 SHORT $LN27@compiler_t@3

; 2162 :                 return 0;

  00475	33 c0		 xor	 eax, eax
  00477	e9 ad 04 00 00	 jmp	 $LN53@compiler_t@3
$LN27@compiler_t@3:

; 2163 : 
; 2164 :             /* second # body */
; 2165 :             VISIT_SEQ(c, stmt, handler->v.ExceptHandler.body);

  0047c	48 8b 44 24 60	 mov	 rax, QWORD PTR handler$23691[rsp]
  00481	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00485	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR seq$23711[rsp], rax
  0048d	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR _i$23710[rsp], 0
  00495	eb 0a		 jmp	 SHORT $LN26@compiler_t@3
$LN25@compiler_t@3:
  00497	8b 44 24 78	 mov	 eax, DWORD PTR _i$23710[rsp]
  0049b	ff c0		 inc	 eax
  0049d	89 44 24 78	 mov	 DWORD PTR _i$23710[rsp], eax
$LN26@compiler_t@3:
  004a1	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR seq$23711[rsp], 0
  004aa	75 0e		 jne	 SHORT $LN59@compiler_t@3
  004ac	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv240[rsp], 0
  004b8	eb 13		 jmp	 SHORT $LN60@compiler_t@3
$LN59@compiler_t@3:
  004ba	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR seq$23711[rsp]
  004c2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004c5	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv240[rsp], rax
$LN60@compiler_t@3:
  004cd	48 63 44 24 78	 movsxd	 rax, DWORD PTR _i$23710[rsp]
  004d2	48 3b 84 24 d8
	00 00 00	 cmp	 rax, QWORD PTR tv240[rsp]
  004da	7d 3f		 jge	 SHORT $LN24@compiler_t@3
  004dc	48 63 44 24 78	 movsxd	 rax, DWORD PTR _i$23710[rsp]
  004e1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR seq$23711[rsp]
  004e9	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  004ee	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR elt$23716[rsp], rax
  004f6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR elt$23716[rsp]
  004fe	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00506	e8 00 00 00 00	 call	 compiler_visit_stmt
  0050b	85 c0		 test	 eax, eax
  0050d	75 07		 jne	 SHORT $LN23@compiler_t@3
  0050f	33 c0		 xor	 eax, eax
  00511	e9 13 04 00 00	 jmp	 $LN53@compiler_t@3
$LN23@compiler_t@3:
  00516	e9 7c ff ff ff	 jmp	 $LN25@compiler_t@3
$LN24@compiler_t@3:

; 2166 :             ADDOP(c, POP_BLOCK);

  0051b	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  00520	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00528	e8 00 00 00 00	 call	 compiler_addop
  0052d	85 c0		 test	 eax, eax
  0052f	75 07		 jne	 SHORT $LN22@compiler_t@3
  00531	33 c0		 xor	 eax, eax
  00533	e9 f1 03 00 00	 jmp	 $LN53@compiler_t@3
$LN22@compiler_t@3:

; 2167 :             ADDOP(c, POP_EXCEPT);

  00538	ba 59 00 00 00	 mov	 edx, 89			; 00000059H
  0053d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00545	e8 00 00 00 00	 call	 compiler_addop
  0054a	85 c0		 test	 eax, eax
  0054c	75 07		 jne	 SHORT $LN21@compiler_t@3
  0054e	33 c0		 xor	 eax, eax
  00550	e9 d4 03 00 00	 jmp	 $LN53@compiler_t@3
$LN21@compiler_t@3:

; 2168 :             compiler_pop_fblock(c, FINALLY_TRY, cleanup_body);

  00555	4c 8b 44 24 68	 mov	 r8, QWORD PTR cleanup_body$23705[rsp]
  0055a	ba 02 00 00 00	 mov	 edx, 2
  0055f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00567	e8 00 00 00 00	 call	 compiler_pop_fblock

; 2169 : 
; 2170 :             /* finally: */
; 2171 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  0056c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00574	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00578	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0057f	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00583	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00588	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00590	e8 00 00 00 00	 call	 compiler_addop_o
  00595	85 c0		 test	 eax, eax
  00597	75 07		 jne	 SHORT $LN20@compiler_t@3
  00599	33 c0		 xor	 eax, eax
  0059b	e9 89 03 00 00	 jmp	 $LN53@compiler_t@3
$LN20@compiler_t@3:

; 2172 :             compiler_use_next_block(c, cleanup_end);

  005a0	48 8b 54 24 70	 mov	 rdx, QWORD PTR cleanup_end$23704[rsp]
  005a5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  005ad	e8 00 00 00 00	 call	 compiler_use_next_block

; 2173 :             if (!compiler_push_fblock(c, FINALLY_END, cleanup_end))

  005b2	4c 8b 44 24 70	 mov	 r8, QWORD PTR cleanup_end$23704[rsp]
  005b7	ba 03 00 00 00	 mov	 edx, 3
  005bc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  005c4	e8 00 00 00 00	 call	 compiler_push_fblock
  005c9	85 c0		 test	 eax, eax
  005cb	75 07		 jne	 SHORT $LN19@compiler_t@3

; 2174 :                 return 0;

  005cd	33 c0		 xor	 eax, eax
  005cf	e9 55 03 00 00	 jmp	 $LN53@compiler_t@3
$LN19@compiler_t@3:

; 2175 : 
; 2176 :             /* name = None */
; 2177 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  005d4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  005dc	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  005e0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  005e7	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  005eb	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  005f0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  005f8	e8 00 00 00 00	 call	 compiler_addop_o
  005fd	85 c0		 test	 eax, eax
  005ff	75 07		 jne	 SHORT $LN18@compiler_t@3
  00601	33 c0		 xor	 eax, eax
  00603	e9 21 03 00 00	 jmp	 $LN53@compiler_t@3
$LN18@compiler_t@3:

; 2178 :             compiler_nameop(c, handler->v.ExceptHandler.name, Store);

  00608	41 b8 02 00 00
	00		 mov	 r8d, 2
  0060e	48 8b 44 24 60	 mov	 rax, QWORD PTR handler$23691[rsp]
  00613	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00617	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0061f	e8 00 00 00 00	 call	 compiler_nameop

; 2179 : 
; 2180 :             /* del name */
; 2181 :             compiler_nameop(c, handler->v.ExceptHandler.name, Del);

  00624	41 b8 03 00 00
	00		 mov	 r8d, 3
  0062a	48 8b 44 24 60	 mov	 rax, QWORD PTR handler$23691[rsp]
  0062f	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00633	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0063b	e8 00 00 00 00	 call	 compiler_nameop

; 2182 : 
; 2183 :             ADDOP(c, END_FINALLY);

  00640	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  00645	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0064d	e8 00 00 00 00	 call	 compiler_addop
  00652	85 c0		 test	 eax, eax
  00654	75 07		 jne	 SHORT $LN17@compiler_t@3
  00656	33 c0		 xor	 eax, eax
  00658	e9 cc 02 00 00	 jmp	 $LN53@compiler_t@3
$LN17@compiler_t@3:

; 2184 :             compiler_pop_fblock(c, FINALLY_END, cleanup_end);

  0065d	4c 8b 44 24 70	 mov	 r8, QWORD PTR cleanup_end$23704[rsp]
  00662	ba 03 00 00 00	 mov	 edx, 3
  00667	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0066f	e8 00 00 00 00	 call	 compiler_pop_fblock

; 2185 :         }
; 2186 :         else {

  00674	e9 80 01 00 00	 jmp	 $LN16@compiler_t@3
$LN31@compiler_t@3:

; 2187 :             basicblock *cleanup_body;
; 2188 : 
; 2189 :             cleanup_body = compiler_new_block(c);

  00679	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00681	e8 00 00 00 00	 call	 compiler_new_block
  00686	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cleanup_body$23726[rsp], rax

; 2190 :             if (!cleanup_body)

  0068e	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR cleanup_body$23726[rsp], 0
  00697	75 07		 jne	 SHORT $LN15@compiler_t@3

; 2191 :                 return 0;

  00699	33 c0		 xor	 eax, eax
  0069b	e9 89 02 00 00	 jmp	 $LN53@compiler_t@3
$LN15@compiler_t@3:

; 2192 : 
; 2193 :             ADDOP(c, POP_TOP);

  006a0	ba 01 00 00 00	 mov	 edx, 1
  006a5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006ad	e8 00 00 00 00	 call	 compiler_addop
  006b2	85 c0		 test	 eax, eax
  006b4	75 07		 jne	 SHORT $LN14@compiler_t@3
  006b6	33 c0		 xor	 eax, eax
  006b8	e9 6c 02 00 00	 jmp	 $LN53@compiler_t@3
$LN14@compiler_t@3:

; 2194 :             ADDOP(c, POP_TOP);

  006bd	ba 01 00 00 00	 mov	 edx, 1
  006c2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006ca	e8 00 00 00 00	 call	 compiler_addop
  006cf	85 c0		 test	 eax, eax
  006d1	75 07		 jne	 SHORT $LN13@compiler_t@3
  006d3	33 c0		 xor	 eax, eax
  006d5	e9 4f 02 00 00	 jmp	 $LN53@compiler_t@3
$LN13@compiler_t@3:

; 2195 :             compiler_use_next_block(c, cleanup_body);

  006da	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR cleanup_body$23726[rsp]
  006e2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006ea	e8 00 00 00 00	 call	 compiler_use_next_block

; 2196 :             if (!compiler_push_fblock(c, FINALLY_TRY, cleanup_body))

  006ef	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR cleanup_body$23726[rsp]
  006f7	ba 02 00 00 00	 mov	 edx, 2
  006fc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00704	e8 00 00 00 00	 call	 compiler_push_fblock
  00709	85 c0		 test	 eax, eax
  0070b	75 07		 jne	 SHORT $LN12@compiler_t@3

; 2197 :                 return 0;

  0070d	33 c0		 xor	 eax, eax
  0070f	e9 15 02 00 00	 jmp	 $LN53@compiler_t@3
$LN12@compiler_t@3:

; 2198 :             VISIT_SEQ(c, stmt, handler->v.ExceptHandler.body);

  00714	48 8b 44 24 60	 mov	 rax, QWORD PTR handler$23691[rsp]
  00719	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0071d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR seq$23732[rsp], rax
  00725	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _i$23731[rsp], 0
  00730	eb 10		 jmp	 SHORT $LN11@compiler_t@3
$LN10@compiler_t@3:
  00732	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR _i$23731[rsp]
  00739	ff c0		 inc	 eax
  0073b	89 84 24 98 00
	00 00		 mov	 DWORD PTR _i$23731[rsp], eax
$LN11@compiler_t@3:
  00742	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR seq$23732[rsp], 0
  0074b	75 0e		 jne	 SHORT $LN61@compiler_t@3
  0074d	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv321[rsp], 0
  00759	eb 13		 jmp	 SHORT $LN62@compiler_t@3
$LN61@compiler_t@3:
  0075b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR seq$23732[rsp]
  00763	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00766	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv321[rsp], rax
$LN62@compiler_t@3:
  0076e	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR _i$23731[rsp]
  00776	48 3b 84 24 e0
	00 00 00	 cmp	 rax, QWORD PTR tv321[rsp]
  0077e	7d 42		 jge	 SHORT $LN9@compiler_t@3
  00780	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR _i$23731[rsp]
  00788	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR seq$23732[rsp]
  00790	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00795	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR elt$23737[rsp], rax
  0079d	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR elt$23737[rsp]
  007a5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007ad	e8 00 00 00 00	 call	 compiler_visit_stmt
  007b2	85 c0		 test	 eax, eax
  007b4	75 07		 jne	 SHORT $LN8@compiler_t@3
  007b6	33 c0		 xor	 eax, eax
  007b8	e9 6c 01 00 00	 jmp	 $LN53@compiler_t@3
$LN8@compiler_t@3:
  007bd	e9 70 ff ff ff	 jmp	 $LN10@compiler_t@3
$LN9@compiler_t@3:

; 2199 :             ADDOP(c, POP_EXCEPT);

  007c2	ba 59 00 00 00	 mov	 edx, 89			; 00000059H
  007c7	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007cf	e8 00 00 00 00	 call	 compiler_addop
  007d4	85 c0		 test	 eax, eax
  007d6	75 07		 jne	 SHORT $LN7@compiler_t@3
  007d8	33 c0		 xor	 eax, eax
  007da	e9 4a 01 00 00	 jmp	 $LN53@compiler_t@3
$LN7@compiler_t@3:

; 2200 :             compiler_pop_fblock(c, FINALLY_TRY, cleanup_body);

  007df	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR cleanup_body$23726[rsp]
  007e7	ba 02 00 00 00	 mov	 edx, 2
  007ec	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007f4	e8 00 00 00 00	 call	 compiler_pop_fblock
$LN16@compiler_t@3:

; 2201 :         }
; 2202 :         ADDOP_JREL(c, JUMP_FORWARD, end);

  007f9	45 33 c9	 xor	 r9d, r9d
  007fc	4c 8b 44 24 30	 mov	 r8, QWORD PTR end$[rsp]
  00801	ba 6e 00 00 00	 mov	 edx, 110		; 0000006eH
  00806	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0080e	e8 00 00 00 00	 call	 compiler_addop_j
  00813	85 c0		 test	 eax, eax
  00815	75 07		 jne	 SHORT $LN6@compiler_t@3
  00817	33 c0		 xor	 eax, eax
  00819	e9 0b 01 00 00	 jmp	 $LN53@compiler_t@3
$LN6@compiler_t@3:

; 2203 :         compiler_use_next_block(c, except);

  0081e	48 8b 54 24 28	 mov	 rdx, QWORD PTR except$[rsp]
  00823	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0082b	e8 00 00 00 00	 call	 compiler_use_next_block

; 2204 :     }

  00830	e9 e5 f9 ff ff	 jmp	 $LN41@compiler_t@3
$LN40@compiler_t@3:

; 2205 :     ADDOP(c, END_FINALLY);

  00835	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  0083a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00842	e8 00 00 00 00	 call	 compiler_addop
  00847	85 c0		 test	 eax, eax
  00849	75 07		 jne	 SHORT $LN5@compiler_t@3
  0084b	33 c0		 xor	 eax, eax
  0084d	e9 d7 00 00 00	 jmp	 $LN53@compiler_t@3
$LN5@compiler_t@3:

; 2206 :     compiler_use_next_block(c, orelse);

  00852	48 8b 54 24 40	 mov	 rdx, QWORD PTR orelse$[rsp]
  00857	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0085f	e8 00 00 00 00	 call	 compiler_use_next_block

; 2207 :     VISIT_SEQ(c, stmt, s->v.Try.orelse);

  00864	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0086c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00870	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR seq$23744[rsp], rax
  00878	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _i$23743[rsp], 0
  00883	eb 10		 jmp	 SHORT $LN4@compiler_t@3
$LN3@compiler_t@3:
  00885	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR _i$23743[rsp]
  0088c	ff c0		 inc	 eax
  0088e	89 84 24 b0 00
	00 00		 mov	 DWORD PTR _i$23743[rsp], eax
$LN4@compiler_t@3:
  00895	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR seq$23744[rsp], 0
  0089e	75 0e		 jne	 SHORT $LN63@compiler_t@3
  008a0	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv356[rsp], 0
  008ac	eb 13		 jmp	 SHORT $LN64@compiler_t@3
$LN63@compiler_t@3:
  008ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR seq$23744[rsp]
  008b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008b9	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv356[rsp], rax
$LN64@compiler_t@3:
  008c1	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR _i$23743[rsp]
  008c9	48 3b 84 24 e8
	00 00 00	 cmp	 rax, QWORD PTR tv356[rsp]
  008d1	7d 3f		 jge	 SHORT $LN2@compiler_t@3
  008d3	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR _i$23743[rsp]
  008db	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR seq$23744[rsp]
  008e3	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  008e8	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR elt$23749[rsp], rax
  008f0	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR elt$23749[rsp]
  008f8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00900	e8 00 00 00 00	 call	 compiler_visit_stmt
  00905	85 c0		 test	 eax, eax
  00907	75 04		 jne	 SHORT $LN1@compiler_t@3
  00909	33 c0		 xor	 eax, eax
  0090b	eb 1c		 jmp	 SHORT $LN53@compiler_t@3
$LN1@compiler_t@3:
  0090d	e9 73 ff ff ff	 jmp	 $LN3@compiler_t@3
$LN2@compiler_t@3:

; 2208 :     compiler_use_next_block(c, end);

  00912	48 8b 54 24 30	 mov	 rdx, QWORD PTR end$[rsp]
  00917	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0091f	e8 00 00 00 00	 call	 compiler_use_next_block

; 2209 :     return 1;

  00924	b8 01 00 00 00	 mov	 eax, 1
$LN53@compiler_t@3:

; 2210 : }

  00929	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00930	c3		 ret	 0
compiler_try_except ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EA@DIEOKLFE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@JBHGBMLI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyUnicode_Substring:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_import DD imagerel compiler_import
	DD	imagerel compiler_import+658
	DD	imagerel $unwind$compiler_import
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_import DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_1EA@DIEOKLFE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@DIEOKLFE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H, 'n'
	DB	00H, 'a', 00H, 'm', 00H, 'e', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@JBHGBMLI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@JBHGBMLI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'a', 00H
	DB	's', 00H, '-', 00H, '>', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_import
_TEXT	SEGMENT
n$ = 48
i$ = 52
level$23813 = 56
alias$23810 = 64
r$23812 = 72
dot$23824 = 80
tmp$23823 = 88
tv68 = 96
c$ = 128
s$ = 136
compiler_import PROC					; COMDAT

; 2258 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2259 :     /* The Import node stores a module name like a.b.c as a single
; 2260 :        string.  This is convenient for all cases except
; 2261 :          import a.b.c as d
; 2262 :        where we need to parse that string to extract the individual
; 2263 :        module names.
; 2264 :        XXX Perhaps change the representation to make this case simpler?
; 2265 :      */
; 2266 :     int i, n = asdl_seq_LEN(s->v.Import.names);

  0000e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00016	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0001b	75 0b		 jne	 SHORT $LN16@compiler_i@4
  0001d	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
  00026	eb 14		 jmp	 SHORT $LN17@compiler_i@4
$LN16@compiler_i@4:
  00028	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00030	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 89 44 24 60	 mov	 QWORD PTR tv68[rsp], rax
$LN17@compiler_i@4:
  0003c	8b 44 24 60	 mov	 eax, DWORD PTR tv68[rsp]
  00040	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 2267 : 
; 2268 :     for (i = 0; i < n; i++) {

  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0004c	eb 0a		 jmp	 SHORT $LN13@compiler_i@4
$LN12@compiler_i@4:
  0004e	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00052	ff c0		 inc	 eax
  00054	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN13@compiler_i@4:
  00058	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]
  0005c	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  00060	0f 8d 22 02 00
	00		 jge	 $LN11@compiler_i@4

; 2269 :         alias_ty alias = (alias_ty)asdl_seq_GET(s->v.Import.names, i);

  00066	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0006e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00072	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  00077	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  0007c	48 89 44 24 40	 mov	 QWORD PTR alias$23810[rsp], rax

; 2270 :         int r;
; 2271 :         PyObject *level;
; 2272 : 
; 2273 :         level = PyLong_FromLong(0);

  00081	33 c9		 xor	 ecx, ecx
  00083	e8 00 00 00 00	 call	 PyLong_FromLong
  00088	48 89 44 24 38	 mov	 QWORD PTR level$23813[rsp], rax

; 2274 :         if (level == NULL)

  0008d	48 83 7c 24 38
	00		 cmp	 QWORD PTR level$23813[rsp], 0
  00093	75 07		 jne	 SHORT $LN10@compiler_i@4

; 2275 :             return 0;

  00095	33 c0		 xor	 eax, eax
  00097	e9 f1 01 00 00	 jmp	 $LN14@compiler_i@4
$LN10@compiler_i@4:

; 2276 : 
; 2277 :         ADDOP_O(c, LOAD_CONST, level, consts);

  0009c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000a4	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000a8	4c 8b 4c 24 38	 mov	 r9, QWORD PTR level$23813[rsp]
  000ad	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  000b1	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000b6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000be	e8 00 00 00 00	 call	 compiler_addop_o
  000c3	85 c0		 test	 eax, eax
  000c5	75 07		 jne	 SHORT $LN9@compiler_i@4
  000c7	33 c0		 xor	 eax, eax
  000c9	e9 bf 01 00 00	 jmp	 $LN14@compiler_i@4
$LN9@compiler_i@4:

; 2278 :         Py_DECREF(level);

  000ce	48 8b 4c 24 38	 mov	 rcx, QWORD PTR level$23813[rsp]
  000d3	e8 00 00 00 00	 call	 _Py_DecRef

; 2279 :         ADDOP_O(c, LOAD_CONST, Py_None, consts);

  000d8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000e0	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000e4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000eb	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  000ef	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000f4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000fc	e8 00 00 00 00	 call	 compiler_addop_o
  00101	85 c0		 test	 eax, eax
  00103	75 07		 jne	 SHORT $LN8@compiler_i@4
  00105	33 c0		 xor	 eax, eax
  00107	e9 81 01 00 00	 jmp	 $LN14@compiler_i@4
$LN8@compiler_i@4:

; 2280 :         ADDOP_NAME(c, IMPORT_NAME, alias->name, names);

  0010c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00114	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00118	48 8b 4c 24 40	 mov	 rcx, QWORD PTR alias$23810[rsp]
  0011d	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00120	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  00124	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  00129	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00131	e8 00 00 00 00	 call	 compiler_addop_name
  00136	85 c0		 test	 eax, eax
  00138	75 07		 jne	 SHORT $LN7@compiler_i@4
  0013a	33 c0		 xor	 eax, eax
  0013c	e9 4c 01 00 00	 jmp	 $LN14@compiler_i@4
$LN7@compiler_i@4:

; 2281 : 
; 2282 :         if (alias->asname) {

  00141	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23810[rsp]
  00146	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0014b	74 37		 je	 SHORT $LN6@compiler_i@4

; 2283 :             r = compiler_import_as(c, alias->name, alias->asname);

  0014d	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23810[rsp]
  00152	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00156	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23810[rsp]
  0015b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0015e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00166	e8 00 00 00 00	 call	 compiler_import_as
  0016b	89 44 24 48	 mov	 DWORD PTR r$23812[rsp], eax

; 2284 :             if (!r)

  0016f	83 7c 24 48 00	 cmp	 DWORD PTR r$23812[rsp], 0
  00174	75 09		 jne	 SHORT $LN5@compiler_i@4

; 2285 :                 return r;

  00176	8b 44 24 48	 mov	 eax, DWORD PTR r$23812[rsp]
  0017a	e9 0e 01 00 00	 jmp	 $LN14@compiler_i@4
$LN5@compiler_i@4:

; 2286 :         }
; 2287 :         else {

  0017f	e9 ff 00 00 00	 jmp	 $LN4@compiler_i@4
$LN6@compiler_i@4:

; 2288 :             identifier tmp = alias->name;

  00184	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23810[rsp]
  00189	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0018c	48 89 44 24 58	 mov	 QWORD PTR tmp$23823[rsp], rax

; 2289 :             Py_ssize_t dot = PyUnicode_FindChar(
; 2290 :                 alias->name, '.', 0, PyUnicode_GET_LENGTH(alias->name), 1);

  00191	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23810[rsp]
  00196	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00199	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0019d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001a3	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  001a8	85 c0		 test	 eax, eax
  001aa	75 1c		 jne	 SHORT $LN18@compiler_i@4
  001ac	41 b8 f2 08 00
	00		 mov	 r8d, 2290		; 000008f2H
  001b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@JBHGBMLI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001c6	33 c0		 xor	 eax, eax
$LN18@compiler_i@4:
  001c8	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23810[rsp]
  001cd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001d0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001d3	c1 e8 07	 shr	 eax, 7
  001d6	83 e0 01	 and	 eax, 1
  001d9	85 c0		 test	 eax, eax
  001db	75 1c		 jne	 SHORT $LN19@compiler_i@4
  001dd	41 b8 f2 08 00
	00		 mov	 r8d, 2290		; 000008f2H
  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@DIEOKLFE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f7	33 c0		 xor	 eax, eax
$LN19@compiler_i@4:
  001f9	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23810[rsp]
  001fe	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00201	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00209	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  0020d	45 33 c0	 xor	 r8d, r8d
  00210	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  00215	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23810[rsp]
  0021a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0021d	e8 00 00 00 00	 call	 PyUnicode_FindChar
  00222	48 89 44 24 50	 mov	 QWORD PTR dot$23824[rsp], rax

; 2291 :             if (dot != -1)

  00227	48 83 7c 24 50
	ff		 cmp	 QWORD PTR dot$23824[rsp], -1
  0022d	74 19		 je	 SHORT $LN3@compiler_i@4

; 2292 :                 tmp = PyUnicode_Substring(alias->name, 0, dot);

  0022f	4c 8b 44 24 50	 mov	 r8, QWORD PTR dot$23824[rsp]
  00234	33 d2		 xor	 edx, edx
  00236	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23810[rsp]
  0023b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0023e	e8 00 00 00 00	 call	 PyUnicode_Substring
  00243	48 89 44 24 58	 mov	 QWORD PTR tmp$23823[rsp], rax
$LN3@compiler_i@4:

; 2293 :             r = compiler_nameop(c, tmp, Store);

  00248	41 b8 02 00 00
	00		 mov	 r8d, 2
  0024e	48 8b 54 24 58	 mov	 rdx, QWORD PTR tmp$23823[rsp]
  00253	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0025b	e8 00 00 00 00	 call	 compiler_nameop
  00260	89 44 24 48	 mov	 DWORD PTR r$23812[rsp], eax

; 2294 :             if (dot != -1) {

  00264	48 83 7c 24 50
	ff		 cmp	 QWORD PTR dot$23824[rsp], -1
  0026a	74 0a		 je	 SHORT $LN2@compiler_i@4

; 2295 :                 Py_DECREF(tmp);

  0026c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tmp$23823[rsp]
  00271	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@compiler_i@4:

; 2296 :             }
; 2297 :             if (!r)

  00276	83 7c 24 48 00	 cmp	 DWORD PTR r$23812[rsp], 0
  0027b	75 06		 jne	 SHORT $LN1@compiler_i@4

; 2298 :                 return r;

  0027d	8b 44 24 48	 mov	 eax, DWORD PTR r$23812[rsp]
  00281	eb 0a		 jmp	 SHORT $LN14@compiler_i@4
$LN1@compiler_i@4:
$LN4@compiler_i@4:

; 2299 :         }
; 2300 :     }

  00283	e9 c6 fd ff ff	 jmp	 $LN12@compiler_i@4
$LN11@compiler_i@4:

; 2301 :     return 1;

  00288	b8 01 00 00 00	 mov	 eax, 1
$LN14@compiler_i@4:

; 2302 : }

  0028d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00291	c3		 ret	 0
compiler_import ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_addop_name DD imagerel compiler_addop_name
	DD	imagerel compiler_addop_name+132
	DD	imagerel $unwind$compiler_addop_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_addop_name DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_addop_name
_TEXT	SEGMENT
arg$ = 32
mangled$ = 40
c$ = 64
opcode$ = 72
dict$ = 80
o$ = 88
compiler_addop_name PROC				; COMDAT

; 1094 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1095 :     int arg;
; 1096 :     PyObject *mangled = _Py_Mangle(c->u->u_private, o);

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0001c	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00020	48 8b 54 24 58	 mov	 rdx, QWORD PTR o$[rsp]
  00025	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  00029	e8 00 00 00 00	 call	 _Py_Mangle
  0002e	48 89 44 24 28	 mov	 QWORD PTR mangled$[rsp], rax

; 1097 :     if (!mangled)

  00033	48 83 7c 24 28
	00		 cmp	 QWORD PTR mangled$[rsp], 0
  00039	75 04		 jne	 SHORT $LN2@compiler_a@6

; 1098 :         return 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 40		 jmp	 SHORT $LN3@compiler_a@6
$LN2@compiler_a@6:

; 1099 :     arg = compiler_add_o(c, dict, mangled);

  0003f	4c 8b 44 24 28	 mov	 r8, QWORD PTR mangled$[rsp]
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR dict$[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0004e	e8 00 00 00 00	 call	 compiler_add_o
  00053	89 44 24 20	 mov	 DWORD PTR arg$[rsp], eax

; 1100 :     Py_DECREF(mangled);

  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mangled$[rsp]
  0005c	e8 00 00 00 00	 call	 _Py_DecRef

; 1101 :     if (arg < 0)

  00061	83 7c 24 20 00	 cmp	 DWORD PTR arg$[rsp], 0
  00066	7d 04		 jge	 SHORT $LN1@compiler_a@6

; 1102 :         return 0;

  00068	33 c0		 xor	 eax, eax
  0006a	eb 13		 jmp	 SHORT $LN3@compiler_a@6
$LN1@compiler_a@6:

; 1103 :     return compiler_addop_i(c, opcode, arg);

  0006c	44 8b 44 24 20	 mov	 r8d, DWORD PTR arg$[rsp]
  00071	8b 54 24 48	 mov	 edx, DWORD PTR opcode$[rsp]
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0007a	e8 00 00 00 00	 call	 compiler_addop_i
$LN3@compiler_a@6:

; 1104 : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
compiler_addop_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_import_as DD imagerel compiler_import_as
	DD	imagerel compiler_import_as+637
	DD	imagerel $unwind$compiler_import_as
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_import_as DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'n', 00H
	DB	'a', 00H, 'm', 00H, 'e', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_import_as
_TEXT	SEGMENT
dot$ = 48
pos$23779 = 56
attr$23783 = 64
tv166 = 72
c$ = 96
name$ = 104
asname$ = 112
compiler_import_as PROC					; COMDAT

; 2223 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2224 :     /* The IMPORT_NAME opcode was already generated.  This function
; 2225 :        merely needs to bind the result to a name.
; 2226 : 
; 2227 :        If there is a dot in name, we need to split it and emit a
; 2228 :        LOAD_ATTR for each name.
; 2229 :     */
; 2230 :     Py_ssize_t dot = PyUnicode_FindChar(name, '.', 0,
; 2231 :                                         PyUnicode_GET_LENGTH(name), 1);

  00013	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00027	85 c0		 test	 eax, eax
  00029	75 1c		 jne	 SHORT $LN10@compiler_i@5
  0002b	41 b8 b7 08 00
	00		 mov	 r8d, 2231		; 000008b7H
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00045	33 c0		 xor	 eax, eax
$LN10@compiler_i@5:
  00047	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  0004c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0004f	c1 e8 07	 shr	 eax, 7
  00052	83 e0 01	 and	 eax, 1
  00055	85 c0		 test	 eax, eax
  00057	75 1c		 jne	 SHORT $LN11@compiler_i@5
  00059	41 b8 b7 08 00
	00		 mov	 r8d, 2231		; 000008b7H
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00073	33 c0		 xor	 eax, eax
$LN11@compiler_i@5:
  00075	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  00082	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  00086	45 33 c0	 xor	 r8d, r8d
  00089	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  0008e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR name$[rsp]
  00093	e8 00 00 00 00	 call	 PyUnicode_FindChar
  00098	48 89 44 24 30	 mov	 QWORD PTR dot$[rsp], rax

; 2232 :     if (dot == -2)

  0009d	48 83 7c 24 30
	fe		 cmp	 QWORD PTR dot$[rsp], -2
  000a3	75 0a		 jne	 SHORT $LN7@compiler_i@5

; 2233 :         return -1;

  000a5	b8 ff ff ff ff	 mov	 eax, -1
  000aa	e9 c9 01 00 00	 jmp	 $LN8@compiler_i@5
$LN7@compiler_i@5:

; 2234 :     if (dot != -1) {

  000af	48 83 7c 24 30
	ff		 cmp	 QWORD PTR dot$[rsp], -1
  000b5	0f 84 a8 01 00
	00		 je	 $LN6@compiler_i@5

; 2235 :         /* Consume the base module name to get the first attribute */
; 2236 :         Py_ssize_t pos = dot + 1;

  000bb	48 8b 44 24 30	 mov	 rax, QWORD PTR dot$[rsp]
  000c0	48 ff c0	 inc	 rax
  000c3	48 89 44 24 38	 mov	 QWORD PTR pos$23779[rsp], rax
$LN5@compiler_i@5:

; 2237 :         while (dot != -1) {

  000c8	48 83 7c 24 30
	ff		 cmp	 QWORD PTR dot$[rsp], -1
  000ce	0f 84 8f 01 00
	00		 je	 $LN4@compiler_i@5

; 2238 :             PyObject *attr;
; 2239 :             dot = PyUnicode_FindChar(name, '.', pos,
; 2240 :                                      PyUnicode_GET_LENGTH(name), 1);

  000d4	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  000d9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000dd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000e3	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000e8	85 c0		 test	 eax, eax
  000ea	75 1c		 jne	 SHORT $LN12@compiler_i@5
  000ec	41 b8 c0 08 00
	00		 mov	 r8d, 2240		; 000008c0H
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00106	33 c0		 xor	 eax, eax
$LN12@compiler_i@5:
  00108	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  0010d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00110	c1 e8 07	 shr	 eax, 7
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	75 1c		 jne	 SHORT $LN13@compiler_i@5
  0011a	41 b8 c0 08 00
	00		 mov	 r8d, 2240		; 000008c0H
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00134	33 c0		 xor	 eax, eax
$LN13@compiler_i@5:
  00136	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0013e	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  00143	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  00147	4c 8b 44 24 38	 mov	 r8, QWORD PTR pos$23779[rsp]
  0014c	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  00151	48 8b 4c 24 68	 mov	 rcx, QWORD PTR name$[rsp]
  00156	e8 00 00 00 00	 call	 PyUnicode_FindChar
  0015b	48 89 44 24 30	 mov	 QWORD PTR dot$[rsp], rax

; 2241 :             if (dot == -2)

  00160	48 83 7c 24 30
	fe		 cmp	 QWORD PTR dot$[rsp], -2
  00166	75 0a		 jne	 SHORT $LN3@compiler_i@5

; 2242 :                 return -1;

  00168	b8 ff ff ff ff	 mov	 eax, -1
  0016d	e9 06 01 00 00	 jmp	 $LN8@compiler_i@5
$LN3@compiler_i@5:

; 2243 :             attr = PyUnicode_Substring(name, pos,
; 2244 :                                        (dot != -1) ? dot :
; 2245 :                                        PyUnicode_GET_LENGTH(name));

  00172	48 83 7c 24 30
	ff		 cmp	 QWORD PTR dot$[rsp], -1
  00178	74 0c		 je	 SHORT $LN16@compiler_i@5
  0017a	48 8b 44 24 30	 mov	 rax, QWORD PTR dot$[rsp]
  0017f	48 89 44 24 48	 mov	 QWORD PTR tv166[rsp], rax
  00184	eb 70		 jmp	 SHORT $LN17@compiler_i@5
$LN16@compiler_i@5:
  00186	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  0018b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0018f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00195	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0019a	85 c0		 test	 eax, eax
  0019c	75 1c		 jne	 SHORT $LN14@compiler_i@5
  0019e	41 b8 c5 08 00
	00		 mov	 r8d, 2245		; 000008c5H
  001a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b8	33 c0		 xor	 eax, eax
$LN14@compiler_i@5:
  001ba	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  001bf	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001c2	c1 e8 07	 shr	 eax, 7
  001c5	83 e0 01	 and	 eax, 1
  001c8	85 c0		 test	 eax, eax
  001ca	75 1c		 jne	 SHORT $LN15@compiler_i@5
  001cc	41 b8 c5 08 00
	00		 mov	 r8d, 2245		; 000008c5H
  001d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  001e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001e6	33 c0		 xor	 eax, eax
$LN15@compiler_i@5:
  001e8	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  001ed	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001f1	48 89 44 24 48	 mov	 QWORD PTR tv166[rsp], rax
$LN17@compiler_i@5:
  001f6	4c 8b 44 24 48	 mov	 r8, QWORD PTR tv166[rsp]
  001fb	48 8b 54 24 38	 mov	 rdx, QWORD PTR pos$23779[rsp]
  00200	48 8b 4c 24 68	 mov	 rcx, QWORD PTR name$[rsp]
  00205	e8 00 00 00 00	 call	 PyUnicode_Substring
  0020a	48 89 44 24 40	 mov	 QWORD PTR attr$23783[rsp], rax

; 2246 :             if (!attr)

  0020f	48 83 7c 24 40
	00		 cmp	 QWORD PTR attr$23783[rsp], 0
  00215	75 07		 jne	 SHORT $LN2@compiler_i@5

; 2247 :                 return -1;

  00217	b8 ff ff ff ff	 mov	 eax, -1
  0021c	eb 5a		 jmp	 SHORT $LN8@compiler_i@5
$LN2@compiler_i@5:

; 2248 :             ADDOP_O(c, LOAD_ATTR, attr, names);

  0021e	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00223	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00227	4c 8b 4c 24 40	 mov	 r9, QWORD PTR attr$23783[rsp]
  0022c	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  00230	ba 6a 00 00 00	 mov	 edx, 106		; 0000006aH
  00235	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0023a	e8 00 00 00 00	 call	 compiler_addop_o
  0023f	85 c0		 test	 eax, eax
  00241	75 04		 jne	 SHORT $LN1@compiler_i@5
  00243	33 c0		 xor	 eax, eax
  00245	eb 31		 jmp	 SHORT $LN8@compiler_i@5
$LN1@compiler_i@5:

; 2249 :             Py_DECREF(attr);

  00247	48 8b 4c 24 40	 mov	 rcx, QWORD PTR attr$23783[rsp]
  0024c	e8 00 00 00 00	 call	 _Py_DecRef

; 2250 :             pos = dot + 1;

  00251	48 8b 44 24 30	 mov	 rax, QWORD PTR dot$[rsp]
  00256	48 ff c0	 inc	 rax
  00259	48 89 44 24 38	 mov	 QWORD PTR pos$23779[rsp], rax

; 2251 :         }

  0025e	e9 65 fe ff ff	 jmp	 $LN5@compiler_i@5
$LN4@compiler_i@5:
$LN6@compiler_i@5:

; 2252 :     }
; 2253 :     return compiler_nameop(c, asname, Store);

  00263	41 b8 02 00 00
	00		 mov	 r8d, 2
  00269	48 8b 54 24 70	 mov	 rdx, QWORD PTR asname$[rsp]
  0026e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00273	e8 00 00 00 00	 call	 compiler_nameop
$LN8@compiler_i@5:

; 2254 : }

  00278	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0027c	c3		 ret	 0
compiler_import_as ENDP
_TEXT	ENDS
PUBLIC	??_C@_1O@LNMNFCLP@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FM@MLDOEAKC@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_1EE@FKNLEGLH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@ ; `string'
PUBLIC	??_C@_0L@GKAJCJCM@__future__?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PyUnicode_CompareWithASCIIString:PROC
EXTRN	PyUnicode_FromString:PROC
_BSS	SEGMENT
?empty_string@?1??compiler_from_import@@9@9 DQ 01H DUP (?) ; `compiler_from_import'::`2'::empty_string
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_from_import DD imagerel compiler_from_import
	DD	imagerel compiler_from_import+2394
	DD	imagerel $unwind$compiler_from_import
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_from_import DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_1O@LNMNFCLP@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1O@LNMNFCLP@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'n', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FM@MLDOEAKC@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe@
CONST	SEGMENT
??_C@_1FM@MLDOEAKC@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'(', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'a', 00H, 's', 00H, '-'
	DB	00H, '>', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ')', 00H
	DB	')', 00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't'
	DB	00H, 'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@FKNLEGLH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ@
CONST	SEGMENT
??_C@_1EE@FKNLEGLH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, '(', 00H
	DB	'a', 00H, 'l', 00H, 'i', 00H, 'a', 00H, 's', 00H, '-', 00H, '>'
	DB	00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ')', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, '(', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'a', 00H, 's', 00H, '-', 00H, '>', 00H, 'n', 00H, 'a', 00H, 'm'
	DB	00H, 'e', 00H, ')', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@
CONST	SEGMENT
??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@ DB 'from __futur'
	DB	'e__ imports must occur at the beginning of the file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GKAJCJCM@__future__?$AA@
CONST	SEGMENT
??_C@_0L@GKAJCJCM@__future__?$AA@ DB '__future__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_from_import
_TEXT	SEGMENT
level$ = 32
n$ = 40
i$ = 44
names$ = 48
alias$23858 = 56
alias$23878 = 64
store_name$23880 = 72
tv68 = 80
tv257 = 88
tv266 = 96
tv376 = 104
tv321 = 112
tv330 = 120
tv375 = 128
tv365 = 136
tv374 = 144
c$ = 176
s$ = 184
compiler_from_import PROC				; COMDAT

; 2306 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2307 :     int i, n = asdl_seq_LEN(s->v.ImportFrom.names);

  00011	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00019	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0001e	75 0b		 jne	 SHORT $LN26@compiler_f@4
  00020	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
  00029	eb 14		 jmp	 SHORT $LN27@compiler_f@4
$LN26@compiler_f@4:
  0002b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00033	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00037	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003a	48 89 44 24 50	 mov	 QWORD PTR tv68[rsp], rax
$LN27@compiler_f@4:
  0003f	8b 44 24 50	 mov	 eax, DWORD PTR tv68[rsp]
  00043	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 2308 : 
; 2309 :     PyObject *names = PyTuple_New(n);

  00047	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$[rsp]
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	e8 00 00 00 00	 call	 PyTuple_New
  00054	48 89 44 24 30	 mov	 QWORD PTR names$[rsp], rax

; 2310 :     PyObject *level;
; 2311 :     static PyObject *empty_string;
; 2312 : 
; 2313 :     if (!empty_string) {

  00059	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?empty_string@?1??compiler_from_import@@9@9, 0
  00061	75 24		 jne	 SHORT $LN23@compiler_f@4

; 2314 :         empty_string = PyUnicode_FromString("");

  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0006a	e8 00 00 00 00	 call	 PyUnicode_FromString
  0006f	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?empty_string@?1??compiler_from_import@@9@9, rax

; 2315 :         if (!empty_string)

  00076	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?empty_string@?1??compiler_from_import@@9@9, 0
  0007e	75 07		 jne	 SHORT $LN22@compiler_f@4

; 2316 :             return 0;

  00080	33 c0		 xor	 eax, eax
  00082	e9 cb 08 00 00	 jmp	 $LN24@compiler_f@4
$LN22@compiler_f@4:
$LN23@compiler_f@4:

; 2317 :     }
; 2318 : 
; 2319 :     if (!names)

  00087	48 83 7c 24 30
	00		 cmp	 QWORD PTR names$[rsp], 0
  0008d	75 07		 jne	 SHORT $LN21@compiler_f@4

; 2320 :         return 0;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 bc 08 00 00	 jmp	 $LN24@compiler_f@4
$LN21@compiler_f@4:

; 2321 : 
; 2322 :     level = PyLong_FromLong(s->v.ImportFrom.level);

  00096	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0009e	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000a1	e8 00 00 00 00	 call	 PyLong_FromLong
  000a6	48 89 44 24 20	 mov	 QWORD PTR level$[rsp], rax

; 2323 :     if (!level) {

  000ab	48 83 7c 24 20
	00		 cmp	 QWORD PTR level$[rsp], 0
  000b1	75 11		 jne	 SHORT $LN20@compiler_f@4

; 2324 :         Py_DECREF(names);

  000b3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR names$[rsp]
  000b8	e8 00 00 00 00	 call	 _Py_DecRef

; 2325 :         return 0;

  000bd	33 c0		 xor	 eax, eax
  000bf	e9 8e 08 00 00	 jmp	 $LN24@compiler_f@4
$LN20@compiler_f@4:

; 2326 :     }
; 2327 : 
; 2328 :     /* build up the names */
; 2329 :     for (i = 0; i < n; i++) {

  000c4	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000cc	eb 0a		 jmp	 SHORT $LN19@compiler_f@4
$LN18@compiler_f@4:
  000ce	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  000d2	ff c0		 inc	 eax
  000d4	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN19@compiler_f@4:
  000d8	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  000dc	39 44 24 2c	 cmp	 DWORD PTR i$[rsp], eax
  000e0	7d 41		 jge	 SHORT $LN17@compiler_f@4

; 2330 :         alias_ty alias = (alias_ty)asdl_seq_GET(s->v.ImportFrom.names, i);

  000e2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000ea	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ee	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f3	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  000f8	48 89 44 24 38	 mov	 QWORD PTR alias$23858[rsp], rax

; 2331 :         Py_INCREF(alias->name);

  000fd	48 8b 44 24 38	 mov	 rax, QWORD PTR alias$23858[rsp]
  00102	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00105	e8 00 00 00 00	 call	 _Py_IncRef

; 2332 :         PyTuple_SET_ITEM(names, i, alias->name);

  0010a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i$[rsp]
  0010f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR names$[rsp]
  00114	48 8b 54 24 38	 mov	 rdx, QWORD PTR alias$23858[rsp]
  00119	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0011c	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 2333 :     }

  00121	eb ab		 jmp	 SHORT $LN18@compiler_f@4
$LN17@compiler_f@4:

; 2334 : 
; 2335 :     if (s->lineno > c->c_future->ff_lineno && s->v.ImportFrom.module &&
; 2336 :         !PyUnicode_CompareWithASCIIString(s->v.ImportFrom.module, "__future__")) {

  00123	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0012b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0012f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00137	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0013a	39 41 40	 cmp	 DWORD PTR [rcx+64], eax
  0013d	7e 58		 jle	 SHORT $LN16@compiler_f@4
  0013f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00147	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0014c	74 49		 je	 SHORT $LN16@compiler_f@4
  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@GKAJCJCM@__future__?$AA@
  00155	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0015d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00161	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  00166	85 c0		 test	 eax, eax
  00168	75 2d		 jne	 SHORT $LN16@compiler_f@4

; 2337 :         Py_DECREF(level);

  0016a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR level$[rsp]
  0016f	e8 00 00 00 00	 call	 _Py_DecRef

; 2338 :         Py_DECREF(names);

  00174	48 8b 4c 24 30	 mov	 rcx, QWORD PTR names$[rsp]
  00179	e8 00 00 00 00	 call	 _Py_DecRef

; 2339 :         return compiler_error(c, "from __future__ imports must occur "
; 2340 :                               "at the beginning of the file");

  0017e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@
  00185	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0018d	e8 00 00 00 00	 call	 compiler_error
  00192	e9 bb 07 00 00	 jmp	 $LN24@compiler_f@4
$LN16@compiler_f@4:

; 2341 :     }
; 2342 : 
; 2343 :     ADDOP_O(c, LOAD_CONST, level, consts);

  00197	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0019f	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001a3	4c 8b 4c 24 20	 mov	 r9, QWORD PTR level$[rsp]
  001a8	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  001ac	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  001b1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001b9	e8 00 00 00 00	 call	 compiler_addop_o
  001be	85 c0		 test	 eax, eax
  001c0	75 07		 jne	 SHORT $LN15@compiler_f@4
  001c2	33 c0		 xor	 eax, eax
  001c4	e9 89 07 00 00	 jmp	 $LN24@compiler_f@4
$LN15@compiler_f@4:

; 2344 :     Py_DECREF(level);

  001c9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR level$[rsp]
  001ce	e8 00 00 00 00	 call	 _Py_DecRef

; 2345 :     ADDOP_O(c, LOAD_CONST, names, consts);

  001d3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  001db	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001df	4c 8b 4c 24 30	 mov	 r9, QWORD PTR names$[rsp]
  001e4	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  001e8	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  001ed	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001f5	e8 00 00 00 00	 call	 compiler_addop_o
  001fa	85 c0		 test	 eax, eax
  001fc	75 07		 jne	 SHORT $LN14@compiler_f@4
  001fe	33 c0		 xor	 eax, eax
  00200	e9 4d 07 00 00	 jmp	 $LN24@compiler_f@4
$LN14@compiler_f@4:

; 2346 :     Py_DECREF(names);

  00205	48 8b 4c 24 30	 mov	 rcx, QWORD PTR names$[rsp]
  0020a	e8 00 00 00 00	 call	 _Py_DecRef

; 2347 :     if (s->v.ImportFrom.module) {

  0020f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00217	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0021c	74 3b		 je	 SHORT $LN13@compiler_f@4

; 2348 :         ADDOP_NAME(c, IMPORT_NAME, s->v.ImportFrom.module, names);

  0021e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00226	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0022a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00232	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]
  00236	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  0023a	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  0023f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00247	e8 00 00 00 00	 call	 compiler_addop_name
  0024c	85 c0		 test	 eax, eax
  0024e	75 07		 jne	 SHORT $LN12@compiler_f@4
  00250	33 c0		 xor	 eax, eax
  00252	e9 fb 06 00 00	 jmp	 $LN24@compiler_f@4
$LN12@compiler_f@4:

; 2349 :     }
; 2350 :     else {

  00257	eb 34		 jmp	 SHORT $LN11@compiler_f@4
$LN13@compiler_f@4:

; 2351 :         ADDOP_NAME(c, IMPORT_NAME, empty_string, names);

  00259	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00261	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00265	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?empty_string@?1??compiler_from_import@@9@9
  0026c	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  00270	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  00275	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0027d	e8 00 00 00 00	 call	 compiler_addop_name
  00282	85 c0		 test	 eax, eax
  00284	75 07		 jne	 SHORT $LN10@compiler_f@4
  00286	33 c0		 xor	 eax, eax
  00288	e9 c5 06 00 00	 jmp	 $LN24@compiler_f@4
$LN10@compiler_f@4:
$LN11@compiler_f@4:

; 2352 :     }
; 2353 :     for (i = 0; i < n; i++) {

  0028d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00295	eb 0a		 jmp	 SHORT $LN9@compiler_f@4
$LN8@compiler_f@4:
  00297	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  0029b	ff c0		 inc	 eax
  0029d	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN9@compiler_f@4:
  002a1	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  002a5	39 44 24 2c	 cmp	 DWORD PTR i$[rsp], eax
  002a9	0f 8d 84 06 00
	00		 jge	 $LN7@compiler_f@4

; 2354 :         alias_ty alias = (alias_ty)asdl_seq_GET(s->v.ImportFrom.names, i);

  002af	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002b7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002bb	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i$[rsp]
  002c0	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  002c5	48 89 44 24 40	 mov	 QWORD PTR alias$23878[rsp], rax

; 2355 :         identifier store_name;
; 2356 : 
; 2357 :         if (i == 0 && PyUnicode_READ_CHAR(alias->name, 0) == '*') {

  002ca	83 7c 24 2c 00	 cmp	 DWORD PTR i$[rsp], 0
  002cf	0f 85 d6 05 00
	00		 jne	 $LN6@compiler_f@4
  002d5	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  002da	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002dd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002e1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002e7	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  002ec	85 c0		 test	 eax, eax
  002ee	75 1c		 jne	 SHORT $LN28@compiler_f@4
  002f0	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  002f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@JBHGBMLI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  00304	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0030a	33 c0		 xor	 eax, eax
$LN28@compiler_f@4:
  0030c	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00311	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00314	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00317	c1 e8 07	 shr	 eax, 7
  0031a	83 e0 01	 and	 eax, 1
  0031d	85 c0		 test	 eax, eax
  0031f	75 1c		 jne	 SHORT $LN29@compiler_f@4
  00321	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  00327	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0032e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@DIEOKLFE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0033b	33 c0		 xor	 eax, eax
$LN29@compiler_f@4:
  0033d	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00342	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00345	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00349	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0034f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00354	85 c0		 test	 eax, eax
  00356	75 1c		 jne	 SHORT $LN30@compiler_f@4
  00358	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  0035e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00365	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0036c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00372	33 c0		 xor	 eax, eax
$LN30@compiler_f@4:
  00374	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00379	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0037c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0037f	c1 e8 07	 shr	 eax, 7
  00382	83 e0 01	 and	 eax, 1
  00385	85 c0		 test	 eax, eax
  00387	75 1c		 jne	 SHORT $LN31@compiler_f@4
  00389	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  0038f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00396	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@FKNLEGLH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ@
  0039d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003a3	33 c0		 xor	 eax, eax
$LN31@compiler_f@4:
  003a5	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  003aa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003ad	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003b0	c1 e8 02	 shr	 eax, 2
  003b3	83 e0 07	 and	 eax, 7
  003b6	83 f8 01	 cmp	 eax, 1
  003b9	0f 85 54 01 00
	00		 jne	 $LN60@compiler_f@4
  003bf	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  003c4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003cb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003d1	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  003d6	85 c0		 test	 eax, eax
  003d8	75 1c		 jne	 SHORT $LN32@compiler_f@4
  003da	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  003e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  003e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  003ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003f4	33 c0		 xor	 eax, eax
$LN32@compiler_f@4:
  003f6	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  003fb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003fe	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00401	c1 e8 05	 shr	 eax, 5
  00404	83 e0 01	 and	 eax, 1
  00407	85 c0		 test	 eax, eax
  00409	0f 84 b1 00 00
	00		 je	 $LN38@compiler_f@4
  0040f	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00414	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00417	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0041b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00421	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00426	85 c0		 test	 eax, eax
  00428	75 1c		 jne	 SHORT $LN33@compiler_f@4
  0042a	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  00430	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00437	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0043e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00444	33 c0		 xor	 eax, eax
$LN33@compiler_f@4:
  00446	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  0044b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0044e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00451	c1 e8 07	 shr	 eax, 7
  00454	83 e0 01	 and	 eax, 1
  00457	85 c0		 test	 eax, eax
  00459	75 1c		 jne	 SHORT $LN34@compiler_f@4
  0045b	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  00461	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00468	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@FKNLEGLH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ@
  0046f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00475	33 c0		 xor	 eax, eax
$LN34@compiler_f@4:
  00477	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  0047c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0047f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00482	c1 e8 06	 shr	 eax, 6
  00485	83 e0 01	 and	 eax, 1
  00488	85 c0		 test	 eax, eax
  0048a	74 15		 je	 SHORT $LN35@compiler_f@4
  0048c	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00491	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00494	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0049a	48 89 44 24 58	 mov	 QWORD PTR tv257[rsp], rax
  0049f	eb 13		 jmp	 SHORT $LN36@compiler_f@4
$LN35@compiler_f@4:
  004a1	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  004a6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004a9	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  004af	48 89 44 24 58	 mov	 QWORD PTR tv257[rsp], rax
$LN36@compiler_f@4:
  004b4	48 8b 44 24 58	 mov	 rax, QWORD PTR tv257[rsp]
  004b9	48 89 44 24 60	 mov	 QWORD PTR tv266[rsp], rax
  004be	eb 42		 jmp	 SHORT $LN39@compiler_f@4
$LN38@compiler_f@4:
  004c0	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  004c5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004c8	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  004d0	75 1c		 jne	 SHORT $LN37@compiler_f@4
  004d2	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  004d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  004df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@MLDOEAKC@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe@
  004e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004ec	33 c0		 xor	 eax, eax
$LN37@compiler_f@4:
  004ee	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  004f3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f6	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  004fd	48 89 44 24 60	 mov	 QWORD PTR tv266[rsp], rax
$LN39@compiler_f@4:
  00502	48 8b 44 24 60	 mov	 rax, QWORD PTR tv266[rsp]
  00507	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0050a	89 44 24 68	 mov	 DWORD PTR tv376[rsp], eax
  0050e	e9 47 03 00 00	 jmp	 $LN61@compiler_f@4
$LN60@compiler_f@4:
  00513	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00518	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0051b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0051f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00525	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0052a	85 c0		 test	 eax, eax
  0052c	75 1c		 jne	 SHORT $LN40@compiler_f@4
  0052e	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  00534	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0053b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00542	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00548	33 c0		 xor	 eax, eax
$LN40@compiler_f@4:
  0054a	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  0054f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00552	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00555	c1 e8 07	 shr	 eax, 7
  00558	83 e0 01	 and	 eax, 1
  0055b	85 c0		 test	 eax, eax
  0055d	75 1c		 jne	 SHORT $LN41@compiler_f@4
  0055f	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  00565	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0056c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@FKNLEGLH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ@
  00573	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00579	33 c0		 xor	 eax, eax
$LN41@compiler_f@4:
  0057b	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00580	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00583	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00586	c1 e8 02	 shr	 eax, 2
  00589	83 e0 07	 and	 eax, 7
  0058c	83 f8 02	 cmp	 eax, 2
  0058f	0f 85 57 01 00
	00		 jne	 $LN58@compiler_f@4
  00595	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  0059a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0059d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005a1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005a7	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  005ac	85 c0		 test	 eax, eax
  005ae	75 1c		 jne	 SHORT $LN42@compiler_f@4
  005b0	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  005b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  005bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  005c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005ca	33 c0		 xor	 eax, eax
$LN42@compiler_f@4:
  005cc	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  005d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005d4	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  005d7	c1 e8 05	 shr	 eax, 5
  005da	83 e0 01	 and	 eax, 1
  005dd	85 c0		 test	 eax, eax
  005df	0f 84 b1 00 00
	00		 je	 $LN48@compiler_f@4
  005e5	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  005ea	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005ed	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005f1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005f7	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  005fc	85 c0		 test	 eax, eax
  005fe	75 1c		 jne	 SHORT $LN43@compiler_f@4
  00600	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  00606	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0060d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00614	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0061a	33 c0		 xor	 eax, eax
$LN43@compiler_f@4:
  0061c	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00621	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00624	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00627	c1 e8 07	 shr	 eax, 7
  0062a	83 e0 01	 and	 eax, 1
  0062d	85 c0		 test	 eax, eax
  0062f	75 1c		 jne	 SHORT $LN44@compiler_f@4
  00631	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  00637	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0063e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@FKNLEGLH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ@
  00645	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0064b	33 c0		 xor	 eax, eax
$LN44@compiler_f@4:
  0064d	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00652	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00655	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00658	c1 e8 06	 shr	 eax, 6
  0065b	83 e0 01	 and	 eax, 1
  0065e	85 c0		 test	 eax, eax
  00660	74 15		 je	 SHORT $LN45@compiler_f@4
  00662	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00667	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0066a	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00670	48 89 44 24 70	 mov	 QWORD PTR tv321[rsp], rax
  00675	eb 13		 jmp	 SHORT $LN46@compiler_f@4
$LN45@compiler_f@4:
  00677	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  0067c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0067f	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00685	48 89 44 24 70	 mov	 QWORD PTR tv321[rsp], rax
$LN46@compiler_f@4:
  0068a	48 8b 44 24 70	 mov	 rax, QWORD PTR tv321[rsp]
  0068f	48 89 44 24 78	 mov	 QWORD PTR tv330[rsp], rax
  00694	eb 42		 jmp	 SHORT $LN49@compiler_f@4
$LN48@compiler_f@4:
  00696	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  0069b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0069e	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  006a6	75 1c		 jne	 SHORT $LN47@compiler_f@4
  006a8	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  006ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  006b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@MLDOEAKC@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe@
  006bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006c2	33 c0		 xor	 eax, eax
$LN47@compiler_f@4:
  006c4	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  006c9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006cc	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  006d3	48 89 44 24 78	 mov	 QWORD PTR tv330[rsp], rax
$LN49@compiler_f@4:
  006d8	48 8b 44 24 78	 mov	 rax, QWORD PTR tv330[rsp]
  006dd	0f b7 00	 movzx	 eax, WORD PTR [rax]
  006e0	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv375[rsp], eax
  006e7	e9 63 01 00 00	 jmp	 $LN59@compiler_f@4
$LN58@compiler_f@4:
  006ec	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  006f1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006f4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  006f8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  006fe	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00703	85 c0		 test	 eax, eax
  00705	75 1c		 jne	 SHORT $LN50@compiler_f@4
  00707	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  0070d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00714	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0071b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00721	33 c0		 xor	 eax, eax
$LN50@compiler_f@4:
  00723	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00728	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0072b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0072e	c1 e8 05	 shr	 eax, 5
  00731	83 e0 01	 and	 eax, 1
  00734	85 c0		 test	 eax, eax
  00736	0f 84 bd 00 00
	00		 je	 $LN56@compiler_f@4
  0073c	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00741	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00744	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00748	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0074e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00753	85 c0		 test	 eax, eax
  00755	75 1c		 jne	 SHORT $LN51@compiler_f@4
  00757	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  0075d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00764	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@LOPGPHBF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0076b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00771	33 c0		 xor	 eax, eax
$LN51@compiler_f@4:
  00773	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  00778	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0077b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0077e	c1 e8 07	 shr	 eax, 7
  00781	83 e0 01	 and	 eax, 1
  00784	85 c0		 test	 eax, eax
  00786	75 1c		 jne	 SHORT $LN52@compiler_f@4
  00788	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  0078e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00795	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@FKNLEGLH@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe?$AA?$CJ@
  0079c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  007a2	33 c0		 xor	 eax, eax
$LN52@compiler_f@4:
  007a4	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  007a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007ac	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  007af	c1 e8 06	 shr	 eax, 6
  007b2	83 e0 01	 and	 eax, 1
  007b5	85 c0		 test	 eax, eax
  007b7	74 18		 je	 SHORT $LN53@compiler_f@4
  007b9	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  007be	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007c1	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  007c7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv365[rsp], rax
  007cf	eb 16		 jmp	 SHORT $LN54@compiler_f@4
$LN53@compiler_f@4:
  007d1	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  007d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007d9	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  007df	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv365[rsp], rax
$LN54@compiler_f@4:
  007e7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv365[rsp]
  007ef	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv374[rsp], rax
  007f7	eb 45		 jmp	 SHORT $LN57@compiler_f@4
$LN56@compiler_f@4:
  007f9	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  007fe	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00801	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00809	75 1c		 jne	 SHORT $LN55@compiler_f@4
  0080b	41 b8 35 09 00
	00		 mov	 r8d, 2357		; 00000935H
  00811	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00818	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@MLDOEAKC@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAa?$AAm?$AAe@
  0081f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00825	33 c0		 xor	 eax, eax
$LN55@compiler_f@4:
  00827	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  0082c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0082f	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00836	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv374[rsp], rax
$LN57@compiler_f@4:
  0083e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv374[rsp]
  00846	8b 00		 mov	 eax, DWORD PTR [rax]
  00848	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv375[rsp], eax
$LN59@compiler_f@4:
  0084f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv375[rsp]
  00856	89 44 24 68	 mov	 DWORD PTR tv376[rsp], eax
$LN61@compiler_f@4:
  0085a	83 7c 24 68 2a	 cmp	 DWORD PTR tv376[rsp], 42 ; 0000002aH
  0085f	75 4a		 jne	 SHORT $LN6@compiler_f@4

; 2358 :             assert(n == 1);

  00861	83 7c 24 28 01	 cmp	 DWORD PTR n$[rsp], 1
  00866	74 1c		 je	 SHORT $LN62@compiler_f@4
  00868	41 b8 36 09 00
	00		 mov	 r8d, 2358		; 00000936H
  0086e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00875	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@LNMNFCLP@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0087c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00882	33 c0		 xor	 eax, eax
$LN62@compiler_f@4:

; 2359 :             ADDOP(c, IMPORT_STAR);

  00884	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  00889	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00891	e8 00 00 00 00	 call	 compiler_addop
  00896	85 c0		 test	 eax, eax
  00898	75 07		 jne	 SHORT $LN5@compiler_f@4
  0089a	33 c0		 xor	 eax, eax
  0089c	e9 b1 00 00 00	 jmp	 $LN24@compiler_f@4
$LN5@compiler_f@4:

; 2360 :             return 1;

  008a1	b8 01 00 00 00	 mov	 eax, 1
  008a6	e9 a7 00 00 00	 jmp	 $LN24@compiler_f@4
$LN6@compiler_f@4:

; 2361 :         }
; 2362 : 
; 2363 :         ADDOP_NAME(c, IMPORT_FROM, alias->name, names);

  008ab	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  008b3	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  008b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR alias$23878[rsp]
  008bc	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  008bf	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  008c3	ba 6d 00 00 00	 mov	 edx, 109		; 0000006dH
  008c8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  008d0	e8 00 00 00 00	 call	 compiler_addop_name
  008d5	85 c0		 test	 eax, eax
  008d7	75 04		 jne	 SHORT $LN4@compiler_f@4
  008d9	33 c0		 xor	 eax, eax
  008db	eb 75		 jmp	 SHORT $LN24@compiler_f@4
$LN4@compiler_f@4:

; 2364 :         store_name = alias->name;

  008dd	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  008e2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008e5	48 89 44 24 48	 mov	 QWORD PTR store_name$23880[rsp], rax

; 2365 :         if (alias->asname)

  008ea	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  008ef	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  008f4	74 0e		 je	 SHORT $LN3@compiler_f@4

; 2366 :             store_name = alias->asname;

  008f6	48 8b 44 24 40	 mov	 rax, QWORD PTR alias$23878[rsp]
  008fb	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  008ff	48 89 44 24 48	 mov	 QWORD PTR store_name$23880[rsp], rax
$LN3@compiler_f@4:

; 2367 : 
; 2368 :         if (!compiler_nameop(c, store_name, Store)) {

  00904	41 b8 02 00 00
	00		 mov	 r8d, 2
  0090a	48 8b 54 24 48	 mov	 rdx, QWORD PTR store_name$23880[rsp]
  0090f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00917	e8 00 00 00 00	 call	 compiler_nameop
  0091c	85 c0		 test	 eax, eax
  0091e	75 0e		 jne	 SHORT $LN2@compiler_f@4

; 2369 :             Py_DECREF(names);

  00920	48 8b 4c 24 30	 mov	 rcx, QWORD PTR names$[rsp]
  00925	e8 00 00 00 00	 call	 _Py_DecRef

; 2370 :             return 0;

  0092a	33 c0		 xor	 eax, eax
  0092c	eb 24		 jmp	 SHORT $LN24@compiler_f@4
$LN2@compiler_f@4:

; 2371 :         }
; 2372 :     }

  0092e	e9 64 f9 ff ff	 jmp	 $LN8@compiler_f@4
$LN7@compiler_f@4:

; 2373 :     /* remove imported module */
; 2374 :     ADDOP(c, POP_TOP);

  00933	ba 01 00 00 00	 mov	 edx, 1
  00938	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00940	e8 00 00 00 00	 call	 compiler_addop
  00945	85 c0		 test	 eax, eax
  00947	75 04		 jne	 SHORT $LN1@compiler_f@4
  00949	33 c0		 xor	 eax, eax
  0094b	eb 05		 jmp	 SHORT $LN24@compiler_f@4
$LN1@compiler_f@4:

; 2375 :     return 1;

  0094d	b8 01 00 00 00	 mov	 eax, 1
$LN24@compiler_f@4:

; 2376 : }

  00952	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00959	c3		 ret	 0
compiler_from_import ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@LAKOGDJB@assertion?5is?5always?5true?0?5perhap@ ; `string'
PUBLIC	??_C@_0P@ECLAGKMP@AssertionError?$AA@		; `string'
EXTRN	PyErr_WarnExplicit:PROC
EXTRN	PyExc_SyntaxWarning:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_assert DD imagerel compiler_assert
	DD	imagerel compiler_assert+500
	DD	imagerel $unwind$compiler_assert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_assert DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0DG@LAKOGDJB@assertion?5is?5always?5true?0?5perhap@
CONST	SEGMENT
??_C@_0DG@LAKOGDJB@assertion?5is?5always?5true?0?5perhap@ DB 'assertion i'
	DB	's always true, perhaps remove parentheses?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ECLAGKMP@AssertionError?$AA@
CONST	SEGMENT
??_C@_0P@ECLAGKMP@AssertionError?$AA@ DB 'AssertionError', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_assert
_TEXT	SEGMENT
end$ = 48
msg$23974 = 56
tv79 = 64
c$ = 96
s$ = 104
compiler_assert PROC					; COMDAT

; 2380 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2381 :     static PyObject *assertion_error = NULL;
; 2382 :     basicblock *end;
; 2383 : 
; 2384 :     if (c->c_optimize)

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00013	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00017	74 0a		 je	 SHORT $LN13@compiler_a@7

; 2385 :         return 1;

  00019	b8 01 00 00 00	 mov	 eax, 1
  0001e	e9 cc 01 00 00	 jmp	 $LN14@compiler_a@7
$LN13@compiler_a@7:

; 2386 :     if (assertion_error == NULL) {

  00023	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?assertion_error@?1??compiler_assert@@9@9, 0
  0002b	75 24		 jne	 SHORT $LN12@compiler_a@7

; 2387 :         assertion_error = PyUnicode_InternFromString("AssertionError");

  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@ECLAGKMP@AssertionError?$AA@
  00034	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00039	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?assertion_error@?1??compiler_assert@@9@9, rax

; 2388 :         if (assertion_error == NULL)

  00040	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?assertion_error@?1??compiler_assert@@9@9, 0
  00048	75 07		 jne	 SHORT $LN11@compiler_a@7

; 2389 :             return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 9e 01 00 00	 jmp	 $LN14@compiler_a@7
$LN11@compiler_a@7:
$LN12@compiler_a@7:

; 2390 :     }
; 2391 :     if (s->v.Assert.test->kind == Tuple_kind &&
; 2392 :         asdl_seq_LEN(s->v.Assert.test->v.Tuple.elts) > 0) {

  00051	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00056	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005a	83 38 19	 cmp	 DWORD PTR [rax], 25
  0005d	0f 85 8b 00 00
	00		 jne	 $LN10@compiler_a@7
  00063	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00068	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00071	75 0b		 jne	 SHORT $LN16@compiler_a@7
  00073	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  0007c	eb 15		 jmp	 SHORT $LN17@compiler_a@7
$LN16@compiler_a@7:
  0007e	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00087	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	48 89 44 24 40	 mov	 QWORD PTR tv79[rsp], rax
$LN17@compiler_a@7:
  00093	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv79[rsp], 0
  00099	7e 53		 jle	 SHORT $LN10@compiler_a@7

; 2393 :         const char* msg =
; 2394 :             "assertion is always true, perhaps remove parentheses?";

  0009b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DG@LAKOGDJB@assertion?5is?5always?5true?0?5perhap@
  000a2	48 89 44 24 38	 mov	 QWORD PTR msg$23974[rsp], rax

; 2395 :         if (PyErr_WarnExplicit(PyExc_SyntaxWarning, msg, c->c_filename,
; 2396 :                                c->u->u_lineno, NULL, NULL) == -1)

  000a7	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  000ac	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000b0	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000b9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000c2	44 8b 88 b4 01
	00 00		 mov	 r9d, DWORD PTR [rax+436]
  000c9	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  000ce	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  000d1	48 8b 54 24 38	 mov	 rdx, QWORD PTR msg$23974[rsp]
  000d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxWarning
  000dd	e8 00 00 00 00	 call	 PyErr_WarnExplicit
  000e2	83 f8 ff	 cmp	 eax, -1
  000e5	75 07		 jne	 SHORT $LN9@compiler_a@7

; 2397 :             return 0;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 01 01 00 00	 jmp	 $LN14@compiler_a@7
$LN9@compiler_a@7:
$LN10@compiler_a@7:

; 2398 :     }
; 2399 :     VISIT(c, expr, s->v.Assert.test);

  000ee	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000f3	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000f7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000fc	e8 00 00 00 00	 call	 compiler_visit_expr
  00101	85 c0		 test	 eax, eax
  00103	75 07		 jne	 SHORT $LN8@compiler_a@7
  00105	33 c0		 xor	 eax, eax
  00107	e9 e3 00 00 00	 jmp	 $LN14@compiler_a@7
$LN8@compiler_a@7:

; 2400 :     end = compiler_new_block(c);

  0010c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00111	e8 00 00 00 00	 call	 compiler_new_block
  00116	48 89 44 24 30	 mov	 QWORD PTR end$[rsp], rax

; 2401 :     if (end == NULL)

  0011b	48 83 7c 24 30
	00		 cmp	 QWORD PTR end$[rsp], 0
  00121	75 07		 jne	 SHORT $LN7@compiler_a@7

; 2402 :         return 0;

  00123	33 c0		 xor	 eax, eax
  00125	e9 c5 00 00 00	 jmp	 $LN14@compiler_a@7
$LN7@compiler_a@7:

; 2403 :     ADDOP_JABS(c, POP_JUMP_IF_TRUE, end);

  0012a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00130	4c 8b 44 24 30	 mov	 r8, QWORD PTR end$[rsp]
  00135	ba 73 00 00 00	 mov	 edx, 115		; 00000073H
  0013a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0013f	e8 00 00 00 00	 call	 compiler_addop_j
  00144	85 c0		 test	 eax, eax
  00146	75 07		 jne	 SHORT $LN6@compiler_a@7
  00148	33 c0		 xor	 eax, eax
  0014a	e9 a0 00 00 00	 jmp	 $LN14@compiler_a@7
$LN6@compiler_a@7:

; 2404 :     ADDOP_O(c, LOAD_GLOBAL, assertion_error, names);

  0014f	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00154	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00158	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?assertion_error@?1??compiler_assert@@9@9
  0015f	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  00163	ba 74 00 00 00	 mov	 edx, 116		; 00000074H
  00168	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0016d	e8 00 00 00 00	 call	 compiler_addop_o
  00172	85 c0		 test	 eax, eax
  00174	75 04		 jne	 SHORT $LN5@compiler_a@7
  00176	33 c0		 xor	 eax, eax
  00178	eb 75		 jmp	 SHORT $LN14@compiler_a@7
$LN5@compiler_a@7:

; 2405 :     if (s->v.Assert.msg) {

  0017a	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0017f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00184	74 38		 je	 SHORT $LN4@compiler_a@7

; 2406 :         VISIT(c, expr, s->v.Assert.msg);

  00186	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0018b	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0018f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00194	e8 00 00 00 00	 call	 compiler_visit_expr
  00199	85 c0		 test	 eax, eax
  0019b	75 04		 jne	 SHORT $LN3@compiler_a@7
  0019d	33 c0		 xor	 eax, eax
  0019f	eb 4e		 jmp	 SHORT $LN14@compiler_a@7
$LN3@compiler_a@7:

; 2407 :         ADDOP_I(c, CALL_FUNCTION, 1);

  001a1	41 b8 01 00 00
	00		 mov	 r8d, 1
  001a7	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  001ac	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001b1	e8 00 00 00 00	 call	 compiler_addop_i
  001b6	85 c0		 test	 eax, eax
  001b8	75 04		 jne	 SHORT $LN2@compiler_a@7
  001ba	33 c0		 xor	 eax, eax
  001bc	eb 31		 jmp	 SHORT $LN14@compiler_a@7
$LN2@compiler_a@7:
$LN4@compiler_a@7:

; 2408 :     }
; 2409 :     ADDOP_I(c, RAISE_VARARGS, 1);

  001be	41 b8 01 00 00
	00		 mov	 r8d, 1
  001c4	ba 82 00 00 00	 mov	 edx, 130		; 00000082H
  001c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001ce	e8 00 00 00 00	 call	 compiler_addop_i
  001d3	85 c0		 test	 eax, eax
  001d5	75 04		 jne	 SHORT $LN1@compiler_a@7
  001d7	33 c0		 xor	 eax, eax
  001d9	eb 14		 jmp	 SHORT $LN14@compiler_a@7
$LN1@compiler_a@7:

; 2410 :     compiler_use_next_block(c, end);

  001db	48 8b 54 24 30	 mov	 rdx, QWORD PTR end$[rsp]
  001e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001e5	e8 00 00 00 00	 call	 compiler_use_next_block

; 2411 :     return 1;

  001ea	b8 01 00 00 00	 mov	 eax, 1
$LN14@compiler_a@7:

; 2412 : }

  001ef	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f3	c3		 ret	 0
compiler_assert ENDP
_TEXT	ENDS
PUBLIC	??_C@_15NMKAEDEP@?$AAo?$AAp?$AA?$AA@		; `string'
PUBLIC	??_C@_0CA@NCEOFLI@param?5invalid?5for?5name?5variable?$AA@ ; `string'
PUBLIC	??_C@_0CC@FJALOHIN@param?5invalid?5for?5global?5variabl@ ; `string'
PUBLIC	??_C@_0CB@DECJELAF@param?5invalid?5for?5local?5variable@ ; `string'
PUBLIC	??_C@_0CB@KBKPEBLN@param?5invalid?5for?5deref?5variable@ ; `string'
PUBLIC	??_C@_1FK@OOKJFIAO@?$AAs?$AAc?$AAo?$AAp?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAR?$AAE?$AAA?$AAD?$AA_?$AAC?$AAH?$AAA?$AAR?$AA?$CI?$AAn?$AAa?$AAm@ ; `string'
PUBLIC	??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ ; `string'
PUBLIC	??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_nameop DD imagerel compiler_nameop
	DD	imagerel compiler_nameop+2554
	DD	imagerel $unwind$compiler_nameop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_nameop DD 021601H
	DD	0170116H
xdata	ENDS
;	COMDAT ??_C@_15NMKAEDEP@?$AAo?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_15NMKAEDEP@?$AAo?$AAp?$AA?$AA@ DB 'o', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NCEOFLI@param?5invalid?5for?5name?5variable?$AA@
CONST	SEGMENT
??_C@_0CA@NCEOFLI@param?5invalid?5for?5name?5variable?$AA@ DB 'param inva'
	DB	'lid for name variable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FJALOHIN@param?5invalid?5for?5global?5variabl@
CONST	SEGMENT
??_C@_0CC@FJALOHIN@param?5invalid?5for?5global?5variabl@ DB 'param invali'
	DB	'd for global variable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DECJELAF@param?5invalid?5for?5local?5variable@
CONST	SEGMENT
??_C@_0CB@DECJELAF@param?5invalid?5for?5local?5variable@ DB 'param invali'
	DB	'd for local variable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KBKPEBLN@param?5invalid?5for?5deref?5variable@
CONST	SEGMENT
??_C@_0CB@KBKPEBLN@param?5invalid?5for?5deref?5variable@ DB 'param invali'
	DB	'd for deref variable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@OOKJFIAO@?$AAs?$AAc?$AAo?$AAp?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAR?$AAE?$AAA?$AAD?$AA_?$AAC?$AAH?$AAA?$AAR?$AA?$CI?$AAn?$AAa?$AAm@
CONST	SEGMENT
??_C@_1FK@OOKJFIAO@?$AAs?$AAc?$AAo?$AAp?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAR?$AAE?$AAA?$AAD?$AA_?$AAC?$AAH?$AAA?$AAR?$AA?$CI?$AAn?$AAa?$AAm@ DB 's'
	DB	00H, 'c', 00H, 'o', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i'
	DB	00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'R', 00H
	DB	'E', 00H, 'A', 00H, 'D', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'A'
	DB	00H, 'R', 00H, '(', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	',', 00H, ' ', 00H, '0', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '''', 00H, '_', 00H, '''', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
CONST	SEGMENT
??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'(', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ')', 00H, ')'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, '(', 00H
	DB	'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ')', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, '(', 00H, 'n', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, ')', 00H, ')', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_nameop
_TEXT	SEGMENT
arg$ = 32
dict$ = 40
scope$ = 48
mangled$ = 56
op$ = 64
optype$ = 68
tv77 = 72
tv200 = 80
tv209 = 88
tv319 = 96
tv264 = 104
tv273 = 112
tv318 = 120
tv308 = 128
tv317 = 136
tv326 = 144
tv327 = 148
tv335 = 152
tv352 = 156
tv360 = 160
c$ = 192
name$ = 200
ctx$ = 208
compiler_nameop PROC					; COMDAT

; 2629 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2630 :     int op, scope, arg;
; 2631 :     enum { OP_FAST, OP_GLOBAL, OP_DEREF, OP_NAME } optype;
; 2632 : 
; 2633 :     PyObject *dict = c->u->u_names;

  00016	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0001e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00022	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00026	48 89 44 24 28	 mov	 QWORD PTR dict$[rsp], rax

; 2634 :     PyObject *mangled;
; 2635 :     /* XXX AugStore isn't used anywhere! */
; 2636 : 
; 2637 :     mangled = _Py_Mangle(c->u->u_private, name);

  0002b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00033	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00037	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR name$[rsp]
  0003f	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  00043	e8 00 00 00 00	 call	 _Py_Mangle
  00048	48 89 44 24 38	 mov	 QWORD PTR mangled$[rsp], rax

; 2638 :     if (!mangled)

  0004d	48 83 7c 24 38
	00		 cmp	 QWORD PTR mangled$[rsp], 0
  00053	75 07		 jne	 SHORT $LN47@compiler_n@3

; 2639 :         return 0;

  00055	33 c0		 xor	 eax, eax
  00057	e9 96 09 00 00	 jmp	 $LN48@compiler_n@3
$LN47@compiler_n@3:

; 2640 : 
; 2641 :     op = 0;

  0005c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR op$[rsp], 0

; 2642 :     optype = OP_NAME;

  00064	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR optype$[rsp], 3

; 2643 :     scope = PyST_GetScope(c->u->u_ste, mangled);

  0006c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00074	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00078	48 8b 54 24 38	 mov	 rdx, QWORD PTR mangled$[rsp]
  0007d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00080	e8 00 00 00 00	 call	 PyST_GetScope
  00085	89 44 24 30	 mov	 DWORD PTR scope$[rsp], eax

; 2644 :     switch (scope) {

  00089	8b 44 24 30	 mov	 eax, DWORD PTR scope$[rsp]
  0008d	89 44 24 48	 mov	 DWORD PTR tv77[rsp], eax
  00091	83 7c 24 48 01	 cmp	 DWORD PTR tv77[rsp], 1
  00096	74 66		 je	 SHORT $LN42@compiler_n@3
  00098	83 7c 24 48 02	 cmp	 DWORD PTR tv77[rsp], 2
  0009d	0f 84 b7 00 00
	00		 je	 $LN38@compiler_n@3
  000a3	83 7c 24 48 03	 cmp	 DWORD PTR tv77[rsp], 3
  000a8	74 76		 je	 SHORT $LN40@compiler_n@3
  000aa	83 7c 24 48 04	 cmp	 DWORD PTR tv77[rsp], 4
  000af	74 0c		 je	 SHORT $LN44@compiler_n@3
  000b1	83 7c 24 48 05	 cmp	 DWORD PTR tv77[rsp], 5
  000b6	74 27		 je	 SHORT $LN43@compiler_n@3
  000b8	e9 a5 00 00 00	 jmp	 $LN37@compiler_n@3
$LN44@compiler_n@3:

; 2645 :     case FREE:
; 2646 :         dict = c->u->u_freevars;

  000bd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000c5	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000c9	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000cd	48 89 44 24 28	 mov	 QWORD PTR dict$[rsp], rax

; 2647 :         optype = OP_DEREF;

  000d2	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR optype$[rsp], 2

; 2648 :         break;

  000da	e9 83 00 00 00	 jmp	 $LN45@compiler_n@3
$LN43@compiler_n@3:

; 2649 :     case CELL:
; 2650 :         dict = c->u->u_cellvars;

  000df	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000e7	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000eb	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000ef	48 89 44 24 28	 mov	 QWORD PTR dict$[rsp], rax

; 2651 :         optype = OP_DEREF;

  000f4	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR optype$[rsp], 2

; 2652 :         break;

  000fc	eb 64		 jmp	 SHORT $LN45@compiler_n@3
$LN42@compiler_n@3:

; 2653 :     case LOCAL:
; 2654 :         if (c->u->u_ste->ste_type == FunctionBlock)

  000fe	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00106	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0010a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010d	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00114	75 08		 jne	 SHORT $LN41@compiler_n@3

; 2655 :             optype = OP_FAST;

  00116	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR optype$[rsp], 0
$LN41@compiler_n@3:

; 2656 :         break;

  0011e	eb 42		 jmp	 SHORT $LN45@compiler_n@3
$LN40@compiler_n@3:

; 2657 :     case GLOBAL_IMPLICIT:
; 2658 :         if (c->u->u_ste->ste_type == FunctionBlock &&
; 2659 :             !c->u->u_ste->ste_unoptimized)

  00120	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00128	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0012c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0012f	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00136	75 20		 jne	 SHORT $LN39@compiler_n@3
  00138	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00140	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00144	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00147	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  0014e	75 08		 jne	 SHORT $LN39@compiler_n@3

; 2660 :             optype = OP_GLOBAL;

  00150	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR optype$[rsp], 1
$LN39@compiler_n@3:

; 2661 :         break;

  00158	eb 08		 jmp	 SHORT $LN45@compiler_n@3
$LN38@compiler_n@3:

; 2662 :     case GLOBAL_EXPLICIT:
; 2663 :         optype = OP_GLOBAL;

  0015a	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR optype$[rsp], 1
$LN37@compiler_n@3:
$LN45@compiler_n@3:

; 2664 :         break;
; 2665 :     default:
; 2666 :         /* scope can be 0 */
; 2667 :         break;
; 2668 :     }
; 2669 : 
; 2670 :     /* XXX Leave assert here, but handle __doc__ and the like better */
; 2671 :     assert(scope || PyUnicode_READ_CHAR(name, 0) == '_');

  00162	83 7c 24 30 00	 cmp	 DWORD PTR scope$[rsp], 0
  00167	0f 85 9f 05 00
	00		 jne	 $LN84@compiler_n@3
  0016d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00175	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00179	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0017f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00184	85 c0		 test	 eax, eax
  00186	75 1c		 jne	 SHORT $LN50@compiler_n@3
  00188	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001a2	33 c0		 xor	 eax, eax
$LN50@compiler_n@3:
  001a4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  001ac	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001af	c1 e8 07	 shr	 eax, 7
  001b2	83 e0 01	 and	 eax, 1
  001b5	85 c0		 test	 eax, eax
  001b7	75 1c		 jne	 SHORT $LN51@compiler_n@3
  001b9	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  001bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d3	33 c0		 xor	 eax, eax
$LN51@compiler_n@3:
  001d5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  001dd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001e1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001e7	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  001ec	85 c0		 test	 eax, eax
  001ee	75 1c		 jne	 SHORT $LN52@compiler_n@3
  001f0	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  001f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0020a	33 c0		 xor	 eax, eax
$LN52@compiler_n@3:
  0020c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00214	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00217	c1 e8 07	 shr	 eax, 7
  0021a	83 e0 01	 and	 eax, 1
  0021d	85 c0		 test	 eax, eax
  0021f	75 1c		 jne	 SHORT $LN53@compiler_n@3
  00221	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  00227	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0022e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0023b	33 c0		 xor	 eax, eax
$LN53@compiler_n@3:
  0023d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00245	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00248	c1 e8 02	 shr	 eax, 2
  0024b	83 e0 07	 and	 eax, 7
  0024e	83 f8 01	 cmp	 eax, 1
  00251	0f 85 54 01 00
	00		 jne	 $LN82@compiler_n@3
  00257	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  0025f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00263	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00269	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0026e	85 c0		 test	 eax, eax
  00270	75 1c		 jne	 SHORT $LN54@compiler_n@3
  00272	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  00278	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0027f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0028c	33 c0		 xor	 eax, eax
$LN54@compiler_n@3:
  0028e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00296	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00299	c1 e8 05	 shr	 eax, 5
  0029c	83 e0 01	 and	 eax, 1
  0029f	85 c0		 test	 eax, eax
  002a1	0f 84 b1 00 00
	00		 je	 $LN60@compiler_n@3
  002a7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  002af	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002b3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002b9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  002be	85 c0		 test	 eax, eax
  002c0	75 1c		 jne	 SHORT $LN55@compiler_n@3
  002c2	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  002c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  002d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002dc	33 c0		 xor	 eax, eax
$LN55@compiler_n@3:
  002de	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  002e6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002e9	c1 e8 07	 shr	 eax, 7
  002ec	83 e0 01	 and	 eax, 1
  002ef	85 c0		 test	 eax, eax
  002f1	75 1c		 jne	 SHORT $LN56@compiler_n@3
  002f3	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  002f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00300	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0030d	33 c0		 xor	 eax, eax
$LN56@compiler_n@3:
  0030f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00317	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0031a	c1 e8 06	 shr	 eax, 6
  0031d	83 e0 01	 and	 eax, 1
  00320	85 c0		 test	 eax, eax
  00322	74 15		 je	 SHORT $LN57@compiler_n@3
  00324	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  0032c	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00332	48 89 44 24 50	 mov	 QWORD PTR tv200[rsp], rax
  00337	eb 13		 jmp	 SHORT $LN58@compiler_n@3
$LN57@compiler_n@3:
  00339	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00341	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00347	48 89 44 24 50	 mov	 QWORD PTR tv200[rsp], rax
$LN58@compiler_n@3:
  0034c	48 8b 44 24 50	 mov	 rax, QWORD PTR tv200[rsp]
  00351	48 89 44 24 58	 mov	 QWORD PTR tv209[rsp], rax
  00356	eb 42		 jmp	 SHORT $LN61@compiler_n@3
$LN60@compiler_n@3:
  00358	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00360	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00368	75 1c		 jne	 SHORT $LN59@compiler_n@3
  0036a	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  00370	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00377	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  0037e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00384	33 c0		 xor	 eax, eax
$LN59@compiler_n@3:
  00386	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  0038e	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00395	48 89 44 24 58	 mov	 QWORD PTR tv209[rsp], rax
$LN61@compiler_n@3:
  0039a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv209[rsp]
  0039f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003a2	89 44 24 60	 mov	 DWORD PTR tv319[rsp], eax
  003a6	e9 3e 03 00 00	 jmp	 $LN83@compiler_n@3
$LN82@compiler_n@3:
  003ab	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  003b3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003b7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003bd	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  003c2	85 c0		 test	 eax, eax
  003c4	75 1c		 jne	 SHORT $LN62@compiler_n@3
  003c6	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  003cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  003d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  003da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003e0	33 c0		 xor	 eax, eax
$LN62@compiler_n@3:
  003e2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  003ea	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003ed	c1 e8 07	 shr	 eax, 7
  003f0	83 e0 01	 and	 eax, 1
  003f3	85 c0		 test	 eax, eax
  003f5	75 1c		 jne	 SHORT $LN63@compiler_n@3
  003f7	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  003fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00404	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0040b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00411	33 c0		 xor	 eax, eax
$LN63@compiler_n@3:
  00413	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  0041b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0041e	c1 e8 02	 shr	 eax, 2
  00421	83 e0 07	 and	 eax, 7
  00424	83 f8 02	 cmp	 eax, 2
  00427	0f 85 54 01 00
	00		 jne	 $LN80@compiler_n@3
  0042d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00435	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00439	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0043f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00444	85 c0		 test	 eax, eax
  00446	75 1c		 jne	 SHORT $LN64@compiler_n@3
  00448	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  0044e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00455	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0045c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00462	33 c0		 xor	 eax, eax
$LN64@compiler_n@3:
  00464	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  0046c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0046f	c1 e8 05	 shr	 eax, 5
  00472	83 e0 01	 and	 eax, 1
  00475	85 c0		 test	 eax, eax
  00477	0f 84 b1 00 00
	00		 je	 $LN70@compiler_n@3
  0047d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00485	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00489	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0048f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00494	85 c0		 test	 eax, eax
  00496	75 1c		 jne	 SHORT $LN65@compiler_n@3
  00498	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  0049e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  004a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  004ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004b2	33 c0		 xor	 eax, eax
$LN65@compiler_n@3:
  004b4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  004bc	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004bf	c1 e8 07	 shr	 eax, 7
  004c2	83 e0 01	 and	 eax, 1
  004c5	85 c0		 test	 eax, eax
  004c7	75 1c		 jne	 SHORT $LN66@compiler_n@3
  004c9	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  004cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  004d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  004dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004e3	33 c0		 xor	 eax, eax
$LN66@compiler_n@3:
  004e5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  004ed	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004f0	c1 e8 06	 shr	 eax, 6
  004f3	83 e0 01	 and	 eax, 1
  004f6	85 c0		 test	 eax, eax
  004f8	74 15		 je	 SHORT $LN67@compiler_n@3
  004fa	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00502	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00508	48 89 44 24 68	 mov	 QWORD PTR tv264[rsp], rax
  0050d	eb 13		 jmp	 SHORT $LN68@compiler_n@3
$LN67@compiler_n@3:
  0050f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00517	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0051d	48 89 44 24 68	 mov	 QWORD PTR tv264[rsp], rax
$LN68@compiler_n@3:
  00522	48 8b 44 24 68	 mov	 rax, QWORD PTR tv264[rsp]
  00527	48 89 44 24 70	 mov	 QWORD PTR tv273[rsp], rax
  0052c	eb 42		 jmp	 SHORT $LN71@compiler_n@3
$LN70@compiler_n@3:
  0052e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00536	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  0053e	75 1c		 jne	 SHORT $LN69@compiler_n@3
  00540	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  00546	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0054d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  00554	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0055a	33 c0		 xor	 eax, eax
$LN69@compiler_n@3:
  0055c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00564	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0056b	48 89 44 24 70	 mov	 QWORD PTR tv273[rsp], rax
$LN71@compiler_n@3:
  00570	48 8b 44 24 70	 mov	 rax, QWORD PTR tv273[rsp]
  00575	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00578	89 44 24 78	 mov	 DWORD PTR tv318[rsp], eax
  0057c	e9 60 01 00 00	 jmp	 $LN81@compiler_n@3
$LN80@compiler_n@3:
  00581	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00589	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0058d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00593	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00598	85 c0		 test	 eax, eax
  0059a	75 1c		 jne	 SHORT $LN72@compiler_n@3
  0059c	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  005a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  005a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  005b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005b6	33 c0		 xor	 eax, eax
$LN72@compiler_n@3:
  005b8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  005c0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  005c3	c1 e8 05	 shr	 eax, 5
  005c6	83 e0 01	 and	 eax, 1
  005c9	85 c0		 test	 eax, eax
  005cb	0f 84 bd 00 00
	00		 je	 $LN78@compiler_n@3
  005d1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  005d9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005dd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005e3	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  005e8	85 c0		 test	 eax, eax
  005ea	75 1c		 jne	 SHORT $LN73@compiler_n@3
  005ec	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  005f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  005f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00600	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00606	33 c0		 xor	 eax, eax
$LN73@compiler_n@3:
  00608	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00610	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00613	c1 e8 07	 shr	 eax, 7
  00616	83 e0 01	 and	 eax, 1
  00619	85 c0		 test	 eax, eax
  0061b	75 1c		 jne	 SHORT $LN74@compiler_n@3
  0061d	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  00623	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0062a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00631	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00637	33 c0		 xor	 eax, eax
$LN74@compiler_n@3:
  00639	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00641	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00644	c1 e8 06	 shr	 eax, 6
  00647	83 e0 01	 and	 eax, 1
  0064a	85 c0		 test	 eax, eax
  0064c	74 18		 je	 SHORT $LN75@compiler_n@3
  0064e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00656	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0065c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv308[rsp], rax
  00664	eb 16		 jmp	 SHORT $LN76@compiler_n@3
$LN75@compiler_n@3:
  00666	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  0066e	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00674	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv308[rsp], rax
$LN76@compiler_n@3:
  0067c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv308[rsp]
  00684	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv317[rsp], rax
  0068c	eb 45		 jmp	 SHORT $LN79@compiler_n@3
$LN78@compiler_n@3:
  0068e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00696	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  0069e	75 1c		 jne	 SHORT $LN77@compiler_n@3
  006a0	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  006a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  006ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  006b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006ba	33 c0		 xor	 eax, eax
$LN77@compiler_n@3:
  006bc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  006c4	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  006cb	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv317[rsp], rax
$LN79@compiler_n@3:
  006d3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv317[rsp]
  006db	8b 00		 mov	 eax, DWORD PTR [rax]
  006dd	89 44 24 78	 mov	 DWORD PTR tv318[rsp], eax
$LN81@compiler_n@3:
  006e1	8b 44 24 78	 mov	 eax, DWORD PTR tv318[rsp]
  006e5	89 44 24 60	 mov	 DWORD PTR tv319[rsp], eax
$LN83@compiler_n@3:
  006e9	83 7c 24 60 5f	 cmp	 DWORD PTR tv319[rsp], 95 ; 0000005fH
  006ee	74 1c		 je	 SHORT $LN84@compiler_n@3
  006f0	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  006f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  006fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@OOKJFIAO@?$AAs?$AAc?$AAo?$AAp?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAR?$AAE?$AAA?$AAD?$AA_?$AAC?$AAH?$AAA?$AAR?$AA?$CI?$AAn?$AAa?$AAm@
  00704	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0070a	33 c0		 xor	 eax, eax
$LN84@compiler_n@3:

; 2672 : 
; 2673 :     switch (optype) {

  0070c	8b 44 24 44	 mov	 eax, DWORD PTR optype$[rsp]
  00710	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv326[rsp], eax
  00717	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv326[rsp], 0
  0071f	0f 84 ac 00 00
	00		 je	 $LN26@compiler_n@3
  00725	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR tv326[rsp], 1
  0072d	0f 84 5f 01 00
	00		 je	 $LN17@compiler_n@3
  00733	83 bc 24 90 00
	00 00 02	 cmp	 DWORD PTR tv326[rsp], 2
  0073b	74 13		 je	 SHORT $LN34@compiler_n@3
  0073d	83 bc 24 90 00
	00 00 03	 cmp	 DWORD PTR tv326[rsp], 3
  00745	0f 84 c5 01 00
	00		 je	 $LN9@compiler_n@3
  0074b	e9 39 02 00 00	 jmp	 $LN35@compiler_n@3
$LN34@compiler_n@3:

; 2674 :     case OP_DEREF:
; 2675 :         switch (ctx) {

  00750	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR ctx$[rsp]
  00757	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv327[rsp], eax
  0075e	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR tv327[rsp], 1
  00766	74 2a		 je	 SHORT $LN31@compiler_n@3
  00768	83 bc 24 94 00
	00 00 02	 cmp	 DWORD PTR tv327[rsp], 2
  00770	74 2a		 je	 SHORT $LN30@compiler_n@3
  00772	83 bc 24 94 00
	00 00 03	 cmp	 DWORD PTR tv327[rsp], 3
  0077a	74 2c		 je	 SHORT $LN28@compiler_n@3
  0077c	83 bc 24 94 00
	00 00 03	 cmp	 DWORD PTR tv327[rsp], 3
  00784	7e 2c		 jle	 SHORT $LN27@compiler_n@3
  00786	83 bc 24 94 00
	00 00 05	 cmp	 DWORD PTR tv327[rsp], 5
  0078e	7e 16		 jle	 SHORT $LN29@compiler_n@3
  00790	eb 20		 jmp	 SHORT $LN27@compiler_n@3
$LN31@compiler_n@3:

; 2676 :         case Load: op = LOAD_DEREF; break;

  00792	c7 44 24 40 88
	00 00 00	 mov	 DWORD PTR op$[rsp], 136	; 00000088H
  0079a	eb 30		 jmp	 SHORT $LN32@compiler_n@3
$LN30@compiler_n@3:

; 2677 :         case Store: op = STORE_DEREF; break;

  0079c	c7 44 24 40 89
	00 00 00	 mov	 DWORD PTR op$[rsp], 137	; 00000089H
  007a4	eb 26		 jmp	 SHORT $LN32@compiler_n@3
$LN29@compiler_n@3:

; 2678 :         case AugLoad:
; 2679 :         case AugStore:
; 2680 :             break;

  007a6	eb 24		 jmp	 SHORT $LN32@compiler_n@3
$LN28@compiler_n@3:

; 2681 :         case Del: op = DELETE_DEREF; break;

  007a8	c7 44 24 40 8a
	00 00 00	 mov	 DWORD PTR op$[rsp], 138	; 0000008aH
  007b0	eb 1a		 jmp	 SHORT $LN32@compiler_n@3
$LN27@compiler_n@3:

; 2682 :         case Param:
; 2683 :         default:
; 2684 :             PyErr_SetString(PyExc_SystemError,
; 2685 :                             "param invalid for deref variable");

  007b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@KBKPEBLN@param?5invalid?5for?5deref?5variable@
  007b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  007c0	e8 00 00 00 00	 call	 PyErr_SetString

; 2686 :             return 0;

  007c5	33 c0		 xor	 eax, eax
  007c7	e9 26 02 00 00	 jmp	 $LN48@compiler_n@3
$LN32@compiler_n@3:

; 2687 :         }
; 2688 :         break;

  007cc	e9 b8 01 00 00	 jmp	 $LN35@compiler_n@3
$LN26@compiler_n@3:

; 2689 :     case OP_FAST:
; 2690 :         switch (ctx) {

  007d1	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR ctx$[rsp]
  007d8	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv335[rsp], eax
  007df	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR tv335[rsp], 1
  007e7	74 2a		 je	 SHORT $LN23@compiler_n@3
  007e9	83 bc 24 98 00
	00 00 02	 cmp	 DWORD PTR tv335[rsp], 2
  007f1	74 2a		 je	 SHORT $LN22@compiler_n@3
  007f3	83 bc 24 98 00
	00 00 03	 cmp	 DWORD PTR tv335[rsp], 3
  007fb	74 2a		 je	 SHORT $LN21@compiler_n@3
  007fd	83 bc 24 98 00
	00 00 03	 cmp	 DWORD PTR tv335[rsp], 3
  00805	7e 2c		 jle	 SHORT $LN19@compiler_n@3
  00807	83 bc 24 98 00
	00 00 05	 cmp	 DWORD PTR tv335[rsp], 5
  0080f	7e 20		 jle	 SHORT $LN20@compiler_n@3
  00811	eb 20		 jmp	 SHORT $LN19@compiler_n@3
$LN23@compiler_n@3:

; 2691 :         case Load: op = LOAD_FAST; break;

  00813	c7 44 24 40 7c
	00 00 00	 mov	 DWORD PTR op$[rsp], 124	; 0000007cH
  0081b	eb 30		 jmp	 SHORT $LN24@compiler_n@3
$LN22@compiler_n@3:

; 2692 :         case Store: op = STORE_FAST; break;

  0081d	c7 44 24 40 7d
	00 00 00	 mov	 DWORD PTR op$[rsp], 125	; 0000007dH
  00825	eb 26		 jmp	 SHORT $LN24@compiler_n@3
$LN21@compiler_n@3:

; 2693 :         case Del: op = DELETE_FAST; break;

  00827	c7 44 24 40 7e
	00 00 00	 mov	 DWORD PTR op$[rsp], 126	; 0000007eH
  0082f	eb 1c		 jmp	 SHORT $LN24@compiler_n@3
$LN20@compiler_n@3:

; 2694 :         case AugLoad:
; 2695 :         case AugStore:
; 2696 :             break;

  00831	eb 1a		 jmp	 SHORT $LN24@compiler_n@3
$LN19@compiler_n@3:

; 2697 :         case Param:
; 2698 :         default:
; 2699 :             PyErr_SetString(PyExc_SystemError,
; 2700 :                             "param invalid for local variable");

  00833	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@DECJELAF@param?5invalid?5for?5local?5variable@
  0083a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00841	e8 00 00 00 00	 call	 PyErr_SetString

; 2701 :             return 0;

  00846	33 c0		 xor	 eax, eax
  00848	e9 a5 01 00 00	 jmp	 $LN48@compiler_n@3
$LN24@compiler_n@3:

; 2702 :         }
; 2703 :         ADDOP_O(c, op, mangled, varnames);

  0084d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00855	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00859	4c 8b 4c 24 38	 mov	 r9, QWORD PTR mangled$[rsp]
  0085e	4c 8b 40 30	 mov	 r8, QWORD PTR [rax+48]
  00862	8b 54 24 40	 mov	 edx, DWORD PTR op$[rsp]
  00866	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0086e	e8 00 00 00 00	 call	 compiler_addop_o
  00873	85 c0		 test	 eax, eax
  00875	75 07		 jne	 SHORT $LN18@compiler_n@3
  00877	33 c0		 xor	 eax, eax
  00879	e9 74 01 00 00	 jmp	 $LN48@compiler_n@3
$LN18@compiler_n@3:

; 2704 :         Py_DECREF(mangled);

  0087e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mangled$[rsp]
  00883	e8 00 00 00 00	 call	 _Py_DecRef

; 2705 :         return 1;

  00888	b8 01 00 00 00	 mov	 eax, 1
  0088d	e9 60 01 00 00	 jmp	 $LN48@compiler_n@3
$LN17@compiler_n@3:

; 2706 :     case OP_GLOBAL:
; 2707 :         switch (ctx) {

  00892	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR ctx$[rsp]
  00899	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv352[rsp], eax
  008a0	83 bc 24 9c 00
	00 00 01	 cmp	 DWORD PTR tv352[rsp], 1
  008a8	74 2a		 je	 SHORT $LN14@compiler_n@3
  008aa	83 bc 24 9c 00
	00 00 02	 cmp	 DWORD PTR tv352[rsp], 2
  008b2	74 2a		 je	 SHORT $LN13@compiler_n@3
  008b4	83 bc 24 9c 00
	00 00 03	 cmp	 DWORD PTR tv352[rsp], 3
  008bc	74 2a		 je	 SHORT $LN12@compiler_n@3
  008be	83 bc 24 9c 00
	00 00 03	 cmp	 DWORD PTR tv352[rsp], 3
  008c6	7e 2c		 jle	 SHORT $LN10@compiler_n@3
  008c8	83 bc 24 9c 00
	00 00 05	 cmp	 DWORD PTR tv352[rsp], 5
  008d0	7e 20		 jle	 SHORT $LN11@compiler_n@3
  008d2	eb 20		 jmp	 SHORT $LN10@compiler_n@3
$LN14@compiler_n@3:

; 2708 :         case Load: op = LOAD_GLOBAL; break;

  008d4	c7 44 24 40 74
	00 00 00	 mov	 DWORD PTR op$[rsp], 116	; 00000074H
  008dc	eb 30		 jmp	 SHORT $LN15@compiler_n@3
$LN13@compiler_n@3:

; 2709 :         case Store: op = STORE_GLOBAL; break;

  008de	c7 44 24 40 61
	00 00 00	 mov	 DWORD PTR op$[rsp], 97	; 00000061H
  008e6	eb 26		 jmp	 SHORT $LN15@compiler_n@3
$LN12@compiler_n@3:

; 2710 :         case Del: op = DELETE_GLOBAL; break;

  008e8	c7 44 24 40 62
	00 00 00	 mov	 DWORD PTR op$[rsp], 98	; 00000062H
  008f0	eb 1c		 jmp	 SHORT $LN15@compiler_n@3
$LN11@compiler_n@3:

; 2711 :         case AugLoad:
; 2712 :         case AugStore:
; 2713 :             break;

  008f2	eb 1a		 jmp	 SHORT $LN15@compiler_n@3
$LN10@compiler_n@3:

; 2714 :         case Param:
; 2715 :         default:
; 2716 :             PyErr_SetString(PyExc_SystemError,
; 2717 :                             "param invalid for global variable");

  008f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@FJALOHIN@param?5invalid?5for?5global?5variabl@
  008fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00902	e8 00 00 00 00	 call	 PyErr_SetString

; 2718 :             return 0;

  00907	33 c0		 xor	 eax, eax
  00909	e9 e4 00 00 00	 jmp	 $LN48@compiler_n@3
$LN15@compiler_n@3:

; 2719 :         }
; 2720 :         break;

  0090e	eb 79		 jmp	 SHORT $LN35@compiler_n@3
$LN9@compiler_n@3:

; 2721 :     case OP_NAME:
; 2722 :         switch (ctx) {

  00910	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR ctx$[rsp]
  00917	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv360[rsp], eax
  0091e	83 bc 24 a0 00
	00 00 01	 cmp	 DWORD PTR tv360[rsp], 1
  00926	74 2a		 je	 SHORT $LN6@compiler_n@3
  00928	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR tv360[rsp], 2
  00930	74 2a		 je	 SHORT $LN5@compiler_n@3
  00932	83 bc 24 a0 00
	00 00 03	 cmp	 DWORD PTR tv360[rsp], 3
  0093a	74 2a		 je	 SHORT $LN4@compiler_n@3
  0093c	83 bc 24 a0 00
	00 00 03	 cmp	 DWORD PTR tv360[rsp], 3
  00944	7e 2c		 jle	 SHORT $LN2@compiler_n@3
  00946	83 bc 24 a0 00
	00 00 05	 cmp	 DWORD PTR tv360[rsp], 5
  0094e	7e 20		 jle	 SHORT $LN3@compiler_n@3
  00950	eb 20		 jmp	 SHORT $LN2@compiler_n@3
$LN6@compiler_n@3:

; 2723 :         case Load: op = LOAD_NAME; break;

  00952	c7 44 24 40 65
	00 00 00	 mov	 DWORD PTR op$[rsp], 101	; 00000065H
  0095a	eb 2d		 jmp	 SHORT $LN7@compiler_n@3
$LN5@compiler_n@3:

; 2724 :         case Store: op = STORE_NAME; break;

  0095c	c7 44 24 40 5a
	00 00 00	 mov	 DWORD PTR op$[rsp], 90	; 0000005aH
  00964	eb 23		 jmp	 SHORT $LN7@compiler_n@3
$LN4@compiler_n@3:

; 2725 :         case Del: op = DELETE_NAME; break;

  00966	c7 44 24 40 5b
	00 00 00	 mov	 DWORD PTR op$[rsp], 91	; 0000005bH
  0096e	eb 19		 jmp	 SHORT $LN7@compiler_n@3
$LN3@compiler_n@3:

; 2726 :         case AugLoad:
; 2727 :         case AugStore:
; 2728 :             break;

  00970	eb 17		 jmp	 SHORT $LN7@compiler_n@3
$LN2@compiler_n@3:

; 2729 :         case Param:
; 2730 :         default:
; 2731 :             PyErr_SetString(PyExc_SystemError,
; 2732 :                             "param invalid for name variable");

  00972	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@NCEOFLI@param?5invalid?5for?5name?5variable?$AA@
  00979	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00980	e8 00 00 00 00	 call	 PyErr_SetString

; 2733 :             return 0;

  00985	33 c0		 xor	 eax, eax
  00987	eb 69		 jmp	 SHORT $LN48@compiler_n@3
$LN7@compiler_n@3:
$LN35@compiler_n@3:

; 2734 :         }
; 2735 :         break;
; 2736 :     }
; 2737 : 
; 2738 :     assert(op);

  00989	83 7c 24 40 00	 cmp	 DWORD PTR op$[rsp], 0
  0098e	75 1c		 jne	 SHORT $LN85@compiler_n@3
  00990	41 b8 b2 0a 00
	00		 mov	 r8d, 2738		; 00000ab2H
  00996	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0099d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_15NMKAEDEP@?$AAo?$AAp?$AA?$AA@
  009a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009aa	33 c0		 xor	 eax, eax
$LN85@compiler_n@3:

; 2739 :     arg = compiler_add_o(c, dict, mangled);

  009ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR mangled$[rsp]
  009b1	48 8b 54 24 28	 mov	 rdx, QWORD PTR dict$[rsp]
  009b6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  009be	e8 00 00 00 00	 call	 compiler_add_o
  009c3	89 44 24 20	 mov	 DWORD PTR arg$[rsp], eax

; 2740 :     Py_DECREF(mangled);

  009c7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mangled$[rsp]
  009cc	e8 00 00 00 00	 call	 _Py_DecRef

; 2741 :     if (arg < 0)

  009d1	83 7c 24 20 00	 cmp	 DWORD PTR arg$[rsp], 0
  009d6	7d 04		 jge	 SHORT $LN1@compiler_n@3

; 2742 :         return 0;

  009d8	33 c0		 xor	 eax, eax
  009da	eb 16		 jmp	 SHORT $LN48@compiler_n@3
$LN1@compiler_n@3:

; 2743 :     return compiler_addop_i(c, op, arg);

  009dc	44 8b 44 24 20	 mov	 r8d, DWORD PTR arg$[rsp]
  009e1	8b 54 24 40	 mov	 edx, DWORD PTR op$[rsp]
  009e5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  009ed	e8 00 00 00 00	 call	 compiler_addop_i
$LN48@compiler_n@3:

; 2744 : }

  009f2	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  009f9	c3		 ret	 0
compiler_nameop ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_call_helper DD imagerel compiler_call_helper
	DD	imagerel compiler_call_helper+735
	DD	imagerel $unwind$compiler_call_helper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_call_helper DD 021a01H
	DD	011011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_call_helper
_TEXT	SEGMENT
code$ = 32
_i$24461 = 36
seq$24462 = 40
elt$24467 = 48
_i$24471 = 56
seq$24472 = 64
elt$24477 = 72
tv65 = 80
tv72 = 88
tv86 = 96
tv129 = 104
tv146 = 112
c$ = 144
n$ = 152
args$ = 160
keywords$ = 168
starargs$ = 176
kwargs$ = 184
compiler_call_helper PROC				; COMDAT

; 2903 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2904 :     int code = 0;

  0001a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR code$[rsp], 0

; 2905 : 
; 2906 :     n += asdl_seq_LEN(args);

  00022	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR args$[rsp], 0
  0002b	75 0b		 jne	 SHORT $LN26@compiler_c@3
  0002d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv65[rsp], 0
  00036	eb 10		 jmp	 SHORT $LN27@compiler_c@3
$LN26@compiler_c@3:
  00038	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00040	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00043	48 89 44 24 50	 mov	 QWORD PTR tv65[rsp], rax
$LN27@compiler_c@3:
  00048	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR n$[rsp]
  00050	48 03 44 24 50	 add	 rax, QWORD PTR tv65[rsp]
  00055	89 84 24 98 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 2907 :     VISIT_SEQ(c, expr, args);

  0005c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00064	48 89 44 24 28	 mov	 QWORD PTR seq$24462[rsp], rax
  00069	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _i$24461[rsp], 0
  00071	eb 0a		 jmp	 SHORT $LN23@compiler_c@3
$LN22@compiler_c@3:
  00073	8b 44 24 24	 mov	 eax, DWORD PTR _i$24461[rsp]
  00077	ff c0		 inc	 eax
  00079	89 44 24 24	 mov	 DWORD PTR _i$24461[rsp], eax
$LN23@compiler_c@3:
  0007d	48 83 7c 24 28
	00		 cmp	 QWORD PTR seq$24462[rsp], 0
  00083	75 0b		 jne	 SHORT $LN28@compiler_c@3
  00085	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv72[rsp], 0
  0008e	eb 0d		 jmp	 SHORT $LN29@compiler_c@3
$LN28@compiler_c@3:
  00090	48 8b 44 24 28	 mov	 rax, QWORD PTR seq$24462[rsp]
  00095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00098	48 89 44 24 58	 mov	 QWORD PTR tv72[rsp], rax
$LN29@compiler_c@3:
  0009d	48 63 44 24 24	 movsxd	 rax, DWORD PTR _i$24461[rsp]
  000a2	48 3b 44 24 58	 cmp	 rax, QWORD PTR tv72[rsp]
  000a7	7d 33		 jge	 SHORT $LN21@compiler_c@3
  000a9	48 63 44 24 24	 movsxd	 rax, DWORD PTR _i$24461[rsp]
  000ae	48 8b 4c 24 28	 mov	 rcx, QWORD PTR seq$24462[rsp]
  000b3	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  000b8	48 89 44 24 30	 mov	 QWORD PTR elt$24467[rsp], rax
  000bd	48 8b 54 24 30	 mov	 rdx, QWORD PTR elt$24467[rsp]
  000c2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000ca	e8 00 00 00 00	 call	 compiler_visit_expr
  000cf	85 c0		 test	 eax, eax
  000d1	75 07		 jne	 SHORT $LN20@compiler_c@3
  000d3	33 c0		 xor	 eax, eax
  000d5	e9 fd 01 00 00	 jmp	 $LN24@compiler_c@3
$LN20@compiler_c@3:
  000da	eb 97		 jmp	 SHORT $LN22@compiler_c@3
$LN21@compiler_c@3:

; 2908 :     if (keywords) {

  000dc	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR keywords$[rsp], 0
  000e5	0f 84 c4 00 00
	00		 je	 $LN19@compiler_c@3

; 2909 :         VISIT_SEQ(c, keyword, keywords);

  000eb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR keywords$[rsp]
  000f3	48 89 44 24 40	 mov	 QWORD PTR seq$24472[rsp], rax
  000f8	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _i$24471[rsp], 0
  00100	eb 0a		 jmp	 SHORT $LN18@compiler_c@3
$LN17@compiler_c@3:
  00102	8b 44 24 38	 mov	 eax, DWORD PTR _i$24471[rsp]
  00106	ff c0		 inc	 eax
  00108	89 44 24 38	 mov	 DWORD PTR _i$24471[rsp], eax
$LN18@compiler_c@3:
  0010c	48 83 7c 24 40
	00		 cmp	 QWORD PTR seq$24472[rsp], 0
  00112	75 0b		 jne	 SHORT $LN30@compiler_c@3
  00114	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv86[rsp], 0
  0011d	eb 0d		 jmp	 SHORT $LN31@compiler_c@3
$LN30@compiler_c@3:
  0011f	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$24472[rsp]
  00124	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00127	48 89 44 24 60	 mov	 QWORD PTR tv86[rsp], rax
$LN31@compiler_c@3:
  0012c	48 63 44 24 38	 movsxd	 rax, DWORD PTR _i$24471[rsp]
  00131	48 3b 44 24 60	 cmp	 rax, QWORD PTR tv86[rsp]
  00136	7d 33		 jge	 SHORT $LN16@compiler_c@3
  00138	48 63 44 24 38	 movsxd	 rax, DWORD PTR _i$24471[rsp]
  0013d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$24472[rsp]
  00142	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00147	48 89 44 24 48	 mov	 QWORD PTR elt$24477[rsp], rax
  0014c	48 8b 54 24 48	 mov	 rdx, QWORD PTR elt$24477[rsp]
  00151	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00159	e8 00 00 00 00	 call	 compiler_visit_keyword
  0015e	85 c0		 test	 eax, eax
  00160	75 07		 jne	 SHORT $LN15@compiler_c@3
  00162	33 c0		 xor	 eax, eax
  00164	e9 6e 01 00 00	 jmp	 $LN24@compiler_c@3
$LN15@compiler_c@3:
  00169	eb 97		 jmp	 SHORT $LN17@compiler_c@3
$LN16@compiler_c@3:

; 2910 :         n |= asdl_seq_LEN(keywords) << 8;

  0016b	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR keywords$[rsp], 0
  00174	75 0b		 jne	 SHORT $LN32@compiler_c@3
  00176	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv129[rsp], 0
  0017f	eb 10		 jmp	 SHORT $LN33@compiler_c@3
$LN32@compiler_c@3:
  00181	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR keywords$[rsp]
  00189	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0018c	48 89 44 24 68	 mov	 QWORD PTR tv129[rsp], rax
$LN33@compiler_c@3:
  00191	48 8b 44 24 68	 mov	 rax, QWORD PTR tv129[rsp]
  00196	48 c1 e0 08	 shl	 rax, 8
  0019a	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR n$[rsp]
  001a2	48 0b c8	 or	 rcx, rax
  001a5	48 8b c1	 mov	 rax, rcx
  001a8	89 84 24 98 00
	00 00		 mov	 DWORD PTR n$[rsp], eax
$LN19@compiler_c@3:

; 2911 :     }
; 2912 :     if (starargs) {

  001af	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR starargs$[rsp], 0
  001b8	74 2b		 je	 SHORT $LN14@compiler_c@3

; 2913 :         VISIT(c, expr, starargs);

  001ba	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR starargs$[rsp]
  001c2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001ca	e8 00 00 00 00	 call	 compiler_visit_expr
  001cf	85 c0		 test	 eax, eax
  001d1	75 07		 jne	 SHORT $LN13@compiler_c@3
  001d3	33 c0		 xor	 eax, eax
  001d5	e9 fd 00 00 00	 jmp	 $LN24@compiler_c@3
$LN13@compiler_c@3:

; 2914 :         code |= 1;

  001da	8b 44 24 20	 mov	 eax, DWORD PTR code$[rsp]
  001de	83 c8 01	 or	 eax, 1
  001e1	89 44 24 20	 mov	 DWORD PTR code$[rsp], eax
$LN14@compiler_c@3:

; 2915 :     }
; 2916 :     if (kwargs) {

  001e5	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR kwargs$[rsp], 0
  001ee	74 2b		 je	 SHORT $LN12@compiler_c@3

; 2917 :         VISIT(c, expr, kwargs);

  001f0	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  001f8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00200	e8 00 00 00 00	 call	 compiler_visit_expr
  00205	85 c0		 test	 eax, eax
  00207	75 07		 jne	 SHORT $LN11@compiler_c@3
  00209	33 c0		 xor	 eax, eax
  0020b	e9 c7 00 00 00	 jmp	 $LN24@compiler_c@3
$LN11@compiler_c@3:

; 2918 :         code |= 2;

  00210	8b 44 24 20	 mov	 eax, DWORD PTR code$[rsp]
  00214	83 c8 02	 or	 eax, 2
  00217	89 44 24 20	 mov	 DWORD PTR code$[rsp], eax
$LN12@compiler_c@3:

; 2919 :     }
; 2920 :     switch (code) {

  0021b	8b 44 24 20	 mov	 eax, DWORD PTR code$[rsp]
  0021f	89 44 24 70	 mov	 DWORD PTR tv146[rsp], eax
  00223	83 7c 24 70 00	 cmp	 DWORD PTR tv146[rsp], 0
  00228	74 1a		 je	 SHORT $LN8@compiler_c@3
  0022a	83 7c 24 70 01	 cmp	 DWORD PTR tv146[rsp], 1
  0022f	74 37		 je	 SHORT $LN6@compiler_c@3
  00231	83 7c 24 70 02	 cmp	 DWORD PTR tv146[rsp], 2
  00236	74 54		 je	 SHORT $LN4@compiler_c@3
  00238	83 7c 24 70 03	 cmp	 DWORD PTR tv146[rsp], 3
  0023d	74 71		 je	 SHORT $LN2@compiler_c@3
  0023f	e9 8e 00 00 00	 jmp	 $LN9@compiler_c@3
$LN8@compiler_c@3:

; 2921 :     case 0:
; 2922 :         ADDOP_I(c, CALL_FUNCTION, n);

  00244	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR n$[rsp]
  0024c	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  00251	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00259	e8 00 00 00 00	 call	 compiler_addop_i
  0025e	85 c0		 test	 eax, eax
  00260	75 04		 jne	 SHORT $LN7@compiler_c@3
  00262	33 c0		 xor	 eax, eax
  00264	eb 71		 jmp	 SHORT $LN24@compiler_c@3
$LN7@compiler_c@3:

; 2923 :         break;

  00266	eb 6a		 jmp	 SHORT $LN9@compiler_c@3
$LN6@compiler_c@3:

; 2924 :     case 1:
; 2925 :         ADDOP_I(c, CALL_FUNCTION_VAR, n);

  00268	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR n$[rsp]
  00270	ba 8c 00 00 00	 mov	 edx, 140		; 0000008cH
  00275	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0027d	e8 00 00 00 00	 call	 compiler_addop_i
  00282	85 c0		 test	 eax, eax
  00284	75 04		 jne	 SHORT $LN5@compiler_c@3
  00286	33 c0		 xor	 eax, eax
  00288	eb 4d		 jmp	 SHORT $LN24@compiler_c@3
$LN5@compiler_c@3:

; 2926 :         break;

  0028a	eb 46		 jmp	 SHORT $LN9@compiler_c@3
$LN4@compiler_c@3:

; 2927 :     case 2:
; 2928 :         ADDOP_I(c, CALL_FUNCTION_KW, n);

  0028c	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR n$[rsp]
  00294	ba 8d 00 00 00	 mov	 edx, 141		; 0000008dH
  00299	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002a1	e8 00 00 00 00	 call	 compiler_addop_i
  002a6	85 c0		 test	 eax, eax
  002a8	75 04		 jne	 SHORT $LN3@compiler_c@3
  002aa	33 c0		 xor	 eax, eax
  002ac	eb 29		 jmp	 SHORT $LN24@compiler_c@3
$LN3@compiler_c@3:

; 2929 :         break;

  002ae	eb 22		 jmp	 SHORT $LN9@compiler_c@3
$LN2@compiler_c@3:

; 2930 :     case 3:
; 2931 :         ADDOP_I(c, CALL_FUNCTION_VAR_KW, n);

  002b0	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR n$[rsp]
  002b8	ba 8e 00 00 00	 mov	 edx, 142		; 0000008eH
  002bd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002c5	e8 00 00 00 00	 call	 compiler_addop_i
  002ca	85 c0		 test	 eax, eax
  002cc	75 04		 jne	 SHORT $LN1@compiler_c@3
  002ce	33 c0		 xor	 eax, eax
  002d0	eb 05		 jmp	 SHORT $LN24@compiler_c@3
$LN1@compiler_c@3:
$LN9@compiler_c@3:

; 2932 :         break;
; 2933 :     }
; 2934 :     return 1;

  002d2	b8 01 00 00 00	 mov	 eax, 1
$LN24@compiler_c@3:

; 2935 : }

  002d7	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002de	c3		 ret	 0
compiler_call_helper ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_keyword DD imagerel compiler_visit_keyword
	DD	imagerel compiler_visit_keyword+95
	DD	imagerel $unwind$compiler_visit_keyword
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_keyword DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_visit_keyword
_TEXT	SEGMENT
c$ = 48
k$ = 56
compiler_visit_keyword PROC				; COMDAT

; 3174 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3175 :     ADDOP_O(c, LOAD_CONST, k->arg, consts);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR c$[rsp]
  00013	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR k$[rsp]
  0001c	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  0001f	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00023	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$[rsp]
  0002d	e8 00 00 00 00	 call	 compiler_addop_o
  00032	85 c0		 test	 eax, eax
  00034	75 04		 jne	 SHORT $LN2@compiler_v@6
  00036	33 c0		 xor	 eax, eax
  00038	eb 20		 jmp	 SHORT $LN3@compiler_v@6
$LN2@compiler_v@6:

; 3176 :     VISIT(c, expr, k->value);

  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR k$[rsp]
  0003f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$[rsp]
  00048	e8 00 00 00 00	 call	 compiler_visit_expr
  0004d	85 c0		 test	 eax, eax
  0004f	75 04		 jne	 SHORT $LN1@compiler_v@6
  00051	33 c0		 xor	 eax, eax
  00053	eb 05		 jmp	 SHORT $LN3@compiler_v@6
$LN1@compiler_v@6:

; 3177 :     return 1;

  00055	b8 01 00 00 00	 mov	 eax, 1
$LN3@compiler_v@6:

; 3178 : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
compiler_visit_keyword ENDP
_TEXT	ENDS
PUBLIC	??_C@_09PMJCCPKK@__debug__?$AA@			; `string'
PUBLIC	??_C@_04OHJIHAFH@None?$AA@			; `string'
PUBLIC	??_C@_05MKDOIIA@False?$AA@			; `string'
PUBLIC	??_C@_04HPMIDMKH@True?$AA@			; `string'
EXTRN	strcmp:PROC
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$expr_constant DD imagerel expr_constant
	DD	imagerel expr_constant+269
	DD	imagerel $unwind$expr_constant
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$expr_constant DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_09PMJCCPKK@__debug__?$AA@
CONST	SEGMENT
??_C@_09PMJCCPKK@__debug__?$AA@ DB '__debug__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None?$AA@
CONST	SEGMENT
??_C@_04OHJIHAFH@None?$AA@ DB 'None', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MKDOIIA@False?$AA@
CONST	SEGMENT
??_C@_05MKDOIIA@False?$AA@ DB 'False', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPMIDMKH@True?$AA@
CONST	SEGMENT
??_C@_04HPMIDMKH@True?$AA@ DB 'True', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT expr_constant
_TEXT	SEGMENT
id$ = 32
tv64 = 40
tv92 = 44
c$ = 64
e$ = 72
expr_constant PROC					; COMDAT

; 3188 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3189 :     char *id;
; 3190 :     switch (e->kind) {

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  00013	8b 00		 mov	 eax, DWORD PTR [rax]
  00015	89 44 24 28	 mov	 DWORD PTR tv64[rsp], eax
  00019	83 7c 24 28 10	 cmp	 DWORD PTR tv64[rsp], 16
  0001e	74 24		 je	 SHORT $LN8@expr_const
  00020	83 7c 24 28 11	 cmp	 DWORD PTR tv64[rsp], 17
  00025	74 30		 je	 SHORT $LN7@expr_const
  00027	83 7c 24 28 13	 cmp	 DWORD PTR tv64[rsp], 19
  0002c	74 0c		 je	 SHORT $LN9@expr_const
  0002e	83 7c 24 28 17	 cmp	 DWORD PTR tv64[rsp], 23
  00033	74 35		 je	 SHORT $LN6@expr_const
  00035	e9 c9 00 00 00	 jmp	 $LN1@expr_const
$LN9@expr_const:

; 3191 :     case Ellipsis_kind:
; 3192 :         return 1;

  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	e9 c4 00 00 00	 jmp	 $LN12@expr_const
$LN8@expr_const:

; 3193 :     case Num_kind:
; 3194 :         return PyObject_IsTrue(e->v.Num.n);

  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  00049	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0004d	e8 00 00 00 00	 call	 PyObject_IsTrue
  00052	e9 b1 00 00 00	 jmp	 $LN12@expr_const
$LN7@expr_const:

; 3195 :     case Str_kind:
; 3196 :         return PyObject_IsTrue(e->v.Str.s);

  00057	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  0005c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00060	e8 00 00 00 00	 call	 PyObject_IsTrue
  00065	e9 9e 00 00 00	 jmp	 $LN12@expr_const
$LN6@expr_const:

; 3197 :     case Name_kind:
; 3198 :         /* optimize away names that can't be reassigned */
; 3199 :         id = PyUnicode_AsUTF8(e->v.Name.id);

  0006a	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  0006f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00073	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00078	48 89 44 24 20	 mov	 QWORD PTR id$[rsp], rax

; 3200 :         if (strcmp(id, "True") == 0) return 1;

  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04HPMIDMKH@True?$AA@
  00084	48 8b 4c 24 20	 mov	 rcx, QWORD PTR id$[rsp]
  00089	e8 00 00 00 00	 call	 strcmp
  0008e	85 c0		 test	 eax, eax
  00090	75 07		 jne	 SHORT $LN5@expr_const
  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	eb 6f		 jmp	 SHORT $LN12@expr_const
$LN5@expr_const:

; 3201 :         if (strcmp(id, "False") == 0) return 0;

  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05MKDOIIA@False?$AA@
  000a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR id$[rsp]
  000a5	e8 00 00 00 00	 call	 strcmp
  000aa	85 c0		 test	 eax, eax
  000ac	75 04		 jne	 SHORT $LN4@expr_const
  000ae	33 c0		 xor	 eax, eax
  000b0	eb 56		 jmp	 SHORT $LN12@expr_const
$LN4@expr_const:

; 3202 :         if (strcmp(id, "None") == 0) return 0;

  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04OHJIHAFH@None?$AA@
  000b9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR id$[rsp]
  000be	e8 00 00 00 00	 call	 strcmp
  000c3	85 c0		 test	 eax, eax
  000c5	75 04		 jne	 SHORT $LN3@expr_const
  000c7	33 c0		 xor	 eax, eax
  000c9	eb 3d		 jmp	 SHORT $LN12@expr_const
$LN3@expr_const:

; 3203 :         if (strcmp(id, "__debug__") == 0)

  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09PMJCCPKK@__debug__?$AA@
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR id$[rsp]
  000d7	e8 00 00 00 00	 call	 strcmp
  000dc	85 c0		 test	 eax, eax
  000de	75 23		 jne	 SHORT $LN2@expr_const

; 3204 :             return ! c->c_optimize;

  000e0	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000e5	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  000e9	75 0a		 jne	 SHORT $LN14@expr_const
  000eb	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000f3	eb 08		 jmp	 SHORT $LN15@expr_const
$LN14@expr_const:
  000f5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN15@expr_const:
  000fd	8b 44 24 2c	 mov	 eax, DWORD PTR tv92[rsp]
  00101	eb 05		 jmp	 SHORT $LN12@expr_const
$LN2@expr_const:
$LN1@expr_const:

; 3205 :         /* fall through */
; 3206 :     default:
; 3207 :         return -1;

  00103	b8 ff ff ff ff	 mov	 eax, -1
$LN12@expr_const:

; 3208 :     }
; 3209 : }

  00108	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0010c	c3		 ret	 0
expr_constant ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@JICCKGPJ@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAW?$AAi?$AAt?$AAh?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_with DD imagerel compiler_with
	DD	imagerel compiler_with+761
	DD	imagerel $unwind$compiler_with
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_with DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_1CK@JICCKGPJ@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAW?$AAi?$AAt?$AAh?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@JICCKGPJ@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAW?$AAi?$AAt?$AAh?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 's'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'W', 00H, 'i', 00H, 't'
	DB	00H, 'h', 00H, '_', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_with
_TEXT	SEGMENT
item$ = 32
finally$ = 40
block$ = 48
_i$24738 = 56
seq$24739 = 64
elt$24744 = 72
tv146 = 80
tv152 = 88
c$ = 112
s$ = 120
pos$ = 128
compiler_with PROC					; COMDAT

; 3236 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3237 :     basicblock *block, *finally;
; 3238 :     withitem_ty item = asdl_seq_GET(s->v.With.items, pos);

  00013	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00018	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001c	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR pos$[rsp]
  00024	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  00029	48 89 44 24 20	 mov	 QWORD PTR item$[rsp], rax

; 3239 : 
; 3240 :     assert(s->kind == With_kind);

  0002e	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00033	83 38 0a	 cmp	 DWORD PTR [rax], 10
  00036	74 1c		 je	 SHORT $LN24@compiler_w@2
  00038	41 b8 a8 0c 00
	00		 mov	 r8d, 3240		; 00000ca8H
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JICCKGPJ@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAW?$AAi?$AAt?$AAh?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00052	33 c0		 xor	 eax, eax
$LN24@compiler_w@2:

; 3241 : 
; 3242 :     block = compiler_new_block(c);

  00054	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00059	e8 00 00 00 00	 call	 compiler_new_block
  0005e	48 89 44 24 30	 mov	 QWORD PTR block$[rsp], rax

; 3243 :     finally = compiler_new_block(c);

  00063	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00068	e8 00 00 00 00	 call	 compiler_new_block
  0006d	48 89 44 24 28	 mov	 QWORD PTR finally$[rsp], rax

; 3244 :     if (!block || !finally)

  00072	48 83 7c 24 30
	00		 cmp	 QWORD PTR block$[rsp], 0
  00078	74 08		 je	 SHORT $LN20@compiler_w@2
  0007a	48 83 7c 24 28
	00		 cmp	 QWORD PTR finally$[rsp], 0
  00080	75 07		 jne	 SHORT $LN21@compiler_w@2
$LN20@compiler_w@2:

; 3245 :         return 0;

  00082	33 c0		 xor	 eax, eax
  00084	e9 6b 02 00 00	 jmp	 $LN22@compiler_w@2
$LN21@compiler_w@2:

; 3246 : 
; 3247 :     /* Evaluate EXPR */
; 3248 :     VISIT(c, expr, item->context_expr);

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR item$[rsp]
  0008e	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00091	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00096	e8 00 00 00 00	 call	 compiler_visit_expr
  0009b	85 c0		 test	 eax, eax
  0009d	75 07		 jne	 SHORT $LN19@compiler_w@2
  0009f	33 c0		 xor	 eax, eax
  000a1	e9 4e 02 00 00	 jmp	 $LN22@compiler_w@2
$LN19@compiler_w@2:

; 3249 :     ADDOP_JREL(c, SETUP_WITH, finally);

  000a6	45 33 c9	 xor	 r9d, r9d
  000a9	4c 8b 44 24 28	 mov	 r8, QWORD PTR finally$[rsp]
  000ae	ba 8f 00 00 00	 mov	 edx, 143		; 0000008fH
  000b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000b8	e8 00 00 00 00	 call	 compiler_addop_j
  000bd	85 c0		 test	 eax, eax
  000bf	75 07		 jne	 SHORT $LN18@compiler_w@2
  000c1	33 c0		 xor	 eax, eax
  000c3	e9 2c 02 00 00	 jmp	 $LN22@compiler_w@2
$LN18@compiler_w@2:

; 3250 : 
; 3251 :     /* SETUP_WITH pushes a finally block. */
; 3252 :     compiler_use_next_block(c, block);

  000c8	48 8b 54 24 30	 mov	 rdx, QWORD PTR block$[rsp]
  000cd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000d2	e8 00 00 00 00	 call	 compiler_use_next_block

; 3253 :     if (!compiler_push_fblock(c, FINALLY_TRY, block)) {

  000d7	4c 8b 44 24 30	 mov	 r8, QWORD PTR block$[rsp]
  000dc	ba 02 00 00 00	 mov	 edx, 2
  000e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000e6	e8 00 00 00 00	 call	 compiler_push_fblock
  000eb	85 c0		 test	 eax, eax
  000ed	75 07		 jne	 SHORT $LN17@compiler_w@2

; 3254 :         return 0;

  000ef	33 c0		 xor	 eax, eax
  000f1	e9 fe 01 00 00	 jmp	 $LN22@compiler_w@2
$LN17@compiler_w@2:

; 3255 :     }
; 3256 : 
; 3257 :     if (item->optional_vars) {

  000f6	48 8b 44 24 20	 mov	 rax, QWORD PTR item$[rsp]
  000fb	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00100	74 20		 je	 SHORT $LN16@compiler_w@2

; 3258 :         VISIT(c, expr, item->optional_vars);

  00102	48 8b 44 24 20	 mov	 rax, QWORD PTR item$[rsp]
  00107	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0010b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00110	e8 00 00 00 00	 call	 compiler_visit_expr
  00115	85 c0		 test	 eax, eax
  00117	75 07		 jne	 SHORT $LN15@compiler_w@2
  00119	33 c0		 xor	 eax, eax
  0011b	e9 d4 01 00 00	 jmp	 $LN22@compiler_w@2
$LN15@compiler_w@2:

; 3259 :     }
; 3260 :     else {

  00120	eb 1a		 jmp	 SHORT $LN14@compiler_w@2
$LN16@compiler_w@2:

; 3261 :     /* Discard result from context.__enter__() */
; 3262 :         ADDOP(c, POP_TOP);

  00122	ba 01 00 00 00	 mov	 edx, 1
  00127	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0012c	e8 00 00 00 00	 call	 compiler_addop
  00131	85 c0		 test	 eax, eax
  00133	75 07		 jne	 SHORT $LN13@compiler_w@2
  00135	33 c0		 xor	 eax, eax
  00137	e9 b8 01 00 00	 jmp	 $LN22@compiler_w@2
$LN13@compiler_w@2:
$LN14@compiler_w@2:

; 3263 :     }
; 3264 : 
; 3265 :     pos++;

  0013c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR pos$[rsp]
  00143	ff c0		 inc	 eax
  00145	89 84 24 80 00
	00 00		 mov	 DWORD PTR pos$[rsp], eax

; 3266 :     if (pos == asdl_seq_LEN(s->v.With.items))

  0014c	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00151	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00156	75 0b		 jne	 SHORT $LN25@compiler_w@2
  00158	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv146[rsp], 0
  00161	eb 11		 jmp	 SHORT $LN26@compiler_w@2
$LN25@compiler_w@2:
  00163	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00168	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0016c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0016f	48 89 44 24 50	 mov	 QWORD PTR tv146[rsp], rax
$LN26@compiler_w@2:
  00174	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR pos$[rsp]
  0017c	48 3b 44 24 50	 cmp	 rax, QWORD PTR tv146[rsp]
  00181	0f 85 80 00 00
	00		 jne	 $LN12@compiler_w@2

; 3267 :         /* BLOCK code */
; 3268 :         VISIT_SEQ(c, stmt, s->v.With.body)

  00187	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  0018c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00190	48 89 44 24 40	 mov	 QWORD PTR seq$24739[rsp], rax
  00195	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _i$24738[rsp], 0
  0019d	eb 0a		 jmp	 SHORT $LN11@compiler_w@2
$LN10@compiler_w@2:
  0019f	8b 44 24 38	 mov	 eax, DWORD PTR _i$24738[rsp]
  001a3	ff c0		 inc	 eax
  001a5	89 44 24 38	 mov	 DWORD PTR _i$24738[rsp], eax
$LN11@compiler_w@2:
  001a9	48 83 7c 24 40
	00		 cmp	 QWORD PTR seq$24739[rsp], 0
  001af	75 0b		 jne	 SHORT $LN27@compiler_w@2
  001b1	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv152[rsp], 0
  001ba	eb 0d		 jmp	 SHORT $LN28@compiler_w@2
$LN27@compiler_w@2:
  001bc	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$24739[rsp]
  001c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c4	48 89 44 24 58	 mov	 QWORD PTR tv152[rsp], rax
$LN28@compiler_w@2:
  001c9	48 63 44 24 38	 movsxd	 rax, DWORD PTR _i$24738[rsp]
  001ce	48 3b 44 24 58	 cmp	 rax, QWORD PTR tv152[rsp]
  001d3	7d 30		 jge	 SHORT $LN9@compiler_w@2
  001d5	48 63 44 24 38	 movsxd	 rax, DWORD PTR _i$24738[rsp]
  001da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$24739[rsp]
  001df	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  001e4	48 89 44 24 48	 mov	 QWORD PTR elt$24744[rsp], rax
  001e9	48 8b 54 24 48	 mov	 rdx, QWORD PTR elt$24744[rsp]
  001ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  001f3	e8 00 00 00 00	 call	 compiler_visit_stmt
  001f8	85 c0		 test	 eax, eax
  001fa	75 07		 jne	 SHORT $LN8@compiler_w@2
  001fc	33 c0		 xor	 eax, eax
  001fe	e9 f1 00 00 00	 jmp	 $LN22@compiler_w@2
$LN8@compiler_w@2:
  00203	eb 9a		 jmp	 SHORT $LN10@compiler_w@2
$LN9@compiler_w@2:

; 3269 :     else if (!compiler_with(c, s, pos))

  00205	eb 22		 jmp	 SHORT $LN7@compiler_w@2
$LN12@compiler_w@2:
  00207	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR pos$[rsp]
  0020f	48 8b 54 24 78	 mov	 rdx, QWORD PTR s$[rsp]
  00214	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00219	e8 00 00 00 00	 call	 compiler_with
  0021e	85 c0		 test	 eax, eax
  00220	75 07		 jne	 SHORT $LN6@compiler_w@2

; 3270 :             return 0;

  00222	33 c0		 xor	 eax, eax
  00224	e9 cb 00 00 00	 jmp	 $LN22@compiler_w@2
$LN6@compiler_w@2:
$LN7@compiler_w@2:

; 3271 : 
; 3272 :     /* End of try block; start the finally block */
; 3273 :     ADDOP(c, POP_BLOCK);

  00229	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  0022e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00233	e8 00 00 00 00	 call	 compiler_addop
  00238	85 c0		 test	 eax, eax
  0023a	75 07		 jne	 SHORT $LN5@compiler_w@2
  0023c	33 c0		 xor	 eax, eax
  0023e	e9 b1 00 00 00	 jmp	 $LN22@compiler_w@2
$LN5@compiler_w@2:

; 3274 :     compiler_pop_fblock(c, FINALLY_TRY, block);

  00243	4c 8b 44 24 30	 mov	 r8, QWORD PTR block$[rsp]
  00248	ba 02 00 00 00	 mov	 edx, 2
  0024d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00252	e8 00 00 00 00	 call	 compiler_pop_fblock

; 3275 : 
; 3276 :     ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00257	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0025c	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00260	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00267	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  0026b	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00270	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00275	e8 00 00 00 00	 call	 compiler_addop_o
  0027a	85 c0		 test	 eax, eax
  0027c	75 04		 jne	 SHORT $LN4@compiler_w@2
  0027e	33 c0		 xor	 eax, eax
  00280	eb 72		 jmp	 SHORT $LN22@compiler_w@2
$LN4@compiler_w@2:

; 3277 :     compiler_use_next_block(c, finally);

  00282	48 8b 54 24 28	 mov	 rdx, QWORD PTR finally$[rsp]
  00287	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0028c	e8 00 00 00 00	 call	 compiler_use_next_block

; 3278 :     if (!compiler_push_fblock(c, FINALLY_END, finally))

  00291	4c 8b 44 24 28	 mov	 r8, QWORD PTR finally$[rsp]
  00296	ba 03 00 00 00	 mov	 edx, 3
  0029b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002a0	e8 00 00 00 00	 call	 compiler_push_fblock
  002a5	85 c0		 test	 eax, eax
  002a7	75 04		 jne	 SHORT $LN3@compiler_w@2

; 3279 :         return 0;

  002a9	33 c0		 xor	 eax, eax
  002ab	eb 47		 jmp	 SHORT $LN22@compiler_w@2
$LN3@compiler_w@2:

; 3280 : 
; 3281 :     /* Finally block starts; context.__exit__ is on the stack under
; 3282 :        the exception or return information. Just issue our magic
; 3283 :        opcode. */
; 3284 :     ADDOP(c, WITH_CLEANUP);

  002ad	ba 51 00 00 00	 mov	 edx, 81			; 00000051H
  002b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002b7	e8 00 00 00 00	 call	 compiler_addop
  002bc	85 c0		 test	 eax, eax
  002be	75 04		 jne	 SHORT $LN2@compiler_w@2
  002c0	33 c0		 xor	 eax, eax
  002c2	eb 30		 jmp	 SHORT $LN22@compiler_w@2
$LN2@compiler_w@2:

; 3285 : 
; 3286 :     /* Finally block ends. */
; 3287 :     ADDOP(c, END_FINALLY);

  002c4	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  002c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002ce	e8 00 00 00 00	 call	 compiler_addop
  002d3	85 c0		 test	 eax, eax
  002d5	75 04		 jne	 SHORT $LN1@compiler_w@2
  002d7	33 c0		 xor	 eax, eax
  002d9	eb 19		 jmp	 SHORT $LN22@compiler_w@2
$LN1@compiler_w@2:

; 3288 :     compiler_pop_fblock(c, FINALLY_END, finally);

  002db	4c 8b 44 24 28	 mov	 r8, QWORD PTR finally$[rsp]
  002e0	ba 03 00 00 00	 mov	 edx, 3
  002e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  002ea	e8 00 00 00 00	 call	 compiler_pop_fblock

; 3289 :     return 1;

  002ef	b8 01 00 00 00	 mov	 eax, 1
$LN22@compiler_w@2:

; 3290 : }

  002f4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002f8	c3		 ret	 0
compiler_with ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@NHBPOLCF@can?5use?5starred?5expression?5only?5@ ; `string'
PUBLIC	??_C@_0DF@IPNNMMFP@starred?5assignment?5target?5must?5b@ ; `string'
PUBLIC	??_C@_0CG@CACGIAAN@param?5invalid?5in?5subscript?5expre@ ; `string'
PUBLIC	??_C@_0CG@COAMAJAK@param?5invalid?5in?5attribute?5expre@ ; `string'
PUBLIC	??_C@_0BJ@KHLOCEPE@?8yield?8?5outside?5function?$AA@ ; `string'
EXTRN	_Py_EllipsisObject:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_expr DD imagerel compiler_visit_expr
	DD	imagerel compiler_visit_expr+2892
	DD	imagerel $unwind$compiler_visit_expr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_expr DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0DF@NHBPOLCF@can?5use?5starred?5expression?5only?5@
CONST	SEGMENT
??_C@_0DF@NHBPOLCF@can?5use?5starred?5expression?5only?5@ DB 'can use sta'
	DB	'rred expression only as assignment target', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@IPNNMMFP@starred?5assignment?5target?5must?5b@
CONST	SEGMENT
??_C@_0DF@IPNNMMFP@starred?5assignment?5target?5must?5b@ DB 'starred assi'
	DB	'gnment target must be in a list or tuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CACGIAAN@param?5invalid?5in?5subscript?5expre@
CONST	SEGMENT
??_C@_0CG@CACGIAAN@param?5invalid?5in?5subscript?5expre@ DB 'param invali'
	DB	'd in subscript expression', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@COAMAJAK@param?5invalid?5in?5attribute?5expre@
CONST	SEGMENT
??_C@_0CG@COAMAJAK@param?5invalid?5in?5attribute?5expre@ DB 'param invali'
	DB	'd in attribute expression', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KHLOCEPE@?8yield?8?5outside?5function?$AA@
CONST	SEGMENT
??_C@_0BJ@KHLOCEPE@?8yield?8?5outside?5function?$AA@ DB '''yield'' outsid'
	DB	'e function', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_visit_expr
_TEXT	SEGMENT
n$ = 32
i$ = 36
_i$24789 = 40
seq$24790 = 48
elt$24795 = 56
tv76 = 64
tv152 = 72
tv156 = 80
tv189 = 88
tv195 = 96
tv325 = 104
tv369 = 108
tv428 = 112
c$ = 144
e$ = 152
compiler_visit_expr PROC				; COMDAT

; 3294 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 3295 :     int i, n;
; 3296 : 
; 3297 :     /* If expr e has a different line number than the last expr/stmt,
; 3298 :        set a new line number for the next instruction.
; 3299 :     */
; 3300 :     if (e->lineno > c->u->u_lineno) {

  00011	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00019	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0001d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  00025	8b 80 b4 01 00
	00		 mov	 eax, DWORD PTR [rax+436]
  0002b	39 41 30	 cmp	 DWORD PTR [rcx+48], eax
  0002e	7e 33		 jle	 SHORT $LN96@compiler_v@7

; 3301 :         c->u->u_lineno = e->lineno;

  00030	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00038	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0003c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  00044	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00047	89 88 b4 01 00
	00		 mov	 DWORD PTR [rax+436], ecx

; 3302 :         c->u->u_lineno_set = 0;

  0004d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00055	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00059	c7 80 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+444], 0
$LN96@compiler_v@7:

; 3303 :     }
; 3304 :     /* Updating the column offset is always harmless. */
; 3305 :     c->u->u_col_offset = e->col_offset;

  00063	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0006b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0006f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  00077	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  0007a	89 88 b8 01 00
	00		 mov	 DWORD PTR [rax+440], ecx

; 3306 :     switch (e->kind) {

  00080	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00088	8b 00		 mov	 eax, DWORD PTR [rax]
  0008a	89 44 24 40	 mov	 DWORD PTR tv76[rsp], eax
  0008e	8b 44 24 40	 mov	 eax, DWORD PTR tv76[rsp]
  00092	ff c8		 dec	 eax
  00094	89 44 24 40	 mov	 DWORD PTR tv76[rsp], eax
  00098	83 7c 24 40 18	 cmp	 DWORD PTR tv76[rsp], 24
  0009d	0f 87 35 0a 00
	00		 ja	 $LN94@compiler_v@7
  000a3	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv76[rsp]
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000af	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN107@compiler_v@7[rcx+rax*4]
  000b6	48 03 c1	 add	 rax, rcx
  000b9	ff e0		 jmp	 rax
$LN93@compiler_v@7:

; 3307 :     case BoolOp_kind:
; 3308 :         return compiler_boolop(c, e);

  000bb	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  000c3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000cb	e8 00 00 00 00	 call	 compiler_boolop
  000d0	e9 08 0a 00 00	 jmp	 $LN97@compiler_v@7
$LN92@compiler_v@7:

; 3309 :     case BinOp_kind:
; 3310 :         VISIT(c, expr, e->v.BinOp.left);

  000d5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  000dd	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000e9	e8 00 00 00 00	 call	 compiler_visit_expr
  000ee	85 c0		 test	 eax, eax
  000f0	75 07		 jne	 SHORT $LN91@compiler_v@7
  000f2	33 c0		 xor	 eax, eax
  000f4	e9 e4 09 00 00	 jmp	 $LN97@compiler_v@7
$LN91@compiler_v@7:

; 3311 :         VISIT(c, expr, e->v.BinOp.right);

  000f9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00101	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00105	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0010d	e8 00 00 00 00	 call	 compiler_visit_expr
  00112	85 c0		 test	 eax, eax
  00114	75 07		 jne	 SHORT $LN90@compiler_v@7
  00116	33 c0		 xor	 eax, eax
  00118	e9 c0 09 00 00	 jmp	 $LN97@compiler_v@7
$LN90@compiler_v@7:

; 3312 :         ADDOP(c, binop(c, e->v.BinOp.op));

  0011d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00125	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00128	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00130	e8 00 00 00 00	 call	 binop
  00135	8b d0		 mov	 edx, eax
  00137	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0013f	e8 00 00 00 00	 call	 compiler_addop
  00144	85 c0		 test	 eax, eax
  00146	75 07		 jne	 SHORT $LN89@compiler_v@7
  00148	33 c0		 xor	 eax, eax
  0014a	e9 8e 09 00 00	 jmp	 $LN97@compiler_v@7
$LN89@compiler_v@7:

; 3313 :         break;

  0014f	e9 84 09 00 00	 jmp	 $LN94@compiler_v@7
$LN88@compiler_v@7:

; 3314 :     case UnaryOp_kind:
; 3315 :         VISIT(c, expr, e->v.UnaryOp.operand);

  00154	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0015c	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00160	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00168	e8 00 00 00 00	 call	 compiler_visit_expr
  0016d	85 c0		 test	 eax, eax
  0016f	75 07		 jne	 SHORT $LN87@compiler_v@7
  00171	33 c0		 xor	 eax, eax
  00173	e9 65 09 00 00	 jmp	 $LN97@compiler_v@7
$LN87@compiler_v@7:

; 3316 :         ADDOP(c, unaryop(e->v.UnaryOp.op));

  00178	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00180	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00183	e8 00 00 00 00	 call	 unaryop
  00188	8b d0		 mov	 edx, eax
  0018a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00192	e8 00 00 00 00	 call	 compiler_addop
  00197	85 c0		 test	 eax, eax
  00199	75 07		 jne	 SHORT $LN86@compiler_v@7
  0019b	33 c0		 xor	 eax, eax
  0019d	e9 3b 09 00 00	 jmp	 $LN97@compiler_v@7
$LN86@compiler_v@7:

; 3317 :         break;

  001a2	e9 31 09 00 00	 jmp	 $LN94@compiler_v@7
$LN85@compiler_v@7:

; 3318 :     case Lambda_kind:
; 3319 :         return compiler_lambda(c, e);

  001a7	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  001af	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001b7	e8 00 00 00 00	 call	 compiler_lambda
  001bc	e9 1c 09 00 00	 jmp	 $LN97@compiler_v@7
$LN84@compiler_v@7:

; 3320 :     case IfExp_kind:
; 3321 :         return compiler_ifexp(c, e);

  001c1	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  001c9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001d1	e8 00 00 00 00	 call	 compiler_ifexp
  001d6	e9 02 09 00 00	 jmp	 $LN97@compiler_v@7
$LN83@compiler_v@7:

; 3322 :     case Dict_kind:
; 3323 :         n = asdl_seq_LEN(e->v.Dict.values);

  001db	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  001e3	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  001e8	75 0b		 jne	 SHORT $LN99@compiler_v@7
  001ea	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv152[rsp], 0
  001f3	eb 14		 jmp	 SHORT $LN100@compiler_v@7
$LN99@compiler_v@7:
  001f5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  001fd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00201	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00204	48 89 44 24 48	 mov	 QWORD PTR tv152[rsp], rax
$LN100@compiler_v@7:
  00209	8b 44 24 48	 mov	 eax, DWORD PTR tv152[rsp]
  0020d	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 3324 :         ADDOP_I(c, BUILD_MAP, (n>0xFFFF ? 0xFFFF : n));

  00211	81 7c 24 20 ff
	ff 00 00	 cmp	 DWORD PTR n$[rsp], 65535 ; 0000ffffH
  00219	7e 0a		 jle	 SHORT $LN101@compiler_v@7
  0021b	c7 44 24 50 ff
	ff 00 00	 mov	 DWORD PTR tv156[rsp], 65535 ; 0000ffffH
  00223	eb 08		 jmp	 SHORT $LN102@compiler_v@7
$LN101@compiler_v@7:
  00225	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00229	89 44 24 50	 mov	 DWORD PTR tv156[rsp], eax
$LN102@compiler_v@7:
  0022d	44 8b 44 24 50	 mov	 r8d, DWORD PTR tv156[rsp]
  00232	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
  00237	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0023f	e8 00 00 00 00	 call	 compiler_addop_i
  00244	85 c0		 test	 eax, eax
  00246	75 07		 jne	 SHORT $LN82@compiler_v@7
  00248	33 c0		 xor	 eax, eax
  0024a	e9 8e 08 00 00	 jmp	 $LN97@compiler_v@7
$LN82@compiler_v@7:

; 3325 :         for (i = 0; i < n; i++) {

  0024f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00257	eb 0a		 jmp	 SHORT $LN81@compiler_v@7
$LN80@compiler_v@7:
  00259	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0025d	ff c0		 inc	 eax
  0025f	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN81@compiler_v@7:
  00263	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00267	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0026b	7d 7e		 jge	 SHORT $LN79@compiler_v@7

; 3326 :             VISIT(c, expr,
; 3327 :                 (expr_ty)asdl_seq_GET(e->v.Dict.values, i));

  0026d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00275	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00279	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  0027e	48 8b 54 c8 08	 mov	 rdx, QWORD PTR [rax+rcx*8+8]
  00283	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0028b	e8 00 00 00 00	 call	 compiler_visit_expr
  00290	85 c0		 test	 eax, eax
  00292	75 07		 jne	 SHORT $LN78@compiler_v@7
  00294	33 c0		 xor	 eax, eax
  00296	e9 42 08 00 00	 jmp	 $LN97@compiler_v@7
$LN78@compiler_v@7:

; 3328 :             VISIT(c, expr,
; 3329 :                 (expr_ty)asdl_seq_GET(e->v.Dict.keys, i));

  0029b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  002a3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002a7	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  002ac	48 8b 54 c8 08	 mov	 rdx, QWORD PTR [rax+rcx*8+8]
  002b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002b9	e8 00 00 00 00	 call	 compiler_visit_expr
  002be	85 c0		 test	 eax, eax
  002c0	75 07		 jne	 SHORT $LN77@compiler_v@7
  002c2	33 c0		 xor	 eax, eax
  002c4	e9 14 08 00 00	 jmp	 $LN97@compiler_v@7
$LN77@compiler_v@7:

; 3330 :             ADDOP(c, STORE_MAP);

  002c9	ba 36 00 00 00	 mov	 edx, 54			; 00000036H
  002ce	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002d6	e8 00 00 00 00	 call	 compiler_addop
  002db	85 c0		 test	 eax, eax
  002dd	75 07		 jne	 SHORT $LN76@compiler_v@7
  002df	33 c0		 xor	 eax, eax
  002e1	e9 f7 07 00 00	 jmp	 $LN97@compiler_v@7
$LN76@compiler_v@7:

; 3331 :         }

  002e6	e9 6e ff ff ff	 jmp	 $LN80@compiler_v@7
$LN79@compiler_v@7:

; 3332 :         break;

  002eb	e9 e8 07 00 00	 jmp	 $LN94@compiler_v@7
$LN75@compiler_v@7:

; 3333 :     case Set_kind:
; 3334 :         n = asdl_seq_LEN(e->v.Set.elts);

  002f0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  002f8	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  002fd	75 0b		 jne	 SHORT $LN103@compiler_v@7
  002ff	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv189[rsp], 0
  00308	eb 14		 jmp	 SHORT $LN104@compiler_v@7
$LN103@compiler_v@7:
  0030a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00312	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00316	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00319	48 89 44 24 58	 mov	 QWORD PTR tv189[rsp], rax
$LN104@compiler_v@7:
  0031e	8b 44 24 58	 mov	 eax, DWORD PTR tv189[rsp]
  00322	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 3335 :         VISIT_SEQ(c, expr, e->v.Set.elts);

  00326	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0032e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00332	48 89 44 24 30	 mov	 QWORD PTR seq$24790[rsp], rax
  00337	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _i$24789[rsp], 0
  0033f	eb 0a		 jmp	 SHORT $LN74@compiler_v@7
$LN73@compiler_v@7:
  00341	8b 44 24 28	 mov	 eax, DWORD PTR _i$24789[rsp]
  00345	ff c0		 inc	 eax
  00347	89 44 24 28	 mov	 DWORD PTR _i$24789[rsp], eax
$LN74@compiler_v@7:
  0034b	48 83 7c 24 30
	00		 cmp	 QWORD PTR seq$24790[rsp], 0
  00351	75 0b		 jne	 SHORT $LN105@compiler_v@7
  00353	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv195[rsp], 0
  0035c	eb 0d		 jmp	 SHORT $LN106@compiler_v@7
$LN105@compiler_v@7:
  0035e	48 8b 44 24 30	 mov	 rax, QWORD PTR seq$24790[rsp]
  00363	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00366	48 89 44 24 60	 mov	 QWORD PTR tv195[rsp], rax
$LN106@compiler_v@7:
  0036b	48 63 44 24 28	 movsxd	 rax, DWORD PTR _i$24789[rsp]
  00370	48 3b 44 24 60	 cmp	 rax, QWORD PTR tv195[rsp]
  00375	7d 33		 jge	 SHORT $LN72@compiler_v@7
  00377	48 63 44 24 28	 movsxd	 rax, DWORD PTR _i$24789[rsp]
  0037c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR seq$24790[rsp]
  00381	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00386	48 89 44 24 38	 mov	 QWORD PTR elt$24795[rsp], rax
  0038b	48 8b 54 24 38	 mov	 rdx, QWORD PTR elt$24795[rsp]
  00390	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00398	e8 00 00 00 00	 call	 compiler_visit_expr
  0039d	85 c0		 test	 eax, eax
  0039f	75 07		 jne	 SHORT $LN71@compiler_v@7
  003a1	33 c0		 xor	 eax, eax
  003a3	e9 35 07 00 00	 jmp	 $LN97@compiler_v@7
$LN71@compiler_v@7:
  003a8	eb 97		 jmp	 SHORT $LN73@compiler_v@7
$LN72@compiler_v@7:

; 3336 :         ADDOP_I(c, BUILD_SET, n);

  003aa	44 8b 44 24 20	 mov	 r8d, DWORD PTR n$[rsp]
  003af	ba 68 00 00 00	 mov	 edx, 104		; 00000068H
  003b4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003bc	e8 00 00 00 00	 call	 compiler_addop_i
  003c1	85 c0		 test	 eax, eax
  003c3	75 07		 jne	 SHORT $LN70@compiler_v@7
  003c5	33 c0		 xor	 eax, eax
  003c7	e9 11 07 00 00	 jmp	 $LN97@compiler_v@7
$LN70@compiler_v@7:

; 3337 :         break;

  003cc	e9 07 07 00 00	 jmp	 $LN94@compiler_v@7
$LN69@compiler_v@7:

; 3338 :     case GeneratorExp_kind:
; 3339 :         return compiler_genexp(c, e);

  003d1	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  003d9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003e1	e8 00 00 00 00	 call	 compiler_genexp
  003e6	e9 f2 06 00 00	 jmp	 $LN97@compiler_v@7
$LN68@compiler_v@7:

; 3340 :     case ListComp_kind:
; 3341 :         return compiler_listcomp(c, e);

  003eb	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  003f3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003fb	e8 00 00 00 00	 call	 compiler_listcomp
  00400	e9 d8 06 00 00	 jmp	 $LN97@compiler_v@7
$LN67@compiler_v@7:

; 3342 :     case SetComp_kind:
; 3343 :         return compiler_setcomp(c, e);

  00405	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  0040d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00415	e8 00 00 00 00	 call	 compiler_setcomp
  0041a	e9 be 06 00 00	 jmp	 $LN97@compiler_v@7
$LN66@compiler_v@7:

; 3344 :     case DictComp_kind:
; 3345 :         return compiler_dictcomp(c, e);

  0041f	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  00427	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0042f	e8 00 00 00 00	 call	 compiler_dictcomp
  00434	e9 a4 06 00 00	 jmp	 $LN97@compiler_v@7
$LN65@compiler_v@7:

; 3346 :     case Yield_kind:
; 3347 :         if (c->u->u_ste->ste_type != FunctionBlock)

  00439	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00441	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00445	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00448	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  0044f	74 19		 je	 SHORT $LN64@compiler_v@7

; 3348 :             return compiler_error(c, "'yield' outside function");

  00451	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KHLOCEPE@?8yield?8?5outside?5function?$AA@
  00458	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00460	e8 00 00 00 00	 call	 compiler_error
  00465	e9 73 06 00 00	 jmp	 $LN97@compiler_v@7
$LN64@compiler_v@7:

; 3349 :         if (e->v.Yield.value) {

  0046a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00472	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00477	74 26		 je	 SHORT $LN63@compiler_v@7

; 3350 :             VISIT(c, expr, e->v.Yield.value);

  00479	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00481	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00485	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0048d	e8 00 00 00 00	 call	 compiler_visit_expr
  00492	85 c0		 test	 eax, eax
  00494	75 07		 jne	 SHORT $LN62@compiler_v@7
  00496	33 c0		 xor	 eax, eax
  00498	e9 40 06 00 00	 jmp	 $LN97@compiler_v@7
$LN62@compiler_v@7:

; 3351 :         }
; 3352 :         else {

  0049d	eb 34		 jmp	 SHORT $LN61@compiler_v@7
$LN63@compiler_v@7:

; 3353 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  0049f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  004a7	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  004ab	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  004b2	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  004b6	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  004bb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  004c3	e8 00 00 00 00	 call	 compiler_addop_o
  004c8	85 c0		 test	 eax, eax
  004ca	75 07		 jne	 SHORT $LN60@compiler_v@7
  004cc	33 c0		 xor	 eax, eax
  004ce	e9 0a 06 00 00	 jmp	 $LN97@compiler_v@7
$LN60@compiler_v@7:
$LN61@compiler_v@7:

; 3354 :         }
; 3355 :         ADDOP(c, YIELD_VALUE);

  004d3	ba 56 00 00 00	 mov	 edx, 86			; 00000056H
  004d8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  004e0	e8 00 00 00 00	 call	 compiler_addop
  004e5	85 c0		 test	 eax, eax
  004e7	75 07		 jne	 SHORT $LN59@compiler_v@7
  004e9	33 c0		 xor	 eax, eax
  004eb	e9 ed 05 00 00	 jmp	 $LN97@compiler_v@7
$LN59@compiler_v@7:

; 3356 :         break;

  004f0	e9 e3 05 00 00	 jmp	 $LN94@compiler_v@7
$LN58@compiler_v@7:

; 3357 :     case YieldFrom_kind:
; 3358 :         if (c->u->u_ste->ste_type != FunctionBlock)

  004f5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  004fd	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00501	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00504	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  0050b	74 19		 je	 SHORT $LN57@compiler_v@7

; 3359 :             return compiler_error(c, "'yield' outside function");

  0050d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KHLOCEPE@?8yield?8?5outside?5function?$AA@
  00514	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0051c	e8 00 00 00 00	 call	 compiler_error
  00521	e9 b7 05 00 00	 jmp	 $LN97@compiler_v@7
$LN57@compiler_v@7:

; 3360 :         VISIT(c, expr, e->v.YieldFrom.value);

  00526	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0052e	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00532	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0053a	e8 00 00 00 00	 call	 compiler_visit_expr
  0053f	85 c0		 test	 eax, eax
  00541	75 07		 jne	 SHORT $LN56@compiler_v@7
  00543	33 c0		 xor	 eax, eax
  00545	e9 93 05 00 00	 jmp	 $LN97@compiler_v@7
$LN56@compiler_v@7:

; 3361 :         ADDOP(c, GET_ITER);

  0054a	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  0054f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00557	e8 00 00 00 00	 call	 compiler_addop
  0055c	85 c0		 test	 eax, eax
  0055e	75 07		 jne	 SHORT $LN55@compiler_v@7
  00560	33 c0		 xor	 eax, eax
  00562	e9 76 05 00 00	 jmp	 $LN97@compiler_v@7
$LN55@compiler_v@7:

; 3362 :         ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00567	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0056f	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00573	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0057a	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  0057e	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00583	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0058b	e8 00 00 00 00	 call	 compiler_addop_o
  00590	85 c0		 test	 eax, eax
  00592	75 07		 jne	 SHORT $LN54@compiler_v@7
  00594	33 c0		 xor	 eax, eax
  00596	e9 42 05 00 00	 jmp	 $LN97@compiler_v@7
$LN54@compiler_v@7:

; 3363 :         ADDOP(c, YIELD_FROM);

  0059b	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  005a0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  005a8	e8 00 00 00 00	 call	 compiler_addop
  005ad	85 c0		 test	 eax, eax
  005af	75 07		 jne	 SHORT $LN53@compiler_v@7
  005b1	33 c0		 xor	 eax, eax
  005b3	e9 25 05 00 00	 jmp	 $LN97@compiler_v@7
$LN53@compiler_v@7:

; 3364 :         break;

  005b8	e9 1b 05 00 00	 jmp	 $LN94@compiler_v@7
$LN52@compiler_v@7:

; 3365 :     case Compare_kind:
; 3366 :         return compiler_compare(c, e);

  005bd	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  005c5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  005cd	e8 00 00 00 00	 call	 compiler_compare
  005d2	e9 06 05 00 00	 jmp	 $LN97@compiler_v@7
$LN51@compiler_v@7:

; 3367 :     case Call_kind:
; 3368 :         return compiler_call(c, e);

  005d7	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  005df	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  005e7	e8 00 00 00 00	 call	 compiler_call
  005ec	e9 ec 04 00 00	 jmp	 $LN97@compiler_v@7
$LN50@compiler_v@7:

; 3369 :     case Num_kind:
; 3370 :         ADDOP_O(c, LOAD_CONST, e->v.Num.n, consts);

  005f1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  005f9	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  005fd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  00605	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]
  00609	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  0060d	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00612	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0061a	e8 00 00 00 00	 call	 compiler_addop_o
  0061f	85 c0		 test	 eax, eax
  00621	75 07		 jne	 SHORT $LN49@compiler_v@7
  00623	33 c0		 xor	 eax, eax
  00625	e9 b3 04 00 00	 jmp	 $LN97@compiler_v@7
$LN49@compiler_v@7:

; 3371 :         break;

  0062a	e9 a9 04 00 00	 jmp	 $LN94@compiler_v@7
$LN48@compiler_v@7:

; 3372 :     case Str_kind:
; 3373 :         ADDOP_O(c, LOAD_CONST, e->v.Str.s, consts);

  0062f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00637	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0063b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  00643	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]
  00647	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  0064b	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00650	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00658	e8 00 00 00 00	 call	 compiler_addop_o
  0065d	85 c0		 test	 eax, eax
  0065f	75 07		 jne	 SHORT $LN47@compiler_v@7
  00661	33 c0		 xor	 eax, eax
  00663	e9 75 04 00 00	 jmp	 $LN97@compiler_v@7
$LN47@compiler_v@7:

; 3374 :         break;

  00668	e9 6b 04 00 00	 jmp	 $LN94@compiler_v@7
$LN46@compiler_v@7:

; 3375 :     case Bytes_kind:
; 3376 :         ADDOP_O(c, LOAD_CONST, e->v.Bytes.s, consts);

  0066d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00675	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00679	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  00681	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]
  00685	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00689	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0068e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00696	e8 00 00 00 00	 call	 compiler_addop_o
  0069b	85 c0		 test	 eax, eax
  0069d	75 07		 jne	 SHORT $LN45@compiler_v@7
  0069f	33 c0		 xor	 eax, eax
  006a1	e9 37 04 00 00	 jmp	 $LN97@compiler_v@7
$LN45@compiler_v@7:

; 3377 :         break;

  006a6	e9 2d 04 00 00	 jmp	 $LN94@compiler_v@7
$LN44@compiler_v@7:

; 3378 :     case Ellipsis_kind:
; 3379 :         ADDOP_O(c, LOAD_CONST, Py_Ellipsis, consts);

  006ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  006b3	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  006b7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_EllipsisObject
  006be	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  006c2	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  006c7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006cf	e8 00 00 00 00	 call	 compiler_addop_o
  006d4	85 c0		 test	 eax, eax
  006d6	75 07		 jne	 SHORT $LN43@compiler_v@7
  006d8	33 c0		 xor	 eax, eax
  006da	e9 fe 03 00 00	 jmp	 $LN97@compiler_v@7
$LN43@compiler_v@7:

; 3380 :         break;

  006df	e9 f4 03 00 00	 jmp	 $LN94@compiler_v@7
$LN42@compiler_v@7:

; 3381 :     /* The following exprs can be assignment targets. */
; 3382 :     case Attribute_kind:
; 3383 :         if (e->v.Attribute.ctx != AugStore)

  006e4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  006ec	83 78 18 05	 cmp	 DWORD PTR [rax+24], 5
  006f0	74 24		 je	 SHORT $LN41@compiler_v@7

; 3384 :             VISIT(c, expr, e->v.Attribute.value);

  006f2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  006fa	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  006fe	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00706	e8 00 00 00 00	 call	 compiler_visit_expr
  0070b	85 c0		 test	 eax, eax
  0070d	75 07		 jne	 SHORT $LN40@compiler_v@7
  0070f	33 c0		 xor	 eax, eax
  00711	e9 c7 03 00 00	 jmp	 $LN97@compiler_v@7
$LN40@compiler_v@7:
$LN41@compiler_v@7:

; 3385 :         switch (e->v.Attribute.ctx) {

  00716	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0071e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00721	89 44 24 68	 mov	 DWORD PTR tv325[rsp], eax
  00725	83 7c 24 68 01	 cmp	 DWORD PTR tv325[rsp], 1
  0072a	74 46		 je	 SHORT $LN35@compiler_v@7
  0072c	83 7c 24 68 02	 cmp	 DWORD PTR tv325[rsp], 2
  00731	0f 84 96 00 00
	00		 je	 $LN31@compiler_v@7
  00737	83 7c 24 68 03	 cmp	 DWORD PTR tv325[rsp], 3
  0073c	0f 84 c6 00 00
	00		 je	 $LN29@compiler_v@7
  00742	83 7c 24 68 04	 cmp	 DWORD PTR tv325[rsp], 4
  00747	74 0c		 je	 SHORT $LN37@compiler_v@7
  00749	83 7c 24 68 05	 cmp	 DWORD PTR tv325[rsp], 5
  0074e	74 60		 je	 SHORT $LN33@compiler_v@7
  00750	e9 ee 00 00 00	 jmp	 $LN27@compiler_v@7
$LN37@compiler_v@7:

; 3386 :         case AugLoad:
; 3387 :             ADDOP(c, DUP_TOP);

  00755	ba 04 00 00 00	 mov	 edx, 4
  0075a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00762	e8 00 00 00 00	 call	 compiler_addop
  00767	85 c0		 test	 eax, eax
  00769	75 07		 jne	 SHORT $LN36@compiler_v@7
  0076b	33 c0		 xor	 eax, eax
  0076d	e9 6b 03 00 00	 jmp	 $LN97@compiler_v@7
$LN36@compiler_v@7:
$LN35@compiler_v@7:

; 3388 :             /* Fall through to load */
; 3389 :         case Load:
; 3390 :             ADDOP_NAME(c, LOAD_ATTR, e->v.Attribute.attr, names);

  00772	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0077a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0077e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  00786	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  0078a	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  0078e	ba 6a 00 00 00	 mov	 edx, 106		; 0000006aH
  00793	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0079b	e8 00 00 00 00	 call	 compiler_addop_name
  007a0	85 c0		 test	 eax, eax
  007a2	75 07		 jne	 SHORT $LN34@compiler_v@7
  007a4	33 c0		 xor	 eax, eax
  007a6	e9 32 03 00 00	 jmp	 $LN97@compiler_v@7
$LN34@compiler_v@7:

; 3391 :             break;

  007ab	e9 ad 00 00 00	 jmp	 $LN38@compiler_v@7
$LN33@compiler_v@7:

; 3392 :         case AugStore:
; 3393 :             ADDOP(c, ROT_TWO);

  007b0	ba 02 00 00 00	 mov	 edx, 2
  007b5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007bd	e8 00 00 00 00	 call	 compiler_addop
  007c2	85 c0		 test	 eax, eax
  007c4	75 07		 jne	 SHORT $LN32@compiler_v@7
  007c6	33 c0		 xor	 eax, eax
  007c8	e9 10 03 00 00	 jmp	 $LN97@compiler_v@7
$LN32@compiler_v@7:
$LN31@compiler_v@7:

; 3394 :             /* Fall through to save */
; 3395 :         case Store:
; 3396 :             ADDOP_NAME(c, STORE_ATTR, e->v.Attribute.attr, names);

  007cd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  007d5	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  007d9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  007e1	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  007e5	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  007e9	ba 5f 00 00 00	 mov	 edx, 95			; 0000005fH
  007ee	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007f6	e8 00 00 00 00	 call	 compiler_addop_name
  007fb	85 c0		 test	 eax, eax
  007fd	75 07		 jne	 SHORT $LN30@compiler_v@7
  007ff	33 c0		 xor	 eax, eax
  00801	e9 d7 02 00 00	 jmp	 $LN97@compiler_v@7
$LN30@compiler_v@7:

; 3397 :             break;

  00806	eb 55		 jmp	 SHORT $LN38@compiler_v@7
$LN29@compiler_v@7:

; 3398 :         case Del:
; 3399 :             ADDOP_NAME(c, DELETE_ATTR, e->v.Attribute.attr, names);

  00808	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00810	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00814	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  0081c	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  00820	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  00824	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00829	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00831	e8 00 00 00 00	 call	 compiler_addop_name
  00836	85 c0		 test	 eax, eax
  00838	75 07		 jne	 SHORT $LN28@compiler_v@7
  0083a	33 c0		 xor	 eax, eax
  0083c	e9 9c 02 00 00	 jmp	 $LN97@compiler_v@7
$LN28@compiler_v@7:

; 3400 :             break;

  00841	eb 1a		 jmp	 SHORT $LN38@compiler_v@7
$LN27@compiler_v@7:

; 3401 :         case Param:
; 3402 :         default:
; 3403 :             PyErr_SetString(PyExc_SystemError,
; 3404 :                             "param invalid in attribute expression");

  00843	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@COAMAJAK@param?5invalid?5in?5attribute?5expre@
  0084a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00851	e8 00 00 00 00	 call	 PyErr_SetString

; 3405 :             return 0;

  00856	33 c0		 xor	 eax, eax
  00858	e9 80 02 00 00	 jmp	 $LN97@compiler_v@7
$LN38@compiler_v@7:

; 3406 :         }
; 3407 :         break;

  0085d	e9 76 02 00 00	 jmp	 $LN94@compiler_v@7
$LN26@compiler_v@7:

; 3408 :     case Subscript_kind:
; 3409 :         switch (e->v.Subscript.ctx) {

  00862	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0086a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0086d	89 44 24 6c	 mov	 DWORD PTR tv369[rsp], eax
  00871	83 7c 24 6c 01	 cmp	 DWORD PTR tv369[rsp], 1
  00876	0f 84 80 00 00
	00		 je	 $LN20@compiler_v@7
  0087c	83 7c 24 6c 02	 cmp	 DWORD PTR tv369[rsp], 2
  00881	0f 84 f7 00 00
	00		 je	 $LN15@compiler_v@7
  00887	83 7c 24 6c 03	 cmp	 DWORD PTR tv369[rsp], 3
  0088c	0f 84 3c 01 00
	00		 je	 $LN12@compiler_v@7
  00892	83 7c 24 6c 04	 cmp	 DWORD PTR tv369[rsp], 4
  00897	74 10		 je	 SHORT $LN23@compiler_v@7
  00899	83 7c 24 6c 05	 cmp	 DWORD PTR tv369[rsp], 5
  0089e	0f 84 ab 00 00
	00		 je	 $LN17@compiler_v@7
  008a4	e9 75 01 00 00	 jmp	 $LN9@compiler_v@7
$LN23@compiler_v@7:

; 3410 :         case AugLoad:
; 3411 :             VISIT(c, expr, e->v.Subscript.value);

  008a9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  008b1	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  008b5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  008bd	e8 00 00 00 00	 call	 compiler_visit_expr
  008c2	85 c0		 test	 eax, eax
  008c4	75 07		 jne	 SHORT $LN22@compiler_v@7
  008c6	33 c0		 xor	 eax, eax
  008c8	e9 10 02 00 00	 jmp	 $LN97@compiler_v@7
$LN22@compiler_v@7:

; 3412 :             VISIT_SLICE(c, e->v.Subscript.slice, AugLoad);

  008cd	41 b8 04 00 00
	00		 mov	 r8d, 4
  008d3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  008db	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  008df	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  008e7	e8 00 00 00 00	 call	 compiler_visit_slice
  008ec	85 c0		 test	 eax, eax
  008ee	75 07		 jne	 SHORT $LN21@compiler_v@7
  008f0	33 c0		 xor	 eax, eax
  008f2	e9 e6 01 00 00	 jmp	 $LN97@compiler_v@7
$LN21@compiler_v@7:

; 3413 :             break;

  008f7	e9 3c 01 00 00	 jmp	 $LN24@compiler_v@7
$LN20@compiler_v@7:

; 3414 :         case Load:
; 3415 :             VISIT(c, expr, e->v.Subscript.value);

  008fc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00904	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00908	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00910	e8 00 00 00 00	 call	 compiler_visit_expr
  00915	85 c0		 test	 eax, eax
  00917	75 07		 jne	 SHORT $LN19@compiler_v@7
  00919	33 c0		 xor	 eax, eax
  0091b	e9 bd 01 00 00	 jmp	 $LN97@compiler_v@7
$LN19@compiler_v@7:

; 3416 :             VISIT_SLICE(c, e->v.Subscript.slice, Load);

  00920	41 b8 01 00 00
	00		 mov	 r8d, 1
  00926	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0092e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00932	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0093a	e8 00 00 00 00	 call	 compiler_visit_slice
  0093f	85 c0		 test	 eax, eax
  00941	75 07		 jne	 SHORT $LN18@compiler_v@7
  00943	33 c0		 xor	 eax, eax
  00945	e9 93 01 00 00	 jmp	 $LN97@compiler_v@7
$LN18@compiler_v@7:

; 3417 :             break;

  0094a	e9 e9 00 00 00	 jmp	 $LN24@compiler_v@7
$LN17@compiler_v@7:

; 3418 :         case AugStore:
; 3419 :             VISIT_SLICE(c, e->v.Subscript.slice, AugStore);

  0094f	41 b8 05 00 00
	00		 mov	 r8d, 5
  00955	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0095d	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00961	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00969	e8 00 00 00 00	 call	 compiler_visit_slice
  0096e	85 c0		 test	 eax, eax
  00970	75 07		 jne	 SHORT $LN16@compiler_v@7
  00972	33 c0		 xor	 eax, eax
  00974	e9 64 01 00 00	 jmp	 $LN97@compiler_v@7
$LN16@compiler_v@7:

; 3420 :             break;

  00979	e9 ba 00 00 00	 jmp	 $LN24@compiler_v@7
$LN15@compiler_v@7:

; 3421 :         case Store:
; 3422 :             VISIT(c, expr, e->v.Subscript.value);

  0097e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00986	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0098a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00992	e8 00 00 00 00	 call	 compiler_visit_expr
  00997	85 c0		 test	 eax, eax
  00999	75 07		 jne	 SHORT $LN14@compiler_v@7
  0099b	33 c0		 xor	 eax, eax
  0099d	e9 3b 01 00 00	 jmp	 $LN97@compiler_v@7
$LN14@compiler_v@7:

; 3423 :             VISIT_SLICE(c, e->v.Subscript.slice, Store);

  009a2	41 b8 02 00 00
	00		 mov	 r8d, 2
  009a8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  009b0	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  009b4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  009bc	e8 00 00 00 00	 call	 compiler_visit_slice
  009c1	85 c0		 test	 eax, eax
  009c3	75 07		 jne	 SHORT $LN13@compiler_v@7
  009c5	33 c0		 xor	 eax, eax
  009c7	e9 11 01 00 00	 jmp	 $LN97@compiler_v@7
$LN13@compiler_v@7:

; 3424 :             break;

  009cc	eb 6a		 jmp	 SHORT $LN24@compiler_v@7
$LN12@compiler_v@7:

; 3425 :         case Del:
; 3426 :             VISIT(c, expr, e->v.Subscript.value);

  009ce	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  009d6	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  009da	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  009e2	e8 00 00 00 00	 call	 compiler_visit_expr
  009e7	85 c0		 test	 eax, eax
  009e9	75 07		 jne	 SHORT $LN11@compiler_v@7
  009eb	33 c0		 xor	 eax, eax
  009ed	e9 eb 00 00 00	 jmp	 $LN97@compiler_v@7
$LN11@compiler_v@7:

; 3427 :             VISIT_SLICE(c, e->v.Subscript.slice, Del);

  009f2	41 b8 03 00 00
	00		 mov	 r8d, 3
  009f8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00a00	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00a04	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00a0c	e8 00 00 00 00	 call	 compiler_visit_slice
  00a11	85 c0		 test	 eax, eax
  00a13	75 07		 jne	 SHORT $LN10@compiler_v@7
  00a15	33 c0		 xor	 eax, eax
  00a17	e9 c1 00 00 00	 jmp	 $LN97@compiler_v@7
$LN10@compiler_v@7:

; 3428 :             break;

  00a1c	eb 1a		 jmp	 SHORT $LN24@compiler_v@7
$LN9@compiler_v@7:

; 3429 :         case Param:
; 3430 :         default:
; 3431 :             PyErr_SetString(PyExc_SystemError,
; 3432 :                 "param invalid in subscript expression");

  00a1e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@CACGIAAN@param?5invalid?5in?5subscript?5expre@
  00a25	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00a2c	e8 00 00 00 00	 call	 PyErr_SetString

; 3433 :             return 0;

  00a31	33 c0		 xor	 eax, eax
  00a33	e9 a5 00 00 00	 jmp	 $LN97@compiler_v@7
$LN24@compiler_v@7:

; 3434 :         }
; 3435 :         break;

  00a38	e9 9b 00 00 00	 jmp	 $LN94@compiler_v@7
$LN8@compiler_v@7:

; 3436 :     case Starred_kind:
; 3437 :         switch (e->v.Starred.ctx) {

  00a3d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00a45	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00a48	89 44 24 70	 mov	 DWORD PTR tv428[rsp], eax
  00a4c	83 7c 24 70 02	 cmp	 DWORD PTR tv428[rsp], 2
  00a51	74 02		 je	 SHORT $LN5@compiler_v@7
  00a53	eb 16		 jmp	 SHORT $LN4@compiler_v@7
$LN5@compiler_v@7:

; 3438 :         case Store:
; 3439 :             /* In all legitimate cases, the Starred node was already replaced
; 3440 :              * by compiler_list/compiler_tuple. XXX: is that okay? */
; 3441 :             return compiler_error(c,
; 3442 :                 "starred assignment target must be in a list or tuple");

  00a55	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@IPNNMMFP@starred?5assignment?5target?5must?5b@
  00a5c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00a64	e8 00 00 00 00	 call	 compiler_error
  00a69	eb 72		 jmp	 SHORT $LN97@compiler_v@7
$LN4@compiler_v@7:

; 3443 :         default:
; 3444 :             return compiler_error(c,
; 3445 :                 "can use starred expression only as assignment target");

  00a6b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@NHBPOLCF@can?5use?5starred?5expression?5only?5@
  00a72	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00a7a	e8 00 00 00 00	 call	 compiler_error
  00a7f	eb 5c		 jmp	 SHORT $LN97@compiler_v@7

; 3446 :         }
; 3447 :         break;

  00a81	eb 55		 jmp	 SHORT $LN94@compiler_v@7
$LN3@compiler_v@7:

; 3448 :     case Name_kind:
; 3449 :         return compiler_nameop(c, e->v.Name.id, e->v.Name.ctx);

  00a83	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00a8b	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00a8f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00a97	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00a9b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00aa3	e8 00 00 00 00	 call	 compiler_nameop
  00aa8	eb 33		 jmp	 SHORT $LN97@compiler_v@7
$LN2@compiler_v@7:

; 3450 :     /* child nodes of List and Tuple will have expr_context set */
; 3451 :     case List_kind:
; 3452 :         return compiler_list(c, e);

  00aaa	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  00ab2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00aba	e8 00 00 00 00	 call	 compiler_list
  00abf	eb 1c		 jmp	 SHORT $LN97@compiler_v@7
$LN1@compiler_v@7:

; 3453 :     case Tuple_kind:
; 3454 :         return compiler_tuple(c, e);

  00ac1	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  00ac9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00ad1	e8 00 00 00 00	 call	 compiler_tuple
  00ad6	eb 05		 jmp	 SHORT $LN97@compiler_v@7
$LN94@compiler_v@7:

; 3455 :     }
; 3456 :     return 1;

  00ad8	b8 01 00 00 00	 mov	 eax, 1
$LN97@compiler_v@7:

; 3457 : }

  00add	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00ae4	c3		 ret	 0
  00ae5	0f 1f 00	 npad	 3
$LN107@compiler_v@7:
  00ae8	00 00 00 00	 DD	 $LN93@compiler_v@7
  00aec	00 00 00 00	 DD	 $LN92@compiler_v@7
  00af0	00 00 00 00	 DD	 $LN88@compiler_v@7
  00af4	00 00 00 00	 DD	 $LN85@compiler_v@7
  00af8	00 00 00 00	 DD	 $LN84@compiler_v@7
  00afc	00 00 00 00	 DD	 $LN83@compiler_v@7
  00b00	00 00 00 00	 DD	 $LN75@compiler_v@7
  00b04	00 00 00 00	 DD	 $LN68@compiler_v@7
  00b08	00 00 00 00	 DD	 $LN67@compiler_v@7
  00b0c	00 00 00 00	 DD	 $LN66@compiler_v@7
  00b10	00 00 00 00	 DD	 $LN69@compiler_v@7
  00b14	00 00 00 00	 DD	 $LN65@compiler_v@7
  00b18	00 00 00 00	 DD	 $LN58@compiler_v@7
  00b1c	00 00 00 00	 DD	 $LN52@compiler_v@7
  00b20	00 00 00 00	 DD	 $LN51@compiler_v@7
  00b24	00 00 00 00	 DD	 $LN50@compiler_v@7
  00b28	00 00 00 00	 DD	 $LN48@compiler_v@7
  00b2c	00 00 00 00	 DD	 $LN46@compiler_v@7
  00b30	00 00 00 00	 DD	 $LN44@compiler_v@7
  00b34	00 00 00 00	 DD	 $LN42@compiler_v@7
  00b38	00 00 00 00	 DD	 $LN26@compiler_v@7
  00b3c	00 00 00 00	 DD	 $LN8@compiler_v@7
  00b40	00 00 00 00	 DD	 $LN3@compiler_v@7
  00b44	00 00 00 00	 DD	 $LN2@compiler_v@7
  00b48	00 00 00 00	 DD	 $LN1@compiler_v@7
compiler_visit_expr ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@DKFBKIFA@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAf?$AAE?$AAx?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_ifexp DD imagerel compiler_ifexp
	DD	imagerel compiler_ifexp+301
	DD	imagerel $unwind$compiler_ifexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_ifexp DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1CM@DKFBKIFA@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAf?$AAE?$AAx?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@DKFBKIFA@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAf?$AAE?$AAx?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'f', 00H, 'E'
	DB	00H, 'x', 00H, 'p', 00H, '_', 00H, 'k', 00H, 'i', 00H, 'n', 00H
	DB	'd', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_ifexp
_TEXT	SEGMENT
next$ = 32
end$ = 40
c$ = 64
e$ = 72
compiler_ifexp PROC					; COMDAT

; 1764 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1765 :     basicblock *end, *next;
; 1766 : 
; 1767 :     assert(e->kind == IfExp_kind);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  00013	83 38 05	 cmp	 DWORD PTR [rax], 5
  00016	74 1c		 je	 SHORT $LN10@compiler_i@6
  00018	41 b8 e7 06 00
	00		 mov	 r8d, 1767		; 000006e7H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DKFBKIFA@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAf?$AAE?$AAx?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00032	33 c0		 xor	 eax, eax
$LN10@compiler_i@6:

; 1768 :     end = compiler_new_block(c);

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00039	e8 00 00 00 00	 call	 compiler_new_block
  0003e	48 89 44 24 28	 mov	 QWORD PTR end$[rsp], rax

; 1769 :     if (end == NULL)

  00043	48 83 7c 24 28
	00		 cmp	 QWORD PTR end$[rsp], 0
  00049	75 07		 jne	 SHORT $LN7@compiler_i@6

; 1770 :         return 0;

  0004b	33 c0		 xor	 eax, eax
  0004d	e9 d6 00 00 00	 jmp	 $LN8@compiler_i@6
$LN7@compiler_i@6:

; 1771 :     next = compiler_new_block(c);

  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00057	e8 00 00 00 00	 call	 compiler_new_block
  0005c	48 89 44 24 20	 mov	 QWORD PTR next$[rsp], rax

; 1772 :     if (next == NULL)

  00061	48 83 7c 24 20
	00		 cmp	 QWORD PTR next$[rsp], 0
  00067	75 07		 jne	 SHORT $LN6@compiler_i@6

; 1773 :         return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 b8 00 00 00	 jmp	 $LN8@compiler_i@6
$LN6@compiler_i@6:

; 1774 :     VISIT(c, expr, e->v.IfExp.test);

  00070	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  00075	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0007e	e8 00 00 00 00	 call	 compiler_visit_expr
  00083	85 c0		 test	 eax, eax
  00085	75 07		 jne	 SHORT $LN5@compiler_i@6
  00087	33 c0		 xor	 eax, eax
  00089	e9 9a 00 00 00	 jmp	 $LN8@compiler_i@6
$LN5@compiler_i@6:

; 1775 :     ADDOP_JABS(c, POP_JUMP_IF_FALSE, next);

  0008e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00094	4c 8b 44 24 20	 mov	 r8, QWORD PTR next$[rsp]
  00099	ba 72 00 00 00	 mov	 edx, 114		; 00000072H
  0009e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000a3	e8 00 00 00 00	 call	 compiler_addop_j
  000a8	85 c0		 test	 eax, eax
  000aa	75 04		 jne	 SHORT $LN4@compiler_i@6
  000ac	33 c0		 xor	 eax, eax
  000ae	eb 78		 jmp	 SHORT $LN8@compiler_i@6
$LN4@compiler_i@6:

; 1776 :     VISIT(c, expr, e->v.IfExp.body);

  000b0	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  000b5	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000be	e8 00 00 00 00	 call	 compiler_visit_expr
  000c3	85 c0		 test	 eax, eax
  000c5	75 04		 jne	 SHORT $LN3@compiler_i@6
  000c7	33 c0		 xor	 eax, eax
  000c9	eb 5d		 jmp	 SHORT $LN8@compiler_i@6
$LN3@compiler_i@6:

; 1777 :     ADDOP_JREL(c, JUMP_FORWARD, end);

  000cb	45 33 c9	 xor	 r9d, r9d
  000ce	4c 8b 44 24 28	 mov	 r8, QWORD PTR end$[rsp]
  000d3	ba 6e 00 00 00	 mov	 edx, 110		; 0000006eH
  000d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000dd	e8 00 00 00 00	 call	 compiler_addop_j
  000e2	85 c0		 test	 eax, eax
  000e4	75 04		 jne	 SHORT $LN2@compiler_i@6
  000e6	33 c0		 xor	 eax, eax
  000e8	eb 3e		 jmp	 SHORT $LN8@compiler_i@6
$LN2@compiler_i@6:

; 1778 :     compiler_use_next_block(c, next);

  000ea	48 8b 54 24 20	 mov	 rdx, QWORD PTR next$[rsp]
  000ef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000f4	e8 00 00 00 00	 call	 compiler_use_next_block

; 1779 :     VISIT(c, expr, e->v.IfExp.orelse);

  000f9	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  000fe	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00102	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00107	e8 00 00 00 00	 call	 compiler_visit_expr
  0010c	85 c0		 test	 eax, eax
  0010e	75 04		 jne	 SHORT $LN1@compiler_i@6
  00110	33 c0		 xor	 eax, eax
  00112	eb 14		 jmp	 SHORT $LN8@compiler_i@6
$LN1@compiler_i@6:

; 1780 :     compiler_use_next_block(c, end);

  00114	48 8b 54 24 28	 mov	 rdx, QWORD PTR end$[rsp]
  00119	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0011e	e8 00 00 00 00	 call	 compiler_use_next_block

; 1781 :     return 1;

  00123	b8 01 00 00 00	 mov	 eax, 1
$LN8@compiler_i@6:

; 1782 : }

  00128	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012c	c3		 ret	 0
compiler_ifexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_08JAHKMIKF@?$DMlambda?$DO?$AA@		; `string'
PUBLIC	??_C@_1CO@KNGGCIJ@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAL?$AAa?$AAm?$AAb?$AAd?$AAa?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
_BSS	SEGMENT
?name@?1??compiler_lambda@@9@9 DQ 01H DUP (?)		; `compiler_lambda'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_lambda DD imagerel compiler_lambda
	DD	imagerel compiler_lambda+946
	DD	imagerel $unwind$compiler_lambda
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_lambda DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_08JAHKMIKF@?$DMlambda?$DO?$AA@
CONST	SEGMENT
??_C@_08JAHKMIKF@?$DMlambda?$DO?$AA@ DB '<lambda>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@KNGGCIJ@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAL?$AAa?$AAm?$AAb?$AAd?$AAa?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@KNGGCIJ@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAL?$AAa?$AAm?$AAb?$AAd?$AAa?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'L', 00H, 'a', 00H, 'm'
	DB	00H, 'b', 00H, 'd', 00H, 'a', 00H, '_', 00H, 'k', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_lambda
_TEXT	SEGMENT
args$ = 48
kw_default_count$ = 56
arglength$ = 60
co$ = 64
qualname$ = 72
res$23399 = 80
_i$23402 = 84
seq$23403 = 88
elt$23408 = 96
tv89 = 104
tv150 = 112
tv158 = 120
tv194 = 128
c$ = 160
e$ = 168
compiler_lambda PROC					; COMDAT

; 1786 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1787 :     PyCodeObject *co;
; 1788 :     PyObject *qualname;
; 1789 :     static identifier name;
; 1790 :     int kw_default_count = 0, arglength;

  00011	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR kw_default_count$[rsp], 0

; 1791 :     arguments_ty args = e->v.Lambda.args;

  00019	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00021	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00025	48 89 44 24 30	 mov	 QWORD PTR args$[rsp], rax

; 1792 :     assert(e->kind == Lambda_kind);

  0002a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00032	83 38 04	 cmp	 DWORD PTR [rax], 4
  00035	74 1c		 je	 SHORT $LN21@compiler_l@2
  00037	41 b8 00 07 00
	00		 mov	 r8d, 1792		; 00000700H
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@KNGGCIJ@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAL?$AAa?$AAm?$AAb?$AAd?$AAa?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00051	33 c0		 xor	 eax, eax
$LN21@compiler_l@2:

; 1793 : 
; 1794 :     if (!name) {

  00053	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name@?1??compiler_lambda@@9@9, 0
  0005b	75 24		 jne	 SHORT $LN18@compiler_l@2

; 1795 :         name = PyUnicode_InternFromString("<lambda>");

  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08JAHKMIKF@?$DMlambda?$DO?$AA@
  00064	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00069	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name@?1??compiler_lambda@@9@9, rax

; 1796 :         if (!name)

  00070	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name@?1??compiler_lambda@@9@9, 0
  00078	75 07		 jne	 SHORT $LN17@compiler_l@2

; 1797 :             return 0;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 29 03 00 00	 jmp	 $LN19@compiler_l@2
$LN17@compiler_l@2:
$LN18@compiler_l@2:

; 1798 :     }
; 1799 : 
; 1800 :     if (args->kwonlyargs) {

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  00086	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0008b	74 39		 je	 SHORT $LN16@compiler_l@2

; 1801 :         int res = compiler_visit_kwonlydefaults(c, args->kwonlyargs,
; 1802 :                                                 args->kw_defaults);

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  00092	4c 8b 40 38	 mov	 r8, QWORD PTR [rax+56]
  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  0009b	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  0009f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000a7	e8 00 00 00 00	 call	 compiler_visit_kwonlydefaults
  000ac	89 44 24 50	 mov	 DWORD PTR res$23399[rsp], eax

; 1803 :         if (res < 0) return 0;

  000b0	83 7c 24 50 00	 cmp	 DWORD PTR res$23399[rsp], 0
  000b5	7d 07		 jge	 SHORT $LN15@compiler_l@2
  000b7	33 c0		 xor	 eax, eax
  000b9	e9 ec 02 00 00	 jmp	 $LN19@compiler_l@2
$LN15@compiler_l@2:

; 1804 :         kw_default_count = res;

  000be	8b 44 24 50	 mov	 eax, DWORD PTR res$23399[rsp]
  000c2	89 44 24 38	 mov	 DWORD PTR kw_default_count$[rsp], eax
$LN16@compiler_l@2:

; 1805 :     }
; 1806 :     if (args->defaults)

  000c6	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  000cb	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000d0	0f 84 81 00 00
	00		 je	 $LN14@compiler_l@2

; 1807 :         VISIT_SEQ(c, expr, args->defaults);

  000d6	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  000db	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000df	48 89 44 24 58	 mov	 QWORD PTR seq$23403[rsp], rax
  000e4	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR _i$23402[rsp], 0
  000ec	eb 0a		 jmp	 SHORT $LN13@compiler_l@2
$LN12@compiler_l@2:
  000ee	8b 44 24 54	 mov	 eax, DWORD PTR _i$23402[rsp]
  000f2	ff c0		 inc	 eax
  000f4	89 44 24 54	 mov	 DWORD PTR _i$23402[rsp], eax
$LN13@compiler_l@2:
  000f8	48 83 7c 24 58
	00		 cmp	 QWORD PTR seq$23403[rsp], 0
  000fe	75 0b		 jne	 SHORT $LN22@compiler_l@2
  00100	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv89[rsp], 0
  00109	eb 0d		 jmp	 SHORT $LN23@compiler_l@2
$LN22@compiler_l@2:
  0010b	48 8b 44 24 58	 mov	 rax, QWORD PTR seq$23403[rsp]
  00110	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00113	48 89 44 24 68	 mov	 QWORD PTR tv89[rsp], rax
$LN23@compiler_l@2:
  00118	48 63 44 24 54	 movsxd	 rax, DWORD PTR _i$23402[rsp]
  0011d	48 3b 44 24 68	 cmp	 rax, QWORD PTR tv89[rsp]
  00122	7d 33		 jge	 SHORT $LN11@compiler_l@2
  00124	48 63 44 24 54	 movsxd	 rax, DWORD PTR _i$23402[rsp]
  00129	48 8b 4c 24 58	 mov	 rcx, QWORD PTR seq$23403[rsp]
  0012e	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00133	48 89 44 24 60	 mov	 QWORD PTR elt$23408[rsp], rax
  00138	48 8b 54 24 60	 mov	 rdx, QWORD PTR elt$23408[rsp]
  0013d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00145	e8 00 00 00 00	 call	 compiler_visit_expr
  0014a	85 c0		 test	 eax, eax
  0014c	75 07		 jne	 SHORT $LN10@compiler_l@2
  0014e	33 c0		 xor	 eax, eax
  00150	e9 55 02 00 00	 jmp	 $LN19@compiler_l@2
$LN10@compiler_l@2:
  00155	eb 97		 jmp	 SHORT $LN12@compiler_l@2
$LN11@compiler_l@2:
$LN14@compiler_l@2:

; 1808 :     if (!compiler_enter_scope(c, name, COMPILER_SCOPE_FUNCTION,
; 1809 :                               (void *)e, e->lineno))

  00157	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0015f	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00162	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00166	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR e$[rsp]
  0016e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00174	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?name@?1??compiler_lambda@@9@9
  0017b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00183	e8 00 00 00 00	 call	 compiler_enter_scope
  00188	85 c0		 test	 eax, eax
  0018a	75 07		 jne	 SHORT $LN9@compiler_l@2

; 1810 :         return 0;

  0018c	33 c0		 xor	 eax, eax
  0018e	e9 17 02 00 00	 jmp	 $LN19@compiler_l@2
$LN9@compiler_l@2:

; 1811 : 
; 1812 :     /* Make None the first constant, so the lambda can't have a
; 1813 :        docstring. */
; 1814 :     if (compiler_add_o(c, c->u->u_consts, Py_None) < 0)

  00193	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0019b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0019f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  001a6	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  001aa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001b2	e8 00 00 00 00	 call	 compiler_add_o
  001b7	85 c0		 test	 eax, eax
  001b9	7d 07		 jge	 SHORT $LN8@compiler_l@2

; 1815 :         return 0;

  001bb	33 c0		 xor	 eax, eax
  001bd	e9 e8 01 00 00	 jmp	 $LN19@compiler_l@2
$LN8@compiler_l@2:

; 1816 : 
; 1817 :     c->u->u_argcount = asdl_seq_LEN(args->args);

  001c2	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  001c7	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001cb	75 0b		 jne	 SHORT $LN24@compiler_l@2
  001cd	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv150[rsp], 0
  001d6	eb 10		 jmp	 SHORT $LN25@compiler_l@2
$LN24@compiler_l@2:
  001d8	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  001dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e3	48 89 44 24 70	 mov	 QWORD PTR tv150[rsp], rax
$LN25@compiler_l@2:
  001e8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  001f0	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001f4	8b 4c 24 70	 mov	 ecx, DWORD PTR tv150[rsp]
  001f8	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 1818 :     c->u->u_kwonlyargcount = asdl_seq_LEN(args->kwonlyargs);

  001fb	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  00200	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00205	75 0b		 jne	 SHORT $LN26@compiler_l@2
  00207	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv158[rsp], 0
  00210	eb 11		 jmp	 SHORT $LN27@compiler_l@2
$LN26@compiler_l@2:
  00212	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  00217	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0021b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0021e	48 89 44 24 78	 mov	 QWORD PTR tv158[rsp], rax
$LN27@compiler_l@2:
  00223	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0022b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0022f	8b 4c 24 78	 mov	 ecx, DWORD PTR tv158[rsp]
  00233	89 48 54	 mov	 DWORD PTR [rax+84], ecx

; 1819 :     VISIT_IN_SCOPE(c, expr, e->v.Lambda.body);

  00236	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0023e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00242	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0024a	e8 00 00 00 00	 call	 compiler_visit_expr
  0024f	85 c0		 test	 eax, eax
  00251	75 14		 jne	 SHORT $LN7@compiler_l@2
  00253	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0025b	e8 00 00 00 00	 call	 compiler_exit_scope
  00260	33 c0		 xor	 eax, eax
  00262	e9 43 01 00 00	 jmp	 $LN19@compiler_l@2
$LN7@compiler_l@2:

; 1820 :     if (c->u->u_ste->ste_generator) {

  00267	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0026f	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00273	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00276	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0027c	c1 e8 02	 shr	 eax, 2
  0027f	83 e0 01	 and	 eax, 1
  00282	85 c0		 test	 eax, eax
  00284	74 2c		 je	 SHORT $LN6@compiler_l@2

; 1821 :         ADDOP_IN_SCOPE(c, POP_TOP);

  00286	ba 01 00 00 00	 mov	 edx, 1
  0028b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00293	e8 00 00 00 00	 call	 compiler_addop
  00298	85 c0		 test	 eax, eax
  0029a	75 14		 jne	 SHORT $LN5@compiler_l@2
  0029c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002a4	e8 00 00 00 00	 call	 compiler_exit_scope
  002a9	33 c0		 xor	 eax, eax
  002ab	e9 fa 00 00 00	 jmp	 $LN19@compiler_l@2
$LN5@compiler_l@2:

; 1822 :     }
; 1823 :     else {

  002b0	eb 2a		 jmp	 SHORT $LN4@compiler_l@2
$LN6@compiler_l@2:

; 1824 :         ADDOP_IN_SCOPE(c, RETURN_VALUE);

  002b2	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  002b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002bf	e8 00 00 00 00	 call	 compiler_addop
  002c4	85 c0		 test	 eax, eax
  002c6	75 14		 jne	 SHORT $LN3@compiler_l@2
  002c8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002d0	e8 00 00 00 00	 call	 compiler_exit_scope
  002d5	33 c0		 xor	 eax, eax
  002d7	e9 ce 00 00 00	 jmp	 $LN19@compiler_l@2
$LN3@compiler_l@2:
$LN4@compiler_l@2:

; 1825 :     }
; 1826 :     co = assemble(c, 1);

  002dc	ba 01 00 00 00	 mov	 edx, 1
  002e1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002e9	e8 00 00 00 00	 call	 assemble
  002ee	48 89 44 24 40	 mov	 QWORD PTR co$[rsp], rax

; 1827 :     qualname = compiler_scope_qualname(c);

  002f3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002fb	e8 00 00 00 00	 call	 compiler_scope_qualname
  00300	48 89 44 24 48	 mov	 QWORD PTR qualname$[rsp], rax

; 1828 :     compiler_exit_scope(c);

  00305	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0030d	e8 00 00 00 00	 call	 compiler_exit_scope

; 1829 :     if (qualname == NULL || co == NULL)

  00312	48 83 7c 24 48
	00		 cmp	 QWORD PTR qualname$[rsp], 0
  00318	74 08		 je	 SHORT $LN1@compiler_l@2
  0031a	48 83 7c 24 40
	00		 cmp	 QWORD PTR co$[rsp], 0
  00320	75 07		 jne	 SHORT $LN2@compiler_l@2
$LN1@compiler_l@2:

; 1830 :         return 0;

  00322	33 c0		 xor	 eax, eax
  00324	e9 81 00 00 00	 jmp	 $LN19@compiler_l@2
$LN2@compiler_l@2:

; 1831 : 
; 1832 :     arglength = asdl_seq_LEN(args->defaults);

  00329	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  0032e	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00333	75 0e		 jne	 SHORT $LN28@compiler_l@2
  00335	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv194[rsp], 0
  00341	eb 14		 jmp	 SHORT $LN29@compiler_l@2
$LN28@compiler_l@2:
  00343	48 8b 44 24 30	 mov	 rax, QWORD PTR args$[rsp]
  00348	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0034c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0034f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv194[rsp], rax
$LN29@compiler_l@2:
  00357	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv194[rsp]
  0035e	89 44 24 3c	 mov	 DWORD PTR arglength$[rsp], eax

; 1833 :     arglength |= kw_default_count << 8;

  00362	8b 44 24 38	 mov	 eax, DWORD PTR kw_default_count$[rsp]
  00366	c1 e0 08	 shl	 eax, 8
  00369	8b 4c 24 3c	 mov	 ecx, DWORD PTR arglength$[rsp]
  0036d	0b c8		 or	 ecx, eax
  0036f	8b c1		 mov	 eax, ecx
  00371	89 44 24 3c	 mov	 DWORD PTR arglength$[rsp], eax

; 1834 :     compiler_make_closure(c, co, arglength, qualname);

  00375	4c 8b 4c 24 48	 mov	 r9, QWORD PTR qualname$[rsp]
  0037a	44 8b 44 24 3c	 mov	 r8d, DWORD PTR arglength$[rsp]
  0037f	48 8b 54 24 40	 mov	 rdx, QWORD PTR co$[rsp]
  00384	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0038c	e8 00 00 00 00	 call	 compiler_make_closure

; 1835 :     Py_DECREF(qualname);

  00391	48 8b 4c 24 48	 mov	 rcx, QWORD PTR qualname$[rsp]
  00396	e8 00 00 00 00	 call	 _Py_DecRef

; 1836 :     Py_DECREF(co);

  0039b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR co$[rsp]
  003a0	e8 00 00 00 00	 call	 _Py_DecRef

; 1837 : 
; 1838 :     return 1;

  003a5	b8 01 00 00 00	 mov	 eax, 1
$LN19@compiler_l@2:

; 1839 : }

  003aa	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  003b1	c3		 ret	 0
compiler_lambda ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@LCCMHKOH@unary?5op?5?$CFd?5should?5not?5be?5possib@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unaryop DD imagerel unaryop
	DD	imagerel unaryop+105
	DD	imagerel $unwind$unaryop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unaryop DD 010801H
	DD	06208H
xdata	ENDS
;	COMDAT ??_C@_0CD@LCCMHKOH@unary?5op?5?$CFd?5should?5not?5be?5possib@
CONST	SEGMENT
??_C@_0CD@LCCMHKOH@unary?5op?5?$CFd?5should?5not?5be?5possib@ DB 'unary o'
	DB	'p %d should not be possible', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT unaryop
_TEXT	SEGMENT
tv64 = 32
op$ = 64
unaryop	PROC						; COMDAT

; 2511 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2512 :     switch (op) {

  00008	8b 44 24 40	 mov	 eax, DWORD PTR op$[rsp]
  0000c	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00010	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  00015	74 17		 je	 SHORT $LN5@unaryop
  00017	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  0001c	74 17		 je	 SHORT $LN4@unaryop
  0001e	83 7c 24 20 03	 cmp	 DWORD PTR tv64[rsp], 3
  00023	74 17		 je	 SHORT $LN3@unaryop
  00025	83 7c 24 20 04	 cmp	 DWORD PTR tv64[rsp], 4
  0002a	74 17		 je	 SHORT $LN2@unaryop
  0002c	eb 1c		 jmp	 SHORT $LN1@unaryop
$LN5@unaryop:

; 2513 :     case Invert:
; 2514 :         return UNARY_INVERT;

  0002e	b8 0f 00 00 00	 mov	 eax, 15
  00033	eb 2f		 jmp	 SHORT $LN8@unaryop
$LN4@unaryop:

; 2515 :     case Not:
; 2516 :         return UNARY_NOT;

  00035	b8 0c 00 00 00	 mov	 eax, 12
  0003a	eb 28		 jmp	 SHORT $LN8@unaryop
$LN3@unaryop:

; 2517 :     case UAdd:
; 2518 :         return UNARY_POSITIVE;

  0003c	b8 0a 00 00 00	 mov	 eax, 10
  00041	eb 21		 jmp	 SHORT $LN8@unaryop
$LN2@unaryop:

; 2519 :     case USub:
; 2520 :         return UNARY_NEGATIVE;

  00043	b8 0b 00 00 00	 mov	 eax, 11
  00048	eb 1a		 jmp	 SHORT $LN8@unaryop
$LN1@unaryop:

; 2521 :     default:
; 2522 :         PyErr_Format(PyExc_SystemError,
; 2523 :             "unary op %d should not be possible", op);

  0004a	44 8b 44 24 40	 mov	 r8d, DWORD PTR op$[rsp]
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@LCCMHKOH@unary?5op?5?$CFd?5should?5not?5be?5possib@
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0005d	e8 00 00 00 00	 call	 PyErr_Format

; 2524 :         return 0;

  00062	33 c0		 xor	 eax, eax
$LN8@unaryop:

; 2525 :     }
; 2526 : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
unaryop	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@HMDMBIJ@binary?5op?5?$CFd?5should?5not?5be?5possi@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binop DD	imagerel binop
	DD	imagerel binop+228
	DD	imagerel $unwind$binop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binop DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_0CE@HMDMBIJ@binary?5op?5?$CFd?5should?5not?5be?5possi@
CONST	SEGMENT
??_C@_0CE@HMDMBIJ@binary?5op?5?$CFd?5should?5not?5be?5possi@ DB 'binary o'
	DB	'p %d should not be possible', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binop
_TEXT	SEGMENT
tv64 = 32
c$ = 64
op$ = 72
binop	PROC						; COMDAT

; 2530 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2531 :     switch (op) {

  0000d	8b 44 24 48	 mov	 eax, DWORD PTR op$[rsp]
  00011	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00015	8b 44 24 20	 mov	 eax, DWORD PTR tv64[rsp]
  00019	ff c8		 dec	 eax
  0001b	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0001f	83 7c 24 20 0b	 cmp	 DWORD PTR tv64[rsp], 11
  00024	77 6c		 ja	 SHORT $LN1@binop
  00026	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv64[rsp]
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00032	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN18@binop[rcx+rax*4]
  00039	48 03 c1	 add	 rax, rcx
  0003c	ff e0		 jmp	 rax
$LN13@binop:

; 2532 :     case Add:
; 2533 :         return BINARY_ADD;

  0003e	b8 17 00 00 00	 mov	 eax, 23
  00043	eb 67		 jmp	 SHORT $LN16@binop
$LN12@binop:

; 2534 :     case Sub:
; 2535 :         return BINARY_SUBTRACT;

  00045	b8 18 00 00 00	 mov	 eax, 24
  0004a	eb 60		 jmp	 SHORT $LN16@binop
$LN11@binop:

; 2536 :     case Mult:
; 2537 :         return BINARY_MULTIPLY;

  0004c	b8 14 00 00 00	 mov	 eax, 20
  00051	eb 59		 jmp	 SHORT $LN16@binop
$LN10@binop:

; 2538 :     case Div:
; 2539 :         return BINARY_TRUE_DIVIDE;

  00053	b8 1b 00 00 00	 mov	 eax, 27
  00058	eb 52		 jmp	 SHORT $LN16@binop
$LN9@binop:

; 2540 :     case Mod:
; 2541 :         return BINARY_MODULO;

  0005a	b8 16 00 00 00	 mov	 eax, 22
  0005f	eb 4b		 jmp	 SHORT $LN16@binop
$LN8@binop:

; 2542 :     case Pow:
; 2543 :         return BINARY_POWER;

  00061	b8 13 00 00 00	 mov	 eax, 19
  00066	eb 44		 jmp	 SHORT $LN16@binop
$LN7@binop:

; 2544 :     case LShift:
; 2545 :         return BINARY_LSHIFT;

  00068	b8 3e 00 00 00	 mov	 eax, 62			; 0000003eH
  0006d	eb 3d		 jmp	 SHORT $LN16@binop
$LN6@binop:

; 2546 :     case RShift:
; 2547 :         return BINARY_RSHIFT;

  0006f	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00074	eb 36		 jmp	 SHORT $LN16@binop
$LN5@binop:

; 2548 :     case BitOr:
; 2549 :         return BINARY_OR;

  00076	b8 42 00 00 00	 mov	 eax, 66			; 00000042H
  0007b	eb 2f		 jmp	 SHORT $LN16@binop
$LN4@binop:

; 2550 :     case BitXor:
; 2551 :         return BINARY_XOR;

  0007d	b8 41 00 00 00	 mov	 eax, 65			; 00000041H
  00082	eb 28		 jmp	 SHORT $LN16@binop
$LN3@binop:

; 2552 :     case BitAnd:
; 2553 :         return BINARY_AND;

  00084	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00089	eb 21		 jmp	 SHORT $LN16@binop
$LN2@binop:

; 2554 :     case FloorDiv:
; 2555 :         return BINARY_FLOOR_DIVIDE;

  0008b	b8 1a 00 00 00	 mov	 eax, 26
  00090	eb 1a		 jmp	 SHORT $LN16@binop
$LN1@binop:

; 2556 :     default:
; 2557 :         PyErr_Format(PyExc_SystemError,
; 2558 :             "binary op %d should not be possible", op);

  00092	44 8b 44 24 48	 mov	 r8d, DWORD PTR op$[rsp]
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@HMDMBIJ@binary?5op?5?$CFd?5should?5not?5be?5possi@
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000a5	e8 00 00 00 00	 call	 PyErr_Format

; 2559 :         return 0;

  000aa	33 c0		 xor	 eax, eax
$LN16@binop:

; 2560 :     }
; 2561 : }

  000ac	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b0	c3		 ret	 0
  000b1	0f 1f 00	 npad	 3
$LN18@binop:
  000b4	00 00 00 00	 DD	 $LN13@binop
  000b8	00 00 00 00	 DD	 $LN12@binop
  000bc	00 00 00 00	 DD	 $LN11@binop
  000c0	00 00 00 00	 DD	 $LN10@binop
  000c4	00 00 00 00	 DD	 $LN9@binop
  000c8	00 00 00 00	 DD	 $LN8@binop
  000cc	00 00 00 00	 DD	 $LN7@binop
  000d0	00 00 00 00	 DD	 $LN6@binop
  000d4	00 00 00 00	 DD	 $LN5@binop
  000d8	00 00 00 00	 DD	 $LN4@binop
  000dc	00 00 00 00	 DD	 $LN3@binop
  000e0	00 00 00 00	 DD	 $LN2@binop
binop	ENDP
_TEXT	ENDS
PUBLIC	??_C@_1O@OOEGIONJ@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@MGOOJJDI@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAB?$AAo?$AAo?$AAl?$AAO?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_boolop DD imagerel compiler_boolop
	DD	imagerel compiler_boolop+360
	DD	imagerel $unwind$compiler_boolop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_boolop DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1O@OOEGIONJ@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1O@OOEGIONJ@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'n', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@MGOOJJDI@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAB?$AAo?$AAo?$AAl?$AAO?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@MGOOJJDI@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAB?$AAo?$AAo?$AAl?$AAO?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'B', 00H, 'o', 00H, 'o'
	DB	00H, 'l', 00H, 'O', 00H, 'p', 00H, '_', 00H, 'k', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_boolop
_TEXT	SEGMENT
n$ = 32
i$ = 36
s$ = 40
jumpi$ = 48
end$ = 56
tv76 = 64
c$ = 96
e$ = 104
compiler_boolop PROC					; COMDAT

; 2748 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2749 :     basicblock *end;
; 2750 :     int jumpi, i, n;
; 2751 :     asdl_seq *s;
; 2752 : 
; 2753 :     assert(e->kind == BoolOp_kind);

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR e$[rsp]
  00013	83 38 01	 cmp	 DWORD PTR [rax], 1
  00016	74 1c		 je	 SHORT $LN12@compiler_b@2
  00018	41 b8 c1 0a 00
	00		 mov	 r8d, 2753		; 00000ac1H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@MGOOJJDI@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAB?$AAo?$AAo?$AAl?$AAO?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00032	33 c0		 xor	 eax, eax
$LN12@compiler_b@2:

; 2754 :     if (e->v.BoolOp.op == And)

  00034	48 8b 44 24 68	 mov	 rax, QWORD PTR e$[rsp]
  00039	83 78 08 01	 cmp	 DWORD PTR [rax+8], 1
  0003d	75 0a		 jne	 SHORT $LN9@compiler_b@2

; 2755 :         jumpi = JUMP_IF_FALSE_OR_POP;

  0003f	c7 44 24 30 6f
	00 00 00	 mov	 DWORD PTR jumpi$[rsp], 111 ; 0000006fH

; 2756 :     else

  00047	eb 08		 jmp	 SHORT $LN8@compiler_b@2
$LN9@compiler_b@2:

; 2757 :         jumpi = JUMP_IF_TRUE_OR_POP;

  00049	c7 44 24 30 70
	00 00 00	 mov	 DWORD PTR jumpi$[rsp], 112 ; 00000070H
$LN8@compiler_b@2:

; 2758 :     end = compiler_new_block(c);

  00051	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00056	e8 00 00 00 00	 call	 compiler_new_block
  0005b	48 89 44 24 38	 mov	 QWORD PTR end$[rsp], rax

; 2759 :     if (end == NULL)

  00060	48 83 7c 24 38
	00		 cmp	 QWORD PTR end$[rsp], 0
  00066	75 07		 jne	 SHORT $LN7@compiler_b@2

; 2760 :         return 0;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 f4 00 00 00	 jmp	 $LN10@compiler_b@2
$LN7@compiler_b@2:

; 2761 :     s = e->v.BoolOp.values;

  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR e$[rsp]
  00074	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00078	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 2762 :     n = asdl_seq_LEN(s) - 1;

  0007d	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  00083	75 0b		 jne	 SHORT $LN13@compiler_b@2
  00085	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv76[rsp], 0
  0008e	eb 0d		 jmp	 SHORT $LN14@compiler_b@2
$LN13@compiler_b@2:
  00090	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00098	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
$LN14@compiler_b@2:
  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR tv76[rsp]
  000a2	48 ff c8	 dec	 rax
  000a5	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 2763 :     assert(n >= 0);

  000a9	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  000ae	7d 1c		 jge	 SHORT $LN15@compiler_b@2
  000b0	41 b8 cb 0a 00
	00		 mov	 r8d, 2763		; 00000acbH
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@OOEGIONJ@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ca	33 c0		 xor	 eax, eax
$LN15@compiler_b@2:

; 2764 :     for (i = 0; i < n; ++i) {

  000cc	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000d4	eb 0a		 jmp	 SHORT $LN6@compiler_b@2
$LN5@compiler_b@2:
  000d6	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000da	ff c0		 inc	 eax
  000dc	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN6@compiler_b@2:
  000e0	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000e4	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000e8	7d 44		 jge	 SHORT $LN4@compiler_b@2

; 2765 :         VISIT(c, expr, (expr_ty)asdl_seq_GET(s, i));

  000ea	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000f4	48 8b 54 c1 08	 mov	 rdx, QWORD PTR [rcx+rax*8+8]
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000fe	e8 00 00 00 00	 call	 compiler_visit_expr
  00103	85 c0		 test	 eax, eax
  00105	75 04		 jne	 SHORT $LN3@compiler_b@2
  00107	33 c0		 xor	 eax, eax
  00109	eb 58		 jmp	 SHORT $LN10@compiler_b@2
$LN3@compiler_b@2:

; 2766 :         ADDOP_JABS(c, jumpi, end);

  0010b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00111	4c 8b 44 24 38	 mov	 r8, QWORD PTR end$[rsp]
  00116	8b 54 24 30	 mov	 edx, DWORD PTR jumpi$[rsp]
  0011a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0011f	e8 00 00 00 00	 call	 compiler_addop_j
  00124	85 c0		 test	 eax, eax
  00126	75 04		 jne	 SHORT $LN2@compiler_b@2
  00128	33 c0		 xor	 eax, eax
  0012a	eb 37		 jmp	 SHORT $LN10@compiler_b@2
$LN2@compiler_b@2:

; 2767 :     }

  0012c	eb a8		 jmp	 SHORT $LN5@compiler_b@2
$LN4@compiler_b@2:

; 2768 :     VISIT(c, expr, (expr_ty)asdl_seq_GET(s, n));

  0012e	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$[rsp]
  00133	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00138	48 8b 54 c1 08	 mov	 rdx, QWORD PTR [rcx+rax*8+8]
  0013d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00142	e8 00 00 00 00	 call	 compiler_visit_expr
  00147	85 c0		 test	 eax, eax
  00149	75 04		 jne	 SHORT $LN1@compiler_b@2
  0014b	33 c0		 xor	 eax, eax
  0014d	eb 14		 jmp	 SHORT $LN10@compiler_b@2
$LN1@compiler_b@2:

; 2769 :     compiler_use_next_block(c, end);

  0014f	48 8b 54 24 38	 mov	 rdx, QWORD PTR end$[rsp]
  00154	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00159	e8 00 00 00 00	 call	 compiler_use_next_block

; 2770 :     return 1;

  0015e	b8 01 00 00 00	 mov	 eax, 1
$LN10@compiler_b@2:

; 2771 : }

  00163	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00167	c3		 ret	 0
compiler_boolop ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@OJEPACC@two?5starred?5expressions?5in?5assig@ ; `string'
PUBLIC	??_C@_1GK@CCPDPFNM@?$AA?$CI?$AAe?$AA?9?$AA?$DO?$AAv?$AA?4?$AAL?$AAi?$AAs?$AAt?$AA?4?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAe@ ; `string'
PUBLIC	??_C@_0DC@DEOGEHAB@too?5many?5expressions?5in?5star?9unp@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_list DD imagerel compiler_list
	DD	imagerel compiler_list+627
	DD	imagerel $unwind$compiler_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_list DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0CG@OJEPACC@two?5starred?5expressions?5in?5assig@
CONST	SEGMENT
??_C@_0CG@OJEPACC@two?5starred?5expressions?5in?5assig@ DB 'two starred e'
	DB	'xpressions in assignment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@CCPDPFNM@?$AA?$CI?$AAe?$AA?9?$AA?$DO?$AAv?$AA?4?$AAL?$AAi?$AAs?$AAt?$AA?4?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAe@
CONST	SEGMENT
??_C@_1GK@CCPDPFNM@?$AA?$CI?$AAe?$AA?9?$AA?$DO?$AAv?$AA?4?$AAL?$AAi?$AAs?$AAt?$AA?4?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAe@ DB '('
	DB	00H, 'e', 00H, '-', 00H, '>', 00H, 'v', 00H, '.', 00H, 'L', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'e', 00H, 'l', 00H, 't'
	DB	00H, 's', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'_', 00H, 'a', 00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 'i'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'v', 00H, '.', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, '.', 00H, 'e', 00H, 'l', 00H, 't', 00H, 's', 00H, ')', 00H
	DB	'-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DEOGEHAB@too?5many?5expressions?5in?5star?9unp@
CONST	SEGMENT
??_C@_0DC@DEOGEHAB@too?5many?5expressions?5in?5star?9unp@ DB 'too many ex'
	DB	'pressions in star-unpacking assignment', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_list
_TEXT	SEGMENT
n$ = 32
seen_star$24330 = 36
i$24329 = 40
elt$24334 = 48
_asdl_i$24340 = 56
_i$24348 = 60
seq$24349 = 64
elt$24354 = 72
tv68 = 80
tv159 = 88
c$ = 112
e$ = 120
compiler_list PROC					; COMDAT

; 2775 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2776 :     int n = asdl_seq_LEN(e->v.List.elts);

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  00013	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00018	75 0b		 jne	 SHORT $LN21@compiler_l@3
  0001a	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
  00023	eb 11		 jmp	 SHORT $LN22@compiler_l@3
$LN21@compiler_l@3:
  00025	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  0002a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00031	48 89 44 24 50	 mov	 QWORD PTR tv68[rsp], rax
$LN22@compiler_l@3:
  00036	8b 44 24 50	 mov	 eax, DWORD PTR tv68[rsp]
  0003a	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 2777 :     if (e->v.List.ctx == Store) {

  0003e	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  00043	83 78 10 02	 cmp	 DWORD PTR [rax+16], 2
  00047	0f 85 7a 01 00
	00		 jne	 $LN18@compiler_l@3

; 2778 :         int i, seen_star = 0;

  0004d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR seen_star$24330[rsp], 0

; 2779 :         for (i = 0; i < n; i++) {

  00055	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$24329[rsp], 0
  0005d	eb 0a		 jmp	 SHORT $LN17@compiler_l@3
$LN16@compiler_l@3:
  0005f	8b 44 24 28	 mov	 eax, DWORD PTR i$24329[rsp]
  00063	ff c0		 inc	 eax
  00065	89 44 24 28	 mov	 DWORD PTR i$24329[rsp], eax
$LN17@compiler_l@3:
  00069	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0006d	39 44 24 28	 cmp	 DWORD PTR i$24329[rsp], eax
  00071	0f 8d 2a 01 00
	00		 jge	 $LN15@compiler_l@3

; 2780 :             expr_ty elt = asdl_seq_GET(e->v.List.elts, i);

  00077	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  0007c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00080	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR i$24329[rsp]
  00085	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  0008a	48 89 44 24 30	 mov	 QWORD PTR elt$24334[rsp], rax

; 2781 :             if (elt->kind == Starred_kind && !seen_star) {

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR elt$24334[rsp]
  00094	83 38 16	 cmp	 DWORD PTR [rax], 22
  00097	0f 85 df 00 00
	00		 jne	 $LN14@compiler_l@3
  0009d	83 7c 24 24 00	 cmp	 DWORD PTR seen_star$24330[rsp], 0
  000a2	0f 85 d4 00 00
	00		 jne	 $LN14@compiler_l@3

; 2782 :                 if ((i >= (1 << 8)) ||
; 2783 :                     (n-i-1 >= (INT_MAX >> 8)))

  000a8	81 7c 24 28 00
	01 00 00	 cmp	 DWORD PTR i$24329[rsp], 256 ; 00000100H
  000b0	7d 15		 jge	 SHORT $LN12@compiler_l@3
  000b2	8b 44 24 28	 mov	 eax, DWORD PTR i$24329[rsp]
  000b6	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  000ba	2b c8		 sub	 ecx, eax
  000bc	8b c1		 mov	 eax, ecx
  000be	ff c8		 dec	 eax
  000c0	3d ff ff 7f 00	 cmp	 eax, 8388607		; 007fffffH
  000c5	7c 16		 jl	 SHORT $LN13@compiler_l@3
$LN12@compiler_l@3:

; 2784 :                     return compiler_error(c,
; 2785 :                         "too many expressions in "
; 2786 :                         "star-unpacking assignment");

  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DEOGEHAB@too?5many?5expressions?5in?5star?9unp@
  000ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000d3	e8 00 00 00 00	 call	 compiler_error
  000d8	e9 91 01 00 00	 jmp	 $LN19@compiler_l@3
$LN13@compiler_l@3:

; 2787 :                 ADDOP_I(c, UNPACK_EX, (i + ((n-i-1) << 8)));

  000dd	8b 44 24 28	 mov	 eax, DWORD PTR i$24329[rsp]
  000e1	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  000e5	2b c8		 sub	 ecx, eax
  000e7	8b c1		 mov	 eax, ecx
  000e9	ff c8		 dec	 eax
  000eb	c1 e0 08	 shl	 eax, 8
  000ee	8b 4c 24 28	 mov	 ecx, DWORD PTR i$24329[rsp]
  000f2	03 c8		 add	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	44 8b c0	 mov	 r8d, eax
  000f9	ba 5e 00 00 00	 mov	 edx, 94			; 0000005eH
  000fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00103	e8 00 00 00 00	 call	 compiler_addop_i
  00108	85 c0		 test	 eax, eax
  0010a	75 07		 jne	 SHORT $LN11@compiler_l@3
  0010c	33 c0		 xor	 eax, eax
  0010e	e9 5b 01 00 00	 jmp	 $LN19@compiler_l@3
$LN11@compiler_l@3:

; 2788 :                 seen_star = 1;

  00113	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR seen_star$24330[rsp], 1

; 2789 :                 asdl_seq_SET(e->v.List.elts, i, elt->v.Starred.value);

  0011b	8b 44 24 28	 mov	 eax, DWORD PTR i$24329[rsp]
  0011f	89 44 24 38	 mov	 DWORD PTR _asdl_i$24340[rsp], eax
  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  00128	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0012d	74 13		 je	 SHORT $LN23@compiler_l@3
  0012f	48 63 44 24 38	 movsxd	 rax, DWORD PTR _asdl_i$24340[rsp]
  00134	48 8b 4c 24 78	 mov	 rcx, QWORD PTR e$[rsp]
  00139	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0013d	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00140	7c 1c		 jl	 SHORT $LN24@compiler_l@3
$LN23@compiler_l@3:
  00142	41 b8 e5 0a 00
	00		 mov	 r8d, 2789		; 00000ae5H
  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GK@CCPDPFNM@?$AA?$CI?$AAe?$AA?9?$AA?$DO?$AAv?$AA?4?$AAL?$AAi?$AAs?$AAt?$AA?4?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAe@
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0015c	33 c0		 xor	 eax, eax
$LN24@compiler_l@3:
  0015e	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  00163	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00167	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR _asdl_i$24340[rsp]
  0016c	48 8b 54 24 30	 mov	 rdx, QWORD PTR elt$24334[rsp]
  00171	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00175	48 89 54 c8 08	 mov	 QWORD PTR [rax+rcx*8+8], rdx
  0017a	eb 20		 jmp	 SHORT $LN10@compiler_l@3
$LN14@compiler_l@3:

; 2790 :             } else if (elt->kind == Starred_kind) {

  0017c	48 8b 44 24 30	 mov	 rax, QWORD PTR elt$24334[rsp]
  00181	83 38 16	 cmp	 DWORD PTR [rax], 22
  00184	75 16		 jne	 SHORT $LN9@compiler_l@3

; 2791 :                 return compiler_error(c,
; 2792 :                     "two starred expressions in assignment");

  00186	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@OJEPACC@two?5starred?5expressions?5in?5assig@
  0018d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00192	e8 00 00 00 00	 call	 compiler_error
  00197	e9 d2 00 00 00	 jmp	 $LN19@compiler_l@3
$LN9@compiler_l@3:
$LN10@compiler_l@3:

; 2793 :             }
; 2794 :         }

  0019c	e9 be fe ff ff	 jmp	 $LN16@compiler_l@3
$LN15@compiler_l@3:

; 2795 :         if (!seen_star) {

  001a1	83 7c 24 24 00	 cmp	 DWORD PTR seen_star$24330[rsp], 0
  001a6	75 1f		 jne	 SHORT $LN8@compiler_l@3

; 2796 :             ADDOP_I(c, UNPACK_SEQUENCE, n);

  001a8	44 8b 44 24 20	 mov	 r8d, DWORD PTR n$[rsp]
  001ad	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  001b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  001b7	e8 00 00 00 00	 call	 compiler_addop_i
  001bc	85 c0		 test	 eax, eax
  001be	75 07		 jne	 SHORT $LN7@compiler_l@3
  001c0	33 c0		 xor	 eax, eax
  001c2	e9 a7 00 00 00	 jmp	 $LN19@compiler_l@3
$LN7@compiler_l@3:
$LN8@compiler_l@3:
$LN18@compiler_l@3:

; 2797 :         }
; 2798 :     }
; 2799 :     VISIT_SEQ(c, expr, e->v.List.elts);

  001c7	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  001cc	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001d0	48 89 44 24 40	 mov	 QWORD PTR seq$24349[rsp], rax
  001d5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _i$24348[rsp], 0
  001dd	eb 0a		 jmp	 SHORT $LN6@compiler_l@3
$LN5@compiler_l@3:
  001df	8b 44 24 3c	 mov	 eax, DWORD PTR _i$24348[rsp]
  001e3	ff c0		 inc	 eax
  001e5	89 44 24 3c	 mov	 DWORD PTR _i$24348[rsp], eax
$LN6@compiler_l@3:
  001e9	48 83 7c 24 40
	00		 cmp	 QWORD PTR seq$24349[rsp], 0
  001ef	75 0b		 jne	 SHORT $LN25@compiler_l@3
  001f1	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv159[rsp], 0
  001fa	eb 0d		 jmp	 SHORT $LN26@compiler_l@3
$LN25@compiler_l@3:
  001fc	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$24349[rsp]
  00201	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00204	48 89 44 24 58	 mov	 QWORD PTR tv159[rsp], rax
$LN26@compiler_l@3:
  00209	48 63 44 24 3c	 movsxd	 rax, DWORD PTR _i$24348[rsp]
  0020e	48 3b 44 24 58	 cmp	 rax, QWORD PTR tv159[rsp]
  00213	7d 2d		 jge	 SHORT $LN4@compiler_l@3
  00215	48 63 44 24 3c	 movsxd	 rax, DWORD PTR _i$24348[rsp]
  0021a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$24349[rsp]
  0021f	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00224	48 89 44 24 48	 mov	 QWORD PTR elt$24354[rsp], rax
  00229	48 8b 54 24 48	 mov	 rdx, QWORD PTR elt$24354[rsp]
  0022e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00233	e8 00 00 00 00	 call	 compiler_visit_expr
  00238	85 c0		 test	 eax, eax
  0023a	75 04		 jne	 SHORT $LN3@compiler_l@3
  0023c	33 c0		 xor	 eax, eax
  0023e	eb 2e		 jmp	 SHORT $LN19@compiler_l@3
$LN3@compiler_l@3:
  00240	eb 9d		 jmp	 SHORT $LN5@compiler_l@3
$LN4@compiler_l@3:

; 2800 :     if (e->v.List.ctx == Load) {

  00242	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  00247	83 78 10 01	 cmp	 DWORD PTR [rax+16], 1
  0024b	75 1c		 jne	 SHORT $LN2@compiler_l@3

; 2801 :         ADDOP_I(c, BUILD_LIST, n);

  0024d	44 8b 44 24 20	 mov	 r8d, DWORD PTR n$[rsp]
  00252	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
  00257	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0025c	e8 00 00 00 00	 call	 compiler_addop_i
  00261	85 c0		 test	 eax, eax
  00263	75 04		 jne	 SHORT $LN1@compiler_l@3
  00265	33 c0		 xor	 eax, eax
  00267	eb 05		 jmp	 SHORT $LN19@compiler_l@3
$LN1@compiler_l@3:
$LN2@compiler_l@3:

; 2802 :     }
; 2803 :     return 1;

  00269	b8 01 00 00 00	 mov	 eax, 1
$LN19@compiler_l@3:

; 2804 : }

  0026e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00272	c3		 ret	 0
compiler_list ENDP
_TEXT	ENDS
PUBLIC	??_C@_1GO@LPGCEKGM@?$AA?$CI?$AAe?$AA?9?$AA?$DO?$AAv?$AA?4?$AAT?$AAu?$AAp?$AAl?$AAe?$AA?4?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_tuple DD imagerel compiler_tuple
	DD	imagerel compiler_tuple+627
	DD	imagerel $unwind$compiler_tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_tuple DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_1GO@LPGCEKGM@?$AA?$CI?$AAe?$AA?9?$AA?$DO?$AAv?$AA?4?$AAT?$AAu?$AAp?$AAl?$AAe?$AA?4?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI@
CONST	SEGMENT
??_C@_1GO@LPGCEKGM@?$AA?$CI?$AAe?$AA?9?$AA?$DO?$AAv?$AA?4?$AAT?$AAu?$AAp?$AAl?$AAe?$AA?4?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI@ DB '('
	DB	00H, 'e', 00H, '-', 00H, '>', 00H, 'v', 00H, '.', 00H, 'T', 00H
	DB	'u', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '.', 00H, 'e', 00H, 'l'
	DB	00H, 't', 00H, 's', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, '_', 00H, 'a', 00H, 's', 00H, 'd', 00H, 'l', 00H, '_'
	DB	00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 'v', 00H, '.', 00H, 'T', 00H, 'u', 00H, 'p'
	DB	00H, 'l', 00H, 'e', 00H, '.', 00H, 'e', 00H, 'l', 00H, 't', 00H
	DB	's', 00H, ')', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_tuple
_TEXT	SEGMENT
n$ = 32
seen_star$24369 = 36
i$24368 = 40
elt$24373 = 48
_asdl_i$24378 = 56
_i$24385 = 60
seq$24386 = 64
elt$24391 = 72
tv68 = 80
tv159 = 88
c$ = 112
e$ = 120
compiler_tuple PROC					; COMDAT

; 2808 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2809 :     int n = asdl_seq_LEN(e->v.Tuple.elts);

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  00013	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00018	75 0b		 jne	 SHORT $LN21@compiler_t@4
  0001a	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
  00023	eb 11		 jmp	 SHORT $LN22@compiler_t@4
$LN21@compiler_t@4:
  00025	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  0002a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00031	48 89 44 24 50	 mov	 QWORD PTR tv68[rsp], rax
$LN22@compiler_t@4:
  00036	8b 44 24 50	 mov	 eax, DWORD PTR tv68[rsp]
  0003a	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 2810 :     if (e->v.Tuple.ctx == Store) {

  0003e	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  00043	83 78 10 02	 cmp	 DWORD PTR [rax+16], 2
  00047	0f 85 7a 01 00
	00		 jne	 $LN18@compiler_t@4

; 2811 :         int i, seen_star = 0;

  0004d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR seen_star$24369[rsp], 0

; 2812 :         for (i = 0; i < n; i++) {

  00055	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$24368[rsp], 0
  0005d	eb 0a		 jmp	 SHORT $LN17@compiler_t@4
$LN16@compiler_t@4:
  0005f	8b 44 24 28	 mov	 eax, DWORD PTR i$24368[rsp]
  00063	ff c0		 inc	 eax
  00065	89 44 24 28	 mov	 DWORD PTR i$24368[rsp], eax
$LN17@compiler_t@4:
  00069	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0006d	39 44 24 28	 cmp	 DWORD PTR i$24368[rsp], eax
  00071	0f 8d 2a 01 00
	00		 jge	 $LN15@compiler_t@4

; 2813 :             expr_ty elt = asdl_seq_GET(e->v.Tuple.elts, i);

  00077	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  0007c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00080	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR i$24368[rsp]
  00085	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  0008a	48 89 44 24 30	 mov	 QWORD PTR elt$24373[rsp], rax

; 2814 :             if (elt->kind == Starred_kind && !seen_star) {

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR elt$24373[rsp]
  00094	83 38 16	 cmp	 DWORD PTR [rax], 22
  00097	0f 85 df 00 00
	00		 jne	 $LN14@compiler_t@4
  0009d	83 7c 24 24 00	 cmp	 DWORD PTR seen_star$24369[rsp], 0
  000a2	0f 85 d4 00 00
	00		 jne	 $LN14@compiler_t@4

; 2815 :                 if ((i >= (1 << 8)) ||
; 2816 :                     (n-i-1 >= (INT_MAX >> 8)))

  000a8	81 7c 24 28 00
	01 00 00	 cmp	 DWORD PTR i$24368[rsp], 256 ; 00000100H
  000b0	7d 15		 jge	 SHORT $LN12@compiler_t@4
  000b2	8b 44 24 28	 mov	 eax, DWORD PTR i$24368[rsp]
  000b6	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  000ba	2b c8		 sub	 ecx, eax
  000bc	8b c1		 mov	 eax, ecx
  000be	ff c8		 dec	 eax
  000c0	3d ff ff 7f 00	 cmp	 eax, 8388607		; 007fffffH
  000c5	7c 16		 jl	 SHORT $LN13@compiler_t@4
$LN12@compiler_t@4:

; 2817 :                     return compiler_error(c,
; 2818 :                         "too many expressions in "
; 2819 :                         "star-unpacking assignment");

  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DEOGEHAB@too?5many?5expressions?5in?5star?9unp@
  000ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000d3	e8 00 00 00 00	 call	 compiler_error
  000d8	e9 91 01 00 00	 jmp	 $LN19@compiler_t@4
$LN13@compiler_t@4:

; 2820 :                 ADDOP_I(c, UNPACK_EX, (i + ((n-i-1) << 8)));

  000dd	8b 44 24 28	 mov	 eax, DWORD PTR i$24368[rsp]
  000e1	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  000e5	2b c8		 sub	 ecx, eax
  000e7	8b c1		 mov	 eax, ecx
  000e9	ff c8		 dec	 eax
  000eb	c1 e0 08	 shl	 eax, 8
  000ee	8b 4c 24 28	 mov	 ecx, DWORD PTR i$24368[rsp]
  000f2	03 c8		 add	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	44 8b c0	 mov	 r8d, eax
  000f9	ba 5e 00 00 00	 mov	 edx, 94			; 0000005eH
  000fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00103	e8 00 00 00 00	 call	 compiler_addop_i
  00108	85 c0		 test	 eax, eax
  0010a	75 07		 jne	 SHORT $LN11@compiler_t@4
  0010c	33 c0		 xor	 eax, eax
  0010e	e9 5b 01 00 00	 jmp	 $LN19@compiler_t@4
$LN11@compiler_t@4:

; 2821 :                 seen_star = 1;

  00113	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR seen_star$24369[rsp], 1

; 2822 :                 asdl_seq_SET(e->v.Tuple.elts, i, elt->v.Starred.value);

  0011b	8b 44 24 28	 mov	 eax, DWORD PTR i$24368[rsp]
  0011f	89 44 24 38	 mov	 DWORD PTR _asdl_i$24378[rsp], eax
  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  00128	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0012d	74 13		 je	 SHORT $LN23@compiler_t@4
  0012f	48 63 44 24 38	 movsxd	 rax, DWORD PTR _asdl_i$24378[rsp]
  00134	48 8b 4c 24 78	 mov	 rcx, QWORD PTR e$[rsp]
  00139	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0013d	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00140	7c 1c		 jl	 SHORT $LN24@compiler_t@4
$LN23@compiler_t@4:
  00142	41 b8 06 0b 00
	00		 mov	 r8d, 2822		; 00000b06H
  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GO@LPGCEKGM@?$AA?$CI?$AAe?$AA?9?$AA?$DO?$AAv?$AA?4?$AAT?$AAu?$AAp?$AAl?$AAe?$AA?4?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI@
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0015c	33 c0		 xor	 eax, eax
$LN24@compiler_t@4:
  0015e	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  00163	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00167	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR _asdl_i$24378[rsp]
  0016c	48 8b 54 24 30	 mov	 rdx, QWORD PTR elt$24373[rsp]
  00171	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00175	48 89 54 c8 08	 mov	 QWORD PTR [rax+rcx*8+8], rdx
  0017a	eb 20		 jmp	 SHORT $LN10@compiler_t@4
$LN14@compiler_t@4:

; 2823 :             } else if (elt->kind == Starred_kind) {

  0017c	48 8b 44 24 30	 mov	 rax, QWORD PTR elt$24373[rsp]
  00181	83 38 16	 cmp	 DWORD PTR [rax], 22
  00184	75 16		 jne	 SHORT $LN9@compiler_t@4

; 2824 :                 return compiler_error(c,
; 2825 :                     "two starred expressions in assignment");

  00186	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@OJEPACC@two?5starred?5expressions?5in?5assig@
  0018d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00192	e8 00 00 00 00	 call	 compiler_error
  00197	e9 d2 00 00 00	 jmp	 $LN19@compiler_t@4
$LN9@compiler_t@4:
$LN10@compiler_t@4:

; 2826 :             }
; 2827 :         }

  0019c	e9 be fe ff ff	 jmp	 $LN16@compiler_t@4
$LN15@compiler_t@4:

; 2828 :         if (!seen_star) {

  001a1	83 7c 24 24 00	 cmp	 DWORD PTR seen_star$24369[rsp], 0
  001a6	75 1f		 jne	 SHORT $LN8@compiler_t@4

; 2829 :             ADDOP_I(c, UNPACK_SEQUENCE, n);

  001a8	44 8b 44 24 20	 mov	 r8d, DWORD PTR n$[rsp]
  001ad	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  001b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  001b7	e8 00 00 00 00	 call	 compiler_addop_i
  001bc	85 c0		 test	 eax, eax
  001be	75 07		 jne	 SHORT $LN7@compiler_t@4
  001c0	33 c0		 xor	 eax, eax
  001c2	e9 a7 00 00 00	 jmp	 $LN19@compiler_t@4
$LN7@compiler_t@4:
$LN8@compiler_t@4:
$LN18@compiler_t@4:

; 2830 :         }
; 2831 :     }
; 2832 :     VISIT_SEQ(c, expr, e->v.Tuple.elts);

  001c7	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  001cc	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001d0	48 89 44 24 40	 mov	 QWORD PTR seq$24386[rsp], rax
  001d5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _i$24385[rsp], 0
  001dd	eb 0a		 jmp	 SHORT $LN6@compiler_t@4
$LN5@compiler_t@4:
  001df	8b 44 24 3c	 mov	 eax, DWORD PTR _i$24385[rsp]
  001e3	ff c0		 inc	 eax
  001e5	89 44 24 3c	 mov	 DWORD PTR _i$24385[rsp], eax
$LN6@compiler_t@4:
  001e9	48 83 7c 24 40
	00		 cmp	 QWORD PTR seq$24386[rsp], 0
  001ef	75 0b		 jne	 SHORT $LN25@compiler_t@4
  001f1	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv159[rsp], 0
  001fa	eb 0d		 jmp	 SHORT $LN26@compiler_t@4
$LN25@compiler_t@4:
  001fc	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$24386[rsp]
  00201	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00204	48 89 44 24 58	 mov	 QWORD PTR tv159[rsp], rax
$LN26@compiler_t@4:
  00209	48 63 44 24 3c	 movsxd	 rax, DWORD PTR _i$24385[rsp]
  0020e	48 3b 44 24 58	 cmp	 rax, QWORD PTR tv159[rsp]
  00213	7d 2d		 jge	 SHORT $LN4@compiler_t@4
  00215	48 63 44 24 3c	 movsxd	 rax, DWORD PTR _i$24385[rsp]
  0021a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$24386[rsp]
  0021f	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00224	48 89 44 24 48	 mov	 QWORD PTR elt$24391[rsp], rax
  00229	48 8b 54 24 48	 mov	 rdx, QWORD PTR elt$24391[rsp]
  0022e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00233	e8 00 00 00 00	 call	 compiler_visit_expr
  00238	85 c0		 test	 eax, eax
  0023a	75 04		 jne	 SHORT $LN3@compiler_t@4
  0023c	33 c0		 xor	 eax, eax
  0023e	eb 2e		 jmp	 SHORT $LN19@compiler_t@4
$LN3@compiler_t@4:
  00240	eb 9d		 jmp	 SHORT $LN5@compiler_t@4
$LN4@compiler_t@4:

; 2833 :     if (e->v.Tuple.ctx == Load) {

  00242	48 8b 44 24 78	 mov	 rax, QWORD PTR e$[rsp]
  00247	83 78 10 01	 cmp	 DWORD PTR [rax+16], 1
  0024b	75 1c		 jne	 SHORT $LN2@compiler_t@4

; 2834 :         ADDOP_I(c, BUILD_TUPLE, n);

  0024d	44 8b 44 24 20	 mov	 r8d, DWORD PTR n$[rsp]
  00252	ba 66 00 00 00	 mov	 edx, 102		; 00000066H
  00257	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0025c	e8 00 00 00 00	 call	 compiler_addop_i
  00261	85 c0		 test	 eax, eax
  00263	75 04		 jne	 SHORT $LN1@compiler_t@4
  00265	33 c0		 xor	 eax, eax
  00267	eb 05		 jmp	 SHORT $LN19@compiler_t@4
$LN1@compiler_t@4:
$LN2@compiler_t@4:

; 2835 :     }
; 2836 :     return 1;

  00269	b8 01 00 00 00	 mov	 eax, 1
$LN19@compiler_t@4:

; 2837 : }

  0026e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00272	c3		 ret	 0
compiler_tuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_1M@GNNEDJIO@?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_compare DD imagerel compiler_compare
	DD	imagerel compiler_compare+720
	DD	imagerel $unwind$compiler_compare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_compare DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1M@GNNEDJIO@?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GNNEDJIO@?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_compare
_TEXT	SEGMENT
cleanup$ = 32
n$ = 40
i$ = 44
end$24433 = 48
tv73 = 56
c$ = 80
e$ = 88
compiler_compare PROC					; COMDAT

; 2841 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2842 :     int i, n;
; 2843 :     basicblock *cleanup = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR cleanup$[rsp], 0

; 2844 : 
; 2845 :     /* XXX the logic can be cleaned up for 1 or multiple comparisons */
; 2846 :     VISIT(c, expr, e->v.Compare.left);

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0001c	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00020	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00025	e8 00 00 00 00	 call	 compiler_visit_expr
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN21@compiler_c@4
  0002e	33 c0		 xor	 eax, eax
  00030	e9 96 02 00 00	 jmp	 $LN22@compiler_c@4
$LN21@compiler_c@4:

; 2847 :     n = asdl_seq_LEN(e->v.Compare.ops);

  00035	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0003a	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0003f	75 0b		 jne	 SHORT $LN24@compiler_c@4
  00041	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
  0004a	eb 11		 jmp	 SHORT $LN25@compiler_c@4
$LN24@compiler_c@4:
  0004c	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  00051	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 89 44 24 38	 mov	 QWORD PTR tv73[rsp], rax
$LN25@compiler_c@4:
  0005d	8b 44 24 38	 mov	 eax, DWORD PTR tv73[rsp]
  00061	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 2848 :     assert(n > 0);

  00065	83 7c 24 28 00	 cmp	 DWORD PTR n$[rsp], 0
  0006a	7f 1c		 jg	 SHORT $LN26@compiler_c@4
  0006c	41 b8 20 0b 00
	00		 mov	 r8d, 2848		; 00000b20H
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1M@GNNEDJIO@?$AAn?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00086	33 c0		 xor	 eax, eax
$LN26@compiler_c@4:

; 2849 :     if (n > 1) {

  00088	83 7c 24 28 01	 cmp	 DWORD PTR n$[rsp], 1
  0008d	7e 40		 jle	 SHORT $LN20@compiler_c@4

; 2850 :         cleanup = compiler_new_block(c);

  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00094	e8 00 00 00 00	 call	 compiler_new_block
  00099	48 89 44 24 20	 mov	 QWORD PTR cleanup$[rsp], rax

; 2851 :         if (cleanup == NULL)

  0009e	48 83 7c 24 20
	00		 cmp	 QWORD PTR cleanup$[rsp], 0
  000a4	75 07		 jne	 SHORT $LN19@compiler_c@4

; 2852 :             return 0;

  000a6	33 c0		 xor	 eax, eax
  000a8	e9 1e 02 00 00	 jmp	 $LN22@compiler_c@4
$LN19@compiler_c@4:

; 2853 :         VISIT(c, expr,
; 2854 :             (expr_ty)asdl_seq_GET(e->v.Compare.comparators, 0));

  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  000b2	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000b6	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000ba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000bf	e8 00 00 00 00	 call	 compiler_visit_expr
  000c4	85 c0		 test	 eax, eax
  000c6	75 07		 jne	 SHORT $LN18@compiler_c@4
  000c8	33 c0		 xor	 eax, eax
  000ca	e9 fc 01 00 00	 jmp	 $LN22@compiler_c@4
$LN18@compiler_c@4:
$LN20@compiler_c@4:

; 2855 :     }
; 2856 :     for (i = 1; i < n; i++) {

  000cf	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  000d7	eb 0a		 jmp	 SHORT $LN17@compiler_c@4
$LN16@compiler_c@4:
  000d9	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  000dd	ff c0		 inc	 eax
  000df	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN17@compiler_c@4:
  000e3	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  000e7	39 44 24 2c	 cmp	 DWORD PTR i$[rsp], eax
  000eb	0f 8d e0 00 00
	00		 jge	 $LN15@compiler_c@4

; 2857 :         ADDOP(c, DUP_TOP);

  000f1	ba 04 00 00 00	 mov	 edx, 4
  000f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000fb	e8 00 00 00 00	 call	 compiler_addop
  00100	85 c0		 test	 eax, eax
  00102	75 07		 jne	 SHORT $LN14@compiler_c@4
  00104	33 c0		 xor	 eax, eax
  00106	e9 c0 01 00 00	 jmp	 $LN22@compiler_c@4
$LN14@compiler_c@4:

; 2858 :         ADDOP(c, ROT_THREE);

  0010b	ba 03 00 00 00	 mov	 edx, 3
  00110	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00115	e8 00 00 00 00	 call	 compiler_addop
  0011a	85 c0		 test	 eax, eax
  0011c	75 07		 jne	 SHORT $LN13@compiler_c@4
  0011e	33 c0		 xor	 eax, eax
  00120	e9 a6 01 00 00	 jmp	 $LN22@compiler_c@4
$LN13@compiler_c@4:

; 2859 :         ADDOP_I(c, COMPARE_OP,
; 2860 :             cmpop((cmpop_ty)(asdl_seq_GET(
; 2861 :                                       e->v.Compare.ops, i - 1))));

  00125	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0012a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0012e	8b 4c 24 2c	 mov	 ecx, DWORD PTR i$[rsp]
  00132	ff c9		 dec	 ecx
  00134	48 63 c9	 movsxd	 rcx, ecx
  00137	8b 4c 88 08	 mov	 ecx, DWORD PTR [rax+rcx*4+8]
  0013b	e8 00 00 00 00	 call	 cmpop
  00140	44 8b c0	 mov	 r8d, eax
  00143	ba 6b 00 00 00	 mov	 edx, 107		; 0000006bH
  00148	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0014d	e8 00 00 00 00	 call	 compiler_addop_i
  00152	85 c0		 test	 eax, eax
  00154	75 07		 jne	 SHORT $LN12@compiler_c@4
  00156	33 c0		 xor	 eax, eax
  00158	e9 6e 01 00 00	 jmp	 $LN22@compiler_c@4
$LN12@compiler_c@4:

; 2862 :         ADDOP_JABS(c, JUMP_IF_FALSE_OR_POP, cleanup);

  0015d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00163	4c 8b 44 24 20	 mov	 r8, QWORD PTR cleanup$[rsp]
  00168	ba 6f 00 00 00	 mov	 edx, 111		; 0000006fH
  0016d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00172	e8 00 00 00 00	 call	 compiler_addop_j
  00177	85 c0		 test	 eax, eax
  00179	75 07		 jne	 SHORT $LN11@compiler_c@4
  0017b	33 c0		 xor	 eax, eax
  0017d	e9 49 01 00 00	 jmp	 $LN22@compiler_c@4
$LN11@compiler_c@4:

; 2863 :         NEXT_BLOCK(c);

  00182	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00187	e8 00 00 00 00	 call	 compiler_next_block
  0018c	48 85 c0	 test	 rax, rax
  0018f	75 07		 jne	 SHORT $LN10@compiler_c@4
  00191	33 c0		 xor	 eax, eax
  00193	e9 33 01 00 00	 jmp	 $LN22@compiler_c@4
$LN10@compiler_c@4:

; 2864 :         if (i < (n - 1))

  00198	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  0019c	ff c8		 dec	 eax
  0019e	39 44 24 2c	 cmp	 DWORD PTR i$[rsp], eax
  001a2	7d 28		 jge	 SHORT $LN9@compiler_c@4

; 2865 :             VISIT(c, expr,
; 2866 :                 (expr_ty)asdl_seq_GET(e->v.Compare.comparators, i));

  001a4	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  001a9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001ad	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i$[rsp]
  001b2	48 8b 54 c8 08	 mov	 rdx, QWORD PTR [rax+rcx*8+8]
  001b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  001bc	e8 00 00 00 00	 call	 compiler_visit_expr
  001c1	85 c0		 test	 eax, eax
  001c3	75 07		 jne	 SHORT $LN8@compiler_c@4
  001c5	33 c0		 xor	 eax, eax
  001c7	e9 ff 00 00 00	 jmp	 $LN22@compiler_c@4
$LN8@compiler_c@4:
$LN9@compiler_c@4:

; 2867 :     }

  001cc	e9 08 ff ff ff	 jmp	 $LN16@compiler_c@4
$LN15@compiler_c@4:

; 2868 :     VISIT(c, expr, (expr_ty)asdl_seq_GET(e->v.Compare.comparators, n - 1));

  001d1	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  001d6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001da	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  001de	ff c9		 dec	 ecx
  001e0	48 63 c9	 movsxd	 rcx, ecx
  001e3	48 8b 54 c8 08	 mov	 rdx, QWORD PTR [rax+rcx*8+8]
  001e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  001ed	e8 00 00 00 00	 call	 compiler_visit_expr
  001f2	85 c0		 test	 eax, eax
  001f4	75 07		 jne	 SHORT $LN7@compiler_c@4
  001f6	33 c0		 xor	 eax, eax
  001f8	e9 ce 00 00 00	 jmp	 $LN22@compiler_c@4
$LN7@compiler_c@4:

; 2869 :     ADDOP_I(c, COMPARE_OP,
; 2870 :            cmpop((cmpop_ty)(asdl_seq_GET(e->v.Compare.ops, n - 1))));

  001fd	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  00202	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00206	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  0020a	ff c9		 dec	 ecx
  0020c	48 63 c9	 movsxd	 rcx, ecx
  0020f	8b 4c 88 08	 mov	 ecx, DWORD PTR [rax+rcx*4+8]
  00213	e8 00 00 00 00	 call	 cmpop
  00218	44 8b c0	 mov	 r8d, eax
  0021b	ba 6b 00 00 00	 mov	 edx, 107		; 0000006bH
  00220	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00225	e8 00 00 00 00	 call	 compiler_addop_i
  0022a	85 c0		 test	 eax, eax
  0022c	75 07		 jne	 SHORT $LN6@compiler_c@4
  0022e	33 c0		 xor	 eax, eax
  00230	e9 96 00 00 00	 jmp	 $LN22@compiler_c@4
$LN6@compiler_c@4:

; 2871 :     if (n > 1) {

  00235	83 7c 24 28 01	 cmp	 DWORD PTR n$[rsp], 1
  0023a	0f 8e 86 00 00
	00		 jle	 $LN5@compiler_c@4

; 2872 :         basicblock *end = compiler_new_block(c);

  00240	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00245	e8 00 00 00 00	 call	 compiler_new_block
  0024a	48 89 44 24 30	 mov	 QWORD PTR end$24433[rsp], rax

; 2873 :         if (end == NULL)

  0024f	48 83 7c 24 30
	00		 cmp	 QWORD PTR end$24433[rsp], 0
  00255	75 04		 jne	 SHORT $LN4@compiler_c@4

; 2874 :             return 0;

  00257	33 c0		 xor	 eax, eax
  00259	eb 70		 jmp	 SHORT $LN22@compiler_c@4
$LN4@compiler_c@4:

; 2875 :         ADDOP_JREL(c, JUMP_FORWARD, end);

  0025b	45 33 c9	 xor	 r9d, r9d
  0025e	4c 8b 44 24 30	 mov	 r8, QWORD PTR end$24433[rsp]
  00263	ba 6e 00 00 00	 mov	 edx, 110		; 0000006eH
  00268	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0026d	e8 00 00 00 00	 call	 compiler_addop_j
  00272	85 c0		 test	 eax, eax
  00274	75 04		 jne	 SHORT $LN3@compiler_c@4
  00276	33 c0		 xor	 eax, eax
  00278	eb 51		 jmp	 SHORT $LN22@compiler_c@4
$LN3@compiler_c@4:

; 2876 :         compiler_use_next_block(c, cleanup);

  0027a	48 8b 54 24 20	 mov	 rdx, QWORD PTR cleanup$[rsp]
  0027f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00284	e8 00 00 00 00	 call	 compiler_use_next_block

; 2877 :         ADDOP(c, ROT_TWO);

  00289	ba 02 00 00 00	 mov	 edx, 2
  0028e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00293	e8 00 00 00 00	 call	 compiler_addop
  00298	85 c0		 test	 eax, eax
  0029a	75 04		 jne	 SHORT $LN2@compiler_c@4
  0029c	33 c0		 xor	 eax, eax
  0029e	eb 2b		 jmp	 SHORT $LN22@compiler_c@4
$LN2@compiler_c@4:

; 2878 :         ADDOP(c, POP_TOP);

  002a0	ba 01 00 00 00	 mov	 edx, 1
  002a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  002aa	e8 00 00 00 00	 call	 compiler_addop
  002af	85 c0		 test	 eax, eax
  002b1	75 04		 jne	 SHORT $LN1@compiler_c@4
  002b3	33 c0		 xor	 eax, eax
  002b5	eb 14		 jmp	 SHORT $LN22@compiler_c@4
$LN1@compiler_c@4:

; 2879 :         compiler_use_next_block(c, end);

  002b7	48 8b 54 24 30	 mov	 rdx, QWORD PTR end$24433[rsp]
  002bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  002c1	e8 00 00 00 00	 call	 compiler_use_next_block
$LN5@compiler_c@4:

; 2880 :     }
; 2881 :     return 1;

  002c6	b8 01 00 00 00	 mov	 eax, 1
$LN22@compiler_c@4:

; 2882 : }

  002cb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002cf	c3		 ret	 0
compiler_compare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_next_block DD imagerel compiler_next_block
	DD	imagerel compiler_next_block+86
	DD	imagerel $unwind$compiler_next_block
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_next_block DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_next_block
_TEXT	SEGMENT
block$ = 32
c$ = 64
compiler_next_block PROC				; COMDAT

; 698  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 699  :     basicblock *block = compiler_new_block(c);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0000e	e8 00 00 00 00	 call	 compiler_new_block
  00013	48 89 44 24 20	 mov	 QWORD PTR block$[rsp], rax

; 700  :     if (block == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR block$[rsp], 0
  0001e	75 04		 jne	 SHORT $LN1@compiler_n@4

; 701  :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	eb 2d		 jmp	 SHORT $LN2@compiler_n@4
$LN1@compiler_n@4:

; 702  :     c->u->u_curblock->b_next = block;

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00029	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0002d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR block$[rsp]
  00036	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 703  :     c->u->u_curblock = block;

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0003f	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR block$[rsp]
  00048	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 704  :     return block;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR block$[rsp]
$LN2@compiler_n@4:

; 705  : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
compiler_next_block ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmpop DD	imagerel cmpop
	DD	imagerel cmpop+172
	DD	imagerel $unwind$cmpop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmpop DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cmpop
_TEXT	SEGMENT
tv64 = 0
op$ = 32
cmpop	PROC						; COMDAT

; 2565 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 2566 :     switch (op) {

  00008	8b 44 24 20	 mov	 eax, DWORD PTR op$[rsp]
  0000c	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  0000f	8b 04 24	 mov	 eax, DWORD PTR tv64[rsp]
  00012	ff c8		 dec	 eax
  00014	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00017	83 3c 24 09	 cmp	 DWORD PTR tv64[rsp], 9
  0001b	77 5a		 ja	 SHORT $LN1@cmpop
  0001d	48 63 04 24	 movsxd	 rax, DWORD PTR tv64[rsp]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00028	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN16@cmpop[rcx+rax*4]
  0002f	48 03 c1	 add	 rax, rcx
  00032	ff e0		 jmp	 rax
$LN11@cmpop:

; 2567 :     case Eq:
; 2568 :         return PyCmp_EQ;

  00034	b8 02 00 00 00	 mov	 eax, 2
  00039	eb 41		 jmp	 SHORT $LN14@cmpop
$LN10@cmpop:

; 2569 :     case NotEq:
; 2570 :         return PyCmp_NE;

  0003b	b8 03 00 00 00	 mov	 eax, 3
  00040	eb 3a		 jmp	 SHORT $LN14@cmpop
$LN9@cmpop:

; 2571 :     case Lt:
; 2572 :         return PyCmp_LT;

  00042	33 c0		 xor	 eax, eax
  00044	eb 36		 jmp	 SHORT $LN14@cmpop
$LN8@cmpop:

; 2573 :     case LtE:
; 2574 :         return PyCmp_LE;

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	eb 2f		 jmp	 SHORT $LN14@cmpop
$LN7@cmpop:

; 2575 :     case Gt:
; 2576 :         return PyCmp_GT;

  0004d	b8 04 00 00 00	 mov	 eax, 4
  00052	eb 28		 jmp	 SHORT $LN14@cmpop
$LN6@cmpop:

; 2577 :     case GtE:
; 2578 :         return PyCmp_GE;

  00054	b8 05 00 00 00	 mov	 eax, 5
  00059	eb 21		 jmp	 SHORT $LN14@cmpop
$LN5@cmpop:

; 2579 :     case Is:
; 2580 :         return PyCmp_IS;

  0005b	b8 08 00 00 00	 mov	 eax, 8
  00060	eb 1a		 jmp	 SHORT $LN14@cmpop
$LN4@cmpop:

; 2581 :     case IsNot:
; 2582 :         return PyCmp_IS_NOT;

  00062	b8 09 00 00 00	 mov	 eax, 9
  00067	eb 13		 jmp	 SHORT $LN14@cmpop
$LN3@cmpop:

; 2583 :     case In:
; 2584 :         return PyCmp_IN;

  00069	b8 06 00 00 00	 mov	 eax, 6
  0006e	eb 0c		 jmp	 SHORT $LN14@cmpop
$LN2@cmpop:

; 2585 :     case NotIn:
; 2586 :         return PyCmp_NOT_IN;

  00070	b8 07 00 00 00	 mov	 eax, 7
  00075	eb 05		 jmp	 SHORT $LN14@cmpop
$LN1@cmpop:

; 2587 :     default:
; 2588 :         return PyCmp_BAD;

  00077	b8 0b 00 00 00	 mov	 eax, 11
$LN14@cmpop:

; 2589 :     }
; 2590 : }

  0007c	48 83 c4 18	 add	 rsp, 24
  00080	c3		 ret	 0
  00081	0f 1f 00	 npad	 3
$LN16@cmpop:
  00084	00 00 00 00	 DD	 $LN11@cmpop
  00088	00 00 00 00	 DD	 $LN10@cmpop
  0008c	00 00 00 00	 DD	 $LN9@cmpop
  00090	00 00 00 00	 DD	 $LN8@cmpop
  00094	00 00 00 00	 DD	 $LN7@cmpop
  00098	00 00 00 00	 DD	 $LN6@cmpop
  0009c	00 00 00 00	 DD	 $LN5@cmpop
  000a0	00 00 00 00	 DD	 $LN4@cmpop
  000a4	00 00 00 00	 DD	 $LN3@cmpop
  000a8	00 00 00 00	 DD	 $LN2@cmpop
cmpop	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_call DD imagerel compiler_call
	DD	imagerel compiler_call+104
	DD	imagerel $unwind$compiler_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_call DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_call
_TEXT	SEGMENT
c$ = 64
e$ = 72
compiler_call PROC					; COMDAT

; 2886 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2887 :     VISIT(c, expr, e->v.Call.func);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  00013	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0001c	e8 00 00 00 00	 call	 compiler_visit_expr
  00021	85 c0		 test	 eax, eax
  00023	75 04		 jne	 SHORT $LN1@compiler_c@5
  00025	33 c0		 xor	 eax, eax
  00027	eb 3a		 jmp	 SHORT $LN2@compiler_c@5
$LN1@compiler_c@5:

; 2888 :     return compiler_call_helper(c, 0,
; 2889 :                                 e->v.Call.args,
; 2890 :                                 e->v.Call.keywords,
; 2891 :                                 e->v.Call.starargs,
; 2892 :                                 e->v.Call.kwargs);

  00029	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  0002e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00032	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  0003c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00040	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  0004a	4c 8b 48 18	 mov	 r9, QWORD PTR [rax+24]
  0004e	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  00053	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  00057	33 d2		 xor	 edx, edx
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0005e	e8 00 00 00 00	 call	 compiler_call_helper
$LN2@compiler_c@5:

; 2893 : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
compiler_call ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DK@JLNCNOB@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAE?$AAx?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_09PJCOLCAN@?$DMgenexpr?$DO?$AA@		; `string'
_BSS	SEGMENT
?name@?1??compiler_genexp@@9@9 DQ 01H DUP (?)		; `compiler_genexp'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_genexp DD imagerel compiler_genexp
	DD	imagerel compiler_genexp+162
	DD	imagerel $unwind$compiler_genexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_genexp DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1DK@JLNCNOB@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAE?$AAx?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@JLNCNOB@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAE?$AAx?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'G', 00H, 'e', 00H, 'n'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'E', 00H, 'x', 00H, 'p', 00H, '_', 00H, 'k', 00H, 'i', 00H, 'n'
	DB	00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJCOLCAN@?$DMgenexpr?$DO?$AA@
CONST	SEGMENT
??_C@_09PJCOLCAN@?$DMgenexpr?$DO?$AA@ DB '<genexpr>', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_genexp
_TEXT	SEGMENT
c$ = 80
e$ = 88
compiler_genexp PROC					; COMDAT

; 3112 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3113 :     static identifier name;
; 3114 :     if (!name) {

  0000e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name@?1??compiler_genexp@@9@9, 0
  00016	75 21		 jne	 SHORT $LN2@compiler_g

; 3115 :         name = PyUnicode_FromString("<genexpr>");

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09PJCOLCAN@?$DMgenexpr?$DO?$AA@
  0001f	e8 00 00 00 00	 call	 PyUnicode_FromString
  00024	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name@?1??compiler_genexp@@9@9, rax

; 3116 :         if (!name)

  0002b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name@?1??compiler_genexp@@9@9, 0
  00033	75 04		 jne	 SHORT $LN1@compiler_g

; 3117 :             return 0;

  00035	33 c0		 xor	 eax, eax
  00037	eb 64		 jmp	 SHORT $LN3@compiler_g
$LN1@compiler_g:
$LN2@compiler_g:

; 3118 :     }
; 3119 :     assert(e->kind == GeneratorExp_kind);

  00039	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0003e	83 38 0b	 cmp	 DWORD PTR [rax], 11
  00041	74 1c		 je	 SHORT $LN5@compiler_g
  00043	41 b8 2f 0c 00
	00		 mov	 r8d, 3119		; 00000c2fH
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@JLNCNOB@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAE?$AAx?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005d	33 c0		 xor	 eax, eax
$LN5@compiler_g:

; 3120 :     return compiler_comprehension(c, e, COMP_GENEXP, name,
; 3121 :                                   e->v.GeneratorExp.generators,
; 3122 :                                   e->v.GeneratorExp.elt, NULL);

  0005f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00068	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0006d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00071	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00076	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0007b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00084	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?name@?1??compiler_genexp@@9@9
  0008b	45 33 c0	 xor	 r8d, r8d
  0008e	48 8b 54 24 58	 mov	 rdx, QWORD PTR e$[rsp]
  00093	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00098	e8 00 00 00 00	 call	 compiler_comprehension
$LN3@compiler_g:

; 3123 : }

  0009d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a1	c3		 ret	 0
compiler_genexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@NJACIMDF@unknown?5comprehension?5type?5?$CFd?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_comprehension DD imagerel compiler_comprehension
	DD	imagerel compiler_comprehension+589
	DD	imagerel $unwind$compiler_comprehension
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_comprehension DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT ??_C@_0BO@NJACIMDF@unknown?5comprehension?5type?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@NJACIMDF@unknown?5comprehension?5type?5?$CFd?$AA@ DB 'unknown c'
	DB	'omprehension type %d', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_comprehension
_TEXT	SEGMENT
outermost_iter$ = 48
co$ = 56
qualname$ = 64
op$24595 = 72
tv76 = 76
c$ = 96
e$ = 104
type$ = 112
name$ = 120
generators$ = 128
elt$ = 136
val$ = 144
compiler_comprehension PROC				; COMDAT

; 3046 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3047 :     PyCodeObject *co = NULL;

  00018	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR co$[rsp], 0

; 3048 :     expr_ty outermost_iter;
; 3049 :     PyObject *qualname = NULL;

  00021	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR qualname$[rsp], 0

; 3050 : 
; 3051 :     outermost_iter = ((comprehension_ty)
; 3052 :                       asdl_seq_GET(generators, 0))->iter;

  0002a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR generators$[rsp]
  00032	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00036	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003a	48 89 44 24 30	 mov	 QWORD PTR outermost_iter$[rsp], rax

; 3053 : 
; 3054 :     if (!compiler_enter_scope(c, name, COMPILER_SCOPE_COMPREHENSION,
; 3055 :                               (void *)e, e->lineno))

  0003f	48 8b 44 24 68	 mov	 rax, QWORD PTR e$[rsp]
  00044	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00047	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR e$[rsp]
  00050	41 b8 03 00 00
	00		 mov	 r8d, 3
  00056	48 8b 54 24 78	 mov	 rdx, QWORD PTR name$[rsp]
  0005b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00060	e8 00 00 00 00	 call	 compiler_enter_scope
  00065	85 c0		 test	 eax, eax
  00067	75 05		 jne	 SHORT $LN26@compiler_c@6

; 3056 :         goto error;

  00069	e9 a8 01 00 00	 jmp	 $error$24593
$LN26@compiler_c@6:

; 3057 : 
; 3058 :     if (type != COMP_GENEXP) {

  0006e	83 7c 24 70 00	 cmp	 DWORD PTR type$[rsp], 0
  00073	74 76		 je	 SHORT $LN25@compiler_c@6

; 3059 :         int op;
; 3060 :         switch (type) {

  00075	8b 44 24 70	 mov	 eax, DWORD PTR type$[rsp]
  00079	89 44 24 4c	 mov	 DWORD PTR tv76[rsp], eax
  0007d	83 7c 24 4c 01	 cmp	 DWORD PTR tv76[rsp], 1
  00082	74 10		 je	 SHORT $LN22@compiler_c@6
  00084	83 7c 24 4c 02	 cmp	 DWORD PTR tv76[rsp], 2
  00089	74 13		 je	 SHORT $LN21@compiler_c@6
  0008b	83 7c 24 4c 03	 cmp	 DWORD PTR tv76[rsp], 3
  00090	74 16		 je	 SHORT $LN20@compiler_c@6
  00092	eb 1e		 jmp	 SHORT $LN19@compiler_c@6
$LN22@compiler_c@6:

; 3061 :         case COMP_LISTCOMP:
; 3062 :             op = BUILD_LIST;

  00094	c7 44 24 48 67
	00 00 00	 mov	 DWORD PTR op$24595[rsp], 103 ; 00000067H

; 3063 :             break;

  0009c	eb 31		 jmp	 SHORT $LN23@compiler_c@6
$LN21@compiler_c@6:

; 3064 :         case COMP_SETCOMP:
; 3065 :             op = BUILD_SET;

  0009e	c7 44 24 48 68
	00 00 00	 mov	 DWORD PTR op$24595[rsp], 104 ; 00000068H

; 3066 :             break;

  000a6	eb 27		 jmp	 SHORT $LN23@compiler_c@6
$LN20@compiler_c@6:

; 3067 :         case COMP_DICTCOMP:
; 3068 :             op = BUILD_MAP;

  000a8	c7 44 24 48 69
	00 00 00	 mov	 DWORD PTR op$24595[rsp], 105 ; 00000069H

; 3069 :             break;

  000b0	eb 1d		 jmp	 SHORT $LN23@compiler_c@6
$LN19@compiler_c@6:

; 3070 :         default:
; 3071 :             PyErr_Format(PyExc_SystemError,
; 3072 :                          "unknown comprehension type %d", type);

  000b2	44 8b 44 24 70	 mov	 r8d, DWORD PTR type$[rsp]
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJACIMDF@unknown?5comprehension?5type?5?$CFd?$AA@
  000be	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000c5	e8 00 00 00 00	 call	 PyErr_Format

; 3073 :             goto error_in_scope;

  000ca	e9 3d 01 00 00	 jmp	 $error_in_scope$24605
$LN23@compiler_c@6:

; 3074 :         }
; 3075 : 
; 3076 :         ADDOP_I(c, op, 0);

  000cf	45 33 c0	 xor	 r8d, r8d
  000d2	8b 54 24 48	 mov	 edx, DWORD PTR op$24595[rsp]
  000d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000db	e8 00 00 00 00	 call	 compiler_addop_i
  000e0	85 c0		 test	 eax, eax
  000e2	75 07		 jne	 SHORT $LN18@compiler_c@6
  000e4	33 c0		 xor	 eax, eax
  000e6	e9 5d 01 00 00	 jmp	 $LN27@compiler_c@6
$LN18@compiler_c@6:
$LN25@compiler_c@6:

; 3077 :     }
; 3078 : 
; 3079 :     if (!compiler_comprehension_generator(c, generators, 0, elt,
; 3080 :                                           val, type))

  000eb	8b 44 24 70	 mov	 eax, DWORD PTR type$[rsp]
  000ef	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000f3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR val$[rsp]
  000fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00100	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR elt$[rsp]
  00108	45 33 c0	 xor	 r8d, r8d
  0010b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR generators$[rsp]
  00113	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00118	e8 00 00 00 00	 call	 compiler_comprehension_generator
  0011d	85 c0		 test	 eax, eax
  0011f	75 05		 jne	 SHORT $LN17@compiler_c@6

; 3081 :         goto error_in_scope;

  00121	e9 e6 00 00 00	 jmp	 $error_in_scope$24605
$LN17@compiler_c@6:

; 3082 : 
; 3083 :     if (type != COMP_GENEXP) {

  00126	83 7c 24 70 00	 cmp	 DWORD PTR type$[rsp], 0
  0012b	74 1a		 je	 SHORT $LN16@compiler_c@6

; 3084 :         ADDOP(c, RETURN_VALUE);

  0012d	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  00132	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00137	e8 00 00 00 00	 call	 compiler_addop
  0013c	85 c0		 test	 eax, eax
  0013e	75 07		 jne	 SHORT $LN15@compiler_c@6
  00140	33 c0		 xor	 eax, eax
  00142	e9 01 01 00 00	 jmp	 $LN27@compiler_c@6
$LN15@compiler_c@6:
$LN16@compiler_c@6:

; 3085 :     }
; 3086 : 
; 3087 :     co = assemble(c, 1);

  00147	ba 01 00 00 00	 mov	 edx, 1
  0014c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00151	e8 00 00 00 00	 call	 assemble
  00156	48 89 44 24 38	 mov	 QWORD PTR co$[rsp], rax

; 3088 :     qualname = compiler_scope_qualname(c);

  0015b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00160	e8 00 00 00 00	 call	 compiler_scope_qualname
  00165	48 89 44 24 40	 mov	 QWORD PTR qualname$[rsp], rax

; 3089 :     compiler_exit_scope(c);

  0016a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0016f	e8 00 00 00 00	 call	 compiler_exit_scope

; 3090 :     if (qualname == NULL || co == NULL)

  00174	48 83 7c 24 40
	00		 cmp	 QWORD PTR qualname$[rsp], 0
  0017a	74 08		 je	 SHORT $LN13@compiler_c@6
  0017c	48 83 7c 24 38
	00		 cmp	 QWORD PTR co$[rsp], 0
  00182	75 05		 jne	 SHORT $LN14@compiler_c@6
$LN13@compiler_c@6:

; 3091 :         goto error;

  00184	e9 8d 00 00 00	 jmp	 $error$24593
$LN14@compiler_c@6:

; 3092 : 
; 3093 :     if (!compiler_make_closure(c, co, 0, qualname))

  00189	4c 8b 4c 24 40	 mov	 r9, QWORD PTR qualname$[rsp]
  0018e	45 33 c0	 xor	 r8d, r8d
  00191	48 8b 54 24 38	 mov	 rdx, QWORD PTR co$[rsp]
  00196	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0019b	e8 00 00 00 00	 call	 compiler_make_closure
  001a0	85 c0		 test	 eax, eax
  001a2	75 02		 jne	 SHORT $LN12@compiler_c@6

; 3094 :         goto error;

  001a4	eb 70		 jmp	 SHORT $error$24593
$LN12@compiler_c@6:

; 3095 :     Py_DECREF(qualname);

  001a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR qualname$[rsp]
  001ab	e8 00 00 00 00	 call	 _Py_DecRef

; 3096 :     Py_DECREF(co);

  001b0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR co$[rsp]
  001b5	e8 00 00 00 00	 call	 _Py_DecRef

; 3097 : 
; 3098 :     VISIT(c, expr, outermost_iter);

  001ba	48 8b 54 24 30	 mov	 rdx, QWORD PTR outermost_iter$[rsp]
  001bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001c4	e8 00 00 00 00	 call	 compiler_visit_expr
  001c9	85 c0		 test	 eax, eax
  001cb	75 04		 jne	 SHORT $LN11@compiler_c@6
  001cd	33 c0		 xor	 eax, eax
  001cf	eb 77		 jmp	 SHORT $LN27@compiler_c@6
$LN11@compiler_c@6:

; 3099 :     ADDOP(c, GET_ITER);

  001d1	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001db	e8 00 00 00 00	 call	 compiler_addop
  001e0	85 c0		 test	 eax, eax
  001e2	75 04		 jne	 SHORT $LN10@compiler_c@6
  001e4	33 c0		 xor	 eax, eax
  001e6	eb 60		 jmp	 SHORT $LN27@compiler_c@6
$LN10@compiler_c@6:

; 3100 :     ADDOP_I(c, CALL_FUNCTION, 1);

  001e8	41 b8 01 00 00
	00		 mov	 r8d, 1
  001ee	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  001f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001f8	e8 00 00 00 00	 call	 compiler_addop_i
  001fd	85 c0		 test	 eax, eax
  001ff	75 04		 jne	 SHORT $LN9@compiler_c@6
  00201	33 c0		 xor	 eax, eax
  00203	eb 43		 jmp	 SHORT $LN27@compiler_c@6
$LN9@compiler_c@6:

; 3101 :     return 1;

  00205	b8 01 00 00 00	 mov	 eax, 1
  0020a	eb 3c		 jmp	 SHORT $LN27@compiler_c@6
$error_in_scope$24605:

; 3102 : error_in_scope:
; 3103 :     compiler_exit_scope(c);

  0020c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00211	e8 00 00 00 00	 call	 compiler_exit_scope
$error$24593:
$LN8@compiler_c@6:

; 3104 : error:
; 3105 :     Py_XDECREF(qualname);

  00216	48 83 7c 24 40
	00		 cmp	 QWORD PTR qualname$[rsp], 0
  0021c	74 0a		 je	 SHORT $LN5@compiler_c@6
  0021e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR qualname$[rsp]
  00223	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@compiler_c@6:
  00228	33 c0		 xor	 eax, eax
  0022a	85 c0		 test	 eax, eax
  0022c	75 e8		 jne	 SHORT $LN8@compiler_c@6
$LN4@compiler_c@6:

; 3106 :     Py_XDECREF(co);

  0022e	48 83 7c 24 38
	00		 cmp	 QWORD PTR co$[rsp], 0
  00234	74 0a		 je	 SHORT $LN1@compiler_c@6
  00236	48 8b 4c 24 38	 mov	 rcx, QWORD PTR co$[rsp]
  0023b	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@compiler_c@6:
  00240	33 c0		 xor	 eax, eax
  00242	85 c0		 test	 eax, eax
  00244	75 e8		 jne	 SHORT $LN4@compiler_c@6

; 3107 :     return 0;

  00246	33 c0		 xor	 eax, eax
$LN27@compiler_c@6:

; 3108 : }

  00248	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0024c	c3		 ret	 0
compiler_comprehension ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_comprehension_generator DD imagerel compiler_comprehension_generator
	DD	imagerel compiler_comprehension_generator+1331
	DD	imagerel $unwind$compiler_comprehension_generator
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_comprehension_generator DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_comprehension_generator
_TEXT	SEGMENT
n$ = 48
i$ = 52
anchor$ = 56
if_cleanup$ = 64
skip$ = 72
start$ = 80
gen$ = 88
e$24538 = 96
tv148 = 104
tv173 = 112
tv185 = 120
tv187 = 128
c$ = 160
generators$ = 168
gen_index$ = 176
elt$ = 184
val$ = 192
type$ = 200
compiler_comprehension_generator PROC			; COMDAT

; 2957 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2958 :     /* generate code for the iterator, then each of the ifs,
; 2959 :        and then write to the element */
; 2960 : 
; 2961 :     comprehension_ty gen;
; 2962 :     basicblock *start, *anchor, *skip, *if_cleanup;
; 2963 :     int i, n;
; 2964 : 
; 2965 :     start = compiler_new_block(c);

  0001b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00023	e8 00 00 00 00	 call	 compiler_new_block
  00028	48 89 44 24 50	 mov	 QWORD PTR start$[rsp], rax

; 2966 :     skip = compiler_new_block(c);

  0002d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00035	e8 00 00 00 00	 call	 compiler_new_block
  0003a	48 89 44 24 48	 mov	 QWORD PTR skip$[rsp], rax

; 2967 :     if_cleanup = compiler_new_block(c);

  0003f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00047	e8 00 00 00 00	 call	 compiler_new_block
  0004c	48 89 44 24 40	 mov	 QWORD PTR if_cleanup$[rsp], rax

; 2968 :     anchor = compiler_new_block(c);

  00051	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00059	e8 00 00 00 00	 call	 compiler_new_block
  0005e	48 89 44 24 38	 mov	 QWORD PTR anchor$[rsp], rax

; 2969 : 
; 2970 :     if (start == NULL || skip == NULL || if_cleanup == NULL ||
; 2971 :         anchor == NULL)

  00063	48 83 7c 24 50
	00		 cmp	 QWORD PTR start$[rsp], 0
  00069	74 18		 je	 SHORT $LN36@compiler_c@7
  0006b	48 83 7c 24 48
	00		 cmp	 QWORD PTR skip$[rsp], 0
  00071	74 10		 je	 SHORT $LN36@compiler_c@7
  00073	48 83 7c 24 40
	00		 cmp	 QWORD PTR if_cleanup$[rsp], 0
  00079	74 08		 je	 SHORT $LN36@compiler_c@7
  0007b	48 83 7c 24 38
	00		 cmp	 QWORD PTR anchor$[rsp], 0
  00081	75 07		 jne	 SHORT $LN37@compiler_c@7
$LN36@compiler_c@7:

; 2972 :         return 0;

  00083	33 c0		 xor	 eax, eax
  00085	e9 a1 04 00 00	 jmp	 $LN38@compiler_c@7
$LN37@compiler_c@7:

; 2973 : 
; 2974 :     gen = (comprehension_ty)asdl_seq_GET(generators, gen_index);

  0008a	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR gen_index$[rsp]
  00092	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR generators$[rsp]
  0009a	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  0009f	48 89 44 24 58	 mov	 QWORD PTR gen$[rsp], rax

; 2975 : 
; 2976 :     if (gen_index == 0) {

  000a4	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR gen_index$[rsp], 0
  000ac	75 35		 jne	 SHORT $LN35@compiler_c@7

; 2977 :         /* Receive outermost iter as an implicit argument */
; 2978 :         c->u->u_argcount = 1;

  000ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000b6	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000ba	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [rax+80], 1

; 2979 :         ADDOP_I(c, LOAD_FAST, 0);

  000c1	45 33 c0	 xor	 r8d, r8d
  000c4	ba 7c 00 00 00	 mov	 edx, 124		; 0000007cH
  000c9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000d1	e8 00 00 00 00	 call	 compiler_addop_i
  000d6	85 c0		 test	 eax, eax
  000d8	75 07		 jne	 SHORT $LN34@compiler_c@7
  000da	33 c0		 xor	 eax, eax
  000dc	e9 4a 04 00 00	 jmp	 $LN38@compiler_c@7
$LN34@compiler_c@7:

; 2980 :     }
; 2981 :     else {

  000e1	eb 3e		 jmp	 SHORT $LN33@compiler_c@7
$LN35@compiler_c@7:

; 2982 :         /* Sub-iter - calculate on the fly */
; 2983 :         VISIT(c, expr, gen->iter);

  000e3	48 8b 44 24 58	 mov	 rax, QWORD PTR gen$[rsp]
  000e8	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000ec	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000f4	e8 00 00 00 00	 call	 compiler_visit_expr
  000f9	85 c0		 test	 eax, eax
  000fb	75 07		 jne	 SHORT $LN32@compiler_c@7
  000fd	33 c0		 xor	 eax, eax
  000ff	e9 27 04 00 00	 jmp	 $LN38@compiler_c@7
$LN32@compiler_c@7:

; 2984 :         ADDOP(c, GET_ITER);

  00104	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  00109	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00111	e8 00 00 00 00	 call	 compiler_addop
  00116	85 c0		 test	 eax, eax
  00118	75 07		 jne	 SHORT $LN31@compiler_c@7
  0011a	33 c0		 xor	 eax, eax
  0011c	e9 0a 04 00 00	 jmp	 $LN38@compiler_c@7
$LN31@compiler_c@7:
$LN33@compiler_c@7:

; 2985 :     }
; 2986 :     compiler_use_next_block(c, start);

  00121	48 8b 54 24 50	 mov	 rdx, QWORD PTR start$[rsp]
  00126	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0012e	e8 00 00 00 00	 call	 compiler_use_next_block

; 2987 :     ADDOP_JREL(c, FOR_ITER, anchor);

  00133	45 33 c9	 xor	 r9d, r9d
  00136	4c 8b 44 24 38	 mov	 r8, QWORD PTR anchor$[rsp]
  0013b	ba 5d 00 00 00	 mov	 edx, 93			; 0000005dH
  00140	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00148	e8 00 00 00 00	 call	 compiler_addop_j
  0014d	85 c0		 test	 eax, eax
  0014f	75 07		 jne	 SHORT $LN30@compiler_c@7
  00151	33 c0		 xor	 eax, eax
  00153	e9 d3 03 00 00	 jmp	 $LN38@compiler_c@7
$LN30@compiler_c@7:

; 2988 :     NEXT_BLOCK(c);

  00158	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00160	e8 00 00 00 00	 call	 compiler_next_block
  00165	48 85 c0	 test	 rax, rax
  00168	75 07		 jne	 SHORT $LN29@compiler_c@7
  0016a	33 c0		 xor	 eax, eax
  0016c	e9 ba 03 00 00	 jmp	 $LN38@compiler_c@7
$LN29@compiler_c@7:

; 2989 :     VISIT(c, expr, gen->target);

  00171	48 8b 44 24 58	 mov	 rax, QWORD PTR gen$[rsp]
  00176	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00179	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00181	e8 00 00 00 00	 call	 compiler_visit_expr
  00186	85 c0		 test	 eax, eax
  00188	75 07		 jne	 SHORT $LN28@compiler_c@7
  0018a	33 c0		 xor	 eax, eax
  0018c	e9 9a 03 00 00	 jmp	 $LN38@compiler_c@7
$LN28@compiler_c@7:

; 2990 : 
; 2991 :     /* XXX this needs to be cleaned up...a lot! */
; 2992 :     n = asdl_seq_LEN(gen->ifs);

  00191	48 8b 44 24 58	 mov	 rax, QWORD PTR gen$[rsp]
  00196	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0019b	75 0b		 jne	 SHORT $LN40@compiler_c@7
  0019d	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv148[rsp], 0
  001a6	eb 11		 jmp	 SHORT $LN41@compiler_c@7
$LN40@compiler_c@7:
  001a8	48 8b 44 24 58	 mov	 rax, QWORD PTR gen$[rsp]
  001ad	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001b1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b4	48 89 44 24 68	 mov	 QWORD PTR tv148[rsp], rax
$LN41@compiler_c@7:
  001b9	8b 44 24 68	 mov	 eax, DWORD PTR tv148[rsp]
  001bd	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 2993 :     for (i = 0; i < n; i++) {

  001c1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001c9	eb 0a		 jmp	 SHORT $LN27@compiler_c@7
$LN26@compiler_c@7:
  001cb	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  001cf	ff c0		 inc	 eax
  001d1	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN27@compiler_c@7:
  001d5	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]
  001d9	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  001dd	7d 7b		 jge	 SHORT $LN25@compiler_c@7

; 2994 :         expr_ty e = (expr_ty)asdl_seq_GET(gen->ifs, i);

  001df	48 8b 44 24 58	 mov	 rax, QWORD PTR gen$[rsp]
  001e4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001e8	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  001ed	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  001f2	48 89 44 24 60	 mov	 QWORD PTR e$24538[rsp], rax

; 2995 :         VISIT(c, expr, e);

  001f7	48 8b 54 24 60	 mov	 rdx, QWORD PTR e$24538[rsp]
  001fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00204	e8 00 00 00 00	 call	 compiler_visit_expr
  00209	85 c0		 test	 eax, eax
  0020b	75 07		 jne	 SHORT $LN24@compiler_c@7
  0020d	33 c0		 xor	 eax, eax
  0020f	e9 17 03 00 00	 jmp	 $LN38@compiler_c@7
$LN24@compiler_c@7:

; 2996 :         ADDOP_JABS(c, POP_JUMP_IF_FALSE, if_cleanup);

  00214	41 b9 01 00 00
	00		 mov	 r9d, 1
  0021a	4c 8b 44 24 40	 mov	 r8, QWORD PTR if_cleanup$[rsp]
  0021f	ba 72 00 00 00	 mov	 edx, 114		; 00000072H
  00224	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0022c	e8 00 00 00 00	 call	 compiler_addop_j
  00231	85 c0		 test	 eax, eax
  00233	75 07		 jne	 SHORT $LN23@compiler_c@7
  00235	33 c0		 xor	 eax, eax
  00237	e9 ef 02 00 00	 jmp	 $LN38@compiler_c@7
$LN23@compiler_c@7:

; 2997 :         NEXT_BLOCK(c);

  0023c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00244	e8 00 00 00 00	 call	 compiler_next_block
  00249	48 85 c0	 test	 rax, rax
  0024c	75 07		 jne	 SHORT $LN22@compiler_c@7
  0024e	33 c0		 xor	 eax, eax
  00250	e9 d6 02 00 00	 jmp	 $LN38@compiler_c@7
$LN22@compiler_c@7:

; 2998 :     }

  00255	e9 71 ff ff ff	 jmp	 $LN26@compiler_c@7
$LN25@compiler_c@7:

; 2999 : 
; 3000 :     if (++gen_index < asdl_seq_LEN(generators))

  0025a	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR generators$[rsp], 0
  00263	75 0b		 jne	 SHORT $LN42@compiler_c@7
  00265	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv173[rsp], 0
  0026e	eb 10		 jmp	 SHORT $LN43@compiler_c@7
$LN42@compiler_c@7:
  00270	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR generators$[rsp]
  00278	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0027b	48 89 44 24 70	 mov	 QWORD PTR tv173[rsp], rax
$LN43@compiler_c@7:
  00280	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR gen_index$[rsp]
  00287	ff c0		 inc	 eax
  00289	89 84 24 b0 00
	00 00		 mov	 DWORD PTR gen_index$[rsp], eax
  00290	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR gen_index$[rsp]
  00298	48 3b 44 24 70	 cmp	 rax, QWORD PTR tv173[rsp]
  0029d	7d 48		 jge	 SHORT $LN21@compiler_c@7

; 3001 :         if (!compiler_comprehension_generator(c,
; 3002 :                                               generators, gen_index,
; 3003 :                                               elt, val, type))

  0029f	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR type$[rsp]
  002a6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  002aa	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR val$[rsp]
  002b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b7	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR elt$[rsp]
  002bf	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR gen_index$[rsp]
  002c7	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR generators$[rsp]
  002cf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002d7	e8 00 00 00 00	 call	 compiler_comprehension_generator
  002dc	85 c0		 test	 eax, eax
  002de	75 07		 jne	 SHORT $LN20@compiler_c@7

; 3004 :         return 0;

  002e0	33 c0		 xor	 eax, eax
  002e2	e9 44 02 00 00	 jmp	 $LN38@compiler_c@7
$LN20@compiler_c@7:
$LN21@compiler_c@7:

; 3005 : 
; 3006 :     /* only append after the last for generator */
; 3007 :     if (gen_index >= asdl_seq_LEN(generators)) {

  002e7	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR generators$[rsp], 0
  002f0	75 0b		 jne	 SHORT $LN44@compiler_c@7
  002f2	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv185[rsp], 0
  002fb	eb 10		 jmp	 SHORT $LN45@compiler_c@7
$LN44@compiler_c@7:
  002fd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR generators$[rsp]
  00305	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00308	48 89 44 24 78	 mov	 QWORD PTR tv185[rsp], rax
$LN45@compiler_c@7:
  0030d	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR gen_index$[rsp]
  00315	48 3b 44 24 78	 cmp	 rax, QWORD PTR tv185[rsp]
  0031a	0f 8c bd 01 00
	00		 jl	 $LN19@compiler_c@7

; 3008 :         /* comprehension specific code */
; 3009 :         switch (type) {

  00320	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR type$[rsp]
  00327	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv187[rsp], eax
  0032e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv187[rsp], 0
  00336	74 2f		 je	 SHORT $LN16@compiler_c@7
  00338	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR tv187[rsp], 1
  00340	0f 84 80 00 00
	00		 je	 $LN12@compiler_c@7
  00346	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR tv187[rsp], 2
  0034e	0f 84 c0 00 00
	00		 je	 $LN9@compiler_c@7
  00354	83 bc 24 80 00
	00 00 03	 cmp	 DWORD PTR tv187[rsp], 3
  0035c	0f 84 fd 00 00
	00		 je	 $LN6@compiler_c@7
  00362	e9 60 01 00 00	 jmp	 $LN2@compiler_c@7
$LN16@compiler_c@7:

; 3010 :         case COMP_GENEXP:
; 3011 :             VISIT(c, expr, elt);

  00367	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR elt$[rsp]
  0036f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00377	e8 00 00 00 00	 call	 compiler_visit_expr
  0037c	85 c0		 test	 eax, eax
  0037e	75 07		 jne	 SHORT $LN15@compiler_c@7
  00380	33 c0		 xor	 eax, eax
  00382	e9 a4 01 00 00	 jmp	 $LN38@compiler_c@7
$LN15@compiler_c@7:

; 3012 :             ADDOP(c, YIELD_VALUE);

  00387	ba 56 00 00 00	 mov	 edx, 86			; 00000056H
  0038c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00394	e8 00 00 00 00	 call	 compiler_addop
  00399	85 c0		 test	 eax, eax
  0039b	75 07		 jne	 SHORT $LN14@compiler_c@7
  0039d	33 c0		 xor	 eax, eax
  0039f	e9 87 01 00 00	 jmp	 $LN38@compiler_c@7
$LN14@compiler_c@7:

; 3013 :             ADDOP(c, POP_TOP);

  003a4	ba 01 00 00 00	 mov	 edx, 1
  003a9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003b1	e8 00 00 00 00	 call	 compiler_addop
  003b6	85 c0		 test	 eax, eax
  003b8	75 07		 jne	 SHORT $LN13@compiler_c@7
  003ba	33 c0		 xor	 eax, eax
  003bc	e9 6a 01 00 00	 jmp	 $LN38@compiler_c@7
$LN13@compiler_c@7:

; 3014 :             break;

  003c1	e9 05 01 00 00	 jmp	 $LN17@compiler_c@7
$LN12@compiler_c@7:

; 3015 :         case COMP_LISTCOMP:
; 3016 :             VISIT(c, expr, elt);

  003c6	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR elt$[rsp]
  003ce	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003d6	e8 00 00 00 00	 call	 compiler_visit_expr
  003db	85 c0		 test	 eax, eax
  003dd	75 07		 jne	 SHORT $LN11@compiler_c@7
  003df	33 c0		 xor	 eax, eax
  003e1	e9 45 01 00 00	 jmp	 $LN38@compiler_c@7
$LN11@compiler_c@7:

; 3017 :             ADDOP_I(c, LIST_APPEND, gen_index + 1);

  003e6	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR gen_index$[rsp]
  003ed	ff c0		 inc	 eax
  003ef	44 8b c0	 mov	 r8d, eax
  003f2	ba 91 00 00 00	 mov	 edx, 145		; 00000091H
  003f7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003ff	e8 00 00 00 00	 call	 compiler_addop_i
  00404	85 c0		 test	 eax, eax
  00406	75 07		 jne	 SHORT $LN10@compiler_c@7
  00408	33 c0		 xor	 eax, eax
  0040a	e9 1c 01 00 00	 jmp	 $LN38@compiler_c@7
$LN10@compiler_c@7:

; 3018 :             break;

  0040f	e9 b7 00 00 00	 jmp	 $LN17@compiler_c@7
$LN9@compiler_c@7:

; 3019 :         case COMP_SETCOMP:
; 3020 :             VISIT(c, expr, elt);

  00414	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR elt$[rsp]
  0041c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00424	e8 00 00 00 00	 call	 compiler_visit_expr
  00429	85 c0		 test	 eax, eax
  0042b	75 07		 jne	 SHORT $LN8@compiler_c@7
  0042d	33 c0		 xor	 eax, eax
  0042f	e9 f7 00 00 00	 jmp	 $LN38@compiler_c@7
$LN8@compiler_c@7:

; 3021 :             ADDOP_I(c, SET_ADD, gen_index + 1);

  00434	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR gen_index$[rsp]
  0043b	ff c0		 inc	 eax
  0043d	44 8b c0	 mov	 r8d, eax
  00440	ba 92 00 00 00	 mov	 edx, 146		; 00000092H
  00445	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0044d	e8 00 00 00 00	 call	 compiler_addop_i
  00452	85 c0		 test	 eax, eax
  00454	75 07		 jne	 SHORT $LN7@compiler_c@7
  00456	33 c0		 xor	 eax, eax
  00458	e9 ce 00 00 00	 jmp	 $LN38@compiler_c@7
$LN7@compiler_c@7:

; 3022 :             break;

  0045d	eb 6c		 jmp	 SHORT $LN17@compiler_c@7
$LN6@compiler_c@7:

; 3023 :         case COMP_DICTCOMP:
; 3024 :             /* With 'd[k] = v', v is evaluated before k, so we do
; 3025 :                the same. */
; 3026 :             VISIT(c, expr, val);

  0045f	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR val$[rsp]
  00467	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0046f	e8 00 00 00 00	 call	 compiler_visit_expr
  00474	85 c0		 test	 eax, eax
  00476	75 07		 jne	 SHORT $LN5@compiler_c@7
  00478	33 c0		 xor	 eax, eax
  0047a	e9 ac 00 00 00	 jmp	 $LN38@compiler_c@7
$LN5@compiler_c@7:

; 3027 :             VISIT(c, expr, elt);

  0047f	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR elt$[rsp]
  00487	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0048f	e8 00 00 00 00	 call	 compiler_visit_expr
  00494	85 c0		 test	 eax, eax
  00496	75 07		 jne	 SHORT $LN4@compiler_c@7
  00498	33 c0		 xor	 eax, eax
  0049a	e9 8c 00 00 00	 jmp	 $LN38@compiler_c@7
$LN4@compiler_c@7:

; 3028 :             ADDOP_I(c, MAP_ADD, gen_index + 1);

  0049f	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR gen_index$[rsp]
  004a6	ff c0		 inc	 eax
  004a8	44 8b c0	 mov	 r8d, eax
  004ab	ba 93 00 00 00	 mov	 edx, 147		; 00000093H
  004b0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  004b8	e8 00 00 00 00	 call	 compiler_addop_i
  004bd	85 c0		 test	 eax, eax
  004bf	75 04		 jne	 SHORT $LN3@compiler_c@7
  004c1	33 c0		 xor	 eax, eax
  004c3	eb 66		 jmp	 SHORT $LN38@compiler_c@7
$LN3@compiler_c@7:

; 3029 :             break;

  004c5	eb 04		 jmp	 SHORT $LN17@compiler_c@7
$LN2@compiler_c@7:

; 3030 :         default:
; 3031 :             return 0;

  004c7	33 c0		 xor	 eax, eax
  004c9	eb 60		 jmp	 SHORT $LN38@compiler_c@7
$LN17@compiler_c@7:

; 3032 :         }
; 3033 : 
; 3034 :         compiler_use_next_block(c, skip);

  004cb	48 8b 54 24 48	 mov	 rdx, QWORD PTR skip$[rsp]
  004d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  004d8	e8 00 00 00 00	 call	 compiler_use_next_block
$LN19@compiler_c@7:

; 3035 :     }
; 3036 :     compiler_use_next_block(c, if_cleanup);

  004dd	48 8b 54 24 40	 mov	 rdx, QWORD PTR if_cleanup$[rsp]
  004e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  004ea	e8 00 00 00 00	 call	 compiler_use_next_block

; 3037 :     ADDOP_JABS(c, JUMP_ABSOLUTE, start);

  004ef	41 b9 01 00 00
	00		 mov	 r9d, 1
  004f5	4c 8b 44 24 50	 mov	 r8, QWORD PTR start$[rsp]
  004fa	ba 71 00 00 00	 mov	 edx, 113		; 00000071H
  004ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00507	e8 00 00 00 00	 call	 compiler_addop_j
  0050c	85 c0		 test	 eax, eax
  0050e	75 04		 jne	 SHORT $LN1@compiler_c@7
  00510	33 c0		 xor	 eax, eax
  00512	eb 17		 jmp	 SHORT $LN38@compiler_c@7
$LN1@compiler_c@7:

; 3038 :     compiler_use_next_block(c, anchor);

  00514	48 8b 54 24 38	 mov	 rdx, QWORD PTR anchor$[rsp]
  00519	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00521	e8 00 00 00 00	 call	 compiler_use_next_block

; 3039 : 
; 3040 :     return 1;

  00526	b8 01 00 00 00	 mov	 eax, 1
$LN38@compiler_c@7:

; 3041 : }

  0052b	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00532	c3		 ret	 0
compiler_comprehension_generator ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DC@MCOEIBMJ@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAL?$AAi?$AAs?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_0L@POJBOHBJ@?$DMlistcomp?$DO?$AA@		; `string'
_BSS	SEGMENT
?name@?1??compiler_listcomp@@9@9 DQ 01H DUP (?)		; `compiler_listcomp'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_listcomp DD imagerel compiler_listcomp
	DD	imagerel compiler_listcomp+165
	DD	imagerel $unwind$compiler_listcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_listcomp DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1DC@MCOEIBMJ@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAL?$AAi?$AAs?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@MCOEIBMJ@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAL?$AAi?$AAs?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'L', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, '_', 00H
	DB	'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@POJBOHBJ@?$DMlistcomp?$DO?$AA@
CONST	SEGMENT
??_C@_0L@POJBOHBJ@?$DMlistcomp?$DO?$AA@ DB '<listcomp>', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_listcomp
_TEXT	SEGMENT
c$ = 80
e$ = 88
compiler_listcomp PROC					; COMDAT

; 3127 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3128 :     static identifier name;
; 3129 :     if (!name) {

  0000e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name@?1??compiler_listcomp@@9@9, 0
  00016	75 21		 jne	 SHORT $LN2@compiler_l@4

; 3130 :         name = PyUnicode_FromString("<listcomp>");

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@POJBOHBJ@?$DMlistcomp?$DO?$AA@
  0001f	e8 00 00 00 00	 call	 PyUnicode_FromString
  00024	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name@?1??compiler_listcomp@@9@9, rax

; 3131 :         if (!name)

  0002b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name@?1??compiler_listcomp@@9@9, 0
  00033	75 04		 jne	 SHORT $LN1@compiler_l@4

; 3132 :             return 0;

  00035	33 c0		 xor	 eax, eax
  00037	eb 67		 jmp	 SHORT $LN3@compiler_l@4
$LN1@compiler_l@4:
$LN2@compiler_l@4:

; 3133 :     }
; 3134 :     assert(e->kind == ListComp_kind);

  00039	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0003e	83 38 08	 cmp	 DWORD PTR [rax], 8
  00041	74 1c		 je	 SHORT $LN5@compiler_l@4
  00043	41 b8 3e 0c 00
	00		 mov	 r8d, 3134		; 00000c3eH
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@MCOEIBMJ@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAL?$AAi?$AAs?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005d	33 c0		 xor	 eax, eax
$LN5@compiler_l@4:

; 3135 :     return compiler_comprehension(c, e, COMP_LISTCOMP, name,
; 3136 :                                   e->v.ListComp.generators,
; 3137 :                                   e->v.ListComp.elt, NULL);

  0005f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00068	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0006d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00071	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00076	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0007b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00084	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?name@?1??compiler_listcomp@@9@9
  0008b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00091	48 8b 54 24 58	 mov	 rdx, QWORD PTR e$[rsp]
  00096	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0009b	e8 00 00 00 00	 call	 compiler_comprehension
$LN3@compiler_l@4:

; 3138 : }

  000a0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a4	c3		 ret	 0
compiler_listcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DA@LCIBCCDE@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAe?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_09GOMCJBFD@?$DMsetcomp?$DO?$AA@		; `string'
_BSS	SEGMENT
?name@?1??compiler_setcomp@@9@9 DQ 01H DUP (?)		; `compiler_setcomp'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_setcomp DD imagerel compiler_setcomp
	DD	imagerel compiler_setcomp+165
	DD	imagerel $unwind$compiler_setcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_setcomp DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1DA@LCIBCCDE@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAe?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@LCIBCCDE@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAe?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'e', 00H, 't'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, '_', 00H, 'k', 00H
	DB	'i', 00H, 'n', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GOMCJBFD@?$DMsetcomp?$DO?$AA@
CONST	SEGMENT
??_C@_09GOMCJBFD@?$DMsetcomp?$DO?$AA@ DB '<setcomp>', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_setcomp
_TEXT	SEGMENT
c$ = 80
e$ = 88
compiler_setcomp PROC					; COMDAT

; 3142 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3143 :     static identifier name;
; 3144 :     if (!name) {

  0000e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name@?1??compiler_setcomp@@9@9, 0
  00016	75 21		 jne	 SHORT $LN2@compiler_s@3

; 3145 :         name = PyUnicode_FromString("<setcomp>");

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09GOMCJBFD@?$DMsetcomp?$DO?$AA@
  0001f	e8 00 00 00 00	 call	 PyUnicode_FromString
  00024	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name@?1??compiler_setcomp@@9@9, rax

; 3146 :         if (!name)

  0002b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name@?1??compiler_setcomp@@9@9, 0
  00033	75 04		 jne	 SHORT $LN1@compiler_s@3

; 3147 :             return 0;

  00035	33 c0		 xor	 eax, eax
  00037	eb 67		 jmp	 SHORT $LN3@compiler_s@3
$LN1@compiler_s@3:
$LN2@compiler_s@3:

; 3148 :     }
; 3149 :     assert(e->kind == SetComp_kind);

  00039	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0003e	83 38 09	 cmp	 DWORD PTR [rax], 9
  00041	74 1c		 je	 SHORT $LN5@compiler_s@3
  00043	41 b8 4d 0c 00
	00		 mov	 r8d, 3149		; 00000c4dH
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LCIBCCDE@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAe?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005d	33 c0		 xor	 eax, eax
$LN5@compiler_s@3:

; 3150 :     return compiler_comprehension(c, e, COMP_SETCOMP, name,
; 3151 :                                   e->v.SetComp.generators,
; 3152 :                                   e->v.SetComp.elt, NULL);

  0005f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00068	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0006d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00071	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00076	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0007b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00084	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?name@?1??compiler_setcomp@@9@9
  0008b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00091	48 8b 54 24 58	 mov	 rdx, QWORD PTR e$[rsp]
  00096	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0009b	e8 00 00 00 00	 call	 compiler_comprehension
$LN3@compiler_s@3:

; 3153 : }

  000a0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a4	c3		 ret	 0
compiler_setcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DC@LACABGBM@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAD?$AAi?$AAc?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_0L@JBPNJGMG@?$DMdictcomp?$DO?$AA@		; `string'
_BSS	SEGMENT
?name@?1??compiler_dictcomp@@9@9 DQ 01H DUP (?)		; `compiler_dictcomp'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_dictcomp DD imagerel compiler_dictcomp
	DD	imagerel compiler_dictcomp+170
	DD	imagerel $unwind$compiler_dictcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_dictcomp DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1DC@LACABGBM@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAD?$AAi?$AAc?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@LACABGBM@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAD?$AAi?$AAc?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'D', 00H, 'i', 00H, 'c'
	DB	00H, 't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, '_', 00H
	DB	'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JBPNJGMG@?$DMdictcomp?$DO?$AA@
CONST	SEGMENT
??_C@_0L@JBPNJGMG@?$DMdictcomp?$DO?$AA@ DB '<dictcomp>', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_dictcomp
_TEXT	SEGMENT
c$ = 80
e$ = 88
compiler_dictcomp PROC					; COMDAT

; 3158 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3159 :     static identifier name;
; 3160 :     if (!name) {

  0000e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name@?1??compiler_dictcomp@@9@9, 0
  00016	75 21		 jne	 SHORT $LN2@compiler_d@2

; 3161 :         name = PyUnicode_FromString("<dictcomp>");

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@JBPNJGMG@?$DMdictcomp?$DO?$AA@
  0001f	e8 00 00 00 00	 call	 PyUnicode_FromString
  00024	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name@?1??compiler_dictcomp@@9@9, rax

; 3162 :         if (!name)

  0002b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?name@?1??compiler_dictcomp@@9@9, 0
  00033	75 04		 jne	 SHORT $LN1@compiler_d@2

; 3163 :             return 0;

  00035	33 c0		 xor	 eax, eax
  00037	eb 6c		 jmp	 SHORT $LN3@compiler_d@2
$LN1@compiler_d@2:
$LN2@compiler_d@2:

; 3164 :     }
; 3165 :     assert(e->kind == DictComp_kind);

  00039	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0003e	83 38 0a	 cmp	 DWORD PTR [rax], 10
  00041	74 1c		 je	 SHORT $LN5@compiler_d@2
  00043	41 b8 5d 0c 00
	00		 mov	 r8d, 3165		; 00000c5dH
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@LACABGBM@?$AAe?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAD?$AAi?$AAc?$AAt?$AAC?$AAo?$AAm?$AAp?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005d	33 c0		 xor	 eax, eax
$LN5@compiler_d@2:

; 3166 :     return compiler_comprehension(c, e, COMP_DICTCOMP, name,
; 3167 :                                   e->v.DictComp.generators,
; 3168 :                                   e->v.DictComp.key, e->v.DictComp.value);

  0005f	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  00064	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00068	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0006d	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  00072	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00076	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  00080	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00084	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00089	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?name@?1??compiler_dictcomp@@9@9
  00090	41 b8 03 00 00
	00		 mov	 r8d, 3
  00096	48 8b 54 24 58	 mov	 rdx, QWORD PTR e$[rsp]
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000a0	e8 00 00 00 00	 call	 compiler_comprehension
$LN3@compiler_d@2:

; 3169 : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
compiler_dictcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@EGNPBIDB@invalid?5node?5type?5?$CI?$CFd?$CJ?5for?5augme@ ; `string'
PUBLIC	??_C@_1DE@DBDLKKFN@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
EXTRN	_Py_Subscript:PROC
EXTRN	_Py_Attribute:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_augassign DD imagerel compiler_augassign
	DD	imagerel compiler_augassign+728
	DD	imagerel $unwind$compiler_augassign
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_augassign DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0DA@EGNPBIDB@invalid?5node?5type?5?$CI?$CFd?$CJ?5for?5augme@
CONST	SEGMENT
??_C@_0DA@EGNPBIDB@invalid?5node?5type?5?$CI?$CFd?$CJ?5for?5augme@ DB 'in'
	DB	'valid node type (%d) for augmented assignment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@DBDLKKFN@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@DBDLKKFN@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 's'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'A', 00H, 'u', 00H, 'g'
	DB	00H, 'A', 00H, 's', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H
	DB	'_', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_augassign
_TEXT	SEGMENT
auge$ = 48
e$ = 56
tv70 = 64
c$ = 96
s$ = 104
compiler_augassign PROC					; COMDAT

; 3461 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3462 :     expr_ty e = s->v.AugAssign.target;

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00013	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00017	48 89 44 24 38	 mov	 QWORD PTR e$[rsp], rax

; 3463 :     expr_ty auge;
; 3464 : 
; 3465 :     assert(s->kind == AugAssign_kind);

  0001c	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00021	83 38 06	 cmp	 DWORD PTR [rax], 6
  00024	74 1c		 je	 SHORT $LN22@compiler_a@8
  00026	41 b8 89 0d 00
	00		 mov	 r8d, 3465		; 00000d89H
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@DBDLKKFN@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00040	33 c0		 xor	 eax, eax
$LN22@compiler_a@8:

; 3466 : 
; 3467 :     switch (e->kind) {

  00042	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  00047	8b 00		 mov	 eax, DWORD PTR [rax]
  00049	89 44 24 40	 mov	 DWORD PTR tv70[rsp], eax
  0004d	83 7c 24 40 14	 cmp	 DWORD PTR tv70[rsp], 20
  00052	74 1b		 je	 SHORT $LN17@compiler_a@8
  00054	83 7c 24 40 15	 cmp	 DWORD PTR tv70[rsp], 21
  00059	0f 84 f0 00 00
	00		 je	 $LN11@compiler_a@8
  0005f	83 7c 24 40 17	 cmp	 DWORD PTR tv70[rsp], 23
  00064	0f 84 c5 01 00
	00		 je	 $LN5@compiler_a@8
  0006a	e9 40 02 00 00	 jmp	 $LN1@compiler_a@8
$LN17@compiler_a@8:

; 3468 :     case Attribute_kind:
; 3469 :         auge = Attribute(e->v.Attribute.value, e->v.Attribute.attr,
; 3470 :                          AugLoad, e->lineno, e->col_offset, c->c_arena);

  0006f	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00074	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00078	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007d	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  00082	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00085	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00089	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  0008e	44 8b 48 30	 mov	 r9d, DWORD PTR [rax+48]
  00092	41 b8 04 00 00
	00		 mov	 r8d, 4
  00098	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  0009d	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000a1	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  000a6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000aa	e8 00 00 00 00	 call	 _Py_Attribute
  000af	48 89 44 24 30	 mov	 QWORD PTR auge$[rsp], rax

; 3471 :         if (auge == NULL)

  000b4	48 83 7c 24 30
	00		 cmp	 QWORD PTR auge$[rsp], 0
  000ba	75 07		 jne	 SHORT $LN16@compiler_a@8

; 3472 :             return 0;

  000bc	33 c0		 xor	 eax, eax
  000be	e9 10 02 00 00	 jmp	 $LN20@compiler_a@8
$LN16@compiler_a@8:

; 3473 :         VISIT(c, expr, auge);

  000c3	48 8b 54 24 30	 mov	 rdx, QWORD PTR auge$[rsp]
  000c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000cd	e8 00 00 00 00	 call	 compiler_visit_expr
  000d2	85 c0		 test	 eax, eax
  000d4	75 07		 jne	 SHORT $LN15@compiler_a@8
  000d6	33 c0		 xor	 eax, eax
  000d8	e9 f6 01 00 00	 jmp	 $LN20@compiler_a@8
$LN15@compiler_a@8:

; 3474 :         VISIT(c, expr, s->v.AugAssign.value);

  000dd	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000e2	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  000e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000eb	e8 00 00 00 00	 call	 compiler_visit_expr
  000f0	85 c0		 test	 eax, eax
  000f2	75 07		 jne	 SHORT $LN14@compiler_a@8
  000f4	33 c0		 xor	 eax, eax
  000f6	e9 d8 01 00 00	 jmp	 $LN20@compiler_a@8
$LN14@compiler_a@8:

; 3475 :         ADDOP(c, inplace_binop(c, s->v.AugAssign.op));

  000fb	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00100	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00103	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00108	e8 00 00 00 00	 call	 inplace_binop
  0010d	8b d0		 mov	 edx, eax
  0010f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00114	e8 00 00 00 00	 call	 compiler_addop
  00119	85 c0		 test	 eax, eax
  0011b	75 07		 jne	 SHORT $LN13@compiler_a@8
  0011d	33 c0		 xor	 eax, eax
  0011f	e9 af 01 00 00	 jmp	 $LN20@compiler_a@8
$LN13@compiler_a@8:

; 3476 :         auge->v.Attribute.ctx = AugStore;

  00124	48 8b 44 24 30	 mov	 rax, QWORD PTR auge$[rsp]
  00129	c7 40 18 05 00
	00 00		 mov	 DWORD PTR [rax+24], 5

; 3477 :         VISIT(c, expr, auge);

  00130	48 8b 54 24 30	 mov	 rdx, QWORD PTR auge$[rsp]
  00135	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0013a	e8 00 00 00 00	 call	 compiler_visit_expr
  0013f	85 c0		 test	 eax, eax
  00141	75 07		 jne	 SHORT $LN12@compiler_a@8
  00143	33 c0		 xor	 eax, eax
  00145	e9 89 01 00 00	 jmp	 $LN20@compiler_a@8
$LN12@compiler_a@8:

; 3478 :         break;

  0014a	e9 7f 01 00 00	 jmp	 $LN18@compiler_a@8
$LN11@compiler_a@8:

; 3479 :     case Subscript_kind:
; 3480 :         auge = Subscript(e->v.Subscript.value, e->v.Subscript.slice,
; 3481 :                          AugLoad, e->lineno, e->col_offset, c->c_arena);

  0014f	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00154	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00158	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0015d	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  00162	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00165	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00169	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  0016e	44 8b 48 30	 mov	 r9d, DWORD PTR [rax+48]
  00172	41 b8 04 00 00
	00		 mov	 r8d, 4
  00178	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  0017d	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00181	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  00186	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0018a	e8 00 00 00 00	 call	 _Py_Subscript
  0018f	48 89 44 24 30	 mov	 QWORD PTR auge$[rsp], rax

; 3482 :         if (auge == NULL)

  00194	48 83 7c 24 30
	00		 cmp	 QWORD PTR auge$[rsp], 0
  0019a	75 07		 jne	 SHORT $LN10@compiler_a@8

; 3483 :             return 0;

  0019c	33 c0		 xor	 eax, eax
  0019e	e9 30 01 00 00	 jmp	 $LN20@compiler_a@8
$LN10@compiler_a@8:

; 3484 :         VISIT(c, expr, auge);

  001a3	48 8b 54 24 30	 mov	 rdx, QWORD PTR auge$[rsp]
  001a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001ad	e8 00 00 00 00	 call	 compiler_visit_expr
  001b2	85 c0		 test	 eax, eax
  001b4	75 07		 jne	 SHORT $LN9@compiler_a@8
  001b6	33 c0		 xor	 eax, eax
  001b8	e9 16 01 00 00	 jmp	 $LN20@compiler_a@8
$LN9@compiler_a@8:

; 3485 :         VISIT(c, expr, s->v.AugAssign.value);

  001bd	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  001c2	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  001c6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001cb	e8 00 00 00 00	 call	 compiler_visit_expr
  001d0	85 c0		 test	 eax, eax
  001d2	75 07		 jne	 SHORT $LN8@compiler_a@8
  001d4	33 c0		 xor	 eax, eax
  001d6	e9 f8 00 00 00	 jmp	 $LN20@compiler_a@8
$LN8@compiler_a@8:

; 3486 :         ADDOP(c, inplace_binop(c, s->v.AugAssign.op));

  001db	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  001e0	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  001e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001e8	e8 00 00 00 00	 call	 inplace_binop
  001ed	8b d0		 mov	 edx, eax
  001ef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001f4	e8 00 00 00 00	 call	 compiler_addop
  001f9	85 c0		 test	 eax, eax
  001fb	75 07		 jne	 SHORT $LN7@compiler_a@8
  001fd	33 c0		 xor	 eax, eax
  001ff	e9 cf 00 00 00	 jmp	 $LN20@compiler_a@8
$LN7@compiler_a@8:

; 3487 :         auge->v.Subscript.ctx = AugStore;

  00204	48 8b 44 24 30	 mov	 rax, QWORD PTR auge$[rsp]
  00209	c7 40 18 05 00
	00 00		 mov	 DWORD PTR [rax+24], 5

; 3488 :         VISIT(c, expr, auge);

  00210	48 8b 54 24 30	 mov	 rdx, QWORD PTR auge$[rsp]
  00215	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0021a	e8 00 00 00 00	 call	 compiler_visit_expr
  0021f	85 c0		 test	 eax, eax
  00221	75 07		 jne	 SHORT $LN6@compiler_a@8
  00223	33 c0		 xor	 eax, eax
  00225	e9 a9 00 00 00	 jmp	 $LN20@compiler_a@8
$LN6@compiler_a@8:

; 3489 :         break;

  0022a	e9 9f 00 00 00	 jmp	 $LN18@compiler_a@8
$LN5@compiler_a@8:

; 3490 :     case Name_kind:
; 3491 :         if (!compiler_nameop(c, e->v.Name.id, Load))

  0022f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00235	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  0023a	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0023e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00243	e8 00 00 00 00	 call	 compiler_nameop
  00248	85 c0		 test	 eax, eax
  0024a	75 07		 jne	 SHORT $LN4@compiler_a@8

; 3492 :             return 0;

  0024c	33 c0		 xor	 eax, eax
  0024e	e9 80 00 00 00	 jmp	 $LN20@compiler_a@8
$LN4@compiler_a@8:

; 3493 :         VISIT(c, expr, s->v.AugAssign.value);

  00253	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00258	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  0025c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00261	e8 00 00 00 00	 call	 compiler_visit_expr
  00266	85 c0		 test	 eax, eax
  00268	75 04		 jne	 SHORT $LN3@compiler_a@8
  0026a	33 c0		 xor	 eax, eax
  0026c	eb 65		 jmp	 SHORT $LN20@compiler_a@8
$LN3@compiler_a@8:

; 3494 :         ADDOP(c, inplace_binop(c, s->v.AugAssign.op));

  0026e	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00273	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00276	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0027b	e8 00 00 00 00	 call	 inplace_binop
  00280	8b d0		 mov	 edx, eax
  00282	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00287	e8 00 00 00 00	 call	 compiler_addop
  0028c	85 c0		 test	 eax, eax
  0028e	75 04		 jne	 SHORT $LN2@compiler_a@8
  00290	33 c0		 xor	 eax, eax
  00292	eb 3f		 jmp	 SHORT $LN20@compiler_a@8
$LN2@compiler_a@8:

; 3495 :         return compiler_nameop(c, e->v.Name.id, Store);

  00294	41 b8 02 00 00
	00		 mov	 r8d, 2
  0029a	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  0029f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  002a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  002a8	e8 00 00 00 00	 call	 compiler_nameop
  002ad	eb 24		 jmp	 SHORT $LN20@compiler_a@8
$LN1@compiler_a@8:

; 3496 :     default:
; 3497 :         PyErr_Format(PyExc_SystemError,
; 3498 :             "invalid node type (%d) for augmented assignment",
; 3499 :             e->kind);

  002af	48 8b 44 24 38	 mov	 rax, QWORD PTR e$[rsp]
  002b4	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  002b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@EGNPBIDB@invalid?5node?5type?5?$CI?$CFd?$CJ?5for?5augme@
  002be	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  002c5	e8 00 00 00 00	 call	 PyErr_Format

; 3500 :         return 0;

  002ca	33 c0		 xor	 eax, eax
  002cc	eb 05		 jmp	 SHORT $LN20@compiler_a@8
$LN18@compiler_a@8:

; 3501 :     }
; 3502 :     return 1;

  002ce	b8 01 00 00 00	 mov	 eax, 1
$LN20@compiler_a@8:

; 3503 : }

  002d3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002d7	c3		 ret	 0
compiler_augassign ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LKMPPKN@inplace?5binary?5op?5?$CFd?5should?5not?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$inplace_binop DD imagerel inplace_binop
	DD	imagerel inplace_binop+228
	DD	imagerel $unwind$inplace_binop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inplace_binop DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_0CM@LKMPPKN@inplace?5binary?5op?5?$CFd?5should?5not?5@
CONST	SEGMENT
??_C@_0CM@LKMPPKN@inplace?5binary?5op?5?$CFd?5should?5not?5@ DB 'inplace '
	DB	'binary op %d should not be possible', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT inplace_binop
_TEXT	SEGMENT
tv64 = 32
c$ = 64
op$ = 72
inplace_binop PROC					; COMDAT

; 2594 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2595 :     switch (op) {

  0000d	8b 44 24 48	 mov	 eax, DWORD PTR op$[rsp]
  00011	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00015	8b 44 24 20	 mov	 eax, DWORD PTR tv64[rsp]
  00019	ff c8		 dec	 eax
  0001b	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0001f	83 7c 24 20 0b	 cmp	 DWORD PTR tv64[rsp], 11
  00024	77 6c		 ja	 SHORT $LN1@inplace_bi
  00026	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv64[rsp]
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00032	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN18@inplace_bi[rcx+rax*4]
  00039	48 03 c1	 add	 rax, rcx
  0003c	ff e0		 jmp	 rax
$LN13@inplace_bi:

; 2596 :     case Add:
; 2597 :         return INPLACE_ADD;

  0003e	b8 37 00 00 00	 mov	 eax, 55			; 00000037H
  00043	eb 67		 jmp	 SHORT $LN16@inplace_bi
$LN12@inplace_bi:

; 2598 :     case Sub:
; 2599 :         return INPLACE_SUBTRACT;

  00045	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0004a	eb 60		 jmp	 SHORT $LN16@inplace_bi
$LN11@inplace_bi:

; 2600 :     case Mult:
; 2601 :         return INPLACE_MULTIPLY;

  0004c	b8 39 00 00 00	 mov	 eax, 57			; 00000039H
  00051	eb 59		 jmp	 SHORT $LN16@inplace_bi
$LN10@inplace_bi:

; 2602 :     case Div:
; 2603 :         return INPLACE_TRUE_DIVIDE;

  00053	b8 1d 00 00 00	 mov	 eax, 29
  00058	eb 52		 jmp	 SHORT $LN16@inplace_bi
$LN9@inplace_bi:

; 2604 :     case Mod:
; 2605 :         return INPLACE_MODULO;

  0005a	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  0005f	eb 4b		 jmp	 SHORT $LN16@inplace_bi
$LN8@inplace_bi:

; 2606 :     case Pow:
; 2607 :         return INPLACE_POWER;

  00061	b8 43 00 00 00	 mov	 eax, 67			; 00000043H
  00066	eb 44		 jmp	 SHORT $LN16@inplace_bi
$LN7@inplace_bi:

; 2608 :     case LShift:
; 2609 :         return INPLACE_LSHIFT;

  00068	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  0006d	eb 3d		 jmp	 SHORT $LN16@inplace_bi
$LN6@inplace_bi:

; 2610 :     case RShift:
; 2611 :         return INPLACE_RSHIFT;

  0006f	b8 4c 00 00 00	 mov	 eax, 76			; 0000004cH
  00074	eb 36		 jmp	 SHORT $LN16@inplace_bi
$LN5@inplace_bi:

; 2612 :     case BitOr:
; 2613 :         return INPLACE_OR;

  00076	b8 4f 00 00 00	 mov	 eax, 79			; 0000004fH
  0007b	eb 2f		 jmp	 SHORT $LN16@inplace_bi
$LN4@inplace_bi:

; 2614 :     case BitXor:
; 2615 :         return INPLACE_XOR;

  0007d	b8 4e 00 00 00	 mov	 eax, 78			; 0000004eH
  00082	eb 28		 jmp	 SHORT $LN16@inplace_bi
$LN3@inplace_bi:

; 2616 :     case BitAnd:
; 2617 :         return INPLACE_AND;

  00084	b8 4d 00 00 00	 mov	 eax, 77			; 0000004dH
  00089	eb 21		 jmp	 SHORT $LN16@inplace_bi
$LN2@inplace_bi:

; 2618 :     case FloorDiv:
; 2619 :         return INPLACE_FLOOR_DIVIDE;

  0008b	b8 1c 00 00 00	 mov	 eax, 28
  00090	eb 1a		 jmp	 SHORT $LN16@inplace_bi
$LN1@inplace_bi:

; 2620 :     default:
; 2621 :         PyErr_Format(PyExc_SystemError,
; 2622 :             "inplace binary op %d should not be possible", op);

  00092	44 8b 44 24 48	 mov	 r8d, DWORD PTR op$[rsp]
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@LKMPPKN@inplace?5binary?5op?5?$CFd?5should?5not?5@
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000a5	e8 00 00 00 00	 call	 PyErr_Format

; 2623 :         return 0;

  000aa	33 c0		 xor	 eax, eax
$LN16@inplace_bi:

; 2624 :     }
; 2625 : }

  000ac	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b0	c3		 ret	 0
  000b1	0f 1f 00	 npad	 3
$LN18@inplace_bi:
  000b4	00 00 00 00	 DD	 $LN13@inplace_bi
  000b8	00 00 00 00	 DD	 $LN12@inplace_bi
  000bc	00 00 00 00	 DD	 $LN11@inplace_bi
  000c0	00 00 00 00	 DD	 $LN10@inplace_bi
  000c4	00 00 00 00	 DD	 $LN9@inplace_bi
  000c8	00 00 00 00	 DD	 $LN8@inplace_bi
  000cc	00 00 00 00	 DD	 $LN7@inplace_bi
  000d0	00 00 00 00	 DD	 $LN6@inplace_bi
  000d4	00 00 00 00	 DD	 $LN5@inplace_bi
  000d8	00 00 00 00	 DD	 $LN4@inplace_bi
  000dc	00 00 00 00	 DD	 $LN3@inplace_bi
  000e0	00 00 00 00	 DD	 $LN2@inplace_bi
inplace_binop ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@LMOHMEG@too?5many?5statically?5nested?5block@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_push_fblock DD imagerel compiler_push_fblock
	DD	imagerel compiler_push_fblock+153
	DD	imagerel $unwind$compiler_push_fblock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_push_fblock DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT ??_C@_0CC@LMOHMEG@too?5many?5statically?5nested?5block@
CONST	SEGMENT
??_C@_0CC@LMOHMEG@too?5many?5statically?5nested?5block@ DB 'too many stat'
	DB	'ically nested blocks', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_push_fblock
_TEXT	SEGMENT
f$ = 32
c$ = 64
t$ = 72
b$ = 80
compiler_push_fblock PROC				; COMDAT

; 3507 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3508 :     struct fblockinfo *f;
; 3509 :     if (c->u->u_nfblocks >= CO_MAXBLOCKS) {

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00017	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0001b	83 78 68 14	 cmp	 DWORD PTR [rax+104], 20
  0001f	7c 17		 jl	 SHORT $LN1@compiler_p

; 3510 :         PyErr_SetString(PyExc_SystemError,
; 3511 :                         "too many statically nested blocks");

  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@LMOHMEG@too?5many?5statically?5nested?5block@
  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0002f	e8 00 00 00 00	 call	 PyErr_SetString

; 3512 :         return 0;

  00034	33 c0		 xor	 eax, eax
  00036	eb 5c		 jmp	 SHORT $LN2@compiler_p
$LN1@compiler_p:

; 3513 :     }
; 3514 :     f = &c->u->u_fblock[c->u->u_nfblocks++];

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0003d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00046	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0004a	48 63 49 68	 movsxd	 rcx, DWORD PTR [rcx+104]
  0004e	48 6b c9 10	 imul	 rcx, 16
  00052	48 8d 44 08 70	 lea	 rax, QWORD PTR [rax+rcx+112]
  00057	48 89 44 24 20	 mov	 QWORD PTR f$[rsp], rax
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00061	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00065	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00068	ff c0		 inc	 eax
  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0006f	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00073	89 41 68	 mov	 DWORD PTR [rcx+104], eax

; 3515 :     f->fb_type = t;

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR f$[rsp]
  0007b	8b 4c 24 48	 mov	 ecx, DWORD PTR t$[rsp]
  0007f	89 08		 mov	 DWORD PTR [rax], ecx

; 3516 :     f->fb_block = b;

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR f$[rsp]
  00086	48 8b 4c 24 50	 mov	 rcx, QWORD PTR b$[rsp]
  0008b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3517 :     return 1;

  0008f	b8 01 00 00 00	 mov	 eax, 1
$LN2@compiler_p:

; 3518 : }

  00094	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00098	c3		 ret	 0
compiler_push_fblock ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FC@NOLCKEDP@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$FL?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?$FN?$AA?4?$AAf?$AAb?$AA_?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_1FA@INEIEGCC@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$FL?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?$FN?$AA?4?$AAf?$AAb?$AA_?$AAt?$AAy@ ; `string'
PUBLIC	??_C@_1CE@CHHFEEMN@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_pop_fblock DD imagerel compiler_pop_fblock
	DD	imagerel compiler_pop_fblock+208
	DD	imagerel $unwind$compiler_pop_fblock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_pop_fblock DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT ??_C@_1FC@NOLCKEDP@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$FL?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?$FN?$AA?4?$AAf?$AAb?$AA_?$AAb?$AAl@
CONST	SEGMENT
??_C@_1FC@NOLCKEDP@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$FL?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?$FN?$AA?4?$AAf?$AAb?$AA_?$AAb?$AAl@ DB 'u'
	DB	00H, '-', 00H, '>', 00H, 'u', 00H, '_', 00H, 'f', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '[', 00H, 'u', 00H, '-'
	DB	00H, '>', 00H, 'u', 00H, '_', 00H, 'n', 00H, 'f', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 's', 00H, ']', 00H, '.'
	DB	00H, 'f', 00H, 'b', 00H, '_', 00H, 'b', 00H, 'l', 00H, 'o', 00H
	DB	'c', 00H, 'k', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@INEIEGCC@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$FL?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?$FN?$AA?4?$AAf?$AAb?$AA_?$AAt?$AAy@
CONST	SEGMENT
??_C@_1FA@INEIEGCC@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$FL?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?$FN?$AA?4?$AAf?$AAb?$AA_?$AAt?$AAy@ DB 'u'
	DB	00H, '-', 00H, '>', 00H, 'u', 00H, '_', 00H, 'f', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '[', 00H, 'u', 00H, '-'
	DB	00H, '>', 00H, 'u', 00H, '_', 00H, 'n', 00H, 'f', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 's', 00H, ']', 00H, '.'
	DB	00H, 'f', 00H, 'b', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@CHHFEEMN@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@CHHFEEMN@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'u'
	DB	00H, '-', 00H, '>', 00H, 'u', 00H, '_', 00H, 'n', 00H, 'f', 00H
	DB	'b', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 's', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_pop_fblock
_TEXT	SEGMENT
u$ = 32
c$ = 64
t$ = 72
b$ = 80
compiler_pop_fblock PROC				; COMDAT

; 3522 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3523 :     struct compiler_unit *u = c->u;

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00017	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0001b	48 89 44 24 20	 mov	 QWORD PTR u$[rsp], rax

; 3524 :     assert(u->u_nfblocks > 0);

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00025	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00029	7f 1c		 jg	 SHORT $LN3@compiler_p@2
  0002b	41 b8 c4 0d 00
	00		 mov	 r8d, 3524		; 00000dc4H
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@CHHFEEMN@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00045	33 c0		 xor	 eax, eax
$LN3@compiler_p@2:

; 3525 :     u->u_nfblocks--;

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0004c	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0004f	ff c8		 dec	 eax
  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  00056	89 41 68	 mov	 DWORD PTR [rcx+104], eax

; 3526 :     assert(u->u_fblock[u->u_nfblocks].fb_type == t);

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0005e	48 63 40 68	 movsxd	 rax, DWORD PTR [rax+104]
  00062	48 6b c0 10	 imul	 rax, 16
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  0006b	8b 54 24 48	 mov	 edx, DWORD PTR t$[rsp]
  0006f	39 54 01 70	 cmp	 DWORD PTR [rcx+rax+112], edx
  00073	74 1c		 je	 SHORT $LN4@compiler_p@2
  00075	41 b8 c6 0d 00
	00		 mov	 r8d, 3526		; 00000dc6H
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@INEIEGCC@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$FL?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?$FN?$AA?4?$AAf?$AAb?$AA_?$AAt?$AAy@
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008f	33 c0		 xor	 eax, eax
$LN4@compiler_p@2:

; 3527 :     assert(u->u_fblock[u->u_nfblocks].fb_block == b);

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00096	48 63 40 68	 movsxd	 rax, DWORD PTR [rax+104]
  0009a	48 6b c0 10	 imul	 rax, 16
  0009e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  000a3	48 8b 54 24 50	 mov	 rdx, QWORD PTR b$[rsp]
  000a8	48 39 54 01 78	 cmp	 QWORD PTR [rcx+rax+120], rdx
  000ad	74 1c		 je	 SHORT $LN5@compiler_p@2
  000af	41 b8 c7 0d 00
	00		 mov	 r8d, 3527		; 00000dc7H
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@NOLCKEDP@?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$FL?$AAu?$AA?9?$AA?$DO?$AAu?$AA_?$AAn?$AAf?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?$FN?$AA?4?$AAf?$AAb?$AA_?$AAb?$AAl@
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c9	33 c0		 xor	 eax, eax
$LN5@compiler_p@2:

; 3528 : }

  000cb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cf	c3		 ret	 0
compiler_pop_fblock ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_in_loop DD imagerel compiler_in_loop
	DD	imagerel compiler_in_loop+89
	DD	imagerel $unwind$compiler_in_loop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_in_loop DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compiler_in_loop
_TEXT	SEGMENT
i$ = 0
u$ = 8
c$ = 32
compiler_in_loop PROC					; COMDAT

; 3531 : compiler_in_loop(struct compiler *c) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 3532 :     int i;
; 3533 :     struct compiler_unit *u = c->u;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]
  0000e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00012	48 89 44 24 08	 mov	 QWORD PTR u$[rsp], rax

; 3534 :     for (i = 0; i < u->u_nfblocks; ++i) {

  00017	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001e	eb 08		 jmp	 SHORT $LN4@compiler_i@7
$LN3@compiler_i@7:
  00020	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00023	ff c0		 inc	 eax
  00025	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@compiler_i@7:
  00028	48 8b 44 24 08	 mov	 rax, QWORD PTR u$[rsp]
  0002d	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00030	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00033	7d 1d		 jge	 SHORT $LN2@compiler_i@7

; 3535 :         if (u->u_fblock[i].fb_type == LOOP)

  00035	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00039	48 6b c0 10	 imul	 rax, 16
  0003d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR u$[rsp]
  00042	83 7c 01 70 00	 cmp	 DWORD PTR [rcx+rax+112], 0
  00047	75 07		 jne	 SHORT $LN1@compiler_i@7

; 3536 :             return 1;

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	eb 04		 jmp	 SHORT $LN5@compiler_i@7
$LN1@compiler_i@7:

; 3537 :     }

  00050	eb ce		 jmp	 SHORT $LN3@compiler_i@7
$LN2@compiler_i@7:

; 3538 :     return 0;

  00052	33 c0		 xor	 eax, eax
$LN5@compiler_i@7:

; 3539 : }

  00054	48 83 c4 18	 add	 rsp, 24
  00058	c3		 ret	 0
compiler_in_loop ENDP
_TEXT	ENDS
PUBLIC	??_C@_04PDGOHJMJ@?$CIzO?$CJ?$AA@		; `string'
PUBLIC	??_C@_06INEDBHGA@?$CIOiiO?$CJ?$AA@		; `string'
EXTRN	PyErr_SetObject:PROC
EXTRN	Py_BuildValue:PROC
EXTRN	PyErr_ProgramText:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_error DD imagerel compiler_error
	DD	imagerel compiler_error+294
	DD	imagerel $unwind$compiler_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_error DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_04PDGOHJMJ@?$CIzO?$CJ?$AA@
CONST	SEGMENT
??_C@_04PDGOHJMJ@?$CIzO?$CJ?$AA@ DB '(zO)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06INEDBHGA@?$CIOiiO?$CJ?$AA@
CONST	SEGMENT
??_C@_06INEDBHGA@?$CIOiiO?$CJ?$AA@ DB '(OiiO)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_error
_TEXT	SEGMENT
v$ = 48
u$ = 56
loc$ = 64
c$ = 96
errstr$ = 104
compiler_error PROC					; COMDAT

; 3546 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3547 :     PyObject *loc;
; 3548 :     PyObject *u = NULL, *v = NULL;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR u$[rsp], 0
  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR v$[rsp], 0

; 3549 : 
; 3550 :     loc = PyErr_ProgramText(c->c_filename, c->u->u_lineno);

  00020	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00025	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00029	8b 90 b4 01 00
	00		 mov	 edx, DWORD PTR [rax+436]
  0002f	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00034	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00037	e8 00 00 00 00	 call	 PyErr_ProgramText
  0003c	48 89 44 24 40	 mov	 QWORD PTR loc$[rsp], rax

; 3551 :     if (!loc) {

  00041	48 83 7c 24 40
	00		 cmp	 QWORD PTR loc$[rsp], 0
  00047	75 18		 jne	 SHORT $LN11@compiler_e@3

; 3552 :         Py_INCREF(Py_None);

  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00050	e8 00 00 00 00	 call	 _Py_IncRef

; 3553 :         loc = Py_None;

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0005c	48 89 44 24 40	 mov	 QWORD PTR loc$[rsp], rax
$LN11@compiler_e@3:

; 3554 :     }
; 3555 :     u = Py_BuildValue("(OiiO)", c->c_filename_obj, c->u->u_lineno,
; 3556 :                       c->u->u_col_offset, loc);

  00061	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00066	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0006a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0006f	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00073	48 8b 54 24 40	 mov	 rdx, QWORD PTR loc$[rsp]
  00078	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0007d	44 8b 88 b8 01
	00 00		 mov	 r9d, DWORD PTR [rax+440]
  00084	44 8b 81 b4 01
	00 00		 mov	 r8d, DWORD PTR [rcx+436]
  0008b	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00090	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06INEDBHGA@?$CIOiiO?$CJ?$AA@
  0009b	e8 00 00 00 00	 call	 Py_BuildValue
  000a0	48 89 44 24 38	 mov	 QWORD PTR u$[rsp], rax

; 3557 :     if (!u)

  000a5	48 83 7c 24 38
	00		 cmp	 QWORD PTR u$[rsp], 0
  000ab	75 02		 jne	 SHORT $LN10@compiler_e@3

; 3558 :         goto exit;

  000ad	eb 36		 jmp	 SHORT $exit$24959
$LN10@compiler_e@3:

; 3559 :     v = Py_BuildValue("(zO)", errstr, u);

  000af	4c 8b 44 24 38	 mov	 r8, QWORD PTR u$[rsp]
  000b4	48 8b 54 24 68	 mov	 rdx, QWORD PTR errstr$[rsp]
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04PDGOHJMJ@?$CIzO?$CJ?$AA@
  000c0	e8 00 00 00 00	 call	 Py_BuildValue
  000c5	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax

; 3560 :     if (!v)

  000ca	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  000d0	75 02		 jne	 SHORT $LN9@compiler_e@3

; 3561 :         goto exit;

  000d2	eb 11		 jmp	 SHORT $exit$24959
$LN9@compiler_e@3:

; 3562 :     PyErr_SetObject(PyExc_SyntaxError, v);

  000d4	48 8b 54 24 30	 mov	 rdx, QWORD PTR v$[rsp]
  000d9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  000e0	e8 00 00 00 00	 call	 PyErr_SetObject
$exit$24959:

; 3563 :  exit:
; 3564 :     Py_DECREF(loc);

  000e5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR loc$[rsp]
  000ea	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@compiler_e@3:

; 3565 :     Py_XDECREF(u);

  000ef	48 83 7c 24 38
	00		 cmp	 QWORD PTR u$[rsp], 0
  000f5	74 0a		 je	 SHORT $LN5@compiler_e@3
  000f7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR u$[rsp]
  000fc	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@compiler_e@3:
  00101	33 c0		 xor	 eax, eax
  00103	85 c0		 test	 eax, eax
  00105	75 e8		 jne	 SHORT $LN8@compiler_e@3
$LN4@compiler_e@3:

; 3566 :     Py_XDECREF(v);

  00107	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  0010d	74 0a		 je	 SHORT $LN1@compiler_e@3
  0010f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@compiler_e@3:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	75 e8		 jne	 SHORT $LN4@compiler_e@3

; 3567 :     return 0;

  0011f	33 c0		 xor	 eax, eax

; 3568 : }

  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	c3		 ret	 0
compiler_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@DMIFGBD@invalid?5subscript?5kind?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0P@NIBIFKDK@extended?5slice?$AA@		; `string'
PUBLIC	??_C@_05ILHMOJGN@slice?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_slice DD imagerel compiler_visit_slice
	DD	imagerel compiler_visit_slice+415
	DD	imagerel $unwind$compiler_visit_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_slice DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0BK@DMIFGBD@invalid?5subscript?5kind?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@DMIFGBD@invalid?5subscript?5kind?5?$CFd?$AA@ DB 'invalid subscr'
	DB	'ipt kind %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NIBIFKDK@extended?5slice?$AA@
CONST	SEGMENT
??_C@_0P@NIBIFKDK@extended?5slice?$AA@ DB 'extended slice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05ILHMOJGN@slice?$AA@
CONST	SEGMENT
??_C@_05ILHMOJGN@slice?$AA@ DB 'slice', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_visit_slice
_TEXT	SEGMENT
kindname$ = 32
n$25061 = 40
i$25060 = 44
sub$25066 = 48
tv64 = 56
tv82 = 64
c$ = 96
s$ = 104
ctx$ = 112
compiler_visit_slice PROC				; COMDAT

; 3649 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3650 :     char * kindname = NULL;

  00013	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR kindname$[rsp], 0

; 3651 :     switch (s->kind) {

  0001c	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00021	8b 00		 mov	 eax, DWORD PTR [rax]
  00023	89 44 24 38	 mov	 DWORD PTR tv64[rsp], eax
  00027	83 7c 24 38 01	 cmp	 DWORD PTR tv64[rsp], 1
  0002c	74 49		 je	 SHORT $LN11@compiler_v@8
  0002e	83 7c 24 38 02	 cmp	 DWORD PTR tv64[rsp], 2
  00033	74 79		 je	 SHORT $LN8@compiler_v@8
  00035	83 7c 24 38 03	 cmp	 DWORD PTR tv64[rsp], 3
  0003a	74 05		 je	 SHORT $LN14@compiler_v@8
  0003c	e9 26 01 00 00	 jmp	 $LN1@compiler_v@8
$LN14@compiler_v@8:

; 3652 :     case Index_kind:
; 3653 :         kindname = "index";

  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05FKHKFDID@index?$AA@
  00048	48 89 44 24 20	 mov	 QWORD PTR kindname$[rsp], rax

; 3654 :         if (ctx != AugStore) {

  0004d	83 7c 24 70 05	 cmp	 DWORD PTR ctx$[rsp], 5
  00052	74 1e		 je	 SHORT $LN13@compiler_v@8

; 3655 :             VISIT(c, expr, s->v.Index.value);

  00054	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00059	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0005d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00062	e8 00 00 00 00	 call	 compiler_visit_expr
  00067	85 c0		 test	 eax, eax
  00069	75 07		 jne	 SHORT $LN12@compiler_v@8
  0006b	33 c0		 xor	 eax, eax
  0006d	e9 28 01 00 00	 jmp	 $LN17@compiler_v@8
$LN12@compiler_v@8:
$LN13@compiler_v@8:

; 3656 :         }
; 3657 :         break;

  00072	e9 0f 01 00 00	 jmp	 $LN15@compiler_v@8
$LN11@compiler_v@8:

; 3658 :     case Slice_kind:
; 3659 :         kindname = "slice";

  00077	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05ILHMOJGN@slice?$AA@
  0007e	48 89 44 24 20	 mov	 QWORD PTR kindname$[rsp], rax

; 3660 :         if (ctx != AugStore) {

  00083	83 7c 24 70 05	 cmp	 DWORD PTR ctx$[rsp], 5
  00088	74 1f		 je	 SHORT $LN10@compiler_v@8

; 3661 :             if (!compiler_slice(c, s, ctx))

  0008a	44 8b 44 24 70	 mov	 r8d, DWORD PTR ctx$[rsp]
  0008f	48 8b 54 24 68	 mov	 rdx, QWORD PTR s$[rsp]
  00094	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00099	e8 00 00 00 00	 call	 compiler_slice
  0009e	85 c0		 test	 eax, eax
  000a0	75 07		 jne	 SHORT $LN9@compiler_v@8

; 3662 :                 return 0;

  000a2	33 c0		 xor	 eax, eax
  000a4	e9 f1 00 00 00	 jmp	 $LN17@compiler_v@8
$LN9@compiler_v@8:
$LN10@compiler_v@8:

; 3663 :         }
; 3664 :         break;

  000a9	e9 d8 00 00 00	 jmp	 $LN15@compiler_v@8
$LN8@compiler_v@8:

; 3665 :     case ExtSlice_kind:
; 3666 :         kindname = "extended slice";

  000ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0P@NIBIFKDK@extended?5slice?$AA@
  000b5	48 89 44 24 20	 mov	 QWORD PTR kindname$[rsp], rax

; 3667 :         if (ctx != AugStore) {

  000ba	83 7c 24 70 05	 cmp	 DWORD PTR ctx$[rsp], 5
  000bf	0f 84 a0 00 00
	00		 je	 $LN7@compiler_v@8

; 3668 :             int i, n = asdl_seq_LEN(s->v.ExtSlice.dims);

  000c5	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000ca	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000cf	75 0b		 jne	 SHORT $LN19@compiler_v@8
  000d1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
  000da	eb 11		 jmp	 SHORT $LN20@compiler_v@8
$LN19@compiler_v@8:
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000e1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000e5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e8	48 89 44 24 40	 mov	 QWORD PTR tv82[rsp], rax
$LN20@compiler_v@8:
  000ed	8b 44 24 40	 mov	 eax, DWORD PTR tv82[rsp]
  000f1	89 44 24 28	 mov	 DWORD PTR n$25061[rsp], eax

; 3669 :             for (i = 0; i < n; i++) {

  000f5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$25060[rsp], 0
  000fd	eb 0a		 jmp	 SHORT $LN6@compiler_v@8
$LN5@compiler_v@8:
  000ff	8b 44 24 2c	 mov	 eax, DWORD PTR i$25060[rsp]
  00103	ff c0		 inc	 eax
  00105	89 44 24 2c	 mov	 DWORD PTR i$25060[rsp], eax
$LN6@compiler_v@8:
  00109	8b 44 24 28	 mov	 eax, DWORD PTR n$25061[rsp]
  0010d	39 44 24 2c	 cmp	 DWORD PTR i$25060[rsp], eax
  00111	7d 36		 jge	 SHORT $LN4@compiler_v@8

; 3670 :                 slice_ty sub = (slice_ty)asdl_seq_GET(
; 3671 :                     s->v.ExtSlice.dims, i);

  00113	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00118	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0011c	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i$25060[rsp]
  00121	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  00126	48 89 44 24 30	 mov	 QWORD PTR sub$25066[rsp], rax

; 3672 :                 if (!compiler_visit_nested_slice(c, sub, ctx))

  0012b	44 8b 44 24 70	 mov	 r8d, DWORD PTR ctx$[rsp]
  00130	48 8b 54 24 30	 mov	 rdx, QWORD PTR sub$25066[rsp]
  00135	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0013a	e8 00 00 00 00	 call	 compiler_visit_nested_slice
  0013f	85 c0		 test	 eax, eax
  00141	75 04		 jne	 SHORT $LN3@compiler_v@8

; 3673 :                     return 0;

  00143	33 c0		 xor	 eax, eax
  00145	eb 53		 jmp	 SHORT $LN17@compiler_v@8
$LN3@compiler_v@8:

; 3674 :             }

  00147	eb b6		 jmp	 SHORT $LN5@compiler_v@8
$LN4@compiler_v@8:

; 3675 :             ADDOP_I(c, BUILD_TUPLE, n);

  00149	44 8b 44 24 28	 mov	 r8d, DWORD PTR n$25061[rsp]
  0014e	ba 66 00 00 00	 mov	 edx, 102		; 00000066H
  00153	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00158	e8 00 00 00 00	 call	 compiler_addop_i
  0015d	85 c0		 test	 eax, eax
  0015f	75 04		 jne	 SHORT $LN2@compiler_v@8
  00161	33 c0		 xor	 eax, eax
  00163	eb 35		 jmp	 SHORT $LN17@compiler_v@8
$LN2@compiler_v@8:
$LN7@compiler_v@8:

; 3676 :         }
; 3677 :         break;

  00165	eb 1f		 jmp	 SHORT $LN15@compiler_v@8
$LN1@compiler_v@8:

; 3678 :     default:
; 3679 :         PyErr_Format(PyExc_SystemError,
; 3680 :                      "invalid subscript kind %d", s->kind);

  00167	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0016c	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0016f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DMIFGBD@invalid?5subscript?5kind?5?$CFd?$AA@
  00176	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0017d	e8 00 00 00 00	 call	 PyErr_Format

; 3681 :         return 0;

  00182	33 c0		 xor	 eax, eax
  00184	eb 14		 jmp	 SHORT $LN17@compiler_v@8
$LN15@compiler_v@8:

; 3682 :     }
; 3683 :     return compiler_handle_subscr(c, kindname, ctx);

  00186	44 8b 44 24 70	 mov	 r8d, DWORD PTR ctx$[rsp]
  0018b	48 8b 54 24 20	 mov	 rdx, QWORD PTR kindname$[rsp]
  00190	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00195	e8 00 00 00 00	 call	 compiler_handle_subscr
$LN17@compiler_v@8:

; 3684 : }

  0019a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0019e	c3		 ret	 0
compiler_visit_slice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@GFGBAOAN@invalid?5?$CFs?5kind?5?$CFd?5in?5subscript?6@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_handle_subscr DD imagerel compiler_handle_subscr
	DD	imagerel compiler_handle_subscr+260
	DD	imagerel $unwind$compiler_handle_subscr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_handle_subscr DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CB@GFGBAOAN@invalid?5?$CFs?5kind?5?$CFd?5in?5subscript?6@
CONST	SEGMENT
??_C@_0CB@GFGBAOAN@invalid?5?$CFs?5kind?5?$CFd?5in?5subscript?6@ DB 'inva'
	DB	'lid %s kind %d in subscript', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_handle_subscr
_TEXT	SEGMENT
op$ = 32
tv64 = 36
c$ = 64
kind$ = 72
ctx$ = 80
compiler_handle_subscr PROC				; COMDAT

; 3573 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3574 :     int op = 0;

  00013	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR op$[rsp], 0

; 3575 : 
; 3576 :     /* XXX this code is duplicated */
; 3577 :     switch (ctx) {

  0001b	8b 44 24 50	 mov	 eax, DWORD PTR ctx$[rsp]
  0001f	89 44 24 24	 mov	 DWORD PTR tv64[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR tv64[rsp]
  00027	ff c8		 dec	 eax
  00029	89 44 24 24	 mov	 DWORD PTR tv64[rsp], eax
  0002d	83 7c 24 24 05	 cmp	 DWORD PTR tv64[rsp], 5
  00032	77 57		 ja	 SHORT $LN11@compiler_h
  00034	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv64[rsp]
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00040	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN15@compiler_h[rcx+rax*4]
  00047	48 03 c1	 add	 rax, rcx
  0004a	ff e0		 jmp	 rax
$LN10@compiler_h:

; 3578 :         case AugLoad: /* fall through to Load */
; 3579 :         case Load:    op = BINARY_SUBSCR; break;

  0004c	c7 44 24 20 19
	00 00 00	 mov	 DWORD PTR op$[rsp], 25
  00054	eb 35		 jmp	 SHORT $LN11@compiler_h
$LN9@compiler_h:

; 3580 :         case AugStore:/* fall through to Store */
; 3581 :         case Store:   op = STORE_SUBSCR; break;

  00056	c7 44 24 20 3c
	00 00 00	 mov	 DWORD PTR op$[rsp], 60	; 0000003cH
  0005e	eb 2b		 jmp	 SHORT $LN11@compiler_h
$LN8@compiler_h:

; 3582 :         case Del:     op = DELETE_SUBSCR; break;

  00060	c7 44 24 20 3d
	00 00 00	 mov	 DWORD PTR op$[rsp], 61	; 0000003dH
  00068	eb 21		 jmp	 SHORT $LN11@compiler_h
$LN7@compiler_h:

; 3583 :         case Param:
; 3584 :             PyErr_Format(PyExc_SystemError,
; 3585 :                          "invalid %s kind %d in subscript\n",
; 3586 :                          kind, ctx);

  0006a	44 8b 4c 24 50	 mov	 r9d, DWORD PTR ctx$[rsp]
  0006f	4c 8b 44 24 48	 mov	 r8, QWORD PTR kind$[rsp]
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@GFGBAOAN@invalid?5?$CFs?5kind?5?$CFd?5in?5subscript?6@
  0007b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00082	e8 00 00 00 00	 call	 PyErr_Format

; 3587 :             return 0;

  00087	33 c0		 xor	 eax, eax
  00089	eb 59		 jmp	 SHORT $LN13@compiler_h
$LN11@compiler_h:

; 3588 :     }
; 3589 :     if (ctx == AugLoad) {

  0008b	83 7c 24 50 04	 cmp	 DWORD PTR ctx$[rsp], 4
  00090	75 19		 jne	 SHORT $LN6@compiler_h

; 3590 :         ADDOP(c, DUP_TOP_TWO);

  00092	ba 05 00 00 00	 mov	 edx, 5
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0009c	e8 00 00 00 00	 call	 compiler_addop
  000a1	85 c0		 test	 eax, eax
  000a3	75 04		 jne	 SHORT $LN5@compiler_h
  000a5	33 c0		 xor	 eax, eax
  000a7	eb 3b		 jmp	 SHORT $LN13@compiler_h
$LN5@compiler_h:

; 3591 :     }
; 3592 :     else if (ctx == AugStore) {

  000a9	eb 1e		 jmp	 SHORT $LN4@compiler_h
$LN6@compiler_h:
  000ab	83 7c 24 50 05	 cmp	 DWORD PTR ctx$[rsp], 5
  000b0	75 17		 jne	 SHORT $LN3@compiler_h

; 3593 :         ADDOP(c, ROT_THREE);

  000b2	ba 03 00 00 00	 mov	 edx, 3
  000b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000bc	e8 00 00 00 00	 call	 compiler_addop
  000c1	85 c0		 test	 eax, eax
  000c3	75 04		 jne	 SHORT $LN2@compiler_h
  000c5	33 c0		 xor	 eax, eax
  000c7	eb 1b		 jmp	 SHORT $LN13@compiler_h
$LN2@compiler_h:
$LN3@compiler_h:
$LN4@compiler_h:

; 3594 :     }
; 3595 :     ADDOP(c, op);

  000c9	8b 54 24 20	 mov	 edx, DWORD PTR op$[rsp]
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000d2	e8 00 00 00 00	 call	 compiler_addop
  000d7	85 c0		 test	 eax, eax
  000d9	75 04		 jne	 SHORT $LN1@compiler_h
  000db	33 c0		 xor	 eax, eax
  000dd	eb 05		 jmp	 SHORT $LN13@compiler_h
$LN1@compiler_h:

; 3596 :     return 1;

  000df	b8 01 00 00 00	 mov	 eax, 1
$LN13@compiler_h:

; 3597 : }

  000e4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e8	c3		 ret	 0
  000e9	0f 1f 00	 npad	 3
$LN15@compiler_h:
  000ec	00 00 00 00	 DD	 $LN10@compiler_h
  000f0	00 00 00 00	 DD	 $LN9@compiler_h
  000f4	00 00 00 00	 DD	 $LN8@compiler_h
  000f8	00 00 00 00	 DD	 $LN10@compiler_h
  000fc	00 00 00 00	 DD	 $LN9@compiler_h
  00100	00 00 00 00	 DD	 $LN7@compiler_h
compiler_handle_subscr ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@HPBCDGBI@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAl?$AAi?$AAc?$AAe?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_slice DD imagerel compiler_slice
	DD	imagerel compiler_slice+326
	DD	imagerel $unwind$compiler_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_slice DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1CM@HPBCDGBI@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAl?$AAi?$AAc?$AAe?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@HPBCDGBI@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAl?$AAi?$AAc?$AAe?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@ DB 's'
	DB	00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'l', 00H, 'i'
	DB	00H, 'c', 00H, 'e', 00H, '_', 00H, 'k', 00H, 'i', 00H, 'n', 00H
	DB	'd', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_slice
_TEXT	SEGMENT
n$ = 32
c$ = 64
s$ = 72
ctx$ = 80
compiler_slice PROC					; COMDAT

; 3601 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3602 :     int n = 2;

  00013	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR n$[rsp], 2

; 3603 :     assert(s->kind == Slice_kind);

  0001b	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00020	83 38 01	 cmp	 DWORD PTR [rax], 1
  00023	74 1c		 je	 SHORT $LN14@compiler_s@4
  00025	41 b8 13 0e 00
	00		 mov	 r8d, 3603		; 00000e13H
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@HPBCDGBI@?$AAs?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAl?$AAi?$AAc?$AAe?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?$AA@
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003f	33 c0		 xor	 eax, eax
$LN14@compiler_s@4:

; 3604 : 
; 3605 :     /* only handles the cases where BUILD_SLICE is emitted */
; 3606 :     if (s->v.Slice.lower) {

  00041	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00046	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0004b	74 20		 je	 SHORT $LN11@compiler_s@4

; 3607 :         VISIT(c, expr, s->v.Slice.lower);

  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00052	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0005b	e8 00 00 00 00	 call	 compiler_visit_expr
  00060	85 c0		 test	 eax, eax
  00062	75 07		 jne	 SHORT $LN10@compiler_s@4
  00064	33 c0		 xor	 eax, eax
  00066	e9 d6 00 00 00	 jmp	 $LN12@compiler_s@4
$LN10@compiler_s@4:

; 3608 :     }
; 3609 :     else {

  0006b	eb 2e		 jmp	 SHORT $LN9@compiler_s@4
$LN11@compiler_s@4:

; 3610 :         ADDOP_O(c, LOAD_CONST, Py_None, consts);

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00072	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00076	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0007d	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00081	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00086	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0008b	e8 00 00 00 00	 call	 compiler_addop_o
  00090	85 c0		 test	 eax, eax
  00092	75 07		 jne	 SHORT $LN8@compiler_s@4
  00094	33 c0		 xor	 eax, eax
  00096	e9 a6 00 00 00	 jmp	 $LN12@compiler_s@4
$LN8@compiler_s@4:
$LN9@compiler_s@4:

; 3611 :     }
; 3612 : 
; 3613 :     if (s->v.Slice.upper) {

  0009b	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  000a0	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000a5	74 1d		 je	 SHORT $LN7@compiler_s@4

; 3614 :         VISIT(c, expr, s->v.Slice.upper);

  000a7	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  000ac	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000b5	e8 00 00 00 00	 call	 compiler_visit_expr
  000ba	85 c0		 test	 eax, eax
  000bc	75 04		 jne	 SHORT $LN6@compiler_s@4
  000be	33 c0		 xor	 eax, eax
  000c0	eb 7f		 jmp	 SHORT $LN12@compiler_s@4
$LN6@compiler_s@4:

; 3615 :     }
; 3616 :     else {

  000c2	eb 2b		 jmp	 SHORT $LN5@compiler_s@4
$LN7@compiler_s@4:

; 3617 :         ADDOP_O(c, LOAD_CONST, Py_None, consts);

  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000c9	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000cd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000d4	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  000d8	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000e2	e8 00 00 00 00	 call	 compiler_addop_o
  000e7	85 c0		 test	 eax, eax
  000e9	75 04		 jne	 SHORT $LN4@compiler_s@4
  000eb	33 c0		 xor	 eax, eax
  000ed	eb 52		 jmp	 SHORT $LN12@compiler_s@4
$LN4@compiler_s@4:
$LN5@compiler_s@4:

; 3618 :     }
; 3619 : 
; 3620 :     if (s->v.Slice.step) {

  000ef	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  000f4	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000f9	74 25		 je	 SHORT $LN3@compiler_s@4

; 3621 :         n++;

  000fb	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000ff	ff c0		 inc	 eax
  00101	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 3622 :         VISIT(c, expr, s->v.Slice.step);

  00105	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0010a	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00113	e8 00 00 00 00	 call	 compiler_visit_expr
  00118	85 c0		 test	 eax, eax
  0011a	75 04		 jne	 SHORT $LN2@compiler_s@4
  0011c	33 c0		 xor	 eax, eax
  0011e	eb 21		 jmp	 SHORT $LN12@compiler_s@4
$LN2@compiler_s@4:
$LN3@compiler_s@4:

; 3623 :     }
; 3624 :     ADDOP_I(c, BUILD_SLICE, n);

  00120	44 8b 44 24 20	 mov	 r8d, DWORD PTR n$[rsp]
  00125	ba 85 00 00 00	 mov	 edx, 133		; 00000085H
  0012a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0012f	e8 00 00 00 00	 call	 compiler_addop_i
  00134	85 c0		 test	 eax, eax
  00136	75 04		 jne	 SHORT $LN1@compiler_s@4
  00138	33 c0		 xor	 eax, eax
  0013a	eb 05		 jmp	 SHORT $LN12@compiler_s@4
$LN1@compiler_s@4:

; 3625 :     return 1;

  0013c	b8 01 00 00 00	 mov	 eax, 1
$LN12@compiler_s@4:

; 3626 : }

  00141	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00145	c3		 ret	 0
compiler_slice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@PGJJNNIN@extended?5slice?5invalid?5in?5nested@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_nested_slice DD imagerel compiler_visit_nested_slice
	DD	imagerel compiler_visit_nested_slice+130
	DD	imagerel $unwind$compiler_visit_nested_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_nested_slice DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CH@PGJJNNIN@extended?5slice?5invalid?5in?5nested@
CONST	SEGMENT
??_C@_0CH@PGJJNNIN@extended?5slice?5invalid?5in?5nested@ DB 'extended sli'
	DB	'ce invalid in nested slice', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compiler_visit_nested_slice
_TEXT	SEGMENT
tv64 = 32
c$ = 64
s$ = 72
ctx$ = 80
compiler_visit_nested_slice PROC			; COMDAT

; 3631 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3632 :     switch (s->kind) {

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00018	8b 00		 mov	 eax, DWORD PTR [rax]
  0001a	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0001e	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  00023	74 09		 je	 SHORT $LN4@compiler_v@9
  00025	83 7c 24 20 03	 cmp	 DWORD PTR tv64[rsp], 3
  0002a	74 18		 je	 SHORT $LN3@compiler_v@9
  0002c	eb 33		 jmp	 SHORT $LN1@compiler_v@9
$LN4@compiler_v@9:

; 3633 :     case Slice_kind:
; 3634 :         return compiler_slice(c, s, ctx);

  0002e	44 8b 44 24 50	 mov	 r8d, DWORD PTR ctx$[rsp]
  00033	48 8b 54 24 48	 mov	 rdx, QWORD PTR s$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0003d	e8 00 00 00 00	 call	 compiler_slice
  00042	eb 39		 jmp	 SHORT $LN7@compiler_v@9
$LN3@compiler_v@9:

; 3635 :     case Index_kind:
; 3636 :         VISIT(c, expr, s->v.Index.value);

  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00049	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00052	e8 00 00 00 00	 call	 compiler_visit_expr
  00057	85 c0		 test	 eax, eax
  00059	75 04		 jne	 SHORT $LN2@compiler_v@9
  0005b	33 c0		 xor	 eax, eax
  0005d	eb 1e		 jmp	 SHORT $LN7@compiler_v@9
$LN2@compiler_v@9:

; 3637 :         break;

  0005f	eb 17		 jmp	 SHORT $LN5@compiler_v@9
$LN1@compiler_v@9:

; 3638 :     case ExtSlice_kind:
; 3639 :     default:
; 3640 :         PyErr_SetString(PyExc_SystemError,
; 3641 :                         "extended slice invalid in nested slice");

  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@PGJJNNIN@extended?5slice?5invalid?5in?5nested@
  00068	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0006f	e8 00 00 00 00	 call	 PyErr_SetString

; 3642 :         return 0;

  00074	33 c0		 xor	 eax, eax
  00076	eb 05		 jmp	 SHORT $LN7@compiler_v@9
$LN5@compiler_v@9:

; 3643 :     }
; 3644 :     return 1;

  00078	b8 01 00 00 00	 mov	 eax, 1
$LN7@compiler_v@9:

; 3645 : }

  0007d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00081	c3		 ret	 0
compiler_visit_nested_slice ENDP
_TEXT	ENDS
EXTRN	_PyBytes_Resize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble DD imagerel assemble
	DD	imagerel assemble+647
	DD	imagerel $unwind$assemble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble DD 021001H
	DD	0110110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT assemble
_TEXT	SEGMENT
a$ = 32
i$ = 80
nblocks$ = 84
entryblock$ = 88
b$ = 96
co$ = 104
j$ = 112
c$ = 144
addNone$ = 152
assemble PROC						; COMDAT

; 4197 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 4198 :     basicblock *b, *entryblock;
; 4199 :     struct assembler a;
; 4200 :     int i, j, nblocks;
; 4201 :     PyCodeObject *co = NULL;

  00010	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR co$[rsp], 0

; 4202 : 
; 4203 :     /* Make sure every block that falls off the end returns None.
; 4204 :        XXX NEXT_BLOCK() isn't quite right, because if the last
; 4205 :        block ends with a jump or return b_next shouldn't set.
; 4206 :      */
; 4207 :     if (!c->u->u_curblock->b_return) {

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00021	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00025	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00029	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0002c	d1 e8		 shr	 eax, 1
  0002e	83 e0 01	 and	 eax, 1
  00031	85 c0		 test	 eax, eax
  00033	75 74		 jne	 SHORT $LN21@assemble

; 4208 :         NEXT_BLOCK(c);

  00035	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0003d	e8 00 00 00 00	 call	 compiler_next_block
  00042	48 85 c0	 test	 rax, rax
  00045	75 07		 jne	 SHORT $LN20@assemble
  00047	33 c0		 xor	 eax, eax
  00049	e9 31 02 00 00	 jmp	 $LN22@assemble
$LN20@assemble:

; 4209 :         if (addNone)

  0004e	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR addNone$[rsp], 0
  00056	74 34		 je	 SHORT $LN19@assemble

; 4210 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00058	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00060	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00064	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0006b	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  0006f	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00074	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0007c	e8 00 00 00 00	 call	 compiler_addop_o
  00081	85 c0		 test	 eax, eax
  00083	75 07		 jne	 SHORT $LN18@assemble
  00085	33 c0		 xor	 eax, eax
  00087	e9 f3 01 00 00	 jmp	 $LN22@assemble
$LN18@assemble:
$LN19@assemble:

; 4211 :         ADDOP(c, RETURN_VALUE);

  0008c	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  00091	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00099	e8 00 00 00 00	 call	 compiler_addop
  0009e	85 c0		 test	 eax, eax
  000a0	75 07		 jne	 SHORT $LN17@assemble
  000a2	33 c0		 xor	 eax, eax
  000a4	e9 d6 01 00 00	 jmp	 $LN22@assemble
$LN17@assemble:
$LN21@assemble:

; 4212 :     }
; 4213 : 
; 4214 :     nblocks = 0;

  000a9	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR nblocks$[rsp], 0

; 4215 :     entryblock = NULL;

  000b1	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR entryblock$[rsp], 0

; 4216 :     for (b = c->u->u_blocks; b != NULL; b = b->b_list) {

  000ba	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000c2	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000c6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ca	48 89 44 24 60	 mov	 QWORD PTR b$[rsp], rax
  000cf	eb 0d		 jmp	 SHORT $LN16@assemble
$LN15@assemble:
  000d1	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
  000d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d9	48 89 44 24 60	 mov	 QWORD PTR b$[rsp], rax
$LN16@assemble:
  000de	48 83 7c 24 60
	00		 cmp	 QWORD PTR b$[rsp], 0
  000e4	74 16		 je	 SHORT $LN14@assemble

; 4217 :         nblocks++;

  000e6	8b 44 24 54	 mov	 eax, DWORD PTR nblocks$[rsp]
  000ea	ff c0		 inc	 eax
  000ec	89 44 24 54	 mov	 DWORD PTR nblocks$[rsp], eax

; 4218 :         entryblock = b;

  000f0	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
  000f5	48 89 44 24 58	 mov	 QWORD PTR entryblock$[rsp], rax

; 4219 :     }

  000fa	eb d5		 jmp	 SHORT $LN15@assemble
$LN14@assemble:

; 4220 : 
; 4221 :     /* Set firstlineno if it wasn't explicitly set. */
; 4222 :     if (!c->u->u_firstlineno) {

  000fc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00104	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00108	83 b8 b0 01 00
	00 00		 cmp	 DWORD PTR [rax+432], 0
  0010f	75 4a		 jne	 SHORT $LN13@assemble

; 4223 :         if (entryblock && entryblock->b_instr)

  00111	48 83 7c 24 58
	00		 cmp	 QWORD PTR entryblock$[rsp], 0
  00117	74 2c		 je	 SHORT $LN12@assemble
  00119	48 8b 44 24 58	 mov	 rax, QWORD PTR entryblock$[rsp]
  0011e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00123	74 20		 je	 SHORT $LN12@assemble

; 4224 :             c->u->u_firstlineno = entryblock->b_instr->i_lineno;

  00125	48 8b 44 24 58	 mov	 rax, QWORD PTR entryblock$[rsp]
  0012a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0012e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00136	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0013a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0013d	89 81 b0 01 00
	00		 mov	 DWORD PTR [rcx+432], eax

; 4225 :         else

  00143	eb 16		 jmp	 SHORT $LN11@assemble
$LN12@assemble:

; 4226 :             c->u->u_firstlineno = 1;

  00145	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0014d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00151	c7 80 b0 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+432], 1
$LN11@assemble:
$LN13@assemble:

; 4227 :     }
; 4228 :     if (!assemble_init(&a, nblocks, c->u->u_firstlineno))

  0015b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00163	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00167	44 8b 80 b0 01
	00 00		 mov	 r8d, DWORD PTR [rax+432]
  0016e	8b 54 24 54	 mov	 edx, DWORD PTR nblocks$[rsp]
  00172	48 8d 4c 24 20	 lea	 rcx, QWORD PTR a$[rsp]
  00177	e8 00 00 00 00	 call	 assemble_init
  0017c	85 c0		 test	 eax, eax
  0017e	75 05		 jne	 SHORT $LN10@assemble

; 4229 :         goto error;

  00180	e9 eb 00 00 00	 jmp	 $error$25467
$LN10@assemble:

; 4230 :     dfs(c, entryblock, &a);

  00185	4c 8d 44 24 20	 lea	 r8, QWORD PTR a$[rsp]
  0018a	48 8b 54 24 58	 mov	 rdx, QWORD PTR entryblock$[rsp]
  0018f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00197	e8 00 00 00 00	 call	 dfs

; 4231 : 
; 4232 :     /* Can't modify the bytecode after computing jump offsets. */
; 4233 :     assemble_jump_offsets(&a, c);

  0019c	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  001a4	48 8d 4c 24 20	 lea	 rcx, QWORD PTR a$[rsp]
  001a9	e8 00 00 00 00	 call	 assemble_jump_offsets

; 4234 : 
; 4235 :     /* Emit code in reverse postorder from dfs. */
; 4236 :     for (i = a.a_nblocks - 1; i >= 0; i--) {

  001ae	8b 44 24 2c	 mov	 eax, DWORD PTR a$[rsp+12]
  001b2	ff c8		 dec	 eax
  001b4	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
  001b8	eb 0a		 jmp	 SHORT $LN9@assemble
$LN8@assemble:
  001ba	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  001be	ff c8		 dec	 eax
  001c0	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN9@assemble:
  001c4	83 7c 24 50 00	 cmp	 DWORD PTR i$[rsp], 0
  001c9	7c 5e		 jl	 SHORT $LN7@assemble

; 4237 :         b = a.a_postorder[i];

  001cb	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  001d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp+16]
  001d5	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  001d9	48 89 44 24 60	 mov	 QWORD PTR b$[rsp], rax

; 4238 :         for (j = 0; j < b->b_iused; j++)

  001de	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  001e6	eb 0a		 jmp	 SHORT $LN6@assemble
$LN5@assemble:
  001e8	8b 44 24 70	 mov	 eax, DWORD PTR j$[rsp]
  001ec	ff c0		 inc	 eax
  001ee	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax
$LN6@assemble:
  001f2	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
  001f7	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001fa	39 44 24 70	 cmp	 DWORD PTR j$[rsp], eax
  001fe	7d 27		 jge	 SHORT $LN4@assemble

; 4239 :             if (!assemble_emit(&a, &b->b_instr[j]))

  00200	48 63 44 24 70	 movsxd	 rax, DWORD PTR j$[rsp]
  00205	48 6b c0 20	 imul	 rax, 32			; 00000020H
  00209	48 8b 4c 24 60	 mov	 rcx, QWORD PTR b$[rsp]
  0020e	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00212	48 8b d0	 mov	 rdx, rax
  00215	48 8d 4c 24 20	 lea	 rcx, QWORD PTR a$[rsp]
  0021a	e8 00 00 00 00	 call	 assemble_emit
  0021f	85 c0		 test	 eax, eax
  00221	75 02		 jne	 SHORT $LN3@assemble

; 4240 :                 goto error;

  00223	eb 4b		 jmp	 SHORT $error$25467
$LN3@assemble:

; 4241 :     }

  00225	eb c1		 jmp	 SHORT $LN5@assemble
$LN4@assemble:
  00227	eb 91		 jmp	 SHORT $LN8@assemble
$LN7@assemble:

; 4242 : 
; 4243 :     if (_PyBytes_Resize(&a.a_lnotab, a.a_lnotab_off) < 0)

  00229	48 63 44 24 40	 movsxd	 rax, DWORD PTR a$[rsp+32]
  0022e	48 8b d0	 mov	 rdx, rax
  00231	48 8d 4c 24 38	 lea	 rcx, QWORD PTR a$[rsp+24]
  00236	e8 00 00 00 00	 call	 _PyBytes_Resize
  0023b	85 c0		 test	 eax, eax
  0023d	7d 02		 jge	 SHORT $LN2@assemble

; 4244 :         goto error;

  0023f	eb 2f		 jmp	 SHORT $error$25467
$LN2@assemble:

; 4245 :     if (_PyBytes_Resize(&a.a_bytecode, a.a_offset) < 0)

  00241	48 63 44 24 28	 movsxd	 rax, DWORD PTR a$[rsp+8]
  00246	48 8b d0	 mov	 rdx, rax
  00249	48 8d 4c 24 20	 lea	 rcx, QWORD PTR a$[rsp]
  0024e	e8 00 00 00 00	 call	 _PyBytes_Resize
  00253	85 c0		 test	 eax, eax
  00255	7d 02		 jge	 SHORT $LN1@assemble

; 4246 :         goto error;

  00257	eb 17		 jmp	 SHORT $error$25467
$LN1@assemble:

; 4247 : 
; 4248 :     co = makecode(c, &a);

  00259	48 8d 54 24 20	 lea	 rdx, QWORD PTR a$[rsp]
  0025e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00266	e8 00 00 00 00	 call	 makecode
  0026b	48 89 44 24 68	 mov	 QWORD PTR co$[rsp], rax
$error$25467:

; 4249 :  error:
; 4250 :     assemble_free(&a);

  00270	48 8d 4c 24 20	 lea	 rcx, QWORD PTR a$[rsp]
  00275	e8 00 00 00 00	 call	 assemble_free

; 4251 :     return co;

  0027a	48 8b 44 24 68	 mov	 rax, QWORD PTR co$[rsp]
$LN22@assemble:

; 4252 : }

  0027f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00286	c3		 ret	 0
assemble ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dfs DD	imagerel dfs
	DD	imagerel dfs+266
	DD	imagerel $unwind$dfs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dfs DD	011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT dfs
_TEXT	SEGMENT
i$ = 32
instr$ = 40
c$ = 64
b$ = 72
a$ = 80
dfs	PROC						; COMDAT

; 3707 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3708 :     int i;
; 3709 :     struct instr *instr = NULL;

  00013	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR instr$[rsp], 0

; 3710 : 
; 3711 :     if (b->b_seen)

  0001c	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00021	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00024	83 e0 01	 and	 eax, 1
  00027	85 c0		 test	 eax, eax
  00029	74 05		 je	 SHORT $LN7@dfs

; 3712 :         return;

  0002b	e9 d5 00 00 00	 jmp	 $LN8@dfs
$LN7@dfs:

; 3713 :     b->b_seen = 1;

  00030	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00035	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00038	83 c8 01	 or	 eax, 1
  0003b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR b$[rsp]
  00040	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 3714 :     if (b->b_next != NULL)

  00043	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00048	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0004d	74 18		 je	 SHORT $LN6@dfs

; 3715 :         dfs(c, b->b_next, a);

  0004f	4c 8b 44 24 50	 mov	 r8, QWORD PTR a$[rsp]
  00054	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00059	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00062	e8 00 00 00 00	 call	 dfs
$LN6@dfs:

; 3716 :     for (i = 0; i < b->b_iused; i++) {

  00067	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006f	eb 0a		 jmp	 SHORT $LN5@dfs
$LN4@dfs:
  00071	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00075	ff c0		 inc	 eax
  00077	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN5@dfs:
  0007b	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00080	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00083	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00087	7d 4f		 jge	 SHORT $LN3@dfs

; 3717 :         instr = &b->b_instr[i];

  00089	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0008e	48 6b c0 20	 imul	 rax, 32			; 00000020H
  00092	48 8b 4c 24 48	 mov	 rcx, QWORD PTR b$[rsp]
  00097	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0009b	48 89 44 24 28	 mov	 QWORD PTR instr$[rsp], rax

; 3718 :         if (instr->i_jrel || instr->i_jabs)

  000a0	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  000a5	8b 00		 mov	 eax, DWORD PTR [rax]
  000a7	d1 e8		 shr	 eax, 1
  000a9	83 e0 01	 and	 eax, 1
  000ac	85 c0		 test	 eax, eax
  000ae	75 0e		 jne	 SHORT $LN1@dfs
  000b0	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  000b5	8b 00		 mov	 eax, DWORD PTR [rax]
  000b7	83 e0 01	 and	 eax, 1
  000ba	85 c0		 test	 eax, eax
  000bc	74 18		 je	 SHORT $LN2@dfs
$LN1@dfs:

; 3719 :             dfs(c, instr->i_target, a);

  000be	4c 8b 44 24 50	 mov	 r8, QWORD PTR a$[rsp]
  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  000c8	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000d1	e8 00 00 00 00	 call	 dfs
$LN2@dfs:

; 3720 :     }

  000d6	eb 99		 jmp	 SHORT $LN4@dfs
$LN3@dfs:

; 3721 :     a->a_postorder[a->a_nblocks++] = b;

  000d8	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000dd	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  000e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000e6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000ea	48 8b 54 24 48	 mov	 rdx, QWORD PTR b$[rsp]
  000ef	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  000f3	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000f8	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000fb	ff c0		 inc	 eax
  000fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00102	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
$LN8@dfs:

; 3722 : }

  00105	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00109	c3		 ret	 0
dfs	ENDP
_TEXT	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble_init DD imagerel assemble_init
	DD	imagerel assemble_init+206
	DD	imagerel $unwind$assemble_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble_init DD 011201H
	DD	04212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT assemble_init
_TEXT	SEGMENT
a$ = 48
nblocks$ = 56
firstlineno$ = 64
assemble_init PROC					; COMDAT

; 3784 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3785 :     memset(a, 0, sizeof(struct assembler));

  00012	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  00018	33 d2		 xor	 edx, edx
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  0001f	e8 00 00 00 00	 call	 memset

; 3786 :     a->a_lineno = firstlineno;

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00029	8b 4c 24 40	 mov	 ecx, DWORD PTR firstlineno$[rsp]
  0002d	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 3787 :     a->a_bytecode = PyBytes_FromStringAndSize(NULL, DEFAULT_CODE_SIZE);

  00030	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00035	33 c9		 xor	 ecx, ecx
  00037	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00041	48 89 01	 mov	 QWORD PTR [rcx], rax

; 3788 :     if (!a->a_bytecode)

  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00049	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004d	75 04		 jne	 SHORT $LN4@assemble_i

; 3789 :         return 0;

  0004f	33 c0		 xor	 eax, eax
  00051	eb 76		 jmp	 SHORT $LN5@assemble_i
$LN4@assemble_i:

; 3790 :     a->a_lnotab = PyBytes_FromStringAndSize(NULL, DEFAULT_LNOTAB_SIZE);

  00053	ba 10 00 00 00	 mov	 edx, 16
  00058	33 c9		 xor	 ecx, ecx
  0005a	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00064	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 3791 :     if (!a->a_lnotab)

  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0006d	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00072	75 04		 jne	 SHORT $LN3@assemble_i

; 3792 :         return 0;

  00074	33 c0		 xor	 eax, eax
  00076	eb 51		 jmp	 SHORT $LN5@assemble_i
$LN3@assemble_i:

; 3793 :     if (nblocks > PY_SIZE_MAX / sizeof(basicblock *)) {

  00078	48 63 44 24 38	 movsxd	 rax, DWORD PTR nblocks$[rsp]
  0007d	48 b9 ff ff ff
	ff ff ff ff 1f	 mov	 rcx, 2305843009213693951 ; 1fffffffffffffffH
  00087	48 3b c1	 cmp	 rax, rcx
  0008a	76 09		 jbe	 SHORT $LN2@assemble_i

; 3794 :         PyErr_NoMemory();

  0008c	e8 00 00 00 00	 call	 PyErr_NoMemory

; 3795 :         return 0;

  00091	33 c0		 xor	 eax, eax
  00093	eb 34		 jmp	 SHORT $LN5@assemble_i
$LN2@assemble_i:

; 3796 :     }
; 3797 :     a->a_postorder = (basicblock **)PyObject_Malloc(
; 3798 :                                         sizeof(basicblock *) * nblocks);

  00095	48 63 44 24 38	 movsxd	 rax, DWORD PTR nblocks$[rsp]
  0009a	48 c1 e0 03	 shl	 rax, 3
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  000a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  000ab	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3799 :     if (!a->a_postorder) {

  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000b4	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000b9	75 09		 jne	 SHORT $LN1@assemble_i

; 3800 :         PyErr_NoMemory();

  000bb	e8 00 00 00 00	 call	 PyErr_NoMemory

; 3801 :         return 0;

  000c0	33 c0		 xor	 eax, eax
  000c2	eb 05		 jmp	 SHORT $LN5@assemble_i
$LN1@assemble_i:

; 3802 :     }
; 3803 :     return 1;

  000c4	b8 01 00 00 00	 mov	 eax, 1
$LN5@assemble_i:

; 3804 : }

  000c9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000cd	c3		 ret	 0
assemble_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble_free DD imagerel assemble_free
	DD	imagerel assemble_free+102
	DD	imagerel $unwind$assemble_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble_free DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT assemble_free
_TEXT	SEGMENT
a$ = 48
assemble_free PROC					; COMDAT

; 3808 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN9@assemble_f:

; 3809 :     Py_XDECREF(a->a_bytecode);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0000e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00012	74 0d		 je	 SHORT $LN6@assemble_f
  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00019	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0001c	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@assemble_f:
  00021	33 c0		 xor	 eax, eax
  00023	85 c0		 test	 eax, eax
  00025	75 e2		 jne	 SHORT $LN9@assemble_f
$LN5@assemble_f:

; 3810 :     Py_XDECREF(a->a_lnotab);

  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0002c	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00031	74 0e		 je	 SHORT $LN2@assemble_f
  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00038	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0003c	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@assemble_f:
  00041	33 c0		 xor	 eax, eax
  00043	85 c0		 test	 eax, eax
  00045	75 e0		 jne	 SHORT $LN5@assemble_f

; 3811 :     if (a->a_postorder)

  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0004c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00051	74 0e		 je	 SHORT $LN1@assemble_f

; 3812 :         PyObject_Free(a->a_postorder);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00058	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0005c	e8 00 00 00 00	 call	 _PyObject_DebugFree
$LN1@assemble_f:

; 3813 : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
assemble_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CO@OGNHKKBP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA6?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@PKKHKIJG@?$AAi?$AA?9?$AA?$DO?$AAi?$AA_?$AAh?$AAa?$AAs?$AAa?$AAr?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@PMDLBNNF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble_emit DD imagerel assemble_emit
	DD	imagerel assemble_emit+672
	DD	imagerel $unwind$assemble_emit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble_emit DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1CO@OGNHKKBP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@OGNHKKBP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA6?$AA?$AA@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '3', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '6', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@PKKHKIJG@?$AAi?$AA?9?$AA?$DO?$AAi?$AA_?$AAh?$AAa?$AAs?$AAa?$AAr?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@PKKHKIJG@?$AAi?$AA?9?$AA?$DO?$AAi?$AA_?$AAh?$AAa?$AAs?$AAa?$AAr?$AAg?$AA?$AA@ DB 'i'
	DB	00H, '-', 00H, '>', 00H, 'i', 00H, '_', 00H, 'h', 00H, 'a', 00H
	DB	's', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@PMDLBNNF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@PMDLBNNF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'a', 00H, '-', 00H, '>', 00H, 'a', 00H, '_', 00H, 'b', 00H
	DB	'y', 00H, 't', 00H, 'e', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT assemble_emit
_TEXT	SEGMENT
arg$ = 32
code$ = 40
len$ = 48
size$ = 56
ext$ = 60
a$ = 80
i$ = 88
assemble_emit PROC					; COMDAT

; 3942 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3943 :     int size, arg = 0, ext = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR arg$[rsp], 0
  00016	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR ext$[rsp], 0

; 3944 :     Py_ssize_t len = PyBytes_GET_SIZE(a->a_bytecode);

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00030	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00035	85 c0		 test	 eax, eax
  00037	75 1c		 jne	 SHORT $LN10@assemble_e
  00039	41 b8 68 0f 00
	00		 mov	 r8d, 3944		; 00000f68H
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@PMDLBNNF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00053	33 c0		 xor	 eax, eax
$LN10@assemble_e:
  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00061	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 3945 :     char *code;
; 3946 : 
; 3947 :     size = instrsize(i);

  00066	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i$[rsp]
  0006b	e8 00 00 00 00	 call	 instrsize
  00070	89 44 24 38	 mov	 DWORD PTR size$[rsp], eax

; 3948 :     if (i->i_hasarg) {

  00074	48 8b 44 24 58	 mov	 rax, QWORD PTR i$[rsp]
  00079	8b 00		 mov	 eax, DWORD PTR [rax]
  0007b	c1 e8 02	 shr	 eax, 2
  0007e	83 e0 01	 and	 eax, 1
  00081	85 c0		 test	 eax, eax
  00083	74 17		 je	 SHORT $LN7@assemble_e

; 3949 :         arg = i->i_oparg;

  00085	48 8b 44 24 58	 mov	 rax, QWORD PTR i$[rsp]
  0008a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0008d	89 44 24 20	 mov	 DWORD PTR arg$[rsp], eax

; 3950 :         ext = arg >> 16;

  00091	8b 44 24 20	 mov	 eax, DWORD PTR arg$[rsp]
  00095	c1 f8 10	 sar	 eax, 16
  00098	89 44 24 3c	 mov	 DWORD PTR ext$[rsp], eax
$LN7@assemble_e:

; 3951 :     }
; 3952 :     if (i->i_lineno && !assemble_lnotab(a, i))

  0009c	48 8b 44 24 58	 mov	 rax, QWORD PTR i$[rsp]
  000a1	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000a5	74 1a		 je	 SHORT $LN6@assemble_e
  000a7	48 8b 54 24 58	 mov	 rdx, QWORD PTR i$[rsp]
  000ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000b1	e8 00 00 00 00	 call	 assemble_lnotab
  000b6	85 c0		 test	 eax, eax
  000b8	75 07		 jne	 SHORT $LN6@assemble_e

; 3953 :         return 0;

  000ba	33 c0		 xor	 eax, eax
  000bc	e9 da 01 00 00	 jmp	 $LN8@assemble_e
$LN6@assemble_e:

; 3954 :     if (a->a_offset + size >= len) {

  000c1	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000c6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c9	03 44 24 38	 add	 eax, DWORD PTR size$[rsp]
  000cd	48 98		 cdqe
  000cf	48 3b 44 24 30	 cmp	 rax, QWORD PTR len$[rsp]
  000d4	7c 38		 jl	 SHORT $LN5@assemble_e

; 3955 :         if (len > PY_SSIZE_T_MAX / 2)

  000d6	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  000e0	48 39 44 24 30	 cmp	 QWORD PTR len$[rsp], rax
  000e5	7e 07		 jle	 SHORT $LN4@assemble_e

; 3956 :             return 0;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 ad 01 00 00	 jmp	 $LN8@assemble_e
$LN4@assemble_e:

; 3957 :         if (_PyBytes_Resize(&a->a_bytecode, len * 2) < 0)

  000ee	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  000f3	48 d1 e0	 shl	 rax, 1
  000f6	48 8b d0	 mov	 rdx, rax
  000f9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000fe	e8 00 00 00 00	 call	 _PyBytes_Resize
  00103	85 c0		 test	 eax, eax
  00105	7d 07		 jge	 SHORT $LN3@assemble_e

; 3958 :             return 0;

  00107	33 c0		 xor	 eax, eax
  00109	e9 8d 01 00 00	 jmp	 $LN8@assemble_e
$LN3@assemble_e:
$LN5@assemble_e:

; 3959 :     }
; 3960 :     code = PyBytes_AS_STRING(a->a_bytecode) + a->a_offset;

  0010e	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00113	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00116	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0011a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00120	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00125	85 c0		 test	 eax, eax
  00127	75 1c		 jne	 SHORT $LN11@assemble_e
  00129	41 b8 78 0f 00
	00		 mov	 r8d, 3960		; 00000f78H
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@PMDLBNNF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00143	33 c0		 xor	 eax, eax
$LN11@assemble_e:
  00145	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0014a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0014d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00152	48 63 49 08	 movsxd	 rcx, DWORD PTR [rcx+8]
  00156	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  0015b	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax

; 3961 :     a->a_offset += size;

  00160	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00165	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00168	03 44 24 38	 add	 eax, DWORD PTR size$[rsp]
  0016c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00171	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3962 :     if (size == 6) {

  00174	83 7c 24 38 06	 cmp	 DWORD PTR size$[rsp], 6
  00179	0f 85 87 00 00
	00		 jne	 $LN2@assemble_e

; 3963 :         assert(i->i_hasarg);

  0017f	48 8b 44 24 58	 mov	 rax, QWORD PTR i$[rsp]
  00184	8b 00		 mov	 eax, DWORD PTR [rax]
  00186	c1 e8 02	 shr	 eax, 2
  00189	83 e0 01	 and	 eax, 1
  0018c	85 c0		 test	 eax, eax
  0018e	75 1c		 jne	 SHORT $LN12@assemble_e
  00190	41 b8 7b 0f 00
	00		 mov	 r8d, 3963		; 00000f7bH
  00196	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0019d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@PKKHKIJG@?$AAi?$AA?9?$AA?$DO?$AAi?$AA_?$AAh?$AAa?$AAs?$AAa?$AAr?$AAg?$AA?$AA@
  001a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001aa	33 c0		 xor	 eax, eax
$LN12@assemble_e:

; 3964 :         *code++ = (char)EXTENDED_ARG;

  001ac	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  001b1	c6 00 90	 mov	 BYTE PTR [rax], -112	; ffffffffffffff90H
  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  001b9	48 ff c0	 inc	 rax
  001bc	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax

; 3965 :         *code++ = ext & 0xff;

  001c1	8b 44 24 3c	 mov	 eax, DWORD PTR ext$[rsp]
  001c5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR code$[rsp]
  001cf	88 01		 mov	 BYTE PTR [rcx], al
  001d1	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  001d6	48 ff c0	 inc	 rax
  001d9	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax

; 3966 :         *code++ = ext >> 8;

  001de	8b 44 24 3c	 mov	 eax, DWORD PTR ext$[rsp]
  001e2	c1 f8 08	 sar	 eax, 8
  001e5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR code$[rsp]
  001ea	88 01		 mov	 BYTE PTR [rcx], al
  001ec	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  001f1	48 ff c0	 inc	 rax
  001f4	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax

; 3967 :         arg &= 0xffff;

  001f9	8b 44 24 20	 mov	 eax, DWORD PTR arg$[rsp]
  001fd	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00202	89 44 24 20	 mov	 DWORD PTR arg$[rsp], eax
$LN2@assemble_e:

; 3968 :     }
; 3969 :     *code++ = i->i_opcode;

  00206	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  0020b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i$[rsp]
  00210	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00214	88 08		 mov	 BYTE PTR [rax], cl
  00216	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  0021b	48 ff c0	 inc	 rax
  0021e	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax

; 3970 :     if (i->i_hasarg) {

  00223	48 8b 44 24 58	 mov	 rax, QWORD PTR i$[rsp]
  00228	8b 00		 mov	 eax, DWORD PTR [rax]
  0022a	c1 e8 02	 shr	 eax, 2
  0022d	83 e0 01	 and	 eax, 1
  00230	85 c0		 test	 eax, eax
  00232	74 62		 je	 SHORT $LN1@assemble_e

; 3971 :         assert(size == 3 || size == 6);

  00234	83 7c 24 38 03	 cmp	 DWORD PTR size$[rsp], 3
  00239	74 23		 je	 SHORT $LN13@assemble_e
  0023b	83 7c 24 38 06	 cmp	 DWORD PTR size$[rsp], 6
  00240	74 1c		 je	 SHORT $LN13@assemble_e
  00242	41 b8 83 0f 00
	00		 mov	 r8d, 3971		; 00000f83H
  00248	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@OGNHKKBP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA6?$AA?$AA@
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0025c	33 c0		 xor	 eax, eax
$LN13@assemble_e:

; 3972 :         *code++ = arg & 0xff;

  0025e	8b 44 24 20	 mov	 eax, DWORD PTR arg$[rsp]
  00262	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00267	48 8b 4c 24 28	 mov	 rcx, QWORD PTR code$[rsp]
  0026c	88 01		 mov	 BYTE PTR [rcx], al
  0026e	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  00273	48 ff c0	 inc	 rax
  00276	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax

; 3973 :         *code++ = arg >> 8;

  0027b	8b 44 24 20	 mov	 eax, DWORD PTR arg$[rsp]
  0027f	c1 f8 08	 sar	 eax, 8
  00282	48 8b 4c 24 28	 mov	 rcx, QWORD PTR code$[rsp]
  00287	88 01		 mov	 BYTE PTR [rcx], al
  00289	48 8b 44 24 28	 mov	 rax, QWORD PTR code$[rsp]
  0028e	48 ff c0	 inc	 rax
  00291	48 89 44 24 28	 mov	 QWORD PTR code$[rsp], rax
$LN1@assemble_e:

; 3974 :     }
; 3975 :     return 1;

  00296	b8 01 00 00 00	 mov	 eax, 1
$LN8@assemble_e:

; 3976 : }

  0029b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0029f	c3		 ret	 0
assemble_emit ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT instrsize
_TEXT	SEGMENT
instr$ = 8
instrsize PROC						; COMDAT

; 3819 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 3820 :     if (!instr->i_hasarg)

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR instr$[rsp]
  0000a	8b 00		 mov	 eax, DWORD PTR [rax]
  0000c	c1 e8 02	 shr	 eax, 2
  0000f	83 e0 01	 and	 eax, 1
  00012	85 c0		 test	 eax, eax
  00014	75 07		 jne	 SHORT $LN2@instrsize

; 3821 :         return 1;               /* 1 byte for the opcode*/

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	eb 1a		 jmp	 SHORT $LN3@instrsize
$LN2@instrsize:

; 3822 :     if (instr->i_oparg > 0xffff)

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR instr$[rsp]
  00022	81 78 08 ff ff
	00 00		 cmp	 DWORD PTR [rax+8], 65535 ; 0000ffffH
  00029	7e 07		 jle	 SHORT $LN1@instrsize

; 3823 :         return 6;               /* 1 (opcode) + 1 (EXTENDED_ARG opcode) + 2 (oparg) + 2(oparg extended) */

  0002b	b8 06 00 00 00	 mov	 eax, 6
  00030	eb 05		 jmp	 SHORT $LN3@instrsize
$LN1@instrsize:

; 3824 :     return 3;                   /* 1 (opcode) + 2 (oparg) */

  00032	b8 03 00 00 00	 mov	 eax, 3
$LN3@instrsize:

; 3825 : }

  00037	f3 c3		 fatret	 0
instrsize ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@HFFKPBFD@?$AAd?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA5?$AA5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@JBDDLCHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAl?$AAn?$AAo?$AAt?$AAa?$AAb?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@DPECCHNP@?$AAd?$AA_?$AAl?$AAi?$AAn?$AAe?$AAn?$AAo?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@CHPDCON@?$AAd?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble_lnotab DD imagerel assemble_lnotab
	DD	imagerel assemble_lnotab+1485
	DD	imagerel $unwind$assemble_lnotab
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble_lnotab DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1CE@HFFKPBFD@?$AAd?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA5?$AA5?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@HFFKPBFD@?$AAd?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA5?$AA5?$AA?$AA@ DB 'd'
	DB	00H, '_', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, '2', 00H, '5', 00H, '5', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@JBDDLCHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAl?$AAn?$AAo?$AAt?$AAa?$AAb?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@JBDDLCHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAl?$AAn?$AAo?$AAt?$AAa?$AAb?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'a', 00H, '-', 00H, '>', 00H, 'a', 00H, '_', 00H, 'l', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, 'a', 00H, 'b', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@DPECCHNP@?$AAd?$AA_?$AAl?$AAi?$AAn?$AAe?$AAn?$AAo?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@DPECCHNP@?$AAd?$AA_?$AAl?$AAi?$AAn?$AAe?$AAn?$AAo?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'd'
	DB	00H, '_', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'n', 00H
	DB	'o', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@CHPDCON@?$AAd?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@CHPDCON@?$AAd?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'd'
	DB	00H, '_', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT assemble_lnotab
_TEXT	SEGMENT
d_bytecode$ = 32
len$ = 36
d_lineno$ = 40
lnotab$ = 48
ncodes$25210 = 56
nbytes$25209 = 60
j$25208 = 64
ncodes$25233 = 68
nbytes$25232 = 72
j$25231 = 76
a$ = 96
i$ = 104
assemble_lnotab PROC					; COMDAT

; 3844 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3845 :     int d_bytecode, d_lineno;
; 3846 :     int len;
; 3847 :     unsigned char *lnotab;
; 3848 : 
; 3849 :     d_bytecode = a->a_offset - a->a_lineno_off;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00018	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0001b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0001e	2b c1		 sub	 eax, ecx
  00020	89 44 24 20	 mov	 DWORD PTR d_bytecode$[rsp], eax

; 3850 :     d_lineno = i->i_lineno - a->a_lineno;

  00024	48 8b 44 24 68	 mov	 rax, QWORD PTR i$[rsp]
  00029	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  0002e	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  00031	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00034	2b c1		 sub	 eax, ecx
  00036	89 44 24 28	 mov	 DWORD PTR d_lineno$[rsp], eax

; 3851 : 
; 3852 :     assert(d_bytecode >= 0);

  0003a	83 7c 24 20 00	 cmp	 DWORD PTR d_bytecode$[rsp], 0
  0003f	7d 1c		 jge	 SHORT $LN28@assemble_l
  00041	41 b8 0c 0f 00
	00		 mov	 r8d, 3852		; 00000f0cH
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@CHPDCON@?$AAd?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005b	33 c0		 xor	 eax, eax
$LN28@assemble_l:

; 3853 :     assert(d_lineno >= 0);

  0005d	83 7c 24 28 00	 cmp	 DWORD PTR d_lineno$[rsp], 0
  00062	7d 1c		 jge	 SHORT $LN29@assemble_l
  00064	41 b8 0d 0f 00
	00		 mov	 r8d, 3853		; 00000f0dH
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@DPECCHNP@?$AAd?$AA_?$AAl?$AAi?$AAn?$AAe?$AAn?$AAo?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN29@assemble_l:

; 3854 : 
; 3855 :     if(d_bytecode == 0 && d_lineno == 0)

  00080	83 7c 24 20 00	 cmp	 DWORD PTR d_bytecode$[rsp], 0
  00085	75 11		 jne	 SHORT $LN25@assemble_l
  00087	83 7c 24 28 00	 cmp	 DWORD PTR d_lineno$[rsp], 0
  0008c	75 0a		 jne	 SHORT $LN25@assemble_l

; 3856 :         return 1;

  0008e	b8 01 00 00 00	 mov	 eax, 1
  00093	e9 30 05 00 00	 jmp	 $LN26@assemble_l
$LN25@assemble_l:

; 3857 : 
; 3858 :     if (d_bytecode > 255) {

  00098	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR d_bytecode$[rsp], 255 ; 000000ffH
  000a0	0f 8e a3 01 00
	00		 jle	 $LN24@assemble_l

; 3859 :         int j, nbytes, ncodes = d_bytecode / 255;

  000a6	8b 44 24 20	 mov	 eax, DWORD PTR d_bytecode$[rsp]
  000aa	99		 cdq
  000ab	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  000b0	f7 f9		 idiv	 ecx
  000b2	89 44 24 38	 mov	 DWORD PTR ncodes$25210[rsp], eax

; 3860 :         nbytes = a->a_lnotab_off + 2 * ncodes;

  000b6	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  000bb	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000be	8b 4c 24 38	 mov	 ecx, DWORD PTR ncodes$25210[rsp]
  000c2	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  000c5	89 44 24 3c	 mov	 DWORD PTR nbytes$25209[rsp], eax

; 3861 :         len = PyBytes_GET_SIZE(a->a_lnotab);

  000c9	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  000ce	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000d2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d6	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000dc	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000e1	85 c0		 test	 eax, eax
  000e3	75 1c		 jne	 SHORT $LN30@assemble_l
  000e5	41 b8 15 0f 00
	00		 mov	 r8d, 3861		; 00000f15H
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@JBDDLCHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAl?$AAn?$AAo?$AAt?$AAa?$AAb?$AA?$CJ?$AA?$AA@
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ff	33 c0		 xor	 eax, eax
$LN30@assemble_l:
  00101	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00106	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0010a	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0010d	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 3862 :         if (nbytes >= len) {

  00111	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00115	39 44 24 3c	 cmp	 DWORD PTR nbytes$25209[rsp], eax
  00119	7c 63		 jl	 SHORT $LN23@assemble_l

; 3863 :             if ((len <= INT_MAX / 2) && (len * 2 < nbytes))

  0011b	81 7c 24 24 ff
	ff ff 3f	 cmp	 DWORD PTR len$[rsp], 1073741823 ; 3fffffffH
  00123	7f 16		 jg	 SHORT $LN22@assemble_l
  00125	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00129	d1 e0		 shl	 eax, 1
  0012b	3b 44 24 3c	 cmp	 eax, DWORD PTR nbytes$25209[rsp]
  0012f	7d 0a		 jge	 SHORT $LN22@assemble_l

; 3864 :                 len = nbytes;

  00131	8b 44 24 3c	 mov	 eax, DWORD PTR nbytes$25209[rsp]
  00135	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax
  00139	eb 22		 jmp	 SHORT $LN21@assemble_l
$LN22@assemble_l:

; 3865 :             else if (len <= INT_MAX / 2)

  0013b	81 7c 24 24 ff
	ff ff 3f	 cmp	 DWORD PTR len$[rsp], 1073741823 ; 3fffffffH
  00143	7f 0c		 jg	 SHORT $LN20@assemble_l

; 3866 :                 len *= 2;

  00145	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00149	d1 e0		 shl	 eax, 1
  0014b	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 3867 :             else {

  0014f	eb 0c		 jmp	 SHORT $LN19@assemble_l
$LN20@assemble_l:

; 3868 :                 PyErr_NoMemory();

  00151	e8 00 00 00 00	 call	 PyErr_NoMemory

; 3869 :                 return 0;

  00156	33 c0		 xor	 eax, eax
  00158	e9 6b 04 00 00	 jmp	 $LN26@assemble_l
$LN19@assemble_l:
$LN21@assemble_l:

; 3870 :             }
; 3871 :             if (_PyBytes_Resize(&a->a_lnotab, len) < 0)

  0015d	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  00162	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00167	48 83 c1 18	 add	 rcx, 24
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 _PyBytes_Resize
  00173	85 c0		 test	 eax, eax
  00175	7d 07		 jge	 SHORT $LN18@assemble_l

; 3872 :                 return 0;

  00177	33 c0		 xor	 eax, eax
  00179	e9 4a 04 00 00	 jmp	 $LN26@assemble_l
$LN18@assemble_l:
$LN23@assemble_l:

; 3873 :         }
; 3874 :         lnotab = (unsigned char *)
; 3875 :                    PyBytes_AS_STRING(a->a_lnotab) + a->a_lnotab_off;

  0017e	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00183	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00187	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0018b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00191	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00196	85 c0		 test	 eax, eax
  00198	75 1c		 jne	 SHORT $LN31@assemble_l
  0019a	41 b8 23 0f 00
	00		 mov	 r8d, 3875		; 00000f23H
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@JBDDLCHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAl?$AAn?$AAo?$AAt?$AAa?$AAb?$AA?$CJ?$AA?$AA@
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b4	33 c0		 xor	 eax, eax
$LN31@assemble_l:
  001b6	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  001bb	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  001c4	48 63 49 20	 movsxd	 rcx, DWORD PTR [rcx+32]
  001c8	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  001cd	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3876 :         for (j = 0; j < ncodes; j++) {

  001d2	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR j$25208[rsp], 0
  001da	eb 0a		 jmp	 SHORT $LN17@assemble_l
$LN16@assemble_l:
  001dc	8b 44 24 40	 mov	 eax, DWORD PTR j$25208[rsp]
  001e0	ff c0		 inc	 eax
  001e2	89 44 24 40	 mov	 DWORD PTR j$25208[rsp], eax
$LN17@assemble_l:
  001e6	8b 44 24 38	 mov	 eax, DWORD PTR ncodes$25210[rsp]
  001ea	39 44 24 40	 cmp	 DWORD PTR j$25208[rsp], eax
  001ee	7d 2c		 jge	 SHORT $LN15@assemble_l

; 3877 :             *lnotab++ = 255;

  001f0	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  001f5	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  001f8	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  001fd	48 ff c0	 inc	 rax
  00200	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3878 :             *lnotab++ = 0;

  00205	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  0020a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0020d	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  00212	48 ff c0	 inc	 rax
  00215	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3879 :         }

  0021a	eb c0		 jmp	 SHORT $LN16@assemble_l
$LN15@assemble_l:

; 3880 :         d_bytecode -= ncodes * 255;

  0021c	8b 44 24 38	 mov	 eax, DWORD PTR ncodes$25210[rsp]
  00220	69 c0 ff 00 00
	00		 imul	 eax, 255		; 000000ffH
  00226	8b 4c 24 20	 mov	 ecx, DWORD PTR d_bytecode$[rsp]
  0022a	2b c8		 sub	 ecx, eax
  0022c	8b c1		 mov	 eax, ecx
  0022e	89 44 24 20	 mov	 DWORD PTR d_bytecode$[rsp], eax

; 3881 :         a->a_lnotab_off += ncodes * 2;

  00232	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00237	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0023a	8b 4c 24 38	 mov	 ecx, DWORD PTR ncodes$25210[rsp]
  0023e	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  00241	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00246	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN24@assemble_l:

; 3882 :     }
; 3883 :     assert(d_bytecode <= 255);

  00249	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR d_bytecode$[rsp], 255 ; 000000ffH
  00251	7e 1c		 jle	 SHORT $LN32@assemble_l
  00253	41 b8 2b 0f 00
	00		 mov	 r8d, 3883		; 00000f2bH
  00259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@HFFKPBFD@?$AAd?$AA_?$AAb?$AAy?$AAt?$AAe?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA5?$AA5?$AA?$AA@
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0026d	33 c0		 xor	 eax, eax
$LN32@assemble_l:

; 3884 :     if (d_lineno > 255) {

  0026f	81 7c 24 28 ff
	00 00 00	 cmp	 DWORD PTR d_lineno$[rsp], 255 ; 000000ffH
  00277	0f 8e d9 01 00
	00		 jle	 $LN14@assemble_l

; 3885 :         int j, nbytes, ncodes = d_lineno / 255;

  0027d	8b 44 24 28	 mov	 eax, DWORD PTR d_lineno$[rsp]
  00281	99		 cdq
  00282	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00287	f7 f9		 idiv	 ecx
  00289	89 44 24 44	 mov	 DWORD PTR ncodes$25233[rsp], eax

; 3886 :         nbytes = a->a_lnotab_off + 2 * ncodes;

  0028d	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00292	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00295	8b 4c 24 44	 mov	 ecx, DWORD PTR ncodes$25233[rsp]
  00299	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  0029c	89 44 24 48	 mov	 DWORD PTR nbytes$25232[rsp], eax

; 3887 :         len = PyBytes_GET_SIZE(a->a_lnotab);

  002a0	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  002a5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  002a9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002ad	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002b3	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002b8	85 c0		 test	 eax, eax
  002ba	75 1c		 jne	 SHORT $LN33@assemble_l
  002bc	41 b8 2f 0f 00
	00		 mov	 r8d, 3887		; 00000f2fH
  002c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@JBDDLCHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAl?$AAn?$AAo?$AAt?$AAa?$AAb?$AA?$CJ?$AA?$AA@
  002d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002d6	33 c0		 xor	 eax, eax
$LN33@assemble_l:
  002d8	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  002dd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  002e1	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  002e4	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 3888 :         if (nbytes >= len) {

  002e8	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  002ec	39 44 24 48	 cmp	 DWORD PTR nbytes$25232[rsp], eax
  002f0	7c 63		 jl	 SHORT $LN13@assemble_l

; 3889 :             if ((len <= INT_MAX / 2) && len * 2 < nbytes)

  002f2	81 7c 24 24 ff
	ff ff 3f	 cmp	 DWORD PTR len$[rsp], 1073741823 ; 3fffffffH
  002fa	7f 16		 jg	 SHORT $LN12@assemble_l
  002fc	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00300	d1 e0		 shl	 eax, 1
  00302	3b 44 24 48	 cmp	 eax, DWORD PTR nbytes$25232[rsp]
  00306	7d 0a		 jge	 SHORT $LN12@assemble_l

; 3890 :                 len = nbytes;

  00308	8b 44 24 48	 mov	 eax, DWORD PTR nbytes$25232[rsp]
  0030c	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax
  00310	eb 22		 jmp	 SHORT $LN11@assemble_l
$LN12@assemble_l:

; 3891 :             else if (len <= INT_MAX / 2)

  00312	81 7c 24 24 ff
	ff ff 3f	 cmp	 DWORD PTR len$[rsp], 1073741823 ; 3fffffffH
  0031a	7f 0c		 jg	 SHORT $LN10@assemble_l

; 3892 :                 len *= 2;

  0031c	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00320	d1 e0		 shl	 eax, 1
  00322	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 3893 :             else {

  00326	eb 0c		 jmp	 SHORT $LN9@assemble_l
$LN10@assemble_l:

; 3894 :                 PyErr_NoMemory();

  00328	e8 00 00 00 00	 call	 PyErr_NoMemory

; 3895 :                 return 0;

  0032d	33 c0		 xor	 eax, eax
  0032f	e9 94 02 00 00	 jmp	 $LN26@assemble_l
$LN9@assemble_l:
$LN11@assemble_l:

; 3896 :             }
; 3897 :             if (_PyBytes_Resize(&a->a_lnotab, len) < 0)

  00334	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  00339	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  0033e	48 83 c1 18	 add	 rcx, 24
  00342	48 8b d0	 mov	 rdx, rax
  00345	e8 00 00 00 00	 call	 _PyBytes_Resize
  0034a	85 c0		 test	 eax, eax
  0034c	7d 07		 jge	 SHORT $LN8@assemble_l

; 3898 :                 return 0;

  0034e	33 c0		 xor	 eax, eax
  00350	e9 73 02 00 00	 jmp	 $LN26@assemble_l
$LN8@assemble_l:
$LN13@assemble_l:

; 3899 :         }
; 3900 :         lnotab = (unsigned char *)
; 3901 :                    PyBytes_AS_STRING(a->a_lnotab) + a->a_lnotab_off;

  00355	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0035a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0035e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00362	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00368	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0036d	85 c0		 test	 eax, eax
  0036f	75 1c		 jne	 SHORT $LN34@assemble_l
  00371	41 b8 3d 0f 00
	00		 mov	 r8d, 3901		; 00000f3dH
  00377	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0037e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@JBDDLCHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAl?$AAn?$AAo?$AAt?$AAa?$AAb?$AA?$CJ?$AA?$AA@
  00385	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0038b	33 c0		 xor	 eax, eax
$LN34@assemble_l:
  0038d	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00392	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00396	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  0039b	48 63 49 20	 movsxd	 rcx, DWORD PTR [rcx+32]
  0039f	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  003a4	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3902 :         *lnotab++ = d_bytecode;

  003a9	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  003ae	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR d_bytecode$[rsp]
  003b3	88 08		 mov	 BYTE PTR [rax], cl
  003b5	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  003ba	48 ff c0	 inc	 rax
  003bd	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3903 :         *lnotab++ = 255;

  003c2	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  003c7	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  003ca	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  003cf	48 ff c0	 inc	 rax
  003d2	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3904 :         d_bytecode = 0;

  003d7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR d_bytecode$[rsp], 0

; 3905 :         for (j = 1; j < ncodes; j++) {

  003df	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR j$25231[rsp], 1
  003e7	eb 0a		 jmp	 SHORT $LN7@assemble_l
$LN6@assemble_l:
  003e9	8b 44 24 4c	 mov	 eax, DWORD PTR j$25231[rsp]
  003ed	ff c0		 inc	 eax
  003ef	89 44 24 4c	 mov	 DWORD PTR j$25231[rsp], eax
$LN7@assemble_l:
  003f3	8b 44 24 44	 mov	 eax, DWORD PTR ncodes$25233[rsp]
  003f7	39 44 24 4c	 cmp	 DWORD PTR j$25231[rsp], eax
  003fb	7d 2c		 jge	 SHORT $LN5@assemble_l

; 3906 :             *lnotab++ = 0;

  003fd	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  00402	c6 00 00	 mov	 BYTE PTR [rax], 0
  00405	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  0040a	48 ff c0	 inc	 rax
  0040d	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3907 :             *lnotab++ = 255;

  00412	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  00417	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  0041a	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  0041f	48 ff c0	 inc	 rax
  00422	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3908 :         }

  00427	eb c0		 jmp	 SHORT $LN6@assemble_l
$LN5@assemble_l:

; 3909 :         d_lineno -= ncodes * 255;

  00429	8b 44 24 44	 mov	 eax, DWORD PTR ncodes$25233[rsp]
  0042d	69 c0 ff 00 00
	00		 imul	 eax, 255		; 000000ffH
  00433	8b 4c 24 28	 mov	 ecx, DWORD PTR d_lineno$[rsp]
  00437	2b c8		 sub	 ecx, eax
  00439	8b c1		 mov	 eax, ecx
  0043b	89 44 24 28	 mov	 DWORD PTR d_lineno$[rsp], eax

; 3910 :         a->a_lnotab_off += ncodes * 2;

  0043f	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00444	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00447	8b 4c 24 44	 mov	 ecx, DWORD PTR ncodes$25233[rsp]
  0044b	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  0044e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00453	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN14@assemble_l:

; 3911 :     }
; 3912 : 
; 3913 :     len = PyBytes_GET_SIZE(a->a_lnotab);

  00456	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0045b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0045f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00463	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00469	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0046e	85 c0		 test	 eax, eax
  00470	75 1c		 jne	 SHORT $LN35@assemble_l
  00472	41 b8 49 0f 00
	00		 mov	 r8d, 3913		; 00000f49H
  00478	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0047f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@JBDDLCHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAl?$AAn?$AAo?$AAt?$AAa?$AAb?$AA?$CJ?$AA?$AA@
  00486	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0048c	33 c0		 xor	 eax, eax
$LN35@assemble_l:
  0048e	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00493	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00497	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0049a	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 3914 :     if (a->a_lnotab_off + 2 >= len) {

  0049e	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  004a3	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  004a6	83 c0 02	 add	 eax, 2
  004a9	3b 44 24 24	 cmp	 eax, DWORD PTR len$[rsp]
  004ad	7c 24		 jl	 SHORT $LN4@assemble_l

; 3915 :         if (_PyBytes_Resize(&a->a_lnotab, len * 2) < 0)

  004af	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  004b3	d1 e0		 shl	 eax, 1
  004b5	48 98		 cdqe
  004b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  004bc	48 83 c1 18	 add	 rcx, 24
  004c0	48 8b d0	 mov	 rdx, rax
  004c3	e8 00 00 00 00	 call	 _PyBytes_Resize
  004c8	85 c0		 test	 eax, eax
  004ca	7d 07		 jge	 SHORT $LN3@assemble_l

; 3916 :             return 0;

  004cc	33 c0		 xor	 eax, eax
  004ce	e9 f5 00 00 00	 jmp	 $LN26@assemble_l
$LN3@assemble_l:
$LN4@assemble_l:

; 3917 :     }
; 3918 :     lnotab = (unsigned char *)
; 3919 :                     PyBytes_AS_STRING(a->a_lnotab) + a->a_lnotab_off;

  004d3	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  004d8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  004dc	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  004e0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  004e6	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  004eb	85 c0		 test	 eax, eax
  004ed	75 1c		 jne	 SHORT $LN36@assemble_l
  004ef	41 b8 4f 0f 00
	00		 mov	 r8d, 3919		; 00000f4fH
  004f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  004fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@JBDDLCHH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?9?$AA?$DO?$AAa?$AA_?$AAl?$AAn?$AAo?$AAt?$AAa?$AAb?$AA?$CJ?$AA?$AA@
  00503	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00509	33 c0		 xor	 eax, eax
$LN36@assemble_l:
  0050b	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00510	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00514	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00519	48 63 49 20	 movsxd	 rcx, DWORD PTR [rcx+32]
  0051d	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  00522	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3920 : 
; 3921 :     a->a_lnotab_off += 2;

  00527	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0052c	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0052f	83 c0 02	 add	 eax, 2
  00532	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00537	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 3922 :     if (d_bytecode) {

  0053a	83 7c 24 20 00	 cmp	 DWORD PTR d_bytecode$[rsp], 0
  0053f	74 34		 je	 SHORT $LN2@assemble_l

; 3923 :         *lnotab++ = d_bytecode;

  00541	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  00546	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR d_bytecode$[rsp]
  0054b	88 08		 mov	 BYTE PTR [rax], cl
  0054d	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  00552	48 ff c0	 inc	 rax
  00555	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3924 :         *lnotab++ = d_lineno;

  0055a	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  0055f	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR d_lineno$[rsp]
  00564	88 08		 mov	 BYTE PTR [rax], cl
  00566	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  0056b	48 ff c0	 inc	 rax
  0056e	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3925 :     }
; 3926 :     else {      /* First line of a block; def stmt, etc. */

  00573	eb 2e		 jmp	 SHORT $LN1@assemble_l
$LN2@assemble_l:

; 3927 :         *lnotab++ = 0;

  00575	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  0057a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0057d	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  00582	48 ff c0	 inc	 rax
  00585	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax

; 3928 :         *lnotab++ = d_lineno;

  0058a	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  0058f	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR d_lineno$[rsp]
  00594	88 08		 mov	 BYTE PTR [rax], cl
  00596	48 8b 44 24 30	 mov	 rax, QWORD PTR lnotab$[rsp]
  0059b	48 ff c0	 inc	 rax
  0059e	48 89 44 24 30	 mov	 QWORD PTR lnotab$[rsp], rax
$LN1@assemble_l:

; 3929 :     }
; 3930 :     a->a_lineno = i->i_lineno;

  005a3	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  005a8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR i$[rsp]
  005ad	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  005b0	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 3931 :     a->a_lineno_off = a->a_offset;

  005b3	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  005b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  005bd	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  005c0	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 3932 :     return 1;

  005c3	b8 01 00 00 00	 mov	 eax, 1
$LN26@assemble_l:

; 3933 : }

  005c8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  005cc	c3		 ret	 0
assemble_lnotab ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble_jump_offsets DD imagerel assemble_jump_offsets
	DD	imagerel assemble_jump_offsets+432
	DD	imagerel $unwind$assemble_jump_offsets
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble_jump_offsets DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT assemble_jump_offsets
_TEXT	SEGMENT
last_extended_arg_count$ = 32
totsize$ = 36
i$ = 40
bsize$ = 44
extended_arg_count$ = 48
b$ = 56
instr$25318 = 64
delta$25322 = 72
a$ = 96
c$ = 104
assemble_jump_offsets PROC				; COMDAT

; 3980 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3981 :     basicblock *b;
; 3982 :     int bsize, totsize, extended_arg_count = 0, last_extended_arg_count;

  0000e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR extended_arg_count$[rsp], 0
$LN17@assemble_j:

; 3983 :     int i;
; 3984 : 
; 3985 :     /* Compute the size of each block and fixup jump args.
; 3986 :        Replace block pointer with position in bytecode. */
; 3987 :     do {
; 3988 :         totsize = 0;

  00016	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR totsize$[rsp], 0

; 3989 :         for (i = a->a_nblocks - 1; i >= 0; i--) {

  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00023	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00026	ff c8		 dec	 eax
  00028	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  0002c	eb 0a		 jmp	 SHORT $LN14@assemble_j
$LN13@assemble_j:
  0002e	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00032	ff c8		 dec	 eax
  00034	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN14@assemble_j:
  00038	83 7c 24 28 00	 cmp	 DWORD PTR i$[rsp], 0
  0003d	7c 43		 jl	 SHORT $LN12@assemble_j

; 3990 :             b = a->a_postorder[i];

  0003f	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00049	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0004d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00051	48 89 44 24 38	 mov	 QWORD PTR b$[rsp], rax

; 3991 :             bsize = blocksize(b);

  00056	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$[rsp]
  0005b	e8 00 00 00 00	 call	 blocksize
  00060	89 44 24 2c	 mov	 DWORD PTR bsize$[rsp], eax

; 3992 :             b->b_offset = totsize;

  00064	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00069	8b 4c 24 24	 mov	 ecx, DWORD PTR totsize$[rsp]
  0006d	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 3993 :             totsize += bsize;

  00070	8b 44 24 2c	 mov	 eax, DWORD PTR bsize$[rsp]
  00074	8b 4c 24 24	 mov	 ecx, DWORD PTR totsize$[rsp]
  00078	03 c8		 add	 ecx, eax
  0007a	8b c1		 mov	 eax, ecx
  0007c	89 44 24 24	 mov	 DWORD PTR totsize$[rsp], eax

; 3994 :         }

  00080	eb ac		 jmp	 SHORT $LN13@assemble_j
$LN12@assemble_j:

; 3995 :         last_extended_arg_count = extended_arg_count;

  00082	8b 44 24 30	 mov	 eax, DWORD PTR extended_arg_count$[rsp]
  00086	89 44 24 20	 mov	 DWORD PTR last_extended_arg_count$[rsp], eax

; 3996 :         extended_arg_count = 0;

  0008a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR extended_arg_count$[rsp], 0

; 3997 :         for (b = c->u->u_blocks; b != NULL; b = b->b_list) {

  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR c$[rsp]
  00097	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0009b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009f	48 89 44 24 38	 mov	 QWORD PTR b$[rsp], rax
  000a4	eb 0d		 jmp	 SHORT $LN11@assemble_j
$LN10@assemble_j:
  000a6	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  000ab	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ae	48 89 44 24 38	 mov	 QWORD PTR b$[rsp], rax
$LN11@assemble_j:
  000b3	48 83 7c 24 38
	00		 cmp	 QWORD PTR b$[rsp], 0
  000b9	0f 84 de 00 00
	00		 je	 $LN9@assemble_j

; 3998 :             bsize = b->b_offset;

  000bf	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  000c4	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000c7	89 44 24 2c	 mov	 DWORD PTR bsize$[rsp], eax

; 3999 :             for (i = 0; i < b->b_iused; i++) {

  000cb	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000d3	eb 0a		 jmp	 SHORT $LN8@assemble_j
$LN7@assemble_j:
  000d5	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000d9	ff c0		 inc	 eax
  000db	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN8@assemble_j:
  000df	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  000e4	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000e7	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  000eb	0f 8d a7 00 00
	00		 jge	 $LN6@assemble_j

; 4000 :                 struct instr *instr = &b->b_instr[i];

  000f1	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  000f6	48 6b c0 20	 imul	 rax, 32			; 00000020H
  000fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$[rsp]
  000ff	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00103	48 89 44 24 40	 mov	 QWORD PTR instr$25318[rsp], rax

; 4001 :                 /* Relative jumps are computed relative to
; 4002 :                    the instruction pointer after fetching
; 4003 :                    the jump instruction.
; 4004 :                 */
; 4005 :                 bsize += instrsize(instr);

  00108	48 8b 4c 24 40	 mov	 rcx, QWORD PTR instr$25318[rsp]
  0010d	e8 00 00 00 00	 call	 instrsize
  00112	8b 4c 24 2c	 mov	 ecx, DWORD PTR bsize$[rsp]
  00116	03 c8		 add	 ecx, eax
  00118	8b c1		 mov	 eax, ecx
  0011a	89 44 24 2c	 mov	 DWORD PTR bsize$[rsp], eax

; 4006 :                 if (instr->i_jabs)

  0011e	48 8b 44 24 40	 mov	 rax, QWORD PTR instr$25318[rsp]
  00123	8b 00		 mov	 eax, DWORD PTR [rax]
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	74 16		 je	 SHORT $LN5@assemble_j

; 4007 :                     instr->i_oparg = instr->i_target->b_offset;

  0012c	48 8b 44 24 40	 mov	 rax, QWORD PTR instr$25318[rsp]
  00131	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00135	48 8b 4c 24 40	 mov	 rcx, QWORD PTR instr$25318[rsp]
  0013a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0013d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00140	eb 39		 jmp	 SHORT $LN4@assemble_j
$LN5@assemble_j:

; 4008 :                 else if (instr->i_jrel) {

  00142	48 8b 44 24 40	 mov	 rax, QWORD PTR instr$25318[rsp]
  00147	8b 00		 mov	 eax, DWORD PTR [rax]
  00149	d1 e8		 shr	 eax, 1
  0014b	83 e0 01	 and	 eax, 1
  0014e	85 c0		 test	 eax, eax
  00150	74 24		 je	 SHORT $LN3@assemble_j

; 4009 :                     int delta = instr->i_target->b_offset - bsize;

  00152	48 8b 44 24 40	 mov	 rax, QWORD PTR instr$25318[rsp]
  00157	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0015b	8b 4c 24 2c	 mov	 ecx, DWORD PTR bsize$[rsp]
  0015f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00162	2b c1		 sub	 eax, ecx
  00164	89 44 24 48	 mov	 DWORD PTR delta$25322[rsp], eax

; 4010 :                     instr->i_oparg = delta;

  00168	48 8b 44 24 40	 mov	 rax, QWORD PTR instr$25318[rsp]
  0016d	8b 4c 24 48	 mov	 ecx, DWORD PTR delta$25322[rsp]
  00171	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 4011 :                 }
; 4012 :                 else

  00174	eb 05		 jmp	 SHORT $LN2@assemble_j
$LN3@assemble_j:

; 4013 :                     continue;

  00176	e9 5a ff ff ff	 jmp	 $LN7@assemble_j
$LN2@assemble_j:
$LN4@assemble_j:

; 4014 :                 if (instr->i_oparg > 0xffff)

  0017b	48 8b 44 24 40	 mov	 rax, QWORD PTR instr$25318[rsp]
  00180	81 78 08 ff ff
	00 00		 cmp	 DWORD PTR [rax+8], 65535 ; 0000ffffH
  00187	7e 0a		 jle	 SHORT $LN1@assemble_j

; 4015 :                     extended_arg_count++;

  00189	8b 44 24 30	 mov	 eax, DWORD PTR extended_arg_count$[rsp]
  0018d	ff c0		 inc	 eax
  0018f	89 44 24 30	 mov	 DWORD PTR extended_arg_count$[rsp], eax
$LN1@assemble_j:

; 4016 :             }

  00193	e9 3d ff ff ff	 jmp	 $LN7@assemble_j
$LN6@assemble_j:

; 4017 :         }

  00198	e9 09 ff ff ff	 jmp	 $LN10@assemble_j
$LN9@assemble_j:

; 4018 : 
; 4019 :     /* XXX: This is an awful hack that could hurt performance, but
; 4020 :         on the bright side it should work until we come up
; 4021 :         with a better solution.
; 4022 : 
; 4023 :         The issue is that in the first loop blocksize() is called
; 4024 :         which calls instrsize() which requires i_oparg be set
; 4025 :         appropriately.          There is a bootstrap problem because
; 4026 :         i_oparg is calculated in the second loop above.
; 4027 : 
; 4028 :         So we loop until we stop seeing new EXTENDED_ARGs.
; 4029 :         The only EXTENDED_ARGs that could be popping up are
; 4030 :         ones in jump instructions.  So this should converge
; 4031 :         fairly quickly.
; 4032 :     */
; 4033 :     } while (last_extended_arg_count != extended_arg_count);

  0019d	8b 44 24 30	 mov	 eax, DWORD PTR extended_arg_count$[rsp]
  001a1	39 44 24 20	 cmp	 DWORD PTR last_extended_arg_count$[rsp], eax
  001a5	0f 85 6b fe ff
	ff		 jne	 $LN17@assemble_j

; 4034 : }

  001ab	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001af	c3		 ret	 0
assemble_jump_offsets ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$blocksize DD imagerel blocksize
	DD	imagerel blocksize+100
	DD	imagerel $unwind$blocksize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$blocksize DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT blocksize
_TEXT	SEGMENT
i$ = 32
size$ = 36
b$ = 64
blocksize PROC						; COMDAT

; 3829 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3830 :     int i;
; 3831 :     int size = 0;

  00009	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 3832 : 
; 3833 :     for (i = 0; i < b->b_iused; i++)

  00011	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00019	eb 0a		 jmp	 SHORT $LN3@blocksize
$LN2@blocksize:
  0001b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001f	ff c0		 inc	 eax
  00021	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN3@blocksize:
  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  0002a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00031	7d 28		 jge	 SHORT $LN1@blocksize

; 3834 :         size += instrsize(&b->b_instr[i]);

  00033	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00038	48 6b c0 20	 imul	 rax, 32			; 00000020H
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  00041	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 instrsize
  0004d	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00051	03 c8		 add	 ecx, eax
  00053	8b c1		 mov	 eax, ecx
  00055	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax
  00059	eb c0		 jmp	 SHORT $LN2@blocksize
$LN1@blocksize:

; 3835 :     return size;

  0005b	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]

; 3836 : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
blocksize ENDP
_TEXT	ENDS
EXTRN	PyCode_New:PROC
EXTRN	PyList_AsTuple:PROC
EXTRN	PyCode_Optimize:PROC
EXTRN	PyTuple_Size:PROC
EXTRN	PySequence_List:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$makecode DD imagerel makecode
	DD	imagerel makecode+1109
	DD	imagerel $unwind$makecode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$makecode DD 021101H
	DD	01f0111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT makecode
_TEXT	SEGMENT
freevars$ = 128
flags$ = 136
cellvars$ = 144
names$ = 152
tmp$ = 160
name$ = 168
nlocals$ = 176
bytecode$ = 184
co$ = 192
consts$ = 200
varnames$ = 208
tv204 = 216
tv203 = 224
tv201 = 232
c$ = 256
a$ = 264
makecode PROC						; COMDAT

; 4098 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 4099 :     PyObject *tmp;
; 4100 :     PyCodeObject *co = NULL;

  00011	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR co$[rsp], 0

; 4101 :     PyObject *consts = NULL;

  0001d	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR consts$[rsp], 0

; 4102 :     PyObject *names = NULL;

  00029	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR names$[rsp], 0

; 4103 :     PyObject *varnames = NULL;

  00035	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR varnames$[rsp], 0

; 4104 :     PyObject *name = NULL;

  00041	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR name$[rsp], 0

; 4105 :     PyObject *freevars = NULL;

  0004d	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR freevars$[rsp], 0

; 4106 :     PyObject *cellvars = NULL;

  00059	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR cellvars$[rsp], 0

; 4107 :     PyObject *bytecode = NULL;

  00065	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR bytecode$[rsp], 0

; 4108 :     int nlocals, flags;
; 4109 : 
; 4110 :     tmp = dict_keys_inorder(c->u->u_consts, 0);

  00071	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00079	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0007d	33 d2		 xor	 edx, edx
  0007f	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00083	e8 00 00 00 00	 call	 dict_keys_inorder
  00088	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tmp$[rsp], rax

; 4111 :     if (!tmp)

  00090	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR tmp$[rsp], 0
  00099	75 05		 jne	 SHORT $LN36@makecode

; 4112 :         goto error;

  0009b	e9 d3 02 00 00	 jmp	 $error$25394
$LN36@makecode:

; 4113 :     consts = PySequence_List(tmp); /* optimize_code requires a list */

  000a0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tmp$[rsp]
  000a8	e8 00 00 00 00	 call	 PySequence_List
  000ad	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR consts$[rsp], rax

; 4114 :     Py_DECREF(tmp);

  000b5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tmp$[rsp]
  000bd	e8 00 00 00 00	 call	 _Py_DecRef

; 4115 : 
; 4116 :     names = dict_keys_inorder(c->u->u_names, 0);

  000c2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000ca	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000ce	33 d2		 xor	 edx, edx
  000d0	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000d4	e8 00 00 00 00	 call	 dict_keys_inorder
  000d9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR names$[rsp], rax

; 4117 :     varnames = dict_keys_inorder(c->u->u_varnames, 0);

  000e1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000e9	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000ed	33 d2		 xor	 edx, edx
  000ef	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  000f3	e8 00 00 00 00	 call	 dict_keys_inorder
  000f8	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR varnames$[rsp], rax

; 4118 :     if (!consts || !names || !varnames)

  00100	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR consts$[rsp], 0
  00109	74 16		 je	 SHORT $LN34@makecode
  0010b	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR names$[rsp], 0
  00114	74 0b		 je	 SHORT $LN34@makecode
  00116	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR varnames$[rsp], 0
  0011f	75 05		 jne	 SHORT $LN35@makecode
$LN34@makecode:

; 4119 :         goto error;

  00121	e9 4d 02 00 00	 jmp	 $error$25394
$LN35@makecode:

; 4120 : 
; 4121 :     cellvars = dict_keys_inorder(c->u->u_cellvars, 0);

  00126	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0012e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00132	33 d2		 xor	 edx, edx
  00134	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00138	e8 00 00 00 00	 call	 dict_keys_inorder
  0013d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cellvars$[rsp], rax

; 4122 :     if (!cellvars)

  00145	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR cellvars$[rsp], 0
  0014e	75 05		 jne	 SHORT $LN33@makecode

; 4123 :         goto error;

  00150	e9 1e 02 00 00	 jmp	 $error$25394
$LN33@makecode:

; 4124 :     freevars = dict_keys_inorder(c->u->u_freevars, PyTuple_Size(cellvars));

  00155	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cellvars$[rsp]
  0015d	e8 00 00 00 00	 call	 PyTuple_Size
  00162	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0016a	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0016e	8b d0		 mov	 edx, eax
  00170	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00174	e8 00 00 00 00	 call	 dict_keys_inorder
  00179	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR freevars$[rsp], rax

; 4125 :     if (!freevars)

  00181	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR freevars$[rsp], 0
  0018a	75 05		 jne	 SHORT $LN32@makecode

; 4126 :         goto error;

  0018c	e9 e2 01 00 00	 jmp	 $error$25394
$LN32@makecode:

; 4127 :     nlocals = PyDict_Size(c->u->u_varnames);

  00191	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00199	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0019d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  001a1	e8 00 00 00 00	 call	 PyDict_Size
  001a6	89 84 24 b0 00
	00 00		 mov	 DWORD PTR nlocals$[rsp], eax

; 4128 :     flags = compute_code_flags(c);

  001ad	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001b5	e8 00 00 00 00	 call	 compute_code_flags
  001ba	89 84 24 88 00
	00 00		 mov	 DWORD PTR flags$[rsp], eax

; 4129 :     if (flags < 0)

  001c1	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR flags$[rsp], 0
  001c9	7d 05		 jge	 SHORT $LN31@makecode

; 4130 :         goto error;

  001cb	e9 a3 01 00 00	 jmp	 $error$25394
$LN31@makecode:

; 4131 : 
; 4132 :     bytecode = PyCode_Optimize(a->a_bytecode, consts, names, a->a_lnotab);

  001d0	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001d8	4c 8b 48 18	 mov	 r9, QWORD PTR [rax+24]
  001dc	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR names$[rsp]
  001e4	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR consts$[rsp]
  001ec	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001f4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001f7	e8 00 00 00 00	 call	 PyCode_Optimize
  001fc	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR bytecode$[rsp], rax

; 4133 :     if (!bytecode)

  00204	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR bytecode$[rsp], 0
  0020d	75 05		 jne	 SHORT $LN30@makecode

; 4134 :         goto error;

  0020f	e9 5f 01 00 00	 jmp	 $error$25394
$LN30@makecode:

; 4135 : 
; 4136 :     tmp = PyList_AsTuple(consts); /* PyCode_New requires a tuple */

  00214	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR consts$[rsp]
  0021c	e8 00 00 00 00	 call	 PyList_AsTuple
  00221	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tmp$[rsp], rax

; 4137 :     if (!tmp)

  00229	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR tmp$[rsp], 0
  00232	75 05		 jne	 SHORT $LN29@makecode

; 4138 :         goto error;

  00234	e9 3a 01 00 00	 jmp	 $error$25394
$LN29@makecode:

; 4139 :     Py_DECREF(consts);

  00239	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR consts$[rsp]
  00241	e8 00 00 00 00	 call	 _Py_DecRef

; 4140 :     consts = tmp;

  00246	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tmp$[rsp]
  0024e	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR consts$[rsp], rax

; 4141 : 
; 4142 :     co = PyCode_New(c->u->u_argcount, c->u->u_kwonlyargcount,
; 4143 :                     nlocals, stackdepth(c), flags,
; 4144 :                     bytecode, consts, names, varnames,
; 4145 :                     freevars, cellvars,
; 4146 :                     c->c_filename_obj, c->u->u_name,
; 4147 :                     c->u->u_firstlineno,
; 4148 :                     a->a_lnotab);

  00256	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0025e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00262	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv204[rsp], rax
  0026a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00272	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00276	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv203[rsp], rcx
  0027e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00286	e8 00 00 00 00	 call	 stackdepth
  0028b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00293	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00297	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  0029f	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  002a3	48 89 94 24 e8
	00 00 00	 mov	 QWORD PTR tv201[rsp], rdx
  002ab	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR a$[rsp]
  002b3	4d 8b 40 18	 mov	 r8, QWORD PTR [r8+24]
  002b7	4c 89 44 24 70	 mov	 QWORD PTR [rsp+112], r8
  002bc	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR tv204[rsp]
  002c4	45 8b 80 b0 01
	00 00		 mov	 r8d, DWORD PTR [r8+432]
  002cb	44 89 44 24 68	 mov	 DWORD PTR [rsp+104], r8d
  002d0	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR tv203[rsp]
  002d8	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  002dc	4c 89 44 24 60	 mov	 QWORD PTR [rsp+96], r8
  002e1	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR c$[rsp]
  002e9	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  002ed	4c 89 44 24 58	 mov	 QWORD PTR [rsp+88], r8
  002f2	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR cellvars$[rsp]
  002fa	4c 89 44 24 50	 mov	 QWORD PTR [rsp+80], r8
  002ff	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR freevars$[rsp]
  00307	4c 89 44 24 48	 mov	 QWORD PTR [rsp+72], r8
  0030c	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR varnames$[rsp]
  00314	4c 89 44 24 40	 mov	 QWORD PTR [rsp+64], r8
  00319	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR names$[rsp]
  00321	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  00326	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR consts$[rsp]
  0032e	4c 89 44 24 30	 mov	 QWORD PTR [rsp+48], r8
  00333	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR bytecode$[rsp]
  0033b	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  00340	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR flags$[rsp]
  00348	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  0034d	44 8b c8	 mov	 r9d, eax
  00350	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR nlocals$[rsp]
  00358	8b 51 54	 mov	 edx, DWORD PTR [rcx+84]
  0035b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv201[rsp]
  00363	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  00366	e8 00 00 00 00	 call	 PyCode_New
  0036b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR co$[rsp], rax
$error$25394:
$LN28@makecode:

; 4149 :  error:
; 4150 :     Py_XDECREF(consts);

  00373	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR consts$[rsp], 0
  0037c	74 0d		 je	 SHORT $LN25@makecode
  0037e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR consts$[rsp]
  00386	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@makecode:
  0038b	33 c0		 xor	 eax, eax
  0038d	85 c0		 test	 eax, eax
  0038f	75 e2		 jne	 SHORT $LN28@makecode
$LN24@makecode:

; 4151 :     Py_XDECREF(names);

  00391	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR names$[rsp], 0
  0039a	74 0d		 je	 SHORT $LN21@makecode
  0039c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR names$[rsp]
  003a4	e8 00 00 00 00	 call	 _Py_DecRef
$LN21@makecode:
  003a9	33 c0		 xor	 eax, eax
  003ab	85 c0		 test	 eax, eax
  003ad	75 e2		 jne	 SHORT $LN24@makecode
$LN20@makecode:

; 4152 :     Py_XDECREF(varnames);

  003af	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR varnames$[rsp], 0
  003b8	74 0d		 je	 SHORT $LN17@makecode
  003ba	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR varnames$[rsp]
  003c2	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@makecode:
  003c7	33 c0		 xor	 eax, eax
  003c9	85 c0		 test	 eax, eax
  003cb	75 e2		 jne	 SHORT $LN20@makecode
$LN16@makecode:

; 4153 :     Py_XDECREF(name);

  003cd	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR name$[rsp], 0
  003d6	74 0d		 je	 SHORT $LN13@makecode
  003d8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  003e0	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@makecode:
  003e5	33 c0		 xor	 eax, eax
  003e7	85 c0		 test	 eax, eax
  003e9	75 e2		 jne	 SHORT $LN16@makecode
$LN12@makecode:

; 4154 :     Py_XDECREF(freevars);

  003eb	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR freevars$[rsp], 0
  003f4	74 0d		 je	 SHORT $LN9@makecode
  003f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR freevars$[rsp]
  003fe	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@makecode:
  00403	33 c0		 xor	 eax, eax
  00405	85 c0		 test	 eax, eax
  00407	75 e2		 jne	 SHORT $LN12@makecode
$LN8@makecode:

; 4155 :     Py_XDECREF(cellvars);

  00409	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR cellvars$[rsp], 0
  00412	74 0d		 je	 SHORT $LN5@makecode
  00414	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cellvars$[rsp]
  0041c	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@makecode:
  00421	33 c0		 xor	 eax, eax
  00423	85 c0		 test	 eax, eax
  00425	75 e2		 jne	 SHORT $LN8@makecode
$LN4@makecode:

; 4156 :     Py_XDECREF(bytecode);

  00427	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR bytecode$[rsp], 0
  00430	74 0d		 je	 SHORT $LN1@makecode
  00432	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR bytecode$[rsp]
  0043a	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@makecode:
  0043f	33 c0		 xor	 eax, eax
  00441	85 c0		 test	 eax, eax
  00443	75 e2		 jne	 SHORT $LN4@makecode

; 4157 :     return co;

  00445	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]

; 4158 : }

  0044d	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00454	c3		 ret	 0
makecode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stackdepth DD imagerel stackdepth
	DD	imagerel stackdepth+140
	DD	imagerel $unwind$stackdepth
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stackdepth DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stackdepth
_TEXT	SEGMENT
entryblock$ = 32
b$ = 40
c$ = 64
stackdepth PROC						; COMDAT

; 3769 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3770 :     basicblock *b, *entryblock;
; 3771 :     entryblock = NULL;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR entryblock$[rsp], 0

; 3772 :     for (b = c->u->u_blocks; b != NULL; b = b->b_list) {

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00017	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0001b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001f	48 89 44 24 28	 mov	 QWORD PTR b$[rsp], rax
  00024	eb 0d		 jmp	 SHORT $LN4@stackdepth
$LN3@stackdepth:
  00026	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 89 44 24 28	 mov	 QWORD PTR b$[rsp], rax
$LN4@stackdepth:
  00033	48 83 7c 24 28
	00		 cmp	 QWORD PTR b$[rsp], 0
  00039	74 2b		 je	 SHORT $LN2@stackdepth

; 3773 :         b->b_seen = 0;

  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00040	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00043	83 e0 fe	 and	 eax, -2			; fffffffeH
  00046	48 8b 4c 24 28	 mov	 rcx, QWORD PTR b$[rsp]
  0004b	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 3774 :         b->b_startdepth = INT_MIN;

  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00053	c7 40 24 00 00
	00 80		 mov	 DWORD PTR [rax+36], -2147483648 ; ffffffff80000000H

; 3775 :         entryblock = b;

  0005a	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0005f	48 89 44 24 20	 mov	 QWORD PTR entryblock$[rsp], rax

; 3776 :     }

  00064	eb c0		 jmp	 SHORT $LN3@stackdepth
$LN2@stackdepth:

; 3777 :     if (!entryblock)

  00066	48 83 7c 24 20
	00		 cmp	 QWORD PTR entryblock$[rsp], 0
  0006c	75 04		 jne	 SHORT $LN1@stackdepth

; 3778 :         return 0;

  0006e	33 c0		 xor	 eax, eax
  00070	eb 15		 jmp	 SHORT $LN5@stackdepth
$LN1@stackdepth:

; 3779 :     return stackdepth_walk(c, entryblock, 0, 0);

  00072	45 33 c9	 xor	 r9d, r9d
  00075	45 33 c0	 xor	 r8d, r8d
  00078	48 8b 54 24 20	 mov	 rdx, QWORD PTR entryblock$[rsp]
  0007d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00082	e8 00 00 00 00	 call	 stackdepth_walk
$LN5@stackdepth:

; 3780 : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
stackdepth ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BG@LHNHGEJI@?$AAd?$AAe?$AAp?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stackdepth_walk DD imagerel stackdepth_walk
	DD	imagerel stackdepth_walk+510
	DD	imagerel $unwind$stackdepth_walk
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stackdepth_walk DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT ??_C@_1BG@LHNHGEJI@?$AAd?$AAe?$AAp?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@LHNHGEJI@?$AAd?$AAe?$AAp?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'd'
	DB	00H, 'e', 00H, 'p', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stackdepth_walk
_TEXT	SEGMENT
i$ = 32
target_depth$ = 36
instr$ = 40
c$ = 64
b$ = 72
depth$ = 80
maxdepth$ = 88
stackdepth_walk PROC					; COMDAT

; 3726 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3727 :     int i, target_depth;
; 3728 :     struct instr *instr;
; 3729 :     if (b->b_seen || b->b_startdepth >= depth)

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  0001d	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00020	83 e0 01	 and	 eax, 1
  00023	85 c0		 test	 eax, eax
  00025	75 0e		 jne	 SHORT $LN15@stackdepth@2
  00027	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  0002c	8b 4c 24 50	 mov	 ecx, DWORD PTR depth$[rsp]
  00030	39 48 24	 cmp	 DWORD PTR [rax+36], ecx
  00033	7c 09		 jl	 SHORT $LN16@stackdepth@2
$LN15@stackdepth@2:

; 3730 :         return maxdepth;

  00035	8b 44 24 58	 mov	 eax, DWORD PTR maxdepth$[rsp]
  00039	e9 bb 01 00 00	 jmp	 $LN17@stackdepth@2
$LN16@stackdepth@2:

; 3731 :     b->b_seen = 1;

  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00043	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00046	83 c8 01	 or	 eax, 1
  00049	48 8b 4c 24 48	 mov	 rcx, QWORD PTR b$[rsp]
  0004e	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 3732 :     b->b_startdepth = depth;

  00051	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00056	8b 4c 24 50	 mov	 ecx, DWORD PTR depth$[rsp]
  0005a	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 3733 :     for (i = 0; i < b->b_iused; i++) {

  0005d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00065	eb 0a		 jmp	 SHORT $LN14@stackdepth@2
$LN13@stackdepth@2:
  00067	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0006b	ff c0		 inc	 eax
  0006d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN14@stackdepth@2:
  00071	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00076	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00079	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0007d	0f 8d 32 01 00
	00		 jge	 $LN12@stackdepth@2

; 3734 :         instr = &b->b_instr[i];

  00083	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00088	48 6b c0 20	 imul	 rax, 32			; 00000020H
  0008c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR b$[rsp]
  00091	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00095	48 89 44 24 28	 mov	 QWORD PTR instr$[rsp], rax

; 3735 :         depth += opcode_stack_effect(instr->i_opcode, instr->i_oparg);

  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  0009f	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR instr$[rsp]
  000a8	8b 51 08	 mov	 edx, DWORD PTR [rcx+8]
  000ab	8b c8		 mov	 ecx, eax
  000ad	e8 00 00 00 00	 call	 opcode_stack_effect
  000b2	8b 4c 24 50	 mov	 ecx, DWORD PTR depth$[rsp]
  000b6	03 c8		 add	 ecx, eax
  000b8	8b c1		 mov	 eax, ecx
  000ba	89 44 24 50	 mov	 DWORD PTR depth$[rsp], eax

; 3736 :         if (depth > maxdepth)

  000be	8b 44 24 58	 mov	 eax, DWORD PTR maxdepth$[rsp]
  000c2	39 44 24 50	 cmp	 DWORD PTR depth$[rsp], eax
  000c6	7e 08		 jle	 SHORT $LN11@stackdepth@2

; 3737 :             maxdepth = depth;

  000c8	8b 44 24 50	 mov	 eax, DWORD PTR depth$[rsp]
  000cc	89 44 24 58	 mov	 DWORD PTR maxdepth$[rsp], eax
$LN11@stackdepth@2:

; 3738 :         assert(depth >= 0); /* invalid code or bug in stackdepth() */

  000d0	83 7c 24 50 00	 cmp	 DWORD PTR depth$[rsp], 0
  000d5	7d 1c		 jge	 SHORT $LN19@stackdepth@2
  000d7	41 b8 9a 0e 00
	00		 mov	 r8d, 3738		; 00000e9aH
  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@LHNHGEJI@?$AAd?$AAe?$AAp?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f1	33 c0		 xor	 eax, eax
$LN19@stackdepth@2:

; 3739 :         if (instr->i_jrel || instr->i_jabs) {

  000f3	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  000f8	8b 00		 mov	 eax, DWORD PTR [rax]
  000fa	d1 e8		 shr	 eax, 1
  000fc	83 e0 01	 and	 eax, 1
  000ff	85 c0		 test	 eax, eax
  00101	75 12		 jne	 SHORT $LN9@stackdepth@2
  00103	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  00108	8b 00		 mov	 eax, DWORD PTR [rax]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	0f 84 9b 00 00
	00		 je	 $LN10@stackdepth@2
$LN9@stackdepth@2:

; 3740 :             target_depth = depth;

  00115	8b 44 24 50	 mov	 eax, DWORD PTR depth$[rsp]
  00119	89 44 24 24	 mov	 DWORD PTR target_depth$[rsp], eax

; 3741 :             if (instr->i_opcode == FOR_ITER) {

  0011d	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  00122	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00126	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  00129	75 0d		 jne	 SHORT $LN8@stackdepth@2

; 3742 :                 target_depth = depth-2;

  0012b	8b 44 24 50	 mov	 eax, DWORD PTR depth$[rsp]
  0012f	83 e8 02	 sub	 eax, 2
  00132	89 44 24 24	 mov	 DWORD PTR target_depth$[rsp], eax

; 3743 :             } else if (instr->i_opcode == SETUP_FINALLY ||

  00136	eb 39		 jmp	 SHORT $LN7@stackdepth@2
$LN8@stackdepth@2:

; 3744 :                        instr->i_opcode == SETUP_EXCEPT) {

  00138	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  0013d	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00141	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00144	74 0e		 je	 SHORT $LN5@stackdepth@2
  00146	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  0014b	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0014f	83 f8 79	 cmp	 eax, 121		; 00000079H
  00152	75 1d		 jne	 SHORT $LN6@stackdepth@2
$LN5@stackdepth@2:

; 3745 :                 target_depth = depth+3;

  00154	8b 44 24 50	 mov	 eax, DWORD PTR depth$[rsp]
  00158	83 c0 03	 add	 eax, 3
  0015b	89 44 24 24	 mov	 DWORD PTR target_depth$[rsp], eax

; 3746 :                 if (target_depth > maxdepth)

  0015f	8b 44 24 58	 mov	 eax, DWORD PTR maxdepth$[rsp]
  00163	39 44 24 24	 cmp	 DWORD PTR target_depth$[rsp], eax
  00167	7e 08		 jle	 SHORT $LN4@stackdepth@2

; 3747 :                     maxdepth = target_depth;

  00169	8b 44 24 24	 mov	 eax, DWORD PTR target_depth$[rsp]
  0016d	89 44 24 58	 mov	 DWORD PTR maxdepth$[rsp], eax
$LN4@stackdepth@2:
$LN6@stackdepth@2:
$LN7@stackdepth@2:

; 3748 :             }
; 3749 :             maxdepth = stackdepth_walk(c, instr->i_target,
; 3750 :                                        target_depth, maxdepth);

  00171	44 8b 4c 24 58	 mov	 r9d, DWORD PTR maxdepth$[rsp]
  00176	44 8b 44 24 24	 mov	 r8d, DWORD PTR target_depth$[rsp]
  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  00180	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00184	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00189	e8 00 00 00 00	 call	 stackdepth_walk
  0018e	89 44 24 58	 mov	 DWORD PTR maxdepth$[rsp], eax

; 3751 :             if (instr->i_opcode == JUMP_ABSOLUTE ||
; 3752 :                 instr->i_opcode == JUMP_FORWARD) {

  00192	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  00197	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0019b	83 f8 71	 cmp	 eax, 113		; 00000071H
  0019e	74 0e		 je	 SHORT $LN2@stackdepth@2
  001a0	48 8b 44 24 28	 mov	 rax, QWORD PTR instr$[rsp]
  001a5	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001a9	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  001ac	75 02		 jne	 SHORT $LN3@stackdepth@2
$LN2@stackdepth@2:

; 3753 :                 goto out; /* remaining code is dead */

  001ae	eb 32		 jmp	 SHORT $out$25130
$LN3@stackdepth@2:
$LN10@stackdepth@2:

; 3754 :             }
; 3755 :         }
; 3756 :     }

  001b0	e9 b2 fe ff ff	 jmp	 $LN13@stackdepth@2
$LN12@stackdepth@2:

; 3757 :     if (b->b_next)

  001b5	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  001ba	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  001bf	74 21		 je	 SHORT $LN1@stackdepth@2

; 3758 :         maxdepth = stackdepth_walk(c, b->b_next, depth, maxdepth);

  001c1	44 8b 4c 24 58	 mov	 r9d, DWORD PTR maxdepth$[rsp]
  001c6	44 8b 44 24 50	 mov	 r8d, DWORD PTR depth$[rsp]
  001cb	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  001d0	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  001d9	e8 00 00 00 00	 call	 stackdepth_walk
  001de	89 44 24 58	 mov	 DWORD PTR maxdepth$[rsp], eax
$LN1@stackdepth@2:
$out$25130:

; 3759 : out:
; 3760 :     b->b_seen = 0;

  001e2	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  001e7	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  001ea	83 e0 fe	 and	 eax, -2			; fffffffeH
  001ed	48 8b 4c 24 48	 mov	 rcx, QWORD PTR b$[rsp]
  001f2	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 3761 :     return maxdepth;

  001f5	8b 44 24 58	 mov	 eax, DWORD PTR maxdepth$[rsp]
$LN17@stackdepth@2:

; 3762 : }

  001f9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001fd	c3		 ret	 0
stackdepth_walk ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@MPCMOCCE@opcode_stack_effect?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0N@BJFJDAMA@opcode?5?$DN?5?$CFd?6?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$opcode_stack_effect DD imagerel opcode_stack_effect
	DD	imagerel opcode_stack_effect+1539
	DD	imagerel $unwind$opcode_stack_effect
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$opcode_stack_effect DD 010c01H
	DD	0820cH
xdata	ENDS
;	COMDAT ??_C@_0BG@MPCMOCCE@opcode_stack_effect?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@MPCMOCCE@opcode_stack_effect?$CI?$CJ?$AA@ DB 'opcode_stack_effe'
	DB	'ct()', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BJFJDAMA@opcode?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0N@BJFJDAMA@opcode?5?$DN?5?$CFd?6?$AA@ DB 'opcode = %d', 0aH, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT opcode_stack_effect
_TEXT	SEGMENT
tv64 = 32
tv71 = 36
tv77 = 40
tv84 = 44
tv91 = 48
tv132 = 52
opcode$ = 80
oparg$ = 88
opcode_stack_effect PROC				; COMDAT

; 789  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 790  :     switch (opcode) {

  0000c	8b 44 24 50	 mov	 eax, DWORD PTR opcode$[rsp]
  00010	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00014	8b 44 24 20	 mov	 eax, DWORD PTR tv64[rsp]
  00018	ff c8		 dec	 eax
  0001a	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0001e	81 7c 24 20 92
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 146 ; 00000092H
  00026	0f 87 ff 03 00
	00		 ja	 $LN1@opcode_sta
  0002c	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv64[rsp]
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00038	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN75@opcode_sta[rcx+rax]
  00040	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN76@opcode_sta[rcx+rax*4]
  00047	48 03 c1	 add	 rax, rcx
  0004a	ff e0		 jmp	 rax
$LN70@opcode_sta:

; 791  :         case POP_TOP:
; 792  :             return -1;

  0004c	b8 ff ff ff ff	 mov	 eax, -1
  00051	e9 02 04 00 00	 jmp	 $LN73@opcode_sta
$LN69@opcode_sta:

; 793  :         case ROT_TWO:
; 794  :         case ROT_THREE:
; 795  :             return 0;

  00056	33 c0		 xor	 eax, eax
  00058	e9 fb 03 00 00	 jmp	 $LN73@opcode_sta
$LN68@opcode_sta:

; 796  :         case DUP_TOP:
; 797  :             return 1;

  0005d	b8 01 00 00 00	 mov	 eax, 1
  00062	e9 f1 03 00 00	 jmp	 $LN73@opcode_sta
$LN67@opcode_sta:

; 798  :         case DUP_TOP_TWO:
; 799  :             return 2;

  00067	b8 02 00 00 00	 mov	 eax, 2
  0006c	e9 e7 03 00 00	 jmp	 $LN73@opcode_sta
$LN66@opcode_sta:

; 800  : 
; 801  :         case UNARY_POSITIVE:
; 802  :         case UNARY_NEGATIVE:
; 803  :         case UNARY_NOT:
; 804  :         case UNARY_INVERT:
; 805  :             return 0;

  00071	33 c0		 xor	 eax, eax
  00073	e9 e0 03 00 00	 jmp	 $LN73@opcode_sta
$LN65@opcode_sta:

; 806  : 
; 807  :         case SET_ADD:
; 808  :         case LIST_APPEND:
; 809  :             return -1;

  00078	b8 ff ff ff ff	 mov	 eax, -1
  0007d	e9 d6 03 00 00	 jmp	 $LN73@opcode_sta
$LN64@opcode_sta:

; 810  :         case MAP_ADD:
; 811  :             return -2;

  00082	b8 fe ff ff ff	 mov	 eax, -2
  00087	e9 cc 03 00 00	 jmp	 $LN73@opcode_sta
$LN63@opcode_sta:

; 812  : 
; 813  :         case BINARY_POWER:
; 814  :         case BINARY_MULTIPLY:
; 815  :         case BINARY_MODULO:
; 816  :         case BINARY_ADD:
; 817  :         case BINARY_SUBTRACT:
; 818  :         case BINARY_SUBSCR:
; 819  :         case BINARY_FLOOR_DIVIDE:
; 820  :         case BINARY_TRUE_DIVIDE:
; 821  :             return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	e9 c2 03 00 00	 jmp	 $LN73@opcode_sta
$LN62@opcode_sta:

; 822  :         case INPLACE_FLOOR_DIVIDE:
; 823  :         case INPLACE_TRUE_DIVIDE:
; 824  :             return -1;

  00096	b8 ff ff ff ff	 mov	 eax, -1
  0009b	e9 b8 03 00 00	 jmp	 $LN73@opcode_sta
$LN61@opcode_sta:

; 825  : 
; 826  :         case INPLACE_ADD:
; 827  :         case INPLACE_SUBTRACT:
; 828  :         case INPLACE_MULTIPLY:
; 829  :         case INPLACE_MODULO:
; 830  :             return -1;

  000a0	b8 ff ff ff ff	 mov	 eax, -1
  000a5	e9 ae 03 00 00	 jmp	 $LN73@opcode_sta
$LN60@opcode_sta:

; 831  :         case STORE_SUBSCR:
; 832  :             return -3;

  000aa	b8 fd ff ff ff	 mov	 eax, -3
  000af	e9 a4 03 00 00	 jmp	 $LN73@opcode_sta
$LN59@opcode_sta:

; 833  :         case STORE_MAP:
; 834  :             return -2;

  000b4	b8 fe ff ff ff	 mov	 eax, -2
  000b9	e9 9a 03 00 00	 jmp	 $LN73@opcode_sta
$LN58@opcode_sta:

; 835  :         case DELETE_SUBSCR:
; 836  :             return -2;

  000be	b8 fe ff ff ff	 mov	 eax, -2
  000c3	e9 90 03 00 00	 jmp	 $LN73@opcode_sta
$LN57@opcode_sta:

; 837  : 
; 838  :         case BINARY_LSHIFT:
; 839  :         case BINARY_RSHIFT:
; 840  :         case BINARY_AND:
; 841  :         case BINARY_XOR:
; 842  :         case BINARY_OR:
; 843  :             return -1;

  000c8	b8 ff ff ff ff	 mov	 eax, -1
  000cd	e9 86 03 00 00	 jmp	 $LN73@opcode_sta
$LN56@opcode_sta:

; 844  :         case INPLACE_POWER:
; 845  :             return -1;

  000d2	b8 ff ff ff ff	 mov	 eax, -1
  000d7	e9 7c 03 00 00	 jmp	 $LN73@opcode_sta
$LN55@opcode_sta:

; 846  :         case GET_ITER:
; 847  :             return 0;

  000dc	33 c0		 xor	 eax, eax
  000de	e9 75 03 00 00	 jmp	 $LN73@opcode_sta
$LN54@opcode_sta:

; 848  : 
; 849  :         case PRINT_EXPR:
; 850  :             return -1;

  000e3	b8 ff ff ff ff	 mov	 eax, -1
  000e8	e9 6b 03 00 00	 jmp	 $LN73@opcode_sta
$LN53@opcode_sta:

; 851  :         case LOAD_BUILD_CLASS:
; 852  :             return 1;

  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	e9 61 03 00 00	 jmp	 $LN73@opcode_sta
$LN52@opcode_sta:

; 853  :         case INPLACE_LSHIFT:
; 854  :         case INPLACE_RSHIFT:
; 855  :         case INPLACE_AND:
; 856  :         case INPLACE_XOR:
; 857  :         case INPLACE_OR:
; 858  :             return -1;

  000f7	b8 ff ff ff ff	 mov	 eax, -1
  000fc	e9 57 03 00 00	 jmp	 $LN73@opcode_sta
$LN51@opcode_sta:

; 859  :         case BREAK_LOOP:
; 860  :             return 0;

  00101	33 c0		 xor	 eax, eax
  00103	e9 50 03 00 00	 jmp	 $LN73@opcode_sta
$LN50@opcode_sta:

; 861  :         case SETUP_WITH:
; 862  :             return 7;

  00108	b8 07 00 00 00	 mov	 eax, 7
  0010d	e9 46 03 00 00	 jmp	 $LN73@opcode_sta
$LN49@opcode_sta:

; 863  :         case WITH_CLEANUP:
; 864  :             return -1; /* XXX Sometimes more */

  00112	b8 ff ff ff ff	 mov	 eax, -1
  00117	e9 3c 03 00 00	 jmp	 $LN73@opcode_sta
$LN48@opcode_sta:

; 865  :         case STORE_LOCALS:
; 866  :             return -1;

  0011c	b8 ff ff ff ff	 mov	 eax, -1
  00121	e9 32 03 00 00	 jmp	 $LN73@opcode_sta
$LN47@opcode_sta:

; 867  :         case RETURN_VALUE:
; 868  :             return -1;

  00126	b8 ff ff ff ff	 mov	 eax, -1
  0012b	e9 28 03 00 00	 jmp	 $LN73@opcode_sta
$LN46@opcode_sta:

; 869  :         case IMPORT_STAR:
; 870  :             return -1;

  00130	b8 ff ff ff ff	 mov	 eax, -1
  00135	e9 1e 03 00 00	 jmp	 $LN73@opcode_sta
$LN45@opcode_sta:

; 871  :         case YIELD_VALUE:
; 872  :             return 0;

  0013a	33 c0		 xor	 eax, eax
  0013c	e9 17 03 00 00	 jmp	 $LN73@opcode_sta
$LN44@opcode_sta:

; 873  :         case YIELD_FROM:
; 874  :             return -1;

  00141	b8 ff ff ff ff	 mov	 eax, -1
  00146	e9 0d 03 00 00	 jmp	 $LN73@opcode_sta
$LN43@opcode_sta:

; 875  :         case POP_BLOCK:
; 876  :             return 0;

  0014b	33 c0		 xor	 eax, eax
  0014d	e9 06 03 00 00	 jmp	 $LN73@opcode_sta
$LN42@opcode_sta:

; 877  :         case POP_EXCEPT:
; 878  :             return 0;  /* -3 except if bad bytecode */

  00152	33 c0		 xor	 eax, eax
  00154	e9 ff 02 00 00	 jmp	 $LN73@opcode_sta
$LN41@opcode_sta:

; 879  :         case END_FINALLY:
; 880  :             return -1; /* or -2 or -3 if exception occurred */

  00159	b8 ff ff ff ff	 mov	 eax, -1
  0015e	e9 f5 02 00 00	 jmp	 $LN73@opcode_sta
$LN40@opcode_sta:

; 881  : 
; 882  :         case STORE_NAME:
; 883  :             return -1;

  00163	b8 ff ff ff ff	 mov	 eax, -1
  00168	e9 eb 02 00 00	 jmp	 $LN73@opcode_sta
$LN39@opcode_sta:

; 884  :         case DELETE_NAME:
; 885  :             return 0;

  0016d	33 c0		 xor	 eax, eax
  0016f	e9 e4 02 00 00	 jmp	 $LN73@opcode_sta
$LN38@opcode_sta:

; 886  :         case UNPACK_SEQUENCE:
; 887  :             return oparg-1;

  00174	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  00178	ff c8		 dec	 eax
  0017a	e9 d9 02 00 00	 jmp	 $LN73@opcode_sta
$LN37@opcode_sta:

; 888  :         case UNPACK_EX:
; 889  :             return (oparg&0xFF) + (oparg>>8);

  0017f	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  00183	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00188	8b 4c 24 58	 mov	 ecx, DWORD PTR oparg$[rsp]
  0018c	c1 f9 08	 sar	 ecx, 8
  0018f	03 c1		 add	 eax, ecx
  00191	e9 c2 02 00 00	 jmp	 $LN73@opcode_sta
$LN36@opcode_sta:

; 890  :         case FOR_ITER:
; 891  :             return 1; /* or -1, at end of iterator */

  00196	b8 01 00 00 00	 mov	 eax, 1
  0019b	e9 b8 02 00 00	 jmp	 $LN73@opcode_sta
$LN35@opcode_sta:

; 892  : 
; 893  :         case STORE_ATTR:
; 894  :             return -2;

  001a0	b8 fe ff ff ff	 mov	 eax, -2
  001a5	e9 ae 02 00 00	 jmp	 $LN73@opcode_sta
$LN34@opcode_sta:

; 895  :         case DELETE_ATTR:
; 896  :             return -1;

  001aa	b8 ff ff ff ff	 mov	 eax, -1
  001af	e9 a4 02 00 00	 jmp	 $LN73@opcode_sta
$LN33@opcode_sta:

; 897  :         case STORE_GLOBAL:
; 898  :             return -1;

  001b4	b8 ff ff ff ff	 mov	 eax, -1
  001b9	e9 9a 02 00 00	 jmp	 $LN73@opcode_sta
$LN32@opcode_sta:

; 899  :         case DELETE_GLOBAL:
; 900  :             return 0;

  001be	33 c0		 xor	 eax, eax
  001c0	e9 93 02 00 00	 jmp	 $LN73@opcode_sta
$LN31@opcode_sta:

; 901  :         case LOAD_CONST:
; 902  :             return 1;

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	e9 89 02 00 00	 jmp	 $LN73@opcode_sta
$LN30@opcode_sta:

; 903  :         case LOAD_NAME:
; 904  :             return 1;

  001cf	b8 01 00 00 00	 mov	 eax, 1
  001d4	e9 7f 02 00 00	 jmp	 $LN73@opcode_sta
$LN29@opcode_sta:

; 905  :         case BUILD_TUPLE:
; 906  :         case BUILD_LIST:
; 907  :         case BUILD_SET:
; 908  :             return 1-oparg;

  001d9	b8 01 00 00 00	 mov	 eax, 1
  001de	2b 44 24 58	 sub	 eax, DWORD PTR oparg$[rsp]
  001e2	e9 71 02 00 00	 jmp	 $LN73@opcode_sta
$LN28@opcode_sta:

; 909  :         case BUILD_MAP:
; 910  :             return 1;

  001e7	b8 01 00 00 00	 mov	 eax, 1
  001ec	e9 67 02 00 00	 jmp	 $LN73@opcode_sta
$LN27@opcode_sta:

; 911  :         case LOAD_ATTR:
; 912  :             return 0;

  001f1	33 c0		 xor	 eax, eax
  001f3	e9 60 02 00 00	 jmp	 $LN73@opcode_sta
$LN26@opcode_sta:

; 913  :         case COMPARE_OP:
; 914  :             return -1;

  001f8	b8 ff ff ff ff	 mov	 eax, -1
  001fd	e9 56 02 00 00	 jmp	 $LN73@opcode_sta
$LN25@opcode_sta:

; 915  :         case IMPORT_NAME:
; 916  :             return -1;

  00202	b8 ff ff ff ff	 mov	 eax, -1
  00207	e9 4c 02 00 00	 jmp	 $LN73@opcode_sta
$LN24@opcode_sta:

; 917  :         case IMPORT_FROM:
; 918  :             return 1;

  0020c	b8 01 00 00 00	 mov	 eax, 1
  00211	e9 42 02 00 00	 jmp	 $LN73@opcode_sta
$LN23@opcode_sta:

; 919  : 
; 920  :         case JUMP_FORWARD:
; 921  :         case JUMP_IF_TRUE_OR_POP:  /* -1 if jump not taken */
; 922  :         case JUMP_IF_FALSE_OR_POP:  /*  "" */
; 923  :         case JUMP_ABSOLUTE:
; 924  :             return 0;

  00216	33 c0		 xor	 eax, eax
  00218	e9 3b 02 00 00	 jmp	 $LN73@opcode_sta
$LN22@opcode_sta:

; 925  : 
; 926  :         case POP_JUMP_IF_FALSE:
; 927  :         case POP_JUMP_IF_TRUE:
; 928  :             return -1;

  0021d	b8 ff ff ff ff	 mov	 eax, -1
  00222	e9 31 02 00 00	 jmp	 $LN73@opcode_sta
$LN21@opcode_sta:

; 929  : 
; 930  :         case LOAD_GLOBAL:
; 931  :             return 1;

  00227	b8 01 00 00 00	 mov	 eax, 1
  0022c	e9 27 02 00 00	 jmp	 $LN73@opcode_sta
$LN20@opcode_sta:

; 932  : 
; 933  :         case CONTINUE_LOOP:
; 934  :             return 0;

  00231	33 c0		 xor	 eax, eax
  00233	e9 20 02 00 00	 jmp	 $LN73@opcode_sta
$LN19@opcode_sta:

; 935  :         case SETUP_LOOP:
; 936  :             return 0;

  00238	33 c0		 xor	 eax, eax
  0023a	e9 19 02 00 00	 jmp	 $LN73@opcode_sta
$LN18@opcode_sta:

; 937  :         case SETUP_EXCEPT:
; 938  :         case SETUP_FINALLY:
; 939  :             return 6; /* can push 3 values for the new exception

  0023f	b8 06 00 00 00	 mov	 eax, 6
  00244	e9 0f 02 00 00	 jmp	 $LN73@opcode_sta
$LN17@opcode_sta:

; 940  :                 + 3 others for the previous exception state */
; 941  : 
; 942  :         case LOAD_FAST:
; 943  :             return 1;

  00249	b8 01 00 00 00	 mov	 eax, 1
  0024e	e9 05 02 00 00	 jmp	 $LN73@opcode_sta
$LN16@opcode_sta:

; 944  :         case STORE_FAST:
; 945  :             return -1;

  00253	b8 ff ff ff ff	 mov	 eax, -1
  00258	e9 fb 01 00 00	 jmp	 $LN73@opcode_sta
$LN15@opcode_sta:

; 946  :         case DELETE_FAST:
; 947  :             return 0;

  0025d	33 c0		 xor	 eax, eax
  0025f	e9 f4 01 00 00	 jmp	 $LN73@opcode_sta
$LN14@opcode_sta:

; 948  : 
; 949  :         case RAISE_VARARGS:
; 950  :             return -oparg;

  00264	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  00268	f7 d8		 neg	 eax
  0026a	e9 e9 01 00 00	 jmp	 $LN73@opcode_sta
$LN13@opcode_sta:

; 951  : #define NARGS(o) (((o) % 256) + 2*(((o) / 256) % 256))
; 952  :         case CALL_FUNCTION:
; 953  :             return -NARGS(oparg);

  0026f	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  00273	99		 cdq
  00274	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0027a	03 c2		 add	 eax, edx
  0027c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00281	2b c2		 sub	 eax, edx
  00283	89 44 24 24	 mov	 DWORD PTR tv71[rsp], eax
  00287	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  0028b	99		 cdq
  0028c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00292	03 c2		 add	 eax, edx
  00294	c1 f8 08	 sar	 eax, 8
  00297	99		 cdq
  00298	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0029e	03 c2		 add	 eax, edx
  002a0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002a5	2b c2		 sub	 eax, edx
  002a7	8b 4c 24 24	 mov	 ecx, DWORD PTR tv71[rsp]
  002ab	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  002ae	f7 d8		 neg	 eax
  002b0	e9 a3 01 00 00	 jmp	 $LN73@opcode_sta
$LN12@opcode_sta:

; 954  :         case CALL_FUNCTION_VAR:
; 955  :         case CALL_FUNCTION_KW:
; 956  :             return -NARGS(oparg)-1;

  002b5	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  002b9	99		 cdq
  002ba	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  002c0	03 c2		 add	 eax, edx
  002c2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002c7	2b c2		 sub	 eax, edx
  002c9	89 44 24 28	 mov	 DWORD PTR tv77[rsp], eax
  002cd	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  002d1	99		 cdq
  002d2	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  002d8	03 c2		 add	 eax, edx
  002da	c1 f8 08	 sar	 eax, 8
  002dd	99		 cdq
  002de	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  002e4	03 c2		 add	 eax, edx
  002e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002eb	2b c2		 sub	 eax, edx
  002ed	8b 4c 24 28	 mov	 ecx, DWORD PTR tv77[rsp]
  002f1	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  002f4	f7 d8		 neg	 eax
  002f6	ff c8		 dec	 eax
  002f8	e9 5b 01 00 00	 jmp	 $LN73@opcode_sta
$LN11@opcode_sta:

; 957  :         case CALL_FUNCTION_VAR_KW:
; 958  :             return -NARGS(oparg)-2;

  002fd	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  00301	99		 cdq
  00302	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00308	03 c2		 add	 eax, edx
  0030a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0030f	2b c2		 sub	 eax, edx
  00311	89 44 24 2c	 mov	 DWORD PTR tv84[rsp], eax
  00315	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  00319	99		 cdq
  0031a	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00320	03 c2		 add	 eax, edx
  00322	c1 f8 08	 sar	 eax, 8
  00325	99		 cdq
  00326	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0032c	03 c2		 add	 eax, edx
  0032e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00333	2b c2		 sub	 eax, edx
  00335	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv84[rsp]
  00339	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  0033c	f7 d8		 neg	 eax
  0033e	83 e8 02	 sub	 eax, 2
  00341	e9 12 01 00 00	 jmp	 $LN73@opcode_sta
$LN10@opcode_sta:

; 959  :         case MAKE_FUNCTION:
; 960  :             return -1 -NARGS(oparg) - ((oparg >> 16) & 0xffff);

  00346	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  0034a	99		 cdq
  0034b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00351	03 c2		 add	 eax, edx
  00353	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00358	2b c2		 sub	 eax, edx
  0035a	89 44 24 30	 mov	 DWORD PTR tv91[rsp], eax
  0035e	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  00362	99		 cdq
  00363	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00369	03 c2		 add	 eax, edx
  0036b	c1 f8 08	 sar	 eax, 8
  0036e	99		 cdq
  0036f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00375	03 c2		 add	 eax, edx
  00377	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0037c	2b c2		 sub	 eax, edx
  0037e	8b 4c 24 30	 mov	 ecx, DWORD PTR tv91[rsp]
  00382	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  00385	b9 ff ff ff ff	 mov	 ecx, -1
  0038a	2b c8		 sub	 ecx, eax
  0038c	8b c1		 mov	 eax, ecx
  0038e	8b 4c 24 58	 mov	 ecx, DWORD PTR oparg$[rsp]
  00392	c1 f9 10	 sar	 ecx, 16
  00395	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0039b	2b c1		 sub	 eax, ecx
  0039d	e9 b6 00 00 00	 jmp	 $LN73@opcode_sta
$LN9@opcode_sta:

; 961  :         case MAKE_CLOSURE:
; 962  :             return -2 - NARGS(oparg) - ((oparg >> 16) & 0xffff);

  003a2	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  003a6	99		 cdq
  003a7	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  003ad	03 c2		 add	 eax, edx
  003af	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003b4	2b c2		 sub	 eax, edx
  003b6	89 44 24 34	 mov	 DWORD PTR tv132[rsp], eax
  003ba	8b 44 24 58	 mov	 eax, DWORD PTR oparg$[rsp]
  003be	99		 cdq
  003bf	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  003c5	03 c2		 add	 eax, edx
  003c7	c1 f8 08	 sar	 eax, 8
  003ca	99		 cdq
  003cb	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  003d1	03 c2		 add	 eax, edx
  003d3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003d8	2b c2		 sub	 eax, edx
  003da	8b 4c 24 34	 mov	 ecx, DWORD PTR tv132[rsp]
  003de	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  003e1	b9 fe ff ff ff	 mov	 ecx, -2
  003e6	2b c8		 sub	 ecx, eax
  003e8	8b c1		 mov	 eax, ecx
  003ea	8b 4c 24 58	 mov	 ecx, DWORD PTR oparg$[rsp]
  003ee	c1 f9 10	 sar	 ecx, 16
  003f1	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  003f7	2b c1		 sub	 eax, ecx
  003f9	eb 5d		 jmp	 SHORT $LN73@opcode_sta
$LN8@opcode_sta:

; 963  : #undef NARGS
; 964  :         case BUILD_SLICE:
; 965  :             if (oparg == 3)

  003fb	83 7c 24 58 03	 cmp	 DWORD PTR oparg$[rsp], 3
  00400	75 09		 jne	 SHORT $LN7@opcode_sta

; 966  :                 return -2;

  00402	b8 fe ff ff ff	 mov	 eax, -2
  00407	eb 4f		 jmp	 SHORT $LN73@opcode_sta

; 967  :             else

  00409	eb 07		 jmp	 SHORT $LN6@opcode_sta
$LN7@opcode_sta:

; 968  :                 return -1;

  0040b	b8 ff ff ff ff	 mov	 eax, -1
  00410	eb 46		 jmp	 SHORT $LN73@opcode_sta
$LN6@opcode_sta:
$LN5@opcode_sta:

; 969  : 
; 970  :         case LOAD_CLOSURE:
; 971  :             return 1;

  00412	b8 01 00 00 00	 mov	 eax, 1
  00417	eb 3f		 jmp	 SHORT $LN73@opcode_sta
$LN4@opcode_sta:

; 972  :         case LOAD_DEREF:
; 973  :             return 1;

  00419	b8 01 00 00 00	 mov	 eax, 1
  0041e	eb 38		 jmp	 SHORT $LN73@opcode_sta
$LN3@opcode_sta:

; 974  :         case STORE_DEREF:
; 975  :             return -1;

  00420	b8 ff ff ff ff	 mov	 eax, -1
  00425	eb 31		 jmp	 SHORT $LN73@opcode_sta
$LN2@opcode_sta:

; 976  :         case DELETE_DEREF:
; 977  :             return 0;

  00427	33 c0		 xor	 eax, eax
  00429	eb 2d		 jmp	 SHORT $LN73@opcode_sta
$LN1@opcode_sta:

; 978  :         default:
; 979  :             fprintf(stderr, "opcode = %d\n", opcode);

  0042b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00431	48 83 c0 60	 add	 rax, 96			; 00000060H
  00435	44 8b 44 24 50	 mov	 r8d, DWORD PTR opcode$[rsp]
  0043a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BJFJDAMA@opcode?5?$DN?5?$CFd?6?$AA@
  00441	48 8b c8	 mov	 rcx, rax
  00444	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 980  :             Py_FatalError("opcode_stack_effect()");

  0044a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@MPCMOCCE@opcode_stack_effect?$CI?$CJ?$AA@
  00451	e8 00 00 00 00	 call	 Py_FatalError

; 981  : 
; 982  :     }
; 983  :     return 0; /* not reachable */

  00456	33 c0		 xor	 eax, eax
$LN73@opcode_sta:

; 984  : }

  00458	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0045c	c3		 ret	 0
  0045d	0f 1f 00	 npad	 3
$LN76@opcode_sta:
  00460	00 00 00 00	 DD	 $LN70@opcode_sta
  00464	00 00 00 00	 DD	 $LN69@opcode_sta
  00468	00 00 00 00	 DD	 $LN68@opcode_sta
  0046c	00 00 00 00	 DD	 $LN67@opcode_sta
  00470	00 00 00 00	 DD	 $LN66@opcode_sta
  00474	00 00 00 00	 DD	 $LN63@opcode_sta
  00478	00 00 00 00	 DD	 $LN62@opcode_sta
  0047c	00 00 00 00	 DD	 $LN59@opcode_sta
  00480	00 00 00 00	 DD	 $LN61@opcode_sta
  00484	00 00 00 00	 DD	 $LN60@opcode_sta
  00488	00 00 00 00	 DD	 $LN58@opcode_sta
  0048c	00 00 00 00	 DD	 $LN57@opcode_sta
  00490	00 00 00 00	 DD	 $LN56@opcode_sta
  00494	00 00 00 00	 DD	 $LN55@opcode_sta
  00498	00 00 00 00	 DD	 $LN48@opcode_sta
  0049c	00 00 00 00	 DD	 $LN54@opcode_sta
  004a0	00 00 00 00	 DD	 $LN53@opcode_sta
  004a4	00 00 00 00	 DD	 $LN44@opcode_sta
  004a8	00 00 00 00	 DD	 $LN52@opcode_sta
  004ac	00 00 00 00	 DD	 $LN51@opcode_sta
  004b0	00 00 00 00	 DD	 $LN49@opcode_sta
  004b4	00 00 00 00	 DD	 $LN47@opcode_sta
  004b8	00 00 00 00	 DD	 $LN46@opcode_sta
  004bc	00 00 00 00	 DD	 $LN45@opcode_sta
  004c0	00 00 00 00	 DD	 $LN43@opcode_sta
  004c4	00 00 00 00	 DD	 $LN41@opcode_sta
  004c8	00 00 00 00	 DD	 $LN42@opcode_sta
  004cc	00 00 00 00	 DD	 $LN40@opcode_sta
  004d0	00 00 00 00	 DD	 $LN39@opcode_sta
  004d4	00 00 00 00	 DD	 $LN38@opcode_sta
  004d8	00 00 00 00	 DD	 $LN36@opcode_sta
  004dc	00 00 00 00	 DD	 $LN37@opcode_sta
  004e0	00 00 00 00	 DD	 $LN35@opcode_sta
  004e4	00 00 00 00	 DD	 $LN34@opcode_sta
  004e8	00 00 00 00	 DD	 $LN33@opcode_sta
  004ec	00 00 00 00	 DD	 $LN32@opcode_sta
  004f0	00 00 00 00	 DD	 $LN31@opcode_sta
  004f4	00 00 00 00	 DD	 $LN30@opcode_sta
  004f8	00 00 00 00	 DD	 $LN29@opcode_sta
  004fc	00 00 00 00	 DD	 $LN28@opcode_sta
  00500	00 00 00 00	 DD	 $LN27@opcode_sta
  00504	00 00 00 00	 DD	 $LN26@opcode_sta
  00508	00 00 00 00	 DD	 $LN25@opcode_sta
  0050c	00 00 00 00	 DD	 $LN24@opcode_sta
  00510	00 00 00 00	 DD	 $LN23@opcode_sta
  00514	00 00 00 00	 DD	 $LN22@opcode_sta
  00518	00 00 00 00	 DD	 $LN21@opcode_sta
  0051c	00 00 00 00	 DD	 $LN20@opcode_sta
  00520	00 00 00 00	 DD	 $LN19@opcode_sta
  00524	00 00 00 00	 DD	 $LN18@opcode_sta
  00528	00 00 00 00	 DD	 $LN17@opcode_sta
  0052c	00 00 00 00	 DD	 $LN16@opcode_sta
  00530	00 00 00 00	 DD	 $LN15@opcode_sta
  00534	00 00 00 00	 DD	 $LN14@opcode_sta
  00538	00 00 00 00	 DD	 $LN13@opcode_sta
  0053c	00 00 00 00	 DD	 $LN10@opcode_sta
  00540	00 00 00 00	 DD	 $LN8@opcode_sta
  00544	00 00 00 00	 DD	 $LN9@opcode_sta
  00548	00 00 00 00	 DD	 $LN5@opcode_sta
  0054c	00 00 00 00	 DD	 $LN4@opcode_sta
  00550	00 00 00 00	 DD	 $LN3@opcode_sta
  00554	00 00 00 00	 DD	 $LN2@opcode_sta
  00558	00 00 00 00	 DD	 $LN12@opcode_sta
  0055c	00 00 00 00	 DD	 $LN11@opcode_sta
  00560	00 00 00 00	 DD	 $LN50@opcode_sta
  00564	00 00 00 00	 DD	 $LN65@opcode_sta
  00568	00 00 00 00	 DD	 $LN64@opcode_sta
  0056c	00 00 00 00	 DD	 $LN1@opcode_sta
$LN75@opcode_sta:
  00570	00		 DB	 0
  00571	01		 DB	 1
  00572	01		 DB	 1
  00573	02		 DB	 2
  00574	03		 DB	 3
  00575	43		 DB	 67			; 00000043H
  00576	43		 DB	 67			; 00000043H
  00577	43		 DB	 67			; 00000043H
  00578	43		 DB	 67			; 00000043H
  00579	04		 DB	 4
  0057a	04		 DB	 4
  0057b	04		 DB	 4
  0057c	43		 DB	 67			; 00000043H
  0057d	43		 DB	 67			; 00000043H
  0057e	04		 DB	 4
  0057f	43		 DB	 67			; 00000043H
  00580	43		 DB	 67			; 00000043H
  00581	43		 DB	 67			; 00000043H
  00582	05		 DB	 5
  00583	05		 DB	 5
  00584	43		 DB	 67			; 00000043H
  00585	05		 DB	 5
  00586	05		 DB	 5
  00587	05		 DB	 5
  00588	05		 DB	 5
  00589	05		 DB	 5
  0058a	05		 DB	 5
  0058b	06		 DB	 6
  0058c	06		 DB	 6
  0058d	43		 DB	 67			; 00000043H
  0058e	43		 DB	 67			; 00000043H
  0058f	43		 DB	 67			; 00000043H
  00590	43		 DB	 67			; 00000043H
  00591	43		 DB	 67			; 00000043H
  00592	43		 DB	 67			; 00000043H
  00593	43		 DB	 67			; 00000043H
  00594	43		 DB	 67			; 00000043H
  00595	43		 DB	 67			; 00000043H
  00596	43		 DB	 67			; 00000043H
  00597	43		 DB	 67			; 00000043H
  00598	43		 DB	 67			; 00000043H
  00599	43		 DB	 67			; 00000043H
  0059a	43		 DB	 67			; 00000043H
  0059b	43		 DB	 67			; 00000043H
  0059c	43		 DB	 67			; 00000043H
  0059d	43		 DB	 67			; 00000043H
  0059e	43		 DB	 67			; 00000043H
  0059f	43		 DB	 67			; 00000043H
  005a0	43		 DB	 67			; 00000043H
  005a1	43		 DB	 67			; 00000043H
  005a2	43		 DB	 67			; 00000043H
  005a3	43		 DB	 67			; 00000043H
  005a4	43		 DB	 67			; 00000043H
  005a5	07		 DB	 7
  005a6	08		 DB	 8
  005a7	08		 DB	 8
  005a8	08		 DB	 8
  005a9	43		 DB	 67			; 00000043H
  005aa	08		 DB	 8
  005ab	09		 DB	 9
  005ac	0a		 DB	 10
  005ad	0b		 DB	 11
  005ae	0b		 DB	 11
  005af	0b		 DB	 11
  005b0	0b		 DB	 11
  005b1	0b		 DB	 11
  005b2	0c		 DB	 12
  005b3	0d		 DB	 13
  005b4	0e		 DB	 14
  005b5	0f		 DB	 15
  005b6	10		 DB	 16
  005b7	11		 DB	 17
  005b8	43		 DB	 67			; 00000043H
  005b9	43		 DB	 67			; 00000043H
  005ba	12		 DB	 18
  005bb	12		 DB	 18
  005bc	12		 DB	 18
  005bd	12		 DB	 18
  005be	12		 DB	 18
  005bf	13		 DB	 19
  005c0	14		 DB	 20
  005c1	43		 DB	 67			; 00000043H
  005c2	15		 DB	 21
  005c3	16		 DB	 22
  005c4	43		 DB	 67			; 00000043H
  005c5	17		 DB	 23
  005c6	18		 DB	 24
  005c7	19		 DB	 25
  005c8	1a		 DB	 26
  005c9	1b		 DB	 27
  005ca	1c		 DB	 28
  005cb	1d		 DB	 29
  005cc	1e		 DB	 30
  005cd	1f		 DB	 31
  005ce	20		 DB	 32			; 00000020H
  005cf	21		 DB	 33			; 00000021H
  005d0	22		 DB	 34			; 00000022H
  005d1	23		 DB	 35			; 00000023H
  005d2	43		 DB	 67			; 00000043H
  005d3	24		 DB	 36			; 00000024H
  005d4	25		 DB	 37			; 00000025H
  005d5	26		 DB	 38			; 00000026H
  005d6	26		 DB	 38			; 00000026H
  005d7	26		 DB	 38			; 00000026H
  005d8	27		 DB	 39			; 00000027H
  005d9	28		 DB	 40			; 00000028H
  005da	29		 DB	 41			; 00000029H
  005db	2a		 DB	 42			; 0000002aH
  005dc	2b		 DB	 43			; 0000002bH
  005dd	2c		 DB	 44			; 0000002cH
  005de	2c		 DB	 44			; 0000002cH
  005df	2c		 DB	 44			; 0000002cH
  005e0	2c		 DB	 44			; 0000002cH
  005e1	2d		 DB	 45			; 0000002dH
  005e2	2d		 DB	 45			; 0000002dH
  005e3	2e		 DB	 46			; 0000002eH
  005e4	43		 DB	 67			; 00000043H
  005e5	43		 DB	 67			; 00000043H
  005e6	2f		 DB	 47			; 0000002fH
  005e7	30		 DB	 48			; 00000030H
  005e8	31		 DB	 49			; 00000031H
  005e9	31		 DB	 49			; 00000031H
  005ea	43		 DB	 67			; 00000043H
  005eb	32		 DB	 50			; 00000032H
  005ec	33		 DB	 51			; 00000033H
  005ed	34		 DB	 52			; 00000034H
  005ee	43		 DB	 67			; 00000043H
  005ef	43		 DB	 67			; 00000043H
  005f0	43		 DB	 67			; 00000043H
  005f1	35		 DB	 53			; 00000035H
  005f2	36		 DB	 54			; 00000036H
  005f3	37		 DB	 55			; 00000037H
  005f4	38		 DB	 56			; 00000038H
  005f5	39		 DB	 57			; 00000039H
  005f6	3a		 DB	 58			; 0000003aH
  005f7	3b		 DB	 59			; 0000003bH
  005f8	3c		 DB	 60			; 0000003cH
  005f9	3d		 DB	 61			; 0000003dH
  005fa	43		 DB	 67			; 00000043H
  005fb	3e		 DB	 62			; 0000003eH
  005fc	3e		 DB	 62			; 0000003eH
  005fd	3f		 DB	 63			; 0000003fH
  005fe	40		 DB	 64			; 00000040H
  005ff	43		 DB	 67			; 00000043H
  00600	41		 DB	 65			; 00000041H
  00601	41		 DB	 65			; 00000041H
  00602	42		 DB	 66			; 00000042H
opcode_stack_effect ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@PAIGOLLH@?$AA?$CI?$AAi?$AA?5?$AA?9?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@DIKEFADM@?$AA?$CI?$AAi?$AA?5?$AA?9?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
EXTRN	PyDict_Next:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$dict_keys_inorder DD imagerel dict_keys_inorder
	DD	imagerel dict_keys_inorder+287
	DD	imagerel $unwind$dict_keys_inorder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dict_keys_inorder DD 010d01H
	DD	0a20dH
xdata	ENDS
;	COMDAT ??_C@_1CE@PAIGOLLH@?$AA?$CI?$AAi?$AA?5?$AA?9?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@PAIGOLLH@?$AA?$CI?$AAi?$AA?5?$AA?9?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB '('
	DB	00H, 'i', 00H, ' ', 00H, '-', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	'f', 00H, 's', 00H, 'e', 00H, 't', 00H, ')', 00H, ' ', 00H, '>'
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@DIKEFADM@?$AA?$CI?$AAi?$AA?5?$AA?9?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@DIKEFADM@?$AA?$CI?$AAi?$AA?5?$AA?9?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB '('
	DB	00H, 'i', 00H, ' ', 00H, '-', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	'f', 00H, 's', 00H, 'e', 00H, 't', 00H, ')', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT dict_keys_inorder
_TEXT	SEGMENT
v$ = 32
i$ = 40
size$ = 48
tuple$ = 56
k$ = 64
pos$ = 72
dict$ = 96
offset$ = 104
dict_keys_inorder PROC					; COMDAT

; 4038 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4039 :     PyObject *tuple, *k, *v;
; 4040 :     Py_ssize_t i, pos = 0, size = PyDict_Size(dict);

  0000d	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0
  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dict$[rsp]
  0001b	e8 00 00 00 00	 call	 PyDict_Size
  00020	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 4041 : 
; 4042 :     tuple = PyTuple_New(size);

  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$[rsp]
  0002a	e8 00 00 00 00	 call	 PyTuple_New
  0002f	48 89 44 24 38	 mov	 QWORD PTR tuple$[rsp], rax

; 4043 :     if (tuple == NULL)

  00034	48 83 7c 24 38
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  0003a	75 07		 jne	 SHORT $LN3@dict_keys_

; 4044 :         return NULL;

  0003c	33 c0		 xor	 eax, eax
  0003e	e9 d7 00 00 00	 jmp	 $LN4@dict_keys_
$LN3@dict_keys_:
$LN2@dict_keys_:

; 4045 :     while (PyDict_Next(dict, &pos, &k, &v)) {

  00043	4c 8d 4c 24 20	 lea	 r9, QWORD PTR v$[rsp]
  00048	4c 8d 44 24 40	 lea	 r8, QWORD PTR k$[rsp]
  0004d	48 8d 54 24 48	 lea	 rdx, QWORD PTR pos$[rsp]
  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dict$[rsp]
  00057	e8 00 00 00 00	 call	 PyDict_Next
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 b1 00 00
	00		 je	 $LN1@dict_keys_

; 4046 :         i = PyLong_AS_LONG(v);

  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00069	e8 00 00 00 00	 call	 PyLong_AsLong
  0006e	48 98		 cdqe
  00070	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 4047 :         /* The keys of the dictionary are tuples. (see compiler_add_o)
; 4048 :            The object we want is always first, though. */
; 4049 :         k = PyTuple_GET_ITEM(k, 0);

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR k$[rsp]
  0007a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0007e	48 89 44 24 40	 mov	 QWORD PTR k$[rsp], rax

; 4050 :         Py_INCREF(k);

  00083	48 8b 4c 24 40	 mov	 rcx, QWORD PTR k$[rsp]
  00088	e8 00 00 00 00	 call	 _Py_IncRef

; 4051 :         assert((i - offset) < size);

  0008d	48 63 44 24 68	 movsxd	 rax, DWORD PTR offset$[rsp]
  00092	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00097	48 2b c8	 sub	 rcx, rax
  0009a	48 8b c1	 mov	 rax, rcx
  0009d	48 3b 44 24 30	 cmp	 rax, QWORD PTR size$[rsp]
  000a2	7c 1c		 jl	 SHORT $LN6@dict_keys_
  000a4	41 b8 d3 0f 00
	00		 mov	 r8d, 4051		; 00000fd3H
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@DIKEFADM@?$AA?$CI?$AAi?$AA?5?$AA?9?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000be	33 c0		 xor	 eax, eax
$LN6@dict_keys_:

; 4052 :         assert((i - offset) >= 0);

  000c0	48 63 44 24 68	 movsxd	 rax, DWORD PTR offset$[rsp]
  000c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000ca	48 2b c8	 sub	 rcx, rax
  000cd	48 8b c1	 mov	 rax, rcx
  000d0	48 85 c0	 test	 rax, rax
  000d3	7d 1c		 jge	 SHORT $LN7@dict_keys_
  000d5	41 b8 d4 0f 00
	00		 mov	 r8d, 4052		; 00000fd4H
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@JDIFPJCJ@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@PAIGOLLH@?$AA?$CI?$AAi?$AA?5?$AA?9?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ef	33 c0		 xor	 eax, eax
$LN7@dict_keys_:

; 4053 :         PyTuple_SET_ITEM(tuple, i - offset, k);

  000f1	48 63 44 24 68	 movsxd	 rax, DWORD PTR offset$[rsp]
  000f6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000fb	48 2b c8	 sub	 rcx, rax
  000fe	48 8b c1	 mov	 rax, rcx
  00101	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tuple$[rsp]
  00106	48 8b 54 24 40	 mov	 rdx, QWORD PTR k$[rsp]
  0010b	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 4054 :     }

  00110	e9 2e ff ff ff	 jmp	 $LN2@dict_keys_
$LN1@dict_keys_:

; 4055 :     return tuple;

  00115	48 8b 44 24 38	 mov	 rax, QWORD PTR tuple$[rsp]
$LN4@dict_keys_:

; 4056 : }

  0011a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011e	c3		 ret	 0
dict_keys_inorder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compute_code_flags DD imagerel compute_code_flags
	DD	imagerel compute_code_flags+357
	DD	imagerel $unwind$compute_code_flags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compute_code_flags DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compute_code_flags
_TEXT	SEGMENT
flags$ = 32
n$ = 36
ste$ = 40
c$ = 64
compute_code_flags PROC					; COMDAT

; 4060 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4061 :     PySTEntryObject *ste = c->u->u_ste;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0000e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00012	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00015	48 89 44 24 28	 mov	 QWORD PTR ste$[rsp], rax

; 4062 :     int flags = 0, n;

  0001a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR flags$[rsp], 0

; 4063 :     if (ste->ste_type != ModuleBlock)

  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR ste$[rsp]
  00027	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  0002e	74 0b		 je	 SHORT $LN11@compute_co

; 4064 :         flags |= CO_NEWLOCALS;

  00030	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00034	83 c8 02	 or	 eax, 2
  00037	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN11@compute_co:

; 4065 :     if (ste->ste_type == FunctionBlock) {

  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR ste$[rsp]
  00040	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00047	0f 85 92 00 00
	00		 jne	 $LN10@compute_co

; 4066 :         if (!ste->ste_unoptimized)

  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR ste$[rsp]
  00052	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  00059	75 0b		 jne	 SHORT $LN9@compute_co

; 4067 :             flags |= CO_OPTIMIZED;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  0005f	83 c8 01	 or	 eax, 1
  00062	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN9@compute_co:

; 4068 :         if (ste->ste_nested)

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR ste$[rsp]
  0006b	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  00072	74 0b		 je	 SHORT $LN8@compute_co

; 4069 :             flags |= CO_NESTED;

  00074	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00078	83 c8 10	 or	 eax, 16
  0007b	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN8@compute_co:

; 4070 :         if (ste->ste_generator)

  0007f	48 8b 44 24 28	 mov	 rax, QWORD PTR ste$[rsp]
  00084	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0008a	c1 e8 02	 shr	 eax, 2
  0008d	83 e0 01	 and	 eax, 1
  00090	85 c0		 test	 eax, eax
  00092	74 0b		 je	 SHORT $LN7@compute_co

; 4071 :             flags |= CO_GENERATOR;

  00094	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00098	83 c8 20	 or	 eax, 32			; 00000020H
  0009b	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN7@compute_co:

; 4072 :         if (ste->ste_varargs)

  0009f	48 8b 44 24 28	 mov	 rax, QWORD PTR ste$[rsp]
  000a4	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  000aa	c1 e8 03	 shr	 eax, 3
  000ad	83 e0 01	 and	 eax, 1
  000b0	85 c0		 test	 eax, eax
  000b2	74 0b		 je	 SHORT $LN6@compute_co

; 4073 :             flags |= CO_VARARGS;

  000b4	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  000b8	83 c8 04	 or	 eax, 4
  000bb	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN6@compute_co:

; 4074 :         if (ste->ste_varkeywords)

  000bf	48 8b 44 24 28	 mov	 rax, QWORD PTR ste$[rsp]
  000c4	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  000ca	c1 e8 04	 shr	 eax, 4
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	74 0b		 je	 SHORT $LN5@compute_co

; 4075 :             flags |= CO_VARKEYWORDS;

  000d4	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  000d8	83 c8 08	 or	 eax, 8
  000db	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN5@compute_co:
$LN10@compute_co:

; 4076 :     }
; 4077 : 
; 4078 :     /* (Only) inherit compilerflags in PyCF_MASK */
; 4079 :     flags |= (c->c_flags->cf_flags & PyCF_MASK);

  000df	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000e4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000e8	8b 00		 mov	 eax, DWORD PTR [rax]
  000ea	25 00 e0 07 00	 and	 eax, 516096		; 0007e000H
  000ef	8b 4c 24 20	 mov	 ecx, DWORD PTR flags$[rsp]
  000f3	0b c8		 or	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax

; 4080 : 
; 4081 :     n = PyDict_Size(c->u->u_freevars);

  000fb	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00100	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00104	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00108	e8 00 00 00 00	 call	 PyDict_Size
  0010d	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax

; 4082 :     if (n < 0)

  00111	83 7c 24 24 00	 cmp	 DWORD PTR n$[rsp], 0
  00116	7d 07		 jge	 SHORT $LN4@compute_co

; 4083 :         return -1;

  00118	b8 ff ff ff ff	 mov	 eax, -1
  0011d	eb 41		 jmp	 SHORT $LN12@compute_co
$LN4@compute_co:

; 4084 :     if (n == 0) {

  0011f	83 7c 24 24 00	 cmp	 DWORD PTR n$[rsp], 0
  00124	75 36		 jne	 SHORT $LN3@compute_co

; 4085 :         n = PyDict_Size(c->u->u_cellvars);

  00126	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0012b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0012f	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00133	e8 00 00 00 00	 call	 PyDict_Size
  00138	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax

; 4086 :         if (n < 0)

  0013c	83 7c 24 24 00	 cmp	 DWORD PTR n$[rsp], 0
  00141	7d 07		 jge	 SHORT $LN2@compute_co

; 4087 :         return -1;

  00143	b8 ff ff ff ff	 mov	 eax, -1
  00148	eb 16		 jmp	 SHORT $LN12@compute_co
$LN2@compute_co:

; 4088 :         if (n == 0) {

  0014a	83 7c 24 24 00	 cmp	 DWORD PTR n$[rsp], 0
  0014f	75 0b		 jne	 SHORT $LN1@compute_co

; 4089 :         flags |= CO_NOFREE;

  00151	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00155	83 c8 40	 or	 eax, 64			; 00000040H
  00158	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax
$LN1@compute_co:
$LN3@compute_co:

; 4090 :         }
; 4091 :     }
; 4092 : 
; 4093 :     return flags;

  0015c	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
$LN12@compute_co:

; 4094 : }

  00160	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00164	c3		 ret	 0
compute_code_flags ENDP
_TEXT	ENDS
PUBLIC	PyAST_Compile
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyAST_Compile DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$PyAST_Compile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyAST_Compile DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyAST_Compile
_TEXT	SEGMENT
mod$ = 64
filename$ = 72
flags$ = 80
arena$ = 88
PyAST_Compile PROC					; COMDAT

; 4258 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4259 :     return PyAST_CompileEx(mod, filename, flags, -1, arena);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR arena$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  00028	4c 8b 44 24 50	 mov	 r8, QWORD PTR flags$[rsp]
  0002d	48 8b 54 24 48	 mov	 rdx, QWORD PTR filename$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mod$[rsp]
  00037	e8 00 00 00 00	 call	 PyAST_CompileEx

; 4260 : }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
PyAST_Compile ENDP
_TEXT	ENDS
END
