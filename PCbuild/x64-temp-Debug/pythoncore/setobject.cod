; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_09FNPENIBB@frozenset?$AA@			; `string'
PUBLIC	??_C@_03KCHOJKKI@set?$AA@			; `string'
PUBLIC	??_C@_06HDLLMMEJ@update?$AA@			; `string'
PUBLIC	??_C@_05MNALHJLP@union?$AA@			; `string'
PUBLIC	??_C@_0L@IOJDFEEE@test_c_api?$AA@		; `string'
PUBLIC	??_C@_0BM@OJODNHLP@symmetric_difference_update?$AA@ ; `string'
PUBLIC	??_C@_0BF@NMFMJDIP@symmetric_difference?$AA@	; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_06LEMKAMD@remove?$AA@			; `string'
PUBLIC	??_C@_03NJDAHFJE@pop?$AA@			; `string'
PUBLIC	??_C@_0L@MEIHPPPH@issuperset?$AA@		; `string'
PUBLIC	??_C@_08NCLBICHP@issubset?$AA@			; `string'
PUBLIC	??_C@_0L@EMANFHEK@isdisjoint?$AA@		; `string'
PUBLIC	??_C@_0BE@EMPOGGNJ@intersection_update?$AA@	; `string'
PUBLIC	??_C@_0N@JIFGGPLM@intersection?$AA@		; `string'
PUBLIC	??_C@_0BC@LNEPHBNC@difference_update?$AA@	; `string'
PUBLIC	??_C@_0L@CHCOIIBP@difference?$AA@		; `string'
PUBLIC	??_C@_07FGAIHHOI@discard?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_0N@MCIOADFH@__contains__?$AA@		; `string'
PUBLIC	??_C@_05MEHLAELG@clear?$AA@			; `string'
PUBLIC	??_C@_03BDGOHNNK@add?$AA@			; `string'
PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_0N@BIJDNHNJ@set_iterator?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
PUBLIC	PySetIter_Type
PUBLIC	PySet_Type
PUBLIC	PyFrozenSet_Type
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_HashNotImplemented:PROC
EXTRN	PyObject_SelfIter:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
_BSS	SEGMENT
dummy	DQ	01H DUP (?)
numfree	DD	01H DUP (?)
	ALIGN	8

emptyfrozenset DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09FNPENIBB@frozenset?$AA@
CONST	SEGMENT
??_C@_09FNPENIBB@frozenset?$AA@ DB 'frozenset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCHOJKKI@set?$AA@
CONST	SEGMENT
??_C@_03KCHOJKKI@set?$AA@ DB 'set', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDLLMMEJ@update?$AA@
CONST	SEGMENT
??_C@_06HDLLMMEJ@update?$AA@ DB 'update', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNALHJLP@union?$AA@
CONST	SEGMENT
??_C@_05MNALHJLP@union?$AA@ DB 'union', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IOJDFEEE@test_c_api?$AA@
CONST	SEGMENT
??_C@_0L@IOJDFEEE@test_c_api?$AA@ DB 'test_c_api', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OJODNHLP@symmetric_difference_update?$AA@
CONST	SEGMENT
??_C@_0BM@OJODNHLP@symmetric_difference_update?$AA@ DB 'symmetric_differe'
	DB	'nce_update', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NMFMJDIP@symmetric_difference?$AA@
CONST	SEGMENT
??_C@_0BF@NMFMJDIP@symmetric_difference?$AA@ DB 'symmetric_difference', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEMKAMD@remove?$AA@
CONST	SEGMENT
??_C@_06LEMKAMD@remove?$AA@ DB 'remove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJDAHFJE@pop?$AA@
CONST	SEGMENT
??_C@_03NJDAHFJE@pop?$AA@ DB 'pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEIHPPPH@issuperset?$AA@
CONST	SEGMENT
??_C@_0L@MEIHPPPH@issuperset?$AA@ DB 'issuperset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCLBICHP@issubset?$AA@
CONST	SEGMENT
??_C@_08NCLBICHP@issubset?$AA@ DB 'issubset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMANFHEK@isdisjoint?$AA@
CONST	SEGMENT
??_C@_0L@EMANFHEK@isdisjoint?$AA@ DB 'isdisjoint', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMPOGGNJ@intersection_update?$AA@
CONST	SEGMENT
??_C@_0BE@EMPOGGNJ@intersection_update?$AA@ DB 'intersection_update', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JIFGGPLM@intersection?$AA@
CONST	SEGMENT
??_C@_0N@JIFGGPLM@intersection?$AA@ DB 'intersection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LNEPHBNC@difference_update?$AA@
CONST	SEGMENT
??_C@_0BC@LNEPHBNC@difference_update?$AA@ DB 'difference_update', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CHCOIIBP@difference?$AA@
CONST	SEGMENT
??_C@_0L@CHCOIIBP@difference?$AA@ DB 'difference', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FGAIHHOI@discard?$AA@
CONST	SEGMENT
??_C@_07FGAIHHOI@discard?$AA@ DB 'discard', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MCIOADFH@__contains__?$AA@
CONST	SEGMENT
??_C@_0N@MCIOADFH@__contains__?$AA@ DB '__contains__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEHLAELG@clear?$AA@
CONST	SEGMENT
??_C@_05MEHLAELG@clear?$AA@ DB 'clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDGOHNNK@add?$AA@
CONST	SEGMENT
??_C@_03BDGOHNNK@add?$AA@ DB 'add', 00H			; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___dict__@?1??set_reduce@@9@9 DQ 0000000000000000H	; `set_reduce'::`2'::PyId___dict__
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BIJDNHNJ@set_iterator?$AA@
CONST	SEGMENT
??_C@_0N@BIJDNHNJ@set_iterator?$AA@ DB 'set_iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
pop_doc	DB	'Remove and return an arbitrary set element.', 0aH, 'Rais'
	DB	'es KeyError if the set is empty.', 00H
	ORG $+7
length_hint_doc DB 'Private method returning an estimate of len(list(it))'
	DB	'.', 00H
	ORG $+1
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+9
setiter_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:setiter_len
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:setiter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PySetIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0N@BIJDNHNJ@set_iterator?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:setiter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:setiter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:setiter_iternext
	DQ	FLAT:setiter_methods
	DQ	0000000000000000H
	ORG $+144
update_doc DB	'Update a set with the union of itself and others.', 00H
	ORG $+6
copy_doc DB	'Return a shallow copy of a set.', 00H
clear_doc DB	'Remove all elements from this set.', 00H
	ORG $+5
union_doc DB	'Return the union of sets as a new set.', 0aH, 0aH, '(i.e'
	DB	'. all elements that are in either set.)', 00H
	ORG $+12
intersection_doc DB 'Return the intersection of two sets as a new set.', 0aH
	DB	0aH, '(i.e. all elements that are in both sets.)', 00H
	ORG $+2
intersection_update_doc DB 'Update a set with the intersection of itself '
	DB	'and another.', 00H
	ORG $+6
isdisjoint_doc DB 'Return True if two sets have a null intersection.', 00H
	ORG $+6
difference_update_doc DB 'Remove all elements of another set from this se'
	DB	't.', 00H
	ORG $+6
difference_doc DB 'Return the difference of two or more sets as a new set'
	DB	'.', 0aH, 0aH, '(i.e. all elements that are in this set but no'
	DB	't the others.)', 00H
	ORG $+10
symmetric_difference_update_doc DB 'Update a set with the symmetric diffe'
	DB	'rence of itself and another.', 00H
	ORG $+14
symmetric_difference_doc DB 'Return the symmetric difference of two sets '
	DB	'as a new set.', 0aH, 0aH, '(i.e. all elements that are in exa'
	DB	'ctly one of the sets.)', 00H
	ORG $+4
issubset_doc DB	'Report whether another set contains this set.', 00H
	ORG $+2
issuperset_doc DB 'Report whether this set contains another set.', 00H
	ORG $+10
add_doc	DB	'Add an element to a set.', 0aH, 0aH, 'This has no effect'
	DB	' if the element is already present.', 00H
contains_doc DB	'x.__contains__(y) <==> y in x.', 00H
	ORG $+1
remove_doc DB	'Remove an element from a set; it must be a member.', 0aH
	DB	0aH, 'If the element is not a member, raise a KeyError.', 00H
	ORG $+10
discard_doc DB	'Remove an element from a set if it is a member.', 0aH, 0aH
	DB	'If the element is not a member, do nothing.', 00H
	ORG $+3
sizeof_doc DB	'S.__sizeof__() -> size of S in memory, in bytes', 00H
set_as_sequence DQ FLAT:set_len
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_contains
	ORG $+16
test_c_api_doc DB 'Exercises C API.  Returns True.', 0aH, 'All is well if'
	DB	' assertions don''t fail.', 00H
	ORG $+10
set_methods DQ	FLAT:??_C@_03BDGOHNNK@add?$AA@
	DQ	FLAT:set_add
	DD	08H
	ORG $+4
	DQ	FLAT:add_doc
	DQ	FLAT:??_C@_05MEHLAELG@clear?$AA@
	DQ	FLAT:set_clear
	DD	04H
	ORG $+4
	DQ	FLAT:clear_doc
	DQ	FLAT:??_C@_0N@MCIOADFH@__contains__?$AA@
	DQ	FLAT:set_direct_contains
	DD	048H
	ORG $+4
	DQ	FLAT:contains_doc
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:set_copy
	DD	04H
	ORG $+4
	DQ	FLAT:copy_doc
	DQ	FLAT:??_C@_07FGAIHHOI@discard?$AA@
	DQ	FLAT:set_discard
	DD	08H
	ORG $+4
	DQ	FLAT:discard_doc
	DQ	FLAT:??_C@_0L@CHCOIIBP@difference?$AA@
	DQ	FLAT:set_difference_multi
	DD	01H
	ORG $+4
	DQ	FLAT:difference_doc
	DQ	FLAT:??_C@_0BC@LNEPHBNC@difference_update?$AA@
	DQ	FLAT:set_difference_update
	DD	01H
	ORG $+4
	DQ	FLAT:difference_update_doc
	DQ	FLAT:??_C@_0N@JIFGGPLM@intersection?$AA@
	DQ	FLAT:set_intersection_multi
	DD	01H
	ORG $+4
	DQ	FLAT:intersection_doc
	DQ	FLAT:??_C@_0BE@EMPOGGNJ@intersection_update?$AA@
	DQ	FLAT:set_intersection_update_multi
	DD	01H
	ORG $+4
	DQ	FLAT:intersection_update_doc
	DQ	FLAT:??_C@_0L@EMANFHEK@isdisjoint?$AA@
	DQ	FLAT:set_isdisjoint
	DD	08H
	ORG $+4
	DQ	FLAT:isdisjoint_doc
	DQ	FLAT:??_C@_08NCLBICHP@issubset?$AA@
	DQ	FLAT:set_issubset
	DD	08H
	ORG $+4
	DQ	FLAT:issubset_doc
	DQ	FLAT:??_C@_0L@MEIHPPPH@issuperset?$AA@
	DQ	FLAT:set_issuperset
	DD	08H
	ORG $+4
	DQ	FLAT:issuperset_doc
	DQ	FLAT:??_C@_03NJDAHFJE@pop?$AA@
	DQ	FLAT:set_pop
	DD	04H
	ORG $+4
	DQ	FLAT:pop_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:set_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_06LEMKAMD@remove?$AA@
	DQ	FLAT:set_remove
	DD	08H
	ORG $+4
	DQ	FLAT:remove_doc
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:set_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof_doc
	DQ	FLAT:??_C@_0BF@NMFMJDIP@symmetric_difference?$AA@
	DQ	FLAT:set_symmetric_difference
	DD	08H
	ORG $+4
	DQ	FLAT:symmetric_difference_doc
	DQ	FLAT:??_C@_0BM@OJODNHLP@symmetric_difference_update?$AA@
	DQ	FLAT:set_symmetric_difference_update
	DD	08H
	ORG $+4
	DQ	FLAT:symmetric_difference_update_doc
	DQ	FLAT:??_C@_0L@IOJDFEEE@test_c_api?$AA@
	DQ	FLAT:test_c_api
	DD	04H
	ORG $+4
	DQ	FLAT:test_c_api_doc
	DQ	FLAT:??_C@_05MNALHJLP@union?$AA@
	DQ	FLAT:set_union
	DD	01H
	ORG $+4
	DQ	FLAT:union_doc
	DQ	FLAT:??_C@_06HDLLMMEJ@update?$AA@
	DQ	FLAT:set_update
	DD	01H
	ORG $+4
	DQ	FLAT:update_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
set_as_number DQ 0000000000000000H
	DQ	FLAT:set_sub
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_and
	DQ	FLAT:set_xor
	DQ	FLAT:set_or
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_isub
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_iand
	DQ	FLAT:set_ixor
	DQ	FLAT:set_ior
	ORG $+40
set_doc	DB	'set() -> new empty set object', 0aH, 'set(iterable) -> n'
	DB	'ew set object', 0aH, 0aH, 'Build an unordered collection of u'
	DB	'nique elements.', 00H
	ORG $+15
PySet_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_03KCHOJKKI@set?$AA@
	DQ	0000000000000120H
	DQ	0000000000000000H
	DQ	FLAT:set_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_repr
	DQ	FLAT:set_as_number
	DQ	FLAT:set_as_sequence
	DQ	0000000000000000H
	DQ	FLAT:PyObject_HashNotImplemented
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:set_doc
	DQ	FLAT:set_traverse
	DQ	FLAT:set_clear_internal
	DQ	FLAT:set_richcompare
	DQ	0000000000000110H
	DQ	FLAT:set_iter
	DQ	0000000000000000H
	DQ	FLAT:set_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:set_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
frozenset_methods DQ FLAT:??_C@_0N@MCIOADFH@__contains__?$AA@
	DQ	FLAT:set_direct_contains
	DD	048H
	ORG $+4
	DQ	FLAT:contains_doc
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:frozenset_copy
	DD	04H
	ORG $+4
	DQ	FLAT:copy_doc
	DQ	FLAT:??_C@_0L@CHCOIIBP@difference?$AA@
	DQ	FLAT:set_difference_multi
	DD	01H
	ORG $+4
	DQ	FLAT:difference_doc
	DQ	FLAT:??_C@_0N@JIFGGPLM@intersection?$AA@
	DQ	FLAT:set_intersection_multi
	DD	01H
	ORG $+4
	DQ	FLAT:intersection_doc
	DQ	FLAT:??_C@_0L@EMANFHEK@isdisjoint?$AA@
	DQ	FLAT:set_isdisjoint
	DD	08H
	ORG $+4
	DQ	FLAT:isdisjoint_doc
	DQ	FLAT:??_C@_08NCLBICHP@issubset?$AA@
	DQ	FLAT:set_issubset
	DD	08H
	ORG $+4
	DQ	FLAT:issubset_doc
	DQ	FLAT:??_C@_0L@MEIHPPPH@issuperset?$AA@
	DQ	FLAT:set_issuperset
	DD	08H
	ORG $+4
	DQ	FLAT:issuperset_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:set_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:set_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof_doc
	DQ	FLAT:??_C@_0BF@NMFMJDIP@symmetric_difference?$AA@
	DQ	FLAT:set_symmetric_difference
	DD	08H
	ORG $+4
	DQ	FLAT:symmetric_difference_doc
	DQ	FLAT:??_C@_05MNALHJLP@union?$AA@
	DQ	FLAT:set_union
	DD	01H
	ORG $+4
	DQ	FLAT:union_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
frozenset_as_number DQ 0000000000000000H
	DQ	FLAT:set_sub
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_and
	DQ	FLAT:set_xor
	DQ	FLAT:set_or
	ORG $+144
frozenset_doc DB 'frozenset() -> empty frozenset object', 0aH, 'frozenset'
	DB	'(iterable) -> frozenset object', 0aH, 0aH, 'Build an immutabl'
	DB	'e unordered collection of unique elements.', 00H
	ORG $+5
PyFrozenSet_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_09FNPENIBB@frozenset?$AA@
	DQ	0000000000000120H
	DQ	0000000000000000H
	DQ	FLAT:set_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_repr
	DQ	FLAT:frozenset_as_number
	DQ	FLAT:set_as_sequence
	DQ	0000000000000000H
	DQ	FLAT:frozenset_hash
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:frozenset_doc
	DQ	FLAT:set_traverse
	DQ	FLAT:set_clear_internal
	DQ	FLAT:set_richcompare
	DQ	0000000000000110H
	DQ	FLAT:set_iter
	DQ	0000000000000000H
	DQ	FLAT:frozenset_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:frozenset_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
_DATA	ENDS
PUBLIC	_PySet_Dummy
; Function compile flags: /Odtp
; File c:\src\pyparallel\objects\setobject.c
;	COMDAT _PySet_Dummy
_TEXT	SEGMENT
_PySet_Dummy PROC					; COMDAT

; 38   :     return dummy;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dummy

; 39   : }

  00007	c3		 ret	 0
_PySet_Dummy ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CG@COHMIPKH@?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?9?$AA?$DO?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_1M@HALLKPON@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@ODLIIOHJ@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@MEACPONF@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAo?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	_Py_PXCTX:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp__wassert:PROC
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_clear_internal DD imagerel set_clear_internal
	DD	imagerel set_clear_internal+943
	DD	imagerel $unwind$set_clear_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_clear_internal DD 020c01H
	DD	01d010cH
xdata	ENDS
;	COMDAT ??_C@_1CG@COHMIPKH@?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?9?$AA?$DO?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@COHMIPKH@?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?9?$AA?$DO?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'e'
	DB	00H, 'n', 00H, 't', 00H, 'r', 00H, 'y', 00H, '-', 00H, '>', 00H
	DB	'k', 00H, 'e', 00H, 'y', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HALLKPON@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HALLKPON@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAn?$AA?$AA@ DB 'i', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@ODLIIOHJ@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@ODLIIOHJ@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MEACPONF@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAo?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@MEACPONF@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAo?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'A', 00H, 'n', 00H, 'y', 00H, 'S', 00H, 'e', 00H
	DB	't', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k'
	DB	00H, '(', 00H, 's', 00H, 'o', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '\', 00H, 's', 00H, 'e', 00H, 't'
	DB	00H, 'o', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	'.', 00H, 'c', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_clear_internal
_TEXT	SEGMENT
n$ = 32
i$ = 40
small_copy$ = 48
table_is_malloced$ = 176
table$ = 184
fill$ = 192
entry$ = 200
tv92 = 208
tv179 = 212
so$ = 240
set_clear_internal PROC					; COMDAT

; 456  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 457  :     setentry *entry, *table;
; 458  :     int table_is_malloced;
; 459  :     Py_ssize_t fill;
; 460  :     setentry small_copy[PySet_MINSIZE];
; 461  : #ifdef Py_DEBUG
; 462  :     Py_ssize_t i, n;
; 463  :     assert (PyAnySet_Check(so));

  0000c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00013	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  0001b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001f	74 69		 je	 SHORT $LN24@set_clear_
  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00028	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00030	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00034	74 54		 je	 SHORT $LN24@set_clear_
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0003d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00045	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00049	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004e	85 c0		 test	 eax, eax
  00050	75 38		 jne	 SHORT $LN24@set_clear_
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00059	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00061	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00065	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006a	85 c0		 test	 eax, eax
  0006c	75 1c		 jne	 SHORT $LN24@set_clear_
  0006e	41 b8 cf 01 00
	00		 mov	 r8d, 463		; 000001cfH
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@MEACPONF@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAo?$AA?$CJ?$AA?$AA@
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00088	33 c0		 xor	 eax, eax
$LN24@set_clear_:

; 464  : 
; 465  :     n = so->mask + 1;

  0008a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00092	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00096	48 ff c0	 inc	 rax
  00099	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 466  :     i = 0;

  0009e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0

; 467  : #endif
; 468  : 
; 469  :     table = so->table;

  000a7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  000af	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000b3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR table$[rsp], rax

; 470  :     assert(table != NULL);

  000bb	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR table$[rsp], 0
  000c4	75 1c		 jne	 SHORT $LN25@set_clear_
  000c6	41 b8 d6 01 00
	00		 mov	 r8d, 470		; 000001d6H
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@ODLIIOHJ@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e0	33 c0		 xor	 eax, eax
$LN25@set_clear_:

; 471  :     table_is_malloced = table != so->smalltable;

  000e2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  000ea	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  000f0	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR table$[rsp], rax
  000f8	74 0d		 je	 SHORT $LN26@set_clear_
  000fa	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv92[rsp], 1
  00105	eb 0b		 jmp	 SHORT $LN27@set_clear_
$LN26@set_clear_:
  00107	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv92[rsp], 0
$LN27@set_clear_:
  00112	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv92[rsp]
  00119	89 84 24 b0 00
	00 00		 mov	 DWORD PTR table_is_malloced$[rsp], eax

; 472  : 
; 473  :     /* This is delicate.  During the process of clearing the set,
; 474  :      * decrefs can cause the set to mutate.  To avoid fatal confusion
; 475  :      * (voice of experience), we have to make the set empty before
; 476  :      * clearing the slots, and never refer to anything via so->ref while
; 477  :      * clearing.
; 478  :      */
; 479  :     fill = so->fill;

  00120	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00128	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0012c	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR fill$[rsp], rax

; 480  :     if (table_is_malloced)

  00134	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR table_is_malloced$[rsp], 0
  0013c	0f 84 90 00 00
	00		 je	 $LN21@set_clear_
$LN20@set_clear_:

; 481  :         EMPTY_TO_MINSIZE(so);

  00142	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  0014a	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00150	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00156	33 d2		 xor	 edx, edx
  00158	48 8b c8	 mov	 rcx, rax
  0015b	e8 00 00 00 00	 call	 memset
  00160	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00168	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  00170	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00178	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN17@set_clear_:
  00180	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00188	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  0018e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00196	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax
  0019a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  001a2	48 c7 40 70 07
	00 00 00	 mov	 QWORD PTR [rax+112], 7
  001aa	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  001b2	48 c7 80 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+264], -1
  001bd	33 c0		 xor	 eax, eax
  001bf	85 c0		 test	 eax, eax
  001c1	75 bd		 jne	 SHORT $LN17@set_clear_
  001c3	33 c0		 xor	 eax, eax
  001c5	85 c0		 test	 eax, eax
  001c7	0f 85 75 ff ff
	ff		 jne	 $LN20@set_clear_

; 482  : 
; 483  :     else if (fill > 0) {

  001cd	e9 bf 00 00 00	 jmp	 $LN14@set_clear_
$LN21@set_clear_:
  001d2	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR fill$[rsp], 0
  001db	0f 8e b0 00 00
	00		 jle	 $LN13@set_clear_

; 484  :         /* It's a small table with something that needs to be cleared.
; 485  :          * Afraid the only safe way is to copy the set entries into
; 486  :          * another small table first.
; 487  :          */
; 488  :         memcpy(small_copy, table, sizeof(small_copy));

  001e1	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  001e7	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR table$[rsp]
  001ef	48 8d 4c 24 30	 lea	 rcx, QWORD PTR small_copy$[rsp]
  001f4	e8 00 00 00 00	 call	 memcpy

; 489  :         table = small_copy;

  001f9	48 8d 44 24 30	 lea	 rax, QWORD PTR small_copy$[rsp]
  001fe	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR table$[rsp], rax
$LN12@set_clear_:

; 490  :         EMPTY_TO_MINSIZE(so);

  00206	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  0020e	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00214	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0021a	33 d2		 xor	 edx, edx
  0021c	48 8b c8	 mov	 rcx, rax
  0021f	e8 00 00 00 00	 call	 memset
  00224	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  0022c	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  00234	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  0023c	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN9@set_clear_:
  00244	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  0024c	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00252	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  0025a	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax
  0025e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00266	48 c7 40 70 07
	00 00 00	 mov	 QWORD PTR [rax+112], 7
  0026e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00276	48 c7 80 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+264], -1
  00281	33 c0		 xor	 eax, eax
  00283	85 c0		 test	 eax, eax
  00285	75 bd		 jne	 SHORT $LN9@set_clear_
  00287	33 c0		 xor	 eax, eax
  00289	85 c0		 test	 eax, eax
  0028b	0f 85 75 ff ff
	ff		 jne	 $LN12@set_clear_
$LN13@set_clear_:
$LN14@set_clear_:

; 491  :     }
; 492  :     /* else it's a small table that's already empty */
; 493  : 
; 494  :     /* Now we can finally clear things.  If C had refcounts, we could
; 495  :      * assert that the refcount on table is 1 now, i.e. that this function
; 496  :      * has unique access to it, so decref side-effects can't alter it.
; 497  :      */
; 498  :     for (entry = table; fill > 0; ++entry) {

  00291	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00299	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR entry$[rsp], rax
  002a1	eb 14		 jmp	 SHORT $LN6@set_clear_
$LN5@set_clear_:
  002a3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  002ab	48 83 c0 10	 add	 rax, 16
  002af	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR entry$[rsp], rax
$LN6@set_clear_:
  002b7	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR fill$[rsp], 0
  002c0	0f 8e 9a 00 00
	00		 jle	 $LN4@set_clear_

; 499  : #ifdef Py_DEBUG
; 500  :         assert(i < n);

  002c6	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  002cb	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  002d0	7c 1c		 jl	 SHORT $LN28@set_clear_
  002d2	41 b8 f4 01 00
	00		 mov	 r8d, 500		; 000001f4H
  002d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1M@HALLKPON@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAn?$AA?$AA@
  002e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ec	33 c0		 xor	 eax, eax
$LN28@set_clear_:

; 501  :         ++i;

  002ee	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  002f3	48 ff c0	 inc	 rax
  002f6	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 502  : #endif
; 503  :         if (entry->key) {

  002fb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  00303	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00308	74 26		 je	 SHORT $LN3@set_clear_

; 504  :             --fill;

  0030a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR fill$[rsp]
  00312	48 ff c8	 dec	 rax
  00315	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR fill$[rsp], rax

; 505  :             Py_DECREF(entry->key);

  0031d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  00325	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00329	e8 00 00 00 00	 call	 _Py_DecRef

; 506  :         }
; 507  : #ifdef Py_DEBUG
; 508  :         else

  0032e	eb 2b		 jmp	 SHORT $LN2@set_clear_
$LN3@set_clear_:

; 509  :             assert(entry->key == NULL);

  00330	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  00338	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0033d	74 1c		 je	 SHORT $LN29@set_clear_
  0033f	41 b8 fd 01 00
	00		 mov	 r8d, 509		; 000001fdH
  00345	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0034c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@COHMIPKH@?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?9?$AA?$DO?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00353	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00359	33 c0		 xor	 eax, eax
$LN29@set_clear_:
$LN2@set_clear_:

; 510  : #endif
; 511  :     }

  0035b	e9 43 ff ff ff	 jmp	 $LN5@set_clear_
$LN4@set_clear_:

; 512  : 
; 513  :     if (table_is_malloced)

  00360	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR table_is_malloced$[rsp], 0
  00368	74 3b		 je	 SHORT $LN1@set_clear_

; 514  :         PyMem_DEL(table);

  0036a	e8 00 00 00 00	 call	 _Py_PXCTX
  0036f	85 c0		 test	 eax, eax
  00371	74 1a		 je	 SHORT $LN30@set_clear_
  00373	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0037b	e8 00 00 00 00	 call	 _PxMem_Free
  00380	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv179[rsp], 0
  0038b	eb 18		 jmp	 SHORT $LN31@set_clear_
$LN30@set_clear_:
  0038d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00395	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0039a	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv179[rsp], 0
$LN31@set_clear_:
$LN1@set_clear_:

; 515  :     return 0;

  003a5	33 c0		 xor	 eax, eax

; 516  : }

  003a7	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  003ae	c3		 ret	 0
set_clear_internal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@MKNKIMNJ@set_dealloc?$AA@		; `string'
PUBLIC	??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@ ; `string'
EXTRN	_PyTrash_thread_deposit_object:PROC
EXTRN	_PyTrash_thread_destroy_chain:PROC
EXTRN	PyObject_ClearWeakRefs:PROC
EXTRN	PyThreadState_Get:PROC
EXTRN	PyObject_GC_UnTrack:PROC
EXTRN	_PyParallel_ContextGuardFailure:PROC
_BSS	SEGMENT
free_list DQ	050H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\setobject.c
pdata	SEGMENT
$pdata$set_dealloc DD imagerel set_dealloc
	DD	imagerel set_dealloc+492
	DD	imagerel $unwind$set_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_dealloc DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0M@MKNKIMNJ@set_dealloc?$AA@
CONST	SEGMENT
??_C@_0M@MKNKIMNJ@set_dealloc?$AA@ DB 'set_dealloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
CONST	SEGMENT
??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@ DB '..\Objects\setobj'
	DB	'ect.c', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_dealloc
_TEXT	SEGMENT
fill$ = 32
entry$ = 40
_tstate$20789 = 48
tv130 = 56
so$ = 80
set_dealloc PROC					; COMDAT

; 555  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 556  :     register setentry *entry;
; 557  :     Py_ssize_t fill = so->fill;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 89 44 24 20	 mov	 QWORD PTR fill$[rsp], rax

; 558  :     Py_GUARD

  00017	e8 00 00 00 00	 call	 _Py_PXCTX
  0001c	85 c0		 test	 eax, eax
  0001e	74 1c		 je	 SHORT $LN16@set_deallo
  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 2e 02 00
	00		 mov	 r8d, 558		; 0000022eH
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MKNKIMNJ@set_dealloc?$AA@
  00037	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN16@set_deallo:

; 559  :     PyObject_GC_UnTrack(so);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00041	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN15@set_deallo:

; 560  :     Py_TRASHCAN_SAFE_BEGIN(so)

  00046	e8 00 00 00 00	 call	 PyThreadState_Get
  0004b	48 89 44 24 30	 mov	 QWORD PTR _tstate$20789[rsp], rax
  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR _tstate$20789[rsp]
  00055	83 b8 94 00 00
	00 32		 cmp	 DWORD PTR [rax+148], 50	; 00000032H
  0005c	0f 8d 71 01 00
	00		 jge	 $LN12@set_deallo
  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR _tstate$20789[rsp]
  00067	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0006d	ff c0		 inc	 eax
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _tstate$20789[rsp]
  00074	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 561  :     if (so->weakreflist != NULL)

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0007f	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  00087	74 0a		 je	 SHORT $LN11@set_deallo

; 562  :         PyObject_ClearWeakRefs((PyObject *) so);

  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  0008e	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN11@set_deallo:

; 563  : 
; 564  :     for (entry = so->table; fill > 0; entry++) {

  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00098	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0009c	48 89 44 24 28	 mov	 QWORD PTR entry$[rsp], rax
  000a1	eb 0e		 jmp	 SHORT $LN10@set_deallo
$LN9@set_deallo:
  000a3	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  000a8	48 83 c0 10	 add	 rax, 16
  000ac	48 89 44 24 28	 mov	 QWORD PTR entry$[rsp], rax
$LN10@set_deallo:
  000b1	48 83 7c 24 20
	00		 cmp	 QWORD PTR fill$[rsp], 0
  000b7	7e 29		 jle	 SHORT $LN8@set_deallo

; 565  :         if (entry->key) {

  000b9	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  000be	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000c3	74 1b		 je	 SHORT $LN7@set_deallo

; 566  :             --fill;

  000c5	48 8b 44 24 20	 mov	 rax, QWORD PTR fill$[rsp]
  000ca	48 ff c8	 dec	 rax
  000cd	48 89 44 24 20	 mov	 QWORD PTR fill$[rsp], rax

; 567  :             Py_DECREF(entry->key);

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  000d7	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000db	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@set_deallo:

; 568  :         }
; 569  :     }

  000e0	eb c1		 jmp	 SHORT $LN9@set_deallo
$LN8@set_deallo:

; 570  :     if (so->table != so->smalltable)

  000e2	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000e7	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  000f2	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  000f6	74 37		 je	 SHORT $LN6@set_deallo

; 571  :         PyMem_DEL(so->table);

  000f8	e8 00 00 00 00	 call	 _Py_PXCTX
  000fd	85 c0		 test	 eax, eax
  000ff	74 18		 je	 SHORT $LN19@set_deallo
  00101	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00106	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  0010a	e8 00 00 00 00	 call	 _PxMem_Free
  0010f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
  00117	eb 16		 jmp	 SHORT $LN20@set_deallo
$LN19@set_deallo:
  00119	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0011e	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00122	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00127	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN20@set_deallo:
$LN6@set_deallo:

; 572  :     if (numfree < PySet_MAXFREELIST && PyAnySet_CheckExact(so))

  0012f	83 3d 00 00 00
	00 50		 cmp	 DWORD PTR numfree, 80	; 00000050H
  00136	7d 4b		 jge	 SHORT $LN5@set_deallo
  00138	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0013f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00144	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00148	74 12		 je	 SHORT $LN4@set_deallo
  0014a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00151	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00156	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0015a	75 27		 jne	 SHORT $LN5@set_deallo
$LN4@set_deallo:

; 573  :         free_list[numfree++] = so;

  0015c	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR numfree
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:free_list
  0016a	48 8b 54 24 50	 mov	 rdx, QWORD PTR so$[rsp]
  0016f	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  00173	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  00179	ff c0		 inc	 eax
  0017b	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax

; 574  :     else

  00181	eb 14		 jmp	 SHORT $LN3@set_deallo
$LN5@set_deallo:

; 575  :         Py_TYPE(so)->tp_free(so);

  00183	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00188	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0018c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00191	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]
$LN3@set_deallo:

; 576  :     Py_TRASHCAN_SAFE_END(so)

  00197	48 8b 44 24 30	 mov	 rax, QWORD PTR _tstate$20789[rsp]
  0019c	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  001a2	ff c8		 dec	 eax
  001a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _tstate$20789[rsp]
  001a9	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax
  001af	48 8b 44 24 30	 mov	 rax, QWORD PTR _tstate$20789[rsp]
  001b4	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  001bc	74 13		 je	 SHORT $LN2@set_deallo
  001be	48 8b 44 24 30	 mov	 rax, QWORD PTR _tstate$20789[rsp]
  001c3	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  001ca	7f 05		 jg	 SHORT $LN2@set_deallo
  001cc	e8 00 00 00 00	 call	 _PyTrash_thread_destroy_chain
$LN2@set_deallo:
  001d1	eb 0a		 jmp	 SHORT $LN1@set_deallo
$LN12@set_deallo:
  001d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  001d8	e8 00 00 00 00	 call	 _PyTrash_thread_deposit_object
$LN1@set_deallo:
  001dd	33 c0		 xor	 eax, eax
  001df	85 c0		 test	 eax, eax
  001e1	0f 85 5f fe ff
	ff		 jne	 $LN15@set_deallo

; 577  : }

  001e7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001eb	c3		 ret	 0
set_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_04NANFGNNA@?$HL?$CFU?$HN?$AA@		; `string'
PUBLIC	??_C@_08IDGFALDL@?$CFs?$CI?$HL?$CFU?$HN?$CJ?$AA@ ; `string'
PUBLIC	??_C@_1DK@PNCNDKJG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAl?$AAi?$AAs?$AAt?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@NHHBKOBP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAl?$AAi?$AAs?$AAt?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@		; `string'
PUBLIC	??_C@_07FFLNLMCA@?$CFs?$CI?4?4?4?$CJ?$AA@	; `string'
EXTRN	PyUnicode_Substring:PROC
EXTRN	PyObject_Repr:PROC
EXTRN	PySequence_List:PROC
EXTRN	Py_ReprLeave:PROC
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	Py_ReprEnter:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_repr DD imagerel set_repr
	DD	imagerel set_repr+471
	DD	imagerel $unwind$set_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_repr DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_04NANFGNNA@?$HL?$CFU?$HN?$AA@
CONST	SEGMENT
??_C@_04NANFGNNA@?$HL?$CFU?$HN?$AA@ DB '{%U}', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGFALDL@?$CFs?$CI?$HL?$CFU?$HN?$CJ?$AA@
CONST	SEGMENT
??_C@_08IDGFALDL@?$CFs?$CI?$HL?$CFU?$HN?$CJ?$AA@ DB '%s({%U})', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@PNCNDKJG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAl?$AAi?$AAs?$AAt?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@PNCNDKJG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAl?$AAi?$AAs?$AAt?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'l', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'r'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@NHHBKOBP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAl?$AAi?$AAs?$AAt?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@NHHBKOBP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAl?$AAi?$AAs?$AAt?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'e', 00H, 'p', 00H, 'r', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@ DB '%s()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FFLNLMCA@?$CFs?$CI?4?4?4?$CJ?$AA@
CONST	SEGMENT
??_C@_07FFLNLMCA@?$CFs?$CI?4?4?4?$CJ?$AA@ DB '%s(...)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_repr
_TEXT	SEGMENT
tmp$ = 32
status$ = 40
listrepr$ = 48
keys$ = 56
result$ = 64
so$ = 96
set_repr PROC						; COMDAT

; 581  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 582  :     PyObject *result=NULL, *keys, *listrepr, *tmp;

  00009	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 583  :     int status = Py_ReprEnter((PyObject*)so);

  00012	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00017	e8 00 00 00 00	 call	 Py_ReprEnter
  0001c	89 44 24 28	 mov	 DWORD PTR status$[rsp], eax

; 584  : 
; 585  :     if (status != 0) {

  00020	83 7c 24 28 00	 cmp	 DWORD PTR status$[rsp], 0
  00025	74 2c		 je	 SHORT $LN8@set_repr

; 586  :         if (status < 0)

  00027	83 7c 24 28 00	 cmp	 DWORD PTR status$[rsp], 0
  0002c	7d 07		 jge	 SHORT $LN7@set_repr

; 587  :             return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 9d 01 00 00	 jmp	 $LN9@set_repr
$LN7@set_repr:

; 588  :         return PyUnicode_FromFormat("%s(...)", Py_TYPE(so)->tp_name);

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  0003a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003e	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07FFLNLMCA@?$CFs?$CI?4?4?4?$CJ?$AA@
  00049	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0004e	e9 7f 01 00 00	 jmp	 $LN9@set_repr
$LN8@set_repr:

; 589  :     }
; 590  : 
; 591  :     /* shortcut for the empty set */
; 592  :     if (!so->used) {

  00053	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  00058	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0005d	75 28		 jne	 SHORT $LN6@set_repr

; 593  :         Py_ReprLeave((PyObject*)so);

  0005f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00064	e8 00 00 00 00	 call	 Py_ReprLeave

; 594  :         return PyUnicode_FromFormat("%s()", Py_TYPE(so)->tp_name);

  00069	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  0006e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00072	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@
  0007d	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00082	e9 4b 01 00 00	 jmp	 $LN9@set_repr
$LN6@set_repr:

; 595  :     }
; 596  : 
; 597  :     keys = PySequence_List((PyObject *)so);

  00087	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  0008c	e8 00 00 00 00	 call	 PySequence_List
  00091	48 89 44 24 38	 mov	 QWORD PTR keys$[rsp], rax

; 598  :     if (keys == NULL)

  00096	48 83 7c 24 38
	00		 cmp	 QWORD PTR keys$[rsp], 0
  0009c	75 05		 jne	 SHORT $LN5@set_repr

; 599  :         goto done;

  0009e	e9 20 01 00 00	 jmp	 $done$20832
$LN5@set_repr:

; 600  : 
; 601  :     /* repr(keys)[1:-1] */
; 602  :     listrepr = PyObject_Repr(keys);

  000a3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR keys$[rsp]
  000a8	e8 00 00 00 00	 call	 PyObject_Repr
  000ad	48 89 44 24 30	 mov	 QWORD PTR listrepr$[rsp], rax

; 603  :     Py_DECREF(keys);

  000b2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR keys$[rsp]
  000b7	e8 00 00 00 00	 call	 _Py_DecRef

; 604  :     if (listrepr == NULL)

  000bc	48 83 7c 24 30
	00		 cmp	 QWORD PTR listrepr$[rsp], 0
  000c2	75 05		 jne	 SHORT $LN4@set_repr

; 605  :         goto done;

  000c4	e9 fa 00 00 00	 jmp	 $done$20832
$LN4@set_repr:

; 606  :     tmp = PyUnicode_Substring(listrepr, 1, PyUnicode_GET_LENGTH(listrepr)-1);

  000c9	48 8b 44 24 30	 mov	 rax, QWORD PTR listrepr$[rsp]
  000ce	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d8	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000dd	85 c0		 test	 eax, eax
  000df	75 1c		 jne	 SHORT $LN11@set_repr
  000e1	41 b8 5e 02 00
	00		 mov	 r8d, 606		; 0000025eH
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@NHHBKOBP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAl?$AAi?$AAs?$AAt?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fb	33 c0		 xor	 eax, eax
$LN11@set_repr:
  000fd	48 8b 44 24 30	 mov	 rax, QWORD PTR listrepr$[rsp]
  00102	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00105	c1 e8 07	 shr	 eax, 7
  00108	83 e0 01	 and	 eax, 1
  0010b	85 c0		 test	 eax, eax
  0010d	75 1c		 jne	 SHORT $LN12@set_repr
  0010f	41 b8 5e 02 00
	00		 mov	 r8d, 606		; 0000025eH
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@PNCNDKJG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAl?$AAi?$AAs?$AAt?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00129	33 c0		 xor	 eax, eax
$LN12@set_repr:
  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR listrepr$[rsp]
  00130	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00134	48 ff c8	 dec	 rax
  00137	4c 8b c0	 mov	 r8, rax
  0013a	ba 01 00 00 00	 mov	 edx, 1
  0013f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR listrepr$[rsp]
  00144	e8 00 00 00 00	 call	 PyUnicode_Substring
  00149	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 607  :     Py_DECREF(listrepr);

  0014e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR listrepr$[rsp]
  00153	e8 00 00 00 00	 call	 _Py_DecRef

; 608  :     if (tmp == NULL)

  00158	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0015e	75 02		 jne	 SHORT $LN3@set_repr

; 609  :         goto done;

  00160	eb 61		 jmp	 SHORT $done$20832
$LN3@set_repr:

; 610  :     listrepr = tmp;

  00162	48 8b 44 24 20	 mov	 rax, QWORD PTR tmp$[rsp]
  00167	48 89 44 24 30	 mov	 QWORD PTR listrepr$[rsp], rax

; 611  : 
; 612  :     if (Py_TYPE(so) != &PySet_Type)

  0016c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00173	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00178	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0017c	74 25		 je	 SHORT $LN2@set_repr

; 613  :         result = PyUnicode_FromFormat("%s({%U})",
; 614  :                                       Py_TYPE(so)->tp_name,
; 615  :                                       listrepr);

  0017e	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  00183	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00187	4c 8b 44 24 30	 mov	 r8, QWORD PTR listrepr$[rsp]
  0018c	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08IDGFALDL@?$CFs?$CI?$HL?$CFU?$HN?$CJ?$AA@
  00197	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0019c	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 616  :     else

  001a1	eb 16		 jmp	 SHORT $LN1@set_repr
$LN2@set_repr:

; 617  :         result = PyUnicode_FromFormat("{%U}", listrepr);

  001a3	48 8b 54 24 30	 mov	 rdx, QWORD PTR listrepr$[rsp]
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04NANFGNNA@?$HL?$CFU?$HN?$AA@
  001af	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  001b4	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax
$LN1@set_repr:

; 618  :     Py_DECREF(listrepr);

  001b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR listrepr$[rsp]
  001be	e8 00 00 00 00	 call	 _Py_DecRef
$done$20832:

; 619  : done:
; 620  :     Py_ReprLeave((PyObject*)so);

  001c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  001c8	e8 00 00 00 00	 call	 Py_ReprLeave

; 621  :     return result;

  001cd	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN9@set_repr:

; 622  : }

  001d2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d6	c3		 ret	 0
set_repr ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT set_len
_TEXT	SEGMENT
so$ = 8
set_len	PROC						; COMDAT

; 626  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 627  :     return ((PySetObject *)so)->used;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR so$[rsp]
  0000a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]

; 628  : }

  0000e	c3		 ret	 0
set_len	ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0BG@MMGMMGKJ@pop?5from?5an?5empty?5set?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_KeyError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_pop DD imagerel set_pop
	DD	imagerel set_pop+450
	DD	imagerel $unwind$set_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_pop DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BG@MMGMMGKJ@pop?5from?5an?5empty?5set?$AA@
CONST	SEGMENT
??_C@_0BG@MMGMMGKJ@pop?5from?5an?5empty?5set?$AA@ DB 'pop from an empty s'
	DB	'et', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_pop
_TEXT	SEGMENT
i$ = 32
key$ = 40
entry$ = 48
so$ = 80
set_pop	PROC						; COMDAT

; 704  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 705  :     register Py_ssize_t i = 0;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0

; 706  :     register setentry *entry;
; 707  :     PyObject *key;
; 708  : 
; 709  :     assert (PyAnySet_Check(so));

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  0001e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00022	74 60		 je	 SHORT $LN12@set_pop
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0002b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00030	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00034	74 4e		 je	 SHORT $LN12@set_pop
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00042	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00046	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004b	85 c0		 test	 eax, eax
  0004d	75 35		 jne	 SHORT $LN12@set_pop
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0005b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00064	85 c0		 test	 eax, eax
  00066	75 1c		 jne	 SHORT $LN12@set_pop
  00068	41 b8 c5 02 00
	00		 mov	 r8d, 709		; 000002c5H
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@MEACPONF@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAo?$AA?$CJ?$AA?$AA@
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00082	33 c0		 xor	 eax, eax
$LN12@set_pop:

; 710  :     if (so->used == 0) {

  00084	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00089	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0008e	75 1a		 jne	 SHORT $LN9@set_pop

; 711  :         PyErr_SetString(PyExc_KeyError, "pop from an empty set");

  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@MMGMMGKJ@pop?5from?5an?5empty?5set?$AA@
  00097	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  0009e	e8 00 00 00 00	 call	 PyErr_SetString

; 712  :         return NULL;

  000a3	33 c0		 xor	 eax, eax
  000a5	e9 13 01 00 00	 jmp	 $LN10@set_pop
$LN9@set_pop:

; 713  :     }
; 714  : 
; 715  :     /* Set entry to "the first" unused or dummy set entry.  We abuse
; 716  :      * the hash field of slot 0 to hold a search finger:
; 717  :      * If slot 0 has a value, use slot 0.
; 718  :      * Else slot 0 is being used to hold a search finger,
; 719  :      * and we use its hash value as the first index to look.
; 720  :      */
; 721  :     entry = &so->table[0];

  000aa	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000af	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000b3	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 722  :     if (entry->key == NULL || entry->key == dummy) {

  000b8	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000bd	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000c2	74 16		 je	 SHORT $LN7@set_pop
  000c4	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  000d0	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  000d4	0f 85 8b 00 00
	00		 jne	 $LN8@set_pop
$LN7@set_pop:

; 723  :         i = entry->hash;

  000da	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000df	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e2	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 724  :         /* The hash field may be a real hash value, or it may be a
; 725  :          * legit search finger, or it may be a once-legit search
; 726  :          * finger that's out of bounds now because it wrapped around
; 727  :          * or the table shrunk -- simply make sure it's in bounds now.
; 728  :          */
; 729  :         if (i > so->mask || i < 1)

  000e7	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000ec	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000f0	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000f5	7f 08		 jg	 SHORT $LN5@set_pop
  000f7	48 83 7c 24 20
	01		 cmp	 QWORD PTR i$[rsp], 1
  000fd	7d 09		 jge	 SHORT $LN6@set_pop
$LN5@set_pop:

; 730  :             i = 1;              /* skip slot 0 */

  000ff	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR i$[rsp], 1
$LN6@set_pop:
$LN4@set_pop:

; 731  :         while ((entry = &so->table[i])->key == NULL || entry->key==dummy) {

  00108	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0010d	48 6b c0 10	 imul	 rax, 16
  00111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00116	48 03 41 78	 add	 rax, QWORD PTR [rcx+120]
  0011a	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax
  0011f	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00124	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00129	74 12		 je	 SHORT $LN2@set_pop
  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00130	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  00137	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  0013b	75 28		 jne	 SHORT $LN3@set_pop
$LN2@set_pop:

; 732  :             i++;

  0013d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00142	48 ff c0	 inc	 rax
  00145	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 733  :             if (i > so->mask)

  0014a	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0014f	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00153	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00158	7e 09		 jle	 SHORT $LN1@set_pop

; 734  :                 i = 1;

  0015a	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR i$[rsp], 1
$LN1@set_pop:

; 735  :         }

  00163	eb a3		 jmp	 SHORT $LN4@set_pop
$LN3@set_pop:
$LN8@set_pop:

; 736  :     }
; 737  :     key = entry->key;

  00165	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0016a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0016e	48 89 44 24 28	 mov	 QWORD PTR key$[rsp], rax

; 738  :     Py_INCREF(dummy);

  00173	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0017a	e8 00 00 00 00	 call	 _Py_IncRef

; 739  :     entry->key = dummy;

  0017f	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00184	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0018b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 740  :     so->used--;

  0018f	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00194	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00198	48 ff c8	 dec	 rax
  0019b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  001a0	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 741  :     so->table[0].hash = i + 1;  /* next place to start */

  001a4	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  001a9	48 ff c0	 inc	 rax
  001ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  001b1	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  001b5	48 89 01	 mov	 QWORD PTR [rcx], rax

; 742  :     return key;

  001b8	48 8b 44 24 28	 mov	 rax, QWORD PTR key$[rsp]
$LN10@set_pop:

; 743  : }

  001bd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c1	c3		 ret	 0
set_pop	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CMPJDKOD@set_traverse?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\objects\setobject.c
pdata	SEGMENT
$pdata$set_traverse DD imagerel set_traverse
	DD	imagerel set_traverse+151
	DD	imagerel $unwind$set_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_traverse DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0N@CMPJDKOD@set_traverse?$AA@
CONST	SEGMENT
??_C@_0N@CMPJDKOD@set_traverse?$AA@ DB 'set_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_traverse
_TEXT	SEGMENT
entry$ = 32
pos$ = 40
vret$20968 = 48
so$ = 80
visit$ = 88
arg$ = 96
set_traverse PROC					; COMDAT

; 750  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 751  :     Py_ssize_t pos = 0;

  00013	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0
$LN8@set_traver:

; 752  :     setentry *entry;
; 753  : 
; 754  :     while (set_next(so, &pos, &entry))

  0001c	4c 8d 44 24 20	 lea	 r8, QWORD PTR entry$[rsp]
  00021	48 8d 54 24 28	 lea	 rdx, QWORD PTR pos$[rsp]
  00026	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  0002b	e8 00 00 00 00	 call	 set_next
  00030	85 c0		 test	 eax, eax
  00032	74 5c		 je	 SHORT $LN7@set_traver
$LN6@set_traver:

; 755  :         Py_VISIT(entry->key);

  00034	e8 00 00 00 00	 call	 _Py_PXCTX
  00039	85 c0		 test	 eax, eax
  0003b	74 1c		 je	 SHORT $LN3@set_traver
  0003d	45 33 c9	 xor	 r9d, r9d
  00040	41 b8 f3 02 00
	00		 mov	 r8d, 755		; 000002f3H
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@CMPJDKOD@set_traverse?$AA@
  00054	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@set_traver:
  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0005e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00063	74 23		 je	 SHORT $LN2@set_traver
  00065	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0006f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00073	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  00077	89 44 24 30	 mov	 DWORD PTR vret$20968[rsp], eax
  0007b	83 7c 24 30 00	 cmp	 DWORD PTR vret$20968[rsp], 0
  00080	74 06		 je	 SHORT $LN1@set_traver
  00082	8b 44 24 30	 mov	 eax, DWORD PTR vret$20968[rsp]
  00086	eb 0a		 jmp	 SHORT $LN9@set_traver
$LN1@set_traver:
$LN2@set_traver:
  00088	33 c0		 xor	 eax, eax
  0008a	85 c0		 test	 eax, eax
  0008c	75 a6		 jne	 SHORT $LN6@set_traver
  0008e	eb 8c		 jmp	 SHORT $LN8@set_traver
$LN7@set_traver:

; 756  :     return 0;

  00090	33 c0		 xor	 eax, eax
$LN9@set_traver:

; 757  : }

  00092	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00096	c3		 ret	 0
set_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@CPDNOCPM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@ILILCEBJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_next DD imagerel set_next
	DD	imagerel set_next+407
	DD	imagerel $unwind$set_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_next DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_1CK@CPDNOCPM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@CPDNOCPM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '[', 00H, 'i', 00H
	DB	']', 00H, '.', 00H, 'k', 00H, 'e', 00H, 'y', 00H, ' ', 00H, '!'
	DB	00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@ILILCEBJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1O@ILILCEBJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'i', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_next
_TEXT	SEGMENT
i$ = 32
mask$ = 40
table$ = 48
so$ = 80
pos_ptr$ = 88
entry_ptr$ = 96
set_next PROC						; COMDAT

; 533  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 534  :     Py_ssize_t i;
; 535  :     Py_ssize_t mask;
; 536  :     register setentry *table;
; 537  : 
; 538  :     assert (PyAnySet_Check(so));

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  0001f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00023	74 60		 je	 SHORT $LN7@set_next
  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00031	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00035	74 4e		 je	 SHORT $LN7@set_next
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0003e	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00043	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00047	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004c	85 c0		 test	 eax, eax
  0004e	75 35		 jne	 SHORT $LN7@set_next
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00057	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0005c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00060	e8 00 00 00 00	 call	 PyType_IsSubtype
  00065	85 c0		 test	 eax, eax
  00067	75 1c		 jne	 SHORT $LN7@set_next
  00069	41 b8 1a 02 00
	00		 mov	 r8d, 538		; 0000021aH
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@MEACPONF@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAo?$AA?$CJ?$AA?$AA@
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00083	33 c0		 xor	 eax, eax
$LN7@set_next:

; 539  :     i = *pos_ptr;

  00085	48 8b 44 24 58	 mov	 rax, QWORD PTR pos_ptr$[rsp]
  0008a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008d	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 540  :     assert(i >= 0);

  00092	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  00098	7d 1c		 jge	 SHORT $LN8@set_next
  0009a	41 b8 1c 02 00
	00		 mov	 r8d, 540		; 0000021cH
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@ILILCEBJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b4	33 c0		 xor	 eax, eax
$LN8@set_next:

; 541  :     table = so->table;

  000b6	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000bb	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000bf	48 89 44 24 30	 mov	 QWORD PTR table$[rsp], rax

; 542  :     mask = so->mask;

  000c4	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000c9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000cd	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax
$LN4@set_next:

; 543  :     while (i <= mask && (table[i].key == NULL || table[i].key == dummy))

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$[rsp]
  000d7	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000dc	7f 41		 jg	 SHORT $LN3@set_next
  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000e3	48 6b c0 10	 imul	 rax, 16
  000e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR table$[rsp]
  000ec	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  000f2	74 1c		 je	 SHORT $LN2@set_next
  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000f9	48 6b c0 10	 imul	 rax, 16
  000fd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR table$[rsp]
  00102	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR dummy
  00109	48 39 54 01 08	 cmp	 QWORD PTR [rcx+rax+8], rdx
  0010e	75 0f		 jne	 SHORT $LN3@set_next
$LN2@set_next:

; 544  :         i++;

  00110	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00115	48 ff c0	 inc	 rax
  00118	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  0011d	eb b3		 jmp	 SHORT $LN4@set_next
$LN3@set_next:

; 545  :     *pos_ptr = i+1;

  0011f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00124	48 ff c0	 inc	 rax
  00127	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pos_ptr$[rsp]
  0012c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 546  :     if (i > mask)

  0012f	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$[rsp]
  00134	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00139	7e 04		 jle	 SHORT $LN1@set_next

; 547  :         return 0;

  0013b	33 c0		 xor	 eax, eax
  0013d	eb 53		 jmp	 SHORT $LN5@set_next
$LN1@set_next:

; 548  :     assert(table[i].key != NULL);

  0013f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00144	48 6b c0 10	 imul	 rax, 16
  00148	48 8b 4c 24 30	 mov	 rcx, QWORD PTR table$[rsp]
  0014d	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00153	75 1c		 jne	 SHORT $LN9@set_next
  00155	41 b8 24 02 00
	00		 mov	 r8d, 548		; 00000224H
  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@CPDNOCPM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0016f	33 c0		 xor	 eax, eax
$LN9@set_next:

; 549  :     *entry_ptr = &table[i];

  00171	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00176	48 6b c0 10	 imul	 rax, 16
  0017a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR table$[rsp]
  0017f	48 03 c8	 add	 rcx, rax
  00182	48 8b c1	 mov	 rax, rcx
  00185	48 8b 4c 24 60	 mov	 rcx, QWORD PTR entry_ptr$[rsp]
  0018a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 550  :     return 1;

  0018d	b8 01 00 00 00	 mov	 eax, 1
$LN5@set_next:

; 551  : }

  00192	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00196	c3		 ret	 0
set_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$frozenset_hash DD imagerel frozenset_hash
	DD	imagerel frozenset_hash+255
	DD	imagerel $unwind$frozenset_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$frozenset_hash DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT frozenset_hash
_TEXT	SEGMENT
h$ = 32
entry$ = 40
hash$ = 48
pos$ = 56
so$ = 64
self$ = 96
frozenset_hash PROC					; COMDAT

; 761  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 762  :     PySetObject *so = (PySetObject *)self;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 89 44 24 40	 mov	 QWORD PTR so$[rsp], rax

; 763  :     Py_uhash_t h, hash = 1927868237UL;

  00013	48 c7 44 24 30
	4d ef e8 72	 mov	 QWORD PTR hash$[rsp], 1927868237 ; 72e8ef4dH

; 764  :     setentry *entry;
; 765  :     Py_ssize_t pos = 0;

  0001c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0

; 766  : 
; 767  :     if (so->hash != -1)

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  0002a	48 83 b8 08 01
	00 00 ff	 cmp	 QWORD PTR [rax+264], -1
  00032	74 11		 je	 SHORT $LN4@frozenset_

; 768  :         return so->hash;

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00039	48 8b 80 08 01
	00 00		 mov	 rax, QWORD PTR [rax+264]
  00040	e9 b5 00 00 00	 jmp	 $LN5@frozenset_
$LN4@frozenset_:

; 769  : 
; 770  :     hash *= (Py_uhash_t)PySet_GET_SIZE(self) + 1;

  00045	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004e	48 ff c0	 inc	 rax
  00051	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hash$[rsp]
  00056	48 0f af c8	 imul	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	48 89 44 24 30	 mov	 QWORD PTR hash$[rsp], rax
$LN3@frozenset_:

; 771  :     while (set_next(so, &pos, &entry)) {

  00062	4c 8d 44 24 28	 lea	 r8, QWORD PTR entry$[rsp]
  00067	48 8d 54 24 38	 lea	 rdx, QWORD PTR pos$[rsp]
  0006c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00071	e8 00 00 00 00	 call	 set_next
  00076	85 c0		 test	 eax, eax
  00078	74 42		 je	 SHORT $LN2@frozenset_

; 772  :         /* Work to increase the bit dispersion for closely spaced hash
; 773  :            values.  The is important because some use cases have many
; 774  :            combinations of a small number of elements with nearby
; 775  :            hashes so that many distinct combinations collapse to only
; 776  :            a handful of distinct hash values. */
; 777  :         h = entry->hash;

  0007a	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  0007f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00082	48 89 44 24 20	 mov	 QWORD PTR h$[rsp], rax

; 778  :         hash ^= (h ^ (h << 16) ^ 89869747UL)  * 3644798167UL;

  00087	48 8b 44 24 20	 mov	 rax, QWORD PTR h$[rsp]
  0008c	48 c1 e0 10	 shl	 rax, 16
  00090	48 8b 4c 24 20	 mov	 rcx, QWORD PTR h$[rsp]
  00095	48 33 c8	 xor	 rcx, rax
  00098	48 8b c1	 mov	 rax, rcx
  0009b	48 35 b3 4d 5b
	05		 xor	 rax, 89869747		; 055b4db3H
  000a1	b9 d7 34 3f d9	 mov	 ecx, -650169129		; d93f34d7H
  000a6	48 0f af c1	 imul	 rax, rcx
  000aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hash$[rsp]
  000af	48 33 c8	 xor	 rcx, rax
  000b2	48 8b c1	 mov	 rax, rcx
  000b5	48 89 44 24 30	 mov	 QWORD PTR hash$[rsp], rax

; 779  :     }

  000ba	eb a6		 jmp	 SHORT $LN3@frozenset_
$LN2@frozenset_:

; 780  :     hash = hash * 69069U + 907133923UL;

  000bc	48 8b 44 24 30	 mov	 rax, QWORD PTR hash$[rsp]
  000c1	48 69 c0 cd 0d
	01 00		 imul	 rax, 69069		; 00010dcdH
  000c8	48 05 e3 c3 11
	36		 add	 rax, 907133923		; 3611c3e3H
  000ce	48 89 44 24 30	 mov	 QWORD PTR hash$[rsp], rax

; 781  :     if (hash == -1)

  000d3	48 83 7c 24 30
	ff		 cmp	 QWORD PTR hash$[rsp], -1
  000d9	75 09		 jne	 SHORT $LN1@frozenset_

; 782  :         hash = 590923713UL;

  000db	48 c7 44 24 30
	c1 c7 38 23	 mov	 QWORD PTR hash$[rsp], 590923713 ; 2338c7c1H
$LN1@frozenset_:

; 783  :     so->hash = hash;

  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hash$[rsp]
  000ee	48 89 88 08 01
	00 00		 mov	 QWORD PTR [rax+264], rcx

; 784  :     return hash;

  000f5	48 8b 44 24 30	 mov	 rax, QWORD PTR hash$[rsp]
$LN5@frozenset_:

; 785  : }

  000fa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fe	c3		 ret	 0
frozenset_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setiter_dealloc DD imagerel setiter_dealloc
	DD	imagerel setiter_dealloc+56
	DD	imagerel $unwind$setiter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setiter_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT setiter_dealloc
_TEXT	SEGMENT
si$ = 48
setiter_dealloc PROC					; COMDAT

; 799  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@setiter_de:

; 800  :     Py_XDECREF(si->si_set);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR si$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 0e		 je	 SHORT $LN1@setiter_de
  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR si$[rsp]
  0001a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0001e	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@setiter_de:
  00023	33 c0		 xor	 eax, eax
  00025	85 c0		 test	 eax, eax
  00027	75 e0		 jne	 SHORT $LN4@setiter_de

; 801  :     PyObject_GC_Del(si);

  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR si$[rsp]
  0002e	e8 00 00 00 00	 call	 PyObject_GC_Del

; 802  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
setiter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@KFDJELAH@setiter_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$setiter_traverse DD imagerel setiter_traverse
	DD	imagerel setiter_traverse+116
	DD	imagerel $unwind$setiter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setiter_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BB@KFDJELAH@setiter_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@KFDJELAH@setiter_traverse?$AA@ DB 'setiter_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT setiter_traverse
_TEXT	SEGMENT
vret$21018 = 32
si$ = 64
visit$ = 72
arg$ = 80
setiter_traverse PROC					; COMDAT

; 806  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@setiter_tr:

; 807  :     Py_VISIT(si->si_set);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@setiter_tr
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 27 03 00
	00		 mov	 r8d, 807		; 00000327H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KFDJELAH@setiter_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@setiter_tr:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR si$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN2@setiter_tr
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR si$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$21018[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$21018[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@setiter_tr
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$21018[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@setiter_tr
$LN1@setiter_tr:
$LN2@setiter_tr:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@setiter_tr

; 808  :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@setiter_tr:

; 809  : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
setiter_traverse ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$setiter_len DD imagerel setiter_len
	DD	imagerel setiter_len+83
	DD	imagerel $unwind$setiter_len
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setiter_len DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT setiter_len
_TEXT	SEGMENT
len$ = 32
si$ = 64
setiter_len PROC					; COMDAT

; 813  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 814  :     Py_ssize_t len = 0;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0

; 815  :     if (si->si_set != NULL && si->si_used == si->si_set->used)

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR si$[rsp]
  00017	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001c	74 26		 je	 SHORT $LN1@setiter_le
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR si$[rsp]
  00023	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR si$[rsp]
  0002c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00030	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  00034	75 0e		 jne	 SHORT $LN1@setiter_le

; 816  :         len = si->len;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR si$[rsp]
  0003b	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0003f	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax
$LN1@setiter_le:

; 817  :     return PyLong_FromSsize_t(len);

  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  00049	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 818  : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
setiter_len ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@		; `string'
PUBLIC	??_C@_04BKLHDIKK@iter?$AA@			; `string'
PUBLIC	$T23222
EXTRN	Py_BuildValue:PROC
EXTRN	_PyObject_GetBuiltin:PROC
EXTRN	PyList_Append:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$setiter_reduce DD imagerel setiter_reduce
	DD	imagerel setiter_reduce+368
	DD	imagerel $unwind$setiter_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setiter_reduce DD 040e01H
	DD	027010eH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@ DB 'N(N)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLHDIKK@iter?$AA@
CONST	SEGMENT
??_C@_04BKLHDIKK@iter?$AA@ DB 'iter', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT setiter_reduce
_TEXT	SEGMENT
tmp$ = 32
list$ = 160
element$21048 = 168
$T23222 = 176
si$ = 336
setiter_reduce PROC					; COMDAT

; 826  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 827  :     PyObject *list;
; 828  :     setiterobject tmp;
; 829  : 
; 830  :     list = PyList_New(0);

  0000e	33 c9		 xor	 ecx, ecx
  00010	e8 00 00 00 00	 call	 PyList_New
  00015	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR list$[rsp], rax

; 831  :     if (!list)

  0001d	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR list$[rsp], 0
  00026	75 07		 jne	 SHORT $LN19@setiter_re

; 832  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 37 01 00 00	 jmp	 $LN20@setiter_re
$LN19@setiter_re:

; 833  : 
; 834  :     /* copy the iterator state */
; 835  :     tmp = *si;

  0002f	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T23222[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	48 8b b4 24 50
	01 00 00	 mov	 rsi, QWORD PTR si$[rsp]
  00042	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00047	f3 a4		 rep movsb
  00049	48 8d 44 24 20	 lea	 rax, QWORD PTR tmp$[rsp]
  0004e	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T23222[rsp]
  00056	48 8b f8	 mov	 rdi, rax
  00059	48 8b f1	 mov	 rsi, rcx
  0005c	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00061	f3 a4		 rep movsb
$LN18@setiter_re:

; 836  :     Py_XINCREF(tmp.si_set);

  00063	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tmp$[rsp+96], 0
  0006c	74 0d		 je	 SHORT $LN15@setiter_re
  0006e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tmp$[rsp+96]
  00076	e8 00 00 00 00	 call	 _Py_IncRef
$LN15@setiter_re:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 e2		 jne	 SHORT $LN18@setiter_re
$LN14@setiter_re:

; 837  : 
; 838  :     /* iterate the temporary into a list */
; 839  :     for(;;) {
; 840  :         PyObject *element = setiter_iternext(&tmp);

  00081	48 8d 4c 24 20	 lea	 rcx, QWORD PTR tmp$[rsp]
  00086	e8 00 00 00 00	 call	 setiter_iternext
  0008b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR element$21048[rsp], rax

; 841  :         if (element) {

  00093	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR element$21048[rsp], 0
  0009c	74 64		 je	 SHORT $LN12@setiter_re

; 842  :             if (PyList_Append(list, element)) {

  0009e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR element$21048[rsp]
  000a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  000ae	e8 00 00 00 00	 call	 PyList_Append
  000b3	85 c0		 test	 eax, eax
  000b5	74 3c		 je	 SHORT $LN11@setiter_re

; 843  :                 Py_DECREF(element);

  000b7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR element$21048[rsp]
  000bf	e8 00 00 00 00	 call	 _Py_DecRef

; 844  :                 Py_DECREF(list);

  000c4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  000cc	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@setiter_re:

; 845  :                 Py_XDECREF(tmp.si_set);

  000d1	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tmp$[rsp+96], 0
  000da	74 0d		 je	 SHORT $LN7@setiter_re
  000dc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tmp$[rsp+96]
  000e4	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@setiter_re:
  000e9	33 c0		 xor	 eax, eax
  000eb	85 c0		 test	 eax, eax
  000ed	75 e2		 jne	 SHORT $LN10@setiter_re

; 846  :                 return NULL;

  000ef	33 c0		 xor	 eax, eax
  000f1	eb 73		 jmp	 SHORT $LN20@setiter_re
$LN11@setiter_re:

; 847  :             }
; 848  :             Py_DECREF(element);

  000f3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR element$21048[rsp]
  000fb	e8 00 00 00 00	 call	 _Py_DecRef

; 849  :         } else

  00100	eb 02		 jmp	 SHORT $LN6@setiter_re
$LN12@setiter_re:

; 850  :             break;

  00102	eb 05		 jmp	 SHORT $LN13@setiter_re
$LN6@setiter_re:

; 851  :     }

  00104	e9 78 ff ff ff	 jmp	 $LN14@setiter_re
$LN13@setiter_re:
$LN5@setiter_re:

; 852  :     Py_XDECREF(tmp.si_set);

  00109	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tmp$[rsp+96], 0
  00112	74 0d		 je	 SHORT $LN2@setiter_re
  00114	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tmp$[rsp+96]
  0011c	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@setiter_re:
  00121	33 c0		 xor	 eax, eax
  00123	85 c0		 test	 eax, eax
  00125	75 e2		 jne	 SHORT $LN5@setiter_re

; 853  :     /* check for error */
; 854  :     if (tmp.si_set != NULL) {

  00127	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tmp$[rsp+96], 0
  00130	74 11		 je	 SHORT $LN1@setiter_re

; 855  :         /* we have an error */
; 856  :         Py_DECREF(list);

  00132	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  0013a	e8 00 00 00 00	 call	 _Py_DecRef

; 857  :         return NULL;

  0013f	33 c0		 xor	 eax, eax
  00141	eb 23		 jmp	 SHORT $LN20@setiter_re
$LN1@setiter_re:

; 858  :     }
; 859  :     return Py_BuildValue("N(N)", _PyObject_GetBuiltin("iter"), list);

  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  0014a	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  0014f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR list$[rsp]
  00157	48 8b d0	 mov	 rdx, rax
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
  00161	e8 00 00 00 00	 call	 Py_BuildValue
$LN20@setiter_re:

; 860  : }

  00166	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  0016d	5f		 pop	 rdi
  0016e	5e		 pop	 rsi
  0016f	c3		 ret	 0
setiter_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_19OJAPBFKO@?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CC@CCFGNEIP@Set?5changed?5size?5during?5iteratio@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$setiter_iternext DD imagerel setiter_iternext
	DD	imagerel setiter_iternext+489
	DD	imagerel $unwind$setiter_iternext
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setiter_iternext DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_19OJAPBFKO@?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_19OJAPBFKO@?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ DB 'i', 00H, '>', 00H
	DB	'=', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CCFGNEIP@Set?5changed?5size?5during?5iteratio@
CONST	SEGMENT
??_C@_0CC@CCFGNEIP@Set?5changed?5size?5during?5iteratio@ DB 'Set changed '
	DB	'size during iteration', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT setiter_iternext
_TEXT	SEGMENT
i$ = 32
mask$ = 40
key$ = 48
entry$ = 56
so$ = 64
si$ = 96
setiter_iternext PROC					; COMDAT

; 871  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 872  :     PyObject *key;
; 873  :     register Py_ssize_t i, mask;
; 874  :     register setentry *entry;
; 875  :     PySetObject *so = si->si_set;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR si$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 89 44 24 40	 mov	 QWORD PTR so$[rsp], rax

; 876  : 
; 877  :     if (so == NULL)

  00017	48 83 7c 24 40
	00		 cmp	 QWORD PTR so$[rsp], 0
  0001d	75 07		 jne	 SHORT $LN6@setiter_it

; 878  :         return NULL;

  0001f	33 c0		 xor	 eax, eax
  00021	e9 be 01 00 00	 jmp	 $LN7@setiter_it
$LN6@setiter_it:

; 879  :     assert (PyAnySet_Check(so));

  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00032	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00036	74 60		 je	 SHORT $LN9@setiter_it
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00044	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00048	74 4e		 je	 SHORT $LN9@setiter_it
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00056	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0005f	85 c0		 test	 eax, eax
  00061	75 35		 jne	 SHORT $LN9@setiter_it
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  0006f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00073	e8 00 00 00 00	 call	 PyType_IsSubtype
  00078	85 c0		 test	 eax, eax
  0007a	75 1c		 jne	 SHORT $LN9@setiter_it
  0007c	41 b8 6f 03 00
	00		 mov	 r8d, 879		; 0000036fH
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@MEACPONF@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAo?$AA?$CJ?$AA?$AA@
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00096	33 c0		 xor	 eax, eax
$LN9@setiter_it:

; 880  : 
; 881  :     if (si->si_used != so->used) {

  00098	48 8b 44 24 60	 mov	 rax, QWORD PTR si$[rsp]
  0009d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  000a2	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000a6	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  000aa	74 27		 je	 SHORT $LN5@setiter_it

; 882  :         PyErr_SetString(PyExc_RuntimeError,
; 883  :                         "Set changed size during iteration");

  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@CCFGNEIP@Set?5changed?5size?5during?5iteratio@
  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  000ba	e8 00 00 00 00	 call	 PyErr_SetString

; 884  :         si->si_used = -1; /* Make this state sticky */

  000bf	48 8b 44 24 60	 mov	 rax, QWORD PTR si$[rsp]
  000c4	48 c7 40 68 ff
	ff ff ff	 mov	 QWORD PTR [rax+104], -1

; 885  :         return NULL;

  000cc	33 c0		 xor	 eax, eax
  000ce	e9 11 01 00 00	 jmp	 $LN7@setiter_it
$LN5@setiter_it:

; 886  :     }
; 887  : 
; 888  :     i = si->si_pos;

  000d3	48 8b 44 24 60	 mov	 rax, QWORD PTR si$[rsp]
  000d8	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000dc	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 889  :     assert(i>=0);

  000e1	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  000e7	7d 1c		 jge	 SHORT $LN10@setiter_it
  000e9	41 b8 79 03 00
	00		 mov	 r8d, 889		; 00000379H
  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_19OJAPBFKO@?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00103	33 c0		 xor	 eax, eax
$LN10@setiter_it:

; 890  :     entry = so->table;

  00105	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  0010a	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0010e	48 89 44 24 38	 mov	 QWORD PTR entry$[rsp], rax

; 891  :     mask = so->mask;

  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00118	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0011c	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax
$LN4@setiter_it:

; 892  :     while (i <= mask && (entry[i].key == NULL || entry[i].key == dummy))

  00121	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$[rsp]
  00126	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0012b	7f 41		 jg	 SHORT $LN3@setiter_it
  0012d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00132	48 6b c0 10	 imul	 rax, 16
  00136	48 8b 4c 24 38	 mov	 rcx, QWORD PTR entry$[rsp]
  0013b	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00141	74 1c		 je	 SHORT $LN2@setiter_it
  00143	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00148	48 6b c0 10	 imul	 rax, 16
  0014c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR entry$[rsp]
  00151	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR dummy
  00158	48 39 54 01 08	 cmp	 QWORD PTR [rcx+rax+8], rdx
  0015d	75 0f		 jne	 SHORT $LN3@setiter_it
$LN2@setiter_it:

; 893  :         i++;

  0015f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00164	48 ff c0	 inc	 rax
  00167	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  0016c	eb b3		 jmp	 SHORT $LN4@setiter_it
$LN3@setiter_it:

; 894  :     si->si_pos = i+1;

  0016e	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00173	48 ff c0	 inc	 rax
  00176	48 8b 4c 24 60	 mov	 rcx, QWORD PTR si$[rsp]
  0017b	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 895  :     if (i > mask)

  0017f	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$[rsp]
  00184	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00189	7e 02		 jle	 SHORT $LN1@setiter_it

; 896  :         goto fail;

  0018b	eb 3e		 jmp	 SHORT $fail$21107
$LN1@setiter_it:

; 897  :     si->len--;

  0018d	48 8b 44 24 60	 mov	 rax, QWORD PTR si$[rsp]
  00192	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00196	48 ff c8	 dec	 rax
  00199	48 8b 4c 24 60	 mov	 rcx, QWORD PTR si$[rsp]
  0019e	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 898  :     key = entry[i].key;

  001a2	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  001a7	48 6b c0 10	 imul	 rax, 16
  001ab	48 8b 4c 24 38	 mov	 rcx, QWORD PTR entry$[rsp]
  001b0	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  001b5	48 89 44 24 30	 mov	 QWORD PTR key$[rsp], rax

; 899  :     Py_INCREF(key);

  001ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR key$[rsp]
  001bf	e8 00 00 00 00	 call	 _Py_IncRef

; 900  :     return key;

  001c4	48 8b 44 24 30	 mov	 rax, QWORD PTR key$[rsp]
  001c9	eb 19		 jmp	 SHORT $LN7@setiter_it
$fail$21107:

; 901  : 
; 902  : fail:
; 903  :     Py_DECREF(so);

  001cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  001d0	e8 00 00 00 00	 call	 _Py_DecRef

; 904  :     si->si_set = NULL;

  001d5	48 8b 44 24 60	 mov	 rax, QWORD PTR si$[rsp]
  001da	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 905  :     return NULL;

  001e2	33 c0		 xor	 eax, eax
$LN7@setiter_it:

; 906  : }

  001e4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e8	c3		 ret	 0
setiter_iternext ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_08IOEGMEMM@set_iter?$AA@			; `string'
EXTRN	_PyGC_generation0:QWORD
EXTRN	Py_FatalError:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_iter DD imagerel set_iter
	DD	imagerel set_iter+400
	DD	imagerel $unwind$set_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_iter DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOEGMEMM@set_iter?$AA@
CONST	SEGMENT
??_C@_08IOEGMEMM@set_iter?$AA@ DB 'set_iter', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_iter
_TEXT	SEGMENT
si$ = 48
g$21145 = 56
tv70 = 64
tv94 = 72
so$ = 96
set_iter PROC						; COMDAT

; 943  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 944  :     setiterobject *si = PyObject_GC_New(setiterobject, &PySetIter_Type);

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 13		 je	 SHORT $LN9@set_iter
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySetIter_Type
  00019	e8 00 00 00 00	 call	 _PxObject_New
  0001e	48 89 44 24 40	 mov	 QWORD PTR tv70[rsp], rax
  00023	eb 11		 jmp	 SHORT $LN10@set_iter
$LN9@set_iter:
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySetIter_Type
  0002c	e8 00 00 00 00	 call	 _PyObject_GC_New
  00031	48 89 44 24 40	 mov	 QWORD PTR tv70[rsp], rax
$LN10@set_iter:
  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR tv70[rsp]
  0003b	48 89 44 24 30	 mov	 QWORD PTR si$[rsp], rax

; 945  :     if (si == NULL)

  00040	48 83 7c 24 30
	00		 cmp	 QWORD PTR si$[rsp], 0
  00046	75 07		 jne	 SHORT $LN6@set_iter

; 946  :         return NULL;

  00048	33 c0		 xor	 eax, eax
  0004a	e9 3c 01 00 00	 jmp	 $LN7@set_iter
$LN6@set_iter:

; 947  :     Py_INCREF(so);

  0004f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00054	e8 00 00 00 00	 call	 _Py_IncRef

; 948  :     si->si_set = so;

  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR si$[rsp]
  0005e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00063	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 949  :     si->si_used = so->used;

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR si$[rsp]
  0006c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00071	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00075	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 950  :     si->si_pos = 0;

  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR si$[rsp]
  0007e	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 951  :     si->len = so->used;

  00086	48 8b 44 24 30	 mov	 rax, QWORD PTR si$[rsp]
  0008b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00090	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00094	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 952  :     _PyObject_GC_TRACK(si);

  00098	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a0	4c 8b 4c 24 30	 mov	 r9, QWORD PTR si$[rsp]
  000a5	41 b8 b8 03 00
	00		 mov	 r8d, 952		; 000003b8H
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08IOEGMEMM@set_iter?$AA@
  000b9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000be	85 c0		 test	 eax, eax
  000c0	0f 85 c0 00 00
	00		 jne	 $LN5@set_iter
$LN4@set_iter:
  000c6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ce	4c 8b 4c 24 30	 mov	 r9, QWORD PTR si$[rsp]
  000d3	41 b8 b8 03 00
	00		 mov	 r8d, 952		; 000003b8H
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08IOEGMEMM@set_iter?$AA@
  000e7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ec	85 c0		 test	 eax, eax
  000ee	74 0b		 je	 SHORT $LN11@set_iter
  000f0	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv94[rsp], 0
  000f9	eb 0e		 jmp	 SHORT $LN12@set_iter
$LN11@set_iter:
  000fb	48 8b 44 24 30	 mov	 rax, QWORD PTR si$[rsp]
  00100	48 83 e8 18	 sub	 rax, 24
  00104	48 89 44 24 48	 mov	 QWORD PTR tv94[rsp], rax
$LN12@set_iter:
  00109	48 8b 44 24 48	 mov	 rax, QWORD PTR tv94[rsp]
  0010e	48 89 44 24 38	 mov	 QWORD PTR g$21145[rsp], rax
  00113	48 8b 44 24 38	 mov	 rax, QWORD PTR g$21145[rsp]
  00118	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  0011d	74 0c		 je	 SHORT $LN1@set_iter
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  00126	e8 00 00 00 00	 call	 Py_FatalError
$LN1@set_iter:
  0012b	48 8b 44 24 38	 mov	 rax, QWORD PTR g$21145[rsp]
  00130	48 c7 40 10 fd
	ff ff ff	 mov	 QWORD PTR [rax+16], -3
  00138	48 8b 44 24 38	 mov	 rax, QWORD PTR g$21145[rsp]
  0013d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  00144	48 89 08	 mov	 QWORD PTR [rax], rcx
  00147	48 8b 44 24 38	 mov	 rax, QWORD PTR g$21145[rsp]
  0014c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  00153	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00157	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0015b	48 8b 44 24 38	 mov	 rax, QWORD PTR g$21145[rsp]
  00160	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00164	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$21145[rsp]
  00169	48 89 08	 mov	 QWORD PTR [rax], rcx
  0016c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00173	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$21145[rsp]
  00178	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0017c	33 c0		 xor	 eax, eax
  0017e	85 c0		 test	 eax, eax
  00180	0f 85 40 ff ff
	ff		 jne	 $LN4@set_iter
$LN5@set_iter:

; 953  :     return (PyObject *)si;

  00186	48 8b 44 24 30	 mov	 rax, QWORD PTR si$[rsp]
$LN7@set_iter:

; 954  : }

  0018b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018f	c3		 ret	 0
set_iter ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_update DD imagerel set_update
	DD	imagerel set_update+124
	DD	imagerel $unwind$set_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_update DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_update
_TEXT	SEGMENT
i$ = 32
other$21204 = 40
so$ = 64
args$ = 72
set_update PROC						; COMDAT

; 1011 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1012 :     Py_ssize_t i;
; 1013 : 
; 1014 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	eb 0d		 jmp	 SHORT $LN4@set_update
$LN3@set_update:
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0001e	48 ff c0	 inc	 rax
  00021	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@set_update:
  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR args$[rsp]
  0002b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002f	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00034	7d 2e		 jge	 SHORT $LN2@set_update

; 1015 :         PyObject *other = PyTuple_GET_ITEM(args, i);

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR args$[rsp]
  0003b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00040	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00045	48 89 44 24 28	 mov	 QWORD PTR other$21204[rsp], rax

; 1016 :         if (set_update_internal(so, other) == -1)

  0004a	48 8b 54 24 28	 mov	 rdx, QWORD PTR other$21204[rsp]
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00054	e8 00 00 00 00	 call	 set_update_internal
  00059	83 f8 ff	 cmp	 eax, -1
  0005c	75 04		 jne	 SHORT $LN1@set_update

; 1017 :             return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	eb 15		 jmp	 SHORT $LN5@set_update
$LN1@set_update:

; 1018 :     }

  00062	eb b5		 jmp	 SHORT $LN3@set_update
$LN2@set_update:

; 1019 :     Py_RETURN_NONE;

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN5@set_update:

; 1020 : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
set_update ENDP
_TEXT	ENDS
EXTRN	PyErr_Occurred:PROC
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
EXTRN	_PyDict_Next:PROC
EXTRN	PyDict_Size:PROC
EXTRN	PyDict_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_update_internal DD imagerel set_update_internal
	DD	imagerel set_update_internal+578
	DD	imagerel $unwind$set_update_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_update_internal DD 010e01H
	DD	0e20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_update_internal
_TEXT	SEGMENT
it$ = 48
key$ = 56
value$21169 = 64
dictsize$21172 = 72
hash$21171 = 80
pos$21170 = 88
an_entry$21179 = 96
so$ = 128
other$ = 136
set_update_internal PROC				; COMDAT

; 958  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 959  :     PyObject *key, *it;
; 960  : 
; 961  :     if (PyAnySet_Check(other))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  0001d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00021	74 4d		 je	 SHORT $LN14@set_update@2
  00023	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0002a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  00032	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00036	74 38		 je	 SHORT $LN14@set_update@2
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0003f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  00047	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00050	85 c0		 test	 eax, eax
  00052	75 1c		 jne	 SHORT $LN14@set_update@2
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0005b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  00063	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00067	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006c	85 c0		 test	 eax, eax
  0006e	74 1a		 je	 SHORT $LN15@set_update@2
$LN14@set_update@2:

; 962  :         return set_merge(so, other);

  00070	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR other$[rsp]
  00078	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00080	e8 00 00 00 00	 call	 set_merge
  00085	e9 b3 01 00 00	 jmp	 $LN16@set_update@2
$LN15@set_update@2:

; 963  : 
; 964  :     if (PyDict_CheckExact(other)) {

  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00091	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  00099	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0009d	74 19		 je	 SHORT $LN12@set_update@2
  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  000a6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  000ae	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  000b2	0f 85 f2 00 00
	00		 jne	 $LN13@set_update@2
$LN12@set_update@2:

; 965  :         PyObject *value;
; 966  :         Py_ssize_t pos = 0;

  000b8	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR pos$21170[rsp], 0

; 967  :         Py_hash_t hash;
; 968  :         Py_ssize_t dictsize = PyDict_Size(other);

  000c1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  000c9	e8 00 00 00 00	 call	 PyDict_Size
  000ce	48 89 44 24 48	 mov	 QWORD PTR dictsize$21172[rsp], rax

; 969  : 
; 970  :         /* Do one big resize at the start, rather than
; 971  :         * incrementally resizing as we insert new keys.  Expect
; 972  :         * that there will be no (or few) overlapping keys.
; 973  :         */
; 974  :         if (dictsize == -1)

  000d3	48 83 7c 24 48
	ff		 cmp	 QWORD PTR dictsize$21172[rsp], -1
  000d9	75 0a		 jne	 SHORT $LN11@set_update@2

; 975  :             return -1;

  000db	b8 ff ff ff ff	 mov	 eax, -1
  000e0	e9 58 01 00 00	 jmp	 $LN16@set_update@2
$LN11@set_update@2:

; 976  :         if ((so->fill + dictsize)*3 >= (so->mask+1)*2) {

  000e5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  000ed	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000f1	48 03 44 24 48	 add	 rax, QWORD PTR dictsize$21172[rsp]
  000f6	48 6b c0 03	 imul	 rax, 3
  000fa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00102	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00106	48 8d 4c 09 02	 lea	 rcx, QWORD PTR [rcx+rcx+2]
  0010b	48 3b c1	 cmp	 rax, rcx
  0010e	7c 32		 jl	 SHORT $LN10@set_update@2

; 977  :             if (set_table_resize(so, (so->used + dictsize)*2) != 0)

  00110	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00118	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011c	48 03 44 24 48	 add	 rax, QWORD PTR dictsize$21172[rsp]
  00121	48 d1 e0	 shl	 rax, 1
  00124	48 8b d0	 mov	 rdx, rax
  00127	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  0012f	e8 00 00 00 00	 call	 set_table_resize
  00134	85 c0		 test	 eax, eax
  00136	74 0a		 je	 SHORT $LN9@set_update@2

; 978  :                 return -1;

  00138	b8 ff ff ff ff	 mov	 eax, -1
  0013d	e9 fb 00 00 00	 jmp	 $LN16@set_update@2
$LN9@set_update@2:
$LN10@set_update@2:
$LN8@set_update@2:

; 979  :         }
; 980  :         while (_PyDict_Next(other, &pos, &key, &value, &hash)) {

  00142	48 8d 44 24 50	 lea	 rax, QWORD PTR hash$21171[rsp]
  00147	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014c	4c 8d 4c 24 40	 lea	 r9, QWORD PTR value$21169[rsp]
  00151	4c 8d 44 24 38	 lea	 r8, QWORD PTR key$[rsp]
  00156	48 8d 54 24 58	 lea	 rdx, QWORD PTR pos$21170[rsp]
  0015b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  00163	e8 00 00 00 00	 call	 _PyDict_Next
  00168	85 c0		 test	 eax, eax
  0016a	74 37		 je	 SHORT $LN7@set_update@2

; 981  :             setentry an_entry;
; 982  : 
; 983  :             an_entry.hash = hash;

  0016c	48 8b 44 24 50	 mov	 rax, QWORD PTR hash$21171[rsp]
  00171	48 89 44 24 60	 mov	 QWORD PTR an_entry$21179[rsp], rax

; 984  :             an_entry.key = key;

  00176	48 8b 44 24 38	 mov	 rax, QWORD PTR key$[rsp]
  0017b	48 89 44 24 68	 mov	 QWORD PTR an_entry$21179[rsp+8], rax

; 985  :             if (set_add_entry(so, &an_entry) == -1)

  00180	48 8d 54 24 60	 lea	 rdx, QWORD PTR an_entry$21179[rsp]
  00185	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  0018d	e8 00 00 00 00	 call	 set_add_entry
  00192	83 f8 ff	 cmp	 eax, -1
  00195	75 0a		 jne	 SHORT $LN6@set_update@2

; 986  :                 return -1;

  00197	b8 ff ff ff ff	 mov	 eax, -1
  0019c	e9 9c 00 00 00	 jmp	 $LN16@set_update@2
$LN6@set_update@2:

; 987  :         }

  001a1	eb 9f		 jmp	 SHORT $LN8@set_update@2
$LN7@set_update@2:

; 988  :         return 0;

  001a3	33 c0		 xor	 eax, eax
  001a5	e9 93 00 00 00	 jmp	 $LN16@set_update@2
$LN13@set_update@2:

; 989  :     }
; 990  : 
; 991  :     it = PyObject_GetIter(other);

  001aa	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  001b2	e8 00 00 00 00	 call	 PyObject_GetIter
  001b7	48 89 44 24 30	 mov	 QWORD PTR it$[rsp], rax

; 992  :     if (it == NULL)

  001bc	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$[rsp], 0
  001c2	75 07		 jne	 SHORT $LN5@set_update@2

; 993  :         return -1;

  001c4	b8 ff ff ff ff	 mov	 eax, -1
  001c9	eb 72		 jmp	 SHORT $LN16@set_update@2
$LN5@set_update@2:
$LN4@set_update@2:

; 994  : 
; 995  :     while ((key = PyIter_Next(it)) != NULL) {

  001cb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  001d0	e8 00 00 00 00	 call	 PyIter_Next
  001d5	48 89 44 24 38	 mov	 QWORD PTR key$[rsp], rax
  001da	48 83 7c 24 38
	00		 cmp	 QWORD PTR key$[rsp], 0
  001e0	74 3e		 je	 SHORT $LN3@set_update@2

; 996  :         if (set_add_key(so, key) == -1) {

  001e2	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  001e7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  001ef	e8 00 00 00 00	 call	 set_add_key
  001f4	83 f8 ff	 cmp	 eax, -1
  001f7	75 1b		 jne	 SHORT $LN2@set_update@2

; 997  :             Py_DECREF(it);

  001f9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  001fe	e8 00 00 00 00	 call	 _Py_DecRef

; 998  :             Py_DECREF(key);

  00203	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  00208	e8 00 00 00 00	 call	 _Py_DecRef

; 999  :             return -1;

  0020d	b8 ff ff ff ff	 mov	 eax, -1
  00212	eb 29		 jmp	 SHORT $LN16@set_update@2
$LN2@set_update@2:

; 1000 :         }
; 1001 :         Py_DECREF(key);

  00214	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  00219	e8 00 00 00 00	 call	 _Py_DecRef

; 1002 :     }

  0021e	eb ab		 jmp	 SHORT $LN4@set_update@2
$LN3@set_update@2:

; 1003 :     Py_DECREF(it);

  00220	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  00225	e8 00 00 00 00	 call	 _Py_DecRef

; 1004 :     if (PyErr_Occurred())

  0022a	e8 00 00 00 00	 call	 PyErr_Occurred
  0022f	48 85 c0	 test	 rax, rax
  00232	74 07		 je	 SHORT $LN1@set_update@2

; 1005 :         return -1;

  00234	b8 ff ff ff ff	 mov	 eax, -1
  00239	eb 02		 jmp	 SHORT $LN16@set_update@2
$LN1@set_update@2:

; 1006 :     return 0;

  0023b	33 c0		 xor	 eax, eax
$LN16@set_update@2:

; 1007 : }

  0023d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00241	c3		 ret	 0
set_update_internal ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CI@MOABPBOH@?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?9?$AA?$DO?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAu?$AAm?$AAm?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@ECLDGBIK@?$AAn?$AAe?$AAw?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAo?$AAl?$AAd?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@OHFHBLDC@?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DO?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAu?$AAs?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@CKDCLCGG@?$AAo?$AAl?$AAd?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@BHHGFLJO@?$AAm?$AAi?$AAn?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	PyErr_NoMemory:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_table_resize DD imagerel set_table_resize
	DD	imagerel set_table_resize+1083
	DD	imagerel $unwind$set_table_resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_table_resize DD 021101H
	DD	0210111H
xdata	ENDS
;	COMDAT ??_C@_1CI@MOABPBOH@?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?9?$AA?$DO?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAu?$AAm?$AAm?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@MOABPBOH@?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?9?$AA?$DO?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAu?$AAm?$AAm?$AAy?$AA?$AA@ DB 'e'
	DB	00H, 'n', 00H, 't', 00H, 'r', 00H, 'y', 00H, '-', 00H, '>', 00H
	DB	'k', 00H, 'e', 00H, 'y', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'd', 00H, 'u', 00H, 'm', 00H, 'm', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@ECLDGBIK@?$AAn?$AAe?$AAw?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAo?$AAl?$AAd?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@ECLDGBIK@?$AAn?$AAe?$AAw?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAo?$AAl?$AAd?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'o', 00H, 'l'
	DB	00H, 'd', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@OHFHBLDC@?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DO?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAu?$AAs?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@OHFHBLDC@?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DO?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAu?$AAs?$AAe?$AAd?$AA?$AA@ DB 's'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'f', 00H, 'i', 00H, 'l', 00H
	DB	'l', 00H, ' ', 00H, '>', 00H, ' ', 00H, 's', 00H, 'o', 00H, '-'
	DB	00H, '>', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@CKDCLCGG@?$AAo?$AAl?$AAd?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@CKDCLCGG@?$AAo?$AAl?$AAd?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'o'
	DB	00H, 'l', 00H, 'd', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@BHHGFLJO@?$AAm?$AAi?$AAn?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@BHHGFLJO@?$AAm?$AAi?$AAn?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'm'
	DB	00H, 'i', 00H, 'n', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_table_resize
_TEXT	SEGMENT
i$ = 32
small_copy$ = 48
newsize$ = 176
oldtable$ = 184
is_oldtable_malloced$ = 192
entry$ = 200
newtable$ = 208
tv81 = 216
tv140 = 224
tv139 = 232
tv182 = 240
so$ = 272
minused$ = 280
set_table_resize PROC					; COMDAT

; 277  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 278  :     Py_ssize_t newsize;
; 279  :     setentry *oldtable, *newtable, *entry;
; 280  :     Py_ssize_t i;
; 281  :     int is_oldtable_malloced;
; 282  :     setentry small_copy[PySet_MINSIZE];
; 283  : 
; 284  :     assert(minused >= 0);

  00011	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR minused$[rsp], 0
  0001a	7d 1c		 jge	 SHORT $LN20@set_table_
  0001c	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@BHHGFLJO@?$AAm?$AAi?$AAn?$AAu?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00036	33 c0		 xor	 eax, eax
$LN20@set_table_:

; 285  : 
; 286  :     /* Find the smallest table size > minused. */
; 287  :     for (newsize = PySet_MINSIZE;
; 288  :          newsize <= minused && newsize > 0;
; 289  :          newsize <<= 1)

  00038	48 c7 84 24 b0
	00 00 00 08 00
	00 00		 mov	 QWORD PTR newsize$[rsp], 8
  00044	eb 13		 jmp	 SHORT $LN17@set_table_
$LN16@set_table_:
  00046	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR newsize$[rsp]
  0004e	48 d1 e0	 shl	 rax, 1
  00051	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR newsize$[rsp], rax
$LN17@set_table_:
  00059	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR minused$[rsp]
  00061	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR newsize$[rsp], rax
  00069	7f 0d		 jg	 SHORT $LN15@set_table_
  0006b	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR newsize$[rsp], 0
  00074	7e 02		 jle	 SHORT $LN15@set_table_

; 290  :         ;

  00076	eb ce		 jmp	 SHORT $LN16@set_table_
$LN15@set_table_:

; 291  :     if (newsize <= 0) {

  00078	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR newsize$[rsp], 0
  00081	7f 0f		 jg	 SHORT $LN14@set_table_

; 292  :         PyErr_NoMemory();

  00083	e8 00 00 00 00	 call	 PyErr_NoMemory

; 293  :         return -1;

  00088	b8 ff ff ff ff	 mov	 eax, -1
  0008d	e9 a1 03 00 00	 jmp	 $LN18@set_table_
$LN14@set_table_:

; 294  :     }
; 295  : 
; 296  :     /* Get space for a new table. */
; 297  :     oldtable = so->table;

  00092	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR so$[rsp]
  0009a	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0009e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR oldtable$[rsp], rax

; 298  :     assert(oldtable != NULL);

  000a6	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR oldtable$[rsp], 0
  000af	75 1c		 jne	 SHORT $LN21@set_table_
  000b1	41 b8 2a 01 00
	00		 mov	 r8d, 298		; 0000012aH
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CKDCLCGG@?$AAo?$AAl?$AAd?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000cb	33 c0		 xor	 eax, eax
$LN21@set_table_:

; 299  :     is_oldtable_malloced = oldtable != so->smalltable;

  000cd	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR so$[rsp]
  000d5	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  000db	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR oldtable$[rsp], rax
  000e3	74 0d		 je	 SHORT $LN22@set_table_
  000e5	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv81[rsp], 1
  000f0	eb 0b		 jmp	 SHORT $LN23@set_table_
$LN22@set_table_:
  000f2	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv81[rsp], 0
$LN23@set_table_:
  000fd	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv81[rsp]
  00104	89 84 24 c0 00
	00 00		 mov	 DWORD PTR is_oldtable_malloced$[rsp], eax

; 300  : 
; 301  :     if (newsize == PySet_MINSIZE) {

  0010b	48 83 bc 24 b0
	00 00 00 08	 cmp	 QWORD PTR newsize$[rsp], 8
  00114	0f 85 a9 00 00
	00		 jne	 $LN13@set_table_

; 302  :         /* A large table is shrinking, or we can't get any smaller. */
; 303  :         newtable = so->smalltable;

  0011a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00122	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00128	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR newtable$[rsp], rax

; 304  :         if (newtable == oldtable) {

  00130	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR oldtable$[rsp]
  00138	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR newtable$[rsp], rax
  00140	75 7c		 jne	 SHORT $LN12@set_table_

; 305  :             if (so->fill == so->used) {

  00142	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR so$[rsp]
  0014a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00152	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00156	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0015a	75 07		 jne	 SHORT $LN11@set_table_

; 306  :                 /* No dummies, so no point doing anything. */
; 307  :                 return 0;

  0015c	33 c0		 xor	 eax, eax
  0015e	e9 d0 02 00 00	 jmp	 $LN18@set_table_
$LN11@set_table_:

; 308  :             }
; 309  :             /* We're not going to resize it, but rebuild the
; 310  :                table anyway to purge old dummy entries.
; 311  :                Subtle:  This is *necessary* if fill==size,
; 312  :                as set_lookkey needs at least one virgin slot to
; 313  :                terminate failing searches.  If fill < size, it's
; 314  :                merely desirable, as dummies slow searches. */
; 315  :             assert(so->fill > so->used);

  00163	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR so$[rsp]
  0016b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00173	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00177	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0017b	7f 1c		 jg	 SHORT $LN24@set_table_
  0017d	41 b8 3b 01 00
	00		 mov	 r8d, 315		; 0000013bH
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0018a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@OHFHBLDC@?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DO?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAu?$AAs?$AAe?$AAd?$AA?$AA@
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00197	33 c0		 xor	 eax, eax
$LN24@set_table_:

; 316  :             memcpy(small_copy, oldtable, sizeof(small_copy));

  00199	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0019f	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR oldtable$[rsp]
  001a7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR small_copy$[rsp]
  001ac	e8 00 00 00 00	 call	 memcpy

; 317  :             oldtable = small_copy;

  001b1	48 8d 44 24 30	 lea	 rax, QWORD PTR small_copy$[rsp]
  001b6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR oldtable$[rsp], rax
$LN12@set_table_:

; 318  :         }
; 319  :     }
; 320  :     else {

  001be	e9 9f 00 00 00	 jmp	 $LN10@set_table_
$LN13@set_table_:

; 321  :         newtable = PyMem_NEW(setentry, newsize);

  001c3	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH
  001cd	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR newsize$[rsp], rax
  001d5	76 0e		 jbe	 SHORT $LN27@set_table_
  001d7	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv140[rsp], 0
  001e3	eb 53		 jmp	 SHORT $LN28@set_table_
$LN27@set_table_:
  001e5	e8 00 00 00 00	 call	 _Py_PXCTX
  001ea	85 c0		 test	 eax, eax
  001ec	74 1e		 je	 SHORT $LN25@set_table_
  001ee	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR newsize$[rsp]
  001f6	48 6b c0 10	 imul	 rax, 16
  001fa	48 8b c8	 mov	 rcx, rax
  001fd	e8 00 00 00 00	 call	 _PxMem_Malloc
  00202	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
  0020a	eb 1c		 jmp	 SHORT $LN26@set_table_
$LN25@set_table_:
  0020c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR newsize$[rsp]
  00214	48 6b c0 10	 imul	 rax, 16
  00218	48 8b c8	 mov	 rcx, rax
  0021b	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00220	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
$LN26@set_table_:
  00228	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv139[rsp]
  00230	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv140[rsp], rax
$LN28@set_table_:
  00238	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv140[rsp]
  00240	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR newtable$[rsp], rax

; 322  :         if (newtable == NULL) {

  00248	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR newtable$[rsp], 0
  00251	75 0f		 jne	 SHORT $LN9@set_table_

; 323  :             PyErr_NoMemory();

  00253	e8 00 00 00 00	 call	 PyErr_NoMemory

; 324  :             return -1;

  00258	b8 ff ff ff ff	 mov	 eax, -1
  0025d	e9 d1 01 00 00	 jmp	 $LN18@set_table_
$LN9@set_table_:
$LN10@set_table_:

; 325  :         }
; 326  :     }
; 327  : 
; 328  :     /* Make the set empty, using the new table. */
; 329  :     assert(newtable != oldtable);

  00262	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR oldtable$[rsp]
  0026a	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR newtable$[rsp], rax
  00272	75 1c		 jne	 SHORT $LN29@set_table_
  00274	41 b8 49 01 00
	00		 mov	 r8d, 329		; 00000149H
  0027a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@ECLDGBIK@?$AAn?$AAe?$AAw?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAo?$AAl?$AAd?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0028e	33 c0		 xor	 eax, eax
$LN29@set_table_:

; 330  :     so->table = newtable;

  00290	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00298	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR newtable$[rsp]
  002a0	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 331  :     so->mask = newsize - 1;

  002a4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR newsize$[rsp]
  002ac	48 ff c8	 dec	 rax
  002af	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  002b7	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 332  :     memset(newtable, 0, sizeof(setentry) * newsize);

  002bb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR newsize$[rsp]
  002c3	48 6b c0 10	 imul	 rax, 16
  002c7	4c 8b c0	 mov	 r8, rax
  002ca	33 d2		 xor	 edx, edx
  002cc	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR newtable$[rsp]
  002d4	e8 00 00 00 00	 call	 memset

; 333  :     so->used = 0;

  002d9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR so$[rsp]
  002e1	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 334  :     i = so->fill;

  002e9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR so$[rsp]
  002f1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002f5	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 335  :     so->fill = 0;

  002fa	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00302	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 336  : 
; 337  :     /* Copy the data over; this is refcount-neutral for active entries;
; 338  :        dummy entries aren't copied over, of course */
; 339  :     for (entry = oldtable; i > 0; entry++) {

  0030a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR oldtable$[rsp]
  00312	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR entry$[rsp], rax
  0031a	eb 14		 jmp	 SHORT $LN8@set_table_
$LN7@set_table_:
  0031c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  00324	48 83 c0 10	 add	 rax, 16
  00328	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR entry$[rsp], rax
$LN8@set_table_:
  00330	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  00336	0f 8e b0 00 00
	00		 jle	 $LN6@set_table_

; 340  :         if (entry->key == NULL) {

  0033c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  00344	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00349	75 05		 jne	 SHORT $LN5@set_table_
  0034b	e9 97 00 00 00	 jmp	 $LN4@set_table_
$LN5@set_table_:

; 341  :             /* UNUSED */
; 342  :             ;
; 343  :         } else if (entry->key == dummy) {

  00350	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  00358	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0035f	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00363	75 51		 jne	 SHORT $LN3@set_table_

; 344  :             /* DUMMY */
; 345  :             --i;

  00365	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0036a	48 ff c8	 dec	 rax
  0036d	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 346  :             assert(entry->key == dummy);

  00372	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  0037a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  00381	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00385	74 1c		 je	 SHORT $LN30@set_table_
  00387	41 b8 5a 01 00
	00		 mov	 r8d, 346		; 0000015aH
  0038d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00394	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@MOABPBOH@?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?9?$AA?$DO?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAu?$AAm?$AAm?$AAy?$AA?$AA@
  0039b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003a1	33 c0		 xor	 eax, eax
$LN30@set_table_:

; 347  :             Py_DECREF(entry->key);

  003a3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  003ab	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  003af	e8 00 00 00 00	 call	 _Py_DecRef

; 348  :         } else {

  003b4	eb 31		 jmp	 SHORT $LN2@set_table_
$LN3@set_table_:

; 349  :             /* ACTIVE */
; 350  :             --i;

  003b6	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  003bb	48 ff c8	 dec	 rax
  003be	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 351  :             set_insert_clean(so, entry->key, entry->hash);

  003c3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  003cb	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  003ce	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR entry$[rsp]
  003d6	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  003da	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  003e2	e8 00 00 00 00	 call	 set_insert_clean
$LN2@set_table_:
$LN4@set_table_:

; 352  :         }
; 353  :     }

  003e7	e9 30 ff ff ff	 jmp	 $LN7@set_table_
$LN6@set_table_:

; 354  : 
; 355  :     if (is_oldtable_malloced)

  003ec	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR is_oldtable_malloced$[rsp], 0
  003f4	74 3b		 je	 SHORT $LN1@set_table_

; 356  :         PyMem_DEL(oldtable);

  003f6	e8 00 00 00 00	 call	 _Py_PXCTX
  003fb	85 c0		 test	 eax, eax
  003fd	74 1a		 je	 SHORT $LN31@set_table_
  003ff	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR oldtable$[rsp]
  00407	e8 00 00 00 00	 call	 _PxMem_Free
  0040c	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
  00417	eb 18		 jmp	 SHORT $LN32@set_table_
$LN31@set_table_:
  00419	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR oldtable$[rsp]
  00421	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00426	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
$LN32@set_table_:
$LN1@set_table_:

; 357  :     return 0;

  00431	33 c0		 xor	 eax, eax
$LN18@set_table_:

; 358  : }

  00433	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  0043a	c3		 ret	 0
set_table_resize ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_insert_clean DD imagerel set_insert_clean
	DD	imagerel set_insert_clean+266
	DD	imagerel $unwind$set_insert_clean
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_insert_clean DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_insert_clean
_TEXT	SEGMENT
i$ = 0
mask$ = 8
perturb$ = 16
table$ = 24
entry$ = 32
so$ = 64
key$ = 72
hash$ = 80
set_insert_clean PROC					; COMDAT

; 251  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 252  :     register size_t i;
; 253  :     register size_t perturb;
; 254  :     register size_t mask = (size_t)so->mask;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00018	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0001c	48 89 44 24 08	 mov	 QWORD PTR mask$[rsp], rax

; 255  :     setentry *table = so->table;

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00026	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0002a	48 89 44 24 18	 mov	 QWORD PTR table$[rsp], rax

; 256  :     register setentry *entry;
; 257  : 
; 258  :     i = (size_t)hash & mask;

  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR mask$[rsp]
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hash$[rsp]
  00039	48 23 c8	 and	 rcx, rax
  0003c	48 8b c1	 mov	 rax, rcx
  0003f	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax

; 259  :     entry = &table[i];

  00043	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00047	48 6b c0 10	 imul	 rax, 16
  0004b	48 8b 4c 24 18	 mov	 rcx, QWORD PTR table$[rsp]
  00050	48 03 c8	 add	 rcx, rax
  00053	48 8b c1	 mov	 rax, rcx
  00056	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 260  :     for (perturb = hash; entry->key != NULL; perturb >>= PERTURB_SHIFT) {

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR hash$[rsp]
  00060	48 89 44 24 10	 mov	 QWORD PTR perturb$[rsp], rax
  00065	eb 0e		 jmp	 SHORT $LN3@set_insert
$LN2@set_insert:
  00067	48 8b 44 24 10	 mov	 rax, QWORD PTR perturb$[rsp]
  0006c	48 c1 e8 05	 shr	 rax, 5
  00070	48 89 44 24 10	 mov	 QWORD PTR perturb$[rsp], rax
$LN3@set_insert:
  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0007a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0007f	74 3f		 je	 SHORT $LN1@set_insert

; 261  :         i = (i << 2) + i + perturb + 1;

  00081	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00085	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00089	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0008d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR perturb$[rsp]
  00092	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  00097	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax

; 262  :         entry = &table[i & mask];

  0009b	48 8b 44 24 08	 mov	 rax, QWORD PTR mask$[rsp]
  000a0	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  000a4	48 23 c8	 and	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 6b c0 10	 imul	 rax, 16
  000ae	48 8b 4c 24 18	 mov	 rcx, QWORD PTR table$[rsp]
  000b3	48 03 c8	 add	 rcx, rax
  000b6	48 8b c1	 mov	 rax, rcx
  000b9	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 263  :     }

  000be	eb a7		 jmp	 SHORT $LN2@set_insert
$LN1@set_insert:

; 264  :     so->fill++;

  000c0	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  000c5	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000c9	48 ff c0	 inc	 rax
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  000d1	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 265  :     entry->key = key;

  000d5	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  000da	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  000df	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 266  :     entry->hash = hash;

  000e3	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  000e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hash$[rsp]
  000ed	48 89 08	 mov	 QWORD PTR [rax], rcx

; 267  :     so->used++;

  000f0	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  000f5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f9	48 ff c0	 inc	 rax
  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00101	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 268  : }

  00105	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00109	c3		 ret	 0
set_insert_clean ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@BAPLGKPP@?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAm?$AAa?$AAs?$AAk?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_add_entry DD imagerel set_add_entry
	DD	imagerel set_add_entry+279
	DD	imagerel $unwind$set_add_entry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_add_entry DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1CK@BAPLGKPP@?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAm?$AAa?$AAs?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@BAPLGKPP@?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAm?$AAa?$AAs?$AAk?$AA?$AA@ DB 's'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'f', 00H, 'i', 00H, 'l', 00H
	DB	'l', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 's', 00H, 'o'
	DB	00H, '-', 00H, '>', 00H, 'm', 00H, 'a', 00H, 's', 00H, 'k', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_add_entry
_TEXT	SEGMENT
key$ = 32
n_used$ = 40
hash$ = 48
tv95 = 56
so$ = 80
entry$ = 88
set_add_entry PROC					; COMDAT

; 364  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 365  :     register Py_ssize_t n_used;
; 366  :     PyObject *key = entry->key;

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR entry$[rsp]
  00013	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00017	48 89 44 24 20	 mov	 QWORD PTR key$[rsp], rax

; 367  :     Py_hash_t hash = entry->hash;

  0001c	48 8b 44 24 58	 mov	 rax, QWORD PTR entry$[rsp]
  00021	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00024	48 89 44 24 30	 mov	 QWORD PTR hash$[rsp], rax

; 368  : 
; 369  :     assert(so->fill <= so->mask);  /* at least one empty slot */

  00029	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0002e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00033	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00037	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0003b	7e 1c		 jle	 SHORT $LN6@set_add_en
  0003d	41 b8 71 01 00
	00		 mov	 r8d, 369		; 00000171H
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@BAPLGKPP@?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAm?$AAa?$AAs?$AAk?$AA?$AA@
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00057	33 c0		 xor	 eax, eax
$LN6@set_add_en:

; 370  :     n_used = so->used;

  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0005e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00062	48 89 44 24 28	 mov	 QWORD PTR n_used$[rsp], rax

; 371  :     Py_INCREF(key);

  00067	48 8b 4c 24 20	 mov	 rcx, QWORD PTR key$[rsp]
  0006c	e8 00 00 00 00	 call	 _Py_IncRef

; 372  :     if (set_insert_key(so, key, hash) == -1) {

  00071	4c 8b 44 24 30	 mov	 r8, QWORD PTR hash$[rsp]
  00076	48 8b 54 24 20	 mov	 rdx, QWORD PTR key$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00080	e8 00 00 00 00	 call	 set_insert_key
  00085	83 f8 ff	 cmp	 eax, -1
  00088	75 11		 jne	 SHORT $LN3@set_add_en

; 373  :         Py_DECREF(key);

  0008a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR key$[rsp]
  0008f	e8 00 00 00 00	 call	 _Py_DecRef

; 374  :         return -1;

  00094	b8 ff ff ff ff	 mov	 eax, -1
  00099	eb 77		 jmp	 SHORT $LN4@set_add_en
$LN3@set_add_en:

; 375  :     }
; 376  :     if (!(so->used > n_used && so->fill*3 >= (so->mask+1)*2))

  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n_used$[rsp]
  000a5	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  000a9	7e 20		 jle	 SHORT $LN1@set_add_en
  000ab	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000b0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b4	48 6b c0 03	 imul	 rax, 3
  000b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  000bd	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000c1	48 8d 4c 09 02	 lea	 rcx, QWORD PTR [rcx+rcx+2]
  000c6	48 3b c1	 cmp	 rax, rcx
  000c9	7d 04		 jge	 SHORT $LN2@set_add_en
$LN1@set_add_en:

; 377  :         return 0;

  000cb	33 c0		 xor	 eax, eax
  000cd	eb 43		 jmp	 SHORT $LN4@set_add_en
$LN2@set_add_en:

; 378  :     return set_table_resize(so, so->used>50000 ? so->used*2 : so->used*4);

  000cf	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000d4	48 81 78 68 50
	c3 00 00	 cmp	 QWORD PTR [rax+104], 50000 ; 0000c350H
  000dc	7e 13		 jle	 SHORT $LN7@set_add_en
  000de	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000e3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e7	48 d1 e0	 shl	 rax, 1
  000ea	48 89 44 24 38	 mov	 QWORD PTR tv95[rsp], rax
  000ef	eb 12		 jmp	 SHORT $LN8@set_add_en
$LN7@set_add_en:
  000f1	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000f6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000fa	48 c1 e0 02	 shl	 rax, 2
  000fe	48 89 44 24 38	 mov	 QWORD PTR tv95[rsp], rax
$LN8@set_add_en:
  00103	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv95[rsp]
  00108	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  0010d	e8 00 00 00 00	 call	 set_table_resize
$LN4@set_add_en:

; 379  : }

  00112	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00116	c3		 ret	 0
set_add_entry ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CG@FANKKCNM@?$AAs?$AAo?$AA?9?$AA?$DO?$AAl?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_insert_key DD imagerel set_insert_key
	DD	imagerel set_insert_key+291
	DD	imagerel $unwind$set_insert_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_insert_key DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1CG@FANKKCNM@?$AAs?$AAo?$AA?9?$AA?$DO?$AAl?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@FANKKCNM@?$AAs?$AAo?$AA?9?$AA?$DO?$AAl?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'l', 00H, 'o', 00H, 'o', 00H
	DB	'k', 00H, 'u', 00H, 'p', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_insert_key
_TEXT	SEGMENT
entry$ = 32
so$ = 64
key$ = 72
hash$ = 80
set_insert_key PROC					; COMDAT

; 215  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 216  :     register setentry *entry;
; 217  : 
; 218  :     assert(so->lookup != NULL);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00018	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00020	75 1c		 jne	 SHORT $LN8@set_insert@2
  00022	41 b8 da 00 00
	00		 mov	 r8d, 218		; 000000daH
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@FANKKCNM@?$AAs?$AAo?$AA?9?$AA?$DO?$AAl?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003c	33 c0		 xor	 eax, eax
$LN8@set_insert@2:

; 219  :     entry = so->lookup(so, key, hash);

  0003e	4c 8b 44 24 50	 mov	 r8, QWORD PTR hash$[rsp]
  00043	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00052	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00058	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 220  :     if (entry == NULL)

  0005d	48 83 7c 24 20
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00063	75 0a		 jne	 SHORT $LN5@set_insert@2

; 221  :         return -1;

  00065	b8 ff ff ff ff	 mov	 eax, -1
  0006a	e9 af 00 00 00	 jmp	 $LN6@set_insert@2
$LN5@set_insert@2:

; 222  :     if (entry->key == NULL) {

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00074	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00079	75 47		 jne	 SHORT $LN4@set_insert@2

; 223  :         /* UNUSED */
; 224  :         so->fill++;

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00080	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00084	48 ff c0	 inc	 rax
  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  0008c	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 225  :         entry->key = key;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00095	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0009a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 226  :         entry->hash = hash;

  0009e	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hash$[rsp]
  000a8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 227  :         so->used++;

  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  000b0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b4	48 ff c0	 inc	 rax
  000b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  000bc	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c0	eb 5a		 jmp	 SHORT $LN3@set_insert@2
$LN4@set_insert@2:

; 228  :     } else if (entry->key == dummy) {

  000c2	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  000c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  000ce	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  000d2	75 3e		 jne	 SHORT $LN2@set_insert@2

; 229  :         /* DUMMY */
; 230  :         entry->key = key;

  000d4	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  000d9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  000de	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 231  :         entry->hash = hash;

  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  000e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hash$[rsp]
  000ec	48 89 08	 mov	 QWORD PTR [rax], rcx

; 232  :         so->used++;

  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  000f4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f8	48 ff c0	 inc	 rax
  000fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00100	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 233  :         Py_DECREF(dummy);

  00104	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0010b	e8 00 00 00 00	 call	 _Py_DecRef

; 234  :     } else {

  00110	eb 0a		 jmp	 SHORT $LN1@set_insert@2
$LN2@set_insert@2:

; 235  :         /* ACTIVE */
; 236  :         Py_DECREF(key);

  00112	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00117	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@set_insert@2:
$LN3@set_insert@2:

; 237  :     }
; 238  :     return 0;

  0011c	33 c0		 xor	 eax, eax
$LN6@set_insert@2:

; 239  : }

  0011e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00122	c3		 ret	 0
set_insert_key ENDP
_TEXT	ENDS
EXTRN	PyObject_Hash:PROC
EXTRN	PyUnicode_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_add_key DD imagerel set_add_key
	DD	imagerel set_add_key+325
	DD	imagerel $unwind$set_add_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_add_key DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_add_key
_TEXT	SEGMENT
n_used$ = 32
hash$ = 40
tv133 = 48
so$ = 80
key$ = 88
set_add_key PROC					; COMDAT

; 383  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 384  :     register Py_hash_t hash;
; 385  :     register Py_ssize_t n_used;
; 386  : 
; 387  :     if (!PyUnicode_CheckExact(key) ||
; 388  :         (hash = ((PyASCIIObject *) key)->hash) == -1) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00015	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	75 16		 jne	 SHORT $LN5@set_add_ke
  00020	48 8b 44 24 58	 mov	 rax, QWORD PTR key$[rsp]
  00025	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00029	48 89 44 24 28	 mov	 QWORD PTR hash$[rsp], rax
  0002e	48 83 7c 24 28
	ff		 cmp	 QWORD PTR hash$[rsp], -1
  00034	75 21		 jne	 SHORT $LN6@set_add_ke
$LN5@set_add_ke:

; 389  :         hash = PyObject_Hash(key);

  00036	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0003b	e8 00 00 00 00	 call	 PyObject_Hash
  00040	48 89 44 24 28	 mov	 QWORD PTR hash$[rsp], rax

; 390  :         if (hash == -1)

  00045	48 83 7c 24 28
	ff		 cmp	 QWORD PTR hash$[rsp], -1
  0004b	75 0a		 jne	 SHORT $LN4@set_add_ke

; 391  :             return -1;

  0004d	b8 ff ff ff ff	 mov	 eax, -1
  00052	e9 e9 00 00 00	 jmp	 $LN7@set_add_ke
$LN4@set_add_ke:
$LN6@set_add_ke:

; 392  :     }
; 393  :     assert(so->fill <= so->mask);  /* at least one empty slot */

  00057	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00061	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00065	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00069	7e 1c		 jle	 SHORT $LN9@set_add_ke
  0006b	41 b8 89 01 00
	00		 mov	 r8d, 393		; 00000189H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@BAPLGKPP@?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAm?$AAa?$AAs?$AAk?$AA?$AA@
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00085	33 c0		 xor	 eax, eax
$LN9@set_add_ke:

; 394  :     n_used = so->used;

  00087	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0008c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00090	48 89 44 24 20	 mov	 QWORD PTR n_used$[rsp], rax

; 395  :     Py_INCREF(key);

  00095	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0009a	e8 00 00 00 00	 call	 _Py_IncRef

; 396  :     if (set_insert_key(so, key, hash) == -1) {

  0009f	4c 8b 44 24 28	 mov	 r8, QWORD PTR hash$[rsp]
  000a4	48 8b 54 24 58	 mov	 rdx, QWORD PTR key$[rsp]
  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  000ae	e8 00 00 00 00	 call	 set_insert_key
  000b3	83 f8 ff	 cmp	 eax, -1
  000b6	75 11		 jne	 SHORT $LN3@set_add_ke

; 397  :         Py_DECREF(key);

  000b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  000bd	e8 00 00 00 00	 call	 _Py_DecRef

; 398  :         return -1;

  000c2	b8 ff ff ff ff	 mov	 eax, -1
  000c7	eb 77		 jmp	 SHORT $LN7@set_add_ke
$LN3@set_add_ke:

; 399  :     }
; 400  :     if (!(so->used > n_used && so->fill*3 >= (so->mask+1)*2))

  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000ce	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n_used$[rsp]
  000d3	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  000d7	7e 20		 jle	 SHORT $LN1@set_add_ke
  000d9	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000de	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000e2	48 6b c0 03	 imul	 rax, 3
  000e6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  000eb	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000ef	48 8d 4c 09 02	 lea	 rcx, QWORD PTR [rcx+rcx+2]
  000f4	48 3b c1	 cmp	 rax, rcx
  000f7	7d 04		 jge	 SHORT $LN2@set_add_ke
$LN1@set_add_ke:

; 401  :         return 0;

  000f9	33 c0		 xor	 eax, eax
  000fb	eb 43		 jmp	 SHORT $LN7@set_add_ke
$LN2@set_add_ke:

; 402  :     return set_table_resize(so, so->used>50000 ? so->used*2 : so->used*4);

  000fd	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00102	48 81 78 68 50
	c3 00 00	 cmp	 QWORD PTR [rax+104], 50000 ; 0000c350H
  0010a	7e 13		 jle	 SHORT $LN10@set_add_ke
  0010c	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00111	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00115	48 d1 e0	 shl	 rax, 1
  00118	48 89 44 24 30	 mov	 QWORD PTR tv133[rsp], rax
  0011d	eb 12		 jmp	 SHORT $LN11@set_add_ke
$LN10@set_add_ke:
  0011f	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00124	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00128	48 c1 e0 02	 shl	 rax, 2
  0012c	48 89 44 24 30	 mov	 QWORD PTR tv133[rsp], rax
$LN11@set_add_ke:
  00131	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv133[rsp]
  00136	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  0013b	e8 00 00 00 00	 call	 set_table_resize
$LN7@set_add_ke:

; 403  : }

  00140	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00144	c3		 ret	 0
set_add_key ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DC@JGBFJDDE@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAt?$AAh?$AAe?$AAr?$AAs?$AAe?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_merge DD imagerel set_merge
	DD	imagerel set_merge+552
	DD	imagerel $unwind$set_merge
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_merge DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1DC@JGBFJDDE@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAt?$AAh?$AAe?$AAr?$AAs?$AAe?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@JGBFJDDE@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAt?$AAh?$AAe?$AAr?$AAs?$AAe?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'A', 00H, 'n', 00H, 'y', 00H, 'S', 00H, 'e', 00H
	DB	't', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k'
	DB	00H, '(', 00H, 'o', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, 'e', 00H, 't', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_merge
_TEXT	SEGMENT
i$ = 32
key$ = 40
other$ = 48
entry$ = 56
hash$ = 64
so$ = 96
otherset$ = 104
set_merge PROC						; COMDAT

; 632  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 633  :     PySetObject *other;
; 634  :     PyObject *key;
; 635  :     Py_hash_t hash;
; 636  :     register Py_ssize_t i;
; 637  :     register setentry *entry;
; 638  : 
; 639  :     assert (PyAnySet_Check(so));

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 60		 je	 SHORT $LN12@set_merge
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 4e		 je	 SHORT $LN12@set_merge
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 35		 jne	 SHORT $LN12@set_merge
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 1c		 jne	 SHORT $LN12@set_merge
  00064	41 b8 7f 02 00
	00		 mov	 r8d, 639		; 0000027fH
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@MEACPONF@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAo?$AA?$CJ?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN12@set_merge:

; 640  :     assert (PyAnySet_Check(otherset));

  00080	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00087	48 8b 4c 24 68	 mov	 rcx, QWORD PTR otherset$[rsp]
  0008c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00090	74 60		 je	 SHORT $LN13@set_merge
  00092	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00099	48 8b 4c 24 68	 mov	 rcx, QWORD PTR otherset$[rsp]
  0009e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000a2	74 4e		 je	 SHORT $LN13@set_merge
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  000ab	48 8b 44 24 68	 mov	 rax, QWORD PTR otherset$[rsp]
  000b0	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000b4	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b9	85 c0		 test	 eax, eax
  000bb	75 35		 jne	 SHORT $LN13@set_merge
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  000c4	48 8b 44 24 68	 mov	 rax, QWORD PTR otherset$[rsp]
  000c9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000cd	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d2	85 c0		 test	 eax, eax
  000d4	75 1c		 jne	 SHORT $LN13@set_merge
  000d6	41 b8 80 02 00
	00		 mov	 r8d, 640		; 00000280H
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@JGBFJDDE@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAt?$AAh?$AAe?$AAr?$AAs?$AAe?$AAt?$AA?$CJ?$AA?$AA@
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f0	33 c0		 xor	 eax, eax
$LN13@set_merge:

; 641  : 
; 642  :     other = (PySetObject*)otherset;

  000f2	48 8b 44 24 68	 mov	 rax, QWORD PTR otherset$[rsp]
  000f7	48 89 44 24 30	 mov	 QWORD PTR other$[rsp], rax

; 643  :     if (other == so || other->used == 0)

  000fc	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  00101	48 39 44 24 30	 cmp	 QWORD PTR other$[rsp], rax
  00106	74 0c		 je	 SHORT $LN8@set_merge
  00108	48 8b 44 24 30	 mov	 rax, QWORD PTR other$[rsp]
  0010d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00112	75 07		 jne	 SHORT $LN9@set_merge
$LN8@set_merge:

; 644  :         /* a.update(a) or a.update({}); nothing to do */
; 645  :         return 0;

  00114	33 c0		 xor	 eax, eax
  00116	e9 08 01 00 00	 jmp	 $LN10@set_merge
$LN9@set_merge:

; 646  :     /* Do one big resize at the start, rather than
; 647  :      * incrementally resizing as we insert new keys.  Expect
; 648  :      * that there will be no (or few) overlapping keys.
; 649  :      */
; 650  :     if ((so->fill + other->used)*3 >= (so->mask+1)*2) {

  0011b	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  00120	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR other$[rsp]
  00129	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  0012d	48 6b c0 03	 imul	 rax, 3
  00131	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00136	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0013a	48 8d 4c 09 02	 lea	 rcx, QWORD PTR [rcx+rcx+2]
  0013f	48 3b c1	 cmp	 rax, rcx
  00142	7c 30		 jl	 SHORT $LN7@set_merge

; 651  :        if (set_table_resize(so, (so->used + other->used)*2) != 0)

  00144	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  00149	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR other$[rsp]
  00152	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  00156	48 d1 e0	 shl	 rax, 1
  00159	48 8b d0	 mov	 rdx, rax
  0015c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00161	e8 00 00 00 00	 call	 set_table_resize
  00166	85 c0		 test	 eax, eax
  00168	74 0a		 je	 SHORT $LN6@set_merge

; 652  :            return -1;

  0016a	b8 ff ff ff ff	 mov	 eax, -1
  0016f	e9 af 00 00 00	 jmp	 $LN10@set_merge
$LN6@set_merge:
$LN7@set_merge:

; 653  :     }
; 654  :     for (i = 0; i <= other->mask; i++) {

  00174	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0017d	eb 0d		 jmp	 SHORT $LN5@set_merge
$LN4@set_merge:
  0017f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00184	48 ff c0	 inc	 rax
  00187	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN5@set_merge:
  0018c	48 8b 44 24 30	 mov	 rax, QWORD PTR other$[rsp]
  00191	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00195	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0019a	0f 8f 81 00 00
	00		 jg	 $LN3@set_merge

; 655  :         entry = &other->table[i];

  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  001a5	48 6b c0 10	 imul	 rax, 16
  001a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR other$[rsp]
  001ae	48 03 41 78	 add	 rax, QWORD PTR [rcx+120]
  001b2	48 89 44 24 38	 mov	 QWORD PTR entry$[rsp], rax

; 656  :         key = entry->key;

  001b7	48 8b 44 24 38	 mov	 rax, QWORD PTR entry$[rsp]
  001bc	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001c0	48 89 44 24 28	 mov	 QWORD PTR key$[rsp], rax

; 657  :         hash = entry->hash;

  001c5	48 8b 44 24 38	 mov	 rax, QWORD PTR entry$[rsp]
  001ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cd	48 89 44 24 40	 mov	 QWORD PTR hash$[rsp], rax

; 658  :         if (key != NULL &&
; 659  :             key != dummy) {

  001d2	48 83 7c 24 28
	00		 cmp	 QWORD PTR key$[rsp], 0
  001d8	74 42		 je	 SHORT $LN2@set_merge
  001da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dummy
  001e1	48 39 44 24 28	 cmp	 QWORD PTR key$[rsp], rax
  001e6	74 34		 je	 SHORT $LN2@set_merge

; 660  :             Py_INCREF(key);

  001e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR key$[rsp]
  001ed	e8 00 00 00 00	 call	 _Py_IncRef

; 661  :             if (set_insert_key(so, key, hash) == -1) {

  001f2	4c 8b 44 24 40	 mov	 r8, QWORD PTR hash$[rsp]
  001f7	48 8b 54 24 28	 mov	 rdx, QWORD PTR key$[rsp]
  001fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00201	e8 00 00 00 00	 call	 set_insert_key
  00206	83 f8 ff	 cmp	 eax, -1
  00209	75 11		 jne	 SHORT $LN1@set_merge

; 662  :                 Py_DECREF(key);

  0020b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR key$[rsp]
  00210	e8 00 00 00 00	 call	 _Py_DecRef

; 663  :                 return -1;

  00215	b8 ff ff ff ff	 mov	 eax, -1
  0021a	eb 07		 jmp	 SHORT $LN10@set_merge
$LN1@set_merge:
$LN2@set_merge:

; 664  :             }
; 665  :         }
; 666  :     }

  0021c	e9 5e ff ff ff	 jmp	 $LN4@set_merge
$LN3@set_merge:

; 667  :     return 0;

  00221	33 c0		 xor	 eax, eax
$LN10@set_merge:

; 668  : }

  00223	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00227	c3		 ret	 0
set_merge ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@KJMJKMLB@frozenset?$CI?$CJ?$AA@	; `string'
EXTRN	PyArg_UnpackTuple:PROC
EXTRN	_PyArg_NoKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$frozenset_new DD imagerel frozenset_new
	DD	imagerel frozenset_new+322
	DD	imagerel $unwind$frozenset_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$frozenset_new DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0M@KJMJKMLB@frozenset?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@KJMJKMLB@frozenset?$CI?$CJ?$AA@ DB 'frozenset()', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT frozenset_new
_TEXT	SEGMENT
result$ = 48
iterable$ = 56
type$ = 80
args$ = 88
kwds$ = 96
frozenset_new PROC					; COMDAT

; 1084 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1085 :     PyObject *iterable = NULL, *result;

  00013	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR iterable$[rsp], 0

; 1086 : 
; 1087 :     if (type == &PyFrozenSet_Type && !_PyArg_NoKeywords("frozenset()", kwds))

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00023	48 39 44 24 50	 cmp	 QWORD PTR type$[rsp], rax
  00028	75 1c		 jne	 SHORT $LN12@frozenset_@2
  0002a	48 8b 54 24 60	 mov	 rdx, QWORD PTR kwds$[rsp]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@KJMJKMLB@frozenset?$CI?$CJ?$AA@
  00036	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  0003b	85 c0		 test	 eax, eax
  0003d	75 07		 jne	 SHORT $LN12@frozenset_@2

; 1088 :         return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 f7 00 00 00	 jmp	 $LN13@frozenset_@2
$LN12@frozenset_@2:

; 1089 : 
; 1090 :     if (!PyArg_UnpackTuple(args, type->tp_name, 0, 1, &iterable))

  00046	48 8d 44 24 38	 lea	 rax, QWORD PTR iterable$[rsp]
  0004b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00050	41 b9 01 00 00
	00		 mov	 r9d, 1
  00056	45 33 c0	 xor	 r8d, r8d
  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR type$[rsp]
  0005e	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00062	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00067	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0006c	85 c0		 test	 eax, eax
  0006e	75 07		 jne	 SHORT $LN11@frozenset_@2

; 1091 :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	e9 c6 00 00 00	 jmp	 $LN13@frozenset_@2
$LN11@frozenset_@2:

; 1092 : 
; 1093 :     if (type != &PyFrozenSet_Type)

  00077	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0007e	48 39 44 24 50	 cmp	 QWORD PTR type$[rsp], rax
  00083	74 14		 je	 SHORT $LN10@frozenset_@2

; 1094 :         return make_new_set(type, iterable);

  00085	48 8b 54 24 38	 mov	 rdx, QWORD PTR iterable$[rsp]
  0008a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR type$[rsp]
  0008f	e8 00 00 00 00	 call	 make_new_set
  00094	e9 a4 00 00 00	 jmp	 $LN13@frozenset_@2
$LN10@frozenset_@2:

; 1095 : 
; 1096 :     if (iterable != NULL) {

  00099	48 83 7c 24 38
	00		 cmp	 QWORD PTR iterable$[rsp], 0
  0009f	74 5c		 je	 SHORT $LN9@frozenset_@2

; 1097 :         /* frozenset(f) is idempotent */
; 1098 :         if (PyFrozenSet_CheckExact(iterable)) {

  000a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR iterable$[rsp]
  000ad	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000b1	75 11		 jne	 SHORT $LN8@frozenset_@2

; 1099 :             Py_INCREF(iterable);

  000b3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR iterable$[rsp]
  000b8	e8 00 00 00 00	 call	 _Py_IncRef

; 1100 :             return iterable;

  000bd	48 8b 44 24 38	 mov	 rax, QWORD PTR iterable$[rsp]
  000c2	eb 79		 jmp	 SHORT $LN13@frozenset_@2
$LN8@frozenset_@2:

; 1101 :         }
; 1102 :         result = make_new_set(type, iterable);

  000c4	48 8b 54 24 38	 mov	 rdx, QWORD PTR iterable$[rsp]
  000c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR type$[rsp]
  000ce	e8 00 00 00 00	 call	 make_new_set
  000d3	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1103 :         if (result == NULL || PySet_GET_SIZE(result))

  000d8	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  000de	74 0c		 je	 SHORT $LN6@frozenset_@2
  000e0	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  000e5	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000ea	74 07		 je	 SHORT $LN7@frozenset_@2
$LN6@frozenset_@2:

; 1104 :             return result;

  000ec	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  000f1	eb 4a		 jmp	 SHORT $LN13@frozenset_@2
$LN7@frozenset_@2:

; 1105 :         Py_DECREF(result);

  000f3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  000f8	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@frozenset_@2:

; 1106 :     }
; 1107 :     /* The empty frozenset is a singleton */
; 1108 :     if (emptyfrozenset == NULL)

  000fd	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR emptyfrozenset, 0
  00105	75 13		 jne	 SHORT $LN5@frozenset_@2

; 1109 :         emptyfrozenset = make_new_set(type, NULL);

  00107	33 d2		 xor	 edx, edx
  00109	48 8b 4c 24 50	 mov	 rcx, QWORD PTR type$[rsp]
  0010e	e8 00 00 00 00	 call	 make_new_set
  00113	48 89 05 00 00
	00 00		 mov	 QWORD PTR emptyfrozenset, rax
$LN5@frozenset_@2:
$LN4@frozenset_@2:

; 1110 :     Py_XINCREF(emptyfrozenset);

  0011a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR emptyfrozenset, 0
  00122	74 0c		 je	 SHORT $LN1@frozenset_@2
  00124	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR emptyfrozenset
  0012b	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@frozenset_@2:
  00130	33 c0		 xor	 eax, eax
  00132	85 c0		 test	 eax, eax
  00134	75 e4		 jne	 SHORT $LN4@frozenset_@2

; 1111 :     return emptyfrozenset;

  00136	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR emptyfrozenset
$LN13@frozenset_@2:

; 1112 : }

  0013d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00141	c3		 ret	 0
frozenset_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_1GI@ONNIFOEO@?$AAs?$AAo?$AA?9?$AA?$DO?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_1EM@JAAELAFH@?$AAs?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc@ ; `string'
PUBLIC	??_C@_0M@FAFKDOL@?$DMdummy?5key?$DO?$AA@	; `string'
EXTRN	PyObject_GC_Track:PROC
EXTRN	_Py_NewReference:PROC
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_new_set DD imagerel make_new_set
	DD	imagerel make_new_set+633
	DD	imagerel $unwind$make_new_set
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_new_set DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1GI@ONNIFOEO@?$AAs?$AAo?$AA?9?$AA?$DO?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1GI@ONNIFOEO@?$AAs?$AAo?$AA?9?$AA?$DO?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DN?$AA?$DN@ DB 's'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 't', 00H, 'a', 00H, 'b', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N'
	DB	00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 's', 00H, 'o', 00H, '-', 00H, '>', 00H, 'f', 00H, 'i'
	DB	00H, 'l', 00H, 'l', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 's', 00H, 'o'
	DB	00H, '-', 00H, '>', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@JAAELAFH@?$AAs?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc@
CONST	SEGMENT
??_C@_1EM@JAAELAFH@?$AAs?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc@ DB 's'
	DB	00H, 'o', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'P', 00H, 'y', 00H, 'A', 00H, 'n', 00H, 'y', 00H, 'S', 00H
	DB	'e', 00H, 't', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, 'E', 00H, 'x', 00H, 'a', 00H, 'c', 00H, 't', 00H
	DB	'(', 00H, 's', 00H, 'o', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FAFKDOL@?$DMdummy?5key?$DO?$AA@
CONST	SEGMENT
??_C@_0M@FAFKDOL@?$DMdummy?5key?$DO?$AA@ DB '<dummy key>', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT make_new_set
_TEXT	SEGMENT
so$ = 32
type$ = 64
iterable$ = 72
make_new_set PROC					; COMDAT

; 1027 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1028 :     register PySetObject *so = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR so$[rsp], 0

; 1029 : 
; 1030 :     if (dummy == NULL) { /* Auto-initialize dummy */

  00017	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR dummy, 0
  0001f	75 24		 jne	 SHORT $LN17@make_new_s

; 1031 :         dummy = PyUnicode_FromString("<dummy key>");

  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@FAFKDOL@?$DMdummy?5key?$DO?$AA@
  00028	e8 00 00 00 00	 call	 PyUnicode_FromString
  0002d	48 89 05 00 00
	00 00		 mov	 QWORD PTR dummy, rax

; 1032 :         if (dummy == NULL)

  00034	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR dummy, 0
  0003c	75 07		 jne	 SHORT $LN16@make_new_s

; 1033 :             return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	e9 2f 02 00 00	 jmp	 $LN18@make_new_s
$LN16@make_new_s:
$LN17@make_new_s:

; 1034 :     }
; 1035 : 
; 1036 :     /* create PySetObject structure */
; 1037 :     if (!Py_PXCTX && numfree &&
; 1038 :         (type == &PySet_Type  ||  type == &PyFrozenSet_Type)) {

  00045	e8 00 00 00 00	 call	 _Py_PXCTX
  0004a	85 c0		 test	 eax, eax
  0004c	0f 85 33 01 00
	00		 jne	 $LN15@make_new_s
  00052	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR numfree, 0
  00059	0f 84 26 01 00
	00		 je	 $LN15@make_new_s
  0005f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00066	48 39 44 24 40	 cmp	 QWORD PTR type$[rsp], rax
  0006b	74 12		 je	 SHORT $LN14@make_new_s
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00074	48 39 44 24 40	 cmp	 QWORD PTR type$[rsp], rax
  00079	0f 85 06 01 00
	00		 jne	 $LN15@make_new_s
$LN14@make_new_s:

; 1039 :         so = free_list[--numfree];

  0007f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  00085	ff c8		 dec	 eax
  00087	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax
  0008d	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR numfree
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:free_list
  0009b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0009f	48 89 44 24 20	 mov	 QWORD PTR so$[rsp], rax

; 1040 :         assert (so != NULL && PyAnySet_CheckExact(so));

  000a4	48 83 7c 24 20
	00		 cmp	 QWORD PTR so$[rsp], 0
  000aa	74 24		 je	 SHORT $LN21@make_new_s
  000ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  000b3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR so$[rsp]
  000b8	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000bc	74 2e		 je	 SHORT $LN20@make_new_s
  000be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR so$[rsp]
  000ca	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000ce	74 1c		 je	 SHORT $LN20@make_new_s
$LN21@make_new_s:
  000d0	41 b8 10 04 00
	00		 mov	 r8d, 1040		; 00000410H
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@JAAELAFH@?$AAs?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc@
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ea	33 c0		 xor	 eax, eax
$LN20@make_new_s:

; 1041 :         Py_TYPE(so) = type;

  000ec	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  000f1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  000f6	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 1042 :         _Py_NewReference((PyObject *)so);

  000fa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR so$[rsp]
  000ff	e8 00 00 00 00	 call	 _Py_NewReference
$LN13@make_new_s:

; 1043 :         EMPTY_TO_MINSIZE(so);

  00104	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  00109	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  0010f	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00115	33 d2		 xor	 edx, edx
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 memset
  0011f	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  00124	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  0012c	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  00131	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN10@make_new_s:
  00139	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  0013e	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00144	48 8b 4c 24 20	 mov	 rcx, QWORD PTR so$[rsp]
  00149	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax
  0014d	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  00152	48 c7 40 70 07
	00 00 00	 mov	 QWORD PTR [rax+112], 7
  0015a	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  0015f	48 c7 80 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+264], -1
  0016a	33 c0		 xor	 eax, eax
  0016c	85 c0		 test	 eax, eax
  0016e	75 c9		 jne	 SHORT $LN10@make_new_s
  00170	33 c0		 xor	 eax, eax
  00172	85 c0		 test	 eax, eax
  00174	75 8e		 jne	 SHORT $LN13@make_new_s

; 1044 :         PyObject_GC_Track(so);

  00176	48 8b 4c 24 20	 mov	 rcx, QWORD PTR so$[rsp]
  0017b	e8 00 00 00 00	 call	 PyObject_GC_Track

; 1045 :     } else {

  00180	e9 9d 00 00 00	 jmp	 $LN7@make_new_s
$LN15@make_new_s:

; 1046 :         so = (PySetObject *)type->tp_alloc(type, 0);

  00185	33 d2		 xor	 edx, edx
  00187	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  0018c	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  00191	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00197	48 89 44 24 20	 mov	 QWORD PTR so$[rsp], rax

; 1047 :         if (so == NULL)

  0019c	48 83 7c 24 20
	00		 cmp	 QWORD PTR so$[rsp], 0
  001a2	75 07		 jne	 SHORT $LN6@make_new_s

; 1048 :             return NULL;

  001a4	33 c0		 xor	 eax, eax
  001a6	e9 c9 00 00 00	 jmp	 $LN18@make_new_s
$LN6@make_new_s:

; 1049 :         /* tp_alloc has already zeroed the structure */
; 1050 :         assert(so->table == NULL && so->fill == 0 && so->used == 0);

  001ab	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  001b0	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  001b5	75 18		 jne	 SHORT $LN22@make_new_s
  001b7	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  001bc	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001c1	75 0c		 jne	 SHORT $LN22@make_new_s
  001c3	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  001c8	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  001cd	74 1c		 je	 SHORT $LN23@make_new_s
$LN22@make_new_s:
  001cf	41 b8 1a 04 00
	00		 mov	 r8d, 1050		; 0000041aH
  001d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GI@ONNIFOEO@?$AAs?$AAo?$AA?9?$AA?$DO?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAo?$AA?9?$AA?$DO?$AAf?$AAi?$AAl?$AAl?$AA?5?$AA?$DN?$AA?$DN@
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001e9	33 c0		 xor	 eax, eax
$LN23@make_new_s:
$LN5@make_new_s:

; 1051 :         INIT_NONZERO_SET_SLOTS(so);

  001eb	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  001f0	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  001f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR so$[rsp]
  001fb	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax
  001ff	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  00204	48 c7 40 70 07
	00 00 00	 mov	 QWORD PTR [rax+112], 7
  0020c	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  00211	48 c7 80 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+264], -1
  0021c	33 c0		 xor	 eax, eax
  0021e	85 c0		 test	 eax, eax
  00220	75 c9		 jne	 SHORT $LN5@make_new_s
$LN7@make_new_s:

; 1052 :     }
; 1053 : 
; 1054 :     so->lookup = set_lookkey_unicode;

  00222	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  00227	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:set_lookkey_unicode
  0022e	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 1055 :     so->weakreflist = NULL;

  00235	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
  0023a	48 c7 80 10 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+272], 0

; 1056 : 
; 1057 :     if (iterable != NULL) {

  00245	48 83 7c 24 48
	00		 cmp	 QWORD PTR iterable$[rsp], 0
  0024b	74 22		 je	 SHORT $LN2@make_new_s

; 1058 :         if (set_update_internal(so, iterable) == -1) {

  0024d	48 8b 54 24 48	 mov	 rdx, QWORD PTR iterable$[rsp]
  00252	48 8b 4c 24 20	 mov	 rcx, QWORD PTR so$[rsp]
  00257	e8 00 00 00 00	 call	 set_update_internal
  0025c	83 f8 ff	 cmp	 eax, -1
  0025f	75 0e		 jne	 SHORT $LN1@make_new_s

; 1059 :             Py_DECREF(so);

  00261	48 8b 4c 24 20	 mov	 rcx, QWORD PTR so$[rsp]
  00266	e8 00 00 00 00	 call	 _Py_DecRef

; 1060 :             return NULL;

  0026b	33 c0		 xor	 eax, eax
  0026d	eb 05		 jmp	 SHORT $LN18@make_new_s
$LN1@make_new_s:
$LN2@make_new_s:

; 1061 :         }
; 1062 :     }
; 1063 : 
; 1064 :     return (PyObject *)so;

  0026f	48 8b 44 24 20	 mov	 rax, QWORD PTR so$[rsp]
$LN18@make_new_s:

; 1065 : }

  00274	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00278	c3		 ret	 0
make_new_set ENDP
_TEXT	ENDS
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_lookkey_unicode DD imagerel set_lookkey_unicode
	DD	imagerel set_lookkey_unicode+599
	DD	imagerel $unwind$set_lookkey_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_lookkey_unicode DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_lookkey_unicode
_TEXT	SEGMENT
i$ = 32
mask$ = 40
perturb$ = 48
table$ = 56
entry$ = 64
freeslot$ = 72
tv131 = 80
so$ = 112
key$ = 120
hash$ = 128
set_lookkey_unicode PROC				; COMDAT

; 161  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 162  :     register size_t i;  /* Unsigned for defined overflow behavior. */
; 163  :     register size_t perturb;
; 164  :     register setentry *freeslot;
; 165  :     register size_t mask = so->mask;

  00013	48 8b 44 24 70	 mov	 rax, QWORD PTR so$[rsp]
  00018	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0001c	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax

; 166  :     setentry *table = so->table;

  00021	48 8b 44 24 70	 mov	 rax, QWORD PTR so$[rsp]
  00026	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0002a	48 89 44 24 38	 mov	 QWORD PTR table$[rsp], rax

; 167  :     register setentry *entry;
; 168  : 
; 169  :     /* Make sure this function doesn't have to handle non-unicode keys,
; 170  :        including subclasses of str; e.g., one reason to subclass
; 171  :        strings is to override __eq__, and for speed we don't cater to
; 172  :        that here. */
; 173  :     if (!PyUnicode_CheckExact(key)) {

  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00036	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  0003b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003f	74 2f		 je	 SHORT $LN13@set_lookke

; 174  :         so->lookup = set_lookkey;

  00041	48 8b 44 24 70	 mov	 rax, QWORD PTR so$[rsp]
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:set_lookkey
  0004d	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 175  :         return set_lookkey(so, key, hash);

  00054	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR hash$[rsp]
  0005c	48 8b 54 24 78	 mov	 rdx, QWORD PTR key$[rsp]
  00061	48 8b 4c 24 70	 mov	 rcx, QWORD PTR so$[rsp]
  00066	e8 00 00 00 00	 call	 set_lookkey
  0006b	e9 e2 01 00 00	 jmp	 $LN14@set_lookke
$LN13@set_lookke:

; 176  :     }
; 177  :     i = (size_t)hash & mask;

  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$[rsp]
  00075	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hash$[rsp]
  0007d	48 23 c8	 and	 rcx, rax
  00080	48 8b c1	 mov	 rax, rcx
  00083	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 178  :     entry = &table[i];

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0008d	48 6b c0 10	 imul	 rax, 16
  00091	48 8b 4c 24 38	 mov	 rcx, QWORD PTR table$[rsp]
  00096	48 03 c8	 add	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 89 44 24 40	 mov	 QWORD PTR entry$[rsp], rax

; 179  :     if (entry->key == NULL || entry->key == key)

  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  000a6	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000ab	74 10		 je	 SHORT $LN11@set_lookke
  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  000b2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  000b7	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  000bb	75 0a		 jne	 SHORT $LN12@set_lookke
$LN11@set_lookke:

; 180  :         return entry;

  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  000c2	e9 8b 01 00 00	 jmp	 $LN14@set_lookke
$LN12@set_lookke:

; 181  :     if (entry->key == dummy)

  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  000cc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  000d3	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  000d7	75 0c		 jne	 SHORT $LN10@set_lookke

; 182  :         freeslot = entry;

  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  000de	48 89 44 24 48	 mov	 QWORD PTR freeslot$[rsp], rax

; 183  :     else {

  000e3	eb 3c		 jmp	 SHORT $LN9@set_lookke
$LN10@set_lookke:

; 184  :         if (entry->hash == hash && unicode_eq(entry->key, key))

  000e5	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  000ea	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hash$[rsp]
  000f2	48 39 08	 cmp	 QWORD PTR [rax], rcx
  000f5	75 21		 jne	 SHORT $LN8@set_lookke
  000f7	48 8b 54 24 78	 mov	 rdx, QWORD PTR key$[rsp]
  000fc	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  00101	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00105	e8 00 00 00 00	 call	 unicode_eq
  0010a	85 c0		 test	 eax, eax
  0010c	74 0a		 je	 SHORT $LN8@set_lookke

; 185  :             return entry;

  0010e	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  00113	e9 3a 01 00 00	 jmp	 $LN14@set_lookke
$LN8@set_lookke:

; 186  :         freeslot = NULL;

  00118	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR freeslot$[rsp], 0
$LN9@set_lookke:

; 187  :     }
; 188  : 
; 189  :     /* In the loop, key == dummy is by far (factor of 100s) the
; 190  :        least likely outcome, so test for that last. */
; 191  :     for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {

  00121	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR hash$[rsp]
  00129	48 89 44 24 30	 mov	 QWORD PTR perturb$[rsp], rax
  0012e	eb 0e		 jmp	 SHORT $LN7@set_lookke
$LN6@set_lookke:
  00130	48 8b 44 24 30	 mov	 rax, QWORD PTR perturb$[rsp]
  00135	48 c1 e8 05	 shr	 rax, 5
  00139	48 89 44 24 30	 mov	 QWORD PTR perturb$[rsp], rax
$LN7@set_lookke:

; 192  :         i = (i << 2) + i + perturb + 1;

  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00143	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00148	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0014c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR perturb$[rsp]
  00151	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  00156	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 193  :         entry = &table[i & mask];

  0015b	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$[rsp]
  00160	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00165	48 23 c8	 and	 rcx, rax
  00168	48 8b c1	 mov	 rax, rcx
  0016b	48 6b c0 10	 imul	 rax, 16
  0016f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR table$[rsp]
  00174	48 03 c8	 add	 rcx, rax
  00177	48 8b c1	 mov	 rax, rcx
  0017a	48 89 44 24 40	 mov	 QWORD PTR entry$[rsp], rax

; 194  :         if (entry->key == NULL)

  0017f	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  00184	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00189	75 28		 jne	 SHORT $LN4@set_lookke

; 195  :             return freeslot == NULL ? entry : freeslot;

  0018b	48 83 7c 24 48
	00		 cmp	 QWORD PTR freeslot$[rsp], 0
  00191	75 0c		 jne	 SHORT $LN16@set_lookke
  00193	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  00198	48 89 44 24 50	 mov	 QWORD PTR tv131[rsp], rax
  0019d	eb 0a		 jmp	 SHORT $LN17@set_lookke
$LN16@set_lookke:
  0019f	48 8b 44 24 48	 mov	 rax, QWORD PTR freeslot$[rsp]
  001a4	48 89 44 24 50	 mov	 QWORD PTR tv131[rsp], rax
$LN17@set_lookke:
  001a9	48 8b 44 24 50	 mov	 rax, QWORD PTR tv131[rsp]
  001ae	e9 9f 00 00 00	 jmp	 $LN14@set_lookke
$LN4@set_lookke:

; 196  :         if (entry->key == key
; 197  :             || (entry->hash == hash
; 198  :             && entry->key != dummy
; 199  :             && unicode_eq(entry->key, key)))

  001b3	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  001b8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  001bd	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  001c1	74 3b		 je	 SHORT $LN2@set_lookke
  001c3	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  001c8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hash$[rsp]
  001d0	48 39 08	 cmp	 QWORD PTR [rax], rcx
  001d3	75 30		 jne	 SHORT $LN3@set_lookke
  001d5	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  001da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  001e1	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  001e5	74 1e		 je	 SHORT $LN3@set_lookke
  001e7	48 8b 54 24 78	 mov	 rdx, QWORD PTR key$[rsp]
  001ec	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  001f1	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001f5	e8 00 00 00 00	 call	 unicode_eq
  001fa	85 c0		 test	 eax, eax
  001fc	74 07		 je	 SHORT $LN3@set_lookke
$LN2@set_lookke:

; 200  :             return entry;

  001fe	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  00203	eb 4d		 jmp	 SHORT $LN14@set_lookke
$LN3@set_lookke:

; 201  :         if (entry->key == dummy && freeslot == NULL)

  00205	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  0020a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  00211	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00215	75 12		 jne	 SHORT $LN1@set_lookke
  00217	48 83 7c 24 48
	00		 cmp	 QWORD PTR freeslot$[rsp], 0
  0021d	75 0a		 jne	 SHORT $LN1@set_lookke

; 202  :             freeslot = entry;

  0021f	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  00224	48 89 44 24 48	 mov	 QWORD PTR freeslot$[rsp], rax
$LN1@set_lookke:

; 203  :     }

  00229	e9 02 ff ff ff	 jmp	 $LN6@set_lookke

; 204  :     assert(0);          /* NOT REACHED */

  0022e	33 c0		 xor	 eax, eax
  00230	85 c0		 test	 eax, eax
  00232	75 1c		 jne	 SHORT $LN18@set_lookke
  00234	41 b8 cc 00 00
	00		 mov	 r8d, 204		; 000000ccH
  0023a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  00248	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0024e	33 c0		 xor	 eax, eax
$LN18@set_lookke:

; 205  :     return 0;

  00250	33 c0		 xor	 eax, eax
$LN14@set_lookke:

; 206  : }

  00252	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00256	c3		 ret	 0
set_lookkey_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EE@PCPICPBJ@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@ ; `string'
PUBLIC	??_C@_1EE@PACGCIDO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAb?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@ ; `string'
PUBLIC	??_C@_1CM@KGBPLJCE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@CAILMLIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@MIIHENII@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAe?$AAq?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAy?$AA?5?$AAf?$AAa?$AAi?$AAl?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@CHIKBFM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ ; `string'
EXTRN	memcmp:PROC
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\eq.h
pdata	SEGMENT
$pdata$unicode_eq DD imagerel unicode_eq
	DD	imagerel unicode_eq+1724
	DD	imagerel $unwind$unicode_eq
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_eq DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_1EE@PCPICPBJ@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
CONST	SEGMENT
??_C@_1EE@PCPICPBJ@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'a', 00H, ')', 00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@PACGCIDO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAb?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
CONST	SEGMENT
??_C@_1EE@PACGCIDO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAb?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'b', 00H, ')', 00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@KGBPLJCE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@KGBPLJCE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'b', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@CAILMLIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@CAILMLIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'a', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@MIIHENII@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAe?$AAq?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAy?$AA?5?$AAf?$AAa?$AAi?$AAl?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@MIIHENII@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAe?$AAq?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAy?$AA?5?$AAf?$AAa?$AAi?$AAl?$AA?$CC?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'u', 00H
	DB	'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_'
	DB	00H, 'e', 00H, 'q', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	'd', 00H, 'y', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l'
	DB	00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@CHIKBFM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@CHIKBFM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'b', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'a', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'l', 00H
	DB	'i', 00H, 'b', 00H, '/', 00H, 'e', 00H, 'q', 00H, '.', 00H, 'h'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT unicode_eq
_TEXT	SEGMENT
a$ = 32
b$ = 40
tv78 = 48
tv94 = 52
tv298 = 56
tv307 = 64
tv342 = 72
tv351 = 80
tv354 = 88
aa$ = 112
bb$ = 120
unicode_eq PROC						; COMDAT

; 8    : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 9    :     register PyUnicodeObject *a = (PyUnicodeObject *)aa;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR aa$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR a$[rsp], rax

; 10   :     register PyUnicodeObject *b = (PyUnicodeObject *)bb;

  00018	48 8b 44 24 78	 mov	 rax, QWORD PTR bb$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR b$[rsp], rax

; 11   : 
; 12   :     if (PyUnicode_READY(a) == -1 || PyUnicode_READY(b) == -1) {

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00027	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00031	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00036	85 c0		 test	 eax, eax
  00038	75 1c		 jne	 SHORT $LN8@unicode_eq
  0003a	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00054	33 c0		 xor	 eax, eax
$LN8@unicode_eq:
  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0005b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0005e	c1 e8 07	 shr	 eax, 7
  00061	83 e0 01	 and	 eax, 1
  00064	85 c0		 test	 eax, eax
  00066	74 0a		 je	 SHORT $LN9@unicode_eq
  00068	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  00070	eb 0e		 jmp	 SHORT $LN10@unicode_eq
$LN9@unicode_eq:
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  00077	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0007c	89 44 24 30	 mov	 DWORD PTR tv78[rsp], eax
$LN10@unicode_eq:
  00080	83 7c 24 30 ff	 cmp	 DWORD PTR tv78[rsp], -1
  00085	74 65		 je	 SHORT $LN4@unicode_eq
  00087	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0008c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00090	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00096	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0009b	85 c0		 test	 eax, eax
  0009d	75 1c		 jne	 SHORT $LN11@unicode_eq
  0009f	41 b8 0c 00 00
	00		 mov	 r8d, 12
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@CHIKBFM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b9	33 c0		 xor	 eax, eax
$LN11@unicode_eq:
  000bb	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  000c0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000c3	c1 e8 07	 shr	 eax, 7
  000c6	83 e0 01	 and	 eax, 1
  000c9	85 c0		 test	 eax, eax
  000cb	74 0a		 je	 SHORT $LN12@unicode_eq
  000cd	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
  000d5	eb 0e		 jmp	 SHORT $LN13@unicode_eq
$LN12@unicode_eq:
  000d7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR b$[rsp]
  000dc	e8 00 00 00 00	 call	 _PyUnicode_Ready
  000e1	89 44 24 34	 mov	 DWORD PTR tv94[rsp], eax
$LN13@unicode_eq:
  000e5	83 7c 24 34 ff	 cmp	 DWORD PTR tv94[rsp], -1
  000ea	75 29		 jne	 SHORT $LN5@unicode_eq
$LN4@unicode_eq:

; 13   :         assert(0 && "unicode_eq ready fail");

  000ec	33 c0		 xor	 eax, eax
  000ee	85 c0		 test	 eax, eax
  000f0	75 1c		 jne	 SHORT $LN14@unicode_eq
  000f2	41 b8 0d 00 00
	00		 mov	 r8d, 13
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@MIIHENII@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAe?$AAq?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAy?$AA?5?$AAf?$AAa?$AAi?$AAl?$AA?$CC?$AA?$AA@
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0010c	33 c0		 xor	 eax, eax
$LN14@unicode_eq:

; 14   :         return 0;

  0010e	33 c0		 xor	 eax, eax
  00110	e9 a2 05 00 00	 jmp	 $LN6@unicode_eq
$LN5@unicode_eq:

; 15   :     }
; 16   : 
; 17   :     if (PyUnicode_GET_LENGTH(a) != PyUnicode_GET_LENGTH(b))

  00115	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0011a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0011e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00124	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00129	85 c0		 test	 eax, eax
  0012b	75 1c		 jne	 SHORT $LN15@unicode_eq
  0012d	41 b8 11 00 00
	00		 mov	 r8d, 17
  00133	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00147	33 c0		 xor	 eax, eax
$LN15@unicode_eq:
  00149	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0014e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00151	c1 e8 07	 shr	 eax, 7
  00154	83 e0 01	 and	 eax, 1
  00157	85 c0		 test	 eax, eax
  00159	75 1c		 jne	 SHORT $LN16@unicode_eq
  0015b	41 b8 11 00 00
	00		 mov	 r8d, 17
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CAILMLIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00175	33 c0		 xor	 eax, eax
$LN16@unicode_eq:
  00177	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0017c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00180	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00186	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0018b	85 c0		 test	 eax, eax
  0018d	75 1c		 jne	 SHORT $LN17@unicode_eq
  0018f	41 b8 11 00 00
	00		 mov	 r8d, 17
  00195	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@CHIKBFM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001a9	33 c0		 xor	 eax, eax
$LN17@unicode_eq:
  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  001b0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001b3	c1 e8 07	 shr	 eax, 7
  001b6	83 e0 01	 and	 eax, 1
  001b9	85 c0		 test	 eax, eax
  001bb	75 1c		 jne	 SHORT $LN18@unicode_eq
  001bd	41 b8 11 00 00
	00		 mov	 r8d, 17
  001c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@KGBPLJCE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d7	33 c0		 xor	 eax, eax
$LN18@unicode_eq:
  001d9	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  001de	48 8b 4c 24 28	 mov	 rcx, QWORD PTR b$[rsp]
  001e3	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  001e7	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  001eb	74 07		 je	 SHORT $LN3@unicode_eq

; 18   :         return 0;

  001ed	33 c0		 xor	 eax, eax
  001ef	e9 c3 04 00 00	 jmp	 $LN6@unicode_eq
$LN3@unicode_eq:

; 19   :     if (PyUnicode_GET_LENGTH(a) == 0)

  001f4	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  001f9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001fd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00203	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00208	85 c0		 test	 eax, eax
  0020a	75 1c		 jne	 SHORT $LN19@unicode_eq
  0020c	41 b8 13 00 00
	00		 mov	 r8d, 19
  00212	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00226	33 c0		 xor	 eax, eax
$LN19@unicode_eq:
  00228	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0022d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00230	c1 e8 07	 shr	 eax, 7
  00233	83 e0 01	 and	 eax, 1
  00236	85 c0		 test	 eax, eax
  00238	75 1c		 jne	 SHORT $LN20@unicode_eq
  0023a	41 b8 13 00 00
	00		 mov	 r8d, 19
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CAILMLIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00254	33 c0		 xor	 eax, eax
$LN20@unicode_eq:
  00256	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0025b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00260	75 0a		 jne	 SHORT $LN2@unicode_eq

; 20   :         return 1;

  00262	b8 01 00 00 00	 mov	 eax, 1
  00267	e9 4b 04 00 00	 jmp	 $LN6@unicode_eq
$LN2@unicode_eq:

; 21   :     if (PyUnicode_KIND(a) != PyUnicode_KIND(b))

  0026c	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00271	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00275	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0027b	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00280	85 c0		 test	 eax, eax
  00282	75 1c		 jne	 SHORT $LN21@unicode_eq
  00284	41 b8 15 00 00
	00		 mov	 r8d, 21
  0028a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00291	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0029e	33 c0		 xor	 eax, eax
$LN21@unicode_eq:
  002a0	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  002a5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002a8	c1 e8 07	 shr	 eax, 7
  002ab	83 e0 01	 and	 eax, 1
  002ae	85 c0		 test	 eax, eax
  002b0	75 1c		 jne	 SHORT $LN22@unicode_eq
  002b2	41 b8 15 00 00
	00		 mov	 r8d, 21
  002b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  002bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CAILMLIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  002c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002cc	33 c0		 xor	 eax, eax
$LN22@unicode_eq:
  002ce	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  002d3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002d7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002dd	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  002e2	85 c0		 test	 eax, eax
  002e4	75 1c		 jne	 SHORT $LN23@unicode_eq
  002e6	41 b8 15 00 00
	00		 mov	 r8d, 21
  002ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@CHIKBFM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
  002fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00300	33 c0		 xor	 eax, eax
$LN23@unicode_eq:
  00302	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00307	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0030a	c1 e8 07	 shr	 eax, 7
  0030d	83 e0 01	 and	 eax, 1
  00310	85 c0		 test	 eax, eax
  00312	75 1c		 jne	 SHORT $LN24@unicode_eq
  00314	41 b8 15 00 00
	00		 mov	 r8d, 21
  0031a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00321	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@KGBPLJCE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
  00328	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0032e	33 c0		 xor	 eax, eax
$LN24@unicode_eq:
  00330	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00335	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00338	c1 e8 02	 shr	 eax, 2
  0033b	83 e0 07	 and	 eax, 7
  0033e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR b$[rsp]
  00343	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00346	c1 e9 02	 shr	 ecx, 2
  00349	83 e1 07	 and	 ecx, 7
  0034c	3b c1		 cmp	 eax, ecx
  0034e	74 07		 je	 SHORT $LN1@unicode_eq

; 22   :         return 0;

  00350	33 c0		 xor	 eax, eax
  00352	e9 60 03 00 00	 jmp	 $LN6@unicode_eq
$LN1@unicode_eq:

; 23   :     return memcmp(PyUnicode_1BYTE_DATA(a), PyUnicode_1BYTE_DATA(b),
; 24   :                   PyUnicode_GET_LENGTH(a) * PyUnicode_KIND(a)) == 0;

  00357	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0035c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00360	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00366	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0036b	85 c0		 test	 eax, eax
  0036d	75 1c		 jne	 SHORT $LN25@unicode_eq
  0036f	41 b8 18 00 00
	00		 mov	 r8d, 24
  00375	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0037c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  00383	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00389	33 c0		 xor	 eax, eax
$LN25@unicode_eq:
  0038b	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00390	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00393	c1 e8 07	 shr	 eax, 7
  00396	83 e0 01	 and	 eax, 1
  00399	85 c0		 test	 eax, eax
  0039b	75 1c		 jne	 SHORT $LN26@unicode_eq
  0039d	41 b8 18 00 00
	00		 mov	 r8d, 24
  003a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  003aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CAILMLIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  003b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003b7	33 c0		 xor	 eax, eax
$LN26@unicode_eq:
  003b9	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  003be	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003c2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003c8	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  003cd	85 c0		 test	 eax, eax
  003cf	75 1c		 jne	 SHORT $LN27@unicode_eq
  003d1	41 b8 18 00 00
	00		 mov	 r8d, 24
  003d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  003de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  003e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003eb	33 c0		 xor	 eax, eax
$LN27@unicode_eq:
  003ed	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  003f2	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003f5	c1 e8 07	 shr	 eax, 7
  003f8	83 e0 01	 and	 eax, 1
  003fb	85 c0		 test	 eax, eax
  003fd	75 1c		 jne	 SHORT $LN28@unicode_eq
  003ff	41 b8 18 00 00
	00		 mov	 r8d, 24
  00405	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0040c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CAILMLIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  00413	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00419	33 c0		 xor	 eax, eax
$LN28@unicode_eq:
  0041b	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00420	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00424	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0042a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0042f	85 c0		 test	 eax, eax
  00431	75 1c		 jne	 SHORT $LN29@unicode_eq
  00433	41 b8 17 00 00
	00		 mov	 r8d, 23
  00439	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00440	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@CHIKBFM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
  00447	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0044d	33 c0		 xor	 eax, eax
$LN29@unicode_eq:
  0044f	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00454	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00457	c1 e8 05	 shr	 eax, 5
  0045a	83 e0 01	 and	 eax, 1
  0045d	85 c0		 test	 eax, eax
  0045f	0f 84 a2 00 00
	00		 je	 $LN35@unicode_eq
  00465	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0046a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0046e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00474	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00479	85 c0		 test	 eax, eax
  0047b	75 1c		 jne	 SHORT $LN30@unicode_eq
  0047d	41 b8 17 00 00
	00		 mov	 r8d, 23
  00483	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0048a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@CHIKBFM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
  00491	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00497	33 c0		 xor	 eax, eax
$LN30@unicode_eq:
  00499	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0049e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004a1	c1 e8 07	 shr	 eax, 7
  004a4	83 e0 01	 and	 eax, 1
  004a7	85 c0		 test	 eax, eax
  004a9	75 1c		 jne	 SHORT $LN31@unicode_eq
  004ab	41 b8 17 00 00
	00		 mov	 r8d, 23
  004b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  004b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@KGBPLJCE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
  004bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004c5	33 c0		 xor	 eax, eax
$LN31@unicode_eq:
  004c7	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  004cc	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004cf	c1 e8 06	 shr	 eax, 6
  004d2	83 e0 01	 and	 eax, 1
  004d5	85 c0		 test	 eax, eax
  004d7	74 12		 je	 SHORT $LN32@unicode_eq
  004d9	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  004de	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  004e4	48 89 44 24 38	 mov	 QWORD PTR tv298[rsp], rax
  004e9	eb 10		 jmp	 SHORT $LN33@unicode_eq
$LN32@unicode_eq:
  004eb	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  004f0	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  004f6	48 89 44 24 38	 mov	 QWORD PTR tv298[rsp], rax
$LN33@unicode_eq:
  004fb	48 8b 44 24 38	 mov	 rax, QWORD PTR tv298[rsp]
  00500	48 89 44 24 40	 mov	 QWORD PTR tv307[rsp], rax
  00505	eb 3c		 jmp	 SHORT $LN36@unicode_eq
$LN35@unicode_eq:
  00507	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0050c	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00514	75 1c		 jne	 SHORT $LN34@unicode_eq
  00516	41 b8 17 00 00
	00		 mov	 r8d, 23
  0051c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00523	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@PACGCIDO@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAb?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
  0052a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00530	33 c0		 xor	 eax, eax
$LN34@unicode_eq:
  00532	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00537	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0053e	48 89 44 24 40	 mov	 QWORD PTR tv307[rsp], rax
$LN36@unicode_eq:
  00543	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00548	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0054c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00552	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00557	85 c0		 test	 eax, eax
  00559	75 1c		 jne	 SHORT $LN37@unicode_eq
  0055b	41 b8 17 00 00
	00		 mov	 r8d, 23
  00561	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00568	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  0056f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00575	33 c0		 xor	 eax, eax
$LN37@unicode_eq:
  00577	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0057c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0057f	c1 e8 05	 shr	 eax, 5
  00582	83 e0 01	 and	 eax, 1
  00585	85 c0		 test	 eax, eax
  00587	0f 84 a2 00 00
	00		 je	 $LN43@unicode_eq
  0058d	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00592	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00596	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0059c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  005a1	85 c0		 test	 eax, eax
  005a3	75 1c		 jne	 SHORT $LN38@unicode_eq
  005a5	41 b8 17 00 00
	00		 mov	 r8d, 23
  005ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  005b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@IEOMNDPC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  005b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005bf	33 c0		 xor	 eax, eax
$LN38@unicode_eq:
  005c1	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  005c6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  005c9	c1 e8 07	 shr	 eax, 7
  005cc	83 e0 01	 and	 eax, 1
  005cf	85 c0		 test	 eax, eax
  005d1	75 1c		 jne	 SHORT $LN39@unicode_eq
  005d3	41 b8 17 00 00
	00		 mov	 r8d, 23
  005d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  005e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CAILMLIK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  005e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005ed	33 c0		 xor	 eax, eax
$LN39@unicode_eq:
  005ef	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  005f4	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  005f7	c1 e8 06	 shr	 eax, 6
  005fa	83 e0 01	 and	 eax, 1
  005fd	85 c0		 test	 eax, eax
  005ff	74 12		 je	 SHORT $LN40@unicode_eq
  00601	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00606	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0060c	48 89 44 24 48	 mov	 QWORD PTR tv342[rsp], rax
  00611	eb 10		 jmp	 SHORT $LN41@unicode_eq
$LN40@unicode_eq:
  00613	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00618	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0061e	48 89 44 24 48	 mov	 QWORD PTR tv342[rsp], rax
$LN41@unicode_eq:
  00623	48 8b 44 24 48	 mov	 rax, QWORD PTR tv342[rsp]
  00628	48 89 44 24 50	 mov	 QWORD PTR tv351[rsp], rax
  0062d	eb 3c		 jmp	 SHORT $LN44@unicode_eq
$LN43@unicode_eq:
  0062f	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00634	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  0063c	75 1c		 jne	 SHORT $LN42@unicode_eq
  0063e	41 b8 17 00 00
	00		 mov	 r8d, 23
  00644	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FC@DJFCKAMI@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0064b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@PCPICPBJ@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
  00652	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00658	33 c0		 xor	 eax, eax
$LN42@unicode_eq:
  0065a	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  0065f	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00666	48 89 44 24 50	 mov	 QWORD PTR tv351[rsp], rax
$LN44@unicode_eq:
  0066b	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00670	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00673	c1 e8 02	 shr	 eax, 2
  00676	83 e0 07	 and	 eax, 7
  00679	8b c0		 mov	 eax, eax
  0067b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  00680	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00684	48 0f af c8	 imul	 rcx, rax
  00688	48 8b c1	 mov	 rax, rcx
  0068b	4c 8b c0	 mov	 r8, rax
  0068e	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv307[rsp]
  00693	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv351[rsp]
  00698	e8 00 00 00 00	 call	 memcmp
  0069d	85 c0		 test	 eax, eax
  0069f	75 0a		 jne	 SHORT $LN45@unicode_eq
  006a1	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv354[rsp], 1
  006a9	eb 08		 jmp	 SHORT $LN46@unicode_eq
$LN45@unicode_eq:
  006ab	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv354[rsp], 0
$LN46@unicode_eq:
  006b3	8b 44 24 58	 mov	 eax, DWORD PTR tv354[rsp]
$LN6@unicode_eq:

; 25   : }

  006b7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  006bb	c3		 ret	 0
unicode_eq ENDP
_TEXT	ENDS
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\setobject.c
pdata	SEGMENT
$pdata$set_lookkey DD imagerel set_lookkey
	DD	imagerel set_lookkey+735
	DD	imagerel $unwind$set_lookkey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_lookkey DD 011301H
	DD	0c213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_lookkey
_TEXT	SEGMENT
i$ = 32
mask$ = 40
perturb$ = 48
table$ = 56
startkey$ = 64
entry$ = 72
cmp$ = 80
freeslot$ = 88
so$ = 112
key$ = 120
hash$ = 128
set_lookkey PROC					; COMDAT

; 79   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 80   :     register size_t i;  /* Unsigned for defined overflow behavior. */
; 81   :     register size_t perturb;
; 82   :     register setentry *freeslot;
; 83   :     register size_t mask = so->mask;

  00013	48 8b 44 24 70	 mov	 rax, QWORD PTR so$[rsp]
  00018	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0001c	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax

; 84   :     setentry *table = so->table;

  00021	48 8b 44 24 70	 mov	 rax, QWORD PTR so$[rsp]
  00026	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0002a	48 89 44 24 38	 mov	 QWORD PTR table$[rsp], rax

; 85   :     register setentry *entry;
; 86   :     register int cmp;
; 87   :     PyObject *startkey;
; 88   : 
; 89   :     i = (size_t)hash & mask;

  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$[rsp]
  00034	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hash$[rsp]
  0003c	48 23 c8	 and	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 90   :     entry = &table[i];

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0004c	48 6b c0 10	 imul	 rax, 16
  00050	48 8b 4c 24 38	 mov	 rcx, QWORD PTR table$[rsp]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 44 24 48	 mov	 QWORD PTR entry$[rsp], rax

; 91   :     if (entry->key == NULL || entry->key == key)

  00060	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  00065	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0006a	74 10		 je	 SHORT $LN21@set_lookke@2
  0006c	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  00071	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  00076	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  0007a	75 0a		 jne	 SHORT $LN22@set_lookke@2
$LN21@set_lookke@2:

; 92   :         return entry;

  0007c	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  00081	e9 54 02 00 00	 jmp	 $LN23@set_lookke@2
$LN22@set_lookke@2:

; 93   : 
; 94   :     if (entry->key == dummy)

  00086	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  00092	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00096	75 0f		 jne	 SHORT $LN20@set_lookke@2

; 95   :         freeslot = entry;

  00098	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  0009d	48 89 44 24 58	 mov	 QWORD PTR freeslot$[rsp], rax

; 96   :     else {

  000a2	e9 b7 00 00 00	 jmp	 $LN19@set_lookke@2
$LN20@set_lookke@2:

; 97   :         if (entry->hash == hash) {

  000a7	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  000ac	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hash$[rsp]
  000b4	48 39 08	 cmp	 QWORD PTR [rax], rcx
  000b7	0f 85 98 00 00
	00		 jne	 $LN18@set_lookke@2

; 98   :             startkey = entry->key;

  000bd	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  000c2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c6	48 89 44 24 40	 mov	 QWORD PTR startkey$[rsp], rax

; 99   :             Py_INCREF(startkey);

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR startkey$[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_IncRef

; 100  :             cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);

  000d5	41 b8 02 00 00
	00		 mov	 r8d, 2
  000db	48 8b 54 24 78	 mov	 rdx, QWORD PTR key$[rsp]
  000e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR startkey$[rsp]
  000e5	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000ea	89 44 24 50	 mov	 DWORD PTR cmp$[rsp], eax

; 101  :             Py_DECREF(startkey);

  000ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR startkey$[rsp]
  000f3	e8 00 00 00 00	 call	 _Py_DecRef

; 102  :             if (cmp < 0)

  000f8	83 7c 24 50 00	 cmp	 DWORD PTR cmp$[rsp], 0
  000fd	7d 07		 jge	 SHORT $LN17@set_lookke@2

; 103  :                 return NULL;

  000ff	33 c0		 xor	 eax, eax
  00101	e9 d4 01 00 00	 jmp	 $LN23@set_lookke@2
$LN17@set_lookke@2:

; 104  :             if (table == so->table && entry->key == startkey) {

  00106	48 8b 44 24 70	 mov	 rax, QWORD PTR so$[rsp]
  0010b	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0010f	48 39 44 24 38	 cmp	 QWORD PTR table$[rsp], rax
  00114	75 23		 jne	 SHORT $LN16@set_lookke@2
  00116	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  0011b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR startkey$[rsp]
  00120	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00124	75 13		 jne	 SHORT $LN16@set_lookke@2

; 105  :                 if (cmp > 0)

  00126	83 7c 24 50 00	 cmp	 DWORD PTR cmp$[rsp], 0
  0012b	7e 0a		 jle	 SHORT $LN15@set_lookke@2

; 106  :                     return entry;

  0012d	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  00132	e9 a3 01 00 00	 jmp	 $LN23@set_lookke@2
$LN15@set_lookke@2:

; 107  :             }
; 108  :             else {

  00137	eb 1c		 jmp	 SHORT $LN14@set_lookke@2
$LN16@set_lookke@2:

; 109  :                 /* The compare did major nasty stuff to the
; 110  :                  * set:  start over.
; 111  :                  */
; 112  :                 return set_lookkey(so, key, hash);

  00139	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR hash$[rsp]
  00141	48 8b 54 24 78	 mov	 rdx, QWORD PTR key$[rsp]
  00146	48 8b 4c 24 70	 mov	 rcx, QWORD PTR so$[rsp]
  0014b	e8 00 00 00 00	 call	 set_lookkey
  00150	e9 85 01 00 00	 jmp	 $LN23@set_lookke@2
$LN14@set_lookke@2:
$LN18@set_lookke@2:

; 113  :             }
; 114  :         }
; 115  :         freeslot = NULL;

  00155	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR freeslot$[rsp], 0
$LN19@set_lookke@2:

; 116  :     }
; 117  : 
; 118  :     /* In the loop, key == dummy is by far (factor of 100s) the
; 119  :        least likely outcome, so test for that last. */
; 120  :     for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {

  0015e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR hash$[rsp]
  00166	48 89 44 24 30	 mov	 QWORD PTR perturb$[rsp], rax
  0016b	eb 0e		 jmp	 SHORT $LN13@set_lookke@2
$LN12@set_lookke@2:
  0016d	48 8b 44 24 30	 mov	 rax, QWORD PTR perturb$[rsp]
  00172	48 c1 e8 05	 shr	 rax, 5
  00176	48 89 44 24 30	 mov	 QWORD PTR perturb$[rsp], rax
$LN13@set_lookke@2:

; 121  :         i = (i << 2) + i + perturb + 1;

  0017b	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00180	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00185	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  00189	48 8b 4c 24 30	 mov	 rcx, QWORD PTR perturb$[rsp]
  0018e	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  00193	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 122  :         entry = &table[i & mask];

  00198	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$[rsp]
  0019d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  001a2	48 23 c8	 and	 rcx, rax
  001a5	48 8b c1	 mov	 rax, rcx
  001a8	48 6b c0 10	 imul	 rax, 16
  001ac	48 8b 4c 24 38	 mov	 rcx, QWORD PTR table$[rsp]
  001b1	48 03 c8	 add	 rcx, rax
  001b4	48 8b c1	 mov	 rax, rcx
  001b7	48 89 44 24 48	 mov	 QWORD PTR entry$[rsp], rax

; 123  :         if (entry->key == NULL) {

  001bc	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  001c1	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  001c6	75 17		 jne	 SHORT $LN10@set_lookke@2

; 124  :             if (freeslot != NULL)

  001c8	48 83 7c 24 58
	00		 cmp	 QWORD PTR freeslot$[rsp], 0
  001ce	74 0a		 je	 SHORT $LN9@set_lookke@2

; 125  :                 entry = freeslot;

  001d0	48 8b 44 24 58	 mov	 rax, QWORD PTR freeslot$[rsp]
  001d5	48 89 44 24 48	 mov	 QWORD PTR entry$[rsp], rax
$LN9@set_lookke@2:

; 126  :             break;

  001da	e9 f6 00 00 00	 jmp	 $LN11@set_lookke@2
$LN10@set_lookke@2:

; 127  :         }
; 128  :         if (entry->key == key)

  001df	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  001e4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  001e9	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  001ed	75 05		 jne	 SHORT $LN8@set_lookke@2

; 129  :             break;

  001ef	e9 e1 00 00 00	 jmp	 $LN11@set_lookke@2
$LN8@set_lookke@2:

; 130  :         if (entry->hash == hash && entry->key != dummy) {

  001f4	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  001f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hash$[rsp]
  00201	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00204	0f 85 a2 00 00
	00		 jne	 $LN7@set_lookke@2
  0020a	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  0020f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  00216	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  0021a	0f 84 8c 00 00
	00		 je	 $LN7@set_lookke@2

; 131  :             startkey = entry->key;

  00220	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  00225	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00229	48 89 44 24 40	 mov	 QWORD PTR startkey$[rsp], rax

; 132  :             Py_INCREF(startkey);

  0022e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR startkey$[rsp]
  00233	e8 00 00 00 00	 call	 _Py_IncRef

; 133  :             cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);

  00238	41 b8 02 00 00
	00		 mov	 r8d, 2
  0023e	48 8b 54 24 78	 mov	 rdx, QWORD PTR key$[rsp]
  00243	48 8b 4c 24 40	 mov	 rcx, QWORD PTR startkey$[rsp]
  00248	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0024d	89 44 24 50	 mov	 DWORD PTR cmp$[rsp], eax

; 134  :             Py_DECREF(startkey);

  00251	48 8b 4c 24 40	 mov	 rcx, QWORD PTR startkey$[rsp]
  00256	e8 00 00 00 00	 call	 _Py_DecRef

; 135  :             if (cmp < 0)

  0025b	83 7c 24 50 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00260	7d 04		 jge	 SHORT $LN6@set_lookke@2

; 136  :                 return NULL;

  00262	33 c0		 xor	 eax, eax
  00264	eb 74		 jmp	 SHORT $LN23@set_lookke@2
$LN6@set_lookke@2:

; 137  :             if (table == so->table && entry->key == startkey) {

  00266	48 8b 44 24 70	 mov	 rax, QWORD PTR so$[rsp]
  0026b	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0026f	48 39 44 24 38	 cmp	 QWORD PTR table$[rsp], rax
  00274	75 1b		 jne	 SHORT $LN5@set_lookke@2
  00276	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  0027b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR startkey$[rsp]
  00280	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00284	75 0b		 jne	 SHORT $LN5@set_lookke@2

; 138  :                 if (cmp > 0)

  00286	83 7c 24 50 00	 cmp	 DWORD PTR cmp$[rsp], 0
  0028b	7e 02		 jle	 SHORT $LN4@set_lookke@2

; 139  :                     break;

  0028d	eb 46		 jmp	 SHORT $LN11@set_lookke@2
$LN4@set_lookke@2:

; 140  :             }
; 141  :             else {

  0028f	eb 19		 jmp	 SHORT $LN3@set_lookke@2
$LN5@set_lookke@2:

; 142  :                 /* The compare did major nasty stuff to the
; 143  :                  * set:  start over.
; 144  :                  */
; 145  :                 return set_lookkey(so, key, hash);

  00291	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR hash$[rsp]
  00299	48 8b 54 24 78	 mov	 rdx, QWORD PTR key$[rsp]
  0029e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR so$[rsp]
  002a3	e8 00 00 00 00	 call	 set_lookkey
  002a8	eb 30		 jmp	 SHORT $LN23@set_lookke@2
$LN3@set_lookke@2:

; 146  :             }

  002aa	eb 24		 jmp	 SHORT $LN2@set_lookke@2
$LN7@set_lookke@2:

; 147  :         }
; 148  :         else if (entry->key == dummy && freeslot == NULL)

  002ac	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  002b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  002b8	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  002bc	75 12		 jne	 SHORT $LN1@set_lookke@2
  002be	48 83 7c 24 58
	00		 cmp	 QWORD PTR freeslot$[rsp], 0
  002c4	75 0a		 jne	 SHORT $LN1@set_lookke@2

; 149  :             freeslot = entry;

  002c6	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
  002cb	48 89 44 24 58	 mov	 QWORD PTR freeslot$[rsp], rax
$LN1@set_lookke@2:
$LN2@set_lookke@2:

; 150  :     }

  002d0	e9 98 fe ff ff	 jmp	 $LN12@set_lookke@2
$LN11@set_lookke@2:

; 151  :     return entry;

  002d5	48 8b 44 24 48	 mov	 rax, QWORD PTR entry$[rsp]
$LN23@set_lookke@2:

; 152  : }

  002da	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002de	c3		 ret	 0
set_lookkey ENDP
_TEXT	ENDS
PUBLIC	PySet_ClearFreeList
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_ClearFreeList DD imagerel $LN6
	DD	imagerel $LN6+94
	DD	imagerel $unwind$PySet_ClearFreeList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_ClearFreeList DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySet_ClearFreeList
_TEXT	SEGMENT
freelist_size$ = 32
so$ = 40
PySet_ClearFreeList PROC				; COMDAT

; 1116 : {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1117 :     int freelist_size = numfree;

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  0000a	89 44 24 20	 mov	 DWORD PTR freelist_size$[rsp], eax

; 1118 :     PySetObject *so;
; 1119 :     if (Py_PXCTX)

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 04		 je	 SHORT $LN3@PySet_Clea

; 1120 :         return 0;

  00017	33 c0		 xor	 eax, eax
  00019	eb 3e		 jmp	 SHORT $LN4@PySet_Clea
$LN3@PySet_Clea:
$LN2@PySet_Clea:

; 1121 : 
; 1122 :     while (numfree) {

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR numfree, 0
  00022	74 31		 je	 SHORT $LN1@PySet_Clea

; 1123 :         numfree--;

  00024	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  0002a	ff c8		 dec	 eax
  0002c	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax

; 1124 :         so = free_list[numfree];

  00032	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR numfree
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:free_list
  00040	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00044	48 89 44 24 28	 mov	 QWORD PTR so$[rsp], rax

; 1125 :         PyObject_GC_Del(so);

  00049	48 8b 4c 24 28	 mov	 rcx, QWORD PTR so$[rsp]
  0004e	e8 00 00 00 00	 call	 PyObject_GC_Del

; 1126 :     }

  00053	eb c6		 jmp	 SHORT $LN2@PySet_Clea
$LN1@PySet_Clea:

; 1127 :     return freelist_size;

  00055	8b 44 24 20	 mov	 eax, DWORD PTR freelist_size$[rsp]
$LN4@PySet_Clea:

; 1128 : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
PySet_ClearFreeList ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LHFKIDLH@PySet_Fini?$AA@		; `string'
PUBLIC	PySet_Fini
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Fini DD imagerel $LN11
	DD	imagerel $LN11+200
	DD	imagerel $unwind$PySet_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Fini DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0L@LHFKIDLH@PySet_Fini?$AA@
CONST	SEGMENT
??_C@_0L@LHFKIDLH@PySet_Fini?$AA@ DB 'PySet_Fini', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySet_Fini
_TEXT	SEGMENT
_py_tmp$21318 = 48
_py_tmp$21326 = 56
PySet_Fini PROC						; COMDAT

; 1132 : {

$LN11:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1133 :     PySet_ClearFreeList();

  00004	e8 00 00 00 00	 call	 PySet_ClearFreeList
$LN8@PySet_Fini:

; 1134 :     Py_CLEAR(dummy);

  00009	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR dummy, 0
  00011	74 4d		 je	 SHORT $LN5@PySet_Fini
  00013	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0001b	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR dummy
  00022	41 b8 6e 04 00
	00		 mov	 r8d, 1134		; 0000046eH
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LHFKIDLH@PySet_Fini?$AA@
  00036	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003b	85 c0		 test	 eax, eax
  0003d	75 21		 jne	 SHORT $LN5@PySet_Fini
  0003f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dummy
  00046	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$21318[rsp], rax
  0004b	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR dummy, 0
  00056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$21318[rsp]
  0005b	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@PySet_Fini:
  00060	33 c0		 xor	 eax, eax
  00062	85 c0		 test	 eax, eax
  00064	75 a3		 jne	 SHORT $LN8@PySet_Fini
$LN4@PySet_Fini:

; 1135 :     Py_CLEAR(emptyfrozenset);

  00066	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR emptyfrozenset, 0
  0006e	74 4d		 je	 SHORT $LN1@PySet_Fini
  00070	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00078	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR emptyfrozenset
  0007f	41 b8 6f 04 00
	00		 mov	 r8d, 1135		; 0000046fH
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LHFKIDLH@PySet_Fini?$AA@
  00093	e8 00 00 00 00	 call	 _PyParallel_Guard
  00098	85 c0		 test	 eax, eax
  0009a	75 21		 jne	 SHORT $LN1@PySet_Fini
  0009c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR emptyfrozenset
  000a3	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$21326[rsp], rax
  000a8	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR emptyfrozenset, 0
  000b3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$21326[rsp]
  000b8	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PySet_Fini:
  000bd	33 c0		 xor	 eax, eax
  000bf	85 c0		 test	 eax, eax
  000c1	75 a3		 jne	 SHORT $LN4@PySet_Fini

; 1136 : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
PySet_Fini ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@IMKAHDMA@free?5PySetObject?$AA@	; `string'
PUBLIC	_PySet_DebugMallocStats
EXTRN	_PyDebugAllocatorStats:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PySet_DebugMallocStats DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$_PySet_DebugMallocStats
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PySet_DebugMallocStats DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BB@IMKAHDMA@free?5PySetObject?$AA@
CONST	SEGMENT
??_C@_0BB@IMKAHDMA@free?5PySetObject?$AA@ DB 'free PySetObject', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PySet_DebugMallocStats
_TEXT	SEGMENT
out$ = 48
_PySet_DebugMallocStats PROC				; COMDAT

; 1141 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1142 :     _PyDebugAllocatorStats(out,
; 1143 :                            "free PySetObject",
; 1144 :                            numfree, sizeof(PySetObject));

  00009	41 b9 20 01 00
	00		 mov	 r9d, 288		; 00000120H
  0000f	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR numfree
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@IMKAHDMA@free?5PySetObject?$AA@
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00022	e8 00 00 00 00	 call	 _PyDebugAllocatorStats

; 1145 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
_PySet_DebugMallocStats ENDP
_TEXT	ENDS
PUBLIC	??_C@_05EBMGGHG@set?$CI?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_new DD imagerel set_new
	DD	imagerel set_new+75
	DD	imagerel $unwind$set_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_new DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_05EBMGGHG@set?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_05EBMGGHG@set?$CI?$CJ?$AA@ DB 'set()', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_new
_TEXT	SEGMENT
type$ = 48
args$ = 56
kwds$ = 64
set_new	PROC						; COMDAT

; 1150 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1151 :     if (type == &PySet_Type && !_PyArg_NoKeywords("set()", kwds))

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0001a	48 39 44 24 30	 cmp	 QWORD PTR type$[rsp], rax
  0001f	75 19		 jne	 SHORT $LN1@set_new
  00021	48 8b 54 24 40	 mov	 rdx, QWORD PTR kwds$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05EBMGGHG@set?$CI?$CJ?$AA@
  0002d	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00032	85 c0		 test	 eax, eax
  00034	75 04		 jne	 SHORT $LN1@set_new

; 1152 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 0c		 jmp	 SHORT $LN2@set_new
$LN1@set_new:

; 1153 : 
; 1154 :     return make_new_set(type, NULL);

  0003a	33 d2		 xor	 edx, edx
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR type$[rsp]
  00041	e8 00 00 00 00	 call	 make_new_set
$LN2@set_new:

; 1155 : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
set_new	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_copy DD imagerel set_copy
	DD	imagerel set_copy+33
	DD	imagerel $unwind$set_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_copy DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_copy
_TEXT	SEGMENT
so$ = 48
set_copy PROC						; COMDAT

; 1210 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1211 :     return make_new_set_basetype(Py_TYPE(so), (PyObject *)so);

  00009	48 8b 54 24 30	 mov	 rdx, QWORD PTR so$[rsp]
  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR so$[rsp]
  00013	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00017	e8 00 00 00 00	 call	 make_new_set_basetype

; 1212 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
set_copy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_new_set_basetype DD imagerel make_new_set_basetype
	DD	imagerel make_new_set_basetype+109
	DD	imagerel $unwind$make_new_set_basetype
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_new_set_basetype DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT make_new_set_basetype
_TEXT	SEGMENT
type$ = 48
iterable$ = 56
make_new_set_basetype PROC				; COMDAT

; 1069 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1070 :     if (type != &PySet_Type && type != &PyFrozenSet_Type) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 39 44 24 30	 cmp	 QWORD PTR type$[rsp], rax
  0001a	74 3d		 je	 SHORT $LN3@make_new_s@2
  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00023	48 39 44 24 30	 cmp	 QWORD PTR type$[rsp], rax
  00028	74 2f		 je	 SHORT $LN3@make_new_s@2

; 1071 :         if (PyType_IsSubtype(type, &PySet_Type))

  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR type$[rsp]
  00036	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003b	85 c0		 test	 eax, eax
  0003d	74 0e		 je	 SHORT $LN2@make_new_s@2

; 1072 :             type = &PySet_Type;

  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00046	48 89 44 24 30	 mov	 QWORD PTR type$[rsp], rax

; 1073 :         else

  0004b	eb 0c		 jmp	 SHORT $LN1@make_new_s@2
$LN2@make_new_s@2:

; 1074 :             type = &PyFrozenSet_Type;

  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00054	48 89 44 24 30	 mov	 QWORD PTR type$[rsp], rax
$LN1@make_new_s@2:
$LN3@make_new_s@2:

; 1075 :     }
; 1076 :     return make_new_set(type, iterable);

  00059	48 8b 54 24 38	 mov	 rdx, QWORD PTR iterable$[rsp]
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR type$[rsp]
  00063	e8 00 00 00 00	 call	 make_new_set

; 1077 : }

  00068	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006c	c3		 ret	 0
make_new_set_basetype ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$frozenset_copy DD imagerel frozenset_copy
	DD	imagerel frozenset_copy+59
	DD	imagerel $unwind$frozenset_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$frozenset_copy DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT frozenset_copy
_TEXT	SEGMENT
so$ = 48
frozenset_copy PROC					; COMDAT

; 1216 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1217 :     if (PyFrozenSet_CheckExact(so)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	75 11		 jne	 SHORT $LN1@frozenset_@3

; 1218 :         Py_INCREF(so);

  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  00020	e8 00 00 00 00	 call	 _Py_IncRef

; 1219 :         return (PyObject *)so;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR so$[rsp]
  0002a	eb 0a		 jmp	 SHORT $LN2@frozenset_@3
$LN1@frozenset_@3:

; 1220 :     }
; 1221 :     return set_copy(so);

  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  00031	e8 00 00 00 00	 call	 set_copy
$LN2@frozenset_@3:

; 1222 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
frozenset_copy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_clear DD imagerel set_clear
	DD	imagerel set_clear+43
	DD	imagerel $unwind$set_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_clear DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_clear
_TEXT	SEGMENT
so$ = 48
set_clear PROC						; COMDAT

; 1228 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1229 :     set_clear_internal(so);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  0000e	e8 00 00 00 00	 call	 set_clear_internal

; 1230 :     Py_RETURN_NONE;

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0001a	e8 00 00 00 00	 call	 _Py_IncRef
  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1231 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
set_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_union DD imagerel set_union
	DD	imagerel set_union+161
	DD	imagerel $unwind$set_union
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_union DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_union
_TEXT	SEGMENT
i$ = 32
other$ = 40
result$ = 48
so$ = 80
args$ = 88
set_union PROC						; COMDAT

; 1237 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1238 :     PySetObject *result;
; 1239 :     PyObject *other;
; 1240 :     Py_ssize_t i;
; 1241 : 
; 1242 :     result = (PySetObject *)set_copy(so);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00013	e8 00 00 00 00	 call	 set_copy
  00018	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1243 :     if (result == NULL)

  0001d	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00023	75 04		 jne	 SHORT $LN6@set_union

; 1244 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 73		 jmp	 SHORT $LN7@set_union
$LN6@set_union:

; 1245 : 
; 1246 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00029	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00032	eb 0d		 jmp	 SHORT $LN5@set_union
$LN4@set_union:
  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00039	48 ff c0	 inc	 rax
  0003c	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN5@set_union:
  00041	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00046	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004a	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0004f	7d 46		 jge	 SHORT $LN3@set_union

; 1247 :         other = PyTuple_GET_ITEM(args, i);

  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00056	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0005b	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00060	48 89 44 24 28	 mov	 QWORD PTR other$[rsp], rax

; 1248 :         if ((PyObject *)so == other)

  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR other$[rsp]
  0006a	48 39 44 24 50	 cmp	 QWORD PTR so$[rsp], rax
  0006f	75 02		 jne	 SHORT $LN2@set_union

; 1249 :             continue;

  00071	eb c1		 jmp	 SHORT $LN4@set_union
$LN2@set_union:

; 1250 :         if (set_update_internal(result, other) == -1) {

  00073	48 8b 54 24 28	 mov	 rdx, QWORD PTR other$[rsp]
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  0007d	e8 00 00 00 00	 call	 set_update_internal
  00082	83 f8 ff	 cmp	 eax, -1
  00085	75 0e		 jne	 SHORT $LN1@set_union

; 1251 :             Py_DECREF(result);

  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  0008c	e8 00 00 00 00	 call	 _Py_DecRef

; 1252 :             return NULL;

  00091	33 c0		 xor	 eax, eax
  00093	eb 07		 jmp	 SHORT $LN7@set_union
$LN1@set_union:

; 1253 :         }
; 1254 :     }

  00095	eb 9d		 jmp	 SHORT $LN4@set_union
$LN3@set_union:

; 1255 :     return (PyObject *)result;

  00097	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN7@set_union:

; 1256 : }

  0009c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a0	c3		 ret	 0
set_union ENDP
_TEXT	ENDS
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_or DD imagerel set_or
	DD	imagerel set_or+297
	DD	imagerel $unwind$set_or
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_or DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_or
_TEXT	SEGMENT
result$ = 32
so$ = 64
other$ = 72
set_or	PROC						; COMDAT

; 1265 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1266 :     PySetObject *result;
; 1267 : 
; 1268 :     if (!PyAnySet_Check(so) || !PyAnySet_Check(other))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 44		 je	 SHORT $LN4@set_or
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 32		 je	 SHORT $LN4@set_or
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 19		 jne	 SHORT $LN4@set_or
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	74 56		 je	 SHORT $LN5@set_or
$LN4@set_or:
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0006b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  00070	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00074	74 59		 je	 SHORT $LN6@set_or
  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0007d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  00082	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00086	74 47		 je	 SHORT $LN6@set_or
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0008f	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  00094	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00098	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009d	85 c0		 test	 eax, eax
  0009f	75 2e		 jne	 SHORT $LN6@set_or
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  000a8	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  000ad	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000b1	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b6	85 c0		 test	 eax, eax
  000b8	75 15		 jne	 SHORT $LN6@set_or
$LN5@set_or:

; 1269 :         Py_RETURN_NOTIMPLEMENTED;

  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  000c1	e8 00 00 00 00	 call	 _Py_IncRef
  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000cd	eb 55		 jmp	 SHORT $LN7@set_or
$LN6@set_or:

; 1270 : 
; 1271 :     result = (PySetObject *)set_copy(so);

  000cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  000d4	e8 00 00 00 00	 call	 set_copy
  000d9	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1272 :     if (result == NULL)

  000de	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  000e4	75 04		 jne	 SHORT $LN3@set_or

; 1273 :         return NULL;

  000e6	33 c0		 xor	 eax, eax
  000e8	eb 3a		 jmp	 SHORT $LN7@set_or
$LN3@set_or:

; 1274 :     if ((PyObject *)so == other)

  000ea	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  000ef	48 39 44 24 40	 cmp	 QWORD PTR so$[rsp], rax
  000f4	75 07		 jne	 SHORT $LN2@set_or

; 1275 :         return (PyObject *)result;

  000f6	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000fb	eb 27		 jmp	 SHORT $LN7@set_or
$LN2@set_or:

; 1276 :     if (set_update_internal(result, other) == -1) {

  000fd	48 8b 54 24 48	 mov	 rdx, QWORD PTR other$[rsp]
  00102	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00107	e8 00 00 00 00	 call	 set_update_internal
  0010c	83 f8 ff	 cmp	 eax, -1
  0010f	75 0e		 jne	 SHORT $LN1@set_or

; 1277 :         Py_DECREF(result);

  00111	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00116	e8 00 00 00 00	 call	 _Py_DecRef

; 1278 :         return NULL;

  0011b	33 c0		 xor	 eax, eax
  0011d	eb 05		 jmp	 SHORT $LN7@set_or
$LN1@set_or:

; 1279 :     }
; 1280 :     return (PyObject *)result;

  0011f	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN7@set_or:

; 1281 : }

  00124	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00128	c3		 ret	 0
set_or	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_ior DD imagerel set_ior
	DD	imagerel set_ior+165
	DD	imagerel $unwind$set_ior
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_ior DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_ior
_TEXT	SEGMENT
so$ = 48
other$ = 56
set_ior	PROC						; COMDAT

; 1285 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1286 :     if (!PyAnySet_Check(other))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 59		 je	 SHORT $LN2@set_ior
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 47		 je	 SHORT $LN2@set_ior
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 2e		 jne	 SHORT $LN2@set_ior
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 15		 jne	 SHORT $LN2@set_ior

; 1287 :         Py_RETURN_NOTIMPLEMENTED;

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00077	eb 27		 jmp	 SHORT $LN3@set_ior
$LN2@set_ior:

; 1288 : 
; 1289 :     if (set_update_internal(so, other) == -1)

  00079	48 8b 54 24 38	 mov	 rdx, QWORD PTR other$[rsp]
  0007e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  00083	e8 00 00 00 00	 call	 set_update_internal
  00088	83 f8 ff	 cmp	 eax, -1
  0008b	75 04		 jne	 SHORT $LN1@set_ior

; 1290 :         return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 0f		 jmp	 SHORT $LN3@set_ior
$LN1@set_ior:

; 1291 :     Py_INCREF(so);

  00091	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  00096	e8 00 00 00 00	 call	 _Py_IncRef

; 1292 :     return (PyObject *)so;

  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR so$[rsp]
$LN3@set_ior:

; 1293 : }

  000a0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a4	c3		 ret	 0
set_ior	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_intersection_multi DD imagerel set_intersection_multi
	DD	imagerel set_intersection_multi+195
	DD	imagerel $unwind$set_intersection_multi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_intersection_multi DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_intersection_multi
_TEXT	SEGMENT
i$ = 32
result$ = 40
other$21557 = 48
newresult$21559 = 56
so$ = 80
args$ = 88
set_intersection_multi PROC				; COMDAT

; 1380 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1381 :     Py_ssize_t i;
; 1382 :     PyObject *result = (PyObject *)so;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1383 : 
; 1384 :     if (PyTuple_GET_SIZE(args) == 0)

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  0001d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00022	75 0f		 jne	 SHORT $LN5@set_inters

; 1385 :         return set_copy(so);

  00024	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00029	e8 00 00 00 00	 call	 set_copy
  0002e	e9 8b 00 00 00	 jmp	 $LN6@set_inters
$LN5@set_inters:

; 1386 : 
; 1387 :     Py_INCREF(so);

  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00038	e8 00 00 00 00	 call	 _Py_IncRef

; 1388 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  0003d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00046	eb 0d		 jmp	 SHORT $LN4@set_inters
$LN3@set_inters:
  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0004d	48 ff c0	 inc	 rax
  00050	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@set_inters:
  00055	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  0005a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0005e	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00063	7d 54		 jge	 SHORT $LN2@set_inters

; 1389 :         PyObject *other = PyTuple_GET_ITEM(args, i);

  00065	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0006f	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00074	48 89 44 24 30	 mov	 QWORD PTR other$21557[rsp], rax

; 1390 :         PyObject *newresult = set_intersection((PySetObject *)result, other);

  00079	48 8b 54 24 30	 mov	 rdx, QWORD PTR other$21557[rsp]
  0007e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00083	e8 00 00 00 00	 call	 set_intersection
  00088	48 89 44 24 38	 mov	 QWORD PTR newresult$21559[rsp], rax

; 1391 :         if (newresult == NULL) {

  0008d	48 83 7c 24 38
	00		 cmp	 QWORD PTR newresult$21559[rsp], 0
  00093	75 0e		 jne	 SHORT $LN1@set_inters

; 1392 :             Py_DECREF(result);

  00095	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  0009a	e8 00 00 00 00	 call	 _Py_DecRef

; 1393 :             return NULL;

  0009f	33 c0		 xor	 eax, eax
  000a1	eb 1b		 jmp	 SHORT $LN6@set_inters
$LN1@set_inters:

; 1394 :         }
; 1395 :         Py_DECREF(result);

  000a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  000a8	e8 00 00 00 00	 call	 _Py_DecRef

; 1396 :         result = newresult;

  000ad	48 8b 44 24 38	 mov	 rax, QWORD PTR newresult$21559[rsp]
  000b2	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1397 :     }

  000b7	eb 8f		 jmp	 SHORT $LN3@set_inters
$LN2@set_inters:

; 1398 :     return result;

  000b9	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN6@set_inters:

; 1399 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
set_intersection_multi ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_intersection DD imagerel set_intersection
	DD	imagerel set_intersection+730
	DD	imagerel $unwind$set_intersection
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_intersection DD 010e01H
	DD	0e20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_intersection
_TEXT	SEGMENT
it$ = 32
tmp$ = 40
key$ = 48
result$ = 56
entry$21489 = 64
pos$21488 = 72
rv$21499 = 80
rv$21516 = 84
hash$21518 = 88
entry$21517 = 96
so$ = 128
other$ = 136
set_intersection PROC					; COMDAT

; 1297 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1298 :     PySetObject *result;
; 1299 :     PyObject *key, *it, *tmp;
; 1300 : 
; 1301 :     if ((PyObject *)so == other)

  0000e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  00016	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR so$[rsp], rax
  0001e	75 12		 jne	 SHORT $LN18@set_inters@2

; 1302 :         return set_copy(so);

  00020	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00028	e8 00 00 00 00	 call	 set_copy
  0002d	e9 a3 02 00 00	 jmp	 $LN19@set_inters@2
$LN18@set_inters@2:

; 1303 : 
; 1304 :     result = (PySetObject *)make_new_set_basetype(Py_TYPE(so), NULL);

  00032	33 d2		 xor	 edx, edx
  00034	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  0003c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00040	e8 00 00 00 00	 call	 make_new_set_basetype
  00045	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 1305 :     if (result == NULL)

  0004a	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  00050	75 07		 jne	 SHORT $LN17@set_inters@2

; 1306 :         return NULL;

  00052	33 c0		 xor	 eax, eax
  00054	e9 7c 02 00 00	 jmp	 $LN19@set_inters@2
$LN17@set_inters@2:

; 1307 : 
; 1308 :     if (PyAnySet_Check(other)) {

  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00060	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  00068	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0006c	74 51		 je	 SHORT $LN15@set_inters@2
  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00075	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  0007d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00081	74 3c		 je	 SHORT $LN15@set_inters@2
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0008a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  00092	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00096	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009b	85 c0		 test	 eax, eax
  0009d	75 20		 jne	 SHORT $LN15@set_inters@2
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  000a6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  000ae	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000b2	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b7	85 c0		 test	 eax, eax
  000b9	0f 84 ce 00 00
	00		 je	 $LN16@set_inters@2
$LN15@set_inters@2:

; 1309 :         Py_ssize_t pos = 0;

  000bf	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR pos$21488[rsp], 0

; 1310 :         setentry *entry;
; 1311 : 
; 1312 :         if (PySet_GET_SIZE(other) > PySet_GET_SIZE(so)) {

  000c8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  000d0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  000d8	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000dc	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  000e0	7e 2a		 jle	 SHORT $LN14@set_inters@2

; 1313 :             tmp = (PyObject *)so;

  000e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  000ea	48 89 44 24 28	 mov	 QWORD PTR tmp$[rsp], rax

; 1314 :             so = (PySetObject *)other;

  000ef	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  000f7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR so$[rsp], rax

; 1315 :             other = tmp;

  000ff	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  00104	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR other$[rsp], rax
$LN14@set_inters@2:
$LN13@set_inters@2:

; 1316 :         }
; 1317 : 
; 1318 :         while (set_next((PySetObject *)other, &pos, &entry)) {

  0010c	4c 8d 44 24 40	 lea	 r8, QWORD PTR entry$21489[rsp]
  00111	48 8d 54 24 48	 lea	 rdx, QWORD PTR pos$21488[rsp]
  00116	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  0011e	e8 00 00 00 00	 call	 set_next
  00123	85 c0		 test	 eax, eax
  00125	74 5c		 je	 SHORT $LN12@set_inters@2

; 1319 :             int rv = set_contains_entry(so, entry);

  00127	48 8b 54 24 40	 mov	 rdx, QWORD PTR entry$21489[rsp]
  0012c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00134	e8 00 00 00 00	 call	 set_contains_entry
  00139	89 44 24 50	 mov	 DWORD PTR rv$21499[rsp], eax

; 1320 :             if (rv == -1) {

  0013d	83 7c 24 50 ff	 cmp	 DWORD PTR rv$21499[rsp], -1
  00142	75 11		 jne	 SHORT $LN11@set_inters@2

; 1321 :                 Py_DECREF(result);

  00144	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00149	e8 00 00 00 00	 call	 _Py_DecRef

; 1322 :                 return NULL;

  0014e	33 c0		 xor	 eax, eax
  00150	e9 80 01 00 00	 jmp	 $LN19@set_inters@2
$LN11@set_inters@2:

; 1323 :             }
; 1324 :             if (rv) {

  00155	83 7c 24 50 00	 cmp	 DWORD PTR rv$21499[rsp], 0
  0015a	74 25		 je	 SHORT $LN10@set_inters@2

; 1325 :                 if (set_add_entry(result, entry) == -1) {

  0015c	48 8b 54 24 40	 mov	 rdx, QWORD PTR entry$21489[rsp]
  00161	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00166	e8 00 00 00 00	 call	 set_add_entry
  0016b	83 f8 ff	 cmp	 eax, -1
  0016e	75 11		 jne	 SHORT $LN9@set_inters@2

; 1326 :                     Py_DECREF(result);

  00170	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00175	e8 00 00 00 00	 call	 _Py_DecRef

; 1327 :                     return NULL;

  0017a	33 c0		 xor	 eax, eax
  0017c	e9 54 01 00 00	 jmp	 $LN19@set_inters@2
$LN9@set_inters@2:
$LN10@set_inters@2:

; 1328 :                 }
; 1329 :             }
; 1330 :         }

  00181	eb 89		 jmp	 SHORT $LN13@set_inters@2
$LN12@set_inters@2:

; 1331 :         return (PyObject *)result;

  00183	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  00188	e9 48 01 00 00	 jmp	 $LN19@set_inters@2
$LN16@set_inters@2:

; 1332 :     }
; 1333 : 
; 1334 :     it = PyObject_GetIter(other);

  0018d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  00195	e8 00 00 00 00	 call	 PyObject_GetIter
  0019a	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 1335 :     if (it == NULL) {

  0019f	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  001a5	75 11		 jne	 SHORT $LN8@set_inters@2

; 1336 :         Py_DECREF(result);

  001a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  001ac	e8 00 00 00 00	 call	 _Py_DecRef

; 1337 :         return NULL;

  001b1	33 c0		 xor	 eax, eax
  001b3	e9 1d 01 00 00	 jmp	 $LN19@set_inters@2
$LN8@set_inters@2:
$LN7@set_inters@2:

; 1338 :     }
; 1339 : 
; 1340 :     while ((key = PyIter_Next(it)) != NULL) {

  001b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  001bd	e8 00 00 00 00	 call	 PyIter_Next
  001c2	48 89 44 24 30	 mov	 QWORD PTR key$[rsp], rax
  001c7	48 83 7c 24 30
	00		 cmp	 QWORD PTR key$[rsp], 0
  001cd	0f 84 db 00 00
	00		 je	 $LN6@set_inters@2

; 1341 :         int rv;
; 1342 :         setentry entry;
; 1343 :         Py_hash_t hash = PyObject_Hash(key);

  001d3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR key$[rsp]
  001d8	e8 00 00 00 00	 call	 PyObject_Hash
  001dd	48 89 44 24 58	 mov	 QWORD PTR hash$21518[rsp], rax

; 1344 : 
; 1345 :         if (hash == -1) {

  001e2	48 83 7c 24 58
	ff		 cmp	 QWORD PTR hash$21518[rsp], -1
  001e8	75 25		 jne	 SHORT $LN5@set_inters@2

; 1346 :             Py_DECREF(it);

  001ea	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  001ef	e8 00 00 00 00	 call	 _Py_DecRef

; 1347 :             Py_DECREF(result);

  001f4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  001f9	e8 00 00 00 00	 call	 _Py_DecRef

; 1348 :             Py_DECREF(key);

  001fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR key$[rsp]
  00203	e8 00 00 00 00	 call	 _Py_DecRef

; 1349 :             return NULL;

  00208	33 c0		 xor	 eax, eax
  0020a	e9 c6 00 00 00	 jmp	 $LN19@set_inters@2
$LN5@set_inters@2:

; 1350 :         }
; 1351 :         entry.hash = hash;

  0020f	48 8b 44 24 58	 mov	 rax, QWORD PTR hash$21518[rsp]
  00214	48 89 44 24 60	 mov	 QWORD PTR entry$21517[rsp], rax

; 1352 :         entry.key = key;

  00219	48 8b 44 24 30	 mov	 rax, QWORD PTR key$[rsp]
  0021e	48 89 44 24 68	 mov	 QWORD PTR entry$21517[rsp+8], rax

; 1353 :         rv = set_contains_entry(so, &entry);

  00223	48 8d 54 24 60	 lea	 rdx, QWORD PTR entry$21517[rsp]
  00228	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00230	e8 00 00 00 00	 call	 set_contains_entry
  00235	89 44 24 54	 mov	 DWORD PTR rv$21516[rsp], eax

; 1354 :         if (rv == -1) {

  00239	83 7c 24 54 ff	 cmp	 DWORD PTR rv$21516[rsp], -1
  0023e	75 22		 jne	 SHORT $LN4@set_inters@2

; 1355 :             Py_DECREF(it);

  00240	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00245	e8 00 00 00 00	 call	 _Py_DecRef

; 1356 :             Py_DECREF(result);

  0024a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  0024f	e8 00 00 00 00	 call	 _Py_DecRef

; 1357 :             Py_DECREF(key);

  00254	48 8b 4c 24 30	 mov	 rcx, QWORD PTR key$[rsp]
  00259	e8 00 00 00 00	 call	 _Py_DecRef

; 1358 :             return NULL;

  0025e	33 c0		 xor	 eax, eax
  00260	eb 73		 jmp	 SHORT $LN19@set_inters@2
$LN4@set_inters@2:

; 1359 :         }
; 1360 :         if (rv) {

  00262	83 7c 24 54 00	 cmp	 DWORD PTR rv$21516[rsp], 0
  00267	74 36		 je	 SHORT $LN3@set_inters@2

; 1361 :             if (set_add_entry(result, &entry) == -1) {

  00269	48 8d 54 24 60	 lea	 rdx, QWORD PTR entry$21517[rsp]
  0026e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00273	e8 00 00 00 00	 call	 set_add_entry
  00278	83 f8 ff	 cmp	 eax, -1
  0027b	75 22		 jne	 SHORT $LN2@set_inters@2

; 1362 :                 Py_DECREF(it);

  0027d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00282	e8 00 00 00 00	 call	 _Py_DecRef

; 1363 :                 Py_DECREF(result);

  00287	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  0028c	e8 00 00 00 00	 call	 _Py_DecRef

; 1364 :                 Py_DECREF(key);

  00291	48 8b 4c 24 30	 mov	 rcx, QWORD PTR key$[rsp]
  00296	e8 00 00 00 00	 call	 _Py_DecRef

; 1365 :                 return NULL;

  0029b	33 c0		 xor	 eax, eax
  0029d	eb 36		 jmp	 SHORT $LN19@set_inters@2
$LN2@set_inters@2:
$LN3@set_inters@2:

; 1366 :             }
; 1367 :         }
; 1368 :         Py_DECREF(key);

  0029f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR key$[rsp]
  002a4	e8 00 00 00 00	 call	 _Py_DecRef

; 1369 :     }

  002a9	e9 0a ff ff ff	 jmp	 $LN7@set_inters@2
$LN6@set_inters@2:

; 1370 :     Py_DECREF(it);

  002ae	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  002b3	e8 00 00 00 00	 call	 _Py_DecRef

; 1371 :     if (PyErr_Occurred()) {

  002b8	e8 00 00 00 00	 call	 PyErr_Occurred
  002bd	48 85 c0	 test	 rax, rax
  002c0	74 0e		 je	 SHORT $LN1@set_inters@2

; 1372 :         Py_DECREF(result);

  002c2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  002c7	e8 00 00 00 00	 call	 _Py_DecRef

; 1373 :         return NULL;

  002cc	33 c0		 xor	 eax, eax
  002ce	eb 05		 jmp	 SHORT $LN19@set_inters@2
$LN1@set_inters@2:

; 1374 :     }
; 1375 :     return (PyObject *)result;

  002d0	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN19@set_inters@2:

; 1376 : }

  002d5	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002d9	c3		 ret	 0
set_intersection ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_contains_entry DD imagerel set_contains_entry
	DD	imagerel set_contains_entry+130
	DD	imagerel $unwind$set_contains_entry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_contains_entry DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_contains_entry
_TEXT	SEGMENT
lu_entry$ = 32
key$ = 40
tv74 = 48
so$ = 80
entry$ = 88
set_contains_entry PROC					; COMDAT

; 691  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 692  :     PyObject *key;
; 693  :     setentry *lu_entry;
; 694  : 
; 695  :     lu_entry = (so->lookup)(so, entry->key, entry->hash);

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR entry$[rsp]
  00013	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00016	48 8b 44 24 58	 mov	 rax, QWORD PTR entry$[rsp]
  0001b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00029	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0002f	48 89 44 24 20	 mov	 QWORD PTR lu_entry$[rsp], rax

; 696  :     if (lu_entry == NULL)

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR lu_entry$[rsp], 0
  0003a	75 07		 jne	 SHORT $LN1@set_contai

; 697  :         return -1;

  0003c	b8 ff ff ff ff	 mov	 eax, -1
  00041	eb 3a		 jmp	 SHORT $LN2@set_contai
$LN1@set_contai:

; 698  :     key = lu_entry->key;

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR lu_entry$[rsp]
  00048	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004c	48 89 44 24 28	 mov	 QWORD PTR key$[rsp], rax

; 699  :     return key != NULL && key != dummy;

  00051	48 83 7c 24 28
	00		 cmp	 QWORD PTR key$[rsp], 0
  00057	74 18		 je	 SHORT $LN4@set_contai
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dummy
  00060	48 39 44 24 28	 cmp	 QWORD PTR key$[rsp], rax
  00065	74 0a		 je	 SHORT $LN4@set_contai
  00067	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0006f	eb 08		 jmp	 SHORT $LN5@set_contai
$LN4@set_contai:
  00071	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN5@set_contai:
  00079	8b 44 24 30	 mov	 eax, DWORD PTR tv74[rsp]
$LN2@set_contai:

; 700  : }

  0007d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00081	c3		 ret	 0
set_contains_entry ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_intersection_update_multi DD imagerel set_intersection_update_multi
	DD	imagerel set_intersection_update_multi+95
	DD	imagerel $unwind$set_intersection_update_multi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_intersection_update_multi DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_intersection_update_multi
_TEXT	SEGMENT
tmp$ = 32
so$ = 64
args$ = 72
set_intersection_update_multi PROC			; COMDAT

; 1421 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1422 :     PyObject *tmp;
; 1423 : 
; 1424 :     tmp = set_intersection_multi(so, args);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00018	e8 00 00 00 00	 call	 set_intersection_multi
  0001d	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 1425 :     if (tmp == NULL)

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00028	75 04		 jne	 SHORT $LN1@set_inters@3

; 1426 :         return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 2c		 jmp	 SHORT $LN2@set_inters@3
$LN1@set_inters@3:

; 1427 :     set_swap_bodies(so, (PySetObject *)tmp);

  0002e	48 8b 54 24 20	 mov	 rdx, QWORD PTR tmp$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00038	e8 00 00 00 00	 call	 set_swap_bodies

; 1428 :     Py_DECREF(tmp);

  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  00042	e8 00 00 00 00	 call	 _Py_DecRef

; 1429 :     Py_RETURN_NONE;

  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0004e	e8 00 00 00 00	 call	 _Py_IncRef
  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@set_inters@3:

; 1430 : }

  0005a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005e	c3		 ret	 0
set_intersection_update_multi ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_swap_bodies DD imagerel set_swap_bodies
	DD	imagerel set_swap_bodies+777
	DD	imagerel $unwind$set_swap_bodies
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_swap_bodies DD 021101H
	DD	01b0111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_swap_bodies
_TEXT	SEGMENT
h$ = 32
u$ = 40
f$ = 48
tab$ = 64
t$ = 192
a$ = 224
b$ = 232
set_swap_bodies PROC					; COMDAT

; 1172 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1173 :     Py_ssize_t t;
; 1174 :     setentry *u;
; 1175 :     setentry *(*f)(PySetObject *so, PyObject *key, Py_ssize_t hash);
; 1176 :     setentry tab[PySet_MINSIZE];
; 1177 :     Py_hash_t h;
; 1178 : 
; 1179 :     t = a->fill;     a->fill   = b->fill;        b->fill  = t;

  00011	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00019	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR t$[rsp], rax
  00025	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0002d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00035	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00039	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
  0003d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00045	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  0004d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1180 :     t = a->used;     a->used   = b->used;        b->used  = t;

  00051	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00059	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR t$[rsp], rax
  00065	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0006d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00075	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00079	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00085	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  0008d	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1181 :     t = a->mask;     a->mask   = b->mask;        b->mask  = t;

  00091	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00099	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0009d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR t$[rsp], rax
  000a5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000ad	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  000b5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000b9	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
  000bd	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000c5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  000cd	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 1182 : 
; 1183 :     u = a->table;

  000d1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000d9	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000dd	48 89 44 24 28	 mov	 QWORD PTR u$[rsp], rax

; 1184 :     if (a->table == a->smalltable)

  000e2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000ea	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  000f0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000f8	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  000fc	75 13		 jne	 SHORT $LN6@set_swap_b

; 1185 :         u = b->smalltable;

  000fe	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00106	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  0010c	48 89 44 24 28	 mov	 QWORD PTR u$[rsp], rax
$LN6@set_swap_b:

; 1186 :     a->table  = b->table;

  00111	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00119	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00121	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00125	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1187 :     if (b->table == b->smalltable)

  00129	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00131	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00137	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0013f	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  00143	75 1a		 jne	 SHORT $LN5@set_swap_b

; 1188 :         a->table = a->smalltable;

  00145	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0014d	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00153	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0015b	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax
$LN5@set_swap_b:

; 1189 :     b->table = u;

  0015f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00167	48 8b 4c 24 28	 mov	 rcx, QWORD PTR u$[rsp]
  0016c	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1190 : 
; 1191 :     f = a->lookup;   a->lookup = b->lookup;      b->lookup = f;

  00170	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00178	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0017f	48 89 44 24 30	 mov	 QWORD PTR f$[rsp], rax
  00184	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0018c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00194	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0019b	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx
  001a2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  001aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f$[rsp]
  001af	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 1192 : 
; 1193 :     if (a->table == a->smalltable || b->table == b->smalltable) {

  001b6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001be	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  001c4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001cc	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  001d0	74 1c		 je	 SHORT $LN3@set_swap_b
  001d2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  001da	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  001e0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  001e8	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  001ec	75 6d		 jne	 SHORT $LN4@set_swap_b
$LN3@set_swap_b:

; 1194 :         memcpy(tab, a->smalltable, sizeof(tab));

  001ee	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001f6	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  001fc	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00202	48 8b d0	 mov	 rdx, rax
  00205	48 8d 4c 24 40	 lea	 rcx, QWORD PTR tab$[rsp]
  0020a	e8 00 00 00 00	 call	 memcpy

; 1195 :         memcpy(a->smalltable, b->smalltable, sizeof(tab));

  0020f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00217	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  0021d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00225	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  0022c	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00232	48 8b d0	 mov	 rdx, rax
  00235	e8 00 00 00 00	 call	 memcpy

; 1196 :         memcpy(b->smalltable, tab, sizeof(tab));

  0023a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00242	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00248	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0024e	48 8d 54 24 40	 lea	 rdx, QWORD PTR tab$[rsp]
  00253	48 8b c8	 mov	 rcx, rax
  00256	e8 00 00 00 00	 call	 memcpy
$LN4@set_swap_b:

; 1197 :     }
; 1198 : 
; 1199 :     if (PyType_IsSubtype(Py_TYPE(a), &PyFrozenSet_Type)  &&
; 1200 :         PyType_IsSubtype(Py_TYPE(b), &PyFrozenSet_Type)) {

  0025b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00262	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0026a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0026e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00273	85 c0		 test	 eax, eax
  00275	74 64		 je	 SHORT $LN2@set_swap_b
  00277	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0027e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00286	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0028a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0028f	85 c0		 test	 eax, eax
  00291	74 48		 je	 SHORT $LN2@set_swap_b

; 1201 :         h = a->hash;     a->hash = b->hash;  b->hash = h;

  00293	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0029b	48 8b 80 08 01
	00 00		 mov	 rax, QWORD PTR [rax+264]
  002a2	48 89 44 24 20	 mov	 QWORD PTR h$[rsp], rax
  002a7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002af	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  002b7	48 8b 89 08 01
	00 00		 mov	 rcx, QWORD PTR [rcx+264]
  002be	48 89 88 08 01
	00 00		 mov	 QWORD PTR [rax+264], rcx
  002c5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  002cd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR h$[rsp]
  002d2	48 89 88 08 01
	00 00		 mov	 QWORD PTR [rax+264], rcx

; 1202 :     } else {

  002d9	eb 26		 jmp	 SHORT $LN1@set_swap_b
$LN2@set_swap_b:

; 1203 :         a->hash = -1;

  002db	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002e3	48 c7 80 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+264], -1

; 1204 :         b->hash = -1;

  002ee	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  002f6	48 c7 80 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+264], -1
$LN1@set_swap_b:

; 1205 :     }
; 1206 : }

  00301	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00308	c3		 ret	 0
set_swap_bodies ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_and DD imagerel set_and
	DD	imagerel set_and+227
	DD	imagerel $unwind$set_and
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_and DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_and
_TEXT	SEGMENT
so$ = 48
other$ = 56
set_and	PROC						; COMDAT

; 1437 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1438 :     if (!PyAnySet_Check(so) || !PyAnySet_Check(other))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 44		 je	 SHORT $LN1@set_and
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 32		 je	 SHORT $LN1@set_and
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR so$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 19		 jne	 SHORT $LN1@set_and
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR so$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	74 56		 je	 SHORT $LN2@set_and
$LN1@set_and:
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0006b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  00070	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00074	74 59		 je	 SHORT $LN3@set_and
  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  00082	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00086	74 47		 je	 SHORT $LN3@set_and
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0008f	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  00094	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00098	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009d	85 c0		 test	 eax, eax
  0009f	75 2e		 jne	 SHORT $LN3@set_and
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  000a8	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  000ad	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000b1	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b6	85 c0		 test	 eax, eax
  000b8	75 15		 jne	 SHORT $LN3@set_and
$LN2@set_and:

; 1439 :         Py_RETURN_NOTIMPLEMENTED;

  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  000c1	e8 00 00 00 00	 call	 _Py_IncRef
  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000cd	eb 0f		 jmp	 SHORT $LN4@set_and
$LN3@set_and:

; 1440 :     return set_intersection(so, other);

  000cf	48 8b 54 24 38	 mov	 rdx, QWORD PTR other$[rsp]
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  000d9	e8 00 00 00 00	 call	 set_intersection
$LN4@set_and:

; 1441 : }

  000de	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e2	c3		 ret	 0
set_and	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_iand DD imagerel set_iand
	DD	imagerel set_iand+183
	DD	imagerel $unwind$set_iand
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_iand DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_iand
_TEXT	SEGMENT
result$ = 32
so$ = 64
other$ = 72
set_iand PROC						; COMDAT

; 1445 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1446 :     PyObject *result;
; 1447 : 
; 1448 :     if (!PyAnySet_Check(other))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 59		 je	 SHORT $LN2@set_iand
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 47		 je	 SHORT $LN2@set_iand
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 2e		 jne	 SHORT $LN2@set_iand
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 15		 jne	 SHORT $LN2@set_iand

; 1449 :         Py_RETURN_NOTIMPLEMENTED;

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00077	eb 39		 jmp	 SHORT $LN3@set_iand
$LN2@set_iand:

; 1450 :     result = set_intersection_update(so, other);

  00079	48 8b 54 24 48	 mov	 rdx, QWORD PTR other$[rsp]
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00083	e8 00 00 00 00	 call	 set_intersection_update
  00088	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1451 :     if (result == NULL)

  0008d	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00093	75 04		 jne	 SHORT $LN1@set_iand

; 1452 :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	eb 19		 jmp	 SHORT $LN3@set_iand
$LN1@set_iand:

; 1453 :     Py_DECREF(result);

  00099	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0009e	e8 00 00 00 00	 call	 _Py_DecRef

; 1454 :     Py_INCREF(so);

  000a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  000a8	e8 00 00 00 00	 call	 _Py_IncRef

; 1455 :     return (PyObject *)so;

  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
$LN3@set_iand:

; 1456 : }

  000b2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b6	c3		 ret	 0
set_iand ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_intersection_update DD imagerel set_intersection_update
	DD	imagerel set_intersection_update+95
	DD	imagerel $unwind$set_intersection_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_intersection_update DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_intersection_update
_TEXT	SEGMENT
tmp$ = 32
so$ = 64
other$ = 72
set_intersection_update PROC				; COMDAT

; 1408 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1409 :     PyObject *tmp;
; 1410 : 
; 1411 :     tmp = set_intersection(so, other);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR other$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00018	e8 00 00 00 00	 call	 set_intersection
  0001d	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 1412 :     if (tmp == NULL)

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00028	75 04		 jne	 SHORT $LN1@set_inters@4

; 1413 :         return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 2c		 jmp	 SHORT $LN2@set_inters@4
$LN1@set_inters@4:

; 1414 :     set_swap_bodies(so, (PySetObject *)tmp);

  0002e	48 8b 54 24 20	 mov	 rdx, QWORD PTR tmp$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00038	e8 00 00 00 00	 call	 set_swap_bodies

; 1415 :     Py_DECREF(tmp);

  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  00042	e8 00 00 00 00	 call	 _Py_DecRef

; 1416 :     Py_RETURN_NONE;

  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0004e	e8 00 00 00 00	 call	 _Py_IncRef
  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@set_inters@4:

; 1417 : }

  0005a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005e	c3		 ret	 0
set_intersection_update ENDP
_TEXT	ENDS
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_isdisjoint DD imagerel set_isdisjoint
	DD	imagerel set_isdisjoint+614
	DD	imagerel $unwind$set_isdisjoint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_isdisjoint DD 010e01H
	DD	0e20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_isdisjoint
_TEXT	SEGMENT
it$ = 32
tmp$ = 40
key$ = 48
entry$21656 = 56
pos$21655 = 64
rv$21666 = 72
rv$21683 = 76
hash$21685 = 80
entry$21684 = 88
so$ = 128
other$ = 136
set_isdisjoint PROC					; COMDAT

; 1460 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1461 :     PyObject *key, *it, *tmp;
; 1462 : 
; 1463 :     if ((PyObject *)so == other) {

  0000e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  00016	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR so$[rsp], rax
  0001e	75 41		 jne	 SHORT $LN17@set_isdisj

; 1464 :         if (PySet_GET_SIZE(so) == 0)

  00020	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00028	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0002d	75 1a		 jne	 SHORT $LN16@set_isdisj

; 1465 :             Py_RETURN_TRUE;

  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00036	e8 00 00 00 00	 call	 _Py_IncRef
  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00042	e9 1a 02 00 00	 jmp	 $LN18@set_isdisj

; 1466 :         else

  00047	eb 18		 jmp	 SHORT $LN15@set_isdisj
$LN16@set_isdisj:

; 1467 :             Py_RETURN_FALSE;

  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00050	e8 00 00 00 00	 call	 _Py_IncRef
  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0005c	e9 00 02 00 00	 jmp	 $LN18@set_isdisj
$LN15@set_isdisj:
$LN17@set_isdisj:

; 1468 :     }
; 1469 : 
; 1470 :     if (PyAnySet_CheckExact(other)) {

  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00068	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  00070	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00074	74 19		 je	 SHORT $LN13@set_isdisj
  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0007d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  00085	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00089	0f 85 c5 00 00
	00		 jne	 $LN14@set_isdisj
$LN13@set_isdisj:

; 1471 :         Py_ssize_t pos = 0;

  0008f	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pos$21655[rsp], 0

; 1472 :         setentry *entry;
; 1473 : 
; 1474 :         if (PySet_GET_SIZE(other) > PySet_GET_SIZE(so)) {

  00098	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  000a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  000a8	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000ac	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  000b0	7e 2a		 jle	 SHORT $LN12@set_isdisj

; 1475 :             tmp = (PyObject *)so;

  000b2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  000ba	48 89 44 24 28	 mov	 QWORD PTR tmp$[rsp], rax

; 1476 :             so = (PySetObject *)other;

  000bf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  000c7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR so$[rsp], rax

; 1477 :             other = tmp;

  000cf	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  000d4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR other$[rsp], rax
$LN12@set_isdisj:
$LN11@set_isdisj:

; 1478 :         }
; 1479 :         while (set_next((PySetObject *)other, &pos, &entry)) {

  000dc	4c 8d 44 24 38	 lea	 r8, QWORD PTR entry$21656[rsp]
  000e1	48 8d 54 24 40	 lea	 rdx, QWORD PTR pos$21655[rsp]
  000e6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  000ee	e8 00 00 00 00	 call	 set_next
  000f3	85 c0		 test	 eax, eax
  000f5	74 45		 je	 SHORT $LN10@set_isdisj

; 1480 :             int rv = set_contains_entry(so, entry);

  000f7	48 8b 54 24 38	 mov	 rdx, QWORD PTR entry$21656[rsp]
  000fc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00104	e8 00 00 00 00	 call	 set_contains_entry
  00109	89 44 24 48	 mov	 DWORD PTR rv$21666[rsp], eax

; 1481 :             if (rv == -1)

  0010d	83 7c 24 48 ff	 cmp	 DWORD PTR rv$21666[rsp], -1
  00112	75 07		 jne	 SHORT $LN9@set_isdisj

; 1482 :                 return NULL;

  00114	33 c0		 xor	 eax, eax
  00116	e9 46 01 00 00	 jmp	 $LN18@set_isdisj
$LN9@set_isdisj:

; 1483 :             if (rv)

  0011b	83 7c 24 48 00	 cmp	 DWORD PTR rv$21666[rsp], 0
  00120	74 18		 je	 SHORT $LN8@set_isdisj

; 1484 :                 Py_RETURN_FALSE;

  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00129	e8 00 00 00 00	 call	 _Py_IncRef
  0012e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00135	e9 27 01 00 00	 jmp	 $LN18@set_isdisj
$LN8@set_isdisj:

; 1485 :         }

  0013a	eb a0		 jmp	 SHORT $LN11@set_isdisj
$LN10@set_isdisj:

; 1486 :         Py_RETURN_TRUE;

  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00143	e8 00 00 00 00	 call	 _Py_IncRef
  00148	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0014f	e9 0d 01 00 00	 jmp	 $LN18@set_isdisj
$LN14@set_isdisj:

; 1487 :     }
; 1488 : 
; 1489 :     it = PyObject_GetIter(other);

  00154	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  0015c	e8 00 00 00 00	 call	 PyObject_GetIter
  00161	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 1490 :     if (it == NULL)

  00166	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  0016c	75 07		 jne	 SHORT $LN7@set_isdisj

; 1491 :         return NULL;

  0016e	33 c0		 xor	 eax, eax
  00170	e9 ec 00 00 00	 jmp	 $LN18@set_isdisj
$LN7@set_isdisj:
$LN6@set_isdisj:

; 1492 : 
; 1493 :     while ((key = PyIter_Next(it)) != NULL) {

  00175	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0017a	e8 00 00 00 00	 call	 PyIter_Next
  0017f	48 89 44 24 30	 mov	 QWORD PTR key$[rsp], rax
  00184	48 83 7c 24 30
	00		 cmp	 QWORD PTR key$[rsp], 0
  0018a	0f 84 a6 00 00
	00		 je	 $LN5@set_isdisj

; 1494 :         int rv;
; 1495 :         setentry entry;
; 1496 :         Py_hash_t hash = PyObject_Hash(key);

  00190	48 8b 4c 24 30	 mov	 rcx, QWORD PTR key$[rsp]
  00195	e8 00 00 00 00	 call	 PyObject_Hash
  0019a	48 89 44 24 50	 mov	 QWORD PTR hash$21685[rsp], rax

; 1497 : 
; 1498 :         if (hash == -1) {

  0019f	48 83 7c 24 50
	ff		 cmp	 QWORD PTR hash$21685[rsp], -1
  001a5	75 1b		 jne	 SHORT $LN4@set_isdisj

; 1499 :             Py_DECREF(key);

  001a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR key$[rsp]
  001ac	e8 00 00 00 00	 call	 _Py_DecRef

; 1500 :             Py_DECREF(it);

  001b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  001b6	e8 00 00 00 00	 call	 _Py_DecRef

; 1501 :             return NULL;

  001bb	33 c0		 xor	 eax, eax
  001bd	e9 9f 00 00 00	 jmp	 $LN18@set_isdisj
$LN4@set_isdisj:

; 1502 :         }
; 1503 :         entry.hash = hash;

  001c2	48 8b 44 24 50	 mov	 rax, QWORD PTR hash$21685[rsp]
  001c7	48 89 44 24 58	 mov	 QWORD PTR entry$21684[rsp], rax

; 1504 :         entry.key = key;

  001cc	48 8b 44 24 30	 mov	 rax, QWORD PTR key$[rsp]
  001d1	48 89 44 24 60	 mov	 QWORD PTR entry$21684[rsp+8], rax

; 1505 :         rv = set_contains_entry(so, &entry);

  001d6	48 8d 54 24 58	 lea	 rdx, QWORD PTR entry$21684[rsp]
  001db	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  001e3	e8 00 00 00 00	 call	 set_contains_entry
  001e8	89 44 24 4c	 mov	 DWORD PTR rv$21683[rsp], eax

; 1506 :         Py_DECREF(key);

  001ec	48 8b 4c 24 30	 mov	 rcx, QWORD PTR key$[rsp]
  001f1	e8 00 00 00 00	 call	 _Py_DecRef

; 1507 :         if (rv == -1) {

  001f6	83 7c 24 4c ff	 cmp	 DWORD PTR rv$21683[rsp], -1
  001fb	75 0e		 jne	 SHORT $LN3@set_isdisj

; 1508 :             Py_DECREF(it);

  001fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00202	e8 00 00 00 00	 call	 _Py_DecRef

; 1509 :             return NULL;

  00207	33 c0		 xor	 eax, eax
  00209	eb 56		 jmp	 SHORT $LN18@set_isdisj
$LN3@set_isdisj:

; 1510 :         }
; 1511 :         if (rv) {

  0020b	83 7c 24 4c 00	 cmp	 DWORD PTR rv$21683[rsp], 0
  00210	74 1f		 je	 SHORT $LN2@set_isdisj

; 1512 :             Py_DECREF(it);

  00212	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00217	e8 00 00 00 00	 call	 _Py_DecRef

; 1513 :             Py_RETURN_FALSE;

  0021c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00223	e8 00 00 00 00	 call	 _Py_IncRef
  00228	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0022f	eb 30		 jmp	 SHORT $LN18@set_isdisj
$LN2@set_isdisj:

; 1514 :         }
; 1515 :     }

  00231	e9 3f ff ff ff	 jmp	 $LN6@set_isdisj
$LN5@set_isdisj:

; 1516 :     Py_DECREF(it);

  00236	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0023b	e8 00 00 00 00	 call	 _Py_DecRef

; 1517 :     if (PyErr_Occurred())

  00240	e8 00 00 00 00	 call	 PyErr_Occurred
  00245	48 85 c0	 test	 rax, rax
  00248	74 04		 je	 SHORT $LN1@set_isdisj

; 1518 :         return NULL;

  0024a	33 c0		 xor	 eax, eax
  0024c	eb 13		 jmp	 SHORT $LN18@set_isdisj
$LN1@set_isdisj:

; 1519 :     Py_RETURN_TRUE;

  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00255	e8 00 00 00 00	 call	 _Py_IncRef
  0025a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
$LN18@set_isdisj:

; 1520 : }

  00261	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00265	c3		 ret	 0
set_isdisjoint ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_difference_update DD imagerel set_difference_update
	DD	imagerel set_difference_update+124
	DD	imagerel $unwind$set_difference_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_difference_update DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_difference_update
_TEXT	SEGMENT
i$ = 32
other$21754 = 40
so$ = 64
args$ = 72
set_difference_update PROC				; COMDAT

; 1564 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1565 :     Py_ssize_t i;
; 1566 : 
; 1567 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	eb 0d		 jmp	 SHORT $LN4@set_differ
$LN3@set_differ:
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0001e	48 ff c0	 inc	 rax
  00021	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@set_differ:
  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR args$[rsp]
  0002b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002f	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00034	7d 2e		 jge	 SHORT $LN2@set_differ

; 1568 :         PyObject *other = PyTuple_GET_ITEM(args, i);

  00036	48 8b 44 24 48	 mov	 rax, QWORD PTR args$[rsp]
  0003b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00040	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00045	48 89 44 24 28	 mov	 QWORD PTR other$21754[rsp], rax

; 1569 :         if (set_difference_update_internal(so, other) == -1)

  0004a	48 8b 54 24 28	 mov	 rdx, QWORD PTR other$21754[rsp]
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00054	e8 00 00 00 00	 call	 set_difference_update_internal
  00059	83 f8 ff	 cmp	 eax, -1
  0005c	75 04		 jne	 SHORT $LN1@set_differ

; 1570 :             return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	eb 15		 jmp	 SHORT $LN5@set_differ
$LN1@set_differ:

; 1571 :     }

  00062	eb b5		 jmp	 SHORT $LN3@set_differ
$LN2@set_differ:

; 1572 :     Py_RETURN_NONE;

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN5@set_differ:

; 1573 : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
set_difference_update ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_difference_update_internal DD imagerel set_difference_update_internal
	DD	imagerel set_difference_update_internal+454
	DD	imagerel $unwind$set_difference_update_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_difference_update_internal DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_difference_update_internal
_TEXT	SEGMENT
entry$21720 = 32
pos$21721 = 40
it$21729 = 48
key$21728 = 56
tv151 = 64
so$ = 96
other$ = 104
set_difference_update_internal PROC			; COMDAT

; 1527 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1528 :     if ((PyObject *)so == other)

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR other$[rsp]
  00013	48 39 44 24 60	 cmp	 QWORD PTR so$[rsp], rax
  00018	75 0f		 jne	 SHORT $LN13@set_differ@2

; 1529 :         return set_clear_internal(so);

  0001a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  0001f	e8 00 00 00 00	 call	 set_clear_internal
  00024	e9 98 01 00 00	 jmp	 $LN14@set_differ@2
$LN13@set_differ@2:

; 1530 : 
; 1531 :     if (PyAnySet_Check(other)) {

  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00030	48 8b 4c 24 68	 mov	 rcx, QWORD PTR other$[rsp]
  00035	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00039	74 44		 je	 SHORT $LN11@set_differ@2
  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00042	48 8b 4c 24 68	 mov	 rcx, QWORD PTR other$[rsp]
  00047	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0004b	74 32		 je	 SHORT $LN11@set_differ@2
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00054	48 8b 44 24 68	 mov	 rax, QWORD PTR other$[rsp]
  00059	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00062	85 c0		 test	 eax, eax
  00064	75 19		 jne	 SHORT $LN11@set_differ@2
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0006d	48 8b 44 24 68	 mov	 rax, QWORD PTR other$[rsp]
  00072	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00076	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007b	85 c0		 test	 eax, eax
  0007d	74 46		 je	 SHORT $LN12@set_differ@2
$LN11@set_differ@2:

; 1532 :         setentry *entry;
; 1533 :         Py_ssize_t pos = 0;

  0007f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pos$21721[rsp], 0
$LN10@set_differ@2:

; 1534 : 
; 1535 :         while (set_next((PySetObject *)other, &pos, &entry))

  00088	4c 8d 44 24 20	 lea	 r8, QWORD PTR entry$21720[rsp]
  0008d	48 8d 54 24 28	 lea	 rdx, QWORD PTR pos$21721[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR other$[rsp]
  00097	e8 00 00 00 00	 call	 set_next
  0009c	85 c0		 test	 eax, eax
  0009e	74 20		 je	 SHORT $LN9@set_differ@2

; 1536 :             if (set_discard_entry(so, entry) == -1)

  000a0	48 8b 54 24 20	 mov	 rdx, QWORD PTR entry$21720[rsp]
  000a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  000aa	e8 00 00 00 00	 call	 set_discard_entry
  000af	83 f8 ff	 cmp	 eax, -1
  000b2	75 0a		 jne	 SHORT $LN8@set_differ@2

; 1537 :                 return -1;

  000b4	b8 ff ff ff ff	 mov	 eax, -1
  000b9	e9 03 01 00 00	 jmp	 $LN14@set_differ@2
$LN8@set_differ@2:

; 1538 :     } else {

  000be	eb c8		 jmp	 SHORT $LN10@set_differ@2
$LN9@set_differ@2:
  000c0	e9 91 00 00 00	 jmp	 $LN7@set_differ@2
$LN12@set_differ@2:

; 1539 :         PyObject *key, *it;
; 1540 :         it = PyObject_GetIter(other);

  000c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR other$[rsp]
  000ca	e8 00 00 00 00	 call	 PyObject_GetIter
  000cf	48 89 44 24 30	 mov	 QWORD PTR it$21729[rsp], rax

; 1541 :         if (it == NULL)

  000d4	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$21729[rsp], 0
  000da	75 0a		 jne	 SHORT $LN6@set_differ@2

; 1542 :             return -1;

  000dc	b8 ff ff ff ff	 mov	 eax, -1
  000e1	e9 db 00 00 00	 jmp	 $LN14@set_differ@2
$LN6@set_differ@2:
$LN5@set_differ@2:

; 1543 : 
; 1544 :         while ((key = PyIter_Next(it)) != NULL) {

  000e6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$21729[rsp]
  000eb	e8 00 00 00 00	 call	 PyIter_Next
  000f0	48 89 44 24 38	 mov	 QWORD PTR key$21728[rsp], rax
  000f5	48 83 7c 24 38
	00		 cmp	 QWORD PTR key$21728[rsp], 0
  000fb	74 3e		 je	 SHORT $LN4@set_differ@2

; 1545 :             if (set_discard_key(so, key) == -1) {

  000fd	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$21728[rsp]
  00102	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00107	e8 00 00 00 00	 call	 set_discard_key
  0010c	83 f8 ff	 cmp	 eax, -1
  0010f	75 1e		 jne	 SHORT $LN3@set_differ@2

; 1546 :                 Py_DECREF(it);

  00111	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$21729[rsp]
  00116	e8 00 00 00 00	 call	 _Py_DecRef

; 1547 :                 Py_DECREF(key);

  0011b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$21728[rsp]
  00120	e8 00 00 00 00	 call	 _Py_DecRef

; 1548 :                 return -1;

  00125	b8 ff ff ff ff	 mov	 eax, -1
  0012a	e9 92 00 00 00	 jmp	 $LN14@set_differ@2
$LN3@set_differ@2:

; 1549 :             }
; 1550 :             Py_DECREF(key);

  0012f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$21728[rsp]
  00134	e8 00 00 00 00	 call	 _Py_DecRef

; 1551 :         }

  00139	eb ab		 jmp	 SHORT $LN5@set_differ@2
$LN4@set_differ@2:

; 1552 :         Py_DECREF(it);

  0013b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$21729[rsp]
  00140	e8 00 00 00 00	 call	 _Py_DecRef

; 1553 :         if (PyErr_Occurred())

  00145	e8 00 00 00 00	 call	 PyErr_Occurred
  0014a	48 85 c0	 test	 rax, rax
  0014d	74 07		 je	 SHORT $LN2@set_differ@2

; 1554 :             return -1;

  0014f	b8 ff ff ff ff	 mov	 eax, -1
  00154	eb 6b		 jmp	 SHORT $LN14@set_differ@2
$LN2@set_differ@2:
$LN7@set_differ@2:

; 1555 :     }
; 1556 :     /* If more than 1/5 are dummies, then resize them away. */
; 1557 :     if ((so->fill - so->used) * 5 < so->mask)

  00156	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  0015b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00160	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00164	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00168	48 2b c1	 sub	 rax, rcx
  0016b	48 6b c0 05	 imul	 rax, 5
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  00174	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00178	7d 04		 jge	 SHORT $LN1@set_differ@2

; 1558 :         return 0;

  0017a	33 c0		 xor	 eax, eax
  0017c	eb 43		 jmp	 SHORT $LN14@set_differ@2
$LN1@set_differ@2:

; 1559 :     return set_table_resize(so, so->used>50000 ? so->used*2 : so->used*4);

  0017e	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  00183	48 81 78 68 50
	c3 00 00	 cmp	 QWORD PTR [rax+104], 50000 ; 0000c350H
  0018b	7e 13		 jle	 SHORT $LN16@set_differ@2
  0018d	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  00192	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00196	48 d1 e0	 shl	 rax, 1
  00199	48 89 44 24 40	 mov	 QWORD PTR tv151[rsp], rax
  0019e	eb 12		 jmp	 SHORT $LN17@set_differ@2
$LN16@set_differ@2:
  001a0	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  001a5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001a9	48 c1 e0 02	 shl	 rax, 2
  001ad	48 89 44 24 40	 mov	 QWORD PTR tv151[rsp], rax
$LN17@set_differ@2:
  001b2	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv151[rsp]
  001b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  001bc	e8 00 00 00 00	 call	 set_table_resize
$LN14@set_differ@2:

; 1560 : }

  001c1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c5	c3		 ret	 0
set_difference_update_internal ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_discard_entry DD imagerel set_discard_entry
	DD	imagerel set_discard_entry+184
	DD	imagerel $unwind$set_discard_entry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_discard_entry DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_discard_entry
_TEXT	SEGMENT
old_key$ = 32
entry$ = 40
so$ = 64
oldentry$ = 72
set_discard_entry PROC					; COMDAT

; 410  : {       register setentry *entry;

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 411  :     PyObject *old_key;
; 412  : 
; 413  :     entry = (so->lookup)(so, oldentry->key, oldentry->hash);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR oldentry$[rsp]
  00013	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00016	48 8b 44 24 48	 mov	 rax, QWORD PTR oldentry$[rsp]
  0001b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00029	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0002f	48 89 44 24 28	 mov	 QWORD PTR entry$[rsp], rax

; 414  :     if (entry == NULL)

  00034	48 83 7c 24 28
	00		 cmp	 QWORD PTR entry$[rsp], 0
  0003a	75 07		 jne	 SHORT $LN3@set_discar

; 415  :         return -1;

  0003c	b8 ff ff ff ff	 mov	 eax, -1
  00041	eb 70		 jmp	 SHORT $LN4@set_discar
$LN3@set_discar:

; 416  :     if (entry->key == NULL  ||  entry->key == dummy)

  00043	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  00048	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0004d	74 12		 je	 SHORT $LN1@set_discar
  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0005b	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  0005f	75 04		 jne	 SHORT $LN2@set_discar
$LN1@set_discar:

; 417  :         return DISCARD_NOTFOUND;

  00061	33 c0		 xor	 eax, eax
  00063	eb 4e		 jmp	 SHORT $LN4@set_discar
$LN2@set_discar:

; 418  :     old_key = entry->key;

  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  0006a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006e	48 89 44 24 20	 mov	 QWORD PTR old_key$[rsp], rax

; 419  :     Py_INCREF(dummy);

  00073	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0007a	e8 00 00 00 00	 call	 _Py_IncRef

; 420  :     entry->key = dummy;

  0007f	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  00084	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0008b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 421  :     so->used--;

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00094	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00098	48 ff c8	 dec	 rax
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  000a0	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 422  :     Py_DECREF(old_key);

  000a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR old_key$[rsp]
  000a9	e8 00 00 00 00	 call	 _Py_DecRef

; 423  :     return DISCARD_FOUND;

  000ae	b8 01 00 00 00	 mov	 eax, 1
$LN4@set_discar:

; 424  : }

  000b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b7	c3		 ret	 0
set_discard_entry ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_discard_key DD imagerel set_discard_key
	DD	imagerel set_discard_key+364
	DD	imagerel $unwind$set_discard_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_discard_key DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_discard_key
_TEXT	SEGMENT
old_key$ = 32
entry$ = 40
hash$ = 48
so$ = 80
key$ = 88
set_discard_key PROC					; COMDAT

; 428  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 429  :     register Py_hash_t hash;
; 430  :     register setentry *entry;
; 431  :     PyObject *old_key;
; 432  : 
; 433  :     assert (PyAnySet_Check(so));

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 60		 je	 SHORT $LN9@set_discar@2
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 4e		 je	 SHORT $LN9@set_discar@2
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 35		 jne	 SHORT $LN9@set_discar@2
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 1c		 jne	 SHORT $LN9@set_discar@2
  00064	41 b8 b1 01 00
	00		 mov	 r8d, 433		; 000001b1H
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@MEACPONF@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAo?$AA?$CJ?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN9@set_discar@2:

; 434  : 
; 435  :     if (!PyUnicode_CheckExact(key) ||
; 436  :         (hash = ((PyASCIIObject *) key)->hash) == -1) {

  00080	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00087	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0008c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00090	75 16		 jne	 SHORT $LN5@set_discar@2
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR key$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 89 44 24 30	 mov	 QWORD PTR hash$[rsp], rax
  000a0	48 83 7c 24 30
	ff		 cmp	 QWORD PTR hash$[rsp], -1
  000a6	75 21		 jne	 SHORT $LN6@set_discar@2
$LN5@set_discar@2:

; 437  :         hash = PyObject_Hash(key);

  000a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  000ad	e8 00 00 00 00	 call	 PyObject_Hash
  000b2	48 89 44 24 30	 mov	 QWORD PTR hash$[rsp], rax

; 438  :         if (hash == -1)

  000b7	48 83 7c 24 30
	ff		 cmp	 QWORD PTR hash$[rsp], -1
  000bd	75 0a		 jne	 SHORT $LN4@set_discar@2

; 439  :             return -1;

  000bf	b8 ff ff ff ff	 mov	 eax, -1
  000c4	e9 9e 00 00 00	 jmp	 $LN7@set_discar@2
$LN4@set_discar@2:
$LN6@set_discar@2:

; 440  :     }
; 441  :     entry = (so->lookup)(so, key, hash);

  000c9	4c 8b 44 24 30	 mov	 r8, QWORD PTR hash$[rsp]
  000ce	48 8b 54 24 58	 mov	 rdx, QWORD PTR key$[rsp]
  000d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  000d8	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000dd	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  000e3	48 89 44 24 28	 mov	 QWORD PTR entry$[rsp], rax

; 442  :     if (entry == NULL)

  000e8	48 83 7c 24 28
	00		 cmp	 QWORD PTR entry$[rsp], 0
  000ee	75 07		 jne	 SHORT $LN3@set_discar@2

; 443  :         return -1;

  000f0	b8 ff ff ff ff	 mov	 eax, -1
  000f5	eb 70		 jmp	 SHORT $LN7@set_discar@2
$LN3@set_discar@2:

; 444  :     if (entry->key == NULL  ||  entry->key == dummy)

  000f7	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  000fc	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00101	74 12		 je	 SHORT $LN1@set_discar@2
  00103	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  00108	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0010f	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00113	75 04		 jne	 SHORT $LN2@set_discar@2
$LN1@set_discar@2:

; 445  :         return DISCARD_NOTFOUND;

  00115	33 c0		 xor	 eax, eax
  00117	eb 4e		 jmp	 SHORT $LN7@set_discar@2
$LN2@set_discar@2:

; 446  :     old_key = entry->key;

  00119	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  0011e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00122	48 89 44 24 20	 mov	 QWORD PTR old_key$[rsp], rax

; 447  :     Py_INCREF(dummy);

  00127	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0012e	e8 00 00 00 00	 call	 _Py_IncRef

; 448  :     entry->key = dummy;

  00133	48 8b 44 24 28	 mov	 rax, QWORD PTR entry$[rsp]
  00138	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0013f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 449  :     so->used--;

  00143	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00148	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0014c	48 ff c8	 dec	 rax
  0014f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00154	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 450  :     Py_DECREF(old_key);

  00158	48 8b 4c 24 20	 mov	 rcx, QWORD PTR old_key$[rsp]
  0015d	e8 00 00 00 00	 call	 _Py_DecRef

; 451  :     return DISCARD_FOUND;

  00162	b8 01 00 00 00	 mov	 eax, 1
$LN7@set_discar@2:

; 452  : }

  00167	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0016b	c3		 ret	 0
set_discard_key ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_difference_multi DD imagerel set_difference_multi
	DD	imagerel set_difference_multi+193
	DD	imagerel $unwind$set_difference_multi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_difference_multi DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_difference_multi
_TEXT	SEGMENT
i$ = 32
other$ = 40
result$ = 48
so$ = 80
args$ = 88
set_difference_multi PROC				; COMDAT

; 1647 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1648 :     Py_ssize_t i;
; 1649 :     PyObject *result, *other;
; 1650 : 
; 1651 :     if (PyTuple_GET_SIZE(args) == 0)

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00013	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00018	75 0f		 jne	 SHORT $LN6@set_differ@3

; 1652 :         return set_copy(so);

  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  0001f	e8 00 00 00 00	 call	 set_copy
  00024	e9 93 00 00 00	 jmp	 $LN7@set_differ@3
$LN6@set_differ@3:

; 1653 : 
; 1654 :     other = PyTuple_GET_ITEM(args, 0);

  00029	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  0002e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00032	48 89 44 24 28	 mov	 QWORD PTR other$[rsp], rax

; 1655 :     result = set_difference(so, other);

  00037	48 8b 54 24 28	 mov	 rdx, QWORD PTR other$[rsp]
  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00041	e8 00 00 00 00	 call	 set_difference
  00046	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1656 :     if (result == NULL)

  0004b	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00051	75 04		 jne	 SHORT $LN5@set_differ@3

; 1657 :         return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	eb 65		 jmp	 SHORT $LN7@set_differ@3
$LN5@set_differ@3:

; 1658 : 
; 1659 :     for (i=1 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00057	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR i$[rsp], 1
  00060	eb 0d		 jmp	 SHORT $LN4@set_differ@3
$LN3@set_differ@3:
  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00067	48 ff c0	 inc	 rax
  0006a	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@set_differ@3:
  0006f	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00074	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00078	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0007d	7d 38		 jge	 SHORT $LN2@set_differ@3

; 1660 :         other = PyTuple_GET_ITEM(args, i);

  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00084	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00089	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  0008e	48 89 44 24 28	 mov	 QWORD PTR other$[rsp], rax

; 1661 :         if (set_difference_update_internal((PySetObject *)result, other) == -1) {

  00093	48 8b 54 24 28	 mov	 rdx, QWORD PTR other$[rsp]
  00098	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  0009d	e8 00 00 00 00	 call	 set_difference_update_internal
  000a2	83 f8 ff	 cmp	 eax, -1
  000a5	75 0e		 jne	 SHORT $LN1@set_differ@3

; 1662 :             Py_DECREF(result);

  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  000ac	e8 00 00 00 00	 call	 _Py_DecRef

; 1663 :             return NULL;

  000b1	33 c0		 xor	 eax, eax
  000b3	eb 07		 jmp	 SHORT $LN7@set_differ@3
$LN1@set_differ@3:

; 1664 :         }
; 1665 :     }

  000b5	eb ab		 jmp	 SHORT $LN3@set_differ@3
$LN2@set_differ@3:

; 1666 :     return result;

  000b7	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN7@set_differ@3:

; 1667 : }

  000bc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c0	c3		 ret	 0
set_difference_multi ENDP
_TEXT	ENDS
EXTRN	_PyDict_Contains:PROC
EXTRN	PyObject_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_difference DD imagerel set_difference
	DD	imagerel set_difference+537
	DD	imagerel $unwind$set_difference
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_difference DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_difference
_TEXT	SEGMENT
entry$ = 32
result$ = 40
pos$ = 48
entrycopy$21804 = 56
rv$21813 = 72
tv86 = 80
so$ = 112
other$ = 120
set_difference PROC					; COMDAT

; 1594 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1595 :     PyObject *result;
; 1596 :     setentry *entry;
; 1597 :     Py_ssize_t pos = 0;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0

; 1598 : 
; 1599 :     if (!PyAnySet_Check(other)  && !PyDict_CheckExact(other)) {

  00017	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0001e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  00023	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00027	74 7c		 je	 SHORT $LN14@set_differ@4
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00030	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  00035	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00039	74 6a		 je	 SHORT $LN14@set_differ@4
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00042	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  00047	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00050	85 c0		 test	 eax, eax
  00052	75 51		 jne	 SHORT $LN14@set_differ@4
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0005b	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  00060	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00064	e8 00 00 00 00	 call	 PyType_IsSubtype
  00069	85 c0		 test	 eax, eax
  0006b	75 38		 jne	 SHORT $LN14@set_differ@4
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00074	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  00079	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0007d	74 26		 je	 SHORT $LN14@set_differ@4
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  0008b	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  0008f	74 14		 je	 SHORT $LN14@set_differ@4

; 1600 :         return set_copy_and_difference(so, other);

  00091	48 8b 54 24 78	 mov	 rdx, QWORD PTR other$[rsp]
  00096	48 8b 4c 24 70	 mov	 rcx, QWORD PTR so$[rsp]
  0009b	e8 00 00 00 00	 call	 set_copy_and_difference
  000a0	e9 6f 01 00 00	 jmp	 $LN15@set_differ@4
$LN14@set_differ@4:

; 1601 :     }
; 1602 : 
; 1603 :     /* If len(so) much more than len(other), it's more efficient to simply copy
; 1604 :      * so and then iterate other looking for common elements. */
; 1605 :     if ((PySet_GET_SIZE(so) >> 2) > PyObject_Size(other)) {

  000a5	48 8b 44 24 70	 mov	 rax, QWORD PTR so$[rsp]
  000aa	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ae	48 c1 f8 02	 sar	 rax, 2
  000b2	48 89 44 24 50	 mov	 QWORD PTR tv86[rsp], rax
  000b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  000bc	e8 00 00 00 00	 call	 PyObject_Size
  000c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv86[rsp]
  000c6	48 3b c8	 cmp	 rcx, rax
  000c9	7e 14		 jle	 SHORT $LN13@set_differ@4

; 1606 :         return set_copy_and_difference(so, other);

  000cb	48 8b 54 24 78	 mov	 rdx, QWORD PTR other$[rsp]
  000d0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR so$[rsp]
  000d5	e8 00 00 00 00	 call	 set_copy_and_difference
  000da	e9 35 01 00 00	 jmp	 $LN15@set_differ@4
$LN13@set_differ@4:

; 1607 :     }
; 1608 : 
; 1609 :     result = make_new_set_basetype(Py_TYPE(so), NULL);

  000df	33 d2		 xor	 edx, edx
  000e1	48 8b 44 24 70	 mov	 rax, QWORD PTR so$[rsp]
  000e6	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000ea	e8 00 00 00 00	 call	 make_new_set_basetype
  000ef	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1610 :     if (result == NULL)

  000f4	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  000fa	75 07		 jne	 SHORT $LN12@set_differ@4

; 1611 :         return NULL;

  000fc	33 c0		 xor	 eax, eax
  000fe	e9 11 01 00 00	 jmp	 $LN15@set_differ@4
$LN12@set_differ@4:

; 1612 : 
; 1613 :     if (PyDict_CheckExact(other)) {

  00103	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  0010f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00113	74 12		 je	 SHORT $LN10@set_differ@4
  00115	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  0011c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  00121	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  00125	75 7d		 jne	 SHORT $LN11@set_differ@4
$LN10@set_differ@4:
$LN9@set_differ@4:

; 1614 :         while (set_next(so, &pos, &entry)) {

  00127	4c 8d 44 24 20	 lea	 r8, QWORD PTR entry$[rsp]
  0012c	48 8d 54 24 30	 lea	 rdx, QWORD PTR pos$[rsp]
  00131	48 8b 4c 24 70	 mov	 rcx, QWORD PTR so$[rsp]
  00136	e8 00 00 00 00	 call	 set_next
  0013b	85 c0		 test	 eax, eax
  0013d	74 5e		 je	 SHORT $LN8@set_differ@4

; 1615 :             setentry entrycopy;
; 1616 :             entrycopy.hash = entry->hash;

  0013f	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00144	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00147	48 89 44 24 38	 mov	 QWORD PTR entrycopy$21804[rsp], rax

; 1617 :             entrycopy.key = entry->key;

  0014c	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00151	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00155	48 89 44 24 40	 mov	 QWORD PTR entrycopy$21804[rsp+8], rax

; 1618 :             if (!_PyDict_Contains(other, entry->key, entry->hash)) {

  0015a	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0015f	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00162	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00167	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0016b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  00170	e8 00 00 00 00	 call	 _PyDict_Contains
  00175	85 c0		 test	 eax, eax
  00177	75 22		 jne	 SHORT $LN7@set_differ@4

; 1619 :                 if (set_add_entry((PySetObject *)result, &entrycopy) == -1) {

  00179	48 8d 54 24 38	 lea	 rdx, QWORD PTR entrycopy$21804[rsp]
  0017e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00183	e8 00 00 00 00	 call	 set_add_entry
  00188	83 f8 ff	 cmp	 eax, -1
  0018b	75 0e		 jne	 SHORT $LN6@set_differ@4

; 1620 :                     Py_DECREF(result);

  0018d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00192	e8 00 00 00 00	 call	 _Py_DecRef

; 1621 :                     return NULL;

  00197	33 c0		 xor	 eax, eax
  00199	eb 79		 jmp	 SHORT $LN15@set_differ@4
$LN6@set_differ@4:
$LN7@set_differ@4:

; 1622 :                 }
; 1623 :             }
; 1624 :         }

  0019b	eb 8a		 jmp	 SHORT $LN9@set_differ@4
$LN8@set_differ@4:

; 1625 :         return result;

  0019d	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
  001a2	eb 70		 jmp	 SHORT $LN15@set_differ@4
$LN11@set_differ@4:
$LN5@set_differ@4:

; 1626 :     }
; 1627 : 
; 1628 :     /* Iterate over so, checking for common elements in other. */
; 1629 :     while (set_next(so, &pos, &entry)) {

  001a4	4c 8d 44 24 20	 lea	 r8, QWORD PTR entry$[rsp]
  001a9	48 8d 54 24 30	 lea	 rdx, QWORD PTR pos$[rsp]
  001ae	48 8b 4c 24 70	 mov	 rcx, QWORD PTR so$[rsp]
  001b3	e8 00 00 00 00	 call	 set_next
  001b8	85 c0		 test	 eax, eax
  001ba	74 53		 je	 SHORT $LN4@set_differ@4

; 1630 :         int rv = set_contains_entry((PySetObject *)other, entry);

  001bc	48 8b 54 24 20	 mov	 rdx, QWORD PTR entry$[rsp]
  001c1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  001c6	e8 00 00 00 00	 call	 set_contains_entry
  001cb	89 44 24 48	 mov	 DWORD PTR rv$21813[rsp], eax

; 1631 :         if (rv == -1) {

  001cf	83 7c 24 48 ff	 cmp	 DWORD PTR rv$21813[rsp], -1
  001d4	75 0e		 jne	 SHORT $LN3@set_differ@4

; 1632 :             Py_DECREF(result);

  001d6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  001db	e8 00 00 00 00	 call	 _Py_DecRef

; 1633 :             return NULL;

  001e0	33 c0		 xor	 eax, eax
  001e2	eb 30		 jmp	 SHORT $LN15@set_differ@4
$LN3@set_differ@4:

; 1634 :         }
; 1635 :         if (!rv) {

  001e4	83 7c 24 48 00	 cmp	 DWORD PTR rv$21813[rsp], 0
  001e9	75 22		 jne	 SHORT $LN2@set_differ@4

; 1636 :             if (set_add_entry((PySetObject *)result, entry) == -1) {

  001eb	48 8b 54 24 20	 mov	 rdx, QWORD PTR entry$[rsp]
  001f0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  001f5	e8 00 00 00 00	 call	 set_add_entry
  001fa	83 f8 ff	 cmp	 eax, -1
  001fd	75 0e		 jne	 SHORT $LN1@set_differ@4

; 1637 :                 Py_DECREF(result);

  001ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00204	e8 00 00 00 00	 call	 _Py_DecRef

; 1638 :                 return NULL;

  00209	33 c0		 xor	 eax, eax
  0020b	eb 07		 jmp	 SHORT $LN15@set_differ@4
$LN1@set_differ@4:
$LN2@set_differ@4:

; 1639 :             }
; 1640 :         }
; 1641 :     }

  0020d	eb 95		 jmp	 SHORT $LN5@set_differ@4
$LN4@set_differ@4:

; 1642 :     return result;

  0020f	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN15@set_differ@4:

; 1643 : }

  00214	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00218	c3		 ret	 0
set_difference ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_copy_and_difference DD imagerel set_copy_and_difference
	DD	imagerel set_copy_and_difference+85
	DD	imagerel $unwind$set_copy_and_difference
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_copy_and_difference DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_copy_and_difference
_TEXT	SEGMENT
result$ = 32
so$ = 64
other$ = 72
set_copy_and_difference PROC				; COMDAT

; 1580 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1581 :     PyObject *result;
; 1582 : 
; 1583 :     result = set_copy(so);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00013	e8 00 00 00 00	 call	 set_copy
  00018	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1584 :     if (result == NULL)

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00023	75 04		 jne	 SHORT $LN2@set_copy_a

; 1585 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 27		 jmp	 SHORT $LN3@set_copy_a
$LN2@set_copy_a:

; 1586 :     if (set_difference_update_internal((PySetObject *) result, other) != -1)

  00029	48 8b 54 24 48	 mov	 rdx, QWORD PTR other$[rsp]
  0002e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00033	e8 00 00 00 00	 call	 set_difference_update_internal
  00038	83 f8 ff	 cmp	 eax, -1
  0003b	74 07		 je	 SHORT $LN1@set_copy_a

; 1587 :         return result;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00042	eb 0c		 jmp	 SHORT $LN3@set_copy_a
$LN1@set_copy_a:

; 1588 :     Py_DECREF(result);

  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00049	e8 00 00 00 00	 call	 _Py_DecRef

; 1589 :     return NULL;

  0004e	33 c0		 xor	 eax, eax
$LN3@set_copy_a:

; 1590 : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
set_copy_and_difference ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_sub DD imagerel set_sub
	DD	imagerel set_sub+227
	DD	imagerel $unwind$set_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_sub DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_sub
_TEXT	SEGMENT
so$ = 48
other$ = 56
set_sub	PROC						; COMDAT

; 1675 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1676 :     if (!PyAnySet_Check(so) || !PyAnySet_Check(other))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 44		 je	 SHORT $LN1@set_sub
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 32		 je	 SHORT $LN1@set_sub
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR so$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 19		 jne	 SHORT $LN1@set_sub
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR so$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	74 56		 je	 SHORT $LN2@set_sub
$LN1@set_sub:
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0006b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  00070	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00074	74 59		 je	 SHORT $LN3@set_sub
  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  00082	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00086	74 47		 je	 SHORT $LN3@set_sub
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0008f	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  00094	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00098	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009d	85 c0		 test	 eax, eax
  0009f	75 2e		 jne	 SHORT $LN3@set_sub
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  000a8	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  000ad	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000b1	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b6	85 c0		 test	 eax, eax
  000b8	75 15		 jne	 SHORT $LN3@set_sub
$LN2@set_sub:

; 1677 :         Py_RETURN_NOTIMPLEMENTED;

  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  000c1	e8 00 00 00 00	 call	 _Py_IncRef
  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000cd	eb 0f		 jmp	 SHORT $LN4@set_sub
$LN3@set_sub:

; 1678 :     return set_difference(so, other);

  000cf	48 8b 54 24 38	 mov	 rdx, QWORD PTR other$[rsp]
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  000d9	e8 00 00 00 00	 call	 set_difference
$LN4@set_sub:

; 1679 : }

  000de	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e2	c3		 ret	 0
set_sub	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_isub DD imagerel set_isub
	DD	imagerel set_isub+165
	DD	imagerel $unwind$set_isub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_isub DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_isub
_TEXT	SEGMENT
so$ = 48
other$ = 56
set_isub PROC						; COMDAT

; 1683 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1684 :     if (!PyAnySet_Check(other))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 59		 je	 SHORT $LN2@set_isub
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 47		 je	 SHORT $LN2@set_isub
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 2e		 jne	 SHORT $LN2@set_isub
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 15		 jne	 SHORT $LN2@set_isub

; 1685 :         Py_RETURN_NOTIMPLEMENTED;

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00077	eb 27		 jmp	 SHORT $LN3@set_isub
$LN2@set_isub:

; 1686 :     if (set_difference_update_internal(so, other) == -1)

  00079	48 8b 54 24 38	 mov	 rdx, QWORD PTR other$[rsp]
  0007e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  00083	e8 00 00 00 00	 call	 set_difference_update_internal
  00088	83 f8 ff	 cmp	 eax, -1
  0008b	75 04		 jne	 SHORT $LN1@set_isub

; 1687 :         return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 0f		 jmp	 SHORT $LN3@set_isub
$LN1@set_isub:

; 1688 :     Py_INCREF(so);

  00091	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  00096	e8 00 00 00 00	 call	 _Py_IncRef

; 1689 :     return (PyObject *)so;

  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR so$[rsp]
$LN3@set_isub:

; 1690 : }

  000a0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a4	c3		 ret	 0
set_isub ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_symmetric_difference_update DD imagerel set_symmetric_difference_update
	DD	imagerel set_symmetric_difference_update+637
	DD	imagerel $unwind$set_symmetric_difference_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_symmetric_difference_update DD 021101H
	DD	0110111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_symmetric_difference_update
_TEXT	SEGMENT
otherset$ = 48
key$ = 56
entry$ = 64
pos$ = 72
value$21898 = 80
rv$21899 = 88
hash$21900 = 96
an_entry$21904 = 104
rv$21932 = 120
so$ = 144
other$ = 152
set_symmetric_difference_update PROC			; COMDAT

; 1694 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1695 :     PySetObject *otherset;
; 1696 :     PyObject *key;
; 1697 :     Py_ssize_t pos = 0;

  00011	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0

; 1698 :     setentry *entry;
; 1699 : 
; 1700 :     if ((PyObject *)so == other)

  0001a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  00022	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR so$[rsp], rax
  0002a	75 12		 jne	 SHORT $LN17@set_symmet

; 1701 :         return set_clear(so);

  0002c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00034	e8 00 00 00 00	 call	 set_clear
  00039	e9 37 02 00 00	 jmp	 $LN18@set_symmet
$LN17@set_symmet:

; 1702 : 
; 1703 :     if (PyDict_CheckExact(other)) {

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00045	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  0004d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00051	74 19		 je	 SHORT $LN15@set_symmet
  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  0005a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  00062	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  00066	0f 85 d0 00 00
	00		 jne	 $LN16@set_symmet
$LN15@set_symmet:
$LN14@set_symmet:

; 1704 :         PyObject *value;
; 1705 :         int rv;
; 1706 :         Py_hash_t hash;
; 1707 :         while (_PyDict_Next(other, &pos, &key, &value, &hash)) {

  0006c	48 8d 44 24 60	 lea	 rax, QWORD PTR hash$21900[rsp]
  00071	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00076	4c 8d 4c 24 50	 lea	 r9, QWORD PTR value$21898[rsp]
  0007b	4c 8d 44 24 38	 lea	 r8, QWORD PTR key$[rsp]
  00080	48 8d 54 24 48	 lea	 rdx, QWORD PTR pos$[rsp]
  00085	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  0008d	e8 00 00 00 00	 call	 _PyDict_Next
  00092	85 c0		 test	 eax, eax
  00094	0f 84 8a 00 00
	00		 je	 $LN13@set_symmet

; 1708 :             setentry an_entry;
; 1709 : 
; 1710 :             Py_INCREF(key);

  0009a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  0009f	e8 00 00 00 00	 call	 _Py_IncRef

; 1711 :             an_entry.hash = hash;

  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR hash$21900[rsp]
  000a9	48 89 44 24 68	 mov	 QWORD PTR an_entry$21904[rsp], rax

; 1712 :             an_entry.key = key;

  000ae	48 8b 44 24 38	 mov	 rax, QWORD PTR key$[rsp]
  000b3	48 89 44 24 70	 mov	 QWORD PTR an_entry$21904[rsp+8], rax

; 1713 : 
; 1714 :             rv = set_discard_entry(so, &an_entry);

  000b8	48 8d 54 24 68	 lea	 rdx, QWORD PTR an_entry$21904[rsp]
  000bd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  000c5	e8 00 00 00 00	 call	 set_discard_entry
  000ca	89 44 24 58	 mov	 DWORD PTR rv$21899[rsp], eax

; 1715 :             if (rv == -1) {

  000ce	83 7c 24 58 ff	 cmp	 DWORD PTR rv$21899[rsp], -1
  000d3	75 11		 jne	 SHORT $LN12@set_symmet

; 1716 :                 Py_DECREF(key);

  000d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  000da	e8 00 00 00 00	 call	 _Py_DecRef

; 1717 :                 return NULL;

  000df	33 c0		 xor	 eax, eax
  000e1	e9 8f 01 00 00	 jmp	 $LN18@set_symmet
$LN12@set_symmet:

; 1718 :             }
; 1719 :             if (rv == DISCARD_NOTFOUND) {

  000e6	83 7c 24 58 00	 cmp	 DWORD PTR rv$21899[rsp], 0
  000eb	75 28		 jne	 SHORT $LN11@set_symmet

; 1720 :                 if (set_add_entry(so, &an_entry) == -1) {

  000ed	48 8d 54 24 68	 lea	 rdx, QWORD PTR an_entry$21904[rsp]
  000f2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  000fa	e8 00 00 00 00	 call	 set_add_entry
  000ff	83 f8 ff	 cmp	 eax, -1
  00102	75 11		 jne	 SHORT $LN10@set_symmet

; 1721 :                     Py_DECREF(key);

  00104	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  00109	e8 00 00 00 00	 call	 _Py_DecRef

; 1722 :                     return NULL;

  0010e	33 c0		 xor	 eax, eax
  00110	e9 60 01 00 00	 jmp	 $LN18@set_symmet
$LN10@set_symmet:
$LN11@set_symmet:

; 1723 :                 }
; 1724 :             }
; 1725 :             Py_DECREF(key);

  00115	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  0011a	e8 00 00 00 00	 call	 _Py_DecRef

; 1726 :         }

  0011f	e9 48 ff ff ff	 jmp	 $LN14@set_symmet
$LN13@set_symmet:

; 1727 :         Py_RETURN_NONE;

  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0012b	e8 00 00 00 00	 call	 _Py_IncRef
  00130	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00137	e9 39 01 00 00	 jmp	 $LN18@set_symmet
$LN16@set_symmet:

; 1728 :     }
; 1729 : 
; 1730 :     if (PyAnySet_Check(other)) {

  0013c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00143	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  0014b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0014f	74 4d		 je	 SHORT $LN8@set_symmet
  00151	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00158	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  00160	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00164	74 38		 je	 SHORT $LN8@set_symmet
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0016d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  00175	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00179	e8 00 00 00 00	 call	 PyType_IsSubtype
  0017e	85 c0		 test	 eax, eax
  00180	75 1c		 jne	 SHORT $LN8@set_symmet
  00182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00189	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  00191	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00195	e8 00 00 00 00	 call	 PyType_IsSubtype
  0019a	85 c0		 test	 eax, eax
  0019c	74 1c		 je	 SHORT $LN9@set_symmet
$LN8@set_symmet:

; 1731 :         Py_INCREF(other);

  0019e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  001a6	e8 00 00 00 00	 call	 _Py_IncRef

; 1732 :         otherset = (PySetObject *)other;

  001ab	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR other$[rsp]
  001b3	48 89 44 24 30	 mov	 QWORD PTR otherset$[rsp], rax

; 1733 :     } else {

  001b8	eb 2d		 jmp	 SHORT $LN7@set_symmet
$LN9@set_symmet:

; 1734 :         otherset = (PySetObject *)make_new_set_basetype(Py_TYPE(so), other);

  001ba	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR other$[rsp]
  001c2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  001ca	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001ce	e8 00 00 00 00	 call	 make_new_set_basetype
  001d3	48 89 44 24 30	 mov	 QWORD PTR otherset$[rsp], rax

; 1735 :         if (otherset == NULL)

  001d8	48 83 7c 24 30
	00		 cmp	 QWORD PTR otherset$[rsp], 0
  001de	75 07		 jne	 SHORT $LN6@set_symmet

; 1736 :             return NULL;

  001e0	33 c0		 xor	 eax, eax
  001e2	e9 8e 00 00 00	 jmp	 $LN18@set_symmet
$LN6@set_symmet:
$LN7@set_symmet:
$LN5@set_symmet:

; 1737 :     }
; 1738 : 
; 1739 :     while (set_next(otherset, &pos, &entry)) {

  001e7	4c 8d 44 24 40	 lea	 r8, QWORD PTR entry$[rsp]
  001ec	48 8d 54 24 48	 lea	 rdx, QWORD PTR pos$[rsp]
  001f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR otherset$[rsp]
  001f6	e8 00 00 00 00	 call	 set_next
  001fb	85 c0		 test	 eax, eax
  001fd	74 59		 je	 SHORT $LN4@set_symmet

; 1740 :         int rv = set_discard_entry(so, entry);

  001ff	48 8b 54 24 40	 mov	 rdx, QWORD PTR entry$[rsp]
  00204	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  0020c	e8 00 00 00 00	 call	 set_discard_entry
  00211	89 44 24 78	 mov	 DWORD PTR rv$21932[rsp], eax

; 1741 :         if (rv == -1) {

  00215	83 7c 24 78 ff	 cmp	 DWORD PTR rv$21932[rsp], -1
  0021a	75 0e		 jne	 SHORT $LN3@set_symmet

; 1742 :             Py_DECREF(otherset);

  0021c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR otherset$[rsp]
  00221	e8 00 00 00 00	 call	 _Py_DecRef

; 1743 :             return NULL;

  00226	33 c0		 xor	 eax, eax
  00228	eb 4b		 jmp	 SHORT $LN18@set_symmet
$LN3@set_symmet:

; 1744 :         }
; 1745 :         if (rv == DISCARD_NOTFOUND) {

  0022a	83 7c 24 78 00	 cmp	 DWORD PTR rv$21932[rsp], 0
  0022f	75 25		 jne	 SHORT $LN2@set_symmet

; 1746 :             if (set_add_entry(so, entry) == -1) {

  00231	48 8b 54 24 40	 mov	 rdx, QWORD PTR entry$[rsp]
  00236	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  0023e	e8 00 00 00 00	 call	 set_add_entry
  00243	83 f8 ff	 cmp	 eax, -1
  00246	75 0e		 jne	 SHORT $LN1@set_symmet

; 1747 :                 Py_DECREF(otherset);

  00248	48 8b 4c 24 30	 mov	 rcx, QWORD PTR otherset$[rsp]
  0024d	e8 00 00 00 00	 call	 _Py_DecRef

; 1748 :                 return NULL;

  00252	33 c0		 xor	 eax, eax
  00254	eb 1f		 jmp	 SHORT $LN18@set_symmet
$LN1@set_symmet:
$LN2@set_symmet:

; 1749 :             }
; 1750 :         }
; 1751 :     }

  00256	eb 8f		 jmp	 SHORT $LN5@set_symmet
$LN4@set_symmet:

; 1752 :     Py_DECREF(otherset);

  00258	48 8b 4c 24 30	 mov	 rcx, QWORD PTR otherset$[rsp]
  0025d	e8 00 00 00 00	 call	 _Py_DecRef

; 1753 :     Py_RETURN_NONE;

  00262	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00269	e8 00 00 00 00	 call	 _Py_IncRef
  0026e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN18@set_symmet:

; 1754 : }

  00275	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0027c	c3		 ret	 0
set_symmetric_difference_update ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_symmetric_difference DD imagerel set_symmetric_difference
	DD	imagerel set_symmetric_difference+102
	DD	imagerel $unwind$set_symmetric_difference
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_symmetric_difference DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_symmetric_difference
_TEXT	SEGMENT
otherset$ = 32
rv$ = 40
so$ = 64
other$ = 72
set_symmetric_difference PROC				; COMDAT

; 1761 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1762 :     PyObject *rv;
; 1763 :     PySetObject *otherset;
; 1764 : 
; 1765 :     otherset = (PySetObject *)make_new_set_basetype(Py_TYPE(so), other);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR other$[rsp]
  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00018	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0001c	e8 00 00 00 00	 call	 make_new_set_basetype
  00021	48 89 44 24 20	 mov	 QWORD PTR otherset$[rsp], rax

; 1766 :     if (otherset == NULL)

  00026	48 83 7c 24 20
	00		 cmp	 QWORD PTR otherset$[rsp], 0
  0002c	75 04		 jne	 SHORT $LN2@set_symmet@2

; 1767 :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 2f		 jmp	 SHORT $LN3@set_symmet@2
$LN2@set_symmet@2:

; 1768 :     rv = set_symmetric_difference_update(otherset, (PyObject *)so);

  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR so$[rsp]
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR otherset$[rsp]
  0003c	e8 00 00 00 00	 call	 set_symmetric_difference_update
  00041	48 89 44 24 28	 mov	 QWORD PTR rv$[rsp], rax

; 1769 :     if (rv == NULL)

  00046	48 83 7c 24 28
	00		 cmp	 QWORD PTR rv$[rsp], 0
  0004c	75 04		 jne	 SHORT $LN1@set_symmet@2

; 1770 :         return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	eb 0f		 jmp	 SHORT $LN3@set_symmet@2
$LN1@set_symmet@2:

; 1771 :     Py_DECREF(rv);

  00052	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rv$[rsp]
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 1772 :     return (PyObject *)otherset;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR otherset$[rsp]
$LN3@set_symmet@2:

; 1773 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
set_symmetric_difference ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_xor DD imagerel set_xor
	DD	imagerel set_xor+227
	DD	imagerel $unwind$set_xor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_xor DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_xor
_TEXT	SEGMENT
so$ = 48
other$ = 56
set_xor	PROC						; COMDAT

; 1782 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1783 :     if (!PyAnySet_Check(so) || !PyAnySet_Check(other))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 44		 je	 SHORT $LN1@set_xor
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 32		 je	 SHORT $LN1@set_xor
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR so$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 19		 jne	 SHORT $LN1@set_xor
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR so$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	74 56		 je	 SHORT $LN2@set_xor
$LN1@set_xor:
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0006b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  00070	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00074	74 59		 je	 SHORT $LN3@set_xor
  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  00082	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00086	74 47		 je	 SHORT $LN3@set_xor
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0008f	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  00094	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00098	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009d	85 c0		 test	 eax, eax
  0009f	75 2e		 jne	 SHORT $LN3@set_xor
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  000a8	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  000ad	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000b1	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b6	85 c0		 test	 eax, eax
  000b8	75 15		 jne	 SHORT $LN3@set_xor
$LN2@set_xor:

; 1784 :         Py_RETURN_NOTIMPLEMENTED;

  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  000c1	e8 00 00 00 00	 call	 _Py_IncRef
  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000cd	eb 0f		 jmp	 SHORT $LN4@set_xor
$LN3@set_xor:

; 1785 :     return set_symmetric_difference(so, other);

  000cf	48 8b 54 24 38	 mov	 rdx, QWORD PTR other$[rsp]
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  000d9	e8 00 00 00 00	 call	 set_symmetric_difference
$LN4@set_xor:

; 1786 : }

  000de	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e2	c3		 ret	 0
set_xor	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_ixor DD imagerel set_ixor
	DD	imagerel set_ixor+183
	DD	imagerel $unwind$set_ixor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_ixor DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_ixor
_TEXT	SEGMENT
result$ = 32
so$ = 64
other$ = 72
set_ixor PROC						; COMDAT

; 1790 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1791 :     PyObject *result;
; 1792 : 
; 1793 :     if (!PyAnySet_Check(other))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 59		 je	 SHORT $LN2@set_ixor
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 47		 je	 SHORT $LN2@set_ixor
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 2e		 jne	 SHORT $LN2@set_ixor
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 15		 jne	 SHORT $LN2@set_ixor

; 1794 :         Py_RETURN_NOTIMPLEMENTED;

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00077	eb 39		 jmp	 SHORT $LN3@set_ixor
$LN2@set_ixor:

; 1795 :     result = set_symmetric_difference_update(so, other);

  00079	48 8b 54 24 48	 mov	 rdx, QWORD PTR other$[rsp]
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00083	e8 00 00 00 00	 call	 set_symmetric_difference_update
  00088	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1796 :     if (result == NULL)

  0008d	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00093	75 04		 jne	 SHORT $LN1@set_ixor

; 1797 :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	eb 19		 jmp	 SHORT $LN3@set_ixor
$LN1@set_ixor:

; 1798 :     Py_DECREF(result);

  00099	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0009e	e8 00 00 00 00	 call	 _Py_DecRef

; 1799 :     Py_INCREF(so);

  000a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  000a8	e8 00 00 00 00	 call	 _Py_IncRef

; 1800 :     return (PyObject *)so;

  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
$LN3@set_ixor:

; 1801 : }

  000b2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b6	c3		 ret	 0
set_ixor ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_issubset DD imagerel set_issubset
	DD	imagerel set_issubset+339
	DD	imagerel $unwind$set_issubset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_issubset DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_issubset
_TEXT	SEGMENT
entry$ = 32
pos$ = 40
tmp$22013 = 48
result$22014 = 56
rv$22028 = 64
so$ = 96
other$ = 104
set_issubset PROC					; COMDAT

; 1805 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1806 :     setentry *entry;
; 1807 :     Py_ssize_t pos = 0;

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0

; 1808 : 
; 1809 :     if (!PyAnySet_Check(other)) {

  00017	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0001e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR other$[rsp]
  00023	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00027	0f 84 91 00 00
	00		 je	 $LN7@set_issubs
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00034	48 8b 4c 24 68	 mov	 rcx, QWORD PTR other$[rsp]
  00039	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003d	74 7f		 je	 SHORT $LN7@set_issubs
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00046	48 8b 44 24 68	 mov	 rax, QWORD PTR other$[rsp]
  0004b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00054	85 c0		 test	 eax, eax
  00056	75 66		 jne	 SHORT $LN7@set_issubs
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0005f	48 8b 44 24 68	 mov	 rax, QWORD PTR other$[rsp]
  00064	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00068	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006d	85 c0		 test	 eax, eax
  0006f	75 4d		 jne	 SHORT $LN7@set_issubs

; 1810 :         PyObject *tmp, *result;
; 1811 :         tmp = make_new_set(&PySet_Type, other);

  00071	48 8b 54 24 68	 mov	 rdx, QWORD PTR other$[rsp]
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySet_Type
  0007d	e8 00 00 00 00	 call	 make_new_set
  00082	48 89 44 24 30	 mov	 QWORD PTR tmp$22013[rsp], rax

; 1812 :         if (tmp == NULL)

  00087	48 83 7c 24 30
	00		 cmp	 QWORD PTR tmp$22013[rsp], 0
  0008d	75 07		 jne	 SHORT $LN6@set_issubs

; 1813 :             return NULL;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 b8 00 00 00	 jmp	 $LN8@set_issubs
$LN6@set_issubs:

; 1814 :         result = set_issubset(so, tmp);

  00096	48 8b 54 24 30	 mov	 rdx, QWORD PTR tmp$22013[rsp]
  0009b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  000a0	e8 00 00 00 00	 call	 set_issubset
  000a5	48 89 44 24 38	 mov	 QWORD PTR result$22014[rsp], rax

; 1815 :         Py_DECREF(tmp);

  000aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp$22013[rsp]
  000af	e8 00 00 00 00	 call	 _Py_DecRef

; 1816 :         return result;

  000b4	48 8b 44 24 38	 mov	 rax, QWORD PTR result$22014[rsp]
  000b9	e9 90 00 00 00	 jmp	 $LN8@set_issubs
$LN7@set_issubs:

; 1817 :     }
; 1818 :     if (PySet_GET_SIZE(so) > PySet_GET_SIZE(other))

  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR so$[rsp]
  000c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR other$[rsp]
  000c8	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000cc	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  000d0	7e 15		 jle	 SHORT $LN5@set_issubs

; 1819 :         Py_RETURN_FALSE;

  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000d9	e8 00 00 00 00	 call	 _Py_IncRef
  000de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000e5	eb 67		 jmp	 SHORT $LN8@set_issubs
$LN5@set_issubs:
$LN4@set_issubs:

; 1820 : 
; 1821 :     while (set_next(so, &pos, &entry)) {

  000e7	4c 8d 44 24 20	 lea	 r8, QWORD PTR entry$[rsp]
  000ec	48 8d 54 24 28	 lea	 rdx, QWORD PTR pos$[rsp]
  000f1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR so$[rsp]
  000f6	e8 00 00 00 00	 call	 set_next
  000fb	85 c0		 test	 eax, eax
  000fd	74 3c		 je	 SHORT $LN3@set_issubs

; 1822 :         int rv = set_contains_entry((PySetObject *)other, entry);

  000ff	48 8b 54 24 20	 mov	 rdx, QWORD PTR entry$[rsp]
  00104	48 8b 4c 24 68	 mov	 rcx, QWORD PTR other$[rsp]
  00109	e8 00 00 00 00	 call	 set_contains_entry
  0010e	89 44 24 40	 mov	 DWORD PTR rv$22028[rsp], eax

; 1823 :         if (rv == -1)

  00112	83 7c 24 40 ff	 cmp	 DWORD PTR rv$22028[rsp], -1
  00117	75 04		 jne	 SHORT $LN2@set_issubs

; 1824 :             return NULL;

  00119	33 c0		 xor	 eax, eax
  0011b	eb 31		 jmp	 SHORT $LN8@set_issubs
$LN2@set_issubs:

; 1825 :         if (!rv)

  0011d	83 7c 24 40 00	 cmp	 DWORD PTR rv$22028[rsp], 0
  00122	75 15		 jne	 SHORT $LN1@set_issubs

; 1826 :             Py_RETURN_FALSE;

  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  0012b	e8 00 00 00 00	 call	 _Py_IncRef
  00130	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00137	eb 15		 jmp	 SHORT $LN8@set_issubs
$LN1@set_issubs:

; 1827 :     }

  00139	eb ac		 jmp	 SHORT $LN4@set_issubs
$LN3@set_issubs:

; 1828 :     Py_RETURN_TRUE;

  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00142	e8 00 00 00 00	 call	 _Py_IncRef
  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
$LN8@set_issubs:

; 1829 : }

  0014e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00152	c3		 ret	 0
set_issubset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_issuperset DD imagerel set_issuperset
	DD	imagerel set_issuperset+195
	DD	imagerel $unwind$set_issuperset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_issuperset DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_issuperset
_TEXT	SEGMENT
tmp$ = 32
result$ = 40
so$ = 64
other$ = 72
set_issuperset PROC					; COMDAT

; 1835 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1836 :     PyObject *tmp, *result;
; 1837 : 
; 1838 :     if (!PyAnySet_Check(other)) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	0f 84 8b 00 00
	00		 je	 $LN2@set_issupe
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0002b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  00030	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00034	74 79		 je	 SHORT $LN2@set_issupe
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  00042	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00046	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004b	85 c0		 test	 eax, eax
  0004d	75 60		 jne	 SHORT $LN2@set_issupe
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  0005b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00064	85 c0		 test	 eax, eax
  00066	75 47		 jne	 SHORT $LN2@set_issupe

; 1839 :         tmp = make_new_set(&PySet_Type, other);

  00068	48 8b 54 24 48	 mov	 rdx, QWORD PTR other$[rsp]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySet_Type
  00074	e8 00 00 00 00	 call	 make_new_set
  00079	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 1840 :         if (tmp == NULL)

  0007e	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00084	75 04		 jne	 SHORT $LN1@set_issupe

; 1841 :             return NULL;

  00086	33 c0		 xor	 eax, eax
  00088	eb 34		 jmp	 SHORT $LN3@set_issupe
$LN1@set_issupe:

; 1842 :         result = set_issuperset(so, tmp);

  0008a	48 8b 54 24 20	 mov	 rdx, QWORD PTR tmp$[rsp]
  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00094	e8 00 00 00 00	 call	 set_issuperset
  00099	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1843 :         Py_DECREF(tmp);

  0009e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  000a3	e8 00 00 00 00	 call	 _Py_DecRef

; 1844 :         return result;

  000a8	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
  000ad	eb 0f		 jmp	 SHORT $LN3@set_issupe
$LN2@set_issupe:

; 1845 :     }
; 1846 :     return set_issubset((PySetObject *)other, (PyObject *)so);

  000af	48 8b 54 24 40	 mov	 rdx, QWORD PTR so$[rsp]
  000b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  000b9	e8 00 00 00 00	 call	 set_issubset
$LN3@set_issupe:

; 1847 : }

  000be	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c2	c3		 ret	 0
set_issuperset ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
EXTRN	PyObject_Not:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_richcompare DD imagerel set_richcompare
	DD	imagerel set_richcompare+604
	DD	imagerel $unwind$set_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_richcompare DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_richcompare
_TEXT	SEGMENT
r1$ = 32
r2$ = 40
tv79 = 48
v$ = 80
w$ = 88
op$ = 96
set_richcompare PROC					; COMDAT

; 1853 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1854 :     PyObject *r1, *r2;
; 1855 : 
; 1856 :     if(!PyAnySet_Check(w))

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR w$[rsp]
  0001f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00023	74 5c		 je	 SHORT $LN14@set_richco
  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR w$[rsp]
  00031	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00035	74 4a		 je	 SHORT $LN14@set_richco
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0003e	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  00043	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00047	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004c	85 c0		 test	 eax, eax
  0004e	75 31		 jne	 SHORT $LN14@set_richco
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00057	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  0005c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00060	e8 00 00 00 00	 call	 PyType_IsSubtype
  00065	85 c0		 test	 eax, eax
  00067	75 18		 jne	 SHORT $LN14@set_richco

; 1857 :         Py_RETURN_NOTIMPLEMENTED;

  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00070	e8 00 00 00 00	 call	 _Py_IncRef
  00075	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0007c	e9 bd 01 00 00	 jmp	 $LN15@set_richco
$LN14@set_richco:

; 1858 : 
; 1859 :     switch (op) {

  00081	8b 44 24 60	 mov	 eax, DWORD PTR op$[rsp]
  00085	89 44 24 30	 mov	 DWORD PTR tv79[rsp], eax
  00089	83 7c 24 30 05	 cmp	 DWORD PTR tv79[rsp], 5
  0008e	0f 87 97 01 00
	00		 ja	 $LN12@set_richco
  00094	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv79[rsp]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a0	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN17@set_richco[rcx+rax*4]
  000a7	48 03 c1	 add	 rax, rcx
  000aa	ff e0		 jmp	 rax
$LN11@set_richco:

; 1860 :     case Py_EQ:
; 1861 :         if (PySet_GET_SIZE(v) != PySet_GET_SIZE(w))

  000ac	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  000b1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR w$[rsp]
  000b6	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000ba	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  000be	74 18		 je	 SHORT $LN10@set_richco

; 1862 :             Py_RETURN_FALSE;

  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000c7	e8 00 00 00 00	 call	 _Py_IncRef
  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000d3	e9 66 01 00 00	 jmp	 $LN15@set_richco
$LN10@set_richco:

; 1863 :         if (v->hash != -1  &&
; 1864 :             ((PySetObject *)w)->hash != -1 &&
; 1865 :             v->hash != ((PySetObject *)w)->hash)

  000d8	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  000dd	48 83 b8 08 01
	00 00 ff	 cmp	 QWORD PTR [rax+264], -1
  000e5	74 41		 je	 SHORT $LN9@set_richco
  000e7	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  000ec	48 83 b8 08 01
	00 00 ff	 cmp	 QWORD PTR [rax+264], -1
  000f4	74 32		 je	 SHORT $LN9@set_richco
  000f6	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  000fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR w$[rsp]
  00100	48 8b 89 08 01
	00 00		 mov	 rcx, QWORD PTR [rcx+264]
  00107	48 39 88 08 01
	00 00		 cmp	 QWORD PTR [rax+264], rcx
  0010e	74 18		 je	 SHORT $LN9@set_richco

; 1866 :             Py_RETURN_FALSE;

  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00117	e8 00 00 00 00	 call	 _Py_IncRef
  0011c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00123	e9 16 01 00 00	 jmp	 $LN15@set_richco
$LN9@set_richco:

; 1867 :         return set_issubset(v, w);

  00128	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  0012d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00132	e8 00 00 00 00	 call	 set_issubset
  00137	e9 02 01 00 00	 jmp	 $LN15@set_richco
$LN8@set_richco:

; 1868 :     case Py_NE:
; 1869 :         r1 = set_richcompare(v, w, Py_EQ);

  0013c	41 b8 02 00 00
	00		 mov	 r8d, 2
  00142	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  00147	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0014c	e8 00 00 00 00	 call	 set_richcompare
  00151	48 89 44 24 20	 mov	 QWORD PTR r1$[rsp], rax

; 1870 :         if (r1 == NULL)

  00156	48 83 7c 24 20
	00		 cmp	 QWORD PTR r1$[rsp], 0
  0015c	75 07		 jne	 SHORT $LN7@set_richco

; 1871 :             return NULL;

  0015e	33 c0		 xor	 eax, eax
  00160	e9 d9 00 00 00	 jmp	 $LN15@set_richco
$LN7@set_richco:

; 1872 :         r2 = PyBool_FromLong(PyObject_Not(r1));

  00165	48 8b 4c 24 20	 mov	 rcx, QWORD PTR r1$[rsp]
  0016a	e8 00 00 00 00	 call	 PyObject_Not
  0016f	8b c8		 mov	 ecx, eax
  00171	e8 00 00 00 00	 call	 PyBool_FromLong
  00176	48 89 44 24 28	 mov	 QWORD PTR r2$[rsp], rax

; 1873 :         Py_DECREF(r1);

  0017b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR r1$[rsp]
  00180	e8 00 00 00 00	 call	 _Py_DecRef

; 1874 :         return r2;

  00185	48 8b 44 24 28	 mov	 rax, QWORD PTR r2$[rsp]
  0018a	e9 af 00 00 00	 jmp	 $LN15@set_richco
$LN6@set_richco:

; 1875 :     case Py_LE:
; 1876 :         return set_issubset(v, w);

  0018f	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  00194	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00199	e8 00 00 00 00	 call	 set_issubset
  0019e	e9 9b 00 00 00	 jmp	 $LN15@set_richco
$LN5@set_richco:

; 1877 :     case Py_GE:
; 1878 :         return set_issuperset(v, w);

  001a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  001a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  001ad	e8 00 00 00 00	 call	 set_issuperset
  001b2	e9 87 00 00 00	 jmp	 $LN15@set_richco
$LN4@set_richco:

; 1879 :     case Py_LT:
; 1880 :         if (PySet_GET_SIZE(v) >= PySet_GET_SIZE(w))

  001b7	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  001bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR w$[rsp]
  001c1	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  001c5	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  001c9	7c 15		 jl	 SHORT $LN3@set_richco

; 1881 :             Py_RETURN_FALSE;

  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  001d2	e8 00 00 00 00	 call	 _Py_IncRef
  001d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  001de	eb 5e		 jmp	 SHORT $LN15@set_richco
$LN3@set_richco:

; 1882 :         return set_issubset(v, w);

  001e0	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  001e5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  001ea	e8 00 00 00 00	 call	 set_issubset
  001ef	eb 4d		 jmp	 SHORT $LN15@set_richco
$LN2@set_richco:

; 1883 :     case Py_GT:
; 1884 :         if (PySet_GET_SIZE(v) <= PySet_GET_SIZE(w))

  001f1	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  001f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR w$[rsp]
  001fb	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  001ff	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00203	7f 15		 jg	 SHORT $LN1@set_richco

; 1885 :             Py_RETURN_FALSE;

  00205	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  0020c	e8 00 00 00 00	 call	 _Py_IncRef
  00211	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00218	eb 24		 jmp	 SHORT $LN15@set_richco
$LN1@set_richco:

; 1886 :         return set_issuperset(v, w);

  0021a	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  0021f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00224	e8 00 00 00 00	 call	 set_issuperset
  00229	eb 13		 jmp	 SHORT $LN15@set_richco
$LN12@set_richco:

; 1887 :     }
; 1888 :     Py_RETURN_NOTIMPLEMENTED;

  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00232	e8 00 00 00 00	 call	 _Py_IncRef
  00237	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN15@set_richco:

; 1889 : }

  0023e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00242	c3		 ret	 0
  00243	90		 npad	 1
$LN17@set_richco:
  00244	00 00 00 00	 DD	 $LN4@set_richco
  00248	00 00 00 00	 DD	 $LN6@set_richco
  0024c	00 00 00 00	 DD	 $LN11@set_richco
  00250	00 00 00 00	 DD	 $LN8@set_richco
  00254	00 00 00 00	 DD	 $LN2@set_richco
  00258	00 00 00 00	 DD	 $LN5@set_richco
set_richcompare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_add DD imagerel set_add
	DD	imagerel set_add+62
	DD	imagerel $unwind$set_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_add DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_add
_TEXT	SEGMENT
so$ = 48
key$ = 56
set_add	PROC						; COMDAT

; 1893 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1894 :     if (set_add_key(so, key) == -1)

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR so$[rsp]
  00018	e8 00 00 00 00	 call	 set_add_key
  0001d	83 f8 ff	 cmp	 eax, -1
  00020	75 04		 jne	 SHORT $LN1@set_add

; 1895 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	eb 13		 jmp	 SHORT $LN2@set_add
$LN1@set_add:

; 1896 :     Py_RETURN_NONE;

  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0002d	e8 00 00 00 00	 call	 _Py_IncRef
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@set_add:

; 1897 : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
set_add	ENDP
_TEXT	ENDS
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_contains DD imagerel set_contains
	DD	imagerel set_contains+190
	DD	imagerel $unwind$set_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_contains DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_contains
_TEXT	SEGMENT
rv$ = 32
tmpkey$ = 40
so$ = 64
key$ = 72
set_contains PROC					; COMDAT

; 1906 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1907 :     PyObject *tmpkey;
; 1908 :     int rv;
; 1909 : 
; 1910 :     rv = set_contains_key(so, key);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00018	e8 00 00 00 00	 call	 set_contains_key
  0001d	89 44 24 20	 mov	 DWORD PTR rv$[rsp], eax

; 1911 :     if (rv == -1) {

  00021	83 7c 24 20 ff	 cmp	 DWORD PTR rv$[rsp], -1
  00026	0f 85 89 00 00
	00		 jne	 $LN5@set_contai@2

; 1912 :         if (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))

  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00033	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00038	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003c	74 19		 je	 SHORT $LN2@set_contai@2
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0004a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00053	85 c0		 test	 eax, eax
  00055	74 10		 je	 SHORT $LN3@set_contai@2
$LN2@set_contai@2:
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0005e	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00063	85 c0		 test	 eax, eax
  00065	75 07		 jne	 SHORT $LN4@set_contai@2
$LN3@set_contai@2:

; 1913 :             return -1;

  00067	b8 ff ff ff ff	 mov	 eax, -1
  0006c	eb 4b		 jmp	 SHORT $LN6@set_contai@2
$LN4@set_contai@2:

; 1914 :         PyErr_Clear();

  0006e	e8 00 00 00 00	 call	 PyErr_Clear

; 1915 :         tmpkey = make_new_set(&PyFrozenSet_Type, key);

  00073	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFrozenSet_Type
  0007f	e8 00 00 00 00	 call	 make_new_set
  00084	48 89 44 24 28	 mov	 QWORD PTR tmpkey$[rsp], rax

; 1916 :         if (tmpkey == NULL)

  00089	48 83 7c 24 28
	00		 cmp	 QWORD PTR tmpkey$[rsp], 0
  0008f	75 07		 jne	 SHORT $LN1@set_contai@2

; 1917 :             return -1;

  00091	b8 ff ff ff ff	 mov	 eax, -1
  00096	eb 21		 jmp	 SHORT $LN6@set_contai@2
$LN1@set_contai@2:

; 1918 :         rv = set_contains_key(so, tmpkey);

  00098	48 8b 54 24 28	 mov	 rdx, QWORD PTR tmpkey$[rsp]
  0009d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  000a2	e8 00 00 00 00	 call	 set_contains_key
  000a7	89 44 24 20	 mov	 DWORD PTR rv$[rsp], eax

; 1919 :         Py_DECREF(tmpkey);

  000ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmpkey$[rsp]
  000b0	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@set_contai@2:

; 1920 :     }
; 1921 :     return rv;

  000b5	8b 44 24 20	 mov	 eax, DWORD PTR rv$[rsp]
$LN6@set_contai@2:

; 1922 : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
set_contains ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_contains_key DD imagerel set_contains_key
	DD	imagerel set_contains_key+193
	DD	imagerel $unwind$set_contains_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_contains_key DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_contains_key
_TEXT	SEGMENT
entry$ = 32
hash$ = 40
tv80 = 48
so$ = 80
key$ = 88
set_contains_key PROC					; COMDAT

; 672  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 673  :     Py_hash_t hash;
; 674  :     setentry *entry;
; 675  : 
; 676  :     if (!PyUnicode_CheckExact(key) ||
; 677  :         (hash = ((PyASCIIObject *) key)->hash) == -1) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00015	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	75 16		 jne	 SHORT $LN3@set_contai@3
  00020	48 8b 44 24 58	 mov	 rax, QWORD PTR key$[rsp]
  00025	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00029	48 89 44 24 28	 mov	 QWORD PTR hash$[rsp], rax
  0002e	48 83 7c 24 28
	ff		 cmp	 QWORD PTR hash$[rsp], -1
  00034	75 1e		 jne	 SHORT $LN4@set_contai@3
$LN3@set_contai@3:

; 678  :         hash = PyObject_Hash(key);

  00036	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0003b	e8 00 00 00 00	 call	 PyObject_Hash
  00040	48 89 44 24 28	 mov	 QWORD PTR hash$[rsp], rax

; 679  :         if (hash == -1)

  00045	48 83 7c 24 28
	ff		 cmp	 QWORD PTR hash$[rsp], -1
  0004b	75 07		 jne	 SHORT $LN2@set_contai@3

; 680  :             return -1;

  0004d	b8 ff ff ff ff	 mov	 eax, -1
  00052	eb 68		 jmp	 SHORT $LN5@set_contai@3
$LN2@set_contai@3:
$LN4@set_contai@3:

; 681  :     }
; 682  :     entry = (so->lookup)(so, key, hash);

  00054	4c 8b 44 24 28	 mov	 r8, QWORD PTR hash$[rsp]
  00059	48 8b 54 24 58	 mov	 rdx, QWORD PTR key$[rsp]
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  00068	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0006e	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 683  :     if (entry == NULL)

  00073	48 83 7c 24 20
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00079	75 07		 jne	 SHORT $LN1@set_contai@3

; 684  :         return -1;

  0007b	b8 ff ff ff ff	 mov	 eax, -1
  00080	eb 3a		 jmp	 SHORT $LN5@set_contai@3
$LN1@set_contai@3:

; 685  :     key = entry->key;

  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00087	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008b	48 89 44 24 58	 mov	 QWORD PTR key$[rsp], rax

; 686  :     return key != NULL && key != dummy;

  00090	48 83 7c 24 58
	00		 cmp	 QWORD PTR key$[rsp], 0
  00096	74 18		 je	 SHORT $LN7@set_contai@3
  00098	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dummy
  0009f	48 39 44 24 58	 cmp	 QWORD PTR key$[rsp], rax
  000a4	74 0a		 je	 SHORT $LN7@set_contai@3
  000a6	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  000ae	eb 08		 jmp	 SHORT $LN8@set_contai@3
$LN7@set_contai@3:
  000b0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN8@set_contai@3:
  000b8	8b 44 24 30	 mov	 eax, DWORD PTR tv80[rsp]
$LN5@set_contai@3:

; 687  : }

  000bc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c0	c3		 ret	 0
set_contains_key ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_direct_contains DD imagerel set_direct_contains
	DD	imagerel set_direct_contains+58
	DD	imagerel $unwind$set_direct_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_direct_contains DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_direct_contains
_TEXT	SEGMENT
result$ = 32
so$ = 64
key$ = 72
set_direct_contains PROC				; COMDAT

; 1926 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1927 :     long result;
; 1928 : 
; 1929 :     result = set_contains(so, key);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00018	e8 00 00 00 00	 call	 set_contains
  0001d	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 1930 :     if (result == -1)

  00021	83 7c 24 20 ff	 cmp	 DWORD PTR result$[rsp], -1
  00026	75 04		 jne	 SHORT $LN1@set_direct

; 1931 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 09		 jmp	 SHORT $LN2@set_direct
$LN1@set_direct:

; 1932 :     return PyBool_FromLong(result);

  0002c	8b 4c 24 20	 mov	 ecx, DWORD PTR result$[rsp]
  00030	e8 00 00 00 00	 call	 PyBool_FromLong
$LN2@set_direct:

; 1933 : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
set_direct_contains ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_remove DD imagerel set_remove
	DD	imagerel set_remove+231
	DD	imagerel $unwind$set_remove
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_remove DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_remove
_TEXT	SEGMENT
rv$ = 32
tmpkey$ = 40
so$ = 64
key$ = 72
set_remove PROC						; COMDAT

; 1939 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1940 :     PyObject *tmpkey;
; 1941 :     int rv;
; 1942 : 
; 1943 :     rv = set_discard_key(so, key);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00018	e8 00 00 00 00	 call	 set_discard_key
  0001d	89 44 24 20	 mov	 DWORD PTR rv$[rsp], eax

; 1944 :     if (rv == -1) {

  00021	83 7c 24 20 ff	 cmp	 DWORD PTR rv$[rsp], -1
  00026	0f 85 8e 00 00
	00		 jne	 $LN7@set_remove

; 1945 :         if (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))

  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00033	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00038	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003c	74 19		 je	 SHORT $LN4@set_remove
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0004a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00053	85 c0		 test	 eax, eax
  00055	74 10		 je	 SHORT $LN5@set_remove
$LN4@set_remove:
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0005e	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00063	85 c0		 test	 eax, eax
  00065	75 04		 jne	 SHORT $LN6@set_remove
$LN5@set_remove:

; 1946 :             return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	eb 77		 jmp	 SHORT $LN8@set_remove
$LN6@set_remove:

; 1947 :         PyErr_Clear();

  0006b	e8 00 00 00 00	 call	 PyErr_Clear

; 1948 :         tmpkey = make_new_set(&PyFrozenSet_Type, key);

  00070	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFrozenSet_Type
  0007c	e8 00 00 00 00	 call	 make_new_set
  00081	48 89 44 24 28	 mov	 QWORD PTR tmpkey$[rsp], rax

; 1949 :         if (tmpkey == NULL)

  00086	48 83 7c 24 28
	00		 cmp	 QWORD PTR tmpkey$[rsp], 0
  0008c	75 04		 jne	 SHORT $LN3@set_remove

; 1950 :             return NULL;

  0008e	33 c0		 xor	 eax, eax
  00090	eb 50		 jmp	 SHORT $LN8@set_remove
$LN3@set_remove:

; 1951 :         rv = set_discard_key(so, tmpkey);

  00092	48 8b 54 24 28	 mov	 rdx, QWORD PTR tmpkey$[rsp]
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  0009c	e8 00 00 00 00	 call	 set_discard_key
  000a1	89 44 24 20	 mov	 DWORD PTR rv$[rsp], eax

; 1952 :         Py_DECREF(tmpkey);

  000a5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmpkey$[rsp]
  000aa	e8 00 00 00 00	 call	 _Py_DecRef

; 1953 :         if (rv == -1)

  000af	83 7c 24 20 ff	 cmp	 DWORD PTR rv$[rsp], -1
  000b4	75 04		 jne	 SHORT $LN2@set_remove

; 1954 :             return NULL;

  000b6	33 c0		 xor	 eax, eax
  000b8	eb 28		 jmp	 SHORT $LN8@set_remove
$LN2@set_remove:
$LN7@set_remove:

; 1955 :     }
; 1956 : 
; 1957 :     if (rv == DISCARD_NOTFOUND) {

  000ba	83 7c 24 20 00	 cmp	 DWORD PTR rv$[rsp], 0
  000bf	75 0e		 jne	 SHORT $LN1@set_remove

; 1958 :         set_key_error(key);

  000c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  000c6	e8 00 00 00 00	 call	 set_key_error

; 1959 :         return NULL;

  000cb	33 c0		 xor	 eax, eax
  000cd	eb 13		 jmp	 SHORT $LN8@set_remove
$LN1@set_remove:

; 1960 :     }
; 1961 :     Py_RETURN_NONE;

  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000d6	e8 00 00 00 00	 call	 _Py_IncRef
  000db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@set_remove:

; 1962 : }

  000e2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e6	c3		 ret	 0
set_remove ENDP
_TEXT	ENDS
EXTRN	PyErr_SetObject:PROC
EXTRN	PyTuple_Pack:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_key_error DD imagerel set_key_error
	DD	imagerel set_key_error+71
	DD	imagerel $unwind$set_key_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_key_error DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_key_error
_TEXT	SEGMENT
tup$ = 32
arg$ = 64
set_key_error PROC					; COMDAT

; 19   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 20   :     PyObject *tup;
; 21   :     tup = PyTuple_Pack(1, arg);

  00009	48 8b 54 24 40	 mov	 rdx, QWORD PTR arg$[rsp]
  0000e	b9 01 00 00 00	 mov	 ecx, 1
  00013	e8 00 00 00 00	 call	 PyTuple_Pack
  00018	48 89 44 24 20	 mov	 QWORD PTR tup$[rsp], rax

; 22   :     if (!tup)

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR tup$[rsp], 0
  00023	75 02		 jne	 SHORT $LN1@set_key_er

; 23   :         return; /* caller will expect error to be set anyway */

  00025	eb 1b		 jmp	 SHORT $LN2@set_key_er
$LN1@set_key_er:

; 24   :     PyErr_SetObject(PyExc_KeyError, tup);

  00027	48 8b 54 24 20	 mov	 rdx, QWORD PTR tup$[rsp]
  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  00033	e8 00 00 00 00	 call	 PyErr_SetObject

; 25   :     Py_DECREF(tup);

  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tup$[rsp]
  0003d	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@set_key_er:

; 26   : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
set_key_error ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_discard DD imagerel set_discard
	DD	imagerel set_discard+210
	DD	imagerel $unwind$set_discard
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_discard DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_discard
_TEXT	SEGMENT
rv$ = 32
tmpkey$ = 40
so$ = 64
key$ = 72
set_discard PROC					; COMDAT

; 1971 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1972 :     PyObject *tmpkey;
; 1973 :     int rv;
; 1974 : 
; 1975 :     rv = set_discard_key(so, key);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00018	e8 00 00 00 00	 call	 set_discard_key
  0001d	89 44 24 20	 mov	 DWORD PTR rv$[rsp], eax

; 1976 :     if (rv == -1) {

  00021	83 7c 24 20 ff	 cmp	 DWORD PTR rv$[rsp], -1
  00026	0f 85 8e 00 00
	00		 jne	 $LN6@set_discar@3

; 1977 :         if (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))

  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00033	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00038	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003c	74 19		 je	 SHORT $LN3@set_discar@3
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0004a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00053	85 c0		 test	 eax, eax
  00055	74 10		 je	 SHORT $LN4@set_discar@3
$LN3@set_discar@3:
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0005e	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00063	85 c0		 test	 eax, eax
  00065	75 04		 jne	 SHORT $LN5@set_discar@3
$LN4@set_discar@3:

; 1978 :             return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	eb 62		 jmp	 SHORT $LN7@set_discar@3
$LN5@set_discar@3:

; 1979 :         PyErr_Clear();

  0006b	e8 00 00 00 00	 call	 PyErr_Clear

; 1980 :         tmpkey = make_new_set(&PyFrozenSet_Type, key);

  00070	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFrozenSet_Type
  0007c	e8 00 00 00 00	 call	 make_new_set
  00081	48 89 44 24 28	 mov	 QWORD PTR tmpkey$[rsp], rax

; 1981 :         if (tmpkey == NULL)

  00086	48 83 7c 24 28
	00		 cmp	 QWORD PTR tmpkey$[rsp], 0
  0008c	75 04		 jne	 SHORT $LN2@set_discar@3

; 1982 :             return NULL;

  0008e	33 c0		 xor	 eax, eax
  00090	eb 3b		 jmp	 SHORT $LN7@set_discar@3
$LN2@set_discar@3:

; 1983 :         rv = set_discard_key(so, tmpkey);

  00092	48 8b 54 24 28	 mov	 rdx, QWORD PTR tmpkey$[rsp]
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  0009c	e8 00 00 00 00	 call	 set_discard_key
  000a1	89 44 24 20	 mov	 DWORD PTR rv$[rsp], eax

; 1984 :         Py_DECREF(tmpkey);

  000a5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmpkey$[rsp]
  000aa	e8 00 00 00 00	 call	 _Py_DecRef

; 1985 :         if (rv == -1)

  000af	83 7c 24 20 ff	 cmp	 DWORD PTR rv$[rsp], -1
  000b4	75 04		 jne	 SHORT $LN1@set_discar@3

; 1986 :             return NULL;

  000b6	33 c0		 xor	 eax, eax
  000b8	eb 13		 jmp	 SHORT $LN7@set_discar@3
$LN1@set_discar@3:
$LN6@set_discar@3:

; 1987 :     }
; 1988 :     Py_RETURN_NONE;

  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000c1	e8 00 00 00 00	 call	 _Py_IncRef
  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN7@set_discar@3:

; 1989 : }

  000cd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d1	c3		 ret	 0
set_discard ENDP
_TEXT	ENDS
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_reduce DD imagerel set_reduce
	DD	imagerel set_reduce+298
	DD	imagerel $unwind$set_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_reduce DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_reduce
_TEXT	SEGMENT
args$ = 32
dict$ = 40
keys$ = 48
result$ = 56
so$ = 80
set_reduce PROC						; COMDAT

; 1998 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1999 :     PyObject *keys=NULL, *args=NULL, *result=NULL, *dict=NULL;

  00009	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR keys$[rsp], 0
  00012	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0
  0001b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0
  00024	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR dict$[rsp], 0

; 2000 :     _Py_IDENTIFIER(__dict__);
; 2001 : 
; 2002 :     keys = PySequence_List((PyObject *)so);

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00032	e8 00 00 00 00	 call	 PySequence_List
  00037	48 89 44 24 30	 mov	 QWORD PTR keys$[rsp], rax

; 2003 :     if (keys == NULL)

  0003c	48 83 7c 24 30
	00		 cmp	 QWORD PTR keys$[rsp], 0
  00042	75 05		 jne	 SHORT $LN15@set_reduce

; 2004 :         goto done;

  00044	e9 8f 00 00 00	 jmp	 $done$22218
$LN15@set_reduce:

; 2005 :     args = PyTuple_Pack(1, keys);

  00049	48 8b 54 24 30	 mov	 rdx, QWORD PTR keys$[rsp]
  0004e	b9 01 00 00 00	 mov	 ecx, 1
  00053	e8 00 00 00 00	 call	 PyTuple_Pack
  00058	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 2006 :     if (args == NULL)

  0005d	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  00063	75 02		 jne	 SHORT $LN14@set_reduce

; 2007 :         goto done;

  00065	eb 71		 jmp	 SHORT $done$22218
$LN14@set_reduce:

; 2008 :     dict = _PyObject_GetAttrId((PyObject *)so, &PyId___dict__);

  00067	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___dict__@?1??set_reduce@@9@9
  0006c	8b c0		 mov	 eax, eax
  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00074	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0007d	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00081	48 8b d0	 mov	 rdx, rax
  00084	48 8b 4c 24 50	 mov	 rcx, QWORD PTR so$[rsp]
  00089	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0008e	48 89 44 24 28	 mov	 QWORD PTR dict$[rsp], rax

; 2009 :     if (dict == NULL) {

  00093	48 83 7c 24 28
	00		 cmp	 QWORD PTR dict$[rsp], 0
  00099	75 1b		 jne	 SHORT $LN13@set_reduce

; 2010 :         PyErr_Clear();

  0009b	e8 00 00 00 00	 call	 PyErr_Clear

; 2011 :         dict = Py_None;

  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000a7	48 89 44 24 28	 mov	 QWORD PTR dict$[rsp], rax

; 2012 :         Py_INCREF(dict);

  000ac	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dict$[rsp]
  000b1	e8 00 00 00 00	 call	 _Py_IncRef
$LN13@set_reduce:

; 2013 :     }
; 2014 :     result = PyTuple_Pack(3, Py_TYPE(so), args, dict);

  000b6	4c 8b 4c 24 28	 mov	 r9, QWORD PTR dict$[rsp]
  000bb	4c 8b 44 24 20	 mov	 r8, QWORD PTR args$[rsp]
  000c0	48 8b 44 24 50	 mov	 rax, QWORD PTR so$[rsp]
  000c5	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  000c9	b9 03 00 00 00	 mov	 ecx, 3
  000ce	e8 00 00 00 00	 call	 PyTuple_Pack
  000d3	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax
$done$22218:
$LN12@set_reduce:

; 2015 : done:
; 2016 :     Py_XDECREF(args);

  000d8	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  000de	74 0a		 je	 SHORT $LN9@set_reduce
  000e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  000e5	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@set_reduce:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 e8		 jne	 SHORT $LN12@set_reduce
$LN8@set_reduce:

; 2017 :     Py_XDECREF(keys);

  000f0	48 83 7c 24 30
	00		 cmp	 QWORD PTR keys$[rsp], 0
  000f6	74 0a		 je	 SHORT $LN5@set_reduce
  000f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR keys$[rsp]
  000fd	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@set_reduce:
  00102	33 c0		 xor	 eax, eax
  00104	85 c0		 test	 eax, eax
  00106	75 e8		 jne	 SHORT $LN8@set_reduce
$LN4@set_reduce:

; 2018 :     Py_XDECREF(dict);

  00108	48 83 7c 24 28
	00		 cmp	 QWORD PTR dict$[rsp], 0
  0010e	74 0a		 je	 SHORT $LN1@set_reduce
  00110	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dict$[rsp]
  00115	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@set_reduce:
  0011a	33 c0		 xor	 eax, eax
  0011c	85 c0		 test	 eax, eax
  0011e	75 e8		 jne	 SHORT $LN4@set_reduce

; 2019 :     return result;

  00120	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]

; 2020 : }

  00125	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00129	c3		 ret	 0
set_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_sizeof DD imagerel set_sizeof
	DD	imagerel set_sizeof+87
	DD	imagerel $unwind$set_sizeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_sizeof DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_sizeof
_TEXT	SEGMENT
res$ = 32
so$ = 64
set_sizeof PROC						; COMDAT

; 2024 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2025 :     Py_ssize_t res;
; 2026 : 
; 2027 :     res = sizeof(PySetObject);

  00009	48 c7 44 24 20
	20 01 00 00	 mov	 QWORD PTR res$[rsp], 288 ; 00000120H

; 2028 :     if (so->table != so->smalltable)

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  00017	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR so$[rsp]
  00022	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  00026	74 20		 je	 SHORT $LN1@set_sizeof

; 2029 :         res = res + (so->mask + 1) * sizeof(setentry);

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR so$[rsp]
  0002d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00031	48 ff c0	 inc	 rax
  00034	48 6b c0 10	 imul	 rax, 16
  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  0003d	48 03 c8	 add	 rcx, rax
  00040	48 8b c1	 mov	 rax, rcx
  00043	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax
$LN1@set_sizeof:

; 2030 :     return PyLong_FromSsize_t(res);

  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  0004d	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 2031 : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
set_sizeof ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_init DD imagerel set_init
	DD	imagerel set_init+306
	DD	imagerel $unwind$set_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_init DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT set_init
_TEXT	SEGMENT
iterable$ = 48
self$ = 80
args$ = 88
kwds$ = 96
set_init PROC						; COMDAT

; 2036 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2037 :     PyObject *iterable = NULL;

  00013	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR iterable$[rsp], 0

; 2038 : 
; 2039 :     if (!PyAnySet_Check(self))

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00028	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002c	74 4e		 je	 SHORT $LN5@set_init
  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00035	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0003a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003e	74 3c		 je	 SHORT $LN5@set_init
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0004c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00050	e8 00 00 00 00	 call	 PyType_IsSubtype
  00055	85 c0		 test	 eax, eax
  00057	75 23		 jne	 SHORT $LN5@set_init
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00060	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00065	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00069	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006e	85 c0		 test	 eax, eax
  00070	75 0a		 jne	 SHORT $LN5@set_init

; 2040 :         return -1;

  00072	b8 ff ff ff ff	 mov	 eax, -1
  00077	e9 b1 00 00 00	 jmp	 $LN6@set_init
$LN5@set_init:

; 2041 :     if (PySet_Check(self) && !_PyArg_NoKeywords("set()", kwds))

  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00088	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0008c	74 19		 je	 SHORT $LN3@set_init
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00095	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0009a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0009e	e8 00 00 00 00	 call	 PyType_IsSubtype
  000a3	85 c0		 test	 eax, eax
  000a5	74 1c		 je	 SHORT $LN4@set_init
$LN3@set_init:
  000a7	48 8b 54 24 60	 mov	 rdx, QWORD PTR kwds$[rsp]
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05EBMGGHG@set?$CI?$CJ?$AA@
  000b3	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  000b8	85 c0		 test	 eax, eax
  000ba	75 07		 jne	 SHORT $LN4@set_init

; 2042 :         return -1;

  000bc	b8 ff ff ff ff	 mov	 eax, -1
  000c1	eb 6a		 jmp	 SHORT $LN6@set_init
$LN4@set_init:

; 2043 :     if (!PyArg_UnpackTuple(args, Py_TYPE(self)->tp_name, 0, 1, &iterable))

  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000cc	48 8d 4c 24 30	 lea	 rcx, QWORD PTR iterable$[rsp]
  000d1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000d6	41 b9 01 00 00
	00		 mov	 r9d, 1
  000dc	45 33 c0	 xor	 r8d, r8d
  000df	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  000e3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  000e8	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  000ed	85 c0		 test	 eax, eax
  000ef	75 07		 jne	 SHORT $LN2@set_init

; 2044 :         return -1;

  000f1	b8 ff ff ff ff	 mov	 eax, -1
  000f6	eb 35		 jmp	 SHORT $LN6@set_init
$LN2@set_init:

; 2045 :     set_clear_internal(self);

  000f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000fd	e8 00 00 00 00	 call	 set_clear_internal

; 2046 :     self->hash = -1;

  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00107	48 c7 80 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+264], -1

; 2047 :     if (iterable == NULL)

  00112	48 83 7c 24 30
	00		 cmp	 QWORD PTR iterable$[rsp], 0
  00118	75 04		 jne	 SHORT $LN1@set_init

; 2048 :         return 0;

  0011a	33 c0		 xor	 eax, eax
  0011c	eb 0f		 jmp	 SHORT $LN6@set_init
$LN1@set_init:

; 2049 :     return set_update_internal(self, iterable);

  0011e	48 8b 54 24 30	 mov	 rdx, QWORD PTR iterable$[rsp]
  00123	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00128	e8 00 00 00 00	 call	 set_update_internal
$LN6@set_init:

; 2050 : }

  0012d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00131	c3		 ret	 0
set_init ENDP
_TEXT	ENDS
PUBLIC	PySet_New
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_New DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$PySet_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_New DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySet_New
_TEXT	SEGMENT
iterable$ = 48
PySet_New PROC						; COMDAT

; 2305 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2306 :     return make_new_set(&PySet_Type, iterable);

  00009	48 8b 54 24 30	 mov	 rdx, QWORD PTR iterable$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySet_Type
  00015	e8 00 00 00 00	 call	 make_new_set

; 2307 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
PySet_New ENDP
_TEXT	ENDS
PUBLIC	PyFrozenSet_New
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFrozenSet_New DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$PyFrozenSet_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFrozenSet_New DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyFrozenSet_New
_TEXT	SEGMENT
iterable$ = 48
PyFrozenSet_New PROC					; COMDAT

; 2311 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2312 :     return make_new_set(&PyFrozenSet_Type, iterable);

  00009	48 8b 54 24 30	 mov	 rdx, QWORD PTR iterable$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFrozenSet_Type
  00015	e8 00 00 00 00	 call	 make_new_set

; 2313 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
PyFrozenSet_New ENDP
_TEXT	ENDS
PUBLIC	PySet_Size
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Size DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$PySet_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Size DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySet_Size
_TEXT	SEGMENT
anyset$ = 48
PySet_Size PROC						; COMDAT

; 2317 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2318 :     if (!PyAnySet_Check(anyset)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR anyset$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 5e		 je	 SHORT $LN1@PySet_Size
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR anyset$[rsp]
  00027	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002b	74 4c		 je	 SHORT $LN1@PySet_Size
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR anyset$[rsp]
  00039	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00042	85 c0		 test	 eax, eax
  00044	75 33		 jne	 SHORT $LN1@PySet_Size
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR anyset$[rsp]
  00052	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00056	e8 00 00 00 00	 call	 PyType_IsSubtype
  0005b	85 c0		 test	 eax, eax
  0005d	75 1a		 jne	 SHORT $LN1@PySet_Size

; 2319 :         PyErr_BadInternalCall();

  0005f	ba 0f 09 00 00	 mov	 edx, 2319		; 0000090fH
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  0006b	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2320 :         return -1;

  00070	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00077	eb 09		 jmp	 SHORT $LN2@PySet_Size
$LN1@PySet_Size:

; 2321 :     }
; 2322 :     return PySet_GET_SIZE(anyset);

  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR anyset$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
$LN2@PySet_Size:

; 2323 : }

  00082	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00086	c3		 ret	 0
PySet_Size ENDP
_TEXT	ENDS
PUBLIC	PySet_Clear
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Clear DD imagerel $LN4
	DD	imagerel $LN4+91
	DD	imagerel $unwind$PySet_Clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Clear DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySet_Clear
_TEXT	SEGMENT
set$ = 48
PySet_Clear PROC					; COMDAT

; 2327 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2328 :     if (!PySet_Check(set)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR set$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 31		 je	 SHORT $LN1@PySet_Clea@2
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR set$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 18		 jne	 SHORT $LN1@PySet_Clea@2

; 2329 :         PyErr_BadInternalCall();

  00034	ba 19 09 00 00	 mov	 edx, 2329		; 00000919H
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00040	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2330 :         return -1;

  00045	b8 ff ff ff ff	 mov	 eax, -1
  0004a	eb 0a		 jmp	 SHORT $LN2@PySet_Clea@2
$LN1@PySet_Clea@2:

; 2331 :     }
; 2332 :     return set_clear_internal((PySetObject *)set);

  0004c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR set$[rsp]
  00051	e8 00 00 00 00	 call	 set_clear_internal
$LN2@PySet_Clea@2:

; 2333 : }

  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
PySet_Clear ENDP
_TEXT	ENDS
PUBLIC	PySet_Contains
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Contains DD imagerel $LN4
	DD	imagerel $LN4+144
	DD	imagerel $unwind$PySet_Contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Contains DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySet_Contains
_TEXT	SEGMENT
anyset$ = 48
key$ = 56
PySet_Contains PROC					; COMDAT

; 2337 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2338 :     if (!PyAnySet_Check(anyset)) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR anyset$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 5c		 je	 SHORT $LN1@PySet_Cont
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR anyset$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 4a		 je	 SHORT $LN1@PySet_Cont
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR anyset$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 31		 jne	 SHORT $LN1@PySet_Cont
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR anyset$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 18		 jne	 SHORT $LN1@PySet_Cont

; 2339 :         PyErr_BadInternalCall();

  00064	ba 23 09 00 00	 mov	 edx, 2339		; 00000923H
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00070	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2340 :         return -1;

  00075	b8 ff ff ff ff	 mov	 eax, -1
  0007a	eb 0f		 jmp	 SHORT $LN2@PySet_Cont
$LN1@PySet_Cont:

; 2341 :     }
; 2342 :     return set_contains_key((PySetObject *)anyset, key);

  0007c	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  00081	48 8b 4c 24 30	 mov	 rcx, QWORD PTR anyset$[rsp]
  00086	e8 00 00 00 00	 call	 set_contains_key
$LN2@PySet_Cont:

; 2343 : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
PySet_Contains ENDP
_TEXT	ENDS
PUBLIC	PySet_Discard
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Discard DD imagerel $LN4
	DD	imagerel $LN4+101
	DD	imagerel $unwind$PySet_Discard
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Discard DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySet_Discard
_TEXT	SEGMENT
set$ = 48
key$ = 56
PySet_Discard PROC					; COMDAT

; 2347 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2348 :     if (!PySet_Check(set)) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR set$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 31		 je	 SHORT $LN1@PySet_Disc
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR set$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 18		 jne	 SHORT $LN1@PySet_Disc

; 2349 :         PyErr_BadInternalCall();

  00039	ba 2d 09 00 00	 mov	 edx, 2349		; 0000092dH
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00045	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2350 :         return -1;

  0004a	b8 ff ff ff ff	 mov	 eax, -1
  0004f	eb 0f		 jmp	 SHORT $LN2@PySet_Disc
$LN1@PySet_Disc:

; 2351 :     }
; 2352 :     return set_discard_key((PySetObject *)set, key);

  00051	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  00056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR set$[rsp]
  0005b	e8 00 00 00 00	 call	 set_discard_key
$LN2@PySet_Disc:

; 2353 : }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	c3		 ret	 0
PySet_Discard ENDP
_TEXT	ENDS
PUBLIC	PySet_Add
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Add DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$PySet_Add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Add DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySet_Add
_TEXT	SEGMENT
anyset$ = 48
key$ = 56
PySet_Add PROC						; COMDAT

; 2357 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2358 :     if (!PySet_Check(anyset) &&
; 2359 :         (!PyFrozenSet_Check(anyset) || Py_REFCNT(anyset) != 1)) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR anyset$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 68		 je	 SHORT $LN3@PySet_Add
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR anyset$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 4f		 jne	 SHORT $LN3@PySet_Add
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR anyset$[rsp]
  00045	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00049	74 19		 je	 SHORT $LN1@PySet_Add
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR anyset$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	74 0c		 je	 SHORT $LN2@PySet_Add
$LN1@PySet_Add:
  00064	48 8b 44 24 30	 mov	 rax, QWORD PTR anyset$[rsp]
  00069	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  0006e	74 18		 je	 SHORT $LN3@PySet_Add
$LN2@PySet_Add:

; 2360 :         PyErr_BadInternalCall();

  00070	ba 38 09 00 00	 mov	 edx, 2360		; 00000938H
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  0007c	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2361 :         return -1;

  00081	b8 ff ff ff ff	 mov	 eax, -1
  00086	eb 0f		 jmp	 SHORT $LN4@PySet_Add
$LN3@PySet_Add:

; 2362 :     }
; 2363 :     return set_add_key((PySetObject *)anyset, key);

  00088	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  0008d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR anyset$[rsp]
  00092	e8 00 00 00 00	 call	 set_add_key
$LN4@PySet_Add:

; 2364 : }

  00097	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009b	c3		 ret	 0
PySet_Add ENDP
_TEXT	ENDS
PUBLIC	_PySet_NextEntry
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PySet_NextEntry DD imagerel $LN5
	DD	imagerel $LN5+205
	DD	imagerel $unwind$_PySet_NextEntry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PySet_NextEntry DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PySet_NextEntry
_TEXT	SEGMENT
entry$ = 32
set$ = 64
pos$ = 72
key$ = 80
hash$ = 88
_PySet_NextEntry PROC					; COMDAT

; 2368 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2369 :     setentry *entry;
; 2370 : 
; 2371 :     if (!PyAnySet_Check(set)) {

  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR set$[rsp]
  00024	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00028	74 5c		 je	 SHORT $LN2@PySet_Next
  0002a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR set$[rsp]
  00036	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003a	74 4a		 je	 SHORT $LN2@PySet_Next
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR set$[rsp]
  00048	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00051	85 c0		 test	 eax, eax
  00053	75 31		 jne	 SHORT $LN2@PySet_Next
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR set$[rsp]
  00061	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00065	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006a	85 c0		 test	 eax, eax
  0006c	75 18		 jne	 SHORT $LN2@PySet_Next

; 2372 :         PyErr_BadInternalCall();

  0006e	ba 44 09 00 00	 mov	 edx, 2372		; 00000944H
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  0007a	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2373 :         return -1;

  0007f	b8 ff ff ff ff	 mov	 eax, -1
  00084	eb 42		 jmp	 SHORT $LN3@PySet_Next
$LN2@PySet_Next:

; 2374 :     }
; 2375 :     if (set_next((PySetObject *)set, pos, &entry) == 0)

  00086	4c 8d 44 24 20	 lea	 r8, QWORD PTR entry$[rsp]
  0008b	48 8b 54 24 48	 mov	 rdx, QWORD PTR pos$[rsp]
  00090	48 8b 4c 24 40	 mov	 rcx, QWORD PTR set$[rsp]
  00095	e8 00 00 00 00	 call	 set_next
  0009a	85 c0		 test	 eax, eax
  0009c	75 04		 jne	 SHORT $LN1@PySet_Next

; 2376 :         return 0;

  0009e	33 c0		 xor	 eax, eax
  000a0	eb 26		 jmp	 SHORT $LN3@PySet_Next
$LN1@PySet_Next:

; 2377 :     *key = entry->key;

  000a2	48 8b 44 24 50	 mov	 rax, QWORD PTR key$[rsp]
  000a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR entry$[rsp]
  000ac	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b0	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2378 :     *hash = entry->hash;

  000b3	48 8b 44 24 58	 mov	 rax, QWORD PTR hash$[rsp]
  000b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR entry$[rsp]
  000bd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c0	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2379 :     return 1;

  000c3	b8 01 00 00 00	 mov	 eax, 1
$LN3@PySet_Next:

; 2380 : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
_PySet_NextEntry ENDP
_TEXT	ENDS
PUBLIC	PySet_Pop
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Pop DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$PySet_Pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Pop DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySet_Pop
_TEXT	SEGMENT
set$ = 48
PySet_Pop PROC						; COMDAT

; 2384 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2385 :     if (!PySet_Check(set)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR set$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 2e		 je	 SHORT $LN1@PySet_Pop
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR set$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 15		 jne	 SHORT $LN1@PySet_Pop

; 2386 :         PyErr_BadInternalCall();

  00034	ba 52 09 00 00	 mov	 edx, 2386		; 00000952H
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00040	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2387 :         return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	eb 0a		 jmp	 SHORT $LN2@PySet_Pop
$LN1@PySet_Pop:

; 2388 :     }
; 2389 :     return set_pop((PySetObject *)set);

  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR set$[rsp]
  0004e	e8 00 00 00 00	 call	 set_pop
$LN2@PySet_Pop:

; 2390 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
PySet_Pop ENDP
_TEXT	ENDS
PUBLIC	_PySet_Update
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PySet_Update DD imagerel $LN4
	DD	imagerel $LN4+101
	DD	imagerel $unwind$_PySet_Update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PySet_Update DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PySet_Update
_TEXT	SEGMENT
set$ = 48
iterable$ = 56
_PySet_Update PROC					; COMDAT

; 2394 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2395 :     if (!PySet_Check(set)) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR set$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 31		 je	 SHORT $LN1@PySet_Upda
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR set$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 18		 jne	 SHORT $LN1@PySet_Upda

; 2396 :         PyErr_BadInternalCall();

  00039	ba 5c 09 00 00	 mov	 edx, 2396		; 0000095cH
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00045	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2397 :         return -1;

  0004a	b8 ff ff ff ff	 mov	 eax, -1
  0004f	eb 0f		 jmp	 SHORT $LN2@PySet_Upda
$LN1@PySet_Upda:

; 2398 :     }
; 2399 :     return set_update_internal((PySetObject *)set, iterable);

  00051	48 8b 54 24 38	 mov	 rdx, QWORD PTR iterable$[rsp]
  00056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR set$[rsp]
  0005b	e8 00 00 00 00	 call	 set_update_internal
$LN2@PySet_Upda:

; 2400 : }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	c3		 ret	 0
_PySet_Update ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CO@OHNHGCNF@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@IPOMFDFC@?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EE@ONLMHKFI@?$AAP?$AAy?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA_?$AAI?$AAn?$AAP?$AAl?$AAa?$AAc?$AAe?$AAO?$AAr?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo@ ; `string'
PUBLIC	??_C@_1EO@ILCKEJCD@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAK?$AAe?$AAy@ ; `string'
PUBLIC	??_C@_1DK@FLJNOHIN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAP?$AAo?$AAp?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@PLPHNOMB@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EO@DFJENNHB@?$AAP?$AAy?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA_?$AAI?$AAn?$AAP?$AAl?$AAa?$AAc?$AAe?$AAS?$AAu?$AAb?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAo?$AAb?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1DI@KPJHHOAE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAP?$AAo?$AAp?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@DEILAHIP@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@HJOOOEJO@?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAf?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@DIDFNCN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DM@IGOIOOEK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAt?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@GPMMLPJB@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@COKKJJBF@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DM@EGNKFHFO@?$AA_?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@MGLAKGBP@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GC@IDHKDLIB@?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAa?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAb?$AA?8@ ; `string'
PUBLIC	??_C@_1DC@LPNPCMJC@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@CJFDIPLJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@DBNADGLH@?$AA_?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?$CI?$AAf?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FE@KOJNFMCG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAS?$AAy?$AAs@ ; `string'
PUBLIC	??_C@_1CK@MNABLIMO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@DMBPDGPL@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@GLBFNHIM@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@IAAHBJJJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@DILLHOPM@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DM@ICPFGNCL@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@LFDDCIE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@FBPOBGEK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DM@DKEJAKEO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@OLGKNEAE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DM@NKHAOMMO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@GADOPPBJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GE@FBHIJEBI@?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAN?$AAe?$AAw?$AA?$CI?$AA?$CI?$AA?$CG?$AA_?$AAP?$AAy?$AA_?$AAN?$AAo?$AAn?$AAe?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt@ ; `string'
PUBLIC	??_C@_1FA@FIIOHKHG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAT?$AAy?$AAp@ ; `string'
PUBLIC	??_C@_1FI@CNDNFLLK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAN?$AAe?$AAw?$AA?$CI?$AA?$CI?$AA?$CG?$AA_?$AAP?$AAy?$AA_?$AAN?$AAo?$AAn?$AAe?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ ; `string'
PUBLIC	??_C@_1DA@OJECHBCP@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@FNFKBFN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ ; `string'
PUBLIC	??_C@_03FIKCJHKP@abc?$AA@			; `string'
PUBLIC	??_C@_1DI@BAPBFECK@?$AA?$CB?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@KAPOLLKC@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@FDIIMJGP@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyNumber_InPlaceOr:PROC
EXTRN	PyNumber_InPlaceSubtract:PROC
EXTRN	PyTuple_New:PROC
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$test_c_api DD imagerel test_c_api
	DD	imagerel test_c_api+3370
	DD	imagerel $unwind$test_c_api
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$test_c_api DD 020c01H
	DD	011010cH
xdata	ENDS
;	COMDAT ??_C@_1CO@OHNHGCNF@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@OHNHGCNF@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'G', 00H
	DB	'E', 00H, 'T', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E'
	DB	00H, '(', 00H, 'f', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@IPOMFDFC@?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@IPOMFDFC@?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'f'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@ONLMHKFI@?$AAP?$AAy?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA_?$AAI?$AAn?$AAP?$AAl?$AAa?$AAc?$AAe?$AAO?$AAr?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo@
CONST	SEGMENT
??_C@_1EE@ONLMHKFI@?$AAP?$AAy?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA_?$AAI?$AAn?$AAP?$AAl?$AAa?$AAc?$AAe?$AAO?$AAr?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo@ DB 'P'
	DB	00H, 'y', 00H, 'N', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H
	DB	'r', 00H, '_', 00H, 'I', 00H, 'n', 00H, 'P', 00H, 'l', 00H, 'a'
	DB	00H, 'c', 00H, 'e', 00H, 'O', 00H, 'r', 00H, '(', 00H, 'o', 00H
	DB	'b', 00H, ',', 00H, ' ', 00H, 'd', 00H, 'u', 00H, 'p', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o', 00H, 'b', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@ILCKEJCD@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAK?$AAe?$AAy@
CONST	SEGMENT
??_C@_1EO@ILCKEJCD@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAK?$AAe?$AAy@ DB 'P'
	DB	00H, 'y', 00H, 'E', 00H, 'r', 00H, 'r', 00H, '_', 00H, 'E', 00H
	DB	'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, 'M', 00H, 'a', 00H, 't', 00H, 'c', 00H, 'h', 00H
	DB	'e', 00H, 's', 00H, '(', 00H, 'P', 00H, 'y', 00H, 'E', 00H, 'x'
	DB	00H, 'c', 00H, '_', 00H, 'K', 00H, 'e', 00H, 'y', 00H, 'E', 00H
	DB	'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@FLJNOHIN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAP?$AAo?$AAp?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@FLJNOHIN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAP?$AAo?$AAp?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'P', 00H
	DB	'o', 00H, 'p', 00H, '(', 00H, 'o', 00H, 'b', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '(', 00H, 'v', 00H
	DB	'o', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '*', 00H, ')', 00H, '0'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@PLPHNOMB@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@PLPHNOMB@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'G', 00H
	DB	'E', 00H, 'T', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E'
	DB	00H, '(', 00H, 'o', 00H, 'b', 00H, ')', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@DFJENNHB@?$AAP?$AAy?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA_?$AAI?$AAn?$AAP?$AAl?$AAa?$AAc?$AAe?$AAS?$AAu?$AAb?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAo?$AAb?$AA?$CJ@
CONST	SEGMENT
??_C@_1EO@DFJENNHB@?$AAP?$AAy?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA_?$AAI?$AAn?$AAP?$AAl?$AAa?$AAc?$AAe?$AAS?$AAu?$AAb?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAo?$AAb?$AA?$CJ@ DB 'P'
	DB	00H, 'y', 00H, 'N', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H
	DB	'r', 00H, '_', 00H, 'I', 00H, 'n', 00H, 'P', 00H, 'l', 00H, 'a'
	DB	00H, 'c', 00H, 'e', 00H, 'S', 00H, 'u', 00H, 'b', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 'c', 00H, 't', 00H, '(', 00H, 'o', 00H, 'b'
	DB	00H, ',', 00H, ' ', 00H, 'o', 00H, 'b', 00H, ')', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'o', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@KPJHHOAE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAP?$AAo?$AAp?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@KPJHHOAE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAP?$AAo?$AAp?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'P', 00H
	DB	'o', 00H, 'p', 00H, '(', 00H, 'f', 00H, ')', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '(', 00H, '(', 00H, 'v', 00H, 'o', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, '*', 00H, ')', 00H, '0', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@DEILAHIP@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@DEILAHIP@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'D', 00H
	DB	'i', 00H, 's', 00H, 'c', 00H, 'a', 00H, 'r', 00H, 'd', 00H, '('
	DB	00H, 'f', 00H, ',', 00H, ' ', 00H, 'e', 00H, 'l', 00H, 'e', 00H
	DB	'm', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '-'
	DB	00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@HJOOOEJO@?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAf?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@HJOOOEJO@?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAf?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'F', 00H, 'r', 00H, 'o', 00H, 'z', 00H, 'e', 00H
	DB	'n', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, 'E', 00H, 'x', 00H, 'a', 00H
	DB	'c', 00H, 't', 00H, '(', 00H, 'f', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@DIDFNCN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@DIDFNCN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '(', 00H, 'f', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '3', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@IGOIOOEK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAt?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@IGOIOOEK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAt?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 's'
	DB	00H, '(', 00H, 't', 00H, ',', 00H, ' ', 00H, 'e', 00H, 'l', 00H
	DB	'e', 00H, 'm', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '-', 00H, '1', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@GPMMLPJB@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@GPMMLPJB@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '(', 00H, 't', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '-', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@COKKJJBF@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@COKKJJBF@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '(', 00H, 'd', 00H, 'u', 00H, 'p'
	DB	00H, '2', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'3', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@EGNKFHFO@?$AA_?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@EGNKFHFO@?$AA_?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB '_'
	DB	00H, 'P', 00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H
	DB	'U', 00H, 'p', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, '('
	DB	00H, 'd', 00H, 'u', 00H, 'p', 00H, '2', 00H, ',', 00H, ' ', 00H
	DB	'd', 00H, 'u', 00H, 'p', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@MGLAKGBP@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@MGLAKGBP@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '3', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@IDHKDLIB@?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAa?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAb?$AA?8@
CONST	SEGMENT
??_C@_1GC@IDHKDLIB@?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAa?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAb?$AA?8@ DB 's'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '(', 00H, 's', 00H
	DB	'[', 00H, '0', 00H, ']', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '''', 00H, 'a', 00H, '''', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, 's', 00H, '[', 00H, '0', 00H, ']', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '''', 00H, 'b', 00H, '''', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 's', 00H, '[', 00H, '0', 00H, ']'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '''', 00H, 'c', 00H
	DB	'''', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@LPNPCMJC@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@LPNPCMJC@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'd', 00H, '(', 00H, 'f', 00H, ',', 00H, ' ', 00H, 'e'
	DB	00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '-', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@CJFDIPLJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@CJFDIPLJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'd', 00H, '(', 00H, 'f', 00H, ',', 00H, ' ', 00H, 'e'
	DB	00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@DBNADGLH@?$AA_?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?$CI?$AAf?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@DBNADGLH@?$AA_?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?$CI?$AAf?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB '_'
	DB	00H, 'P', 00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H
	DB	'U', 00H, 'p', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, '('
	DB	00H, 'f', 00H, ',', 00H, ' ', 00H, 'd', 00H, 'u', 00H, 'p', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '-', 00H, '1'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FE@KOJNFMCG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAS?$AAy?$AAs@
CONST	SEGMENT
??_C@_1FE@KOJNFMCG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAS?$AAy?$AAs@ DB 'P'
	DB	00H, 'y', 00H, 'E', 00H, 'r', 00H, 'r', 00H, '_', 00H, 'E', 00H
	DB	'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, 'M', 00H, 'a', 00H, 't', 00H, 'c', 00H, 'h', 00H
	DB	'e', 00H, 's', 00H, '(', 00H, 'P', 00H, 'y', 00H, 'E', 00H, 'x'
	DB	00H, 'c', 00H, '_', 00H, 'S', 00H, 'y', 00H, 's', 00H, 't', 00H
	DB	'e', 00H, 'm', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@MNABLIMO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@MNABLIMO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'C', 00H
	DB	'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, '(', 00H, 'f', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '-', 00H, '1', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@DMBPDGPL@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@DMBPDGPL@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '(', 00H, 'd', 00H, 'u', 00H, 'p'
	DB	00H, '2', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@GLBFNHIM@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@GLBFNHIM@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'C', 00H
	DB	'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, '(', 00H, 'd', 00H, 'u'
	DB	00H, 'p', 00H, '2', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@IAAHBJJJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@IAAHBJJJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'D', 00H
	DB	'i', 00H, 's', 00H, 'c', 00H, 'a', 00H, 'r', 00H, 'd', 00H, '('
	DB	00H, 'o', 00H, 'b', 00H, ',', 00H, ' ', 00H, 'e', 00H, 'l', 00H
	DB	'e', 00H, 'm', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@DILLHOPM@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@DILLHOPM@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'D', 00H
	DB	'i', 00H, 's', 00H, 'c', 00H, 'a', 00H, 'r', 00H, 'd', 00H, '('
	DB	00H, 'o', 00H, 'b', 00H, ',', 00H, ' ', 00H, 'e', 00H, 'l', 00H
	DB	'e', 00H, 'm', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@ICPFGNCL@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@ICPFGNCL@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 's'
	DB	00H, '(', 00H, 'o', 00H, 'b', 00H, ',', 00H, ' ', 00H, 'e', 00H
	DB	'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '1', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@LFDDCIE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@LFDDCIE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'd', 00H, '(', 00H, 'o', 00H, 'b', 00H, ',', 00H, ' '
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@FBPOBGEK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@FBPOBGEK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'G', 00H
	DB	'E', 00H, 'T', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E'
	DB	00H, '(', 00H, 'o', 00H, 'b', 00H, ')', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@DKEJAKEO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@DKEJAKEO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 's'
	DB	00H, '(', 00H, 'o', 00H, 'b', 00H, ',', 00H, ' ', 00H, 'e', 00H
	DB	'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@OLGKNEAE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@OLGKNEAE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'd', 00H, '(', 00H, 'o', 00H, 'b', 00H, ',', 00H, ' '
	DB	00H, 'd', 00H, 'u', 00H, 'p', 00H, ')', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '-', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@NKHAOMMO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@NKHAOMMO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 's'
	DB	00H, '(', 00H, 'o', 00H, 'b', 00H, ',', 00H, ' ', 00H, 'd', 00H
	DB	'u', 00H, 'p', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '-', 00H, '1', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@GADOPPBJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@GADOPPBJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'D', 00H
	DB	'i', 00H, 's', 00H, 'c', 00H, 'a', 00H, 'r', 00H, 'd', 00H, '('
	DB	00H, 'o', 00H, 'b', 00H, ',', 00H, ' ', 00H, 'd', 00H, 'u', 00H
	DB	'p', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '-'
	DB	00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1GE@FBHIJEBI@?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAN?$AAe?$AAw?$AA?$CI?$AA?$CI?$AA?$CG?$AA_?$AAP?$AAy?$AA_?$AAN?$AAo?$AAn?$AAe?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt@
CONST	SEGMENT
??_C@_1GE@FBHIJEBI@?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAN?$AAe?$AAw?$AA?$CI?$AA?$CI?$AA?$CG?$AA_?$AAP?$AAy?$AA_?$AAN?$AAo?$AAn?$AAe?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt@ DB 'P'
	DB	00H, 'y', 00H, 'F', 00H, 'r', 00H, 'o', 00H, 'z', 00H, 'e', 00H
	DB	'n', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'N', 00H, 'e'
	DB	00H, 'w', 00H, '(', 00H, '(', 00H, '&', 00H, '_', 00H, 'P', 00H
	DB	'y', 00H, '_', 00H, 'N', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 'S'
	DB	00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ')', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '('
	DB	00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '*', 00H
	DB	')', 00H, '0', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@FIIOHKHG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAT?$AAy?$AAp@
CONST	SEGMENT
??_C@_1FA@FIIOHKHG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAT?$AAy?$AAp@ DB 'P'
	DB	00H, 'y', 00H, 'E', 00H, 'r', 00H, 'r', 00H, '_', 00H, 'E', 00H
	DB	'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, 'M', 00H, 'a', 00H, 't', 00H, 'c', 00H, 'h', 00H
	DB	'e', 00H, 's', 00H, '(', 00H, 'P', 00H, 'y', 00H, 'E', 00H, 'x'
	DB	00H, 'c', 00H, '_', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'E', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@CNDNFLLK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAN?$AAe?$AAw?$AA?$CI?$AA?$CI?$AA?$CG?$AA_?$AAP?$AAy?$AA_?$AAN?$AAo?$AAn?$AAe?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1FI@CNDNFLLK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAN?$AAe?$AAw?$AA?$CI?$AA?$CI?$AA?$CG?$AA_?$AAP?$AAy?$AA_?$AAN?$AAo?$AAn?$AAe?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'N', 00H
	DB	'e', 00H, 'w', 00H, '(', 00H, '(', 00H, '&', 00H, '_', 00H, 'P'
	DB	00H, 'y', 00H, '_', 00H, 'N', 00H, 'o', 00H, 'n', 00H, 'e', 00H
	DB	'S', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ')'
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H
	DB	'(', 00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '*'
	DB	00H, ')', 00H, '0', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@OJECHBCP@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@OJECHBCP@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'G', 00H
	DB	'E', 00H, 'T', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E'
	DB	00H, '(', 00H, 'o', 00H, 'b', 00H, ')', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '3', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@FNFKBFN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@FNFKBFN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '(', 00H, 'o', 00H, 'b', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '3', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03FIKCJHKP@abc?$AA@
CONST	SEGMENT
??_C@_03FIKCJHKP@abc?$AA@ DB 'abc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@BAPBFECK@?$AA?$CB?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@BAPBFECK@?$AA?$CB?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@ DB '!'
	DB	00H, 'P', 00H, 'y', 00H, 'F', 00H, 'r', 00H, 'o', 00H, 'z', 00H
	DB	'e', 00H, 'n', 00H, 'S', 00H, 'e', 00H, 't', 00H, '_', 00H, 'C'
	DB	00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'E', 00H, 'x', 00H
	DB	'a', 00H, 'c', 00H, 't', 00H, '(', 00H, 'o', 00H, 'b', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@KAPOLLKC@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@KAPOLLKC@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'A', 00H, 'n', 00H, 'y', 00H, 'S', 00H, 'e', 00H
	DB	't', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k'
	DB	00H, 'E', 00H, 'x', 00H, 'a', 00H, 'c', 00H, 't', 00H, '(', 00H
	DB	'o', 00H, 'b', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@FDIIMJGP@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@FDIIMJGP@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'A', 00H, 'n', 00H, 'y', 00H, 'S', 00H, 'e', 00H
	DB	't', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k'
	DB	00H, '(', 00H, 'o', 00H, 'b', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT test_c_api
_TEXT	SEGMENT
count$ = 32
x$ = 40
elem$ = 48
i$ = 56
s$ = 64
dup2$ = 72
f$ = 80
ob$ = 88
hash$ = 96
t$ = 104
dup$ = 112
str$ = 120
so$ = 144
test_c_api PROC						; COMDAT

; 2416 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2417 :     Py_ssize_t count;
; 2418 :     char *s;
; 2419 :     Py_ssize_t i;
; 2420 :     PyObject *elem=NULL, *dup=NULL, *t, *f, *dup2, *x;

  0000c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR elem$[rsp], 0
  00015	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR dup$[rsp], 0

; 2421 :     PyObject *ob = (PyObject *)so;

  0001e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR so$[rsp]
  00026	48 89 44 24 58	 mov	 QWORD PTR ob$[rsp], rax

; 2422 :     Py_hash_t hash;
; 2423 :     PyObject *str;
; 2424 : 
; 2425 :     /* Verify preconditions */
; 2426 :     assert(PyAnySet_Check(ob));

  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  00037	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003b	74 60		 je	 SHORT $LN46@test_c_api
  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00044	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  00049	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0004d	74 4e		 je	 SHORT $LN46@test_c_api
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00056	48 8b 44 24 58	 mov	 rax, QWORD PTR ob$[rsp]
  0005b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00064	85 c0		 test	 eax, eax
  00066	75 35		 jne	 SHORT $LN46@test_c_api
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0006f	48 8b 44 24 58	 mov	 rax, QWORD PTR ob$[rsp]
  00074	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	75 1c		 jne	 SHORT $LN46@test_c_api
  00081	41 b8 7a 09 00
	00		 mov	 r8d, 2426		; 0000097aH
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@FDIIMJGP@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009b	33 c0		 xor	 eax, eax
$LN46@test_c_api:

; 2427 :     assert(PyAnySet_CheckExact(ob));

  0009d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  000a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  000a9	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000ad	74 2e		 je	 SHORT $LN47@test_c_api
  000af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  000b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  000bb	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000bf	74 1c		 je	 SHORT $LN47@test_c_api
  000c1	41 b8 7b 09 00
	00		 mov	 r8d, 2427		; 0000097bH
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@KAPOLLKC@?$AAP?$AAy?$AAA?$AAn?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000db	33 c0		 xor	 eax, eax
$LN47@test_c_api:

; 2428 :     assert(!PyFrozenSet_CheckExact(ob));

  000dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  000e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  000e9	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000ed	75 1c		 jne	 SHORT $LN48@test_c_api
  000ef	41 b8 7c 09 00
	00		 mov	 r8d, 2428		; 0000097cH
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@BAPBFECK@?$AA?$CB?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?$AA@
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00109	33 c0		 xor	 eax, eax
$LN48@test_c_api:

; 2429 : 
; 2430 :     /* so.clear(); so |= set("abc"); */
; 2431 :     str = PyUnicode_FromString("abc");

  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03FIKCJHKP@abc?$AA@
  00112	e8 00 00 00 00	 call	 PyUnicode_FromString
  00117	48 89 44 24 78	 mov	 QWORD PTR str$[rsp], rax

; 2432 :     if (str == NULL)

  0011c	48 83 7c 24 78
	00		 cmp	 QWORD PTR str$[rsp], 0
  00122	75 07		 jne	 SHORT $LN43@test_c_api

; 2433 :         return NULL;

  00124	33 c0		 xor	 eax, eax
  00126	e9 f7 0b 00 00	 jmp	 $LN44@test_c_api
$LN43@test_c_api:

; 2434 :     set_clear_internal(so);

  0012b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00133	e8 00 00 00 00	 call	 set_clear_internal

; 2435 :     if (set_update_internal(so, str) == -1) {

  00138	48 8b 54 24 78	 mov	 rdx, QWORD PTR str$[rsp]
  0013d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR so$[rsp]
  00145	e8 00 00 00 00	 call	 set_update_internal
  0014a	83 f8 ff	 cmp	 eax, -1
  0014d	75 11		 jne	 SHORT $LN42@test_c_api

; 2436 :         Py_DECREF(str);

  0014f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR str$[rsp]
  00154	e8 00 00 00 00	 call	 _Py_DecRef

; 2437 :         return NULL;

  00159	33 c0		 xor	 eax, eax
  0015b	e9 c2 0b 00 00	 jmp	 $LN44@test_c_api
$LN42@test_c_api:

; 2438 :     }
; 2439 :     Py_DECREF(str);

  00160	48 8b 4c 24 78	 mov	 rcx, QWORD PTR str$[rsp]
  00165	e8 00 00 00 00	 call	 _Py_DecRef

; 2440 : 
; 2441 :     /* Exercise type/size checks */
; 2442 :     assert(PySet_Size(ob) == 3);

  0016a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  0016f	e8 00 00 00 00	 call	 PySet_Size
  00174	48 83 f8 03	 cmp	 rax, 3
  00178	74 1c		 je	 SHORT $LN49@test_c_api
  0017a	41 b8 8a 09 00
	00		 mov	 r8d, 2442		; 0000098aH
  00180	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@FNFKBFN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00194	33 c0		 xor	 eax, eax
$LN49@test_c_api:

; 2443 :     assert(PySet_GET_SIZE(ob) == 3);

  00196	48 8b 44 24 58	 mov	 rax, QWORD PTR ob$[rsp]
  0019b	48 83 78 68 03	 cmp	 QWORD PTR [rax+104], 3
  001a0	74 1c		 je	 SHORT $LN50@test_c_api
  001a2	41 b8 8b 09 00
	00		 mov	 r8d, 2443		; 0000098bH
  001a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@OJECHBCP@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001bc	33 c0		 xor	 eax, eax
$LN50@test_c_api:
$LN41@test_c_api:

; 2444 : 
; 2445 :     /* Raise TypeError for non-iterable constructor arguments */
; 2446 :     assertRaises(PySet_New(Py_None) == NULL, PyExc_TypeError);

  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  001c5	e8 00 00 00 00	 call	 PySet_New
  001ca	48 85 c0	 test	 rax, rax
  001cd	74 1c		 je	 SHORT $LN51@test_c_api
  001cf	41 b8 8e 09 00
	00		 mov	 r8d, 2446		; 0000098eH
  001d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FI@CNDNFLLK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAN?$AAe?$AAw?$AA?$CI?$AA?$CI?$AA?$CG?$AA_?$AAP?$AAy?$AA_?$AAN?$AAo?$AAn?$AAe?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001e9	33 c0		 xor	 eax, eax
$LN51@test_c_api:
  001eb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001f2	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  001f7	85 c0		 test	 eax, eax
  001f9	75 1c		 jne	 SHORT $LN52@test_c_api
  001fb	41 b8 8e 09 00
	00		 mov	 r8d, 2446		; 0000098eH
  00201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@FIIOHKHG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAT?$AAy?$AAp@
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00215	33 c0		 xor	 eax, eax
$LN52@test_c_api:
  00217	e8 00 00 00 00	 call	 PyErr_Clear
  0021c	33 c0		 xor	 eax, eax
  0021e	85 c0		 test	 eax, eax
  00220	75 9c		 jne	 SHORT $LN41@test_c_api
$LN38@test_c_api:

; 2447 :     assertRaises(PyFrozenSet_New(Py_None) == NULL, PyExc_TypeError);

  00222	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00229	e8 00 00 00 00	 call	 PyFrozenSet_New
  0022e	48 85 c0	 test	 rax, rax
  00231	74 1c		 je	 SHORT $LN53@test_c_api
  00233	41 b8 8f 09 00
	00		 mov	 r8d, 2447		; 0000098fH
  00239	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GE@FBHIJEBI@?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAN?$AAe?$AAw?$AA?$CI?$AA?$CI?$AA?$CG?$AA_?$AAP?$AAy?$AA_?$AAN?$AAo?$AAn?$AAe?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt@
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0024d	33 c0		 xor	 eax, eax
$LN53@test_c_api:
  0024f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00256	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0025b	85 c0		 test	 eax, eax
  0025d	75 1c		 jne	 SHORT $LN54@test_c_api
  0025f	41 b8 8f 09 00
	00		 mov	 r8d, 2447		; 0000098fH
  00265	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@FIIOHKHG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAT?$AAy?$AAp@
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00279	33 c0		 xor	 eax, eax
$LN54@test_c_api:
  0027b	e8 00 00 00 00	 call	 PyErr_Clear
  00280	33 c0		 xor	 eax, eax
  00282	85 c0		 test	 eax, eax
  00284	75 9c		 jne	 SHORT $LN38@test_c_api

; 2448 : 
; 2449 :     /* Raise TypeError for unhashable key */
; 2450 :     dup = PySet_New(ob);

  00286	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  0028b	e8 00 00 00 00	 call	 PySet_New
  00290	48 89 44 24 70	 mov	 QWORD PTR dup$[rsp], rax
$LN35@test_c_api:

; 2451 :     assertRaises(PySet_Discard(ob, dup) == -1, PyExc_TypeError);

  00295	48 8b 54 24 70	 mov	 rdx, QWORD PTR dup$[rsp]
  0029a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  0029f	e8 00 00 00 00	 call	 PySet_Discard
  002a4	83 f8 ff	 cmp	 eax, -1
  002a7	74 1c		 je	 SHORT $LN55@test_c_api
  002a9	41 b8 93 09 00
	00		 mov	 r8d, 2451		; 00000993H
  002af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@GADOPPBJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002c3	33 c0		 xor	 eax, eax
$LN55@test_c_api:
  002c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002cc	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  002d1	85 c0		 test	 eax, eax
  002d3	75 1c		 jne	 SHORT $LN56@test_c_api
  002d5	41 b8 93 09 00
	00		 mov	 r8d, 2451		; 00000993H
  002db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@FIIOHKHG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAT?$AAy?$AAp@
  002e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ef	33 c0		 xor	 eax, eax
$LN56@test_c_api:
  002f1	e8 00 00 00 00	 call	 PyErr_Clear
  002f6	33 c0		 xor	 eax, eax
  002f8	85 c0		 test	 eax, eax
  002fa	75 99		 jne	 SHORT $LN35@test_c_api
$LN32@test_c_api:

; 2452 :     assertRaises(PySet_Contains(ob, dup) == -1, PyExc_TypeError);

  002fc	48 8b 54 24 70	 mov	 rdx, QWORD PTR dup$[rsp]
  00301	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  00306	e8 00 00 00 00	 call	 PySet_Contains
  0030b	83 f8 ff	 cmp	 eax, -1
  0030e	74 1c		 je	 SHORT $LN57@test_c_api
  00310	41 b8 94 09 00
	00		 mov	 r8d, 2452		; 00000994H
  00316	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0031d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@NKHAOMMO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  00324	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0032a	33 c0		 xor	 eax, eax
$LN57@test_c_api:
  0032c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00333	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00338	85 c0		 test	 eax, eax
  0033a	75 1c		 jne	 SHORT $LN58@test_c_api
  0033c	41 b8 94 09 00
	00		 mov	 r8d, 2452		; 00000994H
  00342	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00349	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@FIIOHKHG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAT?$AAy?$AAp@
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00356	33 c0		 xor	 eax, eax
$LN58@test_c_api:
  00358	e8 00 00 00 00	 call	 PyErr_Clear
  0035d	33 c0		 xor	 eax, eax
  0035f	85 c0		 test	 eax, eax
  00361	75 99		 jne	 SHORT $LN32@test_c_api
$LN29@test_c_api:

; 2453 :     assertRaises(PySet_Add(ob, dup) == -1, PyExc_TypeError);

  00363	48 8b 54 24 70	 mov	 rdx, QWORD PTR dup$[rsp]
  00368	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  0036d	e8 00 00 00 00	 call	 PySet_Add
  00372	83 f8 ff	 cmp	 eax, -1
  00375	74 1c		 je	 SHORT $LN59@test_c_api
  00377	41 b8 95 09 00
	00		 mov	 r8d, 2453		; 00000995H
  0037d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00384	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@OLGKNEAE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  0038b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00391	33 c0		 xor	 eax, eax
$LN59@test_c_api:
  00393	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0039a	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0039f	85 c0		 test	 eax, eax
  003a1	75 1c		 jne	 SHORT $LN60@test_c_api
  003a3	41 b8 95 09 00
	00		 mov	 r8d, 2453		; 00000995H
  003a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@FIIOHKHG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAT?$AAy?$AAp@
  003b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003bd	33 c0		 xor	 eax, eax
$LN60@test_c_api:
  003bf	e8 00 00 00 00	 call	 PyErr_Clear
  003c4	33 c0		 xor	 eax, eax
  003c6	85 c0		 test	 eax, eax
  003c8	75 99		 jne	 SHORT $LN29@test_c_api

; 2454 : 
; 2455 :     /* Exercise successful pop, contains, add, and discard */
; 2456 :     elem = PySet_Pop(ob);

  003ca	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  003cf	e8 00 00 00 00	 call	 PySet_Pop
  003d4	48 89 44 24 30	 mov	 QWORD PTR elem$[rsp], rax

; 2457 :     assert(PySet_Contains(ob, elem) == 0);

  003d9	48 8b 54 24 30	 mov	 rdx, QWORD PTR elem$[rsp]
  003de	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  003e3	e8 00 00 00 00	 call	 PySet_Contains
  003e8	85 c0		 test	 eax, eax
  003ea	74 1c		 je	 SHORT $LN61@test_c_api
  003ec	41 b8 99 09 00
	00		 mov	 r8d, 2457		; 00000999H
  003f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@DKEJAKEO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00400	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00406	33 c0		 xor	 eax, eax
$LN61@test_c_api:

; 2458 :     assert(PySet_GET_SIZE(ob) == 2);

  00408	48 8b 44 24 58	 mov	 rax, QWORD PTR ob$[rsp]
  0040d	48 83 78 68 02	 cmp	 QWORD PTR [rax+104], 2
  00412	74 1c		 je	 SHORT $LN62@test_c_api
  00414	41 b8 9a 09 00
	00		 mov	 r8d, 2458		; 0000099aH
  0041a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00421	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FBPOBGEK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?$AA@
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0042e	33 c0		 xor	 eax, eax
$LN62@test_c_api:

; 2459 :     assert(PySet_Add(ob, elem) == 0);

  00430	48 8b 54 24 30	 mov	 rdx, QWORD PTR elem$[rsp]
  00435	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  0043a	e8 00 00 00 00	 call	 PySet_Add
  0043f	85 c0		 test	 eax, eax
  00441	74 1c		 je	 SHORT $LN63@test_c_api
  00443	41 b8 9b 09 00
	00		 mov	 r8d, 2459		; 0000099bH
  00449	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00450	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@LFDDCIE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00457	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0045d	33 c0		 xor	 eax, eax
$LN63@test_c_api:

; 2460 :     assert(PySet_Contains(ob, elem) == 1);

  0045f	48 8b 54 24 30	 mov	 rdx, QWORD PTR elem$[rsp]
  00464	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  00469	e8 00 00 00 00	 call	 PySet_Contains
  0046e	83 f8 01	 cmp	 eax, 1
  00471	74 1c		 je	 SHORT $LN64@test_c_api
  00473	41 b8 9c 09 00
	00		 mov	 r8d, 2460		; 0000099cH
  00479	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00480	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@ICPFGNCL@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00487	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0048d	33 c0		 xor	 eax, eax
$LN64@test_c_api:

; 2461 :     assert(PySet_GET_SIZE(ob) == 3);

  0048f	48 8b 44 24 58	 mov	 rax, QWORD PTR ob$[rsp]
  00494	48 83 78 68 03	 cmp	 QWORD PTR [rax+104], 3
  00499	74 1c		 je	 SHORT $LN65@test_c_api
  0049b	41 b8 9d 09 00
	00		 mov	 r8d, 2461		; 0000099dH
  004a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  004a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@OJECHBCP@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
  004af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004b5	33 c0		 xor	 eax, eax
$LN65@test_c_api:

; 2462 :     assert(PySet_Discard(ob, elem) == 1);

  004b7	48 8b 54 24 30	 mov	 rdx, QWORD PTR elem$[rsp]
  004bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  004c1	e8 00 00 00 00	 call	 PySet_Discard
  004c6	83 f8 01	 cmp	 eax, 1
  004c9	74 1c		 je	 SHORT $LN66@test_c_api
  004cb	41 b8 9e 09 00
	00		 mov	 r8d, 2462		; 0000099eH
  004d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  004d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@DILLHOPM@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  004df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004e5	33 c0		 xor	 eax, eax
$LN66@test_c_api:

; 2463 :     assert(PySet_GET_SIZE(ob) == 2);

  004e7	48 8b 44 24 58	 mov	 rax, QWORD PTR ob$[rsp]
  004ec	48 83 78 68 02	 cmp	 QWORD PTR [rax+104], 2
  004f1	74 1c		 je	 SHORT $LN67@test_c_api
  004f3	41 b8 9f 09 00
	00		 mov	 r8d, 2463		; 0000099fH
  004f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00500	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FBPOBGEK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?$AA@
  00507	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0050d	33 c0		 xor	 eax, eax
$LN67@test_c_api:

; 2464 :     assert(PySet_Discard(ob, elem) == 0);

  0050f	48 8b 54 24 30	 mov	 rdx, QWORD PTR elem$[rsp]
  00514	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  00519	e8 00 00 00 00	 call	 PySet_Discard
  0051e	85 c0		 test	 eax, eax
  00520	74 1c		 je	 SHORT $LN68@test_c_api
  00522	41 b8 a0 09 00
	00		 mov	 r8d, 2464		; 000009a0H
  00528	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0052f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@IAAHBJJJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00536	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0053c	33 c0		 xor	 eax, eax
$LN68@test_c_api:

; 2465 :     assert(PySet_GET_SIZE(ob) == 2);

  0053e	48 8b 44 24 58	 mov	 rax, QWORD PTR ob$[rsp]
  00543	48 83 78 68 02	 cmp	 QWORD PTR [rax+104], 2
  00548	74 1c		 je	 SHORT $LN69@test_c_api
  0054a	41 b8 a1 09 00
	00		 mov	 r8d, 2465		; 000009a1H
  00550	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00557	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FBPOBGEK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?$AA@
  0055e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00564	33 c0		 xor	 eax, eax
$LN69@test_c_api:

; 2466 : 
; 2467 :     /* Exercise clear */
; 2468 :     dup2 = PySet_New(dup);

  00566	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dup$[rsp]
  0056b	e8 00 00 00 00	 call	 PySet_New
  00570	48 89 44 24 48	 mov	 QWORD PTR dup2$[rsp], rax

; 2469 :     assert(PySet_Clear(dup2) == 0);

  00575	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dup2$[rsp]
  0057a	e8 00 00 00 00	 call	 PySet_Clear
  0057f	85 c0		 test	 eax, eax
  00581	74 1c		 je	 SHORT $LN70@test_c_api
  00583	41 b8 a5 09 00
	00		 mov	 r8d, 2469		; 000009a5H
  00589	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00590	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@GLBFNHIM@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00597	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0059d	33 c0		 xor	 eax, eax
$LN70@test_c_api:

; 2470 :     assert(PySet_Size(dup2) == 0);

  0059f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dup2$[rsp]
  005a4	e8 00 00 00 00	 call	 PySet_Size
  005a9	48 85 c0	 test	 rax, rax
  005ac	74 1c		 je	 SHORT $LN71@test_c_api
  005ae	41 b8 a6 09 00
	00		 mov	 r8d, 2470		; 000009a6H
  005b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  005bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DMBPDGPL@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  005c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005c8	33 c0		 xor	 eax, eax
$LN71@test_c_api:

; 2471 :     Py_DECREF(dup2);

  005ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dup2$[rsp]
  005cf	e8 00 00 00 00	 call	 _Py_DecRef

; 2472 : 
; 2473 :     /* Raise SystemError on clear or update of frozen set */
; 2474 :     f = PyFrozenSet_New(dup);

  005d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dup$[rsp]
  005d9	e8 00 00 00 00	 call	 PyFrozenSet_New
  005de	48 89 44 24 50	 mov	 QWORD PTR f$[rsp], rax
$LN26@test_c_api:

; 2475 :     assertRaises(PySet_Clear(f) == -1, PyExc_SystemError);

  005e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  005e8	e8 00 00 00 00	 call	 PySet_Clear
  005ed	83 f8 ff	 cmp	 eax, -1
  005f0	74 1c		 je	 SHORT $LN72@test_c_api
  005f2	41 b8 ab 09 00
	00		 mov	 r8d, 2475		; 000009abH
  005f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  005ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@MNABLIMO@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  00606	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0060c	33 c0		 xor	 eax, eax
$LN72@test_c_api:
  0060e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00615	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0061a	85 c0		 test	 eax, eax
  0061c	75 1c		 jne	 SHORT $LN73@test_c_api
  0061e	41 b8 ab 09 00
	00		 mov	 r8d, 2475		; 000009abH
  00624	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0062b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@KOJNFMCG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAS?$AAy?$AAs@
  00632	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00638	33 c0		 xor	 eax, eax
$LN73@test_c_api:
  0063a	e8 00 00 00 00	 call	 PyErr_Clear
  0063f	33 c0		 xor	 eax, eax
  00641	85 c0		 test	 eax, eax
  00643	75 9e		 jne	 SHORT $LN26@test_c_api
$LN23@test_c_api:

; 2476 :     assertRaises(_PySet_Update(f, dup) == -1, PyExc_SystemError);

  00645	48 8b 54 24 70	 mov	 rdx, QWORD PTR dup$[rsp]
  0064a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  0064f	e8 00 00 00 00	 call	 _PySet_Update
  00654	83 f8 ff	 cmp	 eax, -1
  00657	74 1c		 je	 SHORT $LN74@test_c_api
  00659	41 b8 ac 09 00
	00		 mov	 r8d, 2476		; 000009acH
  0065f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00666	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@DBNADGLH@?$AA_?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?$CI?$AAf?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  0066d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00673	33 c0		 xor	 eax, eax
$LN74@test_c_api:
  00675	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0067c	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00681	85 c0		 test	 eax, eax
  00683	75 1c		 jne	 SHORT $LN75@test_c_api
  00685	41 b8 ac 09 00
	00		 mov	 r8d, 2476		; 000009acH
  0068b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00692	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@KOJNFMCG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAS?$AAy?$AAs@
  00699	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0069f	33 c0		 xor	 eax, eax
$LN75@test_c_api:
  006a1	e8 00 00 00 00	 call	 PyErr_Clear
  006a6	33 c0		 xor	 eax, eax
  006a8	85 c0		 test	 eax, eax
  006aa	75 99		 jne	 SHORT $LN23@test_c_api

; 2477 :     assert(PySet_Add(f, elem) == 0);

  006ac	48 8b 54 24 30	 mov	 rdx, QWORD PTR elem$[rsp]
  006b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  006b6	e8 00 00 00 00	 call	 PySet_Add
  006bb	85 c0		 test	 eax, eax
  006bd	74 1c		 je	 SHORT $LN76@test_c_api
  006bf	41 b8 ad 09 00
	00		 mov	 r8d, 2477		; 000009adH
  006c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  006cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CJFDIPLJ@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  006d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006d9	33 c0		 xor	 eax, eax
$LN76@test_c_api:

; 2478 :     Py_INCREF(f);

  006db	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  006e0	e8 00 00 00 00	 call	 _Py_IncRef
$LN20@test_c_api:

; 2479 :     assertRaises(PySet_Add(f, elem) == -1, PyExc_SystemError);

  006e5	48 8b 54 24 30	 mov	 rdx, QWORD PTR elem$[rsp]
  006ea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  006ef	e8 00 00 00 00	 call	 PySet_Add
  006f4	83 f8 ff	 cmp	 eax, -1
  006f7	74 1c		 je	 SHORT $LN77@test_c_api
  006f9	41 b8 af 09 00
	00		 mov	 r8d, 2479		; 000009afH
  006ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00706	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@LPNPCMJC@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAA?$AAd?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  0070d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00713	33 c0		 xor	 eax, eax
$LN77@test_c_api:
  00715	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0071c	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00721	85 c0		 test	 eax, eax
  00723	75 1c		 jne	 SHORT $LN78@test_c_api
  00725	41 b8 af 09 00
	00		 mov	 r8d, 2479		; 000009afH
  0072b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00732	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@KOJNFMCG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAS?$AAy?$AAs@
  00739	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0073f	33 c0		 xor	 eax, eax
$LN78@test_c_api:
  00741	e8 00 00 00 00	 call	 PyErr_Clear
  00746	33 c0		 xor	 eax, eax
  00748	85 c0		 test	 eax, eax
  0074a	75 99		 jne	 SHORT $LN20@test_c_api

; 2480 :     Py_DECREF(f);

  0074c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  00751	e8 00 00 00 00	 call	 _Py_DecRef

; 2481 :     Py_DECREF(f);

  00756	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  0075b	e8 00 00 00 00	 call	 _Py_DecRef

; 2482 : 
; 2483 :     /* Exercise direct iteration */
; 2484 :     i = 0, count = 0;

  00760	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00769	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0
$LN17@test_c_api:

; 2485 :     while (_PySet_NextEntry((PyObject *)dup, &i, &x, &hash)) {

  00772	4c 8d 4c 24 60	 lea	 r9, QWORD PTR hash$[rsp]
  00777	4c 8d 44 24 28	 lea	 r8, QWORD PTR x$[rsp]
  0077c	48 8d 54 24 38	 lea	 rdx, QWORD PTR i$[rsp]
  00781	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dup$[rsp]
  00786	e8 00 00 00 00	 call	 _PySet_NextEntry
  0078b	85 c0		 test	 eax, eax
  0078d	74 6c		 je	 SHORT $LN16@test_c_api

; 2486 :         s = _PyUnicode_AsString(x);

  0078f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  00794	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00799	48 89 44 24 40	 mov	 QWORD PTR s$[rsp], rax

; 2487 :         assert(s && (s[0] == 'a' || s[0] == 'b' || s[0] == 'c'));

  0079e	48 83 7c 24 40
	00		 cmp	 QWORD PTR s$[rsp], 0
  007a4	74 27		 je	 SHORT $LN80@test_c_api
  007a6	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  007ab	0f be 00	 movsx	 eax, BYTE PTR [rax]
  007ae	83 f8 61	 cmp	 eax, 97			; 00000061H
  007b1	74 36		 je	 SHORT $LN79@test_c_api
  007b3	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  007b8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  007bb	83 f8 62	 cmp	 eax, 98			; 00000062H
  007be	74 29		 je	 SHORT $LN79@test_c_api
  007c0	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  007c5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  007c8	83 f8 63	 cmp	 eax, 99			; 00000063H
  007cb	74 1c		 je	 SHORT $LN79@test_c_api
$LN80@test_c_api:
  007cd	41 b8 b7 09 00
	00		 mov	 r8d, 2487		; 000009b7H
  007d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  007da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GC@IDHKDLIB@?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAa?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAs?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AAb?$AA?8@
  007e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  007e7	33 c0		 xor	 eax, eax
$LN79@test_c_api:

; 2488 :         count++;

  007e9	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  007ee	48 ff c0	 inc	 rax
  007f1	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 2489 :     }

  007f6	e9 77 ff ff ff	 jmp	 $LN17@test_c_api
$LN16@test_c_api:

; 2490 :     assert(count == 3);

  007fb	48 83 7c 24 20
	03		 cmp	 QWORD PTR count$[rsp], 3
  00801	74 1c		 je	 SHORT $LN81@test_c_api
  00803	41 b8 ba 09 00
	00		 mov	 r8d, 2490		; 000009baH
  00809	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00810	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@MGLAKGBP@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
  00817	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0081d	33 c0		 xor	 eax, eax
$LN81@test_c_api:

; 2491 : 
; 2492 :     /* Exercise updates */
; 2493 :     dup2 = PySet_New(NULL);

  0081f	33 c9		 xor	 ecx, ecx
  00821	e8 00 00 00 00	 call	 PySet_New
  00826	48 89 44 24 48	 mov	 QWORD PTR dup2$[rsp], rax

; 2494 :     assert(_PySet_Update(dup2, dup) == 0);

  0082b	48 8b 54 24 70	 mov	 rdx, QWORD PTR dup$[rsp]
  00830	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dup2$[rsp]
  00835	e8 00 00 00 00	 call	 _PySet_Update
  0083a	85 c0		 test	 eax, eax
  0083c	74 1c		 je	 SHORT $LN82@test_c_api
  0083e	41 b8 be 09 00
	00		 mov	 r8d, 2494		; 000009beH
  00844	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0084b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@EGNKFHFO@?$AA_?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00852	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00858	33 c0		 xor	 eax, eax
$LN82@test_c_api:

; 2495 :     assert(PySet_Size(dup2) == 3);

  0085a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dup2$[rsp]
  0085f	e8 00 00 00 00	 call	 PySet_Size
  00864	48 83 f8 03	 cmp	 rax, 3
  00868	74 1c		 je	 SHORT $LN83@test_c_api
  0086a	41 b8 bf 09 00
	00		 mov	 r8d, 2495		; 000009bfH
  00870	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00877	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@COKKJJBF@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
  0087e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00884	33 c0		 xor	 eax, eax
$LN83@test_c_api:

; 2496 :     assert(_PySet_Update(dup2, dup) == 0);

  00886	48 8b 54 24 70	 mov	 rdx, QWORD PTR dup$[rsp]
  0088b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dup2$[rsp]
  00890	e8 00 00 00 00	 call	 _PySet_Update
  00895	85 c0		 test	 eax, eax
  00897	74 1c		 je	 SHORT $LN84@test_c_api
  00899	41 b8 c0 09 00
	00		 mov	 r8d, 2496		; 000009c0H
  0089f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  008a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@EGNKFHFO@?$AA_?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  008ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  008b3	33 c0		 xor	 eax, eax
$LN84@test_c_api:

; 2497 :     assert(PySet_Size(dup2) == 3);

  008b5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dup2$[rsp]
  008ba	e8 00 00 00 00	 call	 PySet_Size
  008bf	48 83 f8 03	 cmp	 rax, 3
  008c3	74 1c		 je	 SHORT $LN85@test_c_api
  008c5	41 b8 c1 09 00
	00		 mov	 r8d, 2497		; 000009c1H
  008cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  008d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@COKKJJBF@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAu?$AAp?$AA2?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
  008d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  008df	33 c0		 xor	 eax, eax
$LN85@test_c_api:

; 2498 :     Py_DECREF(dup2);

  008e1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dup2$[rsp]
  008e6	e8 00 00 00 00	 call	 _Py_DecRef

; 2499 : 
; 2500 :     /* Raise SystemError when self argument is not a set or frozenset. */
; 2501 :     t = PyTuple_New(0);

  008eb	33 c9		 xor	 ecx, ecx
  008ed	e8 00 00 00 00	 call	 PyTuple_New
  008f2	48 89 44 24 68	 mov	 QWORD PTR t$[rsp], rax
$LN15@test_c_api:

; 2502 :     assertRaises(PySet_Size(t) == -1, PyExc_SystemError);

  008f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  008fc	e8 00 00 00 00	 call	 PySet_Size
  00901	48 83 f8 ff	 cmp	 rax, -1
  00905	74 1c		 je	 SHORT $LN86@test_c_api
  00907	41 b8 c6 09 00
	00		 mov	 r8d, 2502		; 000009c6H
  0090d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00914	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@GPMMLPJB@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  0091b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00921	33 c0		 xor	 eax, eax
$LN86@test_c_api:
  00923	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0092a	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0092f	85 c0		 test	 eax, eax
  00931	75 1c		 jne	 SHORT $LN87@test_c_api
  00933	41 b8 c6 09 00
	00		 mov	 r8d, 2502		; 000009c6H
  00939	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00940	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@KOJNFMCG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAS?$AAy?$AAs@
  00947	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0094d	33 c0		 xor	 eax, eax
$LN87@test_c_api:
  0094f	e8 00 00 00 00	 call	 PyErr_Clear
  00954	33 c0		 xor	 eax, eax
  00956	85 c0		 test	 eax, eax
  00958	75 9d		 jne	 SHORT $LN15@test_c_api
$LN12@test_c_api:

; 2503 :     assertRaises(PySet_Contains(t, elem) == -1, PyExc_SystemError);

  0095a	48 8b 54 24 30	 mov	 rdx, QWORD PTR elem$[rsp]
  0095f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  00964	e8 00 00 00 00	 call	 PySet_Contains
  00969	83 f8 ff	 cmp	 eax, -1
  0096c	74 1c		 je	 SHORT $LN88@test_c_api
  0096e	41 b8 c7 09 00
	00		 mov	 r8d, 2503		; 000009c7H
  00974	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0097b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@IGOIOOEK@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAs?$AA?$CI?$AAt?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  00982	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00988	33 c0		 xor	 eax, eax
$LN88@test_c_api:
  0098a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00991	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00996	85 c0		 test	 eax, eax
  00998	75 1c		 jne	 SHORT $LN89@test_c_api
  0099a	41 b8 c7 09 00
	00		 mov	 r8d, 2503		; 000009c7H
  009a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  009a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@KOJNFMCG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAS?$AAy?$AAs@
  009ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009b4	33 c0		 xor	 eax, eax
$LN89@test_c_api:
  009b6	e8 00 00 00 00	 call	 PyErr_Clear
  009bb	33 c0		 xor	 eax, eax
  009bd	85 c0		 test	 eax, eax
  009bf	75 99		 jne	 SHORT $LN12@test_c_api

; 2504 :     Py_DECREF(t);

  009c1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  009c6	e8 00 00 00 00	 call	 _Py_DecRef

; 2505 : 
; 2506 :     /* Raise SystemError when self argument is not a set. */
; 2507 :     f = PyFrozenSet_New(dup);

  009cb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dup$[rsp]
  009d0	e8 00 00 00 00	 call	 PyFrozenSet_New
  009d5	48 89 44 24 50	 mov	 QWORD PTR f$[rsp], rax

; 2508 :     assert(PySet_Size(f) == 3);

  009da	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  009df	e8 00 00 00 00	 call	 PySet_Size
  009e4	48 83 f8 03	 cmp	 rax, 3
  009e8	74 1c		 je	 SHORT $LN90@test_c_api
  009ea	41 b8 cc 09 00
	00		 mov	 r8d, 2508		; 000009ccH
  009f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  009f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@DIDFNCN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3?$AA?$AA@
  009fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a04	33 c0		 xor	 eax, eax
$LN90@test_c_api:

; 2509 :     assert(PyFrozenSet_CheckExact(f));

  00a06	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00a0d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  00a12	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00a16	74 1c		 je	 SHORT $LN91@test_c_api
  00a18	41 b8 cd 09 00
	00		 mov	 r8d, 2509		; 000009cdH
  00a1e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00a25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@HJOOOEJO@?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAf?$AA?$CJ?$AA?$AA@
  00a2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a32	33 c0		 xor	 eax, eax
$LN91@test_c_api:
$LN9@test_c_api:

; 2510 :     assertRaises(PySet_Discard(f, elem) == -1, PyExc_SystemError);

  00a34	48 8b 54 24 30	 mov	 rdx, QWORD PTR elem$[rsp]
  00a39	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  00a3e	e8 00 00 00 00	 call	 PySet_Discard
  00a43	83 f8 ff	 cmp	 eax, -1
  00a46	74 1c		 je	 SHORT $LN92@test_c_api
  00a48	41 b8 ce 09 00
	00		 mov	 r8d, 2510		; 000009ceH
  00a4e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00a55	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@DEILAHIP@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$CI?$AAf?$AA?0?$AA?5?$AAe?$AAl?$AAe?$AAm?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  00a5c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a62	33 c0		 xor	 eax, eax
$LN92@test_c_api:
  00a64	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00a6b	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00a70	85 c0		 test	 eax, eax
  00a72	75 1c		 jne	 SHORT $LN93@test_c_api
  00a74	41 b8 ce 09 00
	00		 mov	 r8d, 2510		; 000009ceH
  00a7a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00a81	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@KOJNFMCG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAS?$AAy?$AAs@
  00a88	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a8e	33 c0		 xor	 eax, eax
$LN93@test_c_api:
  00a90	e8 00 00 00 00	 call	 PyErr_Clear
  00a95	33 c0		 xor	 eax, eax
  00a97	85 c0		 test	 eax, eax
  00a99	75 99		 jne	 SHORT $LN9@test_c_api
$LN6@test_c_api:

; 2511 :     assertRaises(PySet_Pop(f) == NULL, PyExc_SystemError);

  00a9b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  00aa0	e8 00 00 00 00	 call	 PySet_Pop
  00aa5	48 85 c0	 test	 rax, rax
  00aa8	74 1c		 je	 SHORT $LN94@test_c_api
  00aaa	41 b8 cf 09 00
	00		 mov	 r8d, 2511		; 000009cfH
  00ab0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00ab7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@KPJHHOAE@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAP?$AAo?$AAp?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AA?$CJ?$AA?$AA@
  00abe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00ac4	33 c0		 xor	 eax, eax
$LN94@test_c_api:
  00ac6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00acd	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00ad2	85 c0		 test	 eax, eax
  00ad4	75 1c		 jne	 SHORT $LN95@test_c_api
  00ad6	41 b8 cf 09 00
	00		 mov	 r8d, 2511		; 000009cfH
  00adc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00ae3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@KOJNFMCG@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAS?$AAy?$AAs@
  00aea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00af0	33 c0		 xor	 eax, eax
$LN95@test_c_api:
  00af2	e8 00 00 00 00	 call	 PyErr_Clear
  00af7	33 c0		 xor	 eax, eax
  00af9	85 c0		 test	 eax, eax
  00afb	75 9e		 jne	 SHORT $LN6@test_c_api

; 2512 :     Py_DECREF(f);

  00afd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  00b02	e8 00 00 00 00	 call	 _Py_DecRef

; 2513 : 
; 2514 :     /* Raise KeyError when popping from an empty set */
; 2515 :     assert(PyNumber_InPlaceSubtract(ob, ob) == ob);

  00b07	48 8b 54 24 58	 mov	 rdx, QWORD PTR ob$[rsp]
  00b0c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  00b11	e8 00 00 00 00	 call	 PyNumber_InPlaceSubtract
  00b16	48 3b 44 24 58	 cmp	 rax, QWORD PTR ob$[rsp]
  00b1b	74 1c		 je	 SHORT $LN96@test_c_api
  00b1d	41 b8 d3 09 00
	00		 mov	 r8d, 2515		; 000009d3H
  00b23	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00b2a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@DFJENNHB@?$AAP?$AAy?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA_?$AAI?$AAn?$AAP?$AAl?$AAa?$AAc?$AAe?$AAS?$AAu?$AAb?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAo?$AAb?$AA?$CJ@
  00b31	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00b37	33 c0		 xor	 eax, eax
$LN96@test_c_api:

; 2516 :     Py_DECREF(ob);

  00b39	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  00b3e	e8 00 00 00 00	 call	 _Py_DecRef

; 2517 :     assert(PySet_GET_SIZE(ob) == 0);

  00b43	48 8b 44 24 58	 mov	 rax, QWORD PTR ob$[rsp]
  00b48	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00b4d	74 1c		 je	 SHORT $LN97@test_c_api
  00b4f	41 b8 d5 09 00
	00		 mov	 r8d, 2517		; 000009d5H
  00b55	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00b5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@PLPHNOMB@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00b63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00b69	33 c0		 xor	 eax, eax
$LN97@test_c_api:
$LN3@test_c_api:

; 2518 :     assertRaises(PySet_Pop(ob) == NULL, PyExc_KeyError);

  00b6b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  00b70	e8 00 00 00 00	 call	 PySet_Pop
  00b75	48 85 c0	 test	 rax, rax
  00b78	74 1c		 je	 SHORT $LN98@test_c_api
  00b7a	41 b8 d6 09 00
	00		 mov	 r8d, 2518		; 000009d6H
  00b80	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00b87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@FLJNOHIN@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAP?$AAo?$AAp?$AA?$CI?$AAo?$AAb?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA0?$AA?$CJ?$AA?$AA@
  00b8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00b94	33 c0		 xor	 eax, eax
$LN98@test_c_api:
  00b96	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  00b9d	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00ba2	85 c0		 test	 eax, eax
  00ba4	75 1c		 jne	 SHORT $LN99@test_c_api
  00ba6	41 b8 d6 09 00
	00		 mov	 r8d, 2518		; 000009d6H
  00bac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00bb3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@ILCKEJCD@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AAM?$AAa?$AAt?$AAc?$AAh?$AAe?$AAs?$AA?$CI?$AAP?$AAy?$AAE?$AAx?$AAc?$AA_?$AAK?$AAe?$AAy@
  00bba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00bc0	33 c0		 xor	 eax, eax
$LN99@test_c_api:
  00bc2	e8 00 00 00 00	 call	 PyErr_Clear
  00bc7	33 c0		 xor	 eax, eax
  00bc9	85 c0		 test	 eax, eax
  00bcb	75 9e		 jne	 SHORT $LN3@test_c_api

; 2519 : 
; 2520 :     /* Restore the set from the copy using the PyNumber API */
; 2521 :     assert(PyNumber_InPlaceOr(ob, dup) == ob);

  00bcd	48 8b 54 24 70	 mov	 rdx, QWORD PTR dup$[rsp]
  00bd2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  00bd7	e8 00 00 00 00	 call	 PyNumber_InPlaceOr
  00bdc	48 3b 44 24 58	 cmp	 rax, QWORD PTR ob$[rsp]
  00be1	74 1c		 je	 SHORT $LN100@test_c_api
  00be3	41 b8 d9 09 00
	00		 mov	 r8d, 2521		; 000009d9H
  00be9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00bf0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@ONLMHKFI@?$AAP?$AAy?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AA_?$AAI?$AAn?$AAP?$AAl?$AAa?$AAc?$AAe?$AAO?$AAr?$AA?$CI?$AAo?$AAb?$AA?0?$AA?5?$AAd?$AAu?$AAp?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo@
  00bf7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00bfd	33 c0		 xor	 eax, eax
$LN100@test_c_api:

; 2522 :     Py_DECREF(ob);

  00bff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ob$[rsp]
  00c04	e8 00 00 00 00	 call	 _Py_DecRef

; 2523 : 
; 2524 :     /* Verify constructors accept NULL arguments */
; 2525 :     f = PySet_New(NULL);

  00c09	33 c9		 xor	 ecx, ecx
  00c0b	e8 00 00 00 00	 call	 PySet_New
  00c10	48 89 44 24 50	 mov	 QWORD PTR f$[rsp], rax

; 2526 :     assert(f != NULL);

  00c15	48 83 7c 24 50
	00		 cmp	 QWORD PTR f$[rsp], 0
  00c1b	75 1c		 jne	 SHORT $LN101@test_c_api
  00c1d	41 b8 de 09 00
	00		 mov	 r8d, 2526		; 000009deH
  00c23	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00c2a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@IPOMFDFC@?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00c31	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c37	33 c0		 xor	 eax, eax
$LN101@test_c_api:

; 2527 :     assert(PySet_GET_SIZE(f) == 0);

  00c39	48 8b 44 24 50	 mov	 rax, QWORD PTR f$[rsp]
  00c3e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00c43	74 1c		 je	 SHORT $LN102@test_c_api
  00c45	41 b8 df 09 00
	00		 mov	 r8d, 2527		; 000009dfH
  00c4b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00c52	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@OHNHGCNF@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00c59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c5f	33 c0		 xor	 eax, eax
$LN102@test_c_api:

; 2528 :     Py_DECREF(f);

  00c61	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  00c66	e8 00 00 00 00	 call	 _Py_DecRef

; 2529 :     f = PyFrozenSet_New(NULL);

  00c6b	33 c9		 xor	 ecx, ecx
  00c6d	e8 00 00 00 00	 call	 PyFrozenSet_New
  00c72	48 89 44 24 50	 mov	 QWORD PTR f$[rsp], rax

; 2530 :     assert(f != NULL);

  00c77	48 83 7c 24 50
	00		 cmp	 QWORD PTR f$[rsp], 0
  00c7d	75 1c		 jne	 SHORT $LN103@test_c_api
  00c7f	41 b8 e2 09 00
	00		 mov	 r8d, 2530		; 000009e2H
  00c85	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00c8c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@IPOMFDFC@?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00c93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c99	33 c0		 xor	 eax, eax
$LN103@test_c_api:

; 2531 :     assert(PyFrozenSet_CheckExact(f));

  00c9b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  00ca2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  00ca7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00cab	74 1c		 je	 SHORT $LN104@test_c_api
  00cad	41 b8 e3 09 00
	00		 mov	 r8d, 2531		; 000009e3H
  00cb3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00cba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@HJOOOEJO@?$AAP?$AAy?$AAF?$AAr?$AAo?$AAz?$AAe?$AAn?$AAS?$AAe?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAf?$AA?$CJ?$AA?$AA@
  00cc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00cc7	33 c0		 xor	 eax, eax
$LN104@test_c_api:

; 2532 :     assert(PySet_GET_SIZE(f) == 0);

  00cc9	48 8b 44 24 50	 mov	 rax, QWORD PTR f$[rsp]
  00cce	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00cd3	74 1c		 je	 SHORT $LN105@test_c_api
  00cd5	41 b8 e4 09 00
	00		 mov	 r8d, 2532		; 000009e4H
  00cdb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@GJMFHBGO@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAe?$AAt?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00ce2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@OHNHGCNF@?$AAP?$AAy?$AAS?$AAe?$AAt?$AA_?$AAG?$AAE?$AAT?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAf?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00ce9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00cef	33 c0		 xor	 eax, eax
$LN105@test_c_api:

; 2533 :     Py_DECREF(f);

  00cf1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  00cf6	e8 00 00 00 00	 call	 _Py_DecRef

; 2534 : 
; 2535 :     Py_DECREF(elem);

  00cfb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR elem$[rsp]
  00d00	e8 00 00 00 00	 call	 _Py_DecRef

; 2536 :     Py_DECREF(dup);

  00d05	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dup$[rsp]
  00d0a	e8 00 00 00 00	 call	 _Py_DecRef

; 2537 :     Py_RETURN_TRUE;

  00d0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00d16	e8 00 00 00 00	 call	 _Py_IncRef
  00d1b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
$LN44@test_c_api:

; 2538 : }

  00d22	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00d29	c3		 ret	 0
test_c_api ENDP
_TEXT	ENDS
END
