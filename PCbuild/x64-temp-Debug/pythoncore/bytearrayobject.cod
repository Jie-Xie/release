; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@FCNILHGP@bytearray_iterator?$AA@	; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
PUBLIC	??_C@_09FCJHKOIN@bytearray?$AA@			; `string'
PUBLIC	??_C@_05DMFNFMHA@zfill?$AA@			; `string'
PUBLIC	??_C@_05NECKJAMC@upper?$AA@			; `string'
PUBLIC	??_C@_09ODNGOEIO@translate?$AA@			; `string'
PUBLIC	??_C@_05PHLGJONK@title?$AA@			; `string'
PUBLIC	??_C@_08EDJLBCEI@swapcase?$AA@			; `string'
PUBLIC	??_C@_05GGNGIGHC@strip?$AA@			; `string'
PUBLIC	??_C@_0L@MPOGHCCL@startswith?$AA@		; `string'
PUBLIC	??_C@_0L@BCMGLLLC@splitlines?$AA@		; `string'
PUBLIC	??_C@_05EHPMMFBK@split?$AA@			; `string'
PUBLIC	??_C@_06DBIPDJKN@rstrip?$AA@			; `string'
PUBLIC	??_C@_06BAKFHKMF@rsplit?$AA@			; `string'
PUBLIC	??_C@_0L@KEEHLNKL@rpartition?$AA@		; `string'
PUBLIC	??_C@_05JKFAKHCP@rjust?$AA@			; `string'
PUBLIC	??_C@_06NCDOMFM@rindex?$AA@			; `string'
PUBLIC	??_C@_05BLFDIAHL@rfind?$AA@			; `string'
PUBLIC	??_C@_07KOIEOCCE@reverse?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_06LEMKAMD@remove?$AA@			; `string'
PUBLIC	??_C@_03NJDAHFJE@pop?$AA@			; `string'
PUBLIC	??_C@_09IKAEIPAD@partition?$AA@			; `string'
PUBLIC	??_C@_09PBBLPCAA@maketrans?$AA@			; `string'
PUBLIC	??_C@_06GGONODO@lstrip?$AA@			; `string'
PUBLIC	??_C@_05IPJEPLHL@lower?$AA@			; `string'
PUBLIC	??_C@_05KDIMMEME@ljust?$AA@			; `string'
PUBLIC	??_C@_04DFGCDGNN@join?$AA@			; `string'
PUBLIC	??_C@_07BCOOJPCO@isupper?$AA@			; `string'
PUBLIC	??_C@_07DBHCJBDG@istitle?$AA@			; `string'
PUBLIC	??_C@_07CNBMLEON@isspace?$AA@			; `string'
PUBLIC	??_C@_07EJFAPEJH@islower?$AA@			; `string'
PUBLIC	??_C@_07CFBKIKCH@isdigit?$AA@			; `string'
PUBLIC	??_C@_07EGIOHHOB@isalpha?$AA@			; `string'
PUBLIC	??_C@_07EOADCIGC@isalnum?$AA@			; `string'
PUBLIC	??_C@_06OAOPNKHP@insert?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_07DIMGGDAC@fromhex?$AA@			; `string'
PUBLIC	??_C@_04CKFJHKAP@find?$AA@			; `string'
PUBLIC	??_C@_06BPBOMFNI@extend?$AA@			; `string'
PUBLIC	??_C@_0L@DEOCELBD@expandtabs?$AA@		; `string'
PUBLIC	??_C@_08MLCMCPNP@endswith?$AA@			; `string'
PUBLIC	??_C@_06KPNAMAEI@decode?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_05MEHLAELG@clear?$AA@			; `string'
PUBLIC	??_C@_06BBLOAEEI@center?$AA@			; `string'
PUBLIC	??_C@_0L@NMODNBEH@capitalize?$AA@		; `string'
PUBLIC	??_C@_06PCICMFGG@append?$AA@			; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_09LONCBNBJ@__alloc__?$AA@			; `string'
PUBLIC	PyByteArray_Concat
PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_08EMIAAFLA@keepends?$AA@			; `string'
PUBLIC	??_C@_08HONNCIIN@maxsplit?$AA@			; `string'
PUBLIC	??_C@_03MGBCFPKM@sep?$AA@			; `string'
PUBLIC	??_C@_06EOMHCNPI@errors?$AA@			; `string'
PUBLIC	??_C@_08MLPGAEIK@encoding?$AA@			; `string'
PUBLIC	??_C@_06OEKOLKIL@source?$AA@			; `string'
PUBLIC	_PyByteArray_empty_string
PUBLIC	PyByteArray_Type
PUBLIC	PyByteArrayIter_Type
EXTRN	PyObject_SelfIter:PROC
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PyType_GenericNew:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
EXTRN	_Py_upper__doc__:BYTE
EXTRN	_Py_title__doc__:BYTE
EXTRN	_Py_swapcase__doc__:BYTE
EXTRN	_Py_maketrans__doc__:BYTE
EXTRN	_Py_lower__doc__:BYTE
EXTRN	_Py_isupper__doc__:BYTE
EXTRN	_Py_istitle__doc__:BYTE
EXTRN	_Py_isspace__doc__:BYTE
EXTRN	_Py_islower__doc__:BYTE
EXTRN	_Py_isdigit__doc__:BYTE
EXTRN	_Py_isalpha__doc__:BYTE
EXTRN	_Py_isalnum__doc__:BYTE
EXTRN	_Py_capitalize__doc__:BYTE
_BSS	SEGMENT
_PyByteArray_empty_string DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BD@FCNILHGP@bytearray_iterator?$AA@
CONST	SEGMENT
??_C@_0BD@FCNILHGP@bytearray_iterator?$AA@ DB 'bytearray_iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCJHKOIN@bytearray?$AA@
CONST	SEGMENT
??_C@_09FCJHKOIN@bytearray?$AA@ DB 'bytearray', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DMFNFMHA@zfill?$AA@
CONST	SEGMENT
??_C@_05DMFNFMHA@zfill?$AA@ DB 'zfill', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NECKJAMC@upper?$AA@
CONST	SEGMENT
??_C@_05NECKJAMC@upper?$AA@ DB 'upper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODNGOEIO@translate?$AA@
CONST	SEGMENT
??_C@_09ODNGOEIO@translate?$AA@ DB 'translate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHLGJONK@title?$AA@
CONST	SEGMENT
??_C@_05PHLGJONK@title?$AA@ DB 'title', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDJLBCEI@swapcase?$AA@
CONST	SEGMENT
??_C@_08EDJLBCEI@swapcase?$AA@ DB 'swapcase', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GGNGIGHC@strip?$AA@
CONST	SEGMENT
??_C@_05GGNGIGHC@strip?$AA@ DB 'strip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPOGHCCL@startswith?$AA@
CONST	SEGMENT
??_C@_0L@MPOGHCCL@startswith?$AA@ DB 'startswith', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCMGLLLC@splitlines?$AA@
CONST	SEGMENT
??_C@_0L@BCMGLLLC@splitlines?$AA@ DB 'splitlines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EHPMMFBK@split?$AA@
CONST	SEGMENT
??_C@_05EHPMMFBK@split?$AA@ DB 'split', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DBIPDJKN@rstrip?$AA@
CONST	SEGMENT
??_C@_06DBIPDJKN@rstrip?$AA@ DB 'rstrip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BAKFHKMF@rsplit?$AA@
CONST	SEGMENT
??_C@_06BAKFHKMF@rsplit?$AA@ DB 'rsplit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEEHLNKL@rpartition?$AA@
CONST	SEGMENT
??_C@_0L@KEEHLNKL@rpartition?$AA@ DB 'rpartition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKFAKHCP@rjust?$AA@
CONST	SEGMENT
??_C@_05JKFAKHCP@rjust?$AA@ DB 'rjust', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NCDOMFM@rindex?$AA@
CONST	SEGMENT
??_C@_06NCDOMFM@rindex?$AA@ DB 'rindex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLFDIAHL@rfind?$AA@
CONST	SEGMENT
??_C@_05BLFDIAHL@rfind?$AA@ DB 'rfind', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KOIEOCCE@reverse?$AA@
CONST	SEGMENT
??_C@_07KOIEOCCE@reverse?$AA@ DB 'reverse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEMKAMD@remove?$AA@
CONST	SEGMENT
??_C@_06LEMKAMD@remove?$AA@ DB 'remove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJDAHFJE@pop?$AA@
CONST	SEGMENT
??_C@_03NJDAHFJE@pop?$AA@ DB 'pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09IKAEIPAD@partition?$AA@
CONST	SEGMENT
??_C@_09IKAEIPAD@partition?$AA@ DB 'partition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PBBLPCAA@maketrans?$AA@
CONST	SEGMENT
??_C@_09PBBLPCAA@maketrans?$AA@ DB 'maketrans', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGONODO@lstrip?$AA@
CONST	SEGMENT
??_C@_06GGONODO@lstrip?$AA@ DB 'lstrip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPJEPLHL@lower?$AA@
CONST	SEGMENT
??_C@_05IPJEPLHL@lower?$AA@ DB 'lower', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDIMMEME@ljust?$AA@
CONST	SEGMENT
??_C@_05KDIMMEME@ljust?$AA@ DB 'ljust', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DFGCDGNN@join?$AA@
CONST	SEGMENT
??_C@_04DFGCDGNN@join?$AA@ DB 'join', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCOOJPCO@isupper?$AA@
CONST	SEGMENT
??_C@_07BCOOJPCO@isupper?$AA@ DB 'isupper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBHCJBDG@istitle?$AA@
CONST	SEGMENT
??_C@_07DBHCJBDG@istitle?$AA@ DB 'istitle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNBMLEON@isspace?$AA@
CONST	SEGMENT
??_C@_07CNBMLEON@isspace?$AA@ DB 'isspace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EJFAPEJH@islower?$AA@
CONST	SEGMENT
??_C@_07EJFAPEJH@islower?$AA@ DB 'islower', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CFBKIKCH@isdigit?$AA@
CONST	SEGMENT
??_C@_07CFBKIKCH@isdigit?$AA@ DB 'isdigit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EGIOHHOB@isalpha?$AA@
CONST	SEGMENT
??_C@_07EGIOHHOB@isalpha?$AA@ DB 'isalpha', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOADCIGC@isalnum?$AA@
CONST	SEGMENT
??_C@_07EOADCIGC@isalnum?$AA@ DB 'isalnum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAOPNKHP@insert?$AA@
CONST	SEGMENT
??_C@_06OAOPNKHP@insert?$AA@ DB 'insert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIMGGDAC@fromhex?$AA@
CONST	SEGMENT
??_C@_07DIMGGDAC@fromhex?$AA@ DB 'fromhex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CKFJHKAP@find?$AA@
CONST	SEGMENT
??_C@_04CKFJHKAP@find?$AA@ DB 'find', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPBOMFNI@extend?$AA@
CONST	SEGMENT
??_C@_06BPBOMFNI@extend?$AA@ DB 'extend', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DEOCELBD@expandtabs?$AA@
CONST	SEGMENT
??_C@_0L@DEOCELBD@expandtabs?$AA@ DB 'expandtabs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLCMCPNP@endswith?$AA@
CONST	SEGMENT
??_C@_08MLCMCPNP@endswith?$AA@ DB 'endswith', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KPNAMAEI@decode?$AA@
CONST	SEGMENT
??_C@_06KPNAMAEI@decode?$AA@ DB 'decode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEHLAELG@clear?$AA@
CONST	SEGMENT
??_C@_05MEHLAELG@clear?$AA@ DB 'clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BBLOAEEI@center?$AA@
CONST	SEGMENT
??_C@_06BBLOAEEI@center?$AA@ DB 'center', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMODNBEH@capitalize?$AA@
CONST	SEGMENT
??_C@_0L@NMODNBEH@capitalize?$AA@ DB 'capitalize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCICMFGG@append?$AA@
CONST	SEGMENT
??_C@_06PCICMFGG@append?$AA@ DB 'append', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
CONST	SEGMENT
??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@ DB '__reduce_ex__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LONCBNBJ@__alloc__?$AA@
CONST	SEGMENT
??_C@_09LONCBNBJ@__alloc__?$AA@ DB '__alloc__', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___dict__@?1??_common_reduce@@9@9 DQ 0000000000000000H ; `_common_reduce'::`2'::PyId___dict__
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMIAAFLA@keepends?$AA@
CONST	SEGMENT
??_C@_08EMIAAFLA@keepends?$AA@ DB 'keepends', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HONNCIIN@maxsplit?$AA@
CONST	SEGMENT
??_C@_08HONNCIIN@maxsplit?$AA@ DB 'maxsplit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGBCFPKM@sep?$AA@
CONST	SEGMENT
??_C@_03MGBCFPKM@sep?$AA@ DB 'sep', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?kwlist@?1??bytearray_init@@9@9 DQ FLAT:??_C@_06OEKOLKIL@source?$AA@ ; `bytearray_init'::`2'::kwlist
	DQ	FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
expandtabs__doc__ DB 'B.expandtabs([tabsize]) -> copy of B', 0aH, 0aH, 'R'
	DB	'eturn a copy of B where all tab characters are expanded using'
	DB	' spaces.', 0aH, 'If tabsize is not given, a tab size of 8 cha'
	DB	'racters is assumed.', 00H
	ORG $+3
ljust__doc__ DB	'B.ljust(width[, fillchar]) -> copy of B', 0aH, 0aH, 'Ret'
	DB	'urn B left justified in a string of length width. Padding is', 0aH
	DB	'done using the specified fill character (default is a space).'
	DB	00H
	ORG $+9
rjust__doc__ DB	'B.rjust(width[, fillchar]) -> copy of B', 0aH, 0aH, 'Ret'
	DB	'urn B right justified in a string of length width. Padding is'
	DB	0aH, 'done using the specified fill character (default is a sp'
	DB	'ace)', 00H
	ORG $+9
center__doc__ DB 'B.center(width[, fillchar]) -> copy of B', 0aH, 0aH, 'R'
	DB	'eturn B centered in a string of length width.  Padding is', 0aH
	DB	'done using the specified fill character (default is a space).'
	DB	00H
	ORG $+13
zfill__doc__ DB	'B.zfill(width) -> copy of B', 0aH, 0aH, 'Pad a numeric s'
	DB	'tring B with zeros on the left, to fill a field', 0aH, 'of th'
	DB	'e specified width.  B is never truncated.', 00H
	ORG $+5
find__doc__ DB	'B.find(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return t'
	DB	'he lowest index in B where subsection sub is found,', 0aH, 's'
	DB	'uch that sub is contained within B[start,end].  Optional', 0aH
	DB	'arguments start and end are interpreted as in slice notation.'
	DB	0aH, 0aH, 'Return -1 on failure.', 00H
	ORG $+1
count__doc__ DB	'B.count(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return '
	DB	'the number of non-overlapping occurrences of subsection sub i'
	DB	'n', 0aH, 'bytes B[start:end].  Optional arguments start and e'
	DB	'nd are interpreted', 0aH, 'as in slice notation.', 00H
	ORG $+1
clear__doc__ DB	'B.clear() -> None', 0aH, 0aH, 'Remove all items from B.', 00H
	ORG $+4
copy__doc__ DB	'B.copy() -> bytearray', 0aH, 0aH, 'Return a copy of B.', 00H
	ORG $+13
index__doc__ DB	'B.index(sub[, start[, end]]) -> int', 0aH, 0aH, 'Like B.'
	DB	'find() but raise ValueError when the subsection is not found.'
	DB	00H
	ORG $+6
rfind__doc__ DB	'B.rfind(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return '
	DB	'the highest index in B where subsection sub is found,', 0aH, 's'
	DB	'uch that sub is contained within B[start,end].  Optional', 0aH
	DB	'arguments start and end are interpreted as in slice notation.'
	DB	0aH, 0aH, 'Return -1 on failure.', 00H
	ORG $+15
rindex__doc__ DB 'B.rindex(sub[, start[, end]]) -> int', 0aH, 0aH, 'Like '
	DB	'B.rfind() but raise ValueError when the subsection is not fou'
	DB	'nd.', 00H
	ORG $+4
startswith__doc__ DB 'B.startswith(prefix[, start[, end]]) -> bool', 0aH, 0aH
	DB	'Return True if B starts with the specified prefix, False othe'
	DB	'rwise.', 0aH, 'With optional start, test B beginning at that '
	DB	'position.', 0aH, 'With optional end, stop comparing B at that'
	DB	' position.', 0aH, 'prefix can also be a tuple of bytes to try'
	DB	'.', 00H
	ORG $+4
endswith__doc__ DB 'B.endswith(suffix[, start[, end]]) -> bool', 0aH, 0aH
	DB	'Return True if B ends with the specified suffix, False otherw'
	DB	'ise.', 0aH, 'With optional start, test B beginning at that po'
	DB	'sition.', 0aH, 'With optional end, stop comparing B at that p'
	DB	'osition.', 0aH, 'suffix can also be a tuple of bytes to try.', 00H
	ORG $+8
translate__doc__ DB 'B.translate(table[, deletechars]) -> bytearray', 0aH
	DB	0aH, 'Return a copy of B, where all characters occurring in th'
	DB	'e', 0aH, 'optional argument deletechars are removed, and the '
	DB	'remaining', 0aH, 'characters have been mapped through the giv'
	DB	'en translation', 0aH, 'table, which must be a bytes object of'
	DB	' length 256.', 00H
	ORG $+12
replace__doc__ DB 'B.replace(old, new[, count]) -> bytearray', 0aH, 0aH, 'R'
	DB	'eturn a copy of B with all occurrences of subsection', 0aH, 'o'
	DB	'ld replaced by new.  If the optional argument count is', 0aH, 'g'
	DB	'iven, only the first count occurrences are replaced.', 00H
	ORG $+1
split__doc__ DB	'B.split(sep=None, maxsplit=-1) -> list of bytearrays', 0aH
	DB	0aH, 'Return a list of the sections in B, using sep as the del'
	DB	'imiter.', 0aH, 'If sep is not given, B is split on ASCII whit'
	DB	'espace characters', 0aH, '(space, tab, return, newline, formf'
	DB	'eed, vertical tab).', 0aH, 'If maxsplit is given, at most max'
	DB	'split splits are done.', 00H
	ORG $+4
?kwlist@?1??bytearray_split@@9@9 DQ FLAT:??_C@_03MGBCFPKM@sep?$AA@ ; `bytearray_split'::`2'::kwlist
	DQ	FLAT:??_C@_08HONNCIIN@maxsplit?$AA@
	DQ	0000000000000000H
partition__doc__ DB 'B.partition(sep) -> (head, sep, tail)', 0aH, 0aH, 'S'
	DB	'earch for the separator sep in B, and return the part before '
	DB	'it,', 0aH, 'the separator itself, and the part after it.  If '
	DB	'the separator is not', 0aH, 'found, returns B and two empty b'
	DB	'ytearray objects.', 00H
	ORG $+15
rpartition__doc__ DB 'B.rpartition(sep) -> (head, sep, tail)', 0aH, 0aH, 'S'
	DB	'earch for the separator sep in B, starting at the end of B,', 0aH
	DB	'and return the part before it, the separator itself, and the', 0aH
	DB	'part after it.  If the separator is not found, returns two em'
	DB	'pty', 0aH, 'bytearray objects and B.', 00H
	ORG $+4
rsplit__doc__ DB 'B.rsplit(sep=None, maxsplit=-1) -> list of bytearrays', 0aH
	DB	0aH, 'Return a list of the sections in B, using sep as the del'
	DB	'imiter,', 0aH, 'starting at the end of B and working to the f'
	DB	'ront.', 0aH, 'If sep is not given, B is split on ASCII whites'
	DB	'pace characters', 0aH, '(space, tab, return, newline, formfee'
	DB	'd, vertical tab).', 0aH, 'If maxsplit is given, at most maxsp'
	DB	'lit splits are done.', 00H
?kwlist@?1??bytearray_rsplit@@9@9 DQ FLAT:??_C@_03MGBCFPKM@sep?$AA@ ; `bytearray_rsplit'::`2'::kwlist
	DQ	FLAT:??_C@_08HONNCIIN@maxsplit?$AA@
	DQ	0000000000000000H
reverse__doc__ DB 'B.reverse() -> None', 0aH, 0aH, 'Reverse the order of '
	DB	'the values in B in place.', 00H
	ORG $+12
insert__doc__ DB 'B.insert(index, int) -> None', 0aH, 0aH, 'Insert a sing'
	DB	'le item into the bytearray before the given index.', 00H
	ORG $+2
append__doc__ DB 'B.append(int) -> None', 0aH, 0aH, 'Append a single item'
	DB	' to the end of B.', 00H
	ORG $+3
extend__doc__ DB 'B.extend(iterable_of_ints) -> None', 0aH, 0aH, 'Append '
	DB	'all the elements from the iterator or sequence to the', 0aH, 'e'
	DB	'nd of B.', 00H
	ORG $+5
pop__doc__ DB	'B.pop([index]) -> int', 0aH, 0aH, 'Remove and return a s'
	DB	'ingle item from B. If no index', 0aH, 'argument is given, wil'
	DB	'l pop the last value.', 00H
	ORG $+9
remove__doc__ DB 'B.remove(int) -> None', 0aH, 0aH, 'Remove the first occ'
	DB	'urrence of a value in B.', 00H
	ORG $+12
strip__doc__ DB	'B.strip([bytes]) -> bytearray', 0aH, 0aH, 'Strip leading'
	DB	' and trailing bytes contained in the argument', 0aH, 'and ret'
	DB	'urn the result as a new bytearray.', 0aH, 'If the argument is'
	DB	' omitted, strip ASCII whitespace.', 00H
	ORG $+8
lstrip__doc__ DB 'B.lstrip([bytes]) -> bytearray', 0aH, 0aH, 'Strip leadi'
	DB	'ng bytes contained in the argument', 0aH, 'and return the res'
	DB	'ult as a new bytearray.', 0aH, 'If the argument is omitted, s'
	DB	'trip leading ASCII whitespace.', 00H
	ORG $+12
rstrip__doc__ DB 'B.rstrip([bytes]) -> bytearray', 0aH, 0aH, 'Strip trail'
	DB	'ing bytes contained in the argument', 0aH, 'and return the re'
	DB	'sult as a new bytearray.', 0aH, 'If the argument is omitted, '
	DB	'strip trailing ASCII whitespace.', 00H
	ORG $+10
decode_doc DB	'B.decode(encoding=''utf-8'', errors=''strict'') -> str', 0aH
	DB	0aH, 'Decode B using the codec registered for encoding. Defaul'
	DB	't encoding', 0aH, 'is ''utf-8''. errors may be given to set a'
	DB	' different error', 0aH, 'handling scheme.  Default is ''stric'
	DB	't'' meaning that encoding errors raise', 0aH, 'a UnicodeDecod'
	DB	'eError.  Other possible values are ''ignore'' and ''replace'''
	DB	0aH, 'as well as any other name registered with codecs.registe'
	DB	'r_error that is', 0aH, 'able to handle UnicodeDecodeErrors.', 00H
	ORG $+3
?kwlist@?1??bytearray_decode@@9@9 DQ FLAT:??_C@_08MLPGAEIK@encoding?$AA@ ; `bytearray_decode'::`2'::kwlist
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
	ORG $+8
alloc_doc DB	'B.__alloc__() -> int', 0aH, 0aH, 'Return the number of b'
	DB	'ytes actually allocated.', 00H
	ORG $+11
join_doc DB	'B.join(iterable_of_bytes) -> bytearray', 0aH, 0aH, 'Conc'
	DB	'atenate any number of bytes/bytearray objects, with B', 0aH, 'i'
	DB	'n between each pair, and return the result as a new bytearray'
	DB	'.', 00H
	ORG $+14
splitlines__doc__ DB 'B.splitlines([keepends]) -> list of lines', 0aH, 0aH
	DB	'Return a list of the lines in B, breaking at line boundaries.'
	DB	0aH, 'Line breaks are not included in the resulting list unles'
	DB	's keepends', 0aH, 'is given and true.', 00H
	ORG $+1
?kwlist@?1??bytearray_splitlines@@9@9 DQ FLAT:??_C@_08EMIAAFLA@keepends?$AA@ ; `bytearray_splitlines'::`2'::kwlist
	DQ	0000000000000000H
fromhex_doc DB	'bytearray.fromhex(string) -> bytearray (static method)', 0aH
	DB	0aH, 'Create a bytearray object from a string of hexadecimal n'
	DB	'umbers.', 0aH, 'Spaces between two numbers are accepted.', 0aH
	DB	'Example: bytearray.fromhex(''B9 01EF'') -> bytearray(b''\xb9\'
	DB	'x01\xef'').', 00H
	ORG $+2
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+1
reduce_ex_doc DB 'Return state information for pickling.', 00H
	ORG $+9
sizeof_doc DB	'B.__sizeof__() -> int', 0aH, ' ', 0aH, 'Returns the size'
	DB	' of B in memory, in bytes', 00H
	ORG $+14
bytearray_as_sequence DQ FLAT:bytearray_length
	DQ	FLAT:PyByteArray_Concat
	DQ	FLAT:bytearray_repeat
	DQ	FLAT:bytearray_getitem
	DQ	0000000000000000H
	DQ	FLAT:bytearray_setitem
	DQ	0000000000000000H
	DQ	FLAT:bytearray_contains
	DQ	FLAT:bytearray_iconcat
	DQ	FLAT:bytearray_irepeat
bytearray_as_mapping DQ FLAT:bytearray_length
	DQ	FLAT:bytearray_subscript
	DQ	FLAT:bytearray_ass_subscript
bytearray_as_buffer DQ FLAT:bytearray_getbuffer
	DQ	FLAT:bytearray_releasebuffer
	ORG $+8
bytearray_methods DQ FLAT:??_C@_09LONCBNBJ@__alloc__?$AA@
	DQ	FLAT:bytearray_alloc
	DD	04H
	ORG $+4
	DQ	FLAT:alloc_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:bytearray_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
	DQ	FLAT:bytearray_reduce_ex
	DD	01H
	ORG $+4
	DQ	FLAT:reduce_ex_doc
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:bytearray_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof_doc
	DQ	FLAT:??_C@_06PCICMFGG@append?$AA@
	DQ	FLAT:bytearray_append
	DD	08H
	ORG $+4
	DQ	FLAT:append__doc__
	DQ	FLAT:??_C@_0L@NMODNBEH@capitalize?$AA@
	DQ	FLAT:stringlib_capitalize
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_capitalize__doc__
	DQ	FLAT:??_C@_06BBLOAEEI@center?$AA@
	DQ	FLAT:stringlib_center
	DD	01H
	ORG $+4
	DQ	FLAT:center__doc__
	DQ	FLAT:??_C@_05MEHLAELG@clear?$AA@
	DQ	FLAT:bytearray_clear
	DD	04H
	ORG $+4
	DQ	FLAT:clear__doc__
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:bytearray_copy
	DD	04H
	ORG $+4
	DQ	FLAT:copy__doc__
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	FLAT:bytearray_count
	DD	01H
	ORG $+4
	DQ	FLAT:count__doc__
	DQ	FLAT:??_C@_06KPNAMAEI@decode?$AA@
	DQ	FLAT:bytearray_decode
	DD	03H
	ORG $+4
	DQ	FLAT:decode_doc
	DQ	FLAT:??_C@_08MLCMCPNP@endswith?$AA@
	DQ	FLAT:bytearray_endswith
	DD	01H
	ORG $+4
	DQ	FLAT:endswith__doc__
	DQ	FLAT:??_C@_0L@DEOCELBD@expandtabs?$AA@
	DQ	FLAT:stringlib_expandtabs
	DD	01H
	ORG $+4
	DQ	FLAT:expandtabs__doc__
	DQ	FLAT:??_C@_06BPBOMFNI@extend?$AA@
	DQ	FLAT:bytearray_extend
	DD	08H
	ORG $+4
	DQ	FLAT:extend__doc__
	DQ	FLAT:??_C@_04CKFJHKAP@find?$AA@
	DQ	FLAT:bytearray_find
	DD	01H
	ORG $+4
	DQ	FLAT:find__doc__
	DQ	FLAT:??_C@_07DIMGGDAC@fromhex?$AA@
	DQ	FLAT:bytearray_fromhex
	DD	011H
	ORG $+4
	DQ	FLAT:fromhex_doc
	DQ	FLAT:??_C@_05FKHKFDID@index?$AA@
	DQ	FLAT:bytearray_index
	DD	01H
	ORG $+4
	DQ	FLAT:index__doc__
	DQ	FLAT:??_C@_06OAOPNKHP@insert?$AA@
	DQ	FLAT:bytearray_insert
	DD	01H
	ORG $+4
	DQ	FLAT:insert__doc__
	DQ	FLAT:??_C@_07EOADCIGC@isalnum?$AA@
	DQ	FLAT:stringlib_isalnum
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isalnum__doc__
	DQ	FLAT:??_C@_07EGIOHHOB@isalpha?$AA@
	DQ	FLAT:stringlib_isalpha
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isalpha__doc__
	DQ	FLAT:??_C@_07CFBKIKCH@isdigit?$AA@
	DQ	FLAT:stringlib_isdigit
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isdigit__doc__
	DQ	FLAT:??_C@_07EJFAPEJH@islower?$AA@
	DQ	FLAT:stringlib_islower
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_islower__doc__
	DQ	FLAT:??_C@_07CNBMLEON@isspace?$AA@
	DQ	FLAT:stringlib_isspace
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isspace__doc__
	DQ	FLAT:??_C@_07DBHCJBDG@istitle?$AA@
	DQ	FLAT:stringlib_istitle
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_istitle__doc__
	DQ	FLAT:??_C@_07BCOOJPCO@isupper?$AA@
	DQ	FLAT:stringlib_isupper
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isupper__doc__
	DQ	FLAT:??_C@_04DFGCDGNN@join?$AA@
	DQ	FLAT:bytearray_join
	DD	08H
	ORG $+4
	DQ	FLAT:join_doc
	DQ	FLAT:??_C@_05KDIMMEME@ljust?$AA@
	DQ	FLAT:stringlib_ljust
	DD	01H
	ORG $+4
	DQ	FLAT:ljust__doc__
	DQ	FLAT:??_C@_05IPJEPLHL@lower?$AA@
	DQ	FLAT:stringlib_lower
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_lower__doc__
	DQ	FLAT:??_C@_06GGONODO@lstrip?$AA@
	DQ	FLAT:bytearray_lstrip
	DD	01H
	ORG $+4
	DQ	FLAT:lstrip__doc__
	DQ	FLAT:??_C@_09PBBLPCAA@maketrans?$AA@
	DQ	FLAT:bytearray_maketrans
	DD	021H
	ORG $+4
	DQ	FLAT:_Py_maketrans__doc__
	DQ	FLAT:??_C@_09IKAEIPAD@partition?$AA@
	DQ	FLAT:bytearray_partition
	DD	08H
	ORG $+4
	DQ	FLAT:partition__doc__
	DQ	FLAT:??_C@_03NJDAHFJE@pop?$AA@
	DQ	FLAT:bytearray_pop
	DD	01H
	ORG $+4
	DQ	FLAT:pop__doc__
	DQ	FLAT:??_C@_06LEMKAMD@remove?$AA@
	DQ	FLAT:bytearray_remove
	DD	08H
	ORG $+4
	DQ	FLAT:remove__doc__
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:bytearray_replace
	DD	01H
	ORG $+4
	DQ	FLAT:replace__doc__
	DQ	FLAT:??_C@_07KOIEOCCE@reverse?$AA@
	DQ	FLAT:bytearray_reverse
	DD	04H
	ORG $+4
	DQ	FLAT:reverse__doc__
	DQ	FLAT:??_C@_05BLFDIAHL@rfind?$AA@
	DQ	FLAT:bytearray_rfind
	DD	01H
	ORG $+4
	DQ	FLAT:rfind__doc__
	DQ	FLAT:??_C@_06NCDOMFM@rindex?$AA@
	DQ	FLAT:bytearray_rindex
	DD	01H
	ORG $+4
	DQ	FLAT:rindex__doc__
	DQ	FLAT:??_C@_05JKFAKHCP@rjust?$AA@
	DQ	FLAT:stringlib_rjust
	DD	01H
	ORG $+4
	DQ	FLAT:rjust__doc__
	DQ	FLAT:??_C@_0L@KEEHLNKL@rpartition?$AA@
	DQ	FLAT:bytearray_rpartition
	DD	08H
	ORG $+4
	DQ	FLAT:rpartition__doc__
	DQ	FLAT:??_C@_06BAKFHKMF@rsplit?$AA@
	DQ	FLAT:bytearray_rsplit
	DD	03H
	ORG $+4
	DQ	FLAT:rsplit__doc__
	DQ	FLAT:??_C@_06DBIPDJKN@rstrip?$AA@
	DQ	FLAT:bytearray_rstrip
	DD	01H
	ORG $+4
	DQ	FLAT:rstrip__doc__
	DQ	FLAT:??_C@_05EHPMMFBK@split?$AA@
	DQ	FLAT:bytearray_split
	DD	03H
	ORG $+4
	DQ	FLAT:split__doc__
	DQ	FLAT:??_C@_0L@BCMGLLLC@splitlines?$AA@
	DQ	FLAT:bytearray_splitlines
	DD	03H
	ORG $+4
	DQ	FLAT:splitlines__doc__
	DQ	FLAT:??_C@_0L@MPOGHCCL@startswith?$AA@
	DQ	FLAT:bytearray_startswith
	DD	01H
	ORG $+4
	DQ	FLAT:startswith__doc__
	DQ	FLAT:??_C@_05GGNGIGHC@strip?$AA@
	DQ	FLAT:bytearray_strip
	DD	01H
	ORG $+4
	DQ	FLAT:strip__doc__
	DQ	FLAT:??_C@_08EDJLBCEI@swapcase?$AA@
	DQ	FLAT:stringlib_swapcase
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_swapcase__doc__
	DQ	FLAT:??_C@_05PHLGJONK@title?$AA@
	DQ	FLAT:stringlib_title
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_title__doc__
	DQ	FLAT:??_C@_09ODNGOEIO@translate?$AA@
	DQ	FLAT:bytearray_translate
	DD	01H
	ORG $+4
	DQ	FLAT:translate__doc__
	DQ	FLAT:??_C@_05NECKJAMC@upper?$AA@
	DQ	FLAT:stringlib_upper
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_upper__doc__
	DQ	FLAT:??_C@_05DMFNFMHA@zfill?$AA@
	DQ	FLAT:stringlib_zfill
	DD	01H
	ORG $+4
	DQ	FLAT:zfill__doc__
	DQ	0000000000000000H
	ORG $+24
bytearray_doc DB 'bytearray(iterable_of_ints) -> bytearray', 0aH, 'bytear'
	DB	'ray(string, encoding[, errors]) -> bytearray', 0aH, 'bytearra'
	DB	'y(bytes_or_buffer) -> mutable copy of bytes_or_buffer', 0aH, 'b'
	DB	'ytearray(int) -> bytes array of size given by the parameter i'
	DB	'nitialized with null bytes', 0aH, 'bytearray() -> empty bytes'
	DB	' array', 0aH, 0aH, 'Construct an mutable bytearray object fro'
	DB	'm:', 0aH, '  - an iterable yielding integers in range(256)', 0aH
	DB	'  - a text string encoded using the specified encoding', 0aH, ' '
	DB	' - a bytes or a buffer object', 0aH, '  - any object implemen'
	DB	'ting the buffer API.', 0aH, '  - an integer', 00H
	ORG $+14
PyByteArray_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_09FCJHKOIN@bytearray?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:bytearray_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytearray_repr
	DQ	0000000000000000H
	DQ	FLAT:bytearray_as_sequence
	DQ	FLAT:bytearray_as_mapping
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytearray_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	FLAT:bytearray_as_buffer
	DD	040400H
	ORG $+4
	DQ	FLAT:bytearray_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytearray_richcompare
	DQ	0000000000000000H
	DQ	FLAT:bytearray_iter
	DQ	0000000000000000H
	DQ	FLAT:bytearray_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytearray_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:PyType_GenericNew
	DQ	FLAT:_PyObject_DebugFree
	ORG $+64
length_hint_doc DB 'Private method returning an estimate of len(list(it))'
	DB	'.', 00H
	ORG $+1
setstate_doc DB	'Set state information for unpickling.', 00H
	ORG $+2
bytearrayiter_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:bytearrayiter_length_hint
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:bytearrayiter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:bytearrayiter_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyByteArrayIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BD@FCNILHGP@bytearray_iterator?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:bytearrayiter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:bytearrayiter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:bytearrayiter_next
	DQ	FLAT:bytearrayiter_methods
	DQ	0000000000000000H
	ORG $+144
_DATA	ENDS
;	COMDAT ??_C@_06EOMHCNPI@errors?$AA@
CONST	SEGMENT
??_C@_06EOMHCNPI@errors?$AA@ DB 'errors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPGAEIK@encoding?$AA@
CONST	SEGMENT
??_C@_08MLPGAEIK@encoding?$AA@ DB 'encoding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OEKOLKIL@source?$AA@
CONST	SEGMENT
??_C@_06OEKOLKIL@source?$AA@ DB 'source', 00H		; `string'
CONST	ENDS
PUBLIC	PyByteArray_Fini
; Function compile flags: /Odtp
; File c:\src\pyparallel\objects\bytearrayobject.c
;	COMDAT PyByteArray_Fini
_TEXT	SEGMENT
PyByteArray_Fini PROC					; COMDAT

; 13   : }

  00000	c3		 ret	 0
PyByteArray_Fini ENDP
_TEXT	ENDS
PUBLIC	PyByteArray_Init
; Function compile flags: /Odtp
;	COMDAT PyByteArray_Init
_TEXT	SEGMENT
PyByteArray_Init PROC					; COMDAT

; 18   :     return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 19   : }

  00005	c3		 ret	 0
PyByteArray_Init ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CO@PHBFBFIE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	PyBuffer_FillInfo:PROC
EXTRN	__imp__wassert:PROC
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_getbuffer DD imagerel bytearray_getbuffer
	DD	imagerel bytearray_getbuffer+259
	DD	imagerel $unwind$bytearray_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_getbuffer DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_1CO@PHBFBFIE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@PHBFBFIE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'b', 00H, 'y', 00H, 't'
	DB	00H, 'e', 00H, 'a', 00H, 'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H
	DB	'o', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, '.'
	DB	00H, 'c', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_getbuffer
_TEXT	SEGMENT
ptr$ = 48
ret$ = 56
tv83 = 64
obj$ = 96
view$ = 104
flags$ = 112
bytearray_getbuffer PROC				; COMDAT

; 56   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 57   :     int ret;
; 58   :     void *ptr;
; 59   :     if (view == NULL) {

  00013	48 83 7c 24 68
	00		 cmp	 QWORD PTR view$[rsp], 0
  00019	75 19		 jne	 SHORT $LN2@bytearray_

; 60   :         obj->ob_exports++;

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$[rsp]
  00020	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00023	ff c0		 inc	 eax
  00025	48 8b 4c 24 60	 mov	 rcx, QWORD PTR obj$[rsp]
  0002a	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 61   :         return 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 ca 00 00 00	 jmp	 $LN3@bytearray_
$LN2@bytearray_:

; 62   :     }
; 63   :     ptr = (void *) PyByteArray_AS_STRING(obj);

  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0003b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR obj$[rsp]
  00040	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00044	74 35		 je	 SHORT $LN5@bytearray_
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0004d	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$[rsp]
  00052	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00056	e8 00 00 00 00	 call	 PyType_IsSubtype
  0005b	85 c0		 test	 eax, eax
  0005d	75 1c		 jne	 SHORT $LN5@bytearray_
  0005f	41 b8 3f 00 00
	00		 mov	 r8d, 63			; 0000003fH
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@PHBFBFIE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00079	33 c0		 xor	 eax, eax
$LN5@bytearray_:
  0007b	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$[rsp]
  00080	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00085	74 13		 je	 SHORT $LN6@bytearray_
  00087	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$[rsp]
  0008c	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00093	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00098	eb 0c		 jmp	 SHORT $LN7@bytearray_
$LN6@bytearray_:
  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000a1	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
$LN7@bytearray_:
  000a6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000ab	48 89 44 24 30	 mov	 QWORD PTR ptr$[rsp], rax

; 64   :     ret = PyBuffer_FillInfo(view, (PyObject*)obj, ptr, Py_SIZE(obj), 0, flags);

  000b0	8b 44 24 70	 mov	 eax, DWORD PTR flags$[rsp]
  000b4	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000b8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  000c0	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$[rsp]
  000c5	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  000c9	4c 8b 44 24 30	 mov	 r8, QWORD PTR ptr$[rsp]
  000ce	48 8b 54 24 60	 mov	 rdx, QWORD PTR obj$[rsp]
  000d3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR view$[rsp]
  000d8	e8 00 00 00 00	 call	 PyBuffer_FillInfo
  000dd	89 44 24 38	 mov	 DWORD PTR ret$[rsp], eax

; 65   :     if (ret >= 0) {

  000e1	83 7c 24 38 00	 cmp	 DWORD PTR ret$[rsp], 0
  000e6	7c 12		 jl	 SHORT $LN1@bytearray_

; 66   :         obj->ob_exports++;

  000e8	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$[rsp]
  000ed	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000f0	ff c0		 inc	 eax
  000f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR obj$[rsp]
  000f7	89 41 70	 mov	 DWORD PTR [rcx+112], eax
$LN1@bytearray_:

; 67   :     }
; 68   :     return ret;

  000fa	8b 44 24 38	 mov	 eax, DWORD PTR ret$[rsp]
$LN3@bytearray_:

; 69   : }

  000fe	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00102	c3		 ret	 0
bytearray_getbuffer ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT bytearray_releasebuffer
_TEXT	SEGMENT
obj$ = 8
view$ = 16
bytearray_releasebuffer PROC				; COMDAT

; 73   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 74   :     obj->ob_exports--;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR obj$[rsp]
  0000f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00012	ff c8		 dec	 eax
  00014	48 8b 4c 24 08	 mov	 rcx, QWORD PTR obj$[rsp]
  00019	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 75   : }

  0001c	c3		 ret	 0
bytearray_releasebuffer ENDP
_TEXT	ENDS
PUBLIC	PyByteArray_FromObject
EXTRN	PyObject_CallFunctionObjArgs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyByteArray_FromObject DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$PyByteArray_FromObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyByteArray_FromObject DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyByteArray_FromObject
_TEXT	SEGMENT
input$ = 48
PyByteArray_FromObject PROC				; COMDAT

; 110  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 111  :     return PyObject_CallFunctionObjArgs((PyObject *)&PyByteArray_Type,
; 112  :                                         input, NULL);

  00009	45 33 c0	 xor	 r8d, r8d
  0000c	48 8b 54 24 30	 mov	 rdx, QWORD PTR input$[rsp]
  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArray_Type
  00018	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 113  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
PyByteArray_FromObject ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0DG@DPPIIPAI@Negative?5size?5passed?5to?5PyByteAr@ ; `string'
PUBLIC	PyByteArray_FromStringAndSize
EXTRN	memcpy:PROC
EXTRN	_PyObject_DebugMalloc:PROC
EXTRN	_PyObject_New:PROC
EXTRN	_PxObject_New:PROC
EXTRN	_Py_PXCTX:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyByteArray_FromStringAndSize DD imagerel $LN12
	DD	imagerel $LN12+364
	DD	imagerel $unwind$PyByteArray_FromStringAndSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyByteArray_FromStringAndSize DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0DG@DPPIIPAI@Negative?5size?5passed?5to?5PyByteAr@
CONST	SEGMENT
??_C@_0DG@DPPIIPAI@Negative?5size?5passed?5to?5PyByteAr@ DB 'Negative siz'
	DB	'e passed to PyByteArray_FromStringAndSize', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyByteArray_FromStringAndSize
_TEXT	SEGMENT
alloc$ = 32
new$ = 40
tv75 = 48
bytes$ = 80
size$ = 88
PyByteArray_FromStringAndSize PROC			; COMDAT

; 117  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 118  :     PyByteArrayObject *new;
; 119  :     Py_ssize_t alloc;
; 120  : 
; 121  :     if (size < 0) {

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR size$[rsp], 0
  00014	7d 1a		 jge	 SHORT $LN7@PyByteArra

; 122  :         PyErr_SetString(PyExc_SystemError,
; 123  :             "Negative size passed to PyByteArray_FromStringAndSize");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@DPPIIPAI@Negative?5size?5passed?5to?5PyByteAr@
  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00024	e8 00 00 00 00	 call	 PyErr_SetString

; 124  :         return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	e9 37 01 00 00	 jmp	 $LN8@PyByteArra
$LN7@PyByteArra:

; 125  :     }
; 126  : 
; 127  :     /* Prevent buffer overflow when setting alloc to size+1. */
; 128  :     if (size == PY_SSIZE_T_MAX) {

  00030	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0003a	48 39 44 24 58	 cmp	 QWORD PTR size$[rsp], rax
  0003f	75 0a		 jne	 SHORT $LN6@PyByteArra

; 129  :         return PyErr_NoMemory();

  00041	e8 00 00 00 00	 call	 PyErr_NoMemory
  00046	e9 1c 01 00 00	 jmp	 $LN8@PyByteArra
$LN6@PyByteArra:

; 130  :     }
; 131  : 
; 132  :     new = PyObject_New(PyByteArrayObject, &PyByteArray_Type);

  0004b	e8 00 00 00 00	 call	 _Py_PXCTX
  00050	85 c0		 test	 eax, eax
  00052	74 13		 je	 SHORT $LN10@PyByteArra
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArray_Type
  0005b	e8 00 00 00 00	 call	 _PxObject_New
  00060	48 89 44 24 30	 mov	 QWORD PTR tv75[rsp], rax
  00065	eb 11		 jmp	 SHORT $LN11@PyByteArra
$LN10@PyByteArra:
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArray_Type
  0006e	e8 00 00 00 00	 call	 _PyObject_New
  00073	48 89 44 24 30	 mov	 QWORD PTR tv75[rsp], rax
$LN11@PyByteArra:
  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR tv75[rsp]
  0007d	48 89 44 24 28	 mov	 QWORD PTR new$[rsp], rax

; 133  :     if (new == NULL)

  00082	48 83 7c 24 28
	00		 cmp	 QWORD PTR new$[rsp], 0
  00088	75 07		 jne	 SHORT $LN5@PyByteArra

; 134  :         return NULL;

  0008a	33 c0		 xor	 eax, eax
  0008c	e9 d6 00 00 00	 jmp	 $LN8@PyByteArra
$LN5@PyByteArra:

; 135  : 
; 136  :     if (size == 0) {

  00091	48 83 7c 24 58
	00		 cmp	 QWORD PTR size$[rsp], 0
  00097	75 1e		 jne	 SHORT $LN4@PyByteArra

; 137  :         new->ob_bytes = NULL;

  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  0009e	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 138  :         alloc = 0;

  000a9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR alloc$[rsp], 0

; 139  :     }
; 140  :     else {

  000b2	e9 83 00 00 00	 jmp	 $LN3@PyByteArra
$LN4@PyByteArra:

; 141  :         alloc = size + 1;

  000b7	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  000bc	48 ff c0	 inc	 rax
  000bf	48 89 44 24 20	 mov	 QWORD PTR alloc$[rsp], rax

; 142  :         new->ob_bytes = PyObject_Malloc(alloc);

  000c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR alloc$[rsp]
  000c9	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  000ce	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new$[rsp]
  000d3	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 143  :         if (new->ob_bytes == NULL) {

  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  000df	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000e7	75 11		 jne	 SHORT $LN2@PyByteArra

; 144  :             Py_DECREF(new);

  000e9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new$[rsp]
  000ee	e8 00 00 00 00	 call	 _Py_DecRef

; 145  :             return PyErr_NoMemory();

  000f3	e8 00 00 00 00	 call	 PyErr_NoMemory
  000f8	eb 6d		 jmp	 SHORT $LN8@PyByteArra
$LN2@PyByteArra:

; 146  :         }
; 147  :         if (bytes != NULL && size > 0)

  000fa	48 83 7c 24 50
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  00100	74 23		 je	 SHORT $LN1@PyByteArra
  00102	48 83 7c 24 58
	00		 cmp	 QWORD PTR size$[rsp], 0
  00108	7e 1b		 jle	 SHORT $LN1@PyByteArra

; 148  :             memcpy(new->ob_bytes, bytes, size);

  0010a	4c 8b 44 24 58	 mov	 r8, QWORD PTR size$[rsp]
  0010f	48 8b 54 24 50	 mov	 rdx, QWORD PTR bytes$[rsp]
  00114	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  00119	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00120	e8 00 00 00 00	 call	 memcpy
$LN1@PyByteArra:

; 149  :         new->ob_bytes[size] = '\0';  /* Trailing null byte */

  00125	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  0012a	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00131	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  00136	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN3@PyByteArra:

; 150  :     }
; 151  :     Py_SIZE(new) = size;

  0013a	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  0013f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  00144	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 152  :     new->ob_alloc = alloc;

  00148	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  0014d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR alloc$[rsp]
  00152	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 153  :     new->ob_exports = 0;

  00156	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
  0015b	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 154  : 
; 155  :     return (PyObject *)new;

  00162	48 8b 44 24 28	 mov	 rax, QWORD PTR new$[rsp]
$LN8@PyByteArra:

; 156  : }

  00167	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0016b	c3		 ret	 0
PyByteArray_FromStringAndSize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@KLMFOMEM@?$AAs?$AAe?$AAl?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	PyByteArray_Size
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytearrayobject.c
pdata	SEGMENT
$pdata$PyByteArray_Size DD imagerel $LN6
	DD	imagerel $LN6+201
	DD	imagerel $unwind$PyByteArray_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyByteArray_Size DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 's', 00H, 'e', 00H
	DB	'l', 00H, 'f', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@KLMFOMEM@?$AAs?$AAe?$AAl?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@KLMFOMEM@?$AAs?$AAe?$AAl?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyByteArray_Size
_TEXT	SEGMENT
self$ = 48
PyByteArray_Size PROC					; COMDAT

; 160  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 161  :     assert(self != NULL);

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR self$[rsp], 0
  0000f	75 1c		 jne	 SHORT $LN3@PyByteArra@2
  00011	41 b8 a1 00 00
	00		 mov	 r8d, 161		; 000000a1H
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@KLMFOMEM@?$AAs?$AAe?$AAl?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002b	33 c0		 xor	 eax, eax
$LN3@PyByteArra@2:

; 162  :     assert(PyByteArray_Check(self));

  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00039	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003d	74 35		 je	 SHORT $LN4@PyByteArra@2
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0004b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00054	85 c0		 test	 eax, eax
  00056	75 1c		 jne	 SHORT $LN4@PyByteArra@2
  00058	41 b8 a2 00 00
	00		 mov	 r8d, 162		; 000000a2H
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00072	33 c0		 xor	 eax, eax
$LN4@PyByteArra@2:

; 163  : 
; 164  :     return PyByteArray_GET_SIZE(self);

  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0007b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00080	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00084	74 35		 je	 SHORT $LN5@PyByteArra@2
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00092	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00096	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009b	85 c0		 test	 eax, eax
  0009d	75 1c		 jne	 SHORT $LN5@PyByteArra@2
  0009f	41 b8 a4 00 00
	00		 mov	 r8d, 164		; 000000a4H
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b9	33 c0		 xor	 eax, eax
$LN5@PyByteArra@2:
  000bb	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000c0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]

; 165  : }

  000c4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c8	c3		 ret	 0
PyByteArray_Size ENDP
_TEXT	ENDS
PUBLIC	PyByteArray_AsString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyByteArray_AsString DD imagerel $LN8
	DD	imagerel $LN8+240
	DD	imagerel $unwind$PyByteArray_AsString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyByteArray_AsString DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyByteArray_AsString
_TEXT	SEGMENT
tv94 = 32
self$ = 64
PyByteArray_AsString PROC				; COMDAT

; 169  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 170  :     assert(self != NULL);

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR self$[rsp], 0
  0000f	75 1c		 jne	 SHORT $LN3@PyByteArra@3
  00011	41 b8 aa 00 00
	00		 mov	 r8d, 170		; 000000aaH
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@KLMFOMEM@?$AAs?$AAe?$AAl?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002b	33 c0		 xor	 eax, eax
$LN3@PyByteArra@3:

; 171  :     assert(PyByteArray_Check(self));

  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00039	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003d	74 35		 je	 SHORT $LN4@PyByteArra@3
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00054	85 c0		 test	 eax, eax
  00056	75 1c		 jne	 SHORT $LN4@PyByteArra@3
  00058	41 b8 ab 00 00
	00		 mov	 r8d, 171		; 000000abH
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00072	33 c0		 xor	 eax, eax
$LN4@PyByteArra@3:

; 172  : 
; 173  :     return PyByteArray_AS_STRING(self);

  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0007b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00080	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00084	74 35		 je	 SHORT $LN5@PyByteArra@3
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00092	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00096	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009b	85 c0		 test	 eax, eax
  0009d	75 1c		 jne	 SHORT $LN5@PyByteArra@3
  0009f	41 b8 ad 00 00
	00		 mov	 r8d, 173		; 000000adH
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b9	33 c0		 xor	 eax, eax
$LN5@PyByteArra@3:
  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c0	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000c5	74 13		 je	 SHORT $LN6@PyByteArra@3
  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000cc	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000d3	48 89 44 24 20	 mov	 QWORD PTR tv94[rsp], rax
  000d8	eb 0c		 jmp	 SHORT $LN7@PyByteArra@3
$LN6@PyByteArra@3:
  000da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000e1	48 89 44 24 20	 mov	 QWORD PTR tv94[rsp], rax
$LN7@PyByteArra@3:
  000e6	48 8b 44 24 20	 mov	 rax, QWORD PTR tv94[rsp]

; 174  : }

  000eb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ef	c3		 ret	 0
PyByteArray_AsString ENDP
_TEXT	ENDS
PUBLIC	__real@3ff2000000000000
PUBLIC	??_C@_1BE@CLGGJIAE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	PyByteArray_Resize
EXTRN	_PyObject_DebugRealloc:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyByteArray_Resize DD imagerel $LN17
	DD	imagerel $LN17+542
	DD	imagerel $unwind$PyByteArray_Resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyByteArray_Resize DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT __real@3ff2000000000000
CONST	SEGMENT
__real@3ff2000000000000 DQ 03ff2000000000000r	; 1.125
CONST	ENDS
;	COMDAT ??_C@_1BE@CLGGJIAE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@CLGGJIAE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyByteArray_Resize
_TEXT	SEGMENT
sval$ = 32
alloc$ = 40
tv137 = 48
self$ = 80
size$ = 88
PyByteArray_Resize PROC					; COMDAT

; 178  : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 179  :     void *sval;
; 180  :     Py_ssize_t alloc = ((PyByteArrayObject *)self)->ob_alloc;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00017	48 89 44 24 28	 mov	 QWORD PTR alloc$[rsp], rax

; 181  : 
; 182  :     assert(self != NULL);

  0001c	48 83 7c 24 50
	00		 cmp	 QWORD PTR self$[rsp], 0
  00022	75 1c		 jne	 SHORT $LN12@PyByteArra@4
  00024	41 b8 b6 00 00
	00		 mov	 r8d, 182		; 000000b6H
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@KLMFOMEM@?$AAs?$AAe?$AAl?$AAf?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003e	33 c0		 xor	 eax, eax
$LN12@PyByteArra@4:

; 183  :     assert(PyByteArray_Check(self));

  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0004c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00050	74 35		 je	 SHORT $LN13@PyByteArra@4
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0005e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00062	e8 00 00 00 00	 call	 PyType_IsSubtype
  00067	85 c0		 test	 eax, eax
  00069	75 1c		 jne	 SHORT $LN13@PyByteArra@4
  0006b	41 b8 b7 00 00
	00		 mov	 r8d, 183		; 000000b7H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00085	33 c0		 xor	 eax, eax
$LN13@PyByteArra@4:

; 184  :     assert(size >= 0);

  00087	48 83 7c 24 58
	00		 cmp	 QWORD PTR size$[rsp], 0
  0008d	7d 1c		 jge	 SHORT $LN14@PyByteArra@4
  0008f	41 b8 b8 00 00
	00		 mov	 r8d, 184		; 000000b8H
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@CLGGJIAE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a9	33 c0		 xor	 eax, eax
$LN14@PyByteArra@4:

; 185  : 
; 186  :     if (size == Py_SIZE(self)) {

  000ab	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000b0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b4	48 39 44 24 58	 cmp	 QWORD PTR size$[rsp], rax
  000b9	75 07		 jne	 SHORT $LN9@PyByteArra@4

; 187  :         return 0;

  000bb	33 c0		 xor	 eax, eax
  000bd	e9 57 01 00 00	 jmp	 $LN10@PyByteArra@4
$LN9@PyByteArra@4:

; 188  :     }
; 189  :     if (!_canresize((PyByteArrayObject *)self)) {

  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000c7	e8 00 00 00 00	 call	 _canresize
  000cc	85 c0		 test	 eax, eax
  000ce	75 0a		 jne	 SHORT $LN8@PyByteArra@4

; 190  :         return -1;

  000d0	b8 ff ff ff ff	 mov	 eax, -1
  000d5	e9 3f 01 00 00	 jmp	 $LN10@PyByteArra@4
$LN8@PyByteArra@4:

; 191  :     }
; 192  : 
; 193  :     if (size < alloc / 2) {

  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR alloc$[rsp]
  000df	48 99		 cdq
  000e1	48 2b c2	 sub	 rax, rdx
  000e4	48 d1 f8	 sar	 rax, 1
  000e7	48 39 44 24 58	 cmp	 QWORD PTR size$[rsp], rax
  000ec	7d 12		 jge	 SHORT $LN7@PyByteArra@4

; 194  :         /* Major downsize; resize down to exact size */
; 195  :         alloc = size + 1;

  000ee	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  000f3	48 ff c0	 inc	 rax
  000f6	48 89 44 24 28	 mov	 QWORD PTR alloc$[rsp], rax
  000fb	e9 a6 00 00 00	 jmp	 $LN6@PyByteArra@4
$LN7@PyByteArra@4:

; 196  :     }
; 197  :     else if (size < alloc) {

  00100	48 8b 44 24 28	 mov	 rax, QWORD PTR alloc$[rsp]
  00105	48 39 44 24 58	 cmp	 QWORD PTR size$[rsp], rax
  0010a	7d 2c		 jge	 SHORT $LN5@PyByteArra@4

; 198  :         /* Within allocated size; quick exit */
; 199  :         Py_SIZE(self) = size;

  0010c	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  00116	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 200  :         ((PyByteArrayObject *)self)->ob_bytes[size] = '\0'; /* Trailing null */

  0011a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0011f	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00126	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  0012b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 201  :         return 0;

  0012f	33 c0		 xor	 eax, eax
  00131	e9 e3 00 00 00	 jmp	 $LN10@PyByteArra@4
  00136	eb 6e		 jmp	 SHORT $LN4@PyByteArra@4
$LN5@PyByteArra@4:

; 202  :     }
; 203  :     else if (size <= alloc * 1.125) {

  00138	66 0f ef c0	 pxor	 xmm0, xmm0
  0013c	f2 48 0f 2a 44
	24 58		 cvtsi2sd xmm0, QWORD PTR size$[rsp]
  00143	66 0f ef c9	 pxor	 xmm1, xmm1
  00147	f2 48 0f 2a 4c
	24 28		 cvtsi2sd xmm1, QWORD PTR alloc$[rsp]
  0014e	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3ff2000000000000
  00156	66 0f 2f c8	 comisd	 xmm1, xmm0
  0015a	72 3d		 jb	 SHORT $LN3@PyByteArra@4

; 204  :         /* Moderate upsize; overallocate similar to list_resize() */
; 205  :         alloc = size + (size >> 3) + (size < 9 ? 3 : 6);

  0015c	48 83 7c 24 58
	09		 cmp	 QWORD PTR size$[rsp], 9
  00162	7d 0a		 jge	 SHORT $LN15@PyByteArra@4
  00164	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv137[rsp], 3
  0016c	eb 08		 jmp	 SHORT $LN16@PyByteArra@4
$LN15@PyByteArra@4:
  0016e	c7 44 24 30 06
	00 00 00	 mov	 DWORD PTR tv137[rsp], 6
$LN16@PyByteArra@4:
  00176	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  0017b	48 c1 f8 03	 sar	 rax, 3
  0017f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  00184	48 03 c8	 add	 rcx, rax
  00187	48 8b c1	 mov	 rax, rcx
  0018a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR tv137[rsp]
  0018f	48 03 c1	 add	 rax, rcx
  00192	48 89 44 24 28	 mov	 QWORD PTR alloc$[rsp], rax

; 206  :     }
; 207  :     else {

  00197	eb 0d		 jmp	 SHORT $LN2@PyByteArra@4
$LN3@PyByteArra@4:

; 208  :         /* Major upsize; resize up to exact size */
; 209  :         alloc = size + 1;

  00199	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  0019e	48 ff c0	 inc	 rax
  001a1	48 89 44 24 28	 mov	 QWORD PTR alloc$[rsp], rax
$LN2@PyByteArra@4:
$LN4@PyByteArra@4:
$LN6@PyByteArra@4:

; 210  :     }
; 211  : 
; 212  :     sval = PyObject_Realloc(((PyByteArrayObject *)self)->ob_bytes, alloc);

  001a6	48 8b 54 24 28	 mov	 rdx, QWORD PTR alloc$[rsp]
  001ab	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001b0	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  001b7	e8 00 00 00 00	 call	 _PyObject_DebugRealloc
  001bc	48 89 44 24 20	 mov	 QWORD PTR sval$[rsp], rax

; 213  :     if (sval == NULL) {

  001c1	48 83 7c 24 20
	00		 cmp	 QWORD PTR sval$[rsp], 0
  001c7	75 0c		 jne	 SHORT $LN1@PyByteArra@4

; 214  :         PyErr_NoMemory();

  001c9	e8 00 00 00 00	 call	 PyErr_NoMemory

; 215  :         return -1;

  001ce	b8 ff ff ff ff	 mov	 eax, -1
  001d3	eb 44		 jmp	 SHORT $LN10@PyByteArra@4
$LN1@PyByteArra@4:

; 216  :     }
; 217  : 
; 218  :     ((PyByteArrayObject *)self)->ob_bytes = sval;

  001d5	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sval$[rsp]
  001df	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 219  :     Py_SIZE(self) = size;

  001e6	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  001f0	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 220  :     ((PyByteArrayObject *)self)->ob_alloc = alloc;

  001f4	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001f9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR alloc$[rsp]
  001fe	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 221  :     ((PyByteArrayObject *)self)->ob_bytes[size] = '\0'; /* Trailing null byte */

  00202	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00207	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0020e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  00213	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 222  : 
; 223  :     return 0;

  00217	33 c0		 xor	 eax, eax
$LN10@PyByteArra@4:

; 224  : }

  00219	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0021d	c3		 ret	 0
PyByteArray_Resize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@ ; `string'
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_canresize DD imagerel _canresize
	DD	imagerel _canresize+53
	DD	imagerel $unwind$_canresize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_canresize DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
CONST	SEGMENT
??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@ DB 'Existing ex'
	DB	'ports of data: object cannot be re-sized', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _canresize
_TEXT	SEGMENT
self$ = 48
_canresize PROC						; COMDAT

; 97   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 98   :     if (self->ob_exports > 0) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  00012	7e 17		 jle	 SHORT $LN1@canresize

; 99   :         PyErr_SetString(PyExc_BufferError,
; 100  :                 "Existing exports of data: object cannot be re-sized");

  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00022	e8 00 00 00 00	 call	 PyErr_SetString

; 101  :         return 0;

  00027	33 c0		 xor	 eax, eax
  00029	eb 05		 jmp	 SHORT $LN2@canresize
$LN1@canresize:

; 102  :     }
; 103  :     return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1
$LN2@canresize:

; 104  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
_canresize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@ ; `string'
EXTRN	PyBuffer_Release:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyByteArray_Concat DD imagerel $LN9
	DD	imagerel $LN9+339
	DD	imagerel $unwind$PyByteArray_Concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyByteArray_Concat DD 021101H
	DD	01b0111H
xdata	ENDS
;	COMDAT ??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@
CONST	SEGMENT
??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@ DB 'ca'
	DB	'n''t concat %.100s to %.100s', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyByteArray_Concat
_TEXT	SEGMENT
va$ = 32
size$ = 112
result$ = 120
vb$ = 128
a$ = 224
b$ = 232
PyByteArray_Concat PROC					; COMDAT

; 228  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 229  :     Py_ssize_t size;
; 230  :     Py_buffer va, vb;
; 231  :     PyByteArrayObject *result = NULL;

  00011	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 232  : 
; 233  :     va.len = -1;

  0001a	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR va$[rsp+16], -1

; 234  :     vb.len = -1;

  00023	48 c7 84 24 90
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR vb$[rsp+16], -1

; 235  :     if (_getbuffer(a, &va) < 0  ||
; 236  :         _getbuffer(b, &vb) < 0) {

  0002f	48 8d 54 24 20	 lea	 rdx, QWORD PTR va$[rsp]
  00034	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0003c	e8 00 00 00 00	 call	 _getbuffer
  00041	48 85 c0	 test	 rax, rax
  00044	7c 1a		 jl	 SHORT $LN5@PyByteArra@5
  00046	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR vb$[rsp]
  0004e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00056	e8 00 00 00 00	 call	 _getbuffer
  0005b	48 85 c0	 test	 rax, rax
  0005e	7d 38		 jge	 SHORT $LN6@PyByteArra@5
$LN5@PyByteArra@5:

; 237  :             PyErr_Format(PyExc_TypeError, "can't concat %.100s to %.100s",
; 238  :                          Py_TYPE(a)->tp_name, Py_TYPE(b)->tp_name);

  00060	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00068	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00074	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00078	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  0007c	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0008e	e8 00 00 00 00	 call	 PyErr_Format

; 239  :             goto done;

  00093	e9 84 00 00 00	 jmp	 $done$20600
$LN6@PyByteArra@5:

; 240  :     }
; 241  : 
; 242  :     size = va.len + vb.len;

  00098	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR vb$[rsp+16]
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR va$[rsp+16]
  000a5	48 03 c8	 add	 rcx, rax
  000a8	48 8b c1	 mov	 rax, rcx
  000ab	48 89 44 24 70	 mov	 QWORD PTR size$[rsp], rax

; 243  :     if (size < 0) {

  000b0	48 83 7c 24 70
	00		 cmp	 QWORD PTR size$[rsp], 0
  000b6	7d 07		 jge	 SHORT $LN4@PyByteArra@5

; 244  :             PyErr_NoMemory();

  000b8	e8 00 00 00 00	 call	 PyErr_NoMemory

; 245  :             goto done;

  000bd	eb 5d		 jmp	 SHORT $done$20600
$LN4@PyByteArra@5:

; 246  :     }
; 247  : 
; 248  :     result = (PyByteArrayObject *) PyByteArray_FromStringAndSize(NULL, size);

  000bf	48 8b 54 24 70	 mov	 rdx, QWORD PTR size$[rsp]
  000c4	33 c9		 xor	 ecx, ecx
  000c6	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000cb	48 89 44 24 78	 mov	 QWORD PTR result$[rsp], rax

; 249  :     if (result != NULL) {

  000d0	48 83 7c 24 78
	00		 cmp	 QWORD PTR result$[rsp], 0
  000d6	74 44		 je	 SHORT $LN3@PyByteArra@5

; 250  :         memcpy(result->ob_bytes, va.buf, va.len);

  000d8	4c 8b 44 24 30	 mov	 r8, QWORD PTR va$[rsp+16]
  000dd	48 8b 54 24 20	 mov	 rdx, QWORD PTR va$[rsp]
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR result$[rsp]
  000e7	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000ee	e8 00 00 00 00	 call	 memcpy

; 251  :         memcpy(result->ob_bytes + va.len, vb.buf, vb.len);

  000f3	48 8b 44 24 78	 mov	 rax, QWORD PTR result$[rsp]
  000f8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000ff	48 03 44 24 30	 add	 rax, QWORD PTR va$[rsp+16]
  00104	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR vb$[rsp+16]
  0010c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR vb$[rsp]
  00114	48 8b c8	 mov	 rcx, rax
  00117	e8 00 00 00 00	 call	 memcpy
$LN3@PyByteArra@5:
$done$20600:

; 252  :     }
; 253  : 
; 254  :   done:
; 255  :     if (va.len != -1)

  0011c	48 83 7c 24 30
	ff		 cmp	 QWORD PTR va$[rsp+16], -1
  00122	74 0a		 je	 SHORT $LN2@PyByteArra@5

; 256  :         PyBuffer_Release(&va);

  00124	48 8d 4c 24 20	 lea	 rcx, QWORD PTR va$[rsp]
  00129	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@PyByteArra@5:

; 257  :     if (vb.len != -1)

  0012e	48 83 bc 24 90
	00 00 00 ff	 cmp	 QWORD PTR vb$[rsp+16], -1
  00137	74 0d		 je	 SHORT $LN1@PyByteArra@5

; 258  :         PyBuffer_Release(&vb);

  00139	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR vb$[rsp]
  00141	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@PyByteArra@5:

; 259  :     return (PyObject *)result;

  00146	48 8b 44 24 78	 mov	 rax, QWORD PTR result$[rsp]

; 260  : }

  0014b	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00152	c3		 ret	 0
PyByteArray_Concat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_getbuffer DD imagerel _getbuffer
	DD	imagerel _getbuffer+142
	DD	imagerel $unwind$_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_getbuffer DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@
CONST	SEGMENT
??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@ DB 'Type %'
	DB	'.100s doesn''t support the buffer API', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _getbuffer
_TEXT	SEGMENT
buffer$ = 32
obj$ = 64
view$ = 72
_getbuffer PROC						; COMDAT

; 79   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 80   :     PyBufferProcs *buffer = Py_TYPE(obj)->tp_as_buffer;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  0001e	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax

; 81   : 
; 82   :     if (buffer == NULL || buffer->bf_getbuffer == NULL)

  00023	48 83 7c 24 20
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00029	74 0b		 je	 SHORT $LN2@getbuffer
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00030	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00034	75 29		 jne	 SHORT $LN3@getbuffer
$LN2@getbuffer:

; 83   :     {
; 84   :         PyErr_Format(PyExc_TypeError,
; 85   :                      "Type %.100s doesn't support the buffer API",
; 86   :                      Py_TYPE(obj)->tp_name);

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  0003b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00051	e8 00 00 00 00	 call	 PyErr_Format

; 87   :         return -1;

  00056	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0005d	eb 2a		 jmp	 SHORT $LN4@getbuffer
$LN3@getbuffer:

; 88   :     }
; 89   : 
; 90   :     if (buffer->bf_getbuffer(obj, view, PyBUF_SIMPLE) < 0)

  0005f	45 33 c0	 xor	 r8d, r8d
  00062	48 8b 54 24 48	 mov	 rdx, QWORD PTR view$[rsp]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00071	ff 10		 call	 QWORD PTR [rax]
  00073	85 c0		 test	 eax, eax
  00075	7d 09		 jge	 SHORT $LN1@getbuffer

; 91   :             return -1;

  00077	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0007e	eb 09		 jmp	 SHORT $LN4@getbuffer
$LN1@getbuffer:

; 92   :     return view->len;

  00080	48 8b 44 24 48	 mov	 rax, QWORD PTR view$[rsp]
  00085	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN4@getbuffer:

; 93   : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
_getbuffer ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT bytearray_length
_TEXT	SEGMENT
self$ = 8
bytearray_length PROC					; COMDAT

; 266  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 267  :     return Py_SIZE(self);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  0000a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]

; 268  : }

  0000e	c3		 ret	 0
bytearray_length ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_iconcat DD imagerel bytearray_iconcat
	DD	imagerel bytearray_iconcat+361
	DD	imagerel $unwind$bytearray_iconcat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_iconcat DD 021101H
	DD	0130111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_iconcat
_TEXT	SEGMENT
mysize$ = 32
vo$ = 48
size$ = 128
self$ = 160
other$ = 168
bytearray_iconcat PROC					; COMDAT

; 272  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 273  :     Py_ssize_t mysize;
; 274  :     Py_ssize_t size;
; 275  :     Py_buffer vo;
; 276  : 
; 277  :     if (_getbuffer(other, &vo) < 0) {

  00011	48 8d 54 24 30	 lea	 rdx, QWORD PTR vo$[rsp]
  00016	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  0001e	e8 00 00 00 00	 call	 _getbuffer
  00023	48 85 c0	 test	 rax, rax
  00026	7d 3a		 jge	 SHORT $LN5@bytearray_@2

; 278  :         PyErr_Format(PyExc_TypeError, "can't concat %.100s to %.100s",
; 279  :                      Py_TYPE(other)->tp_name, Py_TYPE(self)->tp_name);

  00028	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00030	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00034	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  0003c	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00040	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00044	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00056	e8 00 00 00 00	 call	 PyErr_Format

; 280  :         return NULL;

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 ff 00 00 00	 jmp	 $LN6@bytearray_@2
$LN5@bytearray_@2:

; 281  :     }
; 282  : 
; 283  :     mysize = Py_SIZE(self);

  00062	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006e	48 89 44 24 20	 mov	 QWORD PTR mysize$[rsp], rax

; 284  :     size = mysize + vo.len;

  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR vo$[rsp+16]
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mysize$[rsp]
  0007d	48 03 c8	 add	 rcx, rax
  00080	48 8b c1	 mov	 rax, rcx
  00083	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR size$[rsp], rax

; 285  :     if (size < 0) {

  0008b	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  00094	7d 14		 jge	 SHORT $LN4@bytearray_@2

; 286  :         PyBuffer_Release(&vo);

  00096	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vo$[rsp]
  0009b	e8 00 00 00 00	 call	 PyBuffer_Release

; 287  :         return PyErr_NoMemory();

  000a0	e8 00 00 00 00	 call	 PyErr_NoMemory
  000a5	e9 b7 00 00 00	 jmp	 $LN6@bytearray_@2
$LN4@bytearray_@2:

; 288  :     }
; 289  :     if (size < self->ob_alloc) {

  000aa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000b2	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000b6	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR size$[rsp], rax
  000be	7d 35		 jge	 SHORT $LN3@bytearray_@2

; 290  :         Py_SIZE(self) = size;

  000c0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000c8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  000d0	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 291  :         self->ob_bytes[Py_SIZE(self)] = '\0'; /* Trailing null byte */

  000d4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000dc	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000e3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000eb	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000ef	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  000f3	eb 27		 jmp	 SHORT $LN2@bytearray_@2
$LN3@bytearray_@2:

; 292  :     }
; 293  :     else if (PyByteArray_Resize((PyObject *)self, size) < 0) {

  000f5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR size$[rsp]
  000fd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00105	e8 00 00 00 00	 call	 PyByteArray_Resize
  0010a	85 c0		 test	 eax, eax
  0010c	7d 0e		 jge	 SHORT $LN1@bytearray_@2

; 294  :         PyBuffer_Release(&vo);

  0010e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vo$[rsp]
  00113	e8 00 00 00 00	 call	 PyBuffer_Release

; 295  :         return NULL;

  00118	33 c0		 xor	 eax, eax
  0011a	eb 45		 jmp	 SHORT $LN6@bytearray_@2
$LN1@bytearray_@2:
$LN2@bytearray_@2:

; 296  :     }
; 297  :     memcpy(self->ob_bytes + mysize, vo.buf, vo.len);

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00124	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0012b	48 03 44 24 20	 add	 rax, QWORD PTR mysize$[rsp]
  00130	4c 8b 44 24 40	 mov	 r8, QWORD PTR vo$[rsp+16]
  00135	48 8b 54 24 30	 mov	 rdx, QWORD PTR vo$[rsp]
  0013a	48 8b c8	 mov	 rcx, rax
  0013d	e8 00 00 00 00	 call	 memcpy

; 298  :     PyBuffer_Release(&vo);

  00142	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vo$[rsp]
  00147	e8 00 00 00 00	 call	 PyBuffer_Release

; 299  :     Py_INCREF(self);

  0014c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00154	e8 00 00 00 00	 call	 _Py_IncRef

; 300  :     return (PyObject *)self;

  00159	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
$LN6@bytearray_@2:

; 301  : }

  00161	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00168	c3		 ret	 0
bytearray_iconcat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytearrayobject.c
pdata	SEGMENT
$pdata$bytearray_repeat DD imagerel bytearray_repeat
	DD	imagerel bytearray_repeat+289
	DD	imagerel $unwind$bytearray_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_repeat DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_repeat
_TEXT	SEGMENT
mysize$ = 32
size$ = 40
result$ = 48
i$20658 = 56
self$ = 80
count$ = 88
bytearray_repeat PROC					; COMDAT

; 305  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 306  :     PyByteArrayObject *result;
; 307  :     Py_ssize_t mysize;
; 308  :     Py_ssize_t size;
; 309  : 
; 310  :     if (count < 0)

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR count$[rsp], 0
  00014	7d 09		 jge	 SHORT $LN8@bytearray_@3

; 311  :         count = 0;

  00016	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0
$LN8@bytearray_@3:

; 312  :     mysize = Py_SIZE(self);

  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00024	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00028	48 89 44 24 20	 mov	 QWORD PTR mysize$[rsp], rax

; 313  :     if (count > 0 && mysize > PY_SSIZE_T_MAX / count)

  0002d	48 83 7c 24 58
	00		 cmp	 QWORD PTR count$[rsp], 0
  00033	7e 22		 jle	 SHORT $LN7@bytearray_@3
  00035	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0003f	48 99		 cdq
  00041	48 f7 7c 24 58	 idiv	 QWORD PTR count$[rsp]
  00046	48 39 44 24 20	 cmp	 QWORD PTR mysize$[rsp], rax
  0004b	7e 0a		 jle	 SHORT $LN7@bytearray_@3

; 314  :         return PyErr_NoMemory();

  0004d	e8 00 00 00 00	 call	 PyErr_NoMemory
  00052	e9 c5 00 00 00	 jmp	 $LN9@bytearray_@3
$LN7@bytearray_@3:

; 315  :     size = mysize * count;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR mysize$[rsp]
  0005c	48 0f af 44 24
	58		 imul	 rax, QWORD PTR count$[rsp]
  00062	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 316  :     result = (PyByteArrayObject *)PyByteArray_FromStringAndSize(NULL, size);

  00067	48 8b 54 24 28	 mov	 rdx, QWORD PTR size$[rsp]
  0006c	33 c9		 xor	 ecx, ecx
  0006e	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00073	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 317  :     if (result != NULL && size != 0) {

  00078	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  0007e	0f 84 93 00 00
	00		 je	 $LN6@bytearray_@3
  00084	48 83 7c 24 28
	00		 cmp	 QWORD PTR size$[rsp], 0
  0008a	0f 84 87 00 00
	00		 je	 $LN6@bytearray_@3

; 318  :         if (mysize == 1)

  00090	48 83 7c 24 20
	01		 cmp	 QWORD PTR mysize$[rsp], 1
  00096	75 29		 jne	 SHORT $LN5@bytearray_@3

; 319  :             memset(result->ob_bytes, self->ob_bytes[0], size);

  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0009d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000a4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a7	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  000ac	8b d0		 mov	 edx, eax
  000ae	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  000b3	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000ba	e8 00 00 00 00	 call	 memset

; 320  :         else {

  000bf	eb 56		 jmp	 SHORT $LN4@bytearray_@3
$LN5@bytearray_@3:

; 321  :             Py_ssize_t i;
; 322  :             for (i = 0; i < count; i++)

  000c1	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$20658[rsp], 0
  000ca	eb 0d		 jmp	 SHORT $LN3@bytearray_@3
$LN2@bytearray_@3:
  000cc	48 8b 44 24 38	 mov	 rax, QWORD PTR i$20658[rsp]
  000d1	48 ff c0	 inc	 rax
  000d4	48 89 44 24 38	 mov	 QWORD PTR i$20658[rsp], rax
$LN3@bytearray_@3:
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR count$[rsp]
  000de	48 39 44 24 38	 cmp	 QWORD PTR i$20658[rsp], rax
  000e3	7d 32		 jge	 SHORT $LN1@bytearray_@3

; 323  :                 memcpy(result->ob_bytes + i*mysize, self->ob_bytes, mysize);

  000e5	48 8b 44 24 38	 mov	 rax, QWORD PTR i$20658[rsp]
  000ea	48 0f af 44 24
	20		 imul	 rax, QWORD PTR mysize$[rsp]
  000f0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  000f5	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  000fc	4c 8b 44 24 20	 mov	 r8, QWORD PTR mysize$[rsp]
  00101	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00106	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  0010d	48 8b c8	 mov	 rcx, rax
  00110	e8 00 00 00 00	 call	 memcpy
  00115	eb b5		 jmp	 SHORT $LN2@bytearray_@3
$LN1@bytearray_@3:
$LN4@bytearray_@3:
$LN6@bytearray_@3:

; 324  :         }
; 325  :     }
; 326  :     return (PyObject *)result;

  00117	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN9@bytearray_@3:

; 327  : }

  0011c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00120	c3		 ret	 0
bytearray_repeat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_irepeat DD imagerel bytearray_irepeat
	DD	imagerel bytearray_irepeat+341
	DD	imagerel $unwind$bytearray_irepeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_irepeat DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_irepeat
_TEXT	SEGMENT
mysize$ = 32
size$ = 40
i$20685 = 48
self$ = 80
count$ = 88
bytearray_irepeat PROC					; COMDAT

; 331  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 332  :     Py_ssize_t mysize;
; 333  :     Py_ssize_t size;
; 334  : 
; 335  :     if (count < 0)

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR count$[rsp], 0
  00014	7d 09		 jge	 SHORT $LN10@bytearray_@4

; 336  :         count = 0;

  00016	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0
$LN10@bytearray_@4:

; 337  :     mysize = Py_SIZE(self);

  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00024	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00028	48 89 44 24 20	 mov	 QWORD PTR mysize$[rsp], rax

; 338  :     if (count > 0 && mysize > PY_SSIZE_T_MAX / count)

  0002d	48 83 7c 24 58
	00		 cmp	 QWORD PTR count$[rsp], 0
  00033	7e 22		 jle	 SHORT $LN9@bytearray_@4
  00035	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0003f	48 99		 cdq
  00041	48 f7 7c 24 58	 idiv	 QWORD PTR count$[rsp]
  00046	48 39 44 24 20	 cmp	 QWORD PTR mysize$[rsp], rax
  0004b	7e 0a		 jle	 SHORT $LN9@bytearray_@4

; 339  :         return PyErr_NoMemory();

  0004d	e8 00 00 00 00	 call	 PyErr_NoMemory
  00052	e9 f9 00 00 00	 jmp	 $LN11@bytearray_@4
$LN9@bytearray_@4:

; 340  :     size = mysize * count;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR mysize$[rsp]
  0005c	48 0f af 44 24
	58		 imul	 rax, QWORD PTR count$[rsp]
  00062	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 341  :     if (size < self->ob_alloc) {

  00067	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0006c	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00070	48 39 44 24 28	 cmp	 QWORD PTR size$[rsp], rax
  00075	7d 29		 jge	 SHORT $LN8@bytearray_@4

; 342  :         Py_SIZE(self) = size;

  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0007c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  00081	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 343  :         self->ob_bytes[Py_SIZE(self)] = '\0'; /* Trailing null byte */

  00085	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0008a	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00091	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00096	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0009a	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  0009e	eb 1a		 jmp	 SHORT $LN7@bytearray_@4
$LN8@bytearray_@4:

; 344  :     }
; 345  :     else if (PyByteArray_Resize((PyObject *)self, size) < 0)

  000a0	48 8b 54 24 28	 mov	 rdx, QWORD PTR size$[rsp]
  000a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000aa	e8 00 00 00 00	 call	 PyByteArray_Resize
  000af	85 c0		 test	 eax, eax
  000b1	7d 07		 jge	 SHORT $LN6@bytearray_@4

; 346  :         return NULL;

  000b3	33 c0		 xor	 eax, eax
  000b5	e9 96 00 00 00	 jmp	 $LN11@bytearray_@4
$LN6@bytearray_@4:
$LN7@bytearray_@4:

; 347  : 
; 348  :     if (mysize == 1)

  000ba	48 83 7c 24 20
	01		 cmp	 QWORD PTR mysize$[rsp], 1
  000c0	75 29		 jne	 SHORT $LN5@bytearray_@4

; 349  :         memset(self->ob_bytes, self->ob_bytes[0], size);

  000c2	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c7	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000ce	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000d1	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  000d6	8b d0		 mov	 edx, eax
  000d8	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000dd	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000e4	e8 00 00 00 00	 call	 memset

; 350  :     else {

  000e9	eb 56		 jmp	 SHORT $LN4@bytearray_@4
$LN5@bytearray_@4:

; 351  :         Py_ssize_t i;
; 352  :         for (i = 1; i < count; i++)

  000eb	48 c7 44 24 30
	01 00 00 00	 mov	 QWORD PTR i$20685[rsp], 1
  000f4	eb 0d		 jmp	 SHORT $LN3@bytearray_@4
$LN2@bytearray_@4:
  000f6	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20685[rsp]
  000fb	48 ff c0	 inc	 rax
  000fe	48 89 44 24 30	 mov	 QWORD PTR i$20685[rsp], rax
$LN3@bytearray_@4:
  00103	48 8b 44 24 58	 mov	 rax, QWORD PTR count$[rsp]
  00108	48 39 44 24 30	 cmp	 QWORD PTR i$20685[rsp], rax
  0010d	7d 32		 jge	 SHORT $LN1@bytearray_@4

; 353  :             memcpy(self->ob_bytes + i*mysize, self->ob_bytes, mysize);

  0010f	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20685[rsp]
  00114	48 0f af 44 24
	20		 imul	 rax, QWORD PTR mysize$[rsp]
  0011a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0011f	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  00126	4c 8b 44 24 20	 mov	 r8, QWORD PTR mysize$[rsp]
  0012b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00130	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  00137	48 8b c8	 mov	 rcx, rax
  0013a	e8 00 00 00 00	 call	 memcpy
  0013f	eb b5		 jmp	 SHORT $LN2@bytearray_@4
$LN1@bytearray_@4:
$LN4@bytearray_@4:

; 354  :     }
; 355  : 
; 356  :     Py_INCREF(self);

  00141	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00146	e8 00 00 00 00	 call	 _Py_IncRef

; 357  :     return (PyObject *)self;

  0014b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
$LN11@bytearray_@4:

; 358  : }

  00150	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00154	c3		 ret	 0
bytearray_irepeat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@ ; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_getitem DD imagerel bytearray_getitem
	DD	imagerel bytearray_getitem+127
	DD	imagerel $unwind$bytearray_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_getitem DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@ DB 'bytearray in'
	DB	'dex out of range', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_getitem
_TEXT	SEGMENT
self$ = 48
i$ = 56
bytearray_getitem PROC					; COMDAT

; 362  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 363  :     if (i < 0)

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  00014	7d 19		 jge	 SHORT $LN3@bytearray_@5

; 364  :         i += Py_SIZE(self);

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00024	48 03 c8	 add	 rcx, rax
  00027	48 8b c1	 mov	 rax, rcx
  0002a	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN3@bytearray_@5:

; 365  :     if (i < 0 || i >= Py_SIZE(self)) {

  0002f	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  00035	7c 10		 jl	 SHORT $LN1@bytearray_@5
  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00040	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00045	7c 17		 jl	 SHORT $LN2@bytearray_@5
$LN1@bytearray_@5:

; 366  :         PyErr_SetString(PyExc_IndexError, "bytearray index out of range");

  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@
  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00055	e8 00 00 00 00	 call	 PyErr_SetString

; 367  :         return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb 1c		 jmp	 SHORT $LN4@bytearray_@5
$LN2@bytearray_@5:

; 368  :     }
; 369  :     return PyLong_FromLong((unsigned char)(self->ob_bytes[i]));

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00063	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0006a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0006f	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00073	8b c8		 mov	 ecx, eax
  00075	e8 00 00 00 00	 call	 PyLong_FromLong
$LN4@bytearray_@5:

; 370  : }

  0007a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007e	c3		 ret	 0
bytearray_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@MBEBMMIP@bytearray?5indices?5must?5be?5intege@ ; `string'
PUBLIC	??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PySlice_GetIndicesEx:PROC
EXTRN	PySlice_Type:BYTE
EXTRN	PyErr_Occurred:PROC
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_subscript DD imagerel bytearray_subscript
	DD	imagerel bytearray_subscript+1038
	DD	imagerel $unwind$bytearray_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_subscript DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0CD@MBEBMMIP@bytearray?5indices?5must?5be?5intege@
CONST	SEGMENT
??_C@_0CD@MBEBMMIP@bytearray?5indices?5must?5be?5intege@ DB 'bytearray in'
	DB	'dices must be integers', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_subscript
_TEXT	SEGMENT
i$20714 = 48
i$20735 = 56
cur$20734 = 64
slicelength$20733 = 72
step$20732 = 80
stop$20731 = 88
start$20730 = 96
source_buf$20747 = 104
result$20754 = 112
result_buf$20753 = 120
tv179 = 128
tv198 = 136
self$ = 160
index$ = 168
bytearray_subscript PROC				; COMDAT

; 374  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 375  :     if (PyIndex_Check(index)) {

  00011	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR index$[rsp]
  00019	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001d	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00025	0f 84 22 01 00
	00		 je	 $LN17@bytearray_@6
  0002b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR index$[rsp]
  00033	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00037	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0003e	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00046	0f 84 01 01 00
	00		 je	 $LN17@bytearray_@6

; 376  :         Py_ssize_t i = PyNumber_AsSsize_t(index, PyExc_IndexError);

  0004c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00053	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR index$[rsp]
  0005b	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00060	48 89 44 24 30	 mov	 QWORD PTR i$20714[rsp], rax

; 377  : 
; 378  :         if (i == -1 && PyErr_Occurred())

  00065	48 83 7c 24 30
	ff		 cmp	 QWORD PTR i$20714[rsp], -1
  0006b	75 11		 jne	 SHORT $LN16@bytearray_@6
  0006d	e8 00 00 00 00	 call	 PyErr_Occurred
  00072	48 85 c0	 test	 rax, rax
  00075	74 07		 je	 SHORT $LN16@bytearray_@6

; 379  :             return NULL;

  00077	33 c0		 xor	 eax, eax
  00079	e9 88 03 00 00	 jmp	 $LN18@bytearray_@6
$LN16@bytearray_@6:

; 380  : 
; 381  :         if (i < 0)

  0007e	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$20714[rsp], 0
  00084	7d 69		 jge	 SHORT $LN15@bytearray_@6

; 382  :             i += PyByteArray_GET_SIZE(self);

  00086	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0008d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00095	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00099	74 38		 je	 SHORT $LN20@bytearray_@6
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000a2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000aa	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000ae	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b3	85 c0		 test	 eax, eax
  000b5	75 1c		 jne	 SHORT $LN20@bytearray_@6
  000b7	41 b8 7e 01 00
	00		 mov	 r8d, 382		; 0000017eH
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d1	33 c0		 xor	 eax, eax
$LN20@bytearray_@6:
  000d3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000db	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$20714[rsp]
  000e4	48 03 c8	 add	 rcx, rax
  000e7	48 8b c1	 mov	 rax, rcx
  000ea	48 89 44 24 30	 mov	 QWORD PTR i$20714[rsp], rax
$LN15@bytearray_@6:

; 383  : 
; 384  :         if (i < 0 || i >= Py_SIZE(self)) {

  000ef	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$20714[rsp], 0
  000f5	7c 13		 jl	 SHORT $LN13@bytearray_@6
  000f7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000ff	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00103	48 39 44 24 30	 cmp	 QWORD PTR i$20714[rsp], rax
  00108	7c 1a		 jl	 SHORT $LN14@bytearray_@6
$LN13@bytearray_@6:

; 385  :             PyErr_SetString(PyExc_IndexError, "bytearray index out of range");

  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@
  00111	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00118	e8 00 00 00 00	 call	 PyErr_SetString

; 386  :             return NULL;

  0011d	33 c0		 xor	 eax, eax
  0011f	e9 e2 02 00 00	 jmp	 $LN18@bytearray_@6
$LN14@bytearray_@6:

; 387  :         }
; 388  :         return PyLong_FromLong((unsigned char)(self->ob_bytes[i]));

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0012c	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00133	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$20714[rsp]
  00138	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0013c	8b c8		 mov	 ecx, eax
  0013e	e8 00 00 00 00	 call	 PyLong_FromLong
  00143	e9 be 02 00 00	 jmp	 $LN18@bytearray_@6
  00148	e9 b9 02 00 00	 jmp	 $LN12@bytearray_@6
$LN17@bytearray_@6:

; 389  :     }
; 390  :     else if (PySlice_Check(index)) {

  0014d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  00154	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR index$[rsp]
  0015c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00160	0f 85 8b 02 00
	00		 jne	 $LN11@bytearray_@6

; 391  :         Py_ssize_t start, stop, step, slicelength, cur, i;
; 392  :         if (PySlice_GetIndicesEx(index,
; 393  :                                  PyByteArray_GET_SIZE(self),
; 394  :                                  &start, &stop, &step, &slicelength) < 0) {

  00166	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0016d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00175	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00179	74 38		 je	 SHORT $LN21@bytearray_@6
  0017b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00182	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0018a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0018e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00193	85 c0		 test	 eax, eax
  00195	75 1c		 jne	 SHORT $LN21@bytearray_@6
  00197	41 b8 89 01 00
	00		 mov	 r8d, 393		; 00000189H
  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b1	33 c0		 xor	 eax, eax
$LN21@bytearray_@6:
  001b3	48 8d 44 24 48	 lea	 rax, QWORD PTR slicelength$20733[rsp]
  001b8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001bd	48 8d 44 24 50	 lea	 rax, QWORD PTR step$20732[rsp]
  001c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c7	4c 8d 4c 24 58	 lea	 r9, QWORD PTR stop$20731[rsp]
  001cc	4c 8d 44 24 60	 lea	 r8, QWORD PTR start$20730[rsp]
  001d1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001d9	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  001dd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR index$[rsp]
  001e5	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  001ea	85 c0		 test	 eax, eax
  001ec	7d 07		 jge	 SHORT $LN10@bytearray_@6

; 395  :             return NULL;

  001ee	33 c0		 xor	 eax, eax
  001f0	e9 11 02 00 00	 jmp	 $LN18@bytearray_@6
$LN10@bytearray_@6:

; 396  :         }
; 397  : 
; 398  :         if (slicelength <= 0)

  001f5	48 83 7c 24 48
	00		 cmp	 QWORD PTR slicelength$20733[rsp], 0
  001fb	7f 18		 jg	 SHORT $LN9@bytearray_@6

; 399  :             return PyByteArray_FromStringAndSize("", 0);

  001fd	33 d2		 xor	 edx, edx
  001ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00206	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0020b	e9 f6 01 00 00	 jmp	 $LN18@bytearray_@6
  00210	e9 da 01 00 00	 jmp	 $LN8@bytearray_@6
$LN9@bytearray_@6:

; 400  :         else if (step == 1) {

  00215	48 83 7c 24 50
	01		 cmp	 QWORD PTR step$20732[rsp], 1
  0021b	75 2b		 jne	 SHORT $LN7@bytearray_@6

; 401  :             return PyByteArray_FromStringAndSize(self->ob_bytes + start,
; 402  :                                              slicelength);

  0021d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00225	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0022c	48 03 44 24 60	 add	 rax, QWORD PTR start$20730[rsp]
  00231	48 8b 54 24 48	 mov	 rdx, QWORD PTR slicelength$20733[rsp]
  00236	48 8b c8	 mov	 rcx, rax
  00239	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0023e	e9 c3 01 00 00	 jmp	 $LN18@bytearray_@6

; 403  :         }
; 404  :         else {

  00243	e9 a7 01 00 00	 jmp	 $LN6@bytearray_@6
$LN7@bytearray_@6:

; 405  :             char *source_buf = PyByteArray_AS_STRING(self);

  00248	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0024f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00257	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0025b	74 38		 je	 SHORT $LN22@bytearray_@6
  0025d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00264	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0026c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00270	e8 00 00 00 00	 call	 PyType_IsSubtype
  00275	85 c0		 test	 eax, eax
  00277	75 1c		 jne	 SHORT $LN22@bytearray_@6
  00279	41 b8 95 01 00
	00		 mov	 r8d, 405		; 00000195H
  0027f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0028d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00293	33 c0		 xor	 eax, eax
$LN22@bytearray_@6:
  00295	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0029d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  002a2	74 19		 je	 SHORT $LN23@bytearray_@6
  002a4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002ac	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  002b3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv179[rsp], rax
  002bb	eb 0f		 jmp	 SHORT $LN24@bytearray_@6
$LN23@bytearray_@6:
  002bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  002c4	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv179[rsp], rax
$LN24@bytearray_@6:
  002cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv179[rsp]
  002d4	48 89 44 24 68	 mov	 QWORD PTR source_buf$20747[rsp], rax

; 406  :             char *result_buf;
; 407  :             PyObject *result;
; 408  : 
; 409  :             result = PyByteArray_FromStringAndSize(NULL, slicelength);

  002d9	48 8b 54 24 48	 mov	 rdx, QWORD PTR slicelength$20733[rsp]
  002de	33 c9		 xor	 ecx, ecx
  002e0	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  002e5	48 89 44 24 70	 mov	 QWORD PTR result$20754[rsp], rax

; 410  :             if (result == NULL)

  002ea	48 83 7c 24 70
	00		 cmp	 QWORD PTR result$20754[rsp], 0
  002f0	75 07		 jne	 SHORT $LN5@bytearray_@6

; 411  :                 return NULL;

  002f2	33 c0		 xor	 eax, eax
  002f4	e9 0d 01 00 00	 jmp	 $LN18@bytearray_@6
$LN5@bytearray_@6:

; 412  : 
; 413  :             result_buf = PyByteArray_AS_STRING(result);

  002f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00300	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result$20754[rsp]
  00305	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00309	74 35		 je	 SHORT $LN25@bytearray_@6
  0030b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00312	48 8b 44 24 70	 mov	 rax, QWORD PTR result$20754[rsp]
  00317	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0031b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00320	85 c0		 test	 eax, eax
  00322	75 1c		 jne	 SHORT $LN25@bytearray_@6
  00324	41 b8 9d 01 00
	00		 mov	 r8d, 413		; 0000019dH
  0032a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00331	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0033e	33 c0		 xor	 eax, eax
$LN25@bytearray_@6:
  00340	48 8b 44 24 70	 mov	 rax, QWORD PTR result$20754[rsp]
  00345	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0034a	74 16		 je	 SHORT $LN26@bytearray_@6
  0034c	48 8b 44 24 70	 mov	 rax, QWORD PTR result$20754[rsp]
  00351	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00358	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
  00360	eb 0f		 jmp	 SHORT $LN27@bytearray_@6
$LN26@bytearray_@6:
  00362	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00369	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
$LN27@bytearray_@6:
  00371	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv198[rsp]
  00379	48 89 44 24 78	 mov	 QWORD PTR result_buf$20753[rsp], rax

; 414  :             for (cur = start, i = 0; i < slicelength;
; 415  :                  cur += step, i++) {

  0037e	48 8b 44 24 60	 mov	 rax, QWORD PTR start$20730[rsp]
  00383	48 89 44 24 40	 mov	 QWORD PTR cur$20734[rsp], rax
  00388	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$20735[rsp], 0
  00391	eb 22		 jmp	 SHORT $LN4@bytearray_@6
$LN3@bytearray_@6:
  00393	48 8b 44 24 50	 mov	 rax, QWORD PTR step$20732[rsp]
  00398	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cur$20734[rsp]
  0039d	48 03 c8	 add	 rcx, rax
  003a0	48 8b c1	 mov	 rax, rcx
  003a3	48 89 44 24 40	 mov	 QWORD PTR cur$20734[rsp], rax
  003a8	48 8b 44 24 38	 mov	 rax, QWORD PTR i$20735[rsp]
  003ad	48 ff c0	 inc	 rax
  003b0	48 89 44 24 38	 mov	 QWORD PTR i$20735[rsp], rax
$LN4@bytearray_@6:
  003b5	48 8b 44 24 48	 mov	 rax, QWORD PTR slicelength$20733[rsp]
  003ba	48 39 44 24 38	 cmp	 QWORD PTR i$20735[rsp], rax
  003bf	7d 27		 jge	 SHORT $LN2@bytearray_@6

; 416  :                      result_buf[i] = source_buf[cur];

  003c1	48 8b 44 24 38	 mov	 rax, QWORD PTR i$20735[rsp]
  003c6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR result_buf$20753[rsp]
  003cb	48 03 c8	 add	 rcx, rax
  003ce	48 8b c1	 mov	 rax, rcx
  003d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cur$20734[rsp]
  003d6	48 8b 54 24 68	 mov	 rdx, QWORD PTR source_buf$20747[rsp]
  003db	48 03 d1	 add	 rdx, rcx
  003de	48 8b ca	 mov	 rcx, rdx
  003e1	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  003e4	88 08		 mov	 BYTE PTR [rax], cl

; 417  :             }

  003e6	eb ab		 jmp	 SHORT $LN3@bytearray_@6
$LN2@bytearray_@6:

; 418  :             return result;

  003e8	48 8b 44 24 70	 mov	 rax, QWORD PTR result$20754[rsp]
  003ed	eb 17		 jmp	 SHORT $LN18@bytearray_@6
$LN6@bytearray_@6:
$LN8@bytearray_@6:

; 419  :         }
; 420  :     }
; 421  :     else {

  003ef	eb 15		 jmp	 SHORT $LN1@bytearray_@6
$LN11@bytearray_@6:

; 422  :         PyErr_SetString(PyExc_TypeError, "bytearray indices must be integers");

  003f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@MBEBMMIP@bytearray?5indices?5must?5be?5intege@
  003f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  003ff	e8 00 00 00 00	 call	 PyErr_SetString

; 423  :         return NULL;

  00404	33 c0		 xor	 eax, eax
$LN1@bytearray_@6:
$LN12@bytearray_@6:
$LN18@bytearray_@6:

; 424  :     }
; 425  : }

  00406	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0040d	c3		 ret	 0
bytearray_subscript ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_setitem DD imagerel bytearray_setitem
	DD	imagerel bytearray_setitem+199
	DD	imagerel $unwind$bytearray_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_setitem DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_setitem
_TEXT	SEGMENT
ival$ = 32
self$ = 64
i$ = 72
value$ = 80
bytearray_setitem PROC					; COMDAT

; 519  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 520  :     int ival;
; 521  : 
; 522  :     if (i < 0)

  00013	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  00019	7d 19		 jge	 SHORT $LN5@bytearray_@7

; 523  :         i += Py_SIZE(self);

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00024	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  00029	48 03 c8	 add	 rcx, rax
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	48 89 44 24 48	 mov	 QWORD PTR i$[rsp], rax
$LN5@bytearray_@7:

; 524  : 
; 525  :     if (i < 0 || i >= Py_SIZE(self)) {

  00034	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  0003a	7c 10		 jl	 SHORT $LN3@bytearray_@7
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00041	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00045	48 39 44 24 48	 cmp	 QWORD PTR i$[rsp], rax
  0004a	7c 1a		 jl	 SHORT $LN4@bytearray_@7
$LN3@bytearray_@7:

; 526  :         PyErr_SetString(PyExc_IndexError, "bytearray index out of range");

  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@
  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0005a	e8 00 00 00 00	 call	 PyErr_SetString

; 527  :         return -1;

  0005f	b8 ff ff ff ff	 mov	 eax, -1
  00064	eb 5c		 jmp	 SHORT $LN6@bytearray_@7
$LN4@bytearray_@7:

; 528  :     }
; 529  : 
; 530  :     if (value == NULL)

  00066	48 83 7c 24 50
	00		 cmp	 QWORD PTR value$[rsp], 0
  0006c	75 1f		 jne	 SHORT $LN2@bytearray_@7

; 531  :         return bytearray_setslice(self, i, i+1, NULL);

  0006e	48 8b 44 24 48	 mov	 rax, QWORD PTR i$[rsp]
  00073	48 ff c0	 inc	 rax
  00076	45 33 c9	 xor	 r9d, r9d
  00079	4c 8b c0	 mov	 r8, rax
  0007c	48 8b 54 24 48	 mov	 rdx, QWORD PTR i$[rsp]
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00086	e8 00 00 00 00	 call	 bytearray_setslice
  0008b	eb 35		 jmp	 SHORT $LN6@bytearray_@7
$LN2@bytearray_@7:

; 532  : 
; 533  :     if (!_getbytevalue(value, &ival))

  0008d	48 8d 54 24 20	 lea	 rdx, QWORD PTR ival$[rsp]
  00092	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  00097	e8 00 00 00 00	 call	 _getbytevalue
  0009c	85 c0		 test	 eax, eax
  0009e	75 07		 jne	 SHORT $LN1@bytearray_@7

; 534  :         return -1;

  000a0	b8 ff ff ff ff	 mov	 eax, -1
  000a5	eb 1b		 jmp	 SHORT $LN6@bytearray_@7
$LN1@bytearray_@7:

; 535  : 
; 536  :     self->ob_bytes[i] = ival;

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000ac	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  000b8	0f b6 54 24 20	 movzx	 edx, BYTE PTR ival$[rsp]
  000bd	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 537  :     return 0;

  000c0	33 c0		 xor	 eax, eax
$LN6@bytearray_@7:

; 538  : }

  000c2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c6	c3		 ret	 0
bytearray_setitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ ; `string'
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyNumber_Index:PROC
EXTRN	PyLong_AsLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_getbytevalue DD imagerel _getbytevalue
	DD	imagerel _getbytevalue+207
	DD	imagerel $unwind$_getbytevalue
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_getbytevalue DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@ DB 'byt'
	DB	'e must be in range(0, 256)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
CONST	SEGMENT
??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ DB 'an integer is requi'
	DB	'red', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _getbytevalue
_TEXT	SEGMENT
face_value$ = 32
index$20433 = 40
arg$ = 64
value$ = 72
_getbytevalue PROC					; COMDAT

; 27   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 28   :     long face_value;
; 29   : 
; 30   :     if (PyLong_Check(arg)) {

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR arg$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00022	85 c0		 test	 eax, eax
  00024	74 10		 je	 SHORT $LN5@getbyteval

; 31   :         face_value = PyLong_AsLong(arg);

  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR arg$[rsp]
  0002b	e8 00 00 00 00	 call	 PyLong_AsLong
  00030	89 44 24 20	 mov	 DWORD PTR face_value$[rsp], eax

; 32   :     } else {

  00034	eb 51		 jmp	 SHORT $LN4@getbyteval
$LN5@getbyteval:

; 33   :         PyObject *index = PyNumber_Index(arg);

  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR arg$[rsp]
  0003b	e8 00 00 00 00	 call	 PyNumber_Index
  00040	48 89 44 24 28	 mov	 QWORD PTR index$20433[rsp], rax

; 34   :         if (index == NULL) {

  00045	48 83 7c 24 28
	00		 cmp	 QWORD PTR index$20433[rsp], 0
  0004b	75 22		 jne	 SHORT $LN3@getbyteval

; 35   :             PyErr_Format(PyExc_TypeError, "an integer is required");

  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0005b	e8 00 00 00 00	 call	 PyErr_Format

; 36   :             *value = -1;

  00060	48 8b 44 24 48	 mov	 rax, QWORD PTR value$[rsp]
  00065	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1

; 37   :             return 0;

  0006b	33 c0		 xor	 eax, eax
  0006d	eb 5b		 jmp	 SHORT $LN6@getbyteval
$LN3@getbyteval:

; 38   :         }
; 39   :         face_value = PyLong_AsLong(index);

  0006f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR index$20433[rsp]
  00074	e8 00 00 00 00	 call	 PyLong_AsLong
  00079	89 44 24 20	 mov	 DWORD PTR face_value$[rsp], eax

; 40   :         Py_DECREF(index);

  0007d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR index$20433[rsp]
  00082	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@getbyteval:

; 41   :     }
; 42   : 
; 43   :     if (face_value < 0 || face_value >= 256) {

  00087	83 7c 24 20 00	 cmp	 DWORD PTR face_value$[rsp], 0
  0008c	7c 0a		 jl	 SHORT $LN1@getbyteval
  0008e	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR face_value$[rsp], 256 ; 00000100H
  00096	7c 22		 jl	 SHORT $LN2@getbyteval
$LN1@getbyteval:

; 44   :         /* this includes the OverflowError in case the long is too large */
; 45   :         PyErr_SetString(PyExc_ValueError, "byte must be in range(0, 256)");

  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  0009f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a6	e8 00 00 00 00	 call	 PyErr_SetString

; 46   :         *value = -1;

  000ab	48 8b 44 24 48	 mov	 rax, QWORD PTR value$[rsp]
  000b0	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1

; 47   :         return 0;

  000b6	33 c0		 xor	 eax, eax
  000b8	eb 10		 jmp	 SHORT $LN6@getbyteval
$LN2@getbyteval:

; 48   :     }
; 49   : 
; 50   :     *value = face_value;

  000ba	48 8b 44 24 48	 mov	 rax, QWORD PTR value$[rsp]
  000bf	8b 4c 24 20	 mov	 ecx, DWORD PTR face_value$[rsp]
  000c3	89 08		 mov	 DWORD PTR [rax], ecx

; 51   :     return 1;

  000c5	b8 01 00 00 00	 mov	 eax, 1
$LN6@getbyteval:

; 52   : }

  000ca	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ce	c3		 ret	 0
_getbytevalue ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@LDFFEMNP@can?8t?5set?5bytearray?5slice?5from?5?$CF@ ; `string'
EXTRN	__imp_memmove:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_setslice DD imagerel bytearray_setslice
	DD	imagerel bytearray_setslice+944
	DD	imagerel $unwind$bytearray_setslice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_setslice DD 021b01H
	DD	017011bH
xdata	ENDS
;	COMDAT ??_C@_0CG@LDFFEMNP@can?8t?5set?5bytearray?5slice?5from?5?$CF@
CONST	SEGMENT
??_C@_0CG@LDFFEMNP@can?8t?5set?5bytearray?5slice?5from?5?$CF@ DB 'can''t '
	DB	'set bytearray slice from %.100s', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_setslice
_TEXT	SEGMENT
res$ = 32
bytes$ = 40
vbytes$ = 48
needed$ = 128
avail$ = 136
err$20788 = 144
tv137 = 152
tv156 = 160
self$ = 192
lo$ = 200
hi$ = 208
values$ = 216
bytearray_setslice PROC					; COMDAT

; 430  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 431  :     Py_ssize_t avail, needed;
; 432  :     void *bytes;
; 433  :     Py_buffer vbytes;
; 434  :     int res = 0;

  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR res$[rsp], 0

; 435  : 
; 436  :     vbytes.len = -1;

  00023	48 c7 44 24 40
	ff ff ff ff	 mov	 QWORD PTR vbytes$[rsp+16], -1

; 437  :     if (values == (PyObject *)self) {

  0002c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00034	48 39 84 24 d8
	00 00 00	 cmp	 QWORD PTR values$[rsp], rax
  0003c	75 6f		 jne	 SHORT $LN16@bytearray_@8

; 438  :         /* Make a copy and call this function recursively */
; 439  :         int err;
; 440  :         values = PyByteArray_FromObject(values);

  0003e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR values$[rsp]
  00046	e8 00 00 00 00	 call	 PyByteArray_FromObject
  0004b	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR values$[rsp], rax

; 441  :         if (values == NULL)

  00053	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR values$[rsp], 0
  0005c	75 0a		 jne	 SHORT $LN15@bytearray_@8

; 442  :             return -1;

  0005e	b8 ff ff ff ff	 mov	 eax, -1
  00063	e9 40 03 00 00	 jmp	 $LN17@bytearray_@8
$LN15@bytearray_@8:

; 443  :         err = bytearray_setslice(self, lo, hi, values);

  00068	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR values$[rsp]
  00070	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR hi$[rsp]
  00078	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR lo$[rsp]
  00080	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00088	e8 00 00 00 00	 call	 bytearray_setslice
  0008d	89 84 24 90 00
	00 00		 mov	 DWORD PTR err$20788[rsp], eax

; 444  :         Py_DECREF(values);

  00094	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR values$[rsp]
  0009c	e8 00 00 00 00	 call	 _Py_DecRef

; 445  :         return err;

  000a1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR err$20788[rsp]
  000a8	e9 fb 02 00 00	 jmp	 $LN17@bytearray_@8
$LN16@bytearray_@8:

; 446  :     }
; 447  :     if (values == NULL) {

  000ad	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR values$[rsp], 0
  000b6	75 17		 jne	 SHORT $LN14@bytearray_@8

; 448  :         /* del b[lo:hi] */
; 449  :         bytes = NULL;

  000b8	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR bytes$[rsp], 0

; 450  :         needed = 0;

  000c1	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR needed$[rsp], 0

; 451  :     }
; 452  :     else {

  000cd	eb 5b		 jmp	 SHORT $LN13@bytearray_@8
$LN14@bytearray_@8:

; 453  :             if (_getbuffer(values, &vbytes) < 0) {

  000cf	48 8d 54 24 30	 lea	 rdx, QWORD PTR vbytes$[rsp]
  000d4	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR values$[rsp]
  000dc	e8 00 00 00 00	 call	 _getbuffer
  000e1	48 85 c0	 test	 rax, rax
  000e4	7d 2d		 jge	 SHORT $LN12@bytearray_@8

; 454  :                     PyErr_Format(PyExc_TypeError,
; 455  :                                  "can't set bytearray slice from %.100s",
; 456  :                                  Py_TYPE(values)->tp_name);

  000e6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR values$[rsp]
  000ee	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f2	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@LDFFEMNP@can?8t?5set?5bytearray?5slice?5from?5?$CF@
  000fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00104	e8 00 00 00 00	 call	 PyErr_Format

; 457  :                     return -1;

  00109	b8 ff ff ff ff	 mov	 eax, -1
  0010e	e9 95 02 00 00	 jmp	 $LN17@bytearray_@8
$LN12@bytearray_@8:

; 458  :             }
; 459  :             needed = vbytes.len;

  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR vbytes$[rsp+16]
  00118	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR needed$[rsp], rax

; 460  :             bytes = vbytes.buf;

  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR vbytes$[rsp]
  00125	48 89 44 24 28	 mov	 QWORD PTR bytes$[rsp], rax
$LN13@bytearray_@8:

; 461  :     }
; 462  : 
; 463  :     if (lo < 0)

  0012a	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR lo$[rsp], 0
  00133	7d 0c		 jge	 SHORT $LN11@bytearray_@8

; 464  :         lo = 0;

  00135	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR lo$[rsp], 0
$LN11@bytearray_@8:

; 465  :     if (hi < lo)

  00141	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR lo$[rsp]
  00149	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR hi$[rsp], rax
  00151	7d 10		 jge	 SHORT $LN10@bytearray_@8

; 466  :         hi = lo;

  00153	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR lo$[rsp]
  0015b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR hi$[rsp], rax
$LN10@bytearray_@8:

; 467  :     if (hi > Py_SIZE(self))

  00163	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0016b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0016f	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR hi$[rsp], rax
  00177	7e 14		 jle	 SHORT $LN9@bytearray_@8

; 468  :         hi = Py_SIZE(self);

  00179	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00181	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00185	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR hi$[rsp], rax
$LN9@bytearray_@8:

; 469  : 
; 470  :     avail = hi - lo;

  0018d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR lo$[rsp]
  00195	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hi$[rsp]
  0019d	48 2b c8	 sub	 rcx, rax
  001a0	48 8b c1	 mov	 rax, rcx
  001a3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR avail$[rsp], rax

; 471  :     if (avail < 0)

  001ab	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR avail$[rsp], 0
  001b4	7d 2c		 jge	 SHORT $LN8@bytearray_@8

; 472  :         lo = hi = avail = 0;

  001b6	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR avail$[rsp], 0
  001c2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR avail$[rsp]
  001ca	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR hi$[rsp], rax
  001d2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR hi$[rsp]
  001da	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR lo$[rsp], rax
$LN8@bytearray_@8:

; 473  : 
; 474  :     if (avail != needed) {

  001e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR needed$[rsp]
  001ea	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR avail$[rsp], rax
  001f2	0f 84 63 01 00
	00		 je	 $LN7@bytearray_@8

; 475  :         if (avail > needed) {

  001f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR needed$[rsp]
  00200	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR avail$[rsp], rax
  00208	0f 8e 8a 00 00
	00		 jle	 $LN6@bytearray_@8

; 476  :             if (!_canresize(self)) {

  0020e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00216	e8 00 00 00 00	 call	 _canresize
  0021b	85 c0		 test	 eax, eax
  0021d	75 0d		 jne	 SHORT $LN5@bytearray_@8

; 477  :                 res = -1;

  0021f	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR res$[rsp], -1

; 478  :                 goto finish;

  00227	e9 66 01 00 00	 jmp	 $finish$20808
$LN5@bytearray_@8:

; 479  :             }
; 480  :             /*
; 481  :               0   lo               hi               old_size
; 482  :               |   |<----avail----->|<-----tomove------>|
; 483  :               |   |<-needed->|<-----tomove------>|
; 484  :               0   lo      new_hi              new_size
; 485  :             */
; 486  :             memmove(self->ob_bytes + lo + needed, self->ob_bytes + hi,
; 487  :                     Py_SIZE(self) - hi);

  0022c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00234	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR hi$[rsp]
  0023c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00240	48 2b c1	 sub	 rax, rcx
  00243	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0024b	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00252	48 03 8c 24 d0
	00 00 00	 add	 rcx, QWORD PTR hi$[rsp]
  0025a	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00262	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00269	48 03 94 24 c8
	00 00 00	 add	 rdx, QWORD PTR lo$[rsp]
  00271	48 03 94 24 80
	00 00 00	 add	 rdx, QWORD PTR needed$[rsp]
  00279	48 89 94 24 98
	00 00 00	 mov	 QWORD PTR tv137[rsp], rdx
  00281	4c 8b c0	 mov	 r8, rax
  00284	48 8b d1	 mov	 rdx, rcx
  00287	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv137[rsp]
  0028f	48 8b c8	 mov	 rcx, rax
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN6@bytearray_@8:

; 488  :         }
; 489  :         /* XXX(nnorwitz): need to verify this can't overflow! */
; 490  :         if (PyByteArray_Resize((PyObject *)self,
; 491  :                            Py_SIZE(self) + needed - avail) < 0) {

  00298	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002a0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002a4	48 03 84 24 80
	00 00 00	 add	 rax, QWORD PTR needed$[rsp]
  002ac	48 2b 84 24 88
	00 00 00	 sub	 rax, QWORD PTR avail$[rsp]
  002b4	48 8b d0	 mov	 rdx, rax
  002b7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002bf	e8 00 00 00 00	 call	 PyByteArray_Resize
  002c4	85 c0		 test	 eax, eax
  002c6	7d 0d		 jge	 SHORT $LN4@bytearray_@8

; 492  :                 res = -1;

  002c8	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR res$[rsp], -1

; 493  :                 goto finish;

  002d0	e9 bd 00 00 00	 jmp	 $finish$20808
$LN4@bytearray_@8:

; 494  :         }
; 495  :         if (avail < needed) {

  002d5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR needed$[rsp]
  002dd	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR avail$[rsp], rax
  002e5	7d 74		 jge	 SHORT $LN3@bytearray_@8

; 496  :             /*
; 497  :               0   lo        hi               old_size
; 498  :               |   |<-avail->|<-----tomove------>|
; 499  :               |   |<----needed---->|<-----tomove------>|
; 500  :               0   lo            new_hi              new_size
; 501  :              */
; 502  :             memmove(self->ob_bytes + lo + needed, self->ob_bytes + hi,
; 503  :                     Py_SIZE(self) - lo - needed);

  002e7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002ef	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR lo$[rsp]
  002f7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002fb	48 2b c1	 sub	 rax, rcx
  002fe	48 2b 84 24 80
	00 00 00	 sub	 rax, QWORD PTR needed$[rsp]
  00306	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0030e	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00315	48 03 8c 24 d0
	00 00 00	 add	 rcx, QWORD PTR hi$[rsp]
  0031d	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00325	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  0032c	48 03 94 24 c8
	00 00 00	 add	 rdx, QWORD PTR lo$[rsp]
  00334	48 03 94 24 80
	00 00 00	 add	 rdx, QWORD PTR needed$[rsp]
  0033c	48 89 94 24 a0
	00 00 00	 mov	 QWORD PTR tv156[rsp], rdx
  00344	4c 8b c0	 mov	 r8, rax
  00347	48 8b d1	 mov	 rdx, rcx
  0034a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv156[rsp]
  00352	48 8b c8	 mov	 rcx, rax
  00355	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN3@bytearray_@8:
$LN7@bytearray_@8:

; 504  :         }
; 505  :     }
; 506  : 
; 507  :     if (needed > 0)

  0035b	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR needed$[rsp], 0
  00364	7e 2c		 jle	 SHORT $LN2@bytearray_@8

; 508  :         memcpy(self->ob_bytes + lo, bytes, needed);

  00366	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0036e	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00375	48 03 84 24 c8
	00 00 00	 add	 rax, QWORD PTR lo$[rsp]
  0037d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR needed$[rsp]
  00385	48 8b 54 24 28	 mov	 rdx, QWORD PTR bytes$[rsp]
  0038a	48 8b c8	 mov	 rcx, rax
  0038d	e8 00 00 00 00	 call	 memcpy
$LN2@bytearray_@8:
$finish$20808:

; 509  : 
; 510  : 
; 511  :  finish:
; 512  :     if (vbytes.len != -1)

  00392	48 83 7c 24 40
	ff		 cmp	 QWORD PTR vbytes$[rsp+16], -1
  00398	74 0a		 je	 SHORT $LN1@bytearray_@8

; 513  :             PyBuffer_Release(&vbytes);

  0039a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vbytes$[rsp]
  0039f	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@8:

; 514  :     return res;

  003a4	8b 44 24 20	 mov	 eax, DWORD PTR res$[rsp]
$LN17@bytearray_@8:

; 515  : }

  003a8	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003af	c3		 ret	 0
bytearray_setslice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@MMHHEENM@attempt?5to?5assign?5bytes?5of?5size?5@ ; `string'
PUBLIC	??_C@_1DE@DJMCGLHN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0EG@MMMHLNMC@can?5assign?5only?5bytes?0?5buffers?0?5@ ; `string'
PUBLIC	??_C@_0CC@OJNNAELI@bytearray?5indices?5must?5be?5intege@ ; `string'
EXTRN	PyNumber_Check:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_ass_subscript DD imagerel bytearray_ass_subscript
	DD	imagerel bytearray_ass_subscript+2597
	DD	imagerel $unwind$bytearray_ass_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_ass_subscript DD 021601H
	DD	0170116H
xdata	ENDS
;	COMDAT ??_C@_0EC@MMHHEENM@attempt?5to?5assign?5bytes?5of?5size?5@
CONST	SEGMENT
??_C@_0EC@MMHHEENM@attempt?5to?5assign?5bytes?5of?5size?5@ DB 'attempt to'
	DB	' assign bytes of size %zd to extended slice of size %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@DJMCGLHN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@DJMCGLHN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'v', 00H, 'a', 00H
	DB	'l', 00H, 'u', 00H, 'e', 00H, 's', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@MMMHLNMC@can?5assign?5only?5bytes?0?5buffers?0?5@
CONST	SEGMENT
??_C@_0EG@MMMHLNMC@can?5assign?5only?5bytes?0?5buffers?0?5@ DB 'can assig'
	DB	'n only bytes, buffers, or iterables of ints in range(0, 256)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OJNNAELI@bytearray?5indices?5must?5be?5intege@
CONST	SEGMENT
??_C@_0CC@OJNNAELI@bytearray?5indices?5must?5be?5intege@ DB 'bytearray in'
	DB	'dices must be integer', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_ass_subscript
_TEXT	SEGMENT
step$ = 48
stop$ = 56
start$ = 64
bytes$ = 72
needed$ = 80
slicelen$ = 88
i$20852 = 96
ival$20865 = 104
err$20887 = 108
i$20919 = 112
cur$20918 = 120
lim$20926 = 128
i$20955 = 136
cur$20956 = 144
tv218 = 152
tv237 = 160
tv332 = 168
self$ = 192
index$ = 200
values$ = 208
bytearray_ass_subscript PROC				; COMDAT

; 542  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 543  :     Py_ssize_t start, stop, step, slicelen, needed;
; 544  :     char *bytes;
; 545  : 
; 546  :     if (PyIndex_Check(index)) {

  00016	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR index$[rsp]
  0001e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00022	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  0002a	0f 84 7d 01 00
	00		 je	 $LN46@bytearray_@9
  00030	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR index$[rsp]
  00038	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003c	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00043	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  0004b	0f 84 5c 01 00
	00		 je	 $LN46@bytearray_@9

; 547  :         Py_ssize_t i = PyNumber_AsSsize_t(index, PyExc_IndexError);

  00051	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00058	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR index$[rsp]
  00060	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00065	48 89 44 24 60	 mov	 QWORD PTR i$20852[rsp], rax

; 548  : 
; 549  :         if (i == -1 && PyErr_Occurred())

  0006a	48 83 7c 24 60
	ff		 cmp	 QWORD PTR i$20852[rsp], -1
  00070	75 14		 jne	 SHORT $LN45@bytearray_@9
  00072	e8 00 00 00 00	 call	 PyErr_Occurred
  00077	48 85 c0	 test	 rax, rax
  0007a	74 0a		 je	 SHORT $LN45@bytearray_@9

; 550  :             return -1;

  0007c	b8 ff ff ff ff	 mov	 eax, -1
  00081	e9 97 09 00 00	 jmp	 $LN47@bytearray_@9
$LN45@bytearray_@9:

; 551  : 
; 552  :         if (i < 0)

  00086	48 83 7c 24 60
	00		 cmp	 QWORD PTR i$20852[rsp], 0
  0008c	7d 69		 jge	 SHORT $LN44@bytearray_@9

; 553  :             i += PyByteArray_GET_SIZE(self);

  0008e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00095	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0009d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000a1	74 38		 je	 SHORT $LN49@bytearray_@9
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000aa	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000b2	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000b6	e8 00 00 00 00	 call	 PyType_IsSubtype
  000bb	85 c0		 test	 eax, eax
  000bd	75 1c		 jne	 SHORT $LN49@bytearray_@9
  000bf	41 b8 29 02 00
	00		 mov	 r8d, 553		; 00000229H
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d9	33 c0		 xor	 eax, eax
$LN49@bytearray_@9:
  000db	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000e3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR i$20852[rsp]
  000ec	48 03 c8	 add	 rcx, rax
  000ef	48 8b c1	 mov	 rax, rcx
  000f2	48 89 44 24 60	 mov	 QWORD PTR i$20852[rsp], rax
$LN44@bytearray_@9:

; 554  : 
; 555  :         if (i < 0 || i >= Py_SIZE(self)) {

  000f7	48 83 7c 24 60
	00		 cmp	 QWORD PTR i$20852[rsp], 0
  000fd	7c 13		 jl	 SHORT $LN42@bytearray_@9
  000ff	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00107	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0010b	48 39 44 24 60	 cmp	 QWORD PTR i$20852[rsp], rax
  00110	7c 1d		 jl	 SHORT $LN43@bytearray_@9
$LN42@bytearray_@9:

; 556  :             PyErr_SetString(PyExc_IndexError, "bytearray index out of range");

  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@
  00119	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00120	e8 00 00 00 00	 call	 PyErr_SetString

; 557  :             return -1;

  00125	b8 ff ff ff ff	 mov	 eax, -1
  0012a	e9 ee 08 00 00	 jmp	 $LN47@bytearray_@9
$LN43@bytearray_@9:

; 558  :         }
; 559  : 
; 560  :         if (values == NULL) {

  0012f	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR values$[rsp], 0
  00138	75 2b		 jne	 SHORT $LN41@bytearray_@9

; 561  :             /* Fall through to slice assignment */
; 562  :             start = i;

  0013a	48 8b 44 24 60	 mov	 rax, QWORD PTR i$20852[rsp]
  0013f	48 89 44 24 40	 mov	 QWORD PTR start$[rsp], rax

; 563  :             stop = i + 1;

  00144	48 8b 44 24 60	 mov	 rax, QWORD PTR i$20852[rsp]
  00149	48 ff c0	 inc	 rax
  0014c	48 89 44 24 38	 mov	 QWORD PTR stop$[rsp], rax

; 564  :             step = 1;

  00151	48 c7 44 24 30
	01 00 00 00	 mov	 QWORD PTR step$[rsp], 1

; 565  :             slicelen = 1;

  0015a	48 c7 44 24 58
	01 00 00 00	 mov	 QWORD PTR slicelen$[rsp], 1

; 566  :         }
; 567  :         else {

  00163	eb 43		 jmp	 SHORT $LN40@bytearray_@9
$LN41@bytearray_@9:

; 568  :             int ival;
; 569  :             if (!_getbytevalue(values, &ival))

  00165	48 8d 54 24 68	 lea	 rdx, QWORD PTR ival$20865[rsp]
  0016a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR values$[rsp]
  00172	e8 00 00 00 00	 call	 _getbytevalue
  00177	85 c0		 test	 eax, eax
  00179	75 0a		 jne	 SHORT $LN39@bytearray_@9

; 570  :                 return -1;

  0017b	b8 ff ff ff ff	 mov	 eax, -1
  00180	e9 98 08 00 00	 jmp	 $LN47@bytearray_@9
$LN39@bytearray_@9:

; 571  :             self->ob_bytes[i] = (char)ival;

  00185	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0018d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00194	48 8b 4c 24 60	 mov	 rcx, QWORD PTR i$20852[rsp]
  00199	0f b6 54 24 68	 movzx	 edx, BYTE PTR ival$20865[rsp]
  0019e	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 572  :             return 0;

  001a1	33 c0		 xor	 eax, eax
  001a3	e9 75 08 00 00	 jmp	 $LN47@bytearray_@9
$LN40@bytearray_@9:

; 573  :         }

  001a8	e9 ca 00 00 00	 jmp	 $LN38@bytearray_@9
$LN46@bytearray_@9:

; 574  :     }
; 575  :     else if (PySlice_Check(index)) {

  001ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  001b4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR index$[rsp]
  001bc	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001c0	0f 85 94 00 00
	00		 jne	 $LN37@bytearray_@9

; 576  :         if (PySlice_GetIndicesEx(index,
; 577  :                                  PyByteArray_GET_SIZE(self),
; 578  :                                  &start, &stop, &step, &slicelen) < 0) {

  001c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001cd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001d5	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001d9	74 38		 je	 SHORT $LN50@bytearray_@9
  001db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001e2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001ea	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001ee	e8 00 00 00 00	 call	 PyType_IsSubtype
  001f3	85 c0		 test	 eax, eax
  001f5	75 1c		 jne	 SHORT $LN50@bytearray_@9
  001f7	41 b8 41 02 00
	00		 mov	 r8d, 577		; 00000241H
  001fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00204	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0020b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00211	33 c0		 xor	 eax, eax
$LN50@bytearray_@9:
  00213	48 8d 44 24 58	 lea	 rax, QWORD PTR slicelen$[rsp]
  00218	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0021d	48 8d 44 24 30	 lea	 rax, QWORD PTR step$[rsp]
  00222	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00227	4c 8d 4c 24 38	 lea	 r9, QWORD PTR stop$[rsp]
  0022c	4c 8d 44 24 40	 lea	 r8, QWORD PTR start$[rsp]
  00231	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00239	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0023d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR index$[rsp]
  00245	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  0024a	85 c0		 test	 eax, eax
  0024c	7d 0a		 jge	 SHORT $LN36@bytearray_@9

; 579  :             return -1;

  0024e	b8 ff ff ff ff	 mov	 eax, -1
  00253	e9 c5 07 00 00	 jmp	 $LN47@bytearray_@9
$LN36@bytearray_@9:

; 580  :         }
; 581  :     }
; 582  :     else {

  00258	eb 1d		 jmp	 SHORT $LN35@bytearray_@9
$LN37@bytearray_@9:

; 583  :         PyErr_SetString(PyExc_TypeError, "bytearray indices must be integer");

  0025a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@OJNNAELI@bytearray?5indices?5must?5be?5intege@
  00261	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00268	e8 00 00 00 00	 call	 PyErr_SetString

; 584  :         return -1;

  0026d	b8 ff ff ff ff	 mov	 eax, -1
  00272	e9 a6 07 00 00	 jmp	 $LN47@bytearray_@9
$LN35@bytearray_@9:
$LN38@bytearray_@9:

; 585  :     }
; 586  : 
; 587  :     if (values == NULL) {

  00277	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR values$[rsp], 0
  00280	75 17		 jne	 SHORT $LN34@bytearray_@9

; 588  :         bytes = NULL;

  00282	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR bytes$[rsp], 0

; 589  :         needed = 0;

  0028b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR needed$[rsp], 0
  00294	e9 69 01 00 00	 jmp	 $LN33@bytearray_@9
$LN34@bytearray_@9:

; 590  :     }
; 591  :     else if (values == (PyObject *)self || !PyByteArray_Check(values)) {

  00299	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002a1	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR values$[rsp], rax
  002a9	74 39		 je	 SHORT $LN31@bytearray_@9
  002ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  002b2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR values$[rsp]
  002ba	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  002be	0f 84 cc 00 00
	00		 je	 $LN32@bytearray_@9
  002c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  002cb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR values$[rsp]
  002d3	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  002d7	e8 00 00 00 00	 call	 PyType_IsSubtype
  002dc	85 c0		 test	 eax, eax
  002de	0f 85 ac 00 00
	00		 jne	 $LN32@bytearray_@9
$LN31@bytearray_@9:

; 592  :         int err;
; 593  :         if (PyNumber_Check(values) || PyUnicode_Check(values)) {

  002e4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR values$[rsp]
  002ec	e8 00 00 00 00	 call	 PyNumber_Check
  002f1	85 c0		 test	 eax, eax
  002f3	75 1b		 jne	 SHORT $LN29@bytearray_@9
  002f5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR values$[rsp]
  002fd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00301	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00307	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0030c	85 c0		 test	 eax, eax
  0030e	74 1d		 je	 SHORT $LN30@bytearray_@9
$LN29@bytearray_@9:

; 594  :             PyErr_SetString(PyExc_TypeError,
; 595  :                             "can assign only bytes, buffers, or iterables "
; 596  :                             "of ints in range(0, 256)");

  00310	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@MMMHLNMC@can?5assign?5only?5bytes?0?5buffers?0?5@
  00317	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0031e	e8 00 00 00 00	 call	 PyErr_SetString

; 597  :             return -1;

  00323	b8 ff ff ff ff	 mov	 eax, -1
  00328	e9 f0 06 00 00	 jmp	 $LN47@bytearray_@9
$LN30@bytearray_@9:

; 598  :         }
; 599  :         /* Make a copy and call this function recursively */
; 600  :         values = PyByteArray_FromObject(values);

  0032d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR values$[rsp]
  00335	e8 00 00 00 00	 call	 PyByteArray_FromObject
  0033a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR values$[rsp], rax

; 601  :         if (values == NULL)

  00342	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR values$[rsp], 0
  0034b	75 0a		 jne	 SHORT $LN28@bytearray_@9

; 602  :             return -1;

  0034d	b8 ff ff ff ff	 mov	 eax, -1
  00352	e9 c6 06 00 00	 jmp	 $LN47@bytearray_@9
$LN28@bytearray_@9:

; 603  :         err = bytearray_ass_subscript(self, index, values);

  00357	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR values$[rsp]
  0035f	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR index$[rsp]
  00367	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0036f	e8 00 00 00 00	 call	 bytearray_ass_subscript
  00374	89 44 24 6c	 mov	 DWORD PTR err$20887[rsp], eax

; 604  :         Py_DECREF(values);

  00378	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR values$[rsp]
  00380	e8 00 00 00 00	 call	 _Py_DecRef

; 605  :         return err;

  00385	8b 44 24 6c	 mov	 eax, DWORD PTR err$20887[rsp]
  00389	e9 8f 06 00 00	 jmp	 $LN47@bytearray_@9

; 606  :     }
; 607  :     else {

  0038e	eb 72		 jmp	 SHORT $LN27@bytearray_@9
$LN32@bytearray_@9:

; 608  :         assert(PyByteArray_Check(values));

  00390	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00397	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR values$[rsp]
  0039f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  003a3	74 38		 je	 SHORT $LN51@bytearray_@9
  003a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  003ac	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR values$[rsp]
  003b4	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  003b8	e8 00 00 00 00	 call	 PyType_IsSubtype
  003bd	85 c0		 test	 eax, eax
  003bf	75 1c		 jne	 SHORT $LN51@bytearray_@9
  003c1	41 b8 60 02 00
	00		 mov	 r8d, 608		; 00000260H
  003c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@DJMCGLHN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  003d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003db	33 c0		 xor	 eax, eax
$LN51@bytearray_@9:

; 609  :         bytes = ((PyByteArrayObject *)values)->ob_bytes;

  003dd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR values$[rsp]
  003e5	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  003ec	48 89 44 24 48	 mov	 QWORD PTR bytes$[rsp], rax

; 610  :         needed = Py_SIZE(values);

  003f1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR values$[rsp]
  003f9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  003fd	48 89 44 24 50	 mov	 QWORD PTR needed$[rsp], rax
$LN27@bytearray_@9:
$LN33@bytearray_@9:

; 611  :     }
; 612  :     /* Make sure b[5:2] = ... inserts before 5, not before 2. */
; 613  :     if ((step < 0 && start < stop) ||
; 614  :         (step > 0 && start > stop))

  00402	48 83 7c 24 30
	00		 cmp	 QWORD PTR step$[rsp], 0
  00408	7d 0c		 jge	 SHORT $LN24@bytearray_@9
  0040a	48 8b 44 24 38	 mov	 rax, QWORD PTR stop$[rsp]
  0040f	48 39 44 24 40	 cmp	 QWORD PTR start$[rsp], rax
  00414	7c 14		 jl	 SHORT $LN25@bytearray_@9
$LN24@bytearray_@9:
  00416	48 83 7c 24 30
	00		 cmp	 QWORD PTR step$[rsp], 0
  0041c	7e 16		 jle	 SHORT $LN26@bytearray_@9
  0041e	48 8b 44 24 38	 mov	 rax, QWORD PTR stop$[rsp]
  00423	48 39 44 24 40	 cmp	 QWORD PTR start$[rsp], rax
  00428	7e 0a		 jle	 SHORT $LN26@bytearray_@9
$LN25@bytearray_@9:

; 615  :         stop = start;

  0042a	48 8b 44 24 40	 mov	 rax, QWORD PTR start$[rsp]
  0042f	48 89 44 24 38	 mov	 QWORD PTR stop$[rsp], rax
$LN26@bytearray_@9:

; 616  :     if (step == 1) {

  00434	48 83 7c 24 30
	01		 cmp	 QWORD PTR step$[rsp], 1
  0043a	0f 85 76 01 00
	00		 jne	 $LN23@bytearray_@9

; 617  :         if (slicelen != needed) {

  00440	48 8b 44 24 50	 mov	 rax, QWORD PTR needed$[rsp]
  00445	48 39 44 24 58	 cmp	 QWORD PTR slicelen$[rsp], rax
  0044a	0f 84 2c 01 00
	00		 je	 $LN22@bytearray_@9

; 618  :             if (!_canresize(self))

  00450	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00458	e8 00 00 00 00	 call	 _canresize
  0045d	85 c0		 test	 eax, eax
  0045f	75 0a		 jne	 SHORT $LN21@bytearray_@9

; 619  :                 return -1;

  00461	b8 ff ff ff ff	 mov	 eax, -1
  00466	e9 b2 05 00 00	 jmp	 $LN47@bytearray_@9
$LN21@bytearray_@9:

; 620  :             if (slicelen > needed) {

  0046b	48 8b 44 24 50	 mov	 rax, QWORD PTR needed$[rsp]
  00470	48 39 44 24 58	 cmp	 QWORD PTR slicelen$[rsp], rax
  00475	7e 60		 jle	 SHORT $LN20@bytearray_@9

; 621  :                 /*
; 622  :                   0   start           stop              old_size
; 623  :                   |   |<---slicelen--->|<-----tomove------>|
; 624  :                   |   |<-needed->|<-----tomove------>|
; 625  :                   0   lo      new_hi              new_size
; 626  :                 */
; 627  :                 memmove(self->ob_bytes + start + needed, self->ob_bytes + stop,
; 628  :                         Py_SIZE(self) - stop);

  00477	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0047f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stop$[rsp]
  00484	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00488	48 2b c1	 sub	 rax, rcx
  0048b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00493	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0049a	48 03 4c 24 38	 add	 rcx, QWORD PTR stop$[rsp]
  0049f	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  004a7	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  004ae	48 03 54 24 40	 add	 rdx, QWORD PTR start$[rsp]
  004b3	48 03 54 24 50	 add	 rdx, QWORD PTR needed$[rsp]
  004b8	48 89 94 24 98
	00 00 00	 mov	 QWORD PTR tv218[rsp], rdx
  004c0	4c 8b c0	 mov	 r8, rax
  004c3	48 8b d1	 mov	 rdx, rcx
  004c6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv218[rsp]
  004ce	48 8b c8	 mov	 rcx, rax
  004d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN20@bytearray_@9:

; 629  :             }
; 630  :             if (PyByteArray_Resize((PyObject *)self,
; 631  :                                Py_SIZE(self) + needed - slicelen) < 0)

  004d7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  004df	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  004e3	48 03 44 24 50	 add	 rax, QWORD PTR needed$[rsp]
  004e8	48 2b 44 24 58	 sub	 rax, QWORD PTR slicelen$[rsp]
  004ed	48 8b d0	 mov	 rdx, rax
  004f0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  004f8	e8 00 00 00 00	 call	 PyByteArray_Resize
  004fd	85 c0		 test	 eax, eax
  004ff	7d 0a		 jge	 SHORT $LN19@bytearray_@9

; 632  :                 return -1;

  00501	b8 ff ff ff ff	 mov	 eax, -1
  00506	e9 12 05 00 00	 jmp	 $LN47@bytearray_@9
$LN19@bytearray_@9:

; 633  :             if (slicelen < needed) {

  0050b	48 8b 44 24 50	 mov	 rax, QWORD PTR needed$[rsp]
  00510	48 39 44 24 58	 cmp	 QWORD PTR slicelen$[rsp], rax
  00515	7d 65		 jge	 SHORT $LN18@bytearray_@9

; 634  :                 /*
; 635  :                   0   lo        hi               old_size
; 636  :                   |   |<-avail->|<-----tomove------>|
; 637  :                   |   |<----needed---->|<-----tomove------>|
; 638  :                   0   lo            new_hi              new_size
; 639  :                  */
; 640  :                 memmove(self->ob_bytes + start + needed, self->ob_bytes + stop,
; 641  :                         Py_SIZE(self) - start - needed);

  00517	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0051f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR start$[rsp]
  00524	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00528	48 2b c1	 sub	 rax, rcx
  0052b	48 2b 44 24 50	 sub	 rax, QWORD PTR needed$[rsp]
  00530	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00538	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0053f	48 03 4c 24 38	 add	 rcx, QWORD PTR stop$[rsp]
  00544	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  0054c	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00553	48 03 54 24 40	 add	 rdx, QWORD PTR start$[rsp]
  00558	48 03 54 24 50	 add	 rdx, QWORD PTR needed$[rsp]
  0055d	48 89 94 24 a0
	00 00 00	 mov	 QWORD PTR tv237[rsp], rdx
  00565	4c 8b c0	 mov	 r8, rax
  00568	48 8b d1	 mov	 rdx, rcx
  0056b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv237[rsp]
  00573	48 8b c8	 mov	 rcx, rax
  00576	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN18@bytearray_@9:
$LN22@bytearray_@9:

; 642  :             }
; 643  :         }
; 644  : 
; 645  :         if (needed > 0)

  0057c	48 83 7c 24 50
	00		 cmp	 QWORD PTR needed$[rsp], 0
  00582	7e 26		 jle	 SHORT $LN17@bytearray_@9

; 646  :             memcpy(self->ob_bytes + start, bytes, needed);

  00584	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0058c	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00593	48 03 44 24 40	 add	 rax, QWORD PTR start$[rsp]
  00598	4c 8b 44 24 50	 mov	 r8, QWORD PTR needed$[rsp]
  0059d	48 8b 54 24 48	 mov	 rdx, QWORD PTR bytes$[rsp]
  005a2	48 8b c8	 mov	 rcx, rax
  005a5	e8 00 00 00 00	 call	 memcpy
$LN17@bytearray_@9:

; 647  : 
; 648  :         return 0;

  005aa	33 c0		 xor	 eax, eax
  005ac	e9 6c 04 00 00	 jmp	 $LN47@bytearray_@9

; 649  :     }
; 650  :     else {

  005b1	e9 67 04 00 00	 jmp	 $LN16@bytearray_@9
$LN23@bytearray_@9:

; 651  :         if (needed == 0) {

  005b6	48 83 7c 24 50
	00		 cmp	 QWORD PTR needed$[rsp], 0
  005bc	0f 85 9c 03 00
	00		 jne	 $LN15@bytearray_@9

; 652  :             /* Delete slice */
; 653  :             size_t cur;
; 654  :             Py_ssize_t i;
; 655  : 
; 656  :             if (!_canresize(self))

  005c2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  005ca	e8 00 00 00 00	 call	 _canresize
  005cf	85 c0		 test	 eax, eax
  005d1	75 0a		 jne	 SHORT $LN14@bytearray_@9

; 657  :                 return -1;

  005d3	b8 ff ff ff ff	 mov	 eax, -1
  005d8	e9 40 04 00 00	 jmp	 $LN47@bytearray_@9
$LN14@bytearray_@9:

; 658  : 
; 659  :             if (slicelen == 0)

  005dd	48 83 7c 24 58
	00		 cmp	 QWORD PTR slicelen$[rsp], 0
  005e3	75 07		 jne	 SHORT $LN13@bytearray_@9

; 660  :                 /* Nothing to do here. */
; 661  :                 return 0;

  005e5	33 c0		 xor	 eax, eax
  005e7	e9 31 04 00 00	 jmp	 $LN47@bytearray_@9
$LN13@bytearray_@9:

; 662  : 
; 663  :             if (step < 0) {

  005ec	48 83 7c 24 30
	00		 cmp	 QWORD PTR step$[rsp], 0
  005f2	7d 3d		 jge	 SHORT $LN12@bytearray_@9

; 664  :                 stop = start + 1;

  005f4	48 8b 44 24 40	 mov	 rax, QWORD PTR start$[rsp]
  005f9	48 ff c0	 inc	 rax
  005fc	48 89 44 24 38	 mov	 QWORD PTR stop$[rsp], rax

; 665  :                 start = stop + step * (slicelen - 1) - 1;

  00601	48 8b 44 24 58	 mov	 rax, QWORD PTR slicelen$[rsp]
  00606	48 ff c8	 dec	 rax
  00609	48 8b 4c 24 30	 mov	 rcx, QWORD PTR step$[rsp]
  0060e	48 0f af c8	 imul	 rcx, rax
  00612	48 8b c1	 mov	 rax, rcx
  00615	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stop$[rsp]
  0061a	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0061f	48 89 44 24 40	 mov	 QWORD PTR start$[rsp], rax

; 666  :                 step = -step;

  00624	48 8b 44 24 30	 mov	 rax, QWORD PTR step$[rsp]
  00629	48 f7 d8	 neg	 rax
  0062c	48 89 44 24 30	 mov	 QWORD PTR step$[rsp], rax
$LN12@bytearray_@9:

; 667  :             }
; 668  :             for (cur = start, i = 0;
; 669  :                  i < slicelen; cur += step, i++) {

  00631	48 8b 44 24 40	 mov	 rax, QWORD PTR start$[rsp]
  00636	48 89 44 24 78	 mov	 QWORD PTR cur$20918[rsp], rax
  0063b	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR i$20919[rsp], 0
  00644	eb 22		 jmp	 SHORT $LN11@bytearray_@9
$LN10@bytearray_@9:
  00646	48 8b 44 24 30	 mov	 rax, QWORD PTR step$[rsp]
  0064b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cur$20918[rsp]
  00650	48 03 c8	 add	 rcx, rax
  00653	48 8b c1	 mov	 rax, rcx
  00656	48 89 44 24 78	 mov	 QWORD PTR cur$20918[rsp], rax
  0065b	48 8b 44 24 70	 mov	 rax, QWORD PTR i$20919[rsp]
  00660	48 ff c0	 inc	 rax
  00663	48 89 44 24 70	 mov	 QWORD PTR i$20919[rsp], rax
$LN11@bytearray_@9:
  00668	48 8b 44 24 58	 mov	 rax, QWORD PTR slicelen$[rsp]
  0066d	48 39 44 24 70	 cmp	 QWORD PTR i$20919[rsp], rax
  00672	0f 8d 2f 01 00
	00		 jge	 $LN9@bytearray_@9

; 670  :                 Py_ssize_t lim = step - 1;

  00678	48 8b 44 24 30	 mov	 rax, QWORD PTR step$[rsp]
  0067d	48 ff c8	 dec	 rax
  00680	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR lim$20926[rsp], rax

; 671  : 
; 672  :                 if (cur + step >= (size_t)PyByteArray_GET_SIZE(self))

  00688	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0068f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00697	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0069b	74 38		 je	 SHORT $LN52@bytearray_@9
  0069d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  006a4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  006ac	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  006b0	e8 00 00 00 00	 call	 PyType_IsSubtype
  006b5	85 c0		 test	 eax, eax
  006b7	75 1c		 jne	 SHORT $LN52@bytearray_@9
  006b9	41 b8 a0 02 00
	00		 mov	 r8d, 672		; 000002a0H
  006bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  006c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  006cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006d3	33 c0		 xor	 eax, eax
$LN52@bytearray_@9:
  006d5	48 8b 44 24 30	 mov	 rax, QWORD PTR step$[rsp]
  006da	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cur$20918[rsp]
  006df	48 03 c8	 add	 rcx, rax
  006e2	48 8b c1	 mov	 rax, rcx
  006e5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  006ed	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  006f1	72 6c		 jb	 SHORT $LN8@bytearray_@9

; 673  :                     lim = PyByteArray_GET_SIZE(self) - cur - 1;

  006f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  006fa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00702	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00706	74 38		 je	 SHORT $LN53@bytearray_@9
  00708	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0070f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00717	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0071b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00720	85 c0		 test	 eax, eax
  00722	75 1c		 jne	 SHORT $LN53@bytearray_@9
  00724	41 b8 a1 02 00
	00		 mov	 r8d, 673		; 000002a1H
  0072a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00731	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00738	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0073e	33 c0		 xor	 eax, eax
$LN53@bytearray_@9:
  00740	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00748	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cur$20918[rsp]
  0074d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00751	48 2b c1	 sub	 rax, rcx
  00754	48 ff c8	 dec	 rax
  00757	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR lim$20926[rsp], rax
$LN8@bytearray_@9:

; 674  : 
; 675  :                 memmove(self->ob_bytes + cur - i,
; 676  :                         self->ob_bytes + cur + 1, lim);

  0075f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00767	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0076e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cur$20918[rsp]
  00773	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  00778	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00780	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00787	48 03 4c 24 78	 add	 rcx, QWORD PTR cur$20918[rsp]
  0078c	48 2b 4c 24 70	 sub	 rcx, QWORD PTR i$20919[rsp]
  00791	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR lim$20926[rsp]
  00799	48 8b d0	 mov	 rdx, rax
  0079c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 677  :             }

  007a2	e9 9f fe ff ff	 jmp	 $LN10@bytearray_@9
$LN9@bytearray_@9:

; 678  :             /* Move the tail of the bytes, in one chunk */
; 679  :             cur = start + (size_t)slicelen*step;

  007a7	48 8b 44 24 58	 mov	 rax, QWORD PTR slicelen$[rsp]
  007ac	48 0f af 44 24
	30		 imul	 rax, QWORD PTR step$[rsp]
  007b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR start$[rsp]
  007b7	48 03 c8	 add	 rcx, rax
  007ba	48 8b c1	 mov	 rax, rcx
  007bd	48 89 44 24 78	 mov	 QWORD PTR cur$20918[rsp], rax

; 680  :             if (cur < (size_t)PyByteArray_GET_SIZE(self)) {

  007c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  007c9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  007d1	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  007d5	74 38		 je	 SHORT $LN54@bytearray_@9
  007d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  007de	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  007e6	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  007ea	e8 00 00 00 00	 call	 PyType_IsSubtype
  007ef	85 c0		 test	 eax, eax
  007f1	75 1c		 jne	 SHORT $LN54@bytearray_@9
  007f3	41 b8 a8 02 00
	00		 mov	 r8d, 680		; 000002a8H
  007f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00800	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00807	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0080d	33 c0		 xor	 eax, eax
$LN54@bytearray_@9:
  0080f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00817	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0081b	48 39 44 24 78	 cmp	 QWORD PTR cur$20918[rsp], rax
  00820	0f 83 ad 00 00
	00		 jae	 $LN7@bytearray_@9

; 681  :                 memmove(self->ob_bytes + cur - slicelen,
; 682  :                         self->ob_bytes + cur,
; 683  :                         PyByteArray_GET_SIZE(self) - cur);

  00826	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0082d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00835	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00839	74 38		 je	 SHORT $LN55@bytearray_@9
  0083b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00842	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0084a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0084e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00853	85 c0		 test	 eax, eax
  00855	75 1c		 jne	 SHORT $LN55@bytearray_@9
  00857	41 b8 ab 02 00
	00		 mov	 r8d, 683		; 000002abH
  0085d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00864	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0086b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00871	33 c0		 xor	 eax, eax
$LN55@bytearray_@9:
  00873	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0087b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cur$20918[rsp]
  00880	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00884	48 2b c1	 sub	 rax, rcx
  00887	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0088f	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00896	48 03 4c 24 78	 add	 rcx, QWORD PTR cur$20918[rsp]
  0089b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  008a3	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  008aa	48 03 54 24 78	 add	 rdx, QWORD PTR cur$20918[rsp]
  008af	48 2b 54 24 58	 sub	 rdx, QWORD PTR slicelen$[rsp]
  008b4	48 89 94 24 a8
	00 00 00	 mov	 QWORD PTR tv332[rsp], rdx
  008bc	4c 8b c0	 mov	 r8, rax
  008bf	48 8b d1	 mov	 rdx, rcx
  008c2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv332[rsp]
  008ca	48 8b c8	 mov	 rcx, rax
  008cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN7@bytearray_@9:

; 684  :             }
; 685  :             if (PyByteArray_Resize((PyObject *)self,
; 686  :                                PyByteArray_GET_SIZE(self) - slicelen) < 0)

  008d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  008da	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  008e2	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  008e6	74 38		 je	 SHORT $LN56@bytearray_@9
  008e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  008ef	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  008f7	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  008fb	e8 00 00 00 00	 call	 PyType_IsSubtype
  00900	85 c0		 test	 eax, eax
  00902	75 1c		 jne	 SHORT $LN56@bytearray_@9
  00904	41 b8 ae 02 00
	00		 mov	 r8d, 686		; 000002aeH
  0090a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00911	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00918	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0091e	33 c0		 xor	 eax, eax
$LN56@bytearray_@9:
  00920	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00928	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slicelen$[rsp]
  0092d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00931	48 2b c1	 sub	 rax, rcx
  00934	48 8b d0	 mov	 rdx, rax
  00937	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0093f	e8 00 00 00 00	 call	 PyByteArray_Resize
  00944	85 c0		 test	 eax, eax
  00946	7d 0a		 jge	 SHORT $LN6@bytearray_@9

; 687  :                 return -1;

  00948	b8 ff ff ff ff	 mov	 eax, -1
  0094d	e9 cb 00 00 00	 jmp	 $LN47@bytearray_@9
$LN6@bytearray_@9:

; 688  : 
; 689  :             return 0;

  00952	33 c0		 xor	 eax, eax
  00954	e9 c4 00 00 00	 jmp	 $LN47@bytearray_@9

; 690  :         }
; 691  :         else {

  00959	e9 bf 00 00 00	 jmp	 $LN5@bytearray_@9
$LN15@bytearray_@9:

; 692  :             /* Assign slice */
; 693  :             Py_ssize_t i;
; 694  :             size_t cur;
; 695  : 
; 696  :             if (needed != slicelen) {

  0095e	48 8b 44 24 58	 mov	 rax, QWORD PTR slicelen$[rsp]
  00963	48 39 44 24 50	 cmp	 QWORD PTR needed$[rsp], rax
  00968	74 27		 je	 SHORT $LN4@bytearray_@9

; 697  :                 PyErr_Format(PyExc_ValueError,
; 698  :                              "attempt to assign bytes of size %zd "
; 699  :                              "to extended slice of size %zd",
; 700  :                              needed, slicelen);

  0096a	4c 8b 4c 24 58	 mov	 r9, QWORD PTR slicelen$[rsp]
  0096f	4c 8b 44 24 50	 mov	 r8, QWORD PTR needed$[rsp]
  00974	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@MMHHEENM@attempt?5to?5assign?5bytes?5of?5size?5@
  0097b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00982	e8 00 00 00 00	 call	 PyErr_Format

; 701  :                 return -1;

  00987	b8 ff ff ff ff	 mov	 eax, -1
  0098c	e9 8c 00 00 00	 jmp	 $LN47@bytearray_@9
$LN4@bytearray_@9:

; 702  :             }
; 703  :             for (cur = start, i = 0; i < slicelen; cur += step, i++)

  00991	48 8b 44 24 40	 mov	 rax, QWORD PTR start$[rsp]
  00996	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cur$20956[rsp], rax
  0099e	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$20955[rsp], 0
  009aa	eb 2e		 jmp	 SHORT $LN3@bytearray_@9
$LN2@bytearray_@9:
  009ac	48 8b 44 24 30	 mov	 rax, QWORD PTR step$[rsp]
  009b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cur$20956[rsp]
  009b9	48 03 c8	 add	 rcx, rax
  009bc	48 8b c1	 mov	 rax, rcx
  009bf	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cur$20956[rsp], rax
  009c7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR i$20955[rsp]
  009cf	48 ff c0	 inc	 rax
  009d2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR i$20955[rsp], rax
$LN3@bytearray_@9:
  009da	48 8b 44 24 58	 mov	 rax, QWORD PTR slicelen$[rsp]
  009df	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR i$20955[rsp], rax
  009e7	7d 32		 jge	 SHORT $LN1@bytearray_@9

; 704  :                 self->ob_bytes[cur] = bytes[i];

  009e9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  009f1	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  009f8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR i$20955[rsp]
  00a00	48 8b 54 24 48	 mov	 rdx, QWORD PTR bytes$[rsp]
  00a05	48 03 d1	 add	 rdx, rcx
  00a08	48 8b ca	 mov	 rcx, rdx
  00a0b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR cur$20956[rsp]
  00a13	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00a16	88 0c 10	 mov	 BYTE PTR [rax+rdx], cl
  00a19	eb 91		 jmp	 SHORT $LN2@bytearray_@9
$LN1@bytearray_@9:

; 705  :             return 0;

  00a1b	33 c0		 xor	 eax, eax
$LN5@bytearray_@9:
$LN16@bytearray_@9:
$LN47@bytearray_@9:

; 706  :         }
; 707  :     }
; 708  : }

  00a1d	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00a24	c3		 ret	 0
bytearray_ass_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@DIJHAIGC@negative?5count?$AA@		; `string'
PUBLIC	??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@ ; `string'
PUBLIC	??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@ ; `string'
PUBLIC	??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@ ; `string'
PUBLIC	??_C@_0P@KMGFKFIF@?$HMOss?3bytearray?$AA@	; `string'
EXTRN	PyExc_StopIteration:QWORD
EXTRN	PyObject_GetIter:PROC
EXTRN	PyBuffer_ToContiguous:PROC
EXTRN	PyObject_GetBuffer:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyUnicode_AsEncodedString:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_init DD imagerel bytearray_init
	DD	imagerel bytearray_init+1261
	DD	imagerel $unwind$bytearray_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_init DD 021601H
	DD	01f0116H
xdata	ENDS
;	COMDAT ??_C@_0P@DIJHAIGC@negative?5count?$AA@
CONST	SEGMENT
??_C@_0P@DIJHAIGC@negative?5count?$AA@ DB 'negative count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@
CONST	SEGMENT
??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@ DB 'encoding or'
	DB	' errors without a string argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'd', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@
CONST	SEGMENT
??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@ DB 'string argum'
	DB	'ent without an encoding', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@
CONST	SEGMENT
??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@ DB 'encoding or '
	DB	'errors without sequence argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KMGFKFIF@?$HMOss?3bytearray?$AA@
CONST	SEGMENT
??_C@_0P@KMGFKFIF@?$HMOss?3bytearray?$AA@ DB '|Oss:bytearray', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_init
_TEXT	SEGMENT
it$ = 64
count$ = 72
iternext$ = 80
arg$ = 88
errors$ = 96
encoding$ = 104
encoded$21000 = 112
new$21001 = 120
size$21031 = 128
view$21032 = 144
value$21046 = 224
rc$21045 = 228
item$21044 = 232
self$ = 256
args$ = 264
kwds$ = 272
bytearray_init PROC					; COMDAT

; 712  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 713  :     static char *kwlist[] = {"source", "encoding", "errors", 0};
; 714  :     PyObject *arg = NULL;

  00016	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR arg$[rsp], 0

; 715  :     const char *encoding = NULL;

  0001f	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR encoding$[rsp], 0

; 716  :     const char *errors = NULL;

  00028	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR errors$[rsp], 0

; 717  :     Py_ssize_t count;
; 718  :     PyObject *it;
; 719  :     PyObject *(*iternext)(PyObject *);
; 720  : 
; 721  :     if (Py_SIZE(self) != 0) {

  00031	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00039	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0003e	74 1d		 je	 SHORT $LN33@bytearray_@10

; 722  :         /* Empty previous contents (yes, do this first of all!) */
; 723  :         if (PyByteArray_Resize((PyObject *)self, 0) < 0)

  00040	33 d2		 xor	 edx, edx
  00042	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0004a	e8 00 00 00 00	 call	 PyByteArray_Resize
  0004f	85 c0		 test	 eax, eax
  00051	7d 0a		 jge	 SHORT $LN32@bytearray_@10

; 724  :             return -1;

  00053	b8 ff ff ff ff	 mov	 eax, -1
  00058	e9 88 04 00 00	 jmp	 $LN34@bytearray_@10
$LN32@bytearray_@10:
$LN33@bytearray_@10:

; 725  :     }
; 726  : 
; 727  :     /* Parse arguments */
; 728  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|Oss:bytearray", kwlist,
; 729  :                                      &arg, &encoding, &errors))

  0005d	48 8d 44 24 60	 lea	 rax, QWORD PTR errors$[rsp]
  00062	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00067	48 8d 44 24 68	 lea	 rax, QWORD PTR encoding$[rsp]
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	48 8d 44 24 58	 lea	 rax, QWORD PTR arg$[rsp]
  00076	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytearray_init@@9@9
  00082	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@KMGFKFIF@?$HMOss?3bytearray?$AA@
  00089	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00091	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00099	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0009e	85 c0		 test	 eax, eax
  000a0	75 0a		 jne	 SHORT $LN31@bytearray_@10

; 730  :         return -1;

  000a2	b8 ff ff ff ff	 mov	 eax, -1
  000a7	e9 39 04 00 00	 jmp	 $LN34@bytearray_@10
$LN31@bytearray_@10:

; 731  : 
; 732  :     /* Make a quick exit if no first argument */
; 733  :     if (arg == NULL) {

  000ac	48 83 7c 24 58
	00		 cmp	 QWORD PTR arg$[rsp], 0
  000b2	75 34		 jne	 SHORT $LN30@bytearray_@10

; 734  :         if (encoding != NULL || errors != NULL) {

  000b4	48 83 7c 24 68
	00		 cmp	 QWORD PTR encoding$[rsp], 0
  000ba	75 08		 jne	 SHORT $LN28@bytearray_@10
  000bc	48 83 7c 24 60
	00		 cmp	 QWORD PTR errors$[rsp], 0
  000c2	74 1d		 je	 SHORT $LN29@bytearray_@10
$LN28@bytearray_@10:

; 735  :             PyErr_SetString(PyExc_TypeError,
; 736  :                             "encoding or errors without sequence argument");

  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@
  000cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d2	e8 00 00 00 00	 call	 PyErr_SetString

; 737  :             return -1;

  000d7	b8 ff ff ff ff	 mov	 eax, -1
  000dc	e9 04 04 00 00	 jmp	 $LN34@bytearray_@10
$LN29@bytearray_@10:

; 738  :         }
; 739  :         return 0;

  000e1	33 c0		 xor	 eax, eax
  000e3	e9 fd 03 00 00	 jmp	 $LN34@bytearray_@10
$LN30@bytearray_@10:

; 740  :     }
; 741  : 
; 742  :     if (PyUnicode_Check(arg)) {

  000e8	48 8b 44 24 58	 mov	 rax, QWORD PTR arg$[rsp]
  000ed	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f7	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000fc	85 c0		 test	 eax, eax
  000fe	0f 84 c8 00 00
	00		 je	 $LN27@bytearray_@10

; 743  :         /* Encode via the codec registry */
; 744  :         PyObject *encoded, *new;
; 745  :         if (encoding == NULL) {

  00104	48 83 7c 24 68
	00		 cmp	 QWORD PTR encoding$[rsp], 0
  0010a	75 1d		 jne	 SHORT $LN26@bytearray_@10

; 746  :             PyErr_SetString(PyExc_TypeError,
; 747  :                             "string argument without an encoding");

  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@
  00113	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0011a	e8 00 00 00 00	 call	 PyErr_SetString

; 748  :             return -1;

  0011f	b8 ff ff ff ff	 mov	 eax, -1
  00124	e9 bc 03 00 00	 jmp	 $LN34@bytearray_@10
$LN26@bytearray_@10:

; 749  :         }
; 750  :         encoded = PyUnicode_AsEncodedString(arg, encoding, errors);

  00129	4c 8b 44 24 60	 mov	 r8, QWORD PTR errors$[rsp]
  0012e	48 8b 54 24 68	 mov	 rdx, QWORD PTR encoding$[rsp]
  00133	48 8b 4c 24 58	 mov	 rcx, QWORD PTR arg$[rsp]
  00138	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString
  0013d	48 89 44 24 70	 mov	 QWORD PTR encoded$21000[rsp], rax

; 751  :         if (encoded == NULL)

  00142	48 83 7c 24 70
	00		 cmp	 QWORD PTR encoded$21000[rsp], 0
  00148	75 0a		 jne	 SHORT $LN25@bytearray_@10

; 752  :             return -1;

  0014a	b8 ff ff ff ff	 mov	 eax, -1
  0014f	e9 91 03 00 00	 jmp	 $LN34@bytearray_@10
$LN25@bytearray_@10:

; 753  :         assert(PyBytes_Check(encoded));

  00154	48 8b 44 24 70	 mov	 rax, QWORD PTR encoded$21000[rsp]
  00159	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0015d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00163	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00168	85 c0		 test	 eax, eax
  0016a	75 1c		 jne	 SHORT $LN36@bytearray_@10
  0016c	41 b8 f1 02 00
	00		 mov	 r8d, 753		; 000002f1H
  00172	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HFMJJPBH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAd?$AA?$CJ?$AA?$AA@
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00186	33 c0		 xor	 eax, eax
$LN36@bytearray_@10:

; 754  :         new = bytearray_iconcat(self, encoded);

  00188	48 8b 54 24 70	 mov	 rdx, QWORD PTR encoded$21000[rsp]
  0018d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00195	e8 00 00 00 00	 call	 bytearray_iconcat
  0019a	48 89 44 24 78	 mov	 QWORD PTR new$21001[rsp], rax

; 755  :         Py_DECREF(encoded);

  0019f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR encoded$21000[rsp]
  001a4	e8 00 00 00 00	 call	 _Py_DecRef

; 756  :         if (new == NULL)

  001a9	48 83 7c 24 78
	00		 cmp	 QWORD PTR new$21001[rsp], 0
  001af	75 0a		 jne	 SHORT $LN24@bytearray_@10

; 757  :             return -1;

  001b1	b8 ff ff ff ff	 mov	 eax, -1
  001b6	e9 2a 03 00 00	 jmp	 $LN34@bytearray_@10
$LN24@bytearray_@10:

; 758  :         Py_DECREF(new);

  001bb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR new$21001[rsp]
  001c0	e8 00 00 00 00	 call	 _Py_DecRef

; 759  :         return 0;

  001c5	33 c0		 xor	 eax, eax
  001c7	e9 19 03 00 00	 jmp	 $LN34@bytearray_@10
$LN27@bytearray_@10:

; 760  :     }
; 761  : 
; 762  :     /* If it's not unicode, there can't be encoding or errors */
; 763  :     if (encoding != NULL || errors != NULL) {

  001cc	48 83 7c 24 68
	00		 cmp	 QWORD PTR encoding$[rsp], 0
  001d2	75 08		 jne	 SHORT $LN22@bytearray_@10
  001d4	48 83 7c 24 60
	00		 cmp	 QWORD PTR errors$[rsp], 0
  001da	74 1d		 je	 SHORT $LN23@bytearray_@10
$LN22@bytearray_@10:

; 764  :         PyErr_SetString(PyExc_TypeError,
; 765  :                         "encoding or errors without a string argument");

  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@
  001e3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001ea	e8 00 00 00 00	 call	 PyErr_SetString

; 766  :         return -1;

  001ef	b8 ff ff ff ff	 mov	 eax, -1
  001f4	e9 ec 02 00 00	 jmp	 $LN34@bytearray_@10
$LN23@bytearray_@10:

; 767  :     }
; 768  : 
; 769  :     /* Is it an int? */
; 770  :     count = PyNumber_AsSsize_t(arg, PyExc_OverflowError);

  001f9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00200	48 8b 4c 24 58	 mov	 rcx, QWORD PTR arg$[rsp]
  00205	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0020a	48 89 44 24 48	 mov	 QWORD PTR count$[rsp], rax

; 771  :     if (count == -1 && PyErr_Occurred()) {

  0020f	48 83 7c 24 48
	ff		 cmp	 QWORD PTR count$[rsp], -1
  00215	75 2b		 jne	 SHORT $LN21@bytearray_@10
  00217	e8 00 00 00 00	 call	 PyErr_Occurred
  0021c	48 85 c0	 test	 rax, rax
  0021f	74 21		 je	 SHORT $LN21@bytearray_@10

; 772  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  00221	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00228	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0022d	85 c0		 test	 eax, eax
  0022f	74 0a		 je	 SHORT $LN20@bytearray_@10

; 773  :             return -1;

  00231	b8 ff ff ff ff	 mov	 eax, -1
  00236	e9 aa 02 00 00	 jmp	 $LN34@bytearray_@10
$LN20@bytearray_@10:

; 774  :         PyErr_Clear();

  0023b	e8 00 00 00 00	 call	 PyErr_Clear
  00240	eb 71		 jmp	 SHORT $LN19@bytearray_@10
$LN21@bytearray_@10:

; 775  :     }
; 776  :     else if (count < 0) {

  00242	48 83 7c 24 48
	00		 cmp	 QWORD PTR count$[rsp], 0
  00248	7d 1f		 jge	 SHORT $LN18@bytearray_@10

; 777  :         PyErr_SetString(PyExc_ValueError, "negative count");

  0024a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DIJHAIGC@negative?5count?$AA@
  00251	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00258	e8 00 00 00 00	 call	 PyErr_SetString

; 778  :         return -1;

  0025d	b8 ff ff ff ff	 mov	 eax, -1
  00262	e9 7e 02 00 00	 jmp	 $LN34@bytearray_@10

; 779  :     }
; 780  :     else {

  00267	eb 4a		 jmp	 SHORT $LN17@bytearray_@10
$LN18@bytearray_@10:

; 781  :         if (count > 0) {

  00269	48 83 7c 24 48
	00		 cmp	 QWORD PTR count$[rsp], 0
  0026f	7e 3b		 jle	 SHORT $LN16@bytearray_@10

; 782  :             if (PyByteArray_Resize((PyObject *)self, count))

  00271	48 8b 54 24 48	 mov	 rdx, QWORD PTR count$[rsp]
  00276	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0027e	e8 00 00 00 00	 call	 PyByteArray_Resize
  00283	85 c0		 test	 eax, eax
  00285	74 0a		 je	 SHORT $LN15@bytearray_@10

; 783  :                 return -1;

  00287	b8 ff ff ff ff	 mov	 eax, -1
  0028c	e9 54 02 00 00	 jmp	 $LN34@bytearray_@10
$LN15@bytearray_@10:

; 784  :             memset(self->ob_bytes, 0, count);

  00291	4c 8b 44 24 48	 mov	 r8, QWORD PTR count$[rsp]
  00296	33 d2		 xor	 edx, edx
  00298	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002a0	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  002a7	e8 00 00 00 00	 call	 memset
$LN16@bytearray_@10:

; 785  :         }
; 786  :         return 0;

  002ac	33 c0		 xor	 eax, eax
  002ae	e9 32 02 00 00	 jmp	 $LN34@bytearray_@10
$LN17@bytearray_@10:
$LN19@bytearray_@10:

; 787  :     }
; 788  : 
; 789  :     /* Use the buffer API */
; 790  :     if (PyObject_CheckBuffer(arg)) {

  002b3	48 8b 44 24 58	 mov	 rax, QWORD PTR arg$[rsp]
  002b8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002bc	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  002c4	0f 84 c3 00 00
	00		 je	 $LN14@bytearray_@10
  002ca	48 8b 44 24 58	 mov	 rax, QWORD PTR arg$[rsp]
  002cf	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002d3	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  002da	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  002de	0f 84 a9 00 00
	00		 je	 $LN14@bytearray_@10

; 791  :         Py_ssize_t size;
; 792  :         Py_buffer view;
; 793  :         if (PyObject_GetBuffer(arg, &view, PyBUF_FULL_RO) < 0)

  002e4	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  002ea	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR view$21032[rsp]
  002f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR arg$[rsp]
  002f7	e8 00 00 00 00	 call	 PyObject_GetBuffer
  002fc	85 c0		 test	 eax, eax
  002fe	7d 0a		 jge	 SHORT $LN13@bytearray_@10

; 794  :             return -1;

  00300	b8 ff ff ff ff	 mov	 eax, -1
  00305	e9 db 01 00 00	 jmp	 $LN34@bytearray_@10
$LN13@bytearray_@10:

; 795  :         size = view.len;

  0030a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR view$21032[rsp+16]
  00312	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR size$21031[rsp], rax

; 796  :         if (PyByteArray_Resize((PyObject *)self, size) < 0) goto fail;

  0031a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR size$21031[rsp]
  00322	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0032a	e8 00 00 00 00	 call	 PyByteArray_Resize
  0032f	85 c0		 test	 eax, eax
  00331	7d 02		 jge	 SHORT $LN12@bytearray_@10
  00333	eb 41		 jmp	 SHORT $fail$21036
$LN12@bytearray_@10:

; 797  :         if (PyBuffer_ToContiguous(self->ob_bytes, &view, size, 'C') < 0)

  00335	41 b1 43	 mov	 r9b, 67			; 00000043H
  00338	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR size$21031[rsp]
  00340	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR view$21032[rsp]
  00348	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00350	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00357	e8 00 00 00 00	 call	 PyBuffer_ToContiguous
  0035c	85 c0		 test	 eax, eax
  0035e	7d 02		 jge	 SHORT $LN11@bytearray_@10

; 798  :             goto fail;

  00360	eb 14		 jmp	 SHORT $fail$21036
$LN11@bytearray_@10:

; 799  :         PyBuffer_Release(&view);

  00362	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR view$21032[rsp]
  0036a	e8 00 00 00 00	 call	 PyBuffer_Release

; 800  :         return 0;

  0036f	33 c0		 xor	 eax, eax
  00371	e9 6f 01 00 00	 jmp	 $LN34@bytearray_@10
$fail$21036:

; 801  :     fail:
; 802  :         PyBuffer_Release(&view);

  00376	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR view$21032[rsp]
  0037e	e8 00 00 00 00	 call	 PyBuffer_Release

; 803  :         return -1;

  00383	b8 ff ff ff ff	 mov	 eax, -1
  00388	e9 58 01 00 00	 jmp	 $LN34@bytearray_@10
$LN14@bytearray_@10:

; 804  :     }
; 805  : 
; 806  :     /* XXX Optimize this if the arguments is a list, tuple */
; 807  : 
; 808  :     /* Get the iterator */
; 809  :     it = PyObject_GetIter(arg);

  0038d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR arg$[rsp]
  00392	e8 00 00 00 00	 call	 PyObject_GetIter
  00397	48 89 44 24 40	 mov	 QWORD PTR it$[rsp], rax

; 810  :     if (it == NULL)

  0039c	48 83 7c 24 40
	00		 cmp	 QWORD PTR it$[rsp], 0
  003a2	75 0a		 jne	 SHORT $LN10@bytearray_@10

; 811  :         return -1;

  003a4	b8 ff ff ff ff	 mov	 eax, -1
  003a9	e9 37 01 00 00	 jmp	 $LN34@bytearray_@10
$LN10@bytearray_@10:

; 812  :     iternext = *Py_TYPE(it)->tp_iternext;

  003ae	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  003b3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003b7	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  003be	48 89 44 24 50	 mov	 QWORD PTR iternext$[rsp], rax
$LN9@bytearray_@10:

; 813  : 
; 814  :     /* Run the iterator to exhaustion */
; 815  :     for (;;) {
; 816  :         PyObject *item;
; 817  :         int rc, value;
; 818  : 
; 819  :         /* Get the next item */
; 820  :         item = iternext(it);

  003c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  003c8	ff 54 24 50	 call	 QWORD PTR iternext$[rsp]
  003cc	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR item$21044[rsp], rax

; 821  :         if (item == NULL) {

  003d4	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR item$21044[rsp], 0
  003dd	75 29		 jne	 SHORT $LN7@bytearray_@10

; 822  :             if (PyErr_Occurred()) {

  003df	e8 00 00 00 00	 call	 PyErr_Occurred
  003e4	48 85 c0	 test	 rax, rax
  003e7	74 1a		 je	 SHORT $LN6@bytearray_@10

; 823  :                 if (!PyErr_ExceptionMatches(PyExc_StopIteration))

  003e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  003f0	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  003f5	85 c0		 test	 eax, eax
  003f7	75 05		 jne	 SHORT $LN5@bytearray_@10

; 824  :                     goto error;

  003f9	e9 d8 00 00 00	 jmp	 $error$21051
$LN5@bytearray_@10:

; 825  :                 PyErr_Clear();

  003fe	e8 00 00 00 00	 call	 PyErr_Clear
$LN6@bytearray_@10:

; 826  :             }
; 827  :             break;

  00403	e9 c0 00 00 00	 jmp	 $LN8@bytearray_@10
$LN7@bytearray_@10:

; 828  :         }
; 829  : 
; 830  :         /* Interpret it as an int (__index__) */
; 831  :         rc = _getbytevalue(item, &value);

  00408	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR value$21046[rsp]
  00410	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$21044[rsp]
  00418	e8 00 00 00 00	 call	 _getbytevalue
  0041d	89 84 24 e4 00
	00 00		 mov	 DWORD PTR rc$21045[rsp], eax

; 832  :         Py_DECREF(item);

  00424	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$21044[rsp]
  0042c	e8 00 00 00 00	 call	 _Py_DecRef

; 833  :         if (!rc)

  00431	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR rc$21045[rsp], 0
  00439	75 05		 jne	 SHORT $LN4@bytearray_@10

; 834  :             goto error;

  0043b	e9 96 00 00 00	 jmp	 $error$21051
$LN4@bytearray_@10:

; 835  : 
; 836  :         /* Append the byte */
; 837  :         if (Py_SIZE(self) < self->ob_alloc)

  00440	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00448	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00450	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00454	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00458	7d 1d		 jge	 SHORT $LN3@bytearray_@10

; 838  :             Py_SIZE(self)++;

  0045a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00462	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00466	48 ff c0	 inc	 rax
  00469	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00471	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  00475	eb 25		 jmp	 SHORT $LN2@bytearray_@10
$LN3@bytearray_@10:

; 839  :         else if (PyByteArray_Resize((PyObject *)self, Py_SIZE(self)+1) < 0)

  00477	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0047f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00483	48 ff c0	 inc	 rax
  00486	48 8b d0	 mov	 rdx, rax
  00489	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00491	e8 00 00 00 00	 call	 PyByteArray_Resize
  00496	85 c0		 test	 eax, eax
  00498	7d 02		 jge	 SHORT $LN1@bytearray_@10

; 840  :             goto error;

  0049a	eb 3a		 jmp	 SHORT $error$21051
$LN1@bytearray_@10:
$LN2@bytearray_@10:

; 841  :         self->ob_bytes[Py_SIZE(self)-1] = value;

  0049c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  004a4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  004a8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  004b0	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  004b7	0f b6 94 24 e0
	00 00 00	 movzx	 edx, BYTE PTR value$21046[rsp]
  004bf	88 54 08 ff	 mov	 BYTE PTR [rax+rcx-1], dl

; 842  :     }

  004c3	e9 fb fe ff ff	 jmp	 $LN9@bytearray_@10
$LN8@bytearray_@10:

; 843  : 
; 844  :     /* Clean up and return success */
; 845  :     Py_DECREF(it);

  004c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  004cd	e8 00 00 00 00	 call	 _Py_DecRef

; 846  :     return 0;

  004d2	33 c0		 xor	 eax, eax
  004d4	eb 0f		 jmp	 SHORT $LN34@bytearray_@10
$error$21051:

; 847  : 
; 848  :  error:
; 849  :     /* Error handling when it != NULL */
; 850  :     Py_DECREF(it);

  004d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  004db	e8 00 00 00 00	 call	 _Py_DecRef

; 851  :     return -1;

  004e0	b8 ff ff ff ff	 mov	 eax, -1
$LN34@bytearray_@10:

; 852  : }

  004e5	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  004ec	c3		 ret	 0
bytearray_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DI@PEAFHOOC@?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA?$CI?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@HLGHOJLF@?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA?$CI?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA5?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CL@FAAGOMMC@bytearray?5object?5is?5too?5large?5to@ ; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	??_C@_0M@NONGCEAD@bytearray?$CIb?$AA@		; `string'
EXTRN	PyUnicode_DecodeASCII:PROC
EXTRN	Py_hexdigits:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_repr DD imagerel bytearray_repr
	DD	imagerel bytearray_repr+1343
	DD	imagerel $unwind$bytearray_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_repr DD 020c01H
	DD	013010cH
xdata	ENDS
;	COMDAT ??_C@_1DI@PEAFHOOC@?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA?$CI?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@PEAFHOOC@?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA?$CI?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, '-', 00H, ' ', 00H, '(', 00H, 'p', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@HLGHOJLF@?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA?$CI?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA5?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@HLGHOJLF@?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA?$CI?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA5?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, '-', 00H, ' ', 00H, '(', 00H, 'p', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '5'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FAAGOMMC@bytearray?5object?5is?5too?5large?5to@
CONST	SEGMENT
??_C@_0CL@FAAGOMMC@bytearray?5object?5is?5too?5large?5to@ DB 'bytearray o'
	DB	'bject is too large to make repr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NONGCEAD@bytearray?$CIb?$AA@
CONST	SEGMENT
??_C@_0M@NONGCEAD@bytearray?$CIb?$AA@ DB 'bytearray(b', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_repr
_TEXT	SEGMENT
p$ = 32
v$ = 40
length$ = 48
quote_postfix$ = 56
i$ = 64
quote$ = 72
newsize$ = 80
quote_prefix$ = 88
start$ = 96
test$ = 104
c$ = 112
buffer$ = 120
tv87 = 128
self$ = 160
bytearray_repr PROC					; COMDAT

; 858  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 859  :     const char *quote_prefix = "bytearray(b";

  0000c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@NONGCEAD@bytearray?$CIb?$AA@
  00013	48 89 44 24 58	 mov	 QWORD PTR quote_prefix$[rsp], rax

; 860  :     const char *quote_postfix = ")";

  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ?$AA@
  0001f	48 89 44 24 38	 mov	 QWORD PTR quote_postfix$[rsp], rax

; 861  :     Py_ssize_t length = Py_SIZE(self);

  00024	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0002c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00030	48 89 44 24 30	 mov	 QWORD PTR length$[rsp], rax

; 862  :     /* 15 == strlen(quote_prefix) + 2 + strlen(quote_postfix) + 1 */
; 863  :     size_t newsize;
; 864  :     PyObject *v;
; 865  :     register Py_ssize_t i;
; 866  :     register char c;
; 867  :     register char *p;
; 868  :     int quote;
; 869  :     char *test, *start;
; 870  :     char *buffer;
; 871  : 
; 872  :     if (length > (PY_SSIZE_T_MAX - 15) / 4) {

  00035	48 b8 fc ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693948 ; 1ffffffffffffffcH
  0003f	48 39 44 24 30	 cmp	 QWORD PTR length$[rsp], rax
  00044	7e 1a		 jle	 SHORT $LN29@bytearray_@11

; 873  :         PyErr_SetString(PyExc_OverflowError,
; 874  :             "bytearray object is too large to make repr");

  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@FAAGOMMC@bytearray?5object?5is?5too?5large?5to@
  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00054	e8 00 00 00 00	 call	 PyErr_SetString

; 875  :         return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 d7 04 00 00	 jmp	 $LN30@bytearray_@11
$LN29@bytearray_@11:

; 876  :     }
; 877  : 
; 878  :     newsize = 15 + length * 4;

  00060	48 8b 44 24 30	 mov	 rax, QWORD PTR length$[rsp]
  00065	48 8d 04 85 0f
	00 00 00	 lea	 rax, QWORD PTR [rax*4+15]
  0006d	48 89 44 24 50	 mov	 QWORD PTR newsize$[rsp], rax

; 879  :     buffer = PyObject_Malloc(newsize);

  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newsize$[rsp]
  00077	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  0007c	48 89 44 24 78	 mov	 QWORD PTR buffer$[rsp], rax

; 880  :     if (buffer == NULL) {

  00081	48 83 7c 24 78
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00087	75 0c		 jne	 SHORT $LN28@bytearray_@11

; 881  :         PyErr_NoMemory();

  00089	e8 00 00 00 00	 call	 PyErr_NoMemory

; 882  :         return NULL;

  0008e	33 c0		 xor	 eax, eax
  00090	e9 a2 04 00 00	 jmp	 $LN30@bytearray_@11
$LN28@bytearray_@11:

; 883  :     }
; 884  : 
; 885  :     /* Figure out which quote to use; single is preferred */
; 886  :     quote = '\'';

  00095	c7 44 24 48 27
	00 00 00	 mov	 DWORD PTR quote$[rsp], 39 ; 00000027H

; 887  :     start = PyByteArray_AS_STRING(self);

  0009d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000a4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000ac	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000b0	74 38		 je	 SHORT $LN32@bytearray_@11
  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000c1	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000c5	e8 00 00 00 00	 call	 PyType_IsSubtype
  000ca	85 c0		 test	 eax, eax
  000cc	75 1c		 jne	 SHORT $LN32@bytearray_@11
  000ce	41 b8 77 03 00
	00		 mov	 r8d, 887		; 00000377H
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e8	33 c0		 xor	 eax, eax
$LN32@bytearray_@11:
  000ea	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000f2	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000f7	74 19		 je	 SHORT $LN33@bytearray_@11
  000f9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00101	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00108	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv87[rsp], rax
  00110	eb 0f		 jmp	 SHORT $LN34@bytearray_@11
$LN33@bytearray_@11:
  00112	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00119	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv87[rsp], rax
$LN34@bytearray_@11:
  00121	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv87[rsp]
  00129	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax

; 888  :     for (test = start; test < start+length; ++test) {

  0012e	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00133	48 89 44 24 68	 mov	 QWORD PTR test$[rsp], rax
  00138	eb 0d		 jmp	 SHORT $LN27@bytearray_@11
$LN26@bytearray_@11:
  0013a	48 8b 44 24 68	 mov	 rax, QWORD PTR test$[rsp]
  0013f	48 ff c0	 inc	 rax
  00142	48 89 44 24 68	 mov	 QWORD PTR test$[rsp], rax
$LN27@bytearray_@11:
  00147	48 8b 44 24 30	 mov	 rax, QWORD PTR length$[rsp]
  0014c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00151	48 03 c8	 add	 rcx, rax
  00154	48 8b c1	 mov	 rax, rcx
  00157	48 39 44 24 68	 cmp	 QWORD PTR test$[rsp], rax
  0015c	73 30		 jae	 SHORT $LN25@bytearray_@11

; 889  :         if (*test == '"') {

  0015e	48 8b 44 24 68	 mov	 rax, QWORD PTR test$[rsp]
  00163	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00166	83 f8 22	 cmp	 eax, 34			; 00000022H
  00169	75 0c		 jne	 SHORT $LN24@bytearray_@11

; 890  :             quote = '\''; /* back to single */

  0016b	c7 44 24 48 27
	00 00 00	 mov	 DWORD PTR quote$[rsp], 39 ; 00000027H

; 891  :             break;

  00173	eb 19		 jmp	 SHORT $LN25@bytearray_@11
  00175	eb 15		 jmp	 SHORT $LN23@bytearray_@11
$LN24@bytearray_@11:

; 892  :         }
; 893  :         else if (*test == '\'')

  00177	48 8b 44 24 68	 mov	 rax, QWORD PTR test$[rsp]
  0017c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0017f	83 f8 27	 cmp	 eax, 39			; 00000027H
  00182	75 08		 jne	 SHORT $LN22@bytearray_@11

; 894  :             quote = '"';

  00184	c7 44 24 48 22
	00 00 00	 mov	 DWORD PTR quote$[rsp], 34 ; 00000022H
$LN22@bytearray_@11:
$LN23@bytearray_@11:

; 895  :     }

  0018c	eb ac		 jmp	 SHORT $LN26@bytearray_@11
$LN25@bytearray_@11:

; 896  : 
; 897  :     p = buffer;

  0018e	48 8b 44 24 78	 mov	 rax, QWORD PTR buffer$[rsp]
  00193	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN21@bytearray_@11:

; 898  :     while (*quote_prefix)

  00198	48 8b 44 24 58	 mov	 rax, QWORD PTR quote_prefix$[rsp]
  0019d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001a0	85 c0		 test	 eax, eax
  001a2	74 2b		 je	 SHORT $LN20@bytearray_@11

; 899  :         *p++ = *quote_prefix++;

  001a4	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001a9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR quote_prefix$[rsp]
  001ae	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001b1	88 08		 mov	 BYTE PTR [rax], cl
  001b3	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001b8	48 ff c0	 inc	 rax
  001bb	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  001c0	48 8b 44 24 58	 mov	 rax, QWORD PTR quote_prefix$[rsp]
  001c5	48 ff c0	 inc	 rax
  001c8	48 89 44 24 58	 mov	 QWORD PTR quote_prefix$[rsp], rax
  001cd	eb c9		 jmp	 SHORT $LN21@bytearray_@11
$LN20@bytearray_@11:

; 900  :     *p++ = quote;

  001cf	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001d4	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR quote$[rsp]
  001d9	88 08		 mov	 BYTE PTR [rax], cl
  001db	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001e0	48 ff c0	 inc	 rax
  001e3	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 901  : 
; 902  :     for (i = 0; i < length; i++) {

  001e8	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001f1	eb 0d		 jmp	 SHORT $LN19@bytearray_@11
$LN18@bytearray_@11:
  001f3	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001f8	48 ff c0	 inc	 rax
  001fb	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN19@bytearray_@11:
  00200	48 8b 44 24 30	 mov	 rax, QWORD PTR length$[rsp]
  00205	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  0020a	0f 8d 66 02 00
	00		 jge	 $LN17@bytearray_@11

; 903  :         /* There's at least enough room for a hex escape
; 904  :            and a closing quote. */
; 905  :         assert(newsize - (p - buffer) >= 5);

  00210	48 8b 44 24 78	 mov	 rax, QWORD PTR buffer$[rsp]
  00215	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0021a	48 2b c8	 sub	 rcx, rax
  0021d	48 8b c1	 mov	 rax, rcx
  00220	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newsize$[rsp]
  00225	48 2b c8	 sub	 rcx, rax
  00228	48 8b c1	 mov	 rax, rcx
  0022b	48 83 f8 05	 cmp	 rax, 5
  0022f	73 1c		 jae	 SHORT $LN35@bytearray_@11
  00231	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00237	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0023e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@HLGHOJLF@?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA?$CI?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA5?$AA?$AA@
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0024b	33 c0		 xor	 eax, eax
$LN35@bytearray_@11:

; 906  :         c = self->ob_bytes[i];

  0024d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00255	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0025c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00261	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00265	88 44 24 70	 mov	 BYTE PTR c$[rsp], al

; 907  :         if (c == '\'' || c == '\\')

  00269	0f be 44 24 70	 movsx	 eax, BYTE PTR c$[rsp]
  0026e	83 f8 27	 cmp	 eax, 39			; 00000027H
  00271	74 0a		 je	 SHORT $LN15@bytearray_@11
  00273	0f be 44 24 70	 movsx	 eax, BYTE PTR c$[rsp]
  00278	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0027b	75 33		 jne	 SHORT $LN16@bytearray_@11
$LN15@bytearray_@11:

; 908  :             *p++ = '\\', *p++ = c;

  0027d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00282	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  00285	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0028a	48 ff c0	 inc	 rax
  0028d	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00292	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00297	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR c$[rsp]
  0029c	88 08		 mov	 BYTE PTR [rax], cl
  0029e	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  002a3	48 ff c0	 inc	 rax
  002a6	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  002ab	e9 c1 01 00 00	 jmp	 $LN14@bytearray_@11
$LN16@bytearray_@11:

; 909  :         else if (c == '\t')

  002b0	0f be 44 24 70	 movsx	 eax, BYTE PTR c$[rsp]
  002b5	83 f8 09	 cmp	 eax, 9
  002b8	75 2f		 jne	 SHORT $LN13@bytearray_@11

; 910  :             *p++ = '\\', *p++ = 't';

  002ba	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  002bf	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  002c2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  002c7	48 ff c0	 inc	 rax
  002ca	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  002cf	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  002d4	c6 00 74	 mov	 BYTE PTR [rax], 116	; 00000074H
  002d7	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  002dc	48 ff c0	 inc	 rax
  002df	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  002e4	e9 88 01 00 00	 jmp	 $LN12@bytearray_@11
$LN13@bytearray_@11:

; 911  :         else if (c == '\n')

  002e9	0f be 44 24 70	 movsx	 eax, BYTE PTR c$[rsp]
  002ee	83 f8 0a	 cmp	 eax, 10
  002f1	75 2f		 jne	 SHORT $LN11@bytearray_@11

; 912  :             *p++ = '\\', *p++ = 'n';

  002f3	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  002f8	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  002fb	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00300	48 ff c0	 inc	 rax
  00303	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00308	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0030d	c6 00 6e	 mov	 BYTE PTR [rax], 110	; 0000006eH
  00310	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00315	48 ff c0	 inc	 rax
  00318	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0031d	e9 4f 01 00 00	 jmp	 $LN10@bytearray_@11
$LN11@bytearray_@11:

; 913  :         else if (c == '\r')

  00322	0f be 44 24 70	 movsx	 eax, BYTE PTR c$[rsp]
  00327	83 f8 0d	 cmp	 eax, 13
  0032a	75 2f		 jne	 SHORT $LN9@bytearray_@11

; 914  :             *p++ = '\\', *p++ = 'r';

  0032c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00331	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  00334	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00339	48 ff c0	 inc	 rax
  0033c	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00341	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00346	c6 00 72	 mov	 BYTE PTR [rax], 114	; 00000072H
  00349	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0034e	48 ff c0	 inc	 rax
  00351	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00356	e9 16 01 00 00	 jmp	 $LN8@bytearray_@11
$LN9@bytearray_@11:

; 915  :         else if (c == 0)

  0035b	0f be 44 24 70	 movsx	 eax, BYTE PTR c$[rsp]
  00360	85 c0		 test	 eax, eax
  00362	75 59		 jne	 SHORT $LN7@bytearray_@11

; 916  :             *p++ = '\\', *p++ = 'x', *p++ = '0', *p++ = '0';

  00364	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00369	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  0036c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00371	48 ff c0	 inc	 rax
  00374	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00379	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0037e	c6 00 78	 mov	 BYTE PTR [rax], 120	; 00000078H
  00381	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00386	48 ff c0	 inc	 rax
  00389	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0038e	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00393	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
  00396	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0039b	48 ff c0	 inc	 rax
  0039e	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  003a3	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003a8	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
  003ab	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003b0	48 ff c0	 inc	 rax
  003b3	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  003b8	e9 b4 00 00 00	 jmp	 $LN6@bytearray_@11
$LN7@bytearray_@11:

; 917  :         else if (c < ' ' || c >= 0x7f) {

  003bd	0f be 44 24 70	 movsx	 eax, BYTE PTR c$[rsp]
  003c2	83 f8 20	 cmp	 eax, 32			; 00000020H
  003c5	7c 0e		 jl	 SHORT $LN4@bytearray_@11
  003c7	0f be 44 24 70	 movsx	 eax, BYTE PTR c$[rsp]
  003cc	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  003cf	0f 8c 83 00 00
	00		 jl	 $LN5@bytearray_@11
$LN4@bytearray_@11:

; 918  :             *p++ = '\\';

  003d5	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003da	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  003dd	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003e2	48 ff c0	 inc	 rax
  003e5	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 919  :             *p++ = 'x';

  003ea	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003ef	c6 00 78	 mov	 BYTE PTR [rax], 120	; 00000078H
  003f2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  003f7	48 ff c0	 inc	 rax
  003fa	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 920  :             *p++ = Py_hexdigits[(c & 0xf0) >> 4];

  003ff	0f be 44 24 70	 movsx	 eax, BYTE PTR c$[rsp]
  00404	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00409	c1 f8 04	 sar	 eax, 4
  0040c	48 98		 cdqe
  0040e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00413	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  0041a	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0041e	88 01		 mov	 BYTE PTR [rcx], al
  00420	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00425	48 ff c0	 inc	 rax
  00428	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 921  :             *p++ = Py_hexdigits[c & 0xf];

  0042d	0f be 44 24 70	 movsx	 eax, BYTE PTR c$[rsp]
  00432	83 e0 0f	 and	 eax, 15
  00435	48 98		 cdqe
  00437	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0043c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  00443	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00447	88 01		 mov	 BYTE PTR [rcx], al
  00449	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0044e	48 ff c0	 inc	 rax
  00451	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 922  :         }
; 923  :         else

  00456	eb 19		 jmp	 SHORT $LN3@bytearray_@11
$LN5@bytearray_@11:

; 924  :             *p++ = c;

  00458	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0045d	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR c$[rsp]
  00462	88 08		 mov	 BYTE PTR [rax], cl
  00464	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00469	48 ff c0	 inc	 rax
  0046c	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN3@bytearray_@11:
$LN6@bytearray_@11:
$LN8@bytearray_@11:
$LN10@bytearray_@11:
$LN12@bytearray_@11:
$LN14@bytearray_@11:

; 925  :     }

  00471	e9 7d fd ff ff	 jmp	 $LN18@bytearray_@11
$LN17@bytearray_@11:

; 926  :     assert(newsize - (p - buffer) >= 1);

  00476	48 8b 44 24 78	 mov	 rax, QWORD PTR buffer$[rsp]
  0047b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00480	48 2b c8	 sub	 rcx, rax
  00483	48 8b c1	 mov	 rax, rcx
  00486	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newsize$[rsp]
  0048b	48 2b c8	 sub	 rcx, rax
  0048e	48 8b c1	 mov	 rax, rcx
  00491	48 83 f8 01	 cmp	 rax, 1
  00495	73 1c		 jae	 SHORT $LN36@bytearray_@11
  00497	41 b8 9e 03 00
	00		 mov	 r8d, 926		; 0000039eH
  0049d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  004a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@PEAFHOOC@?$AAn?$AAe?$AAw?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AA?$CI?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  004ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004b1	33 c0		 xor	 eax, eax
$LN36@bytearray_@11:

; 927  :     *p++ = quote;

  004b3	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004b8	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR quote$[rsp]
  004bd	88 08		 mov	 BYTE PTR [rax], cl
  004bf	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004c4	48 ff c0	 inc	 rax
  004c7	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN2@bytearray_@11:

; 928  :     while (*quote_postfix) {

  004cc	48 8b 44 24 38	 mov	 rax, QWORD PTR quote_postfix$[rsp]
  004d1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004d4	85 c0		 test	 eax, eax
  004d6	74 2b		 je	 SHORT $LN1@bytearray_@11

; 929  :        *p++ = *quote_postfix++;

  004d8	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR quote_postfix$[rsp]
  004e2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  004e5	88 08		 mov	 BYTE PTR [rax], cl
  004e7	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004ec	48 ff c0	 inc	 rax
  004ef	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  004f4	48 8b 44 24 38	 mov	 rax, QWORD PTR quote_postfix$[rsp]
  004f9	48 ff c0	 inc	 rax
  004fc	48 89 44 24 38	 mov	 QWORD PTR quote_postfix$[rsp], rax

; 930  :     }

  00501	eb c9		 jmp	 SHORT $LN2@bytearray_@11
$LN1@bytearray_@11:

; 931  : 
; 932  :     v = PyUnicode_DecodeASCII(buffer, p - buffer, NULL);

  00503	48 8b 44 24 78	 mov	 rax, QWORD PTR buffer$[rsp]
  00508	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0050d	48 2b c8	 sub	 rcx, rax
  00510	48 8b c1	 mov	 rax, rcx
  00513	45 33 c0	 xor	 r8d, r8d
  00516	48 8b d0	 mov	 rdx, rax
  00519	48 8b 4c 24 78	 mov	 rcx, QWORD PTR buffer$[rsp]
  0051e	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  00523	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 933  :     PyObject_Free(buffer);

  00528	48 8b 4c 24 78	 mov	 rcx, QWORD PTR buffer$[rsp]
  0052d	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 934  :     return v;

  00532	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
$LN30@bytearray_@11:

; 935  : }

  00537	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0053e	c3		 ret	 0
bytearray_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@DAKHFBFN@str?$CI?$CJ?5on?5a?5bytearray?5instance?$AA@ ; `string'
EXTRN	PyErr_WarnEx:PROC
EXTRN	PyExc_BytesWarning:QWORD
EXTRN	Py_BytesWarningFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_str DD imagerel bytearray_str
	DD	imagerel bytearray_str+66
	DD	imagerel $unwind$bytearray_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_str DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BO@DAKHFBFN@str?$CI?$CJ?5on?5a?5bytearray?5instance?$AA@
CONST	SEGMENT
??_C@_0BO@DAKHFBFN@str?$CI?$CJ?5on?5a?5bytearray?5instance?$AA@ DB 'str()'
	DB	' on a bytearray instance', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_str
_TEXT	SEGMENT
op$ = 48
bytearray_str PROC					; COMDAT

; 939  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 940  :         if (Py_BytesWarningFlag) {

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_BytesWarningFlag, 0
  00010	74 21		 je	 SHORT $LN2@bytearray_@12

; 941  :                 if (PyErr_WarnEx(PyExc_BytesWarning,
; 942  :                                  "str() on a bytearray instance", 1))

  00012	41 b8 01 00 00
	00		 mov	 r8d, 1
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@DAKHFBFN@str?$CI?$CJ?5on?5a?5bytearray?5instance?$AA@
  0001f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BytesWarning
  00026	e8 00 00 00 00	 call	 PyErr_WarnEx
  0002b	85 c0		 test	 eax, eax
  0002d	74 04		 je	 SHORT $LN1@bytearray_@12

; 943  :                         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 0a		 jmp	 SHORT $LN3@bytearray_@12
$LN1@bytearray_@12:
$LN2@bytearray_@12:

; 944  :         }
; 945  :         return bytearray_repr((PyByteArrayObject*)op);

  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00038	e8 00 00 00 00	 call	 bytearray_repr
$LN3@bytearray_@12:

; 946  : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
bytearray_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@GNKEBMCE@Comparison?5between?5bytearray?5and@ ; `string'
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	memcmp:PROC
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	PyObject_IsInstance:PROC
EXTRN	PyUnicode_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_richcompare DD imagerel bytearray_richcompare
	DD	imagerel bytearray_richcompare+1036
	DD	imagerel $unwind$bytearray_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_richcompare DD 021601H
	DD	0250116H
xdata	ENDS
;	COMDAT ??_C@_0CI@GNKEBMCE@Comparison?5between?5bytearray?5and@
CONST	SEGMENT
??_C@_0CI@GNKEBMCE@Comparison?5between?5bytearray?5and@ DB 'Comparison be'
	DB	'tween bytearray and string', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_richcompare
_TEXT	SEGMENT
res$ = 32
self_bytes$ = 48
minsize$ = 128
other_bytes$ = 144
other_size$ = 224
self_size$ = 232
cmp$ = 240
tv128 = 244
tv137 = 248
tv139 = 252
tv141 = 256
tv143 = 260
tv145 = 264
tv147 = 268
tv149 = 272
tv152 = 280
self$ = 304
other$ = 312
op$ = 320
bytearray_richcompare PROC				; COMDAT

; 950  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H

; 951  :     Py_ssize_t self_size, other_size;
; 952  :     Py_buffer self_bytes, other_bytes;
; 953  :     PyObject *res;
; 954  :     Py_ssize_t minsize;
; 955  :     int cmp;
; 956  : 
; 957  :     /* Bytes can be compared to anything that supports the (binary)
; 958  :        buffer API.  Except that a comparison with Unicode is always an
; 959  :        error, even if the comparison is for equality. */
; 960  :     if (PyObject_IsInstance(self, (PyObject*)&PyUnicode_Type) ||
; 961  :         PyObject_IsInstance(other, (PyObject*)&PyUnicode_Type)) {

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyUnicode_Type
  0001d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00025	e8 00 00 00 00	 call	 PyObject_IsInstance
  0002a	85 c0		 test	 eax, eax
  0002c	75 18		 jne	 SHORT $LN22@bytearray_@13
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyUnicode_Type
  00035	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  0003d	e8 00 00 00 00	 call	 PyObject_IsInstance
  00042	85 c0		 test	 eax, eax
  00044	74 59		 je	 SHORT $LN23@bytearray_@13
$LN22@bytearray_@13:

; 962  :         if (Py_BytesWarningFlag && (op == Py_EQ || op == Py_NE)) {

  00046	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_BytesWarningFlag, 0
  0004d	74 38		 je	 SHORT $LN21@bytearray_@13
  0004f	83 bc 24 40 01
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  00057	74 0a		 je	 SHORT $LN20@bytearray_@13
  00059	83 bc 24 40 01
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  00061	75 24		 jne	 SHORT $LN21@bytearray_@13
$LN20@bytearray_@13:

; 963  :             if (PyErr_WarnEx(PyExc_BytesWarning,
; 964  :                             "Comparison between bytearray and string", 1))

  00063	41 b8 01 00 00
	00		 mov	 r8d, 1
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@GNKEBMCE@Comparison?5between?5bytearray?5and@
  00070	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BytesWarning
  00077	e8 00 00 00 00	 call	 PyErr_WarnEx
  0007c	85 c0		 test	 eax, eax
  0007e	74 07		 je	 SHORT $LN19@bytearray_@13

; 965  :                 return NULL;

  00080	33 c0		 xor	 eax, eax
  00082	e9 64 03 00 00	 jmp	 $LN24@bytearray_@13
$LN19@bytearray_@13:
$LN21@bytearray_@13:

; 966  :         }
; 967  : 
; 968  :         Py_RETURN_NOTIMPLEMENTED;

  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0008e	e8 00 00 00 00	 call	 _Py_IncRef
  00093	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0009a	e9 4c 03 00 00	 jmp	 $LN24@bytearray_@13
$LN23@bytearray_@13:

; 969  :     }
; 970  : 
; 971  :     self_size = _getbuffer(self, &self_bytes);

  0009f	48 8d 54 24 30	 lea	 rdx, QWORD PTR self_bytes$[rsp]
  000a4	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000ac	e8 00 00 00 00	 call	 _getbuffer
  000b1	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR self_size$[rsp], rax

; 972  :     if (self_size < 0) {

  000b9	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR self_size$[rsp], 0
  000c2	7d 1d		 jge	 SHORT $LN18@bytearray_@13

; 973  :         PyErr_Clear();

  000c4	e8 00 00 00 00	 call	 PyErr_Clear

; 974  :         Py_RETURN_NOTIMPLEMENTED;

  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  000d0	e8 00 00 00 00	 call	 _Py_IncRef
  000d5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000dc	e9 0a 03 00 00	 jmp	 $LN24@bytearray_@13
$LN18@bytearray_@13:

; 975  :     }
; 976  : 
; 977  :     other_size = _getbuffer(other, &other_bytes);

  000e1	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR other_bytes$[rsp]
  000e9	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR other$[rsp]
  000f1	e8 00 00 00 00	 call	 _getbuffer
  000f6	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR other_size$[rsp], rax

; 978  :     if (other_size < 0) {

  000fe	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR other_size$[rsp], 0
  00107	7d 27		 jge	 SHORT $LN17@bytearray_@13

; 979  :         PyErr_Clear();

  00109	e8 00 00 00 00	 call	 PyErr_Clear

; 980  :         PyBuffer_Release(&self_bytes);

  0010e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR self_bytes$[rsp]
  00113	e8 00 00 00 00	 call	 PyBuffer_Release

; 981  :         Py_RETURN_NOTIMPLEMENTED;

  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0011f	e8 00 00 00 00	 call	 _Py_IncRef
  00124	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0012b	e9 bb 02 00 00	 jmp	 $LN24@bytearray_@13
$LN17@bytearray_@13:

; 982  :     }
; 983  : 
; 984  :     if (self_size != other_size && (op == Py_EQ || op == Py_NE)) {

  00130	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR other_size$[rsp]
  00138	48 39 84 24 e8
	00 00 00	 cmp	 QWORD PTR self_size$[rsp], rax
  00140	74 49		 je	 SHORT $LN16@bytearray_@13
  00142	83 bc 24 40 01
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  0014a	74 0a		 je	 SHORT $LN15@bytearray_@13
  0014c	83 bc 24 40 01
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  00154	75 35		 jne	 SHORT $LN16@bytearray_@13
$LN15@bytearray_@13:

; 985  :         /* Shortcut: if the lengths differ, the objects differ */
; 986  :         cmp = (op == Py_NE);

  00156	83 bc 24 40 01
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  0015e	75 0d		 jne	 SHORT $LN26@bytearray_@13
  00160	c7 84 24 f4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv128[rsp], 1
  0016b	eb 0b		 jmp	 SHORT $LN27@bytearray_@13
$LN26@bytearray_@13:
  0016d	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv128[rsp], 0
$LN27@bytearray_@13:
  00178	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv128[rsp]
  0017f	89 84 24 f0 00
	00 00		 mov	 DWORD PTR cmp$[rsp], eax

; 987  :     }
; 988  :     else {

  00186	e9 03 02 00 00	 jmp	 $LN14@bytearray_@13
$LN16@bytearray_@13:

; 989  :         minsize = self_size;

  0018b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR self_size$[rsp]
  00193	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR minsize$[rsp], rax

; 990  :         if (other_size < minsize)

  0019b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR minsize$[rsp]
  001a3	48 39 84 24 e0
	00 00 00	 cmp	 QWORD PTR other_size$[rsp], rax
  001ab	7d 10		 jge	 SHORT $LN13@bytearray_@13

; 991  :             minsize = other_size;

  001ad	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR other_size$[rsp]
  001b5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR minsize$[rsp], rax
$LN13@bytearray_@13:

; 992  : 
; 993  :         cmp = memcmp(self_bytes.buf, other_bytes.buf, minsize);

  001bd	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR minsize$[rsp]
  001c5	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR other_bytes$[rsp]
  001cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self_bytes$[rsp]
  001d2	e8 00 00 00 00	 call	 memcmp
  001d7	89 84 24 f0 00
	00 00		 mov	 DWORD PTR cmp$[rsp], eax

; 994  :         /* In ISO C, memcmp() guarantees to use unsigned bytes! */
; 995  : 
; 996  :         if (cmp == 0) {

  001de	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR cmp$[rsp], 0
  001e6	75 3c		 jne	 SHORT $LN12@bytearray_@13

; 997  :             if (self_size < other_size)

  001e8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR other_size$[rsp]
  001f0	48 39 84 24 e8
	00 00 00	 cmp	 QWORD PTR self_size$[rsp], rax
  001f8	7d 0d		 jge	 SHORT $LN11@bytearray_@13

; 998  :                 cmp = -1;

  001fa	c7 84 24 f0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR cmp$[rsp], -1
  00205	eb 1d		 jmp	 SHORT $LN10@bytearray_@13
$LN11@bytearray_@13:

; 999  :             else if (self_size > other_size)

  00207	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR other_size$[rsp]
  0020f	48 39 84 24 e8
	00 00 00	 cmp	 QWORD PTR self_size$[rsp], rax
  00217	7e 0b		 jle	 SHORT $LN9@bytearray_@13

; 1000 :                 cmp = 1;

  00219	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR cmp$[rsp], 1
$LN9@bytearray_@13:
$LN10@bytearray_@13:
$LN12@bytearray_@13:

; 1001 :         }
; 1002 : 
; 1003 :         switch (op) {

  00224	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  0022b	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv137[rsp], eax
  00232	83 bc 24 f8 00
	00 00 05	 cmp	 DWORD PTR tv137[rsp], 5
  0023a	0f 87 4e 01 00
	00		 ja	 $LN7@bytearray_@13
  00240	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR tv137[rsp]
  00248	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0024f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN42@bytearray_@13[rcx+rax*4]
  00256	48 03 c1	 add	 rax, rcx
  00259	ff e0		 jmp	 rax
$LN6@bytearray_@13:

; 1004 :         case Py_LT: cmp = cmp <  0; break;

  0025b	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00263	7d 0d		 jge	 SHORT $LN28@bytearray_@13
  00265	c7 84 24 fc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv139[rsp], 1
  00270	eb 0b		 jmp	 SHORT $LN29@bytearray_@13
$LN28@bytearray_@13:
  00272	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv139[rsp], 0
$LN29@bytearray_@13:
  0027d	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR tv139[rsp]
  00284	89 84 24 f0 00
	00 00		 mov	 DWORD PTR cmp$[rsp], eax
  0028b	e9 fe 00 00 00	 jmp	 $LN7@bytearray_@13
$LN5@bytearray_@13:

; 1005 :         case Py_LE: cmp = cmp <= 0; break;

  00290	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00298	7f 0d		 jg	 SHORT $LN30@bytearray_@13
  0029a	c7 84 24 00 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv141[rsp], 1
  002a5	eb 0b		 jmp	 SHORT $LN31@bytearray_@13
$LN30@bytearray_@13:
  002a7	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv141[rsp], 0
$LN31@bytearray_@13:
  002b2	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR tv141[rsp]
  002b9	89 84 24 f0 00
	00 00		 mov	 DWORD PTR cmp$[rsp], eax
  002c0	e9 c9 00 00 00	 jmp	 $LN7@bytearray_@13
$LN4@bytearray_@13:

; 1006 :         case Py_EQ: cmp = cmp == 0; break;

  002c5	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR cmp$[rsp], 0
  002cd	75 0d		 jne	 SHORT $LN32@bytearray_@13
  002cf	c7 84 24 04 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv143[rsp], 1
  002da	eb 0b		 jmp	 SHORT $LN33@bytearray_@13
$LN32@bytearray_@13:
  002dc	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv143[rsp], 0
$LN33@bytearray_@13:
  002e7	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv143[rsp]
  002ee	89 84 24 f0 00
	00 00		 mov	 DWORD PTR cmp$[rsp], eax
  002f5	e9 94 00 00 00	 jmp	 $LN7@bytearray_@13
$LN3@bytearray_@13:

; 1007 :         case Py_NE: cmp = cmp != 0; break;

  002fa	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00302	74 0d		 je	 SHORT $LN34@bytearray_@13
  00304	c7 84 24 08 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv145[rsp], 1
  0030f	eb 0b		 jmp	 SHORT $LN35@bytearray_@13
$LN34@bytearray_@13:
  00311	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN35@bytearray_@13:
  0031c	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR tv145[rsp]
  00323	89 84 24 f0 00
	00 00		 mov	 DWORD PTR cmp$[rsp], eax
  0032a	eb 62		 jmp	 SHORT $LN7@bytearray_@13
$LN2@bytearray_@13:

; 1008 :         case Py_GT: cmp = cmp >  0; break;

  0032c	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00334	7e 0d		 jle	 SHORT $LN36@bytearray_@13
  00336	c7 84 24 0c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv147[rsp], 1
  00341	eb 0b		 jmp	 SHORT $LN37@bytearray_@13
$LN36@bytearray_@13:
  00343	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv147[rsp], 0
$LN37@bytearray_@13:
  0034e	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR tv147[rsp]
  00355	89 84 24 f0 00
	00 00		 mov	 DWORD PTR cmp$[rsp], eax
  0035c	eb 30		 jmp	 SHORT $LN7@bytearray_@13
$LN1@bytearray_@13:

; 1009 :         case Py_GE: cmp = cmp >= 0; break;

  0035e	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00366	7c 0d		 jl	 SHORT $LN38@bytearray_@13
  00368	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv149[rsp], 1
  00373	eb 0b		 jmp	 SHORT $LN39@bytearray_@13
$LN38@bytearray_@13:
  00375	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv149[rsp], 0
$LN39@bytearray_@13:
  00380	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR tv149[rsp]
  00387	89 84 24 f0 00
	00 00		 mov	 DWORD PTR cmp$[rsp], eax
$LN7@bytearray_@13:
$LN14@bytearray_@13:

; 1010 :         }
; 1011 :     }
; 1012 : 
; 1013 :     res = cmp ? Py_True : Py_False;

  0038e	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00396	74 11		 je	 SHORT $LN40@bytearray_@13
  00398	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0039f	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv152[rsp], rax
  003a7	eb 0f		 jmp	 SHORT $LN41@bytearray_@13
$LN40@bytearray_@13:
  003a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  003b0	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv152[rsp], rax
$LN41@bytearray_@13:
  003b8	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv152[rsp]
  003c0	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 1014 :     PyBuffer_Release(&self_bytes);

  003c5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR self_bytes$[rsp]
  003ca	e8 00 00 00 00	 call	 PyBuffer_Release

; 1015 :     PyBuffer_Release(&other_bytes);

  003cf	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR other_bytes$[rsp]
  003d7	e8 00 00 00 00	 call	 PyBuffer_Release

; 1016 :     Py_INCREF(res);

  003dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  003e1	e8 00 00 00 00	 call	 _Py_IncRef

; 1017 :     return res;

  003e6	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
$LN24@bytearray_@13:

; 1018 : }

  003eb	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  003f2	c3		 ret	 0
  003f3	90		 npad	 1
$LN42@bytearray_@13:
  003f4	00 00 00 00	 DD	 $LN6@bytearray_@13
  003f8	00 00 00 00	 DD	 $LN5@bytearray_@13
  003fc	00 00 00 00	 DD	 $LN4@bytearray_@13
  00400	00 00 00 00	 DD	 $LN3@bytearray_@13
  00404	00 00 00 00	 DD	 $LN2@bytearray_@13
  00408	00 00 00 00	 DD	 $LN1@bytearray_@13
bytearray_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@LNAAPJIN@deallocated?5bytearray?5object?5has@ ; `string'
EXTRN	PyErr_Print:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_dealloc DD imagerel bytearray_dealloc
	DD	imagerel bytearray_dealloc+101
	DD	imagerel $unwind$bytearray_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_dealloc DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0DC@LNAAPJIN@deallocated?5bytearray?5object?5has@
CONST	SEGMENT
??_C@_0DC@LNAAPJIN@deallocated?5bytearray?5object?5has@ DB 'deallocated b'
	DB	'ytearray object has exported buffers', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_dealloc
_TEXT	SEGMENT
self$ = 48
bytearray_dealloc PROC					; COMDAT

; 1022 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1023 :     if (self->ob_exports > 0) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  00012	7e 18		 jle	 SHORT $LN2@bytearray_@14

; 1024 :         PyErr_SetString(PyExc_SystemError,
; 1025 :                         "deallocated bytearray object has exported buffers");

  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LNAAPJIN@deallocated?5bytearray?5object?5has@
  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00022	e8 00 00 00 00	 call	 PyErr_SetString

; 1026 :         PyErr_Print();

  00027	e8 00 00 00 00	 call	 PyErr_Print
$LN2@bytearray_@14:

; 1027 :     }
; 1028 :     if (self->ob_bytes != 0) {

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00031	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00039	74 11		 je	 SHORT $LN1@bytearray_@14

; 1029 :         PyObject_Free(self->ob_bytes);

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00040	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00047	e8 00 00 00 00	 call	 _PyObject_DebugFree
$LN1@bytearray_@14:

; 1030 :     }
; 1031 :     Py_TYPE(self)->tp_free((PyObject *)self);

  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00051	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00055	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0005a	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 1032 : }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	c3		 ret	 0
bytearray_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ ; `string'
EXTRN	_Py_bytes_isspace:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\ctype.h
pdata	SEGMENT
$pdata$stringlib_isspace DD imagerel stringlib_isspace
	DD	imagerel stringlib_isspace+218
	DD	imagerel $unwind$stringlib_isspace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_isspace DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'l', 00H
	DB	'i', 00H, 'b', 00H, '/', 00H, 'c', 00H, 't', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_isspace
_TEXT	SEGMENT
tv92 = 32
self$ = 64
stringlib_isspace PROC					; COMDAT

; 8    : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 9    :     return _Py_bytes_isspace(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN3@stringlib_
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN3@stringlib_
  00034	41 b8 09 00 00
	00		 mov	 r8d, 9
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN3@stringlib_:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00060	74 35		 je	 SHORT $LN4@stringlib_
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00072	e8 00 00 00 00	 call	 PyType_IsSubtype
  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN4@stringlib_
  0007b	41 b8 09 00 00
	00		 mov	 r8d, 9
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00095	33 c0		 xor	 eax, eax
$LN4@stringlib_:
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a1	74 13		 je	 SHORT $LN5@stringlib_
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000af	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
  000b4	eb 0c		 jmp	 SHORT $LN6@stringlib_
$LN5@stringlib_:
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000bd	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
$LN6@stringlib_:
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv92[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_bytes_isspace

; 10   : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
stringlib_isspace ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isalpha:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_isalpha DD imagerel stringlib_isalpha
	DD	imagerel stringlib_isalpha+218
	DD	imagerel $unwind$stringlib_isalpha
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_isalpha DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_isalpha
_TEXT	SEGMENT
tv92 = 32
self$ = 64
stringlib_isalpha PROC					; COMDAT

; 14   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 15   :     return _Py_bytes_isalpha(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN3@stringlib_@2
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN3@stringlib_@2
  00034	41 b8 0f 00 00
	00		 mov	 r8d, 15
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN3@stringlib_@2:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00060	74 35		 je	 SHORT $LN4@stringlib_@2
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00072	e8 00 00 00 00	 call	 PyType_IsSubtype
  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN4@stringlib_@2
  0007b	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00095	33 c0		 xor	 eax, eax
$LN4@stringlib_@2:
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a1	74 13		 je	 SHORT $LN5@stringlib_@2
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000af	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
  000b4	eb 0c		 jmp	 SHORT $LN6@stringlib_@2
$LN5@stringlib_@2:
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000bd	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
$LN6@stringlib_@2:
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv92[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_bytes_isalpha

; 16   : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
stringlib_isalpha ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isalnum:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_isalnum DD imagerel stringlib_isalnum
	DD	imagerel stringlib_isalnum+218
	DD	imagerel $unwind$stringlib_isalnum
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_isalnum DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_isalnum
_TEXT	SEGMENT
tv92 = 32
self$ = 64
stringlib_isalnum PROC					; COMDAT

; 20   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 21   :     return _Py_bytes_isalnum(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN3@stringlib_@3
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN3@stringlib_@3
  00034	41 b8 15 00 00
	00		 mov	 r8d, 21
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN3@stringlib_@3:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00060	74 35		 je	 SHORT $LN4@stringlib_@3
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00072	e8 00 00 00 00	 call	 PyType_IsSubtype
  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN4@stringlib_@3
  0007b	41 b8 15 00 00
	00		 mov	 r8d, 21
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00095	33 c0		 xor	 eax, eax
$LN4@stringlib_@3:
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a1	74 13		 je	 SHORT $LN5@stringlib_@3
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000af	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
  000b4	eb 0c		 jmp	 SHORT $LN6@stringlib_@3
$LN5@stringlib_@3:
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000bd	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
$LN6@stringlib_@3:
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv92[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_bytes_isalnum

; 22   : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
stringlib_isalnum ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isdigit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_isdigit DD imagerel stringlib_isdigit
	DD	imagerel stringlib_isdigit+218
	DD	imagerel $unwind$stringlib_isdigit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_isdigit DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_isdigit
_TEXT	SEGMENT
tv92 = 32
self$ = 64
stringlib_isdigit PROC					; COMDAT

; 26   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 27   :     return _Py_bytes_isdigit(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN3@stringlib_@4
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN3@stringlib_@4
  00034	41 b8 1b 00 00
	00		 mov	 r8d, 27
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN3@stringlib_@4:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00060	74 35		 je	 SHORT $LN4@stringlib_@4
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00072	e8 00 00 00 00	 call	 PyType_IsSubtype
  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN4@stringlib_@4
  0007b	41 b8 1b 00 00
	00		 mov	 r8d, 27
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00095	33 c0		 xor	 eax, eax
$LN4@stringlib_@4:
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a1	74 13		 je	 SHORT $LN5@stringlib_@4
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000af	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
  000b4	eb 0c		 jmp	 SHORT $LN6@stringlib_@4
$LN5@stringlib_@4:
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000bd	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
$LN6@stringlib_@4:
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv92[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_bytes_isdigit

; 28   : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
stringlib_isdigit ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_islower:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_islower DD imagerel stringlib_islower
	DD	imagerel stringlib_islower+218
	DD	imagerel $unwind$stringlib_islower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_islower DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_islower
_TEXT	SEGMENT
tv92 = 32
self$ = 64
stringlib_islower PROC					; COMDAT

; 32   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 33   :     return _Py_bytes_islower(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN3@stringlib_@5
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN3@stringlib_@5
  00034	41 b8 21 00 00
	00		 mov	 r8d, 33			; 00000021H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN3@stringlib_@5:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00060	74 35		 je	 SHORT $LN4@stringlib_@5
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00072	e8 00 00 00 00	 call	 PyType_IsSubtype
  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN4@stringlib_@5
  0007b	41 b8 21 00 00
	00		 mov	 r8d, 33			; 00000021H
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00095	33 c0		 xor	 eax, eax
$LN4@stringlib_@5:
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a1	74 13		 je	 SHORT $LN5@stringlib_@5
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000af	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
  000b4	eb 0c		 jmp	 SHORT $LN6@stringlib_@5
$LN5@stringlib_@5:
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000bd	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
$LN6@stringlib_@5:
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv92[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_bytes_islower

; 34   : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
stringlib_islower ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isupper:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_isupper DD imagerel stringlib_isupper
	DD	imagerel stringlib_isupper+218
	DD	imagerel $unwind$stringlib_isupper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_isupper DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_isupper
_TEXT	SEGMENT
tv92 = 32
self$ = 64
stringlib_isupper PROC					; COMDAT

; 38   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 39   :     return _Py_bytes_isupper(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN3@stringlib_@6
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN3@stringlib_@6
  00034	41 b8 27 00 00
	00		 mov	 r8d, 39			; 00000027H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN3@stringlib_@6:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00060	74 35		 je	 SHORT $LN4@stringlib_@6
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00072	e8 00 00 00 00	 call	 PyType_IsSubtype
  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN4@stringlib_@6
  0007b	41 b8 27 00 00
	00		 mov	 r8d, 39			; 00000027H
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00095	33 c0		 xor	 eax, eax
$LN4@stringlib_@6:
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a1	74 13		 je	 SHORT $LN5@stringlib_@6
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000af	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
  000b4	eb 0c		 jmp	 SHORT $LN6@stringlib_@6
$LN5@stringlib_@6:
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000bd	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
$LN6@stringlib_@6:
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv92[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_bytes_isupper

; 40   : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
stringlib_isupper ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_istitle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_istitle DD imagerel stringlib_istitle
	DD	imagerel stringlib_istitle+218
	DD	imagerel $unwind$stringlib_istitle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_istitle DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_istitle
_TEXT	SEGMENT
tv92 = 32
self$ = 64
stringlib_istitle PROC					; COMDAT

; 44   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 45   :     return _Py_bytes_istitle(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN3@stringlib_@7
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN3@stringlib_@7
  00034	41 b8 2d 00 00
	00		 mov	 r8d, 45			; 0000002dH
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN3@stringlib_@7:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00060	74 35		 je	 SHORT $LN4@stringlib_@7
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00072	e8 00 00 00 00	 call	 PyType_IsSubtype
  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN4@stringlib_@7
  0007b	41 b8 2d 00 00
	00		 mov	 r8d, 45			; 0000002dH
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00095	33 c0		 xor	 eax, eax
$LN4@stringlib_@7:
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a1	74 13		 je	 SHORT $LN5@stringlib_@7
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000af	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
  000b4	eb 0c		 jmp	 SHORT $LN6@stringlib_@7
$LN5@stringlib_@7:
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000bd	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
$LN6@stringlib_@7:
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv92[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_bytes_istitle

; 46   : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
stringlib_istitle ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@NGEAEHCO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_bytes_lower:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_lower DD imagerel stringlib_lower
	DD	imagerel stringlib_lower+449
	DD	imagerel $unwind$stringlib_lower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_lower DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_1DE@NGEAEHCO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@NGEAEHCO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'n', 00H, 'e', 00H
	DB	'w', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_lower
_TEXT	SEGMENT
newobj$ = 32
tv139 = 40
tv155 = 48
self$ = 80
stringlib_lower PROC					; COMDAT

; 53   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 54   :     PyObject* newobj;
; 55   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN4@stringlib_@8
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN4@stringlib_@8
  00034	41 b8 37 00 00
	00		 mov	 r8d, 55			; 00000037H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN4@stringlib_@8:
  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00055	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00059	33 c9		 xor	 ecx, ecx
  0005b	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00060	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax

; 56   :     if (!newobj)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  0006b	75 07		 jne	 SHORT $LN1@stringlib_@8

; 57   :             return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	e9 48 01 00 00	 jmp	 $LN2@stringlib_@8
$LN1@stringlib_@8:

; 58   :     _Py_bytes_lower(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 59   :                  STRINGLIB_LEN(self));

  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00080	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00084	74 35		 je	 SHORT $LN5@stringlib_@8
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00092	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00096	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009b	85 c0		 test	 eax, eax
  0009d	75 1c		 jne	 SHORT $LN5@stringlib_@8
  0009f	41 b8 3b 00 00
	00		 mov	 r8d, 59			; 0000003bH
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b9	33 c0		 xor	 eax, eax
$LN5@stringlib_@8:
  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000c7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000cb	74 35		 je	 SHORT $LN6@stringlib_@8
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000d4	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000dd	e8 00 00 00 00	 call	 PyType_IsSubtype
  000e2	85 c0		 test	 eax, eax
  000e4	75 1c		 jne	 SHORT $LN6@stringlib_@8
  000e6	41 b8 3a 00 00
	00		 mov	 r8d, 58			; 0000003aH
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00100	33 c0		 xor	 eax, eax
$LN6@stringlib_@8:
  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00107	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0010c	74 13		 je	 SHORT $LN7@stringlib_@8
  0010e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00113	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0011a	48 89 44 24 28	 mov	 QWORD PTR tv139[rsp], rax
  0011f	eb 0c		 jmp	 SHORT $LN8@stringlib_@8
$LN7@stringlib_@8:
  00121	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00128	48 89 44 24 28	 mov	 QWORD PTR tv139[rsp], rax
$LN8@stringlib_@8:
  0012d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newobj$[rsp]
  00139	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0013d	74 35		 je	 SHORT $LN9@stringlib_@8
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  0014b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0014f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00154	85 c0		 test	 eax, eax
  00156	75 1c		 jne	 SHORT $LN9@stringlib_@8
  00158	41 b8 3a 00 00
	00		 mov	 r8d, 58			; 0000003aH
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@NGEAEHCO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00172	33 c0		 xor	 eax, eax
$LN9@stringlib_@8:
  00174	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00179	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0017e	74 13		 je	 SHORT $LN10@stringlib_@8
  00180	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00185	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0018c	48 89 44 24 30	 mov	 QWORD PTR tv155[rsp], rax
  00191	eb 0c		 jmp	 SHORT $LN11@stringlib_@8
$LN10@stringlib_@8:
  00193	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0019a	48 89 44 24 30	 mov	 QWORD PTR tv155[rsp], rax
$LN11@stringlib_@8:
  0019f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001a4	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  001a8	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv139[rsp]
  001ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv155[rsp]
  001b2	e8 00 00 00 00	 call	 _Py_bytes_lower

; 60   :     return newobj;

  001b7	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@stringlib_@8:

; 61   : }

  001bc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c0	c3		 ret	 0
stringlib_lower ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_upper:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_upper DD imagerel stringlib_upper
	DD	imagerel stringlib_upper+449
	DD	imagerel $unwind$stringlib_upper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_upper DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_upper
_TEXT	SEGMENT
newobj$ = 32
tv139 = 40
tv155 = 48
self$ = 80
stringlib_upper PROC					; COMDAT

; 65   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 66   :     PyObject* newobj;
; 67   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN4@stringlib_@9
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN4@stringlib_@9
  00034	41 b8 43 00 00
	00		 mov	 r8d, 67			; 00000043H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN4@stringlib_@9:
  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00055	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00059	33 c9		 xor	 ecx, ecx
  0005b	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00060	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax

; 68   :     if (!newobj)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  0006b	75 07		 jne	 SHORT $LN1@stringlib_@9

; 69   :             return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	e9 48 01 00 00	 jmp	 $LN2@stringlib_@9
$LN1@stringlib_@9:

; 70   :     _Py_bytes_upper(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 71   :                  STRINGLIB_LEN(self));

  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00080	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00084	74 35		 je	 SHORT $LN5@stringlib_@9
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00092	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00096	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009b	85 c0		 test	 eax, eax
  0009d	75 1c		 jne	 SHORT $LN5@stringlib_@9
  0009f	41 b8 47 00 00
	00		 mov	 r8d, 71			; 00000047H
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b9	33 c0		 xor	 eax, eax
$LN5@stringlib_@9:
  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000c7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000cb	74 35		 je	 SHORT $LN6@stringlib_@9
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000d4	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000dd	e8 00 00 00 00	 call	 PyType_IsSubtype
  000e2	85 c0		 test	 eax, eax
  000e4	75 1c		 jne	 SHORT $LN6@stringlib_@9
  000e6	41 b8 46 00 00
	00		 mov	 r8d, 70			; 00000046H
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00100	33 c0		 xor	 eax, eax
$LN6@stringlib_@9:
  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00107	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0010c	74 13		 je	 SHORT $LN7@stringlib_@9
  0010e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00113	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0011a	48 89 44 24 28	 mov	 QWORD PTR tv139[rsp], rax
  0011f	eb 0c		 jmp	 SHORT $LN8@stringlib_@9
$LN7@stringlib_@9:
  00121	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00128	48 89 44 24 28	 mov	 QWORD PTR tv139[rsp], rax
$LN8@stringlib_@9:
  0012d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newobj$[rsp]
  00139	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0013d	74 35		 je	 SHORT $LN9@stringlib_@9
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  0014b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0014f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00154	85 c0		 test	 eax, eax
  00156	75 1c		 jne	 SHORT $LN9@stringlib_@9
  00158	41 b8 46 00 00
	00		 mov	 r8d, 70			; 00000046H
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@NGEAEHCO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00172	33 c0		 xor	 eax, eax
$LN9@stringlib_@9:
  00174	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00179	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0017e	74 13		 je	 SHORT $LN10@stringlib_@9
  00180	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00185	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0018c	48 89 44 24 30	 mov	 QWORD PTR tv155[rsp], rax
  00191	eb 0c		 jmp	 SHORT $LN11@stringlib_@9
$LN10@stringlib_@9:
  00193	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0019a	48 89 44 24 30	 mov	 QWORD PTR tv155[rsp], rax
$LN11@stringlib_@9:
  0019f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001a4	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  001a8	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv139[rsp]
  001ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv155[rsp]
  001b2	e8 00 00 00 00	 call	 _Py_bytes_upper

; 72   :     return newobj;

  001b7	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@stringlib_@9:

; 73   : }

  001bc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c0	c3		 ret	 0
stringlib_upper ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_title:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_title DD imagerel stringlib_title
	DD	imagerel stringlib_title+449
	DD	imagerel $unwind$stringlib_title
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_title DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_title
_TEXT	SEGMENT
newobj$ = 32
tv139 = 40
tv155 = 48
self$ = 80
stringlib_title PROC					; COMDAT

; 77   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 78   :     PyObject* newobj;
; 79   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN4@stringlib_@10
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN4@stringlib_@10
  00034	41 b8 4f 00 00
	00		 mov	 r8d, 79			; 0000004fH
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN4@stringlib_@10:
  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00055	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00059	33 c9		 xor	 ecx, ecx
  0005b	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00060	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax

; 80   :     if (!newobj)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  0006b	75 07		 jne	 SHORT $LN1@stringlib_@10

; 81   :             return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	e9 48 01 00 00	 jmp	 $LN2@stringlib_@10
$LN1@stringlib_@10:

; 82   :     _Py_bytes_title(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 83   :                  STRINGLIB_LEN(self));

  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00080	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00084	74 35		 je	 SHORT $LN5@stringlib_@10
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00092	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00096	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009b	85 c0		 test	 eax, eax
  0009d	75 1c		 jne	 SHORT $LN5@stringlib_@10
  0009f	41 b8 53 00 00
	00		 mov	 r8d, 83			; 00000053H
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b9	33 c0		 xor	 eax, eax
$LN5@stringlib_@10:
  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000c7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000cb	74 35		 je	 SHORT $LN6@stringlib_@10
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000d4	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000dd	e8 00 00 00 00	 call	 PyType_IsSubtype
  000e2	85 c0		 test	 eax, eax
  000e4	75 1c		 jne	 SHORT $LN6@stringlib_@10
  000e6	41 b8 52 00 00
	00		 mov	 r8d, 82			; 00000052H
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00100	33 c0		 xor	 eax, eax
$LN6@stringlib_@10:
  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00107	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0010c	74 13		 je	 SHORT $LN7@stringlib_@10
  0010e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00113	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0011a	48 89 44 24 28	 mov	 QWORD PTR tv139[rsp], rax
  0011f	eb 0c		 jmp	 SHORT $LN8@stringlib_@10
$LN7@stringlib_@10:
  00121	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00128	48 89 44 24 28	 mov	 QWORD PTR tv139[rsp], rax
$LN8@stringlib_@10:
  0012d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newobj$[rsp]
  00139	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0013d	74 35		 je	 SHORT $LN9@stringlib_@10
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  0014b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0014f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00154	85 c0		 test	 eax, eax
  00156	75 1c		 jne	 SHORT $LN9@stringlib_@10
  00158	41 b8 52 00 00
	00		 mov	 r8d, 82			; 00000052H
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@NGEAEHCO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00172	33 c0		 xor	 eax, eax
$LN9@stringlib_@10:
  00174	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00179	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0017e	74 13		 je	 SHORT $LN10@stringlib_@10
  00180	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00185	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0018c	48 89 44 24 30	 mov	 QWORD PTR tv155[rsp], rax
  00191	eb 0c		 jmp	 SHORT $LN11@stringlib_@10
$LN10@stringlib_@10:
  00193	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0019a	48 89 44 24 30	 mov	 QWORD PTR tv155[rsp], rax
$LN11@stringlib_@10:
  0019f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001a4	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  001a8	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv139[rsp]
  001ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv155[rsp]
  001b2	e8 00 00 00 00	 call	 _Py_bytes_title

; 84   :     return newobj;

  001b7	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@stringlib_@10:

; 85   : }

  001bc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c0	c3		 ret	 0
stringlib_title ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_capitalize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_capitalize DD imagerel stringlib_capitalize
	DD	imagerel stringlib_capitalize+449
	DD	imagerel $unwind$stringlib_capitalize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_capitalize DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_capitalize
_TEXT	SEGMENT
newobj$ = 32
tv139 = 40
tv155 = 48
self$ = 80
stringlib_capitalize PROC				; COMDAT

; 89   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 90   :     PyObject* newobj;
; 91   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN4@stringlib_@11
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN4@stringlib_@11
  00034	41 b8 5b 00 00
	00		 mov	 r8d, 91			; 0000005bH
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN4@stringlib_@11:
  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00055	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00059	33 c9		 xor	 ecx, ecx
  0005b	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00060	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax

; 92   :     if (!newobj)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  0006b	75 07		 jne	 SHORT $LN1@stringlib_@11

; 93   :             return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	e9 48 01 00 00	 jmp	 $LN2@stringlib_@11
$LN1@stringlib_@11:

; 94   :     _Py_bytes_capitalize(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 95   :                       STRINGLIB_LEN(self));

  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00080	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00084	74 35		 je	 SHORT $LN5@stringlib_@11
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00092	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00096	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009b	85 c0		 test	 eax, eax
  0009d	75 1c		 jne	 SHORT $LN5@stringlib_@11
  0009f	41 b8 5f 00 00
	00		 mov	 r8d, 95			; 0000005fH
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b9	33 c0		 xor	 eax, eax
$LN5@stringlib_@11:
  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000c7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000cb	74 35		 je	 SHORT $LN6@stringlib_@11
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000d4	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000dd	e8 00 00 00 00	 call	 PyType_IsSubtype
  000e2	85 c0		 test	 eax, eax
  000e4	75 1c		 jne	 SHORT $LN6@stringlib_@11
  000e6	41 b8 5e 00 00
	00		 mov	 r8d, 94			; 0000005eH
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00100	33 c0		 xor	 eax, eax
$LN6@stringlib_@11:
  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00107	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0010c	74 13		 je	 SHORT $LN7@stringlib_@11
  0010e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00113	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0011a	48 89 44 24 28	 mov	 QWORD PTR tv139[rsp], rax
  0011f	eb 0c		 jmp	 SHORT $LN8@stringlib_@11
$LN7@stringlib_@11:
  00121	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00128	48 89 44 24 28	 mov	 QWORD PTR tv139[rsp], rax
$LN8@stringlib_@11:
  0012d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newobj$[rsp]
  00139	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0013d	74 35		 je	 SHORT $LN9@stringlib_@11
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  0014b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0014f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00154	85 c0		 test	 eax, eax
  00156	75 1c		 jne	 SHORT $LN9@stringlib_@11
  00158	41 b8 5e 00 00
	00		 mov	 r8d, 94			; 0000005eH
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@NGEAEHCO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00172	33 c0		 xor	 eax, eax
$LN9@stringlib_@11:
  00174	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00179	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0017e	74 13		 je	 SHORT $LN10@stringlib_@11
  00180	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00185	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0018c	48 89 44 24 30	 mov	 QWORD PTR tv155[rsp], rax
  00191	eb 0c		 jmp	 SHORT $LN11@stringlib_@11
$LN10@stringlib_@11:
  00193	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0019a	48 89 44 24 30	 mov	 QWORD PTR tv155[rsp], rax
$LN11@stringlib_@11:
  0019f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001a4	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  001a8	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv139[rsp]
  001ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv155[rsp]
  001b2	e8 00 00 00 00	 call	 _Py_bytes_capitalize

; 96   :     return newobj;

  001b7	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@stringlib_@11:

; 97   : }

  001bc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c0	c3		 ret	 0
stringlib_capitalize ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_swapcase:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_swapcase DD imagerel stringlib_swapcase
	DD	imagerel stringlib_swapcase+449
	DD	imagerel $unwind$stringlib_swapcase
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_swapcase DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_swapcase
_TEXT	SEGMENT
newobj$ = 32
tv139 = 40
tv155 = 48
self$ = 80
stringlib_swapcase PROC					; COMDAT

; 101  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 102  :     PyObject* newobj;
; 103  :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN4@stringlib_@12
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN4@stringlib_@12
  00034	41 b8 67 00 00
	00		 mov	 r8d, 103		; 00000067H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN4@stringlib_@12:
  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00055	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00059	33 c9		 xor	 ecx, ecx
  0005b	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00060	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax

; 104  :     if (!newobj)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  0006b	75 07		 jne	 SHORT $LN1@stringlib_@12

; 105  :             return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	e9 48 01 00 00	 jmp	 $LN2@stringlib_@12
$LN1@stringlib_@12:

; 106  :     _Py_bytes_swapcase(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 107  :                     STRINGLIB_LEN(self));

  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00080	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00084	74 35		 je	 SHORT $LN5@stringlib_@12
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00092	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00096	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009b	85 c0		 test	 eax, eax
  0009d	75 1c		 jne	 SHORT $LN5@stringlib_@12
  0009f	41 b8 6b 00 00
	00		 mov	 r8d, 107		; 0000006bH
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b9	33 c0		 xor	 eax, eax
$LN5@stringlib_@12:
  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000c7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000cb	74 35		 je	 SHORT $LN6@stringlib_@12
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000d4	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000dd	e8 00 00 00 00	 call	 PyType_IsSubtype
  000e2	85 c0		 test	 eax, eax
  000e4	75 1c		 jne	 SHORT $LN6@stringlib_@12
  000e6	41 b8 6a 00 00
	00		 mov	 r8d, 106		; 0000006aH
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00100	33 c0		 xor	 eax, eax
$LN6@stringlib_@12:
  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00107	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0010c	74 13		 je	 SHORT $LN7@stringlib_@12
  0010e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00113	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0011a	48 89 44 24 28	 mov	 QWORD PTR tv139[rsp], rax
  0011f	eb 0c		 jmp	 SHORT $LN8@stringlib_@12
$LN7@stringlib_@12:
  00121	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00128	48 89 44 24 28	 mov	 QWORD PTR tv139[rsp], rax
$LN8@stringlib_@12:
  0012d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newobj$[rsp]
  00139	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0013d	74 35		 je	 SHORT $LN9@stringlib_@12
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  0014b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0014f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00154	85 c0		 test	 eax, eax
  00156	75 1c		 jne	 SHORT $LN9@stringlib_@12
  00158	41 b8 6a 00 00
	00		 mov	 r8d, 106		; 0000006aH
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FI@DHLFHKBK@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@NGEAEHCO@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00172	33 c0		 xor	 eax, eax
$LN9@stringlib_@12:
  00174	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00179	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0017e	74 13		 je	 SHORT $LN10@stringlib_@12
  00180	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00185	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0018c	48 89 44 24 30	 mov	 QWORD PTR tv155[rsp], rax
  00191	eb 0c		 jmp	 SHORT $LN11@stringlib_@12
$LN10@stringlib_@12:
  00193	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0019a	48 89 44 24 30	 mov	 QWORD PTR tv155[rsp], rax
$LN11@stringlib_@12:
  0019f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001a4	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  001a8	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv139[rsp]
  001ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv155[rsp]
  001b2	e8 00 00 00 00	 call	 _Py_bytes_swapcase

; 108  :     return newobj;

  001b7	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@stringlib_@12:

; 109  : }

  001bc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c0	c3		 ret	 0
stringlib_swapcase ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@CMHEKGGP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@	; `string'
PUBLIC	??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ ; `string'
PUBLIC	??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@	; `string'
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\transmogrify.h
pdata	SEGMENT
$pdata$stringlib_expandtabs DD imagerel stringlib_expandtabs
	DD	imagerel stringlib_expandtabs+1351
	DD	imagerel $unwind$stringlib_expandtabs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_expandtabs DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_1CK@CMHEKGGP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@CMHEKGGP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'u', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@ DB 'result is too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'l', 00H
	DB	'i', 00H, 'b', 00H, '/', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 's', 00H, 'm', 00H, 'o', 00H, 'g', 00H, 'r', 00H, 'i', 00H
	DB	'f', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@
CONST	SEGMENT
??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@ DB '|i:expandtabs', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_expandtabs
_TEXT	SEGMENT
p$ = 32
i$ = 40
u$ = 48
tabsize$ = 56
q$ = 64
e$ = 72
j$ = 80
tv83 = 88
tv143 = 96
tv149 = 104
tv189 = 112
tv204 = 120
tv210 = 128
self$ = 160
args$ = 168
stringlib_expandtabs PROC				; COMDAT

; 15   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 16   :     const char *e, *p;
; 17   :     char *q;
; 18   :     size_t i, j;
; 19   :     PyObject *u;
; 20   :     int tabsize = 8;

  00011	c7 44 24 38 08
	00 00 00	 mov	 DWORD PTR tabsize$[rsp], 8

; 21   : 
; 22   :     if (!PyArg_ParseTuple(args, "|i:expandtabs", &tabsize))

  00019	4c 8d 44 24 38	 lea	 r8, QWORD PTR tabsize$[rsp]
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@
  00025	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0002d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN23@stringlib_@13

; 23   :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 02 05 00 00	 jmp	 $LN24@stringlib_@13
$LN23@stringlib_@13:

; 24   : 
; 25   :     /* First pass: determine size of output string */
; 26   :     i = j = 0;

  0003d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0004b	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 27   :     e = STRINGLIB_STR(self) + STRINGLIB_LEN(self);

  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00057	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0005f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00063	74 38		 je	 SHORT $LN26@stringlib_@13
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0006c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00074	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	75 1c		 jne	 SHORT $LN26@stringlib_@13
  00081	41 b8 1b 00 00
	00		 mov	 r8d, 27
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009b	33 c0		 xor	 eax, eax
$LN26@stringlib_@13:
  0009d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a5	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000aa	74 16		 je	 SHORT $LN27@stringlib_@13
  000ac	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000b4	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000bb	48 89 44 24 58	 mov	 QWORD PTR tv83[rsp], rax
  000c0	eb 0c		 jmp	 SHORT $LN28@stringlib_@13
$LN27@stringlib_@13:
  000c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000c9	48 89 44 24 58	 mov	 QWORD PTR tv83[rsp], rax
$LN28@stringlib_@13:
  000ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000d5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000dd	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000e1	74 38		 je	 SHORT $LN29@stringlib_@13
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000ea	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000f2	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000f6	e8 00 00 00 00	 call	 PyType_IsSubtype
  000fb	85 c0		 test	 eax, eax
  000fd	75 1c		 jne	 SHORT $LN29@stringlib_@13
  000ff	41 b8 1b 00 00
	00		 mov	 r8d, 27
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00119	33 c0		 xor	 eax, eax
$LN29@stringlib_@13:
  0011b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00123	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00127	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv83[rsp]
  0012c	48 03 c8	 add	 rcx, rax
  0012f	48 8b c1	 mov	 rax, rcx
  00132	48 89 44 24 48	 mov	 QWORD PTR e$[rsp], rax

; 28   :     for (p = STRINGLIB_STR(self); p < e; p++)

  00137	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0013e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00146	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0014a	74 38		 je	 SHORT $LN30@stringlib_@13
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00153	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0015b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0015f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00164	85 c0		 test	 eax, eax
  00166	75 1c		 jne	 SHORT $LN30@stringlib_@13
  00168	41 b8 1c 00 00
	00		 mov	 r8d, 28
  0016e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00182	33 c0		 xor	 eax, eax
$LN30@stringlib_@13:
  00184	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0018c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00191	74 16		 je	 SHORT $LN31@stringlib_@13
  00193	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0019b	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  001a2	48 89 44 24 60	 mov	 QWORD PTR tv143[rsp], rax
  001a7	eb 0c		 jmp	 SHORT $LN32@stringlib_@13
$LN31@stringlib_@13:
  001a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  001b0	48 89 44 24 60	 mov	 QWORD PTR tv143[rsp], rax
$LN32@stringlib_@13:
  001b5	48 8b 44 24 60	 mov	 rax, QWORD PTR tv143[rsp]
  001ba	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  001bf	eb 0d		 jmp	 SHORT $LN22@stringlib_@13
$LN21@stringlib_@13:
  001c1	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001c6	48 ff c0	 inc	 rax
  001c9	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN22@stringlib_@13:
  001ce	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  001d3	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  001d8	0f 83 ed 00 00
	00		 jae	 $LN20@stringlib_@13

; 29   :         if (*p == '\t') {

  001de	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001e3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001e6	83 f8 09	 cmp	 eax, 9
  001e9	75 6b		 jne	 SHORT $LN19@stringlib_@13

; 30   :             if (tabsize > 0) {

  001eb	83 7c 24 38 00	 cmp	 DWORD PTR tabsize$[rsp], 0
  001f0	7e 62		 jle	 SHORT $LN18@stringlib_@13

; 31   :                 j += tabsize - (j % tabsize);

  001f2	48 63 44 24 38	 movsxd	 rax, DWORD PTR tabsize$[rsp]
  001f7	48 89 44 24 68	 mov	 QWORD PTR tv149[rsp], rax
  001fc	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR tabsize$[rsp]
  00201	33 d2		 xor	 edx, edx
  00203	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00208	48 f7 f1	 div	 rcx
  0020b	48 8b c2	 mov	 rax, rdx
  0020e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv149[rsp]
  00213	48 2b c8	 sub	 rcx, rax
  00216	48 8b c1	 mov	 rax, rcx
  00219	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  0021e	48 03 c8	 add	 rcx, rax
  00221	48 8b c1	 mov	 rax, rcx
  00224	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax

; 32   :                 if (j > PY_SSIZE_T_MAX) {

  00229	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00233	48 39 44 24 50	 cmp	 QWORD PTR j$[rsp], rax
  00238	76 1a		 jbe	 SHORT $LN17@stringlib_@13

; 33   :                     PyErr_SetString(PyExc_OverflowError,
; 34   :                                     "result is too long");

  0023a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@
  00241	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00248	e8 00 00 00 00	 call	 PyErr_SetString

; 35   :                     return NULL;

  0024d	33 c0		 xor	 eax, eax
  0024f	e9 eb 02 00 00	 jmp	 $LN24@stringlib_@13
$LN17@stringlib_@13:
$LN18@stringlib_@13:

; 36   :                 }
; 37   :             }
; 38   :         }
; 39   :         else {

  00254	eb 70		 jmp	 SHORT $LN16@stringlib_@13
$LN19@stringlib_@13:

; 40   :             j++;

  00256	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0025b	48 ff c0	 inc	 rax
  0025e	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax

; 41   :             if (*p == '\n' || *p == '\r') {

  00263	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00268	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0026b	83 f8 0a	 cmp	 eax, 10
  0026e	74 0d		 je	 SHORT $LN14@stringlib_@13
  00270	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00275	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00278	83 f8 0d	 cmp	 eax, 13
  0027b	75 49		 jne	 SHORT $LN15@stringlib_@13
$LN14@stringlib_@13:

; 42   :                 i += j;

  0027d	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00282	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00287	48 03 c8	 add	 rcx, rax
  0028a	48 8b c1	 mov	 rax, rcx
  0028d	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 43   :                 j = 0;

  00292	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0

; 44   :                 if (i > PY_SSIZE_T_MAX) {

  0029b	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  002a5	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  002aa	76 1a		 jbe	 SHORT $LN13@stringlib_@13

; 45   :                     PyErr_SetString(PyExc_OverflowError,
; 46   :                                     "result is too long");

  002ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@
  002b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  002ba	e8 00 00 00 00	 call	 PyErr_SetString

; 47   :                     return NULL;

  002bf	33 c0		 xor	 eax, eax
  002c1	e9 79 02 00 00	 jmp	 $LN24@stringlib_@13
$LN13@stringlib_@13:
$LN15@stringlib_@13:
$LN16@stringlib_@13:

; 48   :                 }
; 49   :             }
; 50   :         }

  002c6	e9 f6 fe ff ff	 jmp	 $LN21@stringlib_@13
$LN20@stringlib_@13:

; 51   : 
; 52   :     if ((i + j) > PY_SSIZE_T_MAX) {

  002cb	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  002d0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  002d5	48 03 c8	 add	 rcx, rax
  002d8	48 8b c1	 mov	 rax, rcx
  002db	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  002e5	48 3b c1	 cmp	 rax, rcx
  002e8	76 1a		 jbe	 SHORT $LN12@stringlib_@13

; 53   :         PyErr_SetString(PyExc_OverflowError, "result is too long");

  002ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@
  002f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  002f8	e8 00 00 00 00	 call	 PyErr_SetString

; 54   :         return NULL;

  002fd	33 c0		 xor	 eax, eax
  002ff	e9 3b 02 00 00	 jmp	 $LN24@stringlib_@13
$LN12@stringlib_@13:

; 55   :     }
; 56   : 
; 57   :     /* Second pass: create output string and fill it */
; 58   :     u = STRINGLIB_NEW(NULL, i + j);

  00304	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00309	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0030e	48 03 c8	 add	 rcx, rax
  00311	48 8b c1	 mov	 rax, rcx
  00314	48 8b d0	 mov	 rdx, rax
  00317	33 c9		 xor	 ecx, ecx
  00319	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0031e	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax

; 59   :     if (!u)

  00323	48 83 7c 24 30
	00		 cmp	 QWORD PTR u$[rsp], 0
  00329	75 07		 jne	 SHORT $LN11@stringlib_@13

; 60   :         return NULL;

  0032b	33 c0		 xor	 eax, eax
  0032d	e9 0d 02 00 00	 jmp	 $LN24@stringlib_@13
$LN11@stringlib_@13:

; 61   : 
; 62   :     j = 0;

  00332	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0

; 63   :     q = STRINGLIB_STR(u);

  0033b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00342	48 8b 4c 24 30	 mov	 rcx, QWORD PTR u$[rsp]
  00347	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0034b	74 35		 je	 SHORT $LN33@stringlib_@13
  0034d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00354	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  00359	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0035d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00362	85 c0		 test	 eax, eax
  00364	75 1c		 jne	 SHORT $LN33@stringlib_@13
  00366	41 b8 3f 00 00
	00		 mov	 r8d, 63			; 0000003fH
  0036c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00373	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@CMHEKGGP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  0037a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00380	33 c0		 xor	 eax, eax
$LN33@stringlib_@13:
  00382	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  00387	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0038c	74 13		 je	 SHORT $LN34@stringlib_@13
  0038e	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
  00393	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0039a	48 89 44 24 70	 mov	 QWORD PTR tv189[rsp], rax
  0039f	eb 0c		 jmp	 SHORT $LN35@stringlib_@13
$LN34@stringlib_@13:
  003a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  003a8	48 89 44 24 70	 mov	 QWORD PTR tv189[rsp], rax
$LN35@stringlib_@13:
  003ad	48 8b 44 24 70	 mov	 rax, QWORD PTR tv189[rsp]
  003b2	48 89 44 24 40	 mov	 QWORD PTR q$[rsp], rax

; 64   : 
; 65   :     for (p = STRINGLIB_STR(self); p < e; p++)

  003b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  003be	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  003c6	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  003ca	74 38		 je	 SHORT $LN36@stringlib_@13
  003cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  003d3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003db	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  003df	e8 00 00 00 00	 call	 PyType_IsSubtype
  003e4	85 c0		 test	 eax, eax
  003e6	75 1c		 jne	 SHORT $LN36@stringlib_@13
  003e8	41 b8 41 00 00
	00		 mov	 r8d, 65			; 00000041H
  003ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  003f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  003fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00402	33 c0		 xor	 eax, eax
$LN36@stringlib_@13:
  00404	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0040c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00411	74 16		 je	 SHORT $LN37@stringlib_@13
  00413	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0041b	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00422	48 89 44 24 78	 mov	 QWORD PTR tv204[rsp], rax
  00427	eb 0c		 jmp	 SHORT $LN38@stringlib_@13
$LN37@stringlib_@13:
  00429	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00430	48 89 44 24 78	 mov	 QWORD PTR tv204[rsp], rax
$LN38@stringlib_@13:
  00435	48 8b 44 24 78	 mov	 rax, QWORD PTR tv204[rsp]
  0043a	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0043f	eb 0d		 jmp	 SHORT $LN10@stringlib_@13
$LN9@stringlib_@13:
  00441	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00446	48 ff c0	 inc	 rax
  00449	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN10@stringlib_@13:
  0044e	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
  00453	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  00458	0f 83 dc 00 00
	00		 jae	 $LN8@stringlib_@13

; 66   :         if (*p == '\t') {

  0045e	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00463	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00466	83 f8 09	 cmp	 eax, 9
  00469	75 7e		 jne	 SHORT $LN7@stringlib_@13

; 67   :             if (tabsize > 0) {

  0046b	83 7c 24 38 00	 cmp	 DWORD PTR tabsize$[rsp], 0
  00470	7e 75		 jle	 SHORT $LN6@stringlib_@13

; 68   :                 i = tabsize - (j % tabsize);

  00472	48 63 44 24 38	 movsxd	 rax, DWORD PTR tabsize$[rsp]
  00477	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv210[rsp], rax
  0047f	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR tabsize$[rsp]
  00484	33 d2		 xor	 edx, edx
  00486	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0048b	48 f7 f1	 div	 rcx
  0048e	48 8b c2	 mov	 rax, rdx
  00491	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv210[rsp]
  00499	48 2b c8	 sub	 rcx, rax
  0049c	48 8b c1	 mov	 rax, rcx
  0049f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 69   :                 j += i;

  004a4	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  004a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  004ae	48 03 c8	 add	 rcx, rax
  004b1	48 8b c1	 mov	 rax, rcx
  004b4	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax
$LN5@stringlib_@13:

; 70   :                 while (i--)

  004b9	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  004be	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  004c3	48 ff c9	 dec	 rcx
  004c6	48 89 4c 24 28	 mov	 QWORD PTR i$[rsp], rcx
  004cb	48 85 c0	 test	 rax, rax
  004ce	74 17		 je	 SHORT $LN4@stringlib_@13

; 71   :                     *q++ = ' ';

  004d0	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  004d5	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H
  004d8	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  004dd	48 ff c0	 inc	 rax
  004e0	48 89 44 24 40	 mov	 QWORD PTR q$[rsp], rax
  004e5	eb d2		 jmp	 SHORT $LN5@stringlib_@13
$LN4@stringlib_@13:
$LN6@stringlib_@13:

; 72   :             }
; 73   :         }
; 74   :         else {

  004e7	eb 4c		 jmp	 SHORT $LN3@stringlib_@13
$LN7@stringlib_@13:

; 75   :             j++;

  004e9	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  004ee	48 ff c0	 inc	 rax
  004f1	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax

; 76   :             *q++ = *p;

  004f6	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  004fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00500	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00503	88 08		 mov	 BYTE PTR [rax], cl
  00505	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  0050a	48 ff c0	 inc	 rax
  0050d	48 89 44 24 40	 mov	 QWORD PTR q$[rsp], rax

; 77   :             if (*p == '\n' || *p == '\r')

  00512	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00517	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0051a	83 f8 0a	 cmp	 eax, 10
  0051d	74 0d		 je	 SHORT $LN1@stringlib_@13
  0051f	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00524	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00527	83 f8 0d	 cmp	 eax, 13
  0052a	75 09		 jne	 SHORT $LN2@stringlib_@13
$LN1@stringlib_@13:

; 78   :                 j = 0;

  0052c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
$LN2@stringlib_@13:
$LN3@stringlib_@13:

; 79   :         }

  00535	e9 07 ff ff ff	 jmp	 $LN9@stringlib_@13
$LN8@stringlib_@13:

; 80   : 
; 81   :     return u;

  0053a	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]
$LN24@stringlib_@13:

; 82   : }

  0053f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00546	c3		 ret	 0
stringlib_expandtabs ENDP
_TEXT	ENDS
PUBLIC	??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_ljust DD imagerel stringlib_ljust
	DD	imagerel stringlib_ljust+493
	DD	imagerel $unwind$stringlib_ljust
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_ljust DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@
CONST	SEGMENT
??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@ DB 'n|c:ljust', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_ljust
_TEXT	SEGMENT
width$ = 32
fillchar$ = 40
tv145 = 48
self$ = 80
args$ = 88
stringlib_ljust PROC					; COMDAT

; 129  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 130  :     Py_ssize_t width;
; 131  :     char fillchar = ' ';

  0000e	c6 44 24 28 20	 mov	 BYTE PTR fillchar$[rsp], 32 ; 00000020H

; 132  : 
; 133  :     if (!PyArg_ParseTuple(args, "n|c:ljust", &width, &fillchar))

  00013	4c 8d 4c 24 28	 lea	 r9, QWORD PTR fillchar$[rsp]
  00018	4c 8d 44 24 20	 lea	 r8, QWORD PTR width$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@
  00024	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 07		 jne	 SHORT $LN2@stringlib_@14

; 134  :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 af 01 00 00	 jmp	 $LN3@stringlib_@14
$LN2@stringlib_@14:

; 135  : 
; 136  :     if (STRINGLIB_LEN(self) >= width && STRINGLIB_CHECK_EXACT(self)) {

  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00045	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00049	74 35		 je	 SHORT $LN5@stringlib_@14
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 1c		 jne	 SHORT $LN5@stringlib_@14
  00064	41 b8 88 00 00
	00		 mov	 r8d, 136		; 00000088H
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN5@stringlib_@14:
  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR width$[rsp]
  0008a	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0008e	0f 8c e4 00 00
	00		 jl	 $LN1@stringlib_@14
  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000a0	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000a4	0f 85 ce 00 00
	00		 jne	 $LN1@stringlib_@14

; 137  : #if STRINGLIB_MUTABLE
; 138  :         /* We're defined as returning a copy;  If the object is mutable
; 139  :          * that means we must make an identical copy. */
; 140  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  000aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000b6	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000ba	74 35		 je	 SHORT $LN6@stringlib_@14
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c8	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000cc	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d1	85 c0		 test	 eax, eax
  000d3	75 1c		 jne	 SHORT $LN6@stringlib_@14
  000d5	41 b8 8c 00 00
	00		 mov	 r8d, 140		; 0000008cH
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ef	33 c0		 xor	 eax, eax
$LN6@stringlib_@14:
  000f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000fd	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00101	74 35		 je	 SHORT $LN7@stringlib_@14
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0010a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0010f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00113	e8 00 00 00 00	 call	 PyType_IsSubtype
  00118	85 c0		 test	 eax, eax
  0011a	75 1c		 jne	 SHORT $LN7@stringlib_@14
  0011c	41 b8 8c 00 00
	00		 mov	 r8d, 140		; 0000008cH
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00136	33 c0		 xor	 eax, eax
$LN7@stringlib_@14:
  00138	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0013d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00142	74 13		 je	 SHORT $LN8@stringlib_@14
  00144	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00149	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00150	48 89 44 24 30	 mov	 QWORD PTR tv145[rsp], rax
  00155	eb 0c		 jmp	 SHORT $LN9@stringlib_@14
$LN8@stringlib_@14:
  00157	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0015e	48 89 44 24 30	 mov	 QWORD PTR tv145[rsp], rax
$LN9@stringlib_@14:
  00163	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00168	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0016c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv145[rsp]
  00171	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00176	eb 70		 jmp	 SHORT $LN3@stringlib_@14
$LN1@stringlib_@14:

; 141  : #else
; 142  :         Py_INCREF(self);
; 143  :         return (PyObject*) self;
; 144  : #endif
; 145  :     }
; 146  : 
; 147  :     return pad(self, 0, width - STRINGLIB_LEN(self), fillchar);

  00178	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0017f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00184	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00188	74 35		 je	 SHORT $LN10@stringlib_@14
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00191	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00196	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0019a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0019f	85 c0		 test	 eax, eax
  001a1	75 1c		 jne	 SHORT $LN10@stringlib_@14
  001a3	41 b8 93 00 00
	00		 mov	 r8d, 147		; 00000093H
  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001bd	33 c0		 xor	 eax, eax
$LN10@stringlib_@14:
  001bf	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001c4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR width$[rsp]
  001cd	48 2b c8	 sub	 rcx, rax
  001d0	48 8b c1	 mov	 rax, rcx
  001d3	44 0f b6 4c 24
	28		 movzx	 r9d, BYTE PTR fillchar$[rsp]
  001d9	4c 8b c0	 mov	 r8, rax
  001dc	33 d2		 xor	 edx, edx
  001de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  001e3	e8 00 00 00 00	 call	 pad
$LN3@stringlib_@14:

; 148  : }

  001e8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ec	c3		 ret	 0
stringlib_ljust ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pad DD	imagerel pad
	DD	imagerel pad+1403
	DD	imagerel $unwind$pad
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pad DD	011801H
	DD	0e218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pad
_TEXT	SEGMENT
u$ = 32
t_$22262 = 40
s_$22269 = 48
i_$22256 = 56
n_$22257 = 64
tv130 = 72
tv169 = 80
tv196 = 88
tv212 = 96
tv241 = 104
self$ = 128
left$ = 136
right$ = 144
fill$ = 152
pad	PROC						; COMDAT

; 86   : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 87   :     PyObject *u;
; 88   : 
; 89   :     if (left < 0)

  00018	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR left$[rsp], 0
  00021	7d 0c		 jge	 SHORT $LN14@pad

; 90   :         left = 0;

  00023	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR left$[rsp], 0
$LN14@pad:

; 91   :     if (right < 0)

  0002f	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR right$[rsp], 0
  00038	7d 0c		 jge	 SHORT $LN13@pad

; 92   :         right = 0;

  0003a	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR right$[rsp], 0
$LN13@pad:

; 93   : 
; 94   :     if (left == 0 && right == 0 && STRINGLIB_CHECK_EXACT(self)) {

  00046	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR left$[rsp], 0
  0004f	0f 85 0e 01 00
	00		 jne	 $LN12@pad
  00055	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR right$[rsp], 0
  0005e	0f 85 ff 00 00
	00		 jne	 $LN12@pad
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0006b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00073	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00077	0f 85 e6 00 00
	00		 jne	 $LN12@pad

; 95   : #if STRINGLIB_MUTABLE
; 96   :         /* We're defined as returning a copy;  If the object is mutable
; 97   :          * that means we must make an identical copy. */
; 98   :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00084	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0008c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00090	74 38		 je	 SHORT $LN17@pad
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00099	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a1	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000a5	e8 00 00 00 00	 call	 PyType_IsSubtype
  000aa	85 c0		 test	 eax, eax
  000ac	75 1c		 jne	 SHORT $LN17@pad
  000ae	41 b8 62 00 00
	00		 mov	 r8d, 98			; 00000062H
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c8	33 c0		 xor	 eax, eax
$LN17@pad:
  000ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000d1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000d9	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000dd	74 38		 je	 SHORT $LN18@pad
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000e6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000ee	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000f2	e8 00 00 00 00	 call	 PyType_IsSubtype
  000f7	85 c0		 test	 eax, eax
  000f9	75 1c		 jne	 SHORT $LN18@pad
  000fb	41 b8 62 00 00
	00		 mov	 r8d, 98			; 00000062H
  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00115	33 c0		 xor	 eax, eax
$LN18@pad:
  00117	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0011f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00124	74 16		 je	 SHORT $LN19@pad
  00126	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0012e	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00135	48 89 44 24 48	 mov	 QWORD PTR tv130[rsp], rax
  0013a	eb 0c		 jmp	 SHORT $LN20@pad
$LN19@pad:
  0013c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00143	48 89 44 24 48	 mov	 QWORD PTR tv130[rsp], rax
$LN20@pad:
  00148	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00150	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00154	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv130[rsp]
  00159	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0015e	e9 13 04 00 00	 jmp	 $LN15@pad
$LN12@pad:

; 99   : #else
; 100  :         Py_INCREF(self);
; 101  :         return (PyObject *)self;
; 102  : #endif /* STRINGLIB_MUTABLE */
; 103  :     }
; 104  : 
; 105  :     u = STRINGLIB_NEW(NULL,
; 106  : 				   left + STRINGLIB_LEN(self) + right);

  00163	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0016a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00172	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00176	74 38		 je	 SHORT $LN21@pad
  00178	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0017f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00187	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0018b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00190	85 c0		 test	 eax, eax
  00192	75 1c		 jne	 SHORT $LN21@pad
  00194	41 b8 6a 00 00
	00		 mov	 r8d, 106		; 0000006aH
  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001ae	33 c0		 xor	 eax, eax
$LN21@pad:
  001b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001b8	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR left$[rsp]
  001c4	48 03 c8	 add	 rcx, rax
  001c7	48 8b c1	 mov	 rax, rcx
  001ca	48 03 84 24 90
	00 00 00	 add	 rax, QWORD PTR right$[rsp]
  001d2	48 8b d0	 mov	 rdx, rax
  001d5	33 c9		 xor	 ecx, ecx
  001d7	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  001dc	48 89 44 24 20	 mov	 QWORD PTR u$[rsp], rax

; 107  :     if (u) {

  001e1	48 83 7c 24 20
	00		 cmp	 QWORD PTR u$[rsp], 0
  001e7	0f 84 84 03 00
	00		 je	 $LN11@pad

; 108  :         if (left)

  001ed	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR left$[rsp], 0
  001f6	0f 84 8e 00 00
	00		 je	 $LN10@pad

; 109  :             memset(STRINGLIB_STR(u), fill, left);

  001fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00203	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  00208	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0020c	74 35		 je	 SHORT $LN22@pad
  0020e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00215	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0021a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0021e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00223	85 c0		 test	 eax, eax
  00225	75 1c		 jne	 SHORT $LN22@pad
  00227	41 b8 6d 00 00
	00		 mov	 r8d, 109		; 0000006dH
  0022d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00234	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@CMHEKGGP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  0023b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00241	33 c0		 xor	 eax, eax
$LN22@pad:
  00243	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00248	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0024d	74 13		 je	 SHORT $LN23@pad
  0024f	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00254	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0025b	48 89 44 24 50	 mov	 QWORD PTR tv169[rsp], rax
  00260	eb 0c		 jmp	 SHORT $LN24@pad
$LN23@pad:
  00262	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00269	48 89 44 24 50	 mov	 QWORD PTR tv169[rsp], rax
$LN24@pad:
  0026e	0f be 84 24 98
	00 00 00	 movsx	 eax, BYTE PTR fill$[rsp]
  00276	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR left$[rsp]
  0027e	8b d0		 mov	 edx, eax
  00280	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv169[rsp]
  00285	e8 00 00 00 00	 call	 memset
$LN10@pad:
$LN9@pad:

; 110  :         Py_MEMCPY(STRINGLIB_STR(u) + left,
; 111  : 	       STRINGLIB_STR(self),
; 112  : 	       STRINGLIB_LEN(self));

  0028a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00291	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00299	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0029d	74 38		 je	 SHORT $LN25@pad
  0029f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  002a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002ae	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  002b2	e8 00 00 00 00	 call	 PyType_IsSubtype
  002b7	85 c0		 test	 eax, eax
  002b9	75 1c		 jne	 SHORT $LN25@pad
  002bb	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  002c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  002cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002d5	33 c0		 xor	 eax, eax
$LN25@pad:
  002d7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002df	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002e3	48 89 44 24 40	 mov	 QWORD PTR n_$22257[rsp], rax
  002e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  002ef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  002f4	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  002f8	74 35		 je	 SHORT $LN26@pad
  002fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00301	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00306	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0030a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0030f	85 c0		 test	 eax, eax
  00311	75 1c		 jne	 SHORT $LN26@pad
  00313	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  00319	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00320	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@CMHEKGGP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  00327	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0032d	33 c0		 xor	 eax, eax
$LN26@pad:
  0032f	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00334	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00339	74 13		 je	 SHORT $LN27@pad
  0033b	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  00340	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00347	48 89 44 24 58	 mov	 QWORD PTR tv196[rsp], rax
  0034c	eb 0c		 jmp	 SHORT $LN28@pad
$LN27@pad:
  0034e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00355	48 89 44 24 58	 mov	 QWORD PTR tv196[rsp], rax
$LN28@pad:
  0035a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR left$[rsp]
  00362	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv196[rsp]
  00367	48 03 c8	 add	 rcx, rax
  0036a	48 8b c1	 mov	 rax, rcx
  0036d	48 89 44 24 28	 mov	 QWORD PTR t_$22262[rsp], rax
  00372	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00379	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00381	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00385	74 38		 je	 SHORT $LN29@pad
  00387	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0038e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00396	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0039a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0039f	85 c0		 test	 eax, eax
  003a1	75 1c		 jne	 SHORT $LN29@pad
  003a3	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  003a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  003b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  003b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003bd	33 c0		 xor	 eax, eax
$LN29@pad:
  003bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003c7	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  003cc	74 16		 je	 SHORT $LN30@pad
  003ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003d6	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  003dd	48 89 44 24 60	 mov	 QWORD PTR tv212[rsp], rax
  003e2	eb 0c		 jmp	 SHORT $LN31@pad
$LN30@pad:
  003e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  003eb	48 89 44 24 60	 mov	 QWORD PTR tv212[rsp], rax
$LN31@pad:
  003f0	48 8b 44 24 60	 mov	 rax, QWORD PTR tv212[rsp]
  003f5	48 89 44 24 30	 mov	 QWORD PTR s_$22269[rsp], rax
  003fa	48 83 7c 24 40
	10		 cmp	 QWORD PTR n_$22257[rsp], 16
  00400	72 16		 jb	 SHORT $LN6@pad
  00402	4c 8b 44 24 40	 mov	 r8, QWORD PTR n_$22257[rsp]
  00407	48 8b 54 24 30	 mov	 rdx, QWORD PTR s_$22269[rsp]
  0040c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t_$22262[rsp]
  00411	e8 00 00 00 00	 call	 memcpy
  00416	eb 4b		 jmp	 SHORT $LN5@pad
$LN6@pad:
  00418	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i_$22256[rsp], 0
  00421	eb 0d		 jmp	 SHORT $LN4@pad
$LN3@pad:
  00423	48 8b 44 24 38	 mov	 rax, QWORD PTR i_$22256[rsp]
  00428	48 ff c0	 inc	 rax
  0042b	48 89 44 24 38	 mov	 QWORD PTR i_$22256[rsp], rax
$LN4@pad:
  00430	48 8b 44 24 40	 mov	 rax, QWORD PTR n_$22257[rsp]
  00435	48 39 44 24 38	 cmp	 QWORD PTR i_$22256[rsp], rax
  0043a	73 27		 jae	 SHORT $LN2@pad
  0043c	48 8b 44 24 38	 mov	 rax, QWORD PTR i_$22256[rsp]
  00441	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t_$22262[rsp]
  00446	48 03 c8	 add	 rcx, rax
  00449	48 8b c1	 mov	 rax, rcx
  0044c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i_$22256[rsp]
  00451	48 8b 54 24 30	 mov	 rdx, QWORD PTR s_$22269[rsp]
  00456	48 03 d1	 add	 rdx, rcx
  00459	48 8b ca	 mov	 rcx, rdx
  0045c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0045f	88 08		 mov	 BYTE PTR [rax], cl
  00461	eb c0		 jmp	 SHORT $LN3@pad
$LN2@pad:
$LN5@pad:
  00463	33 c0		 xor	 eax, eax
  00465	85 c0		 test	 eax, eax
  00467	0f 85 1d fe ff
	ff		 jne	 $LN9@pad

; 113  :         if (right)

  0046d	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR right$[rsp], 0
  00476	0f 84 f5 00 00
	00		 je	 $LN1@pad

; 114  :             memset(STRINGLIB_STR(u) + left + STRINGLIB_LEN(self),
; 115  : 		   fill, right);

  0047c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00483	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$[rsp]
  00488	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0048c	74 35		 je	 SHORT $LN32@pad
  0048e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00495	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  0049a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0049e	e8 00 00 00 00	 call	 PyType_IsSubtype
  004a3	85 c0		 test	 eax, eax
  004a5	75 1c		 jne	 SHORT $LN32@pad
  004a7	41 b8 72 00 00
	00		 mov	 r8d, 114		; 00000072H
  004ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  004b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@CMHEKGGP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  004bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004c1	33 c0		 xor	 eax, eax
$LN32@pad:
  004c3	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  004c8	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  004cd	74 13		 je	 SHORT $LN33@pad
  004cf	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
  004d4	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  004db	48 89 44 24 68	 mov	 QWORD PTR tv241[rsp], rax
  004e0	eb 0c		 jmp	 SHORT $LN34@pad
$LN33@pad:
  004e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  004e9	48 89 44 24 68	 mov	 QWORD PTR tv241[rsp], rax
$LN34@pad:
  004ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  004f5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  004fd	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00501	74 38		 je	 SHORT $LN35@pad
  00503	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0050a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00512	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00516	e8 00 00 00 00	 call	 PyType_IsSubtype
  0051b	85 c0		 test	 eax, eax
  0051d	75 1c		 jne	 SHORT $LN35@pad
  0051f	41 b8 72 00 00
	00		 mov	 r8d, 114		; 00000072H
  00525	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0052c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00533	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00539	33 c0		 xor	 eax, eax
$LN35@pad:
  0053b	0f be 84 24 98
	00 00 00	 movsx	 eax, BYTE PTR fill$[rsp]
  00543	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR left$[rsp]
  0054b	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv241[rsp]
  00550	48 03 d1	 add	 rdx, rcx
  00553	48 8b ca	 mov	 rcx, rdx
  00556	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  0055e	48 03 4a 60	 add	 rcx, QWORD PTR [rdx+96]
  00562	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR right$[rsp]
  0056a	8b d0		 mov	 edx, eax
  0056c	e8 00 00 00 00	 call	 memset
$LN1@pad:
$LN11@pad:

; 116  :     }
; 117  : 
; 118  :     return u;

  00571	48 8b 44 24 20	 mov	 rax, QWORD PTR u$[rsp]
$LN15@pad:

; 119  : }

  00576	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0057a	c3		 ret	 0
pad	ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rjust DD imagerel stringlib_rjust
	DD	imagerel stringlib_rjust+494
	DD	imagerel $unwind$stringlib_rjust
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rjust DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@
CONST	SEGMENT
??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@ DB 'n|c:rjust', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_rjust
_TEXT	SEGMENT
width$ = 32
fillchar$ = 40
tv145 = 48
self$ = 80
args$ = 88
stringlib_rjust PROC					; COMDAT

; 159  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 160  :     Py_ssize_t width;
; 161  :     char fillchar = ' ';

  0000e	c6 44 24 28 20	 mov	 BYTE PTR fillchar$[rsp], 32 ; 00000020H

; 162  : 
; 163  :     if (!PyArg_ParseTuple(args, "n|c:rjust", &width, &fillchar))

  00013	4c 8d 4c 24 28	 lea	 r9, QWORD PTR fillchar$[rsp]
  00018	4c 8d 44 24 20	 lea	 r8, QWORD PTR width$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@
  00024	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 07		 jne	 SHORT $LN2@stringlib_@15

; 164  :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 b0 01 00 00	 jmp	 $LN3@stringlib_@15
$LN2@stringlib_@15:

; 165  : 
; 166  :     if (STRINGLIB_LEN(self) >= width && STRINGLIB_CHECK_EXACT(self)) {

  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00045	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00049	74 35		 je	 SHORT $LN5@stringlib_@15
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 1c		 jne	 SHORT $LN5@stringlib_@15
  00064	41 b8 a6 00 00
	00		 mov	 r8d, 166		; 000000a6H
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN5@stringlib_@15:
  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR width$[rsp]
  0008a	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0008e	0f 8c e4 00 00
	00		 jl	 $LN1@stringlib_@15
  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000a0	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000a4	0f 85 ce 00 00
	00		 jne	 $LN1@stringlib_@15

; 167  : #if STRINGLIB_MUTABLE
; 168  :         /* We're defined as returning a copy;  If the object is mutable
; 169  :          * that means we must make an identical copy. */
; 170  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  000aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000b6	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000ba	74 35		 je	 SHORT $LN6@stringlib_@15
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c8	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000cc	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d1	85 c0		 test	 eax, eax
  000d3	75 1c		 jne	 SHORT $LN6@stringlib_@15
  000d5	41 b8 aa 00 00
	00		 mov	 r8d, 170		; 000000aaH
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ef	33 c0		 xor	 eax, eax
$LN6@stringlib_@15:
  000f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000fd	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00101	74 35		 je	 SHORT $LN7@stringlib_@15
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0010a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0010f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00113	e8 00 00 00 00	 call	 PyType_IsSubtype
  00118	85 c0		 test	 eax, eax
  0011a	75 1c		 jne	 SHORT $LN7@stringlib_@15
  0011c	41 b8 aa 00 00
	00		 mov	 r8d, 170		; 000000aaH
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00136	33 c0		 xor	 eax, eax
$LN7@stringlib_@15:
  00138	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0013d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00142	74 13		 je	 SHORT $LN8@stringlib_@15
  00144	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00149	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00150	48 89 44 24 30	 mov	 QWORD PTR tv145[rsp], rax
  00155	eb 0c		 jmp	 SHORT $LN9@stringlib_@15
$LN8@stringlib_@15:
  00157	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0015e	48 89 44 24 30	 mov	 QWORD PTR tv145[rsp], rax
$LN9@stringlib_@15:
  00163	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00168	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0016c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv145[rsp]
  00171	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00176	eb 71		 jmp	 SHORT $LN3@stringlib_@15
$LN1@stringlib_@15:

; 171  : #else
; 172  :         Py_INCREF(self);
; 173  :         return (PyObject*) self;
; 174  : #endif
; 175  :     }
; 176  : 
; 177  :     return pad(self, width - STRINGLIB_LEN(self), 0, fillchar);

  00178	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0017f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00184	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00188	74 35		 je	 SHORT $LN10@stringlib_@15
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00191	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00196	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0019a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0019f	85 c0		 test	 eax, eax
  001a1	75 1c		 jne	 SHORT $LN10@stringlib_@15
  001a3	41 b8 b1 00 00
	00		 mov	 r8d, 177		; 000000b1H
  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001bd	33 c0		 xor	 eax, eax
$LN10@stringlib_@15:
  001bf	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  001c4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR width$[rsp]
  001cd	48 2b c8	 sub	 rcx, rax
  001d0	48 8b c1	 mov	 rax, rcx
  001d3	44 0f b6 4c 24
	28		 movzx	 r9d, BYTE PTR fillchar$[rsp]
  001d9	45 33 c0	 xor	 r8d, r8d
  001dc	48 8b d0	 mov	 rdx, rax
  001df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  001e4	e8 00 00 00 00	 call	 pad
$LN3@stringlib_@15:

; 178  : }

  001e9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ed	c3		 ret	 0
stringlib_rjust ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_center DD imagerel stringlib_center
	DD	imagerel stringlib_center+561
	DD	imagerel $unwind$stringlib_center
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_center DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@
CONST	SEGMENT
??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@ DB 'n|c:center', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_center
_TEXT	SEGMENT
left$ = 32
width$ = 40
fillchar$ = 48
marg$ = 56
tv145 = 64
self$ = 96
args$ = 104
stringlib_center PROC					; COMDAT

; 189  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 190  :     Py_ssize_t marg, left;
; 191  :     Py_ssize_t width;
; 192  :     char fillchar = ' ';

  0000e	c6 44 24 30 20	 mov	 BYTE PTR fillchar$[rsp], 32 ; 00000020H

; 193  : 
; 194  :     if (!PyArg_ParseTuple(args, "n|c:center", &width, &fillchar))

  00013	4c 8d 4c 24 30	 lea	 r9, QWORD PTR fillchar$[rsp]
  00018	4c 8d 44 24 28	 lea	 r8, QWORD PTR width$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@
  00024	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 07		 jne	 SHORT $LN2@stringlib_@16

; 195  :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 f3 01 00 00	 jmp	 $LN3@stringlib_@16
$LN2@stringlib_@16:

; 196  : 
; 197  :     if (STRINGLIB_LEN(self) >= width && STRINGLIB_CHECK_EXACT(self)) {

  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00040	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00045	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00049	74 35		 je	 SHORT $LN5@stringlib_@16
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 1c		 jne	 SHORT $LN5@stringlib_@16
  00064	41 b8 c5 00 00
	00		 mov	 r8d, 197		; 000000c5H
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN5@stringlib_@16:
  00080	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00085	48 8b 4c 24 28	 mov	 rcx, QWORD PTR width$[rsp]
  0008a	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0008e	0f 8c e7 00 00
	00		 jl	 $LN1@stringlib_@16
  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0009b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000a0	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000a4	0f 85 d1 00 00
	00		 jne	 $LN1@stringlib_@16

; 198  : #if STRINGLIB_MUTABLE
; 199  :         /* We're defined as returning a copy;  If the object is mutable
; 200  :          * that means we must make an identical copy. */
; 201  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  000aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000b6	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000ba	74 35		 je	 SHORT $LN6@stringlib_@16
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000c3	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000c8	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000cc	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d1	85 c0		 test	 eax, eax
  000d3	75 1c		 jne	 SHORT $LN6@stringlib_@16
  000d5	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ef	33 c0		 xor	 eax, eax
$LN6@stringlib_@16:
  000f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000fd	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00101	74 35		 je	 SHORT $LN7@stringlib_@16
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0010a	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0010f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00113	e8 00 00 00 00	 call	 PyType_IsSubtype
  00118	85 c0		 test	 eax, eax
  0011a	75 1c		 jne	 SHORT $LN7@stringlib_@16
  0011c	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00136	33 c0		 xor	 eax, eax
$LN7@stringlib_@16:
  00138	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0013d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00142	74 13		 je	 SHORT $LN8@stringlib_@16
  00144	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00149	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00150	48 89 44 24 40	 mov	 QWORD PTR tv145[rsp], rax
  00155	eb 0c		 jmp	 SHORT $LN9@stringlib_@16
$LN8@stringlib_@16:
  00157	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0015e	48 89 44 24 40	 mov	 QWORD PTR tv145[rsp], rax
$LN9@stringlib_@16:
  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00168	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0016c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv145[rsp]
  00171	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00176	e9 b1 00 00 00	 jmp	 $LN3@stringlib_@16
$LN1@stringlib_@16:

; 202  : #else
; 203  :         Py_INCREF(self);
; 204  :         return (PyObject*) self;
; 205  : #endif
; 206  :     }
; 207  : 
; 208  :     marg = width - STRINGLIB_LEN(self);

  0017b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00182	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00187	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0018b	74 35		 je	 SHORT $LN10@stringlib_@16
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00194	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00199	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0019d	e8 00 00 00 00	 call	 PyType_IsSubtype
  001a2	85 c0		 test	 eax, eax
  001a4	75 1c		 jne	 SHORT $LN10@stringlib_@16
  001a6	41 b8 d0 00 00
	00		 mov	 r8d, 208		; 000000d0H
  001ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001c0	33 c0		 xor	 eax, eax
$LN10@stringlib_@16:
  001c2	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001c7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR width$[rsp]
  001d0	48 2b c8	 sub	 rcx, rax
  001d3	48 8b c1	 mov	 rax, rcx
  001d6	48 89 44 24 38	 mov	 QWORD PTR marg$[rsp], rax

; 209  :     left = marg / 2 + (marg & width & 1);

  001db	48 8b 44 24 38	 mov	 rax, QWORD PTR marg$[rsp]
  001e0	48 99		 cdq
  001e2	48 2b c2	 sub	 rax, rdx
  001e5	48 d1 f8	 sar	 rax, 1
  001e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR width$[rsp]
  001ed	48 8b 54 24 38	 mov	 rdx, QWORD PTR marg$[rsp]
  001f2	48 23 d1	 and	 rdx, rcx
  001f5	48 8b ca	 mov	 rcx, rdx
  001f8	48 83 e1 01	 and	 rcx, 1
  001fc	48 03 c1	 add	 rax, rcx
  001ff	48 89 44 24 20	 mov	 QWORD PTR left$[rsp], rax

; 210  : 
; 211  :     return pad(self, left, marg - left, fillchar);

  00204	48 8b 44 24 20	 mov	 rax, QWORD PTR left$[rsp]
  00209	48 8b 4c 24 38	 mov	 rcx, QWORD PTR marg$[rsp]
  0020e	48 2b c8	 sub	 rcx, rax
  00211	48 8b c1	 mov	 rax, rcx
  00214	44 0f b6 4c 24
	30		 movzx	 r9d, BYTE PTR fillchar$[rsp]
  0021a	4c 8b c0	 mov	 r8, rax
  0021d	48 8b 54 24 20	 mov	 rdx, QWORD PTR left$[rsp]
  00222	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00227	e8 00 00 00 00	 call	 pad
$LN3@stringlib_@16:

; 212  : }

  0022c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00230	c3		 ret	 0
stringlib_center ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@PKCNEFHC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_07CBMPGKCP@n?3zfill?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_zfill DD imagerel stringlib_zfill
	DD	imagerel stringlib_zfill+947
	DD	imagerel $unwind$stringlib_zfill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_zfill DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_1CK@PKCNEFHC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@PKCNEFHC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 's', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07CBMPGKCP@n?3zfill?$AA@
CONST	SEGMENT
??_C@_07CBMPGKCP@n?3zfill?$AA@ DB 'n:zfill', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_zfill
_TEXT	SEGMENT
p$ = 32
s$ = 40
width$ = 48
fill$ = 56
tv144 = 64
tv174 = 72
tv209 = 80
self$ = 112
args$ = 120
stringlib_zfill PROC					; COMDAT

; 222  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 223  :     Py_ssize_t fill;
; 224  :     PyObject *s;
; 225  :     char *p;
; 226  :     Py_ssize_t width;
; 227  : 
; 228  :     if (!PyArg_ParseTuple(args, "n:zfill", &width))

  0000e	4c 8d 44 24 30	 lea	 r8, QWORD PTR width$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07CBMPGKCP@n?3zfill?$AA@
  0001a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 07		 jne	 SHORT $LN7@stringlib_@17

; 229  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 7f 03 00 00	 jmp	 $LN8@stringlib_@17
$LN7@stringlib_@17:

; 230  : 
; 231  :     if (STRINGLIB_LEN(self) >= width) {

  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00036	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0003b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003f	74 35		 je	 SHORT $LN10@stringlib_@17
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00048	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0004d	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00051	e8 00 00 00 00	 call	 PyType_IsSubtype
  00056	85 c0		 test	 eax, eax
  00058	75 1c		 jne	 SHORT $LN10@stringlib_@17
  0005a	41 b8 e7 00 00
	00		 mov	 r8d, 231		; 000000e7H
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00074	33 c0		 xor	 eax, eax
$LN10@stringlib_@17:
  00076	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0007b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR width$[rsp]
  00080	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00084	0f 8c bd 01 00
	00		 jl	 $LN6@stringlib_@17

; 232  :         if (STRINGLIB_CHECK_EXACT(self)) {

  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00091	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00096	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0009a	0f 85 d6 00 00
	00		 jne	 $LN5@stringlib_@17

; 233  : #if STRINGLIB_MUTABLE
; 234  :             /* We're defined as returning a copy;  If the object is mutable
; 235  :              * that means we must make an identical copy. */
; 236  :             return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000ac	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000b0	74 35		 je	 SHORT $LN11@stringlib_@17
  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000b9	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000be	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000c2	e8 00 00 00 00	 call	 PyType_IsSubtype
  000c7	85 c0		 test	 eax, eax
  000c9	75 1c		 jne	 SHORT $LN11@stringlib_@17
  000cb	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e5	33 c0		 xor	 eax, eax
$LN11@stringlib_@17:
  000e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000f3	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f7	74 35		 je	 SHORT $LN12@stringlib_@17
  000f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00100	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00105	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00109	e8 00 00 00 00	 call	 PyType_IsSubtype
  0010e	85 c0		 test	 eax, eax
  00110	75 1c		 jne	 SHORT $LN12@stringlib_@17
  00112	41 b8 ec 00 00
	00		 mov	 r8d, 236		; 000000ecH
  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0012c	33 c0		 xor	 eax, eax
$LN12@stringlib_@17:
  0012e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00133	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00138	74 13		 je	 SHORT $LN13@stringlib_@17
  0013a	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0013f	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00146	48 89 44 24 40	 mov	 QWORD PTR tv144[rsp], rax
  0014b	eb 0c		 jmp	 SHORT $LN14@stringlib_@17
$LN13@stringlib_@17:
  0014d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00154	48 89 44 24 40	 mov	 QWORD PTR tv144[rsp], rax
$LN14@stringlib_@17:
  00159	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0015e	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00162	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv144[rsp]
  00167	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0016c	e9 3d 02 00 00	 jmp	 $LN8@stringlib_@17

; 237  : #else
; 238  :             Py_INCREF(self);
; 239  :             return (PyObject*) self;
; 240  : #endif
; 241  :         }
; 242  :         else

  00171	e9 d1 00 00 00	 jmp	 $LN4@stringlib_@17
$LN5@stringlib_@17:

; 243  :             return STRINGLIB_NEW(
; 244  :                 STRINGLIB_STR(self),
; 245  :                 STRINGLIB_LEN(self)
; 246  :             );

  00176	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0017d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00182	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00186	74 35		 je	 SHORT $LN15@stringlib_@17
  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0018f	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00194	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00198	e8 00 00 00 00	 call	 PyType_IsSubtype
  0019d	85 c0		 test	 eax, eax
  0019f	75 1c		 jne	 SHORT $LN15@stringlib_@17
  001a1	41 b8 f5 00 00
	00		 mov	 r8d, 245		; 000000f5H
  001a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  001ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001bb	33 c0		 xor	 eax, eax
$LN15@stringlib_@17:
  001bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001c9	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001cd	74 35		 je	 SHORT $LN16@stringlib_@17
  001cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001d6	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001db	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001df	e8 00 00 00 00	 call	 PyType_IsSubtype
  001e4	85 c0		 test	 eax, eax
  001e6	75 1c		 jne	 SHORT $LN16@stringlib_@17
  001e8	41 b8 f4 00 00
	00		 mov	 r8d, 244		; 000000f4H
  001ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  001f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00202	33 c0		 xor	 eax, eax
$LN16@stringlib_@17:
  00204	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00209	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0020e	74 13		 je	 SHORT $LN17@stringlib_@17
  00210	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00215	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0021c	48 89 44 24 48	 mov	 QWORD PTR tv174[rsp], rax
  00221	eb 0c		 jmp	 SHORT $LN18@stringlib_@17
$LN17@stringlib_@17:
  00223	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0022a	48 89 44 24 48	 mov	 QWORD PTR tv174[rsp], rax
$LN18@stringlib_@17:
  0022f	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00234	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00238	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv174[rsp]
  0023d	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00242	e9 67 01 00 00	 jmp	 $LN8@stringlib_@17
$LN4@stringlib_@17:
$LN6@stringlib_@17:

; 247  :     }
; 248  : 
; 249  :     fill = width - STRINGLIB_LEN(self);

  00247	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0024e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00253	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00257	74 35		 je	 SHORT $LN19@stringlib_@17
  00259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00260	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00265	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00269	e8 00 00 00 00	 call	 PyType_IsSubtype
  0026e	85 c0		 test	 eax, eax
  00270	75 1c		 jne	 SHORT $LN19@stringlib_@17
  00272	41 b8 f9 00 00
	00		 mov	 r8d, 249		; 000000f9H
  00278	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  0027f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0028c	33 c0		 xor	 eax, eax
$LN19@stringlib_@17:
  0028e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00293	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00297	48 8b 4c 24 30	 mov	 rcx, QWORD PTR width$[rsp]
  0029c	48 2b c8	 sub	 rcx, rax
  0029f	48 8b c1	 mov	 rax, rcx
  002a2	48 89 44 24 38	 mov	 QWORD PTR fill$[rsp], rax

; 250  : 
; 251  :     s = pad(self, fill, 0, '0');

  002a7	41 b1 30	 mov	 r9b, 48			; 00000030H
  002aa	45 33 c0	 xor	 r8d, r8d
  002ad	48 8b 54 24 38	 mov	 rdx, QWORD PTR fill$[rsp]
  002b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  002b7	e8 00 00 00 00	 call	 pad
  002bc	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 252  : 
; 253  :     if (s == NULL)

  002c1	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  002c7	75 07		 jne	 SHORT $LN3@stringlib_@17

; 254  :         return NULL;

  002c9	33 c0		 xor	 eax, eax
  002cb	e9 de 00 00 00	 jmp	 $LN8@stringlib_@17
$LN3@stringlib_@17:

; 255  : 
; 256  :     p = STRINGLIB_STR(s);

  002d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  002d7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  002dc	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  002e0	74 35		 je	 SHORT $LN20@stringlib_@17
  002e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  002e9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  002ee	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  002f2	e8 00 00 00 00	 call	 PyType_IsSubtype
  002f7	85 c0		 test	 eax, eax
  002f9	75 1c		 jne	 SHORT $LN20@stringlib_@17
  002fb	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00301	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@INIJJGIB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  00308	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@PKCNEFHC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
  0030f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00315	33 c0		 xor	 eax, eax
$LN20@stringlib_@17:
  00317	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0031c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00321	74 13		 je	 SHORT $LN21@stringlib_@17
  00323	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00328	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0032f	48 89 44 24 50	 mov	 QWORD PTR tv209[rsp], rax
  00334	eb 0c		 jmp	 SHORT $LN22@stringlib_@17
$LN21@stringlib_@17:
  00336	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0033d	48 89 44 24 50	 mov	 QWORD PTR tv209[rsp], rax
$LN22@stringlib_@17:
  00342	48 8b 44 24 50	 mov	 rax, QWORD PTR tv209[rsp]
  00347	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 257  :     if (p[fill] == '+' || p[fill] == '-') {

  0034c	48 8b 44 24 38	 mov	 rax, QWORD PTR fill$[rsp]
  00351	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00356	48 03 c8	 add	 rcx, rax
  00359	48 8b c1	 mov	 rax, rcx
  0035c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0035f	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00362	74 18		 je	 SHORT $LN1@stringlib_@17
  00364	48 8b 44 24 38	 mov	 rax, QWORD PTR fill$[rsp]
  00369	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0036e	48 03 c8	 add	 rcx, rax
  00371	48 8b c1	 mov	 rax, rcx
  00374	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00377	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0037a	75 2d		 jne	 SHORT $LN2@stringlib_@17
$LN1@stringlib_@17:

; 258  :         /* move sign to beginning of string */
; 259  :         p[0] = p[fill];

  0037c	48 8b 44 24 38	 mov	 rax, QWORD PTR fill$[rsp]
  00381	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00386	48 03 c8	 add	 rcx, rax
  00389	48 8b c1	 mov	 rax, rcx
  0038c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00391	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00394	88 01		 mov	 BYTE PTR [rcx], al

; 260  :         p[fill] = '0';

  00396	48 8b 44 24 38	 mov	 rax, QWORD PTR fill$[rsp]
  0039b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  003a0	48 03 c8	 add	 rcx, rax
  003a3	48 8b c1	 mov	 rax, rcx
  003a6	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
$LN2@stringlib_@17:

; 261  :     }
; 262  : 
; 263  :     return (PyObject*) s;

  003a9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
$LN8@stringlib_@17:

; 264  : }

  003ae	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003b2	c3		 ret	 0
stringlib_zfill ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytearrayobject.c
pdata	SEGMENT
$pdata$bytearray_find DD imagerel bytearray_find
	DD	imagerel bytearray_find+67
	DD	imagerel $unwind$bytearray_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_find DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_find
_TEXT	SEGMENT
result$ = 32
self$ = 64
args$ = 72
bytearray_find PROC					; COMDAT

; 1129 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1130 :     Py_ssize_t result = bytearray_find_internal(self, args, +1);

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	e8 00 00 00 00	 call	 bytearray_find_internal
  00023	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1131 :     if (result == -2)

  00028	48 83 7c 24 20
	fe		 cmp	 QWORD PTR result$[rsp], -2
  0002e	75 04		 jne	 SHORT $LN1@bytearray_@15

; 1132 :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 0a		 jmp	 SHORT $LN2@bytearray_@15
$LN1@bytearray_@15:

; 1133 :     return PyLong_FromSsize_t(result);

  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00039	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN2@bytearray_@15:

; 1134 : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
bytearray_find ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_find_internal DD imagerel bytearray_find_internal
	DD	imagerel bytearray_find_internal+799
	DD	imagerel $unwind$bytearray_find_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_find_internal DD 021601H
	DD	01b0116H
xdata	ENDS
;	COMDAT ??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@
CONST	SEGMENT
??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@ DB 'find/rfind/index/r'
	DB	'index', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_find_internal
_TEXT	SEGMENT
res$ = 48
end$ = 56
start$ = 64
sub_len$ = 72
sub$ = 80
subbuf$ = 96
byte$ = 176
subobj$ = 184
tv142 = 192
tv176 = 200
self$ = 224
args$ = 232
dir$ = 240
bytearray_find_internal PROC				; COMDAT

; 1078 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1079 :     PyObject *subobj;
; 1080 :     char byte;
; 1081 :     Py_buffer subbuf;
; 1082 :     const char *sub;
; 1083 :     Py_ssize_t sub_len;
; 1084 :     Py_ssize_t start=0, end=PY_SSIZE_T_MAX;

  00016	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  0001f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00029	48 89 44 24 38	 mov	 QWORD PTR end$[rsp], rax

; 1085 :     Py_ssize_t res;
; 1086 : 
; 1087 :     if (!stringlib_parse_args_finds_byte("find/rfind/index/rindex",
; 1088 :                                          args, &subobj, &byte, &start, &end))

  0002e	48 8d 44 24 38	 lea	 rax, QWORD PTR end$[rsp]
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 44 24 40	 lea	 rax, QWORD PTR start$[rsp]
  0003d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00042	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR byte$[rsp]
  0004a	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR subobj$[rsp]
  00052	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR args$[rsp]
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@
  00061	e8 00 00 00 00	 call	 stringlib_parse_args_finds_byte
  00066	85 c0		 test	 eax, eax
  00068	75 0c		 jne	 SHORT $LN7@bytearray_@16

; 1089 :         return -2;

  0006a	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00071	e9 a1 02 00 00	 jmp	 $LN8@bytearray_@16
$LN7@bytearray_@16:

; 1090 : 
; 1091 :     if (subobj) {

  00076	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR subobj$[rsp], 0
  0007f	74 39		 je	 SHORT $LN6@bytearray_@16

; 1092 :         if (_getbuffer(subobj, &subbuf) < 0)

  00081	48 8d 54 24 60	 lea	 rdx, QWORD PTR subbuf$[rsp]
  00086	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR subobj$[rsp]
  0008e	e8 00 00 00 00	 call	 _getbuffer
  00093	48 85 c0	 test	 rax, rax
  00096	7d 0c		 jge	 SHORT $LN5@bytearray_@16

; 1093 :             return -2;

  00098	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  0009f	e9 73 02 00 00	 jmp	 $LN8@bytearray_@16
$LN5@bytearray_@16:

; 1094 : 
; 1095 :         sub = subbuf.buf;

  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR subbuf$[rsp]
  000a9	48 89 44 24 50	 mov	 QWORD PTR sub$[rsp], rax

; 1096 :         sub_len = subbuf.len;

  000ae	48 8b 44 24 70	 mov	 rax, QWORD PTR subbuf$[rsp+16]
  000b3	48 89 44 24 48	 mov	 QWORD PTR sub_len$[rsp], rax

; 1097 :     }
; 1098 :     else {

  000b8	eb 16		 jmp	 SHORT $LN4@bytearray_@16
$LN6@bytearray_@16:

; 1099 :         sub = &byte;

  000ba	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR byte$[rsp]
  000c2	48 89 44 24 50	 mov	 QWORD PTR sub$[rsp], rax

; 1100 :         sub_len = 1;

  000c7	48 c7 44 24 48
	01 00 00 00	 mov	 QWORD PTR sub_len$[rsp], 1
$LN4@bytearray_@16:

; 1101 :     }
; 1102 : 
; 1103 :     if (dir > 0)

  000d0	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR dir$[rsp], 0
  000d8	0f 8e 12 01 00
	00		 jle	 $LN3@bytearray_@16

; 1104 :         res = stringlib_find_slice(
; 1105 :             PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self),
; 1106 :             sub, sub_len, start, end);

  000de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000e5	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000ed	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f1	74 38		 je	 SHORT $LN10@bytearray_@16
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000fa	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00102	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00106	e8 00 00 00 00	 call	 PyType_IsSubtype
  0010b	85 c0		 test	 eax, eax
  0010d	75 1c		 jne	 SHORT $LN10@bytearray_@16
  0010f	41 b8 51 04 00
	00		 mov	 r8d, 1105		; 00000451H
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00129	33 c0		 xor	 eax, eax
$LN10@bytearray_@16:
  0012b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00132	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0013a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0013e	74 38		 je	 SHORT $LN11@bytearray_@16
  00140	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00147	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0014f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00153	e8 00 00 00 00	 call	 PyType_IsSubtype
  00158	85 c0		 test	 eax, eax
  0015a	75 1c		 jne	 SHORT $LN11@bytearray_@16
  0015c	41 b8 51 04 00
	00		 mov	 r8d, 1105		; 00000451H
  00162	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00176	33 c0		 xor	 eax, eax
$LN11@bytearray_@16:
  00178	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00180	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00185	74 19		 je	 SHORT $LN12@bytearray_@16
  00187	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0018f	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00196	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv142[rsp], rax
  0019e	eb 0f		 jmp	 SHORT $LN13@bytearray_@16
$LN12@bytearray_@16:
  001a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  001a7	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv142[rsp], rax
$LN13@bytearray_@16:
  001af	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  001b4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b9	48 8b 44 24 40	 mov	 rax, QWORD PTR start$[rsp]
  001be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c3	4c 8b 4c 24 48	 mov	 r9, QWORD PTR sub_len$[rsp]
  001c8	4c 8b 44 24 50	 mov	 r8, QWORD PTR sub$[rsp]
  001cd	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001d5	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  001d9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv142[rsp]
  001e1	e8 00 00 00 00	 call	 stringlib_find_slice
  001e6	48 89 44 24 30	 mov	 QWORD PTR res$[rsp], rax

; 1107 :     else

  001eb	e9 0d 01 00 00	 jmp	 $LN2@bytearray_@16
$LN3@bytearray_@16:

; 1108 :         res = stringlib_rfind_slice(
; 1109 :             PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self),
; 1110 :             sub, sub_len, start, end);

  001f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001f7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001ff	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00203	74 38		 je	 SHORT $LN14@bytearray_@16
  00205	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0020c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00214	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00218	e8 00 00 00 00	 call	 PyType_IsSubtype
  0021d	85 c0		 test	 eax, eax
  0021f	75 1c		 jne	 SHORT $LN14@bytearray_@16
  00221	41 b8 55 04 00
	00		 mov	 r8d, 1109		; 00000455H
  00227	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0022e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0023b	33 c0		 xor	 eax, eax
$LN14@bytearray_@16:
  0023d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00244	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0024c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00250	74 38		 je	 SHORT $LN15@bytearray_@16
  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00259	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00261	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00265	e8 00 00 00 00	 call	 PyType_IsSubtype
  0026a	85 c0		 test	 eax, eax
  0026c	75 1c		 jne	 SHORT $LN15@bytearray_@16
  0026e	41 b8 55 04 00
	00		 mov	 r8d, 1109		; 00000455H
  00274	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0027b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00288	33 c0		 xor	 eax, eax
$LN15@bytearray_@16:
  0028a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00292	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00297	74 19		 je	 SHORT $LN16@bytearray_@16
  00299	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002a1	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  002a8	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
  002b0	eb 0f		 jmp	 SHORT $LN17@bytearray_@16
$LN16@bytearray_@16:
  002b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  002b9	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
$LN17@bytearray_@16:
  002c1	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  002c6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002cb	48 8b 44 24 40	 mov	 rax, QWORD PTR start$[rsp]
  002d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002d5	4c 8b 4c 24 48	 mov	 r9, QWORD PTR sub_len$[rsp]
  002da	4c 8b 44 24 50	 mov	 r8, QWORD PTR sub$[rsp]
  002df	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002e7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  002eb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv176[rsp]
  002f3	e8 00 00 00 00	 call	 stringlib_rfind_slice
  002f8	48 89 44 24 30	 mov	 QWORD PTR res$[rsp], rax
$LN2@bytearray_@16:

; 1111 : 
; 1112 :     if (subobj)

  002fd	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR subobj$[rsp], 0
  00306	74 0a		 je	 SHORT $LN1@bytearray_@16

; 1113 :         PyBuffer_Release(&subbuf);

  00308	48 8d 4c 24 60	 lea	 rcx, QWORD PTR subbuf$[rsp]
  0030d	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@16:

; 1114 : 
; 1115 :     return res;

  00312	48 8b 44 24 30	 mov	 rax, QWORD PTR res$[rsp]
$LN8@bytearray_@16:

; 1116 : }

  00317	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0031e	c3		 ret	 0
bytearray_find_internal ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$stringlib_find_slice DD imagerel stringlib_find_slice
	DD	imagerel stringlib_find_slice+205
	DD	imagerel $unwind$stringlib_find_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_find_slice DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_find_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
stringlib_find_slice PROC				; COMDAT

; 66   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 67   :     ADJUST_INDICES(start, end, str_len);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0001d	48 39 44 24 68	 cmp	 QWORD PTR end$[rsp], rax
  00022	7e 0c		 jle	 SHORT $LN6@stringlib_@18
  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  00029	48 89 44 24 68	 mov	 QWORD PTR end$[rsp], rax
  0002e	eb 2e		 jmp	 SHORT $LN5@stringlib_@18
$LN6@stringlib_@18:
  00030	48 83 7c 24 68
	00		 cmp	 QWORD PTR end$[rsp], 0
  00036	7d 26		 jge	 SHORT $LN4@stringlib_@18
  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0003d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR end$[rsp]
  00042	48 03 c8	 add	 rcx, rax
  00045	48 8b c1	 mov	 rax, rcx
  00048	48 89 44 24 68	 mov	 QWORD PTR end$[rsp], rax
  0004d	48 83 7c 24 68
	00		 cmp	 QWORD PTR end$[rsp], 0
  00053	7d 09		 jge	 SHORT $LN3@stringlib_@18
  00055	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR end$[rsp], 0
$LN3@stringlib_@18:
$LN4@stringlib_@18:
$LN5@stringlib_@18:
  0005e	48 83 7c 24 60
	00		 cmp	 QWORD PTR start$[rsp], 0
  00064	7d 26		 jge	 SHORT $LN2@stringlib_@18
  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0006b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax
  0007b	48 83 7c 24 60
	00		 cmp	 QWORD PTR start$[rsp], 0
  00081	7d 09		 jge	 SHORT $LN1@stringlib_@18
  00083	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
$LN1@stringlib_@18:
$LN2@stringlib_@18:

; 68   :     return STRINGLIB(find)(str + start, end - start, sub, sub_len, start);

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00091	48 8b 4c 24 68	 mov	 rcx, QWORD PTR end$[rsp]
  00096	48 2b c8	 sub	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  000a1	48 8b 54 24 40	 mov	 rdx, QWORD PTR str$[rsp]
  000a6	48 03 d1	 add	 rdx, rcx
  000a9	48 8b ca	 mov	 rcx, rdx
  000ac	48 8b 54 24 60	 mov	 rdx, QWORD PTR start$[rsp]
  000b1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000b6	4c 8b 4c 24 58	 mov	 r9, QWORD PTR sub_len$[rsp]
  000bb	4c 8b 44 24 50	 mov	 r8, QWORD PTR sub$[rsp]
  000c0	48 8b d0	 mov	 rdx, rax
  000c3	e8 00 00 00 00	 call	 stringlib_find

; 69   : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
stringlib_find_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_find DD imagerel stringlib_find
	DD	imagerel stringlib_find+142
	DD	imagerel $unwind$stringlib_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_find DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_find
_TEXT	SEGMENT
pos$ = 48
str$ = 80
str_len$ = 88
sub$ = 96
sub_len$ = 104
offset$ = 112
stringlib_find PROC					; COMDAT

; 11   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 12   :     Py_ssize_t pos;
; 13   : 
; 14   :     if (str_len < 0)

  00018	48 83 7c 24 58
	00		 cmp	 QWORD PTR str_len$[rsp], 0
  0001e	7d 09		 jge	 SHORT $LN3@stringlib_@19

; 15   :         return -1;

  00020	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00027	eb 60		 jmp	 SHORT $LN4@stringlib_@19
$LN3@stringlib_@19:

; 16   :     if (sub_len == 0)

  00029	48 83 7c 24 68
	00		 cmp	 QWORD PTR sub_len$[rsp], 0
  0002f	75 07		 jne	 SHORT $LN2@stringlib_@19

; 17   :         return offset;

  00031	48 8b 44 24 70	 mov	 rax, QWORD PTR offset$[rsp]
  00036	eb 51		 jmp	 SHORT $LN4@stringlib_@19
$LN2@stringlib_@19:

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

  00038	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  00040	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  00049	4c 8b 4c 24 68	 mov	 r9, QWORD PTR sub_len$[rsp]
  0004e	4c 8b 44 24 60	 mov	 r8, QWORD PTR sub$[rsp]
  00053	48 8b 54 24 58	 mov	 rdx, QWORD PTR str_len$[rsp]
  00058	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  0005d	e8 00 00 00 00	 call	 fastsearch
  00062	48 89 44 24 30	 mov	 QWORD PTR pos$[rsp], rax

; 20   : 
; 21   :     if (pos >= 0)

  00067	48 83 7c 24 30
	00		 cmp	 QWORD PTR pos$[rsp], 0
  0006d	7c 15		 jl	 SHORT $LN1@stringlib_@19

; 22   :         pos += offset;

  0006f	48 8b 44 24 70	 mov	 rax, QWORD PTR offset$[rsp]
  00074	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pos$[rsp]
  00079	48 03 c8	 add	 rcx, rax
  0007c	48 8b c1	 mov	 rax, rcx
  0007f	48 89 44 24 30	 mov	 QWORD PTR pos$[rsp], rax
$LN1@stringlib_@19:

; 23   : 
; 24   :     return pos;

  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR pos$[rsp]
$LN4@stringlib_@19:

; 25   : }

  00089	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008d	c3		 ret	 0
stringlib_find ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$fastsearch DD imagerel fastsearch
	DD	imagerel fastsearch+2017
	DD	imagerel $unwind$fastsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fastsearch DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fastsearch
_TEXT	SEGMENT
w$ = 48
count$ = 56
i$ = 64
mask$ = 72
skip$ = 80
mlast$ = 88
j$ = 96
needle$21278 = 104
tv298 = 108
tv312 = 112
tv339 = 116
tv351 = 120
tv359 = 124
tv368 = 128
tv391 = 132
tv402 = 136
s$ = 160
n$ = 168
p$ = 176
m$ = 184
maxcount$ = 192
mode$ = 200
fastsearch PROC						; COMDAT

; 87   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 88   :     unsigned long mask;
; 89   :     Py_ssize_t skip, count = 0;

  0001b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 90   :     Py_ssize_t i, j, mlast, w;
; 91   : 
; 92   :     w = n - m;

  00024	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  0002c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00034	48 2b c8	 sub	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 89 44 24 30	 mov	 QWORD PTR w$[rsp], rax

; 93   : 
; 94   :     if (w < 0 || (mode == FAST_COUNT && maxcount == 0))

  0003f	48 83 7c 24 30
	00		 cmp	 QWORD PTR w$[rsp], 0
  00045	7c 15		 jl	 SHORT $LN60@fastsearch
  00047	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  0004f	75 17		 jne	 SHORT $LN61@fastsearch
  00051	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR maxcount$[rsp], 0
  0005a	75 0c		 jne	 SHORT $LN61@fastsearch
$LN60@fastsearch:

; 95   :         return -1;

  0005c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00063	e9 71 07 00 00	 jmp	 $LN62@fastsearch
$LN61@fastsearch:

; 96   : 
; 97   :     /* look for special cases */
; 98   :     if (m <= 1) {

  00068	48 83 bc 24 b8
	00 00 00 01	 cmp	 QWORD PTR m$[rsp], 1
  00071	0f 8f e0 01 00
	00		 jg	 $LN59@fastsearch

; 99   :         if (m <= 0)

  00077	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR m$[rsp], 0
  00080	7f 0c		 jg	 SHORT $LN58@fastsearch

; 100  :             return -1;

  00082	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00089	e9 4b 07 00 00	 jmp	 $LN62@fastsearch
$LN58@fastsearch:

; 101  :         /* use special case for 1-character strings */
; 102  :         if (n > 10 && (mode == FAST_SEARCH
; 103  : #ifdef HAVE_MEMRCHR
; 104  :                     || mode == FAST_RSEARCH
; 105  : #endif
; 106  :                     )) {

  0008e	48 83 bc 24 a8
	00 00 00 0a	 cmp	 QWORD PTR n$[rsp], 10
  00097	7e 62		 jle	 SHORT $LN57@fastsearch
  00099	83 bc 24 c8 00
	00 00 01	 cmp	 DWORD PTR mode$[rsp], 1
  000a1	75 58		 jne	 SHORT $LN57@fastsearch

; 107  :             /* use memchr if we can choose a needle without two many likely
; 108  :                false positives */
; 109  :             unsigned char needle;
; 110  :             needle = p[0] & 0xff;

  000a3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  000ab	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b3	88 44 24 68	 mov	 BYTE PTR needle$21278[rsp], al

; 111  : #if STRINGLIB_SIZEOF_CHAR > 1
; 112  :             /* If looking for a multiple of 256, we'd have too
; 113  :                many false positives looking for the '\0' byte in UCS2
; 114  :                and UCS4 representations. */
; 115  :             if (needle != 0)
; 116  : #endif
; 117  :                 return STRINGLIB(fastsearch_memchr_1char)
; 118  :                        (s, n, p[0], needle, maxcount, mode);

  000b7	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR mode$[rsp]
  000be	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000c2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cf	44 0f b6 4c 24
	68		 movzx	 r9d, BYTE PTR needle$21278[rsp]
  000d5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  000dd	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  000e1	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  000e9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f1	e8 00 00 00 00	 call	 stringlib_fastsearch_memchr_1char
  000f6	e9 de 06 00 00	 jmp	 $LN62@fastsearch
$LN57@fastsearch:

; 119  :         }
; 120  :         if (mode == FAST_COUNT) {

  000fb	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  00103	0f 85 86 00 00
	00		 jne	 $LN56@fastsearch

; 121  :             for (i = 0; i < n; i++)

  00109	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00112	eb 0d		 jmp	 SHORT $LN55@fastsearch
$LN54@fastsearch:
  00114	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00119	48 ff c0	 inc	 rax
  0011c	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN55@fastsearch:
  00121	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00129	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  0012e	7d 50		 jge	 SHORT $LN53@fastsearch

; 122  :                 if (s[i] == p[0]) {

  00130	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00135	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0013d	48 03 c8	 add	 rcx, rax
  00140	48 8b c1	 mov	 rax, rcx
  00143	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00146	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  0014e	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00151	3b c1		 cmp	 eax, ecx
  00153	75 29		 jne	 SHORT $LN52@fastsearch

; 123  :                     count++;

  00155	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  0015a	48 ff c0	 inc	 rax
  0015d	48 89 44 24 38	 mov	 QWORD PTR count$[rsp], rax

; 124  :                     if (count == maxcount)

  00162	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0016a	48 39 44 24 38	 cmp	 QWORD PTR count$[rsp], rax
  0016f	75 0d		 jne	 SHORT $LN51@fastsearch

; 125  :                         return maxcount;

  00171	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00179	e9 5b 06 00 00	 jmp	 $LN62@fastsearch
$LN51@fastsearch:
$LN52@fastsearch:

; 126  :                 }

  0017e	eb 94		 jmp	 SHORT $LN54@fastsearch
$LN53@fastsearch:

; 127  :             return count;

  00180	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  00185	e9 4f 06 00 00	 jmp	 $LN62@fastsearch
  0018a	e9 bc 00 00 00	 jmp	 $LN50@fastsearch
$LN56@fastsearch:

; 128  :         } else if (mode == FAST_SEARCH) {

  0018f	83 bc 24 c8 00
	00 00 01	 cmp	 DWORD PTR mode$[rsp], 1
  00197	75 5a		 jne	 SHORT $LN49@fastsearch

; 129  :             for (i = 0; i < n; i++)

  00199	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001a2	eb 0d		 jmp	 SHORT $LN48@fastsearch
$LN47@fastsearch:
  001a4	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001a9	48 ff c0	 inc	 rax
  001ac	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN48@fastsearch:
  001b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001b9	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  001be	7d 31		 jge	 SHORT $LN46@fastsearch

; 130  :                 if (s[i] == p[0])

  001c0	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001c5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001cd	48 03 c8	 add	 rcx, rax
  001d0	48 8b c1	 mov	 rax, rcx
  001d3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001d6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  001de	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  001e1	3b c1		 cmp	 eax, ecx
  001e3	75 0a		 jne	 SHORT $LN45@fastsearch

; 131  :                     return i;

  001e5	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001ea	e9 ea 05 00 00	 jmp	 $LN62@fastsearch
$LN45@fastsearch:

; 132  :         } else {    /* FAST_RSEARCH */

  001ef	eb b3		 jmp	 SHORT $LN47@fastsearch
$LN46@fastsearch:
  001f1	eb 58		 jmp	 SHORT $LN44@fastsearch
$LN49@fastsearch:

; 133  :             for (i = n - 1; i > -1; i--)

  001f3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001fb	48 ff c8	 dec	 rax
  001fe	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00203	eb 0d		 jmp	 SHORT $LN43@fastsearch
$LN42@fastsearch:
  00205	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0020a	48 ff c8	 dec	 rax
  0020d	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN43@fastsearch:
  00212	48 83 7c 24 40
	ff		 cmp	 QWORD PTR i$[rsp], -1
  00218	7e 31		 jle	 SHORT $LN41@fastsearch

; 134  :                 if (s[i] == p[0])

  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0021f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00227	48 03 c8	 add	 rcx, rax
  0022a	48 8b c1	 mov	 rax, rcx
  0022d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00230	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00238	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  0023b	3b c1		 cmp	 eax, ecx
  0023d	75 0a		 jne	 SHORT $LN40@fastsearch

; 135  :                     return i;

  0023f	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00244	e9 90 05 00 00	 jmp	 $LN62@fastsearch
$LN40@fastsearch:

; 136  :         }

  00249	eb ba		 jmp	 SHORT $LN42@fastsearch
$LN41@fastsearch:
$LN44@fastsearch:
$LN50@fastsearch:

; 137  :         return -1;

  0024b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00252	e9 82 05 00 00	 jmp	 $LN62@fastsearch
$LN59@fastsearch:

; 138  :     }
; 139  : 
; 140  :     mlast = m - 1;

  00257	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  0025f	48 ff c8	 dec	 rax
  00262	48 89 44 24 58	 mov	 QWORD PTR mlast$[rsp], rax

; 141  :     skip = mlast - 1;

  00267	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  0026c	48 ff c8	 dec	 rax
  0026f	48 89 44 24 50	 mov	 QWORD PTR skip$[rsp], rax

; 142  :     mask = 0;

  00274	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR mask$[rsp], 0

; 143  : 
; 144  :     if (mode != FAST_RSEARCH) {

  0027c	83 bc 24 c8 00
	00 00 02	 cmp	 DWORD PTR mode$[rsp], 2
  00284	0f 84 e1 02 00
	00		 je	 $LN39@fastsearch

; 145  : 
; 146  :         /* create compressed boyer-moore delta 1 table */
; 147  : 
; 148  :         /* process pattern[:-1] */
; 149  :         for (i = 0; i < mlast; i++) {

  0028a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00293	eb 0d		 jmp	 SHORT $LN38@fastsearch
$LN37@fastsearch:
  00295	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0029a	48 ff c0	 inc	 rax
  0029d	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN38@fastsearch:
  002a2	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  002a7	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  002ac	0f 8d 84 00 00
	00		 jge	 $LN36@fastsearch

; 150  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  002b2	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  002b7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  002bf	48 03 c8	 add	 rcx, rax
  002c2	48 8b c1	 mov	 rax, rcx
  002c5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002c8	83 e0 1f	 and	 eax, 31
  002cb	b9 01 00 00 00	 mov	 ecx, 1
  002d0	89 4c 24 6c	 mov	 DWORD PTR tv298[rsp], ecx
  002d4	0f b6 c8	 movzx	 ecx, al
  002d7	8b 44 24 6c	 mov	 eax, DWORD PTR tv298[rsp]
  002db	d3 e0		 shl	 eax, cl
  002dd	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  002e1	0b c8		 or	 ecx, eax
  002e3	8b c1		 mov	 eax, ecx
  002e5	89 44 24 48	 mov	 DWORD PTR mask$[rsp], eax

; 151  :             if (p[i] == p[mlast])

  002e9	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  002ee	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  002f6	48 03 c8	 add	 rcx, rax
  002f9	48 8b c1	 mov	 rax, rcx
  002fc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR mlast$[rsp]
  00304	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  0030c	48 03 d1	 add	 rdx, rcx
  0030f	48 8b ca	 mov	 rcx, rdx
  00312	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00315	3b c1		 cmp	 eax, ecx
  00317	75 18		 jne	 SHORT $LN35@fastsearch

; 152  :                 skip = mlast - i - 1;

  00319	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0031e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR mlast$[rsp]
  00323	48 2b c8	 sub	 rcx, rax
  00326	48 8b c1	 mov	 rax, rcx
  00329	48 ff c8	 dec	 rax
  0032c	48 89 44 24 50	 mov	 QWORD PTR skip$[rsp], rax
$LN35@fastsearch:

; 153  :         }

  00331	e9 5f ff ff ff	 jmp	 $LN37@fastsearch
$LN36@fastsearch:

; 154  :         /* process pattern[-1] outside the loop */
; 155  :         STRINGLIB_BLOOM_ADD(mask, p[mlast]);

  00336	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  0033b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00343	48 03 c8	 add	 rcx, rax
  00346	48 8b c1	 mov	 rax, rcx
  00349	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0034c	83 e0 1f	 and	 eax, 31
  0034f	b9 01 00 00 00	 mov	 ecx, 1
  00354	89 4c 24 70	 mov	 DWORD PTR tv312[rsp], ecx
  00358	0f b6 c8	 movzx	 ecx, al
  0035b	8b 44 24 70	 mov	 eax, DWORD PTR tv312[rsp]
  0035f	d3 e0		 shl	 eax, cl
  00361	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  00365	0b c8		 or	 ecx, eax
  00367	8b c1		 mov	 eax, ecx
  00369	89 44 24 48	 mov	 DWORD PTR mask$[rsp], eax

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  0036d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00376	eb 0d		 jmp	 SHORT $LN34@fastsearch
$LN33@fastsearch:
  00378	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0037d	48 ff c0	 inc	 rax
  00380	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN34@fastsearch:
  00385	48 8b 44 24 30	 mov	 rax, QWORD PTR w$[rsp]
  0038a	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  0038f	0f 8f d1 01 00
	00		 jg	 $LN32@fastsearch

; 158  :             /* note: using mlast in the skip path slows things down on x86 */
; 159  :             if (s[i+m-1] == p[m-1]) {

  00395	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  0039d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  003a2	48 03 c8	 add	 rcx, rax
  003a5	48 8b c1	 mov	 rax, rcx
  003a8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003b0	0f be 44 01 ff	 movsx	 eax, BYTE PTR [rcx+rax-1]
  003b5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR m$[rsp]
  003bd	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  003c5	48 03 d1	 add	 rdx, rcx
  003c8	48 8b ca	 mov	 rcx, rdx
  003cb	0f be 49 ff	 movsx	 ecx, BYTE PTR [rcx-1]
  003cf	3b c1		 cmp	 eax, ecx
  003d1	0f 85 32 01 00
	00		 jne	 $LN31@fastsearch

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  003d7	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  003e0	eb 0d		 jmp	 SHORT $LN30@fastsearch
$LN29@fastsearch:
  003e2	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  003e7	48 ff c0	 inc	 rax
  003ea	48 89 44 24 60	 mov	 QWORD PTR j$[rsp], rax
$LN30@fastsearch:
  003ef	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  003f4	48 39 44 24 60	 cmp	 QWORD PTR j$[rsp], rax
  003f9	7d 3a		 jge	 SHORT $LN28@fastsearch

; 162  :                     if (s[i+j] != p[j])

  003fb	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00400	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00405	48 03 c8	 add	 rcx, rax
  00408	48 8b c1	 mov	 rax, rcx
  0040b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00413	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00417	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0041c	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00424	48 03 d1	 add	 rdx, rcx
  00427	48 8b ca	 mov	 rcx, rdx
  0042a	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  0042d	3b c1		 cmp	 eax, ecx
  0042f	74 02		 je	 SHORT $LN27@fastsearch

; 163  :                         break;

  00431	eb 02		 jmp	 SHORT $LN28@fastsearch
$LN27@fastsearch:

; 164  :                 if (j == mlast) {

  00433	eb ad		 jmp	 SHORT $LN29@fastsearch
$LN28@fastsearch:
  00435	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  0043a	48 39 44 24 60	 cmp	 QWORD PTR j$[rsp], rax
  0043f	75 57		 jne	 SHORT $LN26@fastsearch

; 165  :                     /* got a match! */
; 166  :                     if (mode != FAST_COUNT)

  00441	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  00449	74 0a		 je	 SHORT $LN25@fastsearch

; 167  :                         return i;

  0044b	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00450	e9 84 03 00 00	 jmp	 $LN62@fastsearch
$LN25@fastsearch:

; 168  :                     count++;

  00455	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  0045a	48 ff c0	 inc	 rax
  0045d	48 89 44 24 38	 mov	 QWORD PTR count$[rsp], rax

; 169  :                     if (count == maxcount)

  00462	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0046a	48 39 44 24 38	 cmp	 QWORD PTR count$[rsp], rax
  0046f	75 0d		 jne	 SHORT $LN24@fastsearch

; 170  :                         return maxcount;

  00471	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00479	e9 5b 03 00 00	 jmp	 $LN62@fastsearch
$LN24@fastsearch:

; 171  :                     i = i + mlast;

  0047e	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  00483	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00488	48 03 c8	 add	 rcx, rax
  0048b	48 8b c1	 mov	 rax, rcx
  0048e	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax

; 172  :                     continue;

  00493	e9 e0 fe ff ff	 jmp	 $LN33@fastsearch
$LN26@fastsearch:

; 173  :                 }
; 174  :                 /* miss: check if next character is part of pattern */
; 175  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  00498	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  004a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  004a5	48 03 c8	 add	 rcx, rax
  004a8	48 8b c1	 mov	 rax, rcx
  004ab	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004b3	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  004b7	83 e0 1f	 and	 eax, 31
  004ba	b9 01 00 00 00	 mov	 ecx, 1
  004bf	89 4c 24 74	 mov	 DWORD PTR tv339[rsp], ecx
  004c3	0f b6 c8	 movzx	 ecx, al
  004c6	8b 44 24 74	 mov	 eax, DWORD PTR tv339[rsp]
  004ca	d3 e0		 shl	 eax, cl
  004cc	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  004d0	23 c8		 and	 ecx, eax
  004d2	8b c1		 mov	 eax, ecx
  004d4	85 c0		 test	 eax, eax
  004d6	75 1a		 jne	 SHORT $LN23@fastsearch

; 176  :                     i = i + m;

  004d8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  004e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  004e5	48 03 c8	 add	 rcx, rax
  004e8	48 8b c1	 mov	 rax, rcx
  004eb	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax

; 177  :                 else

  004f0	eb 15		 jmp	 SHORT $LN22@fastsearch
$LN23@fastsearch:

; 178  :                     i = i + skip;

  004f2	48 8b 44 24 50	 mov	 rax, QWORD PTR skip$[rsp]
  004f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  004fc	48 03 c8	 add	 rcx, rax
  004ff	48 8b c1	 mov	 rax, rcx
  00502	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN22@fastsearch:

; 179  :             } else {

  00507	eb 58		 jmp	 SHORT $LN21@fastsearch
$LN31@fastsearch:

; 180  :                 /* skip: check if next character is part of pattern */
; 181  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  00509	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00511	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00516	48 03 c8	 add	 rcx, rax
  00519	48 8b c1	 mov	 rax, rcx
  0051c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00524	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00528	83 e0 1f	 and	 eax, 31
  0052b	b9 01 00 00 00	 mov	 ecx, 1
  00530	89 4c 24 78	 mov	 DWORD PTR tv351[rsp], ecx
  00534	0f b6 c8	 movzx	 ecx, al
  00537	8b 44 24 78	 mov	 eax, DWORD PTR tv351[rsp]
  0053b	d3 e0		 shl	 eax, cl
  0053d	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  00541	23 c8		 and	 ecx, eax
  00543	8b c1		 mov	 eax, ecx
  00545	85 c0		 test	 eax, eax
  00547	75 18		 jne	 SHORT $LN20@fastsearch

; 182  :                     i = i + m;

  00549	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00551	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00556	48 03 c8	 add	 rcx, rax
  00559	48 8b c1	 mov	 rax, rcx
  0055c	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN20@fastsearch:
$LN21@fastsearch:

; 183  :             }
; 184  :         }

  00561	e9 12 fe ff ff	 jmp	 $LN33@fastsearch
$LN32@fastsearch:

; 185  :     } else {    /* FAST_RSEARCH */

  00566	e9 56 02 00 00	 jmp	 $LN19@fastsearch
$LN39@fastsearch:

; 186  : 
; 187  :         /* create compressed boyer-moore delta 1 table */
; 188  : 
; 189  :         /* process pattern[0] outside the loop */
; 190  :         STRINGLIB_BLOOM_ADD(mask, p[0]);

  0056b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00573	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00576	83 e0 1f	 and	 eax, 31
  00579	b9 01 00 00 00	 mov	 ecx, 1
  0057e	89 4c 24 7c	 mov	 DWORD PTR tv359[rsp], ecx
  00582	0f b6 c8	 movzx	 ecx, al
  00585	8b 44 24 7c	 mov	 eax, DWORD PTR tv359[rsp]
  00589	d3 e0		 shl	 eax, cl
  0058b	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  0058f	0b c8		 or	 ecx, eax
  00591	8b c1		 mov	 eax, ecx
  00593	89 44 24 48	 mov	 DWORD PTR mask$[rsp], eax

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  00597	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  0059c	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  005a1	eb 0d		 jmp	 SHORT $LN18@fastsearch
$LN17@fastsearch:
  005a3	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  005a8	48 ff c8	 dec	 rax
  005ab	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN18@fastsearch:
  005b0	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  005b6	7e 74		 jle	 SHORT $LN16@fastsearch

; 193  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  005b8	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  005bd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  005c5	48 03 c8	 add	 rcx, rax
  005c8	48 8b c1	 mov	 rax, rcx
  005cb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005ce	83 e0 1f	 and	 eax, 31
  005d1	b9 01 00 00 00	 mov	 ecx, 1
  005d6	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv368[rsp], ecx
  005dd	0f b6 c8	 movzx	 ecx, al
  005e0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv368[rsp]
  005e7	d3 e0		 shl	 eax, cl
  005e9	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  005ed	0b c8		 or	 ecx, eax
  005ef	8b c1		 mov	 eax, ecx
  005f1	89 44 24 48	 mov	 DWORD PTR mask$[rsp], eax

; 194  :             if (p[i] == p[0])

  005f5	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  005fa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00602	48 03 c8	 add	 rcx, rax
  00605	48 8b c1	 mov	 rax, rcx
  00608	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0060b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00613	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00616	3b c1		 cmp	 eax, ecx
  00618	75 0d		 jne	 SHORT $LN15@fastsearch

; 195  :                 skip = i - 1;

  0061a	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0061f	48 ff c8	 dec	 rax
  00622	48 89 44 24 50	 mov	 QWORD PTR skip$[rsp], rax
$LN15@fastsearch:

; 196  :         }

  00627	e9 77 ff ff ff	 jmp	 $LN17@fastsearch
$LN16@fastsearch:

; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  0062c	48 8b 44 24 30	 mov	 rax, QWORD PTR w$[rsp]
  00631	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00636	eb 0d		 jmp	 SHORT $LN14@fastsearch
$LN13@fastsearch:
  00638	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0063d	48 ff c8	 dec	 rax
  00640	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN14@fastsearch:
  00645	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  0064b	0f 8c 70 01 00
	00		 jl	 $LN12@fastsearch

; 199  :             if (s[i] == p[0]) {

  00651	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00656	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0065e	48 03 c8	 add	 rcx, rax
  00661	48 8b c1	 mov	 rax, rcx
  00664	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00667	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  0066f	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00672	3b c1		 cmp	 eax, ecx
  00674	0f 85 e4 00 00
	00		 jne	 $LN11@fastsearch

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  0067a	48 8b 44 24 58	 mov	 rax, QWORD PTR mlast$[rsp]
  0067f	48 89 44 24 60	 mov	 QWORD PTR j$[rsp], rax
  00684	eb 0d		 jmp	 SHORT $LN10@fastsearch
$LN9@fastsearch:
  00686	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0068b	48 ff c8	 dec	 rax
  0068e	48 89 44 24 60	 mov	 QWORD PTR j$[rsp], rax
$LN10@fastsearch:
  00693	48 83 7c 24 60
	00		 cmp	 QWORD PTR j$[rsp], 0
  00699	7e 3a		 jle	 SHORT $LN8@fastsearch

; 202  :                     if (s[i+j] != p[j])

  0069b	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  006a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  006a5	48 03 c8	 add	 rcx, rax
  006a8	48 8b c1	 mov	 rax, rcx
  006ab	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006b3	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  006b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  006bc	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  006c4	48 03 d1	 add	 rdx, rcx
  006c7	48 8b ca	 mov	 rcx, rdx
  006ca	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  006cd	3b c1		 cmp	 eax, ecx
  006cf	74 02		 je	 SHORT $LN7@fastsearch

; 203  :                         break;

  006d1	eb 02		 jmp	 SHORT $LN8@fastsearch
$LN7@fastsearch:

; 204  :                 if (j == 0)

  006d3	eb b1		 jmp	 SHORT $LN9@fastsearch
$LN8@fastsearch:
  006d5	48 83 7c 24 60
	00		 cmp	 QWORD PTR j$[rsp], 0
  006db	75 0a		 jne	 SHORT $LN6@fastsearch

; 205  :                     /* got a match! */
; 206  :                     return i;

  006dd	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  006e2	e9 f2 00 00 00	 jmp	 $LN62@fastsearch
$LN6@fastsearch:

; 207  :                 /* miss: check if previous character is part of pattern */
; 208  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  006e7	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  006ed	7e 58		 jle	 SHORT $LN5@fastsearch
  006ef	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  006f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006fc	48 03 c8	 add	 rcx, rax
  006ff	48 8b c1	 mov	 rax, rcx
  00702	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  00706	83 e0 1f	 and	 eax, 31
  00709	b9 01 00 00 00	 mov	 ecx, 1
  0070e	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv391[rsp], ecx
  00715	0f b6 c8	 movzx	 ecx, al
  00718	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv391[rsp]
  0071f	d3 e0		 shl	 eax, cl
  00721	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  00725	23 c8		 and	 ecx, eax
  00727	8b c1		 mov	 eax, ecx
  00729	85 c0		 test	 eax, eax
  0072b	75 1a		 jne	 SHORT $LN5@fastsearch

; 209  :                     i = i - m;

  0072d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00735	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  0073a	48 2b c8	 sub	 rcx, rax
  0073d	48 8b c1	 mov	 rax, rcx
  00740	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax

; 210  :                 else

  00745	eb 15		 jmp	 SHORT $LN4@fastsearch
$LN5@fastsearch:

; 211  :                     i = i - skip;

  00747	48 8b 44 24 50	 mov	 rax, QWORD PTR skip$[rsp]
  0074c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00751	48 2b c8	 sub	 rcx, rax
  00754	48 8b c1	 mov	 rax, rcx
  00757	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN4@fastsearch:

; 212  :             } else {

  0075c	eb 5e		 jmp	 SHORT $LN3@fastsearch
$LN11@fastsearch:

; 213  :                 /* skip: check if previous character is part of pattern */
; 214  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  0075e	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  00764	7e 56		 jle	 SHORT $LN2@fastsearch
  00766	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0076b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00773	48 03 c8	 add	 rcx, rax
  00776	48 8b c1	 mov	 rax, rcx
  00779	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  0077d	83 e0 1f	 and	 eax, 31
  00780	b9 01 00 00 00	 mov	 ecx, 1
  00785	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv402[rsp], ecx
  0078c	0f b6 c8	 movzx	 ecx, al
  0078f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv402[rsp]
  00796	d3 e0		 shl	 eax, cl
  00798	8b 4c 24 48	 mov	 ecx, DWORD PTR mask$[rsp]
  0079c	23 c8		 and	 ecx, eax
  0079e	8b c1		 mov	 eax, ecx
  007a0	85 c0		 test	 eax, eax
  007a2	75 18		 jne	 SHORT $LN2@fastsearch

; 215  :                     i = i - m;

  007a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  007ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  007b1	48 2b c8	 sub	 rcx, rax
  007b4	48 8b c1	 mov	 rax, rcx
  007b7	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN2@fastsearch:
$LN3@fastsearch:

; 216  :             }
; 217  :         }

  007bc	e9 77 fe ff ff	 jmp	 $LN13@fastsearch
$LN12@fastsearch:
$LN19@fastsearch:

; 218  :     }
; 219  : 
; 220  :     if (mode != FAST_COUNT)

  007c1	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  007c9	74 09		 je	 SHORT $LN1@fastsearch

; 221  :         return -1;

  007cb	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  007d2	eb 05		 jmp	 SHORT $LN62@fastsearch
$LN1@fastsearch:

; 222  :     return count;

  007d4	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
$LN62@fastsearch:

; 223  : }

  007d9	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  007e0	c3		 ret	 0
fastsearch ENDP
_TEXT	ENDS
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_1GC@ONFLMJIG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ ; `string'
EXTRN	__imp_memchr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_fastsearch_memchr_1char DD imagerel stringlib_fastsearch_memchr_1char
	DD	imagerel stringlib_fastsearch_memchr_1char+239
	DD	imagerel $unwind$stringlib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_fastsearch_memchr_1char DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@ONFLMJIG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1GC@ONFLMJIG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'l', 00H
	DB	'i', 00H, 'b', 00H, '/', 00H, 'f', 00H, 'a', 00H, 's', 00H, 't'
	DB	00H, 's', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_fastsearch_memchr_1char
_TEXT	SEGMENT
ptr$21231 = 32
e$21232 = 40
candidate$21236 = 48
s$ = 80
n$ = 88
ch$ = 96
needle$ = 104
maxcount$ = 112
mode$ = 120
stringlib_fastsearch_memchr_1char PROC			; COMDAT

; 40   : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 41   :     if (mode == FAST_SEARCH) {

  00018	83 7c 24 78 01	 cmp	 DWORD PTR mode$[rsp], 1
  0001d	0f 85 a3 00 00
	00		 jne	 $LN6@stringlib_@20

; 42   :         const STRINGLIB_CHAR *ptr = s;

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00028	48 89 44 24 20	 mov	 QWORD PTR ptr$21231[rsp], rax

; 43   :         const STRINGLIB_CHAR *e = s + n;

  0002d	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 89 44 24 28	 mov	 QWORD PTR e$21232[rsp], rax
$LN5@stringlib_@20:

; 44   :         while (ptr < e) {

  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR e$21232[rsp]
  00047	48 39 44 24 20	 cmp	 QWORD PTR ptr$21231[rsp], rax
  0004c	73 6d		 jae	 SHORT $LN4@stringlib_@20

; 45   :             void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(STRINGLIB_CHAR));

  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$21231[rsp]
  00053	48 8b 4c 24 28	 mov	 rcx, QWORD PTR e$21232[rsp]
  00058	48 2b c8	 sub	 rcx, rax
  0005b	48 8b c1	 mov	 rax, rcx
  0005e	0f b6 4c 24 68	 movzx	 ecx, BYTE PTR needle$[rsp]
  00063	4c 8b c0	 mov	 r8, rax
  00066	8b d1		 mov	 edx, ecx
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$21231[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00073	48 89 44 24 30	 mov	 QWORD PTR candidate$21236[rsp], rax

; 46   :             if (candidate == NULL)

  00078	48 83 7c 24 30
	00		 cmp	 QWORD PTR candidate$21236[rsp], 0
  0007e	75 09		 jne	 SHORT $LN3@stringlib_@20

; 47   :                 return -1;

  00080	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00087	eb 61		 jmp	 SHORT $LN7@stringlib_@20
$LN3@stringlib_@20:

; 48   :             ptr = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));

  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR candidate$21236[rsp]
  0008e	48 89 44 24 20	 mov	 QWORD PTR ptr$21231[rsp], rax

; 49   :             if (sizeof(STRINGLIB_CHAR) == 1 || *ptr == ch)

  00093	33 c0		 xor	 eax, eax
  00095	83 f8 01	 cmp	 eax, 1
  00098	74 12		 je	 SHORT $LN2@stringlib_@20

; 50   :                 return (ptr - s);

  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0009f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$21231[rsp]
  000a4	48 2b c8	 sub	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	eb 3e		 jmp	 SHORT $LN7@stringlib_@20
$LN2@stringlib_@20:

; 51   :             /* False positive */
; 52   :             ptr++;

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$21231[rsp]
  000b1	48 ff c0	 inc	 rax
  000b4	48 89 44 24 20	 mov	 QWORD PTR ptr$21231[rsp], rax

; 53   :         }

  000b9	eb 87		 jmp	 SHORT $LN5@stringlib_@20
$LN4@stringlib_@20:

; 54   :         return -1;

  000bb	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000c2	eb 26		 jmp	 SHORT $LN7@stringlib_@20

; 55   :     }
; 56   : #ifdef HAVE_MEMRCHR
; 57   :     /* memrchr() is a GNU extension, available since glibc 2.1.91.
; 58   :        it doesn't seem as optimized as memchr(), but is still quite
; 59   :        faster than our hand-written loop in FASTSEARCH below */
; 60   :     else if (mode == FAST_RSEARCH) {
; 61   :         while (n > 0) {
; 62   :             const STRINGLIB_CHAR *found;
; 63   :             void *candidate = memrchr((const void *) s, needle, n * sizeof(STRINGLIB_CHAR));
; 64   :             if (candidate == NULL)
; 65   :                 return -1;
; 66   :             found = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));
; 67   :             n = found - s;
; 68   :             if (sizeof(STRINGLIB_CHAR) == 1 || *found == ch)
; 69   :                 return n;
; 70   :             /* False positive */
; 71   :         }
; 72   :         return -1;
; 73   :     }
; 74   : #endif
; 75   :     else {

  000c4	eb 24		 jmp	 SHORT $LN1@stringlib_@20
$LN6@stringlib_@20:

; 76   :         assert(0); /* Should never get here */

  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 1c		 jne	 SHORT $LN9@stringlib_@20
  000cc	41 b8 4c 00 00
	00		 mov	 r8d, 76			; 0000004cH
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GC@ONFLMJIG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg@
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e6	33 c0		 xor	 eax, eax
$LN9@stringlib_@20:

; 77   :         return 0;

  000e8	33 c0		 xor	 eax, eax
$LN1@stringlib_@20:
$LN7@stringlib_@20:

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  000ea	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ee	c3		 ret	 0
stringlib_fastsearch_memchr_1char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$stringlib_rfind_slice DD imagerel stringlib_rfind_slice
	DD	imagerel stringlib_rfind_slice+205
	DD	imagerel $unwind$stringlib_rfind_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rfind_slice DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rfind_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
stringlib_rfind_slice PROC				; COMDAT

; 75   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 76   :     ADJUST_INDICES(start, end, str_len);

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0001d	48 39 44 24 68	 cmp	 QWORD PTR end$[rsp], rax
  00022	7e 0c		 jle	 SHORT $LN6@stringlib_@21
  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  00029	48 89 44 24 68	 mov	 QWORD PTR end$[rsp], rax
  0002e	eb 2e		 jmp	 SHORT $LN5@stringlib_@21
$LN6@stringlib_@21:
  00030	48 83 7c 24 68
	00		 cmp	 QWORD PTR end$[rsp], 0
  00036	7d 26		 jge	 SHORT $LN4@stringlib_@21
  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0003d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR end$[rsp]
  00042	48 03 c8	 add	 rcx, rax
  00045	48 8b c1	 mov	 rax, rcx
  00048	48 89 44 24 68	 mov	 QWORD PTR end$[rsp], rax
  0004d	48 83 7c 24 68
	00		 cmp	 QWORD PTR end$[rsp], 0
  00053	7d 09		 jge	 SHORT $LN3@stringlib_@21
  00055	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR end$[rsp], 0
$LN3@stringlib_@21:
$LN4@stringlib_@21:
$LN5@stringlib_@21:
  0005e	48 83 7c 24 60
	00		 cmp	 QWORD PTR start$[rsp], 0
  00064	7d 26		 jge	 SHORT $LN2@stringlib_@21
  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR str_len$[rsp]
  0006b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax
  0007b	48 83 7c 24 60
	00		 cmp	 QWORD PTR start$[rsp], 0
  00081	7d 09		 jge	 SHORT $LN1@stringlib_@21
  00083	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
$LN1@stringlib_@21:
$LN2@stringlib_@21:

; 77   :     return STRINGLIB(rfind)(str + start, end - start, sub, sub_len, start);

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00091	48 8b 4c 24 68	 mov	 rcx, QWORD PTR end$[rsp]
  00096	48 2b c8	 sub	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  000a1	48 8b 54 24 40	 mov	 rdx, QWORD PTR str$[rsp]
  000a6	48 03 d1	 add	 rdx, rcx
  000a9	48 8b ca	 mov	 rcx, rdx
  000ac	48 8b 54 24 60	 mov	 rdx, QWORD PTR start$[rsp]
  000b1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000b6	4c 8b 4c 24 58	 mov	 r9, QWORD PTR sub_len$[rsp]
  000bb	4c 8b 44 24 50	 mov	 r8, QWORD PTR sub$[rsp]
  000c0	48 8b d0	 mov	 rdx, rax
  000c3	e8 00 00 00 00	 call	 stringlib_rfind

; 78   : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
stringlib_rfind_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rfind DD imagerel stringlib_rfind
	DD	imagerel stringlib_rfind+153
	DD	imagerel $unwind$stringlib_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rfind DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rfind
_TEXT	SEGMENT
pos$ = 48
str$ = 80
str_len$ = 88
sub$ = 96
sub_len$ = 104
offset$ = 112
stringlib_rfind PROC					; COMDAT

; 31   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 32   :     Py_ssize_t pos;
; 33   : 
; 34   :     if (str_len < 0)

  00018	48 83 7c 24 58
	00		 cmp	 QWORD PTR str_len$[rsp], 0
  0001e	7d 09		 jge	 SHORT $LN3@stringlib_@22

; 35   :         return -1;

  00020	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00027	eb 6b		 jmp	 SHORT $LN4@stringlib_@22
$LN3@stringlib_@22:

; 36   :     if (sub_len == 0)

  00029	48 83 7c 24 68
	00		 cmp	 QWORD PTR sub_len$[rsp], 0
  0002f	75 12		 jne	 SHORT $LN2@stringlib_@22

; 37   :         return str_len + offset;

  00031	48 8b 44 24 70	 mov	 rax, QWORD PTR offset$[rsp]
  00036	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str_len$[rsp]
  0003b	48 03 c8	 add	 rcx, rax
  0003e	48 8b c1	 mov	 rax, rcx
  00041	eb 51		 jmp	 SHORT $LN4@stringlib_@22
$LN2@stringlib_@22:

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

  00043	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  0004b	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  00054	4c 8b 4c 24 68	 mov	 r9, QWORD PTR sub_len$[rsp]
  00059	4c 8b 44 24 60	 mov	 r8, QWORD PTR sub$[rsp]
  0005e	48 8b 54 24 58	 mov	 rdx, QWORD PTR str_len$[rsp]
  00063	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  00068	e8 00 00 00 00	 call	 fastsearch
  0006d	48 89 44 24 30	 mov	 QWORD PTR pos$[rsp], rax

; 40   : 
; 41   :     if (pos >= 0)

  00072	48 83 7c 24 30
	00		 cmp	 QWORD PTR pos$[rsp], 0
  00078	7c 15		 jl	 SHORT $LN1@stringlib_@22

; 42   :         pos += offset;

  0007a	48 8b 44 24 70	 mov	 rax, QWORD PTR offset$[rsp]
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pos$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	48 89 44 24 30	 mov	 QWORD PTR pos$[rsp], rax
$LN1@stringlib_@22:

; 43   : 
; 44   :     return pos;

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR pos$[rsp]
$LN4@stringlib_@22:

; 45   : }

  00094	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00098	c3		 ret	 0
stringlib_rfind ENDP
_TEXT	ENDS
EXTRN	PyErr_GivenExceptionMatches:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_parse_args_finds_byte DD imagerel stringlib_parse_args_finds_byte
	DD	imagerel stringlib_parse_args_finds_byte+283
	DD	imagerel $unwind$stringlib_parse_args_finds_byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_parse_args_finds_byte DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_parse_args_finds_byte
_TEXT	SEGMENT
tmp_subobj$ = 48
err$ = 56
ival$ = 64
function_name$ = 96
args$ = 104
subobj$ = 112
byte$ = 120
start$ = 128
end$ = 136
stringlib_parse_args_finds_byte PROC			; COMDAT

; 186  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 187  :     PyObject *tmp_subobj;
; 188  :     Py_ssize_t ival;
; 189  :     PyObject *err;
; 190  : 
; 191  :     if(!STRINGLIB(parse_args_finds)(function_name, args, &tmp_subobj,
; 192  :                                     start, end))

  00018	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR end$[rsp]
  00020	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00025	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR start$[rsp]
  0002d	4c 8d 44 24 30	 lea	 r8, QWORD PTR tmp_subobj$[rsp]
  00032	48 8b 54 24 68	 mov	 rdx, QWORD PTR args$[rsp]
  00037	48 8b 4c 24 60	 mov	 rcx, QWORD PTR function_name$[rsp]
  0003c	e8 00 00 00 00	 call	 stringlib_parse_args_finds
  00041	85 c0		 test	 eax, eax
  00043	75 07		 jne	 SHORT $LN6@stringlib_@23

; 193  :         return 0;

  00045	33 c0		 xor	 eax, eax
  00047	e9 ca 00 00 00	 jmp	 $LN7@stringlib_@23
$LN6@stringlib_@23:

; 194  : 
; 195  :     if (!PyNumber_Check(tmp_subobj)) {

  0004c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp_subobj$[rsp]
  00051	e8 00 00 00 00	 call	 PyNumber_Check
  00056	85 c0		 test	 eax, eax
  00058	75 17		 jne	 SHORT $LN5@stringlib_@23

; 196  :         *subobj = tmp_subobj;

  0005a	48 8b 44 24 70	 mov	 rax, QWORD PTR subobj$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp_subobj$[rsp]
  00064	48 89 08	 mov	 QWORD PTR [rax], rcx

; 197  :         return 1;

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	e9 a5 00 00 00	 jmp	 $LN7@stringlib_@23
$LN5@stringlib_@23:

; 198  :     }
; 199  : 
; 200  :     ival = PyNumber_AsSsize_t(tmp_subobj, PyExc_OverflowError);

  00071	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp_subobj$[rsp]
  0007d	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00082	48 89 44 24 40	 mov	 QWORD PTR ival$[rsp], rax

; 201  :     if (ival == -1) {

  00087	48 83 7c 24 40
	ff		 cmp	 QWORD PTR ival$[rsp], -1
  0008d	75 40		 jne	 SHORT $LN4@stringlib_@23

; 202  :         err = PyErr_Occurred();

  0008f	e8 00 00 00 00	 call	 PyErr_Occurred
  00094	48 89 44 24 38	 mov	 QWORD PTR err$[rsp], rax

; 203  :         if (err && !PyErr_GivenExceptionMatches(err, PyExc_OverflowError)) {

  00099	48 83 7c 24 38
	00		 cmp	 QWORD PTR err$[rsp], 0
  0009f	74 2e		 je	 SHORT $LN3@stringlib_@23
  000a1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR err$[rsp]
  000ad	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches
  000b2	85 c0		 test	 eax, eax
  000b4	75 19		 jne	 SHORT $LN3@stringlib_@23

; 204  :             PyErr_Clear();

  000b6	e8 00 00 00 00	 call	 PyErr_Clear

; 205  :             *subobj = tmp_subobj;

  000bb	48 8b 44 24 70	 mov	 rax, QWORD PTR subobj$[rsp]
  000c0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp_subobj$[rsp]
  000c5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 206  :             return 1;

  000c8	b8 01 00 00 00	 mov	 eax, 1
  000cd	eb 47		 jmp	 SHORT $LN7@stringlib_@23
$LN3@stringlib_@23:
$LN4@stringlib_@23:

; 207  :         }
; 208  :     }
; 209  : 
; 210  :     if (ival < 0 || ival > 255) {

  000cf	48 83 7c 24 40
	00		 cmp	 QWORD PTR ival$[rsp], 0
  000d5	7c 0b		 jl	 SHORT $LN1@stringlib_@23
  000d7	48 81 7c 24 40
	ff 00 00 00	 cmp	 QWORD PTR ival$[rsp], 255 ; 000000ffH
  000e0	7e 17		 jle	 SHORT $LN2@stringlib_@23
$LN1@stringlib_@23:

; 211  :         PyErr_SetString(PyExc_ValueError, "byte must be in range(0, 256)");

  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  000e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000f0	e8 00 00 00 00	 call	 PyErr_SetString

; 212  :         return 0;

  000f5	33 c0		 xor	 eax, eax
  000f7	eb 1d		 jmp	 SHORT $LN7@stringlib_@23
$LN2@stringlib_@23:

; 213  :     }
; 214  : 
; 215  :     *subobj = NULL;

  000f9	48 8b 44 24 70	 mov	 rax, QWORD PTR subobj$[rsp]
  000fe	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 216  :     *byte = (char)ival;

  00105	48 8b 44 24 78	 mov	 rax, QWORD PTR byte$[rsp]
  0010a	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ival$[rsp]
  0010f	88 08		 mov	 BYTE PTR [rax], cl

; 217  :     return 1;

  00111	b8 01 00 00 00	 mov	 eax, 1
$LN7@stringlib_@23:

; 218  : }

  00116	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011a	c3		 ret	 0
stringlib_parse_args_finds_byte ENDP
_TEXT	ENDS
PUBLIC	??_C@_05BBAJLHME@O?$HMOO?3?$AA@			; `string'
EXTRN	_PyEval_SliceIndex:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	strlen:PROC
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_parse_args_finds DD imagerel stringlib_parse_args_finds
	DD	imagerel stringlib_parse_args_finds+389
	DD	imagerel $unwind$stringlib_parse_args_finds
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_parse_args_finds DD 041d01H
	DD	015011dH
	DD	060157016H
xdata	ENDS
;	COMDAT ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
CONST	SEGMENT
??_C@_05BBAJLHME@O?$HMOO?3?$AA@ DB 'O|OO:', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_parse_args_finds
_TEXT	SEGMENT
len$ = 48
obj_end$ = 56
tmp_end$ = 64
tmp_subobj$ = 72
format$ = 80
obj_start$ = 136
tmp_start$ = 144
function_name$ = 192
args$ = 200
subobj$ = 208
start$ = 216
end$ = 224
stringlib_parse_args_finds PROC				; COMDAT

; 108  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 109  :     PyObject *tmp_subobj;
; 110  :     Py_ssize_t tmp_start = 0;

  0001d	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tmp_start$[rsp], 0

; 111  :     Py_ssize_t tmp_end = PY_SSIZE_T_MAX;

  00029	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00033	48 89 44 24 40	 mov	 QWORD PTR tmp_end$[rsp], rax

; 112  :     PyObject *obj_start=Py_None, *obj_end=Py_None;

  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0003f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR obj_start$[rsp], rax
  00047	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0004e	48 89 44 24 38	 mov	 QWORD PTR obj_end$[rsp], rax

; 113  :     char format[FORMAT_BUFFER_SIZE] = "O|OO:";

  00053	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp]
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  0005f	48 8b f8	 mov	 rdi, rax
  00062	48 8b f1	 mov	 rsi, rcx
  00065	b9 06 00 00 00	 mov	 ecx, 6
  0006a	f3 a4		 rep movsb
  0006c	48 8d 44 24 56	 lea	 rax, QWORD PTR format$[rsp+6]
  00071	48 8b f8	 mov	 rdi, rax
  00074	33 c0		 xor	 eax, eax
  00076	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0007b	f3 aa		 rep stosb

; 114  :     size_t len = strlen(format);

  0007d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR format$[rsp]
  00082	e8 00 00 00 00	 call	 strlen
  00087	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 115  : 
; 116  :     strncpy(format + len, function_name, FORMAT_BUFFER_SIZE - len - 1);

  0008c	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  00091	48 2b 44 24 30	 sub	 rax, QWORD PTR len$[rsp]
  00096	48 ff c8	 dec	 rax
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR len$[rsp]
  0009e	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR format$[rsp+rcx]
  000a3	4c 8b c0	 mov	 r8, rax
  000a6	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR function_name$[rsp]
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 117  :     format[FORMAT_BUFFER_SIZE - 1] = '\0';

  000b4	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR format$[rsp+49], 0

; 118  : 
; 119  :     if (!PyArg_ParseTuple(args, format, &tmp_subobj, &obj_start, &obj_end))

  000bc	48 8d 44 24 38	 lea	 rax, QWORD PTR obj_end$[rsp]
  000c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c6	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR obj_start$[rsp]
  000ce	4c 8d 44 24 48	 lea	 r8, QWORD PTR tmp_subobj$[rsp]
  000d3	48 8d 54 24 50	 lea	 rdx, QWORD PTR format$[rsp]
  000d8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000e0	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000e5	85 c0		 test	 eax, eax
  000e7	75 07		 jne	 SHORT $LN5@stringlib_@24

; 120  :         return 0;

  000e9	33 c0		 xor	 eax, eax
  000eb	e9 8b 00 00 00	 jmp	 $LN6@stringlib_@24
$LN5@stringlib_@24:

; 121  : 
; 122  :     /* To support None in "start" and "end" arguments, meaning
; 123  :        the same as if they were not passed.
; 124  :     */
; 125  :     if (obj_start != Py_None)

  000f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000f7	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR obj_start$[rsp], rax
  000ff	74 1d		 je	 SHORT $LN4@stringlib_@24

; 126  :         if (!_PyEval_SliceIndex(obj_start, &tmp_start))

  00101	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR tmp_start$[rsp]
  00109	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR obj_start$[rsp]
  00111	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  00116	85 c0		 test	 eax, eax
  00118	75 04		 jne	 SHORT $LN3@stringlib_@24

; 127  :             return 0;

  0011a	33 c0		 xor	 eax, eax
  0011c	eb 5d		 jmp	 SHORT $LN6@stringlib_@24
$LN3@stringlib_@24:
$LN4@stringlib_@24:

; 128  :     if (obj_end != Py_None)

  0011e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00125	48 39 44 24 38	 cmp	 QWORD PTR obj_end$[rsp], rax
  0012a	74 17		 je	 SHORT $LN2@stringlib_@24

; 129  :         if (!_PyEval_SliceIndex(obj_end, &tmp_end))

  0012c	48 8d 54 24 40	 lea	 rdx, QWORD PTR tmp_end$[rsp]
  00131	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obj_end$[rsp]
  00136	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  0013b	85 c0		 test	 eax, eax
  0013d	75 04		 jne	 SHORT $LN1@stringlib_@24

; 130  :             return 0;

  0013f	33 c0		 xor	 eax, eax
  00141	eb 38		 jmp	 SHORT $LN6@stringlib_@24
$LN1@stringlib_@24:
$LN2@stringlib_@24:

; 131  : 
; 132  :     *start = tmp_start;

  00143	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR start$[rsp]
  0014b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tmp_start$[rsp]
  00153	48 89 08	 mov	 QWORD PTR [rax], rcx

; 133  :     *end = tmp_end;

  00156	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR end$[rsp]
  0015e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tmp_end$[rsp]
  00163	48 89 08	 mov	 QWORD PTR [rax], rcx

; 134  :     *subobj = tmp_subobj;

  00166	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR subobj$[rsp]
  0016e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tmp_subobj$[rsp]
  00173	48 89 08	 mov	 QWORD PTR [rax], rcx

; 135  :     return 1;

  00176	b8 01 00 00 00	 mov	 eax, 1
$LN6@stringlib_@24:

; 136  : }

  0017b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00182	5f		 pop	 rdi
  00183	5e		 pop	 rsi
  00184	c3		 ret	 0
stringlib_parse_args_finds ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytearrayobject.c
pdata	SEGMENT
$pdata$bytearray_count DD imagerel bytearray_count
	DD	imagerel bytearray_count+988
	DD	imagerel $unwind$bytearray_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_count DD 021101H
	DD	01b0111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_count
_TEXT	SEGMENT
sub_obj$ = 48
vsub$ = 64
count_obj$ = 144
end$ = 152
start$ = 160
sub_len$ = 168
sub$ = 176
byte$ = 184
str$ = 192
tv78 = 200
self$ = 224
args$ = 232
bytearray_count PROC					; COMDAT

; 1145 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1146 :     PyObject *sub_obj;
; 1147 :     const char *str = PyByteArray_AS_STRING(self), *sub;

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00018	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00020	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00024	74 38		 je	 SHORT $LN14@bytearray_@17
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0002d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00035	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	75 1c		 jne	 SHORT $LN14@bytearray_@17
  00042	41 b8 7b 04 00
	00		 mov	 r8d, 1147		; 0000047bH
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005c	33 c0		 xor	 eax, eax
$LN14@bytearray_@17:
  0005e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00066	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0006b	74 19		 je	 SHORT $LN15@bytearray_@17
  0006d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00075	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0007c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv78[rsp], rax
  00084	eb 0f		 jmp	 SHORT $LN16@bytearray_@17
$LN15@bytearray_@17:
  00086	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0008d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv78[rsp], rax
$LN16@bytearray_@17:
  00095	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv78[rsp]
  0009d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR str$[rsp], rax

; 1148 :     Py_ssize_t sub_len;
; 1149 :     char byte;
; 1150 :     Py_ssize_t start = 0, end = PY_SSIZE_T_MAX;

  000a5	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR start$[rsp], 0
  000b1	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000bb	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR end$[rsp], rax

; 1151 : 
; 1152 :     Py_buffer vsub;
; 1153 :     PyObject *count_obj;
; 1154 : 
; 1155 :     if (!stringlib_parse_args_finds_byte("count", args, &sub_obj, &byte,
; 1156 :                                          &start, &end))

  000c3	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR end$[rsp]
  000cb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d0	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR start$[rsp]
  000d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dd	4c 8d 8c 24 b8
	00 00 00	 lea	 r9, QWORD PTR byte$[rsp]
  000e5	4c 8d 44 24 30	 lea	 r8, QWORD PTR sub_obj$[rsp]
  000ea	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR args$[rsp]
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
  000f9	e8 00 00 00 00	 call	 stringlib_parse_args_finds_byte
  000fe	85 c0		 test	 eax, eax
  00100	75 07		 jne	 SHORT $LN11@bytearray_@17

; 1157 :         return NULL;

  00102	33 c0		 xor	 eax, eax
  00104	e9 cb 02 00 00	 jmp	 $LN12@bytearray_@17
$LN11@bytearray_@17:

; 1158 : 
; 1159 :     if (sub_obj) {

  00109	48 83 7c 24 30
	00		 cmp	 QWORD PTR sub_obj$[rsp], 0
  0010f	74 37		 je	 SHORT $LN10@bytearray_@17

; 1160 :         if (_getbuffer(sub_obj, &vsub) < 0)

  00111	48 8d 54 24 40	 lea	 rdx, QWORD PTR vsub$[rsp]
  00116	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sub_obj$[rsp]
  0011b	e8 00 00 00 00	 call	 _getbuffer
  00120	48 85 c0	 test	 rax, rax
  00123	7d 07		 jge	 SHORT $LN9@bytearray_@17

; 1161 :             return NULL;

  00125	33 c0		 xor	 eax, eax
  00127	e9 a8 02 00 00	 jmp	 $LN12@bytearray_@17
$LN9@bytearray_@17:

; 1162 : 
; 1163 :         sub = vsub.buf;

  0012c	48 8b 44 24 40	 mov	 rax, QWORD PTR vsub$[rsp]
  00131	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR sub$[rsp], rax

; 1164 :         sub_len = vsub.len;

  00139	48 8b 44 24 50	 mov	 rax, QWORD PTR vsub$[rsp+16]
  0013e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR sub_len$[rsp], rax

; 1165 :     }
; 1166 :     else {

  00146	eb 1c		 jmp	 SHORT $LN8@bytearray_@17
$LN10@bytearray_@17:

; 1167 :         sub = &byte;

  00148	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR byte$[rsp]
  00150	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR sub$[rsp], rax

; 1168 :         sub_len = 1;

  00158	48 c7 84 24 a8
	00 00 00 01 00
	00 00		 mov	 QWORD PTR sub_len$[rsp], 1
$LN8@bytearray_@17:

; 1169 :     }
; 1170 : 
; 1171 :     ADJUST_INDICES(start, end, PyByteArray_GET_SIZE(self));

  00164	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0016b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00173	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00177	74 38		 je	 SHORT $LN17@bytearray_@17
  00179	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00180	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00188	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0018c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00191	85 c0		 test	 eax, eax
  00193	75 1c		 jne	 SHORT $LN17@bytearray_@17
  00195	41 b8 93 04 00
	00		 mov	 r8d, 1171		; 00000493H
  0019b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001af	33 c0		 xor	 eax, eax
$LN17@bytearray_@17:
  001b1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001b9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001bd	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR end$[rsp], rax
  001c5	7e 66		 jle	 SHORT $LN7@bytearray_@17
  001c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001ce	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001d6	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001da	74 38		 je	 SHORT $LN18@bytearray_@17
  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001e3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001eb	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001ef	e8 00 00 00 00	 call	 PyType_IsSubtype
  001f4	85 c0		 test	 eax, eax
  001f6	75 1c		 jne	 SHORT $LN18@bytearray_@17
  001f8	41 b8 93 04 00
	00		 mov	 r8d, 1171		; 00000493H
  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00205	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00212	33 c0		 xor	 eax, eax
$LN18@bytearray_@17:
  00214	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0021c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00220	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR end$[rsp], rax
  00228	e9 95 00 00 00	 jmp	 $LN6@bytearray_@17
$LN7@bytearray_@17:
  0022d	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR end$[rsp], 0
  00236	0f 8d 86 00 00
	00		 jge	 $LN5@bytearray_@17
  0023c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00243	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0024b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0024f	74 38		 je	 SHORT $LN19@bytearray_@17
  00251	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00258	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00260	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00264	e8 00 00 00 00	 call	 PyType_IsSubtype
  00269	85 c0		 test	 eax, eax
  0026b	75 1c		 jne	 SHORT $LN19@bytearray_@17
  0026d	41 b8 93 04 00
	00		 mov	 r8d, 1171		; 00000493H
  00273	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0027a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00287	33 c0		 xor	 eax, eax
$LN19@bytearray_@17:
  00289	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00291	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00295	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  0029d	48 03 c8	 add	 rcx, rax
  002a0	48 8b c1	 mov	 rax, rcx
  002a3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR end$[rsp], rax
  002ab	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR end$[rsp], 0
  002b4	7d 0c		 jge	 SHORT $LN4@bytearray_@17
  002b6	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR end$[rsp], 0
$LN4@bytearray_@17:
$LN5@bytearray_@17:
$LN6@bytearray_@17:
  002c2	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR start$[rsp], 0
  002cb	0f 8d 86 00 00
	00		 jge	 $LN3@bytearray_@17
  002d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  002d8	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002e0	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  002e4	74 38		 je	 SHORT $LN20@bytearray_@17
  002e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  002ed	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002f5	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  002f9	e8 00 00 00 00	 call	 PyType_IsSubtype
  002fe	85 c0		 test	 eax, eax
  00300	75 1c		 jne	 SHORT $LN20@bytearray_@17
  00302	41 b8 93 04 00
	00		 mov	 r8d, 1171		; 00000493H
  00308	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0030f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00316	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0031c	33 c0		 xor	 eax, eax
$LN20@bytearray_@17:
  0031e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00326	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0032a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR start$[rsp]
  00332	48 03 c8	 add	 rcx, rax
  00335	48 8b c1	 mov	 rax, rcx
  00338	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR start$[rsp], rax
  00340	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR start$[rsp], 0
  00349	7d 0c		 jge	 SHORT $LN2@bytearray_@17
  0034b	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR start$[rsp], 0
$LN2@bytearray_@17:
$LN3@bytearray_@17:

; 1172 : 
; 1173 :     count_obj = PyLong_FromSsize_t(
; 1174 :         stringlib_count(str + start, end - start, sub, sub_len, PY_SSIZE_T_MAX)
; 1175 :         );

  00357	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR start$[rsp]
  0035f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  00367	48 2b c8	 sub	 rcx, rax
  0036a	48 8b c1	 mov	 rax, rcx
  0036d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR start$[rsp]
  00375	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  0037d	48 03 d1	 add	 rdx, rcx
  00380	48 8b ca	 mov	 rcx, rdx
  00383	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  0038d	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00392	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR sub_len$[rsp]
  0039a	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR sub$[rsp]
  003a2	48 8b d0	 mov	 rdx, rax
  003a5	e8 00 00 00 00	 call	 stringlib_count
  003aa	48 8b c8	 mov	 rcx, rax
  003ad	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  003b2	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR count_obj$[rsp], rax

; 1176 : 
; 1177 :     if (sub_obj)

  003ba	48 83 7c 24 30
	00		 cmp	 QWORD PTR sub_obj$[rsp], 0
  003c0	74 0a		 je	 SHORT $LN1@bytearray_@17

; 1178 :         PyBuffer_Release(&vsub);

  003c2	48 8d 4c 24 40	 lea	 rcx, QWORD PTR vsub$[rsp]
  003c7	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@17:

; 1179 : 
; 1180 :     return count_obj;

  003cc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR count_obj$[rsp]
$LN12@bytearray_@17:

; 1181 : }

  003d4	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  003db	c3		 ret	 0
bytearray_count ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\count.h
pdata	SEGMENT
$pdata$stringlib_count DD imagerel stringlib_count
	DD	imagerel stringlib_count+158
	DD	imagerel $unwind$stringlib_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_count DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_count
_TEXT	SEGMENT
count$ = 48
tv68 = 56
str$ = 80
str_len$ = 88
sub$ = 96
sub_len$ = 104
maxcount$ = 112
stringlib_count PROC					; COMDAT

; 11   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 12   :     Py_ssize_t count;
; 13   : 
; 14   :     if (str_len < 0)

  00018	48 83 7c 24 58
	00		 cmp	 QWORD PTR str_len$[rsp], 0
  0001e	7d 04		 jge	 SHORT $LN3@stringlib_@25

; 15   :         return 0; /* start > len(str) */

  00020	33 c0		 xor	 eax, eax
  00022	eb 75		 jmp	 SHORT $LN4@stringlib_@25
$LN3@stringlib_@25:

; 16   :     if (sub_len == 0)

  00024	48 83 7c 24 68
	00		 cmp	 QWORD PTR sub_len$[rsp], 0
  0002a	75 2c		 jne	 SHORT $LN2@stringlib_@25

; 17   :         return (str_len < maxcount) ? str_len + 1 : maxcount;

  0002c	48 8b 44 24 70	 mov	 rax, QWORD PTR maxcount$[rsp]
  00031	48 39 44 24 58	 cmp	 QWORD PTR str_len$[rsp], rax
  00036	7d 0f		 jge	 SHORT $LN6@stringlib_@25
  00038	48 8b 44 24 58	 mov	 rax, QWORD PTR str_len$[rsp]
  0003d	48 ff c0	 inc	 rax
  00040	48 89 44 24 38	 mov	 QWORD PTR tv68[rsp], rax
  00045	eb 0a		 jmp	 SHORT $LN7@stringlib_@25
$LN6@stringlib_@25:
  00047	48 8b 44 24 70	 mov	 rax, QWORD PTR maxcount$[rsp]
  0004c	48 89 44 24 38	 mov	 QWORD PTR tv68[rsp], rax
$LN7@stringlib_@25:
  00051	48 8b 44 24 38	 mov	 rax, QWORD PTR tv68[rsp]
  00056	eb 41		 jmp	 SHORT $LN4@stringlib_@25
$LN2@stringlib_@25:

; 18   : 
; 19   :     count = FASTSEARCH(str, str_len, sub, sub_len, maxcount, FAST_COUNT);

  00058	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00060	48 8b 44 24 70	 mov	 rax, QWORD PTR maxcount$[rsp]
  00065	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006a	4c 8b 4c 24 68	 mov	 r9, QWORD PTR sub_len$[rsp]
  0006f	4c 8b 44 24 60	 mov	 r8, QWORD PTR sub$[rsp]
  00074	48 8b 54 24 58	 mov	 rdx, QWORD PTR str_len$[rsp]
  00079	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  0007e	e8 00 00 00 00	 call	 fastsearch
  00083	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax

; 20   : 
; 21   :     if (count < 0)

  00088	48 83 7c 24 30
	00		 cmp	 QWORD PTR count$[rsp], 0
  0008e	7d 04		 jge	 SHORT $LN1@stringlib_@25

; 22   :         return 0; /* no match */

  00090	33 c0		 xor	 eax, eax
  00092	eb 05		 jmp	 SHORT $LN4@stringlib_@25
$LN1@stringlib_@25:

; 23   : 
; 24   :     return count;

  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
$LN4@stringlib_@25:

; 25   : }

  00099	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009d	c3		 ret	 0
stringlib_count ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytearrayobject.c
pdata	SEGMENT
$pdata$bytearray_clear DD imagerel bytearray_clear
	DD	imagerel bytearray_clear+53
	DD	imagerel $unwind$bytearray_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_clear DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_clear
_TEXT	SEGMENT
self$ = 48
bytearray_clear PROC					; COMDAT

; 1190 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1191 :     if (PyByteArray_Resize((PyObject *)self, 0) < 0)

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00010	e8 00 00 00 00	 call	 PyByteArray_Resize
  00015	85 c0		 test	 eax, eax
  00017	7d 04		 jge	 SHORT $LN1@bytearray_@18

; 1192 :         return NULL;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 13		 jmp	 SHORT $LN2@bytearray_@18
$LN1@bytearray_@18:

; 1193 :     Py_RETURN_NONE;

  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00024	e8 00 00 00 00	 call	 _Py_IncRef
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@bytearray_@18:

; 1194 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
bytearray_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EI@NKIFLFND@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AAs?$AAe@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_copy DD imagerel bytearray_copy
	DD	imagerel bytearray_copy+218
	DD	imagerel $unwind$bytearray_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_copy DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1EI@NKIFLFND@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AAs?$AAe@
CONST	SEGMENT
??_C@_1EI@NKIFLFND@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AAs?$AAe@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, '(', 00H, 'P', 00H
	DB	'y', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, ' ', 00H, '*', 00H, ')', 00H, 's', 00H, 'e', 00H, 'l', 00H
	DB	'f', 00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_copy
_TEXT	SEGMENT
tv92 = 32
self$ = 64
bytearray_copy PROC					; COMDAT

; 1203 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1204 :     return PyByteArray_FromStringAndSize(PyByteArray_AS_STRING((PyObject *)self),
; 1205 :                                          PyByteArray_GET_SIZE(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN3@bytearray_@19
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN3@bytearray_@19
  00034	41 b8 b5 04 00
	00		 mov	 r8d, 1205		; 000004b5H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN3@bytearray_@19:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00060	74 35		 je	 SHORT $LN4@bytearray_@19
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00072	e8 00 00 00 00	 call	 PyType_IsSubtype
  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN4@bytearray_@19
  0007b	41 b8 b4 04 00
	00		 mov	 r8d, 1204		; 000004b4H
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@NKIFLFND@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AAs?$AAe@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00095	33 c0		 xor	 eax, eax
$LN4@bytearray_@19:
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a1	74 13		 je	 SHORT $LN5@bytearray_@19
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000af	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
  000b4	eb 0c		 jmp	 SHORT $LN6@bytearray_@19
$LN5@bytearray_@19:
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000bd	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
$LN6@bytearray_@19:
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv92[rsp]
  000d0	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 1206 : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
bytearray_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@BDAGCGNF@subsection?5not?5found?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_index DD imagerel bytearray_index
	DD	imagerel bytearray_index+98
	DD	imagerel $unwind$bytearray_index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_index DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BF@BDAGCGNF@subsection?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BF@BDAGCGNF@subsection?5not?5found?$AA@ DB 'subsection not found', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_index
_TEXT	SEGMENT
result$ = 32
self$ = 64
args$ = 72
bytearray_index PROC					; COMDAT

; 1215 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1216 :     Py_ssize_t result = bytearray_find_internal(self, args, +1);

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	e8 00 00 00 00	 call	 bytearray_find_internal
  00023	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1217 :     if (result == -2)

  00028	48 83 7c 24 20
	fe		 cmp	 QWORD PTR result$[rsp], -2
  0002e	75 04		 jne	 SHORT $LN2@bytearray_@20

; 1218 :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 29		 jmp	 SHORT $LN3@bytearray_@20
$LN2@bytearray_@20:

; 1219 :     if (result == -1) {

  00034	48 83 7c 24 20
	ff		 cmp	 QWORD PTR result$[rsp], -1
  0003a	75 17		 jne	 SHORT $LN1@bytearray_@20

; 1220 :         PyErr_SetString(PyExc_ValueError,
; 1221 :                         "subsection not found");

  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@BDAGCGNF@subsection?5not?5found?$AA@
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0004a	e8 00 00 00 00	 call	 PyErr_SetString

; 1222 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	eb 0a		 jmp	 SHORT $LN3@bytearray_@20
$LN1@bytearray_@20:

; 1223 :     }
; 1224 :     return PyLong_FromSsize_t(result);

  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00058	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN3@bytearray_@20:

; 1225 : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
bytearray_index ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_rfind DD imagerel bytearray_rfind
	DD	imagerel bytearray_rfind+67
	DD	imagerel $unwind$bytearray_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_rfind DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_rfind
_TEXT	SEGMENT
result$ = 32
self$ = 64
args$ = 72
bytearray_rfind PROC					; COMDAT

; 1239 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1240 :     Py_ssize_t result = bytearray_find_internal(self, args, -1);

  0000e	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	e8 00 00 00 00	 call	 bytearray_find_internal
  00023	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1241 :     if (result == -2)

  00028	48 83 7c 24 20
	fe		 cmp	 QWORD PTR result$[rsp], -2
  0002e	75 04		 jne	 SHORT $LN1@bytearray_@21

; 1242 :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 0a		 jmp	 SHORT $LN2@bytearray_@21
$LN1@bytearray_@21:

; 1243 :     return PyLong_FromSsize_t(result);

  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00039	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN2@bytearray_@21:

; 1244 : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
bytearray_rfind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_rindex DD imagerel bytearray_rindex
	DD	imagerel bytearray_rindex+98
	DD	imagerel $unwind$bytearray_rindex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_rindex DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_rindex
_TEXT	SEGMENT
result$ = 32
self$ = 64
args$ = 72
bytearray_rindex PROC					; COMDAT

; 1254 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1255 :     Py_ssize_t result = bytearray_find_internal(self, args, -1);

  0000e	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	e8 00 00 00 00	 call	 bytearray_find_internal
  00023	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1256 :     if (result == -2)

  00028	48 83 7c 24 20
	fe		 cmp	 QWORD PTR result$[rsp], -2
  0002e	75 04		 jne	 SHORT $LN2@bytearray_@22

; 1257 :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 29		 jmp	 SHORT $LN3@bytearray_@22
$LN2@bytearray_@22:

; 1258 :     if (result == -1) {

  00034	48 83 7c 24 20
	ff		 cmp	 QWORD PTR result$[rsp], -1
  0003a	75 17		 jne	 SHORT $LN1@bytearray_@22

; 1259 :         PyErr_SetString(PyExc_ValueError,
; 1260 :                         "subsection not found");

  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@BDAGCGNF@subsection?5not?5found?$AA@
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0004a	e8 00 00 00 00	 call	 PyErr_SetString

; 1261 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	eb 0a		 jmp	 SHORT $LN3@bytearray_@22
$LN1@bytearray_@22:

; 1262 :     }
; 1263 :     return PyLong_FromSsize_t(result);

  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00058	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN3@bytearray_@22:

; 1264 : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
bytearray_rindex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_contains DD imagerel bytearray_contains
	DD	imagerel bytearray_contains+595
	DD	imagerel $unwind$bytearray_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_contains DD 021101H
	DD	0170111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_contains
_TEXT	SEGMENT
ival$ = 48
pos$22623 = 56
varg$22622 = 64
tv94 = 144
tv130 = 152
tv153 = 160
tv156 = 168
self$ = 192
arg$ = 200
bytearray_contains PROC					; COMDAT

; 1269 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1270 :     Py_ssize_t ival = PyNumber_AsSsize_t(arg, PyExc_ValueError);

  00011	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_ValueError
  00018	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00020	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00025	48 89 44 24 30	 mov	 QWORD PTR ival$[rsp], rax

; 1271 :     if (ival == -1 && PyErr_Occurred()) {

  0002a	48 83 7c 24 30
	ff		 cmp	 QWORD PTR ival$[rsp], -1
  00030	0f 85 1f 01 00
	00		 jne	 $LN4@bytearray_@23
  00036	e8 00 00 00 00	 call	 PyErr_Occurred
  0003b	48 85 c0	 test	 rax, rax
  0003e	0f 84 11 01 00
	00		 je	 $LN4@bytearray_@23

; 1272 :         Py_buffer varg;
; 1273 :         Py_ssize_t pos;
; 1274 :         PyErr_Clear();

  00044	e8 00 00 00 00	 call	 PyErr_Clear

; 1275 :         if (_getbuffer(arg, &varg) < 0)

  00049	48 8d 54 24 40	 lea	 rdx, QWORD PTR varg$22622[rsp]
  0004e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00056	e8 00 00 00 00	 call	 _getbuffer
  0005b	48 85 c0	 test	 rax, rax
  0005e	7d 0a		 jge	 SHORT $LN3@bytearray_@23

; 1276 :             return -1;

  00060	b8 ff ff ff ff	 mov	 eax, -1
  00065	e9 e1 01 00 00	 jmp	 $LN5@bytearray_@23
$LN3@bytearray_@23:

; 1277 :         pos = stringlib_find(PyByteArray_AS_STRING(self), Py_SIZE(self),
; 1278 :                              varg.buf, varg.len, 0);

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00071	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00079	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0007d	74 38		 je	 SHORT $LN7@bytearray_@23
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00086	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0008e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00092	e8 00 00 00 00	 call	 PyType_IsSubtype
  00097	85 c0		 test	 eax, eax
  00099	75 1c		 jne	 SHORT $LN7@bytearray_@23
  0009b	41 b8 fd 04 00
	00		 mov	 r8d, 1277		; 000004fdH
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b5	33 c0		 xor	 eax, eax
$LN7@bytearray_@23:
  000b7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000bf	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000c4	74 19		 je	 SHORT $LN8@bytearray_@23
  000c6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000ce	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000d5	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv94[rsp], rax
  000dd	eb 0f		 jmp	 SHORT $LN9@bytearray_@23
$LN8@bytearray_@23:
  000df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000e6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv94[rsp], rax
$LN9@bytearray_@23:
  000ee	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000f7	4c 8b 4c 24 50	 mov	 r9, QWORD PTR varg$22622[rsp+16]
  000fc	4c 8b 44 24 40	 mov	 r8, QWORD PTR varg$22622[rsp]
  00101	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00109	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0010d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv94[rsp]
  00115	e8 00 00 00 00	 call	 stringlib_find
  0011a	48 89 44 24 38	 mov	 QWORD PTR pos$22623[rsp], rax

; 1279 :         PyBuffer_Release(&varg);

  0011f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR varg$22622[rsp]
  00124	e8 00 00 00 00	 call	 PyBuffer_Release

; 1280 :         return pos >= 0;

  00129	48 83 7c 24 38
	00		 cmp	 QWORD PTR pos$22623[rsp], 0
  0012f	7c 0d		 jl	 SHORT $LN10@bytearray_@23
  00131	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv130[rsp], 1
  0013c	eb 0b		 jmp	 SHORT $LN11@bytearray_@23
$LN10@bytearray_@23:
  0013e	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv130[rsp], 0
$LN11@bytearray_@23:
  00149	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv130[rsp]
  00150	e9 f6 00 00 00	 jmp	 $LN5@bytearray_@23
$LN4@bytearray_@23:

; 1281 :     }
; 1282 :     if (ival < 0 || ival >= 256) {

  00155	48 83 7c 24 30
	00		 cmp	 QWORD PTR ival$[rsp], 0
  0015b	7c 0b		 jl	 SHORT $LN1@bytearray_@23
  0015d	48 81 7c 24 30
	00 01 00 00	 cmp	 QWORD PTR ival$[rsp], 256 ; 00000100H
  00166	7c 1d		 jl	 SHORT $LN2@bytearray_@23
$LN1@bytearray_@23:

; 1283 :         PyErr_SetString(PyExc_ValueError, "byte must be in range(0, 256)");

  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  0016f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00176	e8 00 00 00 00	 call	 PyErr_SetString

; 1284 :         return -1;

  0017b	b8 ff ff ff ff	 mov	 eax, -1
  00180	e9 c6 00 00 00	 jmp	 $LN5@bytearray_@23
$LN2@bytearray_@23:

; 1285 :     }
; 1286 : 
; 1287 :     return memchr(PyByteArray_AS_STRING(self), (int) ival, Py_SIZE(self)) != NULL;

  00185	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0018c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00194	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00198	74 38		 je	 SHORT $LN12@bytearray_@23
  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001a1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001a9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001ad	e8 00 00 00 00	 call	 PyType_IsSubtype
  001b2	85 c0		 test	 eax, eax
  001b4	75 1c		 jne	 SHORT $LN12@bytearray_@23
  001b6	41 b8 07 05 00
	00		 mov	 r8d, 1287		; 00000507H
  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  001ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d0	33 c0		 xor	 eax, eax
$LN12@bytearray_@23:
  001d2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001da	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001df	74 19		 je	 SHORT $LN13@bytearray_@23
  001e1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001e9	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  001f0	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv153[rsp], rax
  001f8	eb 0f		 jmp	 SHORT $LN14@bytearray_@23
$LN13@bytearray_@23:
  001fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00201	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv153[rsp], rax
$LN14@bytearray_@23:
  00209	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00211	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00215	8b 54 24 30	 mov	 edx, DWORD PTR ival$[rsp]
  00219	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv153[rsp]
  00221	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00227	48 85 c0	 test	 rax, rax
  0022a	74 0d		 je	 SHORT $LN15@bytearray_@23
  0022c	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv156[rsp], 1
  00237	eb 0b		 jmp	 SHORT $LN16@bytearray_@23
$LN15@bytearray_@23:
  00239	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv156[rsp], 0
$LN16@bytearray_@23:
  00244	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv156[rsp]
$LN5@bytearray_@23:

; 1288 : }

  0024b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00252	c3		 ret	 0
bytearray_contains ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@ ; `string'
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_startswith DD imagerel bytearray_startswith
	DD	imagerel bytearray_startswith+383
	DD	imagerel $unwind$bytearray_startswith
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_startswith DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@
CONST	SEGMENT
??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@ DB 'startswith '
	DB	'first arg must be bytes or a tuple of bytes, not %s', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_startswith
_TEXT	SEGMENT
end$ = 48
start$ = 56
result$ = 64
subobj$ = 72
i$22699 = 80
self$ = 112
args$ = 120
bytearray_startswith PROC				; COMDAT

; 1344 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1345 :     Py_ssize_t start = 0;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0

; 1346 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  00017	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00021	48 89 44 24 30	 mov	 QWORD PTR end$[rsp], rax

; 1347 :     PyObject *subobj;
; 1348 :     int result;
; 1349 : 
; 1350 :     if (!stringlib_parse_args_finds("startswith", args, &subobj, &start, &end))

  00026	48 8d 44 24 30	 lea	 rax, QWORD PTR end$[rsp]
  0002b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00030	4c 8d 4c 24 38	 lea	 r9, QWORD PTR start$[rsp]
  00035	4c 8d 44 24 48	 lea	 r8, QWORD PTR subobj$[rsp]
  0003a	48 8b 54 24 78	 mov	 rdx, QWORD PTR args$[rsp]
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@MPOGHCCL@startswith?$AA@
  00046	e8 00 00 00 00	 call	 stringlib_parse_args_finds
  0004b	85 c0		 test	 eax, eax
  0004d	75 07		 jne	 SHORT $LN11@bytearray_@24

; 1351 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 24 01 00 00	 jmp	 $LN12@bytearray_@24
$LN11@bytearray_@24:

; 1352 :     if (PyTuple_Check(subobj)) {

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  0005b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00065	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 9d 00 00
	00		 je	 $LN10@bytearray_@24

; 1353 :         Py_ssize_t i;
; 1354 :         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  00072	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$22699[rsp], 0
  0007b	eb 0d		 jmp	 SHORT $LN9@bytearray_@24
$LN8@bytearray_@24:
  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR i$22699[rsp]
  00082	48 ff c0	 inc	 rax
  00085	48 89 44 24 50	 mov	 QWORD PTR i$22699[rsp], rax
$LN9@bytearray_@24:
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  0008f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00093	48 39 44 24 50	 cmp	 QWORD PTR i$22699[rsp], rax
  00098	7d 60		 jge	 SHORT $LN7@bytearray_@24

; 1355 :             result = _bytearray_tailmatch(self,
; 1356 :                                       PyTuple_GET_ITEM(subobj, i),
; 1357 :                                       start, end, -1);

  0009a	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  000a2	4c 8b 4c 24 30	 mov	 r9, QWORD PTR end$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR start$[rsp]
  000ac	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$22699[rsp]
  000b6	48 8b 54 c8 70	 mov	 rdx, QWORD PTR [rax+rcx*8+112]
  000bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000c0	e8 00 00 00 00	 call	 _bytearray_tailmatch
  000c5	89 44 24 40	 mov	 DWORD PTR result$[rsp], eax

; 1358 :             if (result == -1)

  000c9	83 7c 24 40 ff	 cmp	 DWORD PTR result$[rsp], -1
  000ce	75 09		 jne	 SHORT $LN6@bytearray_@24

; 1359 :                 return NULL;

  000d0	33 c0		 xor	 eax, eax
  000d2	e9 a3 00 00 00	 jmp	 $LN12@bytearray_@24
  000d7	eb 1f		 jmp	 SHORT $LN5@bytearray_@24
$LN6@bytearray_@24:

; 1360 :             else if (result) {

  000d9	83 7c 24 40 00	 cmp	 DWORD PTR result$[rsp], 0
  000de	74 18		 je	 SHORT $LN4@bytearray_@24

; 1361 :                 Py_RETURN_TRUE;

  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000e7	e8 00 00 00 00	 call	 _Py_IncRef
  000ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000f3	e9 82 00 00 00	 jmp	 $LN12@bytearray_@24
$LN4@bytearray_@24:
$LN5@bytearray_@24:

; 1362 :             }
; 1363 :         }

  000f8	eb 83		 jmp	 SHORT $LN8@bytearray_@24
$LN7@bytearray_@24:

; 1364 :         Py_RETURN_FALSE;

  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00101	e8 00 00 00 00	 call	 _Py_IncRef
  00106	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0010d	eb 6b		 jmp	 SHORT $LN12@bytearray_@24
$LN10@bytearray_@24:

; 1365 :     }
; 1366 :     result = _bytearray_tailmatch(self, subobj, start, end, -1);

  0010f	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  00117	4c 8b 4c 24 30	 mov	 r9, QWORD PTR end$[rsp]
  0011c	4c 8b 44 24 38	 mov	 r8, QWORD PTR start$[rsp]
  00121	48 8b 54 24 48	 mov	 rdx, QWORD PTR subobj$[rsp]
  00126	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0012b	e8 00 00 00 00	 call	 _bytearray_tailmatch
  00130	89 44 24 40	 mov	 DWORD PTR result$[rsp], eax

; 1367 :     if (result == -1) {

  00134	83 7c 24 40 ff	 cmp	 DWORD PTR result$[rsp], -1
  00139	75 36		 jne	 SHORT $LN3@bytearray_@24

; 1368 :         if (PyErr_ExceptionMatches(PyExc_TypeError))

  0013b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00142	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00147	85 c0		 test	 eax, eax
  00149	74 20		 je	 SHORT $LN2@bytearray_@24

; 1369 :             PyErr_Format(PyExc_TypeError, "startswith first arg must be bytes "
; 1370 :                          "or a tuple of bytes, not %s", Py_TYPE(subobj)->tp_name);

  0014b	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  00150	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00154	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@
  0015f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00166	e8 00 00 00 00	 call	 PyErr_Format
$LN2@bytearray_@24:

; 1371 :         return NULL;

  0016b	33 c0		 xor	 eax, eax
  0016d	eb 0b		 jmp	 SHORT $LN12@bytearray_@24

; 1372 :     }
; 1373 :     else

  0016f	eb 09		 jmp	 SHORT $LN1@bytearray_@24
$LN3@bytearray_@24:

; 1374 :         return PyBool_FromLong(result);

  00171	8b 4c 24 40	 mov	 ecx, DWORD PTR result$[rsp]
  00175	e8 00 00 00 00	 call	 PyBool_FromLong
$LN1@bytearray_@24:
$LN12@bytearray_@24:

; 1375 : }

  0017a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017e	c3		 ret	 0
bytearray_startswith ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_bytearray_tailmatch DD imagerel _bytearray_tailmatch
	DD	imagerel _bytearray_tailmatch+740
	DD	imagerel $unwind$_bytearray_tailmatch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_bytearray_tailmatch DD 021b01H
	DD	015011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _bytearray_tailmatch
_TEXT	SEGMENT
len$ = 32
rv$ = 40
vsubstr$ = 48
str$ = 128
tv90 = 136
tv151 = 144
self$ = 176
substr$ = 184
start$ = 192
end$ = 200
direction$ = 208
_bytearray_tailmatch PROC				; COMDAT

; 1298 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1299 :     Py_ssize_t len = PyByteArray_GET_SIZE(self);

  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0002a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002e	74 38		 je	 SHORT $LN17@bytearray_@25
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00037	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00043	e8 00 00 00 00	 call	 PyType_IsSubtype
  00048	85 c0		 test	 eax, eax
  0004a	75 1c		 jne	 SHORT $LN17@bytearray_@25
  0004c	41 b8 13 05 00
	00		 mov	 r8d, 1299		; 00000513H
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00066	33 c0		 xor	 eax, eax
$LN17@bytearray_@25:
  00068	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00070	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00074	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 1300 :     const char* str;
; 1301 :     Py_buffer vsubstr;
; 1302 :     int rv = 0;

  00079	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR rv$[rsp], 0

; 1303 : 
; 1304 :     str = PyByteArray_AS_STRING(self);

  00081	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00088	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00090	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00094	74 38		 je	 SHORT $LN18@bytearray_@25
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0009d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a5	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000a9	e8 00 00 00 00	 call	 PyType_IsSubtype
  000ae	85 c0		 test	 eax, eax
  000b0	75 1c		 jne	 SHORT $LN18@bytearray_@25
  000b2	41 b8 18 05 00
	00		 mov	 r8d, 1304		; 00000518H
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000cc	33 c0		 xor	 eax, eax
$LN18@bytearray_@25:
  000ce	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000d6	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000db	74 19		 je	 SHORT $LN19@bytearray_@25
  000dd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000e5	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000ec	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  000f4	eb 0f		 jmp	 SHORT $LN20@bytearray_@25
$LN19@bytearray_@25:
  000f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000fd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
$LN20@bytearray_@25:
  00105	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv90[rsp]
  0010d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR str$[rsp], rax

; 1305 : 
; 1306 :     if (_getbuffer(substr, &vsubstr) < 0)

  00115	48 8d 54 24 30	 lea	 rdx, QWORD PTR vsubstr$[rsp]
  0011a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR substr$[rsp]
  00122	e8 00 00 00 00	 call	 _getbuffer
  00127	48 85 c0	 test	 rax, rax
  0012a	7d 0a		 jge	 SHORT $LN14@bytearray_@25

; 1307 :         return -1;

  0012c	b8 ff ff ff ff	 mov	 eax, -1
  00131	e9 a6 01 00 00	 jmp	 $LN15@bytearray_@25
$LN14@bytearray_@25:

; 1308 : 
; 1309 :     ADJUST_INDICES(start, end, len);

  00136	48 8b 44 24 20	 mov	 rax, QWORD PTR len$[rsp]
  0013b	48 39 84 24 c8
	00 00 00	 cmp	 QWORD PTR end$[rsp], rax
  00143	7e 0f		 jle	 SHORT $LN13@bytearray_@25
  00145	48 8b 44 24 20	 mov	 rax, QWORD PTR len$[rsp]
  0014a	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR end$[rsp], rax
  00152	eb 3d		 jmp	 SHORT $LN12@bytearray_@25
$LN13@bytearray_@25:
  00154	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR end$[rsp], 0
  0015d	7d 32		 jge	 SHORT $LN11@bytearray_@25
  0015f	48 8b 44 24 20	 mov	 rax, QWORD PTR len$[rsp]
  00164	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  0016c	48 03 c8	 add	 rcx, rax
  0016f	48 8b c1	 mov	 rax, rcx
  00172	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR end$[rsp], rax
  0017a	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR end$[rsp], 0
  00183	7d 0c		 jge	 SHORT $LN10@bytearray_@25
  00185	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR end$[rsp], 0
$LN10@bytearray_@25:
$LN11@bytearray_@25:
$LN12@bytearray_@25:
  00191	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR start$[rsp], 0
  0019a	7d 32		 jge	 SHORT $LN9@bytearray_@25
  0019c	48 8b 44 24 20	 mov	 rax, QWORD PTR len$[rsp]
  001a1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR start$[rsp]
  001a9	48 03 c8	 add	 rcx, rax
  001ac	48 8b c1	 mov	 rax, rcx
  001af	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR start$[rsp], rax
  001b7	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR start$[rsp], 0
  001c0	7d 0c		 jge	 SHORT $LN8@bytearray_@25
  001c2	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR start$[rsp], 0
$LN8@bytearray_@25:
$LN9@bytearray_@25:

; 1310 : 
; 1311 :     if (direction < 0) {

  001ce	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR direction$[rsp], 0
  001d6	7d 21		 jge	 SHORT $LN7@bytearray_@25

; 1312 :         /* startswith */
; 1313 :         if (start+vsubstr.len > len) {

  001d8	48 8b 44 24 40	 mov	 rax, QWORD PTR vsubstr$[rsp+16]
  001dd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR start$[rsp]
  001e5	48 03 c8	 add	 rcx, rax
  001e8	48 8b c1	 mov	 rax, rcx
  001eb	48 3b 44 24 20	 cmp	 rax, QWORD PTR len$[rsp]
  001f0	7e 05		 jle	 SHORT $LN6@bytearray_@25

; 1314 :             goto done;

  001f2	e9 d7 00 00 00	 jmp	 $done$22675
$LN6@bytearray_@25:

; 1315 :         }
; 1316 :     } else {

  001f7	eb 69		 jmp	 SHORT $LN5@bytearray_@25
$LN7@bytearray_@25:

; 1317 :         /* endswith */
; 1318 :         if (end-start < vsubstr.len || start > len) {

  001f9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR start$[rsp]
  00201	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  00209	48 2b c8	 sub	 rcx, rax
  0020c	48 8b c1	 mov	 rax, rcx
  0020f	48 3b 44 24 40	 cmp	 rax, QWORD PTR vsubstr$[rsp+16]
  00214	7c 0f		 jl	 SHORT $LN3@bytearray_@25
  00216	48 8b 44 24 20	 mov	 rax, QWORD PTR len$[rsp]
  0021b	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR start$[rsp], rax
  00223	7e 05		 jle	 SHORT $LN4@bytearray_@25
$LN3@bytearray_@25:

; 1319 :             goto done;

  00225	e9 a4 00 00 00	 jmp	 $done$22675
$LN4@bytearray_@25:

; 1320 :         }
; 1321 : 
; 1322 :         if (end-vsubstr.len > start)

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR vsubstr$[rsp+16]
  0022f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  00237	48 2b c8	 sub	 rcx, rax
  0023a	48 8b c1	 mov	 rax, rcx
  0023d	48 3b 84 24 c0
	00 00 00	 cmp	 rax, QWORD PTR start$[rsp]
  00245	7e 1b		 jle	 SHORT $LN2@bytearray_@25

; 1323 :             start = end - vsubstr.len;

  00247	48 8b 44 24 40	 mov	 rax, QWORD PTR vsubstr$[rsp+16]
  0024c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  00254	48 2b c8	 sub	 rcx, rax
  00257	48 8b c1	 mov	 rax, rcx
  0025a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR start$[rsp], rax
$LN2@bytearray_@25:
$LN5@bytearray_@25:

; 1324 :     }
; 1325 :     if (end-start >= vsubstr.len)

  00262	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR start$[rsp]
  0026a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  00272	48 2b c8	 sub	 rcx, rax
  00275	48 8b c1	 mov	 rax, rcx
  00278	48 3b 44 24 40	 cmp	 rax, QWORD PTR vsubstr$[rsp+16]
  0027d	7c 4f		 jl	 SHORT $LN1@bytearray_@25

; 1326 :         rv = ! memcmp(str+start, vsubstr.buf, vsubstr.len);

  0027f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR start$[rsp]
  00287	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  0028f	48 03 c8	 add	 rcx, rax
  00292	48 8b c1	 mov	 rax, rcx
  00295	4c 8b 44 24 40	 mov	 r8, QWORD PTR vsubstr$[rsp+16]
  0029a	48 8b 54 24 30	 mov	 rdx, QWORD PTR vsubstr$[rsp]
  0029f	48 8b c8	 mov	 rcx, rax
  002a2	e8 00 00 00 00	 call	 memcmp
  002a7	85 c0		 test	 eax, eax
  002a9	75 0d		 jne	 SHORT $LN21@bytearray_@25
  002ab	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv151[rsp], 1
  002b6	eb 0b		 jmp	 SHORT $LN22@bytearray_@25
$LN21@bytearray_@25:
  002b8	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv151[rsp], 0
$LN22@bytearray_@25:
  002c3	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv151[rsp]
  002ca	89 44 24 28	 mov	 DWORD PTR rv$[rsp], eax
$LN1@bytearray_@25:
$done$22675:

; 1327 : 
; 1328 : done:
; 1329 :     PyBuffer_Release(&vsubstr);

  002ce	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vsubstr$[rsp]
  002d3	e8 00 00 00 00	 call	 PyBuffer_Release

; 1330 :     return rv;

  002d8	8b 44 24 28	 mov	 eax, DWORD PTR rv$[rsp]
$LN15@bytearray_@25:

; 1331 : }

  002dc	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002e3	c3		 ret	 0
_bytearray_tailmatch ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_endswith DD imagerel bytearray_endswith
	DD	imagerel bytearray_endswith+383
	DD	imagerel $unwind$bytearray_endswith
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_endswith DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@
CONST	SEGMENT
??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@ DB 'endswith fi'
	DB	'rst arg must be bytes or a tuple of bytes, not %s', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_endswith
_TEXT	SEGMENT
end$ = 48
start$ = 56
result$ = 64
subobj$ = 72
i$22739 = 80
self$ = 112
args$ = 120
bytearray_endswith PROC					; COMDAT

; 1387 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1388 :     Py_ssize_t start = 0;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0

; 1389 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  00017	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00021	48 89 44 24 30	 mov	 QWORD PTR end$[rsp], rax

; 1390 :     PyObject *subobj;
; 1391 :     int result;
; 1392 : 
; 1393 :     if (!stringlib_parse_args_finds("endswith", args, &subobj, &start, &end))

  00026	48 8d 44 24 30	 lea	 rax, QWORD PTR end$[rsp]
  0002b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00030	4c 8d 4c 24 38	 lea	 r9, QWORD PTR start$[rsp]
  00035	4c 8d 44 24 48	 lea	 r8, QWORD PTR subobj$[rsp]
  0003a	48 8b 54 24 78	 mov	 rdx, QWORD PTR args$[rsp]
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08MLCMCPNP@endswith?$AA@
  00046	e8 00 00 00 00	 call	 stringlib_parse_args_finds
  0004b	85 c0		 test	 eax, eax
  0004d	75 07		 jne	 SHORT $LN11@bytearray_@26

; 1394 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 24 01 00 00	 jmp	 $LN12@bytearray_@26
$LN11@bytearray_@26:

; 1395 :     if (PyTuple_Check(subobj)) {

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  0005b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00065	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 9d 00 00
	00		 je	 $LN10@bytearray_@26

; 1396 :         Py_ssize_t i;
; 1397 :         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  00072	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$22739[rsp], 0
  0007b	eb 0d		 jmp	 SHORT $LN9@bytearray_@26
$LN8@bytearray_@26:
  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR i$22739[rsp]
  00082	48 ff c0	 inc	 rax
  00085	48 89 44 24 50	 mov	 QWORD PTR i$22739[rsp], rax
$LN9@bytearray_@26:
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  0008f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00093	48 39 44 24 50	 cmp	 QWORD PTR i$22739[rsp], rax
  00098	7d 60		 jge	 SHORT $LN7@bytearray_@26

; 1398 :             result = _bytearray_tailmatch(self,
; 1399 :                                       PyTuple_GET_ITEM(subobj, i),
; 1400 :                                       start, end, +1);

  0009a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000a2	4c 8b 4c 24 30	 mov	 r9, QWORD PTR end$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR start$[rsp]
  000ac	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$22739[rsp]
  000b6	48 8b 54 c8 70	 mov	 rdx, QWORD PTR [rax+rcx*8+112]
  000bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000c0	e8 00 00 00 00	 call	 _bytearray_tailmatch
  000c5	89 44 24 40	 mov	 DWORD PTR result$[rsp], eax

; 1401 :             if (result == -1)

  000c9	83 7c 24 40 ff	 cmp	 DWORD PTR result$[rsp], -1
  000ce	75 09		 jne	 SHORT $LN6@bytearray_@26

; 1402 :                 return NULL;

  000d0	33 c0		 xor	 eax, eax
  000d2	e9 a3 00 00 00	 jmp	 $LN12@bytearray_@26
  000d7	eb 1f		 jmp	 SHORT $LN5@bytearray_@26
$LN6@bytearray_@26:

; 1403 :             else if (result) {

  000d9	83 7c 24 40 00	 cmp	 DWORD PTR result$[rsp], 0
  000de	74 18		 je	 SHORT $LN4@bytearray_@26

; 1404 :                 Py_RETURN_TRUE;

  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000e7	e8 00 00 00 00	 call	 _Py_IncRef
  000ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000f3	e9 82 00 00 00	 jmp	 $LN12@bytearray_@26
$LN4@bytearray_@26:
$LN5@bytearray_@26:

; 1405 :             }
; 1406 :         }

  000f8	eb 83		 jmp	 SHORT $LN8@bytearray_@26
$LN7@bytearray_@26:

; 1407 :         Py_RETURN_FALSE;

  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00101	e8 00 00 00 00	 call	 _Py_IncRef
  00106	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0010d	eb 6b		 jmp	 SHORT $LN12@bytearray_@26
$LN10@bytearray_@26:

; 1408 :     }
; 1409 :     result = _bytearray_tailmatch(self, subobj, start, end, +1);

  0010f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00117	4c 8b 4c 24 30	 mov	 r9, QWORD PTR end$[rsp]
  0011c	4c 8b 44 24 38	 mov	 r8, QWORD PTR start$[rsp]
  00121	48 8b 54 24 48	 mov	 rdx, QWORD PTR subobj$[rsp]
  00126	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0012b	e8 00 00 00 00	 call	 _bytearray_tailmatch
  00130	89 44 24 40	 mov	 DWORD PTR result$[rsp], eax

; 1410 :     if (result == -1) {

  00134	83 7c 24 40 ff	 cmp	 DWORD PTR result$[rsp], -1
  00139	75 36		 jne	 SHORT $LN3@bytearray_@26

; 1411 :         if (PyErr_ExceptionMatches(PyExc_TypeError))

  0013b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00142	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00147	85 c0		 test	 eax, eax
  00149	74 20		 je	 SHORT $LN2@bytearray_@26

; 1412 :             PyErr_Format(PyExc_TypeError, "endswith first arg must be bytes or "
; 1413 :                          "a tuple of bytes, not %s", Py_TYPE(subobj)->tp_name);

  0014b	48 8b 44 24 48	 mov	 rax, QWORD PTR subobj$[rsp]
  00150	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00154	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@
  0015f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00166	e8 00 00 00 00	 call	 PyErr_Format
$LN2@bytearray_@26:

; 1414 :         return NULL;

  0016b	33 c0		 xor	 eax, eax
  0016d	eb 0b		 jmp	 SHORT $LN12@bytearray_@26

; 1415 :     }
; 1416 :     else

  0016f	eb 09		 jmp	 SHORT $LN1@bytearray_@26
$LN3@bytearray_@26:

; 1417 :         return PyBool_FromLong(result);

  00171	8b 4c 24 40	 mov	 ecx, DWORD PTR result$[rsp]
  00175	e8 00 00 00 00	 call	 PyBool_FromLong
$LN1@bytearray_@26:
$LN12@bytearray_@26:

; 1418 : }

  0017a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017e	c3		 ret	 0
bytearray_endswith ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@LKHHMEFM@bytearray_translate?$AA@	; `string'
PUBLIC	??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@ ; `string'
PUBLIC	??_C@_1DK@GLBPACJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@ ; `string'
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_translate DD imagerel bytearray_translate
	DD	imagerel bytearray_translate+1578
	DD	imagerel $unwind$bytearray_translate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_translate DD 021101H
	DD	0a90111H
xdata	ENDS
;	COMDAT ??_C@_0BE@LKHHMEFM@bytearray_translate?$AA@
CONST	SEGMENT
??_C@_0BE@LKHHMEFM@bytearray_translate?$AA@ DB 'bytearray_translate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
CONST	SEGMENT
??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@ DB '..\Objects\'
	DB	'bytearrayobject.c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@GLBPACJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@GLBPACJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'i', 00H, 'n', 00H
	DB	'p', 00H, 'u', 00H, 't', 00H, '_', 00H, 'o', 00H, 'b', 00H, 'j'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@
CONST	SEGMENT
??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@ DB 'translation'
	DB	' table must be 256 characters long', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_translate
_TEXT	SEGMENT
vdel$ = 48
trans_table$ = 128
inlen$ = 1152
i$ = 1160
tableobj$ = 1168
vtable$ = 1184
output$ = 1264
input$ = 1272
output_start$ = 1280
table$ = 1288
delobj$ = 1296
result$ = 1304
input_obj$ = 1312
c$ = 1320
_py_tmp$22862 = 1328
tv152 = 1336
self$ = 1360
args$ = 1368
bytearray_translate PROC				; COMDAT

; 1431 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 48 05
	00 00		 sub	 rsp, 1352		; 00000548H

; 1432 :     register char *input, *output;
; 1433 :     register const char *table;
; 1434 :     register Py_ssize_t i, c;
; 1435 :     PyObject *input_obj = (PyObject*)self;

  00011	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00019	48 89 84 24 20
	05 00 00	 mov	 QWORD PTR input_obj$[rsp], rax

; 1436 :     const char *output_start;
; 1437 :     Py_ssize_t inlen;
; 1438 :     PyObject *result = NULL;

  00021	48 c7 84 24 18
	05 00 00 00 00
	00 00		 mov	 QWORD PTR result$[rsp], 0

; 1439 :     int trans_table[256];
; 1440 :     PyObject *tableobj = NULL, *delobj = NULL;

  0002d	48 c7 84 24 90
	04 00 00 00 00
	00 00		 mov	 QWORD PTR tableobj$[rsp], 0
  00039	48 c7 84 24 10
	05 00 00 00 00
	00 00		 mov	 QWORD PTR delobj$[rsp], 0

; 1441 :     Py_buffer vtable, vdel;
; 1442 : 
; 1443 :     if (!PyArg_UnpackTuple(args, "translate", 1, 2,
; 1444 :                            &tableobj, &delobj))

  00045	48 8d 84 24 10
	05 00 00	 lea	 rax, QWORD PTR delobj$[rsp]
  0004d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00052	48 8d 84 24 90
	04 00 00	 lea	 rax, QWORD PTR tableobj$[rsp]
  0005a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005f	41 b9 02 00 00
	00		 mov	 r9d, 2
  00065	41 b8 01 00 00
	00		 mov	 r8d, 1
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09ODNGOEIO@translate?$AA@
  00072	48 8b 8c 24 58
	05 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0007a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0007f	85 c0		 test	 eax, eax
  00081	75 07		 jne	 SHORT $LN37@bytearray_@27

; 1445 :           return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	e9 98 05 00 00	 jmp	 $LN38@bytearray_@27
$LN37@bytearray_@27:

; 1446 : 
; 1447 :     if (tableobj == Py_None) {

  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00091	48 39 84 24 90
	04 00 00	 cmp	 QWORD PTR tableobj$[rsp], rax
  00099	75 1a		 jne	 SHORT $LN36@bytearray_@27

; 1448 :         table = NULL;

  0009b	48 c7 84 24 08
	05 00 00 00 00
	00 00		 mov	 QWORD PTR table$[rsp], 0

; 1449 :         tableobj = NULL;

  000a7	48 c7 84 24 90
	04 00 00 00 00
	00 00		 mov	 QWORD PTR tableobj$[rsp], 0
  000b3	eb 68		 jmp	 SHORT $LN35@bytearray_@27
$LN36@bytearray_@27:

; 1450 :     } else if (_getbuffer(tableobj, &vtable) < 0) {

  000b5	48 8d 94 24 a0
	04 00 00	 lea	 rdx, QWORD PTR vtable$[rsp]
  000bd	48 8b 8c 24 90
	04 00 00	 mov	 rcx, QWORD PTR tableobj$[rsp]
  000c5	e8 00 00 00 00	 call	 _getbuffer
  000ca	48 85 c0	 test	 rax, rax
  000cd	7d 09		 jge	 SHORT $LN34@bytearray_@27

; 1451 :         return NULL;

  000cf	33 c0		 xor	 eax, eax
  000d1	e9 4c 05 00 00	 jmp	 $LN38@bytearray_@27

; 1452 :     } else {

  000d6	eb 45		 jmp	 SHORT $LN33@bytearray_@27
$LN34@bytearray_@27:

; 1453 :         if (vtable.len != 256) {

  000d8	48 81 bc 24 b0
	04 00 00 00 01
	00 00		 cmp	 QWORD PTR vtable$[rsp+16], 256 ; 00000100H
  000e4	74 27		 je	 SHORT $LN32@bytearray_@27

; 1454 :             PyErr_SetString(PyExc_ValueError,
; 1455 :                             "translation table must be 256 characters long");

  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@
  000ed	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000f4	e8 00 00 00 00	 call	 PyErr_SetString

; 1456 :             PyBuffer_Release(&vtable);

  000f9	48 8d 8c 24 a0
	04 00 00	 lea	 rcx, QWORD PTR vtable$[rsp]
  00101	e8 00 00 00 00	 call	 PyBuffer_Release

; 1457 :             return NULL;

  00106	33 c0		 xor	 eax, eax
  00108	e9 15 05 00 00	 jmp	 $LN38@bytearray_@27
$LN32@bytearray_@27:

; 1458 :         }
; 1459 :         table = (const char*)vtable.buf;

  0010d	48 8b 84 24 a0
	04 00 00	 mov	 rax, QWORD PTR vtable$[rsp]
  00115	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR table$[rsp], rax
$LN33@bytearray_@27:
$LN35@bytearray_@27:

; 1460 :     }
; 1461 : 
; 1462 :     if (delobj != NULL) {

  0011d	48 83 bc 24 10
	05 00 00 00	 cmp	 QWORD PTR delobj$[rsp], 0
  00126	74 38		 je	 SHORT $LN31@bytearray_@27

; 1463 :         if (_getbuffer(delobj, &vdel) < 0) {

  00128	48 8d 54 24 30	 lea	 rdx, QWORD PTR vdel$[rsp]
  0012d	48 8b 8c 24 10
	05 00 00	 mov	 rcx, QWORD PTR delobj$[rsp]
  00135	e8 00 00 00 00	 call	 _getbuffer
  0013a	48 85 c0	 test	 rax, rax
  0013d	7d 1f		 jge	 SHORT $LN30@bytearray_@27

; 1464 :             if (tableobj != NULL)

  0013f	48 83 bc 24 90
	04 00 00 00	 cmp	 QWORD PTR tableobj$[rsp], 0
  00148	74 0d		 je	 SHORT $LN29@bytearray_@27

; 1465 :                 PyBuffer_Release(&vtable);

  0014a	48 8d 8c 24 a0
	04 00 00	 lea	 rcx, QWORD PTR vtable$[rsp]
  00152	e8 00 00 00 00	 call	 PyBuffer_Release
$LN29@bytearray_@27:

; 1466 :             return NULL;

  00157	33 c0		 xor	 eax, eax
  00159	e9 c4 04 00 00	 jmp	 $LN38@bytearray_@27
$LN30@bytearray_@27:

; 1467 :         }
; 1468 :     }
; 1469 :     else {

  0015e	eb 12		 jmp	 SHORT $LN28@bytearray_@27
$LN31@bytearray_@27:

; 1470 :         vdel.buf = NULL;

  00160	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR vdel$[rsp], 0

; 1471 :         vdel.len = 0;

  00169	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR vdel$[rsp+16], 0
$LN28@bytearray_@27:

; 1472 :     }
; 1473 : 
; 1474 :     inlen = PyByteArray_GET_SIZE(input_obj);

  00172	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00179	48 8b 8c 24 20
	05 00 00	 mov	 rcx, QWORD PTR input_obj$[rsp]
  00181	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00185	74 38		 je	 SHORT $LN40@bytearray_@27
  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0018e	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  00196	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0019a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0019f	85 c0		 test	 eax, eax
  001a1	75 1c		 jne	 SHORT $LN40@bytearray_@27
  001a3	41 b8 c2 05 00
	00		 mov	 r8d, 1474		; 000005c2H
  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@GLBPACJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001bd	33 c0		 xor	 eax, eax
$LN40@bytearray_@27:
  001bf	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  001c7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001cb	48 89 84 24 80
	04 00 00	 mov	 QWORD PTR inlen$[rsp], rax

; 1475 :     result = PyByteArray_FromStringAndSize((char *)NULL, inlen);

  001d3	48 8b 94 24 80
	04 00 00	 mov	 rdx, QWORD PTR inlen$[rsp]
  001db	33 c9		 xor	 ecx, ecx
  001dd	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  001e2	48 89 84 24 18
	05 00 00	 mov	 QWORD PTR result$[rsp], rax

; 1476 :     if (result == NULL)

  001ea	48 83 bc 24 18
	05 00 00 00	 cmp	 QWORD PTR result$[rsp], 0
  001f3	75 05		 jne	 SHORT $LN27@bytearray_@27

; 1477 :         goto done;

  001f5	e9 f3 03 00 00	 jmp	 $done$22817
$LN27@bytearray_@27:

; 1478 :     output_start = output = PyByteArray_AsString(result);

  001fa	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00202	e8 00 00 00 00	 call	 PyByteArray_AsString
  00207	48 89 84 24 f0
	04 00 00	 mov	 QWORD PTR output$[rsp], rax
  0020f	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR output$[rsp]
  00217	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR output_start$[rsp], rax

; 1479 :     input = PyByteArray_AS_STRING(input_obj);

  0021f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00226	48 8b 8c 24 20
	05 00 00	 mov	 rcx, QWORD PTR input_obj$[rsp]
  0022e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00232	74 38		 je	 SHORT $LN41@bytearray_@27
  00234	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0023b	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  00243	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00247	e8 00 00 00 00	 call	 PyType_IsSubtype
  0024c	85 c0		 test	 eax, eax
  0024e	75 1c		 jne	 SHORT $LN41@bytearray_@27
  00250	41 b8 c7 05 00
	00		 mov	 r8d, 1479		; 000005c7H
  00256	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@GLBPACJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA_?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00264	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0026a	33 c0		 xor	 eax, eax
$LN41@bytearray_@27:
  0026c	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  00274	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00279	74 19		 je	 SHORT $LN42@bytearray_@27
  0027b	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR input_obj$[rsp]
  00283	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0028a	48 89 84 24 38
	05 00 00	 mov	 QWORD PTR tv152[rsp], rax
  00292	eb 0f		 jmp	 SHORT $LN43@bytearray_@27
$LN42@bytearray_@27:
  00294	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0029b	48 89 84 24 38
	05 00 00	 mov	 QWORD PTR tv152[rsp], rax
$LN43@bytearray_@27:
  002a3	48 8b 84 24 38
	05 00 00	 mov	 rax, QWORD PTR tv152[rsp]
  002ab	48 89 84 24 f8
	04 00 00	 mov	 QWORD PTR input$[rsp], rax

; 1480 : 
; 1481 :     if (vdel.len == 0 && table != NULL) {

  002b3	48 83 7c 24 40
	00		 cmp	 QWORD PTR vdel$[rsp+16], 0
  002b9	0f 85 ab 00 00
	00		 jne	 $LN26@bytearray_@27
  002bf	48 83 bc 24 08
	05 00 00 00	 cmp	 QWORD PTR table$[rsp], 0
  002c8	0f 84 9c 00 00
	00		 je	 $LN26@bytearray_@27

; 1482 :         /* If no deletions are required, use faster code */
; 1483 :         for (i = inlen; --i >= 0; ) {

  002ce	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR inlen$[rsp]
  002d6	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN25@bytearray_@27:
  002de	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  002e6	48 ff c8	 dec	 rax
  002e9	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
  002f1	48 83 bc 24 88
	04 00 00 00	 cmp	 QWORD PTR i$[rsp], 0
  002fa	7c 69		 jl	 SHORT $LN24@bytearray_@27

; 1484 :             c = Py_CHARMASK(*input++);

  002fc	48 8b 84 24 f8
	04 00 00	 mov	 rax, QWORD PTR input$[rsp]
  00304	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00307	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0030c	0f b6 c0	 movzx	 eax, al
  0030f	48 89 84 24 28
	05 00 00	 mov	 QWORD PTR c$[rsp], rax
  00317	48 8b 84 24 f8
	04 00 00	 mov	 rax, QWORD PTR input$[rsp]
  0031f	48 ff c0	 inc	 rax
  00322	48 89 84 24 f8
	04 00 00	 mov	 QWORD PTR input$[rsp], rax

; 1485 :             *output++ = table[c];

  0032a	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00332	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0033a	48 03 c8	 add	 rcx, rax
  0033d	48 8b c1	 mov	 rax, rcx
  00340	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR output$[rsp]
  00348	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0034b	88 01		 mov	 BYTE PTR [rcx], al
  0034d	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR output$[rsp]
  00355	48 ff c0	 inc	 rax
  00358	48 89 84 24 f0
	04 00 00	 mov	 QWORD PTR output$[rsp], rax

; 1486 :         }

  00360	e9 79 ff ff ff	 jmp	 $LN25@bytearray_@27
$LN24@bytearray_@27:

; 1487 :         goto done;

  00365	e9 83 02 00 00	 jmp	 $done$22817
$LN26@bytearray_@27:

; 1488 :     }
; 1489 : 
; 1490 :     if (table == NULL) {

  0036a	48 83 bc 24 08
	05 00 00 00	 cmp	 QWORD PTR table$[rsp], 0
  00373	75 53		 jne	 SHORT $LN23@bytearray_@27

; 1491 :         for (i = 0; i < 256; i++)

  00375	48 c7 84 24 88
	04 00 00 00 00
	00 00		 mov	 QWORD PTR i$[rsp], 0
  00381	eb 13		 jmp	 SHORT $LN22@bytearray_@27
$LN21@bytearray_@27:
  00383	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0038b	48 ff c0	 inc	 rax
  0038e	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN22@bytearray_@27:
  00396	48 81 bc 24 88
	04 00 00 00 01
	00 00		 cmp	 QWORD PTR i$[rsp], 256	; 00000100H
  003a2	7d 22		 jge	 SHORT $LN20@bytearray_@27

; 1492 :             trans_table[i] = Py_CHARMASK(i);

  003a4	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  003ac	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  003b2	0f b6 c0	 movzx	 eax, al
  003b5	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  003bd	89 84 8c 80 00
	00 00		 mov	 DWORD PTR trans_table$[rsp+rcx*4], eax
  003c4	eb bd		 jmp	 SHORT $LN21@bytearray_@27
$LN20@bytearray_@27:

; 1493 :     } else {

  003c6	eb 61		 jmp	 SHORT $LN19@bytearray_@27
$LN23@bytearray_@27:

; 1494 :         for (i = 0; i < 256; i++)

  003c8	48 c7 84 24 88
	04 00 00 00 00
	00 00		 mov	 QWORD PTR i$[rsp], 0
  003d4	eb 13		 jmp	 SHORT $LN18@bytearray_@27
$LN17@bytearray_@27:
  003d6	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  003de	48 ff c0	 inc	 rax
  003e1	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN18@bytearray_@27:
  003e9	48 81 bc 24 88
	04 00 00 00 01
	00 00		 cmp	 QWORD PTR i$[rsp], 256	; 00000100H
  003f5	7d 32		 jge	 SHORT $LN16@bytearray_@27

; 1495 :             trans_table[i] = Py_CHARMASK(table[i]);

  003f7	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  003ff	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00407	48 03 c8	 add	 rcx, rax
  0040a	48 8b c1	 mov	 rax, rcx
  0040d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00410	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00415	0f b6 c0	 movzx	 eax, al
  00418	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  00420	89 84 8c 80 00
	00 00		 mov	 DWORD PTR trans_table$[rsp+rcx*4], eax
  00427	eb ad		 jmp	 SHORT $LN17@bytearray_@27
$LN16@bytearray_@27:
$LN19@bytearray_@27:

; 1496 :     }
; 1497 : 
; 1498 :     for (i = 0; i < vdel.len; i++)

  00429	48 c7 84 24 88
	04 00 00 00 00
	00 00		 mov	 QWORD PTR i$[rsp], 0
  00435	eb 13		 jmp	 SHORT $LN15@bytearray_@27
$LN14@bytearray_@27:
  00437	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0043f	48 ff c0	 inc	 rax
  00442	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN15@bytearray_@27:
  0044a	48 8b 44 24 40	 mov	 rax, QWORD PTR vdel$[rsp+16]
  0044f	48 39 84 24 88
	04 00 00	 cmp	 QWORD PTR i$[rsp], rax
  00457	7d 2b		 jge	 SHORT $LN13@bytearray_@27

; 1499 :         trans_table[(int) Py_CHARMASK( ((unsigned char*)vdel.buf)[i] )] = -1;

  00459	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  00461	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vdel$[rsp]
  00466	48 03 c8	 add	 rcx, rax
  00469	48 8b c1	 mov	 rax, rcx
  0046c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0046f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00474	0f b6 c0	 movzx	 eax, al
  00477	c7 84 84 80 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR trans_table$[rsp+rax*4], -1
  00482	eb b3		 jmp	 SHORT $LN14@bytearray_@27
$LN13@bytearray_@27:

; 1500 : 
; 1501 :     for (i = inlen; --i >= 0; ) {

  00484	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR inlen$[rsp]
  0048c	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN44@bytearray_@27:
$LN12@bytearray_@27:
  00494	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0049c	48 ff c8	 dec	 rax
  0049f	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR i$[rsp], rax
  004a7	48 83 bc 24 88
	04 00 00 00	 cmp	 QWORD PTR i$[rsp], 0
  004b0	0f 8c 97 00 00
	00		 jl	 $LN11@bytearray_@27

; 1502 :         c = Py_CHARMASK(*input++);

  004b6	48 8b 84 24 f8
	04 00 00	 mov	 rax, QWORD PTR input$[rsp]
  004be	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004c1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004c6	0f b6 c0	 movzx	 eax, al
  004c9	48 89 84 24 28
	05 00 00	 mov	 QWORD PTR c$[rsp], rax
  004d1	48 8b 84 24 f8
	04 00 00	 mov	 rax, QWORD PTR input$[rsp]
  004d9	48 ff c0	 inc	 rax
  004dc	48 89 84 24 f8
	04 00 00	 mov	 QWORD PTR input$[rsp], rax

; 1503 :         if (trans_table[c] != -1)

  004e4	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR c$[rsp]
  004ec	83 bc 84 80 00
	00 00 ff	 cmp	 DWORD PTR trans_table$[rsp+rax*4], -1
  004f4	74 52		 je	 SHORT $LN10@bytearray_@27

; 1504 :             if (Py_CHARMASK(*output++ = (char)trans_table[c]) == c)

  004f6	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR output$[rsp]
  004fe	48 8b 8c 24 28
	05 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00506	0f b6 8c 8c 80
	00 00 00	 movzx	 ecx, BYTE PTR trans_table$[rsp+rcx*4]
  0050e	88 08		 mov	 BYTE PTR [rax], cl
  00510	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR output$[rsp]
  00518	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0051b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00520	0f b6 c0	 movzx	 eax, al
  00523	48 8b 8c 24 28
	05 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0052b	48 8b 94 24 f0
	04 00 00	 mov	 rdx, QWORD PTR output$[rsp]
  00533	48 ff c2	 inc	 rdx
  00536	48 89 94 24 f0
	04 00 00	 mov	 QWORD PTR output$[rsp], rdx
  0053e	48 3b c1	 cmp	 rax, rcx
  00541	75 05		 jne	 SHORT $LN9@bytearray_@27

; 1505 :                     continue;

  00543	e9 4c ff ff ff	 jmp	 $LN12@bytearray_@27
$LN9@bytearray_@27:
$LN10@bytearray_@27:

; 1506 :     }

  00548	e9 47 ff ff ff	 jmp	 $LN44@bytearray_@27
$LN11@bytearray_@27:

; 1507 :     /* Fix the size of the resulting string */
; 1508 :     if (inlen > 0)

  0054d	48 83 bc 24 80
	04 00 00 00	 cmp	 QWORD PTR inlen$[rsp], 0
  00556	0f 8e 91 00 00
	00		 jle	 $LN8@bytearray_@27

; 1509 :         if (PyByteArray_Resize(result, output - output_start) < 0) {

  0055c	48 8b 84 24 00
	05 00 00	 mov	 rax, QWORD PTR output_start$[rsp]
  00564	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR output$[rsp]
  0056c	48 2b c8	 sub	 rcx, rax
  0056f	48 8b c1	 mov	 rax, rcx
  00572	48 8b d0	 mov	 rdx, rax
  00575	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  0057d	e8 00 00 00 00	 call	 PyByteArray_Resize
  00582	85 c0		 test	 eax, eax
  00584	7d 67		 jge	 SHORT $LN7@bytearray_@27
$LN6@bytearray_@27:

; 1510 :             Py_CLEAR(result);

  00586	48 83 bc 24 18
	05 00 00 00	 cmp	 QWORD PTR result$[rsp], 0
  0058f	74 56		 je	 SHORT $LN3@bytearray_@27
  00591	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00599	4c 8b 8c 24 18
	05 00 00	 mov	 r9, QWORD PTR result$[rsp]
  005a1	41 b8 e6 05 00
	00		 mov	 r8d, 1510		; 000005e6H
  005a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  005ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LKHHMEFM@bytearray_translate?$AA@
  005b5	e8 00 00 00 00	 call	 _PyParallel_Guard
  005ba	85 c0		 test	 eax, eax
  005bc	75 29		 jne	 SHORT $LN3@bytearray_@27
  005be	48 8b 84 24 18
	05 00 00	 mov	 rax, QWORD PTR result$[rsp]
  005c6	48 89 84 24 30
	05 00 00	 mov	 QWORD PTR _py_tmp$22862[rsp], rax
  005ce	48 c7 84 24 18
	05 00 00 00 00
	00 00		 mov	 QWORD PTR result$[rsp], 0
  005da	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR _py_tmp$22862[rsp]
  005e2	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@bytearray_@27:
  005e7	33 c0		 xor	 eax, eax
  005e9	85 c0		 test	 eax, eax
  005eb	75 99		 jne	 SHORT $LN6@bytearray_@27
$LN7@bytearray_@27:
$LN8@bytearray_@27:
$done$22817:

; 1511 :             goto done;
; 1512 :         }
; 1513 : 
; 1514 : done:
; 1515 :     if (tableobj != NULL)

  005ed	48 83 bc 24 90
	04 00 00 00	 cmp	 QWORD PTR tableobj$[rsp], 0
  005f6	74 0d		 je	 SHORT $LN2@bytearray_@27

; 1516 :         PyBuffer_Release(&vtable);

  005f8	48 8d 8c 24 a0
	04 00 00	 lea	 rcx, QWORD PTR vtable$[rsp]
  00600	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@bytearray_@27:

; 1517 :     if (delobj != NULL)

  00605	48 83 bc 24 10
	05 00 00 00	 cmp	 QWORD PTR delobj$[rsp], 0
  0060e	74 0a		 je	 SHORT $LN1@bytearray_@27

; 1518 :         PyBuffer_Release(&vdel);

  00610	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vdel$[rsp]
  00615	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@27:

; 1519 :     return result;

  0061a	48 8b 84 24 18
	05 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN38@bytearray_@27:

; 1520 : }

  00622	48 81 c4 48 05
	00 00		 add	 rsp, 1352		; 00000548H
  00629	c3		 ret	 0
bytearray_translate ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_maketrans:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_maketrans DD imagerel bytearray_maketrans
	DD	imagerel bytearray_maketrans+29
	DD	imagerel $unwind$bytearray_maketrans
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_maketrans DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_maketrans
_TEXT	SEGMENT
null$ = 48
args$ = 56
bytearray_maketrans PROC				; COMDAT

; 1525 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1526 :         return _Py_bytes_maketrans(args);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  00013	e8 00 00 00 00	 call	 _Py_bytes_maketrans

; 1527 : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
bytearray_maketrans ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_replace DD imagerel bytearray_replace
	DD	imagerel bytearray_replace+242
	DD	imagerel $unwind$bytearray_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_replace DD 021101H
	DD	0210111H
xdata	ENDS
;	COMDAT ??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@
CONST	SEGMENT
??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@ DB 'OO|n:replace', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_replace
_TEXT	SEGMENT
res$ = 48
count$ = 56
to$ = 64
vto$ = 80
vfrom$ = 160
from$ = 240
self$ = 272
args$ = 280
bytearray_replace PROC					; COMDAT

; 2026 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 2027 :     Py_ssize_t count = -1;

  00011	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR count$[rsp], -1

; 2028 :     PyObject *from, *to, *res;
; 2029 :     Py_buffer vfrom, vto;
; 2030 : 
; 2031 :     if (!PyArg_ParseTuple(args, "OO|n:replace", &from, &to, &count))

  0001a	48 8d 44 24 38	 lea	 rax, QWORD PTR count$[rsp]
  0001f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00024	4c 8d 4c 24 40	 lea	 r9, QWORD PTR to$[rsp]
  00029	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR from$[rsp]
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@
  00038	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00040	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00045	85 c0		 test	 eax, eax
  00047	75 07		 jne	 SHORT $LN3@bytearray_@28

; 2032 :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 9a 00 00 00	 jmp	 $LN4@bytearray_@28
$LN3@bytearray_@28:

; 2033 : 
; 2034 :     if (_getbuffer(from, &vfrom) < 0)

  00050	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR vfrom$[rsp]
  00058	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  00060	e8 00 00 00 00	 call	 _getbuffer
  00065	48 85 c0	 test	 rax, rax
  00068	7d 04		 jge	 SHORT $LN2@bytearray_@28

; 2035 :         return NULL;

  0006a	33 c0		 xor	 eax, eax
  0006c	eb 7c		 jmp	 SHORT $LN4@bytearray_@28
$LN2@bytearray_@28:

; 2036 :     if (_getbuffer(to, &vto) < 0) {

  0006e	48 8d 54 24 50	 lea	 rdx, QWORD PTR vto$[rsp]
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR to$[rsp]
  00078	e8 00 00 00 00	 call	 _getbuffer
  0007d	48 85 c0	 test	 rax, rax
  00080	7d 11		 jge	 SHORT $LN1@bytearray_@28

; 2037 :         PyBuffer_Release(&vfrom);

  00082	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR vfrom$[rsp]
  0008a	e8 00 00 00 00	 call	 PyBuffer_Release

; 2038 :         return NULL;

  0008f	33 c0		 xor	 eax, eax
  00091	eb 57		 jmp	 SHORT $LN4@bytearray_@28
$LN1@bytearray_@28:

; 2039 :     }
; 2040 : 
; 2041 :     res = (PyObject *)replace((PyByteArrayObject *) self,
; 2042 :                               vfrom.buf, vfrom.len,
; 2043 :                               vto.buf, vto.len, count);

  00093	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  00098	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009d	48 8b 44 24 60	 mov	 rax, QWORD PTR vto$[rsp+16]
  000a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a7	4c 8b 4c 24 50	 mov	 r9, QWORD PTR vto$[rsp]
  000ac	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR vfrom$[rsp+16]
  000b4	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR vfrom$[rsp]
  000bc	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000c4	e8 00 00 00 00	 call	 replace
  000c9	48 89 44 24 30	 mov	 QWORD PTR res$[rsp], rax

; 2044 : 
; 2045 :     PyBuffer_Release(&vfrom);

  000ce	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR vfrom$[rsp]
  000d6	e8 00 00 00 00	 call	 PyBuffer_Release

; 2046 :     PyBuffer_Release(&vto);

  000db	48 8d 4c 24 50	 lea	 rcx, QWORD PTR vto$[rsp]
  000e0	e8 00 00 00 00	 call	 PyBuffer_Release

; 2047 :     return res;

  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR res$[rsp]
$LN4@bytearray_@28:

; 2048 : }

  000ea	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  000f1	c3		 ret	 0
bytearray_replace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace DD imagerel replace
	DD	imagerel replace+612
	DD	imagerel $unwind$replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace
_TEXT	SEGMENT
self$ = 64
from_s$ = 72
from_len$ = 80
to_s$ = 88
to_len$ = 96
maxcount$ = 104
replace	PROC						; COMDAT

; 1951 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1952 :     if (maxcount < 0) {

  00018	48 83 7c 24 68
	00		 cmp	 QWORD PTR maxcount$[rsp], 0
  0001e	7d 11		 jge	 SHORT $LN16@replace

; 1953 :         maxcount = PY_SSIZE_T_MAX;

  00020	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002a	48 89 44 24 68	 mov	 QWORD PTR maxcount$[rsp], rax
  0002f	eb 6a		 jmp	 SHORT $LN15@replace
$LN16@replace:

; 1954 :     } else if (maxcount == 0 || PyByteArray_GET_SIZE(self) == 0) {

  00031	48 83 7c 24 68
	00		 cmp	 QWORD PTR maxcount$[rsp], 0
  00037	74 53		 je	 SHORT $LN13@replace
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00045	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00049	74 35		 je	 SHORT $LN19@replace
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 1c		 jne	 SHORT $LN19@replace
  00064	41 b8 a2 07 00
	00		 mov	 r8d, 1954		; 000007a2H
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN19@replace:
  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00085	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0008a	75 0f		 jne	 SHORT $LN14@replace
$LN13@replace:

; 1955 :         /* nothing to do; return the original bytes */
; 1956 :         return return_self(self);

  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00091	e8 00 00 00 00	 call	 return_self
  00096	e9 c4 01 00 00	 jmp	 $LN17@replace
$LN14@replace:
$LN15@replace:

; 1957 :     }
; 1958 : 
; 1959 :     if (maxcount == 0 ||
; 1960 :         (from_len == 0 && to_len == 0)) {

  0009b	48 83 7c 24 68
	00		 cmp	 QWORD PTR maxcount$[rsp], 0
  000a1	74 10		 je	 SHORT $LN11@replace
  000a3	48 83 7c 24 50
	00		 cmp	 QWORD PTR from_len$[rsp], 0
  000a9	75 17		 jne	 SHORT $LN12@replace
  000ab	48 83 7c 24 60
	00		 cmp	 QWORD PTR to_len$[rsp], 0
  000b1	75 0f		 jne	 SHORT $LN12@replace
$LN11@replace:

; 1961 :         /* nothing to do; return the original bytes */
; 1962 :         return return_self(self);

  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000b8	e8 00 00 00 00	 call	 return_self
  000bd	e9 9d 01 00 00	 jmp	 $LN17@replace
$LN12@replace:

; 1963 :     }
; 1964 : 
; 1965 :     /* Handle zero-length special cases */
; 1966 : 
; 1967 :     if (from_len == 0) {

  000c2	48 83 7c 24 50
	00		 cmp	 QWORD PTR from_len$[rsp], 0
  000c8	75 1e		 jne	 SHORT $LN10@replace

; 1968 :         /* insert the 'to' bytes everywhere.   */
; 1969 :         /*    >>> "Python".replace("", ".")     */
; 1970 :         /*    '.P.y.t.h.o.n.'                   */
; 1971 :         return replace_interleave(self, to_s, to_len, maxcount);

  000ca	4c 8b 4c 24 68	 mov	 r9, QWORD PTR maxcount$[rsp]
  000cf	4c 8b 44 24 60	 mov	 r8, QWORD PTR to_len$[rsp]
  000d4	48 8b 54 24 58	 mov	 rdx, QWORD PTR to_s$[rsp]
  000d9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000de	e8 00 00 00 00	 call	 replace_interleave
  000e3	e9 77 01 00 00	 jmp	 $LN17@replace
$LN10@replace:

; 1972 :     }
; 1973 : 
; 1974 :     /* Except for "".replace("", "A") == "A" there is no way beyond this */
; 1975 :     /* point for an empty self bytes to generate a non-empty bytes */
; 1976 :     /* Special case so the remaining code always gets a non-empty bytes */
; 1977 :     if (PyByteArray_GET_SIZE(self) == 0) {

  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000ef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000f4	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f8	74 35		 je	 SHORT $LN20@replace
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00101	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00106	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0010a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0010f	85 c0		 test	 eax, eax
  00111	75 1c		 jne	 SHORT $LN20@replace
  00113	41 b8 b9 07 00
	00		 mov	 r8d, 1977		; 000007b9H
  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0012d	33 c0		 xor	 eax, eax
$LN20@replace:
  0012f	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00134	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00139	75 0f		 jne	 SHORT $LN9@replace

; 1978 :         return return_self(self);

  0013b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00140	e8 00 00 00 00	 call	 return_self
  00145	e9 15 01 00 00	 jmp	 $LN17@replace
$LN9@replace:

; 1979 :     }
; 1980 : 
; 1981 :     if (to_len == 0) {

  0014a	48 83 7c 24 60
	00		 cmp	 QWORD PTR to_len$[rsp], 0
  00150	75 44		 jne	 SHORT $LN8@replace

; 1982 :         /* delete all occurrences of 'from' bytes */
; 1983 :         if (from_len == 1) {

  00152	48 83 7c 24 50
	01		 cmp	 QWORD PTR from_len$[rsp], 1
  00158	75 1e		 jne	 SHORT $LN7@replace

; 1984 :             return replace_delete_single_character(
; 1985 :                     self, from_s[0], maxcount);

  0015a	4c 8b 44 24 68	 mov	 r8, QWORD PTR maxcount$[rsp]
  0015f	48 8b 44 24 48	 mov	 rax, QWORD PTR from_s$[rsp]
  00164	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00167	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0016c	e8 00 00 00 00	 call	 replace_delete_single_character
  00171	e9 e9 00 00 00	 jmp	 $LN17@replace

; 1986 :         } else {

  00176	eb 1e		 jmp	 SHORT $LN6@replace
$LN7@replace:

; 1987 :             return replace_delete_substring(self, from_s, from_len, maxcount);

  00178	4c 8b 4c 24 68	 mov	 r9, QWORD PTR maxcount$[rsp]
  0017d	4c 8b 44 24 50	 mov	 r8, QWORD PTR from_len$[rsp]
  00182	48 8b 54 24 48	 mov	 rdx, QWORD PTR from_s$[rsp]
  00187	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0018c	e8 00 00 00 00	 call	 replace_delete_substring
  00191	e9 c9 00 00 00	 jmp	 $LN17@replace
$LN6@replace:
$LN8@replace:

; 1988 :         }
; 1989 :     }
; 1990 : 
; 1991 :     /* Handle special case where both bytes have the same length */
; 1992 : 
; 1993 :     if (from_len == to_len) {

  00196	48 8b 44 24 60	 mov	 rax, QWORD PTR to_len$[rsp]
  0019b	48 39 44 24 50	 cmp	 QWORD PTR from_len$[rsp], rax
  001a0	75 5e		 jne	 SHORT $LN5@replace

; 1994 :         if (from_len == 1) {

  001a2	48 83 7c 24 50
	01		 cmp	 QWORD PTR from_len$[rsp], 1
  001a8	75 27		 jne	 SHORT $LN4@replace

; 1995 :             return replace_single_character_in_place(
; 1996 :                     self,
; 1997 :                     from_s[0],
; 1998 :                     to_s[0],
; 1999 :                     maxcount);

  001aa	4c 8b 4c 24 68	 mov	 r9, QWORD PTR maxcount$[rsp]
  001af	48 8b 44 24 58	 mov	 rax, QWORD PTR to_s$[rsp]
  001b4	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  001b8	48 8b 44 24 48	 mov	 rax, QWORD PTR from_s$[rsp]
  001bd	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  001c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  001c5	e8 00 00 00 00	 call	 replace_single_character_in_place
  001ca	e9 90 00 00 00	 jmp	 $LN17@replace

; 2000 :         } else {

  001cf	eb 2f		 jmp	 SHORT $LN3@replace
$LN4@replace:

; 2001 :             return replace_substring_in_place(
; 2002 :                 self, from_s, from_len, to_s, to_len, maxcount);

  001d1	48 8b 44 24 68	 mov	 rax, QWORD PTR maxcount$[rsp]
  001d6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001db	48 8b 44 24 60	 mov	 rax, QWORD PTR to_len$[rsp]
  001e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e5	4c 8b 4c 24 58	 mov	 r9, QWORD PTR to_s$[rsp]
  001ea	4c 8b 44 24 50	 mov	 r8, QWORD PTR from_len$[rsp]
  001ef	48 8b 54 24 48	 mov	 rdx, QWORD PTR from_s$[rsp]
  001f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  001f9	e8 00 00 00 00	 call	 replace_substring_in_place
  001fe	eb 5f		 jmp	 SHORT $LN17@replace
$LN3@replace:
$LN5@replace:

; 2003 :         }
; 2004 :     }
; 2005 : 
; 2006 :     /* Otherwise use the more generic algorithms */
; 2007 :     if (from_len == 1) {

  00200	48 83 7c 24 50
	01		 cmp	 QWORD PTR from_len$[rsp], 1
  00206	75 2a		 jne	 SHORT $LN2@replace

; 2008 :         return replace_single_character(self, from_s[0],
; 2009 :                                         to_s, to_len, maxcount);

  00208	48 8b 44 24 68	 mov	 rax, QWORD PTR maxcount$[rsp]
  0020d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00212	4c 8b 4c 24 60	 mov	 r9, QWORD PTR to_len$[rsp]
  00217	4c 8b 44 24 58	 mov	 r8, QWORD PTR to_s$[rsp]
  0021c	48 8b 44 24 48	 mov	 rax, QWORD PTR from_s$[rsp]
  00221	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00224	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00229	e8 00 00 00 00	 call	 replace_single_character
  0022e	eb 2f		 jmp	 SHORT $LN17@replace

; 2010 :     } else {

  00230	eb 2d		 jmp	 SHORT $LN1@replace
$LN2@replace:

; 2011 :         /* len('from')>=2, len('to')>=1 */
; 2012 :         return replace_substring(self, from_s, from_len, to_s, to_len, maxcount);

  00232	48 8b 44 24 68	 mov	 rax, QWORD PTR maxcount$[rsp]
  00237	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0023c	48 8b 44 24 60	 mov	 rax, QWORD PTR to_len$[rsp]
  00241	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00246	4c 8b 4c 24 58	 mov	 r9, QWORD PTR to_s$[rsp]
  0024b	4c 8b 44 24 50	 mov	 r8, QWORD PTR from_len$[rsp]
  00250	48 8b 54 24 48	 mov	 rdx, QWORD PTR from_s$[rsp]
  00255	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0025a	e8 00 00 00 00	 call	 replace_substring
$LN1@replace:
$LN17@replace:

; 2013 :     }
; 2014 : }

  0025f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00263	c3		 ret	 0
replace	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$return_self DD imagerel return_self
	DD	imagerel return_self+218
	DD	imagerel $unwind$return_self
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$return_self DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT return_self
_TEXT	SEGMENT
tv92 = 32
self$ = 64
return_self PROC					; COMDAT

; 1539 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1540 :     /* always return a new bytearray */
; 1541 :     return (PyByteArrayObject *)PyByteArray_FromStringAndSize(
; 1542 :             PyByteArray_AS_STRING(self),
; 1543 :             PyByteArray_GET_SIZE(self));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN3@return_sel
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN3@return_sel
  00034	41 b8 07 06 00
	00		 mov	 r8d, 1543		; 00000607H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN3@return_sel:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00060	74 35		 je	 SHORT $LN4@return_sel
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00072	e8 00 00 00 00	 call	 PyType_IsSubtype
  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN4@return_sel
  0007b	41 b8 06 06 00
	00		 mov	 r8d, 1542		; 00000606H
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00095	33 c0		 xor	 eax, eax
$LN4@return_sel:
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0009c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a1	74 13		 je	 SHORT $LN5@return_sel
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000af	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
  000b4	eb 0c		 jmp	 SHORT $LN6@return_sel
$LN5@return_sel:
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000bd	48 89 44 24 20	 mov	 QWORD PTR tv92[rsp], rax
$LN6@return_sel:
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000c7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv92[rsp]
  000d0	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 1544 : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
return_self ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_interleave DD imagerel replace_interleave
	DD	imagerel replace_interleave+1297
	DD	imagerel $unwind$replace_interleave
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_interleave DD 021b01H
	DD	01b011bH
xdata	ENDS
;	COMDAT ??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@ DB 'replace string'
	DB	' is too long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT replace_interleave
_TEXT	SEGMENT
result_len$ = 32
count$ = 40
i$ = 48
self_len$ = 56
result_s$ = 64
result$ = 72
self_s$ = 80
t_$22960 = 88
s_$22962 = 96
i_$22958 = 104
n_$22959 = 112
t_$22977 = 120
s_$22979 = 128
i_$22975 = 136
n_$22976 = 144
t_$22991 = 152
s_$22993 = 160
i_$22989 = 168
n_$22990 = 176
tv140 = 184
tv155 = 192
self$ = 224
to_s$ = 232
to_len$ = 240
maxcount$ = 248
replace_interleave PROC					; COMDAT

; 1570 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1571 :     char *self_s, *result_s;
; 1572 :     Py_ssize_t self_len, result_len;
; 1573 :     Py_ssize_t count, i;
; 1574 :     PyByteArrayObject *result;
; 1575 : 
; 1576 :     self_len = PyByteArray_GET_SIZE(self);

  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0002a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002e	74 38		 je	 SHORT $LN34@replace_in
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00037	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00043	e8 00 00 00 00	 call	 PyType_IsSubtype
  00048	85 c0		 test	 eax, eax
  0004a	75 1c		 jne	 SHORT $LN34@replace_in
  0004c	41 b8 28 06 00
	00		 mov	 r8d, 1576		; 00000628H
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00066	33 c0		 xor	 eax, eax
$LN34@replace_in:
  00068	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00070	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00074	48 89 44 24 38	 mov	 QWORD PTR self_len$[rsp], rax

; 1577 : 
; 1578 :     /* 1 at the end plus 1 after every character;
; 1579 :        count = min(maxcount, self_len + 1) */
; 1580 :     if (maxcount <= self_len)

  00079	48 8b 44 24 38	 mov	 rax, QWORD PTR self_len$[rsp]
  0007e	48 39 84 24 f8
	00 00 00	 cmp	 QWORD PTR maxcount$[rsp], rax
  00086	7f 0f		 jg	 SHORT $LN31@replace_in

; 1581 :         count = maxcount;

  00088	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00090	48 89 44 24 28	 mov	 QWORD PTR count$[rsp], rax

; 1582 :     else

  00095	eb 0d		 jmp	 SHORT $LN30@replace_in
$LN31@replace_in:

; 1583 :         /* Can't overflow: self_len + 1 <= maxcount <= PY_SSIZE_T_MAX. */
; 1584 :         count = self_len + 1;

  00097	48 8b 44 24 38	 mov	 rax, QWORD PTR self_len$[rsp]
  0009c	48 ff c0	 inc	 rax
  0009f	48 89 44 24 28	 mov	 QWORD PTR count$[rsp], rax
$LN30@replace_in:

; 1585 : 
; 1586 :     /* Check for overflow */
; 1587 :     /*   result_len = count * to_len + self_len; */
; 1588 :     assert(count > 0);

  000a4	48 83 7c 24 28
	00		 cmp	 QWORD PTR count$[rsp], 0
  000aa	7f 1c		 jg	 SHORT $LN35@replace_in
  000ac	41 b8 34 06 00
	00		 mov	 r8d, 1588		; 00000634H
  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c6	33 c0		 xor	 eax, eax
$LN35@replace_in:

; 1589 :     if (to_len > (PY_SSIZE_T_MAX - self_len) / count) {

  000c8	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000d2	48 2b 44 24 38	 sub	 rax, QWORD PTR self_len$[rsp]
  000d7	48 99		 cdq
  000d9	48 f7 7c 24 28	 idiv	 QWORD PTR count$[rsp]
  000de	48 39 84 24 f0
	00 00 00	 cmp	 QWORD PTR to_len$[rsp], rax
  000e6	7e 1a		 jle	 SHORT $LN29@replace_in

; 1590 :         PyErr_SetString(PyExc_OverflowError,
; 1591 :                         "replace string is too long");

  000e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@
  000ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000f6	e8 00 00 00 00	 call	 PyErr_SetString

; 1592 :         return NULL;

  000fb	33 c0		 xor	 eax, eax
  000fd	e9 07 04 00 00	 jmp	 $LN32@replace_in
$LN29@replace_in:

; 1593 :     }
; 1594 :     result_len = count * to_len + self_len;

  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  00107	48 0f af 84 24
	f0 00 00 00	 imul	 rax, QWORD PTR to_len$[rsp]
  00110	48 03 44 24 38	 add	 rax, QWORD PTR self_len$[rsp]
  00115	48 89 44 24 20	 mov	 QWORD PTR result_len$[rsp], rax

; 1595 : 
; 1596 :     if (! (result = (PyByteArrayObject *)
; 1597 :                      PyByteArray_FromStringAndSize(NULL, result_len)) )

  0011a	48 8b 54 24 20	 mov	 rdx, QWORD PTR result_len$[rsp]
  0011f	33 c9		 xor	 ecx, ecx
  00121	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00126	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax
  0012b	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  00131	75 07		 jne	 SHORT $LN28@replace_in

; 1598 :         return NULL;

  00133	33 c0		 xor	 eax, eax
  00135	e9 cf 03 00 00	 jmp	 $LN32@replace_in
$LN28@replace_in:

; 1599 : 
; 1600 :     self_s = PyByteArray_AS_STRING(self);

  0013a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00141	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00149	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0014d	74 38		 je	 SHORT $LN36@replace_in
  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00156	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0015e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00162	e8 00 00 00 00	 call	 PyType_IsSubtype
  00167	85 c0		 test	 eax, eax
  00169	75 1c		 jne	 SHORT $LN36@replace_in
  0016b	41 b8 40 06 00
	00		 mov	 r8d, 1600		; 00000640H
  00171	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00185	33 c0		 xor	 eax, eax
$LN36@replace_in:
  00187	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0018f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00194	74 19		 je	 SHORT $LN37@replace_in
  00196	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0019e	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  001a5	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv140[rsp], rax
  001ad	eb 0f		 jmp	 SHORT $LN38@replace_in
$LN37@replace_in:
  001af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  001b6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv140[rsp], rax
$LN38@replace_in:
  001be	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv140[rsp]
  001c6	48 89 44 24 50	 mov	 QWORD PTR self_s$[rsp], rax

; 1601 :     result_s = PyByteArray_AS_STRING(result);

  001cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001d2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  001d7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001db	74 35		 je	 SHORT $LN39@replace_in
  001dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001e4	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  001e9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001ed	e8 00 00 00 00	 call	 PyType_IsSubtype
  001f2	85 c0		 test	 eax, eax
  001f4	75 1c		 jne	 SHORT $LN39@replace_in
  001f6	41 b8 41 06 00
	00		 mov	 r8d, 1601		; 00000641H
  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00210	33 c0		 xor	 eax, eax
$LN39@replace_in:
  00212	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00217	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0021c	74 16		 je	 SHORT $LN40@replace_in
  0021e	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00223	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0022a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  00232	eb 0f		 jmp	 SHORT $LN41@replace_in
$LN40@replace_in:
  00234	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0023b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN41@replace_in:
  00243	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv155[rsp]
  0024b	48 89 44 24 40	 mov	 QWORD PTR result_s$[rsp], rax
$LN27@replace_in:

; 1602 : 
; 1603 :     /* TODO: special case single character, which doesn't need memcpy */
; 1604 : 
; 1605 :     /* Lay the first one down (guaranteed this will occur) */
; 1606 :     Py_MEMCPY(result_s, to_s, to_len);

  00250	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00258	48 89 44 24 70	 mov	 QWORD PTR n_$22959[rsp], rax
  0025d	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  00262	48 89 44 24 58	 mov	 QWORD PTR t_$22960[rsp], rax
  00267	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  0026f	48 89 44 24 60	 mov	 QWORD PTR s_$22962[rsp], rax
  00274	48 83 7c 24 70
	10		 cmp	 QWORD PTR n_$22959[rsp], 16
  0027a	72 16		 jb	 SHORT $LN24@replace_in
  0027c	4c 8b 44 24 70	 mov	 r8, QWORD PTR n_$22959[rsp]
  00281	48 8b 54 24 60	 mov	 rdx, QWORD PTR s_$22962[rsp]
  00286	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t_$22960[rsp]
  0028b	e8 00 00 00 00	 call	 memcpy
  00290	eb 4b		 jmp	 SHORT $LN23@replace_in
$LN24@replace_in:
  00292	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR i_$22958[rsp], 0
  0029b	eb 0d		 jmp	 SHORT $LN22@replace_in
$LN21@replace_in:
  0029d	48 8b 44 24 68	 mov	 rax, QWORD PTR i_$22958[rsp]
  002a2	48 ff c0	 inc	 rax
  002a5	48 89 44 24 68	 mov	 QWORD PTR i_$22958[rsp], rax
$LN22@replace_in:
  002aa	48 8b 44 24 70	 mov	 rax, QWORD PTR n_$22959[rsp]
  002af	48 39 44 24 68	 cmp	 QWORD PTR i_$22958[rsp], rax
  002b4	73 27		 jae	 SHORT $LN20@replace_in
  002b6	48 8b 44 24 68	 mov	 rax, QWORD PTR i_$22958[rsp]
  002bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t_$22960[rsp]
  002c0	48 03 c8	 add	 rcx, rax
  002c3	48 8b c1	 mov	 rax, rcx
  002c6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR i_$22958[rsp]
  002cb	48 8b 54 24 60	 mov	 rdx, QWORD PTR s_$22962[rsp]
  002d0	48 03 d1	 add	 rdx, rcx
  002d3	48 8b ca	 mov	 rcx, rdx
  002d6	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002d9	88 08		 mov	 BYTE PTR [rax], cl
  002db	eb c0		 jmp	 SHORT $LN21@replace_in
$LN20@replace_in:
$LN23@replace_in:
  002dd	33 c0		 xor	 eax, eax
  002df	85 c0		 test	 eax, eax
  002e1	0f 85 69 ff ff
	ff		 jne	 $LN27@replace_in

; 1607 :     result_s += to_len;

  002e7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  002ef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result_s$[rsp]
  002f4	48 03 c8	 add	 rcx, rax
  002f7	48 8b c1	 mov	 rax, rcx
  002fa	48 89 44 24 40	 mov	 QWORD PTR result_s$[rsp], rax

; 1608 :     count -= 1;

  002ff	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  00304	48 ff c8	 dec	 rax
  00307	48 89 44 24 28	 mov	 QWORD PTR count$[rsp], rax

; 1609 : 
; 1610 :     for (i=0; i<count; i++) {

  0030c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00315	eb 0d		 jmp	 SHORT $LN19@replace_in
$LN18@replace_in:
  00317	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0031c	48 ff c0	 inc	 rax
  0031f	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN19@replace_in:
  00324	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  00329	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0032e	0f 8d 04 01 00
	00		 jge	 $LN17@replace_in

; 1611 :         *result_s++ = *self_s++;

  00334	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  00339	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self_s$[rsp]
  0033e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00341	88 08		 mov	 BYTE PTR [rax], cl
  00343	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  00348	48 ff c0	 inc	 rax
  0034b	48 89 44 24 40	 mov	 QWORD PTR result_s$[rsp], rax
  00350	48 8b 44 24 50	 mov	 rax, QWORD PTR self_s$[rsp]
  00355	48 ff c0	 inc	 rax
  00358	48 89 44 24 50	 mov	 QWORD PTR self_s$[rsp], rax
$LN16@replace_in:

; 1612 :         Py_MEMCPY(result_s, to_s, to_len);

  0035d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00365	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR n_$22976[rsp], rax
  0036d	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  00372	48 89 44 24 78	 mov	 QWORD PTR t_$22977[rsp], rax
  00377	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  0037f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s_$22979[rsp], rax
  00387	48 83 bc 24 90
	00 00 00 10	 cmp	 QWORD PTR n_$22976[rsp], 16
  00390	72 1c		 jb	 SHORT $LN13@replace_in
  00392	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR n_$22976[rsp]
  0039a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s_$22979[rsp]
  003a2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR t_$22977[rsp]
  003a7	e8 00 00 00 00	 call	 memcpy
  003ac	eb 63		 jmp	 SHORT $LN12@replace_in
$LN13@replace_in:
  003ae	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$22975[rsp], 0
  003ba	eb 13		 jmp	 SHORT $LN11@replace_in
$LN10@replace_in:
  003bc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR i_$22975[rsp]
  003c4	48 ff c0	 inc	 rax
  003c7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR i_$22975[rsp], rax
$LN11@replace_in:
  003cf	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR n_$22976[rsp]
  003d7	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR i_$22975[rsp], rax
  003df	73 30		 jae	 SHORT $LN9@replace_in
  003e1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR i_$22975[rsp]
  003e9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR t_$22977[rsp]
  003ee	48 03 c8	 add	 rcx, rax
  003f1	48 8b c1	 mov	 rax, rcx
  003f4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR i_$22975[rsp]
  003fc	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s_$22979[rsp]
  00404	48 03 d1	 add	 rdx, rcx
  00407	48 8b ca	 mov	 rcx, rdx
  0040a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0040d	88 08		 mov	 BYTE PTR [rax], cl
  0040f	eb ab		 jmp	 SHORT $LN10@replace_in
$LN9@replace_in:
$LN12@replace_in:
  00411	33 c0		 xor	 eax, eax
  00413	85 c0		 test	 eax, eax
  00415	0f 85 42 ff ff
	ff		 jne	 $LN16@replace_in

; 1613 :         result_s += to_len;

  0041b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00423	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result_s$[rsp]
  00428	48 03 c8	 add	 rcx, rax
  0042b	48 8b c1	 mov	 rax, rcx
  0042e	48 89 44 24 40	 mov	 QWORD PTR result_s$[rsp], rax

; 1614 :     }

  00433	e9 df fe ff ff	 jmp	 $LN18@replace_in
$LN17@replace_in:
$LN8@replace_in:

; 1615 : 
; 1616 :     /* Copy the rest of the original string */
; 1617 :     Py_MEMCPY(result_s, self_s, self_len-i);

  00438	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0043d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR self_len$[rsp]
  00442	48 2b c8	 sub	 rcx, rax
  00445	48 8b c1	 mov	 rax, rcx
  00448	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR n_$22990[rsp], rax
  00450	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  00455	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR t_$22991[rsp], rax
  0045d	48 8b 44 24 50	 mov	 rax, QWORD PTR self_s$[rsp]
  00462	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR s_$22993[rsp], rax
  0046a	48 83 bc 24 b0
	00 00 00 10	 cmp	 QWORD PTR n_$22990[rsp], 16
  00473	72 1f		 jb	 SHORT $LN5@replace_in
  00475	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR n_$22990[rsp]
  0047d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s_$22993[rsp]
  00485	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR t_$22991[rsp]
  0048d	e8 00 00 00 00	 call	 memcpy
  00492	eb 66		 jmp	 SHORT $LN4@replace_in
$LN5@replace_in:
  00494	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$22989[rsp], 0
  004a0	eb 13		 jmp	 SHORT $LN3@replace_in
$LN2@replace_in:
  004a2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR i_$22989[rsp]
  004aa	48 ff c0	 inc	 rax
  004ad	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR i_$22989[rsp], rax
$LN3@replace_in:
  004b5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR n_$22990[rsp]
  004bd	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR i_$22989[rsp], rax
  004c5	73 33		 jae	 SHORT $LN1@replace_in
  004c7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR i_$22989[rsp]
  004cf	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR t_$22991[rsp]
  004d7	48 03 c8	 add	 rcx, rax
  004da	48 8b c1	 mov	 rax, rcx
  004dd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR i_$22989[rsp]
  004e5	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s_$22993[rsp]
  004ed	48 03 d1	 add	 rdx, rcx
  004f0	48 8b ca	 mov	 rcx, rdx
  004f3	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  004f6	88 08		 mov	 BYTE PTR [rax], cl
  004f8	eb a8		 jmp	 SHORT $LN2@replace_in
$LN1@replace_in:
$LN4@replace_in:
  004fa	33 c0		 xor	 eax, eax
  004fc	85 c0		 test	 eax, eax
  004fe	0f 85 34 ff ff
	ff		 jne	 $LN8@replace_in

; 1618 : 
; 1619 :     return result;

  00504	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
$LN32@replace_in:

; 1620 : }

  00509	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00510	c3		 ret	 0
replace_interleave ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BM@JMBDMDDM@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_delete_single_character DD imagerel replace_delete_single_character
	DD	imagerel replace_delete_single_character+1096
	DD	imagerel $unwind$replace_delete_single_character
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_delete_single_character DD 021501H
	DD	0190115H
xdata	ENDS
;	COMDAT ??_C@_1BM@JMBDMDDM@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@JMBDMDDM@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, '_', 00H
	DB	'l', 00H, 'e', 00H, 'n', 00H, '>', 00H, '=', 00H, '0', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT replace_delete_single_character
_TEXT	SEGMENT
result_len$ = 32
count$ = 40
self_len$ = 48
next$ = 56
end$ = 64
start$ = 72
result_s$ = 80
result$ = 88
self_s$ = 96
t_$23051 = 104
s_$23053 = 112
i_$23049 = 120
n_$23050 = 128
t_$23065 = 136
s_$23067 = 144
i_$23063 = 152
n_$23064 = 160
tv90 = 168
tv155 = 176
self$ = 208
from_c$ = 216
maxcount$ = 224
replace_delete_single_character PROC			; COMDAT

; 1627 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1628 :     char *self_s, *result_s;
; 1629 :     char *start, *next, *end;
; 1630 :     Py_ssize_t self_len, result_len;
; 1631 :     Py_ssize_t count;
; 1632 :     PyByteArrayObject *result;
; 1633 : 
; 1634 :     self_len = PyByteArray_GET_SIZE(self);

  00015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0001c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00024	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00028	74 38		 je	 SHORT $LN24@replace_de
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00031	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00039	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00042	85 c0		 test	 eax, eax
  00044	75 1c		 jne	 SHORT $LN24@replace_de
  00046	41 b8 62 06 00
	00		 mov	 r8d, 1634		; 00000662H
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00060	33 c0		 xor	 eax, eax
$LN24@replace_de:
  00062	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006e	48 89 44 24 30	 mov	 QWORD PTR self_len$[rsp], rax

; 1635 :     self_s = PyByteArray_AS_STRING(self);

  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0007a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00082	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00086	74 38		 je	 SHORT $LN25@replace_de
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0008f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00097	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0009b	e8 00 00 00 00	 call	 PyType_IsSubtype
  000a0	85 c0		 test	 eax, eax
  000a2	75 1c		 jne	 SHORT $LN25@replace_de
  000a4	41 b8 63 06 00
	00		 mov	 r8d, 1635		; 00000663H
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000be	33 c0		 xor	 eax, eax
$LN25@replace_de:
  000c0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000c8	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000cd	74 19		 je	 SHORT $LN26@replace_de
  000cf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000d7	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000de	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  000e6	eb 0f		 jmp	 SHORT $LN27@replace_de
$LN26@replace_de:
  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000ef	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
$LN27@replace_de:
  000f7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv90[rsp]
  000ff	48 89 44 24 60	 mov	 QWORD PTR self_s$[rsp], rax

; 1636 : 
; 1637 :     count = countchar(self_s, self_len, from_c, maxcount);

  00104	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR maxcount$[rsp]
  0010c	44 0f b6 84 24
	d8 00 00 00	 movzx	 r8d, BYTE PTR from_c$[rsp]
  00115	48 8b 54 24 30	 mov	 rdx, QWORD PTR self_len$[rsp]
  0011a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self_s$[rsp]
  0011f	e8 00 00 00 00	 call	 countchar
  00124	48 89 44 24 28	 mov	 QWORD PTR count$[rsp], rax

; 1638 :     if (count == 0) {

  00129	48 83 7c 24 28
	00		 cmp	 QWORD PTR count$[rsp], 0
  0012f	75 12		 jne	 SHORT $LN21@replace_de

; 1639 :         return return_self(self);

  00131	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00139	e8 00 00 00 00	 call	 return_self
  0013e	e9 fd 02 00 00	 jmp	 $LN22@replace_de
$LN21@replace_de:

; 1640 :     }
; 1641 : 
; 1642 :     result_len = self_len - count;  /* from_len == 1 */

  00143	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  00148	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self_len$[rsp]
  0014d	48 2b c8	 sub	 rcx, rax
  00150	48 8b c1	 mov	 rax, rcx
  00153	48 89 44 24 20	 mov	 QWORD PTR result_len$[rsp], rax

; 1643 :     assert(result_len>=0);

  00158	48 83 7c 24 20
	00		 cmp	 QWORD PTR result_len$[rsp], 0
  0015e	7d 1c		 jge	 SHORT $LN28@replace_de
  00160	41 b8 6b 06 00
	00		 mov	 r8d, 1643		; 0000066bH
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@JMBDMDDM@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0017a	33 c0		 xor	 eax, eax
$LN28@replace_de:

; 1644 : 
; 1645 :     if ( (result = (PyByteArrayObject *)
; 1646 :                     PyByteArray_FromStringAndSize(NULL, result_len)) == NULL)

  0017c	48 8b 54 24 20	 mov	 rdx, QWORD PTR result_len$[rsp]
  00181	33 c9		 xor	 ecx, ecx
  00183	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00188	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax
  0018d	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  00193	75 07		 jne	 SHORT $LN20@replace_de

; 1647 :         return NULL;

  00195	33 c0		 xor	 eax, eax
  00197	e9 a4 02 00 00	 jmp	 $LN22@replace_de
$LN20@replace_de:

; 1648 :     result_s = PyByteArray_AS_STRING(result);

  0019c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  001a8	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001ac	74 35		 je	 SHORT $LN29@replace_de
  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001b5	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001ba	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001be	e8 00 00 00 00	 call	 PyType_IsSubtype
  001c3	85 c0		 test	 eax, eax
  001c5	75 1c		 jne	 SHORT $LN29@replace_de
  001c7	41 b8 70 06 00
	00		 mov	 r8d, 1648		; 00000670H
  001cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001e1	33 c0		 xor	 eax, eax
$LN29@replace_de:
  001e3	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001e8	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001ed	74 16		 je	 SHORT $LN30@replace_de
  001ef	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001f4	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  001fb	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  00203	eb 0f		 jmp	 SHORT $LN31@replace_de
$LN30@replace_de:
  00205	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0020c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN31@replace_de:
  00214	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv155[rsp]
  0021c	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax

; 1649 : 
; 1650 :     start = self_s;

  00221	48 8b 44 24 60	 mov	 rax, QWORD PTR self_s$[rsp]
  00226	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1651 :     end = self_s + self_len;

  0022b	48 8b 44 24 30	 mov	 rax, QWORD PTR self_len$[rsp]
  00230	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self_s$[rsp]
  00235	48 03 c8	 add	 rcx, rax
  00238	48 8b c1	 mov	 rax, rcx
  0023b	48 89 44 24 40	 mov	 QWORD PTR end$[rsp], rax
$LN19@replace_de:

; 1652 :     while (count-- > 0) {

  00240	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  00245	48 8b 4c 24 28	 mov	 rcx, QWORD PTR count$[rsp]
  0024a	48 ff c9	 dec	 rcx
  0024d	48 89 4c 24 28	 mov	 QWORD PTR count$[rsp], rcx
  00252	48 85 c0	 test	 rax, rax
  00255	0f 8e 14 01 00
	00		 jle	 $LN18@replace_de

; 1653 :         next = findchar(start, end-start, from_c);

  0025b	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00260	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  00265	48 2b c8	 sub	 rcx, rax
  00268	48 8b c1	 mov	 rax, rcx
  0026b	0f be 8c 24 d8
	00 00 00	 movsx	 ecx, BYTE PTR from_c$[rsp]
  00273	4c 8b c0	 mov	 r8, rax
  00276	8b d1		 mov	 edx, ecx
  00278	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00283	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 1654 :         if (next == NULL)

  00288	48 83 7c 24 38
	00		 cmp	 QWORD PTR next$[rsp], 0
  0028e	75 05		 jne	 SHORT $LN17@replace_de

; 1655 :             break;

  00290	e9 da 00 00 00	 jmp	 $LN18@replace_de
$LN17@replace_de:
$LN16@replace_de:

; 1656 :         Py_MEMCPY(result_s, start, next-start);

  00295	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  0029a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  0029f	48 2b c8	 sub	 rcx, rax
  002a2	48 8b c1	 mov	 rax, rcx
  002a5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n_$23050[rsp], rax
  002ad	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  002b2	48 89 44 24 68	 mov	 QWORD PTR t_$23051[rsp], rax
  002b7	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  002bc	48 89 44 24 70	 mov	 QWORD PTR s_$23053[rsp], rax
  002c1	48 83 bc 24 80
	00 00 00 10	 cmp	 QWORD PTR n_$23050[rsp], 16
  002ca	72 19		 jb	 SHORT $LN13@replace_de
  002cc	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR n_$23050[rsp]
  002d4	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23053[rsp]
  002d9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23051[rsp]
  002de	e8 00 00 00 00	 call	 memcpy
  002e3	eb 4e		 jmp	 SHORT $LN12@replace_de
$LN13@replace_de:
  002e5	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i_$23049[rsp], 0
  002ee	eb 0d		 jmp	 SHORT $LN11@replace_de
$LN10@replace_de:
  002f0	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23049[rsp]
  002f5	48 ff c0	 inc	 rax
  002f8	48 89 44 24 78	 mov	 QWORD PTR i_$23049[rsp], rax
$LN11@replace_de:
  002fd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n_$23050[rsp]
  00305	48 39 44 24 78	 cmp	 QWORD PTR i_$23049[rsp], rax
  0030a	73 27		 jae	 SHORT $LN9@replace_de
  0030c	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23049[rsp]
  00311	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23051[rsp]
  00316	48 03 c8	 add	 rcx, rax
  00319	48 8b c1	 mov	 rax, rcx
  0031c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i_$23049[rsp]
  00321	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23053[rsp]
  00326	48 03 d1	 add	 rdx, rcx
  00329	48 8b ca	 mov	 rcx, rdx
  0032c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0032f	88 08		 mov	 BYTE PTR [rax], cl
  00331	eb bd		 jmp	 SHORT $LN10@replace_de
$LN9@replace_de:
$LN12@replace_de:
  00333	33 c0		 xor	 eax, eax
  00335	85 c0		 test	 eax, eax
  00337	0f 85 58 ff ff
	ff		 jne	 $LN16@replace_de

; 1657 :         result_s += (next-start);

  0033d	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00342	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  00347	48 2b c8	 sub	 rcx, rax
  0034a	48 8b c1	 mov	 rax, rcx
  0034d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  00352	48 03 c8	 add	 rcx, rax
  00355	48 8b c1	 mov	 rax, rcx
  00358	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax

; 1658 :         start = next+1;

  0035d	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  00362	48 ff c0	 inc	 rax
  00365	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1659 :     }

  0036a	e9 d1 fe ff ff	 jmp	 $LN19@replace_de
$LN18@replace_de:
$LN8@replace_de:

; 1660 :     Py_MEMCPY(result_s, start, end-start);

  0036f	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00374	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  00379	48 2b c8	 sub	 rcx, rax
  0037c	48 8b c1	 mov	 rax, rcx
  0037f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR n_$23064[rsp], rax
  00387	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  0038c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR t_$23065[rsp], rax
  00394	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00399	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR s_$23067[rsp], rax
  003a1	48 83 bc 24 a0
	00 00 00 10	 cmp	 QWORD PTR n_$23064[rsp], 16
  003aa	72 1f		 jb	 SHORT $LN5@replace_de
  003ac	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR n_$23064[rsp]
  003b4	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23067[rsp]
  003bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23065[rsp]
  003c4	e8 00 00 00 00	 call	 memcpy
  003c9	eb 66		 jmp	 SHORT $LN4@replace_de
$LN5@replace_de:
  003cb	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23063[rsp], 0
  003d7	eb 13		 jmp	 SHORT $LN3@replace_de
$LN2@replace_de:
  003d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23063[rsp]
  003e1	48 ff c0	 inc	 rax
  003e4	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR i_$23063[rsp], rax
$LN3@replace_de:
  003ec	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR n_$23064[rsp]
  003f4	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR i_$23063[rsp], rax
  003fc	73 33		 jae	 SHORT $LN1@replace_de
  003fe	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23063[rsp]
  00406	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23065[rsp]
  0040e	48 03 c8	 add	 rcx, rax
  00411	48 8b c1	 mov	 rax, rcx
  00414	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR i_$23063[rsp]
  0041c	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23067[rsp]
  00424	48 03 d1	 add	 rdx, rcx
  00427	48 8b ca	 mov	 rcx, rdx
  0042a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0042d	88 08		 mov	 BYTE PTR [rax], cl
  0042f	eb a8		 jmp	 SHORT $LN2@replace_de
$LN1@replace_de:
$LN4@replace_de:
  00431	33 c0		 xor	 eax, eax
  00433	85 c0		 test	 eax, eax
  00435	0f 85 34 ff ff
	ff		 jne	 $LN8@replace_de

; 1661 : 
; 1662 :     return result;

  0043b	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
$LN22@replace_de:

; 1663 : }

  00440	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00447	c3		 ret	 0
replace_delete_single_character ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$countchar DD imagerel countchar
	DD	imagerel countchar+166
	DD	imagerel $unwind$countchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$countchar DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT countchar
_TEXT	SEGMENT
count$ = 32
end$ = 40
start$ = 48
target$ = 80
target_len$ = 88
c$ = 96
maxcount$ = 104
countchar PROC						; COMDAT

; 1548 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1549 :     Py_ssize_t count=0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 1550 :     const char *start=target;

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR target$[rsp]
  00026	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax

; 1551 :     const char *end=target+target_len;

  0002b	48 8b 44 24 58	 mov	 rax, QWORD PTR target_len$[rsp]
  00030	48 8b 4c 24 50	 mov	 rcx, QWORD PTR target$[rsp]
  00035	48 03 c8	 add	 rcx, rax
  00038	48 8b c1	 mov	 rax, rcx
  0003b	48 89 44 24 28	 mov	 QWORD PTR end$[rsp], rax
$LN3@countchar:

; 1552 : 
; 1553 :     while ( (start=findchar(start, end-start, c)) != NULL ) {

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR start$[rsp]
  00045	48 8b 4c 24 28	 mov	 rcx, QWORD PTR end$[rsp]
  0004a	48 2b c8	 sub	 rcx, rax
  0004d	48 8b c1	 mov	 rax, rcx
  00050	0f be 4c 24 60	 movsx	 ecx, BYTE PTR c$[rsp]
  00055	4c 8b c0	 mov	 r8, rax
  00058	8b d1		 mov	 edx, ecx
  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR start$[rsp]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00065	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax
  0006a	48 83 7c 24 30
	00		 cmp	 QWORD PTR start$[rsp], 0
  00070	74 2a		 je	 SHORT $LN2@countchar

; 1554 :         count++;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00077	48 ff c0	 inc	 rax
  0007a	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 1555 :         if (count >= maxcount)

  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR maxcount$[rsp]
  00084	48 39 44 24 20	 cmp	 QWORD PTR count$[rsp], rax
  00089	7c 02		 jl	 SHORT $LN1@countchar

; 1556 :             break;

  0008b	eb 0f		 jmp	 SHORT $LN2@countchar
$LN1@countchar:

; 1557 :         start += 1;

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR start$[rsp]
  00092	48 ff c0	 inc	 rax
  00095	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax

; 1558 :     }

  0009a	eb a4		 jmp	 SHORT $LN3@countchar
$LN2@countchar:

; 1559 :     return count;

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]

; 1560 : }

  000a1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a5	c3		 ret	 0
countchar ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_delete_substring DD imagerel replace_delete_substring
	DD	imagerel replace_delete_substring+1205
	DD	imagerel $unwind$replace_delete_substring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_delete_substring DD 021b01H
	DD	01b011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace_delete_substring
_TEXT	SEGMENT
result_len$ = 48
count$ = 56
self_len$ = 64
offset$ = 72
next$ = 80
end$ = 88
start$ = 96
result_s$ = 104
result$ = 112
self_s$ = 120
t_$23124 = 128
s_$23126 = 136
i_$23122 = 144
n_$23123 = 152
t_$23138 = 160
s_$23140 = 168
i_$23136 = 176
n_$23137 = 184
tv90 = 192
tv157 = 200
self$ = 224
from_s$ = 232
from_len$ = 240
maxcount$ = 248
replace_delete_substring PROC				; COMDAT

; 1671 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1672 :     char *self_s, *result_s;
; 1673 :     char *start, *next, *end;
; 1674 :     Py_ssize_t self_len, result_len;
; 1675 :     Py_ssize_t count, offset;
; 1676 :     PyByteArrayObject *result;
; 1677 : 
; 1678 :     self_len = PyByteArray_GET_SIZE(self);

  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0002a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002e	74 38		 je	 SHORT $LN24@replace_de@2
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00037	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00043	e8 00 00 00 00	 call	 PyType_IsSubtype
  00048	85 c0		 test	 eax, eax
  0004a	75 1c		 jne	 SHORT $LN24@replace_de@2
  0004c	41 b8 8e 06 00
	00		 mov	 r8d, 1678		; 0000068eH
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00066	33 c0		 xor	 eax, eax
$LN24@replace_de@2:
  00068	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00070	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00074	48 89 44 24 40	 mov	 QWORD PTR self_len$[rsp], rax

; 1679 :     self_s = PyByteArray_AS_STRING(self);

  00079	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00080	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00088	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0008c	74 38		 je	 SHORT $LN25@replace_de@2
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00095	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0009d	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000a1	e8 00 00 00 00	 call	 PyType_IsSubtype
  000a6	85 c0		 test	 eax, eax
  000a8	75 1c		 jne	 SHORT $LN25@replace_de@2
  000aa	41 b8 8f 06 00
	00		 mov	 r8d, 1679		; 0000068fH
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c4	33 c0		 xor	 eax, eax
$LN25@replace_de@2:
  000c6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000ce	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000d3	74 19		 je	 SHORT $LN26@replace_de@2
  000d5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000dd	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000e4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  000ec	eb 0f		 jmp	 SHORT $LN27@replace_de@2
$LN26@replace_de@2:
  000ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000f5	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
$LN27@replace_de@2:
  000fd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv90[rsp]
  00105	48 89 44 24 78	 mov	 QWORD PTR self_s$[rsp], rax

; 1680 : 
; 1681 :     count = stringlib_count(self_s, self_len,
; 1682 :                             from_s, from_len,
; 1683 :                             maxcount);

  0010a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00112	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00117	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  0011f	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  00127	48 8b 54 24 40	 mov	 rdx, QWORD PTR self_len$[rsp]
  0012c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self_s$[rsp]
  00131	e8 00 00 00 00	 call	 stringlib_count
  00136	48 89 44 24 38	 mov	 QWORD PTR count$[rsp], rax

; 1684 : 
; 1685 :     if (count == 0) {

  0013b	48 83 7c 24 38
	00		 cmp	 QWORD PTR count$[rsp], 0
  00141	75 12		 jne	 SHORT $LN21@replace_de@2

; 1686 :         /* no matches */
; 1687 :         return return_self(self);

  00143	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0014b	e8 00 00 00 00	 call	 return_self
  00150	e9 58 03 00 00	 jmp	 $LN22@replace_de@2
$LN21@replace_de@2:

; 1688 :     }
; 1689 : 
; 1690 :     result_len = self_len - (count * from_len);

  00155	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  0015a	48 0f af 84 24
	f0 00 00 00	 imul	 rax, QWORD PTR from_len$[rsp]
  00163	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self_len$[rsp]
  00168	48 2b c8	 sub	 rcx, rax
  0016b	48 8b c1	 mov	 rax, rcx
  0016e	48 89 44 24 30	 mov	 QWORD PTR result_len$[rsp], rax

; 1691 :     assert (result_len>=0);

  00173	48 83 7c 24 30
	00		 cmp	 QWORD PTR result_len$[rsp], 0
  00179	7d 1c		 jge	 SHORT $LN28@replace_de@2
  0017b	41 b8 9b 06 00
	00		 mov	 r8d, 1691		; 0000069bH
  00181	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@JMBDMDDM@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00195	33 c0		 xor	 eax, eax
$LN28@replace_de@2:

; 1692 : 
; 1693 :     if ( (result = (PyByteArrayObject *)
; 1694 :         PyByteArray_FromStringAndSize(NULL, result_len)) == NULL )

  00197	48 8b 54 24 30	 mov	 rdx, QWORD PTR result_len$[rsp]
  0019c	33 c9		 xor	 ecx, ecx
  0019e	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  001a3	48 89 44 24 70	 mov	 QWORD PTR result$[rsp], rax
  001a8	48 83 7c 24 70
	00		 cmp	 QWORD PTR result$[rsp], 0
  001ae	75 07		 jne	 SHORT $LN20@replace_de@2

; 1695 :             return NULL;

  001b0	33 c0		 xor	 eax, eax
  001b2	e9 f6 02 00 00	 jmp	 $LN22@replace_de@2
$LN20@replace_de@2:

; 1696 : 
; 1697 :     result_s = PyByteArray_AS_STRING(result);

  001b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result$[rsp]
  001c3	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001c7	74 35		 je	 SHORT $LN29@replace_de@2
  001c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001d0	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  001d5	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001d9	e8 00 00 00 00	 call	 PyType_IsSubtype
  001de	85 c0		 test	 eax, eax
  001e0	75 1c		 jne	 SHORT $LN29@replace_de@2
  001e2	41 b8 a1 06 00
	00		 mov	 r8d, 1697		; 000006a1H
  001e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001fc	33 c0		 xor	 eax, eax
$LN29@replace_de@2:
  001fe	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  00203	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00208	74 16		 je	 SHORT $LN30@replace_de@2
  0020a	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  0020f	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00216	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv157[rsp], rax
  0021e	eb 0f		 jmp	 SHORT $LN31@replace_de@2
$LN30@replace_de@2:
  00220	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00227	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv157[rsp], rax
$LN31@replace_de@2:
  0022f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv157[rsp]
  00237	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax

; 1698 : 
; 1699 :     start = self_s;

  0023c	48 8b 44 24 78	 mov	 rax, QWORD PTR self_s$[rsp]
  00241	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax

; 1700 :     end = self_s + self_len;

  00246	48 8b 44 24 40	 mov	 rax, QWORD PTR self_len$[rsp]
  0024b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self_s$[rsp]
  00250	48 03 c8	 add	 rcx, rax
  00253	48 8b c1	 mov	 rax, rcx
  00256	48 89 44 24 58	 mov	 QWORD PTR end$[rsp], rax
$LN19@replace_de@2:

; 1701 :     while (count-- > 0) {

  0025b	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  00260	48 8b 4c 24 38	 mov	 rcx, QWORD PTR count$[rsp]
  00265	48 ff c9	 dec	 rcx
  00268	48 89 4c 24 38	 mov	 QWORD PTR count$[rsp], rcx
  0026d	48 85 c0	 test	 rax, rax
  00270	0f 8e 66 01 00
	00		 jle	 $LN18@replace_de@2

; 1702 :         offset = stringlib_find(start, end-start,
; 1703 :                                 from_s, from_len,
; 1704 :                                 0);

  00276	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0027b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR end$[rsp]
  00280	48 2b c8	 sub	 rcx, rax
  00283	48 8b c1	 mov	 rax, rcx
  00286	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0028f	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  00297	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  0029f	48 8b d0	 mov	 rdx, rax
  002a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  002a7	e8 00 00 00 00	 call	 stringlib_find
  002ac	48 89 44 24 48	 mov	 QWORD PTR offset$[rsp], rax

; 1705 :         if (offset == -1)

  002b1	48 83 7c 24 48
	ff		 cmp	 QWORD PTR offset$[rsp], -1
  002b7	75 05		 jne	 SHORT $LN17@replace_de@2

; 1706 :             break;

  002b9	e9 1e 01 00 00	 jmp	 $LN18@replace_de@2
$LN17@replace_de@2:

; 1707 :         next = start + offset;

  002be	48 8b 44 24 48	 mov	 rax, QWORD PTR offset$[rsp]
  002c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  002c8	48 03 c8	 add	 rcx, rax
  002cb	48 8b c1	 mov	 rax, rcx
  002ce	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
$LN16@replace_de@2:

; 1708 : 
; 1709 :         Py_MEMCPY(result_s, start, next-start);

  002d3	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  002d8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  002dd	48 2b c8	 sub	 rcx, rax
  002e0	48 8b c1	 mov	 rax, rcx
  002e3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR n_$23123[rsp], rax
  002eb	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  002f0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR t_$23124[rsp], rax
  002f8	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  002fd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s_$23126[rsp], rax
  00305	48 83 bc 24 98
	00 00 00 10	 cmp	 QWORD PTR n_$23123[rsp], 16
  0030e	72 1f		 jb	 SHORT $LN13@replace_de@2
  00310	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR n_$23123[rsp]
  00318	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s_$23126[rsp]
  00320	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t_$23124[rsp]
  00328	e8 00 00 00 00	 call	 memcpy
  0032d	eb 66		 jmp	 SHORT $LN12@replace_de@2
$LN13@replace_de@2:
  0032f	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23122[rsp], 0
  0033b	eb 13		 jmp	 SHORT $LN11@replace_de@2
$LN10@replace_de@2:
  0033d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i_$23122[rsp]
  00345	48 ff c0	 inc	 rax
  00348	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR i_$23122[rsp], rax
$LN11@replace_de@2:
  00350	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n_$23123[rsp]
  00358	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR i_$23122[rsp], rax
  00360	73 33		 jae	 SHORT $LN9@replace_de@2
  00362	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i_$23122[rsp]
  0036a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t_$23124[rsp]
  00372	48 03 c8	 add	 rcx, rax
  00375	48 8b c1	 mov	 rax, rcx
  00378	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR i_$23122[rsp]
  00380	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s_$23126[rsp]
  00388	48 03 d1	 add	 rdx, rcx
  0038b	48 8b ca	 mov	 rcx, rdx
  0038e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00391	88 08		 mov	 BYTE PTR [rax], cl
  00393	eb a8		 jmp	 SHORT $LN10@replace_de@2
$LN9@replace_de@2:
$LN12@replace_de@2:
  00395	33 c0		 xor	 eax, eax
  00397	85 c0		 test	 eax, eax
  00399	0f 85 34 ff ff
	ff		 jne	 $LN16@replace_de@2

; 1710 : 
; 1711 :         result_s += (next-start);

  0039f	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  003a4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  003a9	48 2b c8	 sub	 rcx, rax
  003ac	48 8b c1	 mov	 rax, rcx
  003af	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result_s$[rsp]
  003b4	48 03 c8	 add	 rcx, rax
  003b7	48 8b c1	 mov	 rax, rcx
  003ba	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax

; 1712 :         start = next+from_len;

  003bf	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  003c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  003cc	48 03 c8	 add	 rcx, rax
  003cf	48 8b c1	 mov	 rax, rcx
  003d2	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax

; 1713 :     }

  003d7	e9 7f fe ff ff	 jmp	 $LN19@replace_de@2
$LN18@replace_de@2:
$LN8@replace_de@2:

; 1714 :     Py_MEMCPY(result_s, start, end-start);

  003dc	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  003e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR end$[rsp]
  003e6	48 2b c8	 sub	 rcx, rax
  003e9	48 8b c1	 mov	 rax, rcx
  003ec	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR n_$23137[rsp], rax
  003f4	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  003f9	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR t_$23138[rsp], rax
  00401	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00406	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s_$23140[rsp], rax
  0040e	48 83 bc 24 b8
	00 00 00 10	 cmp	 QWORD PTR n_$23137[rsp], 16
  00417	72 1f		 jb	 SHORT $LN5@replace_de@2
  00419	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR n_$23137[rsp]
  00421	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR s_$23140[rsp]
  00429	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR t_$23138[rsp]
  00431	e8 00 00 00 00	 call	 memcpy
  00436	eb 66		 jmp	 SHORT $LN4@replace_de@2
$LN5@replace_de@2:
  00438	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23136[rsp], 0
  00444	eb 13		 jmp	 SHORT $LN3@replace_de@2
$LN2@replace_de@2:
  00446	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i_$23136[rsp]
  0044e	48 ff c0	 inc	 rax
  00451	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR i_$23136[rsp], rax
$LN3@replace_de@2:
  00459	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n_$23137[rsp]
  00461	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR i_$23136[rsp], rax
  00469	73 33		 jae	 SHORT $LN1@replace_de@2
  0046b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i_$23136[rsp]
  00473	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR t_$23138[rsp]
  0047b	48 03 c8	 add	 rcx, rax
  0047e	48 8b c1	 mov	 rax, rcx
  00481	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR i_$23136[rsp]
  00489	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR s_$23140[rsp]
  00491	48 03 d1	 add	 rdx, rcx
  00494	48 8b ca	 mov	 rcx, rdx
  00497	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0049a	88 08		 mov	 BYTE PTR [rax], cl
  0049c	eb a8		 jmp	 SHORT $LN2@replace_de@2
$LN1@replace_de@2:
$LN4@replace_de@2:
  0049e	33 c0		 xor	 eax, eax
  004a0	85 c0		 test	 eax, eax
  004a2	0f 85 34 ff ff
	ff		 jne	 $LN8@replace_de@2

; 1715 :     return result;

  004a8	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
$LN22@replace_de@2:

; 1716 : }

  004ad	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  004b4	c3		 ret	 0
replace_delete_substring ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_single_character_in_place DD imagerel replace_single_character_in_place
	DD	imagerel replace_single_character_in_place+832
	DD	imagerel $unwind$replace_single_character_in_place
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_single_character_in_place DD 021a01H
	DD	013011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace_single_character_in_place
_TEXT	SEGMENT
self_len$ = 32
next$ = 40
end$ = 48
start$ = 56
result_s$ = 64
result$ = 72
self_s$ = 80
t_$23192 = 88
s_$23194 = 96
i_$23190 = 104
n_$23191 = 112
tv78 = 120
tv149 = 128
self$ = 160
from_c$ = 168
to_c$ = 176
maxcount$ = 184
replace_single_character_in_place PROC			; COMDAT

; 1723 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1724 :     char *self_s, *result_s, *start, *end, *next;
; 1725 :     Py_ssize_t self_len;
; 1726 :     PyByteArrayObject *result;
; 1727 : 
; 1728 :     /* The result string will be the same size */
; 1729 :     self_s = PyByteArray_AS_STRING(self);

  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00021	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00029	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002d	74 38		 je	 SHORT $LN16@replace_si
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00036	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 1c		 jne	 SHORT $LN16@replace_si
  0004b	41 b8 c1 06 00
	00		 mov	 r8d, 1729		; 000006c1H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00065	33 c0		 xor	 eax, eax
$LN16@replace_si:
  00067	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00074	74 16		 je	 SHORT $LN17@replace_si
  00076	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0007e	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00085	48 89 44 24 78	 mov	 QWORD PTR tv78[rsp], rax
  0008a	eb 0c		 jmp	 SHORT $LN18@replace_si
$LN17@replace_si:
  0008c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00093	48 89 44 24 78	 mov	 QWORD PTR tv78[rsp], rax
$LN18@replace_si:
  00098	48 8b 44 24 78	 mov	 rax, QWORD PTR tv78[rsp]
  0009d	48 89 44 24 50	 mov	 QWORD PTR self_s$[rsp], rax

; 1730 :     self_len = PyByteArray_GET_SIZE(self);

  000a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000a9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000b1	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000b5	74 38		 je	 SHORT $LN19@replace_si
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000be	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000c6	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000ca	e8 00 00 00 00	 call	 PyType_IsSubtype
  000cf	85 c0		 test	 eax, eax
  000d1	75 1c		 jne	 SHORT $LN19@replace_si
  000d3	41 b8 c2 06 00
	00		 mov	 r8d, 1730		; 000006c2H
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ed	33 c0		 xor	 eax, eax
$LN19@replace_si:
  000ef	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000f7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000fb	48 89 44 24 20	 mov	 QWORD PTR self_len$[rsp], rax

; 1731 : 
; 1732 :     next = findchar(self_s, self_len, from_c);

  00100	0f be 84 24 a8
	00 00 00	 movsx	 eax, BYTE PTR from_c$[rsp]
  00108	4c 8b 44 24 20	 mov	 r8, QWORD PTR self_len$[rsp]
  0010d	8b d0		 mov	 edx, eax
  0010f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self_s$[rsp]
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0011a	48 89 44 24 28	 mov	 QWORD PTR next$[rsp], rax

; 1733 : 
; 1734 :     if (next == NULL) {

  0011f	48 83 7c 24 28
	00		 cmp	 QWORD PTR next$[rsp], 0
  00125	75 12		 jne	 SHORT $LN13@replace_si

; 1735 :         /* No matches; return the original bytes */
; 1736 :         return return_self(self);

  00127	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0012f	e8 00 00 00 00	 call	 return_self
  00134	e9 ff 01 00 00	 jmp	 $LN14@replace_si
$LN13@replace_si:

; 1737 :     }
; 1738 : 
; 1739 :     /* Need to make a new bytes */
; 1740 :     result = (PyByteArrayObject *) PyByteArray_FromStringAndSize(NULL, self_len);

  00139	48 8b 54 24 20	 mov	 rdx, QWORD PTR self_len$[rsp]
  0013e	33 c9		 xor	 ecx, ecx
  00140	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00145	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 1741 :     if (result == NULL)

  0014a	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  00150	75 07		 jne	 SHORT $LN12@replace_si

; 1742 :         return NULL;

  00152	33 c0		 xor	 eax, eax
  00154	e9 df 01 00 00	 jmp	 $LN14@replace_si
$LN12@replace_si:

; 1743 :     result_s = PyByteArray_AS_STRING(result);

  00159	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00160	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00165	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00169	74 35		 je	 SHORT $LN20@replace_si
  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00172	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00177	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0017b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00180	85 c0		 test	 eax, eax
  00182	75 1c		 jne	 SHORT $LN20@replace_si
  00184	41 b8 cf 06 00
	00		 mov	 r8d, 1743		; 000006cfH
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0019e	33 c0		 xor	 eax, eax
$LN20@replace_si:
  001a0	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  001a5	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001aa	74 16		 je	 SHORT $LN21@replace_si
  001ac	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  001b1	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  001b8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv149[rsp], rax
  001c0	eb 0f		 jmp	 SHORT $LN22@replace_si
$LN21@replace_si:
  001c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  001c9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv149[rsp], rax
$LN22@replace_si:
  001d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv149[rsp]
  001d9	48 89 44 24 40	 mov	 QWORD PTR result_s$[rsp], rax
$LN11@replace_si:

; 1744 :     Py_MEMCPY(result_s, self_s, self_len);

  001de	48 8b 44 24 20	 mov	 rax, QWORD PTR self_len$[rsp]
  001e3	48 89 44 24 70	 mov	 QWORD PTR n_$23191[rsp], rax
  001e8	48 8b 44 24 40	 mov	 rax, QWORD PTR result_s$[rsp]
  001ed	48 89 44 24 58	 mov	 QWORD PTR t_$23192[rsp], rax
  001f2	48 8b 44 24 50	 mov	 rax, QWORD PTR self_s$[rsp]
  001f7	48 89 44 24 60	 mov	 QWORD PTR s_$23194[rsp], rax
  001fc	48 83 7c 24 70
	10		 cmp	 QWORD PTR n_$23191[rsp], 16
  00202	72 16		 jb	 SHORT $LN8@replace_si
  00204	4c 8b 44 24 70	 mov	 r8, QWORD PTR n_$23191[rsp]
  00209	48 8b 54 24 60	 mov	 rdx, QWORD PTR s_$23194[rsp]
  0020e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t_$23192[rsp]
  00213	e8 00 00 00 00	 call	 memcpy
  00218	eb 4b		 jmp	 SHORT $LN7@replace_si
$LN8@replace_si:
  0021a	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR i_$23190[rsp], 0
  00223	eb 0d		 jmp	 SHORT $LN6@replace_si
$LN5@replace_si:
  00225	48 8b 44 24 68	 mov	 rax, QWORD PTR i_$23190[rsp]
  0022a	48 ff c0	 inc	 rax
  0022d	48 89 44 24 68	 mov	 QWORD PTR i_$23190[rsp], rax
$LN6@replace_si:
  00232	48 8b 44 24 70	 mov	 rax, QWORD PTR n_$23191[rsp]
  00237	48 39 44 24 68	 cmp	 QWORD PTR i_$23190[rsp], rax
  0023c	73 27		 jae	 SHORT $LN4@replace_si
  0023e	48 8b 44 24 68	 mov	 rax, QWORD PTR i_$23190[rsp]
  00243	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t_$23192[rsp]
  00248	48 03 c8	 add	 rcx, rax
  0024b	48 8b c1	 mov	 rax, rcx
  0024e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR i_$23190[rsp]
  00253	48 8b 54 24 60	 mov	 rdx, QWORD PTR s_$23194[rsp]
  00258	48 03 d1	 add	 rdx, rcx
  0025b	48 8b ca	 mov	 rcx, rdx
  0025e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00261	88 08		 mov	 BYTE PTR [rax], cl
  00263	eb c0		 jmp	 SHORT $LN5@replace_si
$LN4@replace_si:
$LN7@replace_si:
  00265	33 c0		 xor	 eax, eax
  00267	85 c0		 test	 eax, eax
  00269	0f 85 6f ff ff
	ff		 jne	 $LN11@replace_si

; 1745 : 
; 1746 :     /* change everything in-place, starting with this one */
; 1747 :     start =  result_s + (next-self_s);

  0026f	48 8b 44 24 50	 mov	 rax, QWORD PTR self_s$[rsp]
  00274	48 8b 4c 24 28	 mov	 rcx, QWORD PTR next$[rsp]
  00279	48 2b c8	 sub	 rcx, rax
  0027c	48 8b c1	 mov	 rax, rcx
  0027f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result_s$[rsp]
  00284	48 03 c8	 add	 rcx, rax
  00287	48 8b c1	 mov	 rax, rcx
  0028a	48 89 44 24 38	 mov	 QWORD PTR start$[rsp], rax

; 1748 :     *start = to_c;

  0028f	48 8b 44 24 38	 mov	 rax, QWORD PTR start$[rsp]
  00294	0f b6 8c 24 b0
	00 00 00	 movzx	 ecx, BYTE PTR to_c$[rsp]
  0029c	88 08		 mov	 BYTE PTR [rax], cl

; 1749 :     start++;

  0029e	48 8b 44 24 38	 mov	 rax, QWORD PTR start$[rsp]
  002a3	48 ff c0	 inc	 rax
  002a6	48 89 44 24 38	 mov	 QWORD PTR start$[rsp], rax

; 1750 :     end = result_s + self_len;

  002ab	48 8b 44 24 20	 mov	 rax, QWORD PTR self_len$[rsp]
  002b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result_s$[rsp]
  002b5	48 03 c8	 add	 rcx, rax
  002b8	48 8b c1	 mov	 rax, rcx
  002bb	48 89 44 24 30	 mov	 QWORD PTR end$[rsp], rax
$LN3@replace_si:

; 1751 : 
; 1752 :     while (--maxcount > 0) {

  002c0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  002c8	48 ff c8	 dec	 rax
  002cb	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR maxcount$[rsp], rax
  002d3	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR maxcount$[rsp], 0
  002dc	7e 55		 jle	 SHORT $LN2@replace_si

; 1753 :         next = findchar(start, end-start, from_c);

  002de	48 8b 44 24 38	 mov	 rax, QWORD PTR start$[rsp]
  002e3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR end$[rsp]
  002e8	48 2b c8	 sub	 rcx, rax
  002eb	48 8b c1	 mov	 rax, rcx
  002ee	0f be 8c 24 a8
	00 00 00	 movsx	 ecx, BYTE PTR from_c$[rsp]
  002f6	4c 8b c0	 mov	 r8, rax
  002f9	8b d1		 mov	 edx, ecx
  002fb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR start$[rsp]
  00300	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00306	48 89 44 24 28	 mov	 QWORD PTR next$[rsp], rax

; 1754 :         if (next == NULL)

  0030b	48 83 7c 24 28
	00		 cmp	 QWORD PTR next$[rsp], 0
  00311	75 02		 jne	 SHORT $LN1@replace_si

; 1755 :             break;

  00313	eb 1e		 jmp	 SHORT $LN2@replace_si
$LN1@replace_si:

; 1756 :         *next = to_c;

  00315	48 8b 44 24 28	 mov	 rax, QWORD PTR next$[rsp]
  0031a	0f b6 8c 24 b0
	00 00 00	 movzx	 ecx, BYTE PTR to_c$[rsp]
  00322	88 08		 mov	 BYTE PTR [rax], cl

; 1757 :         start = next+1;

  00324	48 8b 44 24 28	 mov	 rax, QWORD PTR next$[rsp]
  00329	48 ff c0	 inc	 rax
  0032c	48 89 44 24 38	 mov	 QWORD PTR start$[rsp], rax

; 1758 :     }

  00331	eb 8d		 jmp	 SHORT $LN3@replace_si
$LN2@replace_si:

; 1759 : 
; 1760 :     return result;

  00333	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
$LN14@replace_si:

; 1761 : }

  00338	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0033f	c3		 ret	 0
replace_single_character_in_place ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_substring_in_place DD imagerel replace_substring_in_place
	DD	imagerel replace_substring_in_place+1293
	DD	imagerel $unwind$replace_substring_in_place
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_substring_in_place DD 021b01H
	DD	01d011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace_substring_in_place
_TEXT	SEGMENT
self_len$ = 48
offset$ = 56
end$ = 64
start$ = 72
result_s$ = 80
result$ = 88
self_s$ = 96
t_$23254 = 104
s_$23256 = 112
i_$23252 = 120
n_$23253 = 128
t_$23268 = 136
s_$23270 = 144
i_$23266 = 152
n_$23267 = 160
t_$23286 = 168
s_$23288 = 176
i_$23284 = 184
n_$23285 = 192
tv78 = 200
tv150 = 208
self$ = 240
from_s$ = 248
from_len$ = 256
to_s$ = 264
to_len$ = 272
maxcount$ = 280
replace_substring_in_place PROC				; COMDAT

; 1769 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 1770 :     char *result_s, *start, *end;
; 1771 :     char *self_s;
; 1772 :     Py_ssize_t self_len, offset;
; 1773 :     PyByteArrayObject *result;
; 1774 : 
; 1775 :     /* The result bytes will be the same size */
; 1776 : 
; 1777 :     self_s = PyByteArray_AS_STRING(self);

  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0002a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002e	74 38		 je	 SHORT $LN32@replace_su
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00037	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00043	e8 00 00 00 00	 call	 PyType_IsSubtype
  00048	85 c0		 test	 eax, eax
  0004a	75 1c		 jne	 SHORT $LN32@replace_su
  0004c	41 b8 f1 06 00
	00		 mov	 r8d, 1777		; 000006f1H
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00066	33 c0		 xor	 eax, eax
$LN32@replace_su:
  00068	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00070	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00075	74 19		 je	 SHORT $LN33@replace_su
  00077	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0007f	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00086	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv78[rsp], rax
  0008e	eb 0f		 jmp	 SHORT $LN34@replace_su
$LN33@replace_su:
  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00097	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv78[rsp], rax
$LN34@replace_su:
  0009f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv78[rsp]
  000a7	48 89 44 24 60	 mov	 QWORD PTR self_s$[rsp], rax

; 1778 :     self_len = PyByteArray_GET_SIZE(self);

  000ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000b3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000bb	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000bf	74 38		 je	 SHORT $LN35@replace_su
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000c8	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000d0	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000d4	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d9	85 c0		 test	 eax, eax
  000db	75 1c		 jne	 SHORT $LN35@replace_su
  000dd	41 b8 f2 06 00
	00		 mov	 r8d, 1778		; 000006f2H
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f7	33 c0		 xor	 eax, eax
$LN35@replace_su:
  000f9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00101	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00105	48 89 44 24 30	 mov	 QWORD PTR self_len$[rsp], rax

; 1779 : 
; 1780 :     offset = stringlib_find(self_s, self_len,
; 1781 :                             from_s, from_len,
; 1782 :                             0);

  0010a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00113	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  0011b	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  00123	48 8b 54 24 30	 mov	 rdx, QWORD PTR self_len$[rsp]
  00128	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self_s$[rsp]
  0012d	e8 00 00 00 00	 call	 stringlib_find
  00132	48 89 44 24 38	 mov	 QWORD PTR offset$[rsp], rax

; 1783 :     if (offset == -1) {

  00137	48 83 7c 24 38
	ff		 cmp	 QWORD PTR offset$[rsp], -1
  0013d	75 12		 jne	 SHORT $LN29@replace_su

; 1784 :         /* No matches; return the original bytes */
; 1785 :         return return_self(self);

  0013f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00147	e8 00 00 00 00	 call	 return_self
  0014c	e9 b4 03 00 00	 jmp	 $LN30@replace_su
$LN29@replace_su:

; 1786 :     }
; 1787 : 
; 1788 :     /* Need to make a new bytes */
; 1789 :     result = (PyByteArrayObject *) PyByteArray_FromStringAndSize(NULL, self_len);

  00151	48 8b 54 24 30	 mov	 rdx, QWORD PTR self_len$[rsp]
  00156	33 c9		 xor	 ecx, ecx
  00158	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0015d	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 1790 :     if (result == NULL)

  00162	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  00168	75 07		 jne	 SHORT $LN28@replace_su

; 1791 :         return NULL;

  0016a	33 c0		 xor	 eax, eax
  0016c	e9 94 03 00 00	 jmp	 $LN30@replace_su
$LN28@replace_su:

; 1792 :     result_s = PyByteArray_AS_STRING(result);

  00171	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00178	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  0017d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00181	74 35		 je	 SHORT $LN36@replace_su
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0018a	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  0018f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00193	e8 00 00 00 00	 call	 PyType_IsSubtype
  00198	85 c0		 test	 eax, eax
  0019a	75 1c		 jne	 SHORT $LN36@replace_su
  0019c	41 b8 00 07 00
	00		 mov	 r8d, 1792		; 00000700H
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b6	33 c0		 xor	 eax, eax
$LN36@replace_su:
  001b8	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001bd	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001c2	74 16		 je	 SHORT $LN37@replace_su
  001c4	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001c9	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  001d0	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  001d8	eb 0f		 jmp	 SHORT $LN38@replace_su
$LN37@replace_su:
  001da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  001e1	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
$LN38@replace_su:
  001e9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv150[rsp]
  001f1	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax
$LN27@replace_su:

; 1793 :     Py_MEMCPY(result_s, self_s, self_len);

  001f6	48 8b 44 24 30	 mov	 rax, QWORD PTR self_len$[rsp]
  001fb	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n_$23253[rsp], rax
  00203	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  00208	48 89 44 24 68	 mov	 QWORD PTR t_$23254[rsp], rax
  0020d	48 8b 44 24 60	 mov	 rax, QWORD PTR self_s$[rsp]
  00212	48 89 44 24 70	 mov	 QWORD PTR s_$23256[rsp], rax
  00217	48 83 bc 24 80
	00 00 00 10	 cmp	 QWORD PTR n_$23253[rsp], 16
  00220	72 19		 jb	 SHORT $LN24@replace_su
  00222	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR n_$23253[rsp]
  0022a	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23256[rsp]
  0022f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23254[rsp]
  00234	e8 00 00 00 00	 call	 memcpy
  00239	eb 4e		 jmp	 SHORT $LN23@replace_su
$LN24@replace_su:
  0023b	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i_$23252[rsp], 0
  00244	eb 0d		 jmp	 SHORT $LN22@replace_su
$LN21@replace_su:
  00246	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23252[rsp]
  0024b	48 ff c0	 inc	 rax
  0024e	48 89 44 24 78	 mov	 QWORD PTR i_$23252[rsp], rax
$LN22@replace_su:
  00253	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n_$23253[rsp]
  0025b	48 39 44 24 78	 cmp	 QWORD PTR i_$23252[rsp], rax
  00260	73 27		 jae	 SHORT $LN20@replace_su
  00262	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23252[rsp]
  00267	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23254[rsp]
  0026c	48 03 c8	 add	 rcx, rax
  0026f	48 8b c1	 mov	 rax, rcx
  00272	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i_$23252[rsp]
  00277	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23256[rsp]
  0027c	48 03 d1	 add	 rdx, rcx
  0027f	48 8b ca	 mov	 rcx, rdx
  00282	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00285	88 08		 mov	 BYTE PTR [rax], cl
  00287	eb bd		 jmp	 SHORT $LN21@replace_su
$LN20@replace_su:
$LN23@replace_su:
  00289	33 c0		 xor	 eax, eax
  0028b	85 c0		 test	 eax, eax
  0028d	0f 85 63 ff ff
	ff		 jne	 $LN27@replace_su

; 1794 : 
; 1795 :     /* change everything in-place, starting with this one */
; 1796 :     start =  result_s + offset;

  00293	48 8b 44 24 38	 mov	 rax, QWORD PTR offset$[rsp]
  00298	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  0029d	48 03 c8	 add	 rcx, rax
  002a0	48 8b c1	 mov	 rax, rcx
  002a3	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax
$LN19@replace_su:

; 1797 :     Py_MEMCPY(start, to_s, from_len);

  002a8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  002b0	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR n_$23267[rsp], rax
  002b8	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  002bd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR t_$23268[rsp], rax
  002c5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  002cd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR s_$23270[rsp], rax
  002d5	48 83 bc 24 a0
	00 00 00 10	 cmp	 QWORD PTR n_$23267[rsp], 16
  002de	72 1f		 jb	 SHORT $LN16@replace_su
  002e0	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR n_$23267[rsp]
  002e8	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23270[rsp]
  002f0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23268[rsp]
  002f8	e8 00 00 00 00	 call	 memcpy
  002fd	eb 66		 jmp	 SHORT $LN15@replace_su
$LN16@replace_su:
  002ff	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23266[rsp], 0
  0030b	eb 13		 jmp	 SHORT $LN14@replace_su
$LN13@replace_su:
  0030d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23266[rsp]
  00315	48 ff c0	 inc	 rax
  00318	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR i_$23266[rsp], rax
$LN14@replace_su:
  00320	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR n_$23267[rsp]
  00328	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR i_$23266[rsp], rax
  00330	73 33		 jae	 SHORT $LN12@replace_su
  00332	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23266[rsp]
  0033a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23268[rsp]
  00342	48 03 c8	 add	 rcx, rax
  00345	48 8b c1	 mov	 rax, rcx
  00348	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR i_$23266[rsp]
  00350	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23270[rsp]
  00358	48 03 d1	 add	 rdx, rcx
  0035b	48 8b ca	 mov	 rcx, rdx
  0035e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00361	88 08		 mov	 BYTE PTR [rax], cl
  00363	eb a8		 jmp	 SHORT $LN13@replace_su
$LN12@replace_su:
$LN15@replace_su:
  00365	33 c0		 xor	 eax, eax
  00367	85 c0		 test	 eax, eax
  00369	0f 85 39 ff ff
	ff		 jne	 $LN19@replace_su

; 1798 :     start += from_len;

  0036f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  00377	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  0037c	48 03 c8	 add	 rcx, rax
  0037f	48 8b c1	 mov	 rax, rcx
  00382	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1799 :     end = result_s + self_len;

  00387	48 8b 44 24 30	 mov	 rax, QWORD PTR self_len$[rsp]
  0038c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  00391	48 03 c8	 add	 rcx, rax
  00394	48 8b c1	 mov	 rax, rcx
  00397	48 89 44 24 40	 mov	 QWORD PTR end$[rsp], rax
$LN11@replace_su:

; 1800 : 
; 1801 :     while ( --maxcount > 0) {

  0039c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  003a4	48 ff c8	 dec	 rax
  003a7	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR maxcount$[rsp], rax
  003af	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR maxcount$[rsp], 0
  003b8	0f 8e 42 01 00
	00		 jle	 $LN10@replace_su

; 1802 :         offset = stringlib_find(start, end-start,
; 1803 :                                 from_s, from_len,
; 1804 :                                 0);

  003be	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  003c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  003c8	48 2b c8	 sub	 rcx, rax
  003cb	48 8b c1	 mov	 rax, rcx
  003ce	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  003d7	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  003df	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  003e7	48 8b d0	 mov	 rdx, rax
  003ea	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  003ef	e8 00 00 00 00	 call	 stringlib_find
  003f4	48 89 44 24 38	 mov	 QWORD PTR offset$[rsp], rax

; 1805 :         if (offset==-1)

  003f9	48 83 7c 24 38
	ff		 cmp	 QWORD PTR offset$[rsp], -1
  003ff	75 05		 jne	 SHORT $LN9@replace_su

; 1806 :             break;

  00401	e9 fa 00 00 00	 jmp	 $LN10@replace_su
$LN9@replace_su:
$LN8@replace_su:

; 1807 :         Py_MEMCPY(start+offset, to_s, from_len);

  00406	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  0040e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR n_$23285[rsp], rax
  00416	48 8b 44 24 38	 mov	 rax, QWORD PTR offset$[rsp]
  0041b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  00420	48 03 c8	 add	 rcx, rax
  00423	48 8b c1	 mov	 rax, rcx
  00426	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR t_$23286[rsp], rax
  0042e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  00436	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR s_$23288[rsp], rax
  0043e	48 83 bc 24 c0
	00 00 00 10	 cmp	 QWORD PTR n_$23285[rsp], 16
  00447	72 1f		 jb	 SHORT $LN5@replace_su
  00449	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR n_$23285[rsp]
  00451	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR s_$23288[rsp]
  00459	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR t_$23286[rsp]
  00461	e8 00 00 00 00	 call	 memcpy
  00466	eb 66		 jmp	 SHORT $LN4@replace_su
$LN5@replace_su:
  00468	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23284[rsp], 0
  00474	eb 13		 jmp	 SHORT $LN3@replace_su
$LN2@replace_su:
  00476	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR i_$23284[rsp]
  0047e	48 ff c0	 inc	 rax
  00481	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR i_$23284[rsp], rax
$LN3@replace_su:
  00489	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n_$23285[rsp]
  00491	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR i_$23284[rsp], rax
  00499	73 33		 jae	 SHORT $LN1@replace_su
  0049b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR i_$23284[rsp]
  004a3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR t_$23286[rsp]
  004ab	48 03 c8	 add	 rcx, rax
  004ae	48 8b c1	 mov	 rax, rcx
  004b1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR i_$23284[rsp]
  004b9	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR s_$23288[rsp]
  004c1	48 03 d1	 add	 rdx, rcx
  004c4	48 8b ca	 mov	 rcx, rdx
  004c7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  004ca	88 08		 mov	 BYTE PTR [rax], cl
  004cc	eb a8		 jmp	 SHORT $LN2@replace_su
$LN1@replace_su:
$LN4@replace_su:
  004ce	33 c0		 xor	 eax, eax
  004d0	85 c0		 test	 eax, eax
  004d2	0f 85 2e ff ff
	ff		 jne	 $LN8@replace_su

; 1808 :         start += offset+from_len;

  004d8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  004e0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR offset$[rsp]
  004e5	48 03 c8	 add	 rcx, rax
  004e8	48 8b c1	 mov	 rax, rcx
  004eb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  004f0	48 03 c8	 add	 rcx, rax
  004f3	48 8b c1	 mov	 rax, rcx
  004f6	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1809 :     }

  004fb	e9 9c fe ff ff	 jmp	 $LN11@replace_su
$LN10@replace_su:

; 1810 : 
; 1811 :     return result;

  00500	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
$LN30@replace_su:

; 1812 : }

  00505	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0050c	c3		 ret	 0
replace_substring_in_place ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@JCBPECJD@replace?5bytes?5is?5too?5long?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_single_character DD imagerel replace_single_character
	DD	imagerel replace_single_character+1682
	DD	imagerel $unwind$replace_single_character
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_single_character DD 021a01H
	DD	021011aH
xdata	ENDS
;	COMDAT ??_C@_0BK@JCBPECJD@replace?5bytes?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BK@JCBPECJD@replace?5bytes?5is?5too?5long?$AA@ DB 'replace bytes i'
	DB	's too long', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT replace_single_character
_TEXT	SEGMENT
result_len$ = 32
count$ = 40
self_len$ = 48
next$ = 56
end$ = 64
start$ = 72
result_s$ = 80
result$ = 88
self_s$ = 96
t_$23355 = 104
s_$23357 = 112
i_$23353 = 120
n_$23354 = 128
t_$23370 = 136
s_$23372 = 144
i_$23368 = 152
n_$23369 = 160
t_$23384 = 168
s_$23386 = 176
i_$23382 = 184
n_$23383 = 192
t_$23398 = 200
s_$23400 = 208
i_$23396 = 216
n_$23397 = 224
tv78 = 232
tv136 = 240
tv163 = 248
self$ = 272
from_c$ = 280
to_s$ = 288
to_len$ = 296
maxcount$ = 304
replace_single_character PROC				; COMDAT

; 1820 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 1821 :     char *self_s, *result_s;
; 1822 :     char *start, *next, *end;
; 1823 :     Py_ssize_t self_len, result_len;
; 1824 :     Py_ssize_t count;
; 1825 :     PyByteArrayObject *result;
; 1826 : 
; 1827 :     self_s = PyByteArray_AS_STRING(self);

  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00021	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00029	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002d	74 38		 je	 SHORT $LN43@replace_si@2
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00036	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	75 1c		 jne	 SHORT $LN43@replace_si@2
  0004b	41 b8 23 07 00
	00		 mov	 r8d, 1827		; 00000723H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00065	33 c0		 xor	 eax, eax
$LN43@replace_si@2:
  00067	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00074	74 19		 je	 SHORT $LN44@replace_si@2
  00076	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0007e	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00085	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv78[rsp], rax
  0008d	eb 0f		 jmp	 SHORT $LN45@replace_si@2
$LN44@replace_si@2:
  0008f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00096	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv78[rsp], rax
$LN45@replace_si@2:
  0009e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv78[rsp]
  000a6	48 89 44 24 60	 mov	 QWORD PTR self_s$[rsp], rax

; 1828 :     self_len = PyByteArray_GET_SIZE(self);

  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000b2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000ba	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000be	74 38		 je	 SHORT $LN46@replace_si@2
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000c7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000cf	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000d3	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d8	85 c0		 test	 eax, eax
  000da	75 1c		 jne	 SHORT $LN46@replace_si@2
  000dc	41 b8 24 07 00
	00		 mov	 r8d, 1828		; 00000724H
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f6	33 c0		 xor	 eax, eax
$LN46@replace_si@2:
  000f8	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00100	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00104	48 89 44 24 30	 mov	 QWORD PTR self_len$[rsp], rax

; 1829 : 
; 1830 :     count = countchar(self_s, self_len, from_c, maxcount);

  00109	4c 8b 8c 24 30
	01 00 00	 mov	 r9, QWORD PTR maxcount$[rsp]
  00111	44 0f b6 84 24
	18 01 00 00	 movzx	 r8d, BYTE PTR from_c$[rsp]
  0011a	48 8b 54 24 30	 mov	 rdx, QWORD PTR self_len$[rsp]
  0011f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self_s$[rsp]
  00124	e8 00 00 00 00	 call	 countchar
  00129	48 89 44 24 28	 mov	 QWORD PTR count$[rsp], rax

; 1831 :     if (count == 0) {

  0012e	48 83 7c 24 28
	00		 cmp	 QWORD PTR count$[rsp], 0
  00134	75 12		 jne	 SHORT $LN40@replace_si@2

; 1832 :         /* no matches, return unchanged */
; 1833 :         return return_self(self);

  00136	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0013e	e8 00 00 00 00	 call	 return_self
  00143	e9 42 05 00 00	 jmp	 $LN41@replace_si@2
$LN40@replace_si@2:

; 1834 :     }
; 1835 : 
; 1836 :     /* use the difference between current and new, hence the "-1" */
; 1837 :     /*   result_len = self_len + count * (to_len-1)  */
; 1838 :     assert(count > 0);

  00148	48 83 7c 24 28
	00		 cmp	 QWORD PTR count$[rsp], 0
  0014e	7f 1c		 jg	 SHORT $LN47@replace_si@2
  00150	41 b8 2e 07 00
	00		 mov	 r8d, 1838		; 0000072eH
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0016a	33 c0		 xor	 eax, eax
$LN47@replace_si@2:

; 1839 :     if (to_len - 1 > (PY_SSIZE_T_MAX - self_len) / count) {

  0016c	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00174	48 ff c8	 dec	 rax
  00177	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv136[rsp], rax
  0017f	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00189	48 2b 4c 24 30	 sub	 rcx, QWORD PTR self_len$[rsp]
  0018e	48 8b c1	 mov	 rax, rcx
  00191	48 99		 cdq
  00193	48 f7 7c 24 28	 idiv	 QWORD PTR count$[rsp]
  00198	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv136[rsp]
  001a0	48 3b c8	 cmp	 rcx, rax
  001a3	7e 1a		 jle	 SHORT $LN39@replace_si@2

; 1840 :         PyErr_SetString(PyExc_OverflowError, "replace bytes is too long");

  001a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JCBPECJD@replace?5bytes?5is?5too?5long?$AA@
  001ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001b3	e8 00 00 00 00	 call	 PyErr_SetString

; 1841 :         return NULL;

  001b8	33 c0		 xor	 eax, eax
  001ba	e9 cb 04 00 00	 jmp	 $LN41@replace_si@2
$LN39@replace_si@2:

; 1842 :     }
; 1843 :     result_len = self_len + count * (to_len - 1);

  001bf	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  001c7	48 ff c8	 dec	 rax
  001ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR count$[rsp]
  001cf	48 0f af c8	 imul	 rcx, rax
  001d3	48 8b c1	 mov	 rax, rcx
  001d6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self_len$[rsp]
  001db	48 03 c8	 add	 rcx, rax
  001de	48 8b c1	 mov	 rax, rcx
  001e1	48 89 44 24 20	 mov	 QWORD PTR result_len$[rsp], rax

; 1844 : 
; 1845 :     if ( (result = (PyByteArrayObject *)
; 1846 :           PyByteArray_FromStringAndSize(NULL, result_len)) == NULL)

  001e6	48 8b 54 24 20	 mov	 rdx, QWORD PTR result_len$[rsp]
  001eb	33 c9		 xor	 ecx, ecx
  001ed	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  001f2	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax
  001f7	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  001fd	75 07		 jne	 SHORT $LN38@replace_si@2

; 1847 :             return NULL;

  001ff	33 c0		 xor	 eax, eax
  00201	e9 84 04 00 00	 jmp	 $LN41@replace_si@2
$LN38@replace_si@2:

; 1848 :     result_s = PyByteArray_AS_STRING(result);

  00206	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0020d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  00212	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00216	74 35		 je	 SHORT $LN48@replace_si@2
  00218	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0021f	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00224	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00228	e8 00 00 00 00	 call	 PyType_IsSubtype
  0022d	85 c0		 test	 eax, eax
  0022f	75 1c		 jne	 SHORT $LN48@replace_si@2
  00231	41 b8 38 07 00
	00		 mov	 r8d, 1848		; 00000738H
  00237	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0023e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0024b	33 c0		 xor	 eax, eax
$LN48@replace_si@2:
  0024d	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00252	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00257	74 16		 je	 SHORT $LN49@replace_si@2
  00259	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  0025e	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00265	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv163[rsp], rax
  0026d	eb 0f		 jmp	 SHORT $LN50@replace_si@2
$LN49@replace_si@2:
  0026f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00276	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv163[rsp], rax
$LN50@replace_si@2:
  0027e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv163[rsp]
  00286	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax

; 1849 : 
; 1850 :     start = self_s;

  0028b	48 8b 44 24 60	 mov	 rax, QWORD PTR self_s$[rsp]
  00290	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1851 :     end = self_s + self_len;

  00295	48 8b 44 24 30	 mov	 rax, QWORD PTR self_len$[rsp]
  0029a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self_s$[rsp]
  0029f	48 03 c8	 add	 rcx, rax
  002a2	48 8b c1	 mov	 rax, rcx
  002a5	48 89 44 24 40	 mov	 QWORD PTR end$[rsp], rax
$LN37@replace_si@2:

; 1852 :     while (count-- > 0) {

  002aa	48 8b 44 24 28	 mov	 rax, QWORD PTR count$[rsp]
  002af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR count$[rsp]
  002b4	48 ff c9	 dec	 rcx
  002b7	48 89 4c 24 28	 mov	 QWORD PTR count$[rsp], rcx
  002bc	48 85 c0	 test	 rax, rax
  002bf	0f 8e f4 02 00
	00		 jle	 $LN36@replace_si@2

; 1853 :         next = findchar(start, end-start, from_c);

  002c5	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  002ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  002cf	48 2b c8	 sub	 rcx, rax
  002d2	48 8b c1	 mov	 rax, rcx
  002d5	0f be 8c 24 18
	01 00 00	 movsx	 ecx, BYTE PTR from_c$[rsp]
  002dd	4c 8b c0	 mov	 r8, rax
  002e0	8b d1		 mov	 edx, ecx
  002e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  002e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  002ed	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 1854 :         if (next == NULL)

  002f2	48 83 7c 24 38
	00		 cmp	 QWORD PTR next$[rsp], 0
  002f8	75 05		 jne	 SHORT $LN35@replace_si@2

; 1855 :             break;

  002fa	e9 ba 02 00 00	 jmp	 $LN36@replace_si@2
$LN35@replace_si@2:

; 1856 : 
; 1857 :         if (next == start) {

  002ff	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00304	48 39 44 24 38	 cmp	 QWORD PTR next$[rsp], rax
  00309	0f 85 cd 00 00
	00		 jne	 $LN34@replace_si@2
$LN33@replace_si@2:

; 1858 :             /* replace with the 'to' */
; 1859 :             Py_MEMCPY(result_s, to_s, to_len);

  0030f	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00317	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n_$23354[rsp], rax
  0031f	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  00324	48 89 44 24 68	 mov	 QWORD PTR t_$23355[rsp], rax
  00329	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  00331	48 89 44 24 70	 mov	 QWORD PTR s_$23357[rsp], rax
  00336	48 83 bc 24 80
	00 00 00 10	 cmp	 QWORD PTR n_$23354[rsp], 16
  0033f	72 19		 jb	 SHORT $LN30@replace_si@2
  00341	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR n_$23354[rsp]
  00349	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23357[rsp]
  0034e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23355[rsp]
  00353	e8 00 00 00 00	 call	 memcpy
  00358	eb 4e		 jmp	 SHORT $LN29@replace_si@2
$LN30@replace_si@2:
  0035a	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i_$23353[rsp], 0
  00363	eb 0d		 jmp	 SHORT $LN28@replace_si@2
$LN27@replace_si@2:
  00365	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23353[rsp]
  0036a	48 ff c0	 inc	 rax
  0036d	48 89 44 24 78	 mov	 QWORD PTR i_$23353[rsp], rax
$LN28@replace_si@2:
  00372	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n_$23354[rsp]
  0037a	48 39 44 24 78	 cmp	 QWORD PTR i_$23353[rsp], rax
  0037f	73 27		 jae	 SHORT $LN26@replace_si@2
  00381	48 8b 44 24 78	 mov	 rax, QWORD PTR i_$23353[rsp]
  00386	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_$23355[rsp]
  0038b	48 03 c8	 add	 rcx, rax
  0038e	48 8b c1	 mov	 rax, rcx
  00391	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i_$23353[rsp]
  00396	48 8b 54 24 70	 mov	 rdx, QWORD PTR s_$23357[rsp]
  0039b	48 03 d1	 add	 rdx, rcx
  0039e	48 8b ca	 mov	 rcx, rdx
  003a1	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  003a4	88 08		 mov	 BYTE PTR [rax], cl
  003a6	eb bd		 jmp	 SHORT $LN27@replace_si@2
$LN26@replace_si@2:
$LN29@replace_si@2:
  003a8	33 c0		 xor	 eax, eax
  003aa	85 c0		 test	 eax, eax
  003ac	0f 85 5d ff ff
	ff		 jne	 $LN33@replace_si@2

; 1860 :             result_s += to_len;

  003b2	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  003ba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  003bf	48 03 c8	 add	 rcx, rax
  003c2	48 8b c1	 mov	 rax, rcx
  003c5	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax

; 1861 :             start += 1;

  003ca	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  003cf	48 ff c0	 inc	 rax
  003d2	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 1862 :         } else {

  003d7	e9 d8 01 00 00	 jmp	 $LN25@replace_si@2
$LN34@replace_si@2:
$LN24@replace_si@2:

; 1863 :             /* copy the unchanged old then the 'to' */
; 1864 :             Py_MEMCPY(result_s, start, next-start);

  003dc	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  003e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  003e6	48 2b c8	 sub	 rcx, rax
  003e9	48 8b c1	 mov	 rax, rcx
  003ec	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR n_$23369[rsp], rax
  003f4	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  003f9	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR t_$23370[rsp], rax
  00401	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00406	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR s_$23372[rsp], rax
  0040e	48 83 bc 24 a0
	00 00 00 10	 cmp	 QWORD PTR n_$23369[rsp], 16
  00417	72 1f		 jb	 SHORT $LN21@replace_si@2
  00419	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR n_$23369[rsp]
  00421	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23372[rsp]
  00429	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23370[rsp]
  00431	e8 00 00 00 00	 call	 memcpy
  00436	eb 66		 jmp	 SHORT $LN20@replace_si@2
$LN21@replace_si@2:
  00438	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23368[rsp], 0
  00444	eb 13		 jmp	 SHORT $LN19@replace_si@2
$LN18@replace_si@2:
  00446	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23368[rsp]
  0044e	48 ff c0	 inc	 rax
  00451	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR i_$23368[rsp], rax
$LN19@replace_si@2:
  00459	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR n_$23369[rsp]
  00461	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR i_$23368[rsp], rax
  00469	73 33		 jae	 SHORT $LN17@replace_si@2
  0046b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i_$23368[rsp]
  00473	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR t_$23370[rsp]
  0047b	48 03 c8	 add	 rcx, rax
  0047e	48 8b c1	 mov	 rax, rcx
  00481	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR i_$23368[rsp]
  00489	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s_$23372[rsp]
  00491	48 03 d1	 add	 rdx, rcx
  00494	48 8b ca	 mov	 rcx, rdx
  00497	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0049a	88 08		 mov	 BYTE PTR [rax], cl
  0049c	eb a8		 jmp	 SHORT $LN18@replace_si@2
$LN17@replace_si@2:
$LN20@replace_si@2:
  0049e	33 c0		 xor	 eax, eax
  004a0	85 c0		 test	 eax, eax
  004a2	0f 85 34 ff ff
	ff		 jne	 $LN24@replace_si@2

; 1865 :             result_s += (next-start);

  004a8	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  004ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  004b2	48 2b c8	 sub	 rcx, rax
  004b5	48 8b c1	 mov	 rax, rcx
  004b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  004bd	48 03 c8	 add	 rcx, rax
  004c0	48 8b c1	 mov	 rax, rcx
  004c3	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax
$LN16@replace_si@2:

; 1866 :             Py_MEMCPY(result_s, to_s, to_len);

  004c8	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  004d0	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR n_$23383[rsp], rax
  004d8	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  004dd	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR t_$23384[rsp], rax
  004e5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  004ed	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR s_$23386[rsp], rax
  004f5	48 83 bc 24 c0
	00 00 00 10	 cmp	 QWORD PTR n_$23383[rsp], 16
  004fe	72 1f		 jb	 SHORT $LN13@replace_si@2
  00500	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR n_$23383[rsp]
  00508	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR s_$23386[rsp]
  00510	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR t_$23384[rsp]
  00518	e8 00 00 00 00	 call	 memcpy
  0051d	eb 66		 jmp	 SHORT $LN12@replace_si@2
$LN13@replace_si@2:
  0051f	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23382[rsp], 0
  0052b	eb 13		 jmp	 SHORT $LN11@replace_si@2
$LN10@replace_si@2:
  0052d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR i_$23382[rsp]
  00535	48 ff c0	 inc	 rax
  00538	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR i_$23382[rsp], rax
$LN11@replace_si@2:
  00540	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n_$23383[rsp]
  00548	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR i_$23382[rsp], rax
  00550	73 33		 jae	 SHORT $LN9@replace_si@2
  00552	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR i_$23382[rsp]
  0055a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR t_$23384[rsp]
  00562	48 03 c8	 add	 rcx, rax
  00565	48 8b c1	 mov	 rax, rcx
  00568	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR i_$23382[rsp]
  00570	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR s_$23386[rsp]
  00578	48 03 d1	 add	 rdx, rcx
  0057b	48 8b ca	 mov	 rcx, rdx
  0057e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00581	88 08		 mov	 BYTE PTR [rax], cl
  00583	eb a8		 jmp	 SHORT $LN10@replace_si@2
$LN9@replace_si@2:
$LN12@replace_si@2:
  00585	33 c0		 xor	 eax, eax
  00587	85 c0		 test	 eax, eax
  00589	0f 85 39 ff ff
	ff		 jne	 $LN16@replace_si@2

; 1867 :             result_s += to_len;

  0058f	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00597	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result_s$[rsp]
  0059c	48 03 c8	 add	 rcx, rax
  0059f	48 8b c1	 mov	 rax, rcx
  005a2	48 89 44 24 50	 mov	 QWORD PTR result_s$[rsp], rax

; 1868 :             start = next+1;

  005a7	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  005ac	48 ff c0	 inc	 rax
  005af	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax
$LN25@replace_si@2:

; 1869 :         }
; 1870 :     }

  005b4	e9 f1 fc ff ff	 jmp	 $LN37@replace_si@2
$LN36@replace_si@2:
$LN8@replace_si@2:

; 1871 :     /* Copy the remainder of the remaining bytes */
; 1872 :     Py_MEMCPY(result_s, start, end-start);

  005b9	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  005be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  005c3	48 2b c8	 sub	 rcx, rax
  005c6	48 8b c1	 mov	 rax, rcx
  005c9	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR n_$23397[rsp], rax
  005d1	48 8b 44 24 50	 mov	 rax, QWORD PTR result_s$[rsp]
  005d6	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR t_$23398[rsp], rax
  005de	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  005e3	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR s_$23400[rsp], rax
  005eb	48 83 bc 24 e0
	00 00 00 10	 cmp	 QWORD PTR n_$23397[rsp], 16
  005f4	72 1f		 jb	 SHORT $LN5@replace_si@2
  005f6	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR n_$23397[rsp]
  005fe	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR s_$23400[rsp]
  00606	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR t_$23398[rsp]
  0060e	e8 00 00 00 00	 call	 memcpy
  00613	eb 66		 jmp	 SHORT $LN4@replace_si@2
$LN5@replace_si@2:
  00615	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23396[rsp], 0
  00621	eb 13		 jmp	 SHORT $LN3@replace_si@2
$LN2@replace_si@2:
  00623	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR i_$23396[rsp]
  0062b	48 ff c0	 inc	 rax
  0062e	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR i_$23396[rsp], rax
$LN3@replace_si@2:
  00636	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR n_$23397[rsp]
  0063e	48 39 84 24 d8
	00 00 00	 cmp	 QWORD PTR i_$23396[rsp], rax
  00646	73 33		 jae	 SHORT $LN1@replace_si@2
  00648	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR i_$23396[rsp]
  00650	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR t_$23398[rsp]
  00658	48 03 c8	 add	 rcx, rax
  0065b	48 8b c1	 mov	 rax, rcx
  0065e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR i_$23396[rsp]
  00666	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR s_$23400[rsp]
  0066e	48 03 d1	 add	 rdx, rcx
  00671	48 8b ca	 mov	 rcx, rdx
  00674	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00677	88 08		 mov	 BYTE PTR [rax], cl
  00679	eb a8		 jmp	 SHORT $LN2@replace_si@2
$LN1@replace_si@2:
$LN4@replace_si@2:
  0067b	33 c0		 xor	 eax, eax
  0067d	85 c0		 test	 eax, eax
  0067f	0f 85 34 ff ff
	ff		 jne	 $LN8@replace_si@2

; 1873 : 
; 1874 :     return result;

  00685	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
$LN41@replace_si@2:

; 1875 : }

  0068a	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00691	c3		 ret	 0
replace_single_character ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_substring DD imagerel replace_substring
	DD	imagerel replace_substring+1810
	DD	imagerel $unwind$replace_substring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_substring DD 021b01H
	DD	025011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT replace_substring
_TEXT	SEGMENT
result_len$ = 48
count$ = 56
self_len$ = 64
offset$ = 72
next$ = 80
end$ = 88
start$ = 96
result_s$ = 104
result$ = 112
self_s$ = 120
t_$23466 = 128
s_$23468 = 136
i_$23464 = 144
n_$23465 = 152
t_$23481 = 160
s_$23483 = 168
i_$23479 = 176
n_$23480 = 184
t_$23495 = 192
s_$23497 = 200
i_$23493 = 208
n_$23494 = 216
t_$23509 = 224
s_$23511 = 232
i_$23507 = 240
n_$23508 = 248
tv78 = 256
tv137 = 264
tv164 = 272
self$ = 304
from_s$ = 312
from_len$ = 320
to_s$ = 328
to_len$ = 336
maxcount$ = 344
replace_substring PROC					; COMDAT

; 1883 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H

; 1884 :     char *self_s, *result_s;
; 1885 :     char *start, *next, *end;
; 1886 :     Py_ssize_t self_len, result_len;
; 1887 :     Py_ssize_t count, offset;
; 1888 :     PyByteArrayObject *result;
; 1889 : 
; 1890 :     self_s = PyByteArray_AS_STRING(self);

  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0002a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002e	74 38		 je	 SHORT $LN43@replace_su@2
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00037	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00043	e8 00 00 00 00	 call	 PyType_IsSubtype
  00048	85 c0		 test	 eax, eax
  0004a	75 1c		 jne	 SHORT $LN43@replace_su@2
  0004c	41 b8 62 07 00
	00		 mov	 r8d, 1890		; 00000762H
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00066	33 c0		 xor	 eax, eax
$LN43@replace_su@2:
  00068	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00070	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00075	74 19		 je	 SHORT $LN44@replace_su@2
  00077	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0007f	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00086	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv78[rsp], rax
  0008e	eb 0f		 jmp	 SHORT $LN45@replace_su@2
$LN44@replace_su@2:
  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00097	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv78[rsp], rax
$LN45@replace_su@2:
  0009f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv78[rsp]
  000a7	48 89 44 24 78	 mov	 QWORD PTR self_s$[rsp], rax

; 1891 :     self_len = PyByteArray_GET_SIZE(self);

  000ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000b3	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000bb	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000bf	74 38		 je	 SHORT $LN46@replace_su@2
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000c8	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000d0	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000d4	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d9	85 c0		 test	 eax, eax
  000db	75 1c		 jne	 SHORT $LN46@replace_su@2
  000dd	41 b8 63 07 00
	00		 mov	 r8d, 1891		; 00000763H
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f7	33 c0		 xor	 eax, eax
$LN46@replace_su@2:
  000f9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00101	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00105	48 89 44 24 40	 mov	 QWORD PTR self_len$[rsp], rax

; 1892 : 
; 1893 :     count = stringlib_count(self_s, self_len,
; 1894 :                             from_s, from_len,
; 1895 :                             maxcount);

  0010a	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00112	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00117	4c 8b 8c 24 40
	01 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  0011f	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  00127	48 8b 54 24 40	 mov	 rdx, QWORD PTR self_len$[rsp]
  0012c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self_s$[rsp]
  00131	e8 00 00 00 00	 call	 stringlib_count
  00136	48 89 44 24 38	 mov	 QWORD PTR count$[rsp], rax

; 1896 : 
; 1897 :     if (count == 0) {

  0013b	48 83 7c 24 38
	00		 cmp	 QWORD PTR count$[rsp], 0
  00141	75 12		 jne	 SHORT $LN40@replace_su@2

; 1898 :         /* no matches, return unchanged */
; 1899 :         return return_self(self);

  00143	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0014b	e8 00 00 00 00	 call	 return_self
  00150	e9 b5 05 00 00	 jmp	 $LN41@replace_su@2
$LN40@replace_su@2:

; 1900 :     }
; 1901 : 
; 1902 :     /* Check for overflow */
; 1903 :     /*    result_len = self_len + count * (to_len-from_len) */
; 1904 :     assert(count > 0);

  00155	48 83 7c 24 38
	00		 cmp	 QWORD PTR count$[rsp], 0
  0015b	7f 1c		 jg	 SHORT $LN47@replace_su@2
  0015d	41 b8 70 07 00
	00		 mov	 r8d, 1904		; 00000770H
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@IMJLAELI@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00177	33 c0		 xor	 eax, eax
$LN47@replace_su@2:

; 1905 :     if (to_len - from_len > (PY_SSIZE_T_MAX - self_len) / count) {

  00179	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  00181	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR to_len$[rsp]
  00189	48 2b c8	 sub	 rcx, rax
  0018c	48 8b c1	 mov	 rax, rcx
  0018f	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv137[rsp], rax
  00197	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  001a1	48 2b 4c 24 40	 sub	 rcx, QWORD PTR self_len$[rsp]
  001a6	48 8b c1	 mov	 rax, rcx
  001a9	48 99		 cdq
  001ab	48 f7 7c 24 38	 idiv	 QWORD PTR count$[rsp]
  001b0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv137[rsp]
  001b8	48 3b c8	 cmp	 rcx, rax
  001bb	7e 1a		 jle	 SHORT $LN39@replace_su@2

; 1906 :         PyErr_SetString(PyExc_OverflowError, "replace bytes is too long");

  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JCBPECJD@replace?5bytes?5is?5too?5long?$AA@
  001c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001cb	e8 00 00 00 00	 call	 PyErr_SetString

; 1907 :         return NULL;

  001d0	33 c0		 xor	 eax, eax
  001d2	e9 33 05 00 00	 jmp	 $LN41@replace_su@2
$LN39@replace_su@2:

; 1908 :     }
; 1909 :     result_len = self_len + count * (to_len - from_len);

  001d7	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  001df	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR to_len$[rsp]
  001e7	48 2b c8	 sub	 rcx, rax
  001ea	48 8b c1	 mov	 rax, rcx
  001ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR count$[rsp]
  001f2	48 0f af c8	 imul	 rcx, rax
  001f6	48 8b c1	 mov	 rax, rcx
  001f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self_len$[rsp]
  001fe	48 03 c8	 add	 rcx, rax
  00201	48 8b c1	 mov	 rax, rcx
  00204	48 89 44 24 30	 mov	 QWORD PTR result_len$[rsp], rax

; 1910 : 
; 1911 :     if ( (result = (PyByteArrayObject *)
; 1912 :           PyByteArray_FromStringAndSize(NULL, result_len)) == NULL)

  00209	48 8b 54 24 30	 mov	 rdx, QWORD PTR result_len$[rsp]
  0020e	33 c9		 xor	 ecx, ecx
  00210	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00215	48 89 44 24 70	 mov	 QWORD PTR result$[rsp], rax
  0021a	48 83 7c 24 70
	00		 cmp	 QWORD PTR result$[rsp], 0
  00220	75 07		 jne	 SHORT $LN38@replace_su@2

; 1913 :         return NULL;

  00222	33 c0		 xor	 eax, eax
  00224	e9 e1 04 00 00	 jmp	 $LN41@replace_su@2
$LN38@replace_su@2:

; 1914 :     result_s = PyByteArray_AS_STRING(result);

  00229	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00230	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result$[rsp]
  00235	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00239	74 35		 je	 SHORT $LN48@replace_su@2
  0023b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00242	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  00247	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0024b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00250	85 c0		 test	 eax, eax
  00252	75 1c		 jne	 SHORT $LN48@replace_su@2
  00254	41 b8 7a 07 00
	00		 mov	 r8d, 1914		; 0000077aH
  0025a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0026e	33 c0		 xor	 eax, eax
$LN48@replace_su@2:
  00270	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  00275	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0027a	74 16		 je	 SHORT $LN49@replace_su@2
  0027c	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  00281	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00288	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv164[rsp], rax
  00290	eb 0f		 jmp	 SHORT $LN50@replace_su@2
$LN49@replace_su@2:
  00292	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00299	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv164[rsp], rax
$LN50@replace_su@2:
  002a1	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv164[rsp]
  002a9	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax

; 1915 : 
; 1916 :     start = self_s;

  002ae	48 8b 44 24 78	 mov	 rax, QWORD PTR self_s$[rsp]
  002b3	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax

; 1917 :     end = self_s + self_len;

  002b8	48 8b 44 24 40	 mov	 rax, QWORD PTR self_len$[rsp]
  002bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self_s$[rsp]
  002c2	48 03 c8	 add	 rcx, rax
  002c5	48 8b c1	 mov	 rax, rcx
  002c8	48 89 44 24 58	 mov	 QWORD PTR end$[rsp], rax
$LN37@replace_su@2:

; 1918 :     while (count-- > 0) {

  002cd	48 8b 44 24 38	 mov	 rax, QWORD PTR count$[rsp]
  002d2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR count$[rsp]
  002d7	48 ff c9	 dec	 rcx
  002da	48 89 4c 24 38	 mov	 QWORD PTR count$[rsp], rcx
  002df	48 85 c0	 test	 rax, rax
  002e2	0f 8e 51 03 00
	00		 jle	 $LN36@replace_su@2

; 1919 :         offset = stringlib_find(start, end-start,
; 1920 :                                 from_s, from_len,
; 1921 :                                 0);

  002e8	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  002ed	48 8b 4c 24 58	 mov	 rcx, QWORD PTR end$[rsp]
  002f2	48 2b c8	 sub	 rcx, rax
  002f5	48 8b c1	 mov	 rax, rcx
  002f8	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00301	4c 8b 8c 24 40
	01 00 00	 mov	 r9, QWORD PTR from_len$[rsp]
  00309	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR from_s$[rsp]
  00311	48 8b d0	 mov	 rdx, rax
  00314	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00319	e8 00 00 00 00	 call	 stringlib_find
  0031e	48 89 44 24 48	 mov	 QWORD PTR offset$[rsp], rax

; 1922 :         if (offset == -1)

  00323	48 83 7c 24 48
	ff		 cmp	 QWORD PTR offset$[rsp], -1
  00329	75 05		 jne	 SHORT $LN35@replace_su@2

; 1923 :             break;

  0032b	e9 09 03 00 00	 jmp	 $LN36@replace_su@2
$LN35@replace_su@2:

; 1924 :         next = start+offset;

  00330	48 8b 44 24 48	 mov	 rax, QWORD PTR offset$[rsp]
  00335	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  0033a	48 03 c8	 add	 rcx, rax
  0033d	48 8b c1	 mov	 rax, rcx
  00340	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 1925 :         if (next == start) {

  00345	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0034a	48 39 44 24 50	 cmp	 QWORD PTR next$[rsp], rax
  0034f	0f 85 fc 00 00
	00		 jne	 $LN34@replace_su@2
$LN33@replace_su@2:

; 1926 :             /* replace with the 'to' */
; 1927 :             Py_MEMCPY(result_s, to_s, to_len);

  00355	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  0035d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR n_$23465[rsp], rax
  00365	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  0036a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR t_$23466[rsp], rax
  00372	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  0037a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s_$23468[rsp], rax
  00382	48 83 bc 24 98
	00 00 00 10	 cmp	 QWORD PTR n_$23465[rsp], 16
  0038b	72 1f		 jb	 SHORT $LN30@replace_su@2
  0038d	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR n_$23465[rsp]
  00395	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s_$23468[rsp]
  0039d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t_$23466[rsp]
  003a5	e8 00 00 00 00	 call	 memcpy
  003aa	eb 66		 jmp	 SHORT $LN29@replace_su@2
$LN30@replace_su@2:
  003ac	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23464[rsp], 0
  003b8	eb 13		 jmp	 SHORT $LN28@replace_su@2
$LN27@replace_su@2:
  003ba	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i_$23464[rsp]
  003c2	48 ff c0	 inc	 rax
  003c5	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR i_$23464[rsp], rax
$LN28@replace_su@2:
  003cd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n_$23465[rsp]
  003d5	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR i_$23464[rsp], rax
  003dd	73 33		 jae	 SHORT $LN26@replace_su@2
  003df	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i_$23464[rsp]
  003e7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t_$23466[rsp]
  003ef	48 03 c8	 add	 rcx, rax
  003f2	48 8b c1	 mov	 rax, rcx
  003f5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR i_$23464[rsp]
  003fd	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s_$23468[rsp]
  00405	48 03 d1	 add	 rdx, rcx
  00408	48 8b ca	 mov	 rcx, rdx
  0040b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0040e	88 08		 mov	 BYTE PTR [rax], cl
  00410	eb a8		 jmp	 SHORT $LN27@replace_su@2
$LN26@replace_su@2:
$LN29@replace_su@2:
  00412	33 c0		 xor	 eax, eax
  00414	85 c0		 test	 eax, eax
  00416	0f 85 39 ff ff
	ff		 jne	 $LN33@replace_su@2

; 1928 :             result_s += to_len;

  0041c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00424	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result_s$[rsp]
  00429	48 03 c8	 add	 rcx, rax
  0042c	48 8b c1	 mov	 rax, rcx
  0042f	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax

; 1929 :             start += from_len;

  00434	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  0043c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR start$[rsp]
  00441	48 03 c8	 add	 rcx, rax
  00444	48 8b c1	 mov	 rax, rcx
  00447	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax

; 1930 :         } else {

  0044c	e9 e3 01 00 00	 jmp	 $LN25@replace_su@2
$LN34@replace_su@2:
$LN24@replace_su@2:

; 1931 :             /* copy the unchanged old then the 'to' */
; 1932 :             Py_MEMCPY(result_s, start, next-start);

  00451	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00456	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  0045b	48 2b c8	 sub	 rcx, rax
  0045e	48 8b c1	 mov	 rax, rcx
  00461	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR n_$23480[rsp], rax
  00469	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  0046e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR t_$23481[rsp], rax
  00476	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0047b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s_$23483[rsp], rax
  00483	48 83 bc 24 b8
	00 00 00 10	 cmp	 QWORD PTR n_$23480[rsp], 16
  0048c	72 1f		 jb	 SHORT $LN21@replace_su@2
  0048e	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR n_$23480[rsp]
  00496	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR s_$23483[rsp]
  0049e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR t_$23481[rsp]
  004a6	e8 00 00 00 00	 call	 memcpy
  004ab	eb 66		 jmp	 SHORT $LN20@replace_su@2
$LN21@replace_su@2:
  004ad	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23479[rsp], 0
  004b9	eb 13		 jmp	 SHORT $LN19@replace_su@2
$LN18@replace_su@2:
  004bb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i_$23479[rsp]
  004c3	48 ff c0	 inc	 rax
  004c6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR i_$23479[rsp], rax
$LN19@replace_su@2:
  004ce	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n_$23480[rsp]
  004d6	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR i_$23479[rsp], rax
  004de	73 33		 jae	 SHORT $LN17@replace_su@2
  004e0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i_$23479[rsp]
  004e8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR t_$23481[rsp]
  004f0	48 03 c8	 add	 rcx, rax
  004f3	48 8b c1	 mov	 rax, rcx
  004f6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR i_$23479[rsp]
  004fe	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR s_$23483[rsp]
  00506	48 03 d1	 add	 rdx, rcx
  00509	48 8b ca	 mov	 rcx, rdx
  0050c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0050f	88 08		 mov	 BYTE PTR [rax], cl
  00511	eb a8		 jmp	 SHORT $LN18@replace_su@2
$LN17@replace_su@2:
$LN20@replace_su@2:
  00513	33 c0		 xor	 eax, eax
  00515	85 c0		 test	 eax, eax
  00517	0f 85 34 ff ff
	ff		 jne	 $LN24@replace_su@2

; 1933 :             result_s += (next-start);

  0051d	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00522	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00527	48 2b c8	 sub	 rcx, rax
  0052a	48 8b c1	 mov	 rax, rcx
  0052d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result_s$[rsp]
  00532	48 03 c8	 add	 rcx, rax
  00535	48 8b c1	 mov	 rax, rcx
  00538	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax
$LN16@replace_su@2:

; 1934 :             Py_MEMCPY(result_s, to_s, to_len);

  0053d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  00545	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR n_$23494[rsp], rax
  0054d	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  00552	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR t_$23495[rsp], rax
  0055a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR to_s$[rsp]
  00562	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR s_$23497[rsp], rax
  0056a	48 83 bc 24 d8
	00 00 00 10	 cmp	 QWORD PTR n_$23494[rsp], 16
  00573	72 1f		 jb	 SHORT $LN13@replace_su@2
  00575	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR n_$23494[rsp]
  0057d	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR s_$23497[rsp]
  00585	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR t_$23495[rsp]
  0058d	e8 00 00 00 00	 call	 memcpy
  00592	eb 66		 jmp	 SHORT $LN12@replace_su@2
$LN13@replace_su@2:
  00594	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23493[rsp], 0
  005a0	eb 13		 jmp	 SHORT $LN11@replace_su@2
$LN10@replace_su@2:
  005a2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR i_$23493[rsp]
  005aa	48 ff c0	 inc	 rax
  005ad	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR i_$23493[rsp], rax
$LN11@replace_su@2:
  005b5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR n_$23494[rsp]
  005bd	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR i_$23493[rsp], rax
  005c5	73 33		 jae	 SHORT $LN9@replace_su@2
  005c7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR i_$23493[rsp]
  005cf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR t_$23495[rsp]
  005d7	48 03 c8	 add	 rcx, rax
  005da	48 8b c1	 mov	 rax, rcx
  005dd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR i_$23493[rsp]
  005e5	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR s_$23497[rsp]
  005ed	48 03 d1	 add	 rdx, rcx
  005f0	48 8b ca	 mov	 rcx, rdx
  005f3	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  005f6	88 08		 mov	 BYTE PTR [rax], cl
  005f8	eb a8		 jmp	 SHORT $LN10@replace_su@2
$LN9@replace_su@2:
$LN12@replace_su@2:
  005fa	33 c0		 xor	 eax, eax
  005fc	85 c0		 test	 eax, eax
  005fe	0f 85 39 ff ff
	ff		 jne	 $LN16@replace_su@2

; 1935 :             result_s += to_len;

  00604	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR to_len$[rsp]
  0060c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result_s$[rsp]
  00611	48 03 c8	 add	 rcx, rax
  00614	48 8b c1	 mov	 rax, rcx
  00617	48 89 44 24 68	 mov	 QWORD PTR result_s$[rsp], rax

; 1936 :             start = next+from_len;

  0061c	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR from_len$[rsp]
  00624	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00629	48 03 c8	 add	 rcx, rax
  0062c	48 8b c1	 mov	 rax, rcx
  0062f	48 89 44 24 60	 mov	 QWORD PTR start$[rsp], rax
$LN25@replace_su@2:

; 1937 :         }
; 1938 :     }

  00634	e9 94 fc ff ff	 jmp	 $LN37@replace_su@2
$LN36@replace_su@2:
$LN8@replace_su@2:

; 1939 :     /* Copy the remainder of the remaining bytes */
; 1940 :     Py_MEMCPY(result_s, start, end-start);

  00639	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0063e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR end$[rsp]
  00643	48 2b c8	 sub	 rcx, rax
  00646	48 8b c1	 mov	 rax, rcx
  00649	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR n_$23508[rsp], rax
  00651	48 8b 44 24 68	 mov	 rax, QWORD PTR result_s$[rsp]
  00656	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR t_$23509[rsp], rax
  0065e	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  00663	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR s_$23511[rsp], rax
  0066b	48 83 bc 24 f8
	00 00 00 10	 cmp	 QWORD PTR n_$23508[rsp], 16
  00674	72 1f		 jb	 SHORT $LN5@replace_su@2
  00676	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR n_$23508[rsp]
  0067e	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR s_$23511[rsp]
  00686	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR t_$23509[rsp]
  0068e	e8 00 00 00 00	 call	 memcpy
  00693	eb 66		 jmp	 SHORT $LN4@replace_su@2
$LN5@replace_su@2:
  00695	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$23507[rsp], 0
  006a1	eb 13		 jmp	 SHORT $LN3@replace_su@2
$LN2@replace_su@2:
  006a3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR i_$23507[rsp]
  006ab	48 ff c0	 inc	 rax
  006ae	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR i_$23507[rsp], rax
$LN3@replace_su@2:
  006b6	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR n_$23508[rsp]
  006be	48 39 84 24 f0
	00 00 00	 cmp	 QWORD PTR i_$23507[rsp], rax
  006c6	73 33		 jae	 SHORT $LN1@replace_su@2
  006c8	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR i_$23507[rsp]
  006d0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR t_$23509[rsp]
  006d8	48 03 c8	 add	 rcx, rax
  006db	48 8b c1	 mov	 rax, rcx
  006de	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR i_$23507[rsp]
  006e6	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR s_$23511[rsp]
  006ee	48 03 d1	 add	 rdx, rcx
  006f1	48 8b ca	 mov	 rcx, rdx
  006f4	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  006f7	88 08		 mov	 BYTE PTR [rax], cl
  006f9	eb a8		 jmp	 SHORT $LN2@replace_su@2
$LN1@replace_su@2:
$LN4@replace_su@2:
  006fb	33 c0		 xor	 eax, eax
  006fd	85 c0		 test	 eax, eax
  006ff	0f 85 34 ff ff
	ff		 jne	 $LN8@replace_su@2

; 1941 : 
; 1942 :     return result;

  00705	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
$LN41@replace_su@2:

; 1943 : }

  0070a	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00711	c3		 ret	 0
replace_substring ENDP
_TEXT	ENDS
PUBLIC	??_C@_09DBJIONJK@?$HMOn?3split?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_split DD imagerel bytearray_split
	DD	imagerel bytearray_split+604
	DD	imagerel $unwind$bytearray_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_split DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_09DBJIONJK@?$HMOn?3split?$AA@
CONST	SEGMENT
??_C@_09DBJIONJK@?$HMOn?3split?$AA@ DB '|On:split', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_split
_TEXT	SEGMENT
vsub$ = 48
n$ = 128
s$ = 136
list$ = 144
len$ = 152
sub$ = 160
subobj$ = 168
maxsplit$ = 176
tv90 = 184
self$ = 208
args$ = 216
kwds$ = 224
bytearray_split PROC					; COMDAT

; 2060 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 2061 :     static char *kwlist[] = {"sep", "maxsplit", 0};
; 2062 :     Py_ssize_t len = PyByteArray_GET_SIZE(self), n;

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0001d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00025	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00029	74 38		 je	 SHORT $LN7@bytearray_@29
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00032	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00043	85 c0		 test	 eax, eax
  00045	75 1c		 jne	 SHORT $LN7@bytearray_@29
  00047	41 b8 0e 08 00
	00		 mov	 r8d, 2062		; 0000080eH
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN7@bytearray_@29:
  00063	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 2063 :     Py_ssize_t maxsplit = -1;

  00077	48 c7 84 24 b0
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR maxsplit$[rsp], -1

; 2064 :     const char *s = PyByteArray_AS_STRING(self), *sub;

  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0008a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00092	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00096	74 38		 je	 SHORT $LN8@bytearray_@29
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0009f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a7	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000ab	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b0	85 c0		 test	 eax, eax
  000b2	75 1c		 jne	 SHORT $LN8@bytearray_@29
  000b4	41 b8 10 08 00
	00		 mov	 r8d, 2064		; 00000810H
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ce	33 c0		 xor	 eax, eax
$LN8@bytearray_@29:
  000d0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000d8	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000dd	74 19		 je	 SHORT $LN9@bytearray_@29
  000df	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000e7	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000ee	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  000f6	eb 0f		 jmp	 SHORT $LN10@bytearray_@29
$LN9@bytearray_@29:
  000f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000ff	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
$LN10@bytearray_@29:
  00107	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv90[rsp]
  0010f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 2065 :     PyObject *list, *subobj = Py_None;

  00117	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0011e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR subobj$[rsp], rax

; 2066 :     Py_buffer vsub;
; 2067 : 
; 2068 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|On:split",
; 2069 :                                      kwlist, &subobj, &maxsplit))

  00126	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR maxsplit$[rsp]
  0012e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00133	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR subobj$[rsp]
  0013b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00140	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytearray_split@@9@9
  00147	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09DBJIONJK@?$HMOn?3split?$AA@
  0014e	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00156	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0015e	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00163	85 c0		 test	 eax, eax
  00165	75 07		 jne	 SHORT $LN4@bytearray_@29

; 2070 :         return NULL;

  00167	33 c0		 xor	 eax, eax
  00169	e9 e6 00 00 00	 jmp	 $LN5@bytearray_@29
$LN4@bytearray_@29:

; 2071 :     if (maxsplit < 0)

  0016e	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR maxsplit$[rsp], 0
  00177	7d 12		 jge	 SHORT $LN3@bytearray_@29

; 2072 :         maxsplit = PY_SSIZE_T_MAX;

  00179	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00183	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR maxsplit$[rsp], rax
$LN3@bytearray_@29:

; 2073 : 
; 2074 :     if (subobj == Py_None)

  0018b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00192	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR subobj$[rsp], rax
  0019a	75 2a		 jne	 SHORT $LN2@bytearray_@29

; 2075 :         return stringlib_split_whitespace((PyObject*) self, s, len, maxsplit);

  0019c	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR maxsplit$[rsp]
  001a4	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR len$[rsp]
  001ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  001b4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001bc	e8 00 00 00 00	 call	 stringlib_split_whitespace
  001c1	e9 8e 00 00 00	 jmp	 $LN5@bytearray_@29
$LN2@bytearray_@29:

; 2076 : 
; 2077 :     if (_getbuffer(subobj, &vsub) < 0)

  001c6	48 8d 54 24 30	 lea	 rdx, QWORD PTR vsub$[rsp]
  001cb	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR subobj$[rsp]
  001d3	e8 00 00 00 00	 call	 _getbuffer
  001d8	48 85 c0	 test	 rax, rax
  001db	7d 04		 jge	 SHORT $LN1@bytearray_@29

; 2078 :         return NULL;

  001dd	33 c0		 xor	 eax, eax
  001df	eb 73		 jmp	 SHORT $LN5@bytearray_@29
$LN1@bytearray_@29:

; 2079 :     sub = vsub.buf;

  001e1	48 8b 44 24 30	 mov	 rax, QWORD PTR vsub$[rsp]
  001e6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR sub$[rsp], rax

; 2080 :     n = vsub.len;

  001ee	48 8b 44 24 40	 mov	 rax, QWORD PTR vsub$[rsp+16]
  001f3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2081 : 
; 2082 :     list = stringlib_split(
; 2083 :         (PyObject*) self, s, len, sub, n, maxsplit
; 2084 :         );

  001fb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR maxsplit$[rsp]
  00203	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00208	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00210	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00215	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR sub$[rsp]
  0021d	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR len$[rsp]
  00225	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0022d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00235	e8 00 00 00 00	 call	 stringlib_split
  0023a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR list$[rsp], rax

; 2085 :     PyBuffer_Release(&vsub);

  00242	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vsub$[rsp]
  00247	e8 00 00 00 00	 call	 PyBuffer_Release

; 2086 :     return list;

  0024c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR list$[rsp]
$LN5@bytearray_@29:

; 2087 : }

  00254	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0025b	c3		 ret	 0
bytearray_split ENDP
_TEXT	ENDS
EXTRN	PyList_Append:PROC
EXTRN	_Py_ctype_table:BYTE
EXTRN	PyList_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\split.h
pdata	SEGMENT
$pdata$stringlib_split_whitespace DD imagerel stringlib_split_whitespace
	DD	imagerel stringlib_split_whitespace+763
	DD	imagerel $unwind$stringlib_split_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_split_whitespace DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_split_whitespace
_TEXT	SEGMENT
count$ = 32
i$ = 40
list$ = 48
sub$ = 56
j$ = 64
tv67 = 72
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
stringlib_split_whitespace PROC				; COMDAT

; 57   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 58   :     Py_ssize_t i, j, count=0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 59   :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	48 83 7c 24 78
	0c		 cmp	 QWORD PTR maxcount$[rsp], 12
  00027	7c 0b		 jl	 SHORT $LN25@stringlib_@26
  00029	48 c7 44 24 48
	0c 00 00 00	 mov	 QWORD PTR tv67[rsp], 12
  00032	eb 0d		 jmp	 SHORT $LN26@stringlib_@26
$LN25@stringlib_@26:
  00034	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  00039	48 ff c0	 inc	 rax
  0003c	48 89 44 24 48	 mov	 QWORD PTR tv67[rsp], rax
$LN26@stringlib_@26:
  00041	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv67[rsp]
  00046	e8 00 00 00 00	 call	 PyList_New
  0004b	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 60   :     PyObject *sub;
; 61   : 
; 62   :     if (list == NULL)

  00050	48 83 7c 24 30
	00		 cmp	 QWORD PTR list$[rsp], 0
  00056	75 07		 jne	 SHORT $LN22@stringlib_@26

; 63   :         return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 97 02 00 00	 jmp	 $LN23@stringlib_@26
$LN22@stringlib_@26:

; 64   : 
; 65   :     i = j = 0;

  0005f	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0006d	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN21@stringlib_@26:

; 66   :     while (maxcount-- > 0) {

  00072	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  00077	48 8b 4c 24 78	 mov	 rcx, QWORD PTR maxcount$[rsp]
  0007c	48 ff c9	 dec	 rcx
  0007f	48 89 4c 24 78	 mov	 QWORD PTR maxcount$[rsp], rcx
  00084	48 85 c0	 test	 rax, rax
  00087	0f 8e 51 01 00
	00		 jle	 $LN20@stringlib_@26
$LN19@stringlib_@26:

; 67   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  0008d	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00092	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00097	7d 3b		 jge	 SHORT $LN18@stringlib_@26
  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0009e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b1	0f b6 c0	 movzx	 eax, al
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000bb	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000be	83 e0 08	 and	 eax, 8
  000c1	85 c0		 test	 eax, eax
  000c3	74 0f		 je	 SHORT $LN18@stringlib_@26

; 68   :             i++;

  000c5	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000ca	48 ff c0	 inc	 rax
  000cd	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  000d2	eb b9		 jmp	 SHORT $LN19@stringlib_@26
$LN18@stringlib_@26:

; 69   :         if (i == str_len) break;

  000d4	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  000d9	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000de	75 05		 jne	 SHORT $LN17@stringlib_@26
  000e0	e9 f9 00 00 00	 jmp	 $LN20@stringlib_@26
$LN17@stringlib_@26:

; 70   :         j = i; i++;

  000e5	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000ea	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
  000ef	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000f4	48 ff c0	 inc	 rax
  000f7	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN16@stringlib_@26:

; 71   :         while (i < str_len && !STRINGLIB_ISSPACE(str[i]))

  000fc	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00101	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00106	7d 3b		 jge	 SHORT $LN15@stringlib_@26
  00108	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0010d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  00112	48 03 c8	 add	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0011b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00120	0f b6 c0	 movzx	 eax, al
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0012a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0012d	83 e0 08	 and	 eax, 8
  00130	85 c0		 test	 eax, eax
  00132	75 0f		 jne	 SHORT $LN15@stringlib_@26

; 72   :             i++;

  00134	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00139	48 ff c0	 inc	 rax
  0013c	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00141	eb b9		 jmp	 SHORT $LN16@stringlib_@26
$LN15@stringlib_@26:

; 73   : #ifndef STRINGLIB_MUTABLE
; 74   :         if (j == 0 && i == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {
; 75   :             /* No whitespace in str_obj, so just use it as list[0] */
; 76   :             Py_INCREF(str_obj);
; 77   :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 78   :             count++;
; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  00143	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00148	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0014d	48 2b c8	 sub	 rcx, rax
  00150	48 8b c1	 mov	 rax, rcx
  00153	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00158	48 8b 54 24 68	 mov	 rdx, QWORD PTR str$[rsp]
  0015d	48 03 d1	 add	 rdx, rcx
  00160	48 8b ca	 mov	 rcx, rdx
  00163	48 8b d0	 mov	 rdx, rax
  00166	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0016b	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  00170	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  00176	75 05		 jne	 SHORT $LN14@stringlib_@26
  00178	e9 6d 01 00 00	 jmp	 $onError$21585
$LN14@stringlib_@26:
  0017d	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  00183	7d 19		 jge	 SHORT $LN13@stringlib_@26
  00185	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  0018a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0018e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00193	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00198	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  0019c	eb 2e		 jmp	 SHORT $LN12@stringlib_@26
$LN13@stringlib_@26:
  0019e	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  001a3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  001a8	e8 00 00 00 00	 call	 PyList_Append
  001ad	85 c0		 test	 eax, eax
  001af	74 11		 je	 SHORT $LN11@stringlib_@26
  001b1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  001b6	e8 00 00 00 00	 call	 _Py_DecRef
  001bb	e9 2a 01 00 00	 jmp	 $onError$21585
  001c0	eb 0a		 jmp	 SHORT $LN10@stringlib_@26
$LN11@stringlib_@26:
  001c2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  001c7	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@stringlib_@26:
$LN12@stringlib_@26:
  001cc	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  001d1	48 ff c0	 inc	 rax
  001d4	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 83   :     }

  001d9	e9 94 fe ff ff	 jmp	 $LN21@stringlib_@26
$LN20@stringlib_@26:

; 84   : 
; 85   :     if (i < str_len) {

  001de	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  001e3	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  001e8	0f 8d e7 00 00
	00		 jge	 $LN9@stringlib_@26
$LN8@stringlib_@26:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  001ee	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  001f3	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  001f8	7d 3b		 jge	 SHORT $LN7@stringlib_@26
  001fa	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  001ff	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  00204	48 03 c8	 add	 rcx, rax
  00207	48 8b c1	 mov	 rax, rcx
  0020a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0020d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00212	0f b6 c0	 movzx	 eax, al
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0021c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0021f	83 e0 08	 and	 eax, 8
  00222	85 c0		 test	 eax, eax
  00224	74 0f		 je	 SHORT $LN7@stringlib_@26

; 89   :             i++;

  00226	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0022b	48 ff c0	 inc	 rax
  0022e	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00233	eb b9		 jmp	 SHORT $LN8@stringlib_@26
$LN7@stringlib_@26:

; 90   :         if (i != str_len)

  00235	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  0023a	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0023f	0f 84 90 00 00
	00		 je	 $LN6@stringlib_@26

; 91   :             SPLIT_ADD(str, i, str_len);

  00245	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0024a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR str_len$[rsp]
  0024f	48 2b c8	 sub	 rcx, rax
  00252	48 8b c1	 mov	 rax, rcx
  00255	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0025a	48 8b 54 24 68	 mov	 rdx, QWORD PTR str$[rsp]
  0025f	48 03 d1	 add	 rdx, rcx
  00262	48 8b ca	 mov	 rcx, rdx
  00265	48 8b d0	 mov	 rdx, rax
  00268	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0026d	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  00272	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  00278	75 02		 jne	 SHORT $LN5@stringlib_@26
  0027a	eb 6e		 jmp	 SHORT $onError$21585
$LN5@stringlib_@26:
  0027c	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  00282	7d 19		 jge	 SHORT $LN4@stringlib_@26
  00284	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00289	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0028d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00292	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00297	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  0029b	eb 2b		 jmp	 SHORT $LN3@stringlib_@26
$LN4@stringlib_@26:
  0029d	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  002a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  002a7	e8 00 00 00 00	 call	 PyList_Append
  002ac	85 c0		 test	 eax, eax
  002ae	74 0e		 je	 SHORT $LN2@stringlib_@26
  002b0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  002b5	e8 00 00 00 00	 call	 _Py_DecRef
  002ba	eb 2e		 jmp	 SHORT $onError$21585
  002bc	eb 0a		 jmp	 SHORT $LN1@stringlib_@26
$LN2@stringlib_@26:
  002be	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  002c3	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@stringlib_@26:
$LN3@stringlib_@26:
  002c8	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  002cd	48 ff c0	 inc	 rax
  002d0	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
$LN6@stringlib_@26:
$LN9@stringlib_@26:

; 92   :     }
; 93   :     FIX_PREALLOC_SIZE(list);

  002d5	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  002da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  002df	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 94   :     return list;

  002e3	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  002e8	eb 0c		 jmp	 SHORT $LN23@stringlib_@26
$onError$21585:

; 95   : 
; 96   :   onError:
; 97   :     Py_DECREF(list);

  002ea	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  002ef	e8 00 00 00 00	 call	 _Py_DecRef

; 98   :     return NULL;

  002f4	33 c0		 xor	 eax, eax
$LN23@stringlib_@26:

; 99   : }

  002f6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002fa	c3		 ret	 0
stringlib_split_whitespace ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@JDENDMBF@empty?5separator?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_split DD imagerel stringlib_split
	DD	imagerel stringlib_split+753
	DD	imagerel $unwind$stringlib_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_split DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT ??_C@_0BA@JDENDMBF@empty?5separator?$AA@
CONST	SEGMENT
??_C@_0BA@JDENDMBF@empty?5separator?$AA@ DB 'empty separator', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stringlib_split
_TEXT	SEGMENT
count$ = 48
i$ = 56
list$ = 64
sub$ = 72
pos$ = 80
j$ = 88
tv77 = 96
str_obj$ = 128
str$ = 136
str_len$ = 144
sep$ = 152
sep_len$ = 160
maxcount$ = 168
stringlib_split PROC					; COMDAT

; 149  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 150  :     Py_ssize_t i, j, pos, count=0;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 151  :     PyObject *list, *sub;
; 152  : 
; 153  :     if (sep_len == 0) {

  00021	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR sep_len$[rsp], 0
  0002a	75 1c		 jne	 SHORT $LN17@stringlib_@27

; 154  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003a	e8 00 00 00 00	 call	 PyErr_SetString

; 155  :         return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 a6 02 00 00	 jmp	 $LN18@stringlib_@27
  00046	eb 46		 jmp	 SHORT $LN16@stringlib_@27
$LN17@stringlib_@27:

; 156  :     }
; 157  :     else if (sep_len == 1)

  00048	48 83 bc 24 a0
	00 00 00 01	 cmp	 QWORD PTR sep_len$[rsp], 1
  00051	75 3b		 jne	 SHORT $LN15@stringlib_@27

; 158  :         return STRINGLIB(split_char)(str_obj, str, str_len, sep[0], maxcount);

  00053	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0005b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00060	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  00068	44 0f b6 08	 movzx	 r9d, BYTE PTR [rax]
  0006c	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR str_len$[rsp]
  00074	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  0007c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str_obj$[rsp]
  00084	e8 00 00 00 00	 call	 stringlib_split_char
  00089	e9 5e 02 00 00	 jmp	 $LN18@stringlib_@27
$LN15@stringlib_@27:
$LN16@stringlib_@27:

; 159  : 
; 160  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  0008e	48 83 bc 24 a8
	00 00 00 0c	 cmp	 QWORD PTR maxcount$[rsp], 12
  00097	7c 0b		 jl	 SHORT $LN20@stringlib_@27
  00099	48 c7 44 24 60
	0c 00 00 00	 mov	 QWORD PTR tv77[rsp], 12
  000a2	eb 10		 jmp	 SHORT $LN21@stringlib_@27
$LN20@stringlib_@27:
  000a4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000ac	48 ff c0	 inc	 rax
  000af	48 89 44 24 60	 mov	 QWORD PTR tv77[rsp], rax
$LN21@stringlib_@27:
  000b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv77[rsp]
  000b9	e8 00 00 00 00	 call	 PyList_New
  000be	48 89 44 24 40	 mov	 QWORD PTR list$[rsp], rax

; 161  :     if (list == NULL)

  000c3	48 83 7c 24 40
	00		 cmp	 QWORD PTR list$[rsp], 0
  000c9	75 07		 jne	 SHORT $LN14@stringlib_@27

; 162  :         return NULL;

  000cb	33 c0		 xor	 eax, eax
  000cd	e9 1a 02 00 00	 jmp	 $LN18@stringlib_@27
$LN14@stringlib_@27:

; 163  : 
; 164  :     i = j = 0;

  000d2	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  000db	48 8b 44 24 58	 mov	 rax, QWORD PTR j$[rsp]
  000e0	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN13@stringlib_@27:

; 165  :     while (maxcount-- > 0) {

  000e5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000ed	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR maxcount$[rsp]
  000f5	48 ff c9	 dec	 rcx
  000f8	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR maxcount$[rsp], rcx
  00100	48 85 c0	 test	 rax, rax
  00103	0f 8e 2c 01 00
	00		 jle	 $LN12@stringlib_@27

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

  00109	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0010e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR str_len$[rsp]
  00116	48 2b c8	 sub	 rcx, rax
  00119	48 8b c1	 mov	 rax, rcx
  0011c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00121	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  00129	48 03 d1	 add	 rdx, rcx
  0012c	48 8b ca	 mov	 rcx, rdx
  0012f	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  00137	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  00140	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR sep_len$[rsp]
  00148	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR sep$[rsp]
  00150	48 8b d0	 mov	 rdx, rax
  00153	e8 00 00 00 00	 call	 fastsearch
  00158	48 89 44 24 50	 mov	 QWORD PTR pos$[rsp], rax

; 167  :         if (pos < 0)

  0015d	48 83 7c 24 50
	00		 cmp	 QWORD PTR pos$[rsp], 0
  00163	7d 05		 jge	 SHORT $LN11@stringlib_@27

; 168  :             break;

  00165	e9 cb 00 00 00	 jmp	 $LN12@stringlib_@27
$LN11@stringlib_@27:

; 169  :         j = i + pos;

  0016a	48 8b 44 24 50	 mov	 rax, QWORD PTR pos$[rsp]
  0016f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00174	48 03 c8	 add	 rcx, rax
  00177	48 8b c1	 mov	 rax, rcx
  0017a	48 89 44 24 58	 mov	 QWORD PTR j$[rsp], rax

; 170  :         SPLIT_ADD(str, i, j);

  0017f	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00184	48 8b 4c 24 58	 mov	 rcx, QWORD PTR j$[rsp]
  00189	48 2b c8	 sub	 rcx, rax
  0018c	48 8b c1	 mov	 rax, rcx
  0018f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00194	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  0019c	48 03 d1	 add	 rdx, rcx
  0019f	48 8b ca	 mov	 rcx, rdx
  001a2	48 8b d0	 mov	 rdx, rax
  001a5	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  001aa	48 89 44 24 48	 mov	 QWORD PTR sub$[rsp], rax
  001af	48 83 7c 24 48
	00		 cmp	 QWORD PTR sub$[rsp], 0
  001b5	75 05		 jne	 SHORT $LN10@stringlib_@27
  001b7	e9 24 01 00 00	 jmp	 $onError$21694
$LN10@stringlib_@27:
  001bc	48 83 7c 24 30
	0c		 cmp	 QWORD PTR count$[rsp], 12
  001c2	7d 19		 jge	 SHORT $LN9@stringlib_@27
  001c4	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  001c9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  001d2	48 8b 54 24 48	 mov	 rdx, QWORD PTR sub$[rsp]
  001d7	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  001db	eb 2e		 jmp	 SHORT $LN8@stringlib_@27
$LN9@stringlib_@27:
  001dd	48 8b 54 24 48	 mov	 rdx, QWORD PTR sub$[rsp]
  001e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  001e7	e8 00 00 00 00	 call	 PyList_Append
  001ec	85 c0		 test	 eax, eax
  001ee	74 11		 je	 SHORT $LN7@stringlib_@27
  001f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sub$[rsp]
  001f5	e8 00 00 00 00	 call	 _Py_DecRef
  001fa	e9 e1 00 00 00	 jmp	 $onError$21694
  001ff	eb 0a		 jmp	 SHORT $LN6@stringlib_@27
$LN7@stringlib_@27:
  00201	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sub$[rsp]
  00206	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@stringlib_@27:
$LN8@stringlib_@27:
  0020b	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  00210	48 ff c0	 inc	 rax
  00213	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax

; 171  :         i = j + sep_len;

  00218	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep_len$[rsp]
  00220	48 8b 4c 24 58	 mov	 rcx, QWORD PTR j$[rsp]
  00225	48 03 c8	 add	 rcx, rax
  00228	48 8b c1	 mov	 rax, rcx
  0022b	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax

; 172  :     }

  00230	e9 b0 fe ff ff	 jmp	 $LN13@stringlib_@27
$LN12@stringlib_@27:

; 173  : #ifndef STRINGLIB_MUTABLE
; 174  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 175  :         /* No match in str_obj, so just use it as list[0] */
; 176  :         Py_INCREF(str_obj);
; 177  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 178  :         count++;
; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00235	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0023a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR str_len$[rsp]
  00242	48 2b c8	 sub	 rcx, rax
  00245	48 8b c1	 mov	 rax, rcx
  00248	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0024d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  00255	48 03 d1	 add	 rdx, rcx
  00258	48 8b ca	 mov	 rcx, rdx
  0025b	48 8b d0	 mov	 rdx, rax
  0025e	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00263	48 89 44 24 48	 mov	 QWORD PTR sub$[rsp], rax
  00268	48 83 7c 24 48
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0026e	75 02		 jne	 SHORT $LN5@stringlib_@27
  00270	eb 6e		 jmp	 SHORT $onError$21694
$LN5@stringlib_@27:
  00272	48 83 7c 24 30
	0c		 cmp	 QWORD PTR count$[rsp], 12
  00278	7d 19		 jge	 SHORT $LN4@stringlib_@27
  0027a	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  0027f	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00283	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  00288	48 8b 54 24 48	 mov	 rdx, QWORD PTR sub$[rsp]
  0028d	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00291	eb 2b		 jmp	 SHORT $LN3@stringlib_@27
$LN4@stringlib_@27:
  00293	48 8b 54 24 48	 mov	 rdx, QWORD PTR sub$[rsp]
  00298	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  0029d	e8 00 00 00 00	 call	 PyList_Append
  002a2	85 c0		 test	 eax, eax
  002a4	74 0e		 je	 SHORT $LN2@stringlib_@27
  002a6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sub$[rsp]
  002ab	e8 00 00 00 00	 call	 _Py_DecRef
  002b0	eb 2e		 jmp	 SHORT $onError$21694
  002b2	eb 0a		 jmp	 SHORT $LN1@stringlib_@27
$LN2@stringlib_@27:
  002b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sub$[rsp]
  002b9	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@stringlib_@27:
$LN3@stringlib_@27:
  002be	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  002c3	48 ff c0	 inc	 rax
  002c6	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  002cb	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  002d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  002d5	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 185  :     return list;

  002d9	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  002de	eb 0c		 jmp	 SHORT $LN18@stringlib_@27
$onError$21694:

; 186  : 
; 187  :   onError:
; 188  :     Py_DECREF(list);

  002e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  002e5	e8 00 00 00 00	 call	 _Py_DecRef

; 189  :     return NULL;

  002ea	33 c0		 xor	 eax, eax
$LN18@stringlib_@27:

; 190  : }

  002ec	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002f0	c3		 ret	 0
stringlib_split ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_split_char DD imagerel stringlib_split_char
	DD	imagerel stringlib_split_char+618
	DD	imagerel $unwind$stringlib_split_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_split_char DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_split_char
_TEXT	SEGMENT
count$ = 32
i$ = 40
list$ = 48
sub$ = 56
j$ = 64
tv67 = 72
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
stringlib_split_char PROC				; COMDAT

; 106  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 107  :     Py_ssize_t i, j, count=0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 108  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	48 83 bc 24 80
	00 00 00 0c	 cmp	 QWORD PTR maxcount$[rsp], 12
  0002a	7c 0b		 jl	 SHORT $LN21@stringlib_@28
  0002c	48 c7 44 24 48
	0c 00 00 00	 mov	 QWORD PTR tv67[rsp], 12
  00035	eb 10		 jmp	 SHORT $LN22@stringlib_@28
$LN21@stringlib_@28:
  00037	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0003f	48 ff c0	 inc	 rax
  00042	48 89 44 24 48	 mov	 QWORD PTR tv67[rsp], rax
$LN22@stringlib_@28:
  00047	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv67[rsp]
  0004c	e8 00 00 00 00	 call	 PyList_New
  00051	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 109  :     PyObject *sub;
; 110  : 
; 111  :     if (list == NULL)

  00056	48 83 7c 24 30
	00		 cmp	 QWORD PTR list$[rsp], 0
  0005c	75 07		 jne	 SHORT $LN18@stringlib_@28

; 112  :         return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 00 02 00 00	 jmp	 $LN19@stringlib_@28
$LN18@stringlib_@28:

; 113  : 
; 114  :     i = j = 0;

  00065	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00073	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN17@stringlib_@28:

; 115  :     while ((j < str_len) && (maxcount-- > 0)) {

  00078	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  0007d	48 39 44 24 40	 cmp	 QWORD PTR j$[rsp], rax
  00082	0f 8d 1c 01 00
	00		 jge	 $LN16@stringlib_@28
  00088	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00090	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR maxcount$[rsp]
  00098	48 ff c9	 dec	 rcx
  0009b	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR maxcount$[rsp], rcx
  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 8e f8 00 00
	00		 jle	 $LN16@stringlib_@28

; 116  :         for(; j < str_len; j++) {

  000ac	eb 0d		 jmp	 SHORT $LN15@stringlib_@28
$LN14@stringlib_@28:
  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000b3	48 ff c0	 inc	 rax
  000b6	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
$LN15@stringlib_@28:
  000bb	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  000c0	48 39 44 24 40	 cmp	 QWORD PTR j$[rsp], rax
  000c5	0f 8d d4 00 00
	00		 jge	 $LN13@stringlib_@28

; 117  :             /* I found that using memchr makes no difference */
; 118  :             if (str[j] == ch) {

  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000d5	48 03 c8	 add	 rcx, rax
  000d8	48 8b c1	 mov	 rax, rcx
  000db	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000de	0f be 4c 24 78	 movsx	 ecx, BYTE PTR ch$[rsp]
  000e3	3b c1		 cmp	 eax, ecx
  000e5	0f 85 af 00 00
	00		 jne	 $LN12@stringlib_@28

; 119  :                 SPLIT_ADD(str, i, j);

  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000f5	48 2b c8	 sub	 rcx, rax
  000f8	48 8b c1	 mov	 rax, rcx
  000fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00100	48 8b 54 24 68	 mov	 rdx, QWORD PTR str$[rsp]
  00105	48 03 d1	 add	 rdx, rcx
  00108	48 8b ca	 mov	 rcx, rdx
  0010b	48 8b d0	 mov	 rdx, rax
  0010e	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00113	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  00118	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0011e	75 05		 jne	 SHORT $LN11@stringlib_@28
  00120	e9 34 01 00 00	 jmp	 $onError$21640
$LN11@stringlib_@28:
  00125	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  0012b	7d 19		 jge	 SHORT $LN10@stringlib_@28
  0012d	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00132	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00136	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  0013b	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00140	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00144	eb 2e		 jmp	 SHORT $LN9@stringlib_@28
$LN10@stringlib_@28:
  00146	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  0014b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00150	e8 00 00 00 00	 call	 PyList_Append
  00155	85 c0		 test	 eax, eax
  00157	74 11		 je	 SHORT $LN8@stringlib_@28
  00159	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0015e	e8 00 00 00 00	 call	 _Py_DecRef
  00163	e9 f1 00 00 00	 jmp	 $onError$21640
  00168	eb 0a		 jmp	 SHORT $LN7@stringlib_@28
$LN8@stringlib_@28:
  0016a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0016f	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@stringlib_@28:
$LN9@stringlib_@28:
  00174	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00179	48 ff c0	 inc	 rax
  0017c	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 120  :                 i = j = j + 1;

  00181	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00186	48 ff c0	 inc	 rax
  00189	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
  0018e	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00193	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax

; 121  :                 break;

  00198	eb 05		 jmp	 SHORT $LN13@stringlib_@28
$LN12@stringlib_@28:

; 122  :             }
; 123  :         }

  0019a	e9 0f ff ff ff	 jmp	 $LN14@stringlib_@28
$LN13@stringlib_@28:

; 124  :     }

  0019f	e9 d4 fe ff ff	 jmp	 $LN17@stringlib_@28
$LN16@stringlib_@28:

; 125  : #ifndef STRINGLIB_MUTABLE
; 126  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 127  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 128  :         Py_INCREF(str_obj);
; 129  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 130  :         count++;
; 131  :     } else
; 132  : #endif
; 133  :     if (i <= str_len) {

  001a4	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  001a9	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  001ae	0f 8f 90 00 00
	00		 jg	 $LN6@stringlib_@28

; 134  :         SPLIT_ADD(str, i, str_len);

  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  001b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR str_len$[rsp]
  001be	48 2b c8	 sub	 rcx, rax
  001c1	48 8b c1	 mov	 rax, rcx
  001c4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  001c9	48 8b 54 24 68	 mov	 rdx, QWORD PTR str$[rsp]
  001ce	48 03 d1	 add	 rdx, rcx
  001d1	48 8b ca	 mov	 rcx, rdx
  001d4	48 8b d0	 mov	 rdx, rax
  001d7	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  001dc	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  001e1	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  001e7	75 02		 jne	 SHORT $LN5@stringlib_@28
  001e9	eb 6e		 jmp	 SHORT $onError$21640
$LN5@stringlib_@28:
  001eb	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  001f1	7d 19		 jge	 SHORT $LN4@stringlib_@28
  001f3	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  001f8	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001fc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00201	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00206	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  0020a	eb 2b		 jmp	 SHORT $LN3@stringlib_@28
$LN4@stringlib_@28:
  0020c	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00211	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00216	e8 00 00 00 00	 call	 PyList_Append
  0021b	85 c0		 test	 eax, eax
  0021d	74 0e		 je	 SHORT $LN2@stringlib_@28
  0021f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  00224	e8 00 00 00 00	 call	 _Py_DecRef
  00229	eb 2e		 jmp	 SHORT $onError$21640
  0022b	eb 0a		 jmp	 SHORT $LN1@stringlib_@28
$LN2@stringlib_@28:
  0022d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  00232	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@stringlib_@28:
$LN3@stringlib_@28:
  00237	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  0023c	48 ff c0	 inc	 rax
  0023f	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
$LN6@stringlib_@28:

; 135  :     }
; 136  :     FIX_PREALLOC_SIZE(list);

  00244	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00249	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  0024e	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 137  :     return list;

  00252	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00257	eb 0c		 jmp	 SHORT $LN19@stringlib_@28
$onError$21640:

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

  00259	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0025e	e8 00 00 00 00	 call	 _Py_DecRef

; 141  :     return NULL;

  00263	33 c0		 xor	 eax, eax
$LN19@stringlib_@28:

; 142  : }

  00265	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00269	c3		 ret	 0
stringlib_split_char ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DG@MPOCBDEI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AAe?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytearrayobject.c
pdata	SEGMENT
$pdata$bytearray_partition DD imagerel bytearray_partition
	DD	imagerel bytearray_partition+492
	DD	imagerel $unwind$bytearray_partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_partition DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1DG@MPOCBDEI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AAe?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@MPOCBDEI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AAe?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'b', 00H, 'y', 00H
	DB	't', 00H, 'e', 00H, 's', 00H, 'e', 00H, 'p', 00H, ')', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_partition
_TEXT	SEGMENT
bytesep$ = 48
result$ = 56
tv95 = 64
tv157 = 72
self$ = 96
sep_obj$ = 104
bytearray_partition PROC				; COMDAT

; 2098 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2099 :     PyObject *bytesep, *result;
; 2100 : 
; 2101 :     bytesep = PyByteArray_FromObject(sep_obj);

  0000e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  00013	e8 00 00 00 00	 call	 PyByteArray_FromObject
  00018	48 89 44 24 30	 mov	 QWORD PTR bytesep$[rsp], rax

; 2102 :     if (! bytesep)

  0001d	48 83 7c 24 30
	00		 cmp	 QWORD PTR bytesep$[rsp], 0
  00023	75 07		 jne	 SHORT $LN1@bytearray_@30

; 2103 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	e9 bb 01 00 00	 jmp	 $LN2@bytearray_@30
$LN1@bytearray_@30:

; 2104 : 
; 2105 :     result = stringlib_partition(
; 2106 :             (PyObject*) self,
; 2107 :             PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self),
; 2108 :             bytesep,
; 2109 :             PyByteArray_AS_STRING(bytesep), PyByteArray_GET_SIZE(bytesep)
; 2110 :             );

  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytesep$[rsp]
  00038	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003c	74 35		 je	 SHORT $LN4@bytearray_@30
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR bytesep$[rsp]
  0004a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00053	85 c0		 test	 eax, eax
  00055	75 1c		 jne	 SHORT $LN4@bytearray_@30
  00057	41 b8 3d 08 00
	00		 mov	 r8d, 2109		; 0000083dH
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MPOCBDEI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AAe?$AAp?$AA?$CJ?$AA?$AA@
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00071	33 c0		 xor	 eax, eax
$LN4@bytearray_@30:
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytesep$[rsp]
  0007f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00083	74 35		 je	 SHORT $LN5@bytearray_@30
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0008c	48 8b 44 24 30	 mov	 rax, QWORD PTR bytesep$[rsp]
  00091	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00095	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009a	85 c0		 test	 eax, eax
  0009c	75 1c		 jne	 SHORT $LN5@bytearray_@30
  0009e	41 b8 3d 08 00
	00		 mov	 r8d, 2109		; 0000083dH
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MPOCBDEI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AAe?$AAp?$AA?$CJ?$AA?$AA@
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b8	33 c0		 xor	 eax, eax
$LN5@bytearray_@30:
  000ba	48 8b 44 24 30	 mov	 rax, QWORD PTR bytesep$[rsp]
  000bf	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000c4	74 13		 je	 SHORT $LN6@bytearray_@30
  000c6	48 8b 44 24 30	 mov	 rax, QWORD PTR bytesep$[rsp]
  000cb	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000d2	48 89 44 24 40	 mov	 QWORD PTR tv95[rsp], rax
  000d7	eb 0c		 jmp	 SHORT $LN7@bytearray_@30
$LN6@bytearray_@30:
  000d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000e0	48 89 44 24 40	 mov	 QWORD PTR tv95[rsp], rax
$LN7@bytearray_@30:
  000e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000f1	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f5	74 35		 je	 SHORT $LN8@bytearray_@30
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00103	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00107	e8 00 00 00 00	 call	 PyType_IsSubtype
  0010c	85 c0		 test	 eax, eax
  0010e	75 1c		 jne	 SHORT $LN8@bytearray_@30
  00110	41 b8 3b 08 00
	00		 mov	 r8d, 2107		; 0000083bH
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0012a	33 c0		 xor	 eax, eax
$LN8@bytearray_@30:
  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00133	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00138	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0013c	74 35		 je	 SHORT $LN9@bytearray_@30
  0013e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00145	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0014a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0014e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00153	85 c0		 test	 eax, eax
  00155	75 1c		 jne	 SHORT $LN9@bytearray_@30
  00157	41 b8 3b 08 00
	00		 mov	 r8d, 2107		; 0000083bH
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00171	33 c0		 xor	 eax, eax
$LN9@bytearray_@30:
  00173	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00178	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0017d	74 13		 je	 SHORT $LN10@bytearray_@30
  0017f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00184	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0018b	48 89 44 24 48	 mov	 QWORD PTR tv157[rsp], rax
  00190	eb 0c		 jmp	 SHORT $LN11@bytearray_@30
$LN10@bytearray_@30:
  00192	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00199	48 89 44 24 48	 mov	 QWORD PTR tv157[rsp], rax
$LN11@bytearray_@30:
  0019e	48 8b 44 24 30	 mov	 rax, QWORD PTR bytesep$[rsp]
  001a3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001a7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ac	48 8b 44 24 40	 mov	 rax, QWORD PTR tv95[rsp]
  001b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b6	4c 8b 4c 24 30	 mov	 r9, QWORD PTR bytesep$[rsp]
  001bb	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001c0	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  001c4	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv157[rsp]
  001c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001ce	e8 00 00 00 00	 call	 stringlib_partition
  001d3	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 2111 : 
; 2112 :     Py_DECREF(bytesep);

  001d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytesep$[rsp]
  001dd	e8 00 00 00 00	 call	 _Py_DecRef

; 2113 :     return result;

  001e2	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN2@bytearray_@30:

; 2114 : }

  001e7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001eb	c3		 ret	 0
bytearray_partition ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\partition.h
pdata	SEGMENT
$pdata$stringlib_partition DD imagerel stringlib_partition
	DD	imagerel stringlib_partition+371
	DD	imagerel $unwind$stringlib_partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_partition DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_partition
_TEXT	SEGMENT
out$ = 48
pos$ = 56
str_obj$ = 80
str$ = 88
str_len$ = 96
sep_obj$ = 104
sep$ = 112
sep_len$ = 120
stringlib_partition PROC				; COMDAT

; 12   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 13   :     PyObject* out;
; 14   :     Py_ssize_t pos;
; 15   : 
; 16   :     if (sep_len == 0) {

  00018	48 83 7c 24 78
	00		 cmp	 QWORD PTR sep_len$[rsp], 0
  0001e	75 1a		 jne	 SHORT $LN4@stringlib_@29

; 17   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002e	e8 00 00 00 00	 call	 PyErr_SetString

; 18   :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 34 01 00 00	 jmp	 $LN5@stringlib_@29
$LN4@stringlib_@29:

; 19   :     }
; 20   : 
; 21   :     out = PyTuple_New(3);

  0003a	b9 03 00 00 00	 mov	 ecx, 3
  0003f	e8 00 00 00 00	 call	 PyTuple_New
  00044	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax

; 22   :     if (!out)

  00049	48 83 7c 24 30
	00		 cmp	 QWORD PTR out$[rsp], 0
  0004f	75 07		 jne	 SHORT $LN3@stringlib_@29

; 23   :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	e9 16 01 00 00	 jmp	 $LN5@stringlib_@29
$LN3@stringlib_@29:

; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

  00058	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  00060	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  00069	4c 8b 4c 24 78	 mov	 r9, QWORD PTR sep_len$[rsp]
  0006e	4c 8b 44 24 70	 mov	 r8, QWORD PTR sep$[rsp]
  00073	48 8b 54 24 60	 mov	 rdx, QWORD PTR str_len$[rsp]
  00078	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  0007d	e8 00 00 00 00	 call	 fastsearch
  00082	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 26   : 
; 27   :     if (pos < 0) {

  00087	48 83 7c 24 38
	00		 cmp	 QWORD PTR pos$[rsp], 0
  0008d	7d 49		 jge	 SHORT $LN2@stringlib_@29

; 28   : #if STRINGLIB_MUTABLE
; 29   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, str_len));

  0008f	48 8b 54 24 60	 mov	 rdx, QWORD PTR str_len$[rsp]
  00094	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  00099	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  000a3	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 30   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));

  000a7	33 d2		 xor	 edx, edx
  000a9	33 c9		 xor	 ecx, ecx
  000ab	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  000b5	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 31   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(NULL, 0));

  000b9	33 d2		 xor	 edx, edx
  000bb	33 c9		 xor	 ecx, ecx
  000bd	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  000c7	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 32   : #else
; 33   :         Py_INCREF(str_obj);
; 34   :         PyTuple_SET_ITEM(out, 0, (PyObject*) str_obj);
; 35   :         Py_INCREF(STRINGLIB_EMPTY);
; 36   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);
; 37   :         Py_INCREF(STRINGLIB_EMPTY);
; 38   :         PyTuple_SET_ITEM(out, 2, (PyObject*) STRINGLIB_EMPTY);
; 39   : #endif
; 40   :         return out;

  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000d3	e9 96 00 00 00	 jmp	 $LN5@stringlib_@29
$LN2@stringlib_@29:

; 41   :     }
; 42   : 
; 43   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  000d8	48 8b 54 24 38	 mov	 rdx, QWORD PTR pos$[rsp]
  000dd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  000e2	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  000ec	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 44   :     Py_INCREF(sep_obj);

  000f0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  000f5	e8 00 00 00 00	 call	 _Py_IncRef

; 45   :     PyTuple_SET_ITEM(out, 1, sep_obj);

  000fa	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000ff	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  00104	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 46   :     pos += sep_len;

  00108	48 8b 44 24 78	 mov	 rax, QWORD PTR sep_len$[rsp]
  0010d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pos$[rsp]
  00112	48 03 c8	 add	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 47   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  0011d	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_len$[rsp]
  00127	48 2b c8	 sub	 rcx, rax
  0012a	48 8b c1	 mov	 rax, rcx
  0012d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pos$[rsp]
  00132	48 8b 54 24 58	 mov	 rdx, QWORD PTR str$[rsp]
  00137	48 03 d1	 add	 rdx, rcx
  0013a	48 8b ca	 mov	 rcx, rdx
  0013d	48 8b d0	 mov	 rdx, rax
  00140	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00145	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0014a	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 48   : 
; 49   :     if (PyErr_Occurred()) {

  00151	e8 00 00 00 00	 call	 PyErr_Occurred
  00156	48 85 c0	 test	 rax, rax
  00159	74 0e		 je	 SHORT $LN1@stringlib_@29

; 50   :         Py_DECREF(out);

  0015b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00160	e8 00 00 00 00	 call	 _Py_DecRef

; 51   :         return NULL;

  00165	33 c0		 xor	 eax, eax
  00167	eb 05		 jmp	 SHORT $LN5@stringlib_@29
$LN1@stringlib_@29:

; 52   :     }
; 53   : 
; 54   :     return out;

  00169	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
$LN5@stringlib_@29:

; 55   : }

  0016e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00172	c3		 ret	 0
stringlib_partition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytearrayobject.c
pdata	SEGMENT
$pdata$bytearray_rpartition DD imagerel bytearray_rpartition
	DD	imagerel bytearray_rpartition+492
	DD	imagerel $unwind$bytearray_rpartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_rpartition DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_rpartition
_TEXT	SEGMENT
bytesep$ = 48
result$ = 56
tv95 = 64
tv157 = 72
self$ = 96
sep_obj$ = 104
bytearray_rpartition PROC				; COMDAT

; 2126 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2127 :     PyObject *bytesep, *result;
; 2128 : 
; 2129 :     bytesep = PyByteArray_FromObject(sep_obj);

  0000e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  00013	e8 00 00 00 00	 call	 PyByteArray_FromObject
  00018	48 89 44 24 30	 mov	 QWORD PTR bytesep$[rsp], rax

; 2130 :     if (! bytesep)

  0001d	48 83 7c 24 30
	00		 cmp	 QWORD PTR bytesep$[rsp], 0
  00023	75 07		 jne	 SHORT $LN1@bytearray_@31

; 2131 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	e9 bb 01 00 00	 jmp	 $LN2@bytearray_@31
$LN1@bytearray_@31:

; 2132 : 
; 2133 :     result = stringlib_rpartition(
; 2134 :             (PyObject*) self,
; 2135 :             PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self),
; 2136 :             bytesep,
; 2137 :             PyByteArray_AS_STRING(bytesep), PyByteArray_GET_SIZE(bytesep)
; 2138 :             );

  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytesep$[rsp]
  00038	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003c	74 35		 je	 SHORT $LN4@bytearray_@31
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR bytesep$[rsp]
  0004a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00053	85 c0		 test	 eax, eax
  00055	75 1c		 jne	 SHORT $LN4@bytearray_@31
  00057	41 b8 59 08 00
	00		 mov	 r8d, 2137		; 00000859H
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MPOCBDEI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AAe?$AAp?$AA?$CJ?$AA?$AA@
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00071	33 c0		 xor	 eax, eax
$LN4@bytearray_@31:
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytesep$[rsp]
  0007f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00083	74 35		 je	 SHORT $LN5@bytearray_@31
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0008c	48 8b 44 24 30	 mov	 rax, QWORD PTR bytesep$[rsp]
  00091	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00095	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009a	85 c0		 test	 eax, eax
  0009c	75 1c		 jne	 SHORT $LN5@bytearray_@31
  0009e	41 b8 59 08 00
	00		 mov	 r8d, 2137		; 00000859H
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MPOCBDEI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AAe?$AAp?$AA?$CJ?$AA?$AA@
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b8	33 c0		 xor	 eax, eax
$LN5@bytearray_@31:
  000ba	48 8b 44 24 30	 mov	 rax, QWORD PTR bytesep$[rsp]
  000bf	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000c4	74 13		 je	 SHORT $LN6@bytearray_@31
  000c6	48 8b 44 24 30	 mov	 rax, QWORD PTR bytesep$[rsp]
  000cb	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000d2	48 89 44 24 40	 mov	 QWORD PTR tv95[rsp], rax
  000d7	eb 0c		 jmp	 SHORT $LN7@bytearray_@31
$LN6@bytearray_@31:
  000d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000e0	48 89 44 24 40	 mov	 QWORD PTR tv95[rsp], rax
$LN7@bytearray_@31:
  000e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000f1	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f5	74 35		 je	 SHORT $LN8@bytearray_@31
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00103	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00107	e8 00 00 00 00	 call	 PyType_IsSubtype
  0010c	85 c0		 test	 eax, eax
  0010e	75 1c		 jne	 SHORT $LN8@bytearray_@31
  00110	41 b8 57 08 00
	00		 mov	 r8d, 2135		; 00000857H
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0012a	33 c0		 xor	 eax, eax
$LN8@bytearray_@31:
  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00133	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00138	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0013c	74 35		 je	 SHORT $LN9@bytearray_@31
  0013e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00145	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0014a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0014e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00153	85 c0		 test	 eax, eax
  00155	75 1c		 jne	 SHORT $LN9@bytearray_@31
  00157	41 b8 57 08 00
	00		 mov	 r8d, 2135		; 00000857H
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00171	33 c0		 xor	 eax, eax
$LN9@bytearray_@31:
  00173	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00178	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0017d	74 13		 je	 SHORT $LN10@bytearray_@31
  0017f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00184	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0018b	48 89 44 24 48	 mov	 QWORD PTR tv157[rsp], rax
  00190	eb 0c		 jmp	 SHORT $LN11@bytearray_@31
$LN10@bytearray_@31:
  00192	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00199	48 89 44 24 48	 mov	 QWORD PTR tv157[rsp], rax
$LN11@bytearray_@31:
  0019e	48 8b 44 24 30	 mov	 rax, QWORD PTR bytesep$[rsp]
  001a3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001a7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ac	48 8b 44 24 40	 mov	 rax, QWORD PTR tv95[rsp]
  001b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b6	4c 8b 4c 24 30	 mov	 r9, QWORD PTR bytesep$[rsp]
  001bb	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001c0	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  001c4	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv157[rsp]
  001c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001ce	e8 00 00 00 00	 call	 stringlib_rpartition
  001d3	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 2139 : 
; 2140 :     Py_DECREF(bytesep);

  001d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytesep$[rsp]
  001dd	e8 00 00 00 00	 call	 _Py_DecRef

; 2141 :     return result;

  001e2	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN2@bytearray_@31:

; 2142 : }

  001e7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001eb	c3		 ret	 0
bytearray_rpartition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\partition.h
pdata	SEGMENT
$pdata$stringlib_rpartition DD imagerel stringlib_rpartition
	DD	imagerel stringlib_rpartition+371
	DD	imagerel $unwind$stringlib_rpartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rpartition DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rpartition
_TEXT	SEGMENT
out$ = 48
pos$ = 56
str_obj$ = 80
str$ = 88
str_len$ = 96
sep_obj$ = 104
sep$ = 112
sep_len$ = 120
stringlib_rpartition PROC				; COMDAT

; 62   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 63   :     PyObject* out;
; 64   :     Py_ssize_t pos;
; 65   : 
; 66   :     if (sep_len == 0) {

  00018	48 83 7c 24 78
	00		 cmp	 QWORD PTR sep_len$[rsp], 0
  0001e	75 1a		 jne	 SHORT $LN4@stringlib_@30

; 67   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002e	e8 00 00 00 00	 call	 PyErr_SetString

; 68   :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 34 01 00 00	 jmp	 $LN5@stringlib_@30
$LN4@stringlib_@30:

; 69   :     }
; 70   : 
; 71   :     out = PyTuple_New(3);

  0003a	b9 03 00 00 00	 mov	 ecx, 3
  0003f	e8 00 00 00 00	 call	 PyTuple_New
  00044	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax

; 72   :     if (!out)

  00049	48 83 7c 24 30
	00		 cmp	 QWORD PTR out$[rsp], 0
  0004f	75 07		 jne	 SHORT $LN3@stringlib_@30

; 73   :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	e9 16 01 00 00	 jmp	 $LN5@stringlib_@30
$LN3@stringlib_@30:

; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

  00058	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  00060	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  00069	4c 8b 4c 24 78	 mov	 r9, QWORD PTR sep_len$[rsp]
  0006e	4c 8b 44 24 70	 mov	 r8, QWORD PTR sep$[rsp]
  00073	48 8b 54 24 60	 mov	 rdx, QWORD PTR str_len$[rsp]
  00078	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  0007d	e8 00 00 00 00	 call	 fastsearch
  00082	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 76   : 
; 77   :     if (pos < 0) {

  00087	48 83 7c 24 38
	00		 cmp	 QWORD PTR pos$[rsp], 0
  0008d	7d 49		 jge	 SHORT $LN2@stringlib_@30

; 78   : #if STRINGLIB_MUTABLE
; 79   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(NULL, 0));

  0008f	33 d2		 xor	 edx, edx
  00091	33 c9		 xor	 ecx, ecx
  00093	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00098	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0009d	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 80   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));

  000a1	33 d2		 xor	 edx, edx
  000a3	33 c9		 xor	 ecx, ecx
  000a5	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  000af	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 81   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str, str_len));

  000b3	48 8b 54 24 60	 mov	 rdx, QWORD PTR str_len$[rsp]
  000b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  000bd	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  000c7	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 82   : #else
; 83   :         Py_INCREF(STRINGLIB_EMPTY);
; 84   :         PyTuple_SET_ITEM(out, 0, (PyObject*) STRINGLIB_EMPTY);
; 85   :         Py_INCREF(STRINGLIB_EMPTY);
; 86   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);
; 87   :         Py_INCREF(str_obj);
; 88   :         PyTuple_SET_ITEM(out, 2, (PyObject*) str_obj);
; 89   : #endif
; 90   :         return out;

  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000d3	e9 96 00 00 00	 jmp	 $LN5@stringlib_@30
$LN2@stringlib_@30:

; 91   :     }
; 92   : 
; 93   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  000d8	48 8b 54 24 38	 mov	 rdx, QWORD PTR pos$[rsp]
  000dd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  000e2	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  000ec	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 94   :     Py_INCREF(sep_obj);

  000f0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  000f5	e8 00 00 00 00	 call	 _Py_IncRef

; 95   :     PyTuple_SET_ITEM(out, 1, sep_obj);

  000fa	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000ff	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sep_obj$[rsp]
  00104	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 96   :     pos += sep_len;

  00108	48 8b 44 24 78	 mov	 rax, QWORD PTR sep_len$[rsp]
  0010d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pos$[rsp]
  00112	48 03 c8	 add	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 97   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  0011d	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str_len$[rsp]
  00127	48 2b c8	 sub	 rcx, rax
  0012a	48 8b c1	 mov	 rax, rcx
  0012d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pos$[rsp]
  00132	48 8b 54 24 58	 mov	 rdx, QWORD PTR str$[rsp]
  00137	48 03 d1	 add	 rdx, rcx
  0013a	48 8b ca	 mov	 rcx, rdx
  0013d	48 8b d0	 mov	 rdx, rax
  00140	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00145	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0014a	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 98   : 
; 99   :     if (PyErr_Occurred()) {

  00151	e8 00 00 00 00	 call	 PyErr_Occurred
  00156	48 85 c0	 test	 rax, rax
  00159	74 0e		 je	 SHORT $LN1@stringlib_@30

; 100  :         Py_DECREF(out);

  0015b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00160	e8 00 00 00 00	 call	 _Py_DecRef

; 101  :         return NULL;

  00165	33 c0		 xor	 eax, eax
  00167	eb 05		 jmp	 SHORT $LN5@stringlib_@30
$LN1@stringlib_@30:

; 102  :     }
; 103  : 
; 104  :     return out;

  00169	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
$LN5@stringlib_@30:

; 105  : }

  0016e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00172	c3		 ret	 0
stringlib_rpartition ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytearrayobject.c
pdata	SEGMENT
$pdata$bytearray_rsplit DD imagerel bytearray_rsplit
	DD	imagerel bytearray_rsplit+604
	DD	imagerel $unwind$bytearray_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_rsplit DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@
CONST	SEGMENT
??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@ DB '|On:rsplit', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_rsplit
_TEXT	SEGMENT
vsub$ = 48
n$ = 128
s$ = 136
list$ = 144
len$ = 152
sub$ = 160
subobj$ = 168
maxsplit$ = 176
tv90 = 184
self$ = 208
args$ = 216
kwds$ = 224
bytearray_rsplit PROC					; COMDAT

; 2155 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 2156 :     static char *kwlist[] = {"sep", "maxsplit", 0};
; 2157 :     Py_ssize_t len = PyByteArray_GET_SIZE(self), n;

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0001d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00025	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00029	74 38		 je	 SHORT $LN7@bytearray_@32
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00032	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00043	85 c0		 test	 eax, eax
  00045	75 1c		 jne	 SHORT $LN7@bytearray_@32
  00047	41 b8 6d 08 00
	00		 mov	 r8d, 2157		; 0000086dH
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN7@bytearray_@32:
  00063	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 2158 :     Py_ssize_t maxsplit = -1;

  00077	48 c7 84 24 b0
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR maxsplit$[rsp], -1

; 2159 :     const char *s = PyByteArray_AS_STRING(self), *sub;

  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0008a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00092	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00096	74 38		 je	 SHORT $LN8@bytearray_@32
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0009f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a7	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000ab	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b0	85 c0		 test	 eax, eax
  000b2	75 1c		 jne	 SHORT $LN8@bytearray_@32
  000b4	41 b8 6f 08 00
	00		 mov	 r8d, 2159		; 0000086fH
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ce	33 c0		 xor	 eax, eax
$LN8@bytearray_@32:
  000d0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000d8	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000dd	74 19		 je	 SHORT $LN9@bytearray_@32
  000df	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000e7	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000ee	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  000f6	eb 0f		 jmp	 SHORT $LN10@bytearray_@32
$LN9@bytearray_@32:
  000f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  000ff	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
$LN10@bytearray_@32:
  00107	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv90[rsp]
  0010f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 2160 :     PyObject *list, *subobj = Py_None;

  00117	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0011e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR subobj$[rsp], rax

; 2161 :     Py_buffer vsub;
; 2162 : 
; 2163 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|On:rsplit",
; 2164 :                                      kwlist, &subobj, &maxsplit))

  00126	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR maxsplit$[rsp]
  0012e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00133	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR subobj$[rsp]
  0013b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00140	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytearray_rsplit@@9@9
  00147	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@
  0014e	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00156	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0015e	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00163	85 c0		 test	 eax, eax
  00165	75 07		 jne	 SHORT $LN4@bytearray_@32

; 2165 :         return NULL;

  00167	33 c0		 xor	 eax, eax
  00169	e9 e6 00 00 00	 jmp	 $LN5@bytearray_@32
$LN4@bytearray_@32:

; 2166 :     if (maxsplit < 0)

  0016e	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR maxsplit$[rsp], 0
  00177	7d 12		 jge	 SHORT $LN3@bytearray_@32

; 2167 :         maxsplit = PY_SSIZE_T_MAX;

  00179	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00183	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR maxsplit$[rsp], rax
$LN3@bytearray_@32:

; 2168 : 
; 2169 :     if (subobj == Py_None)

  0018b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00192	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR subobj$[rsp], rax
  0019a	75 2a		 jne	 SHORT $LN2@bytearray_@32

; 2170 :         return stringlib_rsplit_whitespace((PyObject*) self, s, len, maxsplit);

  0019c	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR maxsplit$[rsp]
  001a4	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR len$[rsp]
  001ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  001b4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001bc	e8 00 00 00 00	 call	 stringlib_rsplit_whitespace
  001c1	e9 8e 00 00 00	 jmp	 $LN5@bytearray_@32
$LN2@bytearray_@32:

; 2171 : 
; 2172 :     if (_getbuffer(subobj, &vsub) < 0)

  001c6	48 8d 54 24 30	 lea	 rdx, QWORD PTR vsub$[rsp]
  001cb	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR subobj$[rsp]
  001d3	e8 00 00 00 00	 call	 _getbuffer
  001d8	48 85 c0	 test	 rax, rax
  001db	7d 04		 jge	 SHORT $LN1@bytearray_@32

; 2173 :         return NULL;

  001dd	33 c0		 xor	 eax, eax
  001df	eb 73		 jmp	 SHORT $LN5@bytearray_@32
$LN1@bytearray_@32:

; 2174 :     sub = vsub.buf;

  001e1	48 8b 44 24 30	 mov	 rax, QWORD PTR vsub$[rsp]
  001e6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR sub$[rsp], rax

; 2175 :     n = vsub.len;

  001ee	48 8b 44 24 40	 mov	 rax, QWORD PTR vsub$[rsp+16]
  001f3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2176 : 
; 2177 :     list = stringlib_rsplit(
; 2178 :         (PyObject*) self, s, len, sub, n, maxsplit
; 2179 :         );

  001fb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR maxsplit$[rsp]
  00203	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00208	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00210	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00215	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR sub$[rsp]
  0021d	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR len$[rsp]
  00225	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0022d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00235	e8 00 00 00 00	 call	 stringlib_rsplit
  0023a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR list$[rsp], rax

; 2180 :     PyBuffer_Release(&vsub);

  00242	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vsub$[rsp]
  00247	e8 00 00 00 00	 call	 PyBuffer_Release

; 2181 :     return list;

  0024c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR list$[rsp]
$LN5@bytearray_@32:

; 2182 : }

  00254	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0025b	c3		 ret	 0
bytearray_rsplit ENDP
_TEXT	ENDS
EXTRN	PyList_Reverse:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\split.h
pdata	SEGMENT
$pdata$stringlib_rsplit_whitespace DD imagerel stringlib_rsplit_whitespace
	DD	imagerel stringlib_rsplit_whitespace+738
	DD	imagerel $unwind$stringlib_rsplit_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rsplit_whitespace DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rsplit_whitespace
_TEXT	SEGMENT
count$ = 32
i$ = 40
list$ = 48
sub$ = 56
j$ = 64
tv67 = 72
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
stringlib_rsplit_whitespace PROC			; COMDAT

; 196  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 197  :     Py_ssize_t i, j, count=0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 198  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	48 83 7c 24 78
	0c		 cmp	 QWORD PTR maxcount$[rsp], 12
  00027	7c 0b		 jl	 SHORT $LN26@stringlib_@31
  00029	48 c7 44 24 48
	0c 00 00 00	 mov	 QWORD PTR tv67[rsp], 12
  00032	eb 0d		 jmp	 SHORT $LN27@stringlib_@31
$LN26@stringlib_@31:
  00034	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  00039	48 ff c0	 inc	 rax
  0003c	48 89 44 24 48	 mov	 QWORD PTR tv67[rsp], rax
$LN27@stringlib_@31:
  00041	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv67[rsp]
  00046	e8 00 00 00 00	 call	 PyList_New
  0004b	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 199  :     PyObject *sub;
; 200  : 
; 201  :     if (list == NULL)

  00050	48 83 7c 24 30
	00		 cmp	 QWORD PTR list$[rsp], 0
  00056	75 07		 jne	 SHORT $LN23@stringlib_@31

; 202  :         return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 7e 02 00 00	 jmp	 $LN24@stringlib_@31
$LN23@stringlib_@31:

; 203  : 
; 204  :     i = j = str_len - 1;

  0005f	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  00064	48 ff c8	 dec	 rax
  00067	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00071	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN22@stringlib_@31:

; 205  :     while (maxcount-- > 0) {

  00076	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  0007b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR maxcount$[rsp]
  00080	48 ff c9	 dec	 rcx
  00083	48 89 4c 24 78	 mov	 QWORD PTR maxcount$[rsp], rcx
  00088	48 85 c0	 test	 rax, rax
  0008b	0f 8e 47 01 00
	00		 jle	 $LN21@stringlib_@31
$LN20@stringlib_@31:

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  00091	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00097	7c 3b		 jl	 SHORT $LN19@stringlib_@31
  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0009e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b1	0f b6 c0	 movzx	 eax, al
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000bb	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000be	83 e0 08	 and	 eax, 8
  000c1	85 c0		 test	 eax, eax
  000c3	74 0f		 je	 SHORT $LN19@stringlib_@31

; 207  :             i--;

  000c5	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000ca	48 ff c8	 dec	 rax
  000cd	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  000d2	eb bd		 jmp	 SHORT $LN20@stringlib_@31
$LN19@stringlib_@31:

; 208  :         if (i < 0) break;

  000d4	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000da	7d 05		 jge	 SHORT $LN18@stringlib_@31
  000dc	e9 f7 00 00 00	 jmp	 $LN21@stringlib_@31
$LN18@stringlib_@31:

; 209  :         j = i; i--;

  000e1	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000e6	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000f0	48 ff c8	 dec	 rax
  000f3	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN17@stringlib_@31:

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000f8	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000fe	7c 3b		 jl	 SHORT $LN16@stringlib_@31
  00100	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00105	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  0010a	48 03 c8	 add	 rcx, rax
  0010d	48 8b c1	 mov	 rax, rcx
  00110	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00113	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00118	0f b6 c0	 movzx	 eax, al
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00122	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00125	83 e0 08	 and	 eax, 8
  00128	85 c0		 test	 eax, eax
  0012a	75 0f		 jne	 SHORT $LN16@stringlib_@31

; 211  :             i--;

  0012c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00131	48 ff c8	 dec	 rax
  00134	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00139	eb bd		 jmp	 SHORT $LN17@stringlib_@31
$LN16@stringlib_@31:

; 212  : #ifndef STRINGLIB_MUTABLE
; 213  :         if (j == str_len - 1 && i < 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 214  :             /* No whitespace in str_obj, so just use it as list[0] */
; 215  :             Py_INCREF(str_obj);
; 216  :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 217  :             count++;
; 218  :             break;
; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  0013b	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00140	48 ff c0	 inc	 rax
  00143	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00148	48 ff c1	 inc	 rcx
  0014b	48 2b c1	 sub	 rax, rcx
  0014e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  00153	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00158	48 8d 4c 11 01	 lea	 rcx, QWORD PTR [rcx+rdx+1]
  0015d	48 8b d0	 mov	 rdx, rax
  00160	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00165	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  0016a	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  00170	75 05		 jne	 SHORT $LN15@stringlib_@31
  00172	e9 5a 01 00 00	 jmp	 $onError$21746
$LN15@stringlib_@31:
  00177	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  0017d	7d 19		 jge	 SHORT $LN14@stringlib_@31
  0017f	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00184	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00188	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  0018d	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00192	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00196	eb 2e		 jmp	 SHORT $LN13@stringlib_@31
$LN14@stringlib_@31:
  00198	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  0019d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  001a2	e8 00 00 00 00	 call	 PyList_Append
  001a7	85 c0		 test	 eax, eax
  001a9	74 11		 je	 SHORT $LN12@stringlib_@31
  001ab	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  001b0	e8 00 00 00 00	 call	 _Py_DecRef
  001b5	e9 17 01 00 00	 jmp	 $onError$21746
  001ba	eb 0a		 jmp	 SHORT $LN11@stringlib_@31
$LN12@stringlib_@31:
  001bc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  001c1	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@stringlib_@31:
$LN13@stringlib_@31:
  001c6	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  001cb	48 ff c0	 inc	 rax
  001ce	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 222  :     }

  001d3	e9 9e fe ff ff	 jmp	 $LN22@stringlib_@31
$LN21@stringlib_@31:

; 223  : 
; 224  :     if (i >= 0) {

  001d8	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  001de	0f 8c c8 00 00
	00		 jl	 $LN10@stringlib_@31
$LN9@stringlib_@31:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  001e4	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  001ea	7c 3b		 jl	 SHORT $LN8@stringlib_@31
  001ec	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  001f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  001f6	48 03 c8	 add	 rcx, rax
  001f9	48 8b c1	 mov	 rax, rcx
  001fc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001ff	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00204	0f b6 c0	 movzx	 eax, al
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0020e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00211	83 e0 08	 and	 eax, 8
  00214	85 c0		 test	 eax, eax
  00216	74 0f		 je	 SHORT $LN8@stringlib_@31

; 228  :             i--;

  00218	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0021d	48 ff c8	 dec	 rax
  00220	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00225	eb bd		 jmp	 SHORT $LN9@stringlib_@31
$LN8@stringlib_@31:

; 229  :         if (i >= 0)

  00227	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  0022d	7c 7d		 jl	 SHORT $LN7@stringlib_@31

; 230  :             SPLIT_ADD(str, 0, i + 1);

  0022f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00234	48 ff c0	 inc	 rax
  00237	48 8b d0	 mov	 rdx, rax
  0023a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  0023f	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00244	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  00249	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0024f	75 02		 jne	 SHORT $LN6@stringlib_@31
  00251	eb 7e		 jmp	 SHORT $onError$21746
$LN6@stringlib_@31:
  00253	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  00259	7d 19		 jge	 SHORT $LN5@stringlib_@31
  0025b	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00260	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00264	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00269	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  0026e	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00272	eb 2b		 jmp	 SHORT $LN4@stringlib_@31
$LN5@stringlib_@31:
  00274	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00279	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0027e	e8 00 00 00 00	 call	 PyList_Append
  00283	85 c0		 test	 eax, eax
  00285	74 0e		 je	 SHORT $LN3@stringlib_@31
  00287	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0028c	e8 00 00 00 00	 call	 _Py_DecRef
  00291	eb 3e		 jmp	 SHORT $onError$21746
  00293	eb 0a		 jmp	 SHORT $LN2@stringlib_@31
$LN3@stringlib_@31:
  00295	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0029a	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@stringlib_@31:
$LN4@stringlib_@31:
  0029f	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  002a4	48 ff c0	 inc	 rax
  002a7	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
$LN7@stringlib_@31:
$LN10@stringlib_@31:

; 231  :     }
; 232  :     FIX_PREALLOC_SIZE(list);

  002ac	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  002b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  002b6	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 233  :     if (PyList_Reverse(list) < 0)

  002ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  002bf	e8 00 00 00 00	 call	 PyList_Reverse
  002c4	85 c0		 test	 eax, eax
  002c6	7d 02		 jge	 SHORT $LN1@stringlib_@31

; 234  :         goto onError;

  002c8	eb 07		 jmp	 SHORT $onError$21746
$LN1@stringlib_@31:

; 235  :     return list;

  002ca	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  002cf	eb 0c		 jmp	 SHORT $LN24@stringlib_@31
$onError$21746:

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  002d1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  002d6	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  002db	33 c0		 xor	 eax, eax
$LN24@stringlib_@31:

; 240  : }

  002dd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002e1	c3		 ret	 0
stringlib_rsplit_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rsplit DD imagerel stringlib_rsplit
	DD	imagerel stringlib_rsplit+685
	DD	imagerel $unwind$stringlib_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rsplit DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rsplit
_TEXT	SEGMENT
count$ = 48
list$ = 56
sub$ = 64
pos$ = 72
j$ = 80
tv77 = 88
str_obj$ = 112
str$ = 120
str_len$ = 128
sep$ = 136
sep_len$ = 144
maxcount$ = 152
stringlib_rsplit PROC					; COMDAT

; 291  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 292  :     Py_ssize_t j, pos, count=0;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 293  :     PyObject *list, *sub;
; 294  : 
; 295  :     if (sep_len == 0) {

  00021	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR sep_len$[rsp], 0
  0002a	75 1c		 jne	 SHORT $LN18@stringlib_@32

; 296  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003a	e8 00 00 00 00	 call	 PyErr_SetString

; 297  :         return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 62 02 00 00	 jmp	 $LN19@stringlib_@32
  00046	eb 40		 jmp	 SHORT $LN17@stringlib_@32
$LN18@stringlib_@32:

; 298  :     }
; 299  :     else if (sep_len == 1)

  00048	48 83 bc 24 90
	00 00 00 01	 cmp	 QWORD PTR sep_len$[rsp], 1
  00051	75 35		 jne	 SHORT $LN16@stringlib_@32

; 300  :         return STRINGLIB(rsplit_char)(str_obj, str, str_len, sep[0], maxcount);

  00053	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0005b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00060	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  00068	44 0f b6 08	 movzx	 r9d, BYTE PTR [rax]
  0006c	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR str_len$[rsp]
  00074	48 8b 54 24 78	 mov	 rdx, QWORD PTR str$[rsp]
  00079	48 8b 4c 24 70	 mov	 rcx, QWORD PTR str_obj$[rsp]
  0007e	e8 00 00 00 00	 call	 stringlib_rsplit_char
  00083	e9 20 02 00 00	 jmp	 $LN19@stringlib_@32
$LN16@stringlib_@32:
$LN17@stringlib_@32:

; 301  : 
; 302  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  00088	48 83 bc 24 98
	00 00 00 0c	 cmp	 QWORD PTR maxcount$[rsp], 12
  00091	7c 0b		 jl	 SHORT $LN21@stringlib_@32
  00093	48 c7 44 24 58
	0c 00 00 00	 mov	 QWORD PTR tv77[rsp], 12
  0009c	eb 10		 jmp	 SHORT $LN22@stringlib_@32
$LN21@stringlib_@32:
  0009e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000a6	48 ff c0	 inc	 rax
  000a9	48 89 44 24 58	 mov	 QWORD PTR tv77[rsp], rax
$LN22@stringlib_@32:
  000ae	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv77[rsp]
  000b3	e8 00 00 00 00	 call	 PyList_New
  000b8	48 89 44 24 38	 mov	 QWORD PTR list$[rsp], rax

; 303  :     if (list == NULL)

  000bd	48 83 7c 24 38
	00		 cmp	 QWORD PTR list$[rsp], 0
  000c3	75 07		 jne	 SHORT $LN15@stringlib_@32

; 304  :         return NULL;

  000c5	33 c0		 xor	 eax, eax
  000c7	e9 dc 01 00 00	 jmp	 $LN19@stringlib_@32
$LN15@stringlib_@32:

; 305  : 
; 306  :     j = str_len;

  000cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str_len$[rsp]
  000d4	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax
$LN14@stringlib_@32:

; 307  :     while (maxcount-- > 0) {

  000d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  000e1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR maxcount$[rsp]
  000e9	48 ff c9	 dec	 rcx
  000ec	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR maxcount$[rsp], rcx
  000f4	48 85 c0	 test	 rax, rax
  000f7	0f 8e 03 01 00
	00		 jle	 $LN13@stringlib_@32

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

  000fd	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  00105	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR [rsp+32], -1
  0010e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR sep_len$[rsp]
  00116	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR sep$[rsp]
  0011e	48 8b 54 24 50	 mov	 rdx, QWORD PTR j$[rsp]
  00123	48 8b 4c 24 78	 mov	 rcx, QWORD PTR str$[rsp]
  00128	e8 00 00 00 00	 call	 fastsearch
  0012d	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 309  :         if (pos < 0)

  00132	48 83 7c 24 48
	00		 cmp	 QWORD PTR pos$[rsp], 0
  00138	7d 05		 jge	 SHORT $LN12@stringlib_@32

; 310  :             break;

  0013a	e9 c1 00 00 00	 jmp	 $LN13@stringlib_@32
$LN12@stringlib_@32:

; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  0013f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sep_len$[rsp]
  00147	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pos$[rsp]
  0014c	48 03 c8	 add	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  00157	48 2b c8	 sub	 rcx, rax
  0015a	48 8b c1	 mov	 rax, rcx
  0015d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sep_len$[rsp]
  00165	48 8b 54 24 48	 mov	 rdx, QWORD PTR pos$[rsp]
  0016a	48 03 d1	 add	 rdx, rcx
  0016d	48 8b ca	 mov	 rcx, rdx
  00170	48 8b 54 24 78	 mov	 rdx, QWORD PTR str$[rsp]
  00175	48 03 d1	 add	 rdx, rcx
  00178	48 8b ca	 mov	 rcx, rdx
  0017b	48 8b d0	 mov	 rdx, rax
  0017e	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00183	48 89 44 24 40	 mov	 QWORD PTR sub$[rsp], rax
  00188	48 83 7c 24 40
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0018e	75 05		 jne	 SHORT $LN11@stringlib_@32
  00190	e9 07 01 00 00	 jmp	 $onError$21856
$LN11@stringlib_@32:
  00195	48 83 7c 24 30
	0c		 cmp	 QWORD PTR count$[rsp], 12
  0019b	7d 19		 jge	 SHORT $LN10@stringlib_@32
  0019d	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  001a2	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  001ab	48 8b 54 24 40	 mov	 rdx, QWORD PTR sub$[rsp]
  001b0	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  001b4	eb 2e		 jmp	 SHORT $LN9@stringlib_@32
$LN10@stringlib_@32:
  001b6	48 8b 54 24 40	 mov	 rdx, QWORD PTR sub$[rsp]
  001bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$[rsp]
  001c0	e8 00 00 00 00	 call	 PyList_Append
  001c5	85 c0		 test	 eax, eax
  001c7	74 11		 je	 SHORT $LN8@stringlib_@32
  001c9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sub$[rsp]
  001ce	e8 00 00 00 00	 call	 _Py_DecRef
  001d3	e9 c4 00 00 00	 jmp	 $onError$21856
  001d8	eb 0a		 jmp	 SHORT $LN7@stringlib_@32
$LN8@stringlib_@32:
  001da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sub$[rsp]
  001df	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@stringlib_@32:
$LN9@stringlib_@32:
  001e4	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  001e9	48 ff c0	 inc	 rax
  001ec	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax

; 312  :         j = pos;

  001f1	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  001f6	48 89 44 24 50	 mov	 QWORD PTR j$[rsp], rax

; 313  :     }

  001fb	e9 d9 fe ff ff	 jmp	 $LN14@stringlib_@32
$LN13@stringlib_@32:

; 314  : #ifndef STRINGLIB_MUTABLE
; 315  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 316  :         /* No match in str_obj, so just use it as list[0] */
; 317  :         Py_INCREF(str_obj);
; 318  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 319  :         count++;
; 320  :     } else
; 321  : #endif
; 322  :     {
; 323  :         SPLIT_ADD(str, 0, j);

  00200	48 8b 54 24 50	 mov	 rdx, QWORD PTR j$[rsp]
  00205	48 8b 4c 24 78	 mov	 rcx, QWORD PTR str$[rsp]
  0020a	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0020f	48 89 44 24 40	 mov	 QWORD PTR sub$[rsp], rax
  00214	48 83 7c 24 40
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0021a	75 02		 jne	 SHORT $LN6@stringlib_@32
  0021c	eb 7e		 jmp	 SHORT $onError$21856
$LN6@stringlib_@32:
  0021e	48 83 7c 24 30
	0c		 cmp	 QWORD PTR count$[rsp], 12
  00224	7d 19		 jge	 SHORT $LN5@stringlib_@32
  00226	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  0022b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0022f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  00234	48 8b 54 24 40	 mov	 rdx, QWORD PTR sub$[rsp]
  00239	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  0023d	eb 2b		 jmp	 SHORT $LN4@stringlib_@32
$LN5@stringlib_@32:
  0023f	48 8b 54 24 40	 mov	 rdx, QWORD PTR sub$[rsp]
  00244	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$[rsp]
  00249	e8 00 00 00 00	 call	 PyList_Append
  0024e	85 c0		 test	 eax, eax
  00250	74 0e		 je	 SHORT $LN3@stringlib_@32
  00252	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sub$[rsp]
  00257	e8 00 00 00 00	 call	 _Py_DecRef
  0025c	eb 3e		 jmp	 SHORT $onError$21856
  0025e	eb 0a		 jmp	 SHORT $LN2@stringlib_@32
$LN3@stringlib_@32:
  00260	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sub$[rsp]
  00265	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@stringlib_@32:
$LN4@stringlib_@32:
  0026a	48 8b 44 24 30	 mov	 rax, QWORD PTR count$[rsp]
  0026f	48 ff c0	 inc	 rax
  00272	48 89 44 24 30	 mov	 QWORD PTR count$[rsp], rax

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);

  00277	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  0027c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR count$[rsp]
  00281	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 326  :     if (PyList_Reverse(list) < 0)

  00285	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$[rsp]
  0028a	e8 00 00 00 00	 call	 PyList_Reverse
  0028f	85 c0		 test	 eax, eax
  00291	7d 02		 jge	 SHORT $LN1@stringlib_@32

; 327  :         goto onError;

  00293	eb 07		 jmp	 SHORT $onError$21856
$LN1@stringlib_@32:

; 328  :     return list;

  00295	48 8b 44 24 38	 mov	 rax, QWORD PTR list$[rsp]
  0029a	eb 0c		 jmp	 SHORT $LN19@stringlib_@32
$onError$21856:

; 329  : 
; 330  :   onError:
; 331  :     Py_DECREF(list);

  0029c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$[rsp]
  002a1	e8 00 00 00 00	 call	 _Py_DecRef

; 332  :     return NULL;

  002a6	33 c0		 xor	 eax, eax
$LN19@stringlib_@32:

; 333  : }

  002a8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002ac	c3		 ret	 0
stringlib_rsplit ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rsplit_char DD imagerel stringlib_rsplit_char
	DD	imagerel stringlib_rsplit_char+605
	DD	imagerel $unwind$stringlib_rsplit_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rsplit_char DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_rsplit_char
_TEXT	SEGMENT
count$ = 32
i$ = 40
list$ = 48
sub$ = 56
j$ = 64
tv67 = 72
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
stringlib_rsplit_char PROC				; COMDAT

; 247  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 248  :     Py_ssize_t i, j, count=0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 249  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	48 83 bc 24 80
	00 00 00 0c	 cmp	 QWORD PTR maxcount$[rsp], 12
  0002a	7c 0b		 jl	 SHORT $LN22@stringlib_@33
  0002c	48 c7 44 24 48
	0c 00 00 00	 mov	 QWORD PTR tv67[rsp], 12
  00035	eb 10		 jmp	 SHORT $LN23@stringlib_@33
$LN22@stringlib_@33:
  00037	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0003f	48 ff c0	 inc	 rax
  00042	48 89 44 24 48	 mov	 QWORD PTR tv67[rsp], rax
$LN23@stringlib_@33:
  00047	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv67[rsp]
  0004c	e8 00 00 00 00	 call	 PyList_New
  00051	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 250  :     PyObject *sub;
; 251  : 
; 252  :     if (list == NULL)

  00056	48 83 7c 24 30
	00		 cmp	 QWORD PTR list$[rsp], 0
  0005c	75 07		 jne	 SHORT $LN19@stringlib_@33

; 253  :         return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 f3 01 00 00	 jmp	 $LN20@stringlib_@33
$LN19@stringlib_@33:

; 254  : 
; 255  :     i = j = str_len - 1;

  00065	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  0006a	48 ff c8	 dec	 rax
  0006d	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax
  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00077	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN18@stringlib_@33:

; 256  :     while ((i >= 0) && (maxcount-- > 0)) {

  0007c	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00082	0f 8c 1a 01 00
	00		 jl	 $LN17@stringlib_@33
  00088	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00090	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR maxcount$[rsp]
  00098	48 ff c9	 dec	 rcx
  0009b	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR maxcount$[rsp], rcx
  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 8e f6 00 00
	00		 jle	 $LN17@stringlib_@33

; 257  :         for(; i >= 0; i--) {

  000ac	eb 0d		 jmp	 SHORT $LN16@stringlib_@33
$LN15@stringlib_@33:
  000ae	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000b3	48 ff c8	 dec	 rax
  000b6	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN16@stringlib_@33:
  000bb	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000c1	0f 8c d6 00 00
	00		 jl	 $LN14@stringlib_@33

; 258  :             if (str[i] == ch) {

  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000da	0f be 4c 24 78	 movsx	 ecx, BYTE PTR ch$[rsp]
  000df	3b c1		 cmp	 eax, ecx
  000e1	0f 85 b1 00 00
	00		 jne	 $LN13@stringlib_@33

; 259  :                 SPLIT_ADD(str, i + 1, j + 1);

  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000ec	48 ff c0	 inc	 rax
  000ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000f4	48 ff c1	 inc	 rcx
  000f7	48 2b c1	 sub	 rax, rcx
  000fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000ff	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00104	48 8d 4c 11 01	 lea	 rcx, QWORD PTR [rcx+rdx+1]
  00109	48 8b d0	 mov	 rdx, rax
  0010c	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00111	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  00116	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  0011c	75 05		 jne	 SHORT $LN12@stringlib_@33
  0011e	e9 29 01 00 00	 jmp	 $onError$21802
$LN12@stringlib_@33:
  00123	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  00129	7d 19		 jge	 SHORT $LN11@stringlib_@33
  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00130	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00139	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  0013e	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00142	eb 2e		 jmp	 SHORT $LN10@stringlib_@33
$LN11@stringlib_@33:
  00144	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  00149	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0014e	e8 00 00 00 00	 call	 PyList_Append
  00153	85 c0		 test	 eax, eax
  00155	74 11		 je	 SHORT $LN9@stringlib_@33
  00157	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0015c	e8 00 00 00 00	 call	 _Py_DecRef
  00161	e9 e6 00 00 00	 jmp	 $onError$21802
  00166	eb 0a		 jmp	 SHORT $LN8@stringlib_@33
$LN9@stringlib_@33:
  00168	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  0016d	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@stringlib_@33:
$LN10@stringlib_@33:
  00172	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00177	48 ff c0	 inc	 rax
  0017a	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 260  :                 j = i = i - 1;

  0017f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00184	48 ff c8	 dec	 rax
  00187	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0018c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00191	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax

; 261  :                 break;

  00196	eb 05		 jmp	 SHORT $LN14@stringlib_@33
$LN13@stringlib_@33:

; 262  :             }
; 263  :         }

  00198	e9 11 ff ff ff	 jmp	 $LN15@stringlib_@33
$LN14@stringlib_@33:

; 264  :     }

  0019d	e9 da fe ff ff	 jmp	 $LN18@stringlib_@33
$LN17@stringlib_@33:

; 265  : #ifndef STRINGLIB_MUTABLE
; 266  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 267  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 268  :         Py_INCREF(str_obj);
; 269  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 270  :         count++;
; 271  :     } else
; 272  : #endif
; 273  :     if (j >= -1) {

  001a2	48 83 7c 24 40
	ff		 cmp	 QWORD PTR j$[rsp], -1
  001a8	7c 7d		 jl	 SHORT $LN7@stringlib_@33

; 274  :         SPLIT_ADD(str, 0, j + 1);

  001aa	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  001af	48 ff c0	 inc	 rax
  001b2	48 8b d0	 mov	 rdx, rax
  001b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  001ba	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  001bf	48 89 44 24 38	 mov	 QWORD PTR sub$[rsp], rax
  001c4	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub$[rsp], 0
  001ca	75 02		 jne	 SHORT $LN6@stringlib_@33
  001cc	eb 7e		 jmp	 SHORT $onError$21802
$LN6@stringlib_@33:
  001ce	48 83 7c 24 20
	0c		 cmp	 QWORD PTR count$[rsp], 12
  001d4	7d 19		 jge	 SHORT $LN5@stringlib_@33
  001d6	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  001db	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001df	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  001e4	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  001e9	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  001ed	eb 2b		 jmp	 SHORT $LN4@stringlib_@33
$LN5@stringlib_@33:
  001ef	48 8b 54 24 38	 mov	 rdx, QWORD PTR sub$[rsp]
  001f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  001f9	e8 00 00 00 00	 call	 PyList_Append
  001fe	85 c0		 test	 eax, eax
  00200	74 0e		 je	 SHORT $LN3@stringlib_@33
  00202	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  00207	e8 00 00 00 00	 call	 _Py_DecRef
  0020c	eb 3e		 jmp	 SHORT $onError$21802
  0020e	eb 0a		 jmp	 SHORT $LN2@stringlib_@33
$LN3@stringlib_@33:
  00210	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sub$[rsp]
  00215	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@stringlib_@33:
$LN4@stringlib_@33:
  0021a	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  0021f	48 ff c0	 inc	 rax
  00222	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
$LN7@stringlib_@33:

; 275  :     }
; 276  :     FIX_PREALLOC_SIZE(list);

  00227	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  0022c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  00231	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 277  :     if (PyList_Reverse(list) < 0)

  00235	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0023a	e8 00 00 00 00	 call	 PyList_Reverse
  0023f	85 c0		 test	 eax, eax
  00241	7d 02		 jge	 SHORT $LN1@stringlib_@33

; 278  :         goto onError;

  00243	eb 07		 jmp	 SHORT $onError$21802
$LN1@stringlib_@33:

; 279  :     return list;

  00245	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  0024a	eb 0c		 jmp	 SHORT $LN20@stringlib_@33
$onError$21802:

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

  0024c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00251	e8 00 00 00 00	 call	 _Py_DecRef

; 283  :     return NULL;

  00256	33 c0		 xor	 eax, eax
$LN20@stringlib_@33:

; 284  : }

  00258	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0025c	c3		 ret	 0
stringlib_rsplit_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytearrayobject.c
pdata	SEGMENT
$pdata$bytearray_reverse DD imagerel bytearray_reverse
	DD	imagerel bytearray_reverse+210
	DD	imagerel $unwind$bytearray_reverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_reverse DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_reverse
_TEXT	SEGMENT
n$ = 32
i$ = 40
tail$ = 48
head$ = 56
j$ = 64
swap$ = 72
self$ = 96
unused$ = 104
bytearray_reverse PROC					; COMDAT

; 2190 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2191 :     char swap, *head, *tail;
; 2192 :     Py_ssize_t i, j, n = Py_SIZE(self);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 2193 : 
; 2194 :     j = n / 2;

  0001c	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00021	48 99		 cdq
  00023	48 2b c2	 sub	 rax, rdx
  00026	48 d1 f8	 sar	 rax, 1
  00029	48 89 44 24 40	 mov	 QWORD PTR j$[rsp], rax

; 2195 :     head = self->ob_bytes;

  0002e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00033	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0003a	48 89 44 24 38	 mov	 QWORD PTR head$[rsp], rax

; 2196 :     tail = head + n - 1;

  0003f	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  00049	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  0004e	48 89 44 24 30	 mov	 QWORD PTR tail$[rsp], rax

; 2197 :     for (i = 0; i < j; i++) {

  00053	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0005c	eb 0d		 jmp	 SHORT $LN3@bytearray_@33
$LN2@bytearray_@33:
  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00063	48 ff c0	 inc	 rax
  00066	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN3@bytearray_@33:
  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00070	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00075	7d 43		 jge	 SHORT $LN1@bytearray_@33

; 2198 :         swap = *head;

  00077	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  0007c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007f	88 44 24 48	 mov	 BYTE PTR swap$[rsp], al

; 2199 :         *head++ = *tail;

  00083	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  00088	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tail$[rsp]
  0008d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00090	88 08		 mov	 BYTE PTR [rax], cl
  00092	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  00097	48 ff c0	 inc	 rax
  0009a	48 89 44 24 38	 mov	 QWORD PTR head$[rsp], rax

; 2200 :         *tail-- = swap;

  0009f	48 8b 44 24 30	 mov	 rax, QWORD PTR tail$[rsp]
  000a4	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR swap$[rsp]
  000a9	88 08		 mov	 BYTE PTR [rax], cl
  000ab	48 8b 44 24 30	 mov	 rax, QWORD PTR tail$[rsp]
  000b0	48 ff c8	 dec	 rax
  000b3	48 89 44 24 30	 mov	 QWORD PTR tail$[rsp], rax

; 2201 :     }

  000b8	eb a4		 jmp	 SHORT $LN2@bytearray_@33
$LN1@bytearray_@33:

; 2202 : 
; 2203 :     Py_RETURN_NONE;

  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000c1	e8 00 00 00 00	 call	 _Py_IncRef
  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2204 : }

  000cd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d1	c3		 ret	 0
bytearray_reverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@BJCCKGGB@cannot?5add?5more?5objects?5to?5bytea@ ; `string'
PUBLIC	??_C@_09EEABNKNH@nO?3insert?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_insert DD imagerel bytearray_insert
	DD	imagerel bytearray_insert+364
	DD	imagerel $unwind$bytearray_insert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_insert DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0CF@BJCCKGGB@cannot?5add?5more?5objects?5to?5bytea@
CONST	SEGMENT
??_C@_0CF@BJCCKGGB@cannot?5add?5more?5objects?5to?5bytea@ DB 'cannot add '
	DB	'more objects to bytearray', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EEABNKNH@nO?3insert?$AA@
CONST	SEGMENT
??_C@_09EEABNKNH@nO?3insert?$AA@ DB 'nO:insert', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_insert
_TEXT	SEGMENT
where$ = 32
value$ = 40
n$ = 48
ival$ = 56
tv95 = 64
self$ = 96
args$ = 104
bytearray_insert PROC					; COMDAT

; 2212 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2213 :     PyObject *value;
; 2214 :     int ival;
; 2215 :     Py_ssize_t where, n = Py_SIZE(self);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 2216 : 
; 2217 :     if (!PyArg_ParseTuple(args, "nO:insert", &where, &value))

  0001c	4c 8d 4c 24 28	 lea	 r9, QWORD PTR value$[rsp]
  00021	4c 8d 44 24 20	 lea	 r8, QWORD PTR where$[rsp]
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EEABNKNH@nO?3insert?$AA@
  0002d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00032	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00037	85 c0		 test	 eax, eax
  00039	75 07		 jne	 SHORT $LN7@bytearray_@34

; 2218 :         return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	e9 25 01 00 00	 jmp	 $LN8@bytearray_@34
$LN7@bytearray_@34:

; 2219 : 
; 2220 :     if (n == PY_SSIZE_T_MAX) {

  00042	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0004c	48 39 44 24 30	 cmp	 QWORD PTR n$[rsp], rax
  00051	75 1a		 jne	 SHORT $LN6@bytearray_@34

; 2221 :         PyErr_SetString(PyExc_OverflowError,
; 2222 :                         "cannot add more objects to bytearray");

  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@BJCCKGGB@cannot?5add?5more?5objects?5to?5bytea@
  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00061	e8 00 00 00 00	 call	 PyErr_SetString

; 2223 :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	e9 fa 00 00 00	 jmp	 $LN8@bytearray_@34
$LN6@bytearray_@34:

; 2224 :     }
; 2225 :     if (!_getbytevalue(value, &ival))

  0006d	48 8d 54 24 38	 lea	 rdx, QWORD PTR ival$[rsp]
  00072	48 8b 4c 24 28	 mov	 rcx, QWORD PTR value$[rsp]
  00077	e8 00 00 00 00	 call	 _getbytevalue
  0007c	85 c0		 test	 eax, eax
  0007e	75 07		 jne	 SHORT $LN5@bytearray_@34

; 2226 :         return NULL;

  00080	33 c0		 xor	 eax, eax
  00082	e9 e0 00 00 00	 jmp	 $LN8@bytearray_@34
$LN5@bytearray_@34:

; 2227 :     if (PyByteArray_Resize((PyObject *)self, n + 1) < 0)

  00087	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0008c	48 ff c0	 inc	 rax
  0008f	48 8b d0	 mov	 rdx, rax
  00092	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00097	e8 00 00 00 00	 call	 PyByteArray_Resize
  0009c	85 c0		 test	 eax, eax
  0009e	7d 07		 jge	 SHORT $LN4@bytearray_@34

; 2228 :         return NULL;

  000a0	33 c0		 xor	 eax, eax
  000a2	e9 c0 00 00 00	 jmp	 $LN8@bytearray_@34
$LN4@bytearray_@34:

; 2229 : 
; 2230 :     if (where < 0) {

  000a7	48 83 7c 24 20
	00		 cmp	 QWORD PTR where$[rsp], 0
  000ad	7d 26		 jge	 SHORT $LN3@bytearray_@34

; 2231 :         where += n;

  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR where$[rsp]
  000b9	48 03 c8	 add	 rcx, rax
  000bc	48 8b c1	 mov	 rax, rcx
  000bf	48 89 44 24 20	 mov	 QWORD PTR where$[rsp], rax

; 2232 :         if (where < 0)

  000c4	48 83 7c 24 20
	00		 cmp	 QWORD PTR where$[rsp], 0
  000ca	7d 09		 jge	 SHORT $LN2@bytearray_@34

; 2233 :             where = 0;

  000cc	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR where$[rsp], 0
$LN2@bytearray_@34:
$LN3@bytearray_@34:

; 2234 :     }
; 2235 :     if (where > n)

  000d5	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  000da	48 39 44 24 20	 cmp	 QWORD PTR where$[rsp], rax
  000df	7e 0a		 jle	 SHORT $LN1@bytearray_@34

; 2236 :         where = n;

  000e1	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  000e6	48 89 44 24 20	 mov	 QWORD PTR where$[rsp], rax
$LN1@bytearray_@34:

; 2237 :     memmove(self->ob_bytes + where + 1, self->ob_bytes + where, n - where);

  000eb	48 8b 44 24 20	 mov	 rax, QWORD PTR where$[rsp]
  000f0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  000f5	48 2b c8	 sub	 rcx, rax
  000f8	48 8b c1	 mov	 rax, rcx
  000fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00100	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00107	48 03 4c 24 20	 add	 rcx, QWORD PTR where$[rsp]
  0010c	48 8b 54 24 60	 mov	 rdx, QWORD PTR self$[rsp]
  00111	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00118	4c 8b 44 24 20	 mov	 r8, QWORD PTR where$[rsp]
  0011d	4a 8d 54 02 01	 lea	 rdx, QWORD PTR [rdx+r8+1]
  00122	48 89 54 24 40	 mov	 QWORD PTR tv95[rsp], rdx
  00127	4c 8b c0	 mov	 r8, rax
  0012a	48 8b d1	 mov	 rdx, rcx
  0012d	48 8b 44 24 40	 mov	 rax, QWORD PTR tv95[rsp]
  00132	48 8b c8	 mov	 rcx, rax
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2238 :     self->ob_bytes[where] = ival;

  0013b	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00140	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00147	48 8b 4c 24 20	 mov	 rcx, QWORD PTR where$[rsp]
  0014c	0f b6 54 24 38	 movzx	 edx, BYTE PTR ival$[rsp]
  00151	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2239 : 
; 2240 :     Py_RETURN_NONE;

  00154	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0015b	e8 00 00 00 00	 call	 _Py_IncRef
  00160	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@bytearray_@34:

; 2241 : }

  00167	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0016b	c3		 ret	 0
bytearray_insert ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_append DD imagerel bytearray_append
	DD	imagerel bytearray_append+169
	DD	imagerel $unwind$bytearray_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_append DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_append
_TEXT	SEGMENT
value$ = 32
n$ = 40
self$ = 64
arg$ = 72
bytearray_append PROC					; COMDAT

; 2249 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2250 :     int value;
; 2251 :     Py_ssize_t n = Py_SIZE(self);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 2252 : 
; 2253 :     if (! _getbytevalue(arg, &value))

  0001c	48 8d 54 24 20	 lea	 rdx, QWORD PTR value$[rsp]
  00021	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00026	e8 00 00 00 00	 call	 _getbytevalue
  0002b	85 c0		 test	 eax, eax
  0002d	75 04		 jne	 SHORT $LN3@bytearray_@35

; 2254 :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 71		 jmp	 SHORT $LN4@bytearray_@35
$LN3@bytearray_@35:

; 2255 :     if (n == PY_SSIZE_T_MAX) {

  00033	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0003d	48 39 44 24 28	 cmp	 QWORD PTR n$[rsp], rax
  00042	75 17		 jne	 SHORT $LN2@bytearray_@35

; 2256 :         PyErr_SetString(PyExc_OverflowError,
; 2257 :                         "cannot add more objects to bytearray");

  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@BJCCKGGB@cannot?5add?5more?5objects?5to?5bytea@
  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00052	e8 00 00 00 00	 call	 PyErr_SetString

; 2258 :         return NULL;

  00057	33 c0		 xor	 eax, eax
  00059	eb 49		 jmp	 SHORT $LN4@bytearray_@35
$LN2@bytearray_@35:

; 2259 :     }
; 2260 :     if (PyByteArray_Resize((PyObject *)self, n + 1) < 0)

  0005b	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00060	48 ff c0	 inc	 rax
  00063	48 8b d0	 mov	 rdx, rax
  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0006b	e8 00 00 00 00	 call	 PyByteArray_Resize
  00070	85 c0		 test	 eax, eax
  00072	7d 04		 jge	 SHORT $LN1@bytearray_@35

; 2261 :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	eb 2c		 jmp	 SHORT $LN4@bytearray_@35
$LN1@bytearray_@35:

; 2262 : 
; 2263 :     self->ob_bytes[n] = value;

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0007d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00084	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$[rsp]
  00089	0f b6 54 24 20	 movzx	 edx, BYTE PTR value$[rsp]
  0008e	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2264 : 
; 2265 :     Py_RETURN_NONE;

  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00098	e8 00 00 00 00	 call	 _Py_IncRef
  0009d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@bytearray_@35:

; 2266 : }

  000a4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a8	c3		 ret	 0
bytearray_append ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EC@EHCPEDJL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAo?$AAb?$AAj?$AA?$CJ@ ; `string'
EXTRN	PyIter_Next:PROC
EXTRN	_PyObject_LengthHint:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_extend DD imagerel bytearray_extend
	DD	imagerel bytearray_extend+888
	DD	imagerel $unwind$bytearray_extend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_extend DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_1EC@EHCPEDJL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAo?$AAb?$AAj?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@EHCPEDJL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAo?$AAb?$AAj?$AA?$CJ@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'b', 00H, 'y', 00H
	DB	't', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'r', 00H, 'a', 00H, 'y'
	DB	00H, '_', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_extend
_TEXT	SEGMENT
it$ = 32
value$ = 40
buf_size$ = 48
len$ = 56
buf$ = 64
bytearray_obj$ = 72
item$ = 80
tv139 = 88
tv177 = 96
self$ = 128
arg$ = 136
bytearray_extend PROC					; COMDAT

; 2275 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2276 :     PyObject *it, *item, *bytearray_obj;
; 2277 :     Py_ssize_t buf_size = 0, len = 0;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR buf_size$[rsp], 0
  00017	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0

; 2278 :     int value;
; 2279 :     char *buf;
; 2280 : 
; 2281 :     /* bytearray_setslice code only accepts something supporting PEP 3118. */
; 2282 :     if (PyObject_CheckBuffer(arg)) {

  00020	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00028	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002c	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  00034	74 6a		 je	 SHORT $LN12@bytearray_@36
  00036	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  0003e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00042	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00049	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004d	74 51		 je	 SHORT $LN12@bytearray_@36

; 2283 :         if (bytearray_setslice(self, Py_SIZE(self), Py_SIZE(self), arg) == -1)

  0004f	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR arg$[rsp]
  00057	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005f	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00063	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0006f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00077	e8 00 00 00 00	 call	 bytearray_setslice
  0007c	83 f8 ff	 cmp	 eax, -1
  0007f	75 07		 jne	 SHORT $LN11@bytearray_@36

; 2284 :             return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	e9 eb 02 00 00	 jmp	 $LN13@bytearray_@36
$LN11@bytearray_@36:

; 2285 : 
; 2286 :         Py_RETURN_NONE;

  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0008f	e8 00 00 00 00	 call	 _Py_IncRef
  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0009b	e9 d3 02 00 00	 jmp	 $LN13@bytearray_@36
$LN12@bytearray_@36:

; 2287 :     }
; 2288 : 
; 2289 :     it = PyObject_GetIter(arg);

  000a0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  000a8	e8 00 00 00 00	 call	 PyObject_GetIter
  000ad	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 2290 :     if (it == NULL)

  000b2	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  000b8	75 07		 jne	 SHORT $LN10@bytearray_@36

; 2291 :         return NULL;

  000ba	33 c0		 xor	 eax, eax
  000bc	e9 b2 02 00 00	 jmp	 $LN13@bytearray_@36
$LN10@bytearray_@36:

; 2292 : 
; 2293 :     /* Try to determine the length of the argument. 32 is arbitrary. */
; 2294 :     buf_size = _PyObject_LengthHint(arg, 32);

  000c1	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000c6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  000ce	e8 00 00 00 00	 call	 _PyObject_LengthHint
  000d3	48 89 44 24 30	 mov	 QWORD PTR buf_size$[rsp], rax

; 2295 :     if (buf_size == -1) {

  000d8	48 83 7c 24 30
	ff		 cmp	 QWORD PTR buf_size$[rsp], -1
  000de	75 11		 jne	 SHORT $LN9@bytearray_@36

; 2296 :         Py_DECREF(it);

  000e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000e5	e8 00 00 00 00	 call	 _Py_DecRef

; 2297 :         return NULL;

  000ea	33 c0		 xor	 eax, eax
  000ec	e9 82 02 00 00	 jmp	 $LN13@bytearray_@36
$LN9@bytearray_@36:

; 2298 :     }
; 2299 : 
; 2300 :     bytearray_obj = PyByteArray_FromStringAndSize(NULL, buf_size);

  000f1	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf_size$[rsp]
  000f6	33 c9		 xor	 ecx, ecx
  000f8	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000fd	48 89 44 24 48	 mov	 QWORD PTR bytearray_obj$[rsp], rax

; 2301 :     if (bytearray_obj == NULL) {

  00102	48 83 7c 24 48
	00		 cmp	 QWORD PTR bytearray_obj$[rsp], 0
  00108	75 11		 jne	 SHORT $LN8@bytearray_@36

; 2302 :         Py_DECREF(it);

  0010a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0010f	e8 00 00 00 00	 call	 _Py_DecRef

; 2303 :         return NULL;

  00114	33 c0		 xor	 eax, eax
  00116	e9 58 02 00 00	 jmp	 $LN13@bytearray_@36
$LN8@bytearray_@36:

; 2304 :     }
; 2305 :     buf = PyByteArray_AS_STRING(bytearray_obj);

  0011b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00122	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytearray_obj$[rsp]
  00127	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0012b	74 35		 je	 SHORT $LN15@bytearray_@36
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00134	48 8b 44 24 48	 mov	 rax, QWORD PTR bytearray_obj$[rsp]
  00139	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0013d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00142	85 c0		 test	 eax, eax
  00144	75 1c		 jne	 SHORT $LN15@bytearray_@36
  00146	41 b8 01 09 00
	00		 mov	 r8d, 2305		; 00000901H
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@EHCPEDJL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAo?$AAb?$AAj?$AA?$CJ@
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00160	33 c0		 xor	 eax, eax
$LN15@bytearray_@36:
  00162	48 8b 44 24 48	 mov	 rax, QWORD PTR bytearray_obj$[rsp]
  00167	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0016c	74 13		 je	 SHORT $LN16@bytearray_@36
  0016e	48 8b 44 24 48	 mov	 rax, QWORD PTR bytearray_obj$[rsp]
  00173	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0017a	48 89 44 24 58	 mov	 QWORD PTR tv139[rsp], rax
  0017f	eb 0c		 jmp	 SHORT $LN17@bytearray_@36
$LN16@bytearray_@36:
  00181	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00188	48 89 44 24 58	 mov	 QWORD PTR tv139[rsp], rax
$LN17@bytearray_@36:
  0018d	48 8b 44 24 58	 mov	 rax, QWORD PTR tv139[rsp]
  00192	48 89 44 24 40	 mov	 QWORD PTR buf$[rsp], rax
$LN7@bytearray_@36:

; 2306 : 
; 2307 :     while ((item = PyIter_Next(it)) != NULL) {

  00197	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0019c	e8 00 00 00 00	 call	 PyIter_Next
  001a1	48 89 44 24 50	 mov	 QWORD PTR item$[rsp], rax
  001a6	48 83 7c 24 50
	00		 cmp	 QWORD PTR item$[rsp], 0
  001ac	0f 84 3c 01 00
	00		 je	 $LN6@bytearray_@36

; 2308 :         if (! _getbytevalue(item, &value)) {

  001b2	48 8d 54 24 28	 lea	 rdx, QWORD PTR value$[rsp]
  001b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR item$[rsp]
  001bc	e8 00 00 00 00	 call	 _getbytevalue
  001c1	85 c0		 test	 eax, eax
  001c3	75 25		 jne	 SHORT $LN5@bytearray_@36

; 2309 :             Py_DECREF(item);

  001c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR item$[rsp]
  001ca	e8 00 00 00 00	 call	 _Py_DecRef

; 2310 :             Py_DECREF(it);

  001cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  001d4	e8 00 00 00 00	 call	 _Py_DecRef

; 2311 :             Py_DECREF(bytearray_obj);

  001d9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytearray_obj$[rsp]
  001de	e8 00 00 00 00	 call	 _Py_DecRef

; 2312 :             return NULL;

  001e3	33 c0		 xor	 eax, eax
  001e5	e9 89 01 00 00	 jmp	 $LN13@bytearray_@36
$LN5@bytearray_@36:

; 2313 :         }
; 2314 :         buf[len++] = value;

  001ea	48 8b 44 24 38	 mov	 rax, QWORD PTR len$[rsp]
  001ef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf$[rsp]
  001f4	48 03 c8	 add	 rcx, rax
  001f7	48 8b c1	 mov	 rax, rcx
  001fa	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR value$[rsp]
  001ff	88 08		 mov	 BYTE PTR [rax], cl
  00201	48 8b 44 24 38	 mov	 rax, QWORD PTR len$[rsp]
  00206	48 ff c0	 inc	 rax
  00209	48 89 44 24 38	 mov	 QWORD PTR len$[rsp], rax

; 2315 :         Py_DECREF(item);

  0020e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR item$[rsp]
  00213	e8 00 00 00 00	 call	 _Py_DecRef

; 2316 : 
; 2317 :         if (len >= buf_size) {

  00218	48 8b 44 24 30	 mov	 rax, QWORD PTR buf_size$[rsp]
  0021d	48 39 44 24 38	 cmp	 QWORD PTR len$[rsp], rax
  00222	0f 8c c1 00 00
	00		 jl	 $LN4@bytearray_@36

; 2318 :             buf_size = len + (len >> 1) + 1;

  00228	48 8b 44 24 38	 mov	 rax, QWORD PTR len$[rsp]
  0022d	48 d1 f8	 sar	 rax, 1
  00230	48 8b 4c 24 38	 mov	 rcx, QWORD PTR len$[rsp]
  00235	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  0023a	48 89 44 24 30	 mov	 QWORD PTR buf_size$[rsp], rax

; 2319 :             if (PyByteArray_Resize((PyObject *)bytearray_obj, buf_size) < 0) {

  0023f	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf_size$[rsp]
  00244	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytearray_obj$[rsp]
  00249	e8 00 00 00 00	 call	 PyByteArray_Resize
  0024e	85 c0		 test	 eax, eax
  00250	7d 1b		 jge	 SHORT $LN3@bytearray_@36

; 2320 :                 Py_DECREF(it);

  00252	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00257	e8 00 00 00 00	 call	 _Py_DecRef

; 2321 :                 Py_DECREF(bytearray_obj);

  0025c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytearray_obj$[rsp]
  00261	e8 00 00 00 00	 call	 _Py_DecRef

; 2322 :                 return NULL;

  00266	33 c0		 xor	 eax, eax
  00268	e9 06 01 00 00	 jmp	 $LN13@bytearray_@36
$LN3@bytearray_@36:

; 2323 :             }
; 2324 :             /* Recompute the `buf' pointer, since the resizing operation may
; 2325 :                have invalidated it. */
; 2326 :             buf = PyByteArray_AS_STRING(bytearray_obj);

  0026d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00274	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytearray_obj$[rsp]
  00279	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0027d	74 35		 je	 SHORT $LN18@bytearray_@36
  0027f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00286	48 8b 44 24 48	 mov	 rax, QWORD PTR bytearray_obj$[rsp]
  0028b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0028f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00294	85 c0		 test	 eax, eax
  00296	75 1c		 jne	 SHORT $LN18@bytearray_@36
  00298	41 b8 16 09 00
	00		 mov	 r8d, 2326		; 00000916H
  0029e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@EHCPEDJL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAo?$AAb?$AAj?$AA?$CJ@
  002ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002b2	33 c0		 xor	 eax, eax
$LN18@bytearray_@36:
  002b4	48 8b 44 24 48	 mov	 rax, QWORD PTR bytearray_obj$[rsp]
  002b9	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  002be	74 13		 je	 SHORT $LN19@bytearray_@36
  002c0	48 8b 44 24 48	 mov	 rax, QWORD PTR bytearray_obj$[rsp]
  002c5	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  002cc	48 89 44 24 60	 mov	 QWORD PTR tv177[rsp], rax
  002d1	eb 0c		 jmp	 SHORT $LN20@bytearray_@36
$LN19@bytearray_@36:
  002d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  002da	48 89 44 24 60	 mov	 QWORD PTR tv177[rsp], rax
$LN20@bytearray_@36:
  002df	48 8b 44 24 60	 mov	 rax, QWORD PTR tv177[rsp]
  002e4	48 89 44 24 40	 mov	 QWORD PTR buf$[rsp], rax
$LN4@bytearray_@36:

; 2327 :         }
; 2328 :     }

  002e9	e9 a9 fe ff ff	 jmp	 $LN7@bytearray_@36
$LN6@bytearray_@36:

; 2329 :     Py_DECREF(it);

  002ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  002f3	e8 00 00 00 00	 call	 _Py_DecRef

; 2330 : 
; 2331 :     /* Resize down to exact size. */
; 2332 :     if (PyByteArray_Resize((PyObject *)bytearray_obj, len) < 0) {

  002f8	48 8b 54 24 38	 mov	 rdx, QWORD PTR len$[rsp]
  002fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytearray_obj$[rsp]
  00302	e8 00 00 00 00	 call	 PyByteArray_Resize
  00307	85 c0		 test	 eax, eax
  00309	7d 0e		 jge	 SHORT $LN2@bytearray_@36

; 2333 :         Py_DECREF(bytearray_obj);

  0030b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytearray_obj$[rsp]
  00310	e8 00 00 00 00	 call	 _Py_DecRef

; 2334 :         return NULL;

  00315	33 c0		 xor	 eax, eax
  00317	eb 5a		 jmp	 SHORT $LN13@bytearray_@36
$LN2@bytearray_@36:

; 2335 :     }
; 2336 : 
; 2337 :     if (bytearray_setslice(self, Py_SIZE(self), Py_SIZE(self), bytearray_obj) == -1) {

  00319	4c 8b 4c 24 48	 mov	 r9, QWORD PTR bytearray_obj$[rsp]
  0031e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00326	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0032a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00332	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00336	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0033e	e8 00 00 00 00	 call	 bytearray_setslice
  00343	83 f8 ff	 cmp	 eax, -1
  00346	75 0e		 jne	 SHORT $LN1@bytearray_@36

; 2338 :         Py_DECREF(bytearray_obj);

  00348	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytearray_obj$[rsp]
  0034d	e8 00 00 00 00	 call	 _Py_DecRef

; 2339 :         return NULL;

  00352	33 c0		 xor	 eax, eax
  00354	eb 1d		 jmp	 SHORT $LN13@bytearray_@36
$LN1@bytearray_@36:

; 2340 :     }
; 2341 :     Py_DECREF(bytearray_obj);

  00356	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytearray_obj$[rsp]
  0035b	e8 00 00 00 00	 call	 _Py_DecRef

; 2342 : 
; 2343 :     Py_RETURN_NONE;

  00360	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00367	e8 00 00 00 00	 call	 _Py_IncRef
  0036c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN13@bytearray_@36:

; 2344 : }

  00373	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00377	c3		 ret	 0
bytearray_extend ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0BJ@GOKGLLGN@pop?5from?5empty?5bytearray?$AA@ ; `string'
PUBLIC	??_C@_06JHLPABKE@?$HMn?3pop?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_pop DD imagerel bytearray_pop
	DD	imagerel bytearray_pop+359
	DD	imagerel $unwind$bytearray_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_pop DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ DB 'pop index out of r'
	DB	'ange', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GOKGLLGN@pop?5from?5empty?5bytearray?$AA@
CONST	SEGMENT
??_C@_0BJ@GOKGLLGN@pop?5from?5empty?5bytearray?$AA@ DB 'pop from empty by'
	DB	'tearray', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHLPABKE@?$HMn?3pop?$AA@
CONST	SEGMENT
??_C@_06JHLPABKE@?$HMn?3pop?$AA@ DB '|n:pop', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_pop
_TEXT	SEGMENT
where$ = 32
value$ = 40
n$ = 48
tv95 = 56
self$ = 80
args$ = 88
bytearray_pop PROC					; COMDAT

; 2353 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2354 :     int value;
; 2355 :     Py_ssize_t where = -1, n = Py_SIZE(self);

  0000e	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR where$[rsp], -1
  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00020	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 2356 : 
; 2357 :     if (!PyArg_ParseTuple(args, "|n:pop", &where))

  00025	4c 8d 44 24 20	 lea	 r8, QWORD PTR where$[rsp]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JHLPABKE@?$HMn?3pop?$AA@
  00031	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00036	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003b	85 c0		 test	 eax, eax
  0003d	75 07		 jne	 SHORT $LN7@bytearray_@37

; 2358 :         return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 1c 01 00 00	 jmp	 $LN8@bytearray_@37
$LN7@bytearray_@37:

; 2359 : 
; 2360 :     if (n == 0) {

  00046	48 83 7c 24 30
	00		 cmp	 QWORD PTR n$[rsp], 0
  0004c	75 1a		 jne	 SHORT $LN6@bytearray_@37

; 2361 :         PyErr_SetString(PyExc_IndexError,
; 2362 :                         "pop from empty bytearray");

  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GOKGLLGN@pop?5from?5empty?5bytearray?$AA@
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0005c	e8 00 00 00 00	 call	 PyErr_SetString

; 2363 :         return NULL;

  00061	33 c0		 xor	 eax, eax
  00063	e9 fa 00 00 00	 jmp	 $LN8@bytearray_@37
$LN6@bytearray_@37:

; 2364 :     }
; 2365 :     if (where < 0)

  00068	48 83 7c 24 20
	00		 cmp	 QWORD PTR where$[rsp], 0
  0006e	7d 19		 jge	 SHORT $LN5@bytearray_@37

; 2366 :         where += Py_SIZE(self);

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00075	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR where$[rsp]
  0007e	48 03 c8	 add	 rcx, rax
  00081	48 8b c1	 mov	 rax, rcx
  00084	48 89 44 24 20	 mov	 QWORD PTR where$[rsp], rax
$LN5@bytearray_@37:

; 2367 :     if (where < 0 || where >= Py_SIZE(self)) {

  00089	48 83 7c 24 20
	00		 cmp	 QWORD PTR where$[rsp], 0
  0008f	7c 10		 jl	 SHORT $LN3@bytearray_@37
  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00096	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0009a	48 39 44 24 20	 cmp	 QWORD PTR where$[rsp], rax
  0009f	7c 1a		 jl	 SHORT $LN4@bytearray_@37
$LN3@bytearray_@37:

; 2368 :         PyErr_SetString(PyExc_IndexError, "pop index out of range");

  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
  000a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000af	e8 00 00 00 00	 call	 PyErr_SetString

; 2369 :         return NULL;

  000b4	33 c0		 xor	 eax, eax
  000b6	e9 a7 00 00 00	 jmp	 $LN8@bytearray_@37
$LN4@bytearray_@37:

; 2370 :     }
; 2371 :     if (!_canresize(self))

  000bb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000c0	e8 00 00 00 00	 call	 _canresize
  000c5	85 c0		 test	 eax, eax
  000c7	75 07		 jne	 SHORT $LN2@bytearray_@37

; 2372 :         return NULL;

  000c9	33 c0		 xor	 eax, eax
  000cb	e9 92 00 00 00	 jmp	 $LN8@bytearray_@37
$LN2@bytearray_@37:

; 2373 : 
; 2374 :     value = self->ob_bytes[where];

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d5	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR where$[rsp]
  000e1	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000e5	89 44 24 28	 mov	 DWORD PTR value$[rsp], eax

; 2375 :     memmove(self->ob_bytes + where, self->ob_bytes + where + 1, n - where);

  000e9	48 8b 44 24 20	 mov	 rax, QWORD PTR where$[rsp]
  000ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  000f3	48 2b c8	 sub	 rcx, rax
  000f6	48 8b c1	 mov	 rax, rcx
  000f9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000fe	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00105	48 8b 54 24 20	 mov	 rdx, QWORD PTR where$[rsp]
  0010a	48 8d 4c 11 01	 lea	 rcx, QWORD PTR [rcx+rdx+1]
  0010f	48 8b 54 24 50	 mov	 rdx, QWORD PTR self$[rsp]
  00114	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  0011b	48 03 54 24 20	 add	 rdx, QWORD PTR where$[rsp]
  00120	48 89 54 24 38	 mov	 QWORD PTR tv95[rsp], rdx
  00125	4c 8b c0	 mov	 r8, rax
  00128	48 8b d1	 mov	 rdx, rcx
  0012b	48 8b 44 24 38	 mov	 rax, QWORD PTR tv95[rsp]
  00130	48 8b c8	 mov	 rcx, rax
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2376 :     if (PyByteArray_Resize((PyObject *)self, n - 1) < 0)

  00139	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0013e	48 ff c8	 dec	 rax
  00141	48 8b d0	 mov	 rdx, rax
  00144	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00149	e8 00 00 00 00	 call	 PyByteArray_Resize
  0014e	85 c0		 test	 eax, eax
  00150	7d 04		 jge	 SHORT $LN1@bytearray_@37

; 2377 :         return NULL;

  00152	33 c0		 xor	 eax, eax
  00154	eb 0c		 jmp	 SHORT $LN8@bytearray_@37
$LN1@bytearray_@37:

; 2378 : 
; 2379 :     return PyLong_FromLong((unsigned char)value);

  00156	0f b6 44 24 28	 movzx	 eax, BYTE PTR value$[rsp]
  0015b	8b c8		 mov	 ecx, eax
  0015d	e8 00 00 00 00	 call	 PyLong_FromLong
$LN8@bytearray_@37:

; 2380 : }

  00162	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00166	c3		 ret	 0
bytearray_pop ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@JMCHNHHH@value?5not?5found?5in?5bytearray?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_remove DD imagerel bytearray_remove
	DD	imagerel bytearray_remove+313
	DD	imagerel $unwind$bytearray_remove
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_remove DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BN@JMCHNHHH@value?5not?5found?5in?5bytearray?$AA@
CONST	SEGMENT
??_C@_0BN@JMCHNHHH@value?5not?5found?5in?5bytearray?$AA@ DB 'value not fo'
	DB	'und in bytearray', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_remove
_TEXT	SEGMENT
where$ = 32
value$ = 40
n$ = 48
tv89 = 56
self$ = 80
arg$ = 88
bytearray_remove PROC					; COMDAT

; 2388 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2389 :     int value;
; 2390 :     Py_ssize_t where, n = Py_SIZE(self);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 2391 : 
; 2392 :     if (! _getbytevalue(arg, &value))

  0001c	48 8d 54 24 28	 lea	 rdx, QWORD PTR value$[rsp]
  00021	48 8b 4c 24 58	 mov	 rcx, QWORD PTR arg$[rsp]
  00026	e8 00 00 00 00	 call	 _getbytevalue
  0002b	85 c0		 test	 eax, eax
  0002d	75 07		 jne	 SHORT $LN8@bytearray_@38

; 2393 :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 fe 00 00 00	 jmp	 $LN9@bytearray_@38
$LN8@bytearray_@38:

; 2394 : 
; 2395 :     for (where = 0; where < n; where++) {

  00036	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR where$[rsp], 0
  0003f	eb 0d		 jmp	 SHORT $LN7@bytearray_@38
$LN6@bytearray_@38:
  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR where$[rsp]
  00046	48 ff c0	 inc	 rax
  00049	48 89 44 24 20	 mov	 QWORD PTR where$[rsp], rax
$LN7@bytearray_@38:
  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00053	48 39 44 24 20	 cmp	 QWORD PTR where$[rsp], rax
  00058	7d 1f		 jge	 SHORT $LN5@bytearray_@38

; 2396 :         if (self->ob_bytes[where] == value)

  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0005f	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR where$[rsp]
  0006b	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0006f	3b 44 24 28	 cmp	 eax, DWORD PTR value$[rsp]
  00073	75 02		 jne	 SHORT $LN4@bytearray_@38

; 2397 :             break;

  00075	eb 02		 jmp	 SHORT $LN5@bytearray_@38
$LN4@bytearray_@38:

; 2398 :     }

  00077	eb c8		 jmp	 SHORT $LN6@bytearray_@38
$LN5@bytearray_@38:

; 2399 :     if (where == n) {

  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0007e	48 39 44 24 20	 cmp	 QWORD PTR where$[rsp], rax
  00083	75 1a		 jne	 SHORT $LN3@bytearray_@38

; 2400 :         PyErr_SetString(PyExc_ValueError, "value not found in bytearray");

  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JMCHNHHH@value?5not?5found?5in?5bytearray?$AA@
  0008c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00093	e8 00 00 00 00	 call	 PyErr_SetString

; 2401 :         return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	e9 95 00 00 00	 jmp	 $LN9@bytearray_@38
$LN3@bytearray_@38:

; 2402 :     }
; 2403 :     if (!_canresize(self))

  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000a4	e8 00 00 00 00	 call	 _canresize
  000a9	85 c0		 test	 eax, eax
  000ab	75 07		 jne	 SHORT $LN2@bytearray_@38

; 2404 :         return NULL;

  000ad	33 c0		 xor	 eax, eax
  000af	e9 80 00 00 00	 jmp	 $LN9@bytearray_@38
$LN2@bytearray_@38:

; 2405 : 
; 2406 :     memmove(self->ob_bytes + where, self->ob_bytes + where + 1, n - where);

  000b4	48 8b 44 24 20	 mov	 rax, QWORD PTR where$[rsp]
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  000be	48 2b c8	 sub	 rcx, rax
  000c1	48 8b c1	 mov	 rax, rcx
  000c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000c9	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000d0	48 8b 54 24 20	 mov	 rdx, QWORD PTR where$[rsp]
  000d5	48 8d 4c 11 01	 lea	 rcx, QWORD PTR [rcx+rdx+1]
  000da	48 8b 54 24 50	 mov	 rdx, QWORD PTR self$[rsp]
  000df	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  000e6	48 03 54 24 20	 add	 rdx, QWORD PTR where$[rsp]
  000eb	48 89 54 24 38	 mov	 QWORD PTR tv89[rsp], rdx
  000f0	4c 8b c0	 mov	 r8, rax
  000f3	48 8b d1	 mov	 rdx, rcx
  000f6	48 8b 44 24 38	 mov	 rax, QWORD PTR tv89[rsp]
  000fb	48 8b c8	 mov	 rcx, rax
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2407 :     if (PyByteArray_Resize((PyObject *)self, n - 1) < 0)

  00104	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00109	48 ff c8	 dec	 rax
  0010c	48 8b d0	 mov	 rdx, rax
  0010f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00114	e8 00 00 00 00	 call	 PyByteArray_Resize
  00119	85 c0		 test	 eax, eax
  0011b	7d 04		 jge	 SHORT $LN1@bytearray_@38

; 2408 :         return NULL;

  0011d	33 c0		 xor	 eax, eax
  0011f	eb 13		 jmp	 SHORT $LN9@bytearray_@38
$LN1@bytearray_@38:

; 2409 : 
; 2410 :     Py_RETURN_NONE;

  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00128	e8 00 00 00 00	 call	 _Py_IncRef
  0012d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN9@bytearray_@38:

; 2411 : }

  00134	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00138	c3		 ret	 0
bytearray_remove ENDP
_TEXT	ENDS
PUBLIC	??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@	; `string'
PUBLIC	??_C@_08NLCECJOD@?$HMO?3strip?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_strip DD imagerel bytearray_strip
	DD	imagerel bytearray_strip+346
	DD	imagerel $unwind$bytearray_strip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_strip DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@
CONST	SEGMENT
??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@ DB 09H, 0aH, 0dH, 0cH, 0bH, ' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLCECJOD@?$HMO?3strip?$AA@
CONST	SEGMENT
??_C@_08NLCECJOD@?$HMO?3strip?$AA@ DB '|O:strip', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_strip
_TEXT	SEGMENT
mysize$ = 32
argsize$ = 40
myptr$ = 48
arg$ = 56
left$ = 64
argptr$ = 72
right$ = 80
varg$ = 96
self$ = 192
args$ = 200
bytearray_strip PROC					; COMDAT

; 2443 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2444 :     Py_ssize_t left, right, mysize, argsize;
; 2445 :     void *myptr, *argptr;
; 2446 :     PyObject *arg = Py_None;

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00018	48 89 44 24 38	 mov	 QWORD PTR arg$[rsp], rax

; 2447 :     Py_buffer varg;
; 2448 :     if (!PyArg_ParseTuple(args, "|O:strip", &arg))

  0001d	4c 8d 44 24 38	 lea	 r8, QWORD PTR arg$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08NLCECJOD@?$HMO?3strip?$AA@
  00029	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00031	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00036	85 c0		 test	 eax, eax
  00038	75 07		 jne	 SHORT $LN7@bytearray_@39

; 2449 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 11 01 00 00	 jmp	 $LN8@bytearray_@39
$LN7@bytearray_@39:

; 2450 :     if (arg == Py_None) {

  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00048	48 39 44 24 38	 cmp	 QWORD PTR arg$[rsp], rax
  0004d	75 17		 jne	 SHORT $LN6@bytearray_@39

; 2451 :         argptr = "\t\n\r\f\v ";

  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@
  00056	48 89 44 24 48	 mov	 QWORD PTR argptr$[rsp], rax

; 2452 :         argsize = 6;

  0005b	48 c7 44 24 28
	06 00 00 00	 mov	 QWORD PTR argsize$[rsp], 6

; 2453 :     }
; 2454 :     else {

  00064	eb 2f		 jmp	 SHORT $LN5@bytearray_@39
$LN6@bytearray_@39:

; 2455 :         if (_getbuffer(arg, &varg) < 0)

  00066	48 8d 54 24 60	 lea	 rdx, QWORD PTR varg$[rsp]
  0006b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arg$[rsp]
  00070	e8 00 00 00 00	 call	 _getbuffer
  00075	48 85 c0	 test	 rax, rax
  00078	7d 07		 jge	 SHORT $LN4@bytearray_@39

; 2456 :             return NULL;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 d1 00 00 00	 jmp	 $LN8@bytearray_@39
$LN4@bytearray_@39:

; 2457 :         argptr = varg.buf;

  00081	48 8b 44 24 60	 mov	 rax, QWORD PTR varg$[rsp]
  00086	48 89 44 24 48	 mov	 QWORD PTR argptr$[rsp], rax

; 2458 :         argsize = varg.len;

  0008b	48 8b 44 24 70	 mov	 rax, QWORD PTR varg$[rsp+16]
  00090	48 89 44 24 28	 mov	 QWORD PTR argsize$[rsp], rax
$LN5@bytearray_@39:

; 2459 :     }
; 2460 :     myptr = self->ob_bytes;

  00095	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0009d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000a4	48 89 44 24 30	 mov	 QWORD PTR myptr$[rsp], rax

; 2461 :     mysize = Py_SIZE(self);

  000a9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000b1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b5	48 89 44 24 20	 mov	 QWORD PTR mysize$[rsp], rax

; 2462 :     left = lstrip_helper(myptr, mysize, argptr, argsize);

  000ba	4c 8b 4c 24 28	 mov	 r9, QWORD PTR argsize$[rsp]
  000bf	4c 8b 44 24 48	 mov	 r8, QWORD PTR argptr$[rsp]
  000c4	48 8b 54 24 20	 mov	 rdx, QWORD PTR mysize$[rsp]
  000c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR myptr$[rsp]
  000ce	e8 00 00 00 00	 call	 lstrip_helper
  000d3	48 89 44 24 40	 mov	 QWORD PTR left$[rsp], rax

; 2463 :     if (left == mysize)

  000d8	48 8b 44 24 20	 mov	 rax, QWORD PTR mysize$[rsp]
  000dd	48 39 44 24 40	 cmp	 QWORD PTR left$[rsp], rax
  000e2	75 0c		 jne	 SHORT $LN3@bytearray_@39

; 2464 :         right = left;

  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR left$[rsp]
  000e9	48 89 44 24 50	 mov	 QWORD PTR right$[rsp], rax

; 2465 :     else

  000ee	eb 1e		 jmp	 SHORT $LN2@bytearray_@39
$LN3@bytearray_@39:

; 2466 :         right = rstrip_helper(myptr, mysize, argptr, argsize);

  000f0	4c 8b 4c 24 28	 mov	 r9, QWORD PTR argsize$[rsp]
  000f5	4c 8b 44 24 48	 mov	 r8, QWORD PTR argptr$[rsp]
  000fa	48 8b 54 24 20	 mov	 rdx, QWORD PTR mysize$[rsp]
  000ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR myptr$[rsp]
  00104	e8 00 00 00 00	 call	 rstrip_helper
  00109	48 89 44 24 50	 mov	 QWORD PTR right$[rsp], rax
$LN2@bytearray_@39:

; 2467 :     if (arg != Py_None)

  0010e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00115	48 39 44 24 38	 cmp	 QWORD PTR arg$[rsp], rax
  0011a	74 0a		 je	 SHORT $LN1@bytearray_@39

; 2468 :         PyBuffer_Release(&varg);

  0011c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR varg$[rsp]
  00121	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@39:

; 2469 :     return PyByteArray_FromStringAndSize(self->ob_bytes + left, right - left);

  00126	48 8b 44 24 40	 mov	 rax, QWORD PTR left$[rsp]
  0012b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR right$[rsp]
  00130	48 2b c8	 sub	 rcx, rax
  00133	48 8b c1	 mov	 rax, rcx
  00136	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0013e	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00145	48 03 4c 24 40	 add	 rcx, QWORD PTR left$[rsp]
  0014a	48 8b d0	 mov	 rdx, rax
  0014d	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
$LN8@bytearray_@39:

; 2470 : }

  00152	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00159	c3		 ret	 0
bytearray_strip ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lstrip_helper DD imagerel lstrip_helper
	DD	imagerel lstrip_helper+112
	DD	imagerel $unwind$lstrip_helper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lstrip_helper DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lstrip_helper
_TEXT	SEGMENT
i$ = 32
myptr$ = 64
mysize$ = 72
argptr$ = 80
argsize$ = 88
lstrip_helper PROC					; COMDAT

; 2418 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2419 :     Py_ssize_t i = 0;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
$LN2@lstrip_hel:

; 2420 :     while (i < mysize && memchr(argptr, myptr[i], argsize))

  00021	48 8b 44 24 48	 mov	 rax, QWORD PTR mysize$[rsp]
  00026	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0002b	7d 39		 jge	 SHORT $LN1@lstrip_hel
  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR myptr$[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00040	4c 8b 44 24 58	 mov	 r8, QWORD PTR argsize$[rsp]
  00045	8b d0		 mov	 edx, eax
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR argptr$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00052	48 85 c0	 test	 rax, rax
  00055	74 0f		 je	 SHORT $LN1@lstrip_hel

; 2421 :         i++;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0005c	48 ff c0	 inc	 rax
  0005f	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00064	eb bb		 jmp	 SHORT $LN2@lstrip_hel
$LN1@lstrip_hel:

; 2422 :     return i;

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]

; 2423 : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
lstrip_helper ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rstrip_helper DD imagerel rstrip_helper
	DD	imagerel rstrip_helper+115
	DD	imagerel $unwind$rstrip_helper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rstrip_helper DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT rstrip_helper
_TEXT	SEGMENT
i$ = 32
myptr$ = 64
mysize$ = 72
argptr$ = 80
argsize$ = 88
rstrip_helper PROC					; COMDAT

; 2428 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2429 :     Py_ssize_t i = mysize - 1;

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR mysize$[rsp]
  0001d	48 ff c8	 dec	 rax
  00020	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN2@rstrip_hel:

; 2430 :     while (i >= 0 && memchr(argptr, myptr[i], argsize))

  00025	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0002b	7c 39		 jl	 SHORT $LN1@rstrip_hel
  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR myptr$[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00040	4c 8b 44 24 58	 mov	 r8, QWORD PTR argsize$[rsp]
  00045	8b d0		 mov	 edx, eax
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR argptr$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00052	48 85 c0	 test	 rax, rax
  00055	74 0f		 je	 SHORT $LN1@rstrip_hel

; 2431 :         i--;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0005c	48 ff c8	 dec	 rax
  0005f	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00064	eb bf		 jmp	 SHORT $LN2@rstrip_hel
$LN1@rstrip_hel:

; 2432 :     return i + 1;

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0006b	48 ff c0	 inc	 rax

; 2433 : }

  0006e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00072	c3		 ret	 0
rstrip_helper ENDP
_TEXT	ENDS
PUBLIC	??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_lstrip DD imagerel bytearray_lstrip
	DD	imagerel bytearray_lstrip+302
	DD	imagerel $unwind$bytearray_lstrip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_lstrip DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@
CONST	SEGMENT
??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@ DB '|O:lstrip', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_lstrip
_TEXT	SEGMENT
mysize$ = 32
argsize$ = 40
myptr$ = 48
arg$ = 56
left$ = 64
argptr$ = 72
right$ = 80
varg$ = 96
self$ = 192
args$ = 200
bytearray_lstrip PROC					; COMDAT

; 2480 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2481 :     Py_ssize_t left, right, mysize, argsize;
; 2482 :     void *myptr, *argptr;
; 2483 :     PyObject *arg = Py_None;

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00018	48 89 44 24 38	 mov	 QWORD PTR arg$[rsp], rax

; 2484 :     Py_buffer varg;
; 2485 :     if (!PyArg_ParseTuple(args, "|O:lstrip", &arg))

  0001d	4c 8d 44 24 38	 lea	 r8, QWORD PTR arg$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@
  00029	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00031	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00036	85 c0		 test	 eax, eax
  00038	75 07		 jne	 SHORT $LN5@bytearray_@40

; 2486 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 e5 00 00 00	 jmp	 $LN6@bytearray_@40
$LN5@bytearray_@40:

; 2487 :     if (arg == Py_None) {

  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00048	48 39 44 24 38	 cmp	 QWORD PTR arg$[rsp], rax
  0004d	75 17		 jne	 SHORT $LN4@bytearray_@40

; 2488 :         argptr = "\t\n\r\f\v ";

  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@
  00056	48 89 44 24 48	 mov	 QWORD PTR argptr$[rsp], rax

; 2489 :         argsize = 6;

  0005b	48 c7 44 24 28
	06 00 00 00	 mov	 QWORD PTR argsize$[rsp], 6

; 2490 :     }
; 2491 :     else {

  00064	eb 2f		 jmp	 SHORT $LN3@bytearray_@40
$LN4@bytearray_@40:

; 2492 :         if (_getbuffer(arg, &varg) < 0)

  00066	48 8d 54 24 60	 lea	 rdx, QWORD PTR varg$[rsp]
  0006b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arg$[rsp]
  00070	e8 00 00 00 00	 call	 _getbuffer
  00075	48 85 c0	 test	 rax, rax
  00078	7d 07		 jge	 SHORT $LN2@bytearray_@40

; 2493 :             return NULL;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 a5 00 00 00	 jmp	 $LN6@bytearray_@40
$LN2@bytearray_@40:

; 2494 :         argptr = varg.buf;

  00081	48 8b 44 24 60	 mov	 rax, QWORD PTR varg$[rsp]
  00086	48 89 44 24 48	 mov	 QWORD PTR argptr$[rsp], rax

; 2495 :         argsize = varg.len;

  0008b	48 8b 44 24 70	 mov	 rax, QWORD PTR varg$[rsp+16]
  00090	48 89 44 24 28	 mov	 QWORD PTR argsize$[rsp], rax
$LN3@bytearray_@40:

; 2496 :     }
; 2497 :     myptr = self->ob_bytes;

  00095	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0009d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000a4	48 89 44 24 30	 mov	 QWORD PTR myptr$[rsp], rax

; 2498 :     mysize = Py_SIZE(self);

  000a9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000b1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b5	48 89 44 24 20	 mov	 QWORD PTR mysize$[rsp], rax

; 2499 :     left = lstrip_helper(myptr, mysize, argptr, argsize);

  000ba	4c 8b 4c 24 28	 mov	 r9, QWORD PTR argsize$[rsp]
  000bf	4c 8b 44 24 48	 mov	 r8, QWORD PTR argptr$[rsp]
  000c4	48 8b 54 24 20	 mov	 rdx, QWORD PTR mysize$[rsp]
  000c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR myptr$[rsp]
  000ce	e8 00 00 00 00	 call	 lstrip_helper
  000d3	48 89 44 24 40	 mov	 QWORD PTR left$[rsp], rax

; 2500 :     right = mysize;

  000d8	48 8b 44 24 20	 mov	 rax, QWORD PTR mysize$[rsp]
  000dd	48 89 44 24 50	 mov	 QWORD PTR right$[rsp], rax

; 2501 :     if (arg != Py_None)

  000e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000e9	48 39 44 24 38	 cmp	 QWORD PTR arg$[rsp], rax
  000ee	74 0a		 je	 SHORT $LN1@bytearray_@40

; 2502 :         PyBuffer_Release(&varg);

  000f0	48 8d 4c 24 60	 lea	 rcx, QWORD PTR varg$[rsp]
  000f5	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@40:

; 2503 :     return PyByteArray_FromStringAndSize(self->ob_bytes + left, right - left);

  000fa	48 8b 44 24 40	 mov	 rax, QWORD PTR left$[rsp]
  000ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR right$[rsp]
  00104	48 2b c8	 sub	 rcx, rax
  00107	48 8b c1	 mov	 rax, rcx
  0010a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00112	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00119	48 03 4c 24 40	 add	 rcx, QWORD PTR left$[rsp]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
$LN6@bytearray_@40:

; 2504 : }

  00126	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0012d	c3		 ret	 0
bytearray_lstrip ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_rstrip DD imagerel bytearray_rstrip
	DD	imagerel bytearray_rstrip+273
	DD	imagerel $unwind$bytearray_rstrip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_rstrip DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@
CONST	SEGMENT
??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@ DB '|O:rstrip', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_rstrip
_TEXT	SEGMENT
mysize$ = 32
argsize$ = 40
myptr$ = 48
arg$ = 56
argptr$ = 64
right$ = 72
varg$ = 80
self$ = 176
args$ = 184
bytearray_rstrip PROC					; COMDAT

; 2514 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2515 :     Py_ssize_t right, mysize, argsize;
; 2516 :     void *myptr, *argptr;
; 2517 :     PyObject *arg = Py_None;

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00018	48 89 44 24 38	 mov	 QWORD PTR arg$[rsp], rax

; 2518 :     Py_buffer varg;
; 2519 :     if (!PyArg_ParseTuple(args, "|O:rstrip", &arg))

  0001d	4c 8d 44 24 38	 lea	 r8, QWORD PTR arg$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@
  00029	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00031	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00036	85 c0		 test	 eax, eax
  00038	75 07		 jne	 SHORT $LN5@bytearray_@41

; 2520 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 c8 00 00 00	 jmp	 $LN6@bytearray_@41
$LN5@bytearray_@41:

; 2521 :     if (arg == Py_None) {

  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00048	48 39 44 24 38	 cmp	 QWORD PTR arg$[rsp], rax
  0004d	75 17		 jne	 SHORT $LN4@bytearray_@41

; 2522 :         argptr = "\t\n\r\f\v ";

  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@
  00056	48 89 44 24 40	 mov	 QWORD PTR argptr$[rsp], rax

; 2523 :         argsize = 6;

  0005b	48 c7 44 24 28
	06 00 00 00	 mov	 QWORD PTR argsize$[rsp], 6

; 2524 :     }
; 2525 :     else {

  00064	eb 2f		 jmp	 SHORT $LN3@bytearray_@41
$LN4@bytearray_@41:

; 2526 :         if (_getbuffer(arg, &varg) < 0)

  00066	48 8d 54 24 50	 lea	 rdx, QWORD PTR varg$[rsp]
  0006b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arg$[rsp]
  00070	e8 00 00 00 00	 call	 _getbuffer
  00075	48 85 c0	 test	 rax, rax
  00078	7d 07		 jge	 SHORT $LN2@bytearray_@41

; 2527 :             return NULL;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 88 00 00 00	 jmp	 $LN6@bytearray_@41
$LN2@bytearray_@41:

; 2528 :         argptr = varg.buf;

  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR varg$[rsp]
  00086	48 89 44 24 40	 mov	 QWORD PTR argptr$[rsp], rax

; 2529 :         argsize = varg.len;

  0008b	48 8b 44 24 60	 mov	 rax, QWORD PTR varg$[rsp+16]
  00090	48 89 44 24 28	 mov	 QWORD PTR argsize$[rsp], rax
$LN3@bytearray_@41:

; 2530 :     }
; 2531 :     myptr = self->ob_bytes;

  00095	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0009d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000a4	48 89 44 24 30	 mov	 QWORD PTR myptr$[rsp], rax

; 2532 :     mysize = Py_SIZE(self);

  000a9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000b1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b5	48 89 44 24 20	 mov	 QWORD PTR mysize$[rsp], rax

; 2533 :     right = rstrip_helper(myptr, mysize, argptr, argsize);

  000ba	4c 8b 4c 24 28	 mov	 r9, QWORD PTR argsize$[rsp]
  000bf	4c 8b 44 24 40	 mov	 r8, QWORD PTR argptr$[rsp]
  000c4	48 8b 54 24 20	 mov	 rdx, QWORD PTR mysize$[rsp]
  000c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR myptr$[rsp]
  000ce	e8 00 00 00 00	 call	 rstrip_helper
  000d3	48 89 44 24 48	 mov	 QWORD PTR right$[rsp], rax

; 2534 :     if (arg != Py_None)

  000d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000df	48 39 44 24 38	 cmp	 QWORD PTR arg$[rsp], rax
  000e4	74 0a		 je	 SHORT $LN1@bytearray_@41

; 2535 :         PyBuffer_Release(&varg);

  000e6	48 8d 4c 24 50	 lea	 rcx, QWORD PTR varg$[rsp]
  000eb	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@41:

; 2536 :     return PyByteArray_FromStringAndSize(self->ob_bytes, right);

  000f0	48 8b 54 24 48	 mov	 rdx, QWORD PTR right$[rsp]
  000f5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000fd	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00104	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
$LN6@bytearray_@41:

; 2537 : }

  00109	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00110	c3		 ret	 0
bytearray_rstrip ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@		; `string'
EXTRN	PyUnicode_FromEncodedObject:PROC
EXTRN	PyUnicode_GetDefaultEncoding:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_decode DD imagerel bytearray_decode
	DD	imagerel bytearray_decode+137
	DD	imagerel $unwind$bytearray_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_decode DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@
CONST	SEGMENT
??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@ DB '|ss:decode', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_decode
_TEXT	SEGMENT
errors$ = 48
encoding$ = 56
self$ = 80
args$ = 88
kwargs$ = 96
bytearray_decode PROC					; COMDAT

; 2551 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2552 :     const char *encoding = NULL;

  00013	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR encoding$[rsp], 0

; 2553 :     const char *errors = NULL;

  0001c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR errors$[rsp], 0

; 2554 :     static char *kwlist[] = {"encoding", "errors", 0};
; 2555 : 
; 2556 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ss:decode", kwlist, &encoding, &errors))

  00025	48 8d 44 24 30	 lea	 rax, QWORD PTR errors$[rsp]
  0002a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002f	48 8d 44 24 38	 lea	 rax, QWORD PTR encoding$[rsp]
  00034	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00039	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytearray_decode@@9@9
  00040	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@
  00047	48 8b 54 24 60	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0004c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00051	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00056	85 c0		 test	 eax, eax
  00058	75 04		 jne	 SHORT $LN2@bytearray_@42

; 2557 :         return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb 26		 jmp	 SHORT $LN3@bytearray_@42
$LN2@bytearray_@42:

; 2558 :     if (encoding == NULL)

  0005e	48 83 7c 24 38
	00		 cmp	 QWORD PTR encoding$[rsp], 0
  00064	75 0a		 jne	 SHORT $LN1@bytearray_@42

; 2559 :         encoding = PyUnicode_GetDefaultEncoding();

  00066	e8 00 00 00 00	 call	 PyUnicode_GetDefaultEncoding
  0006b	48 89 44 24 38	 mov	 QWORD PTR encoding$[rsp], rax
$LN1@bytearray_@42:

; 2560 :     return PyUnicode_FromEncodedObject(self, encoding, errors);

  00070	4c 8b 44 24 30	 mov	 r8, QWORD PTR errors$[rsp]
  00075	48 8b 54 24 38	 mov	 rdx, QWORD PTR encoding$[rsp]
  0007a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0007f	e8 00 00 00 00	 call	 PyUnicode_FromEncodedObject
$LN3@bytearray_@42:

; 2561 : }

  00084	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00088	c3		 ret	 0
bytearray_decode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_alloc DD imagerel bytearray_alloc
	DD	imagerel bytearray_alloc+28
	DD	imagerel $unwind$bytearray_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_alloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_alloc
_TEXT	SEGMENT
self$ = 48
bytearray_alloc PROC					; COMDAT

; 2570 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2571 :     return PyLong_FromSsize_t(self->ob_alloc);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00012	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 2572 : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
bytearray_alloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0EA@LOOJBHHN@can?5only?5join?5an?5iterable?5of?5byt@ ; `string'
PUBLIC	??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@ ; `string'
EXTRN	PySequence_Fast:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_join DD imagerel bytearray_join
	DD	imagerel bytearray_join+1100
	DD	imagerel $unwind$bytearray_join
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_join DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@LOOJBHHN@can?5only?5join?5an?5iterable?5of?5byt@
CONST	SEGMENT
??_C@_0EA@LOOJBHHN@can?5only?5join?5an?5iterable?5of?5byt@ DB 'can only j'
	DB	'oin an iterable of bytes (item %ld has type ''%.100s'')', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@
CONST	SEGMENT
??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@ DB 'can only join a'
	DB	'n iterable', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_join
_TEXT	SEGMENT
mysize$ = 32
n$ = 40
i$ = 48
dest$ = 56
seq$ = 64
result$ = 72
items$ = 80
totalsize$ = 88
obj$24074 = 96
size$24098 = 104
buf$24100 = 112
obj$24097 = 120
tv75 = 128
tv82 = 136
tv159 = 144
tv186 = 152
self$ = 176
it$ = 184
bytearray_join PROC					; COMDAT

; 2582 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2583 :     PyObject *seq;
; 2584 :     Py_ssize_t mysize = Py_SIZE(self);

  00011	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00019	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001d	48 89 44 24 20	 mov	 QWORD PTR mysize$[rsp], rax

; 2585 :     Py_ssize_t i;
; 2586 :     Py_ssize_t n;
; 2587 :     PyObject **items;
; 2588 :     Py_ssize_t totalsize = 0;

  00022	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR totalsize$[rsp], 0

; 2589 :     PyObject *result;
; 2590 :     char *dest;
; 2591 : 
; 2592 :     seq = PySequence_Fast(it, "can only join an iterable");

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@
  00032	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR it$[rsp]
  0003a	e8 00 00 00 00	 call	 PySequence_Fast
  0003f	48 89 44 24 40	 mov	 QWORD PTR seq$[rsp], rax

; 2593 :     if (seq == NULL)

  00044	48 83 7c 24 40
	00		 cmp	 QWORD PTR seq$[rsp], 0
  0004a	75 07		 jne	 SHORT $LN15@bytearray_@43

; 2594 :         return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 f1 03 00 00	 jmp	 $LN16@bytearray_@43
$LN15@bytearray_@43:

; 2595 :     n = PySequence_Fast_GET_SIZE(seq);

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00062	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00067	85 c0		 test	 eax, eax
  00069	74 13		 je	 SHORT $LN18@bytearray_@43
  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$[rsp]
  00070	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00074	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  0007c	eb 11		 jmp	 SHORT $LN19@bytearray_@43
$LN18@bytearray_@43:
  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$[rsp]
  00083	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00087	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
$LN19@bytearray_@43:
  0008f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  00097	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 2596 :     items = PySequence_Fast_ITEMS(seq);

  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$[rsp]
  000a1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000ab	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  000b0	85 c0		 test	 eax, eax
  000b2	74 13		 je	 SHORT $LN20@bytearray_@43
  000b4	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$[rsp]
  000b9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000bd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  000c5	eb 11		 jmp	 SHORT $LN21@bytearray_@43
$LN20@bytearray_@43:
  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$[rsp]
  000cc	48 83 c0 70	 add	 rax, 112		; 00000070H
  000d0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
$LN21@bytearray_@43:
  000d8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv82[rsp]
  000e0	48 89 44 24 50	 mov	 QWORD PTR items$[rsp], rax

; 2597 : 
; 2598 :     /* Compute the total size, and check that they are all bytes */
; 2599 :     /* XXX Shouldn't we use _getbuffer() on these items instead? */
; 2600 :     for (i = 0; i < n; i++) {

  000e5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000ee	eb 0d		 jmp	 SHORT $LN14@bytearray_@43
$LN13@bytearray_@43:
  000f0	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000f5	48 ff c0	 inc	 rax
  000f8	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN14@bytearray_@43:
  000fd	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00102	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00107	0f 8d cd 00 00
	00		 jge	 $LN12@bytearray_@43

; 2601 :         PyObject *obj = items[i];

  0010d	48 8b 44 24 50	 mov	 rax, QWORD PTR items$[rsp]
  00112	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00117	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0011b	48 89 44 24 60	 mov	 QWORD PTR obj$24074[rsp], rax

; 2602 :         if (!PyByteArray_Check(obj) && !PyBytes_Check(obj)) {

  00120	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00127	48 8b 4c 24 60	 mov	 rcx, QWORD PTR obj$24074[rsp]
  0012c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00130	74 5b		 je	 SHORT $LN11@bytearray_@43
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00139	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$24074[rsp]
  0013e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00142	e8 00 00 00 00	 call	 PyType_IsSubtype
  00147	85 c0		 test	 eax, eax
  00149	75 42		 jne	 SHORT $LN11@bytearray_@43
  0014b	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$24074[rsp]
  00150	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00154	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0015a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0015f	85 c0		 test	 eax, eax
  00161	75 2a		 jne	 SHORT $LN11@bytearray_@43

; 2603 :             PyErr_Format(PyExc_TypeError,
; 2604 :                          "can only join an iterable of bytes "
; 2605 :                          "(item %ld has type '%.100s')",
; 2606 :                          /* XXX %ld isn't right on Win64 */
; 2607 :                          (long)i, Py_TYPE(obj)->tp_name);

  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$24074[rsp]
  00168	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0016c	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00170	44 8b 44 24 30	 mov	 r8d, DWORD PTR i$[rsp]
  00175	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@LOOJBHHN@can?5only?5join?5an?5iterable?5of?5byt@
  0017c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00183	e8 00 00 00 00	 call	 PyErr_Format

; 2608 :             goto error;

  00188	e9 ab 02 00 00	 jmp	 $error$24082
$LN11@bytearray_@43:

; 2609 :         }
; 2610 :         if (i > 0)

  0018d	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  00193	7e 15		 jle	 SHORT $LN10@bytearray_@43

; 2611 :             totalsize += mysize;

  00195	48 8b 44 24 20	 mov	 rax, QWORD PTR mysize$[rsp]
  0019a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR totalsize$[rsp]
  0019f	48 03 c8	 add	 rcx, rax
  001a2	48 8b c1	 mov	 rax, rcx
  001a5	48 89 44 24 58	 mov	 QWORD PTR totalsize$[rsp], rax
$LN10@bytearray_@43:

; 2612 :         totalsize += Py_SIZE(obj);

  001aa	48 8b 44 24 60	 mov	 rax, QWORD PTR obj$24074[rsp]
  001af	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001b3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR totalsize$[rsp]
  001b8	48 03 c8	 add	 rcx, rax
  001bb	48 8b c1	 mov	 rax, rcx
  001be	48 89 44 24 58	 mov	 QWORD PTR totalsize$[rsp], rax

; 2613 :         if (totalsize < 0) {

  001c3	48 83 7c 24 58
	00		 cmp	 QWORD PTR totalsize$[rsp], 0
  001c9	7d 0a		 jge	 SHORT $LN9@bytearray_@43

; 2614 :             PyErr_NoMemory();

  001cb	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2615 :             goto error;

  001d0	e9 63 02 00 00	 jmp	 $error$24082
$LN9@bytearray_@43:

; 2616 :         }
; 2617 :     }

  001d5	e9 16 ff ff ff	 jmp	 $LN13@bytearray_@43
$LN12@bytearray_@43:

; 2618 : 
; 2619 :     /* Allocate the result, and copy the bytes */
; 2620 :     result = PyByteArray_FromStringAndSize(NULL, totalsize);

  001da	48 8b 54 24 58	 mov	 rdx, QWORD PTR totalsize$[rsp]
  001df	33 c9		 xor	 ecx, ecx
  001e1	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  001e6	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 2621 :     if (result == NULL)

  001eb	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  001f1	75 05		 jne	 SHORT $LN8@bytearray_@43

; 2622 :         goto error;

  001f3	e9 40 02 00 00	 jmp	 $error$24082
$LN8@bytearray_@43:

; 2623 :     dest = PyByteArray_AS_STRING(result);

  001f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001ff	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00204	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00208	74 35		 je	 SHORT $LN22@bytearray_@43
  0020a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00211	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00216	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0021a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0021f	85 c0		 test	 eax, eax
  00221	75 1c		 jne	 SHORT $LN22@bytearray_@43
  00223	41 b8 3f 0a 00
	00		 mov	 r8d, 2623		; 00000a3fH
  00229	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@IIJJPBPP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00237	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0023d	33 c0		 xor	 eax, eax
$LN22@bytearray_@43:
  0023f	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00244	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00249	74 16		 je	 SHORT $LN23@bytearray_@43
  0024b	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00250	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00257	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
  0025f	eb 0f		 jmp	 SHORT $LN24@bytearray_@43
$LN23@bytearray_@43:
  00261	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00268	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
$LN24@bytearray_@43:
  00270	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv159[rsp]
  00278	48 89 44 24 38	 mov	 QWORD PTR dest$[rsp], rax

; 2624 :     for (i = 0; i < n; i++) {

  0027d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00286	eb 0d		 jmp	 SHORT $LN7@bytearray_@43
$LN6@bytearray_@43:
  00288	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0028d	48 ff c0	 inc	 rax
  00290	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN7@bytearray_@43:
  00295	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0029a	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0029f	0f 8d 82 01 00
	00		 jge	 $LN5@bytearray_@43

; 2625 :         PyObject *obj = items[i];

  002a5	48 8b 44 24 50	 mov	 rax, QWORD PTR items$[rsp]
  002aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  002af	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  002b3	48 89 44 24 78	 mov	 QWORD PTR obj$24097[rsp], rax

; 2626 :         Py_ssize_t size = Py_SIZE(obj);

  002b8	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$24097[rsp]
  002bd	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002c1	48 89 44 24 68	 mov	 QWORD PTR size$24098[rsp], rax

; 2627 :         char *buf;
; 2628 :         if (PyByteArray_Check(obj))

  002c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  002cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$24097[rsp]
  002d2	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  002d6	74 1d		 je	 SHORT $LN3@bytearray_@43
  002d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  002df	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$24097[rsp]
  002e4	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  002e8	e8 00 00 00 00	 call	 PyType_IsSubtype
  002ed	85 c0		 test	 eax, eax
  002ef	0f 84 87 00 00
	00		 je	 $LN4@bytearray_@43
$LN3@bytearray_@43:

; 2629 :            buf = PyByteArray_AS_STRING(obj);

  002f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  002fc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obj$24097[rsp]
  00301	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00305	74 35		 je	 SHORT $LN25@bytearray_@43
  00307	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0030e	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$24097[rsp]
  00313	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00317	e8 00 00 00 00	 call	 PyType_IsSubtype
  0031c	85 c0		 test	 eax, eax
  0031e	75 1c		 jne	 SHORT $LN25@bytearray_@43
  00320	41 b8 45 0a 00
	00		 mov	 r8d, 2629		; 00000a45H
  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@PHBFBFIE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00334	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0033a	33 c0		 xor	 eax, eax
$LN25@bytearray_@43:
  0033c	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$24097[rsp]
  00341	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00346	74 16		 je	 SHORT $LN26@bytearray_@43
  00348	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$24097[rsp]
  0034d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00354	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
  0035c	eb 0f		 jmp	 SHORT $LN27@bytearray_@43
$LN26@bytearray_@43:
  0035e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00365	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
$LN27@bytearray_@43:
  0036d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv186[rsp]
  00375	48 89 44 24 70	 mov	 QWORD PTR buf$24100[rsp], rax

; 2630 :         else

  0037a	eb 42		 jmp	 SHORT $LN2@bytearray_@43
$LN4@bytearray_@43:

; 2631 :            buf = PyBytes_AS_STRING(obj);

  0037c	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$24097[rsp]
  00381	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00385	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0038b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00390	85 c0		 test	 eax, eax
  00392	75 1c		 jne	 SHORT $LN28@bytearray_@43
  00394	41 b8 47 0a 00
	00		 mov	 r8d, 2631		; 00000a47H
  0039a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  003a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BMHHMEBF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  003a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003ae	33 c0		 xor	 eax, eax
$LN28@bytearray_@43:
  003b0	48 8b 44 24 78	 mov	 rax, QWORD PTR obj$24097[rsp]
  003b5	48 83 c0 78	 add	 rax, 120		; 00000078H
  003b9	48 89 44 24 70	 mov	 QWORD PTR buf$24100[rsp], rax
$LN2@bytearray_@43:

; 2632 :         if (i) {

  003be	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$[rsp], 0
  003c4	74 33		 je	 SHORT $LN1@bytearray_@43

; 2633 :             memcpy(dest, self->ob_bytes, mysize);

  003c6	4c 8b 44 24 20	 mov	 r8, QWORD PTR mysize$[rsp]
  003cb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003d3	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  003da	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dest$[rsp]
  003df	e8 00 00 00 00	 call	 memcpy

; 2634 :             dest += mysize;

  003e4	48 8b 44 24 20	 mov	 rax, QWORD PTR mysize$[rsp]
  003e9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dest$[rsp]
  003ee	48 03 c8	 add	 rcx, rax
  003f1	48 8b c1	 mov	 rax, rcx
  003f4	48 89 44 24 38	 mov	 QWORD PTR dest$[rsp], rax
$LN1@bytearray_@43:

; 2635 :         }
; 2636 :         memcpy(dest, buf, size);

  003f9	4c 8b 44 24 68	 mov	 r8, QWORD PTR size$24098[rsp]
  003fe	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$24100[rsp]
  00403	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dest$[rsp]
  00408	e8 00 00 00 00	 call	 memcpy

; 2637 :         dest += size;

  0040d	48 8b 44 24 68	 mov	 rax, QWORD PTR size$24098[rsp]
  00412	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dest$[rsp]
  00417	48 03 c8	 add	 rcx, rax
  0041a	48 8b c1	 mov	 rax, rcx
  0041d	48 89 44 24 38	 mov	 QWORD PTR dest$[rsp], rax

; 2638 :     }

  00422	e9 61 fe ff ff	 jmp	 $LN6@bytearray_@43
$LN5@bytearray_@43:

; 2639 : 
; 2640 :     /* Done */
; 2641 :     Py_DECREF(seq);

  00427	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$[rsp]
  0042c	e8 00 00 00 00	 call	 _Py_DecRef

; 2642 :     return result;

  00431	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00436	eb 0c		 jmp	 SHORT $LN16@bytearray_@43
$error$24082:

; 2643 : 
; 2644 :     /* Error handling */
; 2645 :   error:
; 2646 :     Py_DECREF(seq);

  00438	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$[rsp]
  0043d	e8 00 00 00 00	 call	 _Py_DecRef

; 2647 :     return NULL;

  00442	33 c0		 xor	 eax, eax
$LN16@bytearray_@43:

; 2648 : }

  00444	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0044b	c3		 ret	 0
bytearray_join ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_splitlines DD imagerel bytearray_splitlines
	DD	imagerel bytearray_splitlines+296
	DD	imagerel $unwind$bytearray_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_splitlines DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@
CONST	SEGMENT
??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@ DB '|i:splitlines', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_splitlines
_TEXT	SEGMENT
keepends$ = 48
tv132 = 56
self$ = 80
args$ = 88
kwds$ = 96
bytearray_splitlines PROC				; COMDAT

; 2659 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2660 :     static char *kwlist[] = {"keepends", 0};
; 2661 :     int keepends = 0;

  00013	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR keepends$[rsp], 0

; 2662 : 
; 2663 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|i:splitlines",
; 2664 :                                      kwlist, &keepends))

  0001b	48 8d 44 24 30	 lea	 rax, QWORD PTR keepends$[rsp]
  00020	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00025	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytearray_splitlines@@9@9
  0002c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@
  00033	48 8b 54 24 60	 mov	 rdx, QWORD PTR kwds$[rsp]
  00038	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0003d	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00042	85 c0		 test	 eax, eax
  00044	75 07		 jne	 SHORT $LN1@bytearray_@44

; 2665 :         return NULL;

  00046	33 c0		 xor	 eax, eax
  00048	e9 d6 00 00 00	 jmp	 $LN2@bytearray_@44
$LN1@bytearray_@44:

; 2666 : 
; 2667 :     return stringlib_splitlines(
; 2668 :         (PyObject*) self, PyByteArray_AS_STRING(self),
; 2669 :         PyByteArray_GET_SIZE(self), keepends
; 2670 :         );

  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00054	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00059	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0005d	74 35		 je	 SHORT $LN4@bytearray_@44
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0006f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00074	85 c0		 test	 eax, eax
  00076	75 1c		 jne	 SHORT $LN4@bytearray_@44
  00078	41 b8 6d 0a 00
	00		 mov	 r8d, 2669		; 00000a6dH
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00092	33 c0		 xor	 eax, eax
$LN4@bytearray_@44:
  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000a0	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000a4	74 35		 je	 SHORT $LN5@bytearray_@44
  000a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000ad	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000b2	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000b6	e8 00 00 00 00	 call	 PyType_IsSubtype
  000bb	85 c0		 test	 eax, eax
  000bd	75 1c		 jne	 SHORT $LN5@bytearray_@44
  000bf	41 b8 6c 0a 00
	00		 mov	 r8d, 2668		; 00000a6cH
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMKHKEDP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d9	33 c0		 xor	 eax, eax
$LN5@bytearray_@44:
  000db	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000e0	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000e5	74 13		 je	 SHORT $LN6@bytearray_@44
  000e7	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ec	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000f3	48 89 44 24 38	 mov	 QWORD PTR tv132[rsp], rax
  000f8	eb 0c		 jmp	 SHORT $LN7@bytearray_@44
$LN6@bytearray_@44:
  000fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  00101	48 89 44 24 38	 mov	 QWORD PTR tv132[rsp], rax
$LN7@bytearray_@44:
  00106	44 8b 4c 24 30	 mov	 r9d, DWORD PTR keepends$[rsp]
  0010b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00110	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00114	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv132[rsp]
  00119	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0011e	e8 00 00 00 00	 call	 stringlib_splitlines
$LN2@bytearray_@44:

; 2671 : }

  00123	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00127	c3		 ret	 0
bytearray_splitlines ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\split.h
pdata	SEGMENT
$pdata$stringlib_splitlines DD imagerel stringlib_splitlines
	DD	imagerel stringlib_splitlines+430
	DD	imagerel $unwind$stringlib_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_splitlines DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT stringlib_splitlines
_TEXT	SEGMENT
i$ = 32
list$ = 40
sub$ = 48
j$ = 56
eol$21897 = 64
str_obj$ = 96
str$ = 104
str_len$ = 112
keepends$ = 120
stringlib_splitlines PROC				; COMDAT

; 339  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 340  :     /* This does not use the preallocated list because splitlines is
; 341  :        usually run with hundreds of newlines.  The overhead of
; 342  :        switching between PyList_SET_ITEM and append causes about a
; 343  :        2-3% slowdown for that common case.  A smarter implementation
; 344  :        could move the if check out, so the SET_ITEMs are done first
; 345  :        and the appends only done when the prealloc buffer is full.
; 346  :        That's too much work for little gain.*/
; 347  : 
; 348  :     register Py_ssize_t i;
; 349  :     register Py_ssize_t j;
; 350  :     PyObject *list = PyList_New(0);

  00018	33 c9		 xor	 ecx, ecx
  0001a	e8 00 00 00 00	 call	 PyList_New
  0001f	48 89 44 24 28	 mov	 QWORD PTR list$[rsp], rax

; 351  :     PyObject *sub;
; 352  : 
; 353  :     if (list == NULL)

  00024	48 83 7c 24 28
	00		 cmp	 QWORD PTR list$[rsp], 0
  0002a	75 07		 jne	 SHORT $LN12@stringlib_@34

; 354  :         return NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 76 01 00 00	 jmp	 $LN13@stringlib_@34
$LN12@stringlib_@34:

; 355  : 
; 356  :     for (i = j = 0; i < str_len; ) {

  00033	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  00041	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN11@stringlib_@34:
  00046	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  0004b	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00050	0f 8d 40 01 00
	00		 jge	 $LN10@stringlib_@34
$LN9@stringlib_@34:

; 357  :         Py_ssize_t eol;
; 358  : 
; 359  :         /* Find a line and append it */
; 360  :         while (i < str_len && !STRINGLIB_ISLINEBREAK(str[i]))

  00056	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  0005b	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00060	7d 3f		 jge	 SHORT $LN8@stringlib_@34
  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00067	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  0006c	48 03 c8	 add	 rcx, rax
  0006f	48 8b c1	 mov	 rax, rcx
  00072	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00075	83 f8 0a	 cmp	 eax, 10
  00078	74 27		 je	 SHORT $LN8@stringlib_@34
  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0007f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0008d	83 f8 0d	 cmp	 eax, 13
  00090	74 0f		 je	 SHORT $LN8@stringlib_@34

; 361  :             i++;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00097	48 ff c0	 inc	 rax
  0009a	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  0009f	eb b5		 jmp	 SHORT $LN9@stringlib_@34
$LN8@stringlib_@34:

; 362  : 
; 363  :         /* Skip the line break reading CRLF as one line break */
; 364  :         eol = i;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000a6	48 89 44 24 40	 mov	 QWORD PTR eol$21897[rsp], rax

; 365  :         if (i < str_len) {

  000ab	48 8b 44 24 70	 mov	 rax, QWORD PTR str_len$[rsp]
  000b0	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000b5	7d 6e		 jge	 SHORT $LN7@stringlib_@34

; 366  :             if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')

  000b7	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000c1	48 03 c8	 add	 rcx, rax
  000c4	48 8b c1	 mov	 rax, rcx
  000c7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ca	83 f8 0d	 cmp	 eax, 13
  000cd	75 38		 jne	 SHORT $LN6@stringlib_@34
  000cf	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000d4	48 ff c0	 inc	 rax
  000d7	48 3b 44 24 70	 cmp	 rax, QWORD PTR str_len$[rsp]
  000dc	7d 29		 jge	 SHORT $LN6@stringlib_@34
  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  000e8	48 03 c8	 add	 rcx, rax
  000eb	48 8b c1	 mov	 rax, rcx
  000ee	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000f2	83 f8 0a	 cmp	 eax, 10
  000f5	75 10		 jne	 SHORT $LN6@stringlib_@34

; 367  :                 i += 2;

  000f7	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000fc	48 83 c0 02	 add	 rax, 2
  00100	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax

; 368  :             else

  00105	eb 0d		 jmp	 SHORT $LN5@stringlib_@34
$LN6@stringlib_@34:

; 369  :                 i++;

  00107	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0010c	48 ff c0	 inc	 rax
  0010f	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN5@stringlib_@34:

; 370  :             if (keepends)

  00114	83 7c 24 78 00	 cmp	 DWORD PTR keepends$[rsp], 0
  00119	74 0a		 je	 SHORT $LN4@stringlib_@34

; 371  :                 eol = i;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00120	48 89 44 24 40	 mov	 QWORD PTR eol$21897[rsp], rax
$LN4@stringlib_@34:
$LN7@stringlib_@34:

; 372  :         }
; 373  : #ifndef STRINGLIB_MUTABLE
; 374  :         if (j == 0 && eol == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {
; 375  :             /* No linebreak in str_obj, so just use it as list[0] */
; 376  :             if (PyList_Append(list, str_obj))
; 377  :                 goto onError;
; 378  :             break;
; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  00125	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  0012a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR eol$21897[rsp]
  0012f	48 2b c8	 sub	 rcx, rax
  00132	48 8b c1	 mov	 rax, rcx
  00135	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  0013a	48 8b 54 24 68	 mov	 rdx, QWORD PTR str$[rsp]
  0013f	48 03 d1	 add	 rdx, rcx
  00142	48 8b ca	 mov	 rcx, rdx
  00145	48 8b d0	 mov	 rdx, rax
  00148	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0014d	48 89 44 24 30	 mov	 QWORD PTR sub$[rsp], rax
  00152	48 83 7c 24 30
	00		 cmp	 QWORD PTR sub$[rsp], 0
  00158	75 02		 jne	 SHORT $LN3@stringlib_@34
  0015a	eb 41		 jmp	 SHORT $onError$21907
$LN3@stringlib_@34:
  0015c	48 8b 54 24 30	 mov	 rdx, QWORD PTR sub$[rsp]
  00161	48 8b 4c 24 28	 mov	 rcx, QWORD PTR list$[rsp]
  00166	e8 00 00 00 00	 call	 PyList_Append
  0016b	85 c0		 test	 eax, eax
  0016d	74 0e		 je	 SHORT $LN2@stringlib_@34
  0016f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sub$[rsp]
  00174	e8 00 00 00 00	 call	 _Py_DecRef
  00179	eb 22		 jmp	 SHORT $onError$21907
  0017b	eb 0a		 jmp	 SHORT $LN1@stringlib_@34
$LN2@stringlib_@34:
  0017d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sub$[rsp]
  00182	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@stringlib_@34:

; 382  :         j = i;

  00187	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0018c	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax

; 383  :     }

  00191	e9 b0 fe ff ff	 jmp	 $LN11@stringlib_@34
$LN10@stringlib_@34:

; 384  :     return list;

  00196	48 8b 44 24 28	 mov	 rax, QWORD PTR list$[rsp]
  0019b	eb 0c		 jmp	 SHORT $LN13@stringlib_@34
$onError$21907:

; 385  : 
; 386  :   onError:
; 387  :     Py_DECREF(list);

  0019d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR list$[rsp]
  001a2	e8 00 00 00 00	 call	 _Py_DecRef

; 388  :     return NULL;

  001a7	33 c0		 xor	 eax, eax
$LN13@stringlib_@34:

; 389  : }

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	c3		 ret	 0
stringlib_splitlines ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@ ; `string'
PUBLIC	??_C@_1DI@HHFILLCH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EO@FBOEPPKM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ ; `string'
PUBLIC	??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_09FKEMNDFN@U?3fromhex?$AA@		; `string'
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytearrayobject.c
pdata	SEGMENT
$pdata$bytearray_fromhex DD imagerel bytearray_fromhex
	DD	imagerel bytearray_fromhex+1508
	DD	imagerel $unwind$bytearray_fromhex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_fromhex DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@
CONST	SEGMENT
??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@ DB 'non-hexadec'
	DB	'imal number found in fromhex() arg at position %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@HHFILLCH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@HHFILLCH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'n', 00H, 'e', 00H
	DB	'w', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@FBOEPPKM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
CONST	SEGMENT
??_C@_1EO@FBOEPPKM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'h', 00H, 'e', 00H, 'x', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'h', 00H
	DB	'e', 00H, 'x', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'h', 00H, 'e', 00H, 'x', 00H, 'o', 00H
	DB	'b', 00H, 'j', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FKEMNDFN@U?3fromhex?$AA@
CONST	SEGMENT
??_C@_09FKEMNDFN@U?3fromhex?$AA@ DB 'U:fromhex', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_fromhex
_TEXT	SEGMENT
kind$ = 32
newbytes$ = 40
i$ = 48
hexobj$ = 56
hexlen$ = 64
bot$ = 72
byteslen$ = 80
buf$ = 88
top$ = 96
data$ = 104
j$ = 112
tv91 = 120
tv177 = 128
tv186 = 136
tv223 = 144
tv236 = 152
tv235 = 156
tv251 = 160
tv250 = 164
tv267 = 168
tv266 = 172
cls$ = 192
args$ = 200
bytearray_fromhex PROC					; COMDAT

; 2698 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2699 :     PyObject *newbytes, *hexobj;
; 2700 :     char *buf;
; 2701 :     Py_ssize_t hexlen, byteslen, i, j;
; 2702 :     int top, bot;
; 2703 :     void *data;
; 2704 :     unsigned int kind;
; 2705 : 
; 2706 :     if (!PyArg_ParseTuple(args, "U:fromhex", &hexobj))

  00011	4c 8d 44 24 38	 lea	 r8, QWORD PTR hexobj$[rsp]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09FKEMNDFN@U?3fromhex?$AA@
  0001d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN12@bytearray_@45

; 2707 :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 a7 05 00 00	 jmp	 $LN13@bytearray_@45
$LN12@bytearray_@45:

; 2708 :     assert(PyUnicode_Check(hexobj));

  00035	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  0003a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00044	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00049	85 c0		 test	 eax, eax
  0004b	75 1c		 jne	 SHORT $LN15@bytearray_@45
  0004d	41 b8 94 0a 00
	00		 mov	 r8d, 2708		; 00000a94H
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00067	33 c0		 xor	 eax, eax
$LN15@bytearray_@45:

; 2709 :     if (PyUnicode_READY(hexobj))

  00069	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  0006e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00072	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00078	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0007d	85 c0		 test	 eax, eax
  0007f	75 1c		 jne	 SHORT $LN16@bytearray_@45
  00081	41 b8 95 0a 00
	00		 mov	 r8d, 2709		; 00000a95H
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009b	33 c0		 xor	 eax, eax
$LN16@bytearray_@45:
  0009d	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  000a2	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000a5	c1 e8 07	 shr	 eax, 7
  000a8	83 e0 01	 and	 eax, 1
  000ab	85 c0		 test	 eax, eax
  000ad	74 0a		 je	 SHORT $LN17@bytearray_@45
  000af	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
  000b7	eb 0e		 jmp	 SHORT $LN18@bytearray_@45
$LN17@bytearray_@45:
  000b9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hexobj$[rsp]
  000be	e8 00 00 00 00	 call	 _PyUnicode_Ready
  000c3	89 44 24 78	 mov	 DWORD PTR tv91[rsp], eax
$LN18@bytearray_@45:
  000c7	83 7c 24 78 00	 cmp	 DWORD PTR tv91[rsp], 0
  000cc	74 07		 je	 SHORT $LN11@bytearray_@45

; 2710 :         return NULL;

  000ce	33 c0		 xor	 eax, eax
  000d0	e9 07 05 00 00	 jmp	 $LN13@bytearray_@45
$LN11@bytearray_@45:

; 2711 :     kind = PyUnicode_KIND(hexobj);

  000d5	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  000da	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000de	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000e4	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 1c		 jne	 SHORT $LN19@bytearray_@45
  000ed	41 b8 97 0a 00
	00		 mov	 r8d, 2711		; 00000a97H
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00107	33 c0		 xor	 eax, eax
$LN19@bytearray_@45:
  00109	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  0010e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00111	c1 e8 07	 shr	 eax, 7
  00114	83 e0 01	 and	 eax, 1
  00117	85 c0		 test	 eax, eax
  00119	75 1c		 jne	 SHORT $LN20@bytearray_@45
  0011b	41 b8 97 0a 00
	00		 mov	 r8d, 2711		; 00000a97H
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00135	33 c0		 xor	 eax, eax
$LN20@bytearray_@45:
  00137	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  0013c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0013f	c1 e8 02	 shr	 eax, 2
  00142	83 e0 07	 and	 eax, 7
  00145	89 44 24 20	 mov	 DWORD PTR kind$[rsp], eax

; 2712 :     data = PyUnicode_DATA(hexobj);

  00149	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  0014e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00152	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00158	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0015d	85 c0		 test	 eax, eax
  0015f	75 1c		 jne	 SHORT $LN21@bytearray_@45
  00161	41 b8 98 0a 00
	00		 mov	 r8d, 2712		; 00000a98H
  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0016e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0017b	33 c0		 xor	 eax, eax
$LN21@bytearray_@45:
  0017d	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  00182	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00185	c1 e8 05	 shr	 eax, 5
  00188	83 e0 01	 and	 eax, 1
  0018b	85 c0		 test	 eax, eax
  0018d	0f 84 ae 00 00
	00		 je	 $LN27@bytearray_@45
  00193	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  00198	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0019c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001a2	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  001a7	85 c0		 test	 eax, eax
  001a9	75 1c		 jne	 SHORT $LN22@bytearray_@45
  001ab	41 b8 98 0a 00
	00		 mov	 r8d, 2712		; 00000a98H
  001b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001c5	33 c0		 xor	 eax, eax
$LN22@bytearray_@45:
  001c7	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  001cc	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001cf	c1 e8 07	 shr	 eax, 7
  001d2	83 e0 01	 and	 eax, 1
  001d5	85 c0		 test	 eax, eax
  001d7	75 1c		 jne	 SHORT $LN23@bytearray_@45
  001d9	41 b8 98 0a 00
	00		 mov	 r8d, 2712		; 00000a98H
  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f3	33 c0		 xor	 eax, eax
$LN23@bytearray_@45:
  001f5	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  001fa	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001fd	c1 e8 06	 shr	 eax, 6
  00200	83 e0 01	 and	 eax, 1
  00203	85 c0		 test	 eax, eax
  00205	74 15		 je	 SHORT $LN24@bytearray_@45
  00207	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  0020c	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00212	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
  0021a	eb 13		 jmp	 SHORT $LN25@bytearray_@45
$LN24@bytearray_@45:
  0021c	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  00221	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00227	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
$LN25@bytearray_@45:
  0022f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv177[rsp]
  00237	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
  0023f	eb 3f		 jmp	 SHORT $LN28@bytearray_@45
$LN27@bytearray_@45:
  00241	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  00246	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  0024e	75 1c		 jne	 SHORT $LN26@bytearray_@45
  00250	41 b8 98 0a 00
	00		 mov	 r8d, 2712		; 00000a98H
  00256	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@FBOEPPKM@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  00264	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0026a	33 c0		 xor	 eax, eax
$LN26@bytearray_@45:
  0026c	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  00271	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00278	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
$LN28@bytearray_@45:
  00280	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv186[rsp]
  00288	48 89 44 24 68	 mov	 QWORD PTR data$[rsp], rax

; 2713 :     hexlen = PyUnicode_GET_LENGTH(hexobj);

  0028d	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  00292	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00296	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0029c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  002a1	85 c0		 test	 eax, eax
  002a3	75 1c		 jne	 SHORT $LN29@bytearray_@45
  002a5	41 b8 99 0a 00
	00		 mov	 r8d, 2713		; 00000a99H
  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@MDBDHECM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  002b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002bf	33 c0		 xor	 eax, eax
$LN29@bytearray_@45:
  002c1	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  002c6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002c9	c1 e8 07	 shr	 eax, 7
  002cc	83 e0 01	 and	 eax, 1
  002cf	85 c0		 test	 eax, eax
  002d1	75 1c		 jne	 SHORT $LN30@bytearray_@45
  002d3	41 b8 99 0a 00
	00		 mov	 r8d, 2713		; 00000a99H
  002d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FIFPAPPG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAh?$AAe?$AAx?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  002e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ed	33 c0		 xor	 eax, eax
$LN30@bytearray_@45:
  002ef	48 8b 44 24 38	 mov	 rax, QWORD PTR hexobj$[rsp]
  002f4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002f8	48 89 44 24 40	 mov	 QWORD PTR hexlen$[rsp], rax

; 2714 : 
; 2715 :     byteslen = hexlen/2; /* This overestimates if there are spaces */

  002fd	48 8b 44 24 40	 mov	 rax, QWORD PTR hexlen$[rsp]
  00302	48 99		 cdq
  00304	48 2b c2	 sub	 rax, rdx
  00307	48 d1 f8	 sar	 rax, 1
  0030a	48 89 44 24 50	 mov	 QWORD PTR byteslen$[rsp], rax

; 2716 :     newbytes = PyByteArray_FromStringAndSize(NULL, byteslen);

  0030f	48 8b 54 24 50	 mov	 rdx, QWORD PTR byteslen$[rsp]
  00314	33 c9		 xor	 ecx, ecx
  00316	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0031b	48 89 44 24 28	 mov	 QWORD PTR newbytes$[rsp], rax

; 2717 :     if (!newbytes)

  00320	48 83 7c 24 28
	00		 cmp	 QWORD PTR newbytes$[rsp], 0
  00326	75 07		 jne	 SHORT $LN10@bytearray_@45

; 2718 :         return NULL;

  00328	33 c0		 xor	 eax, eax
  0032a	e9 ad 02 00 00	 jmp	 $LN13@bytearray_@45
$LN10@bytearray_@45:

; 2719 :     buf = PyByteArray_AS_STRING(newbytes);

  0032f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00336	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newbytes$[rsp]
  0033b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0033f	74 35		 je	 SHORT $LN31@bytearray_@45
  00341	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00348	48 8b 44 24 28	 mov	 rax, QWORD PTR newbytes$[rsp]
  0034d	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00351	e8 00 00 00 00	 call	 PyType_IsSubtype
  00356	85 c0		 test	 eax, eax
  00358	75 1c		 jne	 SHORT $LN31@bytearray_@45
  0035a	41 b8 9f 0a 00
	00		 mov	 r8d, 2719		; 00000a9fH
  00360	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00367	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@HHFILLCH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  0036e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00374	33 c0		 xor	 eax, eax
$LN31@bytearray_@45:
  00376	48 8b 44 24 28	 mov	 rax, QWORD PTR newbytes$[rsp]
  0037b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00380	74 16		 je	 SHORT $LN32@bytearray_@45
  00382	48 8b 44 24 28	 mov	 rax, QWORD PTR newbytes$[rsp]
  00387	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0038e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv223[rsp], rax
  00396	eb 0f		 jmp	 SHORT $LN33@bytearray_@45
$LN32@bytearray_@45:
  00398	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0039f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv223[rsp], rax
$LN33@bytearray_@45:
  003a7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv223[rsp]
  003af	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp], rax

; 2720 :     for (i = j = 0; i < hexlen; i += 2) {

  003b4	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  003bd	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  003c2	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  003c7	eb 0e		 jmp	 SHORT $LN9@bytearray_@45
$LN8@bytearray_@45:
  003c9	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  003ce	48 83 c0 02	 add	 rax, 2
  003d2	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN9@bytearray_@45:
  003d7	48 8b 44 24 40	 mov	 rax, QWORD PTR hexlen$[rsp]
  003dc	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  003e1	0f 8d cd 01 00
	00		 jge	 $LN7@bytearray_@45
$LN6@bytearray_@45:

; 2721 :         /* skip over spaces in the input */
; 2722 :         while (PyUnicode_READ(kind, data, i) == ' ')

  003e7	83 7c 24 20 01	 cmp	 DWORD PTR kind$[rsp], 1
  003ec	75 1c		 jne	 SHORT $LN36@bytearray_@45
  003ee	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  003f3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR data$[rsp]
  003f8	48 03 c8	 add	 rcx, rax
  003fb	48 8b c1	 mov	 rax, rcx
  003fe	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00401	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv236[rsp], eax
  00408	eb 40		 jmp	 SHORT $LN37@bytearray_@45
$LN36@bytearray_@45:
  0040a	83 7c 24 20 02	 cmp	 DWORD PTR kind$[rsp], 2
  0040f	75 17		 jne	 SHORT $LN34@bytearray_@45
  00411	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  00416	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0041b	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0041f	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv235[rsp], eax
  00426	eb 14		 jmp	 SHORT $LN35@bytearray_@45
$LN34@bytearray_@45:
  00428	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  0042d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00432	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00435	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv235[rsp], eax
$LN35@bytearray_@45:
  0043c	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv235[rsp]
  00443	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv236[rsp], eax
$LN37@bytearray_@45:
  0044a	83 bc 24 98 00
	00 00 20	 cmp	 DWORD PTR tv236[rsp], 32 ; 00000020H
  00452	75 0f		 jne	 SHORT $LN5@bytearray_@45

; 2723 :             i++;

  00454	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00459	48 ff c0	 inc	 rax
  0045c	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  00461	eb 84		 jmp	 SHORT $LN6@bytearray_@45
$LN5@bytearray_@45:

; 2724 :         if (i >= hexlen)

  00463	48 8b 44 24 40	 mov	 rax, QWORD PTR hexlen$[rsp]
  00468	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0046d	7c 05		 jl	 SHORT $LN4@bytearray_@45

; 2725 :             break;

  0046f	e9 40 01 00 00	 jmp	 $LN7@bytearray_@45
$LN4@bytearray_@45:

; 2726 :         top = hex_digit_to_int(PyUnicode_READ(kind, data, i));

  00474	83 7c 24 20 01	 cmp	 DWORD PTR kind$[rsp], 1
  00479	75 1c		 jne	 SHORT $LN40@bytearray_@45
  0047b	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00480	48 8b 4c 24 68	 mov	 rcx, QWORD PTR data$[rsp]
  00485	48 03 c8	 add	 rcx, rax
  00488	48 8b c1	 mov	 rax, rcx
  0048b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0048e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv251[rsp], eax
  00495	eb 40		 jmp	 SHORT $LN41@bytearray_@45
$LN40@bytearray_@45:
  00497	83 7c 24 20 02	 cmp	 DWORD PTR kind$[rsp], 2
  0049c	75 17		 jne	 SHORT $LN38@bytearray_@45
  0049e	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  004a3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  004a8	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  004ac	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv250[rsp], eax
  004b3	eb 14		 jmp	 SHORT $LN39@bytearray_@45
$LN38@bytearray_@45:
  004b5	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  004ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  004bf	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  004c2	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv250[rsp], eax
$LN39@bytearray_@45:
  004c9	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv250[rsp]
  004d0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv251[rsp], eax
$LN41@bytearray_@45:
  004d7	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv251[rsp]
  004de	e8 00 00 00 00	 call	 hex_digit_to_int
  004e3	89 44 24 60	 mov	 DWORD PTR top$[rsp], eax

; 2727 :         bot = hex_digit_to_int(PyUnicode_READ(kind, data, i+1));

  004e7	83 7c 24 20 01	 cmp	 DWORD PTR kind$[rsp], 1
  004ec	75 1d		 jne	 SHORT $LN44@bytearray_@45
  004ee	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  004f3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR data$[rsp]
  004f8	48 03 c8	 add	 rcx, rax
  004fb	48 8b c1	 mov	 rax, rcx
  004fe	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00502	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv267[rsp], eax
  00509	eb 42		 jmp	 SHORT $LN45@bytearray_@45
$LN44@bytearray_@45:
  0050b	83 7c 24 20 02	 cmp	 DWORD PTR kind$[rsp], 2
  00510	75 18		 jne	 SHORT $LN42@bytearray_@45
  00512	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  00517	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0051c	0f b7 44 48 02	 movzx	 eax, WORD PTR [rax+rcx*2+2]
  00521	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv266[rsp], eax
  00528	eb 15		 jmp	 SHORT $LN43@bytearray_@45
$LN42@bytearray_@45:
  0052a	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  0052f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00534	8b 44 88 04	 mov	 eax, DWORD PTR [rax+rcx*4+4]
  00538	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv266[rsp], eax
$LN43@bytearray_@45:
  0053f	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv266[rsp]
  00546	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv267[rsp], eax
$LN45@bytearray_@45:
  0054d	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv267[rsp]
  00554	e8 00 00 00 00	 call	 hex_digit_to_int
  00559	89 44 24 48	 mov	 DWORD PTR bot$[rsp], eax

; 2728 :         if (top == -1 || bot == -1) {

  0055d	83 7c 24 60 ff	 cmp	 DWORD PTR top$[rsp], -1
  00562	74 07		 je	 SHORT $LN2@bytearray_@45
  00564	83 7c 24 48 ff	 cmp	 DWORD PTR bot$[rsp], -1
  00569	75 1a		 jne	 SHORT $LN3@bytearray_@45
$LN2@bytearray_@45:

; 2729 :             PyErr_Format(PyExc_ValueError,
; 2730 :                          "non-hexadecimal number found in "
; 2731 :                          "fromhex() arg at position %zd", i);

  0056b	4c 8b 44 24 30	 mov	 r8, QWORD PTR i$[rsp]
  00570	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@
  00577	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0057e	e8 00 00 00 00	 call	 PyErr_Format

; 2732 :             goto error;

  00583	eb 4b		 jmp	 SHORT $error$24245
$LN3@bytearray_@45:

; 2733 :         }
; 2734 :         buf[j++] = (top << 4) + bot;

  00585	8b 44 24 60	 mov	 eax, DWORD PTR top$[rsp]
  00589	c1 e0 04	 shl	 eax, 4
  0058c	03 44 24 48	 add	 eax, DWORD PTR bot$[rsp]
  00590	48 8b 4c 24 70	 mov	 rcx, QWORD PTR j$[rsp]
  00595	48 8b 54 24 58	 mov	 rdx, QWORD PTR buf$[rsp]
  0059a	48 03 d1	 add	 rdx, rcx
  0059d	48 8b ca	 mov	 rcx, rdx
  005a0	88 01		 mov	 BYTE PTR [rcx], al
  005a2	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  005a7	48 ff c0	 inc	 rax
  005aa	48 89 44 24 70	 mov	 QWORD PTR j$[rsp], rax

; 2735 :     }

  005af	e9 15 fe ff ff	 jmp	 $LN8@bytearray_@45
$LN7@bytearray_@45:

; 2736 :     if (PyByteArray_Resize(newbytes, j) < 0)

  005b4	48 8b 54 24 70	 mov	 rdx, QWORD PTR j$[rsp]
  005b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newbytes$[rsp]
  005be	e8 00 00 00 00	 call	 PyByteArray_Resize
  005c3	85 c0		 test	 eax, eax
  005c5	7d 02		 jge	 SHORT $LN1@bytearray_@45

; 2737 :         goto error;

  005c7	eb 07		 jmp	 SHORT $error$24245
$LN1@bytearray_@45:

; 2738 :     return newbytes;

  005c9	48 8b 44 24 28	 mov	 rax, QWORD PTR newbytes$[rsp]
  005ce	eb 0c		 jmp	 SHORT $LN13@bytearray_@45
$error$24245:

; 2739 : 
; 2740 :   error:
; 2741 :     Py_DECREF(newbytes);

  005d0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newbytes$[rsp]
  005d5	e8 00 00 00 00	 call	 _Py_DecRef

; 2742 :     return NULL;

  005da	33 c0		 xor	 eax, eax
$LN13@bytearray_@45:

; 2743 : }

  005dc	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  005e3	c3		 ret	 0
bytearray_fromhex ENDP
_TEXT	ENDS
EXTRN	_Py_ctype_tolower:BYTE
; Function compile flags: /Odtp
;	COMDAT hex_digit_to_int
_TEXT	SEGMENT
c$ = 8
hex_digit_to_int PROC					; COMDAT

; 2682 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 2683 :     if (c >= 128)

  00004	81 7c 24 08 80
	00 00 00	 cmp	 DWORD PTR c$[rsp], 128	; 00000080H
  0000c	72 07		 jb	 SHORT $LN5@hex_digit_

; 2684 :         return -1;

  0000e	b8 ff ff ff ff	 mov	 eax, -1
  00013	eb 7c		 jmp	 SHORT $LN6@hex_digit_
$LN5@hex_digit_:

; 2685 :     if (Py_ISDIGIT(c))

  00015	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00019	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0001e	0f b6 c0	 movzx	 eax, al
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00028	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0002b	83 e0 04	 and	 eax, 4
  0002e	85 c0		 test	 eax, eax
  00030	74 0b		 je	 SHORT $LN4@hex_digit_

; 2686 :         return c - '0';

  00032	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00036	83 e8 30	 sub	 eax, 48			; 00000030H
  00039	eb 56		 jmp	 SHORT $LN6@hex_digit_

; 2687 :     else {

  0003b	eb 4f		 jmp	 SHORT $LN3@hex_digit_
$LN4@hex_digit_:

; 2688 :         if (Py_ISUPPER(c))

  0003d	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00041	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00046	0f b6 c0	 movzx	 eax, al
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00050	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00053	83 e0 02	 and	 eax, 2
  00056	85 c0		 test	 eax, eax
  00058	74 1b		 je	 SHORT $LN2@hex_digit_

; 2689 :             c = Py_TOLOWER(c);

  0005a	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  0005e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00063	0f b6 c0	 movzx	 eax, al
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_tolower
  0006d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00071	89 44 24 08	 mov	 DWORD PTR c$[rsp], eax
$LN2@hex_digit_:

; 2690 :         if (c >= 'a' && c <= 'f')

  00075	83 7c 24 08 61	 cmp	 DWORD PTR c$[rsp], 97	; 00000061H
  0007a	72 10		 jb	 SHORT $LN1@hex_digit_
  0007c	83 7c 24 08 66	 cmp	 DWORD PTR c$[rsp], 102	; 00000066H
  00081	77 09		 ja	 SHORT $LN1@hex_digit_

; 2691 :             return c - 'a' + 10;

  00083	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00087	83 e8 57	 sub	 eax, 87			; 00000057H
  0008a	eb 05		 jmp	 SHORT $LN6@hex_digit_
$LN1@hex_digit_:
$LN3@hex_digit_:

; 2692 :     }
; 2693 :     return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
$LN6@hex_digit_:

; 2694 : }

  00091	f3 c3		 fatret	 0
hex_digit_to_int ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_reduce DD imagerel bytearray_reduce
	DD	imagerel bytearray_reduce+29
	DD	imagerel $unwind$bytearray_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_reduce DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_reduce
_TEXT	SEGMENT
self$ = 48
bytearray_reduce PROC					; COMDAT

; 2783 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2784 :     return _common_reduce(self, 2);

  00009	ba 02 00 00 00	 mov	 edx, 2
  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 _common_reduce

; 2785 : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
bytearray_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_06HCAGFEJD@?$CIO?$CI?$CJN?$CJ?$AA@	; `string'
PUBLIC	??_C@_08GFAELKBI@?$CIO?$CIy?$CD?$CJN?$CJ?$AA@	; `string'
PUBLIC	??_C@_08EEGIECMG@?$CIO?$CINs?$CJN?$CJ?$AA@	; `string'
PUBLIC	??_C@_07BJPINKOJ@latin?91?$AA@			; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyUnicode_DecodeLatin1:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_common_reduce DD imagerel _common_reduce
	DD	imagerel _common_reduce+316
	DD	imagerel $unwind$_common_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_common_reduce DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT ??_C@_06HCAGFEJD@?$CIO?$CI?$CJN?$CJ?$AA@
CONST	SEGMENT
??_C@_06HCAGFEJD@?$CIO?$CI?$CJN?$CJ?$AA@ DB '(O()N)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GFAELKBI@?$CIO?$CIy?$CD?$CJN?$CJ?$AA@
CONST	SEGMENT
??_C@_08GFAELKBI@?$CIO?$CIy?$CD?$CJN?$CJ?$AA@ DB '(O(y#)N)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EEGIECMG@?$CIO?$CINs?$CJN?$CJ?$AA@
CONST	SEGMENT
??_C@_08EEGIECMG@?$CIO?$CINs?$CJN?$CJ?$AA@ DB '(O(Ns)N)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJPINKOJ@latin?91?$AA@
CONST	SEGMENT
??_C@_07BJPINKOJ@latin?91?$AA@ DB 'latin-1', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _common_reduce
_TEXT	SEGMENT
dict$ = 48
latin1$24264 = 56
self$ = 80
proto$ = 88
_common_reduce PROC					; COMDAT

; 2748 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2749 :     PyObject *dict;
; 2750 :     _Py_IDENTIFIER(__dict__);
; 2751 : 
; 2752 :     dict = _PyObject_GetAttrId((PyObject *)self, &PyId___dict__);

  0000d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___dict__@?1??_common_reduce@@9@9
  00012	8b c0		 mov	 eax, eax
  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0001a	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00023	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00027	48 8b d0	 mov	 rdx, rax
  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0002f	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00034	48 89 44 24 30	 mov	 QWORD PTR dict$[rsp], rax

; 2753 :     if (dict == NULL) {

  00039	48 83 7c 24 30
	00		 cmp	 QWORD PTR dict$[rsp], 0
  0003f	75 1b		 jne	 SHORT $LN7@common_red

; 2754 :         PyErr_Clear();

  00041	e8 00 00 00 00	 call	 PyErr_Clear

; 2755 :         dict = Py_None;

  00046	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0004d	48 89 44 24 30	 mov	 QWORD PTR dict$[rsp], rax

; 2756 :         Py_INCREF(dict);

  00052	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dict$[rsp]
  00057	e8 00 00 00 00	 call	 _Py_IncRef
$LN7@common_red:

; 2757 :     }
; 2758 : 
; 2759 :     if (proto < 3) {

  0005c	83 7c 24 58 03	 cmp	 DWORD PTR proto$[rsp], 3
  00061	7d 73		 jge	 SHORT $LN6@common_red

; 2760 :         /* use str based reduction for backwards compatibility with Python 2.x */
; 2761 :         PyObject *latin1;
; 2762 :         if (self->ob_bytes)

  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00068	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00070	74 24		 je	 SHORT $LN5@common_red

; 2763 :             latin1 = PyUnicode_DecodeLatin1(self->ob_bytes, Py_SIZE(self), NULL);

  00072	45 33 c0	 xor	 r8d, r8d
  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0007a	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00083	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0008a	e8 00 00 00 00	 call	 PyUnicode_DecodeLatin1
  0008f	48 89 44 24 38	 mov	 QWORD PTR latin1$24264[rsp], rax

; 2764 :         else

  00094	eb 11		 jmp	 SHORT $LN4@common_red
$LN5@common_red:

; 2765 :             latin1 = PyUnicode_FromString("");

  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0009d	e8 00 00 00 00	 call	 PyUnicode_FromString
  000a2	48 89 44 24 38	 mov	 QWORD PTR latin1$24264[rsp], rax
$LN4@common_red:

; 2766 :         return Py_BuildValue("(O(Ns)N)", Py_TYPE(self), latin1, "latin-1", dict);

  000a7	48 8b 44 24 30	 mov	 rax, QWORD PTR dict$[rsp]
  000ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_07BJPINKOJ@latin?91?$AA@
  000b8	4c 8b 44 24 38	 mov	 r8, QWORD PTR latin1$24264[rsp]
  000bd	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c2	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08EEGIECMG@?$CIO?$CINs?$CJN?$CJ?$AA@
  000cd	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  000d2	eb 63		 jmp	 SHORT $LN8@common_red

; 2767 :     }
; 2768 :     else {

  000d4	eb 61		 jmp	 SHORT $LN3@common_red
$LN6@common_red:

; 2769 :         /* use more efficient byte based reduction */
; 2770 :         if (self->ob_bytes) {

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000db	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000e3	74 38		 je	 SHORT $LN2@common_red

; 2771 :             return Py_BuildValue("(O(y#)N)", Py_TYPE(self), self->ob_bytes, Py_SIZE(self), dict);

  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR dict$[rsp]
  000ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ef	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000f4	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  000f8	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000fd	4c 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [rax+128]
  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00109	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GFAELKBI@?$CIO?$CIy?$CD?$CJN?$CJ?$AA@
  00114	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00119	eb 1c		 jmp	 SHORT $LN8@common_red

; 2772 :         }
; 2773 :         else {

  0011b	eb 1a		 jmp	 SHORT $LN1@common_red
$LN2@common_red:

; 2774 :             return Py_BuildValue("(O()N)", Py_TYPE(self), dict);

  0011d	4c 8b 44 24 30	 mov	 r8, QWORD PTR dict$[rsp]
  00122	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00127	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  0012b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06HCAGFEJD@?$CIO?$CI?$CJN?$CJ?$AA@
  00132	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN1@common_red:
$LN3@common_red:
$LN8@common_red:

; 2775 :         }
; 2776 :     }
; 2777 : }

  00137	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013b	c3		 ret	 0
_common_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_reduce_ex DD imagerel bytearray_reduce_ex
	DD	imagerel bytearray_reduce_ex+71
	DD	imagerel $unwind$bytearray_reduce_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_reduce_ex DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@
CONST	SEGMENT
??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@ DB '|i:__reduce_ex__', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_reduce_ex
_TEXT	SEGMENT
proto$ = 32
self$ = 64
args$ = 72
bytearray_reduce_ex PROC				; COMDAT

; 2791 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2792 :     int proto = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR proto$[rsp], 0

; 2793 : 
; 2794 :     if (!PyArg_ParseTuple(args, "|i:__reduce_ex__", &proto))

  00016	4c 8d 44 24 20	 lea	 r8, QWORD PTR proto$[rsp]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@
  00022	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00027	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002c	85 c0		 test	 eax, eax
  0002e	75 04		 jne	 SHORT $LN1@bytearray_@46

; 2795 :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 0e		 jmp	 SHORT $LN2@bytearray_@46
$LN1@bytearray_@46:

; 2796 : 
; 2797 :     return _common_reduce(self, proto);

  00034	8b 54 24 20	 mov	 edx, DWORD PTR proto$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0003d	e8 00 00 00 00	 call	 _common_reduce
$LN2@bytearray_@46:

; 2798 : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
bytearray_reduce_ex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_sizeof DD imagerel bytearray_sizeof
	DD	imagerel bytearray_sizeof+44
	DD	imagerel $unwind$bytearray_sizeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_sizeof DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearray_sizeof
_TEXT	SEGMENT
res$ = 32
self$ = 64
bytearray_sizeof PROC					; COMDAT

; 2806 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2807 :     Py_ssize_t res;
; 2808 : 
; 2809 :     res = sizeof(PyByteArrayObject) + self->ob_alloc * sizeof(char);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00012	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00018	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 2810 :     return PyLong_FromSsize_t(res);

  0001d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  00022	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 2811 : }

  00027	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002b	c3		 ret	 0
bytearray_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ ; `string'
PUBLIC	??_C@_0BG@JMKAPJBH@bytearrayiter_dealloc?$AA@	; `string'
EXTRN	PyObject_GC_Del:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearrayiter_dealloc DD imagerel bytearrayiter_dealloc
	DD	imagerel bytearrayiter_dealloc+295
	DD	imagerel $unwind$bytearrayiter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_dealloc DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
CONST	SEGMENT
??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ DB 'g'
	DB	00H, '-', 00H, '>', 00H, 'g', 00H, 'c', 00H, '.', 00H, 'g', 00H
	DB	'c', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 's', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H, 'y', 00H
	DB	'G', 00H, 'C', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'S'
	DB	00H, '_', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H
	DB	'C', 00H, 'K', 00H, 'E', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JMKAPJBH@bytearrayiter_dealloc?$AA@
CONST	SEGMENT
??_C@_0BG@JMKAPJBH@bytearrayiter_dealloc?$AA@ DB 'bytearrayiter_dealloc', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearrayiter_dealloc
_TEXT	SEGMENT
g$24454 = 48
tv79 = 56
it$ = 80
bytearrayiter_dealloc PROC				; COMDAT

; 2976 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2977 :     _PyObject_GC_UNTRACK(it);

  00009	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00011	4c 8b 4c 24 50	 mov	 r9, QWORD PTR it$[rsp]
  00016	41 b8 a1 0b 00
	00		 mov	 r8d, 2977		; 00000ba1H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@JMKAPJBH@bytearrayiter_dealloc?$AA@
  0002a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0002f	85 c0		 test	 eax, eax
  00031	0f 85 c1 00 00
	00		 jne	 $LN8@bytearrayi
$LN7@bytearrayi:
  00037	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0003f	4c 8b 4c 24 50	 mov	 r9, QWORD PTR it$[rsp]
  00044	41 b8 a1 0b 00
	00		 mov	 r8d, 2977		; 00000ba1H
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@JMKAPJBH@bytearrayiter_dealloc?$AA@
  00058	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005d	85 c0		 test	 eax, eax
  0005f	74 0b		 je	 SHORT $LN11@bytearrayi
  00061	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
  0006a	eb 0e		 jmp	 SHORT $LN12@bytearrayi
$LN11@bytearrayi:
  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  00071	48 83 e8 18	 sub	 rax, 24
  00075	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
$LN12@bytearrayi:
  0007a	48 8b 44 24 38	 mov	 rax, QWORD PTR tv79[rsp]
  0007f	48 89 44 24 30	 mov	 QWORD PTR g$24454[rsp], rax
  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR g$24454[rsp]
  00089	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  0008e	75 1c		 jne	 SHORT $LN13@bytearrayi
  00090	41 b8 a1 0b 00
	00		 mov	 r8d, 2977		; 00000ba1H
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000aa	33 c0		 xor	 eax, eax
$LN13@bytearrayi:
  000ac	48 8b 44 24 30	 mov	 rax, QWORD PTR g$24454[rsp]
  000b1	48 c7 40 10 fe
	ff ff ff	 mov	 QWORD PTR [rax+16], -2
  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR g$24454[rsp]
  000be	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$24454[rsp]
  000c7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ca	48 89 08	 mov	 QWORD PTR [rax], rcx
  000cd	48 8b 44 24 30	 mov	 rax, QWORD PTR g$24454[rsp]
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$24454[rsp]
  000da	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000de	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR g$24454[rsp]
  000e7	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 85 3f ff ff
	ff		 jne	 $LN7@bytearrayi
$LN8@bytearrayi:
$LN4@bytearrayi:

; 2978 :     Py_XDECREF(it->it_seq);

  000f8	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  000fd	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00102	74 0e		 je	 SHORT $LN1@bytearrayi
  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR it$[rsp]
  00109	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  0010d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@bytearrayi:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 e0		 jne	 SHORT $LN4@bytearrayi

; 2979 :     PyObject_GC_Del(it);

  00118	48 8b 4c 24 50	 mov	 rcx, QWORD PTR it$[rsp]
  0011d	e8 00 00 00 00	 call	 PyObject_GC_Del

; 2980 : }

  00122	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00126	c3		 ret	 0
bytearrayiter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@FAHDKPCB@bytearrayiter_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearrayiter_traverse DD imagerel bytearrayiter_traverse
	DD	imagerel bytearrayiter_traverse+116
	DD	imagerel $unwind$bytearrayiter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BH@FAHDKPCB@bytearrayiter_traverse?$AA@
CONST	SEGMENT
??_C@_0BH@FAHDKPCB@bytearrayiter_traverse?$AA@ DB 'bytearrayiter_traverse'
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearrayiter_traverse
_TEXT	SEGMENT
vret$24479 = 32
it$ = 64
visit$ = 72
arg$ = 80
bytearrayiter_traverse PROC				; COMDAT

; 2984 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@bytearrayi@2:

; 2985 :     Py_VISIT(it->it_seq);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@bytearrayi@2
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 a9 0b 00
	00		 mov	 r8d, 2985		; 00000ba9H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@FAHDKPCB@bytearrayiter_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@bytearrayi@2:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 23		 je	 SHORT $LN2@bytearrayi@2
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$24479[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$24479[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@bytearrayi@2
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$24479[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@bytearrayi@2
$LN1@bytearrayi@2:
$LN2@bytearrayi@2:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@bytearrayi@2

; 2986 :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@bytearrayi@2:

; 2987 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
bytearrayiter_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CO@KJFDIPKD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearrayiter_next DD imagerel bytearrayiter_next
	DD	imagerel bytearrayiter_next+339
	DD	imagerel $unwind$bytearrayiter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_next DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1CO@KJFDIPKD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@KJFDIPKD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 's', 00H, 'e', 00H
	DB	'q', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'i'
	DB	00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearrayiter_next
_TEXT	SEGMENT
seq$ = 32
item$ = 40
it$ = 64
bytearrayiter_next PROC					; COMDAT

; 2991 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2992 :     PyByteArrayObject *seq;
; 2993 :     PyObject *item;
; 2994 : 
; 2995 :     assert(it != NULL);

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR it$[rsp], 0
  0000f	75 1c		 jne	 SHORT $LN6@bytearrayi@3
  00011	41 b8 b3 0b 00
	00		 mov	 r8d, 2995		; 00000bb3H
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@OOKCFHFC@?$AAi?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002b	33 c0		 xor	 eax, eax
$LN6@bytearrayi@3:

; 2996 :     seq = it->it_seq;

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00032	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00036	48 89 44 24 20	 mov	 QWORD PTR seq$[rsp], rax

; 2997 :     if (seq == NULL)

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00041	75 07		 jne	 SHORT $LN3@bytearrayi@3

; 2998 :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 04 01 00 00	 jmp	 $LN4@bytearrayi@3
$LN3@bytearrayi@3:

; 2999 :     assert(PyByteArray_Check(seq));

  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR seq$[rsp]
  00056	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0005a	74 35		 je	 SHORT $LN7@bytearrayi@3
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR seq$[rsp]
  00068	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0006c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00071	85 c0		 test	 eax, eax
  00073	75 1c		 jne	 SHORT $LN7@bytearrayi@3
  00075	41 b8 b7 0b 00
	00		 mov	 r8d, 2999		; 00000bb7H
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@KJFDIPKD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008f	33 c0		 xor	 eax, eax
$LN7@bytearrayi@3:

; 3000 : 
; 3001 :     if (it->it_index < PyByteArray_GET_SIZE(seq)) {

  00091	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00098	48 8b 4c 24 20	 mov	 rcx, QWORD PTR seq$[rsp]
  0009d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000a1	74 35		 je	 SHORT $LN8@bytearrayi@3
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR seq$[rsp]
  000af	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000b3	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b8	85 c0		 test	 eax, eax
  000ba	75 1c		 jne	 SHORT $LN8@bytearrayi@3
  000bc	41 b8 b9 0b 00
	00		 mov	 r8d, 3001		; 00000bb9H
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@KJFDIPKD@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d6	33 c0		 xor	 eax, eax
$LN8@bytearrayi@3:
  000d8	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  000dd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR seq$[rsp]
  000e2	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000e6	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  000ea	7d 49		 jge	 SHORT $LN2@bytearrayi@3

; 3002 :         item = PyLong_FromLong(
; 3003 :             (unsigned char)seq->ob_bytes[it->it_index]);

  000ec	48 8b 44 24 20	 mov	 rax, QWORD PTR seq$[rsp]
  000f1	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  000fd	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00101	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00105	8b c8		 mov	 ecx, eax
  00107	e8 00 00 00 00	 call	 PyLong_FromLong
  0010c	48 89 44 24 28	 mov	 QWORD PTR item$[rsp], rax

; 3004 :         if (item != NULL)

  00111	48 83 7c 24 28
	00		 cmp	 QWORD PTR item$[rsp], 0
  00117	74 15		 je	 SHORT $LN1@bytearrayi@3

; 3005 :             ++it->it_index;

  00119	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0011e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00122	48 ff c0	 inc	 rax
  00125	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  0012a	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN1@bytearrayi@3:

; 3006 :         return item;

  0012e	48 8b 44 24 28	 mov	 rax, QWORD PTR item$[rsp]
  00133	eb 19		 jmp	 SHORT $LN4@bytearrayi@3
$LN2@bytearrayi@3:

; 3007 :     }
; 3008 : 
; 3009 :     Py_DECREF(seq);

  00135	48 8b 4c 24 20	 mov	 rcx, QWORD PTR seq$[rsp]
  0013a	e8 00 00 00 00	 call	 _Py_DecRef

; 3010 :     it->it_seq = NULL;

  0013f	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00144	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 3011 :     return NULL;

  0014c	33 c0		 xor	 eax, eax
$LN4@bytearrayi@3:

; 3012 : }

  0014e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00152	c3		 ret	 0
bytearrayiter_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DM@LGJJFLLF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?9?$AA?$DO?$AAi?$AAt?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearrayiter_length_hint DD imagerel bytearrayiter_length_hint
	DD	imagerel bytearrayiter_length_hint+154
	DD	imagerel $unwind$bytearrayiter_length_hint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_length_hint DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1DM@LGJJFLLF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?9?$AA?$DO?$AAi?$AAt?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@LGJJFLLF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?9?$AA?$DO?$AAi?$AAt?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'i', 00H, 't', 00H
	DB	'-', 00H, '>', 00H, 'i', 00H, 't', 00H, '_', 00H, 's', 00H, 'e'
	DB	00H, 'q', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearrayiter_length_hint
_TEXT	SEGMENT
len$ = 32
it$ = 64
bytearrayiter_length_hint PROC				; COMDAT

; 3016 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3017 :     Py_ssize_t len = 0;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0

; 3018 :     if (it->it_seq)

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00017	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0001c	74 6d		 je	 SHORT $LN1@bytearrayi@4

; 3019 :         len = PyByteArray_GET_SIZE(it->it_seq) - it->it_index;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00023	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArray_Type
  0002e	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  00032	74 39		 je	 SHORT $LN4@bytearrayi@4
  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00039	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00044	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00048	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004d	85 c0		 test	 eax, eax
  0004f	75 1c		 jne	 SHORT $LN4@bytearrayi@4
  00051	41 b8 cb 0b 00
	00		 mov	 r8d, 3019		; 00000bcbH
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@NEEHIPOB@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAa?$AAr?$AAr?$AAa?$AAy?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@LGJJFLLF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?9?$AA?$DO?$AAi?$AAt?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?$AA@
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006b	33 c0		 xor	 eax, eax
$LN4@bytearrayi@4:
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00072	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  0007b	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0007f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00083	48 2b c1	 sub	 rax, rcx
  00086	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax
$LN1@bytearrayi@4:

; 3020 :     return PyLong_FromSsize_t(len);

  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  00090	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 3021 : }

  00095	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00099	c3		 ret	 0
bytearrayiter_length_hint ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@		; `string'
PUBLIC	??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@		; `string'
PUBLIC	??_C@_04BKLHDIKK@iter?$AA@			; `string'
EXTRN	PyUnicode_FromUnicode:PROC
EXTRN	_PyObject_GetBuiltin:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearrayiter_reduce DD imagerel bytearrayiter_reduce
	DD	imagerel bytearrayiter_reduce+133
	DD	imagerel $unwind$bytearrayiter_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_reduce DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@ DB 'N(N)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
CONST	SEGMENT
??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@ DB 'N(O)n', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLHDIKK@iter?$AA@
CONST	SEGMENT
??_C@_04BKLHDIKK@iter?$AA@ DB 'iter', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearrayiter_reduce
_TEXT	SEGMENT
u$24530 = 32
it$ = 64
bytearrayiter_reduce PROC				; COMDAT

; 3028 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3029 :     if (it->it_seq != NULL) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	74 31		 je	 SHORT $LN3@bytearrayi@5

; 3030 :         return Py_BuildValue("N(O)n", _PyObject_GetBuiltin("iter"),
; 3031 :                              it->it_seq, it->it_index);

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  0001c	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  00026	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  0002f	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  00033	48 8b d0	 mov	 rdx, rax
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
  0003d	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00042	eb 3c		 jmp	 SHORT $LN4@bytearrayi@5

; 3032 :     } else {

  00044	eb 3a		 jmp	 SHORT $LN2@bytearrayi@5
$LN3@bytearrayi@5:

; 3033 :         PyObject *u = PyUnicode_FromUnicode(NULL, 0);

  00046	33 d2		 xor	 edx, edx
  00048	33 c9		 xor	 ecx, ecx
  0004a	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0004f	48 89 44 24 20	 mov	 QWORD PTR u$24530[rsp], rax

; 3034 :         if (u == NULL)

  00054	48 83 7c 24 20
	00		 cmp	 QWORD PTR u$24530[rsp], 0
  0005a	75 04		 jne	 SHORT $LN1@bytearrayi@5

; 3035 :             return NULL;

  0005c	33 c0		 xor	 eax, eax
  0005e	eb 20		 jmp	 SHORT $LN4@bytearrayi@5
$LN1@bytearrayi@5:

; 3036 :         return Py_BuildValue("N(N)", _PyObject_GetBuiltin("iter"), u);

  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  00067	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  0006c	4c 8b 44 24 20	 mov	 r8, QWORD PTR u$24530[rsp]
  00071	48 8b d0	 mov	 rdx, rax
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
  0007b	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN2@bytearrayi@5:
$LN4@bytearrayi@5:

; 3037 :     }
; 3038 : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	c3		 ret	 0
bytearrayiter_reduce ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearrayiter_setstate DD imagerel bytearrayiter_setstate
	DD	imagerel bytearrayiter_setstate+106
	DD	imagerel $unwind$bytearrayiter_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_setstate DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bytearrayiter_setstate
_TEXT	SEGMENT
index$ = 32
it$ = 64
state$ = 72
bytearrayiter_setstate PROC				; COMDAT

; 3042 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3043 :     Py_ssize_t index = PyLong_AsSsize_t(state);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00013	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00018	48 89 44 24 20	 mov	 QWORD PTR index$[rsp], rax

; 3044 :     if (index == -1 && PyErr_Occurred())

  0001d	48 83 7c 24 20
	ff		 cmp	 QWORD PTR index$[rsp], -1
  00023	75 0e		 jne	 SHORT $LN2@bytearrayi@6
  00025	e8 00 00 00 00	 call	 PyErr_Occurred
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 04		 je	 SHORT $LN2@bytearrayi@6

; 3045 :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 32		 jmp	 SHORT $LN3@bytearrayi@6
$LN2@bytearrayi@6:

; 3046 :     if (index < 0)

  00033	48 83 7c 24 20
	00		 cmp	 QWORD PTR index$[rsp], 0
  00039	7d 09		 jge	 SHORT $LN1@bytearrayi@6

; 3047 :         index = 0;

  0003b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR index$[rsp], 0
$LN1@bytearrayi@6:

; 3048 :     it->it_index = index;

  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00049	48 8b 4c 24 20	 mov	 rcx, QWORD PTR index$[rsp]
  0004e	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3049 :     Py_RETURN_NONE;

  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00059	e8 00 00 00 00	 call	 _Py_IncRef
  0005e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@bytearrayi@6:

; 3050 : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
bytearrayiter_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_0P@EKKBABNM@bytearray_iter?$AA@		; `string'
EXTRN	_PyGC_generation0:QWORD
EXTRN	Py_FatalError:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_iter DD imagerel bytearray_iter
	DD	imagerel bytearray_iter+431
	DD	imagerel $unwind$bytearray_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_iter DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EKKBABNM@bytearray_iter?$AA@
CONST	SEGMENT
??_C@_0P@EKKBABNM@bytearray_iter?$AA@ DB 'bytearray_iter', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bytearray_iter
_TEXT	SEGMENT
it$ = 48
g$24593 = 56
tv79 = 64
tv131 = 72
seq$ = 96
bytearray_iter PROC					; COMDAT

; 3099 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3100 :     bytesiterobject *it;
; 3101 : 
; 3102 :     if (!PyByteArray_Check(seq)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00010	48 8b 4c 24 60	 mov	 rcx, QWORD PTR seq$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 31		 je	 SHORT $LN7@bytearray_@47
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00022	48 8b 44 24 60	 mov	 rax, QWORD PTR seq$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 18		 jne	 SHORT $LN7@bytearray_@47

; 3103 :         PyErr_BadInternalCall();

  00034	ba 1f 0c 00 00	 mov	 edx, 3103		; 00000c1fH
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  00040	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3104 :         return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	e9 5e 01 00 00	 jmp	 $LN8@bytearray_@47
$LN7@bytearray_@47:

; 3105 :     }
; 3106 :     it = PyObject_GC_New(bytesiterobject, &PyByteArrayIter_Type);

  0004c	e8 00 00 00 00	 call	 _Py_PXCTX
  00051	85 c0		 test	 eax, eax
  00053	74 13		 je	 SHORT $LN10@bytearray_@47
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArrayIter_Type
  0005c	e8 00 00 00 00	 call	 _PxObject_New
  00061	48 89 44 24 40	 mov	 QWORD PTR tv79[rsp], rax
  00066	eb 11		 jmp	 SHORT $LN11@bytearray_@47
$LN10@bytearray_@47:
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArrayIter_Type
  0006f	e8 00 00 00 00	 call	 _PyObject_GC_New
  00074	48 89 44 24 40	 mov	 QWORD PTR tv79[rsp], rax
$LN11@bytearray_@47:
  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR tv79[rsp]
  0007e	48 89 44 24 30	 mov	 QWORD PTR it$[rsp], rax

; 3107 :     if (it == NULL)

  00083	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$[rsp], 0
  00089	75 07		 jne	 SHORT $LN6@bytearray_@47

; 3108 :         return NULL;

  0008b	33 c0		 xor	 eax, eax
  0008d	e9 18 01 00 00	 jmp	 $LN8@bytearray_@47
$LN6@bytearray_@47:

; 3109 :     it->it_index = 0;

  00092	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  00097	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 3110 :     Py_INCREF(seq);

  0009f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR seq$[rsp]
  000a4	e8 00 00 00 00	 call	 _Py_IncRef

; 3111 :     it->it_seq = (PyByteArrayObject *)seq;

  000a9	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  000ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR seq$[rsp]
  000b3	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 3112 :     _PyObject_GC_TRACK(it);

  000b7	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000bf	4c 8b 4c 24 30	 mov	 r9, QWORD PTR it$[rsp]
  000c4	41 b8 28 0c 00
	00		 mov	 r8d, 3112		; 00000c28H
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@EKKBABNM@bytearray_iter?$AA@
  000d8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000dd	85 c0		 test	 eax, eax
  000df	0f 85 c0 00 00
	00		 jne	 $LN5@bytearray_@47
$LN4@bytearray_@47:
  000e5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ed	4c 8b 4c 24 30	 mov	 r9, QWORD PTR it$[rsp]
  000f2	41 b8 28 0c 00
	00		 mov	 r8d, 3112		; 00000c28H
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@EKKBABNM@bytearray_iter?$AA@
  00106	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010b	85 c0		 test	 eax, eax
  0010d	74 0b		 je	 SHORT $LN12@bytearray_@47
  0010f	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv131[rsp], 0
  00118	eb 0e		 jmp	 SHORT $LN13@bytearray_@47
$LN12@bytearray_@47:
  0011a	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  0011f	48 83 e8 18	 sub	 rax, 24
  00123	48 89 44 24 48	 mov	 QWORD PTR tv131[rsp], rax
$LN13@bytearray_@47:
  00128	48 8b 44 24 48	 mov	 rax, QWORD PTR tv131[rsp]
  0012d	48 89 44 24 38	 mov	 QWORD PTR g$24593[rsp], rax
  00132	48 8b 44 24 38	 mov	 rax, QWORD PTR g$24593[rsp]
  00137	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  0013c	74 0c		 je	 SHORT $LN1@bytearray_@47
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  00145	e8 00 00 00 00	 call	 Py_FatalError
$LN1@bytearray_@47:
  0014a	48 8b 44 24 38	 mov	 rax, QWORD PTR g$24593[rsp]
  0014f	48 c7 40 10 fd
	ff ff ff	 mov	 QWORD PTR [rax+16], -3
  00157	48 8b 44 24 38	 mov	 rax, QWORD PTR g$24593[rsp]
  0015c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  00163	48 89 08	 mov	 QWORD PTR [rax], rcx
  00166	48 8b 44 24 38	 mov	 rax, QWORD PTR g$24593[rsp]
  0016b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyGC_generation0
  00172	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00176	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0017a	48 8b 44 24 38	 mov	 rax, QWORD PTR g$24593[rsp]
  0017f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00183	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$24593[rsp]
  00188	48 89 08	 mov	 QWORD PTR [rax], rcx
  0018b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00192	48 8b 4c 24 38	 mov	 rcx, QWORD PTR g$24593[rsp]
  00197	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0019b	33 c0		 xor	 eax, eax
  0019d	85 c0		 test	 eax, eax
  0019f	0f 85 40 ff ff
	ff		 jne	 $LN4@bytearray_@47
$LN5@bytearray_@47:

; 3113 :     return (PyObject *)it;

  001a5	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
$LN8@bytearray_@47:

; 3114 : }

  001aa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ae	c3		 ret	 0
bytearray_iter ENDP
_TEXT	ENDS
END
